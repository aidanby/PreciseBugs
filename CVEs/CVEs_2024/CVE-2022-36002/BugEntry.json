{"buggy_code": ["/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/kernels/batch_kernels.h\"\n\n#include \"absl/strings/str_cat.h\"\n#include \"tensorflow/core/common_runtime/device_mgr.h\"\n#include \"tensorflow/core/framework/device.h\"\n#include \"tensorflow/core/framework/function.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/op_requires.h\"\n#include \"tensorflow/core/framework/resource_mgr.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/batching_util/adaptive_shared_batch_scheduler.h\"\n#include \"tensorflow/core/kernels/batching_util/batch_resource_base.h\"\n#include \"tensorflow/core/kernels/batching_util/bounded_executor.h\"\n#include \"tensorflow/core/kernels/batching_util/concat_split_util.h\"\n#include \"tensorflow/core/kernels/batching_util/periodic_function.h\"\n#include \"tensorflow/core/kernels/ops_util.h\"\n#include \"tensorflow/core/lib/monitoring/gauge.h\"\n#include \"tensorflow/core/lib/random/random.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/numbers.h\"\n#include \"tensorflow/core/platform/threadpool.h\"\n\nnamespace tensorflow {\nnamespace {\n// Op attributes.\nconstexpr char kEnableAdaptiveSchedulerAttr[] = \"_enable_adaptive_scheduler\";\nconstexpr char kMinInflightBatchesAttr[] = \"_min_inflight_batches\";\nconstexpr char kInitialInflightBatchesAttr[] = \"_initial_inflight_batches\";\nconstexpr char kMaxInflightBatchesAttr[] = \"_max_inflight_batches\";\nconstexpr char kBatchesToAverageOverAttr[] = \"_batches_to_average_over\";\n\n// Default thread count in the per-process batching thread pool.\nconstexpr int64_t kBatchThreadPoolSize = 128;\n}  // namespace\n\n// Per-model inflight batches parameters.\nconst int64_t kMinInflightBatches = 16;\nconst int64_t kInitialInflightBatches = 16;\nconst int64_t kBatchesToAverageOver = 10;\nconst int64_t kMaxInflightBatches = 64;\n\nauto* batch_op_split_usage = monitoring::Gauge<string, 1>::New(\n    \"/tensorflow/serving/batching/enable_large_batch_splitting\",\n    \"Tracks the usage of attribute `enable_large_batch_splitting` for \"\n    \"BatchFunction kernel in a saved model.\",\n    \"model_name\");\n\nvoid RecordBatchSplitUsage(\n    absl::optional<bool> maybe_enable_large_batch_splitting,\n    const string& model_name) {\n  if (maybe_enable_large_batch_splitting.has_value()) {\n    if (maybe_enable_large_batch_splitting.value()) {\n      batch_op_split_usage->GetCell(model_name)->Set(\"true\");\n    } else {\n      batch_op_split_usage->GetCell(model_name)->Set(\"false\");\n    }\n  } else {\n    batch_op_split_usage->GetCell(model_name)->Set(\"unset\");\n  }\n}\n\nvoid RecordBatchParamNumBatchThreads(int64_t num_batch_threads,\n                                     const string& model_name) {\n  static auto* cell = monitoring::Gauge<int64_t, 1>::New(\n      \"/tensorflow/serving/batching/num_batch_threads\",\n      \"Tracks the number of batch threads of a model.\", \"model_name\");\n  cell->GetCell(model_name)->Set(num_batch_threads);\n}\n\nconst string& GetModelName(OpKernelContext* ctx) {\n  static string* kModelNameUnset = new string(\"model_name_unset\");\n  if (!ctx->session_metadata()) return *kModelNameUnset;\n  if (ctx->session_metadata()->name().empty()) return *kModelNameUnset;\n  return ctx->session_metadata()->name();\n}\n\nusing ::tensorflow::concat_split_util::Concat;\nusing ::tensorflow::concat_split_util::Split;\n\nint32 NumBatchThreadsFromEnvironmentWithDefault(int default_num_batch_threads) {\n  int32_t num;\n  const char* val = std::getenv(\"TF_NUM_BATCH_THREADS\");\n\n  return (val && strings::safe_strto32(val, &num)) ? num\n                                                   : default_num_batch_threads;\n}\n\nstatic thread::ThreadPool* GetOrCreateBatchThreadsPool() {\n  static thread::ThreadPool* shared_thread_pool = [&]() -> thread::ThreadPool* {\n    serving::BoundedExecutor::Options options;\n\n    options.num_threads =\n        NumBatchThreadsFromEnvironmentWithDefault(kBatchThreadPoolSize);\n\n    options.thread_name = std::string(\"adaptive_batch_threads\");\n\n    auto status_or_executor = serving::BoundedExecutor::Create(options);\n    if (!status_or_executor.ok()) {\n      LOG(WARNING) << \"Failed to create a batch threads pool with error \"\n                   << status_or_executor.status();\n      return nullptr;\n    }\n    static serving::BoundedExecutor* executor =\n        status_or_executor.ValueOrDie().release();\n    return new thread::ThreadPool(executor);\n  }();\n  return shared_thread_pool;\n}\n\n// A class encapsulating the state and logic for batching tensors.\nclass BatchResource : public serving::BatchResourceBase {\n public:\n  static Status Create(int32_t num_batch_threads,\n                       int32_t max_execution_batch_size,\n                       int32_t batch_timeout_micros,\n                       int32_t max_enqueued_batches,\n                       const std::vector<int32>& allowed_batch_sizes,\n                       FunctionLibraryRuntime::Handle fhandle,\n                       FunctionLibraryRuntime* flib,\n                       bool enable_large_batch_splitting,\n                       std::unique_ptr<BatchResource>* resource) {\n    BatcherT::Options batcher_options;\n    batcher_options.num_batch_threads = num_batch_threads;\n    std::shared_ptr<BatcherT> batcher;\n    TF_RETURN_IF_ERROR(BatcherT::Create(batcher_options, &batcher));\n\n    resource->reset(new BatchResource(\n        fhandle, flib, std::move(batcher),\n        GetBatcherQueueOptions(num_batch_threads, max_execution_batch_size,\n                               batch_timeout_micros, max_enqueued_batches,\n                               allowed_batch_sizes,\n                               enable_large_batch_splitting),\n        allowed_batch_sizes));\n    return OkStatus();\n  }\n\n  static Status Create(\n      AdaptiveBatcherT::Options adaptive_shared_batch_scheduler_options,\n      int32_t max_batch_size, int32_t batch_timeout_micros,\n      int32_t max_enqueued_batches,\n      const std::vector<int32>& allowed_batch_sizes,\n      FunctionLibraryRuntime::Handle fhandle, FunctionLibraryRuntime* flib,\n      std::unique_ptr<BatchResource>* resource) {\n    std::shared_ptr<AdaptiveBatcherT> batcher;\n    TF_RETURN_IF_ERROR(AdaptiveBatcherT::Create(\n        adaptive_shared_batch_scheduler_options, &batcher));\n\n    resource->reset(new BatchResource(\n        fhandle, flib, std::move(batcher),\n        GetAdaptiveBatcherQueueOptions(\n            max_batch_size, batch_timeout_micros, max_enqueued_batches,\n            true /* enable large batch split */, allowed_batch_sizes),\n        allowed_batch_sizes));\n    return OkStatus();\n  }\n\n  string DebugString() const final { return \"BatchResource\"; }\n\n private:\n  BatchResource(FunctionLibraryRuntime::Handle fhandle,\n                FunctionLibraryRuntime* flib, std::shared_ptr<BatcherT> batcher,\n                const BatcherT::QueueOptions& batcher_queue_options,\n                std::vector<int32> allowed_batch_sizes)\n      : BatchResourceBase(\n            /*has_process_batch_function=*/fhandle != kInvalidHandle,\n            std::move(batcher), batcher_queue_options,\n            std::move(allowed_batch_sizes)),\n        fhandle_(fhandle),\n        flib_(flib) {}\n\n  BatchResource(FunctionLibraryRuntime::Handle fhandle,\n                FunctionLibraryRuntime* flib,\n                std::shared_ptr<AdaptiveBatcherT> batcher,\n                const AdaptiveBatcherT::QueueOptions& batcher_queue_options,\n                std::vector<int32> allowed_batch_sizes)\n      : BatchResourceBase(\n            /*has_process_batch_function=*/fhandle != kInvalidHandle,\n            std::move(batcher), batcher_queue_options,\n            std::move(allowed_batch_sizes)),\n        fhandle_(fhandle),\n        flib_(flib) {}\n\n  void ProcessFuncBatchImpl(\n      const BatchTask& last_task, absl::Span<const Tensor> inputs,\n      std::vector<Tensor>* combined_outputs,\n      std::function<void(const Status&)> done) const override {\n    auto* last_task_context = last_task.context;\n    FunctionLibraryRuntime::Options opts;\n    opts.step_container = last_task_context->step_container();\n    opts.cancellation_manager = last_task_context->cancellation_manager();\n    opts.collective_executor = last_task_context->collective_executor();\n    opts.stats_collector = last_task_context->stats_collector();\n    opts.runner = last_task_context->runner();\n    opts.run_all_kernels_inline = last_task_context->run_all_kernels_inline();\n    // We do not set 'opts.rendezvous', since if the function is run multiple\n    // times in parallel with the same rendezvous, a _Send node from one run\n    // might be matched with a _Recv node of a different run. Not setting the\n    // rendezvous causes a new rendezvous to be used for each run.\n    Notification done_notif;\n\n    flib_->Run(opts, fhandle_, inputs, combined_outputs,\n               [&](const Status& run_status) {\n                 done(run_status);\n                 done_notif.Notify();\n               });\n    // By waiting for the notification we are ensuring that this thread isn't\n    // used for processing other batches, which gives the batches time to\n    // coalesce upstream. So overall the number of batches going through the\n    // devices goes down, improving latency and throughput in most cases.\n    done_notif.WaitForNotification();\n  }\n\n  FunctionLibraryRuntime::Handle fhandle_;\n  FunctionLibraryRuntime* flib_;\n};\n\nBatchFunctionKernel::BatchFunctionKernel(OpKernelConstruction* c)\n    : AsyncOpKernel(c) {\n  OP_REQUIRES_OK(c, c->GetAttr(\"container\", &container_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"shared_name\", &shared_name_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"batching_queue\", &batcher_queue_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"num_batch_threads\", &num_batch_threads_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"max_batch_size\", &max_batch_size_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"batch_timeout_micros\", &batch_timeout_micros_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"max_enqueued_batches\", &max_enqueued_batches_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"allowed_batch_sizes\", &allowed_batch_sizes_));\n\n  OP_REQUIRES_OK(c, c->GetAttr(\"f\", &func_));\n  flib_ = c->function_library();\n\n  if (c->HasAttr(\"enable_large_batch_splitting\")) {\n    OP_REQUIRES_OK(c, c->GetAttr(\"enable_large_batch_splitting\",\n                                 &enable_large_batch_splitting_));\n    has_attribute_enable_large_batch_splitting_ = true;\n  } else {\n    enable_large_batch_splitting_ = false;\n    has_attribute_enable_large_batch_splitting_ = false;\n  }\n\n  // Helper function `SetAdaptiveBatchSchedulerOptions` calls\n  // `OP_REQUIRES_OK`, which exits the current function upon error.\n  // So validate status of `op-kernel-construction`.\n  SetAdaptiveBatchSchedulerOptions(c, num_batch_threads_);\n  if (!c->status().ok()) {\n    return;\n  }\n\n  if (enable_adaptive_batch_threads_) {\n    // One scheduler instance contains a couple of queue instances,\n    // `batcher_queue_` is the key to find queue for this batch-op in the\n    // graph.\n    // Use `shared_name_` and name() as prefix for `batcher_queue_`.\n    // Note name() is unique per session (from session metadata).\n    batcher_queue_ = name() + \"/\" + shared_name_ + batcher_queue_;\n  }\n\n  if (shared_name_.empty()) {\n    // If shared_name is not supplied, use name instead (prevent collisions by\n    // default).\n    shared_name_ = name();\n  }\n\n  OP_REQUIRES_OK(c, ValidateAllowedBatchSizes());\n}\n\nbool BatchFunctionKernel::IsExpensive() { return false; }\n\nvoid BatchFunctionKernel::ComputeAsync(OpKernelContext* c, DoneCallback done) {\n  RecordBatchSplitUsage(has_attribute_enable_large_batch_splitting_\n                            ? absl::make_optional(enable_large_batch_splitting_)\n                            : absl::nullopt,\n                        GetModelName(c));\n  // TODO(b/173255290): Add num_batch_threads_ parameter to TFRT batch kernel.\n  RecordBatchParamNumBatchThreads(num_batch_threads_, GetModelName(c));\n\n  std::function<Status(BatchResource**)> creator;\n\n  FunctionLibraryRuntime::Handle handle;\n  OP_REQUIRES_OK_ASYNC(c, GetOrCreateFunctionHandle(c, &handle), done);\n\n  if (adaptive_batch_scheduler_options_ != absl::nullopt) {\n    creator = [this, handle](BatchResource** r) {\n      serving::AdaptiveSharedBatchScheduler<\n          serving::BatchResourceBase::BatchTask>::Options\n          adaptive_shared_batch_scheduler_options;\n      adaptive_shared_batch_scheduler_options.thread_pool_name =\n          \"adaptive_batch_threads\";\n      adaptive_shared_batch_scheduler_options.num_batch_threads =\n          adaptive_batch_scheduler_options_->max_in_flight_batches_limit;\n      adaptive_shared_batch_scheduler_options.thread_pool =\n          GetOrCreateBatchThreadsPool();\n      // adaptive_shared_batch_scheduler_options.full_batch_scheduling_boost_micros\n      // is 0 (default value) intentionally, so tasks are scheduled in a FIFO\n      // way.\n      // Two rationales to use default value (zero) for\n      // `full_batch_scheduling_boost_micros`\n      // 1) In this way, tasks scheduling policy is FIFO. Compared with round\n      // robin (what shared batch scheduler does), FIFO ensures that model\n      // with low QPS (i.e., models enqueue fewer tasks in the shared queue)\n      // will be processed timely.\n      // 2) If set, `full_batch_scheduling_boost_micros` should be of order\n      // the batch processing latency (which varies on a model basis).\n      // If a non-zero value is not set properly, it harms tail latency.\n      adaptive_shared_batch_scheduler_options.min_in_flight_batches_limit =\n          adaptive_batch_scheduler_options_->min_in_flight_batches_limit;\n      adaptive_shared_batch_scheduler_options.initial_in_flight_batches_limit =\n          adaptive_batch_scheduler_options_->initial_in_flight_batches_limit;\n      adaptive_shared_batch_scheduler_options.batches_to_average_over =\n          adaptive_batch_scheduler_options_->batches_to_average_over;\n      adaptive_shared_batch_scheduler_options.fifo_scheduling = true;\n      std::unique_ptr<BatchResource> new_resource;\n      TF_RETURN_IF_ERROR(BatchResource::Create(\n          adaptive_shared_batch_scheduler_options, max_batch_size_,\n          batch_timeout_micros_, max_enqueued_batches_, allowed_batch_sizes_,\n          handle, flib_, &new_resource));\n      *r = new_resource.release();\n      return OkStatus();\n    };\n  } else {\n    creator = [this, handle](BatchResource** r) {\n      std::unique_ptr<BatchResource> new_resource;\n      TF_RETURN_IF_ERROR(BatchResource::Create(\n          num_batch_threads_, max_batch_size_, batch_timeout_micros_,\n          max_enqueued_batches_, allowed_batch_sizes_, handle, flib_,\n          enable_large_batch_splitting_, &new_resource));\n      *r = new_resource.release();\n      return OkStatus();\n    };\n  }\n\n  BatchResource* br;\n  OP_REQUIRES_OK_ASYNC(c,\n                       c->resource_manager()->LookupOrCreate(\n                           container_, shared_name_, &br, creator),\n                       done);\n  const Status status =\n      br->RegisterInput(random::New64(), c, batcher_queue_, done);\n  br->Unref();\n  OP_REQUIRES_OK_ASYNC(c, status, done);\n  // Assume br calls done, so nothing to do here.\n}\n\nStatus BatchFunctionKernel::InstantiateFunction(\n    OpKernelContext* c, FunctionLibraryRuntime::Handle* handle) const {\n  // TODO(b/173748062): Merge this instantiation logic with PartitionedCall.\n  if (!flib_) {\n    return errors::Internal(\"No function library\");\n  }\n\n  FunctionLibraryRuntime::InstantiateOptions opts;\n  opts.target = flib_->device() == nullptr ? \"\" : flib_->device()->name();\n  opts.is_multi_device_function = true;\n  const ConfigProto* config = flib_->config_proto();\n  if (config) {\n    opts.config_proto = *config;\n  }\n\n  Device* cpu_device;\n  TF_RETURN_IF_ERROR(flib_->device_mgr()->LookupDevice(\"CPU:0\", &cpu_device));\n\n  const FunctionDef* fdef =\n      flib_->GetFunctionLibraryDefinition()->Find(func_.name());\n  if (!fdef) {\n    return errors::NotFound(\"Failed to find definition for function \\\"\",\n                            func_.name(), \"\\\"\");\n  }\n  OpInputList in_tensors;\n  TF_RETURN_IF_ERROR(c->input_list(\"in_tensors\", &in_tensors));\n  for (int i = 0; i < in_tensors.size(); i++) {\n    if (in_tensors[i].dtype() == DT_RESOURCE) {\n      return errors::InvalidArgument(\n          \"BatchFunction cannot take resource inputs but input \", i,\n          \" is a resource.\");\n    } else {\n      // Currently, inputs are on CPU since they are concatenated on CPU\n      opts.input_devices.push_back(cpu_device->name());\n    }\n  }\n  OpInputList captured_tensors;\n  TF_RETURN_IF_ERROR(c->input_list(\"captured_tensors\", &captured_tensors));\n  for (const Tensor& t : captured_tensors) {\n    if (t.dtype() == DT_RESOURCE) {\n      const ResourceHandle& rhandle = t.flat<ResourceHandle>()(0);\n      opts.input_devices.push_back(rhandle.device());\n    } else {\n      opts.input_devices.push_back(cpu_device->name());\n    }\n  }\n  const OpDef& signature = fdef->signature();\n  for (int i = 0; i < signature.output_arg_size(); i++) {\n    // Currently, outputs must be on CPU since they are split on CPU.\n    opts.output_devices.push_back(cpu_device->name());\n  }\n  if (opts.input_devices.size() != signature.input_arg_size()) {\n    return errors::InvalidArgument(\n        \"Function takes \", signature.input_arg_size(), \" argument(s) but \",\n        opts.input_devices.size(), \" argument(s) were passed\");\n  }\n  return flib_->Instantiate(func_.name(), AttrSlice(&func_.attr()), opts,\n                            handle);\n}\n\nStatus BatchFunctionKernel::GetOrCreateFunctionHandle(\n    OpKernelContext* c, FunctionLibraryRuntime::Handle* handle) {\n  mutex_lock ml(mu_);\n  if (!fhandle_) {\n    TF_RETURN_IF_ERROR(InstantiateFunction(c, handle));\n    fhandle_ = *handle;\n  } else {\n    *handle = fhandle_.value();\n  }\n  return OkStatus();\n}\n\n// Validates 'allowed_batch_sizes_'. The entries must increase monotonically.\n// If large batch split is not enabled, the last one must equal\n// `max_batch_size_`. otherwise the last element must be smaller than or equal\n// to `max_batch_size_`.\nStatus BatchFunctionKernel::ValidateAllowedBatchSizes() const {\n  if (allowed_batch_sizes_.empty()) {\n    return OkStatus();\n  }\n  int32_t last_size = 0;\n  for (size_t i = 0; i < allowed_batch_sizes_.size(); ++i) {\n    const int32_t size = allowed_batch_sizes_.at(i);\n    if (i > 0 && size <= last_size) {\n      return errors::InvalidArgument(\n          \"allowed_batch_sizes entries must be monotonically increasing\");\n    }\n\n    if ((!enable_large_batch_splitting_) &&\n        (i == allowed_batch_sizes_.size() - 1) && (size != max_batch_size_)) {\n      return errors::InvalidArgument(\n          \"final entry in allowed_batch_sizes must equal max_batch_size when \"\n          \"enable_large_batch_splitting is False\");\n    }\n\n    last_size = size;\n  }\n  return OkStatus();\n}\n\n// Initialize vars by reading from op-kernel-construction.\n// Vars\n// - enable_adaptive_batch_threads_\n//   true if value of attribute `kEnableAdaptiveSchedulerAttr` is true, or\n//   if `num_batch_threads` is not positive.\n// - adaptive_batch_scheduler_options_\n//   Read from corresponding attributes as long as they are set.\nvoid BatchFunctionKernel::SetAdaptiveBatchSchedulerOptions(\n    OpKernelConstruction* c, int32_t num_batch_threads) {\n  if (c->HasAttr(kEnableAdaptiveSchedulerAttr)) {\n    OP_REQUIRES_OK(c, c->GetAttr(kEnableAdaptiveSchedulerAttr,\n                                 &enable_adaptive_batch_threads_));\n  }\n\n  if (num_batch_threads <= 0) {\n    enable_adaptive_batch_threads_ = true;\n  }\n\n  if (!enable_adaptive_batch_threads_) {\n    // adaptive_batch_scheduler_options_ is nullopt.\n    return;\n  }\n\n  // adaptive_batch_scheduler_options_ is not nullopt\n  AdaptiveBatchSchedulerOptions options;\n\n  if (c->HasAttr(kBatchesToAverageOverAttr)) {\n    OP_REQUIRES_OK(c, c->GetAttr(kBatchesToAverageOverAttr,\n                                 &options.batches_to_average_over));\n  }\n\n  if (c->HasAttr(kMinInflightBatchesAttr)) {\n    OP_REQUIRES_OK(c, c->GetAttr(kMinInflightBatchesAttr,\n                                 &options.min_in_flight_batches_limit));\n  }\n\n  if (c->HasAttr(kInitialInflightBatchesAttr)) {\n    OP_REQUIRES_OK(c, c->GetAttr(kInitialInflightBatchesAttr,\n                                 &options.initial_in_flight_batches_limit));\n  }\n\n  if (c->HasAttr(kMaxInflightBatchesAttr)) {\n    OP_REQUIRES_OK(c, c->GetAttr(kMaxInflightBatchesAttr,\n                                 &options.max_in_flight_batches_limit));\n  }\n\n  // At this point, the batch kernel is configured to use adaptive scheduling.\n  // To validate or return error at kernel construction time, invokes\n  // `GetOrCreateBatchThreadsPool` and validates returned `thread_pool` is\n  // valid.\n  // Note`GetOrCreateBatchThreadsPool` creates the thread pool once and\n  // re-uses the thread-pool instance afterwards.\n  thread::ThreadPool* thread_pool = GetOrCreateBatchThreadsPool();\n  OP_REQUIRES(\n      c, thread_pool != nullptr,\n      errors::FailedPrecondition(\"Failed to create batch threads pool\"));\n\n  adaptive_batch_scheduler_options_ = options;\n}\nREGISTER_KERNEL_BUILDER(Name(\"BatchFunction\").Device(DEVICE_CPU),\n                        BatchFunctionKernel);\n// Currently all inputs and outputs are on the host.\n// TODO(b/173748277): Accept inputs/outputs on the device.\nREGISTER_KERNEL_BUILDER(Name(\"BatchFunction\")\n                            .Device(DEVICE_GPU)\n                            .HostMemory(\"in_tensors\")\n                            .HostMemory(\"captured_tensors\")\n                            .HostMemory(\"out_tensors\"),\n                        BatchFunctionKernel);\nREGISTER_KERNEL_BUILDER(Name(\"BatchFunction\")\n                            .Device(DEVICE_DEFAULT)\n                            .HostMemory(\"in_tensors\")\n                            .HostMemory(\"captured_tensors\")\n                            .HostMemory(\"out_tensors\"),\n                        BatchFunctionKernel);\n\nclass BatchKernel : public AsyncOpKernel {\n public:\n  explicit BatchKernel(OpKernelConstruction* c) : AsyncOpKernel(c) {\n    OP_REQUIRES_OK(c, c->GetAttr(\"container\", &container_));\n    OP_REQUIRES_OK(c, c->GetAttr(\"shared_name\", &shared_name_));\n    // If shared_name is not supplied, use name instead (prevent collisions by\n    // default).\n    if (shared_name_.empty()) {\n      shared_name_ = name();\n    }\n    OP_REQUIRES_OK(c, c->GetAttr(\"batching_queue\", &batcher_queue_));\n    OP_REQUIRES_OK(c, c->GetAttr(\"num_batch_threads\", &num_batch_threads_));\n    OP_REQUIRES_OK(c, c->GetAttr(\"max_batch_size\", &max_batch_size_));\n    OP_REQUIRES_OK(c,\n                   c->GetAttr(\"batch_timeout_micros\", &batch_timeout_micros_));\n    OP_REQUIRES_OK(c,\n                   c->GetAttr(\"max_enqueued_batches\", &max_enqueued_batches_));\n    OP_REQUIRES_OK(c, c->GetAttr(\"allowed_batch_sizes\", &allowed_batch_sizes_));\n    OP_REQUIRES_OK(c, ValidateAllowedBatchSizes());\n  }\n\n  void ComputeAsync(OpKernelContext* c, DoneCallback done) final {\n    BatchResource* br;\n    std::function<Status(BatchResource**)> creator = [this](BatchResource** r) {\n      std::unique_ptr<BatchResource> new_resource;\n      TF_RETURN_IF_ERROR(BatchResource::Create(\n          num_batch_threads_, max_batch_size_, batch_timeout_micros_,\n          max_enqueued_batches_, allowed_batch_sizes_, kInvalidHandle,\n          /*flib=*/nullptr, false, &new_resource));\n      *r = new_resource.release();\n      return OkStatus();\n    };\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->resource_manager()->LookupOrCreate(\n                             container_, shared_name_, &br, creator),\n                         done);\n    const Status status =\n        br->RegisterInput(random::New64(), c, batcher_queue_, done);\n    br->Unref();\n    OP_REQUIRES_OK_ASYNC(c, status, done);\n    // Assume br calls done, so nothing to do here.\n  }\n\n  // Validates 'allowed_batch_sizes_'. The entries must increase\n  // monotonically, and the last one must equal 'max_batch_size_'.\n  Status ValidateAllowedBatchSizes() const {\n    if (allowed_batch_sizes_.empty()) {\n      return OkStatus();\n    }\n    int32_t last_size = 0;\n    for (size_t i = 0; i < allowed_batch_sizes_.size(); ++i) {\n      const int32_t size = allowed_batch_sizes_.at(i);\n      if (i > 0 && size <= last_size) {\n        return errors::InvalidArgument(\n            \"allowed_batch_sizes entries must be monotonically increasing\");\n      }\n      if (i == allowed_batch_sizes_.size() - 1 && size != max_batch_size_) {\n        return errors::InvalidArgument(\n            \"final entry in allowed_batch_sizes must equal max_batch_size\");\n      }\n      last_size = size;\n    }\n    return OkStatus();\n  }\n\n private:\n  string container_;\n  string shared_name_;\n  string batcher_queue_;\n  int32 num_batch_threads_;\n  int32 max_batch_size_;\n  int32 batch_timeout_micros_;\n  int32 max_enqueued_batches_;\n  std::vector<int32> allowed_batch_sizes_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"Batch\").Device(DEVICE_CPU), BatchKernel);\n\n// A class encapsulating the state and logic for unbatching tensors.\n//\n// UnbatchResource keeps two data structures indexed by batch-key: one which has\n// the continuations for all concurrent kernels which are waiting for tensors\n// and another which has tensors which are waiting for their corresponding\n// kernels to run. Whenever a kernel runs, we either grab its tensor if it's\n// waiting already, or we insert it in the queue and then look at its tensor to\n// see if it can be used to dispatch any stored continuations.\nclass UnbatchResource : public ResourceBase {\n public:\n  explicit UnbatchResource(int32_t timeout_micros)\n      : timeout_micros_(timeout_micros),\n        timeout_enforcer_(new serving::PeriodicFunction(\n            [this] { EnforceTimeout(); }, 1000 /* 1 ms */)) {}\n\n  ~UnbatchResource() override {\n    // Tear down 'timeout_enforcer_' first, since it accesses other state in\n    // this class.\n    timeout_enforcer_ = nullptr;\n  }\n\n  string DebugString() const final { return \"UnbatchResource\"; }\n\n  Status Compute(OpKernelContext* context, AsyncOpKernel::DoneCallback done) {\n    const Tensor& data_t = context->input(0);\n    const Tensor& batch_index_t = context->input(1);\n\n    if (batch_index_t.shape().dim_size(0) > data_t.shape().dim_size(0)) {\n      return errors::InvalidArgument(\n          \"Wrong shape for index tensor. Expected 0th dimension size to be no \"\n          \"greater than \",\n          data_t.shape().dim_size(0),\n          \"; Got: \", batch_index_t.shape().dim_size(0), \".\");\n    }\n    if (batch_index_t.shape().dim_size(1) != 3) {\n      return errors::InvalidArgument(\n          \"Wrong shape for index tensor. Expected 1st dimension size to be 3 ; \"\n          \"Got: \",\n          batch_index_t.shape().dim_size(1), \".\");\n    }\n\n    const int64_t batch_key = context->input(2).scalar<int64_t>()();\n    const bool nonempty_input = batch_index_t.dim_size(0) > 0;\n\n    // If we have a non-empty tensor, slice it up.\n    // (It is important to do this outside of the critical section below.)\n    // The following variables are populated iff 'nonempty_input==true'.\n    std::vector<int64_t> sizes;\n    std::vector<int64_t> batch_keys;\n    std::vector<Tensor> split_inputs;\n    if (nonempty_input) {\n      auto batch_indices =\n          batch_index_t.shaped<int64_t, 2>({batch_index_t.dim_size(0), 3});\n      for (int i = 0; i < batch_index_t.dim_size(0); ++i) {\n        sizes.push_back(batch_indices(i, 2) - batch_indices(i, 1));\n        batch_keys.push_back(batch_indices(i, 0));\n      }\n\n      TF_RETURN_IF_ERROR(Split(context, data_t, sizes, &split_inputs));\n    }\n\n    // Critical section.\n    std::vector<AsyncOpKernel::DoneCallback> done_callbacks_to_call;\n    Status status = [&]() -> Status {\n      mutex_lock ml(mu_);\n\n      // Check to see whether the tensor we want is already ready.\n      auto tensor_it = waiting_tensors_.find(batch_key);\n      if (tensor_it != waiting_tensors_.end()) {\n        context->set_output(0, tensor_it->second.tensor);\n        waiting_tensors_.erase(tensor_it);\n        done_callbacks_to_call.push_back(done);\n        return OkStatus();\n      }\n\n      const uint64 deadline_micros =\n          Env::Default()->NowMicros() + timeout_micros_;\n\n      // Add ourselves to the waitlist for tensors.\n      if (!waiting_callbacks_\n               .emplace(batch_key,\n                        WaitingCallback{deadline_micros, context, done})\n               .second) {\n        return errors::AlreadyExists(\n            \"Multiple session runs with the same batch key.\");\n      }\n\n      // If we have a non-empty tensor, finish the waitlisted runs,\n      // and store any remaining pieces.\n      if (nonempty_input) {\n        for (size_t i = 0; i < batch_keys.size(); ++i) {\n          auto runs_it = waiting_callbacks_.find(batch_keys[i]);\n          if (runs_it != waiting_callbacks_.end()) {\n            runs_it->second.context->set_output(0, split_inputs[i]);\n            done_callbacks_to_call.push_back(runs_it->second.done);\n            waiting_callbacks_.erase(runs_it);\n          } else {\n            // Note: the deadline here is in case we are arriving late and the\n            // kernel that should rendezvous with this tensor has already waited\n            // and timed out.\n            if (!waiting_tensors_\n                     .emplace(batch_keys[i],\n                              WaitingTensor{deadline_micros, split_inputs[i]})\n                     .second) {\n              return errors::AlreadyExists(\n                  \"Multiple tensors returned for same batch key.\");\n            }\n          }\n        }\n      }\n\n      return OkStatus();\n    }();\n\n    for (const AsyncOpKernel::DoneCallback& done_callback :\n         done_callbacks_to_call) {\n      done_callback();\n    }\n\n    return status;\n  }\n\n private:\n  // Evicts waiting tensors and callbacks that have exceeded their deadline.\n  void EnforceTimeout() {\n    const uint64 now = Env::Default()->NowMicros();\n    std::vector<WaitingCallback> evicted_callbacks;\n\n    {\n      mutex_lock ml(mu_);\n\n      for (auto it = waiting_tensors_.begin(); it != waiting_tensors_.end();) {\n        const WaitingTensor& waiting_tensor = it->second;\n        if (waiting_tensor.deadline_micros < now) {\n          it = waiting_tensors_.erase(it);\n        } else {\n          ++it;\n        }\n      }\n\n      for (auto it = waiting_callbacks_.begin();\n           it != waiting_callbacks_.end();) {\n        const WaitingCallback& waiting_callback = it->second;\n        if (waiting_callback.deadline_micros < now) {\n          evicted_callbacks.push_back(waiting_callback);\n          it = waiting_callbacks_.erase(it);\n        } else {\n          ++it;\n        }\n      }\n    }\n\n    for (const WaitingCallback& evicted_callback : evicted_callbacks) {\n      evicted_callback.context->CtxFailureWithWarning(errors::DeadlineExceeded(\n          \"Batched data did not arrive within timeout window.\"));\n      evicted_callback.done();\n    }\n  }\n\n  struct WaitingTensor {\n    uint64 deadline_micros;\n    Tensor tensor;\n  };\n\n  struct WaitingCallback {\n    uint64 deadline_micros;\n    OpKernelContext* context;\n    AsyncOpKernel::DoneCallback done;\n  };\n\n  const int32 timeout_micros_;\n\n  mutex mu_;\n\n  // Maps keyed by BatchKey of tensors waiting for callbacks and callbacks\n  // waiting for tensors.\n  std::unordered_map<int64_t, WaitingTensor> waiting_tensors_\n      TF_GUARDED_BY(mu_);\n  std::unordered_map<int64_t, WaitingCallback> waiting_callbacks_\n      TF_GUARDED_BY(mu_);\n\n  // A thread that evicts waiting tensors and callbacks that have exceeded their\n  // deadline.\n  std::unique_ptr<serving::PeriodicFunction> timeout_enforcer_;\n};\n\nclass UnbatchKernel : public AsyncOpKernel {\n public:\n  explicit UnbatchKernel(OpKernelConstruction* c) : AsyncOpKernel(c) {\n    OP_REQUIRES_OK(c, c->GetAttr(\"container\", &container_));\n    OP_REQUIRES_OK(c, c->GetAttr(\"shared_name\", &shared_name_));\n    // If shared_name is not supplied, use name instead (prevent collisions by\n    // default).\n    if (shared_name_.empty()) {\n      shared_name_ = name();\n    }\n    OP_REQUIRES_OK(c, c->GetAttr(\"timeout_micros\", &timeout_micros_));\n  }\n\n  void ComputeAsync(OpKernelContext* c, DoneCallback done) final {\n    UnbatchResource* ubr;\n    std::function<Status(UnbatchResource**)> creator =\n        [this](UnbatchResource** r) {\n          *r = new UnbatchResource(timeout_micros_);\n          return OkStatus();\n        };\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->resource_manager()->LookupOrCreate(\n                             container_, shared_name_, &ubr, creator),\n                         done);\n    auto status = ubr->Compute(c, done);\n    ubr->Unref();\n    OP_REQUIRES_OK_ASYNC(c, status, done);\n    // Assume ubr calls done, so nothing to do here.\n  }\n\n private:\n  string container_;\n  string shared_name_;\n  int32 timeout_micros_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"Unbatch\").Device(DEVICE_CPU), UnbatchKernel);\n\n// A class encapsulating the state and logic for batching tensors\n// deterministically for the gradient of unbatch.\nclass UnbatchGradResource : public ResourceBase {\n public:\n  UnbatchGradResource() {}\n\n  string DebugString() const final { return \"UnbatchGradResource\"; }\n\n  // Flushes the information for one batch, given its context and done\n  // callback. Clears all information about it from the available_tensors_.\n  Status OutputBatch(OpKernelContext* context,\n                     const AsyncOpKernel::DoneCallback& done)\n      TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    const Tensor& batch_index_t = context->input(1);\n    auto batch_index =\n        batch_index_t.shaped<int64_t, 2>({batch_index_t.dim_size(0), 3});\n    std::vector<Tensor> tensors;\n    for (int i = 0; i < batch_index_t.dim_size(0); ++i) {\n      auto available_it = available_tensors_.find(batch_index(i, 0));\n      if (available_it == available_tensors_.end()) {\n        return errors::Internal(\"bad bookkeeping of available tensors.\");\n      }\n      tensors.push_back(available_it->second);\n      available_tensors_.erase(available_it);\n    }\n\n    const DataType type = tensors[0].dtype();\n    Tensor concatenated_tensor;\n    switch (type) {\n#define CASE(type)                                                            \\\n  case DataTypeToEnum<type>::value:                                           \\\n    TF_RETURN_IF_ERROR(Concat<type>(context, tensors, &concatenated_tensor)); \\\n    context->set_output(0, concatenated_tensor);                              \\\n    break;\n      TF_CALL_ALL_TYPES(CASE);\n#undef CASE\n      default:\n        return errors::InvalidArgument(\"Unsupported data type: \", type);\n    }\n    done();\n    return OkStatus();\n  }\n\n  // Ingests data from one invocation of the op.\n  Status Compute(OpKernelContext* context,\n                 const AsyncOpKernel::DoneCallback& done) {\n    const Tensor& data_t = context->input(0);\n    const Tensor& batch_index_t = context->input(1);\n    const Tensor& grad_t = context->input(2);\n    const Tensor& batch_key_t = context->input(3);\n\n    mutex_lock ml(mu_);\n    if (batch_key_t.NumElements() != 1) {\n      return errors::InvalidArgument(\"Expected `id` to be scalar. Received \",\n                                     batch_key_t.DebugString());\n    }\n\n    const int64_t batch_key = context->input(3).scalar<int64_t>()();\n    // Mark our tensor as available.\n    if (!available_tensors_.emplace(batch_key, grad_t).second) {\n      return errors::InvalidArgument(\"Two runs with the same batch key.\");\n    }\n\n    // Check whether we have a valid input tensor and, if so, create its\n    // dispatch logic.\n    if (data_t.NumElements() > 0) {\n      if (batch_index_t.NumElements() == 0) {\n        return errors::InvalidArgument(\n            \"batch_index is empty while the tensor isn't.\");\n      }\n      std::unordered_set<int64_t> missing_tensors;\n      if (batch_index_t.NumElements() != batch_index_t.dim_size(0) * 3) {\n        return errors::InvalidArgument(\n            \"batch_index should contain \", batch_index_t.dim_size(0) * 3,\n            \" elements. Received \", batch_index_t.NumElements());\n      }\n      const auto batch_index =\n          batch_index_t.shaped<int64_t, 2>({batch_index_t.dim_size(0), 3});\n      for (int i = 0; i < batch_index_t.dim_size(0); ++i) {\n        const int64_t batch_key = batch_index(i, 0);\n        if (available_tensors_.find(batch_key) == available_tensors_.end()) {\n          missing_tensors.emplace(batch_key);\n        }\n      }\n      if (missing_tensors.empty()) {\n        return OutputBatch(context, done);\n      }\n      if (!available_batches_\n               .emplace(batch_key, Batch{missing_tensors, context, done})\n               .second) {\n        return errors::InvalidArgument(\n            \"Batch key with valid batch used twice.\");\n      }\n      for (const int64_t i : missing_tensors) {\n        if (!desired_tensor_to_batch_map_.emplace(i, batch_key).second) {\n          return errors::InvalidArgument(\n              \"Missing tensor wanted by more than one batch.\");\n        }\n      }\n    } else {\n      // If we don't have a valid input tensor we can output an empty tensor and\n      // call our done closure.\n      TensorShape output_shape(grad_t.shape());\n      output_shape.set_dim(0, 0);\n      Tensor* output = nullptr;\n      TF_RETURN_IF_ERROR(context->allocate_output(0, output_shape, &output));\n      done();\n    }\n\n    // Search to see whether our tensor is desired by any existing batch.\n    auto desire_it = desired_tensor_to_batch_map_.find(batch_key);\n    if (desire_it != desired_tensor_to_batch_map_.end()) {\n      // Mark our tensor as no longer missing.\n      auto batch_it = available_batches_.find(desire_it->second);\n      desired_tensor_to_batch_map_.erase(desire_it);\n      if (batch_it == available_batches_.end()) {\n        return errors::InvalidArgument(\"Batch no longer exists.\");\n      }\n      batch_it->second.missing_tensors.erase(batch_key);\n      // If all tensors are available we should concatenate them and dispatch\n      // the batch.\n      if (batch_it->second.missing_tensors.empty()) {\n        TF_RETURN_IF_ERROR(\n            OutputBatch(batch_it->second.context, batch_it->second.done));\n        available_batches_.erase(batch_it);\n      }\n    }\n    return OkStatus();\n  }\n\n private:\n  mutex mu_;\n\n  // Represents a still-incomplete batch of tensors. When all tensors become\n  // available they will be concatenated in the right order and sent through the\n  // context.\n  struct Batch {\n    // Batch keys for tensors which are still missing from this batch. When this\n    // is empty the Tensors can be concatenated and forwarded.\n    std::unordered_set<int64_t> missing_tensors;\n\n    // Context and callback for the session responsible for finishing this\n    // batch.\n    OpKernelContext* context;\n    AsyncOpKernel::DoneCallback done;\n  };\n\n  // Map from batch key of the session which will output the batched gradients\n  // to still-incomplete batches.\n  std::unordered_map<int64_t, Batch> available_batches_;\n\n  // Map from batch key to tensors which are waiting for their batches to be\n  // available.\n  std::unordered_map<int64_t, Tensor> available_tensors_;\n\n  // Map from batch key of a tensor which is not yet available to the batch key\n  // of the batch to which it belongs.\n  std::unordered_map<int64_t, int64_t> desired_tensor_to_batch_map_;\n};\n\nclass UnbatchGradKernel : public AsyncOpKernel {\n public:\n  explicit UnbatchGradKernel(OpKernelConstruction* c) : AsyncOpKernel(c) {\n    OP_REQUIRES_OK(c, c->GetAttr(\"container\", &container_));\n    OP_REQUIRES_OK(c, c->GetAttr(\"shared_name\", &shared_name_));\n    // If shared_name is not supplied, use name instead (prevent collisions by\n    // default).\n    if (shared_name_.empty()) {\n      shared_name_ = name();\n    }\n  }\n\n  void ComputeAsync(OpKernelContext* c, DoneCallback done) final {\n    UnbatchGradResource* ubr;\n    std::function<Status(UnbatchGradResource**)> creator =\n        [](UnbatchGradResource** r) {\n          *r = new UnbatchGradResource();\n          return OkStatus();\n        };\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->resource_manager()->LookupOrCreate(\n                             container_, shared_name_, &ubr, creator),\n                         done);\n    Status status = ubr->Compute(c, done);\n    ubr->Unref();\n    OP_REQUIRES_OK_ASYNC(c, status, done);\n    // Assume ubr calls done, so nothing to do here.\n  }\n\n private:\n  string container_;\n  string shared_name_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"UnbatchGrad\").Device(DEVICE_CPU),\n                        UnbatchGradKernel);\n\n}  // namespace tensorflow\n", "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for the currently experimental in-graph batch ops.\"\"\"\nimport threading\nimport time\nimport numpy as np\n\nfrom tensorflow.core.protobuf import config_pb2\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import function\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.framework.errors import InvalidArgumentError\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import batch_ops\nfrom tensorflow.python.ops import gen_batch_ops\nfrom tensorflow.python.ops import gen_functional_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import random_ops\nfrom tensorflow.python.ops import resource_variable_ops\nfrom tensorflow.python.ops import script_ops\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import test\n\n\ndef delayed_plus1(x):\n  \"\"\"Sleeps for 100ms then returns x+1.\"\"\"\n  time.sleep(0.1)\n  return x + 1\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass BatchOpsTest(test.TestCase):\n  \"\"\"Tests for batch_ops.{un,}batch.\"\"\"\n\n  # Test for only non eager mode as batching in eager context as a functionality\n  # is TBD.\n  def testBasicBatch(self):\n    \"\"\"Tests that a single batched tensor executes together and only once.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      batched, index, _ = batch_ops.batch(\n          [inp], num_batch_threads=1, max_batch_size=2,\n          batch_timeout_micros=36000000, grad_timeout_micros=0,\n          batching_queue=\"\")\n      thread_results = []\n\n      def worker():\n        thread_results.extend(\n            sess.run([batched, index], feed_dict={inp: [1]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([batched, index], feed_dict={inp: [2]})\n      worker_thread.join()\n\n      # At this point either the thread or the main did the batch and the other\n      # should have empty results.\n      if list(thread_results[0][0]):\n        batch_t = thread_results[0][0]\n        index_t = thread_results[1]\n        empty_b = main_results[0][0]\n        empty_m = main_results[1]\n      else:\n        batch_t = main_results[0][0]\n        index_t = main_results[1]\n        empty_b = thread_results[0][0]\n        empty_m = thread_results[1]\n\n      # Check that both the inputs made it out exactly once.\n      self.assertAllEqual(sorted(batch_t), (1, 2))\n      # Check that we get 2 rows in the index tensor.\n      self.assertEqual(len(index_t), 2)\n      # Check that the other ones are empty.\n      self.assertEqual(len(empty_b), 0)\n      self.assertEqual(len(empty_m), 0)\n\n  def testBatchWithPadding(self):\n    \"\"\"Test that batching with padding up to an allowed batch size works.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[2])\n      batched, index, _ = batch_ops.batch(\n          [inp], num_batch_threads=1, max_batch_size=10,\n          batch_timeout_micros=100000,  # 100ms\n          allowed_batch_sizes=[5, 10],\n          grad_timeout_micros=0, batching_queue=\"\")\n      thread_results = []\n\n      def worker():\n        thread_results.extend(\n            sess.run([batched, index], feed_dict={inp: [1, 3]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([batched, index], feed_dict={inp: [2, 4]})\n      worker_thread.join()\n\n      # At this point either the thread or the main did the batch and the other\n      # should have empty results.\n      if list(thread_results[0][0]):\n        batch_t = thread_results[0][0]\n      else:\n        batch_t = main_results[0][0]\n\n      # Check that the batch tensor incorporates the padding.\n      self.assertEqual(len(batch_t), 5)\n\n  def testMultipleBatch(self):\n    \"\"\"Tests that multiple batched tensors execute together.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp0 = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      inp1 = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      batched, _, _ = batch_ops.batch(\n          [inp0, inp1],\n          num_batch_threads=1,\n          max_batch_size=2,\n          batch_timeout_micros=36000000,\n          grad_timeout_micros=0,\n          batching_queue=\"\")\n      thread_results = []\n\n      def worker():\n        thread_results.extend(\n            sess.run([batched], feed_dict={inp0: [1],\n                                           inp1: [2]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([batched], feed_dict={inp0: [2], inp1: [3]})\n      worker_thread.join()\n\n      # At this point either the thread or the main did the batch and the other\n      # should have empty results.\n      if list(thread_results[0][0]):\n        batch_t = thread_results[0]\n        empty_t = main_results[0]\n      else:\n        batch_t = main_results[0]\n        empty_t = thread_results[0]\n\n      # Assert that the tensors were batched together.\n      self.assertAllEqual(sorted(batch_t[0]), [1, 2])\n      self.assertAllEqual(sorted(batch_t[1]), [2, 3])\n      self.assertAllEqual(empty_t[0], [])\n      self.assertAllEqual(empty_t[1], [])\n\n  def testIllegalBatchDifferentDim0Sizes(self):\n    \"\"\"Tests illegally feeding tensors with different dim0 sizes.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp0 = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      inp1 = array_ops.placeholder(dtype=dtypes.int32, shape=[2])\n      batched, index, _ = batch_ops.batch(\n          [inp0, inp1], num_batch_threads=1, max_batch_size=2,\n          batch_timeout_micros=0, grad_timeout_micros=0, batching_queue=\"\")\n      with self.assertRaises(Exception) as raised:\n        _ = sess.run([batched, index], feed_dict={inp0: [0], inp1: [1, 2]})\n      self.assertGreater(\n          raised.exception.message.find(\"must have equal 0th-dimension size\"),\n          0)\n\n  def testBasicUnbatch(self):\n    \"\"\"Tests that batch and unbatch work together.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      batched, index, id_t = batch_ops.batch(\n          [inp], num_batch_threads=1, max_batch_size=10,\n          batch_timeout_micros=100000,  # 100ms\n          allowed_batch_sizes=[3, 10],\n          grad_timeout_micros=0, batching_queue=\"\")\n      computation = batched[0] + 1\n      result = batch_ops.unbatch(computation, index, id_t,\n                                 timeout_micros=1000000, shared_name=\"unbatch\")\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [1]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [2]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [2])\n      self.assertEqual(main_results[0], [3])\n\n  def testBasicUnbatchDecorated(self):\n    \"\"\"Tests that the batch_function decorator works.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      # TODO(apassos): Removing this line causes test flakiness! Ideally should\n      # be investigated.\n      default_inp = array_ops.placeholder_with_default(2, shape=[])  # pylint: disable=unused-variable\n\n      @batch_ops.batch_function(1, 10, 100000)\n      def computation(in_t):\n        self.assertTrue(in_t.shape is not None)\n        return in_t + 1\n\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      result = computation(inp)\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [1]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [2]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [2])\n      self.assertEqual(main_results[0], [3])\n\n  def testBatchDecoratedWithCapturedInput(self):\n    \"\"\"Tests that the batch_function decorator works.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      captured_inp0 = array_ops.placeholder_with_default(2., shape=[])\n      captured_inp1 = resource_variable_ops.ResourceVariable(3.)\n      with ops.device(\"/cpu:0\"):\n        captured_inp2 = resource_variable_ops.ResourceVariable(4.)\n\n      @batch_ops.batch_function(1, 10, 100000)\n      def computation(in_t):\n        return in_t + captured_inp0 + captured_inp1 + captured_inp2\n\n      inp = array_ops.placeholder(dtype=dtypes.float32, shape=[1])\n      result = computation(inp)\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [1]}))\n\n      sess.run(variables.global_variables_initializer())\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [2]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [10])\n      self.assertEqual(main_results[0], [11])\n\n  @test_util.disable_xla(\"DeviceIndex returns sentinel value with XLA\")\n  def testBatchDecoratedGpu(self):\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n\n      @batch_ops.batch_function(1, 10, 100000)\n      def computation(in_t):\n        # index is 0 on CPU and 1 on GPU\n        index = gen_functional_ops.DeviceIndex(device_names=[\"CPU\", \"GPU\"])\n        return in_t + math_ops.cast(index, dtypes.float32)\n\n      inp = array_ops.placeholder(dtype=dtypes.float32, shape=[1])\n      result = computation(inp)\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [10.]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [20.]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [10 + test_util.is_gpu_available()])\n      self.assertEqual(main_results[0], [20 + test_util.is_gpu_available()])\n\n  def testParallelRunsWithCpuAndGpu(self):\n    # Run multiple instances of a batch function in parallel. This is a\n    # regression test: this used to fail because _Send nodes for one call would\n    # send the tensor to the _Recv node for a different call.\n    if context.executing_eagerly():\n      return\n    @batch_ops.batch_function(1, 2, 1)\n    def f(x):\n      with ops.device(\"/GPU:0\"):\n        x = x + 1.\n      with ops.device(\"/CPU:0\"):\n        return x + 1\n    num_calls = 10\n    placeholders = [array_ops.placeholder(dtypes.float32, shape=(1,))\n                    for _ in range(num_calls)]\n    results = []\n    for p in placeholders:\n      result = f(p)\n      results.append(result)\n    inputs = [[float(i)] for i in range(num_calls)]\n    expected = [[float(i + 2)] for i in range(num_calls)]\n    with self.session() as sess:\n      outputs = sess.run(results, feed_dict=dict(zip(placeholders, inputs)))\n      self.assertAllEqual(outputs, expected)\n\n  def testSoftPlacement(self):\n    if context.executing_eagerly():\n      return\n\n    @batch_ops.batch_function(1, 10, 100000)\n    def computation(in_t):\n      with ops.device(\"/GPU:0\"):\n        return in_t + 1.\n\n    inp = array_ops.placeholder(dtype=dtypes.float32, shape=[1])\n    result = computation(inp)\n\n    # With soft placement, the function will run even without a GPU\n    config = config_pb2.ConfigProto(allow_soft_placement=True)\n    with self.session(config=config) as sess:\n      sess.run([result], feed_dict={inp: [20.]})\n\n    # Without soft placement, the function fails without a GPU due to the\n    # addition explicitly being placed on the GPU\n    config.allow_soft_placement = False\n    with self.session(config=config) as sess:\n      if test_util.is_gpu_available():\n        sess.run([result], feed_dict={inp: [20.]})\n      else:\n        with self.assertRaisesRegex(InvalidArgumentError,\n                                    \"Cannot assign a device for operation\"):\n          sess.run([result], feed_dict={inp: [20.]})\n\n  def testBatchFunctionOp(self):\n    \"\"\"Tests that the batch_function op works.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n\n      @function.Defun(dtypes.int32)\n      def computation(in_t):\n        return in_t + 1\n\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      result = gen_batch_ops.batch_function(\n          [inp],\n          num_batch_threads=1,\n          max_batch_size=10,\n          batch_timeout_micros=100000,\n          Tout=[dtypes.int32],\n          f=computation,\n          captured_tensors=computation.captured_inputs)\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [1]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [2]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [2])\n      self.assertEqual(main_results[0], [3])\n\n  def testBatchFunctionOpWithCapturedInput(self):\n    \"\"\"Tests that batch_function op works with captured input.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      captured_inp0 = array_ops.placeholder_with_default(2, shape=[])\n      captured_inp1 = array_ops.placeholder_with_default(1, shape=[])\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n\n      @function.Defun(dtypes.int32)\n      def computation(inp):\n        return inp + captured_inp0 - captured_inp1\n\n      result = gen_batch_ops.batch_function(\n          num_batch_threads=1,\n          max_batch_size=10,\n          batch_timeout_micros=100000,  # 100ms\n          allowed_batch_sizes=[3, 10],\n          batching_queue=\"\",\n          f=computation,\n          in_tensors=[inp],\n          captured_tensors=computation.captured_inputs,\n          Tout=[o.type for o in computation.definition.signature.output_arg])\n\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [1]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [2]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [2])\n      self.assertEqual(main_results[0], [3])\n\n  def testBatchFunctionOpWithInputError(self):\n    \"\"\"Tests that batch_function op works with error in the inputs.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n\n      @function.Defun(dtypes.int32, dtypes.int32)\n      def computation(in0, in1):\n        return in0 + in1\n\n      result = gen_batch_ops.batch_function(\n          [inp],  # computation actually expects 2 inputs.\n          num_batch_threads=1,\n          max_batch_size=10,\n          batch_timeout_micros=100000,  # 100ms\n          batching_queue=\"\",\n          f=computation,\n          captured_tensors=computation.captured_inputs,\n          Tout=[o.type for o in computation.definition.signature.output_arg])\n\n      with self.assertRaisesRegex(\n          InvalidArgumentError,\n          r\"Function takes 2 argument\\(s\\) but 1 argument\\(s\\) were passed\"):\n        sess.run([result], feed_dict={inp: [2]})\n\n  def testBatchFunctionOpWithLargeBatchSplitted(self):\n    \"\"\"Tests that the batch_function op works with large batch splitted.\"\"\"\n    if context.executing_eagerly():\n      return\n\n    with self.cached_session() as sess:\n\n      @function.Defun(dtypes.int32)\n      def computation(in_t):\n        return in_t + 3\n\n      inp = array_ops.placeholder(dtype=dtypes.int32)\n      result = gen_batch_ops.batch_function(\n          [inp],\n          num_batch_threads=2,\n          # enable_large_batch_splitting is True, so it's valid as long as\n          # max('allowed_batch_sizes') <= 'max_batch_size'.\n          allowed_batch_sizes=[1, 2],\n          max_batch_size=5,\n          batch_timeout_micros=100000,  # 100ms\n          Tout=[dtypes.int32],\n          enable_large_batch_splitting=True,\n          f=computation,\n          captured_tensors=computation.captured_inputs)\n      thread1_results = []\n      thread2_results = []\n\n      # Input sizes of worker1 and main thread are larger than\n      # max(allowed_batch_sizes), while input size of worker2 is smaller.\n      def worker1():\n        thread1_results.extend(\n            sess.run([result], feed_dict={inp: [5, 6, 7, 8, 9]}))\n\n      worker_thread1 = threading.Thread(target=worker1)\n      worker_thread1.start()\n\n      def worker2():\n        thread2_results.extend(sess.run([result], feed_dict={inp: [10]}))\n\n      worker_thread2 = threading.Thread(target=worker2)\n      worker_thread2.start()\n\n      main_results = sess.run([result], feed_dict={inp: [2, 3, 4]})\n      worker_thread1.join()\n      worker_thread2.join()\n      self.assertTrue(\n          np.all(np.equal(thread2_results[0], np.array([13], dtype=np.int32))))\n      self.assertTrue(\n          np.all(\n              np.equal(thread1_results[0],\n                       np.array([8, 9, 10, 11, 12], dtype=np.int32))))\n      self.assertTrue(\n          np.all(\n              np.equal(main_results[0], np.array([5, 6, 7], dtype=np.int32))))\n\n  def testBasicUnbatchDecoratedWithReshape(self):\n    \"\"\"Tests that the batch_function decorator works.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n\n      @batch_ops.batch_function(1, 10, 100000)\n      def computation(in_t):\n        return array_ops.reshape(in_t, [-1]) + 1\n\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1, 1])\n      result = computation(inp)\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [[1]]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [[2]]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [2])\n      self.assertEqual(main_results[0], [3])\n\n  def testUnbatchTimeout(self):\n    \"\"\"Tests that the unbatch timeout works.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      batched, index, id_t = batch_ops.batch(\n          [inp], num_batch_threads=1, max_batch_size=2,\n          batch_timeout_micros=36000000, grad_timeout_micros=0,\n          batching_queue=\"\")\n      computation = batched[0] + 1\n      timeout_micros = 10\n      result = batch_ops.unbatch(computation, index, id_t, timeout_micros,\n                                 shared_name=\"shared_unbatch\")\n      # Set up a parallel pipeline that delays the computation, but uses the\n      # same unbatch resource object as the non-delayed pipeline.\n      computation_delayed = script_ops.py_func(delayed_plus1,\n                                               [batched[0]],\n                                               dtypes.int32)\n      result_delayed = batch_ops.unbatch(computation_delayed,\n                                         index,\n                                         id_t,\n                                         timeout_micros,\n                                         shared_name=\"shared_unbatch\")\n\n      thread_results = []\n      def worker():\n        # A first call using the non-delayed pipeline. The batcher will send an\n        # empty tensor along the non-delayed pipeline.\n        thread_results.extend(sess.run([result], feed_dict={inp: [1]}))\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      time.sleep(0.1)  # Ensure the thread's call starts first.\n      # A second call using the delayed pipeline.  The batcher will send the\n      # batched tensor along the delayed pipeline, thus delaying the arrival of\n      # the batched tensor at the unbatch op, relative to the empty tensor.\n      #\n      # TODO(olston, apassos): Avoid relying on the order in which the batch op\n      # emits the empty tensor versus the batched one.\n      _ = sess.run([result_delayed], feed_dict={inp: [2]})\n      worker_thread.join()\n      # The thread's call should hit the timeout, and thus get 0 results.\n      self.assertEqual(len(thread_results), 0)\n\n  def testUnbatchGradInvalidId(self):\n    with self.assertRaises(errors.InvalidArgumentError):\n      self.evaluate(\n          gen_batch_ops.unbatch_grad(\n              original_input=constant_op.constant([1]),\n              batch_index=constant_op.constant([\n                  [0, 0, 0],\n              ], dtype=dtypes.int64),\n              grad=constant_op.constant([\n                  1,\n              ]),\n              id=constant_op.constant([\n                  1,\n                  1,\n              ], dtype=dtypes.int64)))\n\n  def testUnbatchGradInvalidBatchId(self):\n    with self.assertRaises(errors.InvalidArgumentError):\n      self.evaluate(\n          gen_batch_ops.unbatch_grad(\n              original_input=constant_op.constant([1]),\n              batch_index=constant_op.constant([\n                  [0, 0],\n              ], dtype=dtypes.int64),\n              grad=constant_op.constant([\n                  1,\n              ]),\n              id=constant_op.constant([\n                  1,\n              ], dtype=dtypes.int64)))\n\n  def testUnbatchGradInvalidArgs(self):\n    original_input = random_ops.random_uniform(\n        shape=(3, 1), dtype=dtypes.float64, maxval=None)\n    batch_index = random_ops.random_uniform(\n        shape=(3, 1), dtype=dtypes.int64, maxval=65536)\n    grad = random_ops.random_uniform(\n        shape=(3, 1), dtype=dtypes.float64, maxval=None)\n    batch_id = random_ops.random_uniform(\n        shape=(3, 1), dtype=dtypes.int64, maxval=65536)\n    with self.assertRaises(errors.InvalidArgumentError):\n      self.evaluate(\n          gen_batch_ops.unbatch_grad(\n              original_input=original_input,\n              batch_index=batch_index,\n              grad=grad,\n              id=batch_id,\n              container=\"\",\n              shared_name=\"\",\n              name=\"\"))\n\nif __name__ == \"__main__\":\n  test.main()\n"], "fixing_code": ["/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/kernels/batch_kernels.h\"\n\n#include \"absl/strings/str_cat.h\"\n#include \"tensorflow/core/common_runtime/device_mgr.h\"\n#include \"tensorflow/core/framework/device.h\"\n#include \"tensorflow/core/framework/function.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/op_requires.h\"\n#include \"tensorflow/core/framework/resource_mgr.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/batching_util/adaptive_shared_batch_scheduler.h\"\n#include \"tensorflow/core/kernels/batching_util/batch_resource_base.h\"\n#include \"tensorflow/core/kernels/batching_util/bounded_executor.h\"\n#include \"tensorflow/core/kernels/batching_util/concat_split_util.h\"\n#include \"tensorflow/core/kernels/batching_util/periodic_function.h\"\n#include \"tensorflow/core/kernels/ops_util.h\"\n#include \"tensorflow/core/lib/monitoring/gauge.h\"\n#include \"tensorflow/core/lib/random/random.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/numbers.h\"\n#include \"tensorflow/core/platform/threadpool.h\"\n\nnamespace tensorflow {\nnamespace {\n// Op attributes.\nconstexpr char kEnableAdaptiveSchedulerAttr[] = \"_enable_adaptive_scheduler\";\nconstexpr char kMinInflightBatchesAttr[] = \"_min_inflight_batches\";\nconstexpr char kInitialInflightBatchesAttr[] = \"_initial_inflight_batches\";\nconstexpr char kMaxInflightBatchesAttr[] = \"_max_inflight_batches\";\nconstexpr char kBatchesToAverageOverAttr[] = \"_batches_to_average_over\";\n\n// Default thread count in the per-process batching thread pool.\nconstexpr int64_t kBatchThreadPoolSize = 128;\n}  // namespace\n\n// Per-model inflight batches parameters.\nconst int64_t kMinInflightBatches = 16;\nconst int64_t kInitialInflightBatches = 16;\nconst int64_t kBatchesToAverageOver = 10;\nconst int64_t kMaxInflightBatches = 64;\n\nauto* batch_op_split_usage = monitoring::Gauge<string, 1>::New(\n    \"/tensorflow/serving/batching/enable_large_batch_splitting\",\n    \"Tracks the usage of attribute `enable_large_batch_splitting` for \"\n    \"BatchFunction kernel in a saved model.\",\n    \"model_name\");\n\nvoid RecordBatchSplitUsage(\n    absl::optional<bool> maybe_enable_large_batch_splitting,\n    const string& model_name) {\n  if (maybe_enable_large_batch_splitting.has_value()) {\n    if (maybe_enable_large_batch_splitting.value()) {\n      batch_op_split_usage->GetCell(model_name)->Set(\"true\");\n    } else {\n      batch_op_split_usage->GetCell(model_name)->Set(\"false\");\n    }\n  } else {\n    batch_op_split_usage->GetCell(model_name)->Set(\"unset\");\n  }\n}\n\nvoid RecordBatchParamNumBatchThreads(int64_t num_batch_threads,\n                                     const string& model_name) {\n  static auto* cell = monitoring::Gauge<int64_t, 1>::New(\n      \"/tensorflow/serving/batching/num_batch_threads\",\n      \"Tracks the number of batch threads of a model.\", \"model_name\");\n  cell->GetCell(model_name)->Set(num_batch_threads);\n}\n\nconst string& GetModelName(OpKernelContext* ctx) {\n  static string* kModelNameUnset = new string(\"model_name_unset\");\n  if (!ctx->session_metadata()) return *kModelNameUnset;\n  if (ctx->session_metadata()->name().empty()) return *kModelNameUnset;\n  return ctx->session_metadata()->name();\n}\n\nusing ::tensorflow::concat_split_util::Concat;\nusing ::tensorflow::concat_split_util::Split;\n\nint32 NumBatchThreadsFromEnvironmentWithDefault(int default_num_batch_threads) {\n  int32_t num;\n  const char* val = std::getenv(\"TF_NUM_BATCH_THREADS\");\n\n  return (val && strings::safe_strto32(val, &num)) ? num\n                                                   : default_num_batch_threads;\n}\n\nstatic thread::ThreadPool* GetOrCreateBatchThreadsPool() {\n  static thread::ThreadPool* shared_thread_pool = [&]() -> thread::ThreadPool* {\n    serving::BoundedExecutor::Options options;\n\n    options.num_threads =\n        NumBatchThreadsFromEnvironmentWithDefault(kBatchThreadPoolSize);\n\n    options.thread_name = std::string(\"adaptive_batch_threads\");\n\n    auto status_or_executor = serving::BoundedExecutor::Create(options);\n    if (!status_or_executor.ok()) {\n      LOG(WARNING) << \"Failed to create a batch threads pool with error \"\n                   << status_or_executor.status();\n      return nullptr;\n    }\n    static serving::BoundedExecutor* executor =\n        status_or_executor.ValueOrDie().release();\n    return new thread::ThreadPool(executor);\n  }();\n  return shared_thread_pool;\n}\n\n// A class encapsulating the state and logic for batching tensors.\nclass BatchResource : public serving::BatchResourceBase {\n public:\n  static Status Create(int32_t num_batch_threads,\n                       int32_t max_execution_batch_size,\n                       int32_t batch_timeout_micros,\n                       int32_t max_enqueued_batches,\n                       const std::vector<int32>& allowed_batch_sizes,\n                       FunctionLibraryRuntime::Handle fhandle,\n                       FunctionLibraryRuntime* flib,\n                       bool enable_large_batch_splitting,\n                       std::unique_ptr<BatchResource>* resource) {\n    BatcherT::Options batcher_options;\n    batcher_options.num_batch_threads = num_batch_threads;\n    std::shared_ptr<BatcherT> batcher;\n    TF_RETURN_IF_ERROR(BatcherT::Create(batcher_options, &batcher));\n\n    resource->reset(new BatchResource(\n        fhandle, flib, std::move(batcher),\n        GetBatcherQueueOptions(num_batch_threads, max_execution_batch_size,\n                               batch_timeout_micros, max_enqueued_batches,\n                               allowed_batch_sizes,\n                               enable_large_batch_splitting),\n        allowed_batch_sizes));\n    return OkStatus();\n  }\n\n  static Status Create(\n      AdaptiveBatcherT::Options adaptive_shared_batch_scheduler_options,\n      int32_t max_batch_size, int32_t batch_timeout_micros,\n      int32_t max_enqueued_batches,\n      const std::vector<int32>& allowed_batch_sizes,\n      FunctionLibraryRuntime::Handle fhandle, FunctionLibraryRuntime* flib,\n      std::unique_ptr<BatchResource>* resource) {\n    std::shared_ptr<AdaptiveBatcherT> batcher;\n    TF_RETURN_IF_ERROR(AdaptiveBatcherT::Create(\n        adaptive_shared_batch_scheduler_options, &batcher));\n\n    resource->reset(new BatchResource(\n        fhandle, flib, std::move(batcher),\n        GetAdaptiveBatcherQueueOptions(\n            max_batch_size, batch_timeout_micros, max_enqueued_batches,\n            true /* enable large batch split */, allowed_batch_sizes),\n        allowed_batch_sizes));\n    return OkStatus();\n  }\n\n  string DebugString() const final { return \"BatchResource\"; }\n\n private:\n  BatchResource(FunctionLibraryRuntime::Handle fhandle,\n                FunctionLibraryRuntime* flib, std::shared_ptr<BatcherT> batcher,\n                const BatcherT::QueueOptions& batcher_queue_options,\n                std::vector<int32> allowed_batch_sizes)\n      : BatchResourceBase(\n            /*has_process_batch_function=*/fhandle != kInvalidHandle,\n            std::move(batcher), batcher_queue_options,\n            std::move(allowed_batch_sizes)),\n        fhandle_(fhandle),\n        flib_(flib) {}\n\n  BatchResource(FunctionLibraryRuntime::Handle fhandle,\n                FunctionLibraryRuntime* flib,\n                std::shared_ptr<AdaptiveBatcherT> batcher,\n                const AdaptiveBatcherT::QueueOptions& batcher_queue_options,\n                std::vector<int32> allowed_batch_sizes)\n      : BatchResourceBase(\n            /*has_process_batch_function=*/fhandle != kInvalidHandle,\n            std::move(batcher), batcher_queue_options,\n            std::move(allowed_batch_sizes)),\n        fhandle_(fhandle),\n        flib_(flib) {}\n\n  void ProcessFuncBatchImpl(\n      const BatchTask& last_task, absl::Span<const Tensor> inputs,\n      std::vector<Tensor>* combined_outputs,\n      std::function<void(const Status&)> done) const override {\n    auto* last_task_context = last_task.context;\n    FunctionLibraryRuntime::Options opts;\n    opts.step_container = last_task_context->step_container();\n    opts.cancellation_manager = last_task_context->cancellation_manager();\n    opts.collective_executor = last_task_context->collective_executor();\n    opts.stats_collector = last_task_context->stats_collector();\n    opts.runner = last_task_context->runner();\n    opts.run_all_kernels_inline = last_task_context->run_all_kernels_inline();\n    // We do not set 'opts.rendezvous', since if the function is run multiple\n    // times in parallel with the same rendezvous, a _Send node from one run\n    // might be matched with a _Recv node of a different run. Not setting the\n    // rendezvous causes a new rendezvous to be used for each run.\n    Notification done_notif;\n\n    flib_->Run(opts, fhandle_, inputs, combined_outputs,\n               [&](const Status& run_status) {\n                 done(run_status);\n                 done_notif.Notify();\n               });\n    // By waiting for the notification we are ensuring that this thread isn't\n    // used for processing other batches, which gives the batches time to\n    // coalesce upstream. So overall the number of batches going through the\n    // devices goes down, improving latency and throughput in most cases.\n    done_notif.WaitForNotification();\n  }\n\n  FunctionLibraryRuntime::Handle fhandle_;\n  FunctionLibraryRuntime* flib_;\n};\n\nBatchFunctionKernel::BatchFunctionKernel(OpKernelConstruction* c)\n    : AsyncOpKernel(c) {\n  OP_REQUIRES_OK(c, c->GetAttr(\"container\", &container_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"shared_name\", &shared_name_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"batching_queue\", &batcher_queue_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"num_batch_threads\", &num_batch_threads_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"max_batch_size\", &max_batch_size_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"batch_timeout_micros\", &batch_timeout_micros_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"max_enqueued_batches\", &max_enqueued_batches_));\n  OP_REQUIRES_OK(c, c->GetAttr(\"allowed_batch_sizes\", &allowed_batch_sizes_));\n\n  OP_REQUIRES_OK(c, c->GetAttr(\"f\", &func_));\n  flib_ = c->function_library();\n\n  if (c->HasAttr(\"enable_large_batch_splitting\")) {\n    OP_REQUIRES_OK(c, c->GetAttr(\"enable_large_batch_splitting\",\n                                 &enable_large_batch_splitting_));\n    has_attribute_enable_large_batch_splitting_ = true;\n  } else {\n    enable_large_batch_splitting_ = false;\n    has_attribute_enable_large_batch_splitting_ = false;\n  }\n\n  // Helper function `SetAdaptiveBatchSchedulerOptions` calls\n  // `OP_REQUIRES_OK`, which exits the current function upon error.\n  // So validate status of `op-kernel-construction`.\n  SetAdaptiveBatchSchedulerOptions(c, num_batch_threads_);\n  if (!c->status().ok()) {\n    return;\n  }\n\n  if (enable_adaptive_batch_threads_) {\n    // One scheduler instance contains a couple of queue instances,\n    // `batcher_queue_` is the key to find queue for this batch-op in the\n    // graph.\n    // Use `shared_name_` and name() as prefix for `batcher_queue_`.\n    // Note name() is unique per session (from session metadata).\n    batcher_queue_ = name() + \"/\" + shared_name_ + batcher_queue_;\n  }\n\n  if (shared_name_.empty()) {\n    // If shared_name is not supplied, use name instead (prevent collisions by\n    // default).\n    shared_name_ = name();\n  }\n\n  OP_REQUIRES_OK(c, ValidateAllowedBatchSizes());\n}\n\nbool BatchFunctionKernel::IsExpensive() { return false; }\n\nvoid BatchFunctionKernel::ComputeAsync(OpKernelContext* c, DoneCallback done) {\n  RecordBatchSplitUsage(has_attribute_enable_large_batch_splitting_\n                            ? absl::make_optional(enable_large_batch_splitting_)\n                            : absl::nullopt,\n                        GetModelName(c));\n  // TODO(b/173255290): Add num_batch_threads_ parameter to TFRT batch kernel.\n  RecordBatchParamNumBatchThreads(num_batch_threads_, GetModelName(c));\n\n  std::function<Status(BatchResource**)> creator;\n\n  FunctionLibraryRuntime::Handle handle;\n  OP_REQUIRES_OK_ASYNC(c, GetOrCreateFunctionHandle(c, &handle), done);\n\n  if (adaptive_batch_scheduler_options_ != absl::nullopt) {\n    creator = [this, handle](BatchResource** r) {\n      serving::AdaptiveSharedBatchScheduler<\n          serving::BatchResourceBase::BatchTask>::Options\n          adaptive_shared_batch_scheduler_options;\n      adaptive_shared_batch_scheduler_options.thread_pool_name =\n          \"adaptive_batch_threads\";\n      adaptive_shared_batch_scheduler_options.num_batch_threads =\n          adaptive_batch_scheduler_options_->max_in_flight_batches_limit;\n      adaptive_shared_batch_scheduler_options.thread_pool =\n          GetOrCreateBatchThreadsPool();\n      // adaptive_shared_batch_scheduler_options.full_batch_scheduling_boost_micros\n      // is 0 (default value) intentionally, so tasks are scheduled in a FIFO\n      // way.\n      // Two rationales to use default value (zero) for\n      // `full_batch_scheduling_boost_micros`\n      // 1) In this way, tasks scheduling policy is FIFO. Compared with round\n      // robin (what shared batch scheduler does), FIFO ensures that model\n      // with low QPS (i.e., models enqueue fewer tasks in the shared queue)\n      // will be processed timely.\n      // 2) If set, `full_batch_scheduling_boost_micros` should be of order\n      // the batch processing latency (which varies on a model basis).\n      // If a non-zero value is not set properly, it harms tail latency.\n      adaptive_shared_batch_scheduler_options.min_in_flight_batches_limit =\n          adaptive_batch_scheduler_options_->min_in_flight_batches_limit;\n      adaptive_shared_batch_scheduler_options.initial_in_flight_batches_limit =\n          adaptive_batch_scheduler_options_->initial_in_flight_batches_limit;\n      adaptive_shared_batch_scheduler_options.batches_to_average_over =\n          adaptive_batch_scheduler_options_->batches_to_average_over;\n      adaptive_shared_batch_scheduler_options.fifo_scheduling = true;\n      std::unique_ptr<BatchResource> new_resource;\n      TF_RETURN_IF_ERROR(BatchResource::Create(\n          adaptive_shared_batch_scheduler_options, max_batch_size_,\n          batch_timeout_micros_, max_enqueued_batches_, allowed_batch_sizes_,\n          handle, flib_, &new_resource));\n      *r = new_resource.release();\n      return OkStatus();\n    };\n  } else {\n    creator = [this, handle](BatchResource** r) {\n      std::unique_ptr<BatchResource> new_resource;\n      TF_RETURN_IF_ERROR(BatchResource::Create(\n          num_batch_threads_, max_batch_size_, batch_timeout_micros_,\n          max_enqueued_batches_, allowed_batch_sizes_, handle, flib_,\n          enable_large_batch_splitting_, &new_resource));\n      *r = new_resource.release();\n      return OkStatus();\n    };\n  }\n\n  BatchResource* br;\n  OP_REQUIRES_OK_ASYNC(c,\n                       c->resource_manager()->LookupOrCreate(\n                           container_, shared_name_, &br, creator),\n                       done);\n  const Status status =\n      br->RegisterInput(random::New64(), c, batcher_queue_, done);\n  br->Unref();\n  OP_REQUIRES_OK_ASYNC(c, status, done);\n  // Assume br calls done, so nothing to do here.\n}\n\nStatus BatchFunctionKernel::InstantiateFunction(\n    OpKernelContext* c, FunctionLibraryRuntime::Handle* handle) const {\n  // TODO(b/173748062): Merge this instantiation logic with PartitionedCall.\n  if (!flib_) {\n    return errors::Internal(\"No function library\");\n  }\n\n  FunctionLibraryRuntime::InstantiateOptions opts;\n  opts.target = flib_->device() == nullptr ? \"\" : flib_->device()->name();\n  opts.is_multi_device_function = true;\n  const ConfigProto* config = flib_->config_proto();\n  if (config) {\n    opts.config_proto = *config;\n  }\n\n  Device* cpu_device;\n  TF_RETURN_IF_ERROR(flib_->device_mgr()->LookupDevice(\"CPU:0\", &cpu_device));\n\n  const FunctionDef* fdef =\n      flib_->GetFunctionLibraryDefinition()->Find(func_.name());\n  if (!fdef) {\n    return errors::NotFound(\"Failed to find definition for function \\\"\",\n                            func_.name(), \"\\\"\");\n  }\n  OpInputList in_tensors;\n  TF_RETURN_IF_ERROR(c->input_list(\"in_tensors\", &in_tensors));\n  for (int i = 0; i < in_tensors.size(); i++) {\n    if (in_tensors[i].dtype() == DT_RESOURCE) {\n      return errors::InvalidArgument(\n          \"BatchFunction cannot take resource inputs but input \", i,\n          \" is a resource.\");\n    } else {\n      // Currently, inputs are on CPU since they are concatenated on CPU\n      opts.input_devices.push_back(cpu_device->name());\n    }\n  }\n  OpInputList captured_tensors;\n  TF_RETURN_IF_ERROR(c->input_list(\"captured_tensors\", &captured_tensors));\n  for (const Tensor& t : captured_tensors) {\n    if (t.dtype() == DT_RESOURCE) {\n      const ResourceHandle& rhandle = t.flat<ResourceHandle>()(0);\n      opts.input_devices.push_back(rhandle.device());\n    } else {\n      opts.input_devices.push_back(cpu_device->name());\n    }\n  }\n  const OpDef& signature = fdef->signature();\n  for (int i = 0; i < signature.output_arg_size(); i++) {\n    // Currently, outputs must be on CPU since they are split on CPU.\n    opts.output_devices.push_back(cpu_device->name());\n  }\n  if (opts.input_devices.size() != signature.input_arg_size()) {\n    return errors::InvalidArgument(\n        \"Function takes \", signature.input_arg_size(), \" argument(s) but \",\n        opts.input_devices.size(), \" argument(s) were passed\");\n  }\n  return flib_->Instantiate(func_.name(), AttrSlice(&func_.attr()), opts,\n                            handle);\n}\n\nStatus BatchFunctionKernel::GetOrCreateFunctionHandle(\n    OpKernelContext* c, FunctionLibraryRuntime::Handle* handle) {\n  mutex_lock ml(mu_);\n  if (!fhandle_) {\n    TF_RETURN_IF_ERROR(InstantiateFunction(c, handle));\n    fhandle_ = *handle;\n  } else {\n    *handle = fhandle_.value();\n  }\n  return OkStatus();\n}\n\n// Validates 'allowed_batch_sizes_'. The entries must increase monotonically.\n// If large batch split is not enabled, the last one must equal\n// `max_batch_size_`. otherwise the last element must be smaller than or equal\n// to `max_batch_size_`.\nStatus BatchFunctionKernel::ValidateAllowedBatchSizes() const {\n  if (allowed_batch_sizes_.empty()) {\n    return OkStatus();\n  }\n  int32_t last_size = 0;\n  for (size_t i = 0; i < allowed_batch_sizes_.size(); ++i) {\n    const int32_t size = allowed_batch_sizes_.at(i);\n    if (i > 0 && size <= last_size) {\n      return errors::InvalidArgument(\n          \"allowed_batch_sizes entries must be monotonically increasing\");\n    }\n\n    if ((!enable_large_batch_splitting_) &&\n        (i == allowed_batch_sizes_.size() - 1) && (size != max_batch_size_)) {\n      return errors::InvalidArgument(\n          \"final entry in allowed_batch_sizes must equal max_batch_size when \"\n          \"enable_large_batch_splitting is False\");\n    }\n\n    last_size = size;\n  }\n  return OkStatus();\n}\n\n// Initialize vars by reading from op-kernel-construction.\n// Vars\n// - enable_adaptive_batch_threads_\n//   true if value of attribute `kEnableAdaptiveSchedulerAttr` is true, or\n//   if `num_batch_threads` is not positive.\n// - adaptive_batch_scheduler_options_\n//   Read from corresponding attributes as long as they are set.\nvoid BatchFunctionKernel::SetAdaptiveBatchSchedulerOptions(\n    OpKernelConstruction* c, int32_t num_batch_threads) {\n  if (c->HasAttr(kEnableAdaptiveSchedulerAttr)) {\n    OP_REQUIRES_OK(c, c->GetAttr(kEnableAdaptiveSchedulerAttr,\n                                 &enable_adaptive_batch_threads_));\n  }\n\n  if (num_batch_threads <= 0) {\n    enable_adaptive_batch_threads_ = true;\n  }\n\n  if (!enable_adaptive_batch_threads_) {\n    // adaptive_batch_scheduler_options_ is nullopt.\n    return;\n  }\n\n  // adaptive_batch_scheduler_options_ is not nullopt\n  AdaptiveBatchSchedulerOptions options;\n\n  if (c->HasAttr(kBatchesToAverageOverAttr)) {\n    OP_REQUIRES_OK(c, c->GetAttr(kBatchesToAverageOverAttr,\n                                 &options.batches_to_average_over));\n  }\n\n  if (c->HasAttr(kMinInflightBatchesAttr)) {\n    OP_REQUIRES_OK(c, c->GetAttr(kMinInflightBatchesAttr,\n                                 &options.min_in_flight_batches_limit));\n  }\n\n  if (c->HasAttr(kInitialInflightBatchesAttr)) {\n    OP_REQUIRES_OK(c, c->GetAttr(kInitialInflightBatchesAttr,\n                                 &options.initial_in_flight_batches_limit));\n  }\n\n  if (c->HasAttr(kMaxInflightBatchesAttr)) {\n    OP_REQUIRES_OK(c, c->GetAttr(kMaxInflightBatchesAttr,\n                                 &options.max_in_flight_batches_limit));\n  }\n\n  // At this point, the batch kernel is configured to use adaptive scheduling.\n  // To validate or return error at kernel construction time, invokes\n  // `GetOrCreateBatchThreadsPool` and validates returned `thread_pool` is\n  // valid.\n  // Note`GetOrCreateBatchThreadsPool` creates the thread pool once and\n  // re-uses the thread-pool instance afterwards.\n  thread::ThreadPool* thread_pool = GetOrCreateBatchThreadsPool();\n  OP_REQUIRES(\n      c, thread_pool != nullptr,\n      errors::FailedPrecondition(\"Failed to create batch threads pool\"));\n\n  adaptive_batch_scheduler_options_ = options;\n}\nREGISTER_KERNEL_BUILDER(Name(\"BatchFunction\").Device(DEVICE_CPU),\n                        BatchFunctionKernel);\n// Currently all inputs and outputs are on the host.\n// TODO(b/173748277): Accept inputs/outputs on the device.\nREGISTER_KERNEL_BUILDER(Name(\"BatchFunction\")\n                            .Device(DEVICE_GPU)\n                            .HostMemory(\"in_tensors\")\n                            .HostMemory(\"captured_tensors\")\n                            .HostMemory(\"out_tensors\"),\n                        BatchFunctionKernel);\nREGISTER_KERNEL_BUILDER(Name(\"BatchFunction\")\n                            .Device(DEVICE_DEFAULT)\n                            .HostMemory(\"in_tensors\")\n                            .HostMemory(\"captured_tensors\")\n                            .HostMemory(\"out_tensors\"),\n                        BatchFunctionKernel);\n\nclass BatchKernel : public AsyncOpKernel {\n public:\n  explicit BatchKernel(OpKernelConstruction* c) : AsyncOpKernel(c) {\n    OP_REQUIRES_OK(c, c->GetAttr(\"container\", &container_));\n    OP_REQUIRES_OK(c, c->GetAttr(\"shared_name\", &shared_name_));\n    // If shared_name is not supplied, use name instead (prevent collisions by\n    // default).\n    if (shared_name_.empty()) {\n      shared_name_ = name();\n    }\n    OP_REQUIRES_OK(c, c->GetAttr(\"batching_queue\", &batcher_queue_));\n    OP_REQUIRES_OK(c, c->GetAttr(\"num_batch_threads\", &num_batch_threads_));\n    OP_REQUIRES_OK(c, c->GetAttr(\"max_batch_size\", &max_batch_size_));\n    OP_REQUIRES_OK(c,\n                   c->GetAttr(\"batch_timeout_micros\", &batch_timeout_micros_));\n    OP_REQUIRES_OK(c,\n                   c->GetAttr(\"max_enqueued_batches\", &max_enqueued_batches_));\n    OP_REQUIRES_OK(c, c->GetAttr(\"allowed_batch_sizes\", &allowed_batch_sizes_));\n    OP_REQUIRES_OK(c, ValidateAllowedBatchSizes());\n  }\n\n  void ComputeAsync(OpKernelContext* c, DoneCallback done) final {\n    BatchResource* br;\n    std::function<Status(BatchResource**)> creator = [this](BatchResource** r) {\n      std::unique_ptr<BatchResource> new_resource;\n      TF_RETURN_IF_ERROR(BatchResource::Create(\n          num_batch_threads_, max_batch_size_, batch_timeout_micros_,\n          max_enqueued_batches_, allowed_batch_sizes_, kInvalidHandle,\n          /*flib=*/nullptr, false, &new_resource));\n      *r = new_resource.release();\n      return OkStatus();\n    };\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->resource_manager()->LookupOrCreate(\n                             container_, shared_name_, &br, creator),\n                         done);\n    const Status status =\n        br->RegisterInput(random::New64(), c, batcher_queue_, done);\n    br->Unref();\n    OP_REQUIRES_OK_ASYNC(c, status, done);\n    // Assume br calls done, so nothing to do here.\n  }\n\n  // Validates 'allowed_batch_sizes_'. The entries must increase\n  // monotonically, and the last one must equal 'max_batch_size_'.\n  Status ValidateAllowedBatchSizes() const {\n    if (allowed_batch_sizes_.empty()) {\n      return OkStatus();\n    }\n    int32_t last_size = 0;\n    for (size_t i = 0; i < allowed_batch_sizes_.size(); ++i) {\n      const int32_t size = allowed_batch_sizes_.at(i);\n      if (i > 0 && size <= last_size) {\n        return errors::InvalidArgument(\n            \"allowed_batch_sizes entries must be monotonically increasing\");\n      }\n      if (i == allowed_batch_sizes_.size() - 1 && size != max_batch_size_) {\n        return errors::InvalidArgument(\n            \"final entry in allowed_batch_sizes must equal max_batch_size\");\n      }\n      last_size = size;\n    }\n    return OkStatus();\n  }\n\n private:\n  string container_;\n  string shared_name_;\n  string batcher_queue_;\n  int32 num_batch_threads_;\n  int32 max_batch_size_;\n  int32 batch_timeout_micros_;\n  int32 max_enqueued_batches_;\n  std::vector<int32> allowed_batch_sizes_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"Batch\").Device(DEVICE_CPU), BatchKernel);\n\n// A class encapsulating the state and logic for unbatching tensors.\n//\n// UnbatchResource keeps two data structures indexed by batch-key: one which has\n// the continuations for all concurrent kernels which are waiting for tensors\n// and another which has tensors which are waiting for their corresponding\n// kernels to run. Whenever a kernel runs, we either grab its tensor if it's\n// waiting already, or we insert it in the queue and then look at its tensor to\n// see if it can be used to dispatch any stored continuations.\nclass UnbatchResource : public ResourceBase {\n public:\n  explicit UnbatchResource(int32_t timeout_micros)\n      : timeout_micros_(timeout_micros),\n        timeout_enforcer_(new serving::PeriodicFunction(\n            [this] { EnforceTimeout(); }, 1000 /* 1 ms */)) {}\n\n  ~UnbatchResource() override {\n    // Tear down 'timeout_enforcer_' first, since it accesses other state in\n    // this class.\n    timeout_enforcer_ = nullptr;\n  }\n\n  string DebugString() const final { return \"UnbatchResource\"; }\n\n  Status Compute(OpKernelContext* context, AsyncOpKernel::DoneCallback done) {\n    const Tensor& data_t = context->input(0);\n    const Tensor& batch_index_t = context->input(1);\n\n    if (batch_index_t.shape().dim_size(0) > data_t.shape().dim_size(0)) {\n      return errors::InvalidArgument(\n          \"Wrong shape for index tensor. Expected 0th dimension size to be no \"\n          \"greater than \",\n          data_t.shape().dim_size(0),\n          \"; Got: \", batch_index_t.shape().dim_size(0), \".\");\n    }\n    if (batch_index_t.shape().dim_size(1) != 3) {\n      return errors::InvalidArgument(\n          \"Wrong shape for index tensor. Expected 1st dimension size to be 3 ; \"\n          \"Got: \",\n          batch_index_t.shape().dim_size(1), \".\");\n    }\n\n    if (!TensorShapeUtils::IsScalar(context->input(2).shape())) {\n      return errors::InvalidArgument(\n          \"Input id should be scalar; \"\n          \"Got: \",\n          context->input(2).DebugString(), \".\");\n    }\n    const int64_t batch_key = context->input(2).scalar<int64_t>()();\n    const bool nonempty_input = batch_index_t.dim_size(0) > 0;\n\n    // If we have a non-empty tensor, slice it up.\n    // (It is important to do this outside of the critical section below.)\n    // The following variables are populated iff 'nonempty_input==true'.\n    std::vector<int64_t> sizes;\n    std::vector<int64_t> batch_keys;\n    std::vector<Tensor> split_inputs;\n    if (nonempty_input) {\n      auto batch_indices =\n          batch_index_t.shaped<int64_t, 2>({batch_index_t.dim_size(0), 3});\n      for (int i = 0; i < batch_index_t.dim_size(0); ++i) {\n        sizes.push_back(batch_indices(i, 2) - batch_indices(i, 1));\n        batch_keys.push_back(batch_indices(i, 0));\n      }\n\n      TF_RETURN_IF_ERROR(Split(context, data_t, sizes, &split_inputs));\n    }\n\n    // Critical section.\n    std::vector<AsyncOpKernel::DoneCallback> done_callbacks_to_call;\n    Status status = [&]() -> Status {\n      mutex_lock ml(mu_);\n\n      // Check to see whether the tensor we want is already ready.\n      auto tensor_it = waiting_tensors_.find(batch_key);\n      if (tensor_it != waiting_tensors_.end()) {\n        context->set_output(0, tensor_it->second.tensor);\n        waiting_tensors_.erase(tensor_it);\n        done_callbacks_to_call.push_back(done);\n        return OkStatus();\n      }\n\n      const uint64 deadline_micros =\n          Env::Default()->NowMicros() + timeout_micros_;\n\n      // Add ourselves to the waitlist for tensors.\n      if (!waiting_callbacks_\n               .emplace(batch_key,\n                        WaitingCallback{deadline_micros, context, done})\n               .second) {\n        return errors::AlreadyExists(\n            \"Multiple session runs with the same batch key.\");\n      }\n\n      // If we have a non-empty tensor, finish the waitlisted runs,\n      // and store any remaining pieces.\n      if (nonempty_input) {\n        for (size_t i = 0; i < batch_keys.size(); ++i) {\n          auto runs_it = waiting_callbacks_.find(batch_keys[i]);\n          if (runs_it != waiting_callbacks_.end()) {\n            runs_it->second.context->set_output(0, split_inputs[i]);\n            done_callbacks_to_call.push_back(runs_it->second.done);\n            waiting_callbacks_.erase(runs_it);\n          } else {\n            // Note: the deadline here is in case we are arriving late and the\n            // kernel that should rendezvous with this tensor has already waited\n            // and timed out.\n            if (!waiting_tensors_\n                     .emplace(batch_keys[i],\n                              WaitingTensor{deadline_micros, split_inputs[i]})\n                     .second) {\n              return errors::AlreadyExists(\n                  \"Multiple tensors returned for same batch key.\");\n            }\n          }\n        }\n      }\n\n      return OkStatus();\n    }();\n\n    for (const AsyncOpKernel::DoneCallback& done_callback :\n         done_callbacks_to_call) {\n      done_callback();\n    }\n\n    return status;\n  }\n\n private:\n  // Evicts waiting tensors and callbacks that have exceeded their deadline.\n  void EnforceTimeout() {\n    const uint64 now = Env::Default()->NowMicros();\n    std::vector<WaitingCallback> evicted_callbacks;\n\n    {\n      mutex_lock ml(mu_);\n\n      for (auto it = waiting_tensors_.begin(); it != waiting_tensors_.end();) {\n        const WaitingTensor& waiting_tensor = it->second;\n        if (waiting_tensor.deadline_micros < now) {\n          it = waiting_tensors_.erase(it);\n        } else {\n          ++it;\n        }\n      }\n\n      for (auto it = waiting_callbacks_.begin();\n           it != waiting_callbacks_.end();) {\n        const WaitingCallback& waiting_callback = it->second;\n        if (waiting_callback.deadline_micros < now) {\n          evicted_callbacks.push_back(waiting_callback);\n          it = waiting_callbacks_.erase(it);\n        } else {\n          ++it;\n        }\n      }\n    }\n\n    for (const WaitingCallback& evicted_callback : evicted_callbacks) {\n      evicted_callback.context->CtxFailureWithWarning(errors::DeadlineExceeded(\n          \"Batched data did not arrive within timeout window.\"));\n      evicted_callback.done();\n    }\n  }\n\n  struct WaitingTensor {\n    uint64 deadline_micros;\n    Tensor tensor;\n  };\n\n  struct WaitingCallback {\n    uint64 deadline_micros;\n    OpKernelContext* context;\n    AsyncOpKernel::DoneCallback done;\n  };\n\n  const int32 timeout_micros_;\n\n  mutex mu_;\n\n  // Maps keyed by BatchKey of tensors waiting for callbacks and callbacks\n  // waiting for tensors.\n  std::unordered_map<int64_t, WaitingTensor> waiting_tensors_\n      TF_GUARDED_BY(mu_);\n  std::unordered_map<int64_t, WaitingCallback> waiting_callbacks_\n      TF_GUARDED_BY(mu_);\n\n  // A thread that evicts waiting tensors and callbacks that have exceeded their\n  // deadline.\n  std::unique_ptr<serving::PeriodicFunction> timeout_enforcer_;\n};\n\nclass UnbatchKernel : public AsyncOpKernel {\n public:\n  explicit UnbatchKernel(OpKernelConstruction* c) : AsyncOpKernel(c) {\n    OP_REQUIRES_OK(c, c->GetAttr(\"container\", &container_));\n    OP_REQUIRES_OK(c, c->GetAttr(\"shared_name\", &shared_name_));\n    // If shared_name is not supplied, use name instead (prevent collisions by\n    // default).\n    if (shared_name_.empty()) {\n      shared_name_ = name();\n    }\n    OP_REQUIRES_OK(c, c->GetAttr(\"timeout_micros\", &timeout_micros_));\n  }\n\n  void ComputeAsync(OpKernelContext* c, DoneCallback done) final {\n    UnbatchResource* ubr;\n    std::function<Status(UnbatchResource**)> creator =\n        [this](UnbatchResource** r) {\n          *r = new UnbatchResource(timeout_micros_);\n          return OkStatus();\n        };\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->resource_manager()->LookupOrCreate(\n                             container_, shared_name_, &ubr, creator),\n                         done);\n    auto status = ubr->Compute(c, done);\n    ubr->Unref();\n    OP_REQUIRES_OK_ASYNC(c, status, done);\n    // Assume ubr calls done, so nothing to do here.\n  }\n\n private:\n  string container_;\n  string shared_name_;\n  int32 timeout_micros_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"Unbatch\").Device(DEVICE_CPU), UnbatchKernel);\n\n// A class encapsulating the state and logic for batching tensors\n// deterministically for the gradient of unbatch.\nclass UnbatchGradResource : public ResourceBase {\n public:\n  UnbatchGradResource() {}\n\n  string DebugString() const final { return \"UnbatchGradResource\"; }\n\n  // Flushes the information for one batch, given its context and done\n  // callback. Clears all information about it from the available_tensors_.\n  Status OutputBatch(OpKernelContext* context,\n                     const AsyncOpKernel::DoneCallback& done)\n      TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    const Tensor& batch_index_t = context->input(1);\n    auto batch_index =\n        batch_index_t.shaped<int64_t, 2>({batch_index_t.dim_size(0), 3});\n    std::vector<Tensor> tensors;\n    for (int i = 0; i < batch_index_t.dim_size(0); ++i) {\n      auto available_it = available_tensors_.find(batch_index(i, 0));\n      if (available_it == available_tensors_.end()) {\n        return errors::Internal(\"bad bookkeeping of available tensors.\");\n      }\n      tensors.push_back(available_it->second);\n      available_tensors_.erase(available_it);\n    }\n\n    const DataType type = tensors[0].dtype();\n    Tensor concatenated_tensor;\n    switch (type) {\n#define CASE(type)                                                            \\\n  case DataTypeToEnum<type>::value:                                           \\\n    TF_RETURN_IF_ERROR(Concat<type>(context, tensors, &concatenated_tensor)); \\\n    context->set_output(0, concatenated_tensor);                              \\\n    break;\n      TF_CALL_ALL_TYPES(CASE);\n#undef CASE\n      default:\n        return errors::InvalidArgument(\"Unsupported data type: \", type);\n    }\n    done();\n    return OkStatus();\n  }\n\n  // Ingests data from one invocation of the op.\n  Status Compute(OpKernelContext* context,\n                 const AsyncOpKernel::DoneCallback& done) {\n    const Tensor& data_t = context->input(0);\n    const Tensor& batch_index_t = context->input(1);\n    const Tensor& grad_t = context->input(2);\n    const Tensor& batch_key_t = context->input(3);\n\n    mutex_lock ml(mu_);\n    if (batch_key_t.NumElements() != 1) {\n      return errors::InvalidArgument(\"Expected `id` to be scalar. Received \",\n                                     batch_key_t.DebugString());\n    }\n\n    const int64_t batch_key = context->input(3).scalar<int64_t>()();\n    // Mark our tensor as available.\n    if (!available_tensors_.emplace(batch_key, grad_t).second) {\n      return errors::InvalidArgument(\"Two runs with the same batch key.\");\n    }\n\n    // Check whether we have a valid input tensor and, if so, create its\n    // dispatch logic.\n    if (data_t.NumElements() > 0) {\n      if (batch_index_t.NumElements() == 0) {\n        return errors::InvalidArgument(\n            \"batch_index is empty while the tensor isn't.\");\n      }\n      std::unordered_set<int64_t> missing_tensors;\n      if (batch_index_t.NumElements() != batch_index_t.dim_size(0) * 3) {\n        return errors::InvalidArgument(\n            \"batch_index should contain \", batch_index_t.dim_size(0) * 3,\n            \" elements. Received \", batch_index_t.NumElements());\n      }\n      const auto batch_index =\n          batch_index_t.shaped<int64_t, 2>({batch_index_t.dim_size(0), 3});\n      for (int i = 0; i < batch_index_t.dim_size(0); ++i) {\n        const int64_t batch_key = batch_index(i, 0);\n        if (available_tensors_.find(batch_key) == available_tensors_.end()) {\n          missing_tensors.emplace(batch_key);\n        }\n      }\n      if (missing_tensors.empty()) {\n        return OutputBatch(context, done);\n      }\n      if (!available_batches_\n               .emplace(batch_key, Batch{missing_tensors, context, done})\n               .second) {\n        return errors::InvalidArgument(\n            \"Batch key with valid batch used twice.\");\n      }\n      for (const int64_t i : missing_tensors) {\n        if (!desired_tensor_to_batch_map_.emplace(i, batch_key).second) {\n          return errors::InvalidArgument(\n              \"Missing tensor wanted by more than one batch.\");\n        }\n      }\n    } else {\n      // If we don't have a valid input tensor we can output an empty tensor and\n      // call our done closure.\n      TensorShape output_shape(grad_t.shape());\n      output_shape.set_dim(0, 0);\n      Tensor* output = nullptr;\n      TF_RETURN_IF_ERROR(context->allocate_output(0, output_shape, &output));\n      done();\n    }\n\n    // Search to see whether our tensor is desired by any existing batch.\n    auto desire_it = desired_tensor_to_batch_map_.find(batch_key);\n    if (desire_it != desired_tensor_to_batch_map_.end()) {\n      // Mark our tensor as no longer missing.\n      auto batch_it = available_batches_.find(desire_it->second);\n      desired_tensor_to_batch_map_.erase(desire_it);\n      if (batch_it == available_batches_.end()) {\n        return errors::InvalidArgument(\"Batch no longer exists.\");\n      }\n      batch_it->second.missing_tensors.erase(batch_key);\n      // If all tensors are available we should concatenate them and dispatch\n      // the batch.\n      if (batch_it->second.missing_tensors.empty()) {\n        TF_RETURN_IF_ERROR(\n            OutputBatch(batch_it->second.context, batch_it->second.done));\n        available_batches_.erase(batch_it);\n      }\n    }\n    return OkStatus();\n  }\n\n private:\n  mutex mu_;\n\n  // Represents a still-incomplete batch of tensors. When all tensors become\n  // available they will be concatenated in the right order and sent through the\n  // context.\n  struct Batch {\n    // Batch keys for tensors which are still missing from this batch. When this\n    // is empty the Tensors can be concatenated and forwarded.\n    std::unordered_set<int64_t> missing_tensors;\n\n    // Context and callback for the session responsible for finishing this\n    // batch.\n    OpKernelContext* context;\n    AsyncOpKernel::DoneCallback done;\n  };\n\n  // Map from batch key of the session which will output the batched gradients\n  // to still-incomplete batches.\n  std::unordered_map<int64_t, Batch> available_batches_;\n\n  // Map from batch key to tensors which are waiting for their batches to be\n  // available.\n  std::unordered_map<int64_t, Tensor> available_tensors_;\n\n  // Map from batch key of a tensor which is not yet available to the batch key\n  // of the batch to which it belongs.\n  std::unordered_map<int64_t, int64_t> desired_tensor_to_batch_map_;\n};\n\nclass UnbatchGradKernel : public AsyncOpKernel {\n public:\n  explicit UnbatchGradKernel(OpKernelConstruction* c) : AsyncOpKernel(c) {\n    OP_REQUIRES_OK(c, c->GetAttr(\"container\", &container_));\n    OP_REQUIRES_OK(c, c->GetAttr(\"shared_name\", &shared_name_));\n    // If shared_name is not supplied, use name instead (prevent collisions by\n    // default).\n    if (shared_name_.empty()) {\n      shared_name_ = name();\n    }\n  }\n\n  void ComputeAsync(OpKernelContext* c, DoneCallback done) final {\n    UnbatchGradResource* ubr;\n    std::function<Status(UnbatchGradResource**)> creator =\n        [](UnbatchGradResource** r) {\n          *r = new UnbatchGradResource();\n          return OkStatus();\n        };\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->resource_manager()->LookupOrCreate(\n                             container_, shared_name_, &ubr, creator),\n                         done);\n    Status status = ubr->Compute(c, done);\n    ubr->Unref();\n    OP_REQUIRES_OK_ASYNC(c, status, done);\n    // Assume ubr calls done, so nothing to do here.\n  }\n\n private:\n  string container_;\n  string shared_name_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"UnbatchGrad\").Device(DEVICE_CPU),\n                        UnbatchGradKernel);\n\n}  // namespace tensorflow\n", "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for the currently experimental in-graph batch ops.\"\"\"\nimport threading\nimport time\nimport numpy as np\n\nfrom tensorflow.core.protobuf import config_pb2\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import function\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.framework.errors import InvalidArgumentError\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import batch_ops\nfrom tensorflow.python.ops import gen_batch_ops\nfrom tensorflow.python.ops import gen_functional_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import random_ops\nfrom tensorflow.python.ops import resource_variable_ops\nfrom tensorflow.python.ops import script_ops\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import test\n\n\ndef delayed_plus1(x):\n  \"\"\"Sleeps for 100ms then returns x+1.\"\"\"\n  time.sleep(0.1)\n  return x + 1\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass BatchOpsTest(test.TestCase):\n  \"\"\"Tests for batch_ops.{un,}batch.\"\"\"\n\n  # Test for only non eager mode as batching in eager context as a functionality\n  # is TBD.\n  def testBasicBatch(self):\n    \"\"\"Tests that a single batched tensor executes together and only once.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      batched, index, _ = batch_ops.batch(\n          [inp], num_batch_threads=1, max_batch_size=2,\n          batch_timeout_micros=36000000, grad_timeout_micros=0,\n          batching_queue=\"\")\n      thread_results = []\n\n      def worker():\n        thread_results.extend(\n            sess.run([batched, index], feed_dict={inp: [1]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([batched, index], feed_dict={inp: [2]})\n      worker_thread.join()\n\n      # At this point either the thread or the main did the batch and the other\n      # should have empty results.\n      if list(thread_results[0][0]):\n        batch_t = thread_results[0][0]\n        index_t = thread_results[1]\n        empty_b = main_results[0][0]\n        empty_m = main_results[1]\n      else:\n        batch_t = main_results[0][0]\n        index_t = main_results[1]\n        empty_b = thread_results[0][0]\n        empty_m = thread_results[1]\n\n      # Check that both the inputs made it out exactly once.\n      self.assertAllEqual(sorted(batch_t), (1, 2))\n      # Check that we get 2 rows in the index tensor.\n      self.assertEqual(len(index_t), 2)\n      # Check that the other ones are empty.\n      self.assertEqual(len(empty_b), 0)\n      self.assertEqual(len(empty_m), 0)\n\n  def testBatchWithPadding(self):\n    \"\"\"Test that batching with padding up to an allowed batch size works.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[2])\n      batched, index, _ = batch_ops.batch(\n          [inp], num_batch_threads=1, max_batch_size=10,\n          batch_timeout_micros=100000,  # 100ms\n          allowed_batch_sizes=[5, 10],\n          grad_timeout_micros=0, batching_queue=\"\")\n      thread_results = []\n\n      def worker():\n        thread_results.extend(\n            sess.run([batched, index], feed_dict={inp: [1, 3]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([batched, index], feed_dict={inp: [2, 4]})\n      worker_thread.join()\n\n      # At this point either the thread or the main did the batch and the other\n      # should have empty results.\n      if list(thread_results[0][0]):\n        batch_t = thread_results[0][0]\n      else:\n        batch_t = main_results[0][0]\n\n      # Check that the batch tensor incorporates the padding.\n      self.assertEqual(len(batch_t), 5)\n\n  def testMultipleBatch(self):\n    \"\"\"Tests that multiple batched tensors execute together.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp0 = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      inp1 = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      batched, _, _ = batch_ops.batch(\n          [inp0, inp1],\n          num_batch_threads=1,\n          max_batch_size=2,\n          batch_timeout_micros=36000000,\n          grad_timeout_micros=0,\n          batching_queue=\"\")\n      thread_results = []\n\n      def worker():\n        thread_results.extend(\n            sess.run([batched], feed_dict={inp0: [1],\n                                           inp1: [2]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([batched], feed_dict={inp0: [2], inp1: [3]})\n      worker_thread.join()\n\n      # At this point either the thread or the main did the batch and the other\n      # should have empty results.\n      if list(thread_results[0][0]):\n        batch_t = thread_results[0]\n        empty_t = main_results[0]\n      else:\n        batch_t = main_results[0]\n        empty_t = thread_results[0]\n\n      # Assert that the tensors were batched together.\n      self.assertAllEqual(sorted(batch_t[0]), [1, 2])\n      self.assertAllEqual(sorted(batch_t[1]), [2, 3])\n      self.assertAllEqual(empty_t[0], [])\n      self.assertAllEqual(empty_t[1], [])\n\n  def testIllegalBatchDifferentDim0Sizes(self):\n    \"\"\"Tests illegally feeding tensors with different dim0 sizes.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp0 = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      inp1 = array_ops.placeholder(dtype=dtypes.int32, shape=[2])\n      batched, index, _ = batch_ops.batch(\n          [inp0, inp1], num_batch_threads=1, max_batch_size=2,\n          batch_timeout_micros=0, grad_timeout_micros=0, batching_queue=\"\")\n      with self.assertRaises(Exception) as raised:\n        _ = sess.run([batched, index], feed_dict={inp0: [0], inp1: [1, 2]})\n      self.assertGreater(\n          raised.exception.message.find(\"must have equal 0th-dimension size\"),\n          0)\n\n  def testBasicUnbatch(self):\n    \"\"\"Tests that batch and unbatch work together.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      batched, index, id_t = batch_ops.batch(\n          [inp], num_batch_threads=1, max_batch_size=10,\n          batch_timeout_micros=100000,  # 100ms\n          allowed_batch_sizes=[3, 10],\n          grad_timeout_micros=0, batching_queue=\"\")\n      computation = batched[0] + 1\n      result = batch_ops.unbatch(computation, index, id_t,\n                                 timeout_micros=1000000, shared_name=\"unbatch\")\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [1]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [2]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [2])\n      self.assertEqual(main_results[0], [3])\n\n  def testBasicUnbatchDecorated(self):\n    \"\"\"Tests that the batch_function decorator works.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      # TODO(apassos): Removing this line causes test flakiness! Ideally should\n      # be investigated.\n      default_inp = array_ops.placeholder_with_default(2, shape=[])  # pylint: disable=unused-variable\n\n      @batch_ops.batch_function(1, 10, 100000)\n      def computation(in_t):\n        self.assertTrue(in_t.shape is not None)\n        return in_t + 1\n\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      result = computation(inp)\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [1]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [2]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [2])\n      self.assertEqual(main_results[0], [3])\n\n  def testUnbatchInvalidIdArg(self):\n    \"\"\"Tests that unbatch work together.\"\"\"\n    if context.executing_eagerly():\n      batched_tensor = constant_op.constant(\n          value=np.random.random(size=(3, 3, 1)), dtype=dtypes.float64)\n      batched_index = constant_op.constant(\n          value=np.random.randint(0, 100, size=(3, 3, 1)), dtype=dtypes.int64)\n      arg_id = constant_op.constant(\n          value=np.random.randint(0, 100, size=(3, 3, 1)), dtype=dtypes.int64)\n\n      with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                  \"Input id should be scalar;\"):\n        batch_ops.unbatch(\n            batched_tensor=batched_tensor,\n            batch_index=batched_index,\n            id=arg_id,\n            timeout_micros=50,\n            container=\"\",\n            shared_name=\"\")\n\n  def testBatchDecoratedWithCapturedInput(self):\n    \"\"\"Tests that the batch_function decorator works.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      captured_inp0 = array_ops.placeholder_with_default(2., shape=[])\n      captured_inp1 = resource_variable_ops.ResourceVariable(3.)\n      with ops.device(\"/cpu:0\"):\n        captured_inp2 = resource_variable_ops.ResourceVariable(4.)\n\n      @batch_ops.batch_function(1, 10, 100000)\n      def computation(in_t):\n        return in_t + captured_inp0 + captured_inp1 + captured_inp2\n\n      inp = array_ops.placeholder(dtype=dtypes.float32, shape=[1])\n      result = computation(inp)\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [1]}))\n\n      sess.run(variables.global_variables_initializer())\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [2]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [10])\n      self.assertEqual(main_results[0], [11])\n\n  @test_util.disable_xla(\"DeviceIndex returns sentinel value with XLA\")\n  def testBatchDecoratedGpu(self):\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n\n      @batch_ops.batch_function(1, 10, 100000)\n      def computation(in_t):\n        # index is 0 on CPU and 1 on GPU\n        index = gen_functional_ops.DeviceIndex(device_names=[\"CPU\", \"GPU\"])\n        return in_t + math_ops.cast(index, dtypes.float32)\n\n      inp = array_ops.placeholder(dtype=dtypes.float32, shape=[1])\n      result = computation(inp)\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [10.]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [20.]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [10 + test_util.is_gpu_available()])\n      self.assertEqual(main_results[0], [20 + test_util.is_gpu_available()])\n\n  def testParallelRunsWithCpuAndGpu(self):\n    # Run multiple instances of a batch function in parallel. This is a\n    # regression test: this used to fail because _Send nodes for one call would\n    # send the tensor to the _Recv node for a different call.\n    if context.executing_eagerly():\n      return\n    @batch_ops.batch_function(1, 2, 1)\n    def f(x):\n      with ops.device(\"/GPU:0\"):\n        x = x + 1.\n      with ops.device(\"/CPU:0\"):\n        return x + 1\n    num_calls = 10\n    placeholders = [array_ops.placeholder(dtypes.float32, shape=(1,))\n                    for _ in range(num_calls)]\n    results = []\n    for p in placeholders:\n      result = f(p)\n      results.append(result)\n    inputs = [[float(i)] for i in range(num_calls)]\n    expected = [[float(i + 2)] for i in range(num_calls)]\n    with self.session() as sess:\n      outputs = sess.run(results, feed_dict=dict(zip(placeholders, inputs)))\n      self.assertAllEqual(outputs, expected)\n\n  def testSoftPlacement(self):\n    if context.executing_eagerly():\n      return\n\n    @batch_ops.batch_function(1, 10, 100000)\n    def computation(in_t):\n      with ops.device(\"/GPU:0\"):\n        return in_t + 1.\n\n    inp = array_ops.placeholder(dtype=dtypes.float32, shape=[1])\n    result = computation(inp)\n\n    # With soft placement, the function will run even without a GPU\n    config = config_pb2.ConfigProto(allow_soft_placement=True)\n    with self.session(config=config) as sess:\n      sess.run([result], feed_dict={inp: [20.]})\n\n    # Without soft placement, the function fails without a GPU due to the\n    # addition explicitly being placed on the GPU\n    config.allow_soft_placement = False\n    with self.session(config=config) as sess:\n      if test_util.is_gpu_available():\n        sess.run([result], feed_dict={inp: [20.]})\n      else:\n        with self.assertRaisesRegex(InvalidArgumentError,\n                                    \"Cannot assign a device for operation\"):\n          sess.run([result], feed_dict={inp: [20.]})\n\n  def testBatchFunctionOp(self):\n    \"\"\"Tests that the batch_function op works.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n\n      @function.Defun(dtypes.int32)\n      def computation(in_t):\n        return in_t + 1\n\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      result = gen_batch_ops.batch_function(\n          [inp],\n          num_batch_threads=1,\n          max_batch_size=10,\n          batch_timeout_micros=100000,\n          Tout=[dtypes.int32],\n          f=computation,\n          captured_tensors=computation.captured_inputs)\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [1]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [2]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [2])\n      self.assertEqual(main_results[0], [3])\n\n  def testBatchFunctionOpWithCapturedInput(self):\n    \"\"\"Tests that batch_function op works with captured input.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      captured_inp0 = array_ops.placeholder_with_default(2, shape=[])\n      captured_inp1 = array_ops.placeholder_with_default(1, shape=[])\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n\n      @function.Defun(dtypes.int32)\n      def computation(inp):\n        return inp + captured_inp0 - captured_inp1\n\n      result = gen_batch_ops.batch_function(\n          num_batch_threads=1,\n          max_batch_size=10,\n          batch_timeout_micros=100000,  # 100ms\n          allowed_batch_sizes=[3, 10],\n          batching_queue=\"\",\n          f=computation,\n          in_tensors=[inp],\n          captured_tensors=computation.captured_inputs,\n          Tout=[o.type for o in computation.definition.signature.output_arg])\n\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [1]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [2]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [2])\n      self.assertEqual(main_results[0], [3])\n\n  def testBatchFunctionOpWithInputError(self):\n    \"\"\"Tests that batch_function op works with error in the inputs.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n\n      @function.Defun(dtypes.int32, dtypes.int32)\n      def computation(in0, in1):\n        return in0 + in1\n\n      result = gen_batch_ops.batch_function(\n          [inp],  # computation actually expects 2 inputs.\n          num_batch_threads=1,\n          max_batch_size=10,\n          batch_timeout_micros=100000,  # 100ms\n          batching_queue=\"\",\n          f=computation,\n          captured_tensors=computation.captured_inputs,\n          Tout=[o.type for o in computation.definition.signature.output_arg])\n\n      with self.assertRaisesRegex(\n          InvalidArgumentError,\n          r\"Function takes 2 argument\\(s\\) but 1 argument\\(s\\) were passed\"):\n        sess.run([result], feed_dict={inp: [2]})\n\n  def testBatchFunctionOpWithLargeBatchSplitted(self):\n    \"\"\"Tests that the batch_function op works with large batch splitted.\"\"\"\n    if context.executing_eagerly():\n      return\n\n    with self.cached_session() as sess:\n\n      @function.Defun(dtypes.int32)\n      def computation(in_t):\n        return in_t + 3\n\n      inp = array_ops.placeholder(dtype=dtypes.int32)\n      result = gen_batch_ops.batch_function(\n          [inp],\n          num_batch_threads=2,\n          # enable_large_batch_splitting is True, so it's valid as long as\n          # max('allowed_batch_sizes') <= 'max_batch_size'.\n          allowed_batch_sizes=[1, 2],\n          max_batch_size=5,\n          batch_timeout_micros=100000,  # 100ms\n          Tout=[dtypes.int32],\n          enable_large_batch_splitting=True,\n          f=computation,\n          captured_tensors=computation.captured_inputs)\n      thread1_results = []\n      thread2_results = []\n\n      # Input sizes of worker1 and main thread are larger than\n      # max(allowed_batch_sizes), while input size of worker2 is smaller.\n      def worker1():\n        thread1_results.extend(\n            sess.run([result], feed_dict={inp: [5, 6, 7, 8, 9]}))\n\n      worker_thread1 = threading.Thread(target=worker1)\n      worker_thread1.start()\n\n      def worker2():\n        thread2_results.extend(sess.run([result], feed_dict={inp: [10]}))\n\n      worker_thread2 = threading.Thread(target=worker2)\n      worker_thread2.start()\n\n      main_results = sess.run([result], feed_dict={inp: [2, 3, 4]})\n      worker_thread1.join()\n      worker_thread2.join()\n      self.assertTrue(\n          np.all(np.equal(thread2_results[0], np.array([13], dtype=np.int32))))\n      self.assertTrue(\n          np.all(\n              np.equal(thread1_results[0],\n                       np.array([8, 9, 10, 11, 12], dtype=np.int32))))\n      self.assertTrue(\n          np.all(\n              np.equal(main_results[0], np.array([5, 6, 7], dtype=np.int32))))\n\n  def testBasicUnbatchDecoratedWithReshape(self):\n    \"\"\"Tests that the batch_function decorator works.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n\n      @batch_ops.batch_function(1, 10, 100000)\n      def computation(in_t):\n        return array_ops.reshape(in_t, [-1]) + 1\n\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1, 1])\n      result = computation(inp)\n      thread_results = []\n\n      def worker():\n        thread_results.extend(sess.run([result], feed_dict={inp: [[1]]}))\n\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      main_results = sess.run([result], feed_dict={inp: [[2]]})\n      worker_thread.join()\n      self.assertEqual(thread_results[0], [2])\n      self.assertEqual(main_results[0], [3])\n\n  def testUnbatchTimeout(self):\n    \"\"\"Tests that the unbatch timeout works.\"\"\"\n    if context.executing_eagerly():\n      return\n    with self.cached_session() as sess:\n      inp = array_ops.placeholder(dtype=dtypes.int32, shape=[1])\n      batched, index, id_t = batch_ops.batch(\n          [inp], num_batch_threads=1, max_batch_size=2,\n          batch_timeout_micros=36000000, grad_timeout_micros=0,\n          batching_queue=\"\")\n      computation = batched[0] + 1\n      timeout_micros = 10\n      result = batch_ops.unbatch(computation, index, id_t, timeout_micros,\n                                 shared_name=\"shared_unbatch\")\n      # Set up a parallel pipeline that delays the computation, but uses the\n      # same unbatch resource object as the non-delayed pipeline.\n      computation_delayed = script_ops.py_func(delayed_plus1,\n                                               [batched[0]],\n                                               dtypes.int32)\n      result_delayed = batch_ops.unbatch(computation_delayed,\n                                         index,\n                                         id_t,\n                                         timeout_micros,\n                                         shared_name=\"shared_unbatch\")\n\n      thread_results = []\n      def worker():\n        # A first call using the non-delayed pipeline. The batcher will send an\n        # empty tensor along the non-delayed pipeline.\n        thread_results.extend(sess.run([result], feed_dict={inp: [1]}))\n      worker_thread = threading.Thread(target=worker)\n      worker_thread.start()\n      time.sleep(0.1)  # Ensure the thread's call starts first.\n      # A second call using the delayed pipeline.  The batcher will send the\n      # batched tensor along the delayed pipeline, thus delaying the arrival of\n      # the batched tensor at the unbatch op, relative to the empty tensor.\n      #\n      # TODO(olston, apassos): Avoid relying on the order in which the batch op\n      # emits the empty tensor versus the batched one.\n      _ = sess.run([result_delayed], feed_dict={inp: [2]})\n      worker_thread.join()\n      # The thread's call should hit the timeout, and thus get 0 results.\n      self.assertEqual(len(thread_results), 0)\n\n  def testUnbatchGradInvalidId(self):\n    with self.assertRaises(errors.InvalidArgumentError):\n      self.evaluate(\n          gen_batch_ops.unbatch_grad(\n              original_input=constant_op.constant([1]),\n              batch_index=constant_op.constant([\n                  [0, 0, 0],\n              ], dtype=dtypes.int64),\n              grad=constant_op.constant([\n                  1,\n              ]),\n              id=constant_op.constant([\n                  1,\n                  1,\n              ], dtype=dtypes.int64)))\n\n  def testUnbatchGradInvalidBatchId(self):\n    with self.assertRaises(errors.InvalidArgumentError):\n      self.evaluate(\n          gen_batch_ops.unbatch_grad(\n              original_input=constant_op.constant([1]),\n              batch_index=constant_op.constant([\n                  [0, 0],\n              ], dtype=dtypes.int64),\n              grad=constant_op.constant([\n                  1,\n              ]),\n              id=constant_op.constant([\n                  1,\n              ], dtype=dtypes.int64)))\n\n  def testUnbatchGradInvalidArgs(self):\n    original_input = random_ops.random_uniform(\n        shape=(3, 1), dtype=dtypes.float64, maxval=None)\n    batch_index = random_ops.random_uniform(\n        shape=(3, 1), dtype=dtypes.int64, maxval=65536)\n    grad = random_ops.random_uniform(\n        shape=(3, 1), dtype=dtypes.float64, maxval=None)\n    batch_id = random_ops.random_uniform(\n        shape=(3, 1), dtype=dtypes.int64, maxval=65536)\n    with self.assertRaises(errors.InvalidArgumentError):\n      self.evaluate(\n          gen_batch_ops.unbatch_grad(\n              original_input=original_input,\n              batch_index=batch_index,\n              grad=grad,\n              id=batch_id,\n              container=\"\",\n              shared_name=\"\",\n              name=\"\"))\n\nif __name__ == \"__main__\":\n  test.main()\n"], "filenames": ["tensorflow/core/kernels/batch_kernels.cc", "tensorflow/python/ops/batch_ops_test.py"], "buggy_code_start_loc": [25, 238], "buggy_code_end_loc": [656, 238], "fixing_code_start_loc": [26, 239], "fixing_code_end_loc": [664, 259], "type": "CWE-617", "message": "TensorFlow is an open source platform for machine learning. When `Unbatch` receives a nonscalar input `id`, it gives a `CHECK` fail that can trigger a denial of service attack. We have patched the issue in GitHub commit 4419d10d576adefa36b0e0a9425d2569f7c0189f. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-36002", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-16T23:15:10.763", "lastModified": "2022-09-20T14:42:59.873", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. When `Unbatch` receives a nonscalar input `id`, it gives a `CHECK` fail that can trigger a denial of service attack. We have patched the issue in GitHub commit 4419d10d576adefa36b0e0a9425d2569f7c0189f. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. Cuando \"Unbatch\" recibe un \"id\" de entrada no escalar, da un fallo \"CHECK\" que puede desencadenar un ataque de denegaci\u00f3n de servicio. Hemos parcheado el problema en el commit 4419d10d576adefa36b0e0a9425d2569f7c0189f de GitHub. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.10.0. Tambi\u00e9n seleccionaremos este compromiso en TensorFlow versi\u00f3n 2.9.1, TensorFlow versi\u00f3n 2.8.1, y TensorFlow versi\u00f3n 2.7.2, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C6622D95-1C86-45C5-AB55-E6EEEA0996DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.1", "matchCriteriaId": "0F9D273D-02DC-441E-AA91-EAC8DEAA4B44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.1", "matchCriteriaId": "FE4F8A81-6CC2-4F7F-9602-C170FDD926E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc0:*:*:*:*:*:*", "matchCriteriaId": "1DBFBCE2-0A01-4575-BE45-6775ABFB8B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "89806CF9-E423-4CA6-A01A-8175C260CB24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc2:*:*:*:*:*:*", "matchCriteriaId": "F2B80690-A257-4E16-BD27-9AE045BC56ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc3:*:*:*:*:*:*", "matchCriteriaId": "F335F9A4-5AB8-4E53-BC18-E01F7C653E5E"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/4419d10d576adefa36b0e0a9425d2569f7c0189f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-mh3m-62v7-68xg", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/4419d10d576adefa36b0e0a9425d2569f7c0189f"}}