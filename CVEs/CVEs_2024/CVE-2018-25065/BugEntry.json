{"buggy_code": ["<?php\n\nclass I18nTags {\n\tpublic static function onParserFirstCallInit( Parser $parser ) {\n\t\t$parser->setHook( 'formatnum', [ __CLASS__, 'formatNumber' ] );\n\t\t$parser->setHook( 'grammar', [ __CLASS__, 'grammar' ] );\n\t\t$parser->setHook( 'plural', [ __CLASS__, 'plural' ] );\n\t\t$parser->setHook( 'linktrail', [ __CLASS__, 'linktrail' ] );\n\t\t$parser->setFunctionHook( 'languagename',  [ __CLASS__, 'languageName' ] );\n\t}\n\n\tpublic static function formatNumber( $data, $params, $parser ) {\n\t\t$lang = self::languageObject( $params );\n\n\t\treturn $lang->formatNum( $data );\n\t}\n\n\tpublic static function grammar( $data, $params, $parser ) {\n\t\t$case = isset( $params['case'] ) ? $params['case'] : '';\n\t\t$lang = self::languageObject( $params );\n\n\t\treturn $lang->convertGrammar( $data, $case );\n\t}\n\n\tpublic static function plural( $data, $params, $parser ) {\n\t\tlist( $from, $to ) = self::getRange( isset( $params['n'] ) ? $params['n'] : '' );\n\t\t$args = explode( '|', $data );\n\t\t$lang = self::languageObject( $params );\n\n\t\t$format = isset( $params['format'] ) ? $params['format'] : '%s';\n\t\t$format = str_replace( '\\n', \"\\n\", $format );\n\n\t\t$s = '';\n\t\tfor ( $i = $from; $i <= $to; $i++ ) {\n\t\t\t$t = $lang->convertPlural( $i, $args );\n\t\t\t$fmtn = $lang->formatNum( $i );\n\t\t\t$s .= str_replace(\n\t\t\t\t[ '%d', '%s' ],\n\t\t\t\t[ $i, wfMsgReplaceArgs( $t, [ $fmtn ] ) ],\n\t\t\t\t$format\n\t\t\t);\n\t\t}\n\n\t\treturn $s;\n\t}\n\n\tpublic static function linktrail( $data, $params, $parser ) {\n\t\t$lang = self::languageObject( $params );\n\t\t$regex = $lang->linkTrail();\n\n\t\t$inside = '';\n\t\tif ( '' != $data ) {\n\t\t\t$predata = [];\n\t\t\tpreg_match( '/^\\[\\[([^\\]|]+)(\\|[^\\]]+)?\\]\\](.*)$/sDu', $data, $predata );\n\t\t\t$m = [];\n\t\t\tif ( preg_match( $regex, $predata[3], $m ) ) {\n\t\t\t\t$inside = $m[1];\n\t\t\t\t$data = $m[2];\n\t\t\t}\n\t\t}\n\t\t$predata = isset( $predata[2] ) ? $predata[2] : isset( $predata[1] ) ? $predata[1] : $predata[0];\n\n\t\treturn \"<strong>$predata$inside</strong>$data\";\n\t}\n\n\tpublic static function languageName( &$parser, $code = '', $outputLanguage = '' ) {\n\t\tif ( !$code ) {\n\t\t\treturn '';\n\t\t}\n\t\tif ( !$outputLanguage ) {\n\t\t\t$outputLanguage = $parser->getOptions()->getUserLang();\n\t\t}\n\t\t$cldr = is_callable( [ 'LanguageNames', 'getNames' ] );\n\t\tif ( $outputLanguage !== 'native' && $cldr ) {\n\t\t\t$languages = LanguageNames::getNames( $outputLanguage,\n\t\t\t\tLanguageNames::FALLBACK_NORMAL,\n\t\t\t\tLanguageNames::LIST_MW_AND_CLDR\n\t\t\t);\n\t\t} else {\n\t\t\t$languages = Language::fetchLanguageNames( null, 'mw' );\n\t\t}\n\n\t\treturn isset( $languages[$code] ) ? $languages[$code] : $code;\n\t}\n\n\t/**\n\t * Static helper that returns either content or user interface language object.\n\t *\n\t * @param array $params Parameters passed to to the parser tag\n\t * @return Language\n\t */\n\tpublic static function languageObject( array $params ) {\n\t\tglobal $wgContLang;\n\n\t\treturn isset( $params['lang'] ) ? Language::factory( $params['lang'] ) : $wgContLang;\n\t}\n\n\tpublic static function getRange( $s, $min = false, $max = false ) {\n\t\t$matches = [];\n\t\tif ( preg_match( '/(\\d+)-(\\d+)/', $s, $matches ) ) {\n\t\t\t$from = $matches[1];\n\t\t\t$to = $matches[2];\n\t\t} else {\n\t\t\t$from = $to = (int)$s;\n\t\t}\n\n\t\tif ( $from > $to ) {\n\t\t\t$UNDEFINED = $to;\n\t\t\t$to = $from;\n\t\t\t$from = $UNDEFINED;\n\t\t}\n\t\tif ( $min !== false ) {\n\t\t\t$from = max( $min, $from );\n\t\t}\n\t\tif ( $max !== false ) {\n\t\t\t$to = min( $max, $to );\n\t\t}\n\n\t\treturn [ $from, $to ];\n\t}\n}\n", "{\n\t\"name\": \"Parser i18n tags\",\n\t\"version\": \"2016-02-20\",\n\t\"author\": \"Niklas Laxstr\u00f6m\",\n\t\"url\": \"https://www.mediawiki.org/wiki/Extension:I18nTags\",\n\t\"descriptionmsg\": \"i18ntags-desc\",\n\t\"type\": \"parserhook\",\n\t\"license-name\": \"GPL-2.0-or-later\",\n\t\"AutoloadClasses\": {\n\t\t\"I18nTags\": \"I18nTags_body.php\"\n\t},\n\t\"ExtensionMessagesFiles\": {\n\t\t\"I18nTagsMagic\": \"I18nTags.magic.php\"\n\t},\n\t\"Hooks\": {\n\t\t\"ParserFirstCallInit\": [\n\t\t\t\"I18nTags::onParserFirstCallInit\"\n\t\t]\n\t},\n\t\"MessagesDirs\": {\n\t\t\"I18nTags\": [\n\t\t\t\"i18n\"\n\t\t]\n\t},\n\t\"manifest_version\": 1\n}\n"], "fixing_code": ["<?php\n\nclass I18nTags {\n\tpublic static function onParserFirstCallInit( Parser $parser ) {\n\t\t$parser->setHook( 'formatnum', [ __CLASS__, 'formatNumber' ] );\n\t\t$parser->setHook( 'grammar', [ __CLASS__, 'grammar' ] );\n\t\t$parser->setHook( 'plural', [ __CLASS__, 'plural' ] );\n\t\t$parser->setHook( 'linktrail', [ __CLASS__, 'linktrail' ] );\n\t\t$parser->setFunctionHook( 'languagename',  [ __CLASS__, 'languageName' ] );\n\t}\n\n\tpublic static function formatNumber( $data, $params, $parser, $frame ) {\n\t\t$lang = self::languageObject( $params );\n\n\t\t$text = $lang->formatNum( $data );\n\t\treturn $parser->recursiveTagParse( $text, $frame );\n\t}\n\n\tpublic static function grammar( $data, $params, $parser, $frame ) {\n\t\t$case = isset( $params['case'] ) ? $params['case'] : '';\n\t\t$lang = self::languageObject( $params );\n\n\t\t$text = $lang->convertGrammar( $data, $case );\n\t\treturn $parser->recursiveTagParse( $text, $frame );\n\t}\n\n\tpublic static function plural( $data, $params, $parser, $frame ) {\n\t\tlist( $from, $to ) = self::getRange( isset( $params['n'] ) ? $params['n'] : '' );\n\t\t$args = explode( '|', $data );\n\t\t$lang = self::languageObject( $params );\n\n\t\t$format = isset( $params['format'] ) ? $params['format'] : '%s';\n\t\t$format = str_replace( '\\n', \"\\n\", $format );\n\n\t\t$s = '';\n\t\tfor ( $i = $from; $i <= $to; $i++ ) {\n\t\t\t$t = $lang->convertPlural( $i, $args );\n\t\t\t$fmtn = $lang->formatNum( $i );\n\t\t\t$s .= str_replace(\n\t\t\t\t[ '%d', '%s' ],\n\t\t\t\t[ $i, wfMsgReplaceArgs( $t, [ $fmtn ] ) ],\n\t\t\t\t$format\n\t\t\t);\n\t\t}\n\n\t\treturn $parser->recursiveTagParse( $s, $frame );\n\t}\n\n\tpublic static function linktrail( $data, $params, $parser, $frame ) {\n\t\t$lang = self::languageObject( $params );\n\t\t$regex = $lang->linkTrail();\n\n\t\t$inside = '';\n\t\tif ( '' != $data ) {\n\t\t\t$predata = [];\n\t\t\tpreg_match( '/^\\[\\[([^\\]|]+)(\\|[^\\]]+)?\\]\\](.*)$/sDu', $data, $predata );\n\t\t\t$m = [];\n\t\t\tif ( preg_match( $regex, $predata[3], $m ) ) {\n\t\t\t\t$inside = $m[1];\n\t\t\t\t$data = $m[2];\n\t\t\t}\n\t\t}\n\t\t$predata = isset( $predata[2] ) ? $predata[2] : isset( $predata[1] ) ? $predata[1] : $predata[0];\n\n\t\t$text = \"<strong>$predata$inside</strong>$data\";\n\t\treturn $parser->recursiveTagParse( $text, $frame );\n\t}\n\n\tpublic static function languageName( &$parser, $code = '', $outputLanguage = '' ) {\n\t\tif ( !$code ) {\n\t\t\treturn '';\n\t\t}\n\t\tif ( !$outputLanguage ) {\n\t\t\t$outputLanguage = $parser->getOptions()->getUserLang();\n\t\t}\n\t\t$cldr = is_callable( [ 'LanguageNames', 'getNames' ] );\n\t\tif ( $outputLanguage !== 'native' && $cldr ) {\n\t\t\t$languages = LanguageNames::getNames( $outputLanguage,\n\t\t\t\tLanguageNames::FALLBACK_NORMAL,\n\t\t\t\tLanguageNames::LIST_MW_AND_CLDR\n\t\t\t);\n\t\t} else {\n\t\t\t$languages = Language::fetchLanguageNames( null, 'mw' );\n\t\t}\n\n\t\treturn isset( $languages[$code] ) ? $languages[$code] : $code;\n\t}\n\n\t/**\n\t * Static helper that returns either content or user interface language object.\n\t *\n\t * @param array $params Parameters passed to to the parser tag\n\t * @return Language\n\t */\n\tpublic static function languageObject( array $params ) {\n\t\tglobal $wgContLang;\n\n\t\treturn isset( $params['lang'] ) ? Language::factory( $params['lang'] ) : $wgContLang;\n\t}\n\n\tpublic static function getRange( $s, $min = false, $max = false ) {\n\t\t$matches = [];\n\t\tif ( preg_match( '/(\\d+)-(\\d+)/', $s, $matches ) ) {\n\t\t\t$from = $matches[1];\n\t\t\t$to = $matches[2];\n\t\t} else {\n\t\t\t$from = $to = (int)$s;\n\t\t}\n\n\t\tif ( $from > $to ) {\n\t\t\t$UNDEFINED = $to;\n\t\t\t$to = $from;\n\t\t\t$from = $UNDEFINED;\n\t\t}\n\t\tif ( $min !== false ) {\n\t\t\t$from = max( $min, $from );\n\t\t}\n\t\tif ( $max !== false ) {\n\t\t\t$to = min( $max, $to );\n\t\t}\n\n\t\treturn [ $from, $to ];\n\t}\n}\n", "{\n\t\"name\": \"Parser i18n tags\",\n\t\"version\": \"2018-08-06\",\n\t\"author\": \"Niklas Laxstr\u00f6m\",\n\t\"url\": \"https://www.mediawiki.org/wiki/Extension:I18nTags\",\n\t\"descriptionmsg\": \"i18ntags-desc\",\n\t\"type\": \"parserhook\",\n\t\"license-name\": \"GPL-2.0-or-later\",\n\t\"AutoloadClasses\": {\n\t\t\"I18nTags\": \"I18nTags_body.php\"\n\t},\n\t\"ExtensionMessagesFiles\": {\n\t\t\"I18nTagsMagic\": \"I18nTags.magic.php\"\n\t},\n\t\"Hooks\": {\n\t\t\"ParserFirstCallInit\": [\n\t\t\t\"I18nTags::onParserFirstCallInit\"\n\t\t]\n\t},\n\t\"MessagesDirs\": {\n\t\t\"I18nTags\": [\n\t\t\t\"i18n\"\n\t\t]\n\t},\n\t\"manifest_version\": 1\n}\n"], "filenames": ["I18nTags_body.php", "extension.json"], "buggy_code_start_loc": [12, 3], "buggy_code_end_loc": [64, 4], "fixing_code_start_loc": [12, 3], "fixing_code_end_loc": [67, 4], "type": "CWE-79", "message": "A vulnerability was found in Wikimedia mediawiki-extensions-I18nTags and classified as problematic. This issue affects some unknown processing of the file I18nTags_body.php of the component Unlike Parser. The manipulation leads to cross site scripting. The attack may be initiated remotely. The name of the patch is b4bc3cbbb099eab50cf2b544cf577116f1867b94. It is recommended to apply a patch to fix this issue. The identifier VDB-217445 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2018-25065", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-05T10:15:09.657", "lastModified": "2023-01-11T18:25:31.757", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Wikimedia mediawiki-extensions-I18nTags and classified as problematic. This issue affects some unknown processing of the file I18nTags_body.php of the component Unlike Parser. The manipulation leads to cross site scripting. The attack may be initiated remotely. The name of the patch is b4bc3cbbb099eab50cf2b544cf577116f1867b94. It is recommended to apply a patch to fix this issue. The identifier VDB-217445 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wikimedia:mediawiki-extensions-i18ntags:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-08-06", "matchCriteriaId": "C8B4EB75-6F5B-43FA-A586-60ACDA38DCAD"}]}]}], "references": [{"url": "https://github.com/wikimedia/mediawiki-extensions-I18nTags/commit/b4bc3cbbb099eab50cf2b544cf577116f1867b94", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217445", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217445", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wikimedia/mediawiki-extensions-I18nTags/commit/b4bc3cbbb099eab50cf2b544cf577116f1867b94"}}