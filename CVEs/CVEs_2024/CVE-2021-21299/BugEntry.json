{"buggy_code": ["// `mem::uninitialized` replaced with `mem::MaybeUninit`,\n// can't upgrade yet\n#![allow(deprecated)]\n\nuse std::fmt::{self, Write};\nuse std::mem;\n\n#[cfg(feature = \"ffi\")]\nuse bytes::Bytes;\nuse bytes::BytesMut;\nuse http::header::{self, Entry, HeaderName, HeaderValue};\nuse http::{HeaderMap, Method, StatusCode, Version};\n\nuse crate::body::DecodedLength;\n#[cfg(feature = \"server\")]\nuse crate::common::date;\nuse crate::error::Parse;\nuse crate::headers;\nuse crate::proto::h1::{\n    Encode, Encoder, Http1Transaction, ParseContext, ParseResult, ParsedMessage,\n};\nuse crate::proto::{BodyLength, MessageHead, RequestHead, RequestLine};\n\nconst MAX_HEADERS: usize = 100;\nconst AVERAGE_HEADER_SIZE: usize = 30; // totally scientific\n\nmacro_rules! header_name {\n    ($bytes:expr) => {{\n        #[cfg(debug_assertions)]\n        {\n            match HeaderName::from_bytes($bytes) {\n                Ok(name) => name,\n                Err(_) => panic!(\n                    \"illegal header name from httparse: {:?}\",\n                    ::bytes::Bytes::copy_from_slice($bytes)\n                ),\n            }\n        }\n\n        #[cfg(not(debug_assertions))]\n        {\n            match HeaderName::from_bytes($bytes) {\n                Ok(name) => name,\n                Err(_) => panic!(\"illegal header name from httparse: {:?}\", $bytes),\n            }\n        }\n    }};\n}\n\nmacro_rules! header_value {\n    ($bytes:expr) => {{\n        #[cfg(debug_assertions)]\n        {\n            let __hvb: ::bytes::Bytes = $bytes;\n            match HeaderValue::from_maybe_shared(__hvb.clone()) {\n                Ok(name) => name,\n                Err(_) => panic!(\"illegal header value from httparse: {:?}\", __hvb),\n            }\n        }\n\n        #[cfg(not(debug_assertions))]\n        {\n            // Unsafe: httparse already validated header value\n            unsafe { HeaderValue::from_maybe_shared_unchecked($bytes) }\n        }\n    }};\n}\n\npub(super) fn parse_headers<T>(\n    bytes: &mut BytesMut,\n    ctx: ParseContext<'_>,\n) -> ParseResult<T::Incoming>\nwhere\n    T: Http1Transaction,\n{\n    // If the buffer is empty, don't bother entering the span, it's just noise.\n    if bytes.is_empty() {\n        return Ok(None);\n    }\n\n    let span = trace_span!(\"parse_headers\");\n    let _s = span.enter();\n    T::parse(bytes, ctx)\n}\n\npub(super) fn encode_headers<T>(\n    enc: Encode<'_, T::Outgoing>,\n    dst: &mut Vec<u8>,\n) -> crate::Result<Encoder>\nwhere\n    T: Http1Transaction,\n{\n    let span = trace_span!(\"encode_headers\");\n    let _s = span.enter();\n    T::encode(enc, dst)\n}\n\n// There are 2 main roles, Client and Server.\n\n#[cfg(feature = \"client\")]\npub(crate) enum Client {}\n\n#[cfg(feature = \"server\")]\npub(crate) enum Server {}\n\n#[cfg(feature = \"server\")]\nimpl Http1Transaction for Server {\n    type Incoming = RequestLine;\n    type Outgoing = StatusCode;\n    const LOG: &'static str = \"{role=server}\";\n\n    fn parse(buf: &mut BytesMut, ctx: ParseContext<'_>) -> ParseResult<RequestLine> {\n        debug_assert!(!buf.is_empty(), \"parse called with empty buf\");\n\n        let mut keep_alive;\n        let is_http_11;\n        let subject;\n        let version;\n        let len;\n        let headers_len;\n\n        // Unsafe: both headers_indices and headers are using uninitialized memory,\n        // but we *never* read any of it until after httparse has assigned\n        // values into it. By not zeroing out the stack memory, this saves\n        // a good ~5% on pipeline benchmarks.\n        let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };\n        {\n            let mut headers: [httparse::Header<'_>; MAX_HEADERS] = unsafe { mem::uninitialized() };\n            trace!(\n                \"Request.parse([Header; {}], [u8; {}])\",\n                headers.len(),\n                buf.len()\n            );\n            let mut req = httparse::Request::new(&mut headers);\n            let bytes = buf.as_ref();\n            match req.parse(bytes) {\n                Ok(httparse::Status::Complete(parsed_len)) => {\n                    trace!(\"Request.parse Complete({})\", parsed_len);\n                    len = parsed_len;\n                    subject = RequestLine(\n                        Method::from_bytes(req.method.unwrap().as_bytes())?,\n                        req.path.unwrap().parse()?,\n                    );\n                    version = if req.version.unwrap() == 1 {\n                        keep_alive = true;\n                        is_http_11 = true;\n                        Version::HTTP_11\n                    } else {\n                        keep_alive = false;\n                        is_http_11 = false;\n                        Version::HTTP_10\n                    };\n                    trace!(\"headers: {:?}\", &req.headers);\n\n                    record_header_indices(bytes, &req.headers, &mut headers_indices)?;\n                    headers_len = req.headers.len();\n                }\n                Ok(httparse::Status::Partial) => return Ok(None),\n                Err(err) => {\n                    return Err(match err {\n                        // if invalid Token, try to determine if for method or path\n                        httparse::Error::Token => {\n                            if req.method.is_none() {\n                                Parse::Method\n                            } else {\n                                debug_assert!(req.path.is_none());\n                                Parse::Uri\n                            }\n                        }\n                        other => other.into(),\n                    });\n                }\n            }\n        };\n\n        let slice = buf.split_to(len).freeze();\n\n        // According to https://tools.ietf.org/html/rfc7230#section-3.3.3\n        // 1. (irrelevant to Request)\n        // 2. (irrelevant to Request)\n        // 3. Transfer-Encoding: chunked has a chunked body.\n        // 4. If multiple differing Content-Length headers or invalid, close connection.\n        // 5. Content-Length header has a sized body.\n        // 6. Length 0.\n        // 7. (irrelevant to Request)\n\n        let mut decoder = DecodedLength::ZERO;\n        let mut expect_continue = false;\n        let mut con_len = None;\n        let mut is_te = false;\n        let mut is_te_chunked = false;\n        let mut wants_upgrade = subject.0 == Method::CONNECT;\n\n        let mut headers = ctx.cached_headers.take().unwrap_or_else(HeaderMap::new);\n\n        headers.reserve(headers_len);\n\n        for header in &headers_indices[..headers_len] {\n            let name = header_name!(&slice[header.name.0..header.name.1]);\n            let value = header_value!(slice.slice(header.value.0..header.value.1));\n\n            match name {\n                header::TRANSFER_ENCODING => {\n                    // https://tools.ietf.org/html/rfc7230#section-3.3.3\n                    // If Transfer-Encoding header is present, and 'chunked' is\n                    // not the final encoding, and this is a Request, then it is\n                    // malformed. A server should respond with 400 Bad Request.\n                    if !is_http_11 {\n                        debug!(\"HTTP/1.0 cannot have Transfer-Encoding header\");\n                        return Err(Parse::Header);\n                    }\n                    is_te = true;\n                    if headers::is_chunked_(&value) {\n                        is_te_chunked = true;\n                        decoder = DecodedLength::CHUNKED;\n                    }\n                }\n                header::CONTENT_LENGTH => {\n                    if is_te {\n                        continue;\n                    }\n                    let len = value\n                        .to_str()\n                        .map_err(|_| Parse::Header)\n                        .and_then(|s| s.parse().map_err(|_| Parse::Header))?;\n                    if let Some(prev) = con_len {\n                        if prev != len {\n                            debug!(\n                                \"multiple Content-Length headers with different values: [{}, {}]\",\n                                prev, len,\n                            );\n                            return Err(Parse::Header);\n                        }\n                        // we don't need to append this secondary length\n                        continue;\n                    }\n                    decoder = DecodedLength::checked_new(len)?;\n                    con_len = Some(len);\n                }\n                header::CONNECTION => {\n                    // keep_alive was previously set to default for Version\n                    if keep_alive {\n                        // HTTP/1.1\n                        keep_alive = !headers::connection_close(&value);\n                    } else {\n                        // HTTP/1.0\n                        keep_alive = headers::connection_keep_alive(&value);\n                    }\n                }\n                header::EXPECT => {\n                    expect_continue = value.as_bytes() == b\"100-continue\";\n                }\n                header::UPGRADE => {\n                    // Upgrades are only allowed with HTTP/1.1\n                    wants_upgrade = is_http_11;\n                }\n\n                _ => (),\n            }\n\n            headers.append(name, value);\n        }\n\n        if is_te && !is_te_chunked {\n            debug!(\"request with transfer-encoding header, but not chunked, bad request\");\n            return Err(Parse::Header);\n        }\n\n        *ctx.req_method = Some(subject.0.clone());\n\n        Ok(Some(ParsedMessage {\n            head: MessageHead {\n                version,\n                subject,\n                headers,\n                extensions: http::Extensions::default(),\n            },\n            decode: decoder,\n            expect_continue,\n            keep_alive,\n            wants_upgrade,\n        }))\n    }\n\n    fn encode(\n        mut msg: Encode<'_, Self::Outgoing>,\n        mut dst: &mut Vec<u8>,\n    ) -> crate::Result<Encoder> {\n        trace!(\n            \"Server::encode status={:?}, body={:?}, req_method={:?}\",\n            msg.head.subject,\n            msg.body,\n            msg.req_method\n        );\n        debug_assert!(\n            !msg.title_case_headers,\n            \"no server config for title case headers\"\n        );\n\n        let mut wrote_len = false;\n\n        // hyper currently doesn't support returning 1xx status codes as a Response\n        // This is because Service only allows returning a single Response, and\n        // so if you try to reply with a e.g. 100 Continue, you have no way of\n        // replying with the latter status code response.\n        let (ret, mut is_last) = if msg.head.subject == StatusCode::SWITCHING_PROTOCOLS {\n            (Ok(()), true)\n        } else if msg.req_method == &Some(Method::CONNECT) && msg.head.subject.is_success() {\n            // Sending content-length or transfer-encoding header on 2xx response\n            // to CONNECT is forbidden in RFC 7231.\n            wrote_len = true;\n            (Ok(()), true)\n        } else if msg.head.subject.is_informational() {\n            warn!(\"response with 1xx status code not supported\");\n            *msg.head = MessageHead::default();\n            msg.head.subject = StatusCode::INTERNAL_SERVER_ERROR;\n            msg.body = None;\n            (Err(crate::Error::new_user_unsupported_status_code()), true)\n        } else {\n            (Ok(()), !msg.keep_alive)\n        };\n\n        // In some error cases, we don't know about the invalid message until already\n        // pushing some bytes onto the `dst`. In those cases, we don't want to send\n        // the half-pushed message, so rewind to before.\n        let orig_len = dst.len();\n        let rewind = |dst: &mut Vec<u8>| {\n            dst.truncate(orig_len);\n        };\n\n        let init_cap = 30 + msg.head.headers.len() * AVERAGE_HEADER_SIZE;\n        dst.reserve(init_cap);\n        if msg.head.version == Version::HTTP_11 && msg.head.subject == StatusCode::OK {\n            extend(dst, b\"HTTP/1.1 200 OK\\r\\n\");\n        } else {\n            match msg.head.version {\n                Version::HTTP_10 => extend(dst, b\"HTTP/1.0 \"),\n                Version::HTTP_11 => extend(dst, b\"HTTP/1.1 \"),\n                Version::HTTP_2 => {\n                    debug!(\"response with HTTP2 version coerced to HTTP/1.1\");\n                    extend(dst, b\"HTTP/1.1 \");\n                }\n                other => panic!(\"unexpected response version: {:?}\", other),\n            }\n\n            extend(dst, msg.head.subject.as_str().as_bytes());\n            extend(dst, b\" \");\n            // a reason MUST be written, as many parsers will expect it.\n            extend(\n                dst,\n                msg.head\n                    .subject\n                    .canonical_reason()\n                    .unwrap_or(\"<none>\")\n                    .as_bytes(),\n            );\n            extend(dst, b\"\\r\\n\");\n        }\n\n        let mut encoder = Encoder::length(0);\n        let mut wrote_date = false;\n        let mut cur_name = None;\n        let mut is_name_written = false;\n        let mut must_write_chunked = false;\n        let mut prev_con_len = None;\n\n        macro_rules! handle_is_name_written {\n            () => {{\n                if is_name_written {\n                    // we need to clean up and write the newline\n                    debug_assert_ne!(\n                        &dst[dst.len() - 2..],\n                        b\"\\r\\n\",\n                        \"previous header wrote newline but set is_name_written\"\n                    );\n\n                    if must_write_chunked {\n                        extend(dst, b\", chunked\\r\\n\");\n                    } else {\n                        extend(dst, b\"\\r\\n\");\n                    }\n                }\n            }};\n        }\n\n        'headers: for (opt_name, value) in msg.head.headers.drain() {\n            if let Some(n) = opt_name {\n                cur_name = Some(n);\n                handle_is_name_written!();\n                is_name_written = false;\n            }\n            let name = cur_name.as_ref().expect(\"current header name\");\n            match *name {\n                header::CONTENT_LENGTH => {\n                    if wrote_len && !is_name_written {\n                        warn!(\"unexpected content-length found, canceling\");\n                        rewind(dst);\n                        return Err(crate::Error::new_user_header());\n                    }\n                    match msg.body {\n                        Some(BodyLength::Known(known_len)) => {\n                            // The HttpBody claims to know a length, and\n                            // the headers are already set. For performance\n                            // reasons, we are just going to trust that\n                            // the values match.\n                            //\n                            // In debug builds, we'll assert they are the\n                            // same to help developers find bugs.\n                            #[cfg(debug_assertions)]\n                            {\n                                if let Some(len) = headers::content_length_parse(&value) {\n                                    assert!(\n                                        len == known_len,\n                                        \"payload claims content-length of {}, custom content-length header claims {}\",\n                                        known_len,\n                                        len,\n                                    );\n                                }\n                            }\n\n                            if !is_name_written {\n                                encoder = Encoder::length(known_len);\n                                extend(dst, b\"content-length: \");\n                                extend(dst, value.as_bytes());\n                                wrote_len = true;\n                                is_name_written = true;\n                            }\n                            continue 'headers;\n                        }\n                        Some(BodyLength::Unknown) => {\n                            // The HttpBody impl didn't know how long the\n                            // body is, but a length header was included.\n                            // We have to parse the value to return our\n                            // Encoder...\n\n                            if let Some(len) = headers::content_length_parse(&value) {\n                                if let Some(prev) = prev_con_len {\n                                    if prev != len {\n                                        warn!(\n                                            \"multiple Content-Length values found: [{}, {}]\",\n                                            prev, len\n                                        );\n                                        rewind(dst);\n                                        return Err(crate::Error::new_user_header());\n                                    }\n                                    debug_assert!(is_name_written);\n                                    continue 'headers;\n                                } else {\n                                    // we haven't written content-length yet!\n                                    encoder = Encoder::length(len);\n                                    extend(dst, b\"content-length: \");\n                                    extend(dst, value.as_bytes());\n                                    wrote_len = true;\n                                    is_name_written = true;\n                                    prev_con_len = Some(len);\n                                    continue 'headers;\n                                }\n                            } else {\n                                warn!(\"illegal Content-Length value: {:?}\", value);\n                                rewind(dst);\n                                return Err(crate::Error::new_user_header());\n                            }\n                        }\n                        None => {\n                            // We have no body to actually send,\n                            // but the headers claim a content-length.\n                            // There's only 2 ways this makes sense:\n                            //\n                            // - The header says the length is `0`.\n                            // - This is a response to a `HEAD` request.\n                            if msg.req_method == &Some(Method::HEAD) {\n                                debug_assert_eq!(encoder, Encoder::length(0));\n                            } else {\n                                if value.as_bytes() != b\"0\" {\n                                    warn!(\n                                        \"content-length value found, but empty body provided: {:?}\",\n                                        value\n                                    );\n                                }\n                                continue 'headers;\n                            }\n                        }\n                    }\n                    wrote_len = true;\n                }\n                header::TRANSFER_ENCODING => {\n                    if wrote_len && !is_name_written {\n                        warn!(\"unexpected transfer-encoding found, canceling\");\n                        rewind(dst);\n                        return Err(crate::Error::new_user_header());\n                    }\n                    // check that we actually can send a chunked body...\n                    if msg.head.version == Version::HTTP_10\n                        || !Server::can_chunked(msg.req_method, msg.head.subject)\n                    {\n                        continue;\n                    }\n                    wrote_len = true;\n                    // Must check each value, because `chunked` needs to be the\n                    // last encoding, or else we add it.\n                    must_write_chunked = !headers::is_chunked_(&value);\n\n                    if !is_name_written {\n                        encoder = Encoder::chunked();\n                        is_name_written = true;\n                        extend(dst, b\"transfer-encoding: \");\n                        extend(dst, value.as_bytes());\n                    } else {\n                        extend(dst, b\", \");\n                        extend(dst, value.as_bytes());\n                    }\n                    continue 'headers;\n                }\n                header::CONNECTION => {\n                    if !is_last && headers::connection_close(&value) {\n                        is_last = true;\n                    }\n                    if !is_name_written {\n                        is_name_written = true;\n                        extend(dst, b\"connection: \");\n                        extend(dst, value.as_bytes());\n                    } else {\n                        extend(dst, b\", \");\n                        extend(dst, value.as_bytes());\n                    }\n                    continue 'headers;\n                }\n                header::DATE => {\n                    wrote_date = true;\n                }\n                _ => (),\n            }\n            //TODO: this should perhaps instead combine them into\n            //single lines, as RFC7230 suggests is preferable.\n\n            // non-special write Name and Value\n            debug_assert!(\n                !is_name_written,\n                \"{:?} set is_name_written and didn't continue loop\",\n                name,\n            );\n            extend(dst, name.as_str().as_bytes());\n            extend(dst, b\": \");\n            extend(dst, value.as_bytes());\n            extend(dst, b\"\\r\\n\");\n        }\n\n        handle_is_name_written!();\n\n        if !wrote_len {\n            encoder = match msg.body {\n                Some(BodyLength::Unknown) => {\n                    if msg.head.version == Version::HTTP_10\n                        || !Server::can_chunked(msg.req_method, msg.head.subject)\n                    {\n                        Encoder::close_delimited()\n                    } else {\n                        extend(dst, b\"transfer-encoding: chunked\\r\\n\");\n                        Encoder::chunked()\n                    }\n                }\n                None | Some(BodyLength::Known(0)) => {\n                    if msg.head.subject != StatusCode::NOT_MODIFIED {\n                        extend(dst, b\"content-length: 0\\r\\n\");\n                    }\n                    Encoder::length(0)\n                }\n                Some(BodyLength::Known(len)) => {\n                    if msg.head.subject == StatusCode::NOT_MODIFIED {\n                        Encoder::length(0)\n                    } else {\n                        extend(dst, b\"content-length: \");\n                        let _ = ::itoa::write(&mut dst, len);\n                        extend(dst, b\"\\r\\n\");\n                        Encoder::length(len)\n                    }\n                }\n            };\n        }\n\n        if !Server::can_have_body(msg.req_method, msg.head.subject) {\n            trace!(\n                \"server body forced to 0; method={:?}, status={:?}\",\n                msg.req_method,\n                msg.head.subject\n            );\n            encoder = Encoder::length(0);\n        }\n\n        // cached date is much faster than formatting every request\n        if !wrote_date {\n            dst.reserve(date::DATE_VALUE_LENGTH + 8);\n            extend(dst, b\"date: \");\n            date::extend(dst);\n            extend(dst, b\"\\r\\n\\r\\n\");\n        } else {\n            extend(dst, b\"\\r\\n\");\n        }\n\n        ret.map(|()| encoder.set_last(is_last))\n    }\n\n    fn on_error(err: &crate::Error) -> Option<MessageHead<Self::Outgoing>> {\n        use crate::error::Kind;\n        let status = match *err.kind() {\n            Kind::Parse(Parse::Method)\n            | Kind::Parse(Parse::Header)\n            | Kind::Parse(Parse::Uri)\n            | Kind::Parse(Parse::Version) => StatusCode::BAD_REQUEST,\n            Kind::Parse(Parse::TooLarge) => StatusCode::REQUEST_HEADER_FIELDS_TOO_LARGE,\n            _ => return None,\n        };\n\n        debug!(\"sending automatic response ({}) for parse error\", status);\n        let mut msg = MessageHead::default();\n        msg.subject = status;\n        Some(msg)\n    }\n\n    fn is_server() -> bool {\n        true\n    }\n\n    fn update_date() {\n        date::update();\n    }\n}\n\n#[cfg(feature = \"server\")]\nimpl Server {\n    fn can_have_body(method: &Option<Method>, status: StatusCode) -> bool {\n        Server::can_chunked(method, status)\n    }\n\n    fn can_chunked(method: &Option<Method>, status: StatusCode) -> bool {\n        if method == &Some(Method::HEAD) || method == &Some(Method::CONNECT) && status.is_success()\n        {\n            false\n        } else {\n            match status {\n                // TODO: support for 1xx codes needs improvement everywhere\n                // would be 100...199 => false\n                StatusCode::SWITCHING_PROTOCOLS\n                | StatusCode::NO_CONTENT\n                | StatusCode::NOT_MODIFIED => false,\n                _ => true,\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"client\")]\nimpl Http1Transaction for Client {\n    type Incoming = StatusCode;\n    type Outgoing = RequestLine;\n    const LOG: &'static str = \"{role=client}\";\n\n    fn parse(buf: &mut BytesMut, ctx: ParseContext<'_>) -> ParseResult<StatusCode> {\n        debug_assert!(!buf.is_empty(), \"parse called with empty buf\");\n\n        // Loop to skip information status code headers (100 Continue, etc).\n        loop {\n            // Unsafe: see comment in Server Http1Transaction, above.\n            let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };\n            let (len, status, reason, version, headers_len) = {\n                let mut headers: [httparse::Header<'_>; MAX_HEADERS] =\n                    unsafe { mem::uninitialized() };\n                trace!(\n                    \"Response.parse([Header; {}], [u8; {}])\",\n                    headers.len(),\n                    buf.len()\n                );\n                let mut res = httparse::Response::new(&mut headers);\n                let bytes = buf.as_ref();\n                match res.parse(bytes)? {\n                    httparse::Status::Complete(len) => {\n                        trace!(\"Response.parse Complete({})\", len);\n                        let status = StatusCode::from_u16(res.code.unwrap())?;\n\n                        #[cfg(not(feature = \"ffi\"))]\n                        let reason = ();\n                        #[cfg(feature = \"ffi\")]\n                        let reason = {\n                            let reason = res.reason.unwrap();\n                            // Only save the reason phrase if it isnt the canonical reason\n                            if Some(reason) != status.canonical_reason() {\n                                Some(Bytes::copy_from_slice(reason.as_bytes()))\n                            } else {\n                                None\n                            }\n                        };\n\n                        let version = if res.version.unwrap() == 1 {\n                            Version::HTTP_11\n                        } else {\n                            Version::HTTP_10\n                        };\n                        record_header_indices(bytes, &res.headers, &mut headers_indices)?;\n                        let headers_len = res.headers.len();\n                        (len, status, reason, version, headers_len)\n                    }\n                    httparse::Status::Partial => return Ok(None),\n                }\n            };\n\n            let slice = buf.split_to(len).freeze();\n\n            let mut headers = ctx.cached_headers.take().unwrap_or_else(HeaderMap::new);\n\n            let mut keep_alive = version == Version::HTTP_11;\n\n            #[cfg(feature = \"ffi\")]\n            let mut header_case_map = crate::ffi::HeaderCaseMap::default();\n\n            headers.reserve(headers_len);\n            for header in &headers_indices[..headers_len] {\n                let name = header_name!(&slice[header.name.0..header.name.1]);\n                let value = header_value!(slice.slice(header.value.0..header.value.1));\n\n                if let header::CONNECTION = name {\n                    // keep_alive was previously set to default for Version\n                    if keep_alive {\n                        // HTTP/1.1\n                        keep_alive = !headers::connection_close(&value);\n                    } else {\n                        // HTTP/1.0\n                        keep_alive = headers::connection_keep_alive(&value);\n                    }\n                }\n\n                #[cfg(feature = \"ffi\")]\n                if ctx.preserve_header_case {\n                    header_case_map.append(&name, slice.slice(header.name.0..header.name.1));\n                }\n\n                headers.append(name, value);\n            }\n\n            #[allow(unused_mut)]\n            let mut extensions = http::Extensions::default();\n\n            #[cfg(feature = \"ffi\")]\n            if ctx.preserve_header_case {\n                extensions.insert(header_case_map);\n            }\n\n            #[cfg(feature = \"ffi\")]\n            if let Some(reason) = reason {\n                extensions.insert(crate::ffi::ReasonPhrase(reason));\n            }\n            #[cfg(not(feature = \"ffi\"))]\n            drop(reason);\n\n            let head = MessageHead {\n                version,\n                subject: status,\n                headers,\n                extensions,\n            };\n            if let Some((decode, is_upgrade)) = Client::decoder(&head, ctx.req_method)? {\n                return Ok(Some(ParsedMessage {\n                    head,\n                    decode,\n                    expect_continue: false,\n                    // a client upgrade means the connection can't be used\n                    // again, as it is definitely upgrading.\n                    keep_alive: keep_alive && !is_upgrade,\n                    wants_upgrade: is_upgrade,\n                }));\n            }\n\n            // Parsing a 1xx response could have consumed the buffer, check if\n            // it is empty now...\n            if buf.is_empty() {\n                return Ok(None);\n            }\n        }\n    }\n\n    fn encode(msg: Encode<'_, Self::Outgoing>, dst: &mut Vec<u8>) -> crate::Result<Encoder> {\n        trace!(\n            \"Client::encode method={:?}, body={:?}\",\n            msg.head.subject.0,\n            msg.body\n        );\n\n        *msg.req_method = Some(msg.head.subject.0.clone());\n\n        let body = Client::set_length(msg.head, msg.body);\n\n        let init_cap = 30 + msg.head.headers.len() * AVERAGE_HEADER_SIZE;\n        dst.reserve(init_cap);\n\n        extend(dst, msg.head.subject.0.as_str().as_bytes());\n        extend(dst, b\" \");\n        //TODO: add API to http::Uri to encode without std::fmt\n        let _ = write!(FastWrite(dst), \"{} \", msg.head.subject.1);\n\n        match msg.head.version {\n            Version::HTTP_10 => extend(dst, b\"HTTP/1.0\"),\n            Version::HTTP_11 => extend(dst, b\"HTTP/1.1\"),\n            Version::HTTP_2 => {\n                debug!(\"request with HTTP2 version coerced to HTTP/1.1\");\n                extend(dst, b\"HTTP/1.1\");\n            }\n            other => panic!(\"unexpected request version: {:?}\", other),\n        }\n        extend(dst, b\"\\r\\n\");\n\n        #[cfg(feature = \"ffi\")]\n        {\n            if msg.title_case_headers {\n                write_headers_title_case(&msg.head.headers, dst);\n            } else if let Some(orig_headers) =\n                msg.head.extensions.get::<crate::ffi::HeaderCaseMap>()\n            {\n                write_headers_original_case(&msg.head.headers, orig_headers, dst);\n            } else {\n                write_headers(&msg.head.headers, dst);\n            }\n        }\n\n        #[cfg(not(feature = \"ffi\"))]\n        {\n            if msg.title_case_headers {\n                write_headers_title_case(&msg.head.headers, dst);\n            } else {\n                write_headers(&msg.head.headers, dst);\n            }\n        }\n\n        extend(dst, b\"\\r\\n\");\n        msg.head.headers.clear(); //TODO: remove when switching to drain()\n\n        Ok(body)\n    }\n\n    fn on_error(_err: &crate::Error) -> Option<MessageHead<Self::Outgoing>> {\n        // we can't tell the server about any errors it creates\n        None\n    }\n\n    fn is_client() -> bool {\n        true\n    }\n}\n\n#[cfg(feature = \"client\")]\nimpl Client {\n    /// Returns Some(length, wants_upgrade) if successful.\n    ///\n    /// Returns None if this message head should be skipped (like a 100 status).\n    fn decoder(\n        inc: &MessageHead<StatusCode>,\n        method: &mut Option<Method>,\n    ) -> Result<Option<(DecodedLength, bool)>, Parse> {\n        // According to https://tools.ietf.org/html/rfc7230#section-3.3.3\n        // 1. HEAD responses, and Status 1xx, 204, and 304 cannot have a body.\n        // 2. Status 2xx to a CONNECT cannot have a body.\n        // 3. Transfer-Encoding: chunked has a chunked body.\n        // 4. If multiple differing Content-Length headers or invalid, close connection.\n        // 5. Content-Length header has a sized body.\n        // 6. (irrelevant to Response)\n        // 7. Read till EOF.\n\n        match inc.subject.as_u16() {\n            101 => {\n                return Ok(Some((DecodedLength::ZERO, true)));\n            }\n            100 | 102..=199 => {\n                trace!(\"ignoring informational response: {}\", inc.subject.as_u16());\n                return Ok(None);\n            }\n            204 | 304 => return Ok(Some((DecodedLength::ZERO, false))),\n            _ => (),\n        }\n        match *method {\n            Some(Method::HEAD) => {\n                return Ok(Some((DecodedLength::ZERO, false)));\n            }\n            Some(Method::CONNECT) => {\n                if let 200..=299 = inc.subject.as_u16() {\n                    return Ok(Some((DecodedLength::ZERO, true)));\n                }\n            }\n            Some(_) => {}\n            None => {\n                trace!(\"Client::decoder is missing the Method\");\n            }\n        }\n\n        if inc.headers.contains_key(header::TRANSFER_ENCODING) {\n            // https://tools.ietf.org/html/rfc7230#section-3.3.3\n            // If Transfer-Encoding header is present, and 'chunked' is\n            // not the final encoding, and this is a Request, then it is\n            // malformed. A server should respond with 400 Bad Request.\n            if inc.version == Version::HTTP_10 {\n                debug!(\"HTTP/1.0 cannot have Transfer-Encoding header\");\n                Err(Parse::Header)\n            } else if headers::transfer_encoding_is_chunked(&inc.headers) {\n                Ok(Some((DecodedLength::CHUNKED, false)))\n            } else {\n                trace!(\"not chunked, read till eof\");\n                Ok(Some((DecodedLength::CLOSE_DELIMITED, false)))\n            }\n        } else if let Some(len) = headers::content_length_parse_all(&inc.headers) {\n            Ok(Some((DecodedLength::checked_new(len)?, false)))\n        } else if inc.headers.contains_key(header::CONTENT_LENGTH) {\n            debug!(\"illegal Content-Length header\");\n            Err(Parse::Header)\n        } else {\n            trace!(\"neither Transfer-Encoding nor Content-Length\");\n            Ok(Some((DecodedLength::CLOSE_DELIMITED, false)))\n        }\n    }\n    fn set_length(head: &mut RequestHead, body: Option<BodyLength>) -> Encoder {\n        let body = if let Some(body) = body {\n            body\n        } else {\n            head.headers.remove(header::TRANSFER_ENCODING);\n            return Encoder::length(0);\n        };\n\n        // HTTP/1.0 doesn't know about chunked\n        let can_chunked = head.version == Version::HTTP_11;\n        let headers = &mut head.headers;\n\n        // If the user already set specific headers, we should respect them, regardless\n        // of what the HttpBody knows about itself. They set them for a reason.\n\n        // Because of the borrow checker, we can't check the for an existing\n        // Content-Length header while holding an `Entry` for the Transfer-Encoding\n        // header, so unfortunately, we must do the check here, first.\n\n        let existing_con_len = headers::content_length_parse_all(headers);\n        let mut should_remove_con_len = false;\n\n        if !can_chunked {\n            // Chunked isn't legal, so if it is set, we need to remove it.\n            if headers.remove(header::TRANSFER_ENCODING).is_some() {\n                trace!(\"removing illegal transfer-encoding header\");\n            }\n\n            return if let Some(len) = existing_con_len {\n                Encoder::length(len)\n            } else if let BodyLength::Known(len) = body {\n                set_content_length(headers, len)\n            } else {\n                // HTTP/1.0 client requests without a content-length\n                // cannot have any body at all.\n                Encoder::length(0)\n            };\n        }\n\n        // If the user set a transfer-encoding, respect that. Let's just\n        // make sure `chunked` is the final encoding.\n        let encoder = match headers.entry(header::TRANSFER_ENCODING) {\n            Entry::Occupied(te) => {\n                should_remove_con_len = true;\n                if headers::is_chunked(te.iter()) {\n                    Some(Encoder::chunked())\n                } else {\n                    warn!(\"user provided transfer-encoding does not end in 'chunked'\");\n\n                    // There's a Transfer-Encoding, but it doesn't end in 'chunked'!\n                    // An example that could trigger this:\n                    //\n                    //     Transfer-Encoding: gzip\n                    //\n                    // This can be bad, depending on if this is a request or a\n                    // response.\n                    //\n                    // - A request is illegal if there is a `Transfer-Encoding`\n                    //   but it doesn't end in `chunked`.\n                    // - A response that has `Transfer-Encoding` but doesn't\n                    //   end in `chunked` isn't illegal, it just forces this\n                    //   to be close-delimited.\n                    //\n                    // We can try to repair this, by adding `chunked` ourselves.\n\n                    headers::add_chunked(te);\n                    Some(Encoder::chunked())\n                }\n            }\n            Entry::Vacant(te) => {\n                if let Some(len) = existing_con_len {\n                    Some(Encoder::length(len))\n                } else if let BodyLength::Unknown = body {\n                    // GET, HEAD, and CONNECT almost never have bodies.\n                    //\n                    // So instead of sending a \"chunked\" body with a 0-chunk,\n                    // assume no body here. If you *must* send a body,\n                    // set the headers explicitly.\n                    match head.subject.0 {\n                        Method::GET | Method::HEAD | Method::CONNECT => Some(Encoder::length(0)),\n                        _ => {\n                            te.insert(HeaderValue::from_static(\"chunked\"));\n                            Some(Encoder::chunked())\n                        }\n                    }\n                } else {\n                    None\n                }\n            }\n        };\n\n        // This is because we need a second mutable borrow to remove\n        // content-length header.\n        if let Some(encoder) = encoder {\n            if should_remove_con_len && existing_con_len.is_some() {\n                headers.remove(header::CONTENT_LENGTH);\n            }\n            return encoder;\n        }\n\n        // User didn't set transfer-encoding, AND we know body length,\n        // so we can just set the Content-Length automatically.\n\n        let len = if let BodyLength::Known(len) = body {\n            len\n        } else {\n            unreachable!(\"BodyLength::Unknown would set chunked\");\n        };\n\n        set_content_length(headers, len)\n    }\n}\n\nfn set_content_length(headers: &mut HeaderMap, len: u64) -> Encoder {\n    // At this point, there should not be a valid Content-Length\n    // header. However, since we'll be indexing in anyways, we can\n    // warn the user if there was an existing illegal header.\n    //\n    // Or at least, we can in theory. It's actually a little bit slower,\n    // so perhaps only do that while the user is developing/testing.\n\n    if cfg!(debug_assertions) {\n        match headers.entry(header::CONTENT_LENGTH) {\n            Entry::Occupied(mut cl) => {\n                // Internal sanity check, we should have already determined\n                // that the header was illegal before calling this function.\n                debug_assert!(headers::content_length_parse_all_values(cl.iter()).is_none());\n                // Uh oh, the user set `Content-Length` headers, but set bad ones.\n                // This would be an illegal message anyways, so let's try to repair\n                // with our known good length.\n                error!(\"user provided content-length header was invalid\");\n\n                cl.insert(HeaderValue::from(len));\n                Encoder::length(len)\n            }\n            Entry::Vacant(cl) => {\n                cl.insert(HeaderValue::from(len));\n                Encoder::length(len)\n            }\n        }\n    } else {\n        headers.insert(header::CONTENT_LENGTH, HeaderValue::from(len));\n        Encoder::length(len)\n    }\n}\n\n#[derive(Clone, Copy)]\nstruct HeaderIndices {\n    name: (usize, usize),\n    value: (usize, usize),\n}\n\nfn record_header_indices(\n    bytes: &[u8],\n    headers: &[httparse::Header<'_>],\n    indices: &mut [HeaderIndices],\n) -> Result<(), crate::error::Parse> {\n    let bytes_ptr = bytes.as_ptr() as usize;\n\n    for (header, indices) in headers.iter().zip(indices.iter_mut()) {\n        if header.name.len() >= (1 << 16) {\n            debug!(\"header name larger than 64kb: {:?}\", header.name);\n            return Err(crate::error::Parse::TooLarge);\n        }\n        let name_start = header.name.as_ptr() as usize - bytes_ptr;\n        let name_end = name_start + header.name.len();\n        indices.name = (name_start, name_end);\n        let value_start = header.value.as_ptr() as usize - bytes_ptr;\n        let value_end = value_start + header.value.len();\n        indices.value = (value_start, value_end);\n    }\n\n    Ok(())\n}\n\n// Write header names as title case. The header name is assumed to be ASCII,\n// therefore it is trivial to convert an ASCII character from lowercase to\n// uppercase. It is as simple as XORing the lowercase character byte with\n// space.\nfn title_case(dst: &mut Vec<u8>, name: &[u8]) {\n    dst.reserve(name.len());\n\n    let mut iter = name.iter();\n\n    // Uppercase the first character\n    if let Some(c) = iter.next() {\n        if *c >= b'a' && *c <= b'z' {\n            dst.push(*c ^ b' ');\n        } else {\n            dst.push(*c);\n        }\n    }\n\n    while let Some(c) = iter.next() {\n        dst.push(*c);\n\n        if *c == b'-' {\n            if let Some(c) = iter.next() {\n                if *c >= b'a' && *c <= b'z' {\n                    dst.push(*c ^ b' ');\n                } else {\n                    dst.push(*c);\n                }\n            }\n        }\n    }\n}\n\nfn write_headers_title_case(headers: &HeaderMap, dst: &mut Vec<u8>) {\n    for (name, value) in headers {\n        title_case(dst, name.as_str().as_bytes());\n        extend(dst, b\": \");\n        extend(dst, value.as_bytes());\n        extend(dst, b\"\\r\\n\");\n    }\n}\n\nfn write_headers(headers: &HeaderMap, dst: &mut Vec<u8>) {\n    for (name, value) in headers {\n        extend(dst, name.as_str().as_bytes());\n        extend(dst, b\": \");\n        extend(dst, value.as_bytes());\n        extend(dst, b\"\\r\\n\");\n    }\n}\n\n#[cfg(feature = \"ffi\")]\n#[cold]\nfn write_headers_original_case(\n    headers: &HeaderMap,\n    orig_case: &crate::ffi::HeaderCaseMap,\n    dst: &mut Vec<u8>,\n) {\n    // For each header name/value pair, there may be a value in the casemap\n    // that corresponds to the HeaderValue. So, we iterator all the keys,\n    // and for each one, try to pair the originally cased name with the value.\n    //\n    // TODO: consider adding http::HeaderMap::entries() iterator\n    for name in headers.keys() {\n        let mut names = orig_case.get_all(name).iter();\n\n        for value in headers.get_all(name) {\n            if let Some(orig_name) = names.next() {\n                extend(dst, orig_name);\n            } else {\n                extend(dst, name.as_str().as_bytes());\n            }\n\n            // Wanted for curl test cases that send `X-Custom-Header:\\r\\n`\n            if value.is_empty() {\n                extend(dst, b\":\\r\\n\");\n            } else {\n                extend(dst, b\": \");\n                extend(dst, value.as_bytes());\n                extend(dst, b\"\\r\\n\");\n            }\n        }\n    }\n}\n\nstruct FastWrite<'a>(&'a mut Vec<u8>);\n\nimpl<'a> fmt::Write for FastWrite<'a> {\n    #[inline]\n    fn write_str(&mut self, s: &str) -> fmt::Result {\n        extend(self.0, s.as_bytes());\n        Ok(())\n    }\n\n    #[inline]\n    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> fmt::Result {\n        fmt::write(self, args)\n    }\n}\n\n#[inline]\nfn extend(dst: &mut Vec<u8>, data: &[u8]) {\n    dst.extend_from_slice(data);\n}\n\n#[cfg(test)]\nmod tests {\n    use bytes::BytesMut;\n\n    use super::*;\n\n    #[test]\n    fn test_parse_request() {\n        let _ = pretty_env_logger::try_init();\n        let mut raw = BytesMut::from(\"GET /echo HTTP/1.1\\r\\nHost: hyper.rs\\r\\n\\r\\n\");\n        let mut method = None;\n        let msg = Server::parse(\n            &mut raw,\n            ParseContext {\n                cached_headers: &mut None,\n                req_method: &mut method,\n                #[cfg(feature = \"ffi\")]\n                preserve_header_case: false,\n            },\n        )\n        .unwrap()\n        .unwrap();\n        assert_eq!(raw.len(), 0);\n        assert_eq!(msg.head.subject.0, crate::Method::GET);\n        assert_eq!(msg.head.subject.1, \"/echo\");\n        assert_eq!(msg.head.version, crate::Version::HTTP_11);\n        assert_eq!(msg.head.headers.len(), 1);\n        assert_eq!(msg.head.headers[\"Host\"], \"hyper.rs\");\n        assert_eq!(method, Some(crate::Method::GET));\n    }\n\n    #[test]\n    fn test_parse_response() {\n        let _ = pretty_env_logger::try_init();\n        let mut raw = BytesMut::from(\"HTTP/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\");\n        let ctx = ParseContext {\n            cached_headers: &mut None,\n            req_method: &mut Some(crate::Method::GET),\n            #[cfg(feature = \"ffi\")]\n            preserve_header_case: false,\n        };\n        let msg = Client::parse(&mut raw, ctx).unwrap().unwrap();\n        assert_eq!(raw.len(), 0);\n        assert_eq!(msg.head.subject, crate::StatusCode::OK);\n        assert_eq!(msg.head.version, crate::Version::HTTP_11);\n        assert_eq!(msg.head.headers.len(), 1);\n        assert_eq!(msg.head.headers[\"Content-Length\"], \"0\");\n    }\n\n    #[test]\n    fn test_parse_request_errors() {\n        let mut raw = BytesMut::from(\"GET htt:p// HTTP/1.1\\r\\nHost: hyper.rs\\r\\n\\r\\n\");\n        let ctx = ParseContext {\n            cached_headers: &mut None,\n            req_method: &mut None,\n            #[cfg(feature = \"ffi\")]\n            preserve_header_case: false,\n        };\n        Server::parse(&mut raw, ctx).unwrap_err();\n    }\n\n    #[test]\n    fn test_decoder_request() {\n        fn parse(s: &str) -> ParsedMessage<RequestLine> {\n            let mut bytes = BytesMut::from(s);\n            Server::parse(\n                &mut bytes,\n                ParseContext {\n                    cached_headers: &mut None,\n                    req_method: &mut None,\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                },\n            )\n            .expect(\"parse ok\")\n            .expect(\"parse complete\")\n        }\n\n        fn parse_err(s: &str, comment: &str) -> crate::error::Parse {\n            let mut bytes = BytesMut::from(s);\n            Server::parse(\n                &mut bytes,\n                ParseContext {\n                    cached_headers: &mut None,\n                    req_method: &mut None,\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                },\n            )\n            .expect_err(comment)\n        }\n\n        // no length or transfer-encoding means 0-length body\n        assert_eq!(\n            parse(\n                \"\\\n                 GET / HTTP/1.1\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::ZERO\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::ZERO\n        );\n\n        // transfer-encoding: chunked\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 transfer-encoding: gzip, chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 transfer-encoding: gzip\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        // content-length\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::new(10)\n        );\n\n        // transfer-encoding and content-length = chunked\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 transfer-encoding: gzip\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        // multiple content-lengths of same value are fine\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::new(10)\n        );\n\n        // multiple content-lengths with different values is an error\n        parse_err(\n            \"\\\n             POST / HTTP/1.1\\r\\n\\\n             content-length: 10\\r\\n\\\n             content-length: 11\\r\\n\\\n             \\r\\n\\\n             \",\n            \"multiple content-lengths\",\n        );\n\n        // transfer-encoding that isn't chunked is an error\n        parse_err(\n            \"\\\n             POST / HTTP/1.1\\r\\n\\\n             transfer-encoding: gzip\\r\\n\\\n             \\r\\n\\\n             \",\n            \"transfer-encoding but not chunked\",\n        );\n\n        parse_err(\n            \"\\\n             POST / HTTP/1.1\\r\\n\\\n             transfer-encoding: chunked, gzip\\r\\n\\\n             \\r\\n\\\n             \",\n            \"transfer-encoding doesn't end in chunked\",\n        );\n\n        // http/1.0\n\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.0\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::new(10)\n        );\n\n        // 1.0 doesn't understand chunked, so its an error\n        parse_err(\n            \"\\\n             POST / HTTP/1.0\\r\\n\\\n             transfer-encoding: chunked\\r\\n\\\n             \\r\\n\\\n             \",\n            \"1.0 chunked\",\n        );\n    }\n\n    #[test]\n    fn test_decoder_response() {\n        fn parse(s: &str) -> ParsedMessage<StatusCode> {\n            parse_with_method(s, Method::GET)\n        }\n\n        fn parse_ignores(s: &str) {\n            let mut bytes = BytesMut::from(s);\n            assert!(Client::parse(\n                &mut bytes,\n                ParseContext {\n                    cached_headers: &mut None,\n                    req_method: &mut Some(Method::GET),\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                }\n            )\n            .expect(\"parse ok\")\n            .is_none())\n        }\n\n        fn parse_with_method(s: &str, m: Method) -> ParsedMessage<StatusCode> {\n            let mut bytes = BytesMut::from(s);\n            Client::parse(\n                &mut bytes,\n                ParseContext {\n                    cached_headers: &mut None,\n                    req_method: &mut Some(m),\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                },\n            )\n            .expect(\"parse ok\")\n            .expect(\"parse complete\")\n        }\n\n        fn parse_err(s: &str) -> crate::error::Parse {\n            let mut bytes = BytesMut::from(s);\n            Client::parse(\n                &mut bytes,\n                ParseContext {\n                    cached_headers: &mut None,\n                    req_method: &mut Some(Method::GET),\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                },\n            )\n            .expect_err(\"parse should err\")\n        }\n\n        // no content-length or transfer-encoding means close-delimited\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CLOSE_DELIMITED\n        );\n\n        // 204 and 304 never have a body\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 204 No Content\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::ZERO\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 304 Not Modified\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::ZERO\n        );\n\n        // content-length\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 content-length: 8\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::new(8)\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 content-length: 8\\r\\n\\\n                 content-length: 8\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::new(8)\n        );\n\n        parse_err(\n            \"\\\n             HTTP/1.1 200 OK\\r\\n\\\n             content-length: 8\\r\\n\\\n             content-length: 9\\r\\n\\\n             \\r\\n\\\n             \",\n        );\n\n        // transfer-encoding: chunked\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        // transfer-encoding not-chunked is close-delimited\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 transfer-encoding: yolo\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CLOSE_DELIMITED\n        );\n\n        // transfer-encoding and content-length = chunked\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        // HEAD can have content-length, but not body\n        assert_eq!(\n            parse_with_method(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 content-length: 8\\r\\n\\\n                 \\r\\n\\\n                 \",\n                Method::HEAD\n            )\n            .decode,\n            DecodedLength::ZERO\n        );\n\n        // CONNECT with 200 never has body\n        {\n            let msg = parse_with_method(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 \\r\\n\\\n                 \",\n                Method::CONNECT,\n            );\n            assert_eq!(msg.decode, DecodedLength::ZERO);\n            assert!(!msg.keep_alive, \"should be upgrade\");\n            assert!(msg.wants_upgrade, \"should be upgrade\");\n        }\n\n        // CONNECT receiving non 200 can have a body\n        assert_eq!(\n            parse_with_method(\n                \"\\\n                 HTTP/1.1 400 Bad Request\\r\\n\\\n                 \\r\\n\\\n                 \",\n                Method::CONNECT\n            )\n            .decode,\n            DecodedLength::CLOSE_DELIMITED\n        );\n\n        // 1xx status codes\n        parse_ignores(\n            \"\\\n             HTTP/1.1 100 Continue\\r\\n\\\n             \\r\\n\\\n             \",\n        );\n\n        parse_ignores(\n            \"\\\n             HTTP/1.1 103 Early Hints\\r\\n\\\n             \\r\\n\\\n             \",\n        );\n\n        // 101 upgrade not supported yet\n        {\n            let msg = parse(\n                \"\\\n                 HTTP/1.1 101 Switching Protocols\\r\\n\\\n                 \\r\\n\\\n                 \",\n            );\n            assert_eq!(msg.decode, DecodedLength::ZERO);\n            assert!(!msg.keep_alive, \"should be last\");\n            assert!(msg.wants_upgrade, \"should be upgrade\");\n        }\n\n        // http/1.0\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.0 200 OK\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CLOSE_DELIMITED\n        );\n\n        // 1.0 doesn't understand chunked\n        parse_err(\n            \"\\\n             HTTP/1.0 200 OK\\r\\n\\\n             transfer-encoding: chunked\\r\\n\\\n             \\r\\n\\\n             \",\n        );\n\n        // keep-alive\n        assert!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 content-length: 0\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .keep_alive,\n            \"HTTP/1.1 keep-alive is default\"\n        );\n\n        assert!(\n            !parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 content-length: 0\\r\\n\\\n                 connection: foo, close, bar\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .keep_alive,\n            \"connection close is always close\"\n        );\n\n        assert!(\n            !parse(\n                \"\\\n                 HTTP/1.0 200 OK\\r\\n\\\n                 content-length: 0\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .keep_alive,\n            \"HTTP/1.0 close is default\"\n        );\n\n        assert!(\n            parse(\n                \"\\\n                 HTTP/1.0 200 OK\\r\\n\\\n                 content-length: 0\\r\\n\\\n                 connection: foo, keep-alive, bar\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .keep_alive,\n            \"connection keep-alive is always keep-alive\"\n        );\n    }\n\n    #[test]\n    fn test_client_request_encode_title_case() {\n        use crate::proto::BodyLength;\n        use http::header::HeaderValue;\n\n        let mut head = MessageHead::default();\n        head.headers\n            .insert(\"content-length\", HeaderValue::from_static(\"10\"));\n        head.headers\n            .insert(\"content-type\", HeaderValue::from_static(\"application/json\"));\n        head.headers.insert(\"*-*\", HeaderValue::from_static(\"o_o\"));\n\n        let mut vec = Vec::new();\n        Client::encode(\n            Encode {\n                head: &mut head,\n                body: Some(BodyLength::Known(10)),\n                keep_alive: true,\n                req_method: &mut None,\n                title_case_headers: true,\n            },\n            &mut vec,\n        )\n        .unwrap();\n\n        assert_eq!(vec, b\"GET / HTTP/1.1\\r\\nContent-Length: 10\\r\\nContent-Type: application/json\\r\\n*-*: o_o\\r\\n\\r\\n\".to_vec());\n    }\n\n    #[test]\n    fn test_server_encode_connect_method() {\n        let mut head = MessageHead::default();\n\n        let mut vec = Vec::new();\n        let encoder = Server::encode(\n            Encode {\n                head: &mut head,\n                body: None,\n                keep_alive: true,\n                req_method: &mut Some(Method::CONNECT),\n                title_case_headers: false,\n            },\n            &mut vec,\n        )\n        .unwrap();\n\n        assert!(encoder.is_last());\n    }\n\n    #[test]\n    fn parse_header_htabs() {\n        let mut bytes = BytesMut::from(\"HTTP/1.1 200 OK\\r\\nserver: hello\\tworld\\r\\n\\r\\n\");\n        let parsed = Client::parse(\n            &mut bytes,\n            ParseContext {\n                cached_headers: &mut None,\n                req_method: &mut Some(Method::GET),\n                #[cfg(feature = \"ffi\")]\n                preserve_header_case: false,\n            },\n        )\n        .expect(\"parse ok\")\n        .expect(\"parse complete\");\n\n        assert_eq!(parsed.head.headers[\"server\"], \"hello\\tworld\");\n    }\n\n    #[cfg(feature = \"ffi\")]\n    #[test]\n    fn test_write_headers_orig_case_empty_value() {\n        let mut headers = HeaderMap::new();\n        let name = http::header::HeaderName::from_static(\"x-empty\");\n        headers.insert(&name, \"\".parse().expect(\"parse empty\"));\n        let mut orig_cases = crate::ffi::HeaderCaseMap::default();\n        orig_cases.insert(name, Bytes::from_static(b\"X-EmptY\"));\n\n        let mut dst = Vec::new();\n        super::write_headers_original_case(&headers, &orig_cases, &mut dst);\n\n        assert_eq!(\n            dst, b\"X-EmptY:\\r\\n\",\n            \"there should be no space between the colon and CRLF\"\n        );\n    }\n\n    #[cfg(feature = \"ffi\")]\n    #[test]\n    fn test_write_headers_orig_case_multiple_entries() {\n        let mut headers = HeaderMap::new();\n        let name = http::header::HeaderName::from_static(\"x-empty\");\n        headers.insert(&name, \"a\".parse().unwrap());\n        headers.append(&name, \"b\".parse().unwrap());\n\n        let mut orig_cases = crate::ffi::HeaderCaseMap::default();\n        orig_cases.insert(name.clone(), Bytes::from_static(b\"X-Empty\"));\n        orig_cases.append(name, Bytes::from_static(b\"X-EMPTY\"));\n\n        let mut dst = Vec::new();\n        super::write_headers_original_case(&headers, &orig_cases, &mut dst);\n\n        assert_eq!(dst, b\"X-Empty: a\\r\\nX-EMPTY: b\\r\\n\");\n    }\n\n    #[cfg(feature = \"nightly\")]\n    use test::Bencher;\n\n    #[cfg(feature = \"nightly\")]\n    #[bench]\n    fn bench_parse_incoming(b: &mut Bencher) {\n        let mut raw = BytesMut::from(\n            &b\"GET /super_long_uri/and_whatever?what_should_we_talk_about/\\\n            I_wonder/Hard_to_write_in_an_uri_after_all/you_have_to_make\\\n            _up_the_punctuation_yourself/how_fun_is_that?test=foo&test1=\\\n            foo1&test2=foo2&test3=foo3&test4=foo4 HTTP/1.1\\r\\nHost: \\\n            hyper.rs\\r\\nAccept: a lot of things\\r\\nAccept-Charset: \\\n            utf8\\r\\nAccept-Encoding: *\\r\\nAccess-Control-Allow-\\\n            Credentials: None\\r\\nAccess-Control-Allow-Origin: None\\r\\n\\\n            Access-Control-Allow-Methods: None\\r\\nAccess-Control-Allow-\\\n            Headers: None\\r\\nContent-Encoding: utf8\\r\\nContent-Security-\\\n            Policy: None\\r\\nContent-Type: text/html\\r\\nOrigin: hyper\\\n            \\r\\nSec-Websocket-Extensions: It looks super important!\\r\\n\\\n            Sec-Websocket-Origin: hyper\\r\\nSec-Websocket-Version: 4.3\\r\\\n            \\nStrict-Transport-Security: None\\r\\nUser-Agent: hyper\\r\\n\\\n            X-Content-Duration: None\\r\\nX-Content-Security-Policy: None\\\n            \\r\\nX-DNSPrefetch-Control: None\\r\\nX-Frame-Options: \\\n            Something important obviously\\r\\nX-Requested-With: Nothing\\\n            \\r\\n\\r\\n\"[..],\n        );\n        let len = raw.len();\n        let mut headers = Some(HeaderMap::new());\n\n        b.bytes = len as u64;\n        b.iter(|| {\n            let mut msg = Server::parse(\n                &mut raw,\n                ParseContext {\n                    cached_headers: &mut headers,\n                    req_method: &mut None,\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                },\n            )\n            .unwrap()\n            .unwrap();\n            ::test::black_box(&msg);\n            msg.head.headers.clear();\n            headers = Some(msg.head.headers);\n            restart(&mut raw, len);\n        });\n\n        fn restart(b: &mut BytesMut, len: usize) {\n            b.reserve(1);\n            unsafe {\n                b.set_len(len);\n            }\n        }\n    }\n\n    #[cfg(feature = \"nightly\")]\n    #[bench]\n    fn bench_parse_short(b: &mut Bencher) {\n        let s = &b\"GET / HTTP/1.1\\r\\nHost: localhost:8080\\r\\n\\r\\n\"[..];\n        let mut raw = BytesMut::from(s);\n        let len = raw.len();\n        let mut headers = Some(HeaderMap::new());\n\n        b.bytes = len as u64;\n        b.iter(|| {\n            let mut msg = Server::parse(\n                &mut raw,\n                ParseContext {\n                    cached_headers: &mut headers,\n                    req_method: &mut None,\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                },\n            )\n            .unwrap()\n            .unwrap();\n            ::test::black_box(&msg);\n            msg.head.headers.clear();\n            headers = Some(msg.head.headers);\n            restart(&mut raw, len);\n        });\n\n        fn restart(b: &mut BytesMut, len: usize) {\n            b.reserve(1);\n            unsafe {\n                b.set_len(len);\n            }\n        }\n    }\n\n    #[cfg(feature = \"nightly\")]\n    #[bench]\n    fn bench_server_encode_headers_preset(b: &mut Bencher) {\n        use crate::proto::BodyLength;\n        use http::header::HeaderValue;\n\n        let len = 108;\n        b.bytes = len as u64;\n\n        let mut head = MessageHead::default();\n        let mut headers = HeaderMap::new();\n        headers.insert(\"content-length\", HeaderValue::from_static(\"10\"));\n        headers.insert(\"content-type\", HeaderValue::from_static(\"application/json\"));\n\n        b.iter(|| {\n            let mut vec = Vec::new();\n            head.headers = headers.clone();\n            Server::encode(\n                Encode {\n                    head: &mut head,\n                    body: Some(BodyLength::Known(10)),\n                    keep_alive: true,\n                    req_method: &mut Some(Method::GET),\n                    title_case_headers: false,\n                },\n                &mut vec,\n            )\n            .unwrap();\n            assert_eq!(vec.len(), len);\n            ::test::black_box(vec);\n        })\n    }\n\n    #[cfg(feature = \"nightly\")]\n    #[bench]\n    fn bench_server_encode_no_headers(b: &mut Bencher) {\n        use crate::proto::BodyLength;\n\n        let len = 76;\n        b.bytes = len as u64;\n\n        let mut head = MessageHead::default();\n        let mut vec = Vec::with_capacity(128);\n\n        b.iter(|| {\n            Server::encode(\n                Encode {\n                    head: &mut head,\n                    body: Some(BodyLength::Known(10)),\n                    keep_alive: true,\n                    req_method: &mut Some(Method::GET),\n                    title_case_headers: false,\n                },\n                &mut vec,\n            )\n            .unwrap();\n            assert_eq!(vec.len(), len);\n            ::test::black_box(&vec);\n\n            vec.clear();\n        })\n    }\n}\n"], "fixing_code": ["// `mem::uninitialized` replaced with `mem::MaybeUninit`,\n// can't upgrade yet\n#![allow(deprecated)]\n\nuse std::fmt::{self, Write};\nuse std::mem;\n\n#[cfg(feature = \"ffi\")]\nuse bytes::Bytes;\nuse bytes::BytesMut;\nuse http::header::{self, Entry, HeaderName, HeaderValue};\nuse http::{HeaderMap, Method, StatusCode, Version};\n\nuse crate::body::DecodedLength;\n#[cfg(feature = \"server\")]\nuse crate::common::date;\nuse crate::error::Parse;\nuse crate::headers;\nuse crate::proto::h1::{\n    Encode, Encoder, Http1Transaction, ParseContext, ParseResult, ParsedMessage,\n};\nuse crate::proto::{BodyLength, MessageHead, RequestHead, RequestLine};\n\nconst MAX_HEADERS: usize = 100;\nconst AVERAGE_HEADER_SIZE: usize = 30; // totally scientific\n\nmacro_rules! header_name {\n    ($bytes:expr) => {{\n        #[cfg(debug_assertions)]\n        {\n            match HeaderName::from_bytes($bytes) {\n                Ok(name) => name,\n                Err(_) => panic!(\n                    \"illegal header name from httparse: {:?}\",\n                    ::bytes::Bytes::copy_from_slice($bytes)\n                ),\n            }\n        }\n\n        #[cfg(not(debug_assertions))]\n        {\n            match HeaderName::from_bytes($bytes) {\n                Ok(name) => name,\n                Err(_) => panic!(\"illegal header name from httparse: {:?}\", $bytes),\n            }\n        }\n    }};\n}\n\nmacro_rules! header_value {\n    ($bytes:expr) => {{\n        #[cfg(debug_assertions)]\n        {\n            let __hvb: ::bytes::Bytes = $bytes;\n            match HeaderValue::from_maybe_shared(__hvb.clone()) {\n                Ok(name) => name,\n                Err(_) => panic!(\"illegal header value from httparse: {:?}\", __hvb),\n            }\n        }\n\n        #[cfg(not(debug_assertions))]\n        {\n            // Unsafe: httparse already validated header value\n            unsafe { HeaderValue::from_maybe_shared_unchecked($bytes) }\n        }\n    }};\n}\n\npub(super) fn parse_headers<T>(\n    bytes: &mut BytesMut,\n    ctx: ParseContext<'_>,\n) -> ParseResult<T::Incoming>\nwhere\n    T: Http1Transaction,\n{\n    // If the buffer is empty, don't bother entering the span, it's just noise.\n    if bytes.is_empty() {\n        return Ok(None);\n    }\n\n    let span = trace_span!(\"parse_headers\");\n    let _s = span.enter();\n    T::parse(bytes, ctx)\n}\n\npub(super) fn encode_headers<T>(\n    enc: Encode<'_, T::Outgoing>,\n    dst: &mut Vec<u8>,\n) -> crate::Result<Encoder>\nwhere\n    T: Http1Transaction,\n{\n    let span = trace_span!(\"encode_headers\");\n    let _s = span.enter();\n    T::encode(enc, dst)\n}\n\n// There are 2 main roles, Client and Server.\n\n#[cfg(feature = \"client\")]\npub(crate) enum Client {}\n\n#[cfg(feature = \"server\")]\npub(crate) enum Server {}\n\n#[cfg(feature = \"server\")]\nimpl Http1Transaction for Server {\n    type Incoming = RequestLine;\n    type Outgoing = StatusCode;\n    const LOG: &'static str = \"{role=server}\";\n\n    fn parse(buf: &mut BytesMut, ctx: ParseContext<'_>) -> ParseResult<RequestLine> {\n        debug_assert!(!buf.is_empty(), \"parse called with empty buf\");\n\n        let mut keep_alive;\n        let is_http_11;\n        let subject;\n        let version;\n        let len;\n        let headers_len;\n\n        // Unsafe: both headers_indices and headers are using uninitialized memory,\n        // but we *never* read any of it until after httparse has assigned\n        // values into it. By not zeroing out the stack memory, this saves\n        // a good ~5% on pipeline benchmarks.\n        let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };\n        {\n            let mut headers: [httparse::Header<'_>; MAX_HEADERS] = unsafe { mem::uninitialized() };\n            trace!(\n                \"Request.parse([Header; {}], [u8; {}])\",\n                headers.len(),\n                buf.len()\n            );\n            let mut req = httparse::Request::new(&mut headers);\n            let bytes = buf.as_ref();\n            match req.parse(bytes) {\n                Ok(httparse::Status::Complete(parsed_len)) => {\n                    trace!(\"Request.parse Complete({})\", parsed_len);\n                    len = parsed_len;\n                    subject = RequestLine(\n                        Method::from_bytes(req.method.unwrap().as_bytes())?,\n                        req.path.unwrap().parse()?,\n                    );\n                    version = if req.version.unwrap() == 1 {\n                        keep_alive = true;\n                        is_http_11 = true;\n                        Version::HTTP_11\n                    } else {\n                        keep_alive = false;\n                        is_http_11 = false;\n                        Version::HTTP_10\n                    };\n                    trace!(\"headers: {:?}\", &req.headers);\n\n                    record_header_indices(bytes, &req.headers, &mut headers_indices)?;\n                    headers_len = req.headers.len();\n                }\n                Ok(httparse::Status::Partial) => return Ok(None),\n                Err(err) => {\n                    return Err(match err {\n                        // if invalid Token, try to determine if for method or path\n                        httparse::Error::Token => {\n                            if req.method.is_none() {\n                                Parse::Method\n                            } else {\n                                debug_assert!(req.path.is_none());\n                                Parse::Uri\n                            }\n                        }\n                        other => other.into(),\n                    });\n                }\n            }\n        };\n\n        let slice = buf.split_to(len).freeze();\n\n        // According to https://tools.ietf.org/html/rfc7230#section-3.3.3\n        // 1. (irrelevant to Request)\n        // 2. (irrelevant to Request)\n        // 3. Transfer-Encoding: chunked has a chunked body.\n        // 4. If multiple differing Content-Length headers or invalid, close connection.\n        // 5. Content-Length header has a sized body.\n        // 6. Length 0.\n        // 7. (irrelevant to Request)\n\n        let mut decoder = DecodedLength::ZERO;\n        let mut expect_continue = false;\n        let mut con_len = None;\n        let mut is_te = false;\n        let mut is_te_chunked = false;\n        let mut wants_upgrade = subject.0 == Method::CONNECT;\n\n        let mut headers = ctx.cached_headers.take().unwrap_or_else(HeaderMap::new);\n\n        headers.reserve(headers_len);\n\n        for header in &headers_indices[..headers_len] {\n            let name = header_name!(&slice[header.name.0..header.name.1]);\n            let value = header_value!(slice.slice(header.value.0..header.value.1));\n\n            match name {\n                header::TRANSFER_ENCODING => {\n                    // https://tools.ietf.org/html/rfc7230#section-3.3.3\n                    // If Transfer-Encoding header is present, and 'chunked' is\n                    // not the final encoding, and this is a Request, then it is\n                    // malformed. A server should respond with 400 Bad Request.\n                    if !is_http_11 {\n                        debug!(\"HTTP/1.0 cannot have Transfer-Encoding header\");\n                        return Err(Parse::Header);\n                    }\n                    is_te = true;\n                    if headers::is_chunked_(&value) {\n                        is_te_chunked = true;\n                        decoder = DecodedLength::CHUNKED;\n                    } else {\n                        is_te_chunked = false;\n                    }\n                }\n                header::CONTENT_LENGTH => {\n                    if is_te {\n                        continue;\n                    }\n                    let len = value\n                        .to_str()\n                        .map_err(|_| Parse::Header)\n                        .and_then(|s| s.parse().map_err(|_| Parse::Header))?;\n                    if let Some(prev) = con_len {\n                        if prev != len {\n                            debug!(\n                                \"multiple Content-Length headers with different values: [{}, {}]\",\n                                prev, len,\n                            );\n                            return Err(Parse::Header);\n                        }\n                        // we don't need to append this secondary length\n                        continue;\n                    }\n                    decoder = DecodedLength::checked_new(len)?;\n                    con_len = Some(len);\n                }\n                header::CONNECTION => {\n                    // keep_alive was previously set to default for Version\n                    if keep_alive {\n                        // HTTP/1.1\n                        keep_alive = !headers::connection_close(&value);\n                    } else {\n                        // HTTP/1.0\n                        keep_alive = headers::connection_keep_alive(&value);\n                    }\n                }\n                header::EXPECT => {\n                    expect_continue = value.as_bytes() == b\"100-continue\";\n                }\n                header::UPGRADE => {\n                    // Upgrades are only allowed with HTTP/1.1\n                    wants_upgrade = is_http_11;\n                }\n\n                _ => (),\n            }\n\n            headers.append(name, value);\n        }\n\n        if is_te && !is_te_chunked {\n            debug!(\"request with transfer-encoding header, but not chunked, bad request\");\n            return Err(Parse::Header);\n        }\n\n        *ctx.req_method = Some(subject.0.clone());\n\n        Ok(Some(ParsedMessage {\n            head: MessageHead {\n                version,\n                subject,\n                headers,\n                extensions: http::Extensions::default(),\n            },\n            decode: decoder,\n            expect_continue,\n            keep_alive,\n            wants_upgrade,\n        }))\n    }\n\n    fn encode(\n        mut msg: Encode<'_, Self::Outgoing>,\n        mut dst: &mut Vec<u8>,\n    ) -> crate::Result<Encoder> {\n        trace!(\n            \"Server::encode status={:?}, body={:?}, req_method={:?}\",\n            msg.head.subject,\n            msg.body,\n            msg.req_method\n        );\n        debug_assert!(\n            !msg.title_case_headers,\n            \"no server config for title case headers\"\n        );\n\n        let mut wrote_len = false;\n\n        // hyper currently doesn't support returning 1xx status codes as a Response\n        // This is because Service only allows returning a single Response, and\n        // so if you try to reply with a e.g. 100 Continue, you have no way of\n        // replying with the latter status code response.\n        let (ret, mut is_last) = if msg.head.subject == StatusCode::SWITCHING_PROTOCOLS {\n            (Ok(()), true)\n        } else if msg.req_method == &Some(Method::CONNECT) && msg.head.subject.is_success() {\n            // Sending content-length or transfer-encoding header on 2xx response\n            // to CONNECT is forbidden in RFC 7231.\n            wrote_len = true;\n            (Ok(()), true)\n        } else if msg.head.subject.is_informational() {\n            warn!(\"response with 1xx status code not supported\");\n            *msg.head = MessageHead::default();\n            msg.head.subject = StatusCode::INTERNAL_SERVER_ERROR;\n            msg.body = None;\n            (Err(crate::Error::new_user_unsupported_status_code()), true)\n        } else {\n            (Ok(()), !msg.keep_alive)\n        };\n\n        // In some error cases, we don't know about the invalid message until already\n        // pushing some bytes onto the `dst`. In those cases, we don't want to send\n        // the half-pushed message, so rewind to before.\n        let orig_len = dst.len();\n        let rewind = |dst: &mut Vec<u8>| {\n            dst.truncate(orig_len);\n        };\n\n        let init_cap = 30 + msg.head.headers.len() * AVERAGE_HEADER_SIZE;\n        dst.reserve(init_cap);\n        if msg.head.version == Version::HTTP_11 && msg.head.subject == StatusCode::OK {\n            extend(dst, b\"HTTP/1.1 200 OK\\r\\n\");\n        } else {\n            match msg.head.version {\n                Version::HTTP_10 => extend(dst, b\"HTTP/1.0 \"),\n                Version::HTTP_11 => extend(dst, b\"HTTP/1.1 \"),\n                Version::HTTP_2 => {\n                    debug!(\"response with HTTP2 version coerced to HTTP/1.1\");\n                    extend(dst, b\"HTTP/1.1 \");\n                }\n                other => panic!(\"unexpected response version: {:?}\", other),\n            }\n\n            extend(dst, msg.head.subject.as_str().as_bytes());\n            extend(dst, b\" \");\n            // a reason MUST be written, as many parsers will expect it.\n            extend(\n                dst,\n                msg.head\n                    .subject\n                    .canonical_reason()\n                    .unwrap_or(\"<none>\")\n                    .as_bytes(),\n            );\n            extend(dst, b\"\\r\\n\");\n        }\n\n        let mut encoder = Encoder::length(0);\n        let mut wrote_date = false;\n        let mut cur_name = None;\n        let mut is_name_written = false;\n        let mut must_write_chunked = false;\n        let mut prev_con_len = None;\n\n        macro_rules! handle_is_name_written {\n            () => {{\n                if is_name_written {\n                    // we need to clean up and write the newline\n                    debug_assert_ne!(\n                        &dst[dst.len() - 2..],\n                        b\"\\r\\n\",\n                        \"previous header wrote newline but set is_name_written\"\n                    );\n\n                    if must_write_chunked {\n                        extend(dst, b\", chunked\\r\\n\");\n                    } else {\n                        extend(dst, b\"\\r\\n\");\n                    }\n                }\n            }};\n        }\n\n        'headers: for (opt_name, value) in msg.head.headers.drain() {\n            if let Some(n) = opt_name {\n                cur_name = Some(n);\n                handle_is_name_written!();\n                is_name_written = false;\n            }\n            let name = cur_name.as_ref().expect(\"current header name\");\n            match *name {\n                header::CONTENT_LENGTH => {\n                    if wrote_len && !is_name_written {\n                        warn!(\"unexpected content-length found, canceling\");\n                        rewind(dst);\n                        return Err(crate::Error::new_user_header());\n                    }\n                    match msg.body {\n                        Some(BodyLength::Known(known_len)) => {\n                            // The HttpBody claims to know a length, and\n                            // the headers are already set. For performance\n                            // reasons, we are just going to trust that\n                            // the values match.\n                            //\n                            // In debug builds, we'll assert they are the\n                            // same to help developers find bugs.\n                            #[cfg(debug_assertions)]\n                            {\n                                if let Some(len) = headers::content_length_parse(&value) {\n                                    assert!(\n                                        len == known_len,\n                                        \"payload claims content-length of {}, custom content-length header claims {}\",\n                                        known_len,\n                                        len,\n                                    );\n                                }\n                            }\n\n                            if !is_name_written {\n                                encoder = Encoder::length(known_len);\n                                extend(dst, b\"content-length: \");\n                                extend(dst, value.as_bytes());\n                                wrote_len = true;\n                                is_name_written = true;\n                            }\n                            continue 'headers;\n                        }\n                        Some(BodyLength::Unknown) => {\n                            // The HttpBody impl didn't know how long the\n                            // body is, but a length header was included.\n                            // We have to parse the value to return our\n                            // Encoder...\n\n                            if let Some(len) = headers::content_length_parse(&value) {\n                                if let Some(prev) = prev_con_len {\n                                    if prev != len {\n                                        warn!(\n                                            \"multiple Content-Length values found: [{}, {}]\",\n                                            prev, len\n                                        );\n                                        rewind(dst);\n                                        return Err(crate::Error::new_user_header());\n                                    }\n                                    debug_assert!(is_name_written);\n                                    continue 'headers;\n                                } else {\n                                    // we haven't written content-length yet!\n                                    encoder = Encoder::length(len);\n                                    extend(dst, b\"content-length: \");\n                                    extend(dst, value.as_bytes());\n                                    wrote_len = true;\n                                    is_name_written = true;\n                                    prev_con_len = Some(len);\n                                    continue 'headers;\n                                }\n                            } else {\n                                warn!(\"illegal Content-Length value: {:?}\", value);\n                                rewind(dst);\n                                return Err(crate::Error::new_user_header());\n                            }\n                        }\n                        None => {\n                            // We have no body to actually send,\n                            // but the headers claim a content-length.\n                            // There's only 2 ways this makes sense:\n                            //\n                            // - The header says the length is `0`.\n                            // - This is a response to a `HEAD` request.\n                            if msg.req_method == &Some(Method::HEAD) {\n                                debug_assert_eq!(encoder, Encoder::length(0));\n                            } else {\n                                if value.as_bytes() != b\"0\" {\n                                    warn!(\n                                        \"content-length value found, but empty body provided: {:?}\",\n                                        value\n                                    );\n                                }\n                                continue 'headers;\n                            }\n                        }\n                    }\n                    wrote_len = true;\n                }\n                header::TRANSFER_ENCODING => {\n                    if wrote_len && !is_name_written {\n                        warn!(\"unexpected transfer-encoding found, canceling\");\n                        rewind(dst);\n                        return Err(crate::Error::new_user_header());\n                    }\n                    // check that we actually can send a chunked body...\n                    if msg.head.version == Version::HTTP_10\n                        || !Server::can_chunked(msg.req_method, msg.head.subject)\n                    {\n                        continue;\n                    }\n                    wrote_len = true;\n                    // Must check each value, because `chunked` needs to be the\n                    // last encoding, or else we add it.\n                    must_write_chunked = !headers::is_chunked_(&value);\n\n                    if !is_name_written {\n                        encoder = Encoder::chunked();\n                        is_name_written = true;\n                        extend(dst, b\"transfer-encoding: \");\n                        extend(dst, value.as_bytes());\n                    } else {\n                        extend(dst, b\", \");\n                        extend(dst, value.as_bytes());\n                    }\n                    continue 'headers;\n                }\n                header::CONNECTION => {\n                    if !is_last && headers::connection_close(&value) {\n                        is_last = true;\n                    }\n                    if !is_name_written {\n                        is_name_written = true;\n                        extend(dst, b\"connection: \");\n                        extend(dst, value.as_bytes());\n                    } else {\n                        extend(dst, b\", \");\n                        extend(dst, value.as_bytes());\n                    }\n                    continue 'headers;\n                }\n                header::DATE => {\n                    wrote_date = true;\n                }\n                _ => (),\n            }\n            //TODO: this should perhaps instead combine them into\n            //single lines, as RFC7230 suggests is preferable.\n\n            // non-special write Name and Value\n            debug_assert!(\n                !is_name_written,\n                \"{:?} set is_name_written and didn't continue loop\",\n                name,\n            );\n            extend(dst, name.as_str().as_bytes());\n            extend(dst, b\": \");\n            extend(dst, value.as_bytes());\n            extend(dst, b\"\\r\\n\");\n        }\n\n        handle_is_name_written!();\n\n        if !wrote_len {\n            encoder = match msg.body {\n                Some(BodyLength::Unknown) => {\n                    if msg.head.version == Version::HTTP_10\n                        || !Server::can_chunked(msg.req_method, msg.head.subject)\n                    {\n                        Encoder::close_delimited()\n                    } else {\n                        extend(dst, b\"transfer-encoding: chunked\\r\\n\");\n                        Encoder::chunked()\n                    }\n                }\n                None | Some(BodyLength::Known(0)) => {\n                    if msg.head.subject != StatusCode::NOT_MODIFIED {\n                        extend(dst, b\"content-length: 0\\r\\n\");\n                    }\n                    Encoder::length(0)\n                }\n                Some(BodyLength::Known(len)) => {\n                    if msg.head.subject == StatusCode::NOT_MODIFIED {\n                        Encoder::length(0)\n                    } else {\n                        extend(dst, b\"content-length: \");\n                        let _ = ::itoa::write(&mut dst, len);\n                        extend(dst, b\"\\r\\n\");\n                        Encoder::length(len)\n                    }\n                }\n            };\n        }\n\n        if !Server::can_have_body(msg.req_method, msg.head.subject) {\n            trace!(\n                \"server body forced to 0; method={:?}, status={:?}\",\n                msg.req_method,\n                msg.head.subject\n            );\n            encoder = Encoder::length(0);\n        }\n\n        // cached date is much faster than formatting every request\n        if !wrote_date {\n            dst.reserve(date::DATE_VALUE_LENGTH + 8);\n            extend(dst, b\"date: \");\n            date::extend(dst);\n            extend(dst, b\"\\r\\n\\r\\n\");\n        } else {\n            extend(dst, b\"\\r\\n\");\n        }\n\n        ret.map(|()| encoder.set_last(is_last))\n    }\n\n    fn on_error(err: &crate::Error) -> Option<MessageHead<Self::Outgoing>> {\n        use crate::error::Kind;\n        let status = match *err.kind() {\n            Kind::Parse(Parse::Method)\n            | Kind::Parse(Parse::Header)\n            | Kind::Parse(Parse::Uri)\n            | Kind::Parse(Parse::Version) => StatusCode::BAD_REQUEST,\n            Kind::Parse(Parse::TooLarge) => StatusCode::REQUEST_HEADER_FIELDS_TOO_LARGE,\n            _ => return None,\n        };\n\n        debug!(\"sending automatic response ({}) for parse error\", status);\n        let mut msg = MessageHead::default();\n        msg.subject = status;\n        Some(msg)\n    }\n\n    fn is_server() -> bool {\n        true\n    }\n\n    fn update_date() {\n        date::update();\n    }\n}\n\n#[cfg(feature = \"server\")]\nimpl Server {\n    fn can_have_body(method: &Option<Method>, status: StatusCode) -> bool {\n        Server::can_chunked(method, status)\n    }\n\n    fn can_chunked(method: &Option<Method>, status: StatusCode) -> bool {\n        if method == &Some(Method::HEAD) || method == &Some(Method::CONNECT) && status.is_success()\n        {\n            false\n        } else {\n            match status {\n                // TODO: support for 1xx codes needs improvement everywhere\n                // would be 100...199 => false\n                StatusCode::SWITCHING_PROTOCOLS\n                | StatusCode::NO_CONTENT\n                | StatusCode::NOT_MODIFIED => false,\n                _ => true,\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"client\")]\nimpl Http1Transaction for Client {\n    type Incoming = StatusCode;\n    type Outgoing = RequestLine;\n    const LOG: &'static str = \"{role=client}\";\n\n    fn parse(buf: &mut BytesMut, ctx: ParseContext<'_>) -> ParseResult<StatusCode> {\n        debug_assert!(!buf.is_empty(), \"parse called with empty buf\");\n\n        // Loop to skip information status code headers (100 Continue, etc).\n        loop {\n            // Unsafe: see comment in Server Http1Transaction, above.\n            let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };\n            let (len, status, reason, version, headers_len) = {\n                let mut headers: [httparse::Header<'_>; MAX_HEADERS] =\n                    unsafe { mem::uninitialized() };\n                trace!(\n                    \"Response.parse([Header; {}], [u8; {}])\",\n                    headers.len(),\n                    buf.len()\n                );\n                let mut res = httparse::Response::new(&mut headers);\n                let bytes = buf.as_ref();\n                match res.parse(bytes)? {\n                    httparse::Status::Complete(len) => {\n                        trace!(\"Response.parse Complete({})\", len);\n                        let status = StatusCode::from_u16(res.code.unwrap())?;\n\n                        #[cfg(not(feature = \"ffi\"))]\n                        let reason = ();\n                        #[cfg(feature = \"ffi\")]\n                        let reason = {\n                            let reason = res.reason.unwrap();\n                            // Only save the reason phrase if it isnt the canonical reason\n                            if Some(reason) != status.canonical_reason() {\n                                Some(Bytes::copy_from_slice(reason.as_bytes()))\n                            } else {\n                                None\n                            }\n                        };\n\n                        let version = if res.version.unwrap() == 1 {\n                            Version::HTTP_11\n                        } else {\n                            Version::HTTP_10\n                        };\n                        record_header_indices(bytes, &res.headers, &mut headers_indices)?;\n                        let headers_len = res.headers.len();\n                        (len, status, reason, version, headers_len)\n                    }\n                    httparse::Status::Partial => return Ok(None),\n                }\n            };\n\n            let slice = buf.split_to(len).freeze();\n\n            let mut headers = ctx.cached_headers.take().unwrap_or_else(HeaderMap::new);\n\n            let mut keep_alive = version == Version::HTTP_11;\n\n            #[cfg(feature = \"ffi\")]\n            let mut header_case_map = crate::ffi::HeaderCaseMap::default();\n\n            headers.reserve(headers_len);\n            for header in &headers_indices[..headers_len] {\n                let name = header_name!(&slice[header.name.0..header.name.1]);\n                let value = header_value!(slice.slice(header.value.0..header.value.1));\n\n                if let header::CONNECTION = name {\n                    // keep_alive was previously set to default for Version\n                    if keep_alive {\n                        // HTTP/1.1\n                        keep_alive = !headers::connection_close(&value);\n                    } else {\n                        // HTTP/1.0\n                        keep_alive = headers::connection_keep_alive(&value);\n                    }\n                }\n\n                #[cfg(feature = \"ffi\")]\n                if ctx.preserve_header_case {\n                    header_case_map.append(&name, slice.slice(header.name.0..header.name.1));\n                }\n\n                headers.append(name, value);\n            }\n\n            #[allow(unused_mut)]\n            let mut extensions = http::Extensions::default();\n\n            #[cfg(feature = \"ffi\")]\n            if ctx.preserve_header_case {\n                extensions.insert(header_case_map);\n            }\n\n            #[cfg(feature = \"ffi\")]\n            if let Some(reason) = reason {\n                extensions.insert(crate::ffi::ReasonPhrase(reason));\n            }\n            #[cfg(not(feature = \"ffi\"))]\n            drop(reason);\n\n            let head = MessageHead {\n                version,\n                subject: status,\n                headers,\n                extensions,\n            };\n            if let Some((decode, is_upgrade)) = Client::decoder(&head, ctx.req_method)? {\n                return Ok(Some(ParsedMessage {\n                    head,\n                    decode,\n                    expect_continue: false,\n                    // a client upgrade means the connection can't be used\n                    // again, as it is definitely upgrading.\n                    keep_alive: keep_alive && !is_upgrade,\n                    wants_upgrade: is_upgrade,\n                }));\n            }\n\n            // Parsing a 1xx response could have consumed the buffer, check if\n            // it is empty now...\n            if buf.is_empty() {\n                return Ok(None);\n            }\n        }\n    }\n\n    fn encode(msg: Encode<'_, Self::Outgoing>, dst: &mut Vec<u8>) -> crate::Result<Encoder> {\n        trace!(\n            \"Client::encode method={:?}, body={:?}\",\n            msg.head.subject.0,\n            msg.body\n        );\n\n        *msg.req_method = Some(msg.head.subject.0.clone());\n\n        let body = Client::set_length(msg.head, msg.body);\n\n        let init_cap = 30 + msg.head.headers.len() * AVERAGE_HEADER_SIZE;\n        dst.reserve(init_cap);\n\n        extend(dst, msg.head.subject.0.as_str().as_bytes());\n        extend(dst, b\" \");\n        //TODO: add API to http::Uri to encode without std::fmt\n        let _ = write!(FastWrite(dst), \"{} \", msg.head.subject.1);\n\n        match msg.head.version {\n            Version::HTTP_10 => extend(dst, b\"HTTP/1.0\"),\n            Version::HTTP_11 => extend(dst, b\"HTTP/1.1\"),\n            Version::HTTP_2 => {\n                debug!(\"request with HTTP2 version coerced to HTTP/1.1\");\n                extend(dst, b\"HTTP/1.1\");\n            }\n            other => panic!(\"unexpected request version: {:?}\", other),\n        }\n        extend(dst, b\"\\r\\n\");\n\n        #[cfg(feature = \"ffi\")]\n        {\n            if msg.title_case_headers {\n                write_headers_title_case(&msg.head.headers, dst);\n            } else if let Some(orig_headers) =\n                msg.head.extensions.get::<crate::ffi::HeaderCaseMap>()\n            {\n                write_headers_original_case(&msg.head.headers, orig_headers, dst);\n            } else {\n                write_headers(&msg.head.headers, dst);\n            }\n        }\n\n        #[cfg(not(feature = \"ffi\"))]\n        {\n            if msg.title_case_headers {\n                write_headers_title_case(&msg.head.headers, dst);\n            } else {\n                write_headers(&msg.head.headers, dst);\n            }\n        }\n\n        extend(dst, b\"\\r\\n\");\n        msg.head.headers.clear(); //TODO: remove when switching to drain()\n\n        Ok(body)\n    }\n\n    fn on_error(_err: &crate::Error) -> Option<MessageHead<Self::Outgoing>> {\n        // we can't tell the server about any errors it creates\n        None\n    }\n\n    fn is_client() -> bool {\n        true\n    }\n}\n\n#[cfg(feature = \"client\")]\nimpl Client {\n    /// Returns Some(length, wants_upgrade) if successful.\n    ///\n    /// Returns None if this message head should be skipped (like a 100 status).\n    fn decoder(\n        inc: &MessageHead<StatusCode>,\n        method: &mut Option<Method>,\n    ) -> Result<Option<(DecodedLength, bool)>, Parse> {\n        // According to https://tools.ietf.org/html/rfc7230#section-3.3.3\n        // 1. HEAD responses, and Status 1xx, 204, and 304 cannot have a body.\n        // 2. Status 2xx to a CONNECT cannot have a body.\n        // 3. Transfer-Encoding: chunked has a chunked body.\n        // 4. If multiple differing Content-Length headers or invalid, close connection.\n        // 5. Content-Length header has a sized body.\n        // 6. (irrelevant to Response)\n        // 7. Read till EOF.\n\n        match inc.subject.as_u16() {\n            101 => {\n                return Ok(Some((DecodedLength::ZERO, true)));\n            }\n            100 | 102..=199 => {\n                trace!(\"ignoring informational response: {}\", inc.subject.as_u16());\n                return Ok(None);\n            }\n            204 | 304 => return Ok(Some((DecodedLength::ZERO, false))),\n            _ => (),\n        }\n        match *method {\n            Some(Method::HEAD) => {\n                return Ok(Some((DecodedLength::ZERO, false)));\n            }\n            Some(Method::CONNECT) => {\n                if let 200..=299 = inc.subject.as_u16() {\n                    return Ok(Some((DecodedLength::ZERO, true)));\n                }\n            }\n            Some(_) => {}\n            None => {\n                trace!(\"Client::decoder is missing the Method\");\n            }\n        }\n\n        if inc.headers.contains_key(header::TRANSFER_ENCODING) {\n            // https://tools.ietf.org/html/rfc7230#section-3.3.3\n            // If Transfer-Encoding header is present, and 'chunked' is\n            // not the final encoding, and this is a Request, then it is\n            // malformed. A server should respond with 400 Bad Request.\n            if inc.version == Version::HTTP_10 {\n                debug!(\"HTTP/1.0 cannot have Transfer-Encoding header\");\n                Err(Parse::Header)\n            } else if headers::transfer_encoding_is_chunked(&inc.headers) {\n                Ok(Some((DecodedLength::CHUNKED, false)))\n            } else {\n                trace!(\"not chunked, read till eof\");\n                Ok(Some((DecodedLength::CLOSE_DELIMITED, false)))\n            }\n        } else if let Some(len) = headers::content_length_parse_all(&inc.headers) {\n            Ok(Some((DecodedLength::checked_new(len)?, false)))\n        } else if inc.headers.contains_key(header::CONTENT_LENGTH) {\n            debug!(\"illegal Content-Length header\");\n            Err(Parse::Header)\n        } else {\n            trace!(\"neither Transfer-Encoding nor Content-Length\");\n            Ok(Some((DecodedLength::CLOSE_DELIMITED, false)))\n        }\n    }\n    fn set_length(head: &mut RequestHead, body: Option<BodyLength>) -> Encoder {\n        let body = if let Some(body) = body {\n            body\n        } else {\n            head.headers.remove(header::TRANSFER_ENCODING);\n            return Encoder::length(0);\n        };\n\n        // HTTP/1.0 doesn't know about chunked\n        let can_chunked = head.version == Version::HTTP_11;\n        let headers = &mut head.headers;\n\n        // If the user already set specific headers, we should respect them, regardless\n        // of what the HttpBody knows about itself. They set them for a reason.\n\n        // Because of the borrow checker, we can't check the for an existing\n        // Content-Length header while holding an `Entry` for the Transfer-Encoding\n        // header, so unfortunately, we must do the check here, first.\n\n        let existing_con_len = headers::content_length_parse_all(headers);\n        let mut should_remove_con_len = false;\n\n        if !can_chunked {\n            // Chunked isn't legal, so if it is set, we need to remove it.\n            if headers.remove(header::TRANSFER_ENCODING).is_some() {\n                trace!(\"removing illegal transfer-encoding header\");\n            }\n\n            return if let Some(len) = existing_con_len {\n                Encoder::length(len)\n            } else if let BodyLength::Known(len) = body {\n                set_content_length(headers, len)\n            } else {\n                // HTTP/1.0 client requests without a content-length\n                // cannot have any body at all.\n                Encoder::length(0)\n            };\n        }\n\n        // If the user set a transfer-encoding, respect that. Let's just\n        // make sure `chunked` is the final encoding.\n        let encoder = match headers.entry(header::TRANSFER_ENCODING) {\n            Entry::Occupied(te) => {\n                should_remove_con_len = true;\n                if headers::is_chunked(te.iter()) {\n                    Some(Encoder::chunked())\n                } else {\n                    warn!(\"user provided transfer-encoding does not end in 'chunked'\");\n\n                    // There's a Transfer-Encoding, but it doesn't end in 'chunked'!\n                    // An example that could trigger this:\n                    //\n                    //     Transfer-Encoding: gzip\n                    //\n                    // This can be bad, depending on if this is a request or a\n                    // response.\n                    //\n                    // - A request is illegal if there is a `Transfer-Encoding`\n                    //   but it doesn't end in `chunked`.\n                    // - A response that has `Transfer-Encoding` but doesn't\n                    //   end in `chunked` isn't illegal, it just forces this\n                    //   to be close-delimited.\n                    //\n                    // We can try to repair this, by adding `chunked` ourselves.\n\n                    headers::add_chunked(te);\n                    Some(Encoder::chunked())\n                }\n            }\n            Entry::Vacant(te) => {\n                if let Some(len) = existing_con_len {\n                    Some(Encoder::length(len))\n                } else if let BodyLength::Unknown = body {\n                    // GET, HEAD, and CONNECT almost never have bodies.\n                    //\n                    // So instead of sending a \"chunked\" body with a 0-chunk,\n                    // assume no body here. If you *must* send a body,\n                    // set the headers explicitly.\n                    match head.subject.0 {\n                        Method::GET | Method::HEAD | Method::CONNECT => Some(Encoder::length(0)),\n                        _ => {\n                            te.insert(HeaderValue::from_static(\"chunked\"));\n                            Some(Encoder::chunked())\n                        }\n                    }\n                } else {\n                    None\n                }\n            }\n        };\n\n        // This is because we need a second mutable borrow to remove\n        // content-length header.\n        if let Some(encoder) = encoder {\n            if should_remove_con_len && existing_con_len.is_some() {\n                headers.remove(header::CONTENT_LENGTH);\n            }\n            return encoder;\n        }\n\n        // User didn't set transfer-encoding, AND we know body length,\n        // so we can just set the Content-Length automatically.\n\n        let len = if let BodyLength::Known(len) = body {\n            len\n        } else {\n            unreachable!(\"BodyLength::Unknown would set chunked\");\n        };\n\n        set_content_length(headers, len)\n    }\n}\n\nfn set_content_length(headers: &mut HeaderMap, len: u64) -> Encoder {\n    // At this point, there should not be a valid Content-Length\n    // header. However, since we'll be indexing in anyways, we can\n    // warn the user if there was an existing illegal header.\n    //\n    // Or at least, we can in theory. It's actually a little bit slower,\n    // so perhaps only do that while the user is developing/testing.\n\n    if cfg!(debug_assertions) {\n        match headers.entry(header::CONTENT_LENGTH) {\n            Entry::Occupied(mut cl) => {\n                // Internal sanity check, we should have already determined\n                // that the header was illegal before calling this function.\n                debug_assert!(headers::content_length_parse_all_values(cl.iter()).is_none());\n                // Uh oh, the user set `Content-Length` headers, but set bad ones.\n                // This would be an illegal message anyways, so let's try to repair\n                // with our known good length.\n                error!(\"user provided content-length header was invalid\");\n\n                cl.insert(HeaderValue::from(len));\n                Encoder::length(len)\n            }\n            Entry::Vacant(cl) => {\n                cl.insert(HeaderValue::from(len));\n                Encoder::length(len)\n            }\n        }\n    } else {\n        headers.insert(header::CONTENT_LENGTH, HeaderValue::from(len));\n        Encoder::length(len)\n    }\n}\n\n#[derive(Clone, Copy)]\nstruct HeaderIndices {\n    name: (usize, usize),\n    value: (usize, usize),\n}\n\nfn record_header_indices(\n    bytes: &[u8],\n    headers: &[httparse::Header<'_>],\n    indices: &mut [HeaderIndices],\n) -> Result<(), crate::error::Parse> {\n    let bytes_ptr = bytes.as_ptr() as usize;\n\n    for (header, indices) in headers.iter().zip(indices.iter_mut()) {\n        if header.name.len() >= (1 << 16) {\n            debug!(\"header name larger than 64kb: {:?}\", header.name);\n            return Err(crate::error::Parse::TooLarge);\n        }\n        let name_start = header.name.as_ptr() as usize - bytes_ptr;\n        let name_end = name_start + header.name.len();\n        indices.name = (name_start, name_end);\n        let value_start = header.value.as_ptr() as usize - bytes_ptr;\n        let value_end = value_start + header.value.len();\n        indices.value = (value_start, value_end);\n    }\n\n    Ok(())\n}\n\n// Write header names as title case. The header name is assumed to be ASCII,\n// therefore it is trivial to convert an ASCII character from lowercase to\n// uppercase. It is as simple as XORing the lowercase character byte with\n// space.\nfn title_case(dst: &mut Vec<u8>, name: &[u8]) {\n    dst.reserve(name.len());\n\n    let mut iter = name.iter();\n\n    // Uppercase the first character\n    if let Some(c) = iter.next() {\n        if *c >= b'a' && *c <= b'z' {\n            dst.push(*c ^ b' ');\n        } else {\n            dst.push(*c);\n        }\n    }\n\n    while let Some(c) = iter.next() {\n        dst.push(*c);\n\n        if *c == b'-' {\n            if let Some(c) = iter.next() {\n                if *c >= b'a' && *c <= b'z' {\n                    dst.push(*c ^ b' ');\n                } else {\n                    dst.push(*c);\n                }\n            }\n        }\n    }\n}\n\nfn write_headers_title_case(headers: &HeaderMap, dst: &mut Vec<u8>) {\n    for (name, value) in headers {\n        title_case(dst, name.as_str().as_bytes());\n        extend(dst, b\": \");\n        extend(dst, value.as_bytes());\n        extend(dst, b\"\\r\\n\");\n    }\n}\n\nfn write_headers(headers: &HeaderMap, dst: &mut Vec<u8>) {\n    for (name, value) in headers {\n        extend(dst, name.as_str().as_bytes());\n        extend(dst, b\": \");\n        extend(dst, value.as_bytes());\n        extend(dst, b\"\\r\\n\");\n    }\n}\n\n#[cfg(feature = \"ffi\")]\n#[cold]\nfn write_headers_original_case(\n    headers: &HeaderMap,\n    orig_case: &crate::ffi::HeaderCaseMap,\n    dst: &mut Vec<u8>,\n) {\n    // For each header name/value pair, there may be a value in the casemap\n    // that corresponds to the HeaderValue. So, we iterator all the keys,\n    // and for each one, try to pair the originally cased name with the value.\n    //\n    // TODO: consider adding http::HeaderMap::entries() iterator\n    for name in headers.keys() {\n        let mut names = orig_case.get_all(name).iter();\n\n        for value in headers.get_all(name) {\n            if let Some(orig_name) = names.next() {\n                extend(dst, orig_name);\n            } else {\n                extend(dst, name.as_str().as_bytes());\n            }\n\n            // Wanted for curl test cases that send `X-Custom-Header:\\r\\n`\n            if value.is_empty() {\n                extend(dst, b\":\\r\\n\");\n            } else {\n                extend(dst, b\": \");\n                extend(dst, value.as_bytes());\n                extend(dst, b\"\\r\\n\");\n            }\n        }\n    }\n}\n\nstruct FastWrite<'a>(&'a mut Vec<u8>);\n\nimpl<'a> fmt::Write for FastWrite<'a> {\n    #[inline]\n    fn write_str(&mut self, s: &str) -> fmt::Result {\n        extend(self.0, s.as_bytes());\n        Ok(())\n    }\n\n    #[inline]\n    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> fmt::Result {\n        fmt::write(self, args)\n    }\n}\n\n#[inline]\nfn extend(dst: &mut Vec<u8>, data: &[u8]) {\n    dst.extend_from_slice(data);\n}\n\n#[cfg(test)]\nmod tests {\n    use bytes::BytesMut;\n\n    use super::*;\n\n    #[test]\n    fn test_parse_request() {\n        let _ = pretty_env_logger::try_init();\n        let mut raw = BytesMut::from(\"GET /echo HTTP/1.1\\r\\nHost: hyper.rs\\r\\n\\r\\n\");\n        let mut method = None;\n        let msg = Server::parse(\n            &mut raw,\n            ParseContext {\n                cached_headers: &mut None,\n                req_method: &mut method,\n                #[cfg(feature = \"ffi\")]\n                preserve_header_case: false,\n            },\n        )\n        .unwrap()\n        .unwrap();\n        assert_eq!(raw.len(), 0);\n        assert_eq!(msg.head.subject.0, crate::Method::GET);\n        assert_eq!(msg.head.subject.1, \"/echo\");\n        assert_eq!(msg.head.version, crate::Version::HTTP_11);\n        assert_eq!(msg.head.headers.len(), 1);\n        assert_eq!(msg.head.headers[\"Host\"], \"hyper.rs\");\n        assert_eq!(method, Some(crate::Method::GET));\n    }\n\n    #[test]\n    fn test_parse_response() {\n        let _ = pretty_env_logger::try_init();\n        let mut raw = BytesMut::from(\"HTTP/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\");\n        let ctx = ParseContext {\n            cached_headers: &mut None,\n            req_method: &mut Some(crate::Method::GET),\n            #[cfg(feature = \"ffi\")]\n            preserve_header_case: false,\n        };\n        let msg = Client::parse(&mut raw, ctx).unwrap().unwrap();\n        assert_eq!(raw.len(), 0);\n        assert_eq!(msg.head.subject, crate::StatusCode::OK);\n        assert_eq!(msg.head.version, crate::Version::HTTP_11);\n        assert_eq!(msg.head.headers.len(), 1);\n        assert_eq!(msg.head.headers[\"Content-Length\"], \"0\");\n    }\n\n    #[test]\n    fn test_parse_request_errors() {\n        let mut raw = BytesMut::from(\"GET htt:p// HTTP/1.1\\r\\nHost: hyper.rs\\r\\n\\r\\n\");\n        let ctx = ParseContext {\n            cached_headers: &mut None,\n            req_method: &mut None,\n            #[cfg(feature = \"ffi\")]\n            preserve_header_case: false,\n        };\n        Server::parse(&mut raw, ctx).unwrap_err();\n    }\n\n    #[test]\n    fn test_decoder_request() {\n        fn parse(s: &str) -> ParsedMessage<RequestLine> {\n            let mut bytes = BytesMut::from(s);\n            Server::parse(\n                &mut bytes,\n                ParseContext {\n                    cached_headers: &mut None,\n                    req_method: &mut None,\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                },\n            )\n            .expect(\"parse ok\")\n            .expect(\"parse complete\")\n        }\n\n        fn parse_err(s: &str, comment: &str) -> crate::error::Parse {\n            let mut bytes = BytesMut::from(s);\n            Server::parse(\n                &mut bytes,\n                ParseContext {\n                    cached_headers: &mut None,\n                    req_method: &mut None,\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                },\n            )\n            .expect_err(comment)\n        }\n\n        // no length or transfer-encoding means 0-length body\n        assert_eq!(\n            parse(\n                \"\\\n                 GET / HTTP/1.1\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::ZERO\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::ZERO\n        );\n\n        // transfer-encoding: chunked\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 transfer-encoding: gzip, chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 transfer-encoding: gzip\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        // content-length\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::new(10)\n        );\n\n        // transfer-encoding and content-length = chunked\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 transfer-encoding: gzip\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        // multiple content-lengths of same value are fine\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.1\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::new(10)\n        );\n\n        // multiple content-lengths with different values is an error\n        parse_err(\n            \"\\\n             POST / HTTP/1.1\\r\\n\\\n             content-length: 10\\r\\n\\\n             content-length: 11\\r\\n\\\n             \\r\\n\\\n             \",\n            \"multiple content-lengths\",\n        );\n\n        // transfer-encoding that isn't chunked is an error\n        parse_err(\n            \"\\\n             POST / HTTP/1.1\\r\\n\\\n             transfer-encoding: gzip\\r\\n\\\n             \\r\\n\\\n             \",\n            \"transfer-encoding but not chunked\",\n        );\n\n        parse_err(\n            \"\\\n             POST / HTTP/1.1\\r\\n\\\n             transfer-encoding: chunked, gzip\\r\\n\\\n             \\r\\n\\\n             \",\n            \"transfer-encoding doesn't end in chunked\",\n        );\n\n        parse_err(\n            \"\\\n             POST / HTTP/1.1\\r\\n\\\n             transfer-encoding: chunked\\r\\n\\\n             transfer-encoding: afterlol\\r\\n\\\n             \\r\\n\\\n             \",\n            \"transfer-encoding multiple lines doesn't end in chunked\",\n        );\n\n        // http/1.0\n\n        assert_eq!(\n            parse(\n                \"\\\n                 POST / HTTP/1.0\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::new(10)\n        );\n\n        // 1.0 doesn't understand chunked, so its an error\n        parse_err(\n            \"\\\n             POST / HTTP/1.0\\r\\n\\\n             transfer-encoding: chunked\\r\\n\\\n             \\r\\n\\\n             \",\n            \"1.0 chunked\",\n        );\n    }\n\n    #[test]\n    fn test_decoder_response() {\n        fn parse(s: &str) -> ParsedMessage<StatusCode> {\n            parse_with_method(s, Method::GET)\n        }\n\n        fn parse_ignores(s: &str) {\n            let mut bytes = BytesMut::from(s);\n            assert!(Client::parse(\n                &mut bytes,\n                ParseContext {\n                    cached_headers: &mut None,\n                    req_method: &mut Some(Method::GET),\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                }\n            )\n            .expect(\"parse ok\")\n            .is_none())\n        }\n\n        fn parse_with_method(s: &str, m: Method) -> ParsedMessage<StatusCode> {\n            let mut bytes = BytesMut::from(s);\n            Client::parse(\n                &mut bytes,\n                ParseContext {\n                    cached_headers: &mut None,\n                    req_method: &mut Some(m),\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                },\n            )\n            .expect(\"parse ok\")\n            .expect(\"parse complete\")\n        }\n\n        fn parse_err(s: &str) -> crate::error::Parse {\n            let mut bytes = BytesMut::from(s);\n            Client::parse(\n                &mut bytes,\n                ParseContext {\n                    cached_headers: &mut None,\n                    req_method: &mut Some(Method::GET),\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                },\n            )\n            .expect_err(\"parse should err\")\n        }\n\n        // no content-length or transfer-encoding means close-delimited\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CLOSE_DELIMITED\n        );\n\n        // 204 and 304 never have a body\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 204 No Content\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::ZERO\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 304 Not Modified\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::ZERO\n        );\n\n        // content-length\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 content-length: 8\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::new(8)\n        );\n\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 content-length: 8\\r\\n\\\n                 content-length: 8\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::new(8)\n        );\n\n        parse_err(\n            \"\\\n             HTTP/1.1 200 OK\\r\\n\\\n             content-length: 8\\r\\n\\\n             content-length: 9\\r\\n\\\n             \\r\\n\\\n             \",\n        );\n\n        // transfer-encoding: chunked\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        // transfer-encoding not-chunked is close-delimited\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 transfer-encoding: yolo\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CLOSE_DELIMITED\n        );\n\n        // transfer-encoding and content-length = chunked\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 content-length: 10\\r\\n\\\n                 transfer-encoding: chunked\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CHUNKED\n        );\n\n        // HEAD can have content-length, but not body\n        assert_eq!(\n            parse_with_method(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 content-length: 8\\r\\n\\\n                 \\r\\n\\\n                 \",\n                Method::HEAD\n            )\n            .decode,\n            DecodedLength::ZERO\n        );\n\n        // CONNECT with 200 never has body\n        {\n            let msg = parse_with_method(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 \\r\\n\\\n                 \",\n                Method::CONNECT,\n            );\n            assert_eq!(msg.decode, DecodedLength::ZERO);\n            assert!(!msg.keep_alive, \"should be upgrade\");\n            assert!(msg.wants_upgrade, \"should be upgrade\");\n        }\n\n        // CONNECT receiving non 200 can have a body\n        assert_eq!(\n            parse_with_method(\n                \"\\\n                 HTTP/1.1 400 Bad Request\\r\\n\\\n                 \\r\\n\\\n                 \",\n                Method::CONNECT\n            )\n            .decode,\n            DecodedLength::CLOSE_DELIMITED\n        );\n\n        // 1xx status codes\n        parse_ignores(\n            \"\\\n             HTTP/1.1 100 Continue\\r\\n\\\n             \\r\\n\\\n             \",\n        );\n\n        parse_ignores(\n            \"\\\n             HTTP/1.1 103 Early Hints\\r\\n\\\n             \\r\\n\\\n             \",\n        );\n\n        // 101 upgrade not supported yet\n        {\n            let msg = parse(\n                \"\\\n                 HTTP/1.1 101 Switching Protocols\\r\\n\\\n                 \\r\\n\\\n                 \",\n            );\n            assert_eq!(msg.decode, DecodedLength::ZERO);\n            assert!(!msg.keep_alive, \"should be last\");\n            assert!(msg.wants_upgrade, \"should be upgrade\");\n        }\n\n        // http/1.0\n        assert_eq!(\n            parse(\n                \"\\\n                 HTTP/1.0 200 OK\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .decode,\n            DecodedLength::CLOSE_DELIMITED\n        );\n\n        // 1.0 doesn't understand chunked\n        parse_err(\n            \"\\\n             HTTP/1.0 200 OK\\r\\n\\\n             transfer-encoding: chunked\\r\\n\\\n             \\r\\n\\\n             \",\n        );\n\n        // keep-alive\n        assert!(\n            parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 content-length: 0\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .keep_alive,\n            \"HTTP/1.1 keep-alive is default\"\n        );\n\n        assert!(\n            !parse(\n                \"\\\n                 HTTP/1.1 200 OK\\r\\n\\\n                 content-length: 0\\r\\n\\\n                 connection: foo, close, bar\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .keep_alive,\n            \"connection close is always close\"\n        );\n\n        assert!(\n            !parse(\n                \"\\\n                 HTTP/1.0 200 OK\\r\\n\\\n                 content-length: 0\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .keep_alive,\n            \"HTTP/1.0 close is default\"\n        );\n\n        assert!(\n            parse(\n                \"\\\n                 HTTP/1.0 200 OK\\r\\n\\\n                 content-length: 0\\r\\n\\\n                 connection: foo, keep-alive, bar\\r\\n\\\n                 \\r\\n\\\n                 \"\n            )\n            .keep_alive,\n            \"connection keep-alive is always keep-alive\"\n        );\n    }\n\n    #[test]\n    fn test_client_request_encode_title_case() {\n        use crate::proto::BodyLength;\n        use http::header::HeaderValue;\n\n        let mut head = MessageHead::default();\n        head.headers\n            .insert(\"content-length\", HeaderValue::from_static(\"10\"));\n        head.headers\n            .insert(\"content-type\", HeaderValue::from_static(\"application/json\"));\n        head.headers.insert(\"*-*\", HeaderValue::from_static(\"o_o\"));\n\n        let mut vec = Vec::new();\n        Client::encode(\n            Encode {\n                head: &mut head,\n                body: Some(BodyLength::Known(10)),\n                keep_alive: true,\n                req_method: &mut None,\n                title_case_headers: true,\n            },\n            &mut vec,\n        )\n        .unwrap();\n\n        assert_eq!(vec, b\"GET / HTTP/1.1\\r\\nContent-Length: 10\\r\\nContent-Type: application/json\\r\\n*-*: o_o\\r\\n\\r\\n\".to_vec());\n    }\n\n    #[test]\n    fn test_server_encode_connect_method() {\n        let mut head = MessageHead::default();\n\n        let mut vec = Vec::new();\n        let encoder = Server::encode(\n            Encode {\n                head: &mut head,\n                body: None,\n                keep_alive: true,\n                req_method: &mut Some(Method::CONNECT),\n                title_case_headers: false,\n            },\n            &mut vec,\n        )\n        .unwrap();\n\n        assert!(encoder.is_last());\n    }\n\n    #[test]\n    fn parse_header_htabs() {\n        let mut bytes = BytesMut::from(\"HTTP/1.1 200 OK\\r\\nserver: hello\\tworld\\r\\n\\r\\n\");\n        let parsed = Client::parse(\n            &mut bytes,\n            ParseContext {\n                cached_headers: &mut None,\n                req_method: &mut Some(Method::GET),\n                #[cfg(feature = \"ffi\")]\n                preserve_header_case: false,\n            },\n        )\n        .expect(\"parse ok\")\n        .expect(\"parse complete\");\n\n        assert_eq!(parsed.head.headers[\"server\"], \"hello\\tworld\");\n    }\n\n    #[cfg(feature = \"ffi\")]\n    #[test]\n    fn test_write_headers_orig_case_empty_value() {\n        let mut headers = HeaderMap::new();\n        let name = http::header::HeaderName::from_static(\"x-empty\");\n        headers.insert(&name, \"\".parse().expect(\"parse empty\"));\n        let mut orig_cases = crate::ffi::HeaderCaseMap::default();\n        orig_cases.insert(name, Bytes::from_static(b\"X-EmptY\"));\n\n        let mut dst = Vec::new();\n        super::write_headers_original_case(&headers, &orig_cases, &mut dst);\n\n        assert_eq!(\n            dst, b\"X-EmptY:\\r\\n\",\n            \"there should be no space between the colon and CRLF\"\n        );\n    }\n\n    #[cfg(feature = \"ffi\")]\n    #[test]\n    fn test_write_headers_orig_case_multiple_entries() {\n        let mut headers = HeaderMap::new();\n        let name = http::header::HeaderName::from_static(\"x-empty\");\n        headers.insert(&name, \"a\".parse().unwrap());\n        headers.append(&name, \"b\".parse().unwrap());\n\n        let mut orig_cases = crate::ffi::HeaderCaseMap::default();\n        orig_cases.insert(name.clone(), Bytes::from_static(b\"X-Empty\"));\n        orig_cases.append(name, Bytes::from_static(b\"X-EMPTY\"));\n\n        let mut dst = Vec::new();\n        super::write_headers_original_case(&headers, &orig_cases, &mut dst);\n\n        assert_eq!(dst, b\"X-Empty: a\\r\\nX-EMPTY: b\\r\\n\");\n    }\n\n    #[cfg(feature = \"nightly\")]\n    use test::Bencher;\n\n    #[cfg(feature = \"nightly\")]\n    #[bench]\n    fn bench_parse_incoming(b: &mut Bencher) {\n        let mut raw = BytesMut::from(\n            &b\"GET /super_long_uri/and_whatever?what_should_we_talk_about/\\\n            I_wonder/Hard_to_write_in_an_uri_after_all/you_have_to_make\\\n            _up_the_punctuation_yourself/how_fun_is_that?test=foo&test1=\\\n            foo1&test2=foo2&test3=foo3&test4=foo4 HTTP/1.1\\r\\nHost: \\\n            hyper.rs\\r\\nAccept: a lot of things\\r\\nAccept-Charset: \\\n            utf8\\r\\nAccept-Encoding: *\\r\\nAccess-Control-Allow-\\\n            Credentials: None\\r\\nAccess-Control-Allow-Origin: None\\r\\n\\\n            Access-Control-Allow-Methods: None\\r\\nAccess-Control-Allow-\\\n            Headers: None\\r\\nContent-Encoding: utf8\\r\\nContent-Security-\\\n            Policy: None\\r\\nContent-Type: text/html\\r\\nOrigin: hyper\\\n            \\r\\nSec-Websocket-Extensions: It looks super important!\\r\\n\\\n            Sec-Websocket-Origin: hyper\\r\\nSec-Websocket-Version: 4.3\\r\\\n            \\nStrict-Transport-Security: None\\r\\nUser-Agent: hyper\\r\\n\\\n            X-Content-Duration: None\\r\\nX-Content-Security-Policy: None\\\n            \\r\\nX-DNSPrefetch-Control: None\\r\\nX-Frame-Options: \\\n            Something important obviously\\r\\nX-Requested-With: Nothing\\\n            \\r\\n\\r\\n\"[..],\n        );\n        let len = raw.len();\n        let mut headers = Some(HeaderMap::new());\n\n        b.bytes = len as u64;\n        b.iter(|| {\n            let mut msg = Server::parse(\n                &mut raw,\n                ParseContext {\n                    cached_headers: &mut headers,\n                    req_method: &mut None,\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                },\n            )\n            .unwrap()\n            .unwrap();\n            ::test::black_box(&msg);\n            msg.head.headers.clear();\n            headers = Some(msg.head.headers);\n            restart(&mut raw, len);\n        });\n\n        fn restart(b: &mut BytesMut, len: usize) {\n            b.reserve(1);\n            unsafe {\n                b.set_len(len);\n            }\n        }\n    }\n\n    #[cfg(feature = \"nightly\")]\n    #[bench]\n    fn bench_parse_short(b: &mut Bencher) {\n        let s = &b\"GET / HTTP/1.1\\r\\nHost: localhost:8080\\r\\n\\r\\n\"[..];\n        let mut raw = BytesMut::from(s);\n        let len = raw.len();\n        let mut headers = Some(HeaderMap::new());\n\n        b.bytes = len as u64;\n        b.iter(|| {\n            let mut msg = Server::parse(\n                &mut raw,\n                ParseContext {\n                    cached_headers: &mut headers,\n                    req_method: &mut None,\n                    #[cfg(feature = \"ffi\")]\n                    preserve_header_case: false,\n                },\n            )\n            .unwrap()\n            .unwrap();\n            ::test::black_box(&msg);\n            msg.head.headers.clear();\n            headers = Some(msg.head.headers);\n            restart(&mut raw, len);\n        });\n\n        fn restart(b: &mut BytesMut, len: usize) {\n            b.reserve(1);\n            unsafe {\n                b.set_len(len);\n            }\n        }\n    }\n\n    #[cfg(feature = \"nightly\")]\n    #[bench]\n    fn bench_server_encode_headers_preset(b: &mut Bencher) {\n        use crate::proto::BodyLength;\n        use http::header::HeaderValue;\n\n        let len = 108;\n        b.bytes = len as u64;\n\n        let mut head = MessageHead::default();\n        let mut headers = HeaderMap::new();\n        headers.insert(\"content-length\", HeaderValue::from_static(\"10\"));\n        headers.insert(\"content-type\", HeaderValue::from_static(\"application/json\"));\n\n        b.iter(|| {\n            let mut vec = Vec::new();\n            head.headers = headers.clone();\n            Server::encode(\n                Encode {\n                    head: &mut head,\n                    body: Some(BodyLength::Known(10)),\n                    keep_alive: true,\n                    req_method: &mut Some(Method::GET),\n                    title_case_headers: false,\n                },\n                &mut vec,\n            )\n            .unwrap();\n            assert_eq!(vec.len(), len);\n            ::test::black_box(vec);\n        })\n    }\n\n    #[cfg(feature = \"nightly\")]\n    #[bench]\n    fn bench_server_encode_no_headers(b: &mut Bencher) {\n        use crate::proto::BodyLength;\n\n        let len = 76;\n        b.bytes = len as u64;\n\n        let mut head = MessageHead::default();\n        let mut vec = Vec::with_capacity(128);\n\n        b.iter(|| {\n            Server::encode(\n                Encode {\n                    head: &mut head,\n                    body: Some(BodyLength::Known(10)),\n                    keep_alive: true,\n                    req_method: &mut Some(Method::GET),\n                    title_case_headers: false,\n                },\n                &mut vec,\n            )\n            .unwrap();\n            assert_eq!(vec.len(), len);\n            ::test::black_box(&vec);\n\n            vec.clear();\n        })\n    }\n}\n"], "filenames": ["src/proto/h1/role.rs"], "buggy_code_start_loc": [215], "buggy_code_end_loc": [1446], "fixing_code_start_loc": [216], "fixing_code_end_loc": [1459], "type": "CWE-444", "message": "hyper is an open-source HTTP library for Rust (crates.io). In hyper from version 0.12.0 and before versions 0.13.10 and 0.14.3 there is a vulnerability that can enable a request smuggling attack. The HTTP server code had a flaw that incorrectly understands some requests with multiple transfer-encoding headers to have a chunked payload, when it should have been rejected as illegal. This combined with an upstream HTTP proxy that understands the request payload boundary differently can result in \"request smuggling\" or \"desync attacks\". To determine if vulnerable, all these things must be true: 1) Using hyper as an HTTP server (the client is not affected), 2) Using HTTP/1.1 (HTTP/2 does not use transfer-encoding), 3) Using a vulnerable HTTP proxy upstream to hyper. If an upstream proxy correctly rejects the illegal transfer-encoding headers, the desync attack cannot succeed. If there is no proxy upstream of hyper, hyper cannot start the desync attack, as the client will repair the headers before forwarding. This is fixed in versions 0.14.3 and 0.13.10. As a workaround one can take the following options: 1) Reject requests that contain a `transfer-encoding` header, 2) Ensure any upstream proxy handles `transfer-encoding` correctly.", "other": {"cve": {"id": "CVE-2021-21299", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-11T18:15:16.800", "lastModified": "2021-02-19T18:28:26.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "hyper is an open-source HTTP library for Rust (crates.io). In hyper from version 0.12.0 and before versions 0.13.10 and 0.14.3 there is a vulnerability that can enable a request smuggling attack. The HTTP server code had a flaw that incorrectly understands some requests with multiple transfer-encoding headers to have a chunked payload, when it should have been rejected as illegal. This combined with an upstream HTTP proxy that understands the request payload boundary differently can result in \"request smuggling\" or \"desync attacks\". To determine if vulnerable, all these things must be true: 1) Using hyper as an HTTP server (the client is not affected), 2) Using HTTP/1.1 (HTTP/2 does not use transfer-encoding), 3) Using a vulnerable HTTP proxy upstream to hyper. If an upstream proxy correctly rejects the illegal transfer-encoding headers, the desync attack cannot succeed. If there is no proxy upstream of hyper, hyper cannot start the desync attack, as the client will repair the headers before forwarding. This is fixed in versions 0.14.3 and 0.13.10. As a workaround one can take the following options: 1) Reject requests that contain a `transfer-encoding` header, 2) Ensure any upstream proxy handles `transfer-encoding` correctly."}, {"lang": "es", "value": "hyper es una biblioteca HTTP de c\u00f3digo abierto para Rust (crates.io).&#xa0;En Hyper desde la versi\u00f3n 0.12.0 y antes de las versiones 0.13.10 y 0.14.3, se presenta una vulnerabilidad que puede habilitar un ataque de trafico no autorizado de peticiones.&#xa0;El c\u00f3digo del servidor HTTP ten\u00eda un fallo que entiende incorrectamente que algunas peticiones con m\u00faltiples encabezados transfer-encoding tienen una carga \u00fatil fragmentada, cuando deber\u00eda haber sido rechazada como ilegal.&#xa0;Esto, combinado con un proxy HTTP aguas arriba que entiende el l\u00edmite de carga \u00fatil de la petici\u00f3n de manera diferente, puede resultar en \"request smuggling\" o \"desync attacks\".&#xa0;Para determinar si es vulnerable, todas estas cosas deben ser ciertas: 1) Usar Hyper como servidor HTTP (el cliente no se ve afectado), 2) Usar HTTP/1.1 (HTTP/2 no usa transfer-encoding), 3) Usar un Proxy HTTP vulnerable aguas arriba de hiper.&#xa0;Si un proxy aguas arriba rechaza correctamente los encabezados transfer-encoding ilegales, el ataque de desincronizaci\u00f3n no puede tener \u00e9xito.&#xa0;Si no existe un proxy aguas arriba de Hyper, Hyper no puede iniciar el ataque de desincronizaci\u00f3n, ya que el cliente reparar\u00e1 los encabezados antes de reenviar.&#xa0;Esto se corrige en las versiones 0.14.3 y 0.13.10.&#xa0;Como soluci\u00f3n alternativa, se pueden tomar las siguientes opciones: 1) Rechazar las peticiones que contengan un encabezado \"transfer-encoding\", 2) Asegurarse de que cualquier proxy ascendente maneje correctamente \"transfer-encoding\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:hyper:hyper:*:*:*:*:*:rust:*:*", "versionStartIncluding": "0.12.0", "versionEndExcluding": "0.13.10", "matchCriteriaId": "F7FC7D00-33F1-4ACB-8092-470E14701DA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:hyper:hyper:*:*:*:*:*:rust:*:*", "versionStartIncluding": "0.14.0", "versionEndExcluding": "0.14.3", "matchCriteriaId": "E4C26856-B337-4B3F-80FA-B417727F07B2"}]}]}], "references": [{"url": "https://crates.io/crates/hyper", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}, {"url": "https://github.com/hyperium/hyper/commit/8f93123efef5c1361086688fe4f34c83c89cec02", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hyperium/hyper/security/advisories/GHSA-6hfq-h8hq-87mf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://rustsec.org/advisories/RUSTSEC-2021-0020.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hyperium/hyper/commit/8f93123efef5c1361086688fe4f34c83c89cec02"}}