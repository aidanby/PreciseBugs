{"buggy_code": ["<?php\n/**\n * TestLink Open Source Project - http://testlink.sourceforge.net/ \n * This script is distributed under the GNU General Public License 2 or later. \n *\n * Login page with configuratin checking and authorization\n *\n * @filesource  login.php\n * @package     TestLink\n * @copyright   2006,2019 TestLink community \n * @link        http://www.testlink.org\n * \n **/\n\nrequire_once('lib/functions/configCheck.php');\ncheckConfiguration();\nrequire_once('config.inc.php');\nrequire_once('common.php');\nrequire_once('oauth_api.php');\nrequire_once('doAuthorize.php');\n\n$templateCfg = templateConfiguration();\n$doRenderLoginScreen = false;\n$doAuthPostProcess = false;\n\ndoDBConnect($db, database::ONERROREXIT);\n$args = init_args();\n$gui = init_gui($db,$args);\n\n// if these checks fail => we will redirect to login screen with some message\ndoBlockingChecks($db,$gui);\n\nswitch($args->action) {\n  case 'doLogin':\n  case 'ajaxlogin':\n    doSessionStart(true);\n     \n    // When doing ajax login we need to skip control regarding session already open\n    // that we use when doing normal login.\n    // If we do not proceed this way we will enter an infinite loop\n    $options = new stdClass();\n    $options->doSessionExistsCheck = ($args->action =='doLogin');\n    $op = doAuthorize($db,$args->login,$args->pwd,$options);\n    $doAuthPostProcess = true;\n    $gui->draw = true;\n  break;\n\n  case 'ajaxcheck':\n    processAjaxCheck($db);\n  break;\n\n\n  case 'oauth':\n    // If code is empty then break\n    if (!isset($args->oauth_code)){\n        renderLoginScreen($gui);\n        die();\n    }\n\n    // Switch between oauth providers\n    if (!include_once('lib/functions/oauth_providers/'.$args->oauth_name.'.php')) {\n        die(\"Oauth client doesn't exist\");\n    }\n\n    $oau = config_get('OAuthServers');\n    foreach ($oau as $oprov) {\n      if (strcmp($oprov['oauth_name'],$args->oauth_name) == 0){\n        $oauth_params = $oprov;\n        break;\n      }\n    }\n\n    $user_token = oauth_get_token($oauth_params, $args->oauth_code);\n    if($user_token->status['status'] == tl::OK) {\n      doSessionStart(true);\n      $op = doAuthorize($db,$user_token->options->user,'oauth',$user_token->options);\n      $doAuthPostProcess = true;\n    } else {\n\t$gui->note = $user_token->status['msg'];\n\t$gui->draw=true;    \n        renderLoginScreen($gui);\n        die();\n    }\n  break;\n\n  case 'loginform':\n    $doRenderLoginScreen = true;\n    $gui->draw = true;\n    $op = null;\n\n    // unfortunatelly we use $args->note in order to do some logic.\n    if( ($args->note=trim($args->note)) == \"\" ) {\n      if( $gui->authCfg['SSO_enabled'] ) {\n        doSessionStart(true);\n        $doAuthPostProcess = true;\n        \n        switch ($gui->authCfg['SSO_method']) {\n          case 'CLIENT_CERTIFICATE':\n            $op = doSSOClientCertificate($db,$_SERVER,$gui->authCfg);\n          break;\n          \n          case 'WEBSERVER_VAR':\n            //DEBUGsyslogOnCloud('Trying to execute SSO using SAML');\n            $op = doSSOWebServerVar($db,$gui->authCfg);\n          break;\n        }\n      }\n    }\n  break;\n}\n\nif( $doAuthPostProcess ) {\n  list($doRenderLoginScreen,$gui->note) = authorizePostProcessing($args,$op);\n}\n\nif( $doRenderLoginScreen ) {\n  renderLoginScreen($gui);\n}\n\n/**\n * \n *\n */\nfunction init_args() {\n  $pwdInputLen = config_get('loginPagePasswordMaxLenght');\n\n  // 2010904 - eloff - Why is req and reqURI parameters to the login?\n  $iParams = array(\"note\" => array(tlInputParameter::STRING_N,0,255),\n                   \"tl_login\" => array(tlInputParameter::STRING_N,0,100),\n                   \"tl_password\" => array(tlInputParameter::STRING_N,0,$pwdInputLen),\n                   \"req\" => array(tlInputParameter::STRING_N,0,4000),\n                   \"reqURI\" => array(tlInputParameter::STRING_N,0,4000),\n                   \"action\" => array(tlInputParameter::STRING_N,0, 10),\n                   \"destination\" => array(tlInputParameter::STRING_N, 0, 255),\n                   \"loginform_token\" => array(tlInputParameter::STRING_N, 0, 255),\n                   \"viewer\" => array(tlInputParameter::STRING_N, 0, 3),\n                   \"oauth\" => array(tlInputParameter::STRING_N,0,100),\n                   \"code\" => array(tlInputParameter::STRING_N,0,4000),\n                   \"state\" => array(tlInputParameter::STRING_N,0,100),\n                  );\n  $pParams = R_PARAMS($iParams);\n\n  $args = new stdClass();\n  $args->note = $pParams['note'];\n  $args->login = $pParams['tl_login'];\n\n  $args->pwd = $pParams['tl_password'];\n  $args->ssodisable = getSSODisable();\n  $args->reqURI = urlencode($pParams['req']);\n  $args->preqURI = urlencode($pParams['reqURI']);\n  $args->destination = urldecode($pParams['destination']);\n  $args->loginform_token = urldecode($pParams['loginform_token']);\n\n  $args->viewer = $pParams['viewer']; \n\n  $k2c = array('ajaxcheck' => 'do','ajaxlogin' => 'do');\n  if (isset($k2c[$pParams['action']]))  {\n    $args->action = $pParams['action'];\n  } else if (!is_null($args->login)) {\n    $args->action = 'doLogin';\n  // This 'if' branch may be removed in later versions. Kept for compatibility    \n  } else if (!is_null($pParams['oauth']) && $pParams['oauth']) {\n    $args->action = 'oauth';\n    $args->oauth_name = $pParams['oauth'];\n    $args->oauth_code = $pParams['code'];\n  } else if (!is_null($pParams['state']) && !is_null($pParams['code'])) {\n    $args->action = 'oauth';\n    $args->oauth_name = $pParams['state'];\n    $args->oauth_code = $pParams['code'];\n  } else {\n    $args->action = 'loginform';\n  }\n\n  // whitelist oauth_name\n  if (strcasecmp($args->action,'oauth') == 0) {\n    validateOauth($args->oauth_name);\n  }\n\n  return $args;\n}\n\n/**\n *\n */\nfunction validateOauth($name) {\n  $name = trim($name);\n  $oauthServers = config_get('OAuthServers');\n  $whitelistOK = false;\n  foreach ($oauthServers as $serverCfg) {\n    if (strcasecmp($name, $serverCfg['oauth_name']) == 0) {\n      $whitelistOK = true;\n      break;\n    }\n  }\n\n  if ($whitelistOK == false) {\n    die(\"Invalid Oauth Service\");\n  } \n}\n\n/**\n * \n *\n */\nfunction init_gui(&$db,$args) {\n  $gui = new stdClass();\n  $gui->viewer = $args->viewer;\n\n  $secCfg = config_get('config_check_warning_frequence');\n  $gui->securityNotes = '';\n  if( (strcmp($secCfg, 'ALWAYS') == 0) || \n      (strcmp($secCfg, 'ONCE_FOR_SESSION') == 0 && !isset($_SESSION['getSecurityNotesDone'])) ) {\n    $_SESSION['getSecurityNotesDone'] = 1;\n    $gui->securityNotes = getSecurityNotes($db);\n  }  \n\n  $gui->authCfg = config_get('authentication');\n  $gui->user_self_signup = config_get('user_self_signup');\n\n  // Oauth buttons\n  $oau = config_get('OAuthServers');\n  $gui->oauth = array();\n  foreach ($oau as $oauth_prov) {\n    if ($oauth_prov['oauth_enabled']) {\n        $name = $oauth_prov['oauth_name'];\n        $gui->oauth[$name] = new stdClass();\n        $gui->oauth[$name]->name = ucfirst($name);\n        $gui->oauth[$name]->link = oauth_link($oauth_prov);\n        $gui->oauth[$name]->icon = $name . '.png';\n    }\n  }\n\n  $gui->external_password_mgmt = false;\n  $domain = $gui->authCfg['domain'];\n  $mm = $gui->authCfg['method'];\n  if( isset($domain[$mm]) ) {\n    $ac = $domain[$mm];\n    $gui->external_password_mgmt = !$ac['allowPasswordManagement'];\n  }  \n\n  $gui->login_disabled = (('LDAP' == $gui->authCfg['method']) && !checkForLDAPExtension()) ? 1 : 0;\n\n  switch($args->note) {\n    case 'expired':\n      if(!isset($_SESSION)) {\n        session_start();\n      }\n      session_unset();\n      session_destroy();\n      $gui->note = lang_get('session_expired');\n      $gui->reqURI = null;\n    break;\n        \n    case 'first':\n      $gui->note = lang_get('your_first_login');\n      $gui->reqURI = null;\n    break;\n        \n    case 'lost':\n      $gui->note = lang_get('passwd_lost');\n      $gui->reqURI = null;\n    break;\n        \n    default:\n      $gui->note = '';\n    break;\n  }\n\n  $gui->ssodisable = 0;\n  if(property_exists($args,'ssodisable')) {\n    $gui->ssodisable = $args->ssodisable;\n  }  \n\n  $gui->reqURI = $args->reqURI ? $args->reqURI : $args->preqURI;\n  $gui->destination = $args->destination;\n  $gui->pwdInputMaxLenght = config_get('loginPagePasswordMaxLenght');\n  \n\n  // Random Background\n  $imgSet = array();\n  $imgSet[] = \"wp-testing04.jpg\";\n  $imgSet[] = \"Fedora-24-Default-Wallpaper-1.png\";\n  $imgSet[] = \"fedora-76343.jpg\";\n  $imgSet[] = \"fedora-hex_0.002.png\";\n  $imgSet[] = \"fedora-x.jpeg\";\n  $imgSet[] = \"fedora21.png-1024x640.jpg\";\n  $imgSet[] = \"fedora28.png\";\n\n  $itemQty = count($imgSet)-1;\n  $ixx = rand(0,$itemQty);\n\n  $gui->loginBackgroundImg = \n    \"gui/templates/dashio/img/login/\" . $imgSet[$ixx]; \n  \n  return $gui;\n}\n\n\n/**\n * doBlockingChecks\n *\n * wrong Schema version will BLOCK ANY login action\n *\n * @param &$dbHandler DataBase Handler\n * @param &$guiObj some gui elements that will be used to give feedback\n *  \n */\nfunction doBlockingChecks(&$dbHandler,&$guiObj) {\n  $op = checkSchemaVersion($dbHandler);\n  if( $op['status'] < tl::OK ) {\n    // Houston we have a problem\n    // This check to kill session was added to avoid following situation\n    // TestLink 1.9.5 installed\n    // Install TestLink 1.9.6 in another folder, pointing to same OLD DB\n    // you logged in TL 1.9.5 => session is created\n    // you try to login to 1.9.6, you get the Update DB Schema message but\n    // anyway because a LIVE AND VALID session you are allowed to login => BAD\n    if(isset($op['kill_session']) && $op['kill_session']) {\n      session_unset();\n      session_destroy();\n    } \n\n    $guiObj->draw = false;\n    $guiObj->note = $op['msg'];\n    renderLoginScreen($guiObj);\n    die();\n  }\n}\n\n\n/**\n * renderLoginScreen\n * simple piece of code used to clean up code layout\n * \n * @global  $g_tlLogger\n * @param stdClassObject $guiObj\n */\nfunction renderLoginScreen($guiObj) {\n  global $g_tlLogger; \n  $templateCfg = templateConfiguration();\n  $logPeriodToDelete = config_get('removeEventsOlderThan');\n  $g_tlLogger->deleteEventsFor(null, strtotime(\"-{$logPeriodToDelete} days UTC\"));\n  \n  $smarty = new TLSmarty();\n  $smarty->assign('gui', $guiObj);\n\n  $templ = config_get('tpl');\n  $tpl = $templ['login'];\n  \n  $smarty->display($tpl);\n}\n\n\n/**\n * \n * @param stdClassObject $argsObj\n * @param hash $op\n */\nfunction authorizePostProcessing($argsObj,$op) {\n  $note = null;\n  $renderLoginScreen = false;\n  if($op['status'] == tl::OK) {\n    // Login successful, redirect to destination\n    logAuditEvent(TLS(\"audit_login_succeeded\",$argsObj->login,\n                  $_SERVER['REMOTE_ADDR']),\"LOGIN\",$_SESSION['currentUser']->dbID,\"users\");\n    \n    if ($argsObj->action == 'ajaxlogin') {\n      echo json_encode(array('success' => true));\n    } else {\n      // If destination param is set redirect to given page ...\n      if (!empty($argsObj->destination) && preg_match(\"/linkto.php/\", $argsObj->destination)) {\n        redirect($argsObj->destination);\n      } else {\n        // ... or show main page\n        $_SESSION['viewer'] = $argsObj->viewer;\n        $ad = $argsObj->ssodisable ? '&ssodisable=1' : '';\n        $ad .= ($argsObj->preqURI ? \"&reqURI=\".urlencode($argsObj->preqURI) :\"\");\n\n        $rul = $_SESSION['basehref'] . \n                 \"index.php?caller=login&viewer={$argsObj->viewer}\" . $ad;\n        \n        redirect($rul);\n      }\n      exit(); // hmm seems is useless\n    }\n  } else {\n    $note = '';\n    if(!$argsObj->ssodisable) {\n      $note = is_null($op['msg']) ? lang_get('bad_user_passwd') : $op['msg'];\n    } \n\n    if($argsObj->action == 'ajaxlogin') {\n      echo json_encode(array('success' => false,'reason' => $note));\n    } else {\n      $renderLoginScreen = true;\n    }\n  }\n  \n  return array($renderLoginScreen,$note);\n}\n\n/**\n * \n *\n */\nfunction processAjaxCheck(&$dbHandler) {\n   // Send a json reply, include localized strings for use in js to display a login form.\n   doSessionStart(true);\n   echo json_encode(array('validSession' => checkSessionValid($dbHandler, false),\n                        'username_label' => lang_get('login_name'),\n                        'password_label' => lang_get('password'),\n                        'login_label' => lang_get('btn_login'),\n                          'timeout_info' => lang_get('timeout_info')));\n\n}\n"], "fixing_code": ["<?php\n/**\n * TestLink Open Source Project - http://testlink.sourceforge.net/ \n * This script is distributed under the GNU General Public License 2 or later. \n *\n * Login page with configuratin checking and authorization\n *\n * @filesource  login.php\n * @package     TestLink\n * @copyright   2006,2019 TestLink community \n * @link        http://www.testlink.org\n * \n **/\n\nrequire_once('lib/functions/configCheck.php');\ncheckConfiguration();\nrequire_once('config.inc.php');\nrequire_once('common.php');\nrequire_once('oauth_api.php');\nrequire_once('doAuthorize.php');\n\n$templateCfg = templateConfiguration();\n$doRenderLoginScreen = false;\n$doAuthPostProcess = false;\n\ndoDBConnect($db, database::ONERROREXIT);\n$args = init_args();\n$gui = init_gui($db,$args);\n\n// if these checks fail => we will redirect to login screen with some message\ndoBlockingChecks($db,$gui);\n\nswitch($args->action) {\n  case 'doLogin':\n  case 'ajaxlogin':\n    doSessionStart(true);\n     \n    // When doing ajax login we need to skip control regarding session already open\n    // that we use when doing normal login.\n    // If we do not proceed this way we will enter an infinite loop\n    $options = new stdClass();\n    $options->doSessionExistsCheck = ($args->action =='doLogin');\n    $op = doAuthorize($db,$args->login,$args->pwd,$options);\n    $doAuthPostProcess = true;\n    $gui->draw = true;\n  break;\n\n  case 'ajaxcheck':\n    processAjaxCheck($db);\n  break;\n\n\n  case 'oauth':\n    // If code is empty then break\n    if (!isset($args->oauth_code)){\n        renderLoginScreen($gui);\n        die();\n    }\n\n    // Switch between oauth providers\n    if (!include_once('lib/functions/oauth_providers/'.$args->oauth_name.'.php')) {\n        die(\"Oauth client doesn't exist\");\n    }\n\n    $oau = config_get('OAuthServers');\n    foreach ($oau as $oprov) {\n      if (strcmp($oprov['oauth_name'],$args->oauth_name) == 0){\n        $oauth_params = $oprov;\n        break;\n      }\n    }\n\n    $user_token = oauth_get_token($oauth_params, $args->oauth_code);\n    if($user_token->status['status'] == tl::OK) {\n      doSessionStart(true);\n      $op = doAuthorize($db,$user_token->options->user,'oauth',$user_token->options);\n      $doAuthPostProcess = true;\n    } else {\n\t$gui->note = $user_token->status['msg'];\n\t$gui->draw=true;    \n        renderLoginScreen($gui);\n        die();\n    }\n  break;\n\n  case 'loginform':\n    $doRenderLoginScreen = true;\n    $gui->draw = true;\n    $op = null;\n\n    // unfortunatelly we use $args->note in order to do some logic.\n    if( ($args->note=trim($args->note)) == \"\" ) {\n      if( $gui->authCfg['SSO_enabled'] ) {\n        doSessionStart(true);\n        $doAuthPostProcess = true;\n        \n        switch ($gui->authCfg['SSO_method']) {\n          case 'CLIENT_CERTIFICATE':\n            $op = doSSOClientCertificate($db,$_SERVER,$gui->authCfg);\n          break;\n          \n          case 'WEBSERVER_VAR':\n            //DEBUGsyslogOnCloud('Trying to execute SSO using SAML');\n            $op = doSSOWebServerVar($db,$gui->authCfg);\n          break;\n        }\n      }\n    }\n  break;\n}\n\nif( $doAuthPostProcess ) {\n  list($doRenderLoginScreen,$gui->note) = authorizePostProcessing($args,$op);\n}\n\nif( $doRenderLoginScreen ) {\n  renderLoginScreen($gui);\n}\n\n/**\n * \n *\n */\nfunction init_args() {\n  $pwdInputLen = config_get('loginPagePasswordMaxLenght');\n\n  // 2010904 - eloff - Why is req and reqURI parameters to the login?\n  $iParams = array(\"note\" => array(tlInputParameter::STRING_N,0,255),\n                   \"tl_login\" => array(tlInputParameter::STRING_N,0,100),\n                   \"tl_password\" => array(tlInputParameter::STRING_N,0,$pwdInputLen),\n                   \"req\" => array(tlInputParameter::STRING_N,0,4000),\n                   \"reqURI\" => array(tlInputParameter::STRING_N,0,4000),\n                   \"action\" => array(tlInputParameter::STRING_N,0, 10),\n                   \"destination\" => array(tlInputParameter::STRING_N, 0, 255),\n                   \"loginform_token\" => array(tlInputParameter::STRING_N, 0, 255),\n                   \"viewer\" => array(tlInputParameter::STRING_N, 0, 3),\n                   \"oauth\" => array(tlInputParameter::STRING_N,0,100),\n                   \"code\" => array(tlInputParameter::STRING_N,0,4000),\n                   \"state\" => array(tlInputParameter::STRING_N,0,100),\n                  );\n  $pParams = R_PARAMS($iParams);\n\n  $args = new stdClass();\n  $args->note = $pParams['note'];\n  $args->login = $pParams['tl_login'];\n\n  $args->pwd = $pParams['tl_password'];\n  $args->ssodisable = getSSODisable();\n  $args->reqURI = urlencode($pParams['req']);\n  $args->preqURI = urlencode($pParams['reqURI']);\n  $args->destination = urldecode($pParams['destination']);\n  $args->loginform_token = urldecode($pParams['loginform_token']);\n\n  // $args->viewer = $pParams['viewer']; \n  $args->viewer = '';\n\n  $k2c = array('ajaxcheck' => 'do','ajaxlogin' => 'do');\n  if (isset($k2c[$pParams['action']]))  {\n    $args->action = $pParams['action'];\n  } else if (!is_null($args->login)) {\n    $args->action = 'doLogin';\n  // This 'if' branch may be removed in later versions. Kept for compatibility    \n  } else if (!is_null($pParams['oauth']) && $pParams['oauth']) {\n    $args->action = 'oauth';\n    $args->oauth_name = $pParams['oauth'];\n    $args->oauth_code = $pParams['code'];\n  } else if (!is_null($pParams['state']) && !is_null($pParams['code'])) {\n    $args->action = 'oauth';\n    $args->oauth_name = $pParams['state'];\n    $args->oauth_code = $pParams['code'];\n  } else {\n    $args->action = 'loginform';\n  }\n\n  // whitelist oauth_name\n  if (strcasecmp($args->action,'oauth') == 0) {\n    validateOauth($args->oauth_name);\n  }\n\n  return $args;\n}\n\n/**\n *\n */\nfunction validateOauth($name) {\n  $name = trim($name);\n  $oauthServers = config_get('OAuthServers');\n  $whitelistOK = false;\n  foreach ($oauthServers as $serverCfg) {\n    if (strcasecmp($name, $serverCfg['oauth_name']) == 0) {\n      $whitelistOK = true;\n      break;\n    }\n  }\n\n  if ($whitelistOK == false) {\n    die(\"Invalid Oauth Service\");\n  } \n}\n\n/**\n * \n *\n */\nfunction init_gui(&$db,$args) {\n  $gui = new stdClass();\n  $gui->viewer = $args->viewer;\n\n  $secCfg = config_get('config_check_warning_frequence');\n  $gui->securityNotes = '';\n  if( (strcmp($secCfg, 'ALWAYS') == 0) || \n      (strcmp($secCfg, 'ONCE_FOR_SESSION') == 0 && !isset($_SESSION['getSecurityNotesDone'])) ) {\n    $_SESSION['getSecurityNotesDone'] = 1;\n    $gui->securityNotes = getSecurityNotes($db);\n  }  \n\n  $gui->authCfg = config_get('authentication');\n  $gui->user_self_signup = config_get('user_self_signup');\n\n  // Oauth buttons\n  $oau = config_get('OAuthServers');\n  $gui->oauth = array();\n  foreach ($oau as $oauth_prov) {\n    if ($oauth_prov['oauth_enabled']) {\n        $name = $oauth_prov['oauth_name'];\n        $gui->oauth[$name] = new stdClass();\n        $gui->oauth[$name]->name = ucfirst($name);\n        $gui->oauth[$name]->link = oauth_link($oauth_prov);\n        $gui->oauth[$name]->icon = $name . '.png';\n    }\n  }\n\n  $gui->external_password_mgmt = false;\n  $domain = $gui->authCfg['domain'];\n  $mm = $gui->authCfg['method'];\n  if( isset($domain[$mm]) ) {\n    $ac = $domain[$mm];\n    $gui->external_password_mgmt = !$ac['allowPasswordManagement'];\n  }  \n\n  $gui->login_disabled = (('LDAP' == $gui->authCfg['method']) && !checkForLDAPExtension()) ? 1 : 0;\n\n  switch($args->note) {\n    case 'expired':\n      if(!isset($_SESSION)) {\n        session_start();\n      }\n      session_unset();\n      session_destroy();\n      $gui->note = lang_get('session_expired');\n      $gui->reqURI = null;\n    break;\n        \n    case 'first':\n      $gui->note = lang_get('your_first_login');\n      $gui->reqURI = null;\n    break;\n        \n    case 'lost':\n      $gui->note = lang_get('passwd_lost');\n      $gui->reqURI = null;\n    break;\n        \n    default:\n      $gui->note = '';\n    break;\n  }\n\n  $gui->ssodisable = 0;\n  if(property_exists($args,'ssodisable')) {\n    $gui->ssodisable = $args->ssodisable;\n  }  \n\n  $gui->reqURI = $args->reqURI ? $args->reqURI : $args->preqURI;\n  $gui->destination = $args->destination;\n  $gui->pwdInputMaxLenght = config_get('loginPagePasswordMaxLenght');\n  \n\n  // Random Background\n  $imgSet = array();\n  $imgSet[] = \"wp-testing04.jpg\";\n  $imgSet[] = \"Fedora-24-Default-Wallpaper-1.png\";\n  $imgSet[] = \"fedora-76343.jpg\";\n  $imgSet[] = \"fedora-hex_0.002.png\";\n  $imgSet[] = \"fedora-x.jpeg\";\n  $imgSet[] = \"fedora21.png-1024x640.jpg\";\n  $imgSet[] = \"fedora28.png\";\n\n  $itemQty = count($imgSet)-1;\n  $ixx = rand(0,$itemQty);\n\n  $gui->loginBackgroundImg = \n    \"gui/templates/dashio/img/login/\" . $imgSet[$ixx]; \n  \n  return $gui;\n}\n\n\n/**\n * doBlockingChecks\n *\n * wrong Schema version will BLOCK ANY login action\n *\n * @param &$dbHandler DataBase Handler\n * @param &$guiObj some gui elements that will be used to give feedback\n *  \n */\nfunction doBlockingChecks(&$dbHandler,&$guiObj) {\n  $op = checkSchemaVersion($dbHandler);\n  if( $op['status'] < tl::OK ) {\n    // Houston we have a problem\n    // This check to kill session was added to avoid following situation\n    // TestLink 1.9.5 installed\n    // Install TestLink 1.9.6 in another folder, pointing to same OLD DB\n    // you logged in TL 1.9.5 => session is created\n    // you try to login to 1.9.6, you get the Update DB Schema message but\n    // anyway because a LIVE AND VALID session you are allowed to login => BAD\n    if(isset($op['kill_session']) && $op['kill_session']) {\n      session_unset();\n      session_destroy();\n    } \n\n    $guiObj->draw = false;\n    $guiObj->note = $op['msg'];\n    renderLoginScreen($guiObj);\n    die();\n  }\n}\n\n\n/**\n * renderLoginScreen\n * simple piece of code used to clean up code layout\n * \n * @global  $g_tlLogger\n * @param stdClassObject $guiObj\n */\nfunction renderLoginScreen($guiObj) {\n  global $g_tlLogger; \n  $templateCfg = templateConfiguration();\n  $logPeriodToDelete = config_get('removeEventsOlderThan');\n  $g_tlLogger->deleteEventsFor(null, strtotime(\"-{$logPeriodToDelete} days UTC\"));\n  \n  $smarty = new TLSmarty();\n  $smarty->assign('gui', $guiObj);\n\n  $templ = config_get('tpl');\n  $tpl = $templ['login'];\n  \n  $smarty->display($tpl);\n}\n\n\n/**\n * \n * @param stdClassObject $argsObj\n * @param hash $op\n */\nfunction authorizePostProcessing($argsObj,$op) {\n  $note = null;\n  $renderLoginScreen = false;\n  if($op['status'] == tl::OK) {\n    // Login successful, redirect to destination\n    logAuditEvent(TLS(\"audit_login_succeeded\",$argsObj->login,\n                  $_SERVER['REMOTE_ADDR']),\"LOGIN\",$_SESSION['currentUser']->dbID,\"users\");\n    \n    if ($argsObj->action == 'ajaxlogin') {\n      echo json_encode(array('success' => true));\n    } else {\n      // If destination param is set redirect to given page ...\n      if (!empty($argsObj->destination) && preg_match(\"/linkto.php/\", $argsObj->destination)) {\n        redirect($argsObj->destination);\n      } else {\n        // ... or show main page\n        $_SESSION['viewer'] = $argsObj->viewer;\n        $ad = $argsObj->ssodisable ? '&ssodisable=1' : '';\n        $ad .= ($argsObj->preqURI ? \"&reqURI=\".urlencode($argsObj->preqURI) :\"\");\n\n        $rul = $_SESSION['basehref'] . \n                 \"index.php?caller=login&viewer={$argsObj->viewer}\" . $ad;\n        \n        redirect($rul);\n      }\n      exit(); // hmm seems is useless\n    }\n  } else {\n    $note = '';\n    if(!$argsObj->ssodisable) {\n      $note = is_null($op['msg']) ? lang_get('bad_user_passwd') : $op['msg'];\n    } \n\n    if($argsObj->action == 'ajaxlogin') {\n      echo json_encode(array('success' => false,'reason' => $note));\n    } else {\n      $renderLoginScreen = true;\n    }\n  }\n  \n  return array($renderLoginScreen,$note);\n}\n\n/**\n * \n *\n */\nfunction processAjaxCheck(&$dbHandler) {\n   // Send a json reply, include localized strings for use in js to display a login form.\n   doSessionStart(true);\n   echo json_encode(array('validSession' => checkSessionValid($dbHandler, false),\n                        'username_label' => lang_get('login_name'),\n                        'password_label' => lang_get('password'),\n                        'login_label' => lang_get('btn_login'),\n                          'timeout_info' => lang_get('timeout_info')));\n\n}\n"], "filenames": ["login.php"], "buggy_code_start_loc": [154], "buggy_code_end_loc": [155], "fixing_code_start_loc": [154], "fixing_code_end_loc": [156], "type": "CWE-311", "message": "In TestLink 1.9.20, a crafted login.php viewer parameter exposes cleartext credentials.", "other": {"cve": {"id": "CVE-2020-12273", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-27T13:15:12.507", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In TestLink 1.9.20, a crafted login.php viewer parameter exposes cleartext credentials."}, {"lang": "es", "value": "En TestLink versi\u00f3n 1.9.20, un par\u00e1metro viewer del archivo login.php especialmente  dise\u00f1ado expone las credenciales de texto sin cifrar."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-311"}, {"lang": "en", "value": "CWE-522"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:testlink:testlink:1.9.20:*:*:*:*:*:*:*", "matchCriteriaId": "1007C963-3BC2-41CF-9C5F-C8F54EAAAF8A"}]}]}], "references": [{"url": "http://mantis.testlink.org/view.php?id=8895", "source": "cve@mitre.org", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://github.com/TestLinkOpenSourceTRMS/testlink-code/commit/72271ef057e6e4a95c6128973902ea646f7b5462", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/TestLinkOpenSourceTRMS/testlink-code/commit/72271ef057e6e4a95c6128973902ea646f7b5462"}}