{"buggy_code": ["/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n                    This module by Zoltan Herczeg\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2021 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"pcre2_internal.h\"\n\n#ifdef SUPPORT_JIT\n\n/* All-in-one: Since we use the JIT compiler only from here,\nwe just include it. This way we don't need to touch the build\nsystem files. */\n\n#define SLJIT_CONFIG_AUTO 1\n#define SLJIT_CONFIG_STATIC 1\n#define SLJIT_VERBOSE 0\n\n#ifdef PCRE2_DEBUG\n#define SLJIT_DEBUG 1\n#else\n#define SLJIT_DEBUG 0\n#endif\n\n#define SLJIT_MALLOC(size, allocator_data) pcre2_jit_malloc(size, allocator_data)\n#define SLJIT_FREE(ptr, allocator_data) pcre2_jit_free(ptr, allocator_data)\n\nstatic void * pcre2_jit_malloc(size_t size, void *allocator_data)\n{\npcre2_memctl *allocator = ((pcre2_memctl*)allocator_data);\nreturn allocator->malloc(size, allocator->memory_data);\n}\n\nstatic void pcre2_jit_free(void *ptr, void *allocator_data)\n{\npcre2_memctl *allocator = ((pcre2_memctl*)allocator_data);\nallocator->free(ptr, allocator->memory_data);\n}\n\n#include \"sljit/sljitLir.c\"\n\n#if defined SLJIT_CONFIG_UNSUPPORTED && SLJIT_CONFIG_UNSUPPORTED\n#error Unsupported architecture\n#endif\n\n/* Defines for debugging purposes. */\n\n/* 1 - Use unoptimized capturing brackets.\n   2 - Enable capture_last_ptr (includes option 1). */\n/* #define DEBUG_FORCE_UNOPTIMIZED_CBRAS 2 */\n\n/* 1 - Always have a control head. */\n/* #define DEBUG_FORCE_CONTROL_HEAD 1 */\n\n/* Allocate memory for the regex stack on the real machine stack.\nFast, but limited size. */\n#define MACHINE_STACK_SIZE 32768\n\n/* Growth rate for stack allocated by the OS. Should be the multiply\nof page size. */\n#define STACK_GROWTH_RATE 8192\n\n/* Enable to check that the allocation could destroy temporaries. */\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n#define DESTROY_REGISTERS 1\n#endif\n\n/*\nShort summary about the backtracking mechanism empolyed by the jit code generator:\n\nThe code generator follows the recursive nature of the PERL compatible regular\nexpressions. The basic blocks of regular expressions are condition checkers\nwhose execute different commands depending on the result of the condition check.\nThe relationship between the operators can be horizontal (concatenation) and\nvertical (sub-expression) (See struct backtrack_common for more details).\n\n  'ab' - 'a' and 'b' regexps are concatenated\n  'a+' - 'a' is the sub-expression of the '+' operator\n\nThe condition checkers are boolean (true/false) checkers. Machine code is generated\nfor the checker itself and for the actions depending on the result of the checker.\nThe 'true' case is called as the matching path (expected path), and the other is called as\nthe 'backtrack' path. Branch instructions are expesive for all CPUs, so we avoid taken\nbranches on the matching path.\n\n Greedy star operator (*) :\n   Matching path: match happens.\n   Backtrack path: match failed.\n Non-greedy star operator (*?) :\n   Matching path: no need to perform a match.\n   Backtrack path: match is required.\n\nThe following example shows how the code generated for a capturing bracket\nwith two alternatives. Let A, B, C, D are arbirary regular expressions, and\nwe have the following regular expression:\n\n   A(B|C)D\n\nThe generated code will be the following:\n\n A matching path\n '(' matching path (pushing arguments to the stack)\n B matching path\n ')' matching path (pushing arguments to the stack)\n D matching path\n return with successful match\n\n D backtrack path\n ')' backtrack path (If we arrived from \"C\" jump to the backtrack of \"C\")\n B backtrack path\n C expected path\n jump to D matching path\n C backtrack path\n A backtrack path\n\n Notice, that the order of backtrack code paths are the opposite of the fast\n code paths. In this way the topmost value on the stack is always belong\n to the current backtrack code path. The backtrack path must check\n whether there is a next alternative. If so, it needs to jump back to\n the matching path eventually. Otherwise it needs to clear out its own stack\n frame and continue the execution on the backtrack code paths.\n*/\n\n/*\nSaved stack frames:\n\nAtomic blocks and asserts require reloading the values of private data\nwhen the backtrack mechanism performed. Because of OP_RECURSE, the data\nare not necessarly known in compile time, thus we need a dynamic restore\nmechanism.\n\nThe stack frames are stored in a chain list, and have the following format:\n([ capturing bracket offset ][ start value ][ end value ])+ ... [ 0 ] [ previous head ]\n\nThus we can restore the private data to a particular point in the stack.\n*/\n\ntypedef struct jit_arguments {\n  /* Pointers first. */\n  struct sljit_stack *stack;\n  PCRE2_SPTR str;\n  PCRE2_SPTR begin;\n  PCRE2_SPTR end;\n  pcre2_match_data *match_data;\n  PCRE2_SPTR startchar_ptr;\n  PCRE2_UCHAR *mark_ptr;\n  int (*callout)(pcre2_callout_block *, void *);\n  void *callout_data;\n  /* Everything else after. */\n  sljit_uw offset_limit;\n  sljit_u32 limit_match;\n  sljit_u32 oveccount;\n  sljit_u32 options;\n} jit_arguments;\n\n#define JIT_NUMBER_OF_COMPILE_MODES 3\n\ntypedef struct executable_functions {\n  void *executable_funcs[JIT_NUMBER_OF_COMPILE_MODES];\n  void *read_only_data_heads[JIT_NUMBER_OF_COMPILE_MODES];\n  sljit_uw executable_sizes[JIT_NUMBER_OF_COMPILE_MODES];\n  sljit_u32 top_bracket;\n  sljit_u32 limit_match;\n} executable_functions;\n\ntypedef struct jump_list {\n  struct sljit_jump *jump;\n  struct jump_list *next;\n} jump_list;\n\ntypedef struct stub_list {\n  struct sljit_jump *start;\n  struct sljit_label *quit;\n  struct stub_list *next;\n} stub_list;\n\nenum frame_types {\n  no_frame = -1,\n  no_stack = -2\n};\n\nenum control_types {\n  type_mark = 0,\n  type_then_trap = 1\n};\n\nenum  early_fail_types {\n  type_skip = 0,\n  type_fail = 1,\n  type_fail_range = 2\n};\n\ntypedef int (SLJIT_FUNC *jit_function)(jit_arguments *args);\n\n/* The following structure is the key data type for the recursive\ncode generator. It is allocated by compile_matchingpath, and contains\nthe arguments for compile_backtrackingpath. Must be the first member\nof its descendants. */\ntypedef struct backtrack_common {\n  /* Concatenation stack. */\n  struct backtrack_common *prev;\n  jump_list *nextbacktracks;\n  /* Internal stack (for component operators). */\n  struct backtrack_common *top;\n  jump_list *topbacktracks;\n  /* Opcode pointer. */\n  PCRE2_SPTR cc;\n} backtrack_common;\n\ntypedef struct assert_backtrack {\n  backtrack_common common;\n  jump_list *condfailed;\n  /* Less than 0 if a frame is not needed. */\n  int framesize;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n  /* For iterators. */\n  struct sljit_label *matchingpath;\n} assert_backtrack;\n\ntypedef struct bracket_backtrack {\n  backtrack_common common;\n  /* Where to coninue if an alternative is successfully matched. */\n  struct sljit_label *alternative_matchingpath;\n  /* For rmin and rmax iterators. */\n  struct sljit_label *recursive_matchingpath;\n  /* For greedy ? operator. */\n  struct sljit_label *zero_matchingpath;\n  /* Contains the branches of a failed condition. */\n  union {\n    /* Both for OP_COND, OP_SCOND. */\n    jump_list *condfailed;\n    assert_backtrack *assert;\n    /* For OP_ONCE. Less than 0 if not needed. */\n    int framesize;\n    /* For brackets with >3 alternatives. */\n    struct sljit_put_label *matching_put_label;\n  } u;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n} bracket_backtrack;\n\ntypedef struct bracketpos_backtrack {\n  backtrack_common common;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n  /* Reverting stack is needed. */\n  int framesize;\n  /* Allocated stack size. */\n  int stacksize;\n} bracketpos_backtrack;\n\ntypedef struct braminzero_backtrack {\n  backtrack_common common;\n  struct sljit_label *matchingpath;\n} braminzero_backtrack;\n\ntypedef struct char_iterator_backtrack {\n  backtrack_common common;\n  /* Next iteration. */\n  struct sljit_label *matchingpath;\n  union {\n    jump_list *backtracks;\n    struct {\n      unsigned int othercasebit;\n      PCRE2_UCHAR chr;\n      BOOL enabled;\n    } charpos;\n  } u;\n} char_iterator_backtrack;\n\ntypedef struct ref_iterator_backtrack {\n  backtrack_common common;\n  /* Next iteration. */\n  struct sljit_label *matchingpath;\n} ref_iterator_backtrack;\n\ntypedef struct recurse_entry {\n  struct recurse_entry *next;\n  /* Contains the function entry label. */\n  struct sljit_label *entry_label;\n  /* Contains the function entry label. */\n  struct sljit_label *backtrack_label;\n  /* Collects the entry calls until the function is not created. */\n  jump_list *entry_calls;\n  /* Collects the backtrack calls until the function is not created. */\n  jump_list *backtrack_calls;\n  /* Points to the starting opcode. */\n  sljit_sw start;\n} recurse_entry;\n\ntypedef struct recurse_backtrack {\n  backtrack_common common;\n  /* Return to the matching path. */\n  struct sljit_label *matchingpath;\n  /* Recursive pattern. */\n  recurse_entry *entry;\n  /* Pattern is inlined. */\n  BOOL inlined_pattern;\n} recurse_backtrack;\n\n#define OP_THEN_TRAP OP_TABLE_LENGTH\n\ntypedef struct then_trap_backtrack {\n  backtrack_common common;\n  /* If then_trap is not NULL, this structure contains the real\n  then_trap for the backtracking path. */\n  struct then_trap_backtrack *then_trap;\n  /* Points to the starting opcode. */\n  sljit_sw start;\n  /* Exit point for the then opcodes of this alternative. */\n  jump_list *quit;\n  /* Frame size of the current alternative. */\n  int framesize;\n} then_trap_backtrack;\n\n#define MAX_N_CHARS 12\n#define MAX_DIFF_CHARS 5\n\ntypedef struct fast_forward_char_data {\n  /* Number of characters in the chars array, 255 for any character. */\n  sljit_u8 count;\n  /* Number of last UTF-8 characters in the chars array. */\n  sljit_u8 last_count;\n  /* Available characters in the current position. */\n  PCRE2_UCHAR chars[MAX_DIFF_CHARS];\n} fast_forward_char_data;\n\n#define MAX_CLASS_RANGE_SIZE 4\n#define MAX_CLASS_CHARS_SIZE 3\n\ntypedef struct compiler_common {\n  /* The sljit ceneric compiler. */\n  struct sljit_compiler *compiler;\n  /* Compiled regular expression. */\n  pcre2_real_code *re;\n  /* First byte code. */\n  PCRE2_SPTR start;\n  /* Maps private data offset to each opcode. */\n  sljit_s32 *private_data_ptrs;\n  /* Chain list of read-only data ptrs. */\n  void *read_only_data_head;\n  /* Tells whether the capturing bracket is optimized. */\n  sljit_u8 *optimized_cbracket;\n  /* Tells whether the starting offset is a target of then. */\n  sljit_u8 *then_offsets;\n  /* Current position where a THEN must jump. */\n  then_trap_backtrack *then_trap;\n  /* Starting offset of private data for capturing brackets. */\n  sljit_s32 cbra_ptr;\n  /* Output vector starting point. Must be divisible by 2. */\n  sljit_s32 ovector_start;\n  /* Points to the starting character of the current match. */\n  sljit_s32 start_ptr;\n  /* Last known position of the requested byte. */\n  sljit_s32 req_char_ptr;\n  /* Head of the last recursion. */\n  sljit_s32 recursive_head_ptr;\n  /* First inspected character for partial matching.\n     (Needed for avoiding zero length partial matches.) */\n  sljit_s32 start_used_ptr;\n  /* Starting pointer for partial soft matches. */\n  sljit_s32 hit_start;\n  /* Pointer of the match end position. */\n  sljit_s32 match_end_ptr;\n  /* Points to the marked string. */\n  sljit_s32 mark_ptr;\n  /* Recursive control verb management chain. */\n  sljit_s32 control_head_ptr;\n  /* Points to the last matched capture block index. */\n  sljit_s32 capture_last_ptr;\n  /* Fast forward skipping byte code pointer. */\n  PCRE2_SPTR fast_forward_bc_ptr;\n  /* Locals used by fast fail optimization. */\n  sljit_s32 early_fail_start_ptr;\n  sljit_s32 early_fail_end_ptr;\n\n  /* Flipped and lower case tables. */\n  const sljit_u8 *fcc;\n  sljit_sw lcc;\n  /* Mode can be PCRE2_JIT_COMPLETE and others. */\n  int mode;\n  /* TRUE, when empty match is accepted for partial matching. */\n  BOOL allow_empty_partial;\n  /* TRUE, when minlength is greater than 0. */\n  BOOL might_be_empty;\n  /* \\K is found in the pattern. */\n  BOOL has_set_som;\n  /* (*SKIP:arg) is found in the pattern. */\n  BOOL has_skip_arg;\n  /* (*THEN) is found in the pattern. */\n  BOOL has_then;\n  /* (*SKIP) or (*SKIP:arg) is found in lookbehind assertion. */\n  BOOL has_skip_in_assert_back;\n  /* Quit is redirected by recurse, negative assertion, or positive assertion in conditional block. */\n  BOOL local_quit_available;\n  /* Currently in a positive assertion. */\n  BOOL in_positive_assertion;\n  /* Newline control. */\n  int nltype;\n  sljit_u32 nlmax;\n  sljit_u32 nlmin;\n  int newline;\n  int bsr_nltype;\n  sljit_u32 bsr_nlmax;\n  sljit_u32 bsr_nlmin;\n  /* Dollar endonly. */\n  int endonly;\n  /* Tables. */\n  sljit_sw ctypes;\n  /* Named capturing brackets. */\n  PCRE2_SPTR name_table;\n  sljit_sw name_count;\n  sljit_sw name_entry_size;\n\n  /* Labels and jump lists. */\n  struct sljit_label *partialmatchlabel;\n  struct sljit_label *quit_label;\n  struct sljit_label *abort_label;\n  struct sljit_label *accept_label;\n  struct sljit_label *ff_newline_shortcut;\n  stub_list *stubs;\n  recurse_entry *entries;\n  recurse_entry *currententry;\n  jump_list *partialmatch;\n  jump_list *quit;\n  jump_list *positive_assertion_quit;\n  jump_list *abort;\n  jump_list *failed_match;\n  jump_list *accept;\n  jump_list *calllimit;\n  jump_list *stackalloc;\n  jump_list *revertframes;\n  jump_list *wordboundary;\n  jump_list *anynewline;\n  jump_list *hspace;\n  jump_list *vspace;\n  jump_list *casefulcmp;\n  jump_list *caselesscmp;\n  jump_list *reset_match;\n  BOOL unset_backref;\n  BOOL alt_circumflex;\n#ifdef SUPPORT_UNICODE\n  BOOL utf;\n  BOOL invalid_utf;\n  BOOL ucp;\n  /* Points to saving area for iref. */\n  sljit_s32 iref_ptr;\n  jump_list *getucd;\n  jump_list *getucdtype;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  jump_list *utfreadchar;\n  jump_list *utfreadtype8;\n  jump_list *utfpeakcharback;\n#endif\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\n  jump_list *utfreadchar_invalid;\n  jump_list *utfreadnewline_invalid;\n  jump_list *utfmoveback_invalid;\n  jump_list *utfpeakcharback_invalid;\n#endif\n#endif /* SUPPORT_UNICODE */\n} compiler_common;\n\n/* For byte_sequence_compare. */\n\ntypedef struct compare_context {\n  int length;\n  int sourcereg;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  int ucharptr;\n  union {\n    sljit_s32 asint;\n    sljit_u16 asushort;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    sljit_u8 asbyte;\n    sljit_u8 asuchars[4];\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    sljit_u16 asuchars[2];\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n    sljit_u32 asuchars[1];\n#endif\n  } c;\n  union {\n    sljit_s32 asint;\n    sljit_u16 asushort;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    sljit_u8 asbyte;\n    sljit_u8 asuchars[4];\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    sljit_u16 asuchars[2];\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n    sljit_u32 asuchars[1];\n#endif\n  } oc;\n#endif\n} compare_context;\n\n/* Undefine sljit macros. */\n#undef CMP\n\n/* Used for accessing the elements of the stack. */\n#define STACK(i)      ((i) * (int)sizeof(sljit_sw))\n\n#ifdef SLJIT_PREF_SHIFT_REG\n#if SLJIT_PREF_SHIFT_REG == SLJIT_R2\n/* Nothing. */\n#elif SLJIT_PREF_SHIFT_REG == SLJIT_R3\n#define SHIFT_REG_IS_R3\n#else\n#error \"Unsupported shift register\"\n#endif\n#endif\n\n#define TMP1          SLJIT_R0\n#ifdef SHIFT_REG_IS_R3\n#define TMP2          SLJIT_R3\n#define TMP3          SLJIT_R2\n#else\n#define TMP2          SLJIT_R2\n#define TMP3          SLJIT_R3\n#endif\n#define STR_PTR       SLJIT_R1\n#define STR_END       SLJIT_S0\n#define STACK_TOP     SLJIT_S1\n#define STACK_LIMIT   SLJIT_S2\n#define COUNT_MATCH   SLJIT_S3\n#define ARGUMENTS     SLJIT_S4\n#define RETURN_ADDR   SLJIT_R4\n\n#if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)\n#define HAS_VIRTUAL_REGISTERS 1\n#else\n#define HAS_VIRTUAL_REGISTERS 0\n#endif\n\n/* Local space layout. */\n/* These two locals can be used by the current opcode. */\n#define LOCALS0          (0 * sizeof(sljit_sw))\n#define LOCALS1          (1 * sizeof(sljit_sw))\n/* Two local variables for possessive quantifiers (char1 cannot use them). */\n#define POSSESSIVE0      (2 * sizeof(sljit_sw))\n#define POSSESSIVE1      (3 * sizeof(sljit_sw))\n/* Max limit of recursions. */\n#define LIMIT_MATCH      (4 * sizeof(sljit_sw))\n/* The output vector is stored on the stack, and contains pointers\nto characters. The vector data is divided into two groups: the first\ngroup contains the start / end character pointers, and the second is\nthe start pointers when the end of the capturing group has not yet reached. */\n#define OVECTOR_START    (common->ovector_start)\n#define OVECTOR(i)       (OVECTOR_START + (i) * (sljit_sw)sizeof(sljit_sw))\n#define OVECTOR_PRIV(i)  (common->cbra_ptr + (i) * (sljit_sw)sizeof(sljit_sw))\n#define PRIVATE_DATA(cc) (common->private_data_ptrs[(cc) - common->start])\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#define MOV_UCHAR  SLJIT_MOV_U8\n#define IN_UCHARS(x) (x)\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n#define MOV_UCHAR  SLJIT_MOV_U16\n#define UCHAR_SHIFT (1)\n#define IN_UCHARS(x) ((x) * 2)\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n#define MOV_UCHAR  SLJIT_MOV_U32\n#define UCHAR_SHIFT (2)\n#define IN_UCHARS(x) ((x) * 4)\n#else\n#error Unsupported compiling mode\n#endif\n\n/* Shortcuts. */\n#define DEFINE_COMPILER \\\n  struct sljit_compiler *compiler = common->compiler\n#define OP1(op, dst, dstw, src, srcw) \\\n  sljit_emit_op1(compiler, (op), (dst), (dstw), (src), (srcw))\n#define OP2(op, dst, dstw, src1, src1w, src2, src2w) \\\n  sljit_emit_op2(compiler, (op), (dst), (dstw), (src1), (src1w), (src2), (src2w))\n#define OP2U(op, src1, src1w, src2, src2w) \\\n  sljit_emit_op2u(compiler, (op), (src1), (src1w), (src2), (src2w))\n#define OP_SRC(op, src, srcw) \\\n  sljit_emit_op_src(compiler, (op), (src), (srcw))\n#define LABEL() \\\n  sljit_emit_label(compiler)\n#define JUMP(type) \\\n  sljit_emit_jump(compiler, (type))\n#define JUMPTO(type, label) \\\n  sljit_set_label(sljit_emit_jump(compiler, (type)), (label))\n#define JUMPHERE(jump) \\\n  sljit_set_label((jump), sljit_emit_label(compiler))\n#define SET_LABEL(jump, label) \\\n  sljit_set_label((jump), (label))\n#define CMP(type, src1, src1w, src2, src2w) \\\n  sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w))\n#define CMPTO(type, src1, src1w, src2, src2w, label) \\\n  sljit_set_label(sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w)), (label))\n#define OP_FLAGS(op, dst, dstw, type) \\\n  sljit_emit_op_flags(compiler, (op), (dst), (dstw), (type))\n#define CMOV(type, dst_reg, src, srcw) \\\n  sljit_emit_cmov(compiler, (type), (dst_reg), (src), (srcw))\n#define GET_LOCAL_BASE(dst, dstw, offset) \\\n  sljit_get_local_base(compiler, (dst), (dstw), (offset))\n\n#define READ_CHAR_MAX 0x7fffffff\n\n#define INVALID_UTF_CHAR -1\n#define UNASSIGNED_UTF_CHAR 888\n\n#if defined SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr[0] <= 0x7f) \\\n    c = *ptr++; \\\n  else if (ptr + 1 < end && ptr[1] >= 0x80 && ptr[1] < 0xc0) \\\n    { \\\n    c = ptr[1] - 0x80; \\\n    \\\n    if (ptr[0] >= 0xc2 && ptr[0] <= 0xdf) \\\n      { \\\n      c |= (ptr[0] - 0xc0) << 6; \\\n      ptr += 2; \\\n      } \\\n    else if (ptr + 2 < end && ptr[2] >= 0x80 && ptr[2] < 0xc0) \\\n      { \\\n      c = c << 6 | (ptr[2] - 0x80); \\\n      \\\n      if (ptr[0] >= 0xe0 && ptr[0] <= 0xef) \\\n        { \\\n        c |= (ptr[0] - 0xe0) << 12; \\\n        ptr += 3; \\\n        \\\n        if (c < 0x800 || (c >= 0xd800 && c < 0xe000)) \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else if (ptr + 3 < end && ptr[3] >= 0x80 && ptr[3] < 0xc0) \\\n        { \\\n        c = c << 6 | (ptr[3] - 0x80); \\\n        \\\n        if (ptr[0] >= 0xf0 && ptr[0] <= 0xf4) \\\n          { \\\n          c |= (ptr[0] - 0xf0) << 18; \\\n          ptr += 4; \\\n          \\\n          if (c >= 0x110000 || c < 0x10000) \\\n            { \\\n            invalid_action; \\\n            } \\\n          } \\\n        else \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else \\\n        { \\\n        invalid_action; \\\n        } \\\n      } \\\n    else \\\n      { \\\n      invalid_action; \\\n      } \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr[-1]; \\\n  if (c <= 0x7f) \\\n    ptr--; \\\n  else if (ptr - 1 > start && ptr[-1] >= 0x80 && ptr[-1] < 0xc0) \\\n    { \\\n    c -= 0x80; \\\n    \\\n    if (ptr[-2] >= 0xc2 && ptr[-2] <= 0xdf) \\\n      { \\\n      c |= (ptr[-2] - 0xc0) << 6; \\\n      ptr -= 2; \\\n      } \\\n    else if (ptr - 2 > start && ptr[-2] >= 0x80 && ptr[-2] < 0xc0) \\\n      { \\\n      c = c << 6 | (ptr[-2] - 0x80); \\\n      \\\n      if (ptr[-3] >= 0xe0 && ptr[-3] <= 0xef) \\\n        { \\\n        c |= (ptr[-3] - 0xe0) << 12; \\\n        ptr -= 3; \\\n        \\\n        if (c < 0x800 || (c >= 0xd800 && c < 0xe000)) \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else if (ptr - 3 > start && ptr[-3] >= 0x80 && ptr[-3] < 0xc0) \\\n        { \\\n        c = c << 6 | (ptr[-3] - 0x80); \\\n        \\\n        if (ptr[-4] >= 0xf0 && ptr[-4] <= 0xf4) \\\n          { \\\n          c |= (ptr[-4] - 0xf0) << 18; \\\n          ptr -= 4; \\\n          \\\n          if (c >= 0x110000 || c < 0x10000) \\\n            { \\\n            invalid_action; \\\n            } \\\n          } \\\n        else \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else \\\n        { \\\n        invalid_action; \\\n        } \\\n      } \\\n    else \\\n      { \\\n      invalid_action; \\\n      } \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr[0] < 0xd800 || ptr[0] >= 0xe000) \\\n    c = *ptr++; \\\n  else if (ptr[0] < 0xdc00 && ptr + 1 < end && ptr[1] >= 0xdc00 && ptr[1] < 0xe000) \\\n    { \\\n    c = (((ptr[0] - 0xd800) << 10) | (ptr[1] - 0xdc00)) + 0x10000; \\\n    ptr += 2; \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr[-1]; \\\n  if (c < 0xd800 || c >= 0xe000) \\\n    ptr--; \\\n  else if (c >= 0xdc00 && ptr - 1 > start && ptr[-2] >= 0xd800 && ptr[-2] < 0xdc00) \\\n    { \\\n    c = (((ptr[-2] - 0xd800) << 10) | (c - 0xdc00)) + 0x10000; \\\n    ptr -= 2; \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr[0] < 0xd800 || (ptr[0] >= 0xe000 && ptr[0] < 0x110000)) \\\n    c = *ptr++; \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr[-1]; \\\n  if (ptr[-1] < 0xd800 || (ptr[-1] >= 0xe000 && ptr[-1] < 0x110000)) \\\n    ptr--; \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n\nstatic PCRE2_SPTR bracketend(PCRE2_SPTR cc)\n{\nSLJIT_ASSERT((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND));\ndo cc += GET(cc, 1); while (*cc == OP_ALT);\nSLJIT_ASSERT(*cc >= OP_KET && *cc <= OP_KETRPOS);\ncc += 1 + LINK_SIZE;\nreturn cc;\n}\n\nstatic int no_alternatives(PCRE2_SPTR cc)\n{\nint count = 0;\nSLJIT_ASSERT((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND));\ndo\n  {\n  cc += GET(cc, 1);\n  count++;\n  }\nwhile (*cc == OP_ALT);\nSLJIT_ASSERT(*cc >= OP_KET && *cc <= OP_KETRPOS);\nreturn count;\n}\n\n/* Functions whose might need modification for all new supported opcodes:\n next_opcode\n check_opcode_types\n set_private_data_ptrs\n get_framesize\n init_frame\n get_recurse_data_length\n copy_recurse_data\n compile_matchingpath\n compile_backtrackingpath\n*/\n\nstatic PCRE2_SPTR next_opcode(compiler_common *common, PCRE2_SPTR cc)\n{\nSLJIT_UNUSED_ARG(common);\nswitch(*cc)\n  {\n  case OP_SOD:\n  case OP_SOM:\n  case OP_SET_SOM:\n  case OP_NOT_WORD_BOUNDARY:\n  case OP_WORD_BOUNDARY:\n  case OP_NOT_DIGIT:\n  case OP_DIGIT:\n  case OP_NOT_WHITESPACE:\n  case OP_WHITESPACE:\n  case OP_NOT_WORDCHAR:\n  case OP_WORDCHAR:\n  case OP_ANY:\n  case OP_ALLANY:\n  case OP_NOTPROP:\n  case OP_PROP:\n  case OP_ANYNL:\n  case OP_NOT_HSPACE:\n  case OP_HSPACE:\n  case OP_NOT_VSPACE:\n  case OP_VSPACE:\n  case OP_EXTUNI:\n  case OP_EODN:\n  case OP_EOD:\n  case OP_CIRC:\n  case OP_CIRCM:\n  case OP_DOLL:\n  case OP_DOLLM:\n  case OP_CRSTAR:\n  case OP_CRMINSTAR:\n  case OP_CRPLUS:\n  case OP_CRMINPLUS:\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  case OP_CRPOSSTAR:\n  case OP_CRPOSPLUS:\n  case OP_CRPOSQUERY:\n  case OP_CRPOSRANGE:\n  case OP_CLASS:\n  case OP_NCLASS:\n  case OP_REF:\n  case OP_REFI:\n  case OP_DNREF:\n  case OP_DNREFI:\n  case OP_RECURSE:\n  case OP_CALLOUT:\n  case OP_ALT:\n  case OP_KET:\n  case OP_KETRMAX:\n  case OP_KETRMIN:\n  case OP_KETRPOS:\n  case OP_REVERSE:\n  case OP_ASSERT:\n  case OP_ASSERT_NOT:\n  case OP_ASSERTBACK:\n  case OP_ASSERTBACK_NOT:\n  case OP_ASSERT_NA:\n  case OP_ASSERTBACK_NA:\n  case OP_ONCE:\n  case OP_SCRIPT_RUN:\n  case OP_BRA:\n  case OP_BRAPOS:\n  case OP_CBRA:\n  case OP_CBRAPOS:\n  case OP_COND:\n  case OP_SBRA:\n  case OP_SBRAPOS:\n  case OP_SCBRA:\n  case OP_SCBRAPOS:\n  case OP_SCOND:\n  case OP_CREF:\n  case OP_DNCREF:\n  case OP_RREF:\n  case OP_DNRREF:\n  case OP_FALSE:\n  case OP_TRUE:\n  case OP_BRAZERO:\n  case OP_BRAMINZERO:\n  case OP_BRAPOSZERO:\n  case OP_PRUNE:\n  case OP_SKIP:\n  case OP_THEN:\n  case OP_COMMIT:\n  case OP_FAIL:\n  case OP_ACCEPT:\n  case OP_ASSERT_ACCEPT:\n  case OP_CLOSE:\n  case OP_SKIPZERO:\n  return cc + PRIV(OP_lengths)[*cc];\n\n  case OP_CHAR:\n  case OP_CHARI:\n  case OP_NOT:\n  case OP_NOTI:\n  case OP_STAR:\n  case OP_MINSTAR:\n  case OP_PLUS:\n  case OP_MINPLUS:\n  case OP_QUERY:\n  case OP_MINQUERY:\n  case OP_UPTO:\n  case OP_MINUPTO:\n  case OP_EXACT:\n  case OP_POSSTAR:\n  case OP_POSPLUS:\n  case OP_POSQUERY:\n  case OP_POSUPTO:\n  case OP_STARI:\n  case OP_MINSTARI:\n  case OP_PLUSI:\n  case OP_MINPLUSI:\n  case OP_QUERYI:\n  case OP_MINQUERYI:\n  case OP_UPTOI:\n  case OP_MINUPTOI:\n  case OP_EXACTI:\n  case OP_POSSTARI:\n  case OP_POSPLUSI:\n  case OP_POSQUERYI:\n  case OP_POSUPTOI:\n  case OP_NOTSTAR:\n  case OP_NOTMINSTAR:\n  case OP_NOTPLUS:\n  case OP_NOTMINPLUS:\n  case OP_NOTQUERY:\n  case OP_NOTMINQUERY:\n  case OP_NOTUPTO:\n  case OP_NOTMINUPTO:\n  case OP_NOTEXACT:\n  case OP_NOTPOSSTAR:\n  case OP_NOTPOSPLUS:\n  case OP_NOTPOSQUERY:\n  case OP_NOTPOSUPTO:\n  case OP_NOTSTARI:\n  case OP_NOTMINSTARI:\n  case OP_NOTPLUSI:\n  case OP_NOTMINPLUSI:\n  case OP_NOTQUERYI:\n  case OP_NOTMINQUERYI:\n  case OP_NOTUPTOI:\n  case OP_NOTMINUPTOI:\n  case OP_NOTEXACTI:\n  case OP_NOTPOSSTARI:\n  case OP_NOTPOSPLUSI:\n  case OP_NOTPOSQUERYI:\n  case OP_NOTPOSUPTOI:\n  cc += PRIV(OP_lengths)[*cc];\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n  return cc;\n\n  /* Special cases. */\n  case OP_TYPESTAR:\n  case OP_TYPEMINSTAR:\n  case OP_TYPEPLUS:\n  case OP_TYPEMINPLUS:\n  case OP_TYPEQUERY:\n  case OP_TYPEMINQUERY:\n  case OP_TYPEUPTO:\n  case OP_TYPEMINUPTO:\n  case OP_TYPEEXACT:\n  case OP_TYPEPOSSTAR:\n  case OP_TYPEPOSPLUS:\n  case OP_TYPEPOSQUERY:\n  case OP_TYPEPOSUPTO:\n  return cc + PRIV(OP_lengths)[*cc] - 1;\n\n  case OP_ANYBYTE:\n#ifdef SUPPORT_UNICODE\n  if (common->utf) return NULL;\n#endif\n  return cc + 1;\n\n  case OP_CALLOUT_STR:\n  return cc + GET(cc, 1 + 2*LINK_SIZE);\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n  case OP_XCLASS:\n  return cc + GET(cc, 1);\n#endif\n\n  case OP_MARK:\n  case OP_COMMIT_ARG:\n  case OP_PRUNE_ARG:\n  case OP_SKIP_ARG:\n  case OP_THEN_ARG:\n  return cc + 1 + 2 + cc[1];\n\n  default:\n  SLJIT_UNREACHABLE();\n  return NULL;\n  }\n}\n\nstatic BOOL check_opcode_types(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend)\n{\nint count;\nPCRE2_SPTR slot;\nPCRE2_SPTR assert_back_end = cc - 1;\nPCRE2_SPTR assert_na_end = cc - 1;\n\n/* Calculate important variables (like stack size) and checks whether all opcodes are supported. */\nwhile (cc < ccend)\n  {\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    common->has_set_som = TRUE;\n    common->might_be_empty = TRUE;\n    cc += 1;\n    break;\n\n    case OP_REFI:\n#ifdef SUPPORT_UNICODE\n    if (common->iref_ptr == 0)\n      {\n      common->iref_ptr = common->ovector_start;\n      common->ovector_start += 3 * sizeof(sljit_sw);\n      }\n#endif /* SUPPORT_UNICODE */\n    /* Fall through. */\n    case OP_REF:\n    common->optimized_cbracket[GET2(cc, 1)] = 0;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    slot = bracketend(cc);\n    if (slot > assert_na_end)\n      assert_na_end = slot;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] = 0;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    case OP_SCOND:\n    /* Only AUTO_CALLOUT can insert this opcode. We do\n       not intend to support this case. */\n    if (cc[1 + LINK_SIZE] == OP_CALLOUT || cc[1 + LINK_SIZE] == OP_CALLOUT_STR)\n      return FALSE;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CREF:\n    common->optimized_cbracket[GET2(cc, 1)] = 0;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_DNREF:\n    case OP_DNREFI:\n    case OP_DNCREF:\n    count = GET2(cc, 1 + IMM2_SIZE);\n    slot = common->name_table + GET2(cc, 1) * common->name_entry_size;\n    while (count-- > 0)\n      {\n      common->optimized_cbracket[GET2(slot, 0)] = 0;\n      slot += common->name_entry_size;\n      }\n    cc += 1 + 2 * IMM2_SIZE;\n    break;\n\n    case OP_RECURSE:\n    /* Set its value only once. */\n    if (common->recursive_head_ptr == 0)\n      {\n      common->recursive_head_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    if (common->capture_last_ptr == 0)\n      {\n      common->capture_last_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += (*cc == OP_CALLOUT) ? PRIV(OP_lengths)[OP_CALLOUT] : GET(cc, 1 + 2*LINK_SIZE);\n    break;\n\n    case OP_ASSERTBACK:\n    slot = bracketend(cc);\n    if (slot > assert_back_end)\n      assert_back_end = slot;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_THEN_ARG:\n    common->has_then = TRUE;\n    common->control_head_ptr = 1;\n    /* Fall through. */\n\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    if (cc < assert_na_end)\n      return FALSE;\n    /* Fall through */\n    case OP_MARK:\n    if (common->mark_ptr == 0)\n      {\n      common->mark_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    common->has_then = TRUE;\n    common->control_head_ptr = 1;\n    cc += 1;\n    break;\n\n    case OP_SKIP:\n    if (cc < assert_back_end)\n      common->has_skip_in_assert_back = TRUE;\n    if (cc < assert_na_end)\n      return FALSE;\n    cc += 1;\n    break;\n\n    case OP_SKIP_ARG:\n    common->control_head_ptr = 1;\n    common->has_skip_arg = TRUE;\n    if (cc < assert_back_end)\n      common->has_skip_in_assert_back = TRUE;\n    if (cc < assert_na_end)\n      return FALSE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_COMMIT:\n    case OP_ASSERT_ACCEPT:\n    if (cc < assert_na_end)\n      return FALSE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    if (cc == NULL)\n      return FALSE;\n    break;\n    }\n  }\nreturn TRUE;\n}\n\n#define EARLY_FAIL_ENHANCE_MAX (1 + 3)\n\n/*\nstart:\n  0 - skip / early fail allowed\n  1 - only early fail with range allowed\n  >1 - (start - 1) early fail is processed\n\nreturn: current number of iterators enhanced with fast fail\n*/\nstatic int detect_early_fail(compiler_common *common, PCRE2_SPTR cc, int *private_data_start,\n   sljit_s32 depth, int start, BOOL fast_forward_allowed)\n{\nPCRE2_SPTR begin = cc;\nPCRE2_SPTR next_alt;\nPCRE2_SPTR end;\nPCRE2_SPTR accelerated_start;\nBOOL prev_fast_forward_allowed;\nint result = 0;\nint count;\n\nSLJIT_ASSERT(*cc == OP_ONCE || *cc == OP_BRA || *cc == OP_CBRA);\nSLJIT_ASSERT(*cc != OP_CBRA || common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] != 0);\nSLJIT_ASSERT(start < EARLY_FAIL_ENHANCE_MAX);\n\nnext_alt = cc + GET(cc, 1);\nif (*next_alt == OP_ALT)\n  fast_forward_allowed = FALSE;\n\ndo\n  {\n  count = start;\n  cc += 1 + LINK_SIZE + ((*cc == OP_CBRA) ? IMM2_SIZE : 0);\n\n  while (TRUE)\n    {\n    accelerated_start = NULL;\n\n    switch(*cc)\n      {\n      case OP_SOD:\n      case OP_SOM:\n      case OP_SET_SOM:\n      case OP_NOT_WORD_BOUNDARY:\n      case OP_WORD_BOUNDARY:\n      case OP_EODN:\n      case OP_EOD:\n      case OP_CIRC:\n      case OP_CIRCM:\n      case OP_DOLL:\n      case OP_DOLLM:\n      /* Zero width assertions. */\n      cc++;\n      continue;\n\n      case OP_NOT_DIGIT:\n      case OP_DIGIT:\n      case OP_NOT_WHITESPACE:\n      case OP_WHITESPACE:\n      case OP_NOT_WORDCHAR:\n      case OP_WORDCHAR:\n      case OP_ANY:\n      case OP_ALLANY:\n      case OP_ANYBYTE:\n      case OP_NOT_HSPACE:\n      case OP_HSPACE:\n      case OP_NOT_VSPACE:\n      case OP_VSPACE:\n      fast_forward_allowed = FALSE;\n      cc++;\n      continue;\n\n      case OP_ANYNL:\n      case OP_EXTUNI:\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc++;\n      continue;\n\n      case OP_NOTPROP:\n      case OP_PROP:\n      fast_forward_allowed = FALSE;\n      cc += 1 + 2;\n      continue;\n\n      case OP_CHAR:\n      case OP_CHARI:\n      case OP_NOT:\n      case OP_NOTI:\n      fast_forward_allowed = FALSE;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      continue;\n\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      case OP_TYPEPOSSTAR:\n      case OP_TYPEPOSPLUS:\n      /* The type or prop opcode is skipped in the next iteration. */\n      cc += 1;\n\n      if (cc[0] != OP_ANYNL && cc[0] != OP_EXTUNI)\n        {\n        accelerated_start = cc - 1;\n        break;\n        }\n\n      if (count == 0)\n        count = 1;\n      fast_forward_allowed = FALSE;\n      continue;\n\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      case OP_TYPEEXACT:\n      case OP_TYPEPOSUPTO:\n      cc += IMM2_SIZE;\n      /* Fall through */\n\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      case OP_TYPEPOSQUERY:\n      /* The type or prop opcode is skipped in the next iteration. */\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc += 1;\n      continue;\n\n      case OP_STAR:\n      case OP_MINSTAR:\n      case OP_PLUS:\n      case OP_MINPLUS:\n      case OP_POSSTAR:\n      case OP_POSPLUS:\n\n      case OP_STARI:\n      case OP_MINSTARI:\n      case OP_PLUSI:\n      case OP_MINPLUSI:\n      case OP_POSSTARI:\n      case OP_POSPLUSI:\n\n      case OP_NOTSTAR:\n      case OP_NOTMINSTAR:\n      case OP_NOTPLUS:\n      case OP_NOTMINPLUS:\n      case OP_NOTPOSSTAR:\n      case OP_NOTPOSPLUS:\n\n      case OP_NOTSTARI:\n      case OP_NOTMINSTARI:\n      case OP_NOTPLUSI:\n      case OP_NOTMINPLUSI:\n      case OP_NOTPOSSTARI:\n      case OP_NOTPOSPLUSI:\n      accelerated_start = cc;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      break;\n\n      case OP_UPTO:\n      case OP_MINUPTO:\n      case OP_EXACT:\n      case OP_POSUPTO:\n      case OP_UPTOI:\n      case OP_MINUPTOI:\n      case OP_EXACTI:\n      case OP_POSUPTOI:\n      case OP_NOTUPTO:\n      case OP_NOTMINUPTO:\n      case OP_NOTEXACT:\n      case OP_NOTPOSUPTO:\n      case OP_NOTUPTOI:\n      case OP_NOTMINUPTOI:\n      case OP_NOTEXACTI:\n      case OP_NOTPOSUPTOI:\n      cc += IMM2_SIZE;\n      /* Fall through */\n\n      case OP_QUERY:\n      case OP_MINQUERY:\n      case OP_POSQUERY:\n      case OP_QUERYI:\n      case OP_MINQUERYI:\n      case OP_POSQUERYI:\n      case OP_NOTQUERY:\n      case OP_NOTMINQUERY:\n      case OP_NOTPOSQUERY:\n      case OP_NOTQUERYI:\n      case OP_NOTMINQUERYI:\n      case OP_NOTPOSQUERYI:\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      continue;\n\n      case OP_CLASS:\n      case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n      case OP_XCLASS:\n      accelerated_start = cc;\n      cc += ((*cc == OP_XCLASS) ? GET(cc, 1) : (unsigned int)(1 + (32 / sizeof(PCRE2_UCHAR))));\n#else\n      accelerated_start = cc;\n      cc += (1 + (32 / sizeof(PCRE2_UCHAR)));\n#endif\n\n      switch (*cc)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRPOSSTAR:\n        case OP_CRPOSPLUS:\n        cc++;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        case OP_CRPOSRANGE:\n        cc += 2 * IMM2_SIZE;\n        /* Fall through */\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        case OP_CRPOSQUERY:\n        cc++;\n        if (count == 0)\n          count = 1;\n        /* Fall through */\n        default:\n        accelerated_start = NULL;\n        fast_forward_allowed = FALSE;\n        continue;\n        }\n      break;\n\n      case OP_ONCE:\n      case OP_BRA:\n      case OP_CBRA:\n      end = cc + GET(cc, 1);\n\n      prev_fast_forward_allowed = fast_forward_allowed;\n      fast_forward_allowed = FALSE;\n      if (depth >= 4)\n        break;\n\n      end = bracketend(cc) - (1 + LINK_SIZE);\n      if (*end != OP_KET || (*cc == OP_CBRA && common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0))\n        break;\n\n      count = detect_early_fail(common, cc, private_data_start, depth + 1, count, prev_fast_forward_allowed);\n\n      if (PRIVATE_DATA(cc) != 0)\n        common->private_data_ptrs[begin - common->start] = 1;\n\n      if (count < EARLY_FAIL_ENHANCE_MAX)\n        {\n        cc = end + (1 + LINK_SIZE);\n        continue;\n        }\n      break;\n\n      case OP_KET:\n      SLJIT_ASSERT(PRIVATE_DATA(cc) == 0);\n      if (cc >= next_alt)\n        break;\n      cc += 1 + LINK_SIZE;\n      continue;\n      }\n\n    if (accelerated_start != NULL)\n      {\n      if (count == 0)\n        {\n        count++;\n\n        if (fast_forward_allowed)\n          {\n          common->fast_forward_bc_ptr = accelerated_start;\n          common->private_data_ptrs[(accelerated_start + 1) - common->start] = ((*private_data_start) << 3) | type_skip;\n          *private_data_start += sizeof(sljit_sw);\n          }\n        else\n          {\n          common->private_data_ptrs[(accelerated_start + 1) - common->start] = ((*private_data_start) << 3) | type_fail;\n\n          if (common->early_fail_start_ptr == 0)\n            common->early_fail_start_ptr = *private_data_start;\n\n          *private_data_start += sizeof(sljit_sw);\n          common->early_fail_end_ptr = *private_data_start;\n\n          if (*private_data_start > SLJIT_MAX_LOCAL_SIZE)\n            return EARLY_FAIL_ENHANCE_MAX;\n          }\n        }\n      else\n        {\n        common->private_data_ptrs[(accelerated_start + 1) - common->start] = ((*private_data_start) << 3) | type_fail_range;\n\n        if (common->early_fail_start_ptr == 0)\n          common->early_fail_start_ptr = *private_data_start;\n\n        *private_data_start += 2 * sizeof(sljit_sw);\n        common->early_fail_end_ptr = *private_data_start;\n\n        if (*private_data_start > SLJIT_MAX_LOCAL_SIZE)\n          return EARLY_FAIL_ENHANCE_MAX;\n        }\n\n      /* Cannot be part of a repeat. */\n      common->private_data_ptrs[begin - common->start] = 1;\n      count++;\n\n      if (count < EARLY_FAIL_ENHANCE_MAX)\n        continue;\n      }\n\n    break;\n    }\n\n  if (*cc != OP_ALT && *cc != OP_KET)\n    result = EARLY_FAIL_ENHANCE_MAX;\n  else if (result < count)\n    result = count;\n\n  cc = next_alt;\n  next_alt = cc + GET(cc, 1);\n  }\nwhile (*cc == OP_ALT);\n\nreturn result;\n}\n\nstatic int get_class_iterator_size(PCRE2_SPTR cc)\n{\nsljit_u32 min;\nsljit_u32 max;\nswitch(*cc)\n  {\n  case OP_CRSTAR:\n  case OP_CRPLUS:\n  return 2;\n\n  case OP_CRMINSTAR:\n  case OP_CRMINPLUS:\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  return 1;\n\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  min = GET2(cc, 1);\n  max = GET2(cc, 1 + IMM2_SIZE);\n  if (max == 0)\n    return (*cc == OP_CRRANGE) ? 2 : 1;\n  max -= min;\n  if (max > 2)\n    max = 2;\n  return max;\n\n  default:\n  return 0;\n  }\n}\n\nstatic BOOL detect_repeat(compiler_common *common, PCRE2_SPTR begin)\n{\nPCRE2_SPTR end = bracketend(begin);\nPCRE2_SPTR next;\nPCRE2_SPTR next_end;\nPCRE2_SPTR max_end;\nPCRE2_UCHAR type;\nsljit_sw length = end - begin;\nsljit_s32 min, max, i;\n\n/* Detect fixed iterations first. */\nif (end[-(1 + LINK_SIZE)] != OP_KET || PRIVATE_DATA(begin) != 0)\n  return FALSE;\n\n/* /(?:AB){4,6}/ is currently converted to /(?:AB){3}(?AB){1,3}/\n * Skip the check of the second part. */\nif (PRIVATE_DATA(end - LINK_SIZE) != 0)\n  return TRUE;\n\nnext = end;\nmin = 1;\nwhile (1)\n  {\n  if (*next != *begin)\n    break;\n  next_end = bracketend(next);\n  if (next_end - next != length || memcmp(begin, next, IN_UCHARS(length)) != 0)\n    break;\n  next = next_end;\n  min++;\n  }\n\nif (min == 2)\n  return FALSE;\n\nmax = 0;\nmax_end = next;\nif (*next == OP_BRAZERO || *next == OP_BRAMINZERO)\n  {\n  type = *next;\n  while (1)\n    {\n    if (next[0] != type || next[1] != OP_BRA || next[2 + LINK_SIZE] != *begin)\n      break;\n    next_end = bracketend(next + 2 + LINK_SIZE);\n    if (next_end - next != (length + 2 + LINK_SIZE) || memcmp(begin, next + 2 + LINK_SIZE, IN_UCHARS(length)) != 0)\n      break;\n    next = next_end;\n    max++;\n    }\n\n  if (next[0] == type && next[1] == *begin && max >= 1)\n    {\n    next_end = bracketend(next + 1);\n    if (next_end - next == (length + 1) && memcmp(begin, next + 1, IN_UCHARS(length)) == 0)\n      {\n      for (i = 0; i < max; i++, next_end += 1 + LINK_SIZE)\n        if (*next_end != OP_KET)\n          break;\n\n      if (i == max)\n        {\n        common->private_data_ptrs[max_end - common->start - LINK_SIZE] = next_end - max_end;\n        common->private_data_ptrs[max_end - common->start - LINK_SIZE + 1] = (type == OP_BRAZERO) ? OP_UPTO : OP_MINUPTO;\n        /* +2 the original and the last. */\n        common->private_data_ptrs[max_end - common->start - LINK_SIZE + 2] = max + 2;\n        if (min == 1)\n          return TRUE;\n        min--;\n        max_end -= (1 + LINK_SIZE) + GET(max_end, -LINK_SIZE);\n        }\n      }\n    }\n  }\n\nif (min >= 3)\n  {\n  common->private_data_ptrs[end - common->start - LINK_SIZE] = max_end - end;\n  common->private_data_ptrs[end - common->start - LINK_SIZE + 1] = OP_EXACT;\n  common->private_data_ptrs[end - common->start - LINK_SIZE + 2] = min;\n  return TRUE;\n  }\n\nreturn FALSE;\n}\n\n#define CASE_ITERATOR_PRIVATE_DATA_1 \\\n    case OP_MINSTAR: \\\n    case OP_MINPLUS: \\\n    case OP_QUERY: \\\n    case OP_MINQUERY: \\\n    case OP_MINSTARI: \\\n    case OP_MINPLUSI: \\\n    case OP_QUERYI: \\\n    case OP_MINQUERYI: \\\n    case OP_NOTMINSTAR: \\\n    case OP_NOTMINPLUS: \\\n    case OP_NOTQUERY: \\\n    case OP_NOTMINQUERY: \\\n    case OP_NOTMINSTARI: \\\n    case OP_NOTMINPLUSI: \\\n    case OP_NOTQUERYI: \\\n    case OP_NOTMINQUERYI:\n\n#define CASE_ITERATOR_PRIVATE_DATA_2A \\\n    case OP_STAR: \\\n    case OP_PLUS: \\\n    case OP_STARI: \\\n    case OP_PLUSI: \\\n    case OP_NOTSTAR: \\\n    case OP_NOTPLUS: \\\n    case OP_NOTSTARI: \\\n    case OP_NOTPLUSI:\n\n#define CASE_ITERATOR_PRIVATE_DATA_2B \\\n    case OP_UPTO: \\\n    case OP_MINUPTO: \\\n    case OP_UPTOI: \\\n    case OP_MINUPTOI: \\\n    case OP_NOTUPTO: \\\n    case OP_NOTMINUPTO: \\\n    case OP_NOTUPTOI: \\\n    case OP_NOTMINUPTOI:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_1 \\\n    case OP_TYPEMINSTAR: \\\n    case OP_TYPEMINPLUS: \\\n    case OP_TYPEQUERY: \\\n    case OP_TYPEMINQUERY:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_2A \\\n    case OP_TYPESTAR: \\\n    case OP_TYPEPLUS:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_2B \\\n    case OP_TYPEUPTO: \\\n    case OP_TYPEMINUPTO:\n\nstatic void set_private_data_ptrs(compiler_common *common, int *private_data_start, PCRE2_SPTR ccend)\n{\nPCRE2_SPTR cc = common->start;\nPCRE2_SPTR alternative;\nPCRE2_SPTR end = NULL;\nint private_data_ptr = *private_data_start;\nint space, size, bracketlen;\nBOOL repeat_check = TRUE;\n\nwhile (cc < ccend)\n  {\n  space = 0;\n  size = 0;\n  bracketlen = 0;\n  if (private_data_ptr > SLJIT_MAX_LOCAL_SIZE)\n    break;\n\n  /* When the bracket is prefixed by a zero iteration, skip the repeat check (at this point). */\n  if (repeat_check && (*cc == OP_ONCE || *cc == OP_BRA || *cc == OP_CBRA || *cc == OP_COND))\n    {\n    if (detect_repeat(common, cc))\n      {\n      /* These brackets are converted to repeats, so no global\n      based single character repeat is allowed. */\n      if (cc >= end)\n        end = bracketend(cc);\n      }\n    }\n  repeat_check = TRUE;\n\n  switch(*cc)\n    {\n    case OP_KET:\n    if (common->private_data_ptrs[cc + 1 - common->start] != 0)\n      {\n      common->private_data_ptrs[cc - common->start] = private_data_ptr;\n      private_data_ptr += sizeof(sljit_sw);\n      cc += common->private_data_ptrs[cc + 1 - common->start];\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    common->private_data_ptrs[cc - common->start] = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw);\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    common->private_data_ptrs[cc - common->start] = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw);\n    bracketlen = 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    common->private_data_ptrs[cc - common->start] = 0;\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      {\n      common->private_data_ptrs[cc - common->start] = private_data_ptr;\n      private_data_ptr += sizeof(sljit_sw);\n      }\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_BRA:\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    bracketlen = 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_BRAZERO:\n    case OP_BRAMINZERO:\n    case OP_BRAPOSZERO:\n    size = 1;\n    repeat_check = FALSE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    size = -2;\n    space = 1;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    size = -2;\n    space = 2;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    size = -(2 + IMM2_SIZE);\n    space = 2;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    size = 1;\n    space = 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    size = 1;\n    if (cc[1] != OP_ANYNL && cc[1] != OP_EXTUNI)\n      space = 2;\n    break;\n\n    case OP_TYPEUPTO:\n    size = 1 + IMM2_SIZE;\n    if (cc[1 + IMM2_SIZE] != OP_ANYNL && cc[1 + IMM2_SIZE] != OP_EXTUNI)\n      space = 2;\n    break;\n\n    case OP_TYPEMINUPTO:\n    size = 1 + IMM2_SIZE;\n    space = 2;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    size = 1 + 32 / sizeof(PCRE2_UCHAR);\n    space = get_class_iterator_size(cc + size);\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = GET(cc, 1);\n    space = get_class_iterator_size(cc + size);\n    break;\n#endif\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n  /* Character iterators, which are not inside a repeated bracket,\n     gets a private slot instead of allocating it on the stack. */\n  if (space > 0 && cc >= end)\n    {\n    common->private_data_ptrs[cc - common->start] = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw) * space;\n    }\n\n  if (size != 0)\n    {\n    if (size < 0)\n      {\n      cc += -size;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      }\n    else\n      cc += size;\n    }\n\n  if (bracketlen > 0)\n    {\n    if (cc >= end)\n      {\n      end = bracketend(cc);\n      if (end[-1 - LINK_SIZE] == OP_KET)\n        end = NULL;\n      }\n    cc += bracketlen;\n    }\n  }\n*private_data_start = private_data_ptr;\n}\n\n/* Returns with a frame_types (always < 0) if no need for frame. */\nstatic int get_framesize(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, BOOL recursive, BOOL *needs_control_head)\n{\nint length = 0;\nint possessive = 0;\nBOOL stack_restore = FALSE;\nBOOL setsom_found = recursive;\nBOOL setmark_found = recursive;\n/* The last capture is a local variable even for recursions. */\nBOOL capture_last_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\n*needs_control_head = TRUE;\n#else\n*needs_control_head = FALSE;\n#endif\n\nif (ccend == NULL)\n  {\n  ccend = bracketend(cc) - (1 + LINK_SIZE);\n  if (!recursive && (*cc == OP_CBRAPOS || *cc == OP_SCBRAPOS))\n    {\n    possessive = length = (common->capture_last_ptr != 0) ? 5 : 3;\n    /* This is correct regardless of common->capture_last_ptr. */\n    capture_last_found = TRUE;\n    }\n  cc = next_opcode(common, cc);\n  }\n\nSLJIT_ASSERT(cc != NULL);\nwhile (cc < ccend)\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    stack_restore = TRUE;\n    if (!setsom_found)\n      {\n      length += 2;\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    stack_restore = TRUE;\n    if (!setmark_found)\n      {\n      length += 2;\n      setmark_found = TRUE;\n      }\n    if (common->control_head_ptr != 0)\n      *needs_control_head = TRUE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_RECURSE:\n    stack_restore = TRUE;\n    if (common->has_set_som && !setsom_found)\n      {\n      length += 2;\n      setsom_found = TRUE;\n      }\n    if (common->mark_ptr != 0 && !setmark_found)\n      {\n      length += 2;\n      setmark_found = TRUE;\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      length += 2;\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    case OP_SCBRA:\n    case OP_SCBRAPOS:\n    stack_restore = TRUE;\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      length += 2;\n      capture_last_found = TRUE;\n      }\n    length += 3;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_THEN:\n    stack_restore = TRUE;\n    if (common->control_head_ptr != 0)\n      *needs_control_head = TRUE;\n    cc ++;\n    break;\n\n    default:\n    stack_restore = TRUE;\n    /* Fall through. */\n\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n    case OP_ANYBYTE:\n    case OP_NOTPROP:\n    case OP_PROP:\n    case OP_ANYNL:\n    case OP_NOT_HSPACE:\n    case OP_HSPACE:\n    case OP_NOT_VSPACE:\n    case OP_VSPACE:\n    case OP_EXTUNI:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CHAR:\n    case OP_CHARI:\n    case OP_NOT:\n    case OP_NOTI:\n\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    case OP_XCLASS:\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n/* Possessive quantifiers can use a special case. */\nif (SLJIT_UNLIKELY(possessive == length))\n  return stack_restore ? no_frame : no_stack;\n\nif (length > 0)\n  return length + 1;\nreturn stack_restore ? no_frame : no_stack;\n}\n\nstatic void init_frame(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, int stackpos, int stacktop)\n{\nDEFINE_COMPILER;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\n/* The last capture is a local variable even for recursions. */\nBOOL capture_last_found = FALSE;\nint offset;\n\n/* >= 1 + shortest item size (2) */\nSLJIT_UNUSED_ARG(stacktop);\nSLJIT_ASSERT(stackpos >= stacktop + 2);\n\nstackpos = STACK(stackpos);\nif (ccend == NULL)\n  {\n  ccend = bracketend(cc) - (1 + LINK_SIZE);\n  if (*cc != OP_CBRAPOS && *cc != OP_SCBRAPOS)\n    cc = next_opcode(common, cc);\n  }\n\nSLJIT_ASSERT(cc != NULL);\nwhile (cc < ccend)\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    if (!setsom_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -OVECTOR(0));\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->mark_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setmark_found = TRUE;\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som && !setsom_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -OVECTOR(0));\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setsom_found = TRUE;\n      }\n    if (common->mark_ptr != 0 && !setmark_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->mark_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setmark_found = TRUE;\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->capture_last_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    case OP_SCBRA:\n    case OP_SCBRAPOS:\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->capture_last_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      capture_last_found = TRUE;\n      }\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, OVECTOR(offset));\n    stackpos -= (int)sizeof(sljit_sw);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n    stackpos -= (int)sizeof(sljit_sw);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP2, 0);\n    stackpos -= (int)sizeof(sljit_sw);\n\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, 0);\nSLJIT_ASSERT(stackpos == STACK(stacktop));\n}\n\n#define RECURSE_TMP_REG_COUNT 3\n\ntypedef struct delayed_mem_copy_status {\n  struct sljit_compiler *compiler;\n  int store_bases[RECURSE_TMP_REG_COUNT];\n  int store_offsets[RECURSE_TMP_REG_COUNT];\n  int tmp_regs[RECURSE_TMP_REG_COUNT];\n  int saved_tmp_regs[RECURSE_TMP_REG_COUNT];\n  int next_tmp_reg;\n} delayed_mem_copy_status;\n\nstatic void delayed_mem_copy_init(delayed_mem_copy_status *status, compiler_common *common)\n{\nint i;\n\nfor (i = 0; i < RECURSE_TMP_REG_COUNT; i++)\n  {\n  SLJIT_ASSERT(status->tmp_regs[i] >= 0);\n  SLJIT_ASSERT(sljit_get_register_index(status->saved_tmp_regs[i]) < 0 || status->tmp_regs[i] == status->saved_tmp_regs[i]);\n\n  status->store_bases[i] = -1;\n  }\nstatus->next_tmp_reg = 0;\nstatus->compiler = common->compiler;\n}\n\nstatic void delayed_mem_copy_move(delayed_mem_copy_status *status, int load_base, sljit_sw load_offset,\n  int store_base, sljit_sw store_offset)\n{\nstruct sljit_compiler *compiler = status->compiler;\nint next_tmp_reg = status->next_tmp_reg;\nint tmp_reg = status->tmp_regs[next_tmp_reg];\n\nSLJIT_ASSERT(load_base > 0 && store_base > 0);\n\nif (status->store_bases[next_tmp_reg] == -1)\n  {\n  /* Preserve virtual registers. */\n  if (sljit_get_register_index(status->saved_tmp_regs[next_tmp_reg]) < 0)\n    OP1(SLJIT_MOV, status->saved_tmp_regs[next_tmp_reg], 0, tmp_reg, 0);\n  }\nelse\n  OP1(SLJIT_MOV, SLJIT_MEM1(status->store_bases[next_tmp_reg]), status->store_offsets[next_tmp_reg], tmp_reg, 0);\n\nOP1(SLJIT_MOV, tmp_reg, 0, SLJIT_MEM1(load_base), load_offset);\nstatus->store_bases[next_tmp_reg] = store_base;\nstatus->store_offsets[next_tmp_reg] = store_offset;\n\nstatus->next_tmp_reg = (next_tmp_reg + 1) % RECURSE_TMP_REG_COUNT;\n}\n\nstatic void delayed_mem_copy_finish(delayed_mem_copy_status *status)\n{\nstruct sljit_compiler *compiler = status->compiler;\nint next_tmp_reg = status->next_tmp_reg;\nint tmp_reg, saved_tmp_reg, i;\n\nfor (i = 0; i < RECURSE_TMP_REG_COUNT; i++)\n  {\n  if (status->store_bases[next_tmp_reg] != -1)\n    {\n    tmp_reg = status->tmp_regs[next_tmp_reg];\n    saved_tmp_reg = status->saved_tmp_regs[next_tmp_reg];\n\n    OP1(SLJIT_MOV, SLJIT_MEM1(status->store_bases[next_tmp_reg]), status->store_offsets[next_tmp_reg], tmp_reg, 0);\n\n    /* Restore virtual registers. */\n    if (sljit_get_register_index(saved_tmp_reg) < 0)\n      OP1(SLJIT_MOV, tmp_reg, 0, saved_tmp_reg, 0);\n    }\n\n  next_tmp_reg = (next_tmp_reg + 1) % RECURSE_TMP_REG_COUNT;\n  }\n}\n\n#undef RECURSE_TMP_REG_COUNT\n\nstatic int get_recurse_data_length(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  BOOL *needs_control_head, BOOL *has_quit, BOOL *has_accept)\n{\nint length = 1;\nint size;\nPCRE2_SPTR alternative;\nBOOL quit_found = FALSE;\nBOOL accept_found = FALSE;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL capture_last_found = FALSE;\nBOOL control_head_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\n/* Calculate the sum of the private machine words. */\nwhile (cc < ccend)\n  {\n  size = 0;\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    setsom_found = TRUE;\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som)\n      setsom_found = TRUE;\n    if (common->mark_ptr != 0)\n      setmark_found = TRUE;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    if (PRIVATE_DATA(cc) != 0)\n      {\n      length++;\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    length++;\n    SLJIT_ASSERT(PRIVATE_DATA(cc) != 0);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    length += 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)\n      length++;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    length += 2 + 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    size = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n    if (PRIVATE_DATA(cc) != 0)\n      length += get_class_iterator_size(cc + size);\n    cc += size;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      setmark_found = TRUE;\n    if (common->control_head_ptr != 0)\n      control_head_found = TRUE;\n    if (*cc != OP_MARK)\n      quit_found = TRUE;\n\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_SKIP:\n    case OP_COMMIT:\n    quit_found = TRUE;\n    cc++;\n    break;\n\n    case OP_SKIP_ARG:\n    quit_found = TRUE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    quit_found = TRUE;\n    if (!control_head_found)\n      control_head_found = TRUE;\n    cc++;\n    break;\n\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    accept_found = TRUE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n  }\nSLJIT_ASSERT(cc == ccend);\n\nif (control_head_found)\n  length++;\nif (capture_last_found)\n  length++;\nif (quit_found)\n  {\n  if (setsom_found)\n    length++;\n  if (setmark_found)\n    length++;\n  }\n\n*needs_control_head = control_head_found;\n*has_quit = quit_found;\n*has_accept = accept_found;\nreturn length;\n}\n\nenum copy_recurse_data_types {\n  recurse_copy_from_global,\n  recurse_copy_private_to_global,\n  recurse_copy_shared_to_global,\n  recurse_copy_kept_shared_to_global,\n  recurse_swap_global\n};\n\nstatic void copy_recurse_data(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  int type, int stackptr, int stacktop, BOOL has_quit)\n{\ndelayed_mem_copy_status status;\nPCRE2_SPTR alternative;\nsljit_sw private_srcw[2];\nsljit_sw shared_srcw[3];\nsljit_sw kept_shared_srcw[2];\nint private_count, shared_count, kept_shared_count;\nint from_sp, base_reg, offset, i;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL capture_last_found = FALSE;\nBOOL control_head_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\nswitch (type)\n  {\n  case recurse_copy_from_global:\n  from_sp = TRUE;\n  base_reg = STACK_TOP;\n  break;\n\n  case recurse_copy_private_to_global:\n  case recurse_copy_shared_to_global:\n  case recurse_copy_kept_shared_to_global:\n  from_sp = FALSE;\n  base_reg = STACK_TOP;\n  break;\n\n  default:\n  SLJIT_ASSERT(type == recurse_swap_global);\n  from_sp = FALSE;\n  base_reg = TMP2;\n  break;\n  }\n\nstackptr = STACK(stackptr);\nstacktop = STACK(stacktop);\n\nstatus.tmp_regs[0] = TMP1;\nstatus.saved_tmp_regs[0] = TMP1;\n\nif (base_reg != TMP2)\n  {\n  status.tmp_regs[1] = TMP2;\n  status.saved_tmp_regs[1] = TMP2;\n  }\nelse\n  {\n  status.saved_tmp_regs[1] = RETURN_ADDR;\n  if (HAS_VIRTUAL_REGISTERS)\n    status.tmp_regs[1] = STR_PTR;\n  else\n    status.tmp_regs[1] = RETURN_ADDR;\n  }\n\nstatus.saved_tmp_regs[2] = TMP3;\nif (HAS_VIRTUAL_REGISTERS)\n  status.tmp_regs[2] = STR_END;\nelse\n  status.tmp_regs[2] = TMP3;\n\ndelayed_mem_copy_init(&status, common);\n\nif (type != recurse_copy_shared_to_global && type != recurse_copy_kept_shared_to_global)\n  {\n  SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_private_to_global || type == recurse_swap_global);\n\n  if (!from_sp)\n    delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, common->recursive_head_ptr);\n\n  if (from_sp || type == recurse_swap_global)\n    delayed_mem_copy_move(&status, SLJIT_SP, common->recursive_head_ptr, base_reg, stackptr);\n  }\n\nstackptr += sizeof(sljit_sw);\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nif (type != recurse_copy_shared_to_global)\n  {\n  if (!from_sp)\n    delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, common->control_head_ptr);\n\n  if (from_sp || type == recurse_swap_global)\n    delayed_mem_copy_move(&status, SLJIT_SP, common->control_head_ptr, base_reg, stackptr);\n  }\n\nstackptr += sizeof(sljit_sw);\n#endif\n\nwhile (cc < ccend)\n  {\n  private_count = 0;\n  shared_count = 0;\n  kept_shared_count = 0;\n\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    if (has_quit && !setsom_found)\n      {\n      kept_shared_srcw[0] = OVECTOR(0);\n      kept_shared_count = 1;\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (has_quit)\n      {\n      if (common->has_set_som && !setsom_found)\n        {\n        kept_shared_srcw[0] = OVECTOR(0);\n        kept_shared_count = 1;\n        setsom_found = TRUE;\n        }\n      if (common->mark_ptr != 0 && !setmark_found)\n        {\n        kept_shared_srcw[kept_shared_count] = common->mark_ptr;\n        kept_shared_count++;\n        setmark_found = TRUE;\n        }\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw[0] = common->capture_last_ptr;\n      shared_count = 1;\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    if (PRIVATE_DATA(cc) != 0)\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    private_count = 1;\n    private_srcw[0] = PRIVATE_DATA(cc);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    shared_srcw[0] = OVECTOR(offset);\n    shared_srcw[1] = OVECTOR(offset + 1);\n    shared_count = 2;\n\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw[2] = common->capture_last_ptr;\n      shared_count = 3;\n      capture_last_found = TRUE;\n      }\n\n    if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)\n      {\n      private_count = 1;\n      private_srcw[0] = OVECTOR_PRIV(GET2(cc, 1 + LINK_SIZE));\n      }\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    shared_srcw[0] = OVECTOR(offset);\n    shared_srcw[1] = OVECTOR(offset + 1);\n    shared_count = 2;\n\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw[2] = common->capture_last_ptr;\n      shared_count = 3;\n      capture_last_found = TRUE;\n      }\n\n    private_count = 2;\n    private_srcw[0] = PRIVATE_DATA(cc);\n    private_srcw[1] = OVECTOR_PRIV(GET2(cc, 1 + LINK_SIZE));\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = PRIVATE_DATA(cc) + sizeof(sljit_sw);\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = PRIVATE_DATA(cc) + sizeof(sljit_sw);\n      }\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n      }\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    i = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    i = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n    if (PRIVATE_DATA(cc) != 0)\n      switch(get_class_iterator_size(cc + i))\n        {\n        case 1:\n        private_count = 1;\n        private_srcw[0] = PRIVATE_DATA(cc);\n        break;\n\n        case 2:\n        private_count = 2;\n        private_srcw[0] = PRIVATE_DATA(cc);\n        private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n        break;\n\n        default:\n        SLJIT_UNREACHABLE();\n        break;\n        }\n    cc += i;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (has_quit && !setmark_found)\n      {\n      kept_shared_srcw[0] = common->mark_ptr;\n      kept_shared_count = 1;\n      setmark_found = TRUE;\n      }\n    if (common->control_head_ptr != 0 && !control_head_found)\n      {\n      private_srcw[0] = common->control_head_ptr;\n      private_count = 1;\n      control_head_found = TRUE;\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    if (!control_head_found)\n      {\n      private_srcw[0] = common->control_head_ptr;\n      private_count = 1;\n      control_head_found = TRUE;\n      }\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n  if (type != recurse_copy_shared_to_global && type != recurse_copy_kept_shared_to_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_private_to_global || type == recurse_swap_global);\n\n    for (i = 0; i < private_count; i++)\n      {\n      SLJIT_ASSERT(private_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, private_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, private_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * private_count;\n\n  if (type != recurse_copy_private_to_global && type != recurse_copy_kept_shared_to_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_shared_to_global || type == recurse_swap_global);\n\n    for (i = 0; i < shared_count; i++)\n      {\n      SLJIT_ASSERT(shared_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, shared_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, shared_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * shared_count;\n\n  if (type != recurse_copy_private_to_global && type != recurse_swap_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_shared_to_global || type == recurse_copy_kept_shared_to_global);\n\n    for (i = 0; i < kept_shared_count; i++)\n      {\n      SLJIT_ASSERT(kept_shared_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, kept_shared_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, kept_shared_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * kept_shared_count;\n  }\n\nSLJIT_ASSERT(cc == ccend && stackptr == stacktop);\n\ndelayed_mem_copy_finish(&status);\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR set_then_offsets(compiler_common *common, PCRE2_SPTR cc, sljit_u8 *current_offset)\n{\nPCRE2_SPTR end = bracketend(cc);\nBOOL has_alternatives = cc[GET(cc, 1)] == OP_ALT;\n\n/* Assert captures then. */\nif (*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA)\n  current_offset = NULL;\n/* Conditional block does not. */\nif (*cc == OP_COND || *cc == OP_SCOND)\n  has_alternatives = FALSE;\n\ncc = next_opcode(common, cc);\nif (has_alternatives)\n  current_offset = common->then_offsets + (cc - common->start);\n\nwhile (cc < end)\n  {\n  if ((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND))\n    cc = set_then_offsets(common, cc, current_offset);\n  else\n    {\n    if (*cc == OP_ALT && has_alternatives)\n      current_offset = common->then_offsets + (cc + 1 + LINK_SIZE - common->start);\n    if (*cc >= OP_THEN && *cc <= OP_THEN_ARG && current_offset != NULL)\n      *current_offset = 1;\n    cc = next_opcode(common, cc);\n    }\n  }\n\nreturn end;\n}\n\n#undef CASE_ITERATOR_PRIVATE_DATA_1\n#undef CASE_ITERATOR_PRIVATE_DATA_2A\n#undef CASE_ITERATOR_PRIVATE_DATA_2B\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n\nstatic SLJIT_INLINE BOOL is_powerof2(unsigned int value)\n{\nreturn (value & (value - 1)) == 0;\n}\n\nstatic SLJIT_INLINE void set_jumps(jump_list *list, struct sljit_label *label)\n{\nwhile (list)\n  {\n  /* sljit_set_label is clever enough to do nothing\n  if either the jump or the label is NULL. */\n  SET_LABEL(list->jump, label);\n  list = list->next;\n  }\n}\n\nstatic SLJIT_INLINE void add_jump(struct sljit_compiler *compiler, jump_list **list, struct sljit_jump *jump)\n{\njump_list *list_item = sljit_alloc_memory(compiler, sizeof(jump_list));\nif (list_item)\n  {\n  list_item->next = *list;\n  list_item->jump = jump;\n  *list = list_item;\n  }\n}\n\nstatic void add_stub(compiler_common *common, struct sljit_jump *start)\n{\nDEFINE_COMPILER;\nstub_list *list_item = sljit_alloc_memory(compiler, sizeof(stub_list));\n\nif (list_item)\n  {\n  list_item->start = start;\n  list_item->quit = LABEL();\n  list_item->next = common->stubs;\n  common->stubs = list_item;\n  }\n}\n\nstatic void flush_stubs(compiler_common *common)\n{\nDEFINE_COMPILER;\nstub_list *list_item = common->stubs;\n\nwhile (list_item)\n  {\n  JUMPHERE(list_item->start);\n  add_jump(compiler, &common->stackalloc, JUMP(SLJIT_FAST_CALL));\n  JUMPTO(SLJIT_JUMP, list_item->quit);\n  list_item = list_item->next;\n  }\ncommon->stubs = NULL;\n}\n\nstatic SLJIT_INLINE void count_match(compiler_common *common)\n{\nDEFINE_COMPILER;\n\nOP2(SLJIT_SUB | SLJIT_SET_Z, COUNT_MATCH, 0, COUNT_MATCH, 0, SLJIT_IMM, 1);\nadd_jump(compiler, &common->calllimit, JUMP(SLJIT_ZERO));\n}\n\nstatic SLJIT_INLINE void allocate_stack(compiler_common *common, int size)\n{\n/* May destroy all locals and registers except TMP2. */\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(size > 0);\nOP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * sizeof(sljit_sw));\n#ifdef DESTROY_REGISTERS\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 12345);\nOP1(SLJIT_MOV, TMP3, 0, TMP1, 0);\nOP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP1, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, TMP1, 0);\n#endif\nadd_stub(common, CMP(SLJIT_LESS, STACK_TOP, 0, STACK_LIMIT, 0));\n}\n\nstatic SLJIT_INLINE void free_stack(compiler_common *common, int size)\n{\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(size > 0);\nOP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * sizeof(sljit_sw));\n}\n\nstatic sljit_uw * allocate_read_only_data(compiler_common *common, sljit_uw size)\n{\nDEFINE_COMPILER;\nsljit_uw *result;\n\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  return NULL;\n\nresult = (sljit_uw *)SLJIT_MALLOC(size + sizeof(sljit_uw), compiler->allocator_data);\nif (SLJIT_UNLIKELY(result == NULL))\n  {\n  sljit_set_compiler_memory_error(compiler);\n  return NULL;\n  }\n\n*(void**)result = common->read_only_data_head;\ncommon->read_only_data_head = (void *)result;\nreturn result + 1;\n}\n\nstatic SLJIT_INLINE void reset_ovector(compiler_common *common, int length)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nsljit_s32 i;\n\n/* At this point we can freely use all temporary registers. */\nSLJIT_ASSERT(length > 1);\n/* TMP1 returns with begin - 1. */\nOP2(SLJIT_SUB, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_S0), SLJIT_OFFSETOF(jit_arguments, begin), SLJIT_IMM, IN_UCHARS(1));\nif (length < 8)\n  {\n  for (i = 1; i < length; i++)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(i), SLJIT_R0, 0);\n  }\nelse\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw)) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(SLJIT_R1, 0, OVECTOR_START);\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_IMM, length - 1);\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  else\n    {\n    GET_LOCAL_BASE(SLJIT_R1, 0, OVECTOR_START + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_IMM, length - 1);\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R1), 0, SLJIT_R0, 0);\n    OP2(SLJIT_ADD, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  }\n}\n\nstatic SLJIT_INLINE void reset_early_fail(compiler_common *common)\n{\nDEFINE_COMPILER;\nsljit_u32 size = (sljit_u32)(common->early_fail_end_ptr - common->early_fail_start_ptr);\nsljit_u32 uncleared_size;\nsljit_s32 src = SLJIT_IMM;\nsljit_s32 i;\nstruct sljit_label *loop;\n\nSLJIT_ASSERT(common->early_fail_start_ptr < common->early_fail_end_ptr);\n\nif (size == sizeof(sljit_sw))\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->early_fail_start_ptr, SLJIT_IMM, 0);\n  return;\n  }\n\nif (sljit_get_register_index(TMP3) >= 0 && !sljit_has_cpu_feature(SLJIT_HAS_ZERO_REGISTER))\n  {\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, 0);\n  src = TMP3;\n  }\n\nif (size <= 6 * sizeof(sljit_sw))\n  {\n  for (i = common->early_fail_start_ptr; i < common->early_fail_end_ptr; i += sizeof(sljit_sw))\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), i, src, 0);\n  return;\n  }\n\nGET_LOCAL_BASE(TMP1, 0, common->early_fail_start_ptr);\n\nuncleared_size = ((size / sizeof(sljit_sw)) % 3) * sizeof(sljit_sw);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, size - uncleared_size);\n\nloop = LABEL();\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), 0, src, 0);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -2 * (sljit_sw)sizeof(sljit_sw), src, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -1 * (sljit_sw)sizeof(sljit_sw), src, 0);\nCMPTO(SLJIT_LESS, TMP1, 0, TMP2, 0, loop);\n\nif (uncleared_size >= sizeof(sljit_sw))\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), 0, src, 0);\n\nif (uncleared_size >= 2 * sizeof(sljit_sw))\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), sizeof(sljit_sw), src, 0);\n}\n\nstatic SLJIT_INLINE void do_reset_match(compiler_common *common, int length)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nint i;\n\nSLJIT_ASSERT(length > 1);\n/* OVECTOR(1) contains the \"string begin - 1\" constant. */\nif (length > 2)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\nif (length < 8)\n  {\n  for (i = 2; i < length; i++)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(i), TMP1, 0);\n  }\nelse\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw)) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(TMP2, 0, OVECTOR_START + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_IMM, length - 2);\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  else\n    {\n    GET_LOCAL_BASE(TMP2, 0, OVECTOR_START + 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_IMM, length - 2);\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP1, 0);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  }\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, stack));\nelse\n  OP1(SLJIT_MOV, STACK_TOP, 0, ARGUMENTS, 0);\n\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, SLJIT_IMM, 0);\nif (common->control_head_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), SLJIT_OFFSETOF(jit_arguments, stack));\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), SLJIT_OFFSETOF(struct sljit_stack, end));\n}\n\nstatic sljit_sw SLJIT_FUNC do_search_mark(sljit_sw *current, PCRE2_SPTR skip_arg)\n{\nwhile (current != NULL)\n  {\n  switch (current[1])\n    {\n    case type_then_trap:\n    break;\n\n    case type_mark:\n    if (PRIV(strcmp)(skip_arg, (PCRE2_SPTR)current[2]) == 0)\n      return current[3];\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    break;\n    }\n  SLJIT_ASSERT(current[0] == 0 || current < (sljit_sw*)current[0]);\n  current = (sljit_sw*)current[0];\n  }\nreturn 0;\n}\n\nstatic SLJIT_INLINE void copy_ovector(compiler_common *common, int topbracket)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nBOOL has_pre;\n\n/* At this point we can freely use all registers. */\nOP1(SLJIT_MOV, SLJIT_S2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(1), STR_PTR, 0);\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, SLJIT_S0, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n  OP1(SLJIT_MOV_U32, SLJIT_R1, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, oveccount));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_S0, 0);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, mark_ptr), SLJIT_R2, 0);\n  OP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, match_data),\n    SLJIT_IMM, SLJIT_OFFSETOF(pcre2_match_data, ovector) - sizeof(PCRE2_SIZE));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, SLJIT_S0, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, match_data));\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n  OP1(SLJIT_MOV_U32, SLJIT_R1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, oveccount));\n  OP1(SLJIT_MOV, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_S0, 0);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), SLJIT_R0, 0);\n  OP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, SLJIT_OFFSETOF(pcre2_match_data, ovector) - sizeof(PCRE2_SIZE));\n  }\n\nhas_pre = sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw)) == SLJIT_SUCCESS;\n\nGET_LOCAL_BASE(SLJIT_S0, 0, OVECTOR_START - (has_pre ? sizeof(sljit_sw) : 0));\nOP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? SLJIT_R0 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n\nloop = LABEL();\n\nif (has_pre)\n  sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw));\nelse\n  {\n  OP1(SLJIT_MOV, SLJIT_S1, 0, SLJIT_MEM1(SLJIT_S0), 0);\n  OP2(SLJIT_ADD, SLJIT_S0, 0, SLJIT_S0, 0, SLJIT_IMM, sizeof(sljit_sw));\n  }\n\nOP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, sizeof(PCRE2_SIZE));\nOP2(SLJIT_SUB, SLJIT_S1, 0, SLJIT_S1, 0, SLJIT_R0, 0);\n/* Copy the integer value to the output buffer */\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, SLJIT_S1, 0, SLJIT_S1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n\nSLJIT_ASSERT(sizeof(PCRE2_SIZE) == 4 || sizeof(PCRE2_SIZE) == 8);\nOP1(((sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV), SLJIT_MEM1(SLJIT_R2), 0, SLJIT_S1, 0);\n\nOP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\nJUMPTO(SLJIT_NOT_ZERO, loop);\n\n/* Calculate the return value, which is the maximum ovector value. */\nif (topbracket > 1)\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * (sljit_sw)sizeof(sljit_sw))) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(SLJIT_R0, 0, OVECTOR_START + topbracket * 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, topbracket + 1);\n\n    /* OVECTOR(0) is never equal to SLJIT_S2. */\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * (sljit_sw)sizeof(sljit_sw)));\n    OP2(SLJIT_SUB, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\n    CMPTO(SLJIT_EQUAL, SLJIT_R2, 0, SLJIT_S2, 0, loop);\n    OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_R1, 0);\n    }\n  else\n    {\n    GET_LOCAL_BASE(SLJIT_R0, 0, OVECTOR_START + (topbracket - 1) * 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, topbracket + 1);\n\n    /* OVECTOR(0) is never equal to SLJIT_S2. */\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_R0), 0);\n    OP2(SLJIT_SUB, SLJIT_R0, 0, SLJIT_R0, 0, SLJIT_IMM, 2 * (sljit_sw)sizeof(sljit_sw));\n    OP2(SLJIT_SUB, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\n    CMPTO(SLJIT_EQUAL, SLJIT_R2, 0, SLJIT_S2, 0, loop);\n    OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_R1, 0);\n    }\n  }\nelse\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, 1);\n}\n\nstatic SLJIT_INLINE void return_with_partial_match(compiler_common *common, struct sljit_label *quit)\n{\nDEFINE_COMPILER;\nsljit_s32 mov_opcode;\nsljit_s32 arguments_reg = !HAS_VIRTUAL_REGISTERS ? ARGUMENTS : SLJIT_R1;\n\nSLJIT_COMPILE_ASSERT(STR_END == SLJIT_S0, str_end_must_be_saved_reg0);\nSLJIT_ASSERT(common->start_used_ptr != 0 && common->start_ptr != 0\n  && (common->mode == PCRE2_JIT_PARTIAL_SOFT ? common->hit_start != 0 : common->hit_start == 0));\n\nif (arguments_reg != ARGUMENTS)\n  OP1(SLJIT_MOV, arguments_reg, 0, ARGUMENTS, 0);\nOP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP),\n  common->mode == PCRE2_JIT_PARTIAL_SOFT ? common->hit_start : common->start_ptr);\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_PARTIAL);\n\n/* Store match begin and end. */\nOP1(SLJIT_MOV, SLJIT_S1, 0, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, begin));\nOP1(SLJIT_MOV, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_R2, 0);\nOP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, match_data));\n\nmov_opcode = (sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV;\n\nOP2(SLJIT_SUB, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_S1, 0);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\nOP1(mov_opcode, SLJIT_MEM1(SLJIT_R1), SLJIT_OFFSETOF(pcre2_match_data, ovector), SLJIT_R2, 0);\n\nOP2(SLJIT_SUB, STR_END, 0, STR_END, 0, SLJIT_S1, 0);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, STR_END, 0, STR_END, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\nOP1(mov_opcode, SLJIT_MEM1(SLJIT_R1), SLJIT_OFFSETOF(pcre2_match_data, ovector) + sizeof(PCRE2_SIZE), STR_END, 0);\n\nJUMPTO(SLJIT_JUMP, quit);\n}\n\nstatic SLJIT_INLINE void check_start_used_ptr(compiler_common *common)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  /* The value of -1 must be kept for start_used_ptr! */\n  OP2(SLJIT_ADD, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, 1);\n  /* Jumps if start_used_ptr < STR_PTR, or start_used_ptr == -1. Although overwriting\n  is not necessary if start_used_ptr == STR_PTR, it does not hurt as well. */\n  jump = CMP(SLJIT_LESS_EQUAL, TMP1, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\nelse if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n  {\n  jump = CMP(SLJIT_LESS_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\n}\n\nstatic SLJIT_INLINE BOOL char_has_othercase(compiler_common *common, PCRE2_SPTR cc)\n{\n/* Detects if the character has an othercase. */\nunsigned int c;\n\n#ifdef SUPPORT_UNICODE\nif (common->utf || common->ucp)\n  {\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n    c = *cc;\n\n  if (c > 127)\n    return c != UCD_OTHERCASE(c);\n\n  return common->fcc[c] != c;\n  }\nelse\n#endif\n  c = *cc;\nreturn MAX_255(c) ? common->fcc[c] != c : FALSE;\n}\n\nstatic SLJIT_INLINE unsigned int char_othercase(compiler_common *common, unsigned int c)\n{\n/* Returns with the othercase. */\n#ifdef SUPPORT_UNICODE\nif ((common->utf || common->ucp) && c > 127)\n  return UCD_OTHERCASE(c);\n#endif\nreturn TABLE_GET(c, common->fcc, c);\n}\n\nstatic unsigned int char_get_othercase_bit(compiler_common *common, PCRE2_SPTR cc)\n{\n/* Detects if the character and its othercase has only 1 bit difference. */\nunsigned int c, oc, bit;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nint n;\n#endif\n\n#ifdef SUPPORT_UNICODE\nif (common->utf || common->ucp)\n  {\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n    c = *cc;\n\n  if (c <= 127)\n    oc = common->fcc[c];\n  else\n    oc = UCD_OTHERCASE(c);\n  }\nelse\n  {\n  c = *cc;\n  oc = TABLE_GET(c, common->fcc, c);\n  }\n#else\nc = *cc;\noc = TABLE_GET(c, common->fcc, c);\n#endif\n\nSLJIT_ASSERT(c != oc);\n\nbit = c ^ oc;\n/* Optimized for English alphabet. */\nif (c <= 127 && bit == 0x20)\n  return (0 << 8) | 0x20;\n\n/* Since c != oc, they must have at least 1 bit difference. */\nif (!is_powerof2(bit))\n  return 0;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n\n#ifdef SUPPORT_UNICODE\nif (common->utf && c > 127)\n  {\n  n = GET_EXTRALEN(*cc);\n  while ((bit & 0x3f) == 0)\n    {\n    n--;\n    bit >>= 6;\n    }\n  return (n << 8) | bit;\n  }\n#endif /* SUPPORT_UNICODE */\nreturn (0 << 8) | bit;\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n\n#ifdef SUPPORT_UNICODE\nif (common->utf && c > 65535)\n  {\n  if (bit >= (1u << 10))\n    bit >>= 10;\n  else\n    return (bit < 256) ? ((2 << 8) | bit) : ((3 << 8) | (bit >> 8));\n  }\n#endif /* SUPPORT_UNICODE */\nreturn (bit < 256) ? ((0u << 8) | bit) : ((1u << 8) | (bit >> 8));\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n}\n\nstatic void check_partial(compiler_common *common, BOOL force)\n{\n/* Checks whether a partial matching is occurred. Does not modify registers. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump = NULL;\n\nSLJIT_ASSERT(!force || common->mode != PCRE2_JIT_COMPLETE);\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  return;\n\nif (!force && !common->allow_empty_partial)\n  jump = CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\nelse if (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  jump = CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1);\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\nelse\n  {\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\n\nif (jump != NULL)\n  JUMPHERE(jump);\n}\n\nstatic void check_str_end(compiler_common *common, jump_list **end_reached)\n{\n/* Does not affect registers. Usually used in a tight spot. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  return;\n  }\n\njump = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  add_jump(compiler, end_reached, JUMP(SLJIT_JUMP));\n  }\nelse\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\nJUMPHERE(jump);\n}\n\nstatic void detect_partial_match(compiler_common *common, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  {\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  return;\n  }\n\n/* Partial matching mode. */\njump = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\nif (!common->allow_empty_partial)\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\nelse if (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1));\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n  }\nelse\n  {\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\nJUMPHERE(jump);\n}\n\nstatic void process_partial_match(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\n/* Partial matching mode. */\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  jump = CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  JUMPHERE(jump);\n  }\nelse if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n  {\n  if (common->partialmatchlabel != NULL)\n    CMPTO(SLJIT_LESS, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, CMP(SLJIT_LESS, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  }\n}\n\nstatic void detect_partial_match_to(compiler_common *common, struct sljit_label *label)\n{\nDEFINE_COMPILER;\n\nCMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, label);\nprocess_partial_match(common);\n}\n\nstatic void peek_char(compiler_common *common, sljit_u32 max, sljit_s32 dst, sljit_sw dstw, jump_list **backtracks)\n{\n/* Reads the character into TMP1, keeps STR_PTR.\nDoes not check STR_END. TMP2, dst, RETURN_ADDR Destroyed. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\n\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(dst);\nSLJIT_UNUSED_ARG(dstw);\nSLJIT_UNUSED_ARG(backtracks);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128) return;\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n  OP1(SLJIT_MOV, dst, dstw, STR_PTR, 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  add_jump(compiler, common->invalid_utf ? &common->utfreadchar_invalid : &common->utfreadchar, JUMP(SLJIT_FAST_CALL));\n  OP1(SLJIT_MOV, STR_PTR, 0, dst, dstw);\n  if (backtracks && common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800) return;\n\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (common->invalid_utf)\n    {\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    OP1(SLJIT_MOV, dst, dstw, STR_PTR, 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    OP1(SLJIT_MOV, STR_PTR, 0, dst, dstw);\n    if (backtracks && common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    {\n    /* TMP2 contains the high surrogate. */\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xdc00 - 0xd800);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    }\n\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  if (max < 0xd800) return;\n\n  if (backtracks != NULL)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000);\n    CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n}\n\nstatic void peek_char_back(compiler_common *common, sljit_u32 max, jump_list **backtracks)\n{\n/* Reads one character back without moving STR_PTR. TMP2 must\ncontain the start of the subject buffer. Affects TMP1, TMP2, and RETURN_ADDR. */\nDEFINE_COMPILER;\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\n\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(backtracks);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128) return;\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfpeakcharback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    add_jump(compiler, &common->utfpeakcharback, JUMP(SLJIT_FAST_CALL));\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800) return;\n\n  if (common->invalid_utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, &common->utfpeakcharback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xdc00);\n    /* TMP2 contains the low surrogate. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x10000);\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    }\n    JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n}\n\n#define READ_CHAR_UPDATE_STR_PTR 0x1\n#define READ_CHAR_UTF8_NEWLINE 0x2\n#define READ_CHAR_NEWLINE (READ_CHAR_UPDATE_STR_PTR | READ_CHAR_UTF8_NEWLINE)\n#define READ_CHAR_VALID_UTF 0x4\n\nstatic void read_char(compiler_common *common, sljit_u32 min, sljit_u32 max,\n  jump_list **backtracks, sljit_u32 options)\n{\n/* Reads the precise value of a character into TMP1, if the character is\nbetween min and max (c >= min && c <= max). Otherwise it returns with a value\noutside the range. Does not check STR_END. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_jump *jump2;\n#endif\n\nSLJIT_UNUSED_ARG(min);\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(options);\nSLJIT_ASSERT(min <= max);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128 && !(options & READ_CHAR_UPDATE_STR_PTR)) return;\n\n  if (common->invalid_utf && !(options & READ_CHAR_VALID_UTF))\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n\n    if (options & READ_CHAR_UTF8_NEWLINE)\n      add_jump(compiler, &common->utfreadnewline_invalid, JUMP(SLJIT_FAST_CALL));\n    else\n      add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    JUMPHERE(jump);\n    return;\n    }\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n  if (min >= 0x10000)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xf0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump2);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  else if (min >= 0x800 && max <= 0xffff)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xe0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0xf);\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump2);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  else if (max >= 0x800)\n    {\n    add_jump(compiler, &common->utfreadchar, JUMP(SLJIT_FAST_CALL));\n    }\n  else if (max < 128)\n    {\n    OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n    }\n  else\n    {\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    else\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800 && !(options & READ_CHAR_UPDATE_STR_PTR)) return;\n\n  if (common->invalid_utf && !(options & READ_CHAR_VALID_UTF))\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n\n    if (options & READ_CHAR_UTF8_NEWLINE)\n      add_jump(compiler, &common->utfreadnewline_invalid, JUMP(SLJIT_FAST_CALL));\n    else\n      add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    JUMPHERE(jump);\n    return;\n    }\n\n  if (max >= 0x10000)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xdc00 - 0xd800);\n    /* TMP2 contains the high surrogate. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump);\n    return;\n    }\n\n  /* Skip low surrogate if necessary. */\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV) && !HAS_VIRTUAL_REGISTERS)\n    {\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, RETURN_ADDR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0x400);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      CMOV(SLJIT_LESS, STR_PTR, RETURN_ADDR, 0);\n    if (max >= 0xd800)\n      CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, 0x10000);\n    }\n  else\n    {\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    if (max >= 0xd800)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x10000);\n    JUMPHERE(jump);\n    }\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  if (backtracks != NULL)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000);\n    CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n}\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n\nstatic BOOL is_char7_bitset(const sljit_u8 *bitset, BOOL nclass)\n{\n/* Tells whether the character codes below 128 are enough\nto determine a match. */\nconst sljit_u8 value = nclass ? 0xff : 0;\nconst sljit_u8 *end = bitset + 32;\n\nbitset += 16;\ndo\n  {\n  if (*bitset++ != value)\n    return FALSE;\n  }\nwhile (bitset < end);\nreturn TRUE;\n}\n\nstatic void read_char7_type(compiler_common *common, jump_list **backtracks, BOOL negated)\n{\n/* Reads the precise character type of a character into TMP1, if the character\nis less than 128. Otherwise it returns with zero. Does not check STR_END. The\nfull_read argument tells whether characters above max are accepted or not. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nSLJIT_ASSERT(common->utf);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n/* All values > 127 are zero in ctypes. */\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n\nif (negated)\n  {\n  jump = CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x80);\n\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n    }\n  JUMPHERE(jump);\n  }\n}\n\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\nstatic void read_char8_type(compiler_common *common, jump_list **backtracks, BOOL negated)\n{\n/* Reads the character type into TMP1, updates STR_PTR. Does not check STR_END. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\nstruct sljit_jump *jump;\n#endif\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_jump *jump2;\n#endif\n\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(negated);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  /* The result of this read may be unused, but saves an \"else\" part. */\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n  jump = CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x80);\n\n  if (!negated)\n    {\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe0 - 0xc2));\n\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40));\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n    JUMPHERE(jump2);\n    }\n  else if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    OP1(SLJIT_MOV, TMP2, 0, TMP1, 0);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n    JUMPHERE(jump2);\n    }\n  else\n    add_jump(compiler, &common->utfreadtype8, JUMP(SLJIT_FAST_CALL));\n\n  JUMPHERE(jump);\n  return;\n  }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf && negated)\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x110000));\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 32 */\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\n/* The ctypes array contains only 256 values. */\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\njump = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 */\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 */\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf && negated)\n  {\n  /* Skip low surrogate if necessary. */\n  if (!common->invalid_utf)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\n\n    if (sljit_has_cpu_feature(SLJIT_HAS_CMOV) && !HAS_VIRTUAL_REGISTERS)\n      {\n      OP2(SLJIT_ADD, RETURN_ADDR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0x400);\n      CMOV(SLJIT_LESS, STR_PTR, RETURN_ADDR, 0);\n      }\n    else\n      {\n      jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      JUMPHERE(jump);\n      }\n    return;\n    }\n\n  OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\n  jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400));\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xdc00);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400));\n\n  JUMPHERE(jump);\n  return;\n  }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16 */\n}\n\nstatic void move_back(compiler_common *common, jump_list **backtracks, BOOL must_be_valid)\n{\n/* Goes one character back. Affects STR_PTR and TMP1. If must_be_valid is TRUE,\nTMP2 is not used. Otherwise TMP2 must contain the start of the subject buffer,\nand it is destroyed. Does not modify STR_PTR for invalid character sequences. */\nDEFINE_COMPILER;\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_label *label;\n\nif (common->utf)\n  {\n  if (!must_be_valid && common->invalid_utf)\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n    add_jump(compiler, &common->utfmoveback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\n    JUMPHERE(jump);\n    return;\n    }\n\n  label = LABEL();\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\n  CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0x80, label);\n  return;\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  if (!must_be_valid && common->invalid_utf)\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    add_jump(compiler, &common->utfmoveback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\n    JUMPHERE(jump);\n    return;\n    }\n\n  /* Skip low surrogate if necessary. */\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xfc00);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0xdc00);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  return;\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf && !must_be_valid)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  if (backtracks != NULL)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    return;\n    }\n\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x110000);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_LESS);\n  OP2(SLJIT_SHL,  TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  return;\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(must_be_valid);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n}\n\nstatic void check_newlinechar(compiler_common *common, int nltype, jump_list **backtracks, BOOL jumpifmatch)\n{\n/* Character comes in TMP1. Checks if it is a newline. TMP2 may be destroyed. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (nltype == NLTYPE_ANY)\n  {\n  add_jump(compiler, &common->anynewline, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(jumpifmatch ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  }\nelse if (nltype == NLTYPE_ANYCRLF)\n  {\n  if (jumpifmatch)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR));\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n    }\n  else\n    {\n    jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n    JUMPHERE(jump);\n    }\n  }\nelse\n  {\n  SLJIT_ASSERT(nltype == NLTYPE_FIXED && common->newline < 256);\n  add_jump(compiler, backtracks, CMP(jumpifmatch ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline));\n  }\n}\n\n#ifdef SUPPORT_UNICODE\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\nstatic void do_utfreadchar(compiler_common *common)\n{\n/* Fast decoding a UTF-8 character. TMP1 contains the first byte\nof the character (>= 0xc0). Return char value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Searching for the first zero. */\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Two byte sequence. */\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x10000);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Three byte sequence. */\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Four byte sequence. */\nJUMPHERE(jump);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xf0000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadtype8(compiler_common *common)\n{\n/* Fast decoding a UTF-8 character type. TMP2 contains the first byte\nof the character (>= 0xc0). Return value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_jump *compare;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, 0x20);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Two byte sequence. */\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x1f);\n/* The upper 5 bits are known at this point. */\ncompare = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0x3);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP2, 0, TMP2, 0, TMP1, 0);\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(compare);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* We only have types for characters less than 256. */\nJUMPHERE(jump);\nOP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(utf8_table4) - 0xc0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadchar_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-8 character. TMP1 contains the first byte\nof the character (>= 0xc0). Return char value in TMP1. STR_PTR is\nundefined for invalid characters. */\nDEFINE_COMPILER;\nsljit_s32 i;\nsljit_s32 has_cmov = sljit_has_cpu_feature(SLJIT_HAS_CMOV);\nstruct sljit_jump *jump;\nstruct sljit_jump *buffer_end_close;\nstruct sljit_label *three_byte_entry;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid[11];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc2);\n\n/* Usually more than 3 characters remained in the subject buffer. */\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\n\n/* Not a valid start of a multi-byte sequence, no more bytes read. */\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xf5 - 0xc2);\n\nbuffer_end_close = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n/* If TMP2 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, 0x20000);\n  exit_invalid[2] = NULL;\n  }\nelse\n  exit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x10000);\njump = JUMP(SLJIT_NOT_ZERO);\n\nthree_byte_entry = LABEL();\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x2d800);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0xd800);\n  exit_invalid[3] = NULL;\n  }\nelse\n  exit_invalid[3] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid[4] = NULL;\n  }\nelse\n  exit_invalid[4] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\n\n/* Four-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, 0);\n  exit_invalid[5] = NULL;\n  }\nelse\n  exit_invalid[5] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc10000);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0x10000);\n  exit_invalid[6] = NULL;\n  }\nelse\n  exit_invalid[6] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(buffer_end_close);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nexit_invalid[7] = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n/* If TMP2 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nexit_invalid[8] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three-byte sequence. */\nJUMPHERE(jump);\nexit_invalid[9] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid[10] = NULL;\n  }\nelse\n  exit_invalid[10] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\n/* One will be substracted from STR_PTR later. */\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\n/* Four byte sequences are not possible. */\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x30000, three_byte_entry);\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 11; i++)\n  sljit_set_label(exit_invalid[i], exit_invalid_label);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadnewline_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-8 character, specialized for newlines.\nTMP1 contains the first byte of the character (>= 0xc0). Return\nchar value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_label *skip_start;\nstruct sljit_label *three_byte_exit;\nstruct sljit_jump *jump[5];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nif (common->nltype != NLTYPE_ANY)\n  {\n  SLJIT_ASSERT(common->nltype != NLTYPE_FIXED || common->newline < 128);\n\n  /* All newlines are ascii, just skip intermediate octets. */\n  jump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  loop = LABEL();\n  if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1)) == SLJIT_SUCCESS)\n    sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  else\n    {\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n\n  OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\n  CMPTO(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  JUMPHERE(jump[0]);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\n  OP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n  return;\n  }\n\njump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\njump[1] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0xc2);\njump[2] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0xe2);\n\nskip_start = LABEL();\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\njump[3] = CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80);\n\n/* Skip intermediate octets. */\nloop = LABEL();\njump[4] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, loop);\n\nJUMPHERE(jump[3]);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nthree_byte_exit = LABEL();\nJUMPHERE(jump[0]);\nJUMPHERE(jump[4]);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Two byte long newline: 0x85. */\nJUMPHERE(jump[1]);\nCMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x85, skip_start);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x85);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three byte long newlines: 0x2028 and 0x2029. */\nJUMPHERE(jump[2]);\nCMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, skip_start);\nCMPTO(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0, three_byte_exit);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP2, 0, SLJIT_IMM, 0x80);\nCMPTO(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x40, skip_start);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0x2000);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfmoveback_invalid(compiler_common *common)\n{\n/* Goes one character back. */\nDEFINE_COMPILER;\nsljit_s32 i;\nstruct sljit_jump *jump;\nstruct sljit_jump *buffer_start_close;\nstruct sljit_label *exit_ok_label;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid[7];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xc0);\n\n/* Two-byte sequence. */\nbuffer_start_close = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x20);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three-byte sequence. */\nJUMPHERE(jump);\nexit_invalid[1] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, -0x40);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x10);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Four-byte sequence. */\nJUMPHERE(jump);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0 - 0x80);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x40);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xf0);\nexit_invalid[3] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x05);\n\nexit_ok_label = LABEL();\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Two-byte sequence. */\nJUMPHERE(buffer_start_close);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\nexit_invalid[4] = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x20, exit_ok_label);\n\n/* Three-byte sequence. */\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nexit_invalid[5] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, -0x40);\nexit_invalid[6] = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x10, exit_ok_label);\n\n/* Four-byte sequences are not possible. */\n\nexit_invalid_label = LABEL();\nsljit_set_label(exit_invalid[5], exit_invalid_label);\nsljit_set_label(exit_invalid[6], exit_invalid_label);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[4]);\n/* -2 + 4 = 2 */\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 4; i++)\n  sljit_set_label(exit_invalid[i], exit_invalid_label);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(4));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump[2];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\njump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x20);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\njump[1] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x10);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-4));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0 - 0x80);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xf0);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump[1]);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump[0]);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback_invalid(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nsljit_s32 i;\nsljit_s32 has_cmov = sljit_has_cpu_feature(SLJIT_HAS_CMOV);\nstruct sljit_jump *jump[2];\nstruct sljit_label *two_byte_entry;\nstruct sljit_label *three_byte_entry;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid[8];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(3));\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xc0);\njump[0] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\njump[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x1e);\n\ntwo_byte_entry = LABEL();\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n/* If TMP1 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[1]);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2 - 0x80);\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0);\njump[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x10);\n\nthree_byte_entry = LABEL();\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 12);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, -0xd800);\n  exit_invalid[2] = NULL;\n  }\nelse\n  exit_invalid[2] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid[3] = NULL;\n  }\nelse\n  exit_invalid[3] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[1]);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0 - 0x80);\nexit_invalid[4] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 12);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Four-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-4));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xf0);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 18);\n/* ADD is used instead of OR because of the SUB 0x10000 above. */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0x10000);\n  exit_invalid[5] = NULL;\n  }\nelse\n  exit_invalid[5] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[0]);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\njump[0] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x1e, two_byte_entry);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2 - 0x80);\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\nexit_invalid[6] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x10, three_byte_entry);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[0]);\nexit_invalid[7] = CMP(SLJIT_GREATER, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x1e, two_byte_entry);\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 8; i++)\n  sljit_set_label(exit_invalid[i], exit_invalid_label);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n\n#if PCRE2_CODE_UNIT_WIDTH == 16\n\nstatic void do_utfreadchar_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-16 character. TMP1 contains the first half\nof the character (>= 0xd800). Return char value in TMP1. STR_PTR is\nundefined for invalid characters. */\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid[3];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n/* TMP2 contains the high surrogate. */\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xdc00);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x10000);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x400);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nJUMPHERE(exit_invalid[2]);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadnewline_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-16 character, specialized for newlines.\nTMP1 contains the first half of the character (>= 0xd800). Return\nchar value in TMP1. */\n\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid[2];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n/* TMP2 contains the high surrogate. */\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xdc00);\n\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xdc00);\nOP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0x400);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x10000);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCHAR_SHIFT);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfmoveback_invalid(compiler_common *common)\n{\n/* Goes one character back. */\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid[3];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nexit_invalid[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x400);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x400);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nJUMPHERE(exit_invalid[2]);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback_invalid(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_jump *exit_invalid[3];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\nexit_invalid[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xdc00);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nJUMPHERE(exit_invalid[2]);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == 16 */\n\n/* UCD_BLOCK_SIZE must be 128 (see the assert below). */\n#define UCD_BLOCK_MASK 127\n#define UCD_BLOCK_SHIFT 7\n\nstatic void do_getucd(compiler_common *common)\n{\n/* Search the UCD record for the character comes in TMP1.\nReturns chartype in TMP1 and UCD offset in TMP2. */\nDEFINE_COMPILER;\n#if PCRE2_CODE_UNIT_WIDTH == 32\nstruct sljit_jump *jump;\n#endif\n\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n/* dummy_ucd_record */\nconst ucd_record *record = GET_UCD(UNASSIGNED_UTF_CHAR);\nSLJIT_ASSERT(record->script == ucp_Unknown && record->chartype == ucp_Cn && record->gbprop == ucp_gbOther);\nSLJIT_ASSERT(record->caseset == 0 && record->other_case == 0);\n#endif\n\nSLJIT_ASSERT(UCD_BLOCK_SIZE == 128 && sizeof(ucd_record) == 12);\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (!common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n  JUMPHERE(jump);\n  }\n#endif\n\nOP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_getucdtype(compiler_common *common)\n{\n/* Search the UCD record for the character comes in TMP1.\nReturns chartype in TMP1 and UCD offset in TMP2. */\nDEFINE_COMPILER;\n#if PCRE2_CODE_UNIT_WIDTH == 32\nstruct sljit_jump *jump;\n#endif\n\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n/* dummy_ucd_record */\nconst ucd_record *record = GET_UCD(UNASSIGNED_UTF_CHAR);\nSLJIT_ASSERT(record->script == ucp_Unknown && record->chartype == ucp_Cn && record->gbprop == ucp_gbOther);\nSLJIT_ASSERT(record->caseset == 0 && record->other_case == 0);\n#endif\n\nSLJIT_ASSERT(UCD_BLOCK_SIZE == 128 && sizeof(ucd_record) == 12);\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (!common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n  JUMPHERE(jump);\n  }\n#endif\n\nOP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n\n/* TMP2 is multiplied by 12. Same as (TMP2 << 2) + ((TMP2 << 2) << 1). */\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM2(TMP1, TMP2), 1);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic SLJIT_INLINE struct sljit_label *mainloop_entry(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *mainloop;\nstruct sljit_label *newlinelabel = NULL;\nstruct sljit_jump *start;\nstruct sljit_jump *end = NULL;\nstruct sljit_jump *end2 = NULL;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_label *loop;\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\njump_list *newline = NULL;\nsljit_u32 overall_options = common->re->overall_options;\nBOOL hascrorlf = (common->re->flags & PCRE2_HASCRORLF) != 0;\nBOOL newlinecheck = FALSE;\nBOOL readuchar = FALSE;\n\nif (!(hascrorlf || (overall_options & PCRE2_FIRSTLINE) != 0)\n    && (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF || common->newline > 255))\n  newlinecheck = TRUE;\n\nSLJIT_ASSERT(common->abort_label == NULL);\n\nif ((overall_options & PCRE2_FIRSTLINE) != 0)\n  {\n  /* Search for the end of the first line. */\n  SLJIT_ASSERT(common->match_end_ptr != 0);\n  OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    mainloop = LABEL();\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, mainloop);\n    CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff, mainloop);\n    JUMPHERE(end);\n    OP2(SLJIT_SUB, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n  else\n    {\n    end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    mainloop = LABEL();\n    /* Continual stores does not cause data dependency. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0);\n    read_char(common, common->nlmin, common->nlmax, NULL, READ_CHAR_NEWLINE);\n    check_newlinechar(common, common->nltype, &newline, TRUE);\n    CMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, mainloop);\n    JUMPHERE(end);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0);\n    set_jumps(newline, LABEL());\n    }\n\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n  }\nelse if ((overall_options & PCRE2_USE_OFFSET_LIMIT) != 0)\n  {\n  /* Check whether offset limit is set and valid. */\n  SLJIT_ASSERT(common->match_end_ptr != 0);\n\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, offset_limit));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, offset_limit));\n\n  OP1(SLJIT_MOV, TMP2, 0, STR_END, 0);\n  end = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw) PCRE2_UNSET);\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif /* PCRE2_CODE_UNIT_WIDTH == [16|32] */\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, begin));\n\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n  end2 = CMP(SLJIT_LESS_EQUAL, TMP2, 0, STR_END, 0);\n  OP1(SLJIT_MOV, TMP2, 0, STR_END, 0);\n  JUMPHERE(end2);\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  add_jump(compiler, &common->abort, CMP(SLJIT_LESS, TMP2, 0, STR_PTR, 0));\n  JUMPHERE(end);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, TMP2, 0);\n  }\n\nstart = JUMP(SLJIT_JUMP);\n\nif (newlinecheck)\n  {\n  newlinelabel = LABEL();\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, common->newline & 0xff);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif /* PCRE2_CODE_UNIT_WIDTH == [16|32] */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  end2 = JUMP(SLJIT_JUMP);\n  }\n\nmainloop = LABEL();\n\n/* Increasing the STR_PTR here requires one less jump in the most common case. */\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && !common->invalid_utf) readuchar = TRUE;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\nif (newlinecheck) readuchar = TRUE;\n\nif (readuchar)\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n\nif (newlinecheck)\n  CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, newlinelabel);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->invalid_utf)\n  {\n  /* Skip continuation code units. */\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x40, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPHERE(jump);\n  }\nelse if (common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->invalid_utf)\n  {\n  /* Skip continuation code units. */\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x400, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPHERE(jump);\n  }\nelse if (common->utf)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x400);\n    CMOV(SLJIT_LESS, STR_PTR, TMP2, 0);\n    }\n  else\n    {\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x400);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_LESS);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16] */\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\nJUMPHERE(start);\n\nif (newlinecheck)\n  {\n  JUMPHERE(end);\n  JUMPHERE(end2);\n  }\n\nreturn mainloop;\n}\n\n\nstatic SLJIT_INLINE void add_prefix_char(PCRE2_UCHAR chr, fast_forward_char_data *chars, BOOL last)\n{\nsljit_u32 i, count = chars->count;\n\nif (count == 255)\n  return;\n\nif (count == 0)\n  {\n  chars->count = 1;\n  chars->chars[0] = chr;\n\n  if (last)\n    chars->last_count = 1;\n  return;\n  }\n\nfor (i = 0; i < count; i++)\n  if (chars->chars[i] == chr)\n    return;\n\nif (count >= MAX_DIFF_CHARS)\n  {\n  chars->count = 255;\n  return;\n  }\n\nchars->chars[count] = chr;\nchars->count = count + 1;\n\nif (last)\n  chars->last_count++;\n}\n\nstatic int scan_prefix(compiler_common *common, PCRE2_SPTR cc, fast_forward_char_data *chars, int max_chars, sljit_u32 *rec_count)\n{\n/* Recursive function, which scans prefix literals. */\nBOOL last, any, class, caseless;\nint len, repeat, len_save, consumed = 0;\nsljit_u32 chr; /* Any unicode character. */\nsljit_u8 *bytes, *bytes_end, byte;\nPCRE2_SPTR alternative, cc_save, oc;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nPCRE2_UCHAR othercase[4];\n#elif defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16\nPCRE2_UCHAR othercase[2];\n#else\nPCRE2_UCHAR othercase[1];\n#endif\n\nrepeat = 1;\nwhile (TRUE)\n  {\n  if (*rec_count == 0)\n    return 0;\n  (*rec_count)--;\n\n  last = TRUE;\n  any = FALSE;\n  class = FALSE;\n  caseless = FALSE;\n\n  switch (*cc)\n    {\n    case OP_CHARI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_CHAR:\n    last = FALSE;\n    cc++;\n    break;\n\n    case OP_SOD:\n    case OP_SOM:\n    case OP_SET_SOM:\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    /* Zero width assertions. */\n    cc++;\n    continue;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    cc = bracketend(cc);\n    continue;\n\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_POSPLUSI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_POSPLUS:\n    cc++;\n    break;\n\n    case OP_EXACTI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_EXACT:\n    repeat = GET2(cc, 1);\n    last = FALSE;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_POSQUERYI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_POSQUERY:\n    len = 1;\n    cc++;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(*cc)) len += GET_EXTRALEN(*cc);\n#endif\n    max_chars = scan_prefix(common, cc + len, chars, max_chars, rec_count);\n    if (max_chars == 0)\n      return consumed;\n    last = FALSE;\n    break;\n\n    case OP_KET:\n    cc += 1 + LINK_SIZE;\n    continue;\n\n    case OP_ALT:\n    cc += GET(cc, 1);\n    continue;\n\n    case OP_ONCE:\n    case OP_BRA:\n    case OP_BRAPOS:\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    alternative = cc + GET(cc, 1);\n    while (*alternative == OP_ALT)\n      {\n      max_chars = scan_prefix(common, alternative + 1 + LINK_SIZE, chars, max_chars, rec_count);\n      if (max_chars == 0)\n        return consumed;\n      alternative += GET(alternative, 1);\n      }\n\n    if (*cc == OP_CBRA || *cc == OP_CBRAPOS)\n      cc += IMM2_SIZE;\n    cc += 1 + LINK_SIZE;\n    continue;\n\n    case OP_CLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)(cc + 1), FALSE))\n      return consumed;\n#endif\n    class = TRUE;\n    break;\n\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    class = TRUE;\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc += GET(cc, 1);\n    break;\n#endif\n\n    case OP_DIGIT:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_digit, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_WHITESPACE:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_space, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_WORDCHAR:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_word, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_NOT:\n    case OP_NOTI:\n    cc++;\n    /* Fall through. */\n    case OP_NOT_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n#ifdef SUPPORT_UNICODE\n    case OP_NOTPROP:\n    case OP_PROP:\n#if PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc += 1 + 2;\n    break;\n#endif\n\n    case OP_TYPEEXACT:\n    repeat = GET2(cc, 1);\n    cc += 1 + IMM2_SIZE;\n    continue;\n\n    case OP_NOTEXACT:\n    case OP_NOTEXACTI:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    repeat = GET2(cc, 1);\n    cc += 1 + IMM2_SIZE + 1;\n    break;\n\n    default:\n    return consumed;\n    }\n\n  if (any)\n    {\n    do\n      {\n      chars->count = 255;\n\n      consumed++;\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      }\n    while (--repeat > 0);\n\n    repeat = 1;\n    continue;\n    }\n\n  if (class)\n    {\n    bytes = (sljit_u8*) (cc + 1);\n    cc += 1 + 32 / sizeof(PCRE2_UCHAR);\n\n    switch (*cc)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRPOSSTAR:\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      case OP_CRPOSQUERY:\n      max_chars = scan_prefix(common, cc + 1, chars, max_chars, rec_count);\n      if (max_chars == 0)\n        return consumed;\n      break;\n\n      default:\n      case OP_CRPLUS:\n      case OP_CRMINPLUS:\n      case OP_CRPOSPLUS:\n      break;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      case OP_CRPOSRANGE:\n      repeat = GET2(cc, 1);\n      if (repeat <= 0)\n        return consumed;\n      break;\n      }\n\n    do\n      {\n      if (bytes[31] & 0x80)\n        chars->count = 255;\n      else if (chars->count != 255)\n        {\n        bytes_end = bytes + 32;\n        chr = 0;\n        do\n          {\n          byte = *bytes++;\n          SLJIT_ASSERT((chr & 0x7) == 0);\n          if (byte == 0)\n            chr += 8;\n          else\n            {\n            do\n              {\n              if ((byte & 0x1) != 0)\n                add_prefix_char(chr, chars, TRUE);\n              byte >>= 1;\n              chr++;\n              }\n            while (byte != 0);\n            chr = (chr + 7) & ~7;\n            }\n          }\n        while (chars->count != 255 && bytes < bytes_end);\n        bytes = bytes_end - 32;\n        }\n\n      consumed++;\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      }\n    while (--repeat > 0);\n\n    switch (*cc)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRPOSSTAR:\n      return consumed;\n\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      case OP_CRPOSQUERY:\n      cc++;\n      break;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      case OP_CRPOSRANGE:\n      if (GET2(cc, 1) != GET2(cc, 1 + IMM2_SIZE))\n        return consumed;\n      cc += 1 + 2 * IMM2_SIZE;\n      break;\n      }\n\n    repeat = 1;\n    continue;\n    }\n\n  len = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(*cc)) len += GET_EXTRALEN(*cc);\n#endif\n\n  if (caseless && char_has_othercase(common, cc))\n    {\n#ifdef SUPPORT_UNICODE\n    if (common->utf)\n      {\n      GETCHAR(chr, cc);\n      if ((int)PRIV(ord2utf)(char_othercase(common, chr), othercase) != len)\n        return consumed;\n      }\n    else\n#endif\n      {\n      chr = *cc;\n#ifdef SUPPORT_UNICODE\n      if (common->ucp && chr > 127)\n        othercase[0] = UCD_OTHERCASE(chr);\n      else\n#endif\n        othercase[0] = TABLE_GET(chr, common->fcc, chr);\n      }\n    }\n  else\n    {\n    caseless = FALSE;\n    othercase[0] = 0; /* Stops compiler warning - PH */\n    }\n\n  len_save = len;\n  cc_save = cc;\n  while (TRUE)\n    {\n    oc = othercase;\n    do\n      {\n      len--;\n      consumed++;\n\n      chr = *cc;\n      add_prefix_char(*cc, chars, len == 0);\n\n      if (caseless)\n        add_prefix_char(*oc, chars, len == 0);\n\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      cc++;\n      oc++;\n      }\n    while (len > 0);\n\n    if (--repeat == 0)\n      break;\n\n    len = len_save;\n    cc = cc_save;\n    }\n\n  repeat = 1;\n  if (last)\n    return consumed;\n  }\n}\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstatic void jumpto_if_not_utf_char_start(struct sljit_compiler *compiler, sljit_s32 reg, struct sljit_label *label)\n{\n#if PCRE2_CODE_UNIT_WIDTH == 8\nOP2(SLJIT_AND, reg, 0, reg, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_EQUAL, reg, 0, SLJIT_IMM, 0x80, label);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nOP2(SLJIT_AND, reg, 0, reg, 0, SLJIT_IMM, 0xfc00);\nCMPTO(SLJIT_EQUAL, reg, 0, SLJIT_IMM, 0xdc00, label);\n#else\n#error \"Unknown code width\"\n#endif\n}\n#endif\n\n#include \"pcre2_jit_simd_inc.h\"\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\n\nstatic BOOL check_fast_forward_char_pair_simd(compiler_common *common, fast_forward_char_data *chars, int max)\n{\n  sljit_s32 i, j, max_i = 0, max_j = 0;\n  sljit_u32 max_pri = 0;\n  PCRE2_UCHAR a1, a2, a_pri, b1, b2, b_pri;\n\n  for (i = max - 1; i >= 1; i--)\n    {\n    if (chars[i].last_count > 2)\n      {\n      a1 = chars[i].chars[0];\n      a2 = chars[i].chars[1];\n      a_pri = chars[i].last_count;\n\n      j = i - max_fast_forward_char_pair_offset();\n      if (j < 0)\n        j = 0;\n\n      while (j < i)\n        {\n        b_pri = chars[j].last_count;\n        if (b_pri > 2 && a_pri + b_pri >= max_pri)\n          {\n          b1 = chars[j].chars[0];\n          b2 = chars[j].chars[1];\n\n          if (a1 != b1 && a1 != b2 && a2 != b1 && a2 != b2)\n            {\n            max_pri = a_pri + b_pri;\n            max_i = i;\n            max_j = j;\n            }\n          }\n        j++;\n        }\n      }\n    }\n\nif (max_pri == 0)\n  return FALSE;\n\nfast_forward_char_pair_simd(common, max_i, chars[max_i].chars[0], chars[max_i].chars[1], max_j, chars[max_j].chars[0], chars[max_j].chars[1]);\nreturn TRUE;\n}\n\n#endif /* JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD */\n\nstatic void fast_forward_first_char2(compiler_common *common, PCRE2_UCHAR char1, PCRE2_UCHAR char2, sljit_s32 offset)\n{\nDEFINE_COMPILER;\nstruct sljit_label *start;\nstruct sljit_jump *match;\nstruct sljit_jump *partial_quit;\nPCRE2_UCHAR mask;\nBOOL has_match_end = (common->match_end_ptr != 0);\n\nSLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE || offset == 0);\n\nif (has_match_end)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n\nif (offset > 0)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset));\n\nif (has_match_end)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(offset + 1));\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_SIMD\n\nif (JIT_HAS_FAST_FORWARD_CHAR_SIMD)\n  {\n  fast_forward_char_simd(common, char1, char2, offset);\n\n  if (offset > 0)\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset));\n\n  if (has_match_end)\n    OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n  return;\n  }\n\n#endif\n\nstart = LABEL();\n\npartial_quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_COMPLETE)\n  add_jump(compiler, &common->failed_match, partial_quit);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (char1 == char2)\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char1, start);\nelse\n  {\n  mask = char1 ^ char2;\n  if (is_powerof2(mask))\n    {\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, mask);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char1 | mask, start);\n    }\n  else\n    {\n    match = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, char1);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char2, start);\n    JUMPHERE(match);\n    }\n  }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && offset > 0)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-(offset + 1)));\n  jumpto_if_not_utf_char_start(compiler, TMP1, start);\n  }\n#endif\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset + 1));\n\nif (common->mode != PCRE2_JIT_COMPLETE)\n  JUMPHERE(partial_quit);\n\nif (has_match_end)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n}\n\nstatic SLJIT_INLINE BOOL fast_forward_first_n_chars(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *start;\nstruct sljit_jump *match;\nfast_forward_char_data chars[MAX_N_CHARS];\nsljit_s32 offset;\nPCRE2_UCHAR mask;\nPCRE2_UCHAR *char_set, *char_set_end;\nint i, max, from;\nint range_right = -1, range_len;\nsljit_u8 *update_table = NULL;\nBOOL in_range;\nsljit_u32 rec_count;\n\nfor (i = 0; i < MAX_N_CHARS; i++)\n  {\n  chars[i].count = 0;\n  chars[i].last_count = 0;\n  }\n\nrec_count = 10000;\nmax = scan_prefix(common, common->start, chars, MAX_N_CHARS, &rec_count);\n\nif (max < 1)\n  return FALSE;\n\n/* Convert last_count to priority. */\nfor (i = 0; i < max; i++)\n  {\n  SLJIT_ASSERT(chars[i].count > 0 && chars[i].last_count <= chars[i].count);\n\n  if (chars[i].count == 1)\n    {\n    chars[i].last_count = (chars[i].last_count == 1) ? 7 : 5;\n    /* Simplifies algorithms later. */\n    chars[i].chars[1] = chars[i].chars[0];\n    }\n  else if (chars[i].count == 2)\n    {\n    SLJIT_ASSERT(chars[i].chars[0] != chars[i].chars[1]);\n\n    if (is_powerof2(chars[i].chars[0] ^ chars[i].chars[1]))\n      chars[i].last_count = (chars[i].last_count == 2) ? 6 : 4;\n    else\n      chars[i].last_count = (chars[i].last_count == 2) ? 3 : 2;\n    }\n  else\n    chars[i].last_count = (chars[i].count == 255) ? 0 : 1;\n  }\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\nif (JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD && check_fast_forward_char_pair_simd(common, chars, max))\n  return TRUE;\n#endif\n\nin_range = FALSE;\n/* Prevent compiler \"uninitialized\" warning */\nfrom = 0;\nrange_len = 4 /* minimum length */ - 1;\nfor (i = 0; i <= max; i++)\n  {\n  if (in_range && (i - from) > range_len && (chars[i - 1].count < 255))\n    {\n    range_len = i - from;\n    range_right = i - 1;\n    }\n\n  if (i < max && chars[i].count < 255)\n    {\n    SLJIT_ASSERT(chars[i].count > 0);\n    if (!in_range)\n      {\n      in_range = TRUE;\n      from = i;\n      }\n    }\n  else\n    in_range = FALSE;\n  }\n\nif (range_right >= 0)\n  {\n  update_table = (sljit_u8 *)allocate_read_only_data(common, 256);\n  if (update_table == NULL)\n    return TRUE;\n  memset(update_table, IN_UCHARS(range_len), 256);\n\n  for (i = 0; i < range_len; i++)\n    {\n    SLJIT_ASSERT(chars[range_right - i].count > 0 && chars[range_right - i].count < 255);\n\n    char_set = chars[range_right - i].chars;\n    char_set_end = char_set + chars[range_right - i].count;\n    do\n      {\n      if (update_table[(*char_set) & 0xff] > IN_UCHARS(i))\n        update_table[(*char_set) & 0xff] = IN_UCHARS(i);\n      char_set++;\n      }\n    while (char_set < char_set_end);\n    }\n  }\n\noffset = -1;\n/* Scan forward. */\nfor (i = 0; i < max; i++)\n  {\n  if (range_right == i)\n    continue;\n\n  if (offset == -1)\n    {\n    if (chars[i].last_count >= 2)\n      offset = i;\n    }\n  else if (chars[offset].last_count < chars[i].last_count)\n    offset = i;\n  }\n\nSLJIT_ASSERT(offset == -1 || (chars[offset].count >= 1 && chars[offset].count <= 2));\n\nif (range_right < 0)\n  {\n  if (offset < 0)\n    return FALSE;\n  /* Works regardless the value is 1 or 2. */\n  fast_forward_first_char2(common, chars[offset].chars[0], chars[offset].chars[1], offset);\n  return TRUE;\n  }\n\nSLJIT_ASSERT(range_right != offset);\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\n  add_jump(compiler, &common->failed_match, JUMP(SLJIT_LESS));\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\nelse\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\n  add_jump(compiler, &common->failed_match, JUMP(SLJIT_LESS));\n  }\n\nSLJIT_ASSERT(range_right >= 0);\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, SLJIT_IMM, (sljit_sw)update_table);\n\nstart = LABEL();\nadd_jump(compiler, &common->failed_match, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8 || (defined SLJIT_LITTLE_ENDIAN && SLJIT_LITTLE_ENDIAN)\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(range_right));\n#else\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(range_right + 1) - 1);\n#endif\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM2(RETURN_ADDR, TMP1), 0);\nelse\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)update_table);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\nCMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, start);\n\nif (offset >= 0)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(offset));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  if (chars[offset].count == 1)\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[0], start);\n  else\n    {\n    mask = chars[offset].chars[0] ^ chars[offset].chars[1];\n    if (is_powerof2(mask))\n      {\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, mask);\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[0] | mask, start);\n      }\n    else\n      {\n      match = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[0]);\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[1], start);\n      JUMPHERE(match);\n      }\n    }\n  }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && offset != 0)\n  {\n  if (offset < 0)\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n  else\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n\n  jumpto_if_not_utf_char_start(compiler, TMP1, start);\n\n  if (offset < 0)\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\n#endif\n\nif (offset >= 0)\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\nelse\n  OP2(SLJIT_ADD, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\nreturn TRUE;\n}\n\nstatic SLJIT_INLINE void fast_forward_first_char(compiler_common *common)\n{\nPCRE2_UCHAR first_char = (PCRE2_UCHAR)(common->re->first_codeunit);\nPCRE2_UCHAR oc;\n\noc = first_char;\nif ((common->re->flags & PCRE2_FIRSTCASELESS) != 0)\n  {\n  oc = TABLE_GET(first_char, common->fcc, first_char);\n#if defined SUPPORT_UNICODE\n  if (first_char > 127 && (common->utf || common->ucp))\n    oc = UCD_OTHERCASE(first_char);\n#endif\n  }\n\nfast_forward_first_char2(common, first_char, oc, 0);\n}\n\nstatic SLJIT_INLINE void fast_forward_newline(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_jump *lastchar = NULL;\nstruct sljit_jump *firstchar;\nstruct sljit_jump *quit = NULL;\nstruct sljit_jump *foundcr = NULL;\nstruct sljit_jump *notfoundnl;\njump_list *newline = NULL;\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n  OP1(SLJIT_MOV, STR_END, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  }\n\nif (common->nltype == NLTYPE_FIXED && common->newline > 255)\n  {\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\n  if (JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD && common->mode == PCRE2_JIT_COMPLETE)\n    {\n    if (HAS_VIRTUAL_REGISTERS)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    firstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, STR_PTR, 0, TMP1, 0);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_NOT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n\n    fast_forward_char_pair_simd(common, 1, common->newline & 0xff, common->newline & 0xff, 0, (common->newline >> 8) & 0xff, (common->newline >> 8) & 0xff);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    }\n  else\n#endif /* JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD */\n    {\n    lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    if (HAS_VIRTUAL_REGISTERS)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    firstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, STR_PTR, 0, TMP1, 0);\n    OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\n    loop = LABEL();\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, loop);\n    CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff, loop);\n\n    JUMPHERE(quit);\n    JUMPHERE(lastchar);\n    }\n\n  JUMPHERE(firstchar);\n\n  if (common->match_end_ptr != 0)\n    OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n  return;\n  }\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n  }\nelse\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n\n/* Example: match /^/ to \\r\\n from offset 1. */\nfirstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\nif (common->nltype == NLTYPE_ANY)\n  move_back(common, NULL, FALSE);\nelse\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nloop = LABEL();\ncommon->ff_newline_shortcut = loop;\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_SIMD\nif (JIT_HAS_FAST_FORWARD_CHAR_SIMD && (common->nltype == NLTYPE_FIXED || common->nltype == NLTYPE_ANYCRLF))\n  {\n  if (common->nltype == NLTYPE_ANYCRLF)\n    {\n    fast_forward_char_simd(common, CHAR_CR, CHAR_LF, 0);\n    if (common->mode != PCRE2_JIT_COMPLETE)\n      lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    quit = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    }\n   else\n    {\n    fast_forward_char_simd(common, common->newline, common->newline, 0);\n\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    if (common->mode != PCRE2_JIT_COMPLETE)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_PTR, 0, STR_END, 0);\n      CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n      }\n    }\n  }\nelse\n#endif /* JIT_HAS_FAST_FORWARD_CHAR_SIMD */\n  {\n  read_char(common, common->nlmin, common->nlmax, NULL, READ_CHAR_NEWLINE);\n  lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  if (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)\n    foundcr = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n  check_newlinechar(common, common->nltype, &newline, FALSE);\n  set_jumps(newline, loop);\n  }\n\nif (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)\n  {\n  if (quit == NULL)\n    {\n    quit = JUMP(SLJIT_JUMP);\n    JUMPHERE(foundcr);\n    }\n\n  notfoundnl = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, CHAR_NL);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  JUMPHERE(notfoundnl);\n  JUMPHERE(quit);\n  }\n\nif (lastchar)\n  JUMPHERE(lastchar);\nJUMPHERE(firstchar);\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n}\n\nstatic BOOL optimize_class(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks);\n\nstatic SLJIT_INLINE void fast_forward_start_bits(compiler_common *common)\n{\nDEFINE_COMPILER;\nconst sljit_u8 *start_bits = common->re->start_bitmap;\nstruct sljit_label *start;\nstruct sljit_jump *partial_quit;\n#if PCRE2_CODE_UNIT_WIDTH != 8\nstruct sljit_jump *found = NULL;\n#endif\njump_list *matches = NULL;\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, STR_END, 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\n\nstart = LABEL();\n\npartial_quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_COMPLETE)\n  add_jump(compiler, &common->failed_match, partial_quit);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (!optimize_class(common, start_bits, (start_bits[31] & 0x80) != 0, FALSE, &matches))\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  if ((start_bits[31] & 0x80) != 0)\n    found = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 255);\n  else\n    CMPTO(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 255, start);\n#elif defined SUPPORT_UNICODE\n  if (common->utf && is_char7_bitset(start_bits, FALSE))\n    CMPTO(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 127, start);\n#endif\n  OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)start_bits);\n  if (!HAS_VIRTUAL_REGISTERS)\n    {\n    OP2(SLJIT_SHL, TMP3, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP3, 0);\n    }\n  else\n    {\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    }\n  JUMPTO(SLJIT_ZERO, start);\n  }\nelse\n  set_jumps(matches, start);\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\nif (found != NULL)\n  JUMPHERE(found);\n#endif\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (common->mode != PCRE2_JIT_COMPLETE)\n  JUMPHERE(partial_quit);\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, RETURN_ADDR, 0);\n}\n\nstatic SLJIT_INLINE jump_list *search_requested_char(compiler_common *common, PCRE2_UCHAR req_char, BOOL caseless, BOOL has_firstchar)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_jump *toolong;\nstruct sljit_jump *already_found;\nstruct sljit_jump *found;\nstruct sljit_jump *found_oc = NULL;\njump_list *not_found = NULL;\nsljit_u32 oc, bit;\n\nSLJIT_ASSERT(common->req_char_ptr != 0);\nOP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(REQ_CU_MAX) * 100);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr);\ntoolong = CMP(SLJIT_LESS, TMP2, 0, STR_END, 0);\nalready_found = CMP(SLJIT_LESS, STR_PTR, 0, TMP1, 0);\n\nif (has_firstchar)\n  OP2(SLJIT_ADD, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nelse\n  OP1(SLJIT_MOV, TMP1, 0, STR_PTR, 0);\n\noc = req_char;\nif (caseless)\n  {\n  oc = TABLE_GET(req_char, common->fcc, req_char);\n#if defined SUPPORT_UNICODE\n  if (req_char > 127 && (common->utf || common->ucp))\n    oc = UCD_OTHERCASE(req_char);\n#endif\n  }\n\n#ifdef JIT_HAS_FAST_REQUESTED_CHAR_SIMD\nif (JIT_HAS_FAST_REQUESTED_CHAR_SIMD)\n  {\n  not_found = fast_requested_char_simd(common, req_char, oc);\n  }\nelse\n#endif\n  {\n  loop = LABEL();\n  add_jump(compiler, &not_found, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, STR_END, 0));\n\n  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(TMP1), 0);\n\n  if (req_char == oc)\n    found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char);\n  else\n    {\n    bit = req_char ^ oc;\n    if (is_powerof2(bit))\n      {\n       OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, bit);\n      found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char | bit);\n      }\n    else\n      {\n      found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char);\n      found_oc = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, oc);\n      }\n    }\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_JUMP, loop);\n\n  JUMPHERE(found);\n  if (found_oc)\n    JUMPHERE(found_oc);\n  }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr, TMP1, 0);\n\nJUMPHERE(already_found);\nJUMPHERE(toolong);\nreturn not_found;\n}\n\nstatic void do_revertframes(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *mainloop;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\nGET_LOCAL_BASE(TMP1, 0, 0);\n\n/* Drop frames until we reach STACK_TOP. */\nmainloop = LABEL();\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), -sizeof(sljit_sw));\njump = CMP(SLJIT_SIG_LESS_EQUAL, TMP2, 0, SLJIT_IMM, 0);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), sizeof(sljit_sw), SLJIT_MEM1(STACK_TOP), -(3 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(3 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP1, 0);\n  GET_LOCAL_BASE(TMP1, 0, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), sizeof(sljit_sw), TMP3, 0);\n  }\nJUMPTO(SLJIT_JUMP, mainloop);\n\nJUMPHERE(jump);\njump = CMP(SLJIT_NOT_ZERO /* SIG_LESS */, TMP2, 0, SLJIT_IMM, 0);\n/* End of reverting values. */\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\nOP1(SLJIT_NEG, TMP2, 0, TMP2, 0);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * sizeof(sljit_sw));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP3, 0);\n  }\nJUMPTO(SLJIT_JUMP, mainloop);\n}\n\nstatic void check_wordboundary(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *skipread;\njump_list *skipread_list = NULL;\n#ifdef SUPPORT_UNICODE\nstruct sljit_label *valid_utf;\njump_list *invalid_utf1 = NULL;\n#endif /* SUPPORT_UNICODE */\njump_list *invalid_utf2 = NULL;\n#if PCRE2_CODE_UNIT_WIDTH != 8 || defined SUPPORT_UNICODE\nstruct sljit_jump *jump;\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 || SUPPORT_UNICODE */\n\nSLJIT_COMPILE_ASSERT(ctype_word == 0x10, ctype_word_must_be_16);\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n/* Get type of the previous char, and put it to TMP3. */\nOP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\nOP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, 0);\nskipread = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n#ifdef SUPPORT_UNICODE\nif (common->invalid_utf)\n  {\n  peek_char_back(common, READ_CHAR_MAX, &invalid_utf1);\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n    OP1(SLJIT_MOV, TMP2, 0, STR_PTR, 0);\n    move_back(common, NULL, TRUE);\n    check_start_used_ptr(common);\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, TMP2, 0);\n    }\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    peek_char_back(common, READ_CHAR_MAX, NULL);\n  else\n    {\n    move_back(common, NULL, TRUE);\n    check_start_used_ptr(common);\n    read_char(common, 0, READ_CHAR_MAX, NULL, READ_CHAR_UPDATE_STR_PTR);\n    }\n  }\n\n/* Testing char type. */\n#ifdef SUPPORT_UNICODE\nif (common->ucp)\n  {\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 1);\n  jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_UNDERSCORE);\n  add_jump(compiler, &common->getucdtype, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Nd - ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP3, 0, TMP2, 0);\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#elif defined SUPPORT_UNICODE\n  /* Here TMP3 has already been zeroed. */\n  jump = NULL;\n  if (common->utf)\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), common->ctypes);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 4 /* ctype_word */);\n  OP2(SLJIT_AND, TMP3, 0, TMP1, 0, SLJIT_IMM, 1);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  JUMPHERE(jump);\n#elif defined SUPPORT_UNICODE\n  if (jump != NULL)\n    JUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  }\nJUMPHERE(skipread);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\ncheck_str_end(common, &skipread_list);\npeek_char(common, READ_CHAR_MAX, SLJIT_MEM1(SLJIT_SP), LOCALS1, &invalid_utf2);\n\n/* Testing char type. This is a code duplication. */\n#ifdef SUPPORT_UNICODE\n\nvalid_utf = LABEL();\n\nif (common->ucp)\n  {\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 1);\n  jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_UNDERSCORE);\n  add_jump(compiler, &common->getucdtype, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Nd - ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  JUMPHERE(jump);\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  /* TMP2 may be destroyed by peek_char. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n  jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#elif defined SUPPORT_UNICODE\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n  jump = NULL;\n  if (common->utf)\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#endif\n  OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP1), common->ctypes);\n  OP2(SLJIT_LSHR, TMP2, 0, TMP2, 0, SLJIT_IMM, 4 /* ctype_word */);\n  OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  JUMPHERE(jump);\n#elif defined SUPPORT_UNICODE\n  if (jump != NULL)\n    JUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  }\nset_jumps(skipread_list, LABEL());\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_XOR | SLJIT_SET_Z, TMP2, 0, TMP2, 0, TMP3, 0);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n#ifdef SUPPORT_UNICODE\nif (common->invalid_utf)\n  {\n  set_jumps(invalid_utf1, LABEL());\n\n  peek_char(common, READ_CHAR_MAX, SLJIT_MEM1(SLJIT_SP), LOCALS1, NULL);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR, valid_utf);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, -1);\n  OP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n  set_jumps(invalid_utf2, LABEL());\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP1(SLJIT_MOV, TMP2, 0, TMP3, 0);\n  OP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n  }\n#endif /* SUPPORT_UNICODE */\n}\n\nstatic BOOL optimize_class_ranges(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nint ranges[MAX_CLASS_RANGE_SIZE];\nsljit_u8 bit, cbit, all;\nint i, byte, length = 0;\n\nbit = bits[0] & 0x1;\n/* All bits will be zero or one (since bit is zero or one). */\nall = -bit;\n\nfor (i = 0; i < 256; )\n  {\n  byte = i >> 3;\n  if ((i & 0x7) == 0 && bits[byte] == all)\n    i += 8;\n  else\n    {\n    cbit = (bits[byte] >> (i & 0x7)) & 0x1;\n    if (cbit != bit)\n      {\n      if (length >= MAX_CLASS_RANGE_SIZE)\n        return FALSE;\n      ranges[length] = i;\n      length++;\n      bit = cbit;\n      all = -cbit;\n      }\n    i++;\n    }\n  }\n\nif (((bit == 0) && nclass) || ((bit == 1) && !nclass))\n  {\n  if (length >= MAX_CLASS_RANGE_SIZE)\n    return FALSE;\n  ranges[length] = 256;\n  length++;\n  }\n\nif (length < 0 || length > 4)\n  return FALSE;\n\nbit = bits[0] & 0x1;\nif (invert) bit ^= 0x1;\n\n/* No character is accepted. */\nif (length == 0 && bit == 0)\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\nswitch(length)\n  {\n  case 0:\n  /* When bit != 0, all characters are accepted. */\n  return TRUE;\n\n  case 1:\n  add_jump(compiler, backtracks, CMP(bit == 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n  return TRUE;\n\n  case 2:\n  if (ranges[0] + 1 != ranges[1])\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n    add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n  return TRUE;\n\n  case 3:\n  if (bit != 0)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[2]));\n    if (ranges[0] + 1 != ranges[1])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n    return TRUE;\n    }\n\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[0]));\n  if (ranges[1] + 1 != ranges[2])\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[1]);\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[2] - ranges[1]));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[1]));\n  return TRUE;\n\n  case 4:\n  if ((ranges[1] - ranges[0]) == (ranges[3] - ranges[2])\n      && (ranges[0] | (ranges[2] - ranges[0])) == ranges[2]\n      && (ranges[1] & (ranges[2] - ranges[0])) == 0\n      && is_powerof2(ranges[2] - ranges[0]))\n    {\n    SLJIT_ASSERT((ranges[0] & (ranges[2] - ranges[0])) == 0 && (ranges[2] & ranges[3] & (ranges[2] - ranges[0])) != 0);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[2] - ranges[0]);\n    if (ranges[2] + 1 != ranges[3])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[2]);\n      add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[3] - ranges[2]));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[2]));\n    return TRUE;\n    }\n\n  if (bit != 0)\n    {\n    i = 0;\n    if (ranges[0] + 1 != ranges[1])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n      i = ranges[0];\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n\n    if (ranges[2] + 1 != ranges[3])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[2] - i);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[3] - ranges[2]));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[2] - i));\n    return TRUE;\n    }\n\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[3] - ranges[0]));\n  if (ranges[1] + 1 != ranges[2])\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]);\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[2] - ranges[1]));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n  return TRUE;\n\n  default:\n  SLJIT_UNREACHABLE();\n  return FALSE;\n  }\n}\n\nstatic BOOL optimize_class_chars(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nuint16_t char_list[MAX_CLASS_CHARS_SIZE];\nuint8_t byte;\nsljit_s32 type;\nint i, j, k, len, c;\n\nif (!sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n  return FALSE;\n\nlen = 0;\n\nfor (i = 0; i < 32; i++)\n  {\n  byte = bits[i];\n\n  if (nclass)\n    byte = ~byte;\n\n  j = 0;\n  while (byte != 0)\n    {\n    if (byte & 0x1)\n      {\n      c = i * 8 + j;\n\n      k = len;\n\n      if ((c & 0x20) != 0)\n        {\n        for (k = 0; k < len; k++)\n          if (char_list[k] == c - 0x20)\n            {\n            char_list[k] |= 0x120;\n            break;\n            }\n        }\n\n      if (k == len)\n        {\n        if (len >= MAX_CLASS_CHARS_SIZE)\n          return FALSE;\n\n        char_list[len++] = (uint16_t) c;\n        }\n      }\n\n    byte >>= 1;\n    j++;\n    }\n  }\n\nif (len == 0) return FALSE;  /* Should never occur, but stops analyzers complaining. */\n\ni = 0;\nj = 0;\n\nif (char_list[0] == 0)\n  {\n  i++;\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_ZERO);\n  }\nelse\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n\nwhile (i < len)\n  {\n  if ((char_list[i] & 0x100) != 0)\n    j++;\n  else\n    {\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, char_list[i]);\n    CMOV(SLJIT_ZERO, TMP2, TMP1, 0);\n    }\n  i++;\n  }\n\nif (j != 0)\n  {\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x20);\n\n  for (i = 0; i < len; i++)\n    if ((char_list[i] & 0x100) != 0)\n      {\n      j--;\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, char_list[i] & 0xff);\n      CMOV(SLJIT_ZERO, TMP2, TMP1, 0);\n      }\n  }\n\nif (invert)\n  nclass = !nclass;\n\ntype = nclass ? SLJIT_NOT_EQUAL : SLJIT_EQUAL;\nadd_jump(compiler, backtracks, CMP(type, TMP2, 0, SLJIT_IMM, 0));\nreturn TRUE;\n}\n\nstatic BOOL optimize_class(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nif (optimize_class_ranges(common, bits, nclass, invert, backtracks))\n  return TRUE;\nreturn optimize_class_chars(common, bits, nclass, invert, backtracks);\n}\n\nstatic void check_anynewline(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x0a);\nOP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x0d - 0x0a);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x0a);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x1);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x2029 - 0x0a);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void check_hspace(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x09);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x20);\nOP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0xa0);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x1680);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x2000);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x200A - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x202f - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x205f - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x3000 - 0x2000);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void check_vspace(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x0a);\nOP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x0d - 0x0a);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x0a);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x1);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x2029 - 0x0a);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_casefulcmp(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *label;\nint char1_reg;\nint char2_reg;\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  char1_reg = STR_END;\n  char2_reg = STACK_TOP;\n  }\nelse\n  {\n  char1_reg = TMP3;\n  char2_reg = RETURN_ADDR;\n  }\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nif (char1_reg == STR_END)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, char1_reg, 0);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, char2_reg, 0);\n  }\n\nif (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  {\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  }\nelse if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\nelse\n  {\n  label = LABEL();\n  OP1(MOV_UCHAR, char1_reg, 0, SLJIT_MEM1(TMP1), 0);\n  OP1(MOV_UCHAR, char2_reg, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  }\n\nif (char1_reg == STR_END)\n  {\n  OP1(SLJIT_MOV, char1_reg, 0, TMP3, 0);\n  OP1(SLJIT_MOV, char2_reg, 0, RETURN_ADDR, 0);\n  }\n\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n}\n\nstatic void do_caselesscmp(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *label;\nint char1_reg = STR_END;\nint char2_reg;\nint lcc_table;\nint opt_type = 0;\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  char2_reg = STACK_TOP;\n  lcc_table = STACK_LIMIT;\n  }\nelse\n  {\n  char2_reg = RETURN_ADDR;\n  lcc_table = TMP3;\n  }\n\nif (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  opt_type = 1;\nelse if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  opt_type = 2;\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, char1_reg, 0);\n\nif (char2_reg == STACK_TOP)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, char2_reg, 0);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, lcc_table, 0);\n  }\n\nOP1(SLJIT_MOV, lcc_table, 0, SLJIT_IMM, common->lcc);\n\nif (opt_type == 1)\n  {\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  }\nelse if (opt_type == 2)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  }\nelse\n  {\n  label = LABEL();\n  OP1(MOV_UCHAR, char1_reg, 0, SLJIT_MEM1(TMP1), 0);\n  OP1(MOV_UCHAR, char2_reg, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\njump = CMP(SLJIT_GREATER, char1_reg, 0, SLJIT_IMM, 255);\n#endif\nOP1(SLJIT_MOV_U8, char1_reg, 0, SLJIT_MEM2(lcc_table, char1_reg), 0);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\njump = CMP(SLJIT_GREATER, char2_reg, 0, SLJIT_IMM, 255);\n#endif\nOP1(SLJIT_MOV_U8, char2_reg, 0, SLJIT_MEM2(lcc_table, char2_reg), 0);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\n#endif\n\nif (opt_type == 0)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\njump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\nOP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\nJUMPTO(SLJIT_NOT_ZERO, label);\n\nJUMPHERE(jump);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n\nif (opt_type == 2)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (char2_reg == STACK_TOP)\n  {\n  OP1(SLJIT_MOV, char2_reg, 0, TMP3, 0);\n  OP1(SLJIT_MOV, lcc_table, 0, RETURN_ADDR, 0);\n  }\n\nOP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), LOCALS1);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n}\n\nstatic PCRE2_SPTR byte_sequence_compare(compiler_common *common, BOOL caseless, PCRE2_SPTR cc,\n    compare_context *context, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nunsigned int othercasebit = 0;\nPCRE2_SPTR othercasechar = NULL;\n#ifdef SUPPORT_UNICODE\nint utflength;\n#endif\n\nif (caseless && char_has_othercase(common, cc))\n  {\n  othercasebit = char_get_othercase_bit(common, cc);\n  SLJIT_ASSERT(othercasebit);\n  /* Extracting bit difference info. */\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  othercasechar = cc + (othercasebit >> 8);\n  othercasebit &= 0xff;\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  /* Note that this code only handles characters in the BMP. If there\n  ever are characters outside the BMP whose othercase differs in only one\n  bit from itself (there currently are none), this code will need to be\n  revised for PCRE2_CODE_UNIT_WIDTH == 32. */\n  othercasechar = cc + (othercasebit >> 9);\n  if ((othercasebit & 0x100) != 0)\n    othercasebit = (othercasebit & 0xff) << 8;\n  else\n    othercasebit &= 0xff;\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n  }\n\nif (context->sourcereg == -1)\n  {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  if (context->length >= 4)\n    OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else if (context->length >= 2)\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else\n#endif\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  if (context->length >= 4)\n    OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else\n#endif\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n  context->sourcereg = TMP2;\n  }\n\n#ifdef SUPPORT_UNICODE\nutflength = 1;\nif (common->utf && HAS_EXTRALEN(*cc))\n  utflength += GET_EXTRALEN(*cc);\n\ndo\n  {\n#endif\n\n  context->length -= IN_UCHARS(1);\n#if (defined SLJIT_UNALIGNED && SLJIT_UNALIGNED) && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\n\n  /* Unaligned read is supported. */\n  if (othercasebit != 0 && othercasechar == cc)\n    {\n    context->c.asuchars[context->ucharptr] = *cc | othercasebit;\n    context->oc.asuchars[context->ucharptr] = othercasebit;\n    }\n  else\n    {\n    context->c.asuchars[context->ucharptr] = *cc;\n    context->oc.asuchars[context->ucharptr] = 0;\n    }\n  context->ucharptr++;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  if (context->ucharptr >= 4 || context->length == 0 || (context->ucharptr == 2 && context->length == 1))\n#else\n  if (context->ucharptr >= 2 || context->length == 0)\n#endif\n    {\n    if (context->length >= 4)\n      OP1(SLJIT_MOV_S32, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n    else if (context->length >= 2)\n      OP1(SLJIT_MOV_U16, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    else if (context->length >= 1)\n      OP1(SLJIT_MOV_U8, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n    context->sourcereg = context->sourcereg == TMP1 ? TMP2 : TMP1;\n\n    switch(context->ucharptr)\n      {\n      case 4 / sizeof(PCRE2_UCHAR):\n      if (context->oc.asint != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asint);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asint | context->oc.asint));\n      break;\n\n      case 2 / sizeof(PCRE2_UCHAR):\n      if (context->oc.asushort != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asushort);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asushort | context->oc.asushort));\n      break;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      case 1:\n      if (context->oc.asbyte != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asbyte);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asbyte | context->oc.asbyte));\n      break;\n#endif\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    context->ucharptr = 0;\n    }\n\n#else\n\n  /* Unaligned read is unsupported or in 32 bit mode. */\n  if (context->length >= 1)\n    OP1(MOV_UCHAR, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n\n  context->sourcereg = context->sourcereg == TMP1 ? TMP2 : TMP1;\n\n  if (othercasebit != 0 && othercasechar == cc)\n    {\n    OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, othercasebit);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, *cc | othercasebit));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, *cc));\n\n#endif\n\n  cc++;\n#ifdef SUPPORT_UNICODE\n  utflength--;\n  }\nwhile (utflength > 0);\n#endif\n\nreturn cc;\n}\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n\n#define SET_TYPE_OFFSET(value) \\\n  if ((value) != typeoffset) \\\n    { \\\n    if ((value) < typeoffset) \\\n      OP2(SLJIT_ADD, typereg, 0, typereg, 0, SLJIT_IMM, typeoffset - (value)); \\\n    else \\\n      OP2(SLJIT_SUB, typereg, 0, typereg, 0, SLJIT_IMM, (value) - typeoffset); \\\n    } \\\n  typeoffset = (value);\n\n#define SET_CHAR_OFFSET(value) \\\n  if ((value) != charoffset) \\\n    { \\\n    if ((value) < charoffset) \\\n      OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(charoffset - (value))); \\\n    else \\\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)((value) - charoffset)); \\\n    } \\\n  charoffset = (value);\n\nstatic PCRE2_SPTR compile_char1_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks, BOOL check_str_ptr);\n\n#ifdef SUPPORT_UNICODE\n#define XCLASS_SAVE_CHAR 0x001\n#define XCLASS_CHAR_SAVED 0x002\n#define XCLASS_HAS_TYPE 0x004\n#define XCLASS_HAS_SCRIPT 0x008\n#define XCLASS_HAS_SCRIPT_EXTENSION 0x010\n#define XCLASS_HAS_BOOL 0x020\n#define XCLASS_HAS_BIDICL 0x040\n#define XCLASS_NEEDS_UCD (XCLASS_HAS_TYPE | XCLASS_HAS_SCRIPT | XCLASS_HAS_SCRIPT_EXTENSION | XCLASS_HAS_BOOL | XCLASS_HAS_BIDICL)\n#define XCLASS_SCRIPT_EXTENSION_NOTPROP 0x080\n#define XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR 0x100\n#define XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0 0x200\n\n#endif /* SUPPORT_UNICODE */\n\nstatic void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list *found = NULL;\njump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\nsljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\nBOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status = 0;\nint typereg = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n    if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    cc++;\n    if (*cc == PT_CLIST && *cc == XCL_PROP)\n      {\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases != NOTACHAR)\n        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n    else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored. */\n      if (cc[-1] == XCL_PROP)\n        {\n        compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n          add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n        }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n      case PT_ALNUM:\n      unicode_status |= XCLASS_HAS_TYPE;\n      break;\n\n      case PT_SCX:\n      unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n      if (cc[-1] == XCL_NOTPROP)\n        {\n        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n        break;\n        }\n      compares++;\n      /* Fall through */ \n\n      case PT_SC:\n      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n      case PT_UCNC:\n      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\n      case PT_BOOL:\n      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\n      case PT_BIDICL:\n      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n/* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif ((cc[-1] & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\nelse\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\nif ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n      OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) != 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1] == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n          case PT_SC:\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n\n          jump = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n              {\n              add_jump(compiler, backtracks, jump);\n              jump = NULL;\n              }\n            invertcmp ^= 0x1;\n            }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n          if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\ntypeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump = NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc == XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing. */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /* Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n\n      /* At least three characters are required.\n         Otherwise this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0] != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\n      /* Optimizing character pairs, if their difference is power of 2. */\n      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n        }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found != NULL)\n  set_jumps(found, LABEL());\n}\n\n#undef SET_TYPE_OFFSET\n#undef SET_CHAR_OFFSET\n\n#endif\n\nstatic PCRE2_SPTR compile_simple_assertion_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nint length;\nstruct sljit_jump *jump[4];\n#ifdef SUPPORT_UNICODE\nstruct sljit_label *label;\n#endif /* SUPPORT_UNICODE */\n\nswitch(type)\n  {\n  case OP_SOD:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, TMP1, 0));\n  return cc;\n\n  case OP_SOM:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, TMP1, 0));\n  return cc;\n\n  case OP_NOT_WORD_BOUNDARY:\n  case OP_WORD_BOUNDARY:\n  add_jump(compiler, &common->wordboundary, JUMP(SLJIT_FAST_CALL));\n#ifdef SUPPORT_UNICODE\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, backtracks, CMP((type == OP_NOT_WORD_BOUNDARY) ? SLJIT_NOT_EQUAL : SLJIT_SIG_LESS_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n    return cc;\n    }\n#endif /* SUPPORT_UNICODE */\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_WORD_BOUNDARY ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n  case OP_EODN:\n  /* Requires rather complex checks. */\n  jump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_END, 0));\n    else\n      {\n      jump[1] = CMP(SLJIT_EQUAL, TMP2, 0, STR_END, 0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, STR_END, 0);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_NOT_EQUAL);\n      add_jump(compiler, backtracks, JUMP(SLJIT_NOT_EQUAL));\n      check_partial(common, TRUE);\n      add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n      JUMPHERE(jump[1]);\n      }\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else if (common->nltype == NLTYPE_FIXED)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_END, 0));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline));\n    }\n  else\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump[1] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2U(SLJIT_SUB | SLJIT_SET_Z | SLJIT_SET_GREATER, TMP2, 0, STR_END, 0);\n    jump[2] = JUMP(SLJIT_GREATER);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_EQUAL) /* LESS */);\n    /* Equal. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    jump[3] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\n    JUMPHERE(jump[1]);\n    if (common->nltype == NLTYPE_ANYCRLF)\n      {\n      OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, STR_END, 0));\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n      read_char(common, common->nlmin, common->nlmax, backtracks, READ_CHAR_UPDATE_STR_PTR);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0));\n      add_jump(compiler, &common->anynewline, JUMP(SLJIT_FAST_CALL));\n      sljit_set_current_flags(compiler, SLJIT_SET_Z);\n      add_jump(compiler, backtracks, JUMP(SLJIT_ZERO));\n      OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n      }\n    JUMPHERE(jump[2]);\n    JUMPHERE(jump[3]);\n    }\n  JUMPHERE(jump[0]);\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    check_partial(common, TRUE);\n  return cc;\n\n  case OP_EOD:\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0));\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    check_partial(common, TRUE);\n  return cc;\n\n  case OP_DOLL:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n    }\n  else\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n\n  if (!common->endonly)\n    compile_simple_assertion_matchingpath(common, OP_EODN, cc, backtracks);\n  else\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0));\n    check_partial(common, FALSE);\n    }\n  return cc;\n\n  case OP_DOLLM:\n  jump[1] = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n    }\n  else\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n  check_partial(common, FALSE);\n  jump[0] = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump[1]);\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER, TMP2, 0, STR_END, 0));\n    else\n      {\n      jump[1] = CMP(SLJIT_LESS_EQUAL, TMP2, 0, STR_END, 0);\n      /* STR_PTR = STR_END - IN_UCHARS(1) */\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n      check_partial(common, TRUE);\n      add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n      JUMPHERE(jump[1]);\n      }\n\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else\n    {\n    peek_char(common, common->nlmax, TMP3, 0, NULL);\n    check_newlinechar(common, common->nltype, backtracks, FALSE);\n    }\n  JUMPHERE(jump[0]);\n  return cc;\n\n  case OP_CIRC:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, begin));\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, TMP1, 0));\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, TMP1, 0));\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n    }\n  return cc;\n\n  case OP_CIRCM:\n  /* TMP2 might be used by peek_char_back. */\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    jump[1] = CMP(SLJIT_GREATER, STR_PTR, 0, TMP2, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n    jump[1] = CMP(SLJIT_GREATER, STR_PTR, 0, TMP2, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    }\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n  jump[0] = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump[1]);\n\n  if (!common->alt_circumflex)\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_SUB, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, TMP2, 0));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else\n    {\n    peek_char_back(common, common->nlmax, backtracks);\n    check_newlinechar(common, common->nltype, backtracks, FALSE);\n    }\n  JUMPHERE(jump[0]);\n  return cc;\n\n  case OP_REVERSE:\n  length = GET(cc, 0);\n  if (length == 0)\n    return cc + LINK_SIZE;\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    }\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, length);\n    label = LABEL();\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0));\n    move_back(common, backtracks, FALSE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP3, 0, TMP3, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  else\n#endif\n    {\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(length));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0));\n    }\n  check_start_used_ptr(common);\n  return cc + LINK_SIZE;\n  }\nSLJIT_UNREACHABLE();\nreturn cc;\n}\n\n#ifdef SUPPORT_UNICODE\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_utf(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR prevcc, endcc, bptr;\nBOOL first = TRUE;\nuint32_t c;\n\nprevcc = cc;\nendcc = NULL;\ndo\n  {\n  GETCHARINC(c, cc);\n  rgb = UCD_GRAPHBREAK(c);\n\n  if (first)\n    {\n    lgb = rgb;\n    endcc = cc;\n    first = FALSE;\n    continue;\n    }\n\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator)\n    {\n    ricount = 0;\n    bptr = prevcc;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      bptr--;\n      BACKCHAR(bptr);\n      GETCHAR(c, bptr);\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegional_Indicator)\n        break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0) break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  prevcc = endcc;\n  endcc = cc;\n  }\nwhile (cc < end_subject);\n\nreturn endcc;\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH != 32 */\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_utf_invalid(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR prevcc, endcc, bptr;\nBOOL first = TRUE;\nuint32_t c;\n\nprevcc = cc;\nendcc = NULL;\ndo\n  {\n  GETCHARINC_INVALID(c, cc, end_subject, break);\n  rgb = UCD_GRAPHBREAK(c);\n\n  if (first)\n    {\n    lgb = rgb;\n    endcc = cc;\n    first = FALSE;\n    continue;\n    }\n\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator)\n    {\n    ricount = 0;\n    bptr = prevcc;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      GETCHARBACK_INVALID(c, bptr, start_subject, break);\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegional_Indicator)\n        break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0)\n      break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  prevcc = endcc;\n  endcc = cc;\n  }\nwhile (cc < end_subject);\n\nreturn endcc;\n}\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_no_utf(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR bptr;\nuint32_t c;\n\n/* Patch by PH */\n/* GETCHARINC(c, cc); */\nc = *cc++;\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (c >= 0x110000)\n  return NULL;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\nlgb = UCD_GRAPHBREAK(c);\n\nwhile (cc < end_subject)\n  {\n  c = *cc;\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (c >= 0x110000)\n    break;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n  rgb = UCD_GRAPHBREAK(c);\n\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator)\n    {\n    ricount = 0;\n    bptr = cc - 1;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      bptr--;\n      c = *bptr;\n#if PCRE2_CODE_UNIT_WIDTH == 32\n      if (c >= 0x110000)\n        break;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegional_Indicator) break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0)\n      break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  cc++;\n  }\n\nreturn cc;\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic PCRE2_SPTR compile_char1_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks, BOOL check_str_ptr)\n{\nDEFINE_COMPILER;\nint length;\nunsigned int c, oc, bit;\ncompare_context context;\nstruct sljit_jump *jump[3];\njump_list *end_list;\n#ifdef SUPPORT_UNICODE\nPCRE2_UCHAR propdata[5];\n#endif /* SUPPORT_UNICODE */\n\nswitch(type)\n  {\n  case OP_NOT_DIGIT:\n  case OP_DIGIT:\n  /* Digits are usually 0-9, so it is worth to optimize them. */\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_digit, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_DIGIT);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_DIGIT);\n    /* Flip the starting bit in the negative case. */\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, ctype_digit);\n  add_jump(compiler, backtracks, JUMP(type == OP_DIGIT ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_NOT_WHITESPACE:\n  case OP_WHITESPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_space, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_WHITESPACE);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_WHITESPACE);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, ctype_space);\n  add_jump(compiler, backtracks, JUMP(type == OP_WHITESPACE ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_NOT_WORDCHAR:\n  case OP_WORDCHAR:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_word, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_WORDCHAR);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_WORDCHAR);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, ctype_word);\n  add_jump(compiler, backtracks, JUMP(type == OP_WORDCHAR ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_ANY:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  read_char(common, common->nlmin, common->nlmax, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    jump[0] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff);\n    end_list = NULL;\n    if (common->mode != PCRE2_JIT_PARTIAL_HARD)\n      add_jump(compiler, &end_list, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n    else\n      check_str_end(common, &end_list);\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline & 0xff));\n    set_jumps(end_list, LABEL());\n    JUMPHERE(jump[0]);\n    }\n  else\n    check_newlinechar(common, common->nltype, backtracks, TRUE);\n  return cc;\n\n  case OP_ALLANY:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    if (common->invalid_utf)\n      {\n      read_char(common, 0, READ_CHAR_MAX, backtracks, READ_CHAR_UPDATE_STR_PTR);\n      return cc;\n      }\n\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    jump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xfc00);\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n    JUMPHERE(jump[0]);\n    return cc;\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16] */\n    }\n#endif /* SUPPORT_UNICODE */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  return cc;\n\n  case OP_ANYBYTE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  return cc;\n\n#ifdef SUPPORT_UNICODE\n  case OP_NOTPROP:\n  case OP_PROP:\n  propdata[0] = XCL_HASPROP;\n  propdata[1] = type == OP_NOTPROP ? XCL_NOTPROP : XCL_PROP;\n  propdata[2] = cc[0];\n  propdata[3] = cc[1];\n  propdata[4] = XCL_END;\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  compile_xclass_matchingpath(common, propdata, backtracks);\n  return cc + 2;\n#endif\n\n  case OP_ANYNL:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  read_char(common, common->bsr_nlmin, common->bsr_nlmax, NULL, 0);\n  jump[0] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n  /* We don't need to handle soft partial matching case. */\n  end_list = NULL;\n  if (common->mode != PCRE2_JIT_PARTIAL_HARD)\n    add_jump(compiler, &end_list, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  else\n    check_str_end(common, &end_list);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  jump[1] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  jump[2] = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump[0]);\n  check_newlinechar(common, common->bsr_nltype, backtracks, FALSE);\n  set_jumps(end_list, LABEL());\n  JUMPHERE(jump[1]);\n  JUMPHERE(jump[2]);\n  return cc;\n\n  case OP_NOT_HSPACE:\n  case OP_HSPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_NOT_HSPACE)\n    read_char(common, 0x9, 0x3000, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0x9, 0x3000, NULL, 0);\n\n  add_jump(compiler, &common->hspace, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_HSPACE ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n  case OP_NOT_VSPACE:\n  case OP_VSPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_NOT_VSPACE)\n    read_char(common, 0xa, 0x2029, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0xa, 0x2029, NULL, 0);\n\n  add_jump(compiler, &common->vspace, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_VSPACE ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n#ifdef SUPPORT_UNICODE\n  case OP_EXTUNI:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  SLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n  OP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM,\n    common->utf ? (common->invalid_utf ? SLJIT_FUNC_ADDR(do_extuni_utf_invalid) : SLJIT_FUNC_ADDR(do_extuni_utf)) : SLJIT_FUNC_ADDR(do_extuni_no_utf));\n  if (common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n#else\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM,\n    common->invalid_utf ? SLJIT_FUNC_ADDR(do_extuni_utf_invalid) : SLJIT_FUNC_ADDR(do_extuni_no_utf));\n  if (!common->utf || common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n#endif\n\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_RETURN_REG, 0);\n\n  if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n    {\n    jump[0] = CMP(SLJIT_LESS, SLJIT_RETURN_REG, 0, STR_END, 0);\n    /* Since we successfully read a char above, partial matching must occure. */\n    check_partial(common, TRUE);\n    JUMPHERE(jump[0]);\n    }\n  return cc;\n#endif\n\n  case OP_CHAR:\n  case OP_CHARI:\n  length = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(*cc)) length += GET_EXTRALEN(*cc);\n#endif\n\n  if (check_str_ptr && common->mode != PCRE2_JIT_COMPLETE)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_CHAR || !char_has_othercase(common, cc) || char_get_othercase_bit(common, cc) != 0)\n    {\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(length));\n    if (length > 1 || (check_str_ptr && common->mode == PCRE2_JIT_COMPLETE))\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n    context.length = IN_UCHARS(length);\n    context.sourcereg = -1;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n    context.ucharptr = 0;\n#endif\n    return byte_sequence_compare(common, type == OP_CHARI, cc, &context, backtracks);\n    }\n\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n#endif\n    c = *cc;\n\n  SLJIT_ASSERT(type == OP_CHARI && char_has_othercase(common, cc));\n\n  if (check_str_ptr && common->mode == PCRE2_JIT_COMPLETE)\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  oc = char_othercase(common, c);\n  read_char(common, c < oc ? c : oc, c > oc ? c : oc, NULL, 0);\n\n  SLJIT_ASSERT(!is_powerof2(c ^ oc));\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n    {\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, oc);\n    CMOV(SLJIT_EQUAL, TMP1, SLJIT_IMM, c);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n    }\n  else\n    {\n    jump[0] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, oc));\n    JUMPHERE(jump[0]);\n    }\n  return cc + length;\n\n  case OP_NOT:\n  case OP_NOTI:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  length = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    c = *cc;\n    if (c < 128 && !common->invalid_utf)\n      {\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n      if (type == OP_NOT || !char_has_othercase(common, cc))\n        add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n      else\n        {\n        /* Since UTF8 code page is fixed, we know that c is in [a-z] or [A-Z] range. */\n        OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x20);\n        add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, c | 0x20));\n        }\n      /* Skip the variable-length character. */\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      jump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n      OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n      JUMPHERE(jump[0]);\n      return cc + 1;\n      }\n    else\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      {\n      GETCHARLEN(c, cc, length);\n      }\n    }\n  else\n#endif /* SUPPORT_UNICODE */\n    c = *cc;\n\n  if (type == OP_NOT || !char_has_othercase(common, cc))\n    {\n    read_char(common, c, c, backtracks, READ_CHAR_UPDATE_STR_PTR);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n    }\n  else\n    {\n    oc = char_othercase(common, c);\n    read_char(common, c < oc ? c : oc, c > oc ? c : oc, backtracks, READ_CHAR_UPDATE_STR_PTR);\n    bit = c ^ oc;\n    if (is_powerof2(bit))\n      {\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, bit);\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c | bit));\n      }\n    else\n      {\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, oc));\n      }\n    }\n  return cc + length;\n\n  case OP_CLASS:\n  case OP_NCLASS:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  bit = (common->utf && is_char7_bitset((const sljit_u8 *)cc, type == OP_NCLASS)) ? 127 : 255;\n  if (type == OP_NCLASS)\n    read_char(common, 0, bit, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0, bit, NULL, 0);\n#else\n  if (type == OP_NCLASS)\n    read_char(common, 0, 255, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0, 255, NULL, 0);\n#endif\n\n  if (optimize_class(common, (const sljit_u8 *)cc, type == OP_NCLASS, FALSE, backtracks))\n    return cc + 32 / sizeof(PCRE2_UCHAR);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  jump[0] = NULL;\n  if (common->utf)\n    {\n    jump[0] = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, bit);\n    if (type == OP_CLASS)\n      {\n      add_jump(compiler, backtracks, jump[0]);\n      jump[0] = NULL;\n      }\n    }\n#elif PCRE2_CODE_UNIT_WIDTH != 8\n  jump[0] = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n  if (type == OP_CLASS)\n    {\n    add_jump(compiler, backtracks, jump[0]);\n    jump[0] = NULL;\n    }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\n  OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n  OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n  add_jump(compiler, backtracks, JUMP(SLJIT_ZERO));\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n  if (jump[0] != NULL)\n    JUMPHERE(jump[0]);\n#endif\n  return cc + 32 / sizeof(PCRE2_UCHAR);\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  case OP_XCLASS:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  compile_xclass_matchingpath(common, cc + LINK_SIZE, backtracks);\n  return cc + GET(cc, 0) - 1;\n#endif\n  }\nSLJIT_UNREACHABLE();\nreturn cc;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_charn_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, jump_list **backtracks)\n{\n/* This function consumes at least one input character. */\n/* To decrease the number of length checks, we try to concatenate the fixed length character sequences. */\nDEFINE_COMPILER;\nPCRE2_SPTR ccbegin = cc;\ncompare_context context;\nint size;\n\ncontext.length = 0;\ndo\n  {\n  if (cc >= ccend)\n    break;\n\n  if (*cc == OP_CHAR)\n    {\n    size = 1;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[1]))\n      size += GET_EXTRALEN(cc[1]);\n#endif\n    }\n  else if (*cc == OP_CHARI)\n    {\n    size = 1;\n#ifdef SUPPORT_UNICODE\n    if (common->utf)\n      {\n      if (char_has_othercase(common, cc + 1) && char_get_othercase_bit(common, cc + 1) == 0)\n        size = 0;\n      else if (HAS_EXTRALEN(cc[1]))\n        size += GET_EXTRALEN(cc[1]);\n      }\n    else\n#endif\n    if (char_has_othercase(common, cc + 1) && char_get_othercase_bit(common, cc + 1) == 0)\n      size = 0;\n    }\n  else\n    size = 0;\n\n  cc += 1 + size;\n  context.length += IN_UCHARS(size);\n  }\nwhile (size > 0 && context.length <= 128);\n\ncc = ccbegin;\nif (context.length > 0)\n  {\n  /* We have a fixed-length byte sequence. */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, context.length);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n  context.sourcereg = -1;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  context.ucharptr = 0;\n#endif\n  do cc = byte_sequence_compare(common, *cc == OP_CHARI, cc + 1, &context, backtracks); while (context.length > 0);\n  return cc;\n  }\n\n/* A non-fixed length character will be checked if length == 0. */\nreturn compile_char1_matchingpath(common, *cc, cc + 1, backtracks, TRUE);\n}\n\n/* Forward definitions. */\nstatic void compile_matchingpath(compiler_common *, PCRE2_SPTR, PCRE2_SPTR, backtrack_common *);\nstatic void compile_backtrackingpath(compiler_common *, struct backtrack_common *);\n\n#define PUSH_BACKTRACK(size, ccstart, error) \\\n  do \\\n    { \\\n    backtrack = sljit_alloc_memory(compiler, (size)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return error; \\\n    memset(backtrack, 0, size); \\\n    backtrack->prev = parent->top; \\\n    backtrack->cc = (ccstart); \\\n    parent->top = backtrack; \\\n    } \\\n  while (0)\n\n#define PUSH_BACKTRACK_NOVALUE(size, ccstart) \\\n  do \\\n    { \\\n    backtrack = sljit_alloc_memory(compiler, (size)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return; \\\n    memset(backtrack, 0, size); \\\n    backtrack->prev = parent->top; \\\n    backtrack->cc = (ccstart); \\\n    parent->top = backtrack; \\\n    } \\\n  while (0)\n\n#define BACKTRACK_AS(type) ((type *)backtrack)\n\nstatic void compile_dnref_search(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\n/* The OVECTOR offset goes to TMP2. */\nDEFINE_COMPILER;\nint count = GET2(cc, 1 + IMM2_SIZE);\nPCRE2_SPTR slot = common->name_table + GET2(cc, 1) * common->name_entry_size;\nunsigned int offset;\njump_list *found = NULL;\n\nSLJIT_ASSERT(*cc == OP_DNREF || *cc == OP_DNREFI);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\n\ncount--;\nwhile (count-- > 0)\n  {\n  offset = GET2(slot, 0) << 1;\n  GET_LOCAL_BASE(TMP2, 0, OVECTOR(offset));\n  add_jump(compiler, &found, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0));\n  slot += common->name_entry_size;\n  }\n\noffset = GET2(slot, 0) << 1;\nGET_LOCAL_BASE(TMP2, 0, OVECTOR(offset));\nif (backtracks != NULL && !common->unset_backref)\n  add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0));\n\nset_jumps(found, LABEL());\n}\n\nstatic void compile_ref_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks, BOOL withchecks, BOOL emptyfail)\n{\nDEFINE_COMPILER;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nint offset = 0;\nstruct sljit_jump *jump = NULL;\nstruct sljit_jump *partial;\nstruct sljit_jump *nopartial;\n#if defined SUPPORT_UNICODE\nstruct sljit_label *loop;\nstruct sljit_label *caseless_loop;\njump_list *no_match = NULL;\nint source_reg = COUNT_MATCH;\nint source_end_reg = ARGUMENTS;\nint char1_reg = STACK_LIMIT;\n#endif /* SUPPORT_UNICODE */\n\nif (ref)\n  {\n  offset = GET2(cc, 1) << 1;\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n  /* OVECTOR(1) contains the \"string begin - 1\" constant. */\n  if (withchecks && !common->unset_backref)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n  }\nelse\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n\n#if defined SUPPORT_UNICODE\nif (common->utf && *cc == OP_REFI)\n  {\n  SLJIT_ASSERT(common->iref_ptr != 0);\n\n  if (ref)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n\n  if (withchecks && emptyfail)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, TMP2, 0));\n\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr, source_reg, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw), source_end_reg, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2, char1_reg, 0);\n\n  OP1(SLJIT_MOV, source_reg, 0, TMP1, 0);\n  OP1(SLJIT_MOV, source_end_reg, 0, TMP2, 0);\n\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, source_reg, 0, source_end_reg, 0);\n  partial = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\n  /* Read original character. It must be a valid UTF character. */\n  OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, STR_PTR, 0, source_reg, 0);\n\n  read_char(common, 0, READ_CHAR_MAX, NULL, READ_CHAR_UPDATE_STR_PTR | READ_CHAR_VALID_UTF);\n\n  OP1(SLJIT_MOV, source_reg, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n  OP1(SLJIT_MOV, char1_reg, 0, TMP1, 0);\n\n  /* Read second character. */\n  read_char(common, 0, READ_CHAR_MAX, &no_match, READ_CHAR_UPDATE_STR_PTR);\n\n  CMPTO(SLJIT_EQUAL, TMP1, 0, char1_reg, 0, loop);\n\n  OP1(SLJIT_MOV, TMP3, 0, TMP1, 0);\n\n  add_jump(compiler, &common->getucd, JUMP(SLJIT_FAST_CALL));\n\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_records));\n\n  OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(ucd_record, other_case));\n  OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(ucd_record, caseset));\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP3, 0);\n  CMPTO(SLJIT_EQUAL, TMP1, 0, char1_reg, 0, loop);\n\n  add_jump(compiler, &no_match, CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_caseless_sets));\n\n  caseless_loop = LABEL();\n  OP1(SLJIT_MOV_U32, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, sizeof(uint32_t));\n  OP2U(SLJIT_SUB | SLJIT_SET_Z | SLJIT_SET_LESS, TMP1, 0, char1_reg, 0);\n  JUMPTO(SLJIT_EQUAL, loop);\n  JUMPTO(SLJIT_LESS, caseless_loop);\n\n  set_jumps(no_match, LABEL());\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    JUMPHERE(partial);\n\n  OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n  OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n  OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    JUMPHERE(partial);\n    OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n    OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n\n    check_partial(common, FALSE);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    }\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n  OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n  OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n  return;\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n  if (ref)\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP1, 0);\n  else\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw), TMP1, 0);\n\n  if (withchecks)\n    jump = JUMP(SLJIT_ZERO);\n\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n  partial = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    add_jump(compiler, backtracks, partial);\n\n  add_jump(compiler, *cc == OP_REF ? &common->casefulcmp : &common->caselesscmp, JUMP(SLJIT_FAST_CALL));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    nopartial = JUMP(SLJIT_JUMP);\n    JUMPHERE(partial);\n    /* TMP2 -= STR_END - STR_PTR */\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, STR_PTR, 0);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, STR_END, 0);\n    partial = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n    add_jump(compiler, *cc == OP_REF ? &common->casefulcmp : &common->caselesscmp, JUMP(SLJIT_FAST_CALL));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n    JUMPHERE(partial);\n    check_partial(common, FALSE);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(nopartial);\n    }\n  }\n\nif (jump != NULL)\n  {\n  if (emptyfail)\n    add_jump(compiler, backtracks, jump);\n  else\n    JUMPHERE(jump);\n  }\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_ref_iterator_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nbacktrack_common *backtrack;\nPCRE2_UCHAR type;\nint offset = 0;\nstruct sljit_label *label;\nstruct sljit_jump *zerolength;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin = cc;\nint min = 0, max = 0;\nBOOL minimize;\n\nPUSH_BACKTRACK(sizeof(ref_iterator_backtrack), cc, NULL);\n\nif (ref)\n  offset = GET2(cc, 1) << 1;\nelse\n  cc += IMM2_SIZE;\ntype = cc[1 + IMM2_SIZE];\n\nSLJIT_COMPILE_ASSERT((OP_CRSTAR & 0x1) == 0, crstar_opcode_must_be_even);\nminimize = (type & 0x1) != 0;\nswitch(type)\n  {\n  case OP_CRSTAR:\n  case OP_CRMINSTAR:\n  min = 0;\n  max = 0;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRPLUS:\n  case OP_CRMINPLUS:\n  min = 1;\n  max = 0;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  min = 0;\n  max = 1;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  min = GET2(cc, 1 + IMM2_SIZE + 1);\n  max = GET2(cc, 1 + IMM2_SIZE + 1 + IMM2_SIZE);\n  cc += 1 + IMM2_SIZE + 1 + 2 * IMM2_SIZE;\n  break;\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nif (!minimize)\n  {\n  if (min == 0)\n    {\n    allocate_stack(common, 2);\n    if (ref)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n    /* Temporary release of STR_PTR. */\n    OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n    /* Handles both invalid and empty cases. Since the minimum repeat,\n    is zero the invalid case is basically the same as an empty case. */\n    if (ref)\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    else\n      {\n      compile_dnref_search(common, ccbegin, NULL);\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, TMP2, 0);\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n      }\n    /* Restore if not zero length. */\n    OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n    }\n  else\n    {\n    allocate_stack(common, 1);\n    if (ref)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    if (ref)\n      {\n      add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n      }\n    else\n      {\n      compile_dnref_search(common, ccbegin, &backtrack->topbacktracks);\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, TMP2, 0);\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n      }\n    }\n\n  if (min > 1 || max > 1)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, SLJIT_IMM, 0);\n\n  label = LABEL();\n  if (!ref)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1);\n  compile_ref_matchingpath(common, ccbegin, &backtrack->topbacktracks, FALSE, FALSE);\n\n  if (min > 1 || max > 1)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, TMP1, 0);\n    if (min > 1)\n      CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, min, label);\n    if (max > 1)\n      {\n      jump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, max);\n      allocate_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, label);\n      JUMPHERE(jump);\n      }\n    }\n\n  if (max == 0)\n    {\n    /* Includes min > 1 case as well. */\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    JUMPTO(SLJIT_JUMP, label);\n    }\n\n  JUMPHERE(zerolength);\n  BACKTRACK_AS(ref_iterator_backtrack)->matchingpath = LABEL();\n\n  count_match(common);\n  return cc;\n  }\n\nallocate_stack(common, ref ? 2 : 3);\nif (ref)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\nif (type != OP_CRMINSTAR)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n\nif (min == 0)\n  {\n  /* Handles both invalid and empty cases. Since the minimum repeat,\n  is zero the invalid case is basically the same as an empty case. */\n  if (ref)\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  else\n    {\n    compile_dnref_search(common, ccbegin, NULL);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0);\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    }\n  /* Length is non-zero, we can match real repeats. */\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  jump = JUMP(SLJIT_JUMP);\n  }\nelse\n  {\n  if (ref)\n    {\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    }\n  else\n    {\n    compile_dnref_search(common, ccbegin, &backtrack->topbacktracks);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0);\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    }\n  }\n\nBACKTRACK_AS(ref_iterator_backtrack)->matchingpath = LABEL();\nif (max > 0)\n  add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, max));\n\nif (!ref)\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\ncompile_ref_matchingpath(common, ccbegin, &backtrack->topbacktracks, TRUE, TRUE);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\nif (min > 1)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, min, BACKTRACK_AS(ref_iterator_backtrack)->matchingpath);\n  }\nelse if (max > 0)\n  OP2(SLJIT_ADD, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 1);\n\nif (jump != NULL)\n  JUMPHERE(jump);\nJUMPHERE(zerolength);\n\ncount_match(common);\nreturn cc;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_recurse_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nrecurse_entry *entry = common->entries;\nrecurse_entry *prev = NULL;\nsljit_sw start = GET(cc, 1);\nPCRE2_SPTR start_cc;\nBOOL needs_control_head;\n\nPUSH_BACKTRACK(sizeof(recurse_backtrack), cc, NULL);\n\n/* Inlining simple patterns. */\nif (get_framesize(common, common->start + start, NULL, TRUE, &needs_control_head) == no_stack)\n  {\n  start_cc = common->start + start;\n  compile_matchingpath(common, next_opcode(common, start_cc), bracketend(start_cc) - (1 + LINK_SIZE), backtrack);\n  BACKTRACK_AS(recurse_backtrack)->inlined_pattern = TRUE;\n  return cc + 1 + LINK_SIZE;\n  }\n\nwhile (entry != NULL)\n  {\n  if (entry->start == start)\n    break;\n  prev = entry;\n  entry = entry->next;\n  }\n\nif (entry == NULL)\n  {\n  entry = sljit_alloc_memory(compiler, sizeof(recurse_entry));\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n  entry->next = NULL;\n  entry->entry_label = NULL;\n  entry->backtrack_label = NULL;\n  entry->entry_calls = NULL;\n  entry->backtrack_calls = NULL;\n  entry->start = start;\n\n  if (prev != NULL)\n    prev->next = entry;\n  else\n    common->entries = entry;\n  }\n\nBACKTRACK_AS(recurse_backtrack)->entry = entry;\n\nif (entry->entry_label == NULL)\n  add_jump(compiler, &entry->entry_calls, JUMP(SLJIT_FAST_CALL));\nelse\n  JUMPTO(SLJIT_FAST_CALL, entry->entry_label);\n/* Leave if the match is failed. */\nadd_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\nBACKTRACK_AS(recurse_backtrack)->matchingpath = LABEL();\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic sljit_s32 SLJIT_FUNC do_callout(struct jit_arguments *arguments, pcre2_callout_block *callout_block, PCRE2_SPTR *jit_ovector)\n{\nPCRE2_SPTR begin;\nPCRE2_SIZE *ovector;\nsljit_u32 oveccount, capture_top;\n\nif (arguments->callout == NULL)\n  return 0;\n\nSLJIT_COMPILE_ASSERT(sizeof (PCRE2_SIZE) <= sizeof (sljit_sw), pcre2_size_must_be_lower_than_sljit_sw_size);\n\nbegin = arguments->begin;\novector = (PCRE2_SIZE*)(callout_block + 1);\noveccount = callout_block->capture_top;\n\nSLJIT_ASSERT(oveccount >= 1);\n\ncallout_block->version = 2;\ncallout_block->callout_flags = 0;\n\n/* Offsets in subject. */\ncallout_block->subject_length = arguments->end - arguments->begin;\ncallout_block->start_match = jit_ovector[0] - begin;\ncallout_block->current_position = (PCRE2_SPTR)callout_block->offset_vector - begin;\ncallout_block->subject = begin;\n\n/* Convert and copy the JIT offset vector to the ovector array. */\ncallout_block->capture_top = 1;\ncallout_block->offset_vector = ovector;\n\novector[0] = PCRE2_UNSET;\novector[1] = PCRE2_UNSET;\novector += 2;\njit_ovector += 2;\ncapture_top = 1;\n\n/* Convert pointers to sizes. */\nwhile (--oveccount != 0)\n  {\n  capture_top++;\n\n  ovector[0] = (PCRE2_SIZE)(jit_ovector[0] - begin);\n  ovector[1] = (PCRE2_SIZE)(jit_ovector[1] - begin);\n\n  if (ovector[0] != PCRE2_UNSET)\n    callout_block->capture_top = capture_top;\n\n  ovector += 2;\n  jit_ovector += 2;\n  }\n\nreturn (arguments->callout)(callout_block, arguments->callout_data);\n}\n\n#define CALLOUT_ARG_OFFSET(arg) \\\n    SLJIT_OFFSETOF(pcre2_callout_block, arg)\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_callout_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nsljit_s32 mov_opcode;\nunsigned int callout_length = (*cc == OP_CALLOUT)\n    ? PRIV(OP_lengths)[OP_CALLOUT] : GET(cc, 1 + 2 * LINK_SIZE);\nsljit_sw value1;\nsljit_sw value2;\nsljit_sw value3;\nsljit_uw callout_arg_size = (common->re->top_bracket + 1) * 2 * sizeof(sljit_sw);\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\ncallout_arg_size = (sizeof(pcre2_callout_block) + callout_arg_size + sizeof(sljit_sw) - 1) / sizeof(sljit_sw);\n\nallocate_stack(common, callout_arg_size);\n\nSLJIT_ASSERT(common->capture_last_ptr != 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\nOP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\nvalue1 = (*cc == OP_CALLOUT) ? cc[1 + 2 * LINK_SIZE] : 0;\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_number), SLJIT_IMM, value1);\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(capture_last), TMP2, 0);\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(capture_top), SLJIT_IMM, common->re->top_bracket + 1);\n\n/* These pointer sized fields temporarly stores internal variables. */\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(offset_vector), STR_PTR, 0);\n\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, mark_ptr));\nmov_opcode = (sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV;\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(pattern_position), SLJIT_IMM, GET(cc, 1));\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(next_item_length), SLJIT_IMM, GET(cc, 1 + LINK_SIZE));\n\nif (*cc == OP_CALLOUT)\n  {\n  value1 = 0;\n  value2 = 0;\n  value3 = 0;\n  }\nelse\n  {\n  value1 = (sljit_sw) (cc + (1 + 4*LINK_SIZE) + 1);\n  value2 = (callout_length - (1 + 4*LINK_SIZE + 2));\n  value3 = (sljit_sw) (GET(cc, 1 + 3*LINK_SIZE));\n  }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string), SLJIT_IMM, value1);\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string_length), SLJIT_IMM, value2);\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string_offset), SLJIT_IMM, value3);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(mark), (common->mark_ptr != 0) ? TMP2 : SLJIT_IMM, 0);\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\n/* Needed to save important temporary registers. */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, STR_PTR, 0);\n/* SLJIT_R0 = arguments */\nOP1(SLJIT_MOV, SLJIT_R1, 0, STACK_TOP, 0);\nGET_LOCAL_BASE(SLJIT_R2, 0, OVECTOR_START);\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS3(32, W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_callout));\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nfree_stack(common, callout_arg_size);\n\n/* Check return value. */\nOP2U(SLJIT_SUB32 | SLJIT_SET_Z | SLJIT_SET_SIG_GREATER, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_SIG_GREATER));\nif (common->abort_label == NULL)\n  add_jump(compiler, &common->abort, JUMP(SLJIT_NOT_EQUAL) /* SIG_LESS */);\nelse\n  JUMPTO(SLJIT_NOT_EQUAL /* SIG_LESS */, common->abort_label);\nreturn cc + callout_length;\n}\n\n#undef CALLOUT_ARG_SIZE\n#undef CALLOUT_ARG_OFFSET\n\nstatic SLJIT_INLINE BOOL assert_needs_str_ptr_saving(PCRE2_SPTR cc)\n{\nwhile (TRUE)\n  {\n  switch (*cc)\n    {\n    case OP_CALLOUT_STR:\n    cc += GET(cc, 1 + 2*LINK_SIZE);\n    break;\n\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CALLOUT:\n    case OP_ALT:\n    cc += PRIV(OP_lengths)[*cc];\n    break;\n\n    case OP_KET:\n    return FALSE;\n\n    default:\n    return TRUE;\n    }\n  }\n}\n\nstatic PCRE2_SPTR compile_assert_matchingpath(compiler_common *common, PCRE2_SPTR cc, assert_backtrack *backtrack, BOOL conditional)\n{\nDEFINE_COMPILER;\nint framesize;\nint extrasize;\nBOOL local_quit_available = FALSE;\nBOOL needs_control_head;\nint private_data_ptr;\nbacktrack_common altbacktrack;\nPCRE2_SPTR ccbegin;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR bra = OP_BRA;\njump_list *tmp = NULL;\njump_list **target = (conditional) ? &backtrack->condfailed : &backtrack->common.topbacktracks;\njump_list **found;\n/* Saving previous accept variables. */\nBOOL save_local_quit_available = common->local_quit_available;\nBOOL save_in_positive_assertion = common->in_positive_assertion;\nthen_trap_backtrack *save_then_trap = common->then_trap;\nstruct sljit_label *save_quit_label = common->quit_label;\nstruct sljit_label *save_accept_label = common->accept_label;\njump_list *save_quit = common->quit;\njump_list *save_positive_assertion_quit = common->positive_assertion_quit;\njump_list *save_accept = common->accept;\nstruct sljit_jump *jump;\nstruct sljit_jump *brajump = NULL;\n\n/* Assert captures then. */\ncommon->then_trap = NULL;\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  SLJIT_ASSERT(!conditional);\n  bra = *cc;\n  cc++;\n  }\nprivate_data_ptr = PRIVATE_DATA(cc);\nSLJIT_ASSERT(private_data_ptr != 0);\nframesize = get_framesize(common, cc, NULL, FALSE, &needs_control_head);\nbacktrack->framesize = framesize;\nbacktrack->private_data_ptr = private_data_ptr;\nopcode = *cc;\nSLJIT_ASSERT(opcode >= OP_ASSERT && opcode <= OP_ASSERTBACK_NOT);\nfound = (opcode == OP_ASSERT || opcode == OP_ASSERTBACK) ? &tmp : target;\nccbegin = cc;\ncc += GET(cc, 1);\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a braminzero backtrack path. */\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  brajump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  }\n\nif (framesize < 0)\n  {\n  extrasize = 1;\n  if (bra == OP_BRA && !assert_needs_str_ptr_saving(ccbegin + 1 + LINK_SIZE))\n    extrasize = 0;\n\n  if (needs_control_head)\n    extrasize++;\n\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n\n  if (extrasize > 0)\n    allocate_stack(common, extrasize);\n\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n\n  if (extrasize > 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\n  if (needs_control_head)\n    {\n    SLJIT_ASSERT(extrasize == 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n    }\n  }\nelse\n  {\n  extrasize = needs_control_head ? 3 : 2;\n  allocate_stack(common, framesize + extrasize);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  OP2(SLJIT_ADD, TMP2, 0, STACK_TOP, 0, SLJIT_IMM, (framesize + extrasize) * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n    }\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n\n  init_frame(common, ccbegin, NULL, framesize + extrasize - 1, extrasize);\n  }\n\nmemset(&altbacktrack, 0, sizeof(backtrack_common));\nif (conditional || (opcode == OP_ASSERT_NOT || opcode == OP_ASSERTBACK_NOT))\n  {\n  /* Control verbs cannot escape from these asserts. */\n  local_quit_available = TRUE;\n  common->local_quit_available = TRUE;\n  common->quit_label = NULL;\n  common->quit = NULL;\n  }\n\ncommon->in_positive_assertion = (opcode == OP_ASSERT || opcode == OP_ASSERTBACK);\ncommon->positive_assertion_quit = NULL;\n\nwhile (1)\n  {\n  common->accept_label = NULL;\n  common->accept = NULL;\n  altbacktrack.top = NULL;\n  altbacktrack.topbacktracks = NULL;\n\n  if (*ccbegin == OP_ALT && extrasize > 0)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  altbacktrack.cc = ccbegin;\n  compile_matchingpath(common, ccbegin + 1 + LINK_SIZE, cc, &altbacktrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    if (local_quit_available)\n      {\n      common->local_quit_available = save_local_quit_available;\n      common->quit_label = save_quit_label;\n      common->quit = save_quit;\n      }\n    common->in_positive_assertion = save_in_positive_assertion;\n    common->then_trap = save_then_trap;\n    common->accept_label = save_accept_label;\n    common->positive_assertion_quit = save_positive_assertion_quit;\n    common->accept = save_accept;\n    return NULL;\n    }\n  common->accept_label = LABEL();\n  if (common->accept != NULL)\n    set_jumps(common->accept, common->accept_label);\n\n  /* Reset stack. */\n  if (framesize < 0)\n    {\n    if (framesize == no_frame)\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n    }\n  else\n    {\n    if ((opcode != OP_ASSERT_NOT && opcode != OP_ASSERTBACK_NOT) || conditional)\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 1) * sizeof(sljit_sw));\n      if (needs_control_head)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      if (needs_control_head)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 2));\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (framesize - 1) * sizeof(sljit_sw));\n      }\n    }\n\n  if (opcode == OP_ASSERT_NOT || opcode == OP_ASSERTBACK_NOT)\n    {\n    /* We know that STR_PTR was stored on the top of the stack. */\n    if (conditional)\n      {\n      if (extrasize > 0)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), needs_control_head ? STACK(-2) : STACK(-1));\n      }\n    else if (bra == OP_BRAZERO)\n      {\n      if (framesize < 0)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize));\n      else\n        {\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 1));\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-framesize - extrasize));\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n        }\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (framesize >= 0)\n      {\n      /* For OP_BRA and OP_BRAMINZERO. */\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 1));\n      }\n    }\n  add_jump(compiler, found, JUMP(SLJIT_JUMP));\n\n  compile_backtrackingpath(common, altbacktrack.top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    if (local_quit_available)\n      {\n      common->local_quit_available = save_local_quit_available;\n      common->quit_label = save_quit_label;\n      common->quit = save_quit;\n      }\n    common->in_positive_assertion = save_in_positive_assertion;\n    common->then_trap = save_then_trap;\n    common->accept_label = save_accept_label;\n    common->positive_assertion_quit = save_positive_assertion_quit;\n    common->accept = save_accept;\n    return NULL;\n    }\n  set_jumps(altbacktrack.topbacktracks, LABEL());\n\n  if (*cc != OP_ALT)\n    break;\n\n  ccbegin = cc;\n  cc += GET(cc, 1);\n  }\n\nif (local_quit_available)\n  {\n  SLJIT_ASSERT(common->positive_assertion_quit == NULL);\n  /* Makes the check less complicated below. */\n  common->positive_assertion_quit = common->quit;\n  }\n\n/* None of them matched. */\nif (common->positive_assertion_quit != NULL)\n  {\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(common->positive_assertion_quit, LABEL());\n  SLJIT_ASSERT(framesize != no_stack);\n  if (framesize < 0)\n    OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, extrasize * sizeof(sljit_sw));\n  else\n    {\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n    OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (extrasize + 1) * sizeof(sljit_sw));\n    }\n  JUMPHERE(jump);\n  }\n\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(1));\n\nif (opcode == OP_ASSERT || opcode == OP_ASSERTBACK)\n  {\n  /* Assert is failed. */\n  if ((conditional && extrasize > 0) || bra == OP_BRAZERO)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  if (framesize < 0)\n    {\n    /* The topmost item should be 0. */\n    if (bra == OP_BRAZERO)\n      {\n      if (extrasize == 2)\n        free_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(extrasize - 1));\n    /* The topmost item should be 0. */\n    if (bra == OP_BRAZERO)\n      {\n      free_stack(common, framesize + extrasize - 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, framesize + extrasize);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  jump = JUMP(SLJIT_JUMP);\n  if (bra != OP_BRAZERO)\n    add_jump(compiler, target, jump);\n\n  /* Assert is successful. */\n  set_jumps(tmp, LABEL());\n  if (framesize < 0)\n    {\n    /* We know that STR_PTR was stored on the top of the stack. */\n    if (extrasize > 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize));\n\n    /* Keep the STR_PTR on the top of the stack. */\n    if (bra == OP_BRAZERO)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      if (extrasize == 2)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n    else if (bra == OP_BRAMINZERO)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    }\n  else\n    {\n    if (bra == OP_BRA)\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize + 1));\n      }\n    else\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 2) * sizeof(sljit_sw));\n      if (extrasize == 2)\n        {\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n        if (bra == OP_BRAMINZERO)\n          OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n        }\n      else\n        {\n        SLJIT_ASSERT(extrasize == 3);\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), bra == OP_BRAZERO ? STR_PTR : SLJIT_IMM, 0);\n        }\n      }\n    }\n\n  if (bra == OP_BRAZERO)\n    {\n    backtrack->matchingpath = LABEL();\n    SET_LABEL(jump, backtrack->matchingpath);\n    }\n  else if (bra == OP_BRAMINZERO)\n    {\n    JUMPTO(SLJIT_JUMP, backtrack->matchingpath);\n    JUMPHERE(brajump);\n    if (framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n      }\n    set_jumps(backtrack->common.topbacktracks, LABEL());\n    }\n  }\nelse\n  {\n  /* AssertNot is successful. */\n  if (framesize < 0)\n    {\n    if (extrasize > 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n    if (bra != OP_BRA)\n      {\n      if (extrasize == 2)\n        free_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(extrasize - 1));\n    /* The topmost item should be 0. */\n    if (bra != OP_BRA)\n      {\n      free_stack(common, framesize + extrasize - 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, framesize + extrasize);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n\n  if (bra == OP_BRAZERO)\n    backtrack->matchingpath = LABEL();\n  else if (bra == OP_BRAMINZERO)\n    {\n    JUMPTO(SLJIT_JUMP, backtrack->matchingpath);\n    JUMPHERE(brajump);\n    }\n\n  if (bra != OP_BRA)\n    {\n    SLJIT_ASSERT(found == &backtrack->common.topbacktracks);\n    set_jumps(backtrack->common.topbacktracks, LABEL());\n    backtrack->common.topbacktracks = NULL;\n    }\n  }\n\nif (local_quit_available)\n  {\n  common->local_quit_available = save_local_quit_available;\n  common->quit_label = save_quit_label;\n  common->quit = save_quit;\n  }\ncommon->in_positive_assertion = save_in_positive_assertion;\ncommon->then_trap = save_then_trap;\ncommon->accept_label = save_accept_label;\ncommon->positive_assertion_quit = save_positive_assertion_quit;\ncommon->accept = save_accept;\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic SLJIT_INLINE void match_once_common(compiler_common *common, PCRE2_UCHAR ket, int framesize, int private_data_ptr, BOOL has_alternatives, BOOL needs_control_head)\n{\nDEFINE_COMPILER;\nint stacksize;\n\nif (framesize < 0)\n  {\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  else\n    {\n    stacksize = needs_control_head ? 1 : 0;\n    if (ket != OP_KET || has_alternatives)\n      stacksize++;\n\n    if (stacksize > 0)\n      free_stack(common, stacksize);\n    }\n\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), (ket != OP_KET || has_alternatives) ? STACK(-2) : STACK(-1));\n\n  /* TMP2 which is set here used by OP_KETRMAX below. */\n  if (ket == OP_KETRMAX)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n  else if (ket == OP_KETRMIN)\n    {\n    /* Move the STR_PTR to the private_data_ptr. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n    }\n  }\nelse\n  {\n  stacksize = (ket != OP_KET || has_alternatives) ? 2 : 1;\n  OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + stacksize) * sizeof(sljit_sw));\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n\n  if (ket == OP_KETRMAX)\n    {\n    /* TMP2 which is set here used by OP_KETRMAX below. */\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    }\n  }\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP1, 0);\n}\n\nstatic SLJIT_INLINE int match_capture_common(compiler_common *common, int stacksize, int offset, int private_data_ptr)\n{\nDEFINE_COMPILER;\n\nif (common->capture_last_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n  stacksize++;\n  }\nif (common->optimized_cbracket[offset >> 1] == 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize + 1), TMP2, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n  stacksize += 2;\n  }\nreturn stacksize;\n}\n\nstatic PCRE2_SPTR SLJIT_FUNC do_script_run(PCRE2_SPTR ptr, PCRE2_SPTR endptr)\n{\n  if (PRIV(script_run)(ptr, endptr, FALSE))\n    return endptr;\n  return NULL;\n}\n\n#ifdef SUPPORT_UNICODE\n\nstatic PCRE2_SPTR SLJIT_FUNC do_script_run_utf(PCRE2_SPTR ptr, PCRE2_SPTR endptr)\n{\n  if (PRIV(script_run)(ptr, endptr, TRUE))\n    return endptr;\n  return NULL;\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic SLJIT_INLINE void match_script_run_common(compiler_common *common, int private_data_ptr, backtrack_common *parent)\n{\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n#ifdef SUPPORT_UNICODE\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM,\n  common->utf ? SLJIT_FUNC_ADDR(do_script_run_utf) : SLJIT_FUNC_ADDR(do_script_run));\n#else\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_script_run));\n#endif\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_RETURN_REG, 0);\nadd_jump(compiler, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n}\n\n/*\n  Handling bracketed expressions is probably the most complex part.\n\n  Stack layout naming characters:\n    S - Push the current STR_PTR\n    0 - Push a 0 (NULL)\n    A - Push the current STR_PTR. Needed for restoring the STR_PTR\n        before the next alternative. Not pushed if there are no alternatives.\n    M - Any values pushed by the current alternative. Can be empty, or anything.\n    C - Push the previous OVECTOR(i), OVECTOR(i+1) and OVECTOR_PRIV(i) to the stack.\n    L - Push the previous local (pointed by localptr) to the stack\n   () - opional values stored on the stack\n  ()* - optonal, can be stored multiple times\n\n  The following list shows the regular expression templates, their PCRE byte codes\n  and stack layout supported by pcre-sljit.\n\n  (?:)                     OP_BRA     | OP_KET                A M\n  ()                       OP_CBRA    | OP_KET                C M\n  (?:)+                    OP_BRA     | OP_KETRMAX        0   A M S   ( A M S )*\n                           OP_SBRA    | OP_KETRMAX        0   L M S   ( L M S )*\n  (?:)+?                   OP_BRA     | OP_KETRMIN        0   A M S   ( A M S )*\n                           OP_SBRA    | OP_KETRMIN        0   L M S   ( L M S )*\n  ()+                      OP_CBRA    | OP_KETRMAX        0   C M S   ( C M S )*\n                           OP_SCBRA   | OP_KETRMAX        0   C M S   ( C M S )*\n  ()+?                     OP_CBRA    | OP_KETRMIN        0   C M S   ( C M S )*\n                           OP_SCBRA   | OP_KETRMIN        0   C M S   ( C M S )*\n  (?:)?    OP_BRAZERO    | OP_BRA     | OP_KET            S ( A M 0 )\n  (?:)??   OP_BRAMINZERO | OP_BRA     | OP_KET            S ( A M 0 )\n  ()?      OP_BRAZERO    | OP_CBRA    | OP_KET            S ( C M 0 )\n  ()??     OP_BRAMINZERO | OP_CBRA    | OP_KET            S ( C M 0 )\n  (?:)*    OP_BRAZERO    | OP_BRA     | OP_KETRMAX      S 0 ( A M S )*\n           OP_BRAZERO    | OP_SBRA    | OP_KETRMAX      S 0 ( L M S )*\n  (?:)*?   OP_BRAMINZERO | OP_BRA     | OP_KETRMIN      S 0 ( A M S )*\n           OP_BRAMINZERO | OP_SBRA    | OP_KETRMIN      S 0 ( L M S )*\n  ()*      OP_BRAZERO    | OP_CBRA    | OP_KETRMAX      S 0 ( C M S )*\n           OP_BRAZERO    | OP_SCBRA   | OP_KETRMAX      S 0 ( C M S )*\n  ()*?     OP_BRAMINZERO | OP_CBRA    | OP_KETRMIN      S 0 ( C M S )*\n           OP_BRAMINZERO | OP_SCBRA   | OP_KETRMIN      S 0 ( C M S )*\n\n\n  Stack layout naming characters:\n    A - Push the alternative index (starting from 0) on the stack.\n        Not pushed if there is no alternatives.\n    M - Any values pushed by the current alternative. Can be empty, or anything.\n\n  The next list shows the possible content of a bracket:\n  (|)     OP_*BRA    | OP_ALT ...         M A\n  (?()|)  OP_*COND   | OP_ALT             M A\n  (?>|)   OP_ONCE    | OP_ALT ...         [stack trace] M A\n                                          Or nothing, if trace is unnecessary\n*/\n\nstatic PCRE2_SPTR compile_bracket_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nint private_data_ptr = 0;\nint offset = 0;\nint i, stacksize;\nint repeat_ptr = 0, repeat_length = 0;\nint repeat_type = 0, repeat_count = 0;\nPCRE2_SPTR ccbegin;\nPCRE2_SPTR matchingpath;\nPCRE2_SPTR slot;\nPCRE2_UCHAR bra = OP_BRA;\nPCRE2_UCHAR ket;\nassert_backtrack *assert;\nBOOL has_alternatives;\nBOOL needs_control_head = FALSE;\nstruct sljit_jump *jump;\nstruct sljit_jump *skip;\nstruct sljit_label *rmax_label = NULL;\nstruct sljit_jump *braminzero = NULL;\n\nPUSH_BACKTRACK(sizeof(bracket_backtrack), cc, NULL);\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  bra = *cc;\n  cc++;\n  opcode = *cc;\n  }\n\nopcode = *cc;\nccbegin = cc;\nmatchingpath = bracketend(cc) - 1 - LINK_SIZE;\nket = *matchingpath;\nif (ket == OP_KET && PRIVATE_DATA(matchingpath) != 0)\n  {\n  repeat_ptr = PRIVATE_DATA(matchingpath);\n  repeat_length = PRIVATE_DATA(matchingpath + 1);\n  repeat_type = PRIVATE_DATA(matchingpath + 2);\n  repeat_count = PRIVATE_DATA(matchingpath + 3);\n  SLJIT_ASSERT(repeat_length != 0 && repeat_type != 0 && repeat_count != 0);\n  if (repeat_type == OP_UPTO)\n    ket = OP_KETRMAX;\n  if (repeat_type == OP_MINUPTO)\n    ket = OP_KETRMIN;\n  }\n\nmatchingpath = ccbegin + 1 + LINK_SIZE;\nSLJIT_ASSERT(ket == OP_KET || ket == OP_KETRMAX || ket == OP_KETRMIN);\nSLJIT_ASSERT(!((bra == OP_BRAZERO && ket == OP_KETRMIN) || (bra == OP_BRAMINZERO && ket == OP_KETRMAX)));\ncc += GET(cc, 1);\n\nhas_alternatives = *cc == OP_ALT;\nif (SLJIT_UNLIKELY(opcode == OP_COND || opcode == OP_SCOND))\n  {\n  SLJIT_COMPILE_ASSERT(OP_DNRREF == OP_RREF + 1 && OP_FALSE == OP_RREF + 2 && OP_TRUE == OP_RREF + 3,\n    compile_time_checks_must_be_grouped_together);\n  has_alternatives = ((*matchingpath >= OP_RREF && *matchingpath <= OP_TRUE) || *matchingpath == OP_FAIL) ? FALSE : TRUE;\n  }\n\nif (SLJIT_UNLIKELY(opcode == OP_COND) && (*cc == OP_KETRMAX || *cc == OP_KETRMIN))\n  opcode = OP_SCOND;\n\nif (opcode == OP_CBRA || opcode == OP_SCBRA)\n  {\n  /* Capturing brackets has a pre-allocated space. */\n  offset = GET2(ccbegin, 1 + LINK_SIZE);\n  if (common->optimized_cbracket[offset] == 0)\n    {\n    private_data_ptr = OVECTOR_PRIV(offset);\n    offset <<= 1;\n    }\n  else\n    {\n    offset <<= 1;\n    private_data_ptr = OVECTOR(offset);\n    }\n  BACKTRACK_AS(bracket_backtrack)->private_data_ptr = private_data_ptr;\n  matchingpath += IMM2_SIZE;\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_ONCE || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  /* Other brackets simply allocate the next entry. */\n  private_data_ptr = PRIVATE_DATA(ccbegin);\n  SLJIT_ASSERT(private_data_ptr != 0);\n  BACKTRACK_AS(bracket_backtrack)->private_data_ptr = private_data_ptr;\n  if (opcode == OP_ONCE)\n    BACKTRACK_AS(bracket_backtrack)->u.framesize = get_framesize(common, ccbegin, NULL, FALSE, &needs_control_head);\n  }\n\n/* Instructions before the first alternative. */\nstacksize = 0;\nif (ket == OP_KETRMAX || (ket == OP_KETRMIN && bra != OP_BRAMINZERO))\n  stacksize++;\nif (bra == OP_BRAZERO)\n  stacksize++;\n\nif (stacksize > 0)\n  allocate_stack(common, stacksize);\n\nstacksize = 0;\nif (ket == OP_KETRMAX || (ket == OP_KETRMIN && bra != OP_BRAMINZERO))\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n  stacksize++;\n  }\n\nif (bra == OP_BRAZERO)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a backtrack path! (Since the try-path of OP_BRAMINZERO matches to the empty string) */\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  if (ket != OP_KETRMIN)\n    {\n    free_stack(common, 1);\n    braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    }\n  else if (opcode == OP_ONCE || opcode >= OP_SBRA)\n    {\n    jump = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    /* Nothing stored during the first run. */\n    skip = JUMP(SLJIT_JUMP);\n    JUMPHERE(jump);\n    /* Checking zero-length iteration. */\n    if (opcode != OP_ONCE || BACKTRACK_AS(bracket_backtrack)->u.framesize < 0)\n      {\n      /* When we come from outside, private_data_ptr contains the previous STR_PTR. */\n      braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      }\n    else\n      {\n      /* Except when the whole stack frame must be saved. */\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(TMP1), STACK(-BACKTRACK_AS(bracket_backtrack)->u.framesize - 2));\n      }\n    JUMPHERE(skip);\n    }\n  else\n    {\n    jump = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    JUMPHERE(jump);\n    }\n  }\n\nif (repeat_type != 0)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, repeat_count);\n  if (repeat_type == OP_EXACT)\n    rmax_label = LABEL();\n  }\n\nif (ket == OP_KETRMIN)\n  BACKTRACK_AS(bracket_backtrack)->recursive_matchingpath = LABEL();\n\nif (ket == OP_KETRMAX)\n  {\n  rmax_label = LABEL();\n  if (has_alternatives && opcode >= OP_BRA && opcode < OP_SBRA && repeat_type == 0)\n    BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = rmax_label;\n  }\n\n/* Handling capturing brackets and alternatives. */\nif (opcode == OP_ONCE)\n  {\n  stacksize = 0;\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    stacksize++;\n    }\n\n  if (BACKTRACK_AS(bracket_backtrack)->u.framesize < 0)\n    {\n    /* Neither capturing brackets nor recursions are found in the block. */\n    if (ket == OP_KETRMIN)\n      {\n      stacksize += 2;\n      if (!needs_control_head)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      }\n    else\n      {\n      if (BACKTRACK_AS(bracket_backtrack)->u.framesize == no_frame)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n      if (ket == OP_KETRMAX || has_alternatives)\n        stacksize++;\n      }\n\n    if (stacksize > 0)\n      allocate_stack(common, stacksize);\n\n    stacksize = 0;\n    if (needs_control_head)\n      {\n      stacksize++;\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n      }\n\n    if (ket == OP_KETRMIN)\n      {\n      if (needs_control_head)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      if (BACKTRACK_AS(bracket_backtrack)->u.framesize == no_frame)\n        OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0, SLJIT_IMM, needs_control_head ? (2 * sizeof(sljit_sw)) : sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize + 1), TMP2, 0);\n      }\n    else if (ket == OP_KETRMAX || has_alternatives)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n    }\n  else\n    {\n    if (ket != OP_KET || has_alternatives)\n      stacksize++;\n\n    stacksize += BACKTRACK_AS(bracket_backtrack)->u.framesize + 1;\n    allocate_stack(common, stacksize);\n\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    OP2(SLJIT_ADD, TMP2, 0, STACK_TOP, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n\n    stacksize = needs_control_head ? 1 : 0;\n    if (ket != OP_KET || has_alternatives)\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n      stacksize++;\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n      }\n    init_frame(common, ccbegin, NULL, BACKTRACK_AS(bracket_backtrack)->u.framesize + stacksize, stacksize + 1);\n    }\n  }\nelse if (opcode == OP_CBRA || opcode == OP_SCBRA)\n  {\n  /* Saving the previous values. */\n  if (common->optimized_cbracket[offset >> 1] != 0)\n    {\n    SLJIT_ASSERT(private_data_ptr == OVECTOR(offset));\n    allocate_stack(common, 2);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n    }\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  /* Saving the previous value. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n  }\nelse if (has_alternatives)\n  {\n  /* Pushing the starting string pointer. */\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  }\n\n/* Generating code for the first alternative. */\nif (opcode == OP_COND || opcode == OP_SCOND)\n  {\n  if (*matchingpath == OP_CREF)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    add_jump(compiler, &(BACKTRACK_AS(bracket_backtrack)->u.condfailed),\n      CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(matchingpath, 1) << 1), SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n    matchingpath += 1 + IMM2_SIZE;\n    }\n  else if (*matchingpath == OP_DNCREF)\n    {\n    SLJIT_ASSERT(has_alternatives);\n\n    i = GET2(matchingpath, 1 + IMM2_SIZE);\n    slot = common->name_table + GET2(matchingpath, 1) * common->name_entry_size;\n    OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(slot, 0) << 1), TMP1, 0);\n    slot += common->name_entry_size;\n    i--;\n    while (i-- > 0)\n      {\n      OP2(SLJIT_SUB, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(slot, 0) << 1), TMP1, 0);\n      OP2(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, TMP2, 0, STR_PTR, 0);\n      slot += common->name_entry_size;\n      }\n    OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n    add_jump(compiler, &(BACKTRACK_AS(bracket_backtrack)->u.condfailed), JUMP(SLJIT_ZERO));\n    matchingpath += 1 + 2 * IMM2_SIZE;\n    }\n  else if ((*matchingpath >= OP_RREF && *matchingpath <= OP_TRUE) || *matchingpath == OP_FAIL)\n    {\n    /* Never has other case. */\n    BACKTRACK_AS(bracket_backtrack)->u.condfailed = NULL;\n    SLJIT_ASSERT(!has_alternatives);\n\n    if (*matchingpath == OP_TRUE)\n      {\n      stacksize = 1;\n      matchingpath++;\n      }\n    else if (*matchingpath == OP_FALSE || *matchingpath == OP_FAIL)\n      stacksize = 0;\n    else if (*matchingpath == OP_RREF)\n      {\n      stacksize = GET2(matchingpath, 1);\n      if (common->currententry == NULL)\n        stacksize = 0;\n      else if (stacksize == RREF_ANY)\n        stacksize = 1;\n      else if (common->currententry->start == 0)\n        stacksize = stacksize == 0;\n      else\n        stacksize = stacksize == (int)GET2(common->start, common->currententry->start + 1 + LINK_SIZE);\n\n      if (stacksize != 0)\n        matchingpath += 1 + IMM2_SIZE;\n      }\n    else\n      {\n      if (common->currententry == NULL || common->currententry->start == 0)\n        stacksize = 0;\n      else\n        {\n        stacksize = GET2(matchingpath, 1 + IMM2_SIZE);\n        slot = common->name_table + GET2(matchingpath, 1) * common->name_entry_size;\n        i = (int)GET2(common->start, common->currententry->start + 1 + LINK_SIZE);\n        while (stacksize > 0)\n          {\n          if ((int)GET2(slot, 0) == i)\n            break;\n          slot += common->name_entry_size;\n          stacksize--;\n          }\n        }\n\n      if (stacksize != 0)\n        matchingpath += 1 + 2 * IMM2_SIZE;\n      }\n\n      /* The stacksize == 0 is a common \"else\" case. */\n      if (stacksize == 0)\n        {\n        if (*cc == OP_ALT)\n          {\n          matchingpath = cc + 1 + LINK_SIZE;\n          cc += GET(cc, 1);\n          }\n        else\n          matchingpath = cc;\n        }\n    }\n  else\n    {\n    SLJIT_ASSERT(has_alternatives && *matchingpath >= OP_ASSERT && *matchingpath <= OP_ASSERTBACK_NOT);\n    /* Similar code as PUSH_BACKTRACK macro. */\n    assert = sljit_alloc_memory(compiler, sizeof(assert_backtrack));\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n      return NULL;\n    memset(assert, 0, sizeof(assert_backtrack));\n    assert->common.cc = matchingpath;\n    BACKTRACK_AS(bracket_backtrack)->u.assert = assert;\n    matchingpath = compile_assert_matchingpath(common, matchingpath, assert, TRUE);\n    }\n  }\n\ncompile_matchingpath(common, matchingpath, cc, backtrack);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  return NULL;\n\nif (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA)\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\nif (opcode == OP_ONCE)\n  match_once_common(common, ket, BACKTRACK_AS(bracket_backtrack)->u.framesize, private_data_ptr, has_alternatives, needs_control_head);\n\nif (opcode == OP_SCRIPT_RUN)\n  match_script_run_common(common, private_data_ptr, backtrack);\n\nstacksize = 0;\nif (repeat_type == OP_MINUPTO)\n  {\n  /* We need to preserve the counter. TMP2 will be used below. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n  stacksize++;\n  }\nif (ket != OP_KET || bra != OP_BRA)\n  stacksize++;\nif (offset != 0)\n  {\n  if (common->capture_last_ptr != 0)\n    stacksize++;\n  if (common->optimized_cbracket[offset >> 1] == 0)\n    stacksize += 2;\n  }\nif (has_alternatives && opcode != OP_ONCE)\n  stacksize++;\n\nif (stacksize > 0)\n  allocate_stack(common, stacksize);\n\nstacksize = 0;\nif (repeat_type == OP_MINUPTO)\n  {\n  /* TMP2 was set above. */\n  OP2(SLJIT_SUB, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP2, 0, SLJIT_IMM, 1);\n  stacksize++;\n  }\n\nif (ket != OP_KET || bra != OP_BRA)\n  {\n  if (ket != OP_KET)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n  stacksize++;\n  }\n\nif (offset != 0)\n  stacksize = match_capture_common(common, stacksize, offset, private_data_ptr);\n\n/* Skip and count the other alternatives. */\ni = 1;\nwhile (*cc == OP_ALT)\n  {\n  cc += GET(cc, 1);\n  i++;\n  }\n\nif (has_alternatives)\n  {\n  if (opcode != OP_ONCE)\n    {\n    if (i <= 3)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n    else\n      BACKTRACK_AS(bracket_backtrack)->u.matching_put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(stacksize));\n    }\n  if (ket != OP_KETRMAX)\n    BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n  }\n\n/* Must be after the matchingpath label. */\nif (offset != 0 && common->optimized_cbracket[offset >> 1] != 0)\n  {\n  SLJIT_ASSERT(private_data_ptr == OVECTOR(offset + 0));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n  }\n\nif (ket == OP_KETRMAX)\n  {\n  if (repeat_type != 0)\n    {\n    if (has_alternatives)\n      BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, rmax_label);\n    /* Drop STR_PTR for greedy plus quantifier. */\n    if (opcode != OP_ONCE)\n      free_stack(common, 1);\n    }\n  else if (opcode < OP_BRA || opcode >= OP_SBRA)\n    {\n    if (has_alternatives)\n      BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n\n    /* Checking zero-length iteration. */\n    if (opcode != OP_ONCE)\n      {\n      /* This case includes opcodes such as OP_SCRIPT_RUN. */\n      CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0, rmax_label);\n      /* Drop STR_PTR for greedy plus quantifier. */\n      if (bra != OP_BRAZERO)\n        free_stack(common, 1);\n      }\n    else\n      /* TMP2 must contain the starting STR_PTR. */\n      CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, rmax_label);\n    }\n  else\n    JUMPTO(SLJIT_JUMP, rmax_label);\n  BACKTRACK_AS(bracket_backtrack)->recursive_matchingpath = LABEL();\n  }\n\nif (repeat_type == OP_EXACT)\n  {\n  count_match(common);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  JUMPTO(SLJIT_NOT_ZERO, rmax_label);\n  }\nelse if (repeat_type == OP_UPTO)\n  {\n  /* We need to preserve the counter. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n  }\n\nif (bra == OP_BRAZERO)\n  BACKTRACK_AS(bracket_backtrack)->zero_matchingpath = LABEL();\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a backtrack path! (From the viewpoint of OP_BRAMINZERO) */\n  JUMPTO(SLJIT_JUMP, ((braminzero_backtrack *)parent)->matchingpath);\n  if (braminzero != NULL)\n    {\n    JUMPHERE(braminzero);\n    /* We need to release the end pointer to perform the\n    backtrack for the zero-length iteration. When\n    framesize is < 0, OP_ONCE will do the release itself. */\n    if (opcode == OP_ONCE && BACKTRACK_AS(bracket_backtrack)->u.framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (BACKTRACK_AS(bracket_backtrack)->u.framesize - 1) * sizeof(sljit_sw));\n      }\n    else if (ket == OP_KETRMIN && opcode != OP_ONCE)\n      free_stack(common, 1);\n    }\n  /* Continue to the normal backtrack. */\n  }\n\nif ((ket != OP_KET && bra != OP_BRAMINZERO) || bra == OP_BRAZERO)\n  count_match(common);\n\ncc += 1 + LINK_SIZE;\n\nif (opcode == OP_ONCE)\n  {\n  /* We temporarily encode the needs_control_head in the lowest bit.\n     Note: on the target architectures of SLJIT the ((x << 1) >> 1) returns\n     the same value for small signed numbers (including negative numbers). */\n  BACKTRACK_AS(bracket_backtrack)->u.framesize = (int)((unsigned)BACKTRACK_AS(bracket_backtrack)->u.framesize << 1) | (needs_control_head ? 1 : 0);\n  }\nreturn cc + repeat_length;\n}\n\nstatic PCRE2_SPTR compile_bracketpos_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nint private_data_ptr;\nint cbraprivptr = 0;\nBOOL needs_control_head;\nint framesize;\nint stacksize;\nint offset = 0;\nBOOL zero = FALSE;\nPCRE2_SPTR ccbegin = NULL;\nint stack; /* Also contains the offset of control head. */\nstruct sljit_label *loop = NULL;\nstruct jump_list *emptymatch = NULL;\n\nPUSH_BACKTRACK(sizeof(bracketpos_backtrack), cc, NULL);\nif (*cc == OP_BRAPOSZERO)\n  {\n  zero = TRUE;\n  cc++;\n  }\n\nopcode = *cc;\nprivate_data_ptr = PRIVATE_DATA(cc);\nSLJIT_ASSERT(private_data_ptr != 0);\nBACKTRACK_AS(bracketpos_backtrack)->private_data_ptr = private_data_ptr;\nswitch(opcode)\n  {\n  case OP_BRAPOS:\n  case OP_SBRAPOS:\n  ccbegin = cc + 1 + LINK_SIZE;\n  break;\n\n  case OP_CBRAPOS:\n  case OP_SCBRAPOS:\n  offset = GET2(cc, 1 + LINK_SIZE);\n  /* This case cannot be optimized in the same was as\n  normal capturing brackets. */\n  SLJIT_ASSERT(common->optimized_cbracket[offset] == 0);\n  cbraprivptr = OVECTOR_PRIV(offset);\n  offset <<= 1;\n  ccbegin = cc + 1 + LINK_SIZE + IMM2_SIZE;\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nframesize = get_framesize(common, cc, NULL, FALSE, &needs_control_head);\nBACKTRACK_AS(bracketpos_backtrack)->framesize = framesize;\nif (framesize < 0)\n  {\n  if (offset != 0)\n    {\n    stacksize = 2;\n    if (common->capture_last_ptr != 0)\n      stacksize++;\n    }\n  else\n    stacksize = 1;\n\n  if (needs_control_head)\n    stacksize++;\n  if (!zero)\n    stacksize++;\n\n  BACKTRACK_AS(bracketpos_backtrack)->stacksize = stacksize;\n  allocate_stack(common, stacksize);\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n\n  stack = 0;\n  if (offset != 0)\n    {\n    stack = 2;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    if (needs_control_head)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    if (common->capture_last_ptr != 0)\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP1, 0);\n      stack = 3;\n      }\n    }\n  else\n    {\n    if (needs_control_head)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    stack = 1;\n    }\n\n  if (needs_control_head)\n    stack++;\n  if (!zero)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), SLJIT_IMM, 1);\n  if (needs_control_head)\n    {\n    stack--;\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP2, 0);\n    }\n  }\nelse\n  {\n  stacksize = framesize + 1;\n  if (!zero)\n    stacksize++;\n  if (needs_control_head)\n    stacksize++;\n  if (offset == 0)\n    stacksize++;\n  BACKTRACK_AS(bracketpos_backtrack)->stacksize = stacksize;\n\n  allocate_stack(common, stacksize);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n\n  stack = 0;\n  if (!zero)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 1);\n    stack = 1;\n    }\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP2, 0);\n    stack++;\n    }\n  if (offset == 0)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), STR_PTR, 0);\n    stack++;\n    }\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP1, 0);\n  init_frame(common, cc, NULL, stacksize - 1, stacksize - framesize);\n  stack -= 1 + (offset == 0);\n  }\n\nif (offset != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n\nloop = LABEL();\nwhile (*cc != OP_KETRPOS)\n  {\n  backtrack->top = NULL;\n  backtrack->topbacktracks = NULL;\n  cc += GET(cc, 1);\n\n  compile_matchingpath(common, ccbegin, cc, backtrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n\n  if (framesize < 0)\n    {\n    if (framesize == no_frame)\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\n    if (offset != 0)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n      if (common->capture_last_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n      }\n    else\n      {\n      if (opcode == OP_SBRAPOS)\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n\n    /* Even if the match is empty, we need to reset the control head. */\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(stack));\n\n    if (opcode == OP_SBRAPOS || opcode == OP_SCBRAPOS)\n      add_jump(compiler, &emptymatch, CMP(SLJIT_EQUAL, TMP1, 0, STR_PTR, 0));\n\n    if (!zero)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0);\n    }\n  else\n    {\n    if (offset != 0)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n      if (common->capture_last_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP2(SLJIT_SUB, STACK_TOP, 0, TMP2, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n      if (opcode == OP_SBRAPOS)\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), STACK(-framesize - 2));\n      OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), STACK(-framesize - 2), STR_PTR, 0);\n      }\n\n    /* Even if the match is empty, we need to reset the control head. */\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(stack));\n\n    if (opcode == OP_SBRAPOS || opcode == OP_SCBRAPOS)\n      add_jump(compiler, &emptymatch, CMP(SLJIT_EQUAL, TMP1, 0, STR_PTR, 0));\n\n    if (!zero)\n      {\n      if (framesize < 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    }\n\n  JUMPTO(SLJIT_JUMP, loop);\n  flush_stubs(common);\n\n  compile_backtrackingpath(common, backtrack->top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n  set_jumps(backtrack->topbacktracks, LABEL());\n\n  if (framesize < 0)\n    {\n    if (offset != 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n    else\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    }\n  else\n    {\n    if (offset != 0)\n      {\n      /* Last alternative. */\n      if (*cc == OP_KETRPOS)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(TMP2), STACK(-framesize - 2));\n      }\n    }\n\n  if (*cc == OP_KETRPOS)\n    break;\n  ccbegin = cc + 1 + LINK_SIZE;\n  }\n\n/* We don't have to restore the control head in case of a failed match. */\n\nbacktrack->topbacktracks = NULL;\nif (!zero)\n  {\n  if (framesize < 0)\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0));\n  else /* TMP2 is set to [private_data_ptr] above. */\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(TMP2), STACK(-stacksize), SLJIT_IMM, 0));\n  }\n\n/* None of them matched. */\nset_jumps(emptymatch, LABEL());\ncount_match(common);\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR get_iterator_parameters(compiler_common *common, PCRE2_SPTR cc, PCRE2_UCHAR *opcode, PCRE2_UCHAR *type, sljit_u32 *max, sljit_u32 *exact, PCRE2_SPTR *end)\n{\nint class_len;\n\n*opcode = *cc;\n*exact = 0;\n\nif (*opcode >= OP_STAR && *opcode <= OP_POSUPTO)\n  {\n  cc++;\n  *type = OP_CHAR;\n  }\nelse if (*opcode >= OP_STARI && *opcode <= OP_POSUPTOI)\n  {\n  cc++;\n  *type = OP_CHARI;\n  *opcode -= OP_STARI - OP_STAR;\n  }\nelse if (*opcode >= OP_NOTSTAR && *opcode <= OP_NOTPOSUPTO)\n  {\n  cc++;\n  *type = OP_NOT;\n  *opcode -= OP_NOTSTAR - OP_STAR;\n  }\nelse if (*opcode >= OP_NOTSTARI && *opcode <= OP_NOTPOSUPTOI)\n  {\n  cc++;\n  *type = OP_NOTI;\n  *opcode -= OP_NOTSTARI - OP_STAR;\n  }\nelse if (*opcode >= OP_TYPESTAR && *opcode <= OP_TYPEPOSUPTO)\n  {\n  cc++;\n  *opcode -= OP_TYPESTAR - OP_STAR;\n  *type = OP_END;\n  }\nelse\n  {\n  SLJIT_ASSERT(*opcode == OP_CLASS || *opcode == OP_NCLASS || *opcode == OP_XCLASS);\n  *type = *opcode;\n  cc++;\n  class_len = (*type < OP_XCLASS) ? (int)(1 + (32 / sizeof(PCRE2_UCHAR))) : GET(cc, 0);\n  *opcode = cc[class_len - 1];\n\n  if (*opcode >= OP_CRSTAR && *opcode <= OP_CRMINQUERY)\n    {\n    *opcode -= OP_CRSTAR - OP_STAR;\n    *end = cc + class_len;\n\n    if (*opcode == OP_PLUS || *opcode == OP_MINPLUS)\n      {\n      *exact = 1;\n      *opcode -= OP_PLUS - OP_STAR;\n      }\n    }\n  else if (*opcode >= OP_CRPOSSTAR && *opcode <= OP_CRPOSQUERY)\n    {\n    *opcode -= OP_CRPOSSTAR - OP_POSSTAR;\n    *end = cc + class_len;\n\n    if (*opcode == OP_POSPLUS)\n      {\n      *exact = 1;\n      *opcode = OP_POSSTAR;\n      }\n    }\n  else\n    {\n    SLJIT_ASSERT(*opcode == OP_CRRANGE || *opcode == OP_CRMINRANGE || *opcode == OP_CRPOSRANGE);\n    *max = GET2(cc, (class_len + IMM2_SIZE));\n    *exact = GET2(cc, class_len);\n\n    if (*max == 0)\n      {\n      if (*opcode == OP_CRPOSRANGE)\n        *opcode = OP_POSSTAR;\n      else\n        *opcode -= OP_CRRANGE - OP_STAR;\n      }\n    else\n      {\n      *max -= *exact;\n      if (*max == 0)\n        *opcode = OP_EXACT;\n      else if (*max == 1)\n        {\n        if (*opcode == OP_CRPOSRANGE)\n          *opcode = OP_POSQUERY;\n        else\n          *opcode -= OP_CRRANGE - OP_QUERY;\n        }\n      else\n        {\n        if (*opcode == OP_CRPOSRANGE)\n          *opcode = OP_POSUPTO;\n        else\n          *opcode -= OP_CRRANGE - OP_UPTO;\n        }\n      }\n    *end = cc + class_len + 2 * IMM2_SIZE;\n    }\n  return cc;\n  }\n\nswitch(*opcode)\n  {\n  case OP_EXACT:\n  *exact = GET2(cc, 0);\n  cc += IMM2_SIZE;\n  break;\n\n  case OP_PLUS:\n  case OP_MINPLUS:\n  *exact = 1;\n  *opcode -= OP_PLUS - OP_STAR;\n  break;\n\n  case OP_POSPLUS:\n  *exact = 1;\n  *opcode = OP_POSSTAR;\n  break;\n\n  case OP_UPTO:\n  case OP_MINUPTO:\n  case OP_POSUPTO:\n  *max = GET2(cc, 0);\n  cc += IMM2_SIZE;\n  break;\n  }\n\nif (*type == OP_END)\n  {\n  *type = *cc;\n  *end = next_opcode(common, cc);\n  cc++;\n  return cc;\n  }\n\n*end = cc + 1;\n#ifdef SUPPORT_UNICODE\nif (common->utf && HAS_EXTRALEN(*cc)) *end += GET_EXTRALEN(*cc);\n#endif\nreturn cc;\n}\n\nstatic PCRE2_SPTR compile_iterator_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR type;\nsljit_u32 max = 0, exact;\nsljit_s32 early_fail_ptr = PRIVATE_DATA(cc + 1);\nsljit_s32 early_fail_type;\nBOOL charpos_enabled;\nPCRE2_UCHAR charpos_char;\nunsigned int charpos_othercasebit;\nPCRE2_SPTR end;\njump_list *no_match = NULL;\njump_list *no_char1_match = NULL;\nstruct sljit_jump *jump = NULL;\nstruct sljit_label *label;\nint private_data_ptr = PRIVATE_DATA(cc);\nint base = (private_data_ptr == 0) ? SLJIT_MEM1(STACK_TOP) : SLJIT_MEM1(SLJIT_SP);\nint offset0 = (private_data_ptr == 0) ? STACK(0) : private_data_ptr;\nint offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + (int)sizeof(sljit_sw);\nint tmp_base, tmp_offset;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nBOOL use_tmp;\n#endif\n\nPUSH_BACKTRACK(sizeof(char_iterator_backtrack), cc, NULL);\n\nearly_fail_type = (early_fail_ptr & 0x7);\nearly_fail_ptr >>= 3;\n\n/* During recursion, these optimizations are disabled. */\nif (common->early_fail_start_ptr == 0 && common->fast_forward_bc_ptr == NULL)\n  {\n  early_fail_ptr = 0;\n  early_fail_type = type_skip;\n  }\n\nSLJIT_ASSERT(common->fast_forward_bc_ptr != NULL || early_fail_ptr == 0\n  || (early_fail_ptr >= common->early_fail_start_ptr && early_fail_ptr <= common->early_fail_end_ptr));\n\nif (early_fail_type == type_fail)\n  add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr));\n\ncc = get_iterator_parameters(common, cc, &opcode, &type, &max, &exact, &end);\n\nif (type != OP_EXTUNI)\n  {\n  tmp_base = TMP3;\n  tmp_offset = 0;\n  }\nelse\n  {\n  tmp_base = SLJIT_MEM1(SLJIT_SP);\n  tmp_offset = POSSESSIVE0;\n  }\n\n/* Handle fixed part first. */\nif (exact > 1)\n  {\n  SLJIT_ASSERT(early_fail_ptr == 0);\n\n  if (common->mode == PCRE2_JIT_COMPLETE\n#ifdef SUPPORT_UNICODE\n      && !common->utf\n#endif\n      && type != OP_ANYNL && type != OP_EXTUNI)\n    {\n    OP2(SLJIT_ADD, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(exact));\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_GREATER, TMP1, 0, STR_END, 0));\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, exact);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, FALSE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, exact);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, TRUE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  }\nelse if (exact == 1)\n  {\n  compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, TRUE);\n\n  if (early_fail_type == type_fail_range)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + (int)sizeof(sljit_sw));\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP2(SLJIT_SUB, TMP2, 0, STR_PTR, 0, TMP2, 0);\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_LESS_EQUAL, TMP2, 0, TMP1, 0));\n\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + (int)sizeof(sljit_sw), STR_PTR, 0);\n    }\n  }\n\nswitch(opcode)\n  {\n  case OP_STAR:\n  case OP_UPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0 || opcode == OP_STAR);\n\n  if (type == OP_ANYNL || type == OP_EXTUNI)\n    {\n    SLJIT_ASSERT(private_data_ptr == 0);\n    SLJIT_ASSERT(early_fail_ptr == 0);\n\n    allocate_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, SLJIT_IMM, max);\n\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &BACKTRACK_AS(char_iterator_backtrack)->u.backtracks, TRUE);\n    if (opcode == OP_UPTO)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n      jump = JUMP(SLJIT_ZERO);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, TMP1, 0);\n      }\n\n    /* We cannot use TMP3 because of allocate_stack. */\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    JUMPTO(SLJIT_JUMP, label);\n    if (jump != NULL)\n      JUMPHERE(jump);\n    BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n    break;\n    }\n#ifdef SUPPORT_UNICODE\n  else if (type == OP_ALLANY && !common->invalid_utf)\n#else\n  else if (type == OP_ALLANY)\n#endif\n    {\n    if (opcode == OP_STAR)\n      {\n      if (private_data_ptr == 0)\n        allocate_stack(common, 2);\n\n      OP1(SLJIT_MOV, base, offset0, STR_END, 0);\n      OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n\n      OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n      process_partial_match(common);\n\n      if (early_fail_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_END, 0);\n      BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n      break;\n      }\n#ifdef SUPPORT_UNICODE\n    else if (!common->utf)\n#else\n    else\n#endif\n      {\n      if (private_data_ptr == 0)\n        allocate_stack(common, 2);\n\n      OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(max));\n\n      if (common->mode == PCRE2_JIT_COMPLETE)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_PTR, 0, STR_END, 0);\n        CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n        }\n      else\n        {\n        jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, STR_END, 0);\n        process_partial_match(common);\n        JUMPHERE(jump);\n        }\n\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n\n      if (early_fail_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n      BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n      break;\n      }\n    }\n\n  charpos_enabled = FALSE;\n  charpos_char = 0;\n  charpos_othercasebit = 0;\n\n  if ((type != OP_CHAR && type != OP_CHARI) && (*end == OP_CHAR || *end == OP_CHARI))\n    {\n#ifdef SUPPORT_UNICODE\n    charpos_enabled = !common->utf || !HAS_EXTRALEN(end[1]);\n#else\n    charpos_enabled = TRUE;\n#endif\n    if (charpos_enabled && *end == OP_CHARI && char_has_othercase(common, end + 1))\n      {\n      charpos_othercasebit = char_get_othercase_bit(common, end + 1);\n      if (charpos_othercasebit == 0)\n        charpos_enabled = FALSE;\n      }\n\n    if (charpos_enabled)\n      {\n      charpos_char = end[1];\n      /* Consume the OP_CHAR opcode. */\n      end += 2;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      SLJIT_ASSERT((charpos_othercasebit >> 8) == 0);\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n      SLJIT_ASSERT((charpos_othercasebit >> 9) == 0);\n      if ((charpos_othercasebit & 0x100) != 0)\n        charpos_othercasebit = (charpos_othercasebit & 0xff) << 8;\n#endif\n      if (charpos_othercasebit != 0)\n        charpos_char |= charpos_othercasebit;\n\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.enabled = TRUE;\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.chr = charpos_char;\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.othercasebit = charpos_othercasebit;\n      }\n    }\n\n  if (charpos_enabled)\n    {\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max + 1);\n\n    /* Search the first instance of charpos_char. */\n    jump = JUMP(SLJIT_JUMP);\n    label = LABEL();\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_ZERO));\n      }\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, FALSE);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    JUMPHERE(jump);\n\n    detect_partial_match(common, &backtrack->topbacktracks);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (charpos_othercasebit != 0)\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, charpos_othercasebit);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char, label);\n\n    if (private_data_ptr == 0)\n      allocate_stack(common, 2);\n    OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n    OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n      }\n\n    /* Search the last instance of charpos_char. */\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    detect_partial_match(common, &no_match);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (charpos_othercasebit != 0)\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, charpos_othercasebit);\n\n    if (opcode == OP_STAR)\n      {\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char, label);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, label);\n      }\n    else\n      {\n      jump = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPHERE(jump);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      JUMPTO(SLJIT_NOT_ZERO, label);\n      }\n\n    set_jumps(no_match, LABEL());\n    OP2(SLJIT_ADD, STR_PTR, 0, base, offset0, SLJIT_IMM, IN_UCHARS(1));\n    OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n    }\n  else\n    {\n    if (private_data_ptr == 0)\n      allocate_stack(common, 2);\n\n    OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    use_tmp = (!HAS_VIRTUAL_REGISTERS && opcode == OP_STAR);\n    SLJIT_ASSERT(!use_tmp || tmp_base == TMP3);\n\n    if (common->utf)\n      OP1(SLJIT_MOV, use_tmp ? TMP3 : base, use_tmp ? 0 : offset0, STR_PTR, 0);\n#endif\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf)\n      OP1(SLJIT_MOV, use_tmp ? TMP3 : base, use_tmp ? 0 : offset0, STR_PTR, 0);\n#endif\n\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n      }\n\n    detect_partial_match_to(common, label);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n    set_jumps(no_char1_match, LABEL());\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf)\n      {\n      set_jumps(no_match, LABEL());\n      if (use_tmp)\n        {\n        OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n        OP1(SLJIT_MOV, base, offset0, TMP3, 0);\n        }\n      else\n        OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      }\n    else\n#endif\n      {\n      OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      set_jumps(no_match, LABEL());\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      }\n\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    }\n\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_MINSTAR:\n  if (private_data_ptr == 0)\n    allocate_stack(common, 1);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  if (early_fail_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n  break;\n\n  case OP_MINUPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  if (private_data_ptr == 0)\n    allocate_stack(common, 2);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  OP1(SLJIT_MOV, base, offset1, SLJIT_IMM, max + 1);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_QUERY:\n  case OP_MINQUERY:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  if (private_data_ptr == 0)\n    allocate_stack(common, 1);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  if (opcode == OP_QUERY)\n    compile_char1_matchingpath(common, type, cc, &BACKTRACK_AS(char_iterator_backtrack)->u.backtracks, TRUE);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_EXACT:\n  break;\n\n  case OP_POSSTAR:\n#if defined SUPPORT_UNICODE\n  if (type == OP_ALLANY && !common->invalid_utf)\n#else\n  if (type == OP_ALLANY)\n#endif\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n    process_partial_match(common);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_END, 0);\n    break;\n    }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n    detect_partial_match_to(common, label);\n\n    set_jumps(no_match, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, tmp_base, tmp_offset);\n    if (early_fail_ptr != 0)\n      {\n      if (!HAS_VIRTUAL_REGISTERS && tmp_base == TMP3)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, TMP3, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n      }\n    break;\n    }\n#endif\n\n  detect_partial_match(common, &no_match);\n  label = LABEL();\n  compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n  detect_partial_match_to(common, label);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  set_jumps(no_char1_match, LABEL());\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  set_jumps(no_match, LABEL());\n  if (early_fail_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n  break;\n\n  case OP_POSUPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, STR_PTR, 0);\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, STR_PTR, 0);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n    detect_partial_match_to(common, label);\n\n    set_jumps(no_match, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1);\n    break;\n    }\n#endif\n\n  if (type == OP_ALLANY)\n    {\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(max));\n\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_PTR, 0, STR_END, 0);\n      CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, STR_END, 0);\n      process_partial_match(common);\n      JUMPHERE(jump);\n      }\n    break;\n    }\n\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n  detect_partial_match(common, &no_match);\n  label = LABEL();\n  compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n  add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n  detect_partial_match_to(common, label);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  set_jumps(no_char1_match, LABEL());\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  set_jumps(no_match, LABEL());\n  break;\n\n  case OP_POSQUERY:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n  compile_char1_matchingpath(common, type, cc, &no_match, TRUE);\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n  set_jumps(no_match, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, tmp_base, tmp_offset);\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\ncount_match(common);\nreturn end;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_fail_accept_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\nif (*cc == OP_FAIL)\n  {\n  add_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_JUMP));\n  return cc + 1;\n  }\n\nif (*cc == OP_ACCEPT && common->currententry == NULL && (common->re->overall_options & PCRE2_ENDANCHORED) != 0)\n  add_jump(compiler, &common->reset_match, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0));\n\nif (*cc == OP_ASSERT_ACCEPT || common->currententry != NULL || !common->might_be_empty)\n  {\n  /* No need to check notempty conditions. */\n  if (common->accept_label == NULL)\n    add_jump(compiler, &common->accept, JUMP(SLJIT_JUMP));\n  else\n    JUMPTO(SLJIT_JUMP, common->accept_label);\n  return cc + 1;\n  }\n\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0)));\nelse\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), common->accept_label);\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options));\n  }\nelse\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options));\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_NOT_ZERO));\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY_ATSTART);\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, JUMP(SLJIT_ZERO));\nelse\n  JUMPTO(SLJIT_ZERO, common->accept_label);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0));\nelse\n  CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, common->accept_label);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_JUMP));\nreturn cc + 1;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_close_matchingpath(compiler_common *common, PCRE2_SPTR cc)\n{\nDEFINE_COMPILER;\nint offset = GET2(cc, 1);\nBOOL optimized_cbracket = common->optimized_cbracket[offset] != 0;\n\n/* Data will be discarded anyway... */\nif (common->currententry != NULL)\n  return cc + 1 + IMM2_SIZE;\n\nif (!optimized_cbracket)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR_PRIV(offset));\noffset <<= 1;\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\nif (!optimized_cbracket)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\nreturn cc + 1 + IMM2_SIZE;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_control_verb_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode = *cc;\nPCRE2_SPTR ccend = cc + 1;\n\nif (opcode == OP_COMMIT_ARG || opcode == OP_PRUNE_ARG ||\n    opcode == OP_SKIP_ARG || opcode == OP_THEN_ARG)\n  ccend += 2 + cc[1];\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\nif (opcode == OP_SKIP)\n  {\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  return ccend;\n  }\n\nif (opcode == OP_COMMIT_ARG || opcode == OP_PRUNE_ARG || opcode == OP_THEN_ARG)\n  {\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)(cc + 2));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP2, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), TMP2, 0);\n  }\n\nreturn ccend;\n}\n\nstatic PCRE2_UCHAR then_trap_opcode[1] = { OP_THEN_TRAP };\n\nstatic SLJIT_INLINE void compile_then_trap_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nBOOL needs_control_head;\nint size;\n\nPUSH_BACKTRACK_NOVALUE(sizeof(then_trap_backtrack), cc);\ncommon->then_trap = BACKTRACK_AS(then_trap_backtrack);\nBACKTRACK_AS(then_trap_backtrack)->common.cc = then_trap_opcode;\nBACKTRACK_AS(then_trap_backtrack)->start = (sljit_sw)(cc - common->start);\nBACKTRACK_AS(then_trap_backtrack)->framesize = get_framesize(common, cc, ccend, FALSE, &needs_control_head);\n\nsize = BACKTRACK_AS(then_trap_backtrack)->framesize;\nsize = 3 + (size < 0 ? 0 : size);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\nallocate_stack(common, size);\nif (size > 3)\n  OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0, SLJIT_IMM, (size - 3) * sizeof(sljit_sw));\nelse\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 1), SLJIT_IMM, BACKTRACK_AS(then_trap_backtrack)->start);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 2), SLJIT_IMM, type_then_trap);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 3), TMP2, 0);\n\nsize = BACKTRACK_AS(then_trap_backtrack)->framesize;\nif (size >= 0)\n  init_frame(common, cc, ccend, size - 1, 0);\n}\n\nstatic void compile_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nBOOL has_then_trap = FALSE;\nthen_trap_backtrack *save_then_trap = NULL;\n\nSLJIT_ASSERT(*ccend == OP_END || (*ccend >= OP_ALT && *ccend <= OP_KETRPOS));\n\nif (common->has_then && common->then_offsets[cc - common->start] != 0)\n  {\n  SLJIT_ASSERT(*ccend != OP_END && common->control_head_ptr != 0);\n  has_then_trap = TRUE;\n  save_then_trap = common->then_trap;\n  /* Tail item on backtrack. */\n  compile_then_trap_matchingpath(common, cc, ccend, parent);\n  }\n\nwhile (cc < ccend)\n  {\n  switch(*cc)\n    {\n    case OP_SOD:\n    case OP_SOM:\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_REVERSE:\n    cc = compile_simple_assertion_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n    break;\n\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n    case OP_ANYBYTE:\n    case OP_NOTPROP:\n    case OP_PROP:\n    case OP_ANYNL:\n    case OP_NOT_HSPACE:\n    case OP_HSPACE:\n    case OP_NOT_VSPACE:\n    case OP_VSPACE:\n    case OP_EXTUNI:\n    case OP_NOT:\n    case OP_NOTI:\n    cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n    case OP_SET_SOM:\n    PUSH_BACKTRACK_NOVALUE(sizeof(backtrack_common), cc);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n    cc++;\n    break;\n\n    case OP_CHAR:\n    case OP_CHARI:\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      cc = compile_charn_matchingpath(common, cc, ccend, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n    cc = compile_iterator_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    if (cc[1 + (32 / sizeof(PCRE2_UCHAR))] >= OP_CRSTAR && cc[1 + (32 / sizeof(PCRE2_UCHAR))] <= OP_CRPOSRANGE)\n      cc = compile_iterator_matchingpath(common, cc, parent);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n    case OP_XCLASS:\n    if (*(cc + GET(cc, 1)) >= OP_CRSTAR && *(cc + GET(cc, 1)) <= OP_CRPOSRANGE)\n      cc = compile_iterator_matchingpath(common, cc, parent);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n#endif\n\n    case OP_REF:\n    case OP_REFI:\n    if (cc[1 + IMM2_SIZE] >= OP_CRSTAR && cc[1 + IMM2_SIZE] <= OP_CRPOSRANGE)\n      cc = compile_ref_iterator_matchingpath(common, cc, parent);\n    else\n      {\n      compile_ref_matchingpath(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE, FALSE);\n      cc += 1 + IMM2_SIZE;\n      }\n    break;\n\n    case OP_DNREF:\n    case OP_DNREFI:\n    if (cc[1 + 2 * IMM2_SIZE] >= OP_CRSTAR && cc[1 + 2 * IMM2_SIZE] <= OP_CRPOSRANGE)\n      cc = compile_ref_iterator_matchingpath(common, cc, parent);\n    else\n      {\n      compile_dnref_search(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n      compile_ref_matchingpath(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE, FALSE);\n      cc += 1 + 2 * IMM2_SIZE;\n      }\n    break;\n\n    case OP_RECURSE:\n    cc = compile_recurse_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    cc = compile_callout_matchingpath(common, cc, parent);\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    PUSH_BACKTRACK_NOVALUE(sizeof(assert_backtrack), cc);\n    cc = compile_assert_matchingpath(common, cc, BACKTRACK_AS(assert_backtrack), FALSE);\n    break;\n\n    case OP_BRAMINZERO:\n    PUSH_BACKTRACK_NOVALUE(sizeof(braminzero_backtrack), cc);\n    cc = bracketend(cc + 1);\n    if (*(cc - 1 - LINK_SIZE) != OP_KETRMIN)\n      {\n      allocate_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n    else\n      {\n      allocate_stack(common, 2);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), STR_PTR, 0);\n      }\n    BACKTRACK_AS(braminzero_backtrack)->matchingpath = LABEL();\n    count_match(common);\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRA:\n    case OP_CBRA:\n    case OP_COND:\n    case OP_SBRA:\n    case OP_SCBRA:\n    case OP_SCOND:\n    cc = compile_bracket_matchingpath(common, cc, parent);\n    break;\n\n    case OP_BRAZERO:\n    if (cc[1] > OP_ASSERTBACK_NOT)\n      cc = compile_bracket_matchingpath(common, cc, parent);\n    else\n      {\n      PUSH_BACKTRACK_NOVALUE(sizeof(assert_backtrack), cc);\n      cc = compile_assert_matchingpath(common, cc, BACKTRACK_AS(assert_backtrack), FALSE);\n      }\n    break;\n\n    case OP_BRAPOS:\n    case OP_CBRAPOS:\n    case OP_SBRAPOS:\n    case OP_SCBRAPOS:\n    case OP_BRAPOSZERO:\n    cc = compile_bracketpos_matchingpath(common, cc, parent);\n    break;\n\n    case OP_MARK:\n    PUSH_BACKTRACK_NOVALUE(sizeof(backtrack_common), cc);\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n    allocate_stack(common, common->has_skip_arg ? 5 : 1);\n    if (HAS_VIRTUAL_REGISTERS)\n      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(common->has_skip_arg ? 4 : 0), TMP2, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)(cc + 2));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), TMP2, 0);\n    if (common->has_skip_arg)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, type_mark);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), SLJIT_IMM, (sljit_sw)(cc + 2));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(3), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_PRUNE_ARG:\n    case OP_SKIP:\n    case OP_SKIP_ARG:\n    case OP_THEN:\n    case OP_THEN_ARG:\n    case OP_COMMIT:\n    case OP_COMMIT_ARG:\n    cc = compile_control_verb_matchingpath(common, cc, parent);\n    break;\n\n    case OP_FAIL:\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    cc = compile_fail_accept_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CLOSE:\n    cc = compile_close_matchingpath(common, cc);\n    break;\n\n    case OP_SKIPZERO:\n    cc = bracketend(cc + 1);\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    return;\n    }\n  if (cc == NULL)\n    return;\n  }\n\nif (has_then_trap)\n  {\n  /* Head item on backtrack. */\n  PUSH_BACKTRACK_NOVALUE(sizeof(then_trap_backtrack), cc);\n  BACKTRACK_AS(then_trap_backtrack)->common.cc = then_trap_opcode;\n  BACKTRACK_AS(then_trap_backtrack)->then_trap = common->then_trap;\n  common->then_trap = save_then_trap;\n  }\nSLJIT_ASSERT(cc == ccend);\n}\n\n#undef PUSH_BACKTRACK\n#undef PUSH_BACKTRACK_NOVALUE\n#undef BACKTRACK_AS\n\n#define COMPILE_BACKTRACKINGPATH(current) \\\n  do \\\n    { \\\n    compile_backtrackingpath(common, (current)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return; \\\n    } \\\n  while (0)\n\n#define CURRENT_AS(type) ((type *)current)\n\nstatic void compile_iterator_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR type;\nsljit_u32 max = 0, exact;\nstruct sljit_label *label = NULL;\nstruct sljit_jump *jump = NULL;\njump_list *jumplist = NULL;\nPCRE2_SPTR end;\nint private_data_ptr = PRIVATE_DATA(cc);\nint base = (private_data_ptr == 0) ? SLJIT_MEM1(STACK_TOP) : SLJIT_MEM1(SLJIT_SP);\nint offset0 = (private_data_ptr == 0) ? STACK(0) : private_data_ptr;\nint offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + (int)sizeof(sljit_sw);\n\ncc = get_iterator_parameters(common, cc, &opcode, &type, &max, &exact, &end);\n\nswitch(opcode)\n  {\n  case OP_STAR:\n  case OP_UPTO:\n  if (type == OP_ANYNL || type == OP_EXTUNI)\n    {\n    SLJIT_ASSERT(private_data_ptr == 0);\n    set_jumps(CURRENT_AS(char_iterator_backtrack)->u.backtracks, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n    }\n  else\n    {\n    if (CURRENT_AS(char_iterator_backtrack)->u.charpos.enabled)\n      {\n      OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      OP1(SLJIT_MOV, TMP2, 0, base, offset1);\n      OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n      label = LABEL();\n      OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      if (CURRENT_AS(char_iterator_backtrack)->u.charpos.othercasebit != 0)\n        OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, CURRENT_AS(char_iterator_backtrack)->u.charpos.othercasebit);\n      CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CURRENT_AS(char_iterator_backtrack)->u.charpos.chr, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n      move_back(common, NULL, TRUE);\n      CMPTO(SLJIT_GREATER, STR_PTR, 0, TMP2, 0, label);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, base, offset1);\n      move_back(common, NULL, TRUE);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n      }\n    JUMPHERE(jump);\n    if (private_data_ptr == 0)\n      free_stack(common, 2);\n    }\n  break;\n\n  case OP_MINSTAR:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  set_jumps(jumplist, LABEL());\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_MINUPTO:\n  OP1(SLJIT_MOV, TMP1, 0, base, offset1);\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n  add_jump(compiler, &jumplist, JUMP(SLJIT_ZERO));\n\n  OP1(SLJIT_MOV, base, offset1, TMP1, 0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n\n  set_jumps(jumplist, LABEL());\n  if (private_data_ptr == 0)\n    free_stack(common, 2);\n  break;\n\n  case OP_QUERY:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(CURRENT_AS(char_iterator_backtrack)->u.backtracks, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  JUMPHERE(jump);\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_MINQUERY:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  jump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  set_jumps(jumplist, LABEL());\n  JUMPHERE(jump);\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_EXACT:\n  case OP_POSSTAR:\n  case OP_POSQUERY:\n  case OP_POSUPTO:\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nset_jumps(current->topbacktracks, LABEL());\n}\n\nstatic SLJIT_INLINE void compile_ref_iterator_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nPCRE2_UCHAR type;\n\ntype = cc[ref ? 1 + IMM2_SIZE : 1 + 2 * IMM2_SIZE];\n\nif ((type & 0x1) == 0)\n  {\n  /* Maximize case. */\n  set_jumps(current->topbacktracks, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(ref_iterator_backtrack)->matchingpath);\n  return;\n  }\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nCMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(ref_iterator_backtrack)->matchingpath);\nset_jumps(current->topbacktracks, LABEL());\nfree_stack(common, ref ? 2 : 3);\n}\n\nstatic SLJIT_INLINE void compile_recurse_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nrecurse_entry *entry;\n\nif (!CURRENT_AS(recurse_backtrack)->inlined_pattern)\n  {\n  entry = CURRENT_AS(recurse_backtrack)->entry;\n  if (entry->backtrack_label == NULL)\n    add_jump(compiler, &entry->backtrack_calls, JUMP(SLJIT_FAST_CALL));\n  else\n    JUMPTO(SLJIT_FAST_CALL, entry->backtrack_label);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, CURRENT_AS(recurse_backtrack)->matchingpath);\n  }\nelse\n  compile_backtrackingpath(common, current->top);\n\nset_jumps(current->topbacktracks, LABEL());\n}\n\nstatic void compile_assert_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nPCRE2_UCHAR bra = OP_BRA;\nstruct sljit_jump *brajump = NULL;\n\nSLJIT_ASSERT(*cc != OP_BRAMINZERO);\nif (*cc == OP_BRAZERO)\n  {\n  bra = *cc;\n  cc++;\n  }\n\nif (bra == OP_BRAZERO)\n  {\n  SLJIT_ASSERT(current->topbacktracks == NULL);\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  }\n\nif (CURRENT_AS(assert_backtrack)->framesize < 0)\n  {\n  set_jumps(current->topbacktracks, LABEL());\n\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(assert_backtrack)->matchingpath);\n    free_stack(common, 1);\n    }\n  return;\n  }\n\nif (bra == OP_BRAZERO)\n  {\n  if (*cc == OP_ASSERT_NOT || *cc == OP_ASSERTBACK_NOT)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(assert_backtrack)->matchingpath);\n    free_stack(common, 1);\n    return;\n    }\n  free_stack(common, 1);\n  brajump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  }\n\nif (*cc == OP_ASSERT || *cc == OP_ASSERTBACK)\n  {\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(assert_backtrack)->private_data_ptr);\n  add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n  OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(assert_backtrack)->framesize - 1) * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(assert_backtrack)->private_data_ptr, TMP1, 0);\n\n  set_jumps(current->topbacktracks, LABEL());\n  }\nelse\n  set_jumps(current->topbacktracks, LABEL());\n\nif (bra == OP_BRAZERO)\n  {\n  /* We know there is enough place on the stack. */\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(assert_backtrack)->matchingpath);\n  JUMPHERE(brajump);\n  }\n}\n\nstatic void compile_bracket_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nint opcode, stacksize, alt_count, alt_max;\nint offset = 0;\nint private_data_ptr = CURRENT_AS(bracket_backtrack)->private_data_ptr;\nint repeat_ptr = 0, repeat_type = 0, repeat_count = 0;\nPCRE2_SPTR cc = current->cc;\nPCRE2_SPTR ccbegin;\nPCRE2_SPTR ccprev;\nPCRE2_UCHAR bra = OP_BRA;\nPCRE2_UCHAR ket;\nassert_backtrack *assert;\nBOOL has_alternatives;\nBOOL needs_control_head = FALSE;\nstruct sljit_jump *brazero = NULL;\nstruct sljit_jump *next_alt = NULL;\nstruct sljit_jump *once = NULL;\nstruct sljit_jump *cond = NULL;\nstruct sljit_label *rmin_label = NULL;\nstruct sljit_label *exact_label = NULL;\nstruct sljit_put_label *put_label = NULL;\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  bra = *cc;\n  cc++;\n  }\n\nopcode = *cc;\nccbegin = bracketend(cc) - 1 - LINK_SIZE;\nket = *ccbegin;\nif (ket == OP_KET && PRIVATE_DATA(ccbegin) != 0)\n  {\n  repeat_ptr = PRIVATE_DATA(ccbegin);\n  repeat_type = PRIVATE_DATA(ccbegin + 2);\n  repeat_count = PRIVATE_DATA(ccbegin + 3);\n  SLJIT_ASSERT(repeat_type != 0 && repeat_count != 0);\n  if (repeat_type == OP_UPTO)\n    ket = OP_KETRMAX;\n  if (repeat_type == OP_MINUPTO)\n    ket = OP_KETRMIN;\n  }\nccbegin = cc;\ncc += GET(cc, 1);\nhas_alternatives = *cc == OP_ALT;\nif (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  has_alternatives = (ccbegin[1 + LINK_SIZE] >= OP_ASSERT && ccbegin[1 + LINK_SIZE] <= OP_ASSERTBACK_NOT) || CURRENT_AS(bracket_backtrack)->u.condfailed != NULL;\nif (opcode == OP_CBRA || opcode == OP_SCBRA)\n  offset = (GET2(ccbegin, 1 + LINK_SIZE)) << 1;\nif (SLJIT_UNLIKELY(opcode == OP_COND) && (*cc == OP_KETRMAX || *cc == OP_KETRMIN))\n  opcode = OP_SCOND;\n\nalt_max = has_alternatives ? no_alternatives(ccbegin) : 0;\n\n/* Decoding the needs_control_head in framesize. */\nif (opcode == OP_ONCE)\n  {\n  needs_control_head = (CURRENT_AS(bracket_backtrack)->u.framesize & 0x1) != 0;\n  CURRENT_AS(bracket_backtrack)->u.framesize >>= 1;\n  }\n\nif (ket != OP_KET && repeat_type != 0)\n  {\n  /* TMP1 is used in OP_KETRMIN below. */\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  if (repeat_type == OP_UPTO)\n    OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0, SLJIT_IMM, 1);\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0);\n  }\n\nif (ket == OP_KETRMAX)\n  {\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    brazero = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n    }\n  }\nelse if (ket == OP_KETRMIN)\n  {\n  if (bra != OP_BRAMINZERO)\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    if (repeat_type != 0)\n      {\n      /* TMP1 was set a few lines above. */\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n      /* Drop STR_PTR for non-greedy plus quantifier. */\n      if (opcode != OP_ONCE)\n        free_stack(common, 1);\n      }\n    else if (opcode >= OP_SBRA || opcode == OP_ONCE)\n      {\n      /* Checking zero-length iteration. */\n      if (opcode != OP_ONCE || CURRENT_AS(bracket_backtrack)->u.framesize < 0)\n        CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n      else\n        {\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n        CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(TMP1), STACK(-CURRENT_AS(bracket_backtrack)->u.framesize - 2), CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n        }\n      /* Drop STR_PTR for non-greedy plus quantifier. */\n      if (opcode != OP_ONCE)\n        free_stack(common, 1);\n      }\n    else\n      JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n    }\n  rmin_label = LABEL();\n  if (repeat_type != 0)\n    OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  }\nelse if (bra == OP_BRAZERO)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  brazero = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n  }\nelse if (repeat_type == OP_EXACT)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  exact_label = LABEL();\n  }\n\nif (offset != 0)\n  {\n  if (common->capture_last_ptr != 0)\n    {\n    SLJIT_ASSERT(common->optimized_cbracket[offset >> 1] == 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, TMP1, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\n    free_stack(common, 3);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP1, 0);\n    }\n  else if (common->optimized_cbracket[offset >> 1] == 0)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    }\n  }\n\nif (SLJIT_UNLIKELY(opcode == OP_ONCE))\n  {\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    {\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n    OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(bracket_backtrack)->u.framesize - 1) * sizeof(sljit_sw));\n    }\n  once = JUMP(SLJIT_JUMP);\n  }\nelse if (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  {\n  if (has_alternatives)\n    {\n    /* Always exactly one alternative. */\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n\n    alt_max = 2;\n    next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n    }\n  }\nelse if (has_alternatives)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n\n  if (alt_max > 3)\n    {\n    sljit_emit_ijump(compiler, SLJIT_JUMP, TMP1, 0);\n\n    SLJIT_ASSERT(CURRENT_AS(bracket_backtrack)->u.matching_put_label);\n    sljit_set_put_label(CURRENT_AS(bracket_backtrack)->u.matching_put_label, LABEL());\n    sljit_emit_op0(compiler, SLJIT_ENDBR);\n    }\n  else\n    next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n  }\n\nCOMPILE_BACKTRACKINGPATH(current->top);\nif (current->topbacktracks)\n  set_jumps(current->topbacktracks, LABEL());\n\nif (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  {\n  /* Conditional block always has at most one alternative. */\n  if (ccbegin[1 + LINK_SIZE] >= OP_ASSERT && ccbegin[1 + LINK_SIZE] <= OP_ASSERTBACK_NOT)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    assert = CURRENT_AS(bracket_backtrack)->u.assert;\n    if (assert->framesize >= 0 && (ccbegin[1 + LINK_SIZE] == OP_ASSERT || ccbegin[1 + LINK_SIZE] == OP_ASSERTBACK))\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (assert->framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr, TMP1, 0);\n      }\n    cond = JUMP(SLJIT_JUMP);\n    set_jumps(CURRENT_AS(bracket_backtrack)->u.assert->condfailed, LABEL());\n    }\n  else if (CURRENT_AS(bracket_backtrack)->u.condfailed != NULL)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    cond = JUMP(SLJIT_JUMP);\n    set_jumps(CURRENT_AS(bracket_backtrack)->u.condfailed, LABEL());\n    }\n  else\n    SLJIT_ASSERT(!has_alternatives);\n  }\n\nif (has_alternatives)\n  {\n  alt_count = 1;\n  do\n    {\n    current->top = NULL;\n    current->topbacktracks = NULL;\n    current->nextbacktracks = NULL;\n    /* Conditional blocks always have an additional alternative, even if it is empty. */\n    if (*cc == OP_ALT)\n      {\n      ccprev = cc + 1 + LINK_SIZE;\n      cc += GET(cc, 1);\n      if (opcode != OP_COND && opcode != OP_SCOND)\n        {\n        if (opcode != OP_ONCE)\n          {\n          if (private_data_ptr != 0)\n            OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n          else\n            OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n          }\n        else\n          OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(needs_control_head ? 1 : 0));\n        }\n      compile_matchingpath(common, ccprev, cc, current);\n      if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n        return;\n\n      if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\n      if (opcode == OP_SCRIPT_RUN)\n        match_script_run_common(common, private_data_ptr, current);\n      }\n\n    /* Instructions after the current alternative is successfully matched. */\n    /* There is a similar code in compile_bracket_matchingpath. */\n    if (opcode == OP_ONCE)\n      match_once_common(common, ket, CURRENT_AS(bracket_backtrack)->u.framesize, private_data_ptr, has_alternatives, needs_control_head);\n\n    stacksize = 0;\n    if (repeat_type == OP_MINUPTO)\n      {\n      /* We need to preserve the counter. TMP2 will be used below. */\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n      stacksize++;\n      }\n    if (ket != OP_KET || bra != OP_BRA)\n      stacksize++;\n    if (offset != 0)\n      {\n      if (common->capture_last_ptr != 0)\n        stacksize++;\n      if (common->optimized_cbracket[offset >> 1] == 0)\n        stacksize += 2;\n      }\n    if (opcode != OP_ONCE)\n      stacksize++;\n\n    if (stacksize > 0)\n      allocate_stack(common, stacksize);\n\n    stacksize = 0;\n    if (repeat_type == OP_MINUPTO)\n      {\n      /* TMP2 was set above. */\n      OP2(SLJIT_SUB, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP2, 0, SLJIT_IMM, 1);\n      stacksize++;\n      }\n\n    if (ket != OP_KET || bra != OP_BRA)\n      {\n      if (ket != OP_KET)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n      stacksize++;\n      }\n\n    if (offset != 0)\n      stacksize = match_capture_common(common, stacksize, offset, private_data_ptr);\n\n    if (opcode != OP_ONCE)\n      {\n      if (alt_max <= 3)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, alt_count);\n      else\n        put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(stacksize));\n      }\n\n    if (offset != 0 && ket == OP_KETRMAX && common->optimized_cbracket[offset >> 1] != 0)\n      {\n      /* If ket is not OP_KETRMAX, this code path is executed after the jump to alternative_matchingpath. */\n      SLJIT_ASSERT(private_data_ptr == OVECTOR(offset + 0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      }\n\n    JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->alternative_matchingpath);\n\n    if (opcode != OP_ONCE)\n      {\n      if (alt_max <= 3)\n        {\n        JUMPHERE(next_alt);\n        alt_count++;\n        if (alt_count < alt_max)\n          {\n          SLJIT_ASSERT(alt_count == 2 && alt_max == 3);\n          next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 1);\n          }\n        }\n      else\n        {\n        sljit_set_put_label(put_label, LABEL());\n        sljit_emit_op0(compiler, SLJIT_ENDBR);\n        }\n      }\n\n    COMPILE_BACKTRACKINGPATH(current->top);\n    if (current->topbacktracks)\n      set_jumps(current->topbacktracks, LABEL());\n    SLJIT_ASSERT(!current->nextbacktracks);\n    }\n  while (*cc == OP_ALT);\n\n  if (cond != NULL)\n    {\n    SLJIT_ASSERT(opcode == OP_COND || opcode == OP_SCOND);\n    assert = CURRENT_AS(bracket_backtrack)->u.assert;\n    if ((ccbegin[1 + LINK_SIZE] == OP_ASSERT_NOT || ccbegin[1 + LINK_SIZE] == OP_ASSERTBACK_NOT) && assert->framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (assert->framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr, TMP1, 0);\n      }\n    JUMPHERE(cond);\n    }\n\n  /* Free the STR_PTR. */\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  }\n\nif (offset != 0)\n  {\n  /* Using both tmp register is better for instruction scheduling. */\n  if (common->optimized_cbracket[offset >> 1] != 0)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  }\nelse if (opcode == OP_ONCE)\n  {\n  cc = ccbegin + GET(ccbegin, 1);\n  stacksize = needs_control_head ? 1 : 0;\n\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    {\n    /* Reset head and drop saved frame. */\n    stacksize += CURRENT_AS(bracket_backtrack)->u.framesize + ((ket != OP_KET || *cc == OP_ALT) ? 2 : 1);\n    }\n  else if (ket == OP_KETRMAX || (*cc == OP_ALT && ket != OP_KETRMIN))\n    {\n    /* The STR_PTR must be released. */\n    stacksize++;\n    }\n\n  if (stacksize > 0)\n    free_stack(common, stacksize);\n\n  JUMPHERE(once);\n  /* Restore previous private_data_ptr */\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-CURRENT_AS(bracket_backtrack)->u.framesize - 1));\n  else if (ket == OP_KETRMIN)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    /* See the comment below. */\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  }\n\nif (repeat_type == OP_EXACT)\n  {\n  OP2(SLJIT_ADD, TMP1, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0);\n  CMPTO(SLJIT_LESS_EQUAL, TMP1, 0, SLJIT_IMM, repeat_count, exact_label);\n  }\nelse if (ket == OP_KETRMAX)\n  {\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  if (bra != OP_BRAZERO)\n    free_stack(common, 1);\n\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->zero_matchingpath);\n    JUMPHERE(brazero);\n    free_stack(common, 1);\n    }\n  }\nelse if (ket == OP_KETRMIN)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  /* OP_ONCE removes everything in case of a backtrack, so we don't\n  need to explicitly release the STR_PTR. The extra release would\n  affect badly the free_stack(2) above. */\n  if (opcode != OP_ONCE)\n    free_stack(common, 1);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, rmin_label);\n  if (opcode == OP_ONCE)\n    free_stack(common, bra == OP_BRAMINZERO ? 2 : 1);\n  else if (bra == OP_BRAMINZERO)\n    free_stack(common, 1);\n  }\nelse if (bra == OP_BRAZERO)\n  {\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->zero_matchingpath);\n  JUMPHERE(brazero);\n  }\n}\n\nstatic SLJIT_INLINE void compile_bracketpos_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nint offset;\nstruct sljit_jump *jump;\n\nif (CURRENT_AS(bracketpos_backtrack)->framesize < 0)\n  {\n  if (*current->cc == OP_CBRAPOS || *current->cc == OP_SCBRAPOS)\n    {\n    offset = (GET2(current->cc, 1 + LINK_SIZE)) << 1;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, TMP1, 0);\n    }\n  set_jumps(current->topbacktracks, LABEL());\n  free_stack(common, CURRENT_AS(bracketpos_backtrack)->stacksize);\n  return;\n  }\n\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(bracketpos_backtrack)->private_data_ptr);\nadd_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\nOP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(bracketpos_backtrack)->framesize - 1) * sizeof(sljit_sw));\n\nif (current->topbacktracks)\n  {\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(current->topbacktracks, LABEL());\n  /* Drop the stack frame. */\n  free_stack(common, CURRENT_AS(bracketpos_backtrack)->stacksize);\n  JUMPHERE(jump);\n  }\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(bracketpos_backtrack)->private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-CURRENT_AS(bracketpos_backtrack)->framesize - 1));\n}\n\nstatic SLJIT_INLINE void compile_braminzero_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nassert_backtrack backtrack;\n\ncurrent->top = NULL;\ncurrent->topbacktracks = NULL;\ncurrent->nextbacktracks = NULL;\nif (current->cc[1] > OP_ASSERTBACK_NOT)\n  {\n  /* Manual call of compile_bracket_matchingpath and compile_bracket_backtrackingpath. */\n  compile_bracket_matchingpath(common, current->cc, current);\n  compile_bracket_backtrackingpath(common, current->top);\n  }\nelse\n  {\n  memset(&backtrack, 0, sizeof(backtrack));\n  backtrack.common.cc = current->cc;\n  backtrack.matchingpath = CURRENT_AS(braminzero_backtrack)->matchingpath;\n  /* Manual call of compile_assert_matchingpath. */\n  compile_assert_matchingpath(common, current->cc, &backtrack, FALSE);\n  }\nSLJIT_ASSERT(!current->nextbacktracks && !current->topbacktracks);\n}\n\nstatic SLJIT_INLINE void compile_control_verb_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_UCHAR opcode = *current->cc;\nstruct sljit_label *loop;\nstruct sljit_jump *jump;\n\nif (opcode == OP_THEN || opcode == OP_THEN_ARG)\n  {\n  if (common->then_trap != NULL)\n    {\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, type_then_trap);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, common->then_trap->start);\n    jump = JUMP(SLJIT_JUMP);\n\n    loop = LABEL();\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    JUMPHERE(jump);\n    CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0, loop);\n    CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0, loop);\n    add_jump(compiler, &common->then_trap->quit, JUMP(SLJIT_JUMP));\n    return;\n    }\n  else if (!common->local_quit_available && common->in_positive_assertion)\n    {\n    add_jump(compiler, &common->positive_assertion_quit, JUMP(SLJIT_JUMP));\n    return;\n    }\n  }\n\nif (common->local_quit_available)\n  {\n  /* Abort match with a fail. */\n  if (common->quit_label == NULL)\n    add_jump(compiler, &common->quit, JUMP(SLJIT_JUMP));\n  else\n    JUMPTO(SLJIT_JUMP, common->quit_label);\n  return;\n  }\n\nif (opcode == OP_SKIP_ARG)\n  {\n  SLJIT_ASSERT(common->control_head_ptr != 0 && TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, (sljit_sw)(current->cc + 2));\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_search_mark));\n\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_R0, 0);\n  add_jump(compiler, &common->reset_match, CMP(SLJIT_NOT_EQUAL, SLJIT_R0, 0, SLJIT_IMM, 0));\n  return;\n  }\n\nif (opcode == OP_SKIP)\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nelse\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_IMM, 0);\nadd_jump(compiler, &common->reset_match, JUMP(SLJIT_JUMP));\n}\n\nstatic SLJIT_INLINE void compile_then_trap_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nint size;\n\nif (CURRENT_AS(then_trap_backtrack)->then_trap)\n  {\n  common->then_trap = CURRENT_AS(then_trap_backtrack)->then_trap;\n  return;\n  }\n\nsize = CURRENT_AS(then_trap_backtrack)->framesize;\nsize = 3 + (size < 0 ? 0 : size);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(size - 3));\nfree_stack(common, size);\njump = JUMP(SLJIT_JUMP);\n\nset_jumps(CURRENT_AS(then_trap_backtrack)->quit, LABEL());\n/* STACK_TOP is set by THEN. */\nif (CURRENT_AS(then_trap_backtrack)->framesize >= 0)\n  {\n  add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(then_trap_backtrack)->framesize - 1) * sizeof(sljit_sw));\n  }\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nfree_stack(common, 3);\n\nJUMPHERE(jump);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP1, 0);\n}\n\nstatic void compile_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nthen_trap_backtrack *save_then_trap = common->then_trap;\n\nwhile (current)\n  {\n  if (current->nextbacktracks != NULL)\n    set_jumps(current->nextbacktracks, LABEL());\n  switch(*current->cc)\n    {\n    case OP_SET_SOM:\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), TMP1, 0);\n    break;\n\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n#endif\n    compile_iterator_backtrackingpath(common, current);\n    break;\n\n    case OP_REF:\n    case OP_REFI:\n    case OP_DNREF:\n    case OP_DNREFI:\n    compile_ref_iterator_backtrackingpath(common, current);\n    break;\n\n    case OP_RECURSE:\n    compile_recurse_backtrackingpath(common, current);\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    compile_assert_backtrackingpath(common, current);\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRA:\n    case OP_CBRA:\n    case OP_COND:\n    case OP_SBRA:\n    case OP_SCBRA:\n    case OP_SCOND:\n    compile_bracket_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAZERO:\n    if (current->cc[1] > OP_ASSERTBACK_NOT)\n      compile_bracket_backtrackingpath(common, current);\n    else\n      compile_assert_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAPOS:\n    case OP_CBRAPOS:\n    case OP_SBRAPOS:\n    case OP_SCBRAPOS:\n    case OP_BRAPOSZERO:\n    compile_bracketpos_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAMINZERO:\n    compile_braminzero_backtrackingpath(common, current);\n    break;\n\n    case OP_MARK:\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(common->has_skip_arg ? 4 : 0));\n    if (common->has_skip_arg)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, common->has_skip_arg ? 5 : 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP1, 0);\n    if (common->has_skip_arg)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP2, 0);\n    break;\n\n    case OP_THEN:\n    case OP_THEN_ARG:\n    case OP_PRUNE:\n    case OP_PRUNE_ARG:\n    case OP_SKIP:\n    case OP_SKIP_ARG:\n    compile_control_verb_backtrackingpath(common, current);\n    break;\n\n    case OP_COMMIT:\n    case OP_COMMIT_ARG:\n    if (!common->local_quit_available)\n      OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n    if (common->quit_label == NULL)\n      add_jump(compiler, &common->quit, JUMP(SLJIT_JUMP));\n    else\n      JUMPTO(SLJIT_JUMP, common->quit_label);\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    case OP_FAIL:\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    set_jumps(current->topbacktracks, LABEL());\n    break;\n\n    case OP_THEN_TRAP:\n    /* A virtual opcode for then traps. */\n    compile_then_trap_backtrackingpath(common, current);\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    break;\n    }\n  current = current->prev;\n  }\ncommon->then_trap = save_then_trap;\n}\n\nstatic SLJIT_INLINE void compile_recurse(compiler_common *common)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = common->start + common->currententry->start;\nPCRE2_SPTR ccbegin = cc + 1 + LINK_SIZE + (*cc == OP_BRA ? 0 : IMM2_SIZE);\nPCRE2_SPTR ccend = bracketend(cc) - (1 + LINK_SIZE);\nBOOL needs_control_head;\nBOOL has_quit;\nBOOL has_accept;\nint private_data_size = get_recurse_data_length(common, ccbegin, ccend, &needs_control_head, &has_quit, &has_accept);\nint alt_count, alt_max, local_size;\nbacktrack_common altbacktrack;\njump_list *match = NULL;\nstruct sljit_jump *next_alt = NULL;\nstruct sljit_jump *accept_exit = NULL;\nstruct sljit_label *quit;\nstruct sljit_put_label *put_label = NULL;\n\n/* Recurse captures then. */\ncommon->then_trap = NULL;\n\nSLJIT_ASSERT(*cc == OP_BRA || *cc == OP_CBRA || *cc == OP_CBRAPOS || *cc == OP_SCBRA || *cc == OP_SCBRAPOS);\n\nalt_max = no_alternatives(cc);\nalt_count = 0;\n\n/* Matching path. */\nSLJIT_ASSERT(common->currententry->entry_label == NULL && common->recursive_head_ptr != 0);\ncommon->currententry->entry_label = LABEL();\nset_jumps(common->currententry->entry_calls, common->currententry->entry_label);\n\nsljit_emit_fast_enter(compiler, TMP2, 0);\ncount_match(common);\n\nlocal_size = (alt_max > 1) ? 2 : 1;\n\n/* (Reversed) stack layout:\n   [private data][return address][optional: str ptr] ... [optional: alternative index][recursive_head_ptr] */\n\nallocate_stack(common, private_data_size + local_size);\n/* Save return address. */\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1), TMP2, 0);\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_copy_from_global, local_size, private_data_size + local_size, has_quit);\n\n/* This variable is saved and restored all time when we enter or exit from a recursive context. */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr, STACK_TOP, 0);\n\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n\nif (alt_max > 1)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\nmemset(&altbacktrack, 0, sizeof(backtrack_common));\ncommon->quit_label = NULL;\ncommon->accept_label = NULL;\ncommon->quit = NULL;\ncommon->accept = NULL;\naltbacktrack.cc = ccbegin;\ncc += GET(cc, 1);\nwhile (1)\n  {\n  altbacktrack.top = NULL;\n  altbacktrack.topbacktracks = NULL;\n\n  if (altbacktrack.cc != ccbegin)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  compile_matchingpath(common, altbacktrack.cc, cc, &altbacktrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return;\n\n  allocate_stack(common, (alt_max > 1 || has_accept) ? 2 : 1);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n\n  if (alt_max > 1 || has_accept)\n    {\n    if (alt_max > 3)\n      put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(1));\n    else\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, alt_count);\n    }\n\n  add_jump(compiler, &match, JUMP(SLJIT_JUMP));\n\n  if (alt_count == 0)\n    {\n    /* Backtracking path entry. */\n    SLJIT_ASSERT(common->currententry->backtrack_label == NULL);\n    common->currententry->backtrack_label = LABEL();\n    set_jumps(common->currententry->backtrack_calls, common->currententry->backtrack_label);\n\n    sljit_emit_fast_enter(compiler, TMP1, 0);\n\n    if (has_accept)\n      accept_exit = CMP(SLJIT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, -1);\n\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    /* Save return address. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), STACK(local_size - 1), TMP1, 0);\n\n    copy_recurse_data(common, ccbegin, ccend, recurse_swap_global, local_size, private_data_size + local_size, has_quit);\n\n    if (alt_max > 1)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n      free_stack(common, 2);\n\n      if (alt_max > 3)\n        {\n        sljit_emit_ijump(compiler, SLJIT_JUMP, TMP1, 0);\n        sljit_set_put_label(put_label, LABEL());\n        sljit_emit_op0(compiler, SLJIT_ENDBR);\n        }\n      else\n        next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, has_accept ? 2 : 1);\n    }\n  else if (alt_max > 3)\n    {\n    sljit_set_put_label(put_label, LABEL());\n    sljit_emit_op0(compiler, SLJIT_ENDBR);\n    }\n  else\n    {\n    JUMPHERE(next_alt);\n    if (alt_count + 1 < alt_max)\n      {\n      SLJIT_ASSERT(alt_count == 1 && alt_max == 3);\n      next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 1);\n      }\n    }\n\n  alt_count++;\n\n  compile_backtrackingpath(common, altbacktrack.top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return;\n  set_jumps(altbacktrack.topbacktracks, LABEL());\n\n  if (*cc != OP_ALT)\n    break;\n\n  altbacktrack.cc = cc + 1 + LINK_SIZE;\n  cc += GET(cc, 1);\n  }\n\n/* No alternative is matched. */\n\nquit = LABEL();\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_copy_private_to_global, local_size, private_data_size + local_size, has_quit);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1));\nfree_stack(common, private_data_size + local_size);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n\nif (common->quit != NULL)\n  {\n  SLJIT_ASSERT(has_quit);\n\n  set_jumps(common->quit, LABEL());\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n  copy_recurse_data(common, ccbegin, ccend, recurse_copy_shared_to_global, local_size, private_data_size + local_size, has_quit);\n  JUMPTO(SLJIT_JUMP, quit);\n  }\n\nif (has_accept)\n  {\n  JUMPHERE(accept_exit);\n  free_stack(common, 2);\n\n  /* Save return address. */\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1), TMP1, 0);\n\n  copy_recurse_data(common, ccbegin, ccend, recurse_copy_kept_shared_to_global, local_size, private_data_size + local_size, has_quit);\n\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1));\n  free_stack(common, private_data_size + local_size);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n  OP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n  }\n\nif (common->accept != NULL)\n  {\n  SLJIT_ASSERT(has_accept);\n\n  set_jumps(common->accept, LABEL());\n\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n  OP1(SLJIT_MOV, TMP2, 0, STACK_TOP, 0);\n\n  allocate_stack(common, 2);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, -1);\n  }\n\nset_jumps(match, LABEL());\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_swap_global, local_size, private_data_size + local_size, has_quit);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), STACK(local_size - 1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n}\n\n#undef COMPILE_BACKTRACKINGPATH\n#undef CURRENT_AS\n\n#define PUBLIC_JIT_COMPILE_CONFIGURATION_OPTIONS \\\n  (PCRE2_JIT_INVALID_UTF)\n\nstatic int jit_compile(pcre2_code *code, sljit_u32 mode)\n{\npcre2_real_code *re = (pcre2_real_code *)code;\nstruct sljit_compiler *compiler;\nbacktrack_common rootbacktrack;\ncompiler_common common_data;\ncompiler_common *common = &common_data;\nconst sljit_u8 *tables = re->tables;\nvoid *allocator_data = &re->memctl;\nint private_data_size;\nPCRE2_SPTR ccend;\nexecutable_functions *functions;\nvoid *executable_func;\nsljit_uw executable_size;\nsljit_uw total_length;\nstruct sljit_label *mainloop_label = NULL;\nstruct sljit_label *continue_match_label;\nstruct sljit_label *empty_match_found_label = NULL;\nstruct sljit_label *empty_match_backtrack_label = NULL;\nstruct sljit_label *reset_match_label;\nstruct sljit_label *quit_label;\nstruct sljit_jump *jump;\nstruct sljit_jump *minlength_check_failed = NULL;\nstruct sljit_jump *empty_match = NULL;\nstruct sljit_jump *end_anchor_failed = NULL;\njump_list *reqcu_not_found = NULL;\n\nSLJIT_ASSERT(tables);\n\n#if HAS_VIRTUAL_REGISTERS == 1\nSLJIT_ASSERT(sljit_get_register_index(TMP3) < 0 && sljit_get_register_index(ARGUMENTS) < 0 && sljit_get_register_index(RETURN_ADDR) < 0);\n#elif HAS_VIRTUAL_REGISTERS == 0\nSLJIT_ASSERT(sljit_get_register_index(TMP3) >= 0 && sljit_get_register_index(ARGUMENTS) >= 0 && sljit_get_register_index(RETURN_ADDR) >= 0);\n#else\n#error \"Invalid value for HAS_VIRTUAL_REGISTERS\"\n#endif\n\nmemset(&rootbacktrack, 0, sizeof(backtrack_common));\nmemset(common, 0, sizeof(compiler_common));\ncommon->re = re;\ncommon->name_table = (PCRE2_SPTR)((uint8_t *)re + sizeof(pcre2_real_code));\nrootbacktrack.cc = common->name_table + re->name_count * re->name_entry_size;\n\n#ifdef SUPPORT_UNICODE\ncommon->invalid_utf = (mode & PCRE2_JIT_INVALID_UTF) != 0;\n#endif /* SUPPORT_UNICODE */\nmode &= ~PUBLIC_JIT_COMPILE_CONFIGURATION_OPTIONS;\n\ncommon->start = rootbacktrack.cc;\ncommon->read_only_data_head = NULL;\ncommon->fcc = tables + fcc_offset;\ncommon->lcc = (sljit_sw)(tables + lcc_offset);\ncommon->mode = mode;\ncommon->might_be_empty = (re->minlength == 0) || (re->flags & PCRE2_MATCH_EMPTY);\ncommon->allow_empty_partial = (re->max_lookbehind > 0) || (re->flags & PCRE2_MATCH_EMPTY);\ncommon->nltype = NLTYPE_FIXED;\nswitch(re->newline_convention)\n  {\n  case PCRE2_NEWLINE_CR: common->newline = CHAR_CR; break;\n  case PCRE2_NEWLINE_LF: common->newline = CHAR_NL; break;\n  case PCRE2_NEWLINE_CRLF: common->newline = (CHAR_CR << 8) | CHAR_NL; break;\n  case PCRE2_NEWLINE_ANY: common->newline = (CHAR_CR << 8) | CHAR_NL; common->nltype = NLTYPE_ANY; break;\n  case PCRE2_NEWLINE_ANYCRLF: common->newline = (CHAR_CR << 8) | CHAR_NL; common->nltype = NLTYPE_ANYCRLF; break;\n  case PCRE2_NEWLINE_NUL: common->newline = CHAR_NUL; break;\n  default: return PCRE2_ERROR_INTERNAL;\n  }\ncommon->nlmax = READ_CHAR_MAX;\ncommon->nlmin = 0;\nif (re->bsr_convention == PCRE2_BSR_UNICODE)\n  common->bsr_nltype = NLTYPE_ANY;\nelse if (re->bsr_convention == PCRE2_BSR_ANYCRLF)\n  common->bsr_nltype = NLTYPE_ANYCRLF;\nelse\n  {\n#ifdef BSR_ANYCRLF\n  common->bsr_nltype = NLTYPE_ANYCRLF;\n#else\n  common->bsr_nltype = NLTYPE_ANY;\n#endif\n  }\ncommon->bsr_nlmax = READ_CHAR_MAX;\ncommon->bsr_nlmin = 0;\ncommon->endonly = (re->overall_options & PCRE2_DOLLAR_ENDONLY) != 0;\ncommon->ctypes = (sljit_sw)(tables + ctypes_offset);\ncommon->name_count = re->name_count;\ncommon->name_entry_size = re->name_entry_size;\ncommon->unset_backref = (re->overall_options & PCRE2_MATCH_UNSET_BACKREF) != 0;\ncommon->alt_circumflex = (re->overall_options & PCRE2_ALT_CIRCUMFLEX) != 0;\n#ifdef SUPPORT_UNICODE\n/* PCRE_UTF[16|32] have the same value as PCRE_UTF8. */\ncommon->utf = (re->overall_options & PCRE2_UTF) != 0;\ncommon->ucp = (re->overall_options & PCRE2_UCP) != 0;\nif (common->utf)\n  {\n  if (common->nltype == NLTYPE_ANY)\n    common->nlmax = 0x2029;\n  else if (common->nltype == NLTYPE_ANYCRLF)\n    common->nlmax = (CHAR_CR > CHAR_NL) ? CHAR_CR : CHAR_NL;\n  else\n    {\n    /* We only care about the first newline character. */\n    common->nlmax = common->newline & 0xff;\n    }\n\n  if (common->nltype == NLTYPE_FIXED)\n    common->nlmin = common->newline & 0xff;\n  else\n    common->nlmin = (CHAR_CR < CHAR_NL) ? CHAR_CR : CHAR_NL;\n\n  if (common->bsr_nltype == NLTYPE_ANY)\n    common->bsr_nlmax = 0x2029;\n  else\n    common->bsr_nlmax = (CHAR_CR > CHAR_NL) ? CHAR_CR : CHAR_NL;\n  common->bsr_nlmin = (CHAR_CR < CHAR_NL) ? CHAR_CR : CHAR_NL;\n  }\nelse\n  common->invalid_utf = FALSE;\n#endif /* SUPPORT_UNICODE */\nccend = bracketend(common->start);\n\n/* Calculate the local space size on the stack. */\ncommon->ovector_start = LIMIT_MATCH + sizeof(sljit_sw);\ncommon->optimized_cbracket = (sljit_u8 *)SLJIT_MALLOC(re->top_bracket + 1, allocator_data);\nif (!common->optimized_cbracket)\n  return PCRE2_ERROR_NOMEMORY;\n#if defined DEBUG_FORCE_UNOPTIMIZED_CBRAS && DEBUG_FORCE_UNOPTIMIZED_CBRAS == 1\nmemset(common->optimized_cbracket, 0, re->top_bracket + 1);\n#else\nmemset(common->optimized_cbracket, 1, re->top_bracket + 1);\n#endif\n\nSLJIT_ASSERT(*common->start == OP_BRA && ccend[-(1 + LINK_SIZE)] == OP_KET);\n#if defined DEBUG_FORCE_UNOPTIMIZED_CBRAS && DEBUG_FORCE_UNOPTIMIZED_CBRAS == 2\ncommon->capture_last_ptr = common->ovector_start;\ncommon->ovector_start += sizeof(sljit_sw);\n#endif\nif (!check_opcode_types(common, common->start, ccend))\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\n/* Checking flags and updating ovector_start. */\nif (mode == PCRE2_JIT_COMPLETE && (re->flags & PCRE2_LASTSET) != 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n  {\n  common->req_char_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\nif (mode != PCRE2_JIT_COMPLETE)\n  {\n  common->start_used_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  if (mode == PCRE2_JIT_PARTIAL_SOFT)\n    {\n    common->hit_start = common->ovector_start;\n    common->ovector_start += sizeof(sljit_sw);\n    }\n  }\nif ((re->overall_options & (PCRE2_FIRSTLINE | PCRE2_USE_OFFSET_LIMIT)) != 0)\n  {\n  common->match_end_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\ncommon->control_head_ptr = 1;\n#endif\nif (common->control_head_ptr != 0)\n  {\n  common->control_head_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\nif (common->has_set_som)\n  {\n  /* Saving the real start pointer is necessary. */\n  common->start_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\n\n/* Aligning ovector to even number of sljit words. */\nif ((common->ovector_start & sizeof(sljit_sw)) != 0)\n  common->ovector_start += sizeof(sljit_sw);\n\nif (common->start_ptr == 0)\n  common->start_ptr = OVECTOR(0);\n\n/* Capturing brackets cannot be optimized if callouts are allowed. */\nif (common->capture_last_ptr != 0)\n  memset(common->optimized_cbracket, 0, re->top_bracket + 1);\n\nSLJIT_ASSERT(!(common->req_char_ptr != 0 && common->start_used_ptr != 0));\ncommon->cbra_ptr = OVECTOR_START + (re->top_bracket + 1) * 2 * sizeof(sljit_sw);\n\ntotal_length = ccend - common->start;\ncommon->private_data_ptrs = (sljit_s32 *)SLJIT_MALLOC(total_length * (sizeof(sljit_s32) + (common->has_then ? 1 : 0)), allocator_data);\nif (!common->private_data_ptrs)\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\nmemset(common->private_data_ptrs, 0, total_length * sizeof(sljit_s32));\n\nprivate_data_size = common->cbra_ptr + (re->top_bracket + 1) * sizeof(sljit_sw);\n\nif ((re->overall_options & PCRE2_ANCHORED) == 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0 && !common->has_skip_in_assert_back)\n  detect_early_fail(common, common->start, &private_data_size, 0, 0, TRUE);\n\nset_private_data_ptrs(common, &private_data_size, ccend);\n\nSLJIT_ASSERT(common->early_fail_start_ptr <= common->early_fail_end_ptr);\n\nif (private_data_size > SLJIT_MAX_LOCAL_SIZE)\n  {\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nif (common->has_then)\n  {\n  common->then_offsets = (sljit_u8 *)(common->private_data_ptrs + total_length);\n  memset(common->then_offsets, 0, total_length);\n  set_then_offsets(common, common->start, NULL);\n  }\n\ncompiler = sljit_create_compiler(allocator_data, NULL);\nif (!compiler)\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\ncommon->compiler = compiler;\n\n/* Main pcre2_jit_exec entry. */\nsljit_emit_enter(compiler, 0, SLJIT_ARGS1(W, W), 5, 5, 0, 0, private_data_size);\n\n/* Register init. */\nreset_ovector(common, (re->top_bracket + 1) * 2);\nif (common->req_char_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr, SLJIT_R0, 0);\n\nOP1(SLJIT_MOV, ARGUMENTS, 0, SLJIT_S0, 0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_S0, 0);\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\nOP1(SLJIT_MOV, STR_END, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, end));\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, stack));\nOP1(SLJIT_MOV_U32, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, limit_match));\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(struct sljit_stack, end));\nOP1(SLJIT_MOV, STACK_LIMIT, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(struct sljit_stack, start));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LIMIT_MATCH, TMP1, 0);\n\nif (common->early_fail_start_ptr < common->early_fail_end_ptr)\n  reset_early_fail(common);\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1);\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, SLJIT_IMM, 0);\nif (common->control_head_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n\n/* Main part of the matching */\nif ((re->overall_options & PCRE2_ANCHORED) == 0)\n  {\n  mainloop_label = mainloop_entry(common);\n  continue_match_label = LABEL();\n  /* Forward search if possible. */\n  if ((re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n    {\n    if (mode == PCRE2_JIT_COMPLETE && fast_forward_first_n_chars(common))\n      ;\n    else if ((re->flags & PCRE2_FIRSTSET) != 0)\n      fast_forward_first_char(common);\n    else if ((re->flags & PCRE2_STARTLINE) != 0)\n      fast_forward_newline(common);\n    else if ((re->flags & PCRE2_FIRSTMAPSET) != 0)\n      fast_forward_start_bits(common);\n    }\n  }\nelse\n  continue_match_label = LABEL();\n\nif (mode == PCRE2_JIT_COMPLETE && re->minlength > 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n  {\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(re->minlength));\n  minlength_check_failed = CMP(SLJIT_GREATER, TMP2, 0, STR_END, 0);\n  }\nif (common->req_char_ptr != 0)\n  reqcu_not_found = search_requested_char(common, (PCRE2_UCHAR)(re->last_codeunit), (re->flags & PCRE2_LASTCASELESS) != 0, (re->flags & PCRE2_FIRSTSET) != 0);\n\n/* Store the current STR_PTR in OVECTOR(0). */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), STR_PTR, 0);\n/* Copy the limit of allowed recursions. */\nOP1(SLJIT_MOV, COUNT_MATCH, 0, SLJIT_MEM1(SLJIT_SP), LIMIT_MATCH);\nif (common->capture_last_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, 0);\nif (common->fast_forward_bc_ptr != NULL)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), PRIVATE_DATA(common->fast_forward_bc_ptr + 1) >> 3, STR_PTR, 0);\n\nif (common->start_ptr != OVECTOR(0))\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_ptr, STR_PTR, 0);\n\n/* Copy the beginning of the string. */\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  jump = CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\nelse if (mode == PCRE2_JIT_PARTIAL_HARD)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n\ncompile_matchingpath(common, common->start, ccend, &rootbacktrack);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  {\n  sljit_free_compiler(compiler);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nif ((re->overall_options & PCRE2_ENDANCHORED) != 0)\n  end_anchor_failed = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0);\n\nif (common->might_be_empty)\n  {\n  empty_match = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n  empty_match_found_label = LABEL();\n  }\n\ncommon->accept_label = LABEL();\nif (common->accept != NULL)\n  set_jumps(common->accept, common->accept_label);\n\n/* This means we have a match. Update the ovector. */\ncopy_ovector(common, re->top_bracket + 1);\ncommon->quit_label = common->abort_label = LABEL();\nif (common->quit != NULL)\n  set_jumps(common->quit, common->quit_label);\nif (common->abort != NULL)\n  set_jumps(common->abort, common->abort_label);\nif (minlength_check_failed != NULL)\n  SET_LABEL(minlength_check_failed, common->abort_label);\n\nsljit_emit_op0(compiler, SLJIT_SKIP_FRAMES_BEFORE_RETURN);\nsljit_emit_return(compiler, SLJIT_MOV, SLJIT_RETURN_REG, 0);\n\nif (common->failed_match != NULL)\n  {\n  SLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE);\n  set_jumps(common->failed_match, LABEL());\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  JUMPTO(SLJIT_JUMP, common->abort_label);\n  }\n\nif ((re->overall_options & PCRE2_ENDANCHORED) != 0)\n  JUMPHERE(end_anchor_failed);\n\nif (mode != PCRE2_JIT_COMPLETE)\n  {\n  common->partialmatchlabel = LABEL();\n  set_jumps(common->partialmatch, common->partialmatchlabel);\n  return_with_partial_match(common, common->quit_label);\n  }\n\nif (common->might_be_empty)\n  empty_match_backtrack_label = LABEL();\ncompile_backtrackingpath(common, rootbacktrack.top);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  {\n  sljit_free_compiler(compiler);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nSLJIT_ASSERT(rootbacktrack.prev == NULL);\nreset_match_label = LABEL();\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  /* Update hit_start only in the first time. */\n  jump = CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, TMP1, 0);\n  JUMPHERE(jump);\n  }\n\n/* Check we have remaining characters. */\nif ((re->overall_options & PCRE2_ANCHORED) == 0 && common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  }\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP),\n    (common->fast_forward_bc_ptr != NULL) ? (PRIVATE_DATA(common->fast_forward_bc_ptr + 1) >> 3) : common->start_ptr);\n\nif ((re->overall_options & PCRE2_ANCHORED) == 0)\n  {\n  if (common->ff_newline_shortcut != NULL)\n    {\n    /* There cannot be more newlines if PCRE2_FIRSTLINE is set. */\n    if ((re->overall_options & PCRE2_FIRSTLINE) == 0)\n      {\n      if (common->match_end_ptr != 0)\n        {\n        OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n        OP1(SLJIT_MOV, STR_END, 0, TMP1, 0);\n        CMPTO(SLJIT_LESS, STR_PTR, 0, TMP1, 0, common->ff_newline_shortcut);\n        OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n        }\n      else\n        CMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, common->ff_newline_shortcut);\n      }\n    }\n  else\n    CMPTO(SLJIT_LESS, STR_PTR, 0, (common->match_end_ptr == 0) ? STR_END : TMP1, 0, mainloop_label);\n  }\n\n/* No more remaining characters. */\nif (reqcu_not_found != NULL)\n  set_jumps(reqcu_not_found, LABEL());\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1, common->partialmatchlabel);\n\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\nflush_stubs(common);\n\nif (common->might_be_empty)\n  {\n  JUMPHERE(empty_match);\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options));\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY);\n  JUMPTO(SLJIT_NOT_ZERO, empty_match_backtrack_label);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY_ATSTART);\n  JUMPTO(SLJIT_ZERO, empty_match_found_label);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n  CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, empty_match_found_label);\n  JUMPTO(SLJIT_JUMP, empty_match_backtrack_label);\n  }\n\ncommon->fast_forward_bc_ptr = NULL;\ncommon->early_fail_start_ptr = 0;\ncommon->early_fail_end_ptr = 0;\ncommon->currententry = common->entries;\ncommon->local_quit_available = TRUE;\nquit_label = common->quit_label;\nwhile (common->currententry != NULL)\n  {\n  /* Might add new entries. */\n  compile_recurse(common);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    sljit_free_compiler(compiler);\n    SLJIT_FREE(common->optimized_cbracket, allocator_data);\n    SLJIT_FREE(common->private_data_ptrs, allocator_data);\n    PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n    return PCRE2_ERROR_NOMEMORY;\n    }\n  flush_stubs(common);\n  common->currententry = common->currententry->next;\n  }\ncommon->local_quit_available = FALSE;\ncommon->quit_label = quit_label;\n\n/* Allocating stack, returns with PCRE_ERROR_JIT_STACKLIMIT if fails. */\n/* This is a (really) rare case. */\nset_jumps(common->stackalloc, LABEL());\n/* RETURN_ADDR is not a saved register. */\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, STR_PTR, 0);\nOP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\nOP2(SLJIT_SUB, SLJIT_R1, 0, STACK_LIMIT, 0, SLJIT_IMM, STACK_GROWTH_RATE);\nOP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, stack));\nOP1(SLJIT_MOV, STACK_LIMIT, 0, TMP2, 0);\n\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(sljit_stack_resize));\n\njump = CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\nOP1(SLJIT_MOV, TMP2, 0, STACK_LIMIT, 0);\nOP1(SLJIT_MOV, STACK_LIMIT, 0, SLJIT_RETURN_REG, 0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS1);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n/* Allocation failed. */\nJUMPHERE(jump);\n/* We break the return address cache here, but this is a really rare case. */\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_JIT_STACKLIMIT);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\n/* Call limit reached. */\nset_jumps(common->calllimit, LABEL());\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_MATCHLIMIT);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\nif (common->revertframes != NULL)\n  {\n  set_jumps(common->revertframes, LABEL());\n  do_revertframes(common);\n  }\nif (common->wordboundary != NULL)\n  {\n  set_jumps(common->wordboundary, LABEL());\n  check_wordboundary(common);\n  }\nif (common->anynewline != NULL)\n  {\n  set_jumps(common->anynewline, LABEL());\n  check_anynewline(common);\n  }\nif (common->hspace != NULL)\n  {\n  set_jumps(common->hspace, LABEL());\n  check_hspace(common);\n  }\nif (common->vspace != NULL)\n  {\n  set_jumps(common->vspace, LABEL());\n  check_vspace(common);\n  }\nif (common->casefulcmp != NULL)\n  {\n  set_jumps(common->casefulcmp, LABEL());\n  do_casefulcmp(common);\n  }\nif (common->caselesscmp != NULL)\n  {\n  set_jumps(common->caselesscmp, LABEL());\n  do_caselesscmp(common);\n  }\nif (common->reset_match != NULL)\n  {\n  set_jumps(common->reset_match, LABEL());\n  do_reset_match(common, (re->top_bracket + 1) * 2);\n  CMPTO(SLJIT_GREATER, STR_PTR, 0, TMP1, 0, continue_match_label);\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP1, 0);\n  JUMPTO(SLJIT_JUMP, reset_match_label);\n  }\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utfreadchar != NULL)\n  {\n  set_jumps(common->utfreadchar, LABEL());\n  do_utfreadchar(common);\n  }\nif (common->utfreadtype8 != NULL)\n  {\n  set_jumps(common->utfreadtype8, LABEL());\n  do_utfreadtype8(common);\n  }\nif (common->utfpeakcharback != NULL)\n  {\n  set_jumps(common->utfpeakcharback, LABEL());\n  do_utfpeakcharback(common);\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utfreadchar_invalid != NULL)\n  {\n  set_jumps(common->utfreadchar_invalid, LABEL());\n  do_utfreadchar_invalid(common);\n  }\nif (common->utfreadnewline_invalid != NULL)\n  {\n  set_jumps(common->utfreadnewline_invalid, LABEL());\n  do_utfreadnewline_invalid(common);\n  }\nif (common->utfmoveback_invalid)\n  {\n  set_jumps(common->utfmoveback_invalid, LABEL());\n  do_utfmoveback_invalid(common);\n  }\nif (common->utfpeakcharback_invalid)\n  {\n  set_jumps(common->utfpeakcharback_invalid, LABEL());\n  do_utfpeakcharback_invalid(common);\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16 */\nif (common->getucd != NULL)\n  {\n  set_jumps(common->getucd, LABEL());\n  do_getucd(common);\n  }\nif (common->getucdtype != NULL)\n  {\n  set_jumps(common->getucdtype, LABEL());\n  do_getucdtype(common);\n  }\n#endif /* SUPPORT_UNICODE */\n\nSLJIT_FREE(common->optimized_cbracket, allocator_data);\nSLJIT_FREE(common->private_data_ptrs, allocator_data);\n\nexecutable_func = sljit_generate_code(compiler);\nexecutable_size = sljit_get_generated_code_size(compiler);\nsljit_free_compiler(compiler);\n\nif (executable_func == NULL)\n  {\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\n/* Reuse the function descriptor if possible. */\nif (re->executable_jit != NULL)\n  functions = (executable_functions *)re->executable_jit;\nelse\n  {\n  functions = SLJIT_MALLOC(sizeof(executable_functions), allocator_data);\n  if (functions == NULL)\n    {\n    /* This case is highly unlikely since we just recently\n    freed a lot of memory. Not impossible though. */\n    sljit_free_code(executable_func, NULL);\n    PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n    return PCRE2_ERROR_NOMEMORY;\n    }\n  memset(functions, 0, sizeof(executable_functions));\n  functions->top_bracket = re->top_bracket + 1;\n  functions->limit_match = re->limit_match;\n  re->executable_jit = functions;\n  }\n\n/* Turn mode into an index. */\nif (mode == PCRE2_JIT_COMPLETE)\n  mode = 0;\nelse\n  mode = (mode == PCRE2_JIT_PARTIAL_SOFT) ? 1 : 2;\n\nSLJIT_ASSERT(mode < JIT_NUMBER_OF_COMPILE_MODES);\nfunctions->executable_funcs[mode] = executable_func;\nfunctions->read_only_data_heads[mode] = common->read_only_data_head;\nfunctions->executable_sizes[mode] = executable_size;\nreturn 0;\n}\n\n#endif\n\n/*************************************************\n*        JIT compile a Regular Expression        *\n*************************************************/\n\n/* This function used JIT to convert a previously-compiled pattern into machine\ncode.\n\nArguments:\n  code          a compiled pattern\n  options       JIT option bits\n\nReturns:        0: success or (*NOJIT) was used\n               <0: an error code\n*/\n\n#define PUBLIC_JIT_COMPILE_OPTIONS \\\n  (PCRE2_JIT_COMPLETE|PCRE2_JIT_PARTIAL_SOFT|PCRE2_JIT_PARTIAL_HARD|PCRE2_JIT_INVALID_UTF)\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_jit_compile(pcre2_code *code, uint32_t options)\n{\npcre2_real_code *re = (pcre2_real_code *)code;\n#ifdef SUPPORT_JIT\nexecutable_functions *functions;\nstatic int executable_allocator_is_working = 0;\n#endif\n\nif (code == NULL)\n  return PCRE2_ERROR_NULL;\n\nif ((options & ~PUBLIC_JIT_COMPILE_OPTIONS) != 0)\n  return PCRE2_ERROR_JIT_BADOPTION;\n\n/* Support for invalid UTF was first introduced in JIT, with the option\nPCRE2_JIT_INVALID_UTF. Later, support was added to the interpreter, and the\ncompile-time option PCRE2_MATCH_INVALID_UTF was created. This is now the\npreferred feature, with the earlier option deprecated. However, for backward\ncompatibility, if the earlier option is set, it forces the new option so that\nif JIT matching falls back to the interpreter, there is still support for\ninvalid UTF. However, if this function has already been successfully called\nwithout PCRE2_JIT_INVALID_UTF and without PCRE2_MATCH_INVALID_UTF (meaning that\nnon-invalid-supporting JIT code was compiled), give an error.\n\nIf in the future support for PCRE2_JIT_INVALID_UTF is withdrawn, the following\nactions are needed:\n\n  1. Remove the definition from pcre2.h.in and from the list in\n     PUBLIC_JIT_COMPILE_OPTIONS above.\n\n  2. Replace PCRE2_JIT_INVALID_UTF with a local flag in this module.\n\n  3. Replace PCRE2_JIT_INVALID_UTF in pcre2_jit_test.c.\n\n  4. Delete the following short block of code. The setting of \"re\" and\n     \"functions\" can be moved into the JIT-only block below, but if that is\n     done, (void)re and (void)functions will be needed in the non-JIT case, to\n     avoid compiler warnings.\n*/\n\n#ifdef SUPPORT_JIT\nfunctions = (executable_functions *)re->executable_jit;\n#endif\n\nif ((options & PCRE2_JIT_INVALID_UTF) != 0)\n  {\n  if ((re->overall_options & PCRE2_MATCH_INVALID_UTF) == 0)\n    {\n#ifdef SUPPORT_JIT\n    if (functions != NULL) return PCRE2_ERROR_JIT_BADOPTION;\n#endif\n    re->overall_options |= PCRE2_MATCH_INVALID_UTF;\n    }\n  }\n\n/* The above tests are run with and without JIT support. This means that\nPCRE2_JIT_INVALID_UTF propagates back into the regex options (ensuring\ninterpreter support) even in the absence of JIT. But now, if there is no JIT\nsupport, give an error return. */\n\n#ifndef SUPPORT_JIT\nreturn PCRE2_ERROR_JIT_BADOPTION;\n#else  /* SUPPORT_JIT */\n\n/* There is JIT support. Do the necessary. */\n\nif ((re->flags & PCRE2_NOJIT) != 0) return 0;\n\nif (executable_allocator_is_working == 0)\n  {\n  /* Checks whether the executable allocator is working. This check\n     might run multiple times in multi-threaded environments, but the\n     result should not be affected by it. */\n  void *ptr = SLJIT_MALLOC_EXEC(32, NULL);\n\n  executable_allocator_is_working = -1;\n\n  if (ptr != NULL)\n    {\n    SLJIT_FREE_EXEC(((sljit_u8*)(ptr)) + SLJIT_EXEC_OFFSET(ptr), NULL);\n    executable_allocator_is_working = 1;\n    }\n  }\n\nif (executable_allocator_is_working < 0)\n  return PCRE2_ERROR_NOMEMORY;\n\nif ((re->overall_options & PCRE2_MATCH_INVALID_UTF) != 0)\n  options |= PCRE2_JIT_INVALID_UTF;\n\nif ((options & PCRE2_JIT_COMPLETE) != 0 && (functions == NULL\n    || functions->executable_funcs[0] == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_PARTIAL_SOFT | PCRE2_JIT_PARTIAL_HARD);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nif ((options & PCRE2_JIT_PARTIAL_SOFT) != 0 && (functions == NULL\n    || functions->executable_funcs[1] == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_HARD);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nif ((options & PCRE2_JIT_PARTIAL_HARD) != 0 && (functions == NULL\n    || functions->executable_funcs[2] == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_SOFT);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nreturn 0;\n\n#endif  /* SUPPORT_JIT */\n}\n\n/* JIT compiler uses an all-in-one approach. This improves security,\n   since the code generator functions are not exported. */\n\n#define INCLUDED_FROM_PCRE2_JIT_COMPILE\n\n#include \"pcre2_jit_match.c\"\n#include \"pcre2_jit_misc.c\"\n\n/* End of pcre2_jit_compile.c */\n"], "fixing_code": ["/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n                    This module by Zoltan Herczeg\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2021 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"pcre2_internal.h\"\n\n#ifdef SUPPORT_JIT\n\n/* All-in-one: Since we use the JIT compiler only from here,\nwe just include it. This way we don't need to touch the build\nsystem files. */\n\n#define SLJIT_CONFIG_AUTO 1\n#define SLJIT_CONFIG_STATIC 1\n#define SLJIT_VERBOSE 0\n\n#ifdef PCRE2_DEBUG\n#define SLJIT_DEBUG 1\n#else\n#define SLJIT_DEBUG 0\n#endif\n\n#define SLJIT_MALLOC(size, allocator_data) pcre2_jit_malloc(size, allocator_data)\n#define SLJIT_FREE(ptr, allocator_data) pcre2_jit_free(ptr, allocator_data)\n\nstatic void * pcre2_jit_malloc(size_t size, void *allocator_data)\n{\npcre2_memctl *allocator = ((pcre2_memctl*)allocator_data);\nreturn allocator->malloc(size, allocator->memory_data);\n}\n\nstatic void pcre2_jit_free(void *ptr, void *allocator_data)\n{\npcre2_memctl *allocator = ((pcre2_memctl*)allocator_data);\nallocator->free(ptr, allocator->memory_data);\n}\n\n#include \"sljit/sljitLir.c\"\n\n#if defined SLJIT_CONFIG_UNSUPPORTED && SLJIT_CONFIG_UNSUPPORTED\n#error Unsupported architecture\n#endif\n\n/* Defines for debugging purposes. */\n\n/* 1 - Use unoptimized capturing brackets.\n   2 - Enable capture_last_ptr (includes option 1). */\n/* #define DEBUG_FORCE_UNOPTIMIZED_CBRAS 2 */\n\n/* 1 - Always have a control head. */\n/* #define DEBUG_FORCE_CONTROL_HEAD 1 */\n\n/* Allocate memory for the regex stack on the real machine stack.\nFast, but limited size. */\n#define MACHINE_STACK_SIZE 32768\n\n/* Growth rate for stack allocated by the OS. Should be the multiply\nof page size. */\n#define STACK_GROWTH_RATE 8192\n\n/* Enable to check that the allocation could destroy temporaries. */\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n#define DESTROY_REGISTERS 1\n#endif\n\n/*\nShort summary about the backtracking mechanism empolyed by the jit code generator:\n\nThe code generator follows the recursive nature of the PERL compatible regular\nexpressions. The basic blocks of regular expressions are condition checkers\nwhose execute different commands depending on the result of the condition check.\nThe relationship between the operators can be horizontal (concatenation) and\nvertical (sub-expression) (See struct backtrack_common for more details).\n\n  'ab' - 'a' and 'b' regexps are concatenated\n  'a+' - 'a' is the sub-expression of the '+' operator\n\nThe condition checkers are boolean (true/false) checkers. Machine code is generated\nfor the checker itself and for the actions depending on the result of the checker.\nThe 'true' case is called as the matching path (expected path), and the other is called as\nthe 'backtrack' path. Branch instructions are expesive for all CPUs, so we avoid taken\nbranches on the matching path.\n\n Greedy star operator (*) :\n   Matching path: match happens.\n   Backtrack path: match failed.\n Non-greedy star operator (*?) :\n   Matching path: no need to perform a match.\n   Backtrack path: match is required.\n\nThe following example shows how the code generated for a capturing bracket\nwith two alternatives. Let A, B, C, D are arbirary regular expressions, and\nwe have the following regular expression:\n\n   A(B|C)D\n\nThe generated code will be the following:\n\n A matching path\n '(' matching path (pushing arguments to the stack)\n B matching path\n ')' matching path (pushing arguments to the stack)\n D matching path\n return with successful match\n\n D backtrack path\n ')' backtrack path (If we arrived from \"C\" jump to the backtrack of \"C\")\n B backtrack path\n C expected path\n jump to D matching path\n C backtrack path\n A backtrack path\n\n Notice, that the order of backtrack code paths are the opposite of the fast\n code paths. In this way the topmost value on the stack is always belong\n to the current backtrack code path. The backtrack path must check\n whether there is a next alternative. If so, it needs to jump back to\n the matching path eventually. Otherwise it needs to clear out its own stack\n frame and continue the execution on the backtrack code paths.\n*/\n\n/*\nSaved stack frames:\n\nAtomic blocks and asserts require reloading the values of private data\nwhen the backtrack mechanism performed. Because of OP_RECURSE, the data\nare not necessarly known in compile time, thus we need a dynamic restore\nmechanism.\n\nThe stack frames are stored in a chain list, and have the following format:\n([ capturing bracket offset ][ start value ][ end value ])+ ... [ 0 ] [ previous head ]\n\nThus we can restore the private data to a particular point in the stack.\n*/\n\ntypedef struct jit_arguments {\n  /* Pointers first. */\n  struct sljit_stack *stack;\n  PCRE2_SPTR str;\n  PCRE2_SPTR begin;\n  PCRE2_SPTR end;\n  pcre2_match_data *match_data;\n  PCRE2_SPTR startchar_ptr;\n  PCRE2_UCHAR *mark_ptr;\n  int (*callout)(pcre2_callout_block *, void *);\n  void *callout_data;\n  /* Everything else after. */\n  sljit_uw offset_limit;\n  sljit_u32 limit_match;\n  sljit_u32 oveccount;\n  sljit_u32 options;\n} jit_arguments;\n\n#define JIT_NUMBER_OF_COMPILE_MODES 3\n\ntypedef struct executable_functions {\n  void *executable_funcs[JIT_NUMBER_OF_COMPILE_MODES];\n  void *read_only_data_heads[JIT_NUMBER_OF_COMPILE_MODES];\n  sljit_uw executable_sizes[JIT_NUMBER_OF_COMPILE_MODES];\n  sljit_u32 top_bracket;\n  sljit_u32 limit_match;\n} executable_functions;\n\ntypedef struct jump_list {\n  struct sljit_jump *jump;\n  struct jump_list *next;\n} jump_list;\n\ntypedef struct stub_list {\n  struct sljit_jump *start;\n  struct sljit_label *quit;\n  struct stub_list *next;\n} stub_list;\n\nenum frame_types {\n  no_frame = -1,\n  no_stack = -2\n};\n\nenum control_types {\n  type_mark = 0,\n  type_then_trap = 1\n};\n\nenum  early_fail_types {\n  type_skip = 0,\n  type_fail = 1,\n  type_fail_range = 2\n};\n\ntypedef int (SLJIT_FUNC *jit_function)(jit_arguments *args);\n\n/* The following structure is the key data type for the recursive\ncode generator. It is allocated by compile_matchingpath, and contains\nthe arguments for compile_backtrackingpath. Must be the first member\nof its descendants. */\ntypedef struct backtrack_common {\n  /* Concatenation stack. */\n  struct backtrack_common *prev;\n  jump_list *nextbacktracks;\n  /* Internal stack (for component operators). */\n  struct backtrack_common *top;\n  jump_list *topbacktracks;\n  /* Opcode pointer. */\n  PCRE2_SPTR cc;\n} backtrack_common;\n\ntypedef struct assert_backtrack {\n  backtrack_common common;\n  jump_list *condfailed;\n  /* Less than 0 if a frame is not needed. */\n  int framesize;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n  /* For iterators. */\n  struct sljit_label *matchingpath;\n} assert_backtrack;\n\ntypedef struct bracket_backtrack {\n  backtrack_common common;\n  /* Where to coninue if an alternative is successfully matched. */\n  struct sljit_label *alternative_matchingpath;\n  /* For rmin and rmax iterators. */\n  struct sljit_label *recursive_matchingpath;\n  /* For greedy ? operator. */\n  struct sljit_label *zero_matchingpath;\n  /* Contains the branches of a failed condition. */\n  union {\n    /* Both for OP_COND, OP_SCOND. */\n    jump_list *condfailed;\n    assert_backtrack *assert;\n    /* For OP_ONCE. Less than 0 if not needed. */\n    int framesize;\n    /* For brackets with >3 alternatives. */\n    struct sljit_put_label *matching_put_label;\n  } u;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n} bracket_backtrack;\n\ntypedef struct bracketpos_backtrack {\n  backtrack_common common;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n  /* Reverting stack is needed. */\n  int framesize;\n  /* Allocated stack size. */\n  int stacksize;\n} bracketpos_backtrack;\n\ntypedef struct braminzero_backtrack {\n  backtrack_common common;\n  struct sljit_label *matchingpath;\n} braminzero_backtrack;\n\ntypedef struct char_iterator_backtrack {\n  backtrack_common common;\n  /* Next iteration. */\n  struct sljit_label *matchingpath;\n  union {\n    jump_list *backtracks;\n    struct {\n      unsigned int othercasebit;\n      PCRE2_UCHAR chr;\n      BOOL enabled;\n    } charpos;\n  } u;\n} char_iterator_backtrack;\n\ntypedef struct ref_iterator_backtrack {\n  backtrack_common common;\n  /* Next iteration. */\n  struct sljit_label *matchingpath;\n} ref_iterator_backtrack;\n\ntypedef struct recurse_entry {\n  struct recurse_entry *next;\n  /* Contains the function entry label. */\n  struct sljit_label *entry_label;\n  /* Contains the function entry label. */\n  struct sljit_label *backtrack_label;\n  /* Collects the entry calls until the function is not created. */\n  jump_list *entry_calls;\n  /* Collects the backtrack calls until the function is not created. */\n  jump_list *backtrack_calls;\n  /* Points to the starting opcode. */\n  sljit_sw start;\n} recurse_entry;\n\ntypedef struct recurse_backtrack {\n  backtrack_common common;\n  /* Return to the matching path. */\n  struct sljit_label *matchingpath;\n  /* Recursive pattern. */\n  recurse_entry *entry;\n  /* Pattern is inlined. */\n  BOOL inlined_pattern;\n} recurse_backtrack;\n\n#define OP_THEN_TRAP OP_TABLE_LENGTH\n\ntypedef struct then_trap_backtrack {\n  backtrack_common common;\n  /* If then_trap is not NULL, this structure contains the real\n  then_trap for the backtracking path. */\n  struct then_trap_backtrack *then_trap;\n  /* Points to the starting opcode. */\n  sljit_sw start;\n  /* Exit point for the then opcodes of this alternative. */\n  jump_list *quit;\n  /* Frame size of the current alternative. */\n  int framesize;\n} then_trap_backtrack;\n\n#define MAX_N_CHARS 12\n#define MAX_DIFF_CHARS 5\n\ntypedef struct fast_forward_char_data {\n  /* Number of characters in the chars array, 255 for any character. */\n  sljit_u8 count;\n  /* Number of last UTF-8 characters in the chars array. */\n  sljit_u8 last_count;\n  /* Available characters in the current position. */\n  PCRE2_UCHAR chars[MAX_DIFF_CHARS];\n} fast_forward_char_data;\n\n#define MAX_CLASS_RANGE_SIZE 4\n#define MAX_CLASS_CHARS_SIZE 3\n\ntypedef struct compiler_common {\n  /* The sljit ceneric compiler. */\n  struct sljit_compiler *compiler;\n  /* Compiled regular expression. */\n  pcre2_real_code *re;\n  /* First byte code. */\n  PCRE2_SPTR start;\n  /* Maps private data offset to each opcode. */\n  sljit_s32 *private_data_ptrs;\n  /* Chain list of read-only data ptrs. */\n  void *read_only_data_head;\n  /* Tells whether the capturing bracket is optimized. */\n  sljit_u8 *optimized_cbracket;\n  /* Tells whether the starting offset is a target of then. */\n  sljit_u8 *then_offsets;\n  /* Current position where a THEN must jump. */\n  then_trap_backtrack *then_trap;\n  /* Starting offset of private data for capturing brackets. */\n  sljit_s32 cbra_ptr;\n  /* Output vector starting point. Must be divisible by 2. */\n  sljit_s32 ovector_start;\n  /* Points to the starting character of the current match. */\n  sljit_s32 start_ptr;\n  /* Last known position of the requested byte. */\n  sljit_s32 req_char_ptr;\n  /* Head of the last recursion. */\n  sljit_s32 recursive_head_ptr;\n  /* First inspected character for partial matching.\n     (Needed for avoiding zero length partial matches.) */\n  sljit_s32 start_used_ptr;\n  /* Starting pointer for partial soft matches. */\n  sljit_s32 hit_start;\n  /* Pointer of the match end position. */\n  sljit_s32 match_end_ptr;\n  /* Points to the marked string. */\n  sljit_s32 mark_ptr;\n  /* Recursive control verb management chain. */\n  sljit_s32 control_head_ptr;\n  /* Points to the last matched capture block index. */\n  sljit_s32 capture_last_ptr;\n  /* Fast forward skipping byte code pointer. */\n  PCRE2_SPTR fast_forward_bc_ptr;\n  /* Locals used by fast fail optimization. */\n  sljit_s32 early_fail_start_ptr;\n  sljit_s32 early_fail_end_ptr;\n\n  /* Flipped and lower case tables. */\n  const sljit_u8 *fcc;\n  sljit_sw lcc;\n  /* Mode can be PCRE2_JIT_COMPLETE and others. */\n  int mode;\n  /* TRUE, when empty match is accepted for partial matching. */\n  BOOL allow_empty_partial;\n  /* TRUE, when minlength is greater than 0. */\n  BOOL might_be_empty;\n  /* \\K is found in the pattern. */\n  BOOL has_set_som;\n  /* (*SKIP:arg) is found in the pattern. */\n  BOOL has_skip_arg;\n  /* (*THEN) is found in the pattern. */\n  BOOL has_then;\n  /* (*SKIP) or (*SKIP:arg) is found in lookbehind assertion. */\n  BOOL has_skip_in_assert_back;\n  /* Quit is redirected by recurse, negative assertion, or positive assertion in conditional block. */\n  BOOL local_quit_available;\n  /* Currently in a positive assertion. */\n  BOOL in_positive_assertion;\n  /* Newline control. */\n  int nltype;\n  sljit_u32 nlmax;\n  sljit_u32 nlmin;\n  int newline;\n  int bsr_nltype;\n  sljit_u32 bsr_nlmax;\n  sljit_u32 bsr_nlmin;\n  /* Dollar endonly. */\n  int endonly;\n  /* Tables. */\n  sljit_sw ctypes;\n  /* Named capturing brackets. */\n  PCRE2_SPTR name_table;\n  sljit_sw name_count;\n  sljit_sw name_entry_size;\n\n  /* Labels and jump lists. */\n  struct sljit_label *partialmatchlabel;\n  struct sljit_label *quit_label;\n  struct sljit_label *abort_label;\n  struct sljit_label *accept_label;\n  struct sljit_label *ff_newline_shortcut;\n  stub_list *stubs;\n  recurse_entry *entries;\n  recurse_entry *currententry;\n  jump_list *partialmatch;\n  jump_list *quit;\n  jump_list *positive_assertion_quit;\n  jump_list *abort;\n  jump_list *failed_match;\n  jump_list *accept;\n  jump_list *calllimit;\n  jump_list *stackalloc;\n  jump_list *revertframes;\n  jump_list *wordboundary;\n  jump_list *anynewline;\n  jump_list *hspace;\n  jump_list *vspace;\n  jump_list *casefulcmp;\n  jump_list *caselesscmp;\n  jump_list *reset_match;\n  BOOL unset_backref;\n  BOOL alt_circumflex;\n#ifdef SUPPORT_UNICODE\n  BOOL utf;\n  BOOL invalid_utf;\n  BOOL ucp;\n  /* Points to saving area for iref. */\n  sljit_s32 iref_ptr;\n  jump_list *getucd;\n  jump_list *getucdtype;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  jump_list *utfreadchar;\n  jump_list *utfreadtype8;\n  jump_list *utfpeakcharback;\n#endif\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\n  jump_list *utfreadchar_invalid;\n  jump_list *utfreadnewline_invalid;\n  jump_list *utfmoveback_invalid;\n  jump_list *utfpeakcharback_invalid;\n#endif\n#endif /* SUPPORT_UNICODE */\n} compiler_common;\n\n/* For byte_sequence_compare. */\n\ntypedef struct compare_context {\n  int length;\n  int sourcereg;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  int ucharptr;\n  union {\n    sljit_s32 asint;\n    sljit_u16 asushort;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    sljit_u8 asbyte;\n    sljit_u8 asuchars[4];\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    sljit_u16 asuchars[2];\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n    sljit_u32 asuchars[1];\n#endif\n  } c;\n  union {\n    sljit_s32 asint;\n    sljit_u16 asushort;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    sljit_u8 asbyte;\n    sljit_u8 asuchars[4];\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    sljit_u16 asuchars[2];\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n    sljit_u32 asuchars[1];\n#endif\n  } oc;\n#endif\n} compare_context;\n\n/* Undefine sljit macros. */\n#undef CMP\n\n/* Used for accessing the elements of the stack. */\n#define STACK(i)      ((i) * (int)sizeof(sljit_sw))\n\n#ifdef SLJIT_PREF_SHIFT_REG\n#if SLJIT_PREF_SHIFT_REG == SLJIT_R2\n/* Nothing. */\n#elif SLJIT_PREF_SHIFT_REG == SLJIT_R3\n#define SHIFT_REG_IS_R3\n#else\n#error \"Unsupported shift register\"\n#endif\n#endif\n\n#define TMP1          SLJIT_R0\n#ifdef SHIFT_REG_IS_R3\n#define TMP2          SLJIT_R3\n#define TMP3          SLJIT_R2\n#else\n#define TMP2          SLJIT_R2\n#define TMP3          SLJIT_R3\n#endif\n#define STR_PTR       SLJIT_R1\n#define STR_END       SLJIT_S0\n#define STACK_TOP     SLJIT_S1\n#define STACK_LIMIT   SLJIT_S2\n#define COUNT_MATCH   SLJIT_S3\n#define ARGUMENTS     SLJIT_S4\n#define RETURN_ADDR   SLJIT_R4\n\n#if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)\n#define HAS_VIRTUAL_REGISTERS 1\n#else\n#define HAS_VIRTUAL_REGISTERS 0\n#endif\n\n/* Local space layout. */\n/* These two locals can be used by the current opcode. */\n#define LOCALS0          (0 * sizeof(sljit_sw))\n#define LOCALS1          (1 * sizeof(sljit_sw))\n/* Two local variables for possessive quantifiers (char1 cannot use them). */\n#define POSSESSIVE0      (2 * sizeof(sljit_sw))\n#define POSSESSIVE1      (3 * sizeof(sljit_sw))\n/* Max limit of recursions. */\n#define LIMIT_MATCH      (4 * sizeof(sljit_sw))\n/* The output vector is stored on the stack, and contains pointers\nto characters. The vector data is divided into two groups: the first\ngroup contains the start / end character pointers, and the second is\nthe start pointers when the end of the capturing group has not yet reached. */\n#define OVECTOR_START    (common->ovector_start)\n#define OVECTOR(i)       (OVECTOR_START + (i) * (sljit_sw)sizeof(sljit_sw))\n#define OVECTOR_PRIV(i)  (common->cbra_ptr + (i) * (sljit_sw)sizeof(sljit_sw))\n#define PRIVATE_DATA(cc) (common->private_data_ptrs[(cc) - common->start])\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#define MOV_UCHAR  SLJIT_MOV_U8\n#define IN_UCHARS(x) (x)\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n#define MOV_UCHAR  SLJIT_MOV_U16\n#define UCHAR_SHIFT (1)\n#define IN_UCHARS(x) ((x) * 2)\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n#define MOV_UCHAR  SLJIT_MOV_U32\n#define UCHAR_SHIFT (2)\n#define IN_UCHARS(x) ((x) * 4)\n#else\n#error Unsupported compiling mode\n#endif\n\n/* Shortcuts. */\n#define DEFINE_COMPILER \\\n  struct sljit_compiler *compiler = common->compiler\n#define OP1(op, dst, dstw, src, srcw) \\\n  sljit_emit_op1(compiler, (op), (dst), (dstw), (src), (srcw))\n#define OP2(op, dst, dstw, src1, src1w, src2, src2w) \\\n  sljit_emit_op2(compiler, (op), (dst), (dstw), (src1), (src1w), (src2), (src2w))\n#define OP2U(op, src1, src1w, src2, src2w) \\\n  sljit_emit_op2u(compiler, (op), (src1), (src1w), (src2), (src2w))\n#define OP_SRC(op, src, srcw) \\\n  sljit_emit_op_src(compiler, (op), (src), (srcw))\n#define LABEL() \\\n  sljit_emit_label(compiler)\n#define JUMP(type) \\\n  sljit_emit_jump(compiler, (type))\n#define JUMPTO(type, label) \\\n  sljit_set_label(sljit_emit_jump(compiler, (type)), (label))\n#define JUMPHERE(jump) \\\n  sljit_set_label((jump), sljit_emit_label(compiler))\n#define SET_LABEL(jump, label) \\\n  sljit_set_label((jump), (label))\n#define CMP(type, src1, src1w, src2, src2w) \\\n  sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w))\n#define CMPTO(type, src1, src1w, src2, src2w, label) \\\n  sljit_set_label(sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w)), (label))\n#define OP_FLAGS(op, dst, dstw, type) \\\n  sljit_emit_op_flags(compiler, (op), (dst), (dstw), (type))\n#define CMOV(type, dst_reg, src, srcw) \\\n  sljit_emit_cmov(compiler, (type), (dst_reg), (src), (srcw))\n#define GET_LOCAL_BASE(dst, dstw, offset) \\\n  sljit_get_local_base(compiler, (dst), (dstw), (offset))\n\n#define READ_CHAR_MAX 0x7fffffff\n\n#define INVALID_UTF_CHAR -1\n#define UNASSIGNED_UTF_CHAR 888\n\n#if defined SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr[0] <= 0x7f) \\\n    c = *ptr++; \\\n  else if (ptr + 1 < end && ptr[1] >= 0x80 && ptr[1] < 0xc0) \\\n    { \\\n    c = ptr[1] - 0x80; \\\n    \\\n    if (ptr[0] >= 0xc2 && ptr[0] <= 0xdf) \\\n      { \\\n      c |= (ptr[0] - 0xc0) << 6; \\\n      ptr += 2; \\\n      } \\\n    else if (ptr + 2 < end && ptr[2] >= 0x80 && ptr[2] < 0xc0) \\\n      { \\\n      c = c << 6 | (ptr[2] - 0x80); \\\n      \\\n      if (ptr[0] >= 0xe0 && ptr[0] <= 0xef) \\\n        { \\\n        c |= (ptr[0] - 0xe0) << 12; \\\n        ptr += 3; \\\n        \\\n        if (c < 0x800 || (c >= 0xd800 && c < 0xe000)) \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else if (ptr + 3 < end && ptr[3] >= 0x80 && ptr[3] < 0xc0) \\\n        { \\\n        c = c << 6 | (ptr[3] - 0x80); \\\n        \\\n        if (ptr[0] >= 0xf0 && ptr[0] <= 0xf4) \\\n          { \\\n          c |= (ptr[0] - 0xf0) << 18; \\\n          ptr += 4; \\\n          \\\n          if (c >= 0x110000 || c < 0x10000) \\\n            { \\\n            invalid_action; \\\n            } \\\n          } \\\n        else \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else \\\n        { \\\n        invalid_action; \\\n        } \\\n      } \\\n    else \\\n      { \\\n      invalid_action; \\\n      } \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr[-1]; \\\n  if (c <= 0x7f) \\\n    ptr--; \\\n  else if (ptr - 1 > start && ptr[-1] >= 0x80 && ptr[-1] < 0xc0) \\\n    { \\\n    c -= 0x80; \\\n    \\\n    if (ptr[-2] >= 0xc2 && ptr[-2] <= 0xdf) \\\n      { \\\n      c |= (ptr[-2] - 0xc0) << 6; \\\n      ptr -= 2; \\\n      } \\\n    else if (ptr - 2 > start && ptr[-2] >= 0x80 && ptr[-2] < 0xc0) \\\n      { \\\n      c = c << 6 | (ptr[-2] - 0x80); \\\n      \\\n      if (ptr[-3] >= 0xe0 && ptr[-3] <= 0xef) \\\n        { \\\n        c |= (ptr[-3] - 0xe0) << 12; \\\n        ptr -= 3; \\\n        \\\n        if (c < 0x800 || (c >= 0xd800 && c < 0xe000)) \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else if (ptr - 3 > start && ptr[-3] >= 0x80 && ptr[-3] < 0xc0) \\\n        { \\\n        c = c << 6 | (ptr[-3] - 0x80); \\\n        \\\n        if (ptr[-4] >= 0xf0 && ptr[-4] <= 0xf4) \\\n          { \\\n          c |= (ptr[-4] - 0xf0) << 18; \\\n          ptr -= 4; \\\n          \\\n          if (c >= 0x110000 || c < 0x10000) \\\n            { \\\n            invalid_action; \\\n            } \\\n          } \\\n        else \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else \\\n        { \\\n        invalid_action; \\\n        } \\\n      } \\\n    else \\\n      { \\\n      invalid_action; \\\n      } \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr[0] < 0xd800 || ptr[0] >= 0xe000) \\\n    c = *ptr++; \\\n  else if (ptr[0] < 0xdc00 && ptr + 1 < end && ptr[1] >= 0xdc00 && ptr[1] < 0xe000) \\\n    { \\\n    c = (((ptr[0] - 0xd800) << 10) | (ptr[1] - 0xdc00)) + 0x10000; \\\n    ptr += 2; \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr[-1]; \\\n  if (c < 0xd800 || c >= 0xe000) \\\n    ptr--; \\\n  else if (c >= 0xdc00 && ptr - 1 > start && ptr[-2] >= 0xd800 && ptr[-2] < 0xdc00) \\\n    { \\\n    c = (((ptr[-2] - 0xd800) << 10) | (c - 0xdc00)) + 0x10000; \\\n    ptr -= 2; \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr[0] < 0xd800 || (ptr[0] >= 0xe000 && ptr[0] < 0x110000)) \\\n    c = *ptr++; \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr[-1]; \\\n  if (ptr[-1] < 0xd800 || (ptr[-1] >= 0xe000 && ptr[-1] < 0x110000)) \\\n    ptr--; \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n\nstatic PCRE2_SPTR bracketend(PCRE2_SPTR cc)\n{\nSLJIT_ASSERT((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND));\ndo cc += GET(cc, 1); while (*cc == OP_ALT);\nSLJIT_ASSERT(*cc >= OP_KET && *cc <= OP_KETRPOS);\ncc += 1 + LINK_SIZE;\nreturn cc;\n}\n\nstatic int no_alternatives(PCRE2_SPTR cc)\n{\nint count = 0;\nSLJIT_ASSERT((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND));\ndo\n  {\n  cc += GET(cc, 1);\n  count++;\n  }\nwhile (*cc == OP_ALT);\nSLJIT_ASSERT(*cc >= OP_KET && *cc <= OP_KETRPOS);\nreturn count;\n}\n\n/* Functions whose might need modification for all new supported opcodes:\n next_opcode\n check_opcode_types\n set_private_data_ptrs\n get_framesize\n init_frame\n get_recurse_data_length\n copy_recurse_data\n compile_matchingpath\n compile_backtrackingpath\n*/\n\nstatic PCRE2_SPTR next_opcode(compiler_common *common, PCRE2_SPTR cc)\n{\nSLJIT_UNUSED_ARG(common);\nswitch(*cc)\n  {\n  case OP_SOD:\n  case OP_SOM:\n  case OP_SET_SOM:\n  case OP_NOT_WORD_BOUNDARY:\n  case OP_WORD_BOUNDARY:\n  case OP_NOT_DIGIT:\n  case OP_DIGIT:\n  case OP_NOT_WHITESPACE:\n  case OP_WHITESPACE:\n  case OP_NOT_WORDCHAR:\n  case OP_WORDCHAR:\n  case OP_ANY:\n  case OP_ALLANY:\n  case OP_NOTPROP:\n  case OP_PROP:\n  case OP_ANYNL:\n  case OP_NOT_HSPACE:\n  case OP_HSPACE:\n  case OP_NOT_VSPACE:\n  case OP_VSPACE:\n  case OP_EXTUNI:\n  case OP_EODN:\n  case OP_EOD:\n  case OP_CIRC:\n  case OP_CIRCM:\n  case OP_DOLL:\n  case OP_DOLLM:\n  case OP_CRSTAR:\n  case OP_CRMINSTAR:\n  case OP_CRPLUS:\n  case OP_CRMINPLUS:\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  case OP_CRPOSSTAR:\n  case OP_CRPOSPLUS:\n  case OP_CRPOSQUERY:\n  case OP_CRPOSRANGE:\n  case OP_CLASS:\n  case OP_NCLASS:\n  case OP_REF:\n  case OP_REFI:\n  case OP_DNREF:\n  case OP_DNREFI:\n  case OP_RECURSE:\n  case OP_CALLOUT:\n  case OP_ALT:\n  case OP_KET:\n  case OP_KETRMAX:\n  case OP_KETRMIN:\n  case OP_KETRPOS:\n  case OP_REVERSE:\n  case OP_ASSERT:\n  case OP_ASSERT_NOT:\n  case OP_ASSERTBACK:\n  case OP_ASSERTBACK_NOT:\n  case OP_ASSERT_NA:\n  case OP_ASSERTBACK_NA:\n  case OP_ONCE:\n  case OP_SCRIPT_RUN:\n  case OP_BRA:\n  case OP_BRAPOS:\n  case OP_CBRA:\n  case OP_CBRAPOS:\n  case OP_COND:\n  case OP_SBRA:\n  case OP_SBRAPOS:\n  case OP_SCBRA:\n  case OP_SCBRAPOS:\n  case OP_SCOND:\n  case OP_CREF:\n  case OP_DNCREF:\n  case OP_RREF:\n  case OP_DNRREF:\n  case OP_FALSE:\n  case OP_TRUE:\n  case OP_BRAZERO:\n  case OP_BRAMINZERO:\n  case OP_BRAPOSZERO:\n  case OP_PRUNE:\n  case OP_SKIP:\n  case OP_THEN:\n  case OP_COMMIT:\n  case OP_FAIL:\n  case OP_ACCEPT:\n  case OP_ASSERT_ACCEPT:\n  case OP_CLOSE:\n  case OP_SKIPZERO:\n  return cc + PRIV(OP_lengths)[*cc];\n\n  case OP_CHAR:\n  case OP_CHARI:\n  case OP_NOT:\n  case OP_NOTI:\n  case OP_STAR:\n  case OP_MINSTAR:\n  case OP_PLUS:\n  case OP_MINPLUS:\n  case OP_QUERY:\n  case OP_MINQUERY:\n  case OP_UPTO:\n  case OP_MINUPTO:\n  case OP_EXACT:\n  case OP_POSSTAR:\n  case OP_POSPLUS:\n  case OP_POSQUERY:\n  case OP_POSUPTO:\n  case OP_STARI:\n  case OP_MINSTARI:\n  case OP_PLUSI:\n  case OP_MINPLUSI:\n  case OP_QUERYI:\n  case OP_MINQUERYI:\n  case OP_UPTOI:\n  case OP_MINUPTOI:\n  case OP_EXACTI:\n  case OP_POSSTARI:\n  case OP_POSPLUSI:\n  case OP_POSQUERYI:\n  case OP_POSUPTOI:\n  case OP_NOTSTAR:\n  case OP_NOTMINSTAR:\n  case OP_NOTPLUS:\n  case OP_NOTMINPLUS:\n  case OP_NOTQUERY:\n  case OP_NOTMINQUERY:\n  case OP_NOTUPTO:\n  case OP_NOTMINUPTO:\n  case OP_NOTEXACT:\n  case OP_NOTPOSSTAR:\n  case OP_NOTPOSPLUS:\n  case OP_NOTPOSQUERY:\n  case OP_NOTPOSUPTO:\n  case OP_NOTSTARI:\n  case OP_NOTMINSTARI:\n  case OP_NOTPLUSI:\n  case OP_NOTMINPLUSI:\n  case OP_NOTQUERYI:\n  case OP_NOTMINQUERYI:\n  case OP_NOTUPTOI:\n  case OP_NOTMINUPTOI:\n  case OP_NOTEXACTI:\n  case OP_NOTPOSSTARI:\n  case OP_NOTPOSPLUSI:\n  case OP_NOTPOSQUERYI:\n  case OP_NOTPOSUPTOI:\n  cc += PRIV(OP_lengths)[*cc];\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n  return cc;\n\n  /* Special cases. */\n  case OP_TYPESTAR:\n  case OP_TYPEMINSTAR:\n  case OP_TYPEPLUS:\n  case OP_TYPEMINPLUS:\n  case OP_TYPEQUERY:\n  case OP_TYPEMINQUERY:\n  case OP_TYPEUPTO:\n  case OP_TYPEMINUPTO:\n  case OP_TYPEEXACT:\n  case OP_TYPEPOSSTAR:\n  case OP_TYPEPOSPLUS:\n  case OP_TYPEPOSQUERY:\n  case OP_TYPEPOSUPTO:\n  return cc + PRIV(OP_lengths)[*cc] - 1;\n\n  case OP_ANYBYTE:\n#ifdef SUPPORT_UNICODE\n  if (common->utf) return NULL;\n#endif\n  return cc + 1;\n\n  case OP_CALLOUT_STR:\n  return cc + GET(cc, 1 + 2*LINK_SIZE);\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n  case OP_XCLASS:\n  return cc + GET(cc, 1);\n#endif\n\n  case OP_MARK:\n  case OP_COMMIT_ARG:\n  case OP_PRUNE_ARG:\n  case OP_SKIP_ARG:\n  case OP_THEN_ARG:\n  return cc + 1 + 2 + cc[1];\n\n  default:\n  SLJIT_UNREACHABLE();\n  return NULL;\n  }\n}\n\nstatic BOOL check_opcode_types(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend)\n{\nint count;\nPCRE2_SPTR slot;\nPCRE2_SPTR assert_back_end = cc - 1;\nPCRE2_SPTR assert_na_end = cc - 1;\n\n/* Calculate important variables (like stack size) and checks whether all opcodes are supported. */\nwhile (cc < ccend)\n  {\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    common->has_set_som = TRUE;\n    common->might_be_empty = TRUE;\n    cc += 1;\n    break;\n\n    case OP_REFI:\n#ifdef SUPPORT_UNICODE\n    if (common->iref_ptr == 0)\n      {\n      common->iref_ptr = common->ovector_start;\n      common->ovector_start += 3 * sizeof(sljit_sw);\n      }\n#endif /* SUPPORT_UNICODE */\n    /* Fall through. */\n    case OP_REF:\n    common->optimized_cbracket[GET2(cc, 1)] = 0;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    slot = bracketend(cc);\n    if (slot > assert_na_end)\n      assert_na_end = slot;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] = 0;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    case OP_SCOND:\n    /* Only AUTO_CALLOUT can insert this opcode. We do\n       not intend to support this case. */\n    if (cc[1 + LINK_SIZE] == OP_CALLOUT || cc[1 + LINK_SIZE] == OP_CALLOUT_STR)\n      return FALSE;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CREF:\n    common->optimized_cbracket[GET2(cc, 1)] = 0;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_DNREF:\n    case OP_DNREFI:\n    case OP_DNCREF:\n    count = GET2(cc, 1 + IMM2_SIZE);\n    slot = common->name_table + GET2(cc, 1) * common->name_entry_size;\n    while (count-- > 0)\n      {\n      common->optimized_cbracket[GET2(slot, 0)] = 0;\n      slot += common->name_entry_size;\n      }\n    cc += 1 + 2 * IMM2_SIZE;\n    break;\n\n    case OP_RECURSE:\n    /* Set its value only once. */\n    if (common->recursive_head_ptr == 0)\n      {\n      common->recursive_head_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    if (common->capture_last_ptr == 0)\n      {\n      common->capture_last_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += (*cc == OP_CALLOUT) ? PRIV(OP_lengths)[OP_CALLOUT] : GET(cc, 1 + 2*LINK_SIZE);\n    break;\n\n    case OP_ASSERTBACK:\n    slot = bracketend(cc);\n    if (slot > assert_back_end)\n      assert_back_end = slot;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_THEN_ARG:\n    common->has_then = TRUE;\n    common->control_head_ptr = 1;\n    /* Fall through. */\n\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    if (cc < assert_na_end)\n      return FALSE;\n    /* Fall through */\n    case OP_MARK:\n    if (common->mark_ptr == 0)\n      {\n      common->mark_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    common->has_then = TRUE;\n    common->control_head_ptr = 1;\n    cc += 1;\n    break;\n\n    case OP_SKIP:\n    if (cc < assert_back_end)\n      common->has_skip_in_assert_back = TRUE;\n    if (cc < assert_na_end)\n      return FALSE;\n    cc += 1;\n    break;\n\n    case OP_SKIP_ARG:\n    common->control_head_ptr = 1;\n    common->has_skip_arg = TRUE;\n    if (cc < assert_back_end)\n      common->has_skip_in_assert_back = TRUE;\n    if (cc < assert_na_end)\n      return FALSE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_COMMIT:\n    case OP_ASSERT_ACCEPT:\n    if (cc < assert_na_end)\n      return FALSE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    if (cc == NULL)\n      return FALSE;\n    break;\n    }\n  }\nreturn TRUE;\n}\n\n#define EARLY_FAIL_ENHANCE_MAX (1 + 3)\n\n/*\nstart:\n  0 - skip / early fail allowed\n  1 - only early fail with range allowed\n  >1 - (start - 1) early fail is processed\n\nreturn: current number of iterators enhanced with fast fail\n*/\nstatic int detect_early_fail(compiler_common *common, PCRE2_SPTR cc, int *private_data_start,\n   sljit_s32 depth, int start, BOOL fast_forward_allowed)\n{\nPCRE2_SPTR begin = cc;\nPCRE2_SPTR next_alt;\nPCRE2_SPTR end;\nPCRE2_SPTR accelerated_start;\nBOOL prev_fast_forward_allowed;\nint result = 0;\nint count;\n\nSLJIT_ASSERT(*cc == OP_ONCE || *cc == OP_BRA || *cc == OP_CBRA);\nSLJIT_ASSERT(*cc != OP_CBRA || common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] != 0);\nSLJIT_ASSERT(start < EARLY_FAIL_ENHANCE_MAX);\n\nnext_alt = cc + GET(cc, 1);\nif (*next_alt == OP_ALT)\n  fast_forward_allowed = FALSE;\n\ndo\n  {\n  count = start;\n  cc += 1 + LINK_SIZE + ((*cc == OP_CBRA) ? IMM2_SIZE : 0);\n\n  while (TRUE)\n    {\n    accelerated_start = NULL;\n\n    switch(*cc)\n      {\n      case OP_SOD:\n      case OP_SOM:\n      case OP_SET_SOM:\n      case OP_NOT_WORD_BOUNDARY:\n      case OP_WORD_BOUNDARY:\n      case OP_EODN:\n      case OP_EOD:\n      case OP_CIRC:\n      case OP_CIRCM:\n      case OP_DOLL:\n      case OP_DOLLM:\n      /* Zero width assertions. */\n      cc++;\n      continue;\n\n      case OP_NOT_DIGIT:\n      case OP_DIGIT:\n      case OP_NOT_WHITESPACE:\n      case OP_WHITESPACE:\n      case OP_NOT_WORDCHAR:\n      case OP_WORDCHAR:\n      case OP_ANY:\n      case OP_ALLANY:\n      case OP_ANYBYTE:\n      case OP_NOT_HSPACE:\n      case OP_HSPACE:\n      case OP_NOT_VSPACE:\n      case OP_VSPACE:\n      fast_forward_allowed = FALSE;\n      cc++;\n      continue;\n\n      case OP_ANYNL:\n      case OP_EXTUNI:\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc++;\n      continue;\n\n      case OP_NOTPROP:\n      case OP_PROP:\n      fast_forward_allowed = FALSE;\n      cc += 1 + 2;\n      continue;\n\n      case OP_CHAR:\n      case OP_CHARI:\n      case OP_NOT:\n      case OP_NOTI:\n      fast_forward_allowed = FALSE;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      continue;\n\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      case OP_TYPEPOSSTAR:\n      case OP_TYPEPOSPLUS:\n      /* The type or prop opcode is skipped in the next iteration. */\n      cc += 1;\n\n      if (cc[0] != OP_ANYNL && cc[0] != OP_EXTUNI)\n        {\n        accelerated_start = cc - 1;\n        break;\n        }\n\n      if (count == 0)\n        count = 1;\n      fast_forward_allowed = FALSE;\n      continue;\n\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      case OP_TYPEEXACT:\n      case OP_TYPEPOSUPTO:\n      cc += IMM2_SIZE;\n      /* Fall through */\n\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      case OP_TYPEPOSQUERY:\n      /* The type or prop opcode is skipped in the next iteration. */\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc += 1;\n      continue;\n\n      case OP_STAR:\n      case OP_MINSTAR:\n      case OP_PLUS:\n      case OP_MINPLUS:\n      case OP_POSSTAR:\n      case OP_POSPLUS:\n\n      case OP_STARI:\n      case OP_MINSTARI:\n      case OP_PLUSI:\n      case OP_MINPLUSI:\n      case OP_POSSTARI:\n      case OP_POSPLUSI:\n\n      case OP_NOTSTAR:\n      case OP_NOTMINSTAR:\n      case OP_NOTPLUS:\n      case OP_NOTMINPLUS:\n      case OP_NOTPOSSTAR:\n      case OP_NOTPOSPLUS:\n\n      case OP_NOTSTARI:\n      case OP_NOTMINSTARI:\n      case OP_NOTPLUSI:\n      case OP_NOTMINPLUSI:\n      case OP_NOTPOSSTARI:\n      case OP_NOTPOSPLUSI:\n      accelerated_start = cc;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      break;\n\n      case OP_UPTO:\n      case OP_MINUPTO:\n      case OP_EXACT:\n      case OP_POSUPTO:\n      case OP_UPTOI:\n      case OP_MINUPTOI:\n      case OP_EXACTI:\n      case OP_POSUPTOI:\n      case OP_NOTUPTO:\n      case OP_NOTMINUPTO:\n      case OP_NOTEXACT:\n      case OP_NOTPOSUPTO:\n      case OP_NOTUPTOI:\n      case OP_NOTMINUPTOI:\n      case OP_NOTEXACTI:\n      case OP_NOTPOSUPTOI:\n      cc += IMM2_SIZE;\n      /* Fall through */\n\n      case OP_QUERY:\n      case OP_MINQUERY:\n      case OP_POSQUERY:\n      case OP_QUERYI:\n      case OP_MINQUERYI:\n      case OP_POSQUERYI:\n      case OP_NOTQUERY:\n      case OP_NOTMINQUERY:\n      case OP_NOTPOSQUERY:\n      case OP_NOTQUERYI:\n      case OP_NOTMINQUERYI:\n      case OP_NOTPOSQUERYI:\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      continue;\n\n      case OP_CLASS:\n      case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n      case OP_XCLASS:\n      accelerated_start = cc;\n      cc += ((*cc == OP_XCLASS) ? GET(cc, 1) : (unsigned int)(1 + (32 / sizeof(PCRE2_UCHAR))));\n#else\n      accelerated_start = cc;\n      cc += (1 + (32 / sizeof(PCRE2_UCHAR)));\n#endif\n\n      switch (*cc)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRPOSSTAR:\n        case OP_CRPOSPLUS:\n        cc++;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        case OP_CRPOSRANGE:\n        cc += 2 * IMM2_SIZE;\n        /* Fall through */\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        case OP_CRPOSQUERY:\n        cc++;\n        if (count == 0)\n          count = 1;\n        /* Fall through */\n        default:\n        accelerated_start = NULL;\n        fast_forward_allowed = FALSE;\n        continue;\n        }\n      break;\n\n      case OP_ONCE:\n      case OP_BRA:\n      case OP_CBRA:\n      end = cc + GET(cc, 1);\n\n      prev_fast_forward_allowed = fast_forward_allowed;\n      fast_forward_allowed = FALSE;\n      if (depth >= 4)\n        break;\n\n      end = bracketend(cc) - (1 + LINK_SIZE);\n      if (*end != OP_KET || (*cc == OP_CBRA && common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0))\n        break;\n\n      count = detect_early_fail(common, cc, private_data_start, depth + 1, count, prev_fast_forward_allowed);\n\n      if (PRIVATE_DATA(cc) != 0)\n        common->private_data_ptrs[begin - common->start] = 1;\n\n      if (count < EARLY_FAIL_ENHANCE_MAX)\n        {\n        cc = end + (1 + LINK_SIZE);\n        continue;\n        }\n      break;\n\n      case OP_KET:\n      SLJIT_ASSERT(PRIVATE_DATA(cc) == 0);\n      if (cc >= next_alt)\n        break;\n      cc += 1 + LINK_SIZE;\n      continue;\n      }\n\n    if (accelerated_start != NULL)\n      {\n      if (count == 0)\n        {\n        count++;\n\n        if (fast_forward_allowed)\n          {\n          common->fast_forward_bc_ptr = accelerated_start;\n          common->private_data_ptrs[(accelerated_start + 1) - common->start] = ((*private_data_start) << 3) | type_skip;\n          *private_data_start += sizeof(sljit_sw);\n          }\n        else\n          {\n          common->private_data_ptrs[(accelerated_start + 1) - common->start] = ((*private_data_start) << 3) | type_fail;\n\n          if (common->early_fail_start_ptr == 0)\n            common->early_fail_start_ptr = *private_data_start;\n\n          *private_data_start += sizeof(sljit_sw);\n          common->early_fail_end_ptr = *private_data_start;\n\n          if (*private_data_start > SLJIT_MAX_LOCAL_SIZE)\n            return EARLY_FAIL_ENHANCE_MAX;\n          }\n        }\n      else\n        {\n        common->private_data_ptrs[(accelerated_start + 1) - common->start] = ((*private_data_start) << 3) | type_fail_range;\n\n        if (common->early_fail_start_ptr == 0)\n          common->early_fail_start_ptr = *private_data_start;\n\n        *private_data_start += 2 * sizeof(sljit_sw);\n        common->early_fail_end_ptr = *private_data_start;\n\n        if (*private_data_start > SLJIT_MAX_LOCAL_SIZE)\n          return EARLY_FAIL_ENHANCE_MAX;\n        }\n\n      /* Cannot be part of a repeat. */\n      common->private_data_ptrs[begin - common->start] = 1;\n      count++;\n\n      if (count < EARLY_FAIL_ENHANCE_MAX)\n        continue;\n      }\n\n    break;\n    }\n\n  if (*cc != OP_ALT && *cc != OP_KET)\n    result = EARLY_FAIL_ENHANCE_MAX;\n  else if (result < count)\n    result = count;\n\n  cc = next_alt;\n  next_alt = cc + GET(cc, 1);\n  }\nwhile (*cc == OP_ALT);\n\nreturn result;\n}\n\nstatic int get_class_iterator_size(PCRE2_SPTR cc)\n{\nsljit_u32 min;\nsljit_u32 max;\nswitch(*cc)\n  {\n  case OP_CRSTAR:\n  case OP_CRPLUS:\n  return 2;\n\n  case OP_CRMINSTAR:\n  case OP_CRMINPLUS:\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  return 1;\n\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  min = GET2(cc, 1);\n  max = GET2(cc, 1 + IMM2_SIZE);\n  if (max == 0)\n    return (*cc == OP_CRRANGE) ? 2 : 1;\n  max -= min;\n  if (max > 2)\n    max = 2;\n  return max;\n\n  default:\n  return 0;\n  }\n}\n\nstatic BOOL detect_repeat(compiler_common *common, PCRE2_SPTR begin)\n{\nPCRE2_SPTR end = bracketend(begin);\nPCRE2_SPTR next;\nPCRE2_SPTR next_end;\nPCRE2_SPTR max_end;\nPCRE2_UCHAR type;\nsljit_sw length = end - begin;\nsljit_s32 min, max, i;\n\n/* Detect fixed iterations first. */\nif (end[-(1 + LINK_SIZE)] != OP_KET || PRIVATE_DATA(begin) != 0)\n  return FALSE;\n\n/* /(?:AB){4,6}/ is currently converted to /(?:AB){3}(?AB){1,3}/\n * Skip the check of the second part. */\nif (PRIVATE_DATA(end - LINK_SIZE) != 0)\n  return TRUE;\n\nnext = end;\nmin = 1;\nwhile (1)\n  {\n  if (*next != *begin)\n    break;\n  next_end = bracketend(next);\n  if (next_end - next != length || memcmp(begin, next, IN_UCHARS(length)) != 0)\n    break;\n  next = next_end;\n  min++;\n  }\n\nif (min == 2)\n  return FALSE;\n\nmax = 0;\nmax_end = next;\nif (*next == OP_BRAZERO || *next == OP_BRAMINZERO)\n  {\n  type = *next;\n  while (1)\n    {\n    if (next[0] != type || next[1] != OP_BRA || next[2 + LINK_SIZE] != *begin)\n      break;\n    next_end = bracketend(next + 2 + LINK_SIZE);\n    if (next_end - next != (length + 2 + LINK_SIZE) || memcmp(begin, next + 2 + LINK_SIZE, IN_UCHARS(length)) != 0)\n      break;\n    next = next_end;\n    max++;\n    }\n\n  if (next[0] == type && next[1] == *begin && max >= 1)\n    {\n    next_end = bracketend(next + 1);\n    if (next_end - next == (length + 1) && memcmp(begin, next + 1, IN_UCHARS(length)) == 0)\n      {\n      for (i = 0; i < max; i++, next_end += 1 + LINK_SIZE)\n        if (*next_end != OP_KET)\n          break;\n\n      if (i == max)\n        {\n        common->private_data_ptrs[max_end - common->start - LINK_SIZE] = next_end - max_end;\n        common->private_data_ptrs[max_end - common->start - LINK_SIZE + 1] = (type == OP_BRAZERO) ? OP_UPTO : OP_MINUPTO;\n        /* +2 the original and the last. */\n        common->private_data_ptrs[max_end - common->start - LINK_SIZE + 2] = max + 2;\n        if (min == 1)\n          return TRUE;\n        min--;\n        max_end -= (1 + LINK_SIZE) + GET(max_end, -LINK_SIZE);\n        }\n      }\n    }\n  }\n\nif (min >= 3)\n  {\n  common->private_data_ptrs[end - common->start - LINK_SIZE] = max_end - end;\n  common->private_data_ptrs[end - common->start - LINK_SIZE + 1] = OP_EXACT;\n  common->private_data_ptrs[end - common->start - LINK_SIZE + 2] = min;\n  return TRUE;\n  }\n\nreturn FALSE;\n}\n\n#define CASE_ITERATOR_PRIVATE_DATA_1 \\\n    case OP_MINSTAR: \\\n    case OP_MINPLUS: \\\n    case OP_QUERY: \\\n    case OP_MINQUERY: \\\n    case OP_MINSTARI: \\\n    case OP_MINPLUSI: \\\n    case OP_QUERYI: \\\n    case OP_MINQUERYI: \\\n    case OP_NOTMINSTAR: \\\n    case OP_NOTMINPLUS: \\\n    case OP_NOTQUERY: \\\n    case OP_NOTMINQUERY: \\\n    case OP_NOTMINSTARI: \\\n    case OP_NOTMINPLUSI: \\\n    case OP_NOTQUERYI: \\\n    case OP_NOTMINQUERYI:\n\n#define CASE_ITERATOR_PRIVATE_DATA_2A \\\n    case OP_STAR: \\\n    case OP_PLUS: \\\n    case OP_STARI: \\\n    case OP_PLUSI: \\\n    case OP_NOTSTAR: \\\n    case OP_NOTPLUS: \\\n    case OP_NOTSTARI: \\\n    case OP_NOTPLUSI:\n\n#define CASE_ITERATOR_PRIVATE_DATA_2B \\\n    case OP_UPTO: \\\n    case OP_MINUPTO: \\\n    case OP_UPTOI: \\\n    case OP_MINUPTOI: \\\n    case OP_NOTUPTO: \\\n    case OP_NOTMINUPTO: \\\n    case OP_NOTUPTOI: \\\n    case OP_NOTMINUPTOI:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_1 \\\n    case OP_TYPEMINSTAR: \\\n    case OP_TYPEMINPLUS: \\\n    case OP_TYPEQUERY: \\\n    case OP_TYPEMINQUERY:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_2A \\\n    case OP_TYPESTAR: \\\n    case OP_TYPEPLUS:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_2B \\\n    case OP_TYPEUPTO: \\\n    case OP_TYPEMINUPTO:\n\nstatic void set_private_data_ptrs(compiler_common *common, int *private_data_start, PCRE2_SPTR ccend)\n{\nPCRE2_SPTR cc = common->start;\nPCRE2_SPTR alternative;\nPCRE2_SPTR end = NULL;\nint private_data_ptr = *private_data_start;\nint space, size, bracketlen;\nBOOL repeat_check = TRUE;\n\nwhile (cc < ccend)\n  {\n  space = 0;\n  size = 0;\n  bracketlen = 0;\n  if (private_data_ptr > SLJIT_MAX_LOCAL_SIZE)\n    break;\n\n  /* When the bracket is prefixed by a zero iteration, skip the repeat check (at this point). */\n  if (repeat_check && (*cc == OP_ONCE || *cc == OP_BRA || *cc == OP_CBRA || *cc == OP_COND))\n    {\n    if (detect_repeat(common, cc))\n      {\n      /* These brackets are converted to repeats, so no global\n      based single character repeat is allowed. */\n      if (cc >= end)\n        end = bracketend(cc);\n      }\n    }\n  repeat_check = TRUE;\n\n  switch(*cc)\n    {\n    case OP_KET:\n    if (common->private_data_ptrs[cc + 1 - common->start] != 0)\n      {\n      common->private_data_ptrs[cc - common->start] = private_data_ptr;\n      private_data_ptr += sizeof(sljit_sw);\n      cc += common->private_data_ptrs[cc + 1 - common->start];\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    common->private_data_ptrs[cc - common->start] = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw);\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    common->private_data_ptrs[cc - common->start] = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw);\n    bracketlen = 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    common->private_data_ptrs[cc - common->start] = 0;\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      {\n      common->private_data_ptrs[cc - common->start] = private_data_ptr;\n      private_data_ptr += sizeof(sljit_sw);\n      }\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_BRA:\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    bracketlen = 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_BRAZERO:\n    case OP_BRAMINZERO:\n    case OP_BRAPOSZERO:\n    size = 1;\n    repeat_check = FALSE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    size = -2;\n    space = 1;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    size = -2;\n    space = 2;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    size = -(2 + IMM2_SIZE);\n    space = 2;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    size = 1;\n    space = 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    size = 1;\n    if (cc[1] != OP_ANYNL && cc[1] != OP_EXTUNI)\n      space = 2;\n    break;\n\n    case OP_TYPEUPTO:\n    size = 1 + IMM2_SIZE;\n    if (cc[1 + IMM2_SIZE] != OP_ANYNL && cc[1 + IMM2_SIZE] != OP_EXTUNI)\n      space = 2;\n    break;\n\n    case OP_TYPEMINUPTO:\n    size = 1 + IMM2_SIZE;\n    space = 2;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    size = 1 + 32 / sizeof(PCRE2_UCHAR);\n    space = get_class_iterator_size(cc + size);\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = GET(cc, 1);\n    space = get_class_iterator_size(cc + size);\n    break;\n#endif\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n  /* Character iterators, which are not inside a repeated bracket,\n     gets a private slot instead of allocating it on the stack. */\n  if (space > 0 && cc >= end)\n    {\n    common->private_data_ptrs[cc - common->start] = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw) * space;\n    }\n\n  if (size != 0)\n    {\n    if (size < 0)\n      {\n      cc += -size;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      }\n    else\n      cc += size;\n    }\n\n  if (bracketlen > 0)\n    {\n    if (cc >= end)\n      {\n      end = bracketend(cc);\n      if (end[-1 - LINK_SIZE] == OP_KET)\n        end = NULL;\n      }\n    cc += bracketlen;\n    }\n  }\n*private_data_start = private_data_ptr;\n}\n\n/* Returns with a frame_types (always < 0) if no need for frame. */\nstatic int get_framesize(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, BOOL recursive, BOOL *needs_control_head)\n{\nint length = 0;\nint possessive = 0;\nBOOL stack_restore = FALSE;\nBOOL setsom_found = recursive;\nBOOL setmark_found = recursive;\n/* The last capture is a local variable even for recursions. */\nBOOL capture_last_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\n*needs_control_head = TRUE;\n#else\n*needs_control_head = FALSE;\n#endif\n\nif (ccend == NULL)\n  {\n  ccend = bracketend(cc) - (1 + LINK_SIZE);\n  if (!recursive && (*cc == OP_CBRAPOS || *cc == OP_SCBRAPOS))\n    {\n    possessive = length = (common->capture_last_ptr != 0) ? 5 : 3;\n    /* This is correct regardless of common->capture_last_ptr. */\n    capture_last_found = TRUE;\n    }\n  cc = next_opcode(common, cc);\n  }\n\nSLJIT_ASSERT(cc != NULL);\nwhile (cc < ccend)\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    stack_restore = TRUE;\n    if (!setsom_found)\n      {\n      length += 2;\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    stack_restore = TRUE;\n    if (!setmark_found)\n      {\n      length += 2;\n      setmark_found = TRUE;\n      }\n    if (common->control_head_ptr != 0)\n      *needs_control_head = TRUE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_RECURSE:\n    stack_restore = TRUE;\n    if (common->has_set_som && !setsom_found)\n      {\n      length += 2;\n      setsom_found = TRUE;\n      }\n    if (common->mark_ptr != 0 && !setmark_found)\n      {\n      length += 2;\n      setmark_found = TRUE;\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      length += 2;\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    case OP_SCBRA:\n    case OP_SCBRAPOS:\n    stack_restore = TRUE;\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      length += 2;\n      capture_last_found = TRUE;\n      }\n    length += 3;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_THEN:\n    stack_restore = TRUE;\n    if (common->control_head_ptr != 0)\n      *needs_control_head = TRUE;\n    cc ++;\n    break;\n\n    default:\n    stack_restore = TRUE;\n    /* Fall through. */\n\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n    case OP_ANYBYTE:\n    case OP_NOTPROP:\n    case OP_PROP:\n    case OP_ANYNL:\n    case OP_NOT_HSPACE:\n    case OP_HSPACE:\n    case OP_NOT_VSPACE:\n    case OP_VSPACE:\n    case OP_EXTUNI:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CHAR:\n    case OP_CHARI:\n    case OP_NOT:\n    case OP_NOTI:\n\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    case OP_XCLASS:\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n/* Possessive quantifiers can use a special case. */\nif (SLJIT_UNLIKELY(possessive == length))\n  return stack_restore ? no_frame : no_stack;\n\nif (length > 0)\n  return length + 1;\nreturn stack_restore ? no_frame : no_stack;\n}\n\nstatic void init_frame(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, int stackpos, int stacktop)\n{\nDEFINE_COMPILER;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\n/* The last capture is a local variable even for recursions. */\nBOOL capture_last_found = FALSE;\nint offset;\n\n/* >= 1 + shortest item size (2) */\nSLJIT_UNUSED_ARG(stacktop);\nSLJIT_ASSERT(stackpos >= stacktop + 2);\n\nstackpos = STACK(stackpos);\nif (ccend == NULL)\n  {\n  ccend = bracketend(cc) - (1 + LINK_SIZE);\n  if (*cc != OP_CBRAPOS && *cc != OP_SCBRAPOS)\n    cc = next_opcode(common, cc);\n  }\n\nSLJIT_ASSERT(cc != NULL);\nwhile (cc < ccend)\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    if (!setsom_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -OVECTOR(0));\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->mark_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setmark_found = TRUE;\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som && !setsom_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -OVECTOR(0));\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setsom_found = TRUE;\n      }\n    if (common->mark_ptr != 0 && !setmark_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->mark_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setmark_found = TRUE;\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->capture_last_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    case OP_SCBRA:\n    case OP_SCBRAPOS:\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->capture_last_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      capture_last_found = TRUE;\n      }\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, OVECTOR(offset));\n    stackpos -= (int)sizeof(sljit_sw);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n    stackpos -= (int)sizeof(sljit_sw);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP2, 0);\n    stackpos -= (int)sizeof(sljit_sw);\n\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, 0);\nSLJIT_ASSERT(stackpos == STACK(stacktop));\n}\n\n#define RECURSE_TMP_REG_COUNT 3\n\ntypedef struct delayed_mem_copy_status {\n  struct sljit_compiler *compiler;\n  int store_bases[RECURSE_TMP_REG_COUNT];\n  int store_offsets[RECURSE_TMP_REG_COUNT];\n  int tmp_regs[RECURSE_TMP_REG_COUNT];\n  int saved_tmp_regs[RECURSE_TMP_REG_COUNT];\n  int next_tmp_reg;\n} delayed_mem_copy_status;\n\nstatic void delayed_mem_copy_init(delayed_mem_copy_status *status, compiler_common *common)\n{\nint i;\n\nfor (i = 0; i < RECURSE_TMP_REG_COUNT; i++)\n  {\n  SLJIT_ASSERT(status->tmp_regs[i] >= 0);\n  SLJIT_ASSERT(sljit_get_register_index(status->saved_tmp_regs[i]) < 0 || status->tmp_regs[i] == status->saved_tmp_regs[i]);\n\n  status->store_bases[i] = -1;\n  }\nstatus->next_tmp_reg = 0;\nstatus->compiler = common->compiler;\n}\n\nstatic void delayed_mem_copy_move(delayed_mem_copy_status *status, int load_base, sljit_sw load_offset,\n  int store_base, sljit_sw store_offset)\n{\nstruct sljit_compiler *compiler = status->compiler;\nint next_tmp_reg = status->next_tmp_reg;\nint tmp_reg = status->tmp_regs[next_tmp_reg];\n\nSLJIT_ASSERT(load_base > 0 && store_base > 0);\n\nif (status->store_bases[next_tmp_reg] == -1)\n  {\n  /* Preserve virtual registers. */\n  if (sljit_get_register_index(status->saved_tmp_regs[next_tmp_reg]) < 0)\n    OP1(SLJIT_MOV, status->saved_tmp_regs[next_tmp_reg], 0, tmp_reg, 0);\n  }\nelse\n  OP1(SLJIT_MOV, SLJIT_MEM1(status->store_bases[next_tmp_reg]), status->store_offsets[next_tmp_reg], tmp_reg, 0);\n\nOP1(SLJIT_MOV, tmp_reg, 0, SLJIT_MEM1(load_base), load_offset);\nstatus->store_bases[next_tmp_reg] = store_base;\nstatus->store_offsets[next_tmp_reg] = store_offset;\n\nstatus->next_tmp_reg = (next_tmp_reg + 1) % RECURSE_TMP_REG_COUNT;\n}\n\nstatic void delayed_mem_copy_finish(delayed_mem_copy_status *status)\n{\nstruct sljit_compiler *compiler = status->compiler;\nint next_tmp_reg = status->next_tmp_reg;\nint tmp_reg, saved_tmp_reg, i;\n\nfor (i = 0; i < RECURSE_TMP_REG_COUNT; i++)\n  {\n  if (status->store_bases[next_tmp_reg] != -1)\n    {\n    tmp_reg = status->tmp_regs[next_tmp_reg];\n    saved_tmp_reg = status->saved_tmp_regs[next_tmp_reg];\n\n    OP1(SLJIT_MOV, SLJIT_MEM1(status->store_bases[next_tmp_reg]), status->store_offsets[next_tmp_reg], tmp_reg, 0);\n\n    /* Restore virtual registers. */\n    if (sljit_get_register_index(saved_tmp_reg) < 0)\n      OP1(SLJIT_MOV, tmp_reg, 0, saved_tmp_reg, 0);\n    }\n\n  next_tmp_reg = (next_tmp_reg + 1) % RECURSE_TMP_REG_COUNT;\n  }\n}\n\n#undef RECURSE_TMP_REG_COUNT\n\nstatic int get_recurse_data_length(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  BOOL *needs_control_head, BOOL *has_quit, BOOL *has_accept)\n{\nint length = 1;\nint size;\nPCRE2_SPTR alternative;\nBOOL quit_found = FALSE;\nBOOL accept_found = FALSE;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL capture_last_found = FALSE;\nBOOL control_head_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\n/* Calculate the sum of the private machine words. */\nwhile (cc < ccend)\n  {\n  size = 0;\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    setsom_found = TRUE;\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som)\n      setsom_found = TRUE;\n    if (common->mark_ptr != 0)\n      setmark_found = TRUE;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    if (PRIVATE_DATA(cc) != 0)\n      {\n      length++;\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    length++;\n    SLJIT_ASSERT(PRIVATE_DATA(cc) != 0);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    length += 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)\n      length++;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    length += 2 + 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    size = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n    if (PRIVATE_DATA(cc) != 0)\n      length += get_class_iterator_size(cc + size);\n    cc += size;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      setmark_found = TRUE;\n    if (common->control_head_ptr != 0)\n      control_head_found = TRUE;\n    if (*cc != OP_MARK)\n      quit_found = TRUE;\n\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_SKIP:\n    case OP_COMMIT:\n    quit_found = TRUE;\n    cc++;\n    break;\n\n    case OP_SKIP_ARG:\n    quit_found = TRUE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    quit_found = TRUE;\n    if (!control_head_found)\n      control_head_found = TRUE;\n    cc++;\n    break;\n\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    accept_found = TRUE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n  }\nSLJIT_ASSERT(cc == ccend);\n\nif (control_head_found)\n  length++;\nif (capture_last_found)\n  length++;\nif (quit_found)\n  {\n  if (setsom_found)\n    length++;\n  if (setmark_found)\n    length++;\n  }\n\n*needs_control_head = control_head_found;\n*has_quit = quit_found;\n*has_accept = accept_found;\nreturn length;\n}\n\nenum copy_recurse_data_types {\n  recurse_copy_from_global,\n  recurse_copy_private_to_global,\n  recurse_copy_shared_to_global,\n  recurse_copy_kept_shared_to_global,\n  recurse_swap_global\n};\n\nstatic void copy_recurse_data(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  int type, int stackptr, int stacktop, BOOL has_quit)\n{\ndelayed_mem_copy_status status;\nPCRE2_SPTR alternative;\nsljit_sw private_srcw[2];\nsljit_sw shared_srcw[3];\nsljit_sw kept_shared_srcw[2];\nint private_count, shared_count, kept_shared_count;\nint from_sp, base_reg, offset, i;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL capture_last_found = FALSE;\nBOOL control_head_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\nswitch (type)\n  {\n  case recurse_copy_from_global:\n  from_sp = TRUE;\n  base_reg = STACK_TOP;\n  break;\n\n  case recurse_copy_private_to_global:\n  case recurse_copy_shared_to_global:\n  case recurse_copy_kept_shared_to_global:\n  from_sp = FALSE;\n  base_reg = STACK_TOP;\n  break;\n\n  default:\n  SLJIT_ASSERT(type == recurse_swap_global);\n  from_sp = FALSE;\n  base_reg = TMP2;\n  break;\n  }\n\nstackptr = STACK(stackptr);\nstacktop = STACK(stacktop);\n\nstatus.tmp_regs[0] = TMP1;\nstatus.saved_tmp_regs[0] = TMP1;\n\nif (base_reg != TMP2)\n  {\n  status.tmp_regs[1] = TMP2;\n  status.saved_tmp_regs[1] = TMP2;\n  }\nelse\n  {\n  status.saved_tmp_regs[1] = RETURN_ADDR;\n  if (HAS_VIRTUAL_REGISTERS)\n    status.tmp_regs[1] = STR_PTR;\n  else\n    status.tmp_regs[1] = RETURN_ADDR;\n  }\n\nstatus.saved_tmp_regs[2] = TMP3;\nif (HAS_VIRTUAL_REGISTERS)\n  status.tmp_regs[2] = STR_END;\nelse\n  status.tmp_regs[2] = TMP3;\n\ndelayed_mem_copy_init(&status, common);\n\nif (type != recurse_copy_shared_to_global && type != recurse_copy_kept_shared_to_global)\n  {\n  SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_private_to_global || type == recurse_swap_global);\n\n  if (!from_sp)\n    delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, common->recursive_head_ptr);\n\n  if (from_sp || type == recurse_swap_global)\n    delayed_mem_copy_move(&status, SLJIT_SP, common->recursive_head_ptr, base_reg, stackptr);\n  }\n\nstackptr += sizeof(sljit_sw);\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nif (type != recurse_copy_shared_to_global)\n  {\n  if (!from_sp)\n    delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, common->control_head_ptr);\n\n  if (from_sp || type == recurse_swap_global)\n    delayed_mem_copy_move(&status, SLJIT_SP, common->control_head_ptr, base_reg, stackptr);\n  }\n\nstackptr += sizeof(sljit_sw);\n#endif\n\nwhile (cc < ccend)\n  {\n  private_count = 0;\n  shared_count = 0;\n  kept_shared_count = 0;\n\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    if (has_quit && !setsom_found)\n      {\n      kept_shared_srcw[0] = OVECTOR(0);\n      kept_shared_count = 1;\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (has_quit)\n      {\n      if (common->has_set_som && !setsom_found)\n        {\n        kept_shared_srcw[0] = OVECTOR(0);\n        kept_shared_count = 1;\n        setsom_found = TRUE;\n        }\n      if (common->mark_ptr != 0 && !setmark_found)\n        {\n        kept_shared_srcw[kept_shared_count] = common->mark_ptr;\n        kept_shared_count++;\n        setmark_found = TRUE;\n        }\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw[0] = common->capture_last_ptr;\n      shared_count = 1;\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    if (PRIVATE_DATA(cc) != 0)\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    private_count = 1;\n    private_srcw[0] = PRIVATE_DATA(cc);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    shared_srcw[0] = OVECTOR(offset);\n    shared_srcw[1] = OVECTOR(offset + 1);\n    shared_count = 2;\n\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw[2] = common->capture_last_ptr;\n      shared_count = 3;\n      capture_last_found = TRUE;\n      }\n\n    if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)\n      {\n      private_count = 1;\n      private_srcw[0] = OVECTOR_PRIV(GET2(cc, 1 + LINK_SIZE));\n      }\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    shared_srcw[0] = OVECTOR(offset);\n    shared_srcw[1] = OVECTOR(offset + 1);\n    shared_count = 2;\n\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw[2] = common->capture_last_ptr;\n      shared_count = 3;\n      capture_last_found = TRUE;\n      }\n\n    private_count = 2;\n    private_srcw[0] = PRIVATE_DATA(cc);\n    private_srcw[1] = OVECTOR_PRIV(GET2(cc, 1 + LINK_SIZE));\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = PRIVATE_DATA(cc) + sizeof(sljit_sw);\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = PRIVATE_DATA(cc) + sizeof(sljit_sw);\n      }\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n      }\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    i = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    i = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n    if (PRIVATE_DATA(cc) != 0)\n      switch(get_class_iterator_size(cc + i))\n        {\n        case 1:\n        private_count = 1;\n        private_srcw[0] = PRIVATE_DATA(cc);\n        break;\n\n        case 2:\n        private_count = 2;\n        private_srcw[0] = PRIVATE_DATA(cc);\n        private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n        break;\n\n        default:\n        SLJIT_UNREACHABLE();\n        break;\n        }\n    cc += i;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (has_quit && !setmark_found)\n      {\n      kept_shared_srcw[0] = common->mark_ptr;\n      kept_shared_count = 1;\n      setmark_found = TRUE;\n      }\n    if (common->control_head_ptr != 0 && !control_head_found)\n      {\n      private_srcw[0] = common->control_head_ptr;\n      private_count = 1;\n      control_head_found = TRUE;\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    if (!control_head_found)\n      {\n      private_srcw[0] = common->control_head_ptr;\n      private_count = 1;\n      control_head_found = TRUE;\n      }\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n  if (type != recurse_copy_shared_to_global && type != recurse_copy_kept_shared_to_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_private_to_global || type == recurse_swap_global);\n\n    for (i = 0; i < private_count; i++)\n      {\n      SLJIT_ASSERT(private_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, private_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, private_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * private_count;\n\n  if (type != recurse_copy_private_to_global && type != recurse_copy_kept_shared_to_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_shared_to_global || type == recurse_swap_global);\n\n    for (i = 0; i < shared_count; i++)\n      {\n      SLJIT_ASSERT(shared_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, shared_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, shared_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * shared_count;\n\n  if (type != recurse_copy_private_to_global && type != recurse_swap_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_shared_to_global || type == recurse_copy_kept_shared_to_global);\n\n    for (i = 0; i < kept_shared_count; i++)\n      {\n      SLJIT_ASSERT(kept_shared_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, kept_shared_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, kept_shared_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * kept_shared_count;\n  }\n\nSLJIT_ASSERT(cc == ccend && stackptr == stacktop);\n\ndelayed_mem_copy_finish(&status);\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR set_then_offsets(compiler_common *common, PCRE2_SPTR cc, sljit_u8 *current_offset)\n{\nPCRE2_SPTR end = bracketend(cc);\nBOOL has_alternatives = cc[GET(cc, 1)] == OP_ALT;\n\n/* Assert captures then. */\nif (*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA)\n  current_offset = NULL;\n/* Conditional block does not. */\nif (*cc == OP_COND || *cc == OP_SCOND)\n  has_alternatives = FALSE;\n\ncc = next_opcode(common, cc);\nif (has_alternatives)\n  current_offset = common->then_offsets + (cc - common->start);\n\nwhile (cc < end)\n  {\n  if ((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND))\n    cc = set_then_offsets(common, cc, current_offset);\n  else\n    {\n    if (*cc == OP_ALT && has_alternatives)\n      current_offset = common->then_offsets + (cc + 1 + LINK_SIZE - common->start);\n    if (*cc >= OP_THEN && *cc <= OP_THEN_ARG && current_offset != NULL)\n      *current_offset = 1;\n    cc = next_opcode(common, cc);\n    }\n  }\n\nreturn end;\n}\n\n#undef CASE_ITERATOR_PRIVATE_DATA_1\n#undef CASE_ITERATOR_PRIVATE_DATA_2A\n#undef CASE_ITERATOR_PRIVATE_DATA_2B\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n\nstatic SLJIT_INLINE BOOL is_powerof2(unsigned int value)\n{\nreturn (value & (value - 1)) == 0;\n}\n\nstatic SLJIT_INLINE void set_jumps(jump_list *list, struct sljit_label *label)\n{\nwhile (list)\n  {\n  /* sljit_set_label is clever enough to do nothing\n  if either the jump or the label is NULL. */\n  SET_LABEL(list->jump, label);\n  list = list->next;\n  }\n}\n\nstatic SLJIT_INLINE void add_jump(struct sljit_compiler *compiler, jump_list **list, struct sljit_jump *jump)\n{\njump_list *list_item = sljit_alloc_memory(compiler, sizeof(jump_list));\nif (list_item)\n  {\n  list_item->next = *list;\n  list_item->jump = jump;\n  *list = list_item;\n  }\n}\n\nstatic void add_stub(compiler_common *common, struct sljit_jump *start)\n{\nDEFINE_COMPILER;\nstub_list *list_item = sljit_alloc_memory(compiler, sizeof(stub_list));\n\nif (list_item)\n  {\n  list_item->start = start;\n  list_item->quit = LABEL();\n  list_item->next = common->stubs;\n  common->stubs = list_item;\n  }\n}\n\nstatic void flush_stubs(compiler_common *common)\n{\nDEFINE_COMPILER;\nstub_list *list_item = common->stubs;\n\nwhile (list_item)\n  {\n  JUMPHERE(list_item->start);\n  add_jump(compiler, &common->stackalloc, JUMP(SLJIT_FAST_CALL));\n  JUMPTO(SLJIT_JUMP, list_item->quit);\n  list_item = list_item->next;\n  }\ncommon->stubs = NULL;\n}\n\nstatic SLJIT_INLINE void count_match(compiler_common *common)\n{\nDEFINE_COMPILER;\n\nOP2(SLJIT_SUB | SLJIT_SET_Z, COUNT_MATCH, 0, COUNT_MATCH, 0, SLJIT_IMM, 1);\nadd_jump(compiler, &common->calllimit, JUMP(SLJIT_ZERO));\n}\n\nstatic SLJIT_INLINE void allocate_stack(compiler_common *common, int size)\n{\n/* May destroy all locals and registers except TMP2. */\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(size > 0);\nOP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * sizeof(sljit_sw));\n#ifdef DESTROY_REGISTERS\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 12345);\nOP1(SLJIT_MOV, TMP3, 0, TMP1, 0);\nOP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP1, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, TMP1, 0);\n#endif\nadd_stub(common, CMP(SLJIT_LESS, STACK_TOP, 0, STACK_LIMIT, 0));\n}\n\nstatic SLJIT_INLINE void free_stack(compiler_common *common, int size)\n{\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(size > 0);\nOP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * sizeof(sljit_sw));\n}\n\nstatic sljit_uw * allocate_read_only_data(compiler_common *common, sljit_uw size)\n{\nDEFINE_COMPILER;\nsljit_uw *result;\n\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  return NULL;\n\nresult = (sljit_uw *)SLJIT_MALLOC(size + sizeof(sljit_uw), compiler->allocator_data);\nif (SLJIT_UNLIKELY(result == NULL))\n  {\n  sljit_set_compiler_memory_error(compiler);\n  return NULL;\n  }\n\n*(void**)result = common->read_only_data_head;\ncommon->read_only_data_head = (void *)result;\nreturn result + 1;\n}\n\nstatic SLJIT_INLINE void reset_ovector(compiler_common *common, int length)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nsljit_s32 i;\n\n/* At this point we can freely use all temporary registers. */\nSLJIT_ASSERT(length > 1);\n/* TMP1 returns with begin - 1. */\nOP2(SLJIT_SUB, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_S0), SLJIT_OFFSETOF(jit_arguments, begin), SLJIT_IMM, IN_UCHARS(1));\nif (length < 8)\n  {\n  for (i = 1; i < length; i++)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(i), SLJIT_R0, 0);\n  }\nelse\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw)) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(SLJIT_R1, 0, OVECTOR_START);\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_IMM, length - 1);\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  else\n    {\n    GET_LOCAL_BASE(SLJIT_R1, 0, OVECTOR_START + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_IMM, length - 1);\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R1), 0, SLJIT_R0, 0);\n    OP2(SLJIT_ADD, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  }\n}\n\nstatic SLJIT_INLINE void reset_early_fail(compiler_common *common)\n{\nDEFINE_COMPILER;\nsljit_u32 size = (sljit_u32)(common->early_fail_end_ptr - common->early_fail_start_ptr);\nsljit_u32 uncleared_size;\nsljit_s32 src = SLJIT_IMM;\nsljit_s32 i;\nstruct sljit_label *loop;\n\nSLJIT_ASSERT(common->early_fail_start_ptr < common->early_fail_end_ptr);\n\nif (size == sizeof(sljit_sw))\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->early_fail_start_ptr, SLJIT_IMM, 0);\n  return;\n  }\n\nif (sljit_get_register_index(TMP3) >= 0 && !sljit_has_cpu_feature(SLJIT_HAS_ZERO_REGISTER))\n  {\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, 0);\n  src = TMP3;\n  }\n\nif (size <= 6 * sizeof(sljit_sw))\n  {\n  for (i = common->early_fail_start_ptr; i < common->early_fail_end_ptr; i += sizeof(sljit_sw))\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), i, src, 0);\n  return;\n  }\n\nGET_LOCAL_BASE(TMP1, 0, common->early_fail_start_ptr);\n\nuncleared_size = ((size / sizeof(sljit_sw)) % 3) * sizeof(sljit_sw);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, size - uncleared_size);\n\nloop = LABEL();\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), 0, src, 0);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -2 * (sljit_sw)sizeof(sljit_sw), src, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -1 * (sljit_sw)sizeof(sljit_sw), src, 0);\nCMPTO(SLJIT_LESS, TMP1, 0, TMP2, 0, loop);\n\nif (uncleared_size >= sizeof(sljit_sw))\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), 0, src, 0);\n\nif (uncleared_size >= 2 * sizeof(sljit_sw))\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), sizeof(sljit_sw), src, 0);\n}\n\nstatic SLJIT_INLINE void do_reset_match(compiler_common *common, int length)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nint i;\n\nSLJIT_ASSERT(length > 1);\n/* OVECTOR(1) contains the \"string begin - 1\" constant. */\nif (length > 2)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\nif (length < 8)\n  {\n  for (i = 2; i < length; i++)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(i), TMP1, 0);\n  }\nelse\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw)) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(TMP2, 0, OVECTOR_START + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_IMM, length - 2);\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  else\n    {\n    GET_LOCAL_BASE(TMP2, 0, OVECTOR_START + 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_IMM, length - 2);\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP1, 0);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  }\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, stack));\nelse\n  OP1(SLJIT_MOV, STACK_TOP, 0, ARGUMENTS, 0);\n\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, SLJIT_IMM, 0);\nif (common->control_head_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), SLJIT_OFFSETOF(jit_arguments, stack));\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), SLJIT_OFFSETOF(struct sljit_stack, end));\n}\n\nstatic sljit_sw SLJIT_FUNC do_search_mark(sljit_sw *current, PCRE2_SPTR skip_arg)\n{\nwhile (current != NULL)\n  {\n  switch (current[1])\n    {\n    case type_then_trap:\n    break;\n\n    case type_mark:\n    if (PRIV(strcmp)(skip_arg, (PCRE2_SPTR)current[2]) == 0)\n      return current[3];\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    break;\n    }\n  SLJIT_ASSERT(current[0] == 0 || current < (sljit_sw*)current[0]);\n  current = (sljit_sw*)current[0];\n  }\nreturn 0;\n}\n\nstatic SLJIT_INLINE void copy_ovector(compiler_common *common, int topbracket)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nBOOL has_pre;\n\n/* At this point we can freely use all registers. */\nOP1(SLJIT_MOV, SLJIT_S2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(1), STR_PTR, 0);\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, SLJIT_S0, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n  OP1(SLJIT_MOV_U32, SLJIT_R1, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, oveccount));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_S0, 0);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, mark_ptr), SLJIT_R2, 0);\n  OP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, match_data),\n    SLJIT_IMM, SLJIT_OFFSETOF(pcre2_match_data, ovector) - sizeof(PCRE2_SIZE));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, SLJIT_S0, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, match_data));\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n  OP1(SLJIT_MOV_U32, SLJIT_R1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, oveccount));\n  OP1(SLJIT_MOV, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_S0, 0);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), SLJIT_R0, 0);\n  OP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, SLJIT_OFFSETOF(pcre2_match_data, ovector) - sizeof(PCRE2_SIZE));\n  }\n\nhas_pre = sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw)) == SLJIT_SUCCESS;\n\nGET_LOCAL_BASE(SLJIT_S0, 0, OVECTOR_START - (has_pre ? sizeof(sljit_sw) : 0));\nOP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? SLJIT_R0 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n\nloop = LABEL();\n\nif (has_pre)\n  sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw));\nelse\n  {\n  OP1(SLJIT_MOV, SLJIT_S1, 0, SLJIT_MEM1(SLJIT_S0), 0);\n  OP2(SLJIT_ADD, SLJIT_S0, 0, SLJIT_S0, 0, SLJIT_IMM, sizeof(sljit_sw));\n  }\n\nOP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, sizeof(PCRE2_SIZE));\nOP2(SLJIT_SUB, SLJIT_S1, 0, SLJIT_S1, 0, SLJIT_R0, 0);\n/* Copy the integer value to the output buffer */\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, SLJIT_S1, 0, SLJIT_S1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n\nSLJIT_ASSERT(sizeof(PCRE2_SIZE) == 4 || sizeof(PCRE2_SIZE) == 8);\nOP1(((sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV), SLJIT_MEM1(SLJIT_R2), 0, SLJIT_S1, 0);\n\nOP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\nJUMPTO(SLJIT_NOT_ZERO, loop);\n\n/* Calculate the return value, which is the maximum ovector value. */\nif (topbracket > 1)\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * (sljit_sw)sizeof(sljit_sw))) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(SLJIT_R0, 0, OVECTOR_START + topbracket * 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, topbracket + 1);\n\n    /* OVECTOR(0) is never equal to SLJIT_S2. */\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * (sljit_sw)sizeof(sljit_sw)));\n    OP2(SLJIT_SUB, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\n    CMPTO(SLJIT_EQUAL, SLJIT_R2, 0, SLJIT_S2, 0, loop);\n    OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_R1, 0);\n    }\n  else\n    {\n    GET_LOCAL_BASE(SLJIT_R0, 0, OVECTOR_START + (topbracket - 1) * 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, topbracket + 1);\n\n    /* OVECTOR(0) is never equal to SLJIT_S2. */\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_R0), 0);\n    OP2(SLJIT_SUB, SLJIT_R0, 0, SLJIT_R0, 0, SLJIT_IMM, 2 * (sljit_sw)sizeof(sljit_sw));\n    OP2(SLJIT_SUB, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\n    CMPTO(SLJIT_EQUAL, SLJIT_R2, 0, SLJIT_S2, 0, loop);\n    OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_R1, 0);\n    }\n  }\nelse\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, 1);\n}\n\nstatic SLJIT_INLINE void return_with_partial_match(compiler_common *common, struct sljit_label *quit)\n{\nDEFINE_COMPILER;\nsljit_s32 mov_opcode;\nsljit_s32 arguments_reg = !HAS_VIRTUAL_REGISTERS ? ARGUMENTS : SLJIT_R1;\n\nSLJIT_COMPILE_ASSERT(STR_END == SLJIT_S0, str_end_must_be_saved_reg0);\nSLJIT_ASSERT(common->start_used_ptr != 0 && common->start_ptr != 0\n  && (common->mode == PCRE2_JIT_PARTIAL_SOFT ? common->hit_start != 0 : common->hit_start == 0));\n\nif (arguments_reg != ARGUMENTS)\n  OP1(SLJIT_MOV, arguments_reg, 0, ARGUMENTS, 0);\nOP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP),\n  common->mode == PCRE2_JIT_PARTIAL_SOFT ? common->hit_start : common->start_ptr);\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_PARTIAL);\n\n/* Store match begin and end. */\nOP1(SLJIT_MOV, SLJIT_S1, 0, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, begin));\nOP1(SLJIT_MOV, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_R2, 0);\nOP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, match_data));\n\nmov_opcode = (sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV;\n\nOP2(SLJIT_SUB, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_S1, 0);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\nOP1(mov_opcode, SLJIT_MEM1(SLJIT_R1), SLJIT_OFFSETOF(pcre2_match_data, ovector), SLJIT_R2, 0);\n\nOP2(SLJIT_SUB, STR_END, 0, STR_END, 0, SLJIT_S1, 0);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, STR_END, 0, STR_END, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\nOP1(mov_opcode, SLJIT_MEM1(SLJIT_R1), SLJIT_OFFSETOF(pcre2_match_data, ovector) + sizeof(PCRE2_SIZE), STR_END, 0);\n\nJUMPTO(SLJIT_JUMP, quit);\n}\n\nstatic SLJIT_INLINE void check_start_used_ptr(compiler_common *common)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  /* The value of -1 must be kept for start_used_ptr! */\n  OP2(SLJIT_ADD, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, 1);\n  /* Jumps if start_used_ptr < STR_PTR, or start_used_ptr == -1. Although overwriting\n  is not necessary if start_used_ptr == STR_PTR, it does not hurt as well. */\n  jump = CMP(SLJIT_LESS_EQUAL, TMP1, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\nelse if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n  {\n  jump = CMP(SLJIT_LESS_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\n}\n\nstatic SLJIT_INLINE BOOL char_has_othercase(compiler_common *common, PCRE2_SPTR cc)\n{\n/* Detects if the character has an othercase. */\nunsigned int c;\n\n#ifdef SUPPORT_UNICODE\nif (common->utf || common->ucp)\n  {\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n    c = *cc;\n\n  if (c > 127)\n    return c != UCD_OTHERCASE(c);\n\n  return common->fcc[c] != c;\n  }\nelse\n#endif\n  c = *cc;\nreturn MAX_255(c) ? common->fcc[c] != c : FALSE;\n}\n\nstatic SLJIT_INLINE unsigned int char_othercase(compiler_common *common, unsigned int c)\n{\n/* Returns with the othercase. */\n#ifdef SUPPORT_UNICODE\nif ((common->utf || common->ucp) && c > 127)\n  return UCD_OTHERCASE(c);\n#endif\nreturn TABLE_GET(c, common->fcc, c);\n}\n\nstatic unsigned int char_get_othercase_bit(compiler_common *common, PCRE2_SPTR cc)\n{\n/* Detects if the character and its othercase has only 1 bit difference. */\nunsigned int c, oc, bit;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nint n;\n#endif\n\n#ifdef SUPPORT_UNICODE\nif (common->utf || common->ucp)\n  {\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n    c = *cc;\n\n  if (c <= 127)\n    oc = common->fcc[c];\n  else\n    oc = UCD_OTHERCASE(c);\n  }\nelse\n  {\n  c = *cc;\n  oc = TABLE_GET(c, common->fcc, c);\n  }\n#else\nc = *cc;\noc = TABLE_GET(c, common->fcc, c);\n#endif\n\nSLJIT_ASSERT(c != oc);\n\nbit = c ^ oc;\n/* Optimized for English alphabet. */\nif (c <= 127 && bit == 0x20)\n  return (0 << 8) | 0x20;\n\n/* Since c != oc, they must have at least 1 bit difference. */\nif (!is_powerof2(bit))\n  return 0;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n\n#ifdef SUPPORT_UNICODE\nif (common->utf && c > 127)\n  {\n  n = GET_EXTRALEN(*cc);\n  while ((bit & 0x3f) == 0)\n    {\n    n--;\n    bit >>= 6;\n    }\n  return (n << 8) | bit;\n  }\n#endif /* SUPPORT_UNICODE */\nreturn (0 << 8) | bit;\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n\n#ifdef SUPPORT_UNICODE\nif (common->utf && c > 65535)\n  {\n  if (bit >= (1u << 10))\n    bit >>= 10;\n  else\n    return (bit < 256) ? ((2 << 8) | bit) : ((3 << 8) | (bit >> 8));\n  }\n#endif /* SUPPORT_UNICODE */\nreturn (bit < 256) ? ((0u << 8) | bit) : ((1u << 8) | (bit >> 8));\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n}\n\nstatic void check_partial(compiler_common *common, BOOL force)\n{\n/* Checks whether a partial matching is occurred. Does not modify registers. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump = NULL;\n\nSLJIT_ASSERT(!force || common->mode != PCRE2_JIT_COMPLETE);\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  return;\n\nif (!force && !common->allow_empty_partial)\n  jump = CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\nelse if (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  jump = CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1);\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\nelse\n  {\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\n\nif (jump != NULL)\n  JUMPHERE(jump);\n}\n\nstatic void check_str_end(compiler_common *common, jump_list **end_reached)\n{\n/* Does not affect registers. Usually used in a tight spot. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  return;\n  }\n\njump = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  add_jump(compiler, end_reached, JUMP(SLJIT_JUMP));\n  }\nelse\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\nJUMPHERE(jump);\n}\n\nstatic void detect_partial_match(compiler_common *common, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  {\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  return;\n  }\n\n/* Partial matching mode. */\njump = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\nif (!common->allow_empty_partial)\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\nelse if (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1));\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n  }\nelse\n  {\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\nJUMPHERE(jump);\n}\n\nstatic void process_partial_match(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\n/* Partial matching mode. */\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  jump = CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  JUMPHERE(jump);\n  }\nelse if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n  {\n  if (common->partialmatchlabel != NULL)\n    CMPTO(SLJIT_LESS, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, CMP(SLJIT_LESS, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  }\n}\n\nstatic void detect_partial_match_to(compiler_common *common, struct sljit_label *label)\n{\nDEFINE_COMPILER;\n\nCMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, label);\nprocess_partial_match(common);\n}\n\nstatic void peek_char(compiler_common *common, sljit_u32 max, sljit_s32 dst, sljit_sw dstw, jump_list **backtracks)\n{\n/* Reads the character into TMP1, keeps STR_PTR.\nDoes not check STR_END. TMP2, dst, RETURN_ADDR Destroyed. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\n\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(dst);\nSLJIT_UNUSED_ARG(dstw);\nSLJIT_UNUSED_ARG(backtracks);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128) return;\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n  OP1(SLJIT_MOV, dst, dstw, STR_PTR, 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  add_jump(compiler, common->invalid_utf ? &common->utfreadchar_invalid : &common->utfreadchar, JUMP(SLJIT_FAST_CALL));\n  OP1(SLJIT_MOV, STR_PTR, 0, dst, dstw);\n  if (backtracks && common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800) return;\n\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (common->invalid_utf)\n    {\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    OP1(SLJIT_MOV, dst, dstw, STR_PTR, 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    OP1(SLJIT_MOV, STR_PTR, 0, dst, dstw);\n    if (backtracks && common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    {\n    /* TMP2 contains the high surrogate. */\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xdc00 - 0xd800);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    }\n\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  if (max < 0xd800) return;\n\n  if (backtracks != NULL)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000);\n    CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n}\n\nstatic void peek_char_back(compiler_common *common, sljit_u32 max, jump_list **backtracks)\n{\n/* Reads one character back without moving STR_PTR. TMP2 must\ncontain the start of the subject buffer. Affects TMP1, TMP2, and RETURN_ADDR. */\nDEFINE_COMPILER;\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\n\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(backtracks);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128) return;\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfpeakcharback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    add_jump(compiler, &common->utfpeakcharback, JUMP(SLJIT_FAST_CALL));\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800) return;\n\n  if (common->invalid_utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, &common->utfpeakcharback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xdc00);\n    /* TMP2 contains the low surrogate. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x10000);\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    }\n    JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n}\n\n#define READ_CHAR_UPDATE_STR_PTR 0x1\n#define READ_CHAR_UTF8_NEWLINE 0x2\n#define READ_CHAR_NEWLINE (READ_CHAR_UPDATE_STR_PTR | READ_CHAR_UTF8_NEWLINE)\n#define READ_CHAR_VALID_UTF 0x4\n\nstatic void read_char(compiler_common *common, sljit_u32 min, sljit_u32 max,\n  jump_list **backtracks, sljit_u32 options)\n{\n/* Reads the precise value of a character into TMP1, if the character is\nbetween min and max (c >= min && c <= max). Otherwise it returns with a value\noutside the range. Does not check STR_END. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_jump *jump2;\n#endif\n\nSLJIT_UNUSED_ARG(min);\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(options);\nSLJIT_ASSERT(min <= max);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128 && !(options & READ_CHAR_UPDATE_STR_PTR)) return;\n\n  if (common->invalid_utf && !(options & READ_CHAR_VALID_UTF))\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n\n    if (options & READ_CHAR_UTF8_NEWLINE)\n      add_jump(compiler, &common->utfreadnewline_invalid, JUMP(SLJIT_FAST_CALL));\n    else\n      add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    JUMPHERE(jump);\n    return;\n    }\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n  if (min >= 0x10000)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xf0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump2);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  else if (min >= 0x800 && max <= 0xffff)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xe0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0xf);\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump2);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  else if (max >= 0x800)\n    {\n    add_jump(compiler, &common->utfreadchar, JUMP(SLJIT_FAST_CALL));\n    }\n  else if (max < 128)\n    {\n    OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n    }\n  else\n    {\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    else\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800 && !(options & READ_CHAR_UPDATE_STR_PTR)) return;\n\n  if (common->invalid_utf && !(options & READ_CHAR_VALID_UTF))\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n\n    if (options & READ_CHAR_UTF8_NEWLINE)\n      add_jump(compiler, &common->utfreadnewline_invalid, JUMP(SLJIT_FAST_CALL));\n    else\n      add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    JUMPHERE(jump);\n    return;\n    }\n\n  if (max >= 0x10000)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xdc00 - 0xd800);\n    /* TMP2 contains the high surrogate. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump);\n    return;\n    }\n\n  /* Skip low surrogate if necessary. */\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV) && !HAS_VIRTUAL_REGISTERS)\n    {\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, RETURN_ADDR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0x400);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      CMOV(SLJIT_LESS, STR_PTR, RETURN_ADDR, 0);\n    if (max >= 0xd800)\n      CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, 0x10000);\n    }\n  else\n    {\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    if (max >= 0xd800)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x10000);\n    JUMPHERE(jump);\n    }\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  if (backtracks != NULL)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000);\n    CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n}\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n\nstatic BOOL is_char7_bitset(const sljit_u8 *bitset, BOOL nclass)\n{\n/* Tells whether the character codes below 128 are enough\nto determine a match. */\nconst sljit_u8 value = nclass ? 0xff : 0;\nconst sljit_u8 *end = bitset + 32;\n\nbitset += 16;\ndo\n  {\n  if (*bitset++ != value)\n    return FALSE;\n  }\nwhile (bitset < end);\nreturn TRUE;\n}\n\nstatic void read_char7_type(compiler_common *common, jump_list **backtracks, BOOL negated)\n{\n/* Reads the precise character type of a character into TMP1, if the character\nis less than 128. Otherwise it returns with zero. Does not check STR_END. The\nfull_read argument tells whether characters above max are accepted or not. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nSLJIT_ASSERT(common->utf);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n/* All values > 127 are zero in ctypes. */\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n\nif (negated)\n  {\n  jump = CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x80);\n\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n    }\n  JUMPHERE(jump);\n  }\n}\n\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\nstatic void read_char8_type(compiler_common *common, jump_list **backtracks, BOOL negated)\n{\n/* Reads the character type into TMP1, updates STR_PTR. Does not check STR_END. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\nstruct sljit_jump *jump;\n#endif\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_jump *jump2;\n#endif\n\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(negated);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  /* The result of this read may be unused, but saves an \"else\" part. */\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n  jump = CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x80);\n\n  if (!negated)\n    {\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe0 - 0xc2));\n\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40));\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n    JUMPHERE(jump2);\n    }\n  else if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    OP1(SLJIT_MOV, TMP2, 0, TMP1, 0);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n    JUMPHERE(jump2);\n    }\n  else\n    add_jump(compiler, &common->utfreadtype8, JUMP(SLJIT_FAST_CALL));\n\n  JUMPHERE(jump);\n  return;\n  }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf && negated)\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x110000));\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 32 */\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\n/* The ctypes array contains only 256 values. */\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\njump = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 */\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 */\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf && negated)\n  {\n  /* Skip low surrogate if necessary. */\n  if (!common->invalid_utf)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\n\n    if (sljit_has_cpu_feature(SLJIT_HAS_CMOV) && !HAS_VIRTUAL_REGISTERS)\n      {\n      OP2(SLJIT_ADD, RETURN_ADDR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0x400);\n      CMOV(SLJIT_LESS, STR_PTR, RETURN_ADDR, 0);\n      }\n    else\n      {\n      jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      JUMPHERE(jump);\n      }\n    return;\n    }\n\n  OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\n  jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400));\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xdc00);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400));\n\n  JUMPHERE(jump);\n  return;\n  }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16 */\n}\n\nstatic void move_back(compiler_common *common, jump_list **backtracks, BOOL must_be_valid)\n{\n/* Goes one character back. Affects STR_PTR and TMP1. If must_be_valid is TRUE,\nTMP2 is not used. Otherwise TMP2 must contain the start of the subject buffer,\nand it is destroyed. Does not modify STR_PTR for invalid character sequences. */\nDEFINE_COMPILER;\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_label *label;\n\nif (common->utf)\n  {\n  if (!must_be_valid && common->invalid_utf)\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n    add_jump(compiler, &common->utfmoveback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\n    JUMPHERE(jump);\n    return;\n    }\n\n  label = LABEL();\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\n  CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0x80, label);\n  return;\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  if (!must_be_valid && common->invalid_utf)\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    add_jump(compiler, &common->utfmoveback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\n    JUMPHERE(jump);\n    return;\n    }\n\n  /* Skip low surrogate if necessary. */\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xfc00);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0xdc00);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  return;\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf && !must_be_valid)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  if (backtracks != NULL)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    return;\n    }\n\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x110000);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_LESS);\n  OP2(SLJIT_SHL,  TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  return;\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(must_be_valid);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n}\n\nstatic void check_newlinechar(compiler_common *common, int nltype, jump_list **backtracks, BOOL jumpifmatch)\n{\n/* Character comes in TMP1. Checks if it is a newline. TMP2 may be destroyed. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (nltype == NLTYPE_ANY)\n  {\n  add_jump(compiler, &common->anynewline, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(jumpifmatch ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  }\nelse if (nltype == NLTYPE_ANYCRLF)\n  {\n  if (jumpifmatch)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR));\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n    }\n  else\n    {\n    jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n    JUMPHERE(jump);\n    }\n  }\nelse\n  {\n  SLJIT_ASSERT(nltype == NLTYPE_FIXED && common->newline < 256);\n  add_jump(compiler, backtracks, CMP(jumpifmatch ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline));\n  }\n}\n\n#ifdef SUPPORT_UNICODE\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\nstatic void do_utfreadchar(compiler_common *common)\n{\n/* Fast decoding a UTF-8 character. TMP1 contains the first byte\nof the character (>= 0xc0). Return char value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Searching for the first zero. */\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Two byte sequence. */\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x10000);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Three byte sequence. */\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Four byte sequence. */\nJUMPHERE(jump);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xf0000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadtype8(compiler_common *common)\n{\n/* Fast decoding a UTF-8 character type. TMP2 contains the first byte\nof the character (>= 0xc0). Return value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_jump *compare;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, 0x20);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Two byte sequence. */\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x1f);\n/* The upper 5 bits are known at this point. */\ncompare = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0x3);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP2, 0, TMP2, 0, TMP1, 0);\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(compare);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* We only have types for characters less than 256. */\nJUMPHERE(jump);\nOP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(utf8_table4) - 0xc0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadchar_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-8 character. TMP1 contains the first byte\nof the character (>= 0xc0). Return char value in TMP1. STR_PTR is\nundefined for invalid characters. */\nDEFINE_COMPILER;\nsljit_s32 i;\nsljit_s32 has_cmov = sljit_has_cpu_feature(SLJIT_HAS_CMOV);\nstruct sljit_jump *jump;\nstruct sljit_jump *buffer_end_close;\nstruct sljit_label *three_byte_entry;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid[11];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc2);\n\n/* Usually more than 3 characters remained in the subject buffer. */\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\n\n/* Not a valid start of a multi-byte sequence, no more bytes read. */\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xf5 - 0xc2);\n\nbuffer_end_close = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n/* If TMP2 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, 0x20000);\n  exit_invalid[2] = NULL;\n  }\nelse\n  exit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x10000);\njump = JUMP(SLJIT_NOT_ZERO);\n\nthree_byte_entry = LABEL();\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x2d800);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0xd800);\n  exit_invalid[3] = NULL;\n  }\nelse\n  exit_invalid[3] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid[4] = NULL;\n  }\nelse\n  exit_invalid[4] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\n\n/* Four-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, 0);\n  exit_invalid[5] = NULL;\n  }\nelse\n  exit_invalid[5] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc10000);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0x10000);\n  exit_invalid[6] = NULL;\n  }\nelse\n  exit_invalid[6] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(buffer_end_close);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nexit_invalid[7] = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n/* If TMP2 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nexit_invalid[8] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three-byte sequence. */\nJUMPHERE(jump);\nexit_invalid[9] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid[10] = NULL;\n  }\nelse\n  exit_invalid[10] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\n/* One will be substracted from STR_PTR later. */\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\n/* Four byte sequences are not possible. */\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x30000, three_byte_entry);\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 11; i++)\n  sljit_set_label(exit_invalid[i], exit_invalid_label);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadnewline_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-8 character, specialized for newlines.\nTMP1 contains the first byte of the character (>= 0xc0). Return\nchar value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_label *skip_start;\nstruct sljit_label *three_byte_exit;\nstruct sljit_jump *jump[5];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nif (common->nltype != NLTYPE_ANY)\n  {\n  SLJIT_ASSERT(common->nltype != NLTYPE_FIXED || common->newline < 128);\n\n  /* All newlines are ascii, just skip intermediate octets. */\n  jump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  loop = LABEL();\n  if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1)) == SLJIT_SUCCESS)\n    sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  else\n    {\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n\n  OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\n  CMPTO(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  JUMPHERE(jump[0]);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\n  OP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n  return;\n  }\n\njump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\njump[1] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0xc2);\njump[2] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0xe2);\n\nskip_start = LABEL();\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\njump[3] = CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80);\n\n/* Skip intermediate octets. */\nloop = LABEL();\njump[4] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, loop);\n\nJUMPHERE(jump[3]);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nthree_byte_exit = LABEL();\nJUMPHERE(jump[0]);\nJUMPHERE(jump[4]);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Two byte long newline: 0x85. */\nJUMPHERE(jump[1]);\nCMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x85, skip_start);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x85);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three byte long newlines: 0x2028 and 0x2029. */\nJUMPHERE(jump[2]);\nCMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, skip_start);\nCMPTO(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0, three_byte_exit);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP2, 0, SLJIT_IMM, 0x80);\nCMPTO(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x40, skip_start);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0x2000);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfmoveback_invalid(compiler_common *common)\n{\n/* Goes one character back. */\nDEFINE_COMPILER;\nsljit_s32 i;\nstruct sljit_jump *jump;\nstruct sljit_jump *buffer_start_close;\nstruct sljit_label *exit_ok_label;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid[7];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xc0);\n\n/* Two-byte sequence. */\nbuffer_start_close = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x20);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three-byte sequence. */\nJUMPHERE(jump);\nexit_invalid[1] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, -0x40);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x10);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Four-byte sequence. */\nJUMPHERE(jump);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0 - 0x80);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x40);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xf0);\nexit_invalid[3] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x05);\n\nexit_ok_label = LABEL();\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Two-byte sequence. */\nJUMPHERE(buffer_start_close);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\nexit_invalid[4] = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x20, exit_ok_label);\n\n/* Three-byte sequence. */\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nexit_invalid[5] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, -0x40);\nexit_invalid[6] = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x10, exit_ok_label);\n\n/* Four-byte sequences are not possible. */\n\nexit_invalid_label = LABEL();\nsljit_set_label(exit_invalid[5], exit_invalid_label);\nsljit_set_label(exit_invalid[6], exit_invalid_label);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[4]);\n/* -2 + 4 = 2 */\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 4; i++)\n  sljit_set_label(exit_invalid[i], exit_invalid_label);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(4));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump[2];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\njump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x20);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\njump[1] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x10);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-4));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0 - 0x80);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xf0);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump[1]);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump[0]);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback_invalid(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nsljit_s32 i;\nsljit_s32 has_cmov = sljit_has_cpu_feature(SLJIT_HAS_CMOV);\nstruct sljit_jump *jump[2];\nstruct sljit_label *two_byte_entry;\nstruct sljit_label *three_byte_entry;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid[8];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(3));\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xc0);\njump[0] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\njump[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x1e);\n\ntwo_byte_entry = LABEL();\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n/* If TMP1 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[1]);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2 - 0x80);\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0);\njump[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x10);\n\nthree_byte_entry = LABEL();\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 12);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, -0xd800);\n  exit_invalid[2] = NULL;\n  }\nelse\n  exit_invalid[2] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid[3] = NULL;\n  }\nelse\n  exit_invalid[3] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[1]);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0 - 0x80);\nexit_invalid[4] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 12);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Four-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-4));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xf0);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 18);\n/* ADD is used instead of OR because of the SUB 0x10000 above. */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0x10000);\n  exit_invalid[5] = NULL;\n  }\nelse\n  exit_invalid[5] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[0]);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\njump[0] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x1e, two_byte_entry);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2 - 0x80);\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\nexit_invalid[6] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x10, three_byte_entry);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[0]);\nexit_invalid[7] = CMP(SLJIT_GREATER, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x1e, two_byte_entry);\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 8; i++)\n  sljit_set_label(exit_invalid[i], exit_invalid_label);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n\n#if PCRE2_CODE_UNIT_WIDTH == 16\n\nstatic void do_utfreadchar_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-16 character. TMP1 contains the first half\nof the character (>= 0xd800). Return char value in TMP1. STR_PTR is\nundefined for invalid characters. */\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid[3];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n/* TMP2 contains the high surrogate. */\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xdc00);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x10000);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x400);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nJUMPHERE(exit_invalid[2]);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadnewline_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-16 character, specialized for newlines.\nTMP1 contains the first half of the character (>= 0xd800). Return\nchar value in TMP1. */\n\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid[2];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n/* TMP2 contains the high surrogate. */\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xdc00);\n\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xdc00);\nOP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0x400);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x10000);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCHAR_SHIFT);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfmoveback_invalid(compiler_common *common)\n{\n/* Goes one character back. */\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid[3];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nexit_invalid[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x400);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x400);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nJUMPHERE(exit_invalid[2]);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback_invalid(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_jump *exit_invalid[3];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\nexit_invalid[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xdc00);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nJUMPHERE(exit_invalid[2]);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == 16 */\n\n/* UCD_BLOCK_SIZE must be 128 (see the assert below). */\n#define UCD_BLOCK_MASK 127\n#define UCD_BLOCK_SHIFT 7\n\nstatic void do_getucd(compiler_common *common)\n{\n/* Search the UCD record for the character comes in TMP1.\nReturns chartype in TMP1 and UCD offset in TMP2. */\nDEFINE_COMPILER;\n#if PCRE2_CODE_UNIT_WIDTH == 32\nstruct sljit_jump *jump;\n#endif\n\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n/* dummy_ucd_record */\nconst ucd_record *record = GET_UCD(UNASSIGNED_UTF_CHAR);\nSLJIT_ASSERT(record->script == ucp_Unknown && record->chartype == ucp_Cn && record->gbprop == ucp_gbOther);\nSLJIT_ASSERT(record->caseset == 0 && record->other_case == 0);\n#endif\n\nSLJIT_ASSERT(UCD_BLOCK_SIZE == 128 && sizeof(ucd_record) == 12);\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (!common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n  JUMPHERE(jump);\n  }\n#endif\n\nOP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_getucdtype(compiler_common *common)\n{\n/* Search the UCD record for the character comes in TMP1.\nReturns chartype in TMP1 and UCD offset in TMP2. */\nDEFINE_COMPILER;\n#if PCRE2_CODE_UNIT_WIDTH == 32\nstruct sljit_jump *jump;\n#endif\n\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n/* dummy_ucd_record */\nconst ucd_record *record = GET_UCD(UNASSIGNED_UTF_CHAR);\nSLJIT_ASSERT(record->script == ucp_Unknown && record->chartype == ucp_Cn && record->gbprop == ucp_gbOther);\nSLJIT_ASSERT(record->caseset == 0 && record->other_case == 0);\n#endif\n\nSLJIT_ASSERT(UCD_BLOCK_SIZE == 128 && sizeof(ucd_record) == 12);\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (!common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n  JUMPHERE(jump);\n  }\n#endif\n\nOP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n\n/* TMP2 is multiplied by 12. Same as (TMP2 << 2) + ((TMP2 << 2) << 1). */\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM2(TMP1, TMP2), 1);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic SLJIT_INLINE struct sljit_label *mainloop_entry(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *mainloop;\nstruct sljit_label *newlinelabel = NULL;\nstruct sljit_jump *start;\nstruct sljit_jump *end = NULL;\nstruct sljit_jump *end2 = NULL;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_label *loop;\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\njump_list *newline = NULL;\nsljit_u32 overall_options = common->re->overall_options;\nBOOL hascrorlf = (common->re->flags & PCRE2_HASCRORLF) != 0;\nBOOL newlinecheck = FALSE;\nBOOL readuchar = FALSE;\n\nif (!(hascrorlf || (overall_options & PCRE2_FIRSTLINE) != 0)\n    && (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF || common->newline > 255))\n  newlinecheck = TRUE;\n\nSLJIT_ASSERT(common->abort_label == NULL);\n\nif ((overall_options & PCRE2_FIRSTLINE) != 0)\n  {\n  /* Search for the end of the first line. */\n  SLJIT_ASSERT(common->match_end_ptr != 0);\n  OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    mainloop = LABEL();\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, mainloop);\n    CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff, mainloop);\n    JUMPHERE(end);\n    OP2(SLJIT_SUB, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n  else\n    {\n    end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    mainloop = LABEL();\n    /* Continual stores does not cause data dependency. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0);\n    read_char(common, common->nlmin, common->nlmax, NULL, READ_CHAR_NEWLINE);\n    check_newlinechar(common, common->nltype, &newline, TRUE);\n    CMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, mainloop);\n    JUMPHERE(end);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0);\n    set_jumps(newline, LABEL());\n    }\n\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n  }\nelse if ((overall_options & PCRE2_USE_OFFSET_LIMIT) != 0)\n  {\n  /* Check whether offset limit is set and valid. */\n  SLJIT_ASSERT(common->match_end_ptr != 0);\n\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, offset_limit));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, offset_limit));\n\n  OP1(SLJIT_MOV, TMP2, 0, STR_END, 0);\n  end = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw) PCRE2_UNSET);\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif /* PCRE2_CODE_UNIT_WIDTH == [16|32] */\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, begin));\n\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n  end2 = CMP(SLJIT_LESS_EQUAL, TMP2, 0, STR_END, 0);\n  OP1(SLJIT_MOV, TMP2, 0, STR_END, 0);\n  JUMPHERE(end2);\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  add_jump(compiler, &common->abort, CMP(SLJIT_LESS, TMP2, 0, STR_PTR, 0));\n  JUMPHERE(end);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, TMP2, 0);\n  }\n\nstart = JUMP(SLJIT_JUMP);\n\nif (newlinecheck)\n  {\n  newlinelabel = LABEL();\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, common->newline & 0xff);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif /* PCRE2_CODE_UNIT_WIDTH == [16|32] */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  end2 = JUMP(SLJIT_JUMP);\n  }\n\nmainloop = LABEL();\n\n/* Increasing the STR_PTR here requires one less jump in the most common case. */\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && !common->invalid_utf) readuchar = TRUE;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\nif (newlinecheck) readuchar = TRUE;\n\nif (readuchar)\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n\nif (newlinecheck)\n  CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, newlinelabel);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->invalid_utf)\n  {\n  /* Skip continuation code units. */\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x40, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPHERE(jump);\n  }\nelse if (common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->invalid_utf)\n  {\n  /* Skip continuation code units. */\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x400, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPHERE(jump);\n  }\nelse if (common->utf)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x400);\n    CMOV(SLJIT_LESS, STR_PTR, TMP2, 0);\n    }\n  else\n    {\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x400);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_LESS);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16] */\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\nJUMPHERE(start);\n\nif (newlinecheck)\n  {\n  JUMPHERE(end);\n  JUMPHERE(end2);\n  }\n\nreturn mainloop;\n}\n\n\nstatic SLJIT_INLINE void add_prefix_char(PCRE2_UCHAR chr, fast_forward_char_data *chars, BOOL last)\n{\nsljit_u32 i, count = chars->count;\n\nif (count == 255)\n  return;\n\nif (count == 0)\n  {\n  chars->count = 1;\n  chars->chars[0] = chr;\n\n  if (last)\n    chars->last_count = 1;\n  return;\n  }\n\nfor (i = 0; i < count; i++)\n  if (chars->chars[i] == chr)\n    return;\n\nif (count >= MAX_DIFF_CHARS)\n  {\n  chars->count = 255;\n  return;\n  }\n\nchars->chars[count] = chr;\nchars->count = count + 1;\n\nif (last)\n  chars->last_count++;\n}\n\nstatic int scan_prefix(compiler_common *common, PCRE2_SPTR cc, fast_forward_char_data *chars, int max_chars, sljit_u32 *rec_count)\n{\n/* Recursive function, which scans prefix literals. */\nBOOL last, any, class, caseless;\nint len, repeat, len_save, consumed = 0;\nsljit_u32 chr; /* Any unicode character. */\nsljit_u8 *bytes, *bytes_end, byte;\nPCRE2_SPTR alternative, cc_save, oc;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nPCRE2_UCHAR othercase[4];\n#elif defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16\nPCRE2_UCHAR othercase[2];\n#else\nPCRE2_UCHAR othercase[1];\n#endif\n\nrepeat = 1;\nwhile (TRUE)\n  {\n  if (*rec_count == 0)\n    return 0;\n  (*rec_count)--;\n\n  last = TRUE;\n  any = FALSE;\n  class = FALSE;\n  caseless = FALSE;\n\n  switch (*cc)\n    {\n    case OP_CHARI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_CHAR:\n    last = FALSE;\n    cc++;\n    break;\n\n    case OP_SOD:\n    case OP_SOM:\n    case OP_SET_SOM:\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    /* Zero width assertions. */\n    cc++;\n    continue;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    cc = bracketend(cc);\n    continue;\n\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_POSPLUSI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_POSPLUS:\n    cc++;\n    break;\n\n    case OP_EXACTI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_EXACT:\n    repeat = GET2(cc, 1);\n    last = FALSE;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_POSQUERYI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_POSQUERY:\n    len = 1;\n    cc++;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(*cc)) len += GET_EXTRALEN(*cc);\n#endif\n    max_chars = scan_prefix(common, cc + len, chars, max_chars, rec_count);\n    if (max_chars == 0)\n      return consumed;\n    last = FALSE;\n    break;\n\n    case OP_KET:\n    cc += 1 + LINK_SIZE;\n    continue;\n\n    case OP_ALT:\n    cc += GET(cc, 1);\n    continue;\n\n    case OP_ONCE:\n    case OP_BRA:\n    case OP_BRAPOS:\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    alternative = cc + GET(cc, 1);\n    while (*alternative == OP_ALT)\n      {\n      max_chars = scan_prefix(common, alternative + 1 + LINK_SIZE, chars, max_chars, rec_count);\n      if (max_chars == 0)\n        return consumed;\n      alternative += GET(alternative, 1);\n      }\n\n    if (*cc == OP_CBRA || *cc == OP_CBRAPOS)\n      cc += IMM2_SIZE;\n    cc += 1 + LINK_SIZE;\n    continue;\n\n    case OP_CLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)(cc + 1), FALSE))\n      return consumed;\n#endif\n    class = TRUE;\n    break;\n\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    class = TRUE;\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc += GET(cc, 1);\n    break;\n#endif\n\n    case OP_DIGIT:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_digit, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_WHITESPACE:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_space, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_WORDCHAR:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_word, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_NOT:\n    case OP_NOTI:\n    cc++;\n    /* Fall through. */\n    case OP_NOT_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n#ifdef SUPPORT_UNICODE\n    case OP_NOTPROP:\n    case OP_PROP:\n#if PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc += 1 + 2;\n    break;\n#endif\n\n    case OP_TYPEEXACT:\n    repeat = GET2(cc, 1);\n    cc += 1 + IMM2_SIZE;\n    continue;\n\n    case OP_NOTEXACT:\n    case OP_NOTEXACTI:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    repeat = GET2(cc, 1);\n    cc += 1 + IMM2_SIZE + 1;\n    break;\n\n    default:\n    return consumed;\n    }\n\n  if (any)\n    {\n    do\n      {\n      chars->count = 255;\n\n      consumed++;\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      }\n    while (--repeat > 0);\n\n    repeat = 1;\n    continue;\n    }\n\n  if (class)\n    {\n    bytes = (sljit_u8*) (cc + 1);\n    cc += 1 + 32 / sizeof(PCRE2_UCHAR);\n\n    switch (*cc)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRPOSSTAR:\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      case OP_CRPOSQUERY:\n      max_chars = scan_prefix(common, cc + 1, chars, max_chars, rec_count);\n      if (max_chars == 0)\n        return consumed;\n      break;\n\n      default:\n      case OP_CRPLUS:\n      case OP_CRMINPLUS:\n      case OP_CRPOSPLUS:\n      break;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      case OP_CRPOSRANGE:\n      repeat = GET2(cc, 1);\n      if (repeat <= 0)\n        return consumed;\n      break;\n      }\n\n    do\n      {\n      if (bytes[31] & 0x80)\n        chars->count = 255;\n      else if (chars->count != 255)\n        {\n        bytes_end = bytes + 32;\n        chr = 0;\n        do\n          {\n          byte = *bytes++;\n          SLJIT_ASSERT((chr & 0x7) == 0);\n          if (byte == 0)\n            chr += 8;\n          else\n            {\n            do\n              {\n              if ((byte & 0x1) != 0)\n                add_prefix_char(chr, chars, TRUE);\n              byte >>= 1;\n              chr++;\n              }\n            while (byte != 0);\n            chr = (chr + 7) & ~7;\n            }\n          }\n        while (chars->count != 255 && bytes < bytes_end);\n        bytes = bytes_end - 32;\n        }\n\n      consumed++;\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      }\n    while (--repeat > 0);\n\n    switch (*cc)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRPOSSTAR:\n      return consumed;\n\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      case OP_CRPOSQUERY:\n      cc++;\n      break;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      case OP_CRPOSRANGE:\n      if (GET2(cc, 1) != GET2(cc, 1 + IMM2_SIZE))\n        return consumed;\n      cc += 1 + 2 * IMM2_SIZE;\n      break;\n      }\n\n    repeat = 1;\n    continue;\n    }\n\n  len = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(*cc)) len += GET_EXTRALEN(*cc);\n#endif\n\n  if (caseless && char_has_othercase(common, cc))\n    {\n#ifdef SUPPORT_UNICODE\n    if (common->utf)\n      {\n      GETCHAR(chr, cc);\n      if ((int)PRIV(ord2utf)(char_othercase(common, chr), othercase) != len)\n        return consumed;\n      }\n    else\n#endif\n      {\n      chr = *cc;\n#ifdef SUPPORT_UNICODE\n      if (common->ucp && chr > 127)\n        othercase[0] = UCD_OTHERCASE(chr);\n      else\n#endif\n        othercase[0] = TABLE_GET(chr, common->fcc, chr);\n      }\n    }\n  else\n    {\n    caseless = FALSE;\n    othercase[0] = 0; /* Stops compiler warning - PH */\n    }\n\n  len_save = len;\n  cc_save = cc;\n  while (TRUE)\n    {\n    oc = othercase;\n    do\n      {\n      len--;\n      consumed++;\n\n      chr = *cc;\n      add_prefix_char(*cc, chars, len == 0);\n\n      if (caseless)\n        add_prefix_char(*oc, chars, len == 0);\n\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      cc++;\n      oc++;\n      }\n    while (len > 0);\n\n    if (--repeat == 0)\n      break;\n\n    len = len_save;\n    cc = cc_save;\n    }\n\n  repeat = 1;\n  if (last)\n    return consumed;\n  }\n}\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstatic void jumpto_if_not_utf_char_start(struct sljit_compiler *compiler, sljit_s32 reg, struct sljit_label *label)\n{\n#if PCRE2_CODE_UNIT_WIDTH == 8\nOP2(SLJIT_AND, reg, 0, reg, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_EQUAL, reg, 0, SLJIT_IMM, 0x80, label);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nOP2(SLJIT_AND, reg, 0, reg, 0, SLJIT_IMM, 0xfc00);\nCMPTO(SLJIT_EQUAL, reg, 0, SLJIT_IMM, 0xdc00, label);\n#else\n#error \"Unknown code width\"\n#endif\n}\n#endif\n\n#include \"pcre2_jit_simd_inc.h\"\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\n\nstatic BOOL check_fast_forward_char_pair_simd(compiler_common *common, fast_forward_char_data *chars, int max)\n{\n  sljit_s32 i, j, max_i = 0, max_j = 0;\n  sljit_u32 max_pri = 0;\n  PCRE2_UCHAR a1, a2, a_pri, b1, b2, b_pri;\n\n  for (i = max - 1; i >= 1; i--)\n    {\n    if (chars[i].last_count > 2)\n      {\n      a1 = chars[i].chars[0];\n      a2 = chars[i].chars[1];\n      a_pri = chars[i].last_count;\n\n      j = i - max_fast_forward_char_pair_offset();\n      if (j < 0)\n        j = 0;\n\n      while (j < i)\n        {\n        b_pri = chars[j].last_count;\n        if (b_pri > 2 && a_pri + b_pri >= max_pri)\n          {\n          b1 = chars[j].chars[0];\n          b2 = chars[j].chars[1];\n\n          if (a1 != b1 && a1 != b2 && a2 != b1 && a2 != b2)\n            {\n            max_pri = a_pri + b_pri;\n            max_i = i;\n            max_j = j;\n            }\n          }\n        j++;\n        }\n      }\n    }\n\nif (max_pri == 0)\n  return FALSE;\n\nfast_forward_char_pair_simd(common, max_i, chars[max_i].chars[0], chars[max_i].chars[1], max_j, chars[max_j].chars[0], chars[max_j].chars[1]);\nreturn TRUE;\n}\n\n#endif /* JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD */\n\nstatic void fast_forward_first_char2(compiler_common *common, PCRE2_UCHAR char1, PCRE2_UCHAR char2, sljit_s32 offset)\n{\nDEFINE_COMPILER;\nstruct sljit_label *start;\nstruct sljit_jump *match;\nstruct sljit_jump *partial_quit;\nPCRE2_UCHAR mask;\nBOOL has_match_end = (common->match_end_ptr != 0);\n\nSLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE || offset == 0);\n\nif (has_match_end)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n\nif (offset > 0)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset));\n\nif (has_match_end)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(offset + 1));\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_SIMD\n\nif (JIT_HAS_FAST_FORWARD_CHAR_SIMD)\n  {\n  fast_forward_char_simd(common, char1, char2, offset);\n\n  if (offset > 0)\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset));\n\n  if (has_match_end)\n    OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n  return;\n  }\n\n#endif\n\nstart = LABEL();\n\npartial_quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_COMPLETE)\n  add_jump(compiler, &common->failed_match, partial_quit);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (char1 == char2)\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char1, start);\nelse\n  {\n  mask = char1 ^ char2;\n  if (is_powerof2(mask))\n    {\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, mask);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char1 | mask, start);\n    }\n  else\n    {\n    match = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, char1);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char2, start);\n    JUMPHERE(match);\n    }\n  }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && offset > 0)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-(offset + 1)));\n  jumpto_if_not_utf_char_start(compiler, TMP1, start);\n  }\n#endif\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset + 1));\n\nif (common->mode != PCRE2_JIT_COMPLETE)\n  JUMPHERE(partial_quit);\n\nif (has_match_end)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n}\n\nstatic SLJIT_INLINE BOOL fast_forward_first_n_chars(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *start;\nstruct sljit_jump *match;\nfast_forward_char_data chars[MAX_N_CHARS];\nsljit_s32 offset;\nPCRE2_UCHAR mask;\nPCRE2_UCHAR *char_set, *char_set_end;\nint i, max, from;\nint range_right = -1, range_len;\nsljit_u8 *update_table = NULL;\nBOOL in_range;\nsljit_u32 rec_count;\n\nfor (i = 0; i < MAX_N_CHARS; i++)\n  {\n  chars[i].count = 0;\n  chars[i].last_count = 0;\n  }\n\nrec_count = 10000;\nmax = scan_prefix(common, common->start, chars, MAX_N_CHARS, &rec_count);\n\nif (max < 1)\n  return FALSE;\n\n/* Convert last_count to priority. */\nfor (i = 0; i < max; i++)\n  {\n  SLJIT_ASSERT(chars[i].count > 0 && chars[i].last_count <= chars[i].count);\n\n  if (chars[i].count == 1)\n    {\n    chars[i].last_count = (chars[i].last_count == 1) ? 7 : 5;\n    /* Simplifies algorithms later. */\n    chars[i].chars[1] = chars[i].chars[0];\n    }\n  else if (chars[i].count == 2)\n    {\n    SLJIT_ASSERT(chars[i].chars[0] != chars[i].chars[1]);\n\n    if (is_powerof2(chars[i].chars[0] ^ chars[i].chars[1]))\n      chars[i].last_count = (chars[i].last_count == 2) ? 6 : 4;\n    else\n      chars[i].last_count = (chars[i].last_count == 2) ? 3 : 2;\n    }\n  else\n    chars[i].last_count = (chars[i].count == 255) ? 0 : 1;\n  }\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\nif (JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD && check_fast_forward_char_pair_simd(common, chars, max))\n  return TRUE;\n#endif\n\nin_range = FALSE;\n/* Prevent compiler \"uninitialized\" warning */\nfrom = 0;\nrange_len = 4 /* minimum length */ - 1;\nfor (i = 0; i <= max; i++)\n  {\n  if (in_range && (i - from) > range_len && (chars[i - 1].count < 255))\n    {\n    range_len = i - from;\n    range_right = i - 1;\n    }\n\n  if (i < max && chars[i].count < 255)\n    {\n    SLJIT_ASSERT(chars[i].count > 0);\n    if (!in_range)\n      {\n      in_range = TRUE;\n      from = i;\n      }\n    }\n  else\n    in_range = FALSE;\n  }\n\nif (range_right >= 0)\n  {\n  update_table = (sljit_u8 *)allocate_read_only_data(common, 256);\n  if (update_table == NULL)\n    return TRUE;\n  memset(update_table, IN_UCHARS(range_len), 256);\n\n  for (i = 0; i < range_len; i++)\n    {\n    SLJIT_ASSERT(chars[range_right - i].count > 0 && chars[range_right - i].count < 255);\n\n    char_set = chars[range_right - i].chars;\n    char_set_end = char_set + chars[range_right - i].count;\n    do\n      {\n      if (update_table[(*char_set) & 0xff] > IN_UCHARS(i))\n        update_table[(*char_set) & 0xff] = IN_UCHARS(i);\n      char_set++;\n      }\n    while (char_set < char_set_end);\n    }\n  }\n\noffset = -1;\n/* Scan forward. */\nfor (i = 0; i < max; i++)\n  {\n  if (range_right == i)\n    continue;\n\n  if (offset == -1)\n    {\n    if (chars[i].last_count >= 2)\n      offset = i;\n    }\n  else if (chars[offset].last_count < chars[i].last_count)\n    offset = i;\n  }\n\nSLJIT_ASSERT(offset == -1 || (chars[offset].count >= 1 && chars[offset].count <= 2));\n\nif (range_right < 0)\n  {\n  if (offset < 0)\n    return FALSE;\n  /* Works regardless the value is 1 or 2. */\n  fast_forward_first_char2(common, chars[offset].chars[0], chars[offset].chars[1], offset);\n  return TRUE;\n  }\n\nSLJIT_ASSERT(range_right != offset);\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\n  add_jump(compiler, &common->failed_match, JUMP(SLJIT_LESS));\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\nelse\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\n  add_jump(compiler, &common->failed_match, JUMP(SLJIT_LESS));\n  }\n\nSLJIT_ASSERT(range_right >= 0);\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, SLJIT_IMM, (sljit_sw)update_table);\n\nstart = LABEL();\nadd_jump(compiler, &common->failed_match, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8 || (defined SLJIT_LITTLE_ENDIAN && SLJIT_LITTLE_ENDIAN)\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(range_right));\n#else\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(range_right + 1) - 1);\n#endif\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM2(RETURN_ADDR, TMP1), 0);\nelse\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)update_table);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\nCMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, start);\n\nif (offset >= 0)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(offset));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  if (chars[offset].count == 1)\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[0], start);\n  else\n    {\n    mask = chars[offset].chars[0] ^ chars[offset].chars[1];\n    if (is_powerof2(mask))\n      {\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, mask);\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[0] | mask, start);\n      }\n    else\n      {\n      match = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[0]);\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[1], start);\n      JUMPHERE(match);\n      }\n    }\n  }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && offset != 0)\n  {\n  if (offset < 0)\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n  else\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n\n  jumpto_if_not_utf_char_start(compiler, TMP1, start);\n\n  if (offset < 0)\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\n#endif\n\nif (offset >= 0)\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\nelse\n  OP2(SLJIT_ADD, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\nreturn TRUE;\n}\n\nstatic SLJIT_INLINE void fast_forward_first_char(compiler_common *common)\n{\nPCRE2_UCHAR first_char = (PCRE2_UCHAR)(common->re->first_codeunit);\nPCRE2_UCHAR oc;\n\noc = first_char;\nif ((common->re->flags & PCRE2_FIRSTCASELESS) != 0)\n  {\n  oc = TABLE_GET(first_char, common->fcc, first_char);\n#if defined SUPPORT_UNICODE\n  if (first_char > 127 && (common->utf || common->ucp))\n    oc = UCD_OTHERCASE(first_char);\n#endif\n  }\n\nfast_forward_first_char2(common, first_char, oc, 0);\n}\n\nstatic SLJIT_INLINE void fast_forward_newline(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_jump *lastchar = NULL;\nstruct sljit_jump *firstchar;\nstruct sljit_jump *quit = NULL;\nstruct sljit_jump *foundcr = NULL;\nstruct sljit_jump *notfoundnl;\njump_list *newline = NULL;\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n  OP1(SLJIT_MOV, STR_END, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  }\n\nif (common->nltype == NLTYPE_FIXED && common->newline > 255)\n  {\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\n  if (JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD && common->mode == PCRE2_JIT_COMPLETE)\n    {\n    if (HAS_VIRTUAL_REGISTERS)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    firstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, STR_PTR, 0, TMP1, 0);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_NOT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n\n    fast_forward_char_pair_simd(common, 1, common->newline & 0xff, common->newline & 0xff, 0, (common->newline >> 8) & 0xff, (common->newline >> 8) & 0xff);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    }\n  else\n#endif /* JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD */\n    {\n    lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    if (HAS_VIRTUAL_REGISTERS)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    firstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, STR_PTR, 0, TMP1, 0);\n    OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\n    loop = LABEL();\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, loop);\n    CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff, loop);\n\n    JUMPHERE(quit);\n    JUMPHERE(lastchar);\n    }\n\n  JUMPHERE(firstchar);\n\n  if (common->match_end_ptr != 0)\n    OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n  return;\n  }\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n  }\nelse\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n\n/* Example: match /^/ to \\r\\n from offset 1. */\nfirstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\nif (common->nltype == NLTYPE_ANY)\n  move_back(common, NULL, FALSE);\nelse\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nloop = LABEL();\ncommon->ff_newline_shortcut = loop;\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_SIMD\nif (JIT_HAS_FAST_FORWARD_CHAR_SIMD && (common->nltype == NLTYPE_FIXED || common->nltype == NLTYPE_ANYCRLF))\n  {\n  if (common->nltype == NLTYPE_ANYCRLF)\n    {\n    fast_forward_char_simd(common, CHAR_CR, CHAR_LF, 0);\n    if (common->mode != PCRE2_JIT_COMPLETE)\n      lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    quit = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    }\n   else\n    {\n    fast_forward_char_simd(common, common->newline, common->newline, 0);\n\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    if (common->mode != PCRE2_JIT_COMPLETE)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_PTR, 0, STR_END, 0);\n      CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n      }\n    }\n  }\nelse\n#endif /* JIT_HAS_FAST_FORWARD_CHAR_SIMD */\n  {\n  read_char(common, common->nlmin, common->nlmax, NULL, READ_CHAR_NEWLINE);\n  lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  if (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)\n    foundcr = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n  check_newlinechar(common, common->nltype, &newline, FALSE);\n  set_jumps(newline, loop);\n  }\n\nif (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)\n  {\n  if (quit == NULL)\n    {\n    quit = JUMP(SLJIT_JUMP);\n    JUMPHERE(foundcr);\n    }\n\n  notfoundnl = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, CHAR_NL);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  JUMPHERE(notfoundnl);\n  JUMPHERE(quit);\n  }\n\nif (lastchar)\n  JUMPHERE(lastchar);\nJUMPHERE(firstchar);\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n}\n\nstatic BOOL optimize_class(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks);\n\nstatic SLJIT_INLINE void fast_forward_start_bits(compiler_common *common)\n{\nDEFINE_COMPILER;\nconst sljit_u8 *start_bits = common->re->start_bitmap;\nstruct sljit_label *start;\nstruct sljit_jump *partial_quit;\n#if PCRE2_CODE_UNIT_WIDTH != 8\nstruct sljit_jump *found = NULL;\n#endif\njump_list *matches = NULL;\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, STR_END, 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\n\nstart = LABEL();\n\npartial_quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_COMPLETE)\n  add_jump(compiler, &common->failed_match, partial_quit);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (!optimize_class(common, start_bits, (start_bits[31] & 0x80) != 0, FALSE, &matches))\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  if ((start_bits[31] & 0x80) != 0)\n    found = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 255);\n  else\n    CMPTO(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 255, start);\n#elif defined SUPPORT_UNICODE\n  if (common->utf && is_char7_bitset(start_bits, FALSE))\n    CMPTO(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 127, start);\n#endif\n  OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)start_bits);\n  if (!HAS_VIRTUAL_REGISTERS)\n    {\n    OP2(SLJIT_SHL, TMP3, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP3, 0);\n    }\n  else\n    {\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    }\n  JUMPTO(SLJIT_ZERO, start);\n  }\nelse\n  set_jumps(matches, start);\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\nif (found != NULL)\n  JUMPHERE(found);\n#endif\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (common->mode != PCRE2_JIT_COMPLETE)\n  JUMPHERE(partial_quit);\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, RETURN_ADDR, 0);\n}\n\nstatic SLJIT_INLINE jump_list *search_requested_char(compiler_common *common, PCRE2_UCHAR req_char, BOOL caseless, BOOL has_firstchar)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_jump *toolong;\nstruct sljit_jump *already_found;\nstruct sljit_jump *found;\nstruct sljit_jump *found_oc = NULL;\njump_list *not_found = NULL;\nsljit_u32 oc, bit;\n\nSLJIT_ASSERT(common->req_char_ptr != 0);\nOP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(REQ_CU_MAX) * 100);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr);\ntoolong = CMP(SLJIT_LESS, TMP2, 0, STR_END, 0);\nalready_found = CMP(SLJIT_LESS, STR_PTR, 0, TMP1, 0);\n\nif (has_firstchar)\n  OP2(SLJIT_ADD, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nelse\n  OP1(SLJIT_MOV, TMP1, 0, STR_PTR, 0);\n\noc = req_char;\nif (caseless)\n  {\n  oc = TABLE_GET(req_char, common->fcc, req_char);\n#if defined SUPPORT_UNICODE\n  if (req_char > 127 && (common->utf || common->ucp))\n    oc = UCD_OTHERCASE(req_char);\n#endif\n  }\n\n#ifdef JIT_HAS_FAST_REQUESTED_CHAR_SIMD\nif (JIT_HAS_FAST_REQUESTED_CHAR_SIMD)\n  {\n  not_found = fast_requested_char_simd(common, req_char, oc);\n  }\nelse\n#endif\n  {\n  loop = LABEL();\n  add_jump(compiler, &not_found, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, STR_END, 0));\n\n  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(TMP1), 0);\n\n  if (req_char == oc)\n    found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char);\n  else\n    {\n    bit = req_char ^ oc;\n    if (is_powerof2(bit))\n      {\n       OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, bit);\n      found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char | bit);\n      }\n    else\n      {\n      found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char);\n      found_oc = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, oc);\n      }\n    }\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_JUMP, loop);\n\n  JUMPHERE(found);\n  if (found_oc)\n    JUMPHERE(found_oc);\n  }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr, TMP1, 0);\n\nJUMPHERE(already_found);\nJUMPHERE(toolong);\nreturn not_found;\n}\n\nstatic void do_revertframes(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *mainloop;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\nGET_LOCAL_BASE(TMP1, 0, 0);\n\n/* Drop frames until we reach STACK_TOP. */\nmainloop = LABEL();\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), -sizeof(sljit_sw));\njump = CMP(SLJIT_SIG_LESS_EQUAL, TMP2, 0, SLJIT_IMM, 0);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), sizeof(sljit_sw), SLJIT_MEM1(STACK_TOP), -(3 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(3 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP1, 0);\n  GET_LOCAL_BASE(TMP1, 0, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), sizeof(sljit_sw), TMP3, 0);\n  }\nJUMPTO(SLJIT_JUMP, mainloop);\n\nJUMPHERE(jump);\njump = CMP(SLJIT_NOT_ZERO /* SIG_LESS */, TMP2, 0, SLJIT_IMM, 0);\n/* End of reverting values. */\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\nOP1(SLJIT_NEG, TMP2, 0, TMP2, 0);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * sizeof(sljit_sw));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP3, 0);\n  }\nJUMPTO(SLJIT_JUMP, mainloop);\n}\n\nstatic void check_wordboundary(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *skipread;\njump_list *skipread_list = NULL;\n#ifdef SUPPORT_UNICODE\nstruct sljit_label *valid_utf;\njump_list *invalid_utf1 = NULL;\n#endif /* SUPPORT_UNICODE */\njump_list *invalid_utf2 = NULL;\n#if PCRE2_CODE_UNIT_WIDTH != 8 || defined SUPPORT_UNICODE\nstruct sljit_jump *jump;\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 || SUPPORT_UNICODE */\n\nSLJIT_COMPILE_ASSERT(ctype_word == 0x10, ctype_word_must_be_16);\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n/* Get type of the previous char, and put it to TMP3. */\nOP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\nOP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, 0);\nskipread = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n#ifdef SUPPORT_UNICODE\nif (common->invalid_utf)\n  {\n  peek_char_back(common, READ_CHAR_MAX, &invalid_utf1);\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n    OP1(SLJIT_MOV, TMP2, 0, STR_PTR, 0);\n    move_back(common, NULL, TRUE);\n    check_start_used_ptr(common);\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, TMP2, 0);\n    }\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    peek_char_back(common, READ_CHAR_MAX, NULL);\n  else\n    {\n    move_back(common, NULL, TRUE);\n    check_start_used_ptr(common);\n    read_char(common, 0, READ_CHAR_MAX, NULL, READ_CHAR_UPDATE_STR_PTR);\n    }\n  }\n\n/* Testing char type. */\n#ifdef SUPPORT_UNICODE\nif (common->ucp)\n  {\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 1);\n  jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_UNDERSCORE);\n  add_jump(compiler, &common->getucdtype, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Nd - ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP3, 0, TMP2, 0);\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#elif defined SUPPORT_UNICODE\n  /* Here TMP3 has already been zeroed. */\n  jump = NULL;\n  if (common->utf)\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), common->ctypes);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 4 /* ctype_word */);\n  OP2(SLJIT_AND, TMP3, 0, TMP1, 0, SLJIT_IMM, 1);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  JUMPHERE(jump);\n#elif defined SUPPORT_UNICODE\n  if (jump != NULL)\n    JUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  }\nJUMPHERE(skipread);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\ncheck_str_end(common, &skipread_list);\npeek_char(common, READ_CHAR_MAX, SLJIT_MEM1(SLJIT_SP), LOCALS1, &invalid_utf2);\n\n/* Testing char type. This is a code duplication. */\n#ifdef SUPPORT_UNICODE\n\nvalid_utf = LABEL();\n\nif (common->ucp)\n  {\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 1);\n  jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_UNDERSCORE);\n  add_jump(compiler, &common->getucdtype, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Nd - ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  JUMPHERE(jump);\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  /* TMP2 may be destroyed by peek_char. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n  jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#elif defined SUPPORT_UNICODE\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n  jump = NULL;\n  if (common->utf)\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#endif\n  OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP1), common->ctypes);\n  OP2(SLJIT_LSHR, TMP2, 0, TMP2, 0, SLJIT_IMM, 4 /* ctype_word */);\n  OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  JUMPHERE(jump);\n#elif defined SUPPORT_UNICODE\n  if (jump != NULL)\n    JUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  }\nset_jumps(skipread_list, LABEL());\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_XOR | SLJIT_SET_Z, TMP2, 0, TMP2, 0, TMP3, 0);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n#ifdef SUPPORT_UNICODE\nif (common->invalid_utf)\n  {\n  set_jumps(invalid_utf1, LABEL());\n\n  peek_char(common, READ_CHAR_MAX, SLJIT_MEM1(SLJIT_SP), LOCALS1, NULL);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR, valid_utf);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, -1);\n  OP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n  set_jumps(invalid_utf2, LABEL());\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP1(SLJIT_MOV, TMP2, 0, TMP3, 0);\n  OP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n  }\n#endif /* SUPPORT_UNICODE */\n}\n\nstatic BOOL optimize_class_ranges(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nint ranges[MAX_CLASS_RANGE_SIZE];\nsljit_u8 bit, cbit, all;\nint i, byte, length = 0;\n\nbit = bits[0] & 0x1;\n/* All bits will be zero or one (since bit is zero or one). */\nall = -bit;\n\nfor (i = 0; i < 256; )\n  {\n  byte = i >> 3;\n  if ((i & 0x7) == 0 && bits[byte] == all)\n    i += 8;\n  else\n    {\n    cbit = (bits[byte] >> (i & 0x7)) & 0x1;\n    if (cbit != bit)\n      {\n      if (length >= MAX_CLASS_RANGE_SIZE)\n        return FALSE;\n      ranges[length] = i;\n      length++;\n      bit = cbit;\n      all = -cbit;\n      }\n    i++;\n    }\n  }\n\nif (((bit == 0) && nclass) || ((bit == 1) && !nclass))\n  {\n  if (length >= MAX_CLASS_RANGE_SIZE)\n    return FALSE;\n  ranges[length] = 256;\n  length++;\n  }\n\nif (length < 0 || length > 4)\n  return FALSE;\n\nbit = bits[0] & 0x1;\nif (invert) bit ^= 0x1;\n\n/* No character is accepted. */\nif (length == 0 && bit == 0)\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\nswitch(length)\n  {\n  case 0:\n  /* When bit != 0, all characters are accepted. */\n  return TRUE;\n\n  case 1:\n  add_jump(compiler, backtracks, CMP(bit == 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n  return TRUE;\n\n  case 2:\n  if (ranges[0] + 1 != ranges[1])\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n    add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n  return TRUE;\n\n  case 3:\n  if (bit != 0)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[2]));\n    if (ranges[0] + 1 != ranges[1])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n    return TRUE;\n    }\n\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[0]));\n  if (ranges[1] + 1 != ranges[2])\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[1]);\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[2] - ranges[1]));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[1]));\n  return TRUE;\n\n  case 4:\n  if ((ranges[1] - ranges[0]) == (ranges[3] - ranges[2])\n      && (ranges[0] | (ranges[2] - ranges[0])) == ranges[2]\n      && (ranges[1] & (ranges[2] - ranges[0])) == 0\n      && is_powerof2(ranges[2] - ranges[0]))\n    {\n    SLJIT_ASSERT((ranges[0] & (ranges[2] - ranges[0])) == 0 && (ranges[2] & ranges[3] & (ranges[2] - ranges[0])) != 0);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[2] - ranges[0]);\n    if (ranges[2] + 1 != ranges[3])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[2]);\n      add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[3] - ranges[2]));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[2]));\n    return TRUE;\n    }\n\n  if (bit != 0)\n    {\n    i = 0;\n    if (ranges[0] + 1 != ranges[1])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n      i = ranges[0];\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n\n    if (ranges[2] + 1 != ranges[3])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[2] - i);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[3] - ranges[2]));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[2] - i));\n    return TRUE;\n    }\n\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[3] - ranges[0]));\n  if (ranges[1] + 1 != ranges[2])\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]);\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[2] - ranges[1]));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n  return TRUE;\n\n  default:\n  SLJIT_UNREACHABLE();\n  return FALSE;\n  }\n}\n\nstatic BOOL optimize_class_chars(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nuint16_t char_list[MAX_CLASS_CHARS_SIZE];\nuint8_t byte;\nsljit_s32 type;\nint i, j, k, len, c;\n\nif (!sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n  return FALSE;\n\nlen = 0;\n\nfor (i = 0; i < 32; i++)\n  {\n  byte = bits[i];\n\n  if (nclass)\n    byte = ~byte;\n\n  j = 0;\n  while (byte != 0)\n    {\n    if (byte & 0x1)\n      {\n      c = i * 8 + j;\n\n      k = len;\n\n      if ((c & 0x20) != 0)\n        {\n        for (k = 0; k < len; k++)\n          if (char_list[k] == c - 0x20)\n            {\n            char_list[k] |= 0x120;\n            break;\n            }\n        }\n\n      if (k == len)\n        {\n        if (len >= MAX_CLASS_CHARS_SIZE)\n          return FALSE;\n\n        char_list[len++] = (uint16_t) c;\n        }\n      }\n\n    byte >>= 1;\n    j++;\n    }\n  }\n\nif (len == 0) return FALSE;  /* Should never occur, but stops analyzers complaining. */\n\ni = 0;\nj = 0;\n\nif (char_list[0] == 0)\n  {\n  i++;\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_ZERO);\n  }\nelse\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n\nwhile (i < len)\n  {\n  if ((char_list[i] & 0x100) != 0)\n    j++;\n  else\n    {\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, char_list[i]);\n    CMOV(SLJIT_ZERO, TMP2, TMP1, 0);\n    }\n  i++;\n  }\n\nif (j != 0)\n  {\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x20);\n\n  for (i = 0; i < len; i++)\n    if ((char_list[i] & 0x100) != 0)\n      {\n      j--;\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, char_list[i] & 0xff);\n      CMOV(SLJIT_ZERO, TMP2, TMP1, 0);\n      }\n  }\n\nif (invert)\n  nclass = !nclass;\n\ntype = nclass ? SLJIT_NOT_EQUAL : SLJIT_EQUAL;\nadd_jump(compiler, backtracks, CMP(type, TMP2, 0, SLJIT_IMM, 0));\nreturn TRUE;\n}\n\nstatic BOOL optimize_class(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nif (optimize_class_ranges(common, bits, nclass, invert, backtracks))\n  return TRUE;\nreturn optimize_class_chars(common, bits, nclass, invert, backtracks);\n}\n\nstatic void check_anynewline(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x0a);\nOP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x0d - 0x0a);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x0a);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x1);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x2029 - 0x0a);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void check_hspace(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x09);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x20);\nOP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0xa0);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x1680);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x2000);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x200A - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x202f - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x205f - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x3000 - 0x2000);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void check_vspace(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x0a);\nOP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x0d - 0x0a);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x0a);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x1);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x2029 - 0x0a);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_casefulcmp(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *label;\nint char1_reg;\nint char2_reg;\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  char1_reg = STR_END;\n  char2_reg = STACK_TOP;\n  }\nelse\n  {\n  char1_reg = TMP3;\n  char2_reg = RETURN_ADDR;\n  }\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nif (char1_reg == STR_END)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, char1_reg, 0);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, char2_reg, 0);\n  }\n\nif (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  {\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  }\nelse if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\nelse\n  {\n  label = LABEL();\n  OP1(MOV_UCHAR, char1_reg, 0, SLJIT_MEM1(TMP1), 0);\n  OP1(MOV_UCHAR, char2_reg, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  }\n\nif (char1_reg == STR_END)\n  {\n  OP1(SLJIT_MOV, char1_reg, 0, TMP3, 0);\n  OP1(SLJIT_MOV, char2_reg, 0, RETURN_ADDR, 0);\n  }\n\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n}\n\nstatic void do_caselesscmp(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *label;\nint char1_reg = STR_END;\nint char2_reg;\nint lcc_table;\nint opt_type = 0;\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  char2_reg = STACK_TOP;\n  lcc_table = STACK_LIMIT;\n  }\nelse\n  {\n  char2_reg = RETURN_ADDR;\n  lcc_table = TMP3;\n  }\n\nif (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  opt_type = 1;\nelse if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  opt_type = 2;\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, char1_reg, 0);\n\nif (char2_reg == STACK_TOP)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, char2_reg, 0);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, lcc_table, 0);\n  }\n\nOP1(SLJIT_MOV, lcc_table, 0, SLJIT_IMM, common->lcc);\n\nif (opt_type == 1)\n  {\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  }\nelse if (opt_type == 2)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  }\nelse\n  {\n  label = LABEL();\n  OP1(MOV_UCHAR, char1_reg, 0, SLJIT_MEM1(TMP1), 0);\n  OP1(MOV_UCHAR, char2_reg, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\njump = CMP(SLJIT_GREATER, char1_reg, 0, SLJIT_IMM, 255);\n#endif\nOP1(SLJIT_MOV_U8, char1_reg, 0, SLJIT_MEM2(lcc_table, char1_reg), 0);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\njump = CMP(SLJIT_GREATER, char2_reg, 0, SLJIT_IMM, 255);\n#endif\nOP1(SLJIT_MOV_U8, char2_reg, 0, SLJIT_MEM2(lcc_table, char2_reg), 0);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\n#endif\n\nif (opt_type == 0)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\njump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\nOP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\nJUMPTO(SLJIT_NOT_ZERO, label);\n\nJUMPHERE(jump);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n\nif (opt_type == 2)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (char2_reg == STACK_TOP)\n  {\n  OP1(SLJIT_MOV, char2_reg, 0, TMP3, 0);\n  OP1(SLJIT_MOV, lcc_table, 0, RETURN_ADDR, 0);\n  }\n\nOP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), LOCALS1);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n}\n\nstatic PCRE2_SPTR byte_sequence_compare(compiler_common *common, BOOL caseless, PCRE2_SPTR cc,\n    compare_context *context, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nunsigned int othercasebit = 0;\nPCRE2_SPTR othercasechar = NULL;\n#ifdef SUPPORT_UNICODE\nint utflength;\n#endif\n\nif (caseless && char_has_othercase(common, cc))\n  {\n  othercasebit = char_get_othercase_bit(common, cc);\n  SLJIT_ASSERT(othercasebit);\n  /* Extracting bit difference info. */\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  othercasechar = cc + (othercasebit >> 8);\n  othercasebit &= 0xff;\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  /* Note that this code only handles characters in the BMP. If there\n  ever are characters outside the BMP whose othercase differs in only one\n  bit from itself (there currently are none), this code will need to be\n  revised for PCRE2_CODE_UNIT_WIDTH == 32. */\n  othercasechar = cc + (othercasebit >> 9);\n  if ((othercasebit & 0x100) != 0)\n    othercasebit = (othercasebit & 0xff) << 8;\n  else\n    othercasebit &= 0xff;\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n  }\n\nif (context->sourcereg == -1)\n  {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  if (context->length >= 4)\n    OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else if (context->length >= 2)\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else\n#endif\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  if (context->length >= 4)\n    OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else\n#endif\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n  context->sourcereg = TMP2;\n  }\n\n#ifdef SUPPORT_UNICODE\nutflength = 1;\nif (common->utf && HAS_EXTRALEN(*cc))\n  utflength += GET_EXTRALEN(*cc);\n\ndo\n  {\n#endif\n\n  context->length -= IN_UCHARS(1);\n#if (defined SLJIT_UNALIGNED && SLJIT_UNALIGNED) && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\n\n  /* Unaligned read is supported. */\n  if (othercasebit != 0 && othercasechar == cc)\n    {\n    context->c.asuchars[context->ucharptr] = *cc | othercasebit;\n    context->oc.asuchars[context->ucharptr] = othercasebit;\n    }\n  else\n    {\n    context->c.asuchars[context->ucharptr] = *cc;\n    context->oc.asuchars[context->ucharptr] = 0;\n    }\n  context->ucharptr++;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  if (context->ucharptr >= 4 || context->length == 0 || (context->ucharptr == 2 && context->length == 1))\n#else\n  if (context->ucharptr >= 2 || context->length == 0)\n#endif\n    {\n    if (context->length >= 4)\n      OP1(SLJIT_MOV_S32, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n    else if (context->length >= 2)\n      OP1(SLJIT_MOV_U16, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    else if (context->length >= 1)\n      OP1(SLJIT_MOV_U8, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n    context->sourcereg = context->sourcereg == TMP1 ? TMP2 : TMP1;\n\n    switch(context->ucharptr)\n      {\n      case 4 / sizeof(PCRE2_UCHAR):\n      if (context->oc.asint != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asint);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asint | context->oc.asint));\n      break;\n\n      case 2 / sizeof(PCRE2_UCHAR):\n      if (context->oc.asushort != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asushort);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asushort | context->oc.asushort));\n      break;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      case 1:\n      if (context->oc.asbyte != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asbyte);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asbyte | context->oc.asbyte));\n      break;\n#endif\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    context->ucharptr = 0;\n    }\n\n#else\n\n  /* Unaligned read is unsupported or in 32 bit mode. */\n  if (context->length >= 1)\n    OP1(MOV_UCHAR, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n\n  context->sourcereg = context->sourcereg == TMP1 ? TMP2 : TMP1;\n\n  if (othercasebit != 0 && othercasechar == cc)\n    {\n    OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, othercasebit);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, *cc | othercasebit));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, *cc));\n\n#endif\n\n  cc++;\n#ifdef SUPPORT_UNICODE\n  utflength--;\n  }\nwhile (utflength > 0);\n#endif\n\nreturn cc;\n}\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n\n#define SET_TYPE_OFFSET(value) \\\n  if ((value) != typeoffset) \\\n    { \\\n    if ((value) < typeoffset) \\\n      OP2(SLJIT_ADD, typereg, 0, typereg, 0, SLJIT_IMM, typeoffset - (value)); \\\n    else \\\n      OP2(SLJIT_SUB, typereg, 0, typereg, 0, SLJIT_IMM, (value) - typeoffset); \\\n    } \\\n  typeoffset = (value);\n\n#define SET_CHAR_OFFSET(value) \\\n  if ((value) != charoffset) \\\n    { \\\n    if ((value) < charoffset) \\\n      OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(charoffset - (value))); \\\n    else \\\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)((value) - charoffset)); \\\n    } \\\n  charoffset = (value);\n\nstatic PCRE2_SPTR compile_char1_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks, BOOL check_str_ptr);\n\n#ifdef SUPPORT_UNICODE\n#define XCLASS_SAVE_CHAR 0x001\n#define XCLASS_CHAR_SAVED 0x002\n#define XCLASS_HAS_TYPE 0x004\n#define XCLASS_HAS_SCRIPT 0x008\n#define XCLASS_HAS_SCRIPT_EXTENSION 0x010\n#define XCLASS_HAS_BOOL 0x020\n#define XCLASS_HAS_BIDICL 0x040\n#define XCLASS_NEEDS_UCD (XCLASS_HAS_TYPE | XCLASS_HAS_SCRIPT | XCLASS_HAS_SCRIPT_EXTENSION | XCLASS_HAS_BOOL | XCLASS_HAS_BIDICL)\n#define XCLASS_SCRIPT_EXTENSION_NOTPROP 0x080\n#define XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR 0x100\n#define XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0 0x200\n\n#endif /* SUPPORT_UNICODE */\n\nstatic void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list *found = NULL;\njump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\nsljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\nBOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status = 0;\nint typereg = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n    if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    cc++;\n    if (*cc == PT_CLIST && cc[-1] == XCL_PROP)\n      {\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases != NOTACHAR)\n        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n    else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored. */\n      if (cc[-1] == XCL_PROP)\n        {\n        compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n          add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n        }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n      case PT_ALNUM:\n      unicode_status |= XCLASS_HAS_TYPE;\n      break;\n\n      case PT_SCX:\n      unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n      if (cc[-1] == XCL_NOTPROP)\n        {\n        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n        break;\n        }\n      compares++;\n      /* Fall through */ \n\n      case PT_SC:\n      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n      case PT_UCNC:\n      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\n      case PT_BOOL:\n      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\n      case PT_BIDICL:\n      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n/* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif ((cc[-1] & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\nelse\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\nif ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n      OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) != 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1] == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n          case PT_SC:\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n\n          jump = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n              {\n              add_jump(compiler, backtracks, jump);\n              jump = NULL;\n              }\n            invertcmp ^= 0x1;\n            }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n          if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\ntypeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump = NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc == XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing. */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /* Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n\n      /* At least three characters are required.\n         Otherwise this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0] != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\n      /* Optimizing character pairs, if their difference is power of 2. */\n      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n        }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found != NULL)\n  set_jumps(found, LABEL());\n}\n\n#undef SET_TYPE_OFFSET\n#undef SET_CHAR_OFFSET\n\n#endif\n\nstatic PCRE2_SPTR compile_simple_assertion_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nint length;\nstruct sljit_jump *jump[4];\n#ifdef SUPPORT_UNICODE\nstruct sljit_label *label;\n#endif /* SUPPORT_UNICODE */\n\nswitch(type)\n  {\n  case OP_SOD:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, TMP1, 0));\n  return cc;\n\n  case OP_SOM:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, TMP1, 0));\n  return cc;\n\n  case OP_NOT_WORD_BOUNDARY:\n  case OP_WORD_BOUNDARY:\n  add_jump(compiler, &common->wordboundary, JUMP(SLJIT_FAST_CALL));\n#ifdef SUPPORT_UNICODE\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, backtracks, CMP((type == OP_NOT_WORD_BOUNDARY) ? SLJIT_NOT_EQUAL : SLJIT_SIG_LESS_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n    return cc;\n    }\n#endif /* SUPPORT_UNICODE */\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_WORD_BOUNDARY ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n  case OP_EODN:\n  /* Requires rather complex checks. */\n  jump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_END, 0));\n    else\n      {\n      jump[1] = CMP(SLJIT_EQUAL, TMP2, 0, STR_END, 0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, STR_END, 0);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_NOT_EQUAL);\n      add_jump(compiler, backtracks, JUMP(SLJIT_NOT_EQUAL));\n      check_partial(common, TRUE);\n      add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n      JUMPHERE(jump[1]);\n      }\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else if (common->nltype == NLTYPE_FIXED)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_END, 0));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline));\n    }\n  else\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump[1] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2U(SLJIT_SUB | SLJIT_SET_Z | SLJIT_SET_GREATER, TMP2, 0, STR_END, 0);\n    jump[2] = JUMP(SLJIT_GREATER);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_EQUAL) /* LESS */);\n    /* Equal. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    jump[3] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\n    JUMPHERE(jump[1]);\n    if (common->nltype == NLTYPE_ANYCRLF)\n      {\n      OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, STR_END, 0));\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n      read_char(common, common->nlmin, common->nlmax, backtracks, READ_CHAR_UPDATE_STR_PTR);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0));\n      add_jump(compiler, &common->anynewline, JUMP(SLJIT_FAST_CALL));\n      sljit_set_current_flags(compiler, SLJIT_SET_Z);\n      add_jump(compiler, backtracks, JUMP(SLJIT_ZERO));\n      OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n      }\n    JUMPHERE(jump[2]);\n    JUMPHERE(jump[3]);\n    }\n  JUMPHERE(jump[0]);\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    check_partial(common, TRUE);\n  return cc;\n\n  case OP_EOD:\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0));\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    check_partial(common, TRUE);\n  return cc;\n\n  case OP_DOLL:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n    }\n  else\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n\n  if (!common->endonly)\n    compile_simple_assertion_matchingpath(common, OP_EODN, cc, backtracks);\n  else\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0));\n    check_partial(common, FALSE);\n    }\n  return cc;\n\n  case OP_DOLLM:\n  jump[1] = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n    }\n  else\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n  check_partial(common, FALSE);\n  jump[0] = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump[1]);\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER, TMP2, 0, STR_END, 0));\n    else\n      {\n      jump[1] = CMP(SLJIT_LESS_EQUAL, TMP2, 0, STR_END, 0);\n      /* STR_PTR = STR_END - IN_UCHARS(1) */\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n      check_partial(common, TRUE);\n      add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n      JUMPHERE(jump[1]);\n      }\n\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else\n    {\n    peek_char(common, common->nlmax, TMP3, 0, NULL);\n    check_newlinechar(common, common->nltype, backtracks, FALSE);\n    }\n  JUMPHERE(jump[0]);\n  return cc;\n\n  case OP_CIRC:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, begin));\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, TMP1, 0));\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, TMP1, 0));\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n    }\n  return cc;\n\n  case OP_CIRCM:\n  /* TMP2 might be used by peek_char_back. */\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    jump[1] = CMP(SLJIT_GREATER, STR_PTR, 0, TMP2, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n    jump[1] = CMP(SLJIT_GREATER, STR_PTR, 0, TMP2, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    }\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n  jump[0] = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump[1]);\n\n  if (!common->alt_circumflex)\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_SUB, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, TMP2, 0));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else\n    {\n    peek_char_back(common, common->nlmax, backtracks);\n    check_newlinechar(common, common->nltype, backtracks, FALSE);\n    }\n  JUMPHERE(jump[0]);\n  return cc;\n\n  case OP_REVERSE:\n  length = GET(cc, 0);\n  if (length == 0)\n    return cc + LINK_SIZE;\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    }\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, length);\n    label = LABEL();\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0));\n    move_back(common, backtracks, FALSE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP3, 0, TMP3, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  else\n#endif\n    {\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(length));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0));\n    }\n  check_start_used_ptr(common);\n  return cc + LINK_SIZE;\n  }\nSLJIT_UNREACHABLE();\nreturn cc;\n}\n\n#ifdef SUPPORT_UNICODE\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_utf(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR prevcc, endcc, bptr;\nBOOL first = TRUE;\nuint32_t c;\n\nprevcc = cc;\nendcc = NULL;\ndo\n  {\n  GETCHARINC(c, cc);\n  rgb = UCD_GRAPHBREAK(c);\n\n  if (first)\n    {\n    lgb = rgb;\n    endcc = cc;\n    first = FALSE;\n    continue;\n    }\n\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator)\n    {\n    ricount = 0;\n    bptr = prevcc;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      bptr--;\n      BACKCHAR(bptr);\n      GETCHAR(c, bptr);\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegional_Indicator)\n        break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0) break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  prevcc = endcc;\n  endcc = cc;\n  }\nwhile (cc < end_subject);\n\nreturn endcc;\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH != 32 */\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_utf_invalid(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR prevcc, endcc, bptr;\nBOOL first = TRUE;\nuint32_t c;\n\nprevcc = cc;\nendcc = NULL;\ndo\n  {\n  GETCHARINC_INVALID(c, cc, end_subject, break);\n  rgb = UCD_GRAPHBREAK(c);\n\n  if (first)\n    {\n    lgb = rgb;\n    endcc = cc;\n    first = FALSE;\n    continue;\n    }\n\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator)\n    {\n    ricount = 0;\n    bptr = prevcc;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      GETCHARBACK_INVALID(c, bptr, start_subject, break);\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegional_Indicator)\n        break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0)\n      break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  prevcc = endcc;\n  endcc = cc;\n  }\nwhile (cc < end_subject);\n\nreturn endcc;\n}\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_no_utf(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR bptr;\nuint32_t c;\n\n/* Patch by PH */\n/* GETCHARINC(c, cc); */\nc = *cc++;\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (c >= 0x110000)\n  return NULL;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\nlgb = UCD_GRAPHBREAK(c);\n\nwhile (cc < end_subject)\n  {\n  c = *cc;\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (c >= 0x110000)\n    break;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n  rgb = UCD_GRAPHBREAK(c);\n\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator)\n    {\n    ricount = 0;\n    bptr = cc - 1;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      bptr--;\n      c = *bptr;\n#if PCRE2_CODE_UNIT_WIDTH == 32\n      if (c >= 0x110000)\n        break;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegional_Indicator) break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0)\n      break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  cc++;\n  }\n\nreturn cc;\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic PCRE2_SPTR compile_char1_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks, BOOL check_str_ptr)\n{\nDEFINE_COMPILER;\nint length;\nunsigned int c, oc, bit;\ncompare_context context;\nstruct sljit_jump *jump[3];\njump_list *end_list;\n#ifdef SUPPORT_UNICODE\nPCRE2_UCHAR propdata[5];\n#endif /* SUPPORT_UNICODE */\n\nswitch(type)\n  {\n  case OP_NOT_DIGIT:\n  case OP_DIGIT:\n  /* Digits are usually 0-9, so it is worth to optimize them. */\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_digit, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_DIGIT);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_DIGIT);\n    /* Flip the starting bit in the negative case. */\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, ctype_digit);\n  add_jump(compiler, backtracks, JUMP(type == OP_DIGIT ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_NOT_WHITESPACE:\n  case OP_WHITESPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_space, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_WHITESPACE);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_WHITESPACE);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, ctype_space);\n  add_jump(compiler, backtracks, JUMP(type == OP_WHITESPACE ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_NOT_WORDCHAR:\n  case OP_WORDCHAR:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_word, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_WORDCHAR);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_WORDCHAR);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, ctype_word);\n  add_jump(compiler, backtracks, JUMP(type == OP_WORDCHAR ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_ANY:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  read_char(common, common->nlmin, common->nlmax, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    jump[0] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff);\n    end_list = NULL;\n    if (common->mode != PCRE2_JIT_PARTIAL_HARD)\n      add_jump(compiler, &end_list, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n    else\n      check_str_end(common, &end_list);\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline & 0xff));\n    set_jumps(end_list, LABEL());\n    JUMPHERE(jump[0]);\n    }\n  else\n    check_newlinechar(common, common->nltype, backtracks, TRUE);\n  return cc;\n\n  case OP_ALLANY:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    if (common->invalid_utf)\n      {\n      read_char(common, 0, READ_CHAR_MAX, backtracks, READ_CHAR_UPDATE_STR_PTR);\n      return cc;\n      }\n\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    jump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xfc00);\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n    JUMPHERE(jump[0]);\n    return cc;\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16] */\n    }\n#endif /* SUPPORT_UNICODE */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  return cc;\n\n  case OP_ANYBYTE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  return cc;\n\n#ifdef SUPPORT_UNICODE\n  case OP_NOTPROP:\n  case OP_PROP:\n  propdata[0] = XCL_HASPROP;\n  propdata[1] = type == OP_NOTPROP ? XCL_NOTPROP : XCL_PROP;\n  propdata[2] = cc[0];\n  propdata[3] = cc[1];\n  propdata[4] = XCL_END;\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  compile_xclass_matchingpath(common, propdata, backtracks);\n  return cc + 2;\n#endif\n\n  case OP_ANYNL:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  read_char(common, common->bsr_nlmin, common->bsr_nlmax, NULL, 0);\n  jump[0] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n  /* We don't need to handle soft partial matching case. */\n  end_list = NULL;\n  if (common->mode != PCRE2_JIT_PARTIAL_HARD)\n    add_jump(compiler, &end_list, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  else\n    check_str_end(common, &end_list);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  jump[1] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  jump[2] = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump[0]);\n  check_newlinechar(common, common->bsr_nltype, backtracks, FALSE);\n  set_jumps(end_list, LABEL());\n  JUMPHERE(jump[1]);\n  JUMPHERE(jump[2]);\n  return cc;\n\n  case OP_NOT_HSPACE:\n  case OP_HSPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_NOT_HSPACE)\n    read_char(common, 0x9, 0x3000, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0x9, 0x3000, NULL, 0);\n\n  add_jump(compiler, &common->hspace, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_HSPACE ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n  case OP_NOT_VSPACE:\n  case OP_VSPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_NOT_VSPACE)\n    read_char(common, 0xa, 0x2029, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0xa, 0x2029, NULL, 0);\n\n  add_jump(compiler, &common->vspace, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_VSPACE ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n#ifdef SUPPORT_UNICODE\n  case OP_EXTUNI:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  SLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n  OP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM,\n    common->utf ? (common->invalid_utf ? SLJIT_FUNC_ADDR(do_extuni_utf_invalid) : SLJIT_FUNC_ADDR(do_extuni_utf)) : SLJIT_FUNC_ADDR(do_extuni_no_utf));\n  if (common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n#else\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM,\n    common->invalid_utf ? SLJIT_FUNC_ADDR(do_extuni_utf_invalid) : SLJIT_FUNC_ADDR(do_extuni_no_utf));\n  if (!common->utf || common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n#endif\n\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_RETURN_REG, 0);\n\n  if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n    {\n    jump[0] = CMP(SLJIT_LESS, SLJIT_RETURN_REG, 0, STR_END, 0);\n    /* Since we successfully read a char above, partial matching must occure. */\n    check_partial(common, TRUE);\n    JUMPHERE(jump[0]);\n    }\n  return cc;\n#endif\n\n  case OP_CHAR:\n  case OP_CHARI:\n  length = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(*cc)) length += GET_EXTRALEN(*cc);\n#endif\n\n  if (check_str_ptr && common->mode != PCRE2_JIT_COMPLETE)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_CHAR || !char_has_othercase(common, cc) || char_get_othercase_bit(common, cc) != 0)\n    {\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(length));\n    if (length > 1 || (check_str_ptr && common->mode == PCRE2_JIT_COMPLETE))\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n    context.length = IN_UCHARS(length);\n    context.sourcereg = -1;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n    context.ucharptr = 0;\n#endif\n    return byte_sequence_compare(common, type == OP_CHARI, cc, &context, backtracks);\n    }\n\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n#endif\n    c = *cc;\n\n  SLJIT_ASSERT(type == OP_CHARI && char_has_othercase(common, cc));\n\n  if (check_str_ptr && common->mode == PCRE2_JIT_COMPLETE)\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  oc = char_othercase(common, c);\n  read_char(common, c < oc ? c : oc, c > oc ? c : oc, NULL, 0);\n\n  SLJIT_ASSERT(!is_powerof2(c ^ oc));\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n    {\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, oc);\n    CMOV(SLJIT_EQUAL, TMP1, SLJIT_IMM, c);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n    }\n  else\n    {\n    jump[0] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, oc));\n    JUMPHERE(jump[0]);\n    }\n  return cc + length;\n\n  case OP_NOT:\n  case OP_NOTI:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  length = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    c = *cc;\n    if (c < 128 && !common->invalid_utf)\n      {\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n      if (type == OP_NOT || !char_has_othercase(common, cc))\n        add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n      else\n        {\n        /* Since UTF8 code page is fixed, we know that c is in [a-z] or [A-Z] range. */\n        OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x20);\n        add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, c | 0x20));\n        }\n      /* Skip the variable-length character. */\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      jump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n      OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n      JUMPHERE(jump[0]);\n      return cc + 1;\n      }\n    else\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      {\n      GETCHARLEN(c, cc, length);\n      }\n    }\n  else\n#endif /* SUPPORT_UNICODE */\n    c = *cc;\n\n  if (type == OP_NOT || !char_has_othercase(common, cc))\n    {\n    read_char(common, c, c, backtracks, READ_CHAR_UPDATE_STR_PTR);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n    }\n  else\n    {\n    oc = char_othercase(common, c);\n    read_char(common, c < oc ? c : oc, c > oc ? c : oc, backtracks, READ_CHAR_UPDATE_STR_PTR);\n    bit = c ^ oc;\n    if (is_powerof2(bit))\n      {\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, bit);\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c | bit));\n      }\n    else\n      {\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, oc));\n      }\n    }\n  return cc + length;\n\n  case OP_CLASS:\n  case OP_NCLASS:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  bit = (common->utf && is_char7_bitset((const sljit_u8 *)cc, type == OP_NCLASS)) ? 127 : 255;\n  if (type == OP_NCLASS)\n    read_char(common, 0, bit, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0, bit, NULL, 0);\n#else\n  if (type == OP_NCLASS)\n    read_char(common, 0, 255, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0, 255, NULL, 0);\n#endif\n\n  if (optimize_class(common, (const sljit_u8 *)cc, type == OP_NCLASS, FALSE, backtracks))\n    return cc + 32 / sizeof(PCRE2_UCHAR);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  jump[0] = NULL;\n  if (common->utf)\n    {\n    jump[0] = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, bit);\n    if (type == OP_CLASS)\n      {\n      add_jump(compiler, backtracks, jump[0]);\n      jump[0] = NULL;\n      }\n    }\n#elif PCRE2_CODE_UNIT_WIDTH != 8\n  jump[0] = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n  if (type == OP_CLASS)\n    {\n    add_jump(compiler, backtracks, jump[0]);\n    jump[0] = NULL;\n    }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\n  OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n  OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n  add_jump(compiler, backtracks, JUMP(SLJIT_ZERO));\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n  if (jump[0] != NULL)\n    JUMPHERE(jump[0]);\n#endif\n  return cc + 32 / sizeof(PCRE2_UCHAR);\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  case OP_XCLASS:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  compile_xclass_matchingpath(common, cc + LINK_SIZE, backtracks);\n  return cc + GET(cc, 0) - 1;\n#endif\n  }\nSLJIT_UNREACHABLE();\nreturn cc;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_charn_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, jump_list **backtracks)\n{\n/* This function consumes at least one input character. */\n/* To decrease the number of length checks, we try to concatenate the fixed length character sequences. */\nDEFINE_COMPILER;\nPCRE2_SPTR ccbegin = cc;\ncompare_context context;\nint size;\n\ncontext.length = 0;\ndo\n  {\n  if (cc >= ccend)\n    break;\n\n  if (*cc == OP_CHAR)\n    {\n    size = 1;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[1]))\n      size += GET_EXTRALEN(cc[1]);\n#endif\n    }\n  else if (*cc == OP_CHARI)\n    {\n    size = 1;\n#ifdef SUPPORT_UNICODE\n    if (common->utf)\n      {\n      if (char_has_othercase(common, cc + 1) && char_get_othercase_bit(common, cc + 1) == 0)\n        size = 0;\n      else if (HAS_EXTRALEN(cc[1]))\n        size += GET_EXTRALEN(cc[1]);\n      }\n    else\n#endif\n    if (char_has_othercase(common, cc + 1) && char_get_othercase_bit(common, cc + 1) == 0)\n      size = 0;\n    }\n  else\n    size = 0;\n\n  cc += 1 + size;\n  context.length += IN_UCHARS(size);\n  }\nwhile (size > 0 && context.length <= 128);\n\ncc = ccbegin;\nif (context.length > 0)\n  {\n  /* We have a fixed-length byte sequence. */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, context.length);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n  context.sourcereg = -1;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  context.ucharptr = 0;\n#endif\n  do cc = byte_sequence_compare(common, *cc == OP_CHARI, cc + 1, &context, backtracks); while (context.length > 0);\n  return cc;\n  }\n\n/* A non-fixed length character will be checked if length == 0. */\nreturn compile_char1_matchingpath(common, *cc, cc + 1, backtracks, TRUE);\n}\n\n/* Forward definitions. */\nstatic void compile_matchingpath(compiler_common *, PCRE2_SPTR, PCRE2_SPTR, backtrack_common *);\nstatic void compile_backtrackingpath(compiler_common *, struct backtrack_common *);\n\n#define PUSH_BACKTRACK(size, ccstart, error) \\\n  do \\\n    { \\\n    backtrack = sljit_alloc_memory(compiler, (size)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return error; \\\n    memset(backtrack, 0, size); \\\n    backtrack->prev = parent->top; \\\n    backtrack->cc = (ccstart); \\\n    parent->top = backtrack; \\\n    } \\\n  while (0)\n\n#define PUSH_BACKTRACK_NOVALUE(size, ccstart) \\\n  do \\\n    { \\\n    backtrack = sljit_alloc_memory(compiler, (size)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return; \\\n    memset(backtrack, 0, size); \\\n    backtrack->prev = parent->top; \\\n    backtrack->cc = (ccstart); \\\n    parent->top = backtrack; \\\n    } \\\n  while (0)\n\n#define BACKTRACK_AS(type) ((type *)backtrack)\n\nstatic void compile_dnref_search(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\n/* The OVECTOR offset goes to TMP2. */\nDEFINE_COMPILER;\nint count = GET2(cc, 1 + IMM2_SIZE);\nPCRE2_SPTR slot = common->name_table + GET2(cc, 1) * common->name_entry_size;\nunsigned int offset;\njump_list *found = NULL;\n\nSLJIT_ASSERT(*cc == OP_DNREF || *cc == OP_DNREFI);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\n\ncount--;\nwhile (count-- > 0)\n  {\n  offset = GET2(slot, 0) << 1;\n  GET_LOCAL_BASE(TMP2, 0, OVECTOR(offset));\n  add_jump(compiler, &found, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0));\n  slot += common->name_entry_size;\n  }\n\noffset = GET2(slot, 0) << 1;\nGET_LOCAL_BASE(TMP2, 0, OVECTOR(offset));\nif (backtracks != NULL && !common->unset_backref)\n  add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0));\n\nset_jumps(found, LABEL());\n}\n\nstatic void compile_ref_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks, BOOL withchecks, BOOL emptyfail)\n{\nDEFINE_COMPILER;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nint offset = 0;\nstruct sljit_jump *jump = NULL;\nstruct sljit_jump *partial;\nstruct sljit_jump *nopartial;\n#if defined SUPPORT_UNICODE\nstruct sljit_label *loop;\nstruct sljit_label *caseless_loop;\njump_list *no_match = NULL;\nint source_reg = COUNT_MATCH;\nint source_end_reg = ARGUMENTS;\nint char1_reg = STACK_LIMIT;\n#endif /* SUPPORT_UNICODE */\n\nif (ref)\n  {\n  offset = GET2(cc, 1) << 1;\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n  /* OVECTOR(1) contains the \"string begin - 1\" constant. */\n  if (withchecks && !common->unset_backref)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n  }\nelse\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n\n#if defined SUPPORT_UNICODE\nif (common->utf && *cc == OP_REFI)\n  {\n  SLJIT_ASSERT(common->iref_ptr != 0);\n\n  if (ref)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n\n  if (withchecks && emptyfail)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, TMP2, 0));\n\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr, source_reg, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw), source_end_reg, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2, char1_reg, 0);\n\n  OP1(SLJIT_MOV, source_reg, 0, TMP1, 0);\n  OP1(SLJIT_MOV, source_end_reg, 0, TMP2, 0);\n\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, source_reg, 0, source_end_reg, 0);\n  partial = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\n  /* Read original character. It must be a valid UTF character. */\n  OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, STR_PTR, 0, source_reg, 0);\n\n  read_char(common, 0, READ_CHAR_MAX, NULL, READ_CHAR_UPDATE_STR_PTR | READ_CHAR_VALID_UTF);\n\n  OP1(SLJIT_MOV, source_reg, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n  OP1(SLJIT_MOV, char1_reg, 0, TMP1, 0);\n\n  /* Read second character. */\n  read_char(common, 0, READ_CHAR_MAX, &no_match, READ_CHAR_UPDATE_STR_PTR);\n\n  CMPTO(SLJIT_EQUAL, TMP1, 0, char1_reg, 0, loop);\n\n  OP1(SLJIT_MOV, TMP3, 0, TMP1, 0);\n\n  add_jump(compiler, &common->getucd, JUMP(SLJIT_FAST_CALL));\n\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_records));\n\n  OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(ucd_record, other_case));\n  OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(ucd_record, caseset));\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP3, 0);\n  CMPTO(SLJIT_EQUAL, TMP1, 0, char1_reg, 0, loop);\n\n  add_jump(compiler, &no_match, CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_caseless_sets));\n\n  caseless_loop = LABEL();\n  OP1(SLJIT_MOV_U32, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, sizeof(uint32_t));\n  OP2U(SLJIT_SUB | SLJIT_SET_Z | SLJIT_SET_LESS, TMP1, 0, char1_reg, 0);\n  JUMPTO(SLJIT_EQUAL, loop);\n  JUMPTO(SLJIT_LESS, caseless_loop);\n\n  set_jumps(no_match, LABEL());\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    JUMPHERE(partial);\n\n  OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n  OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n  OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    JUMPHERE(partial);\n    OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n    OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n\n    check_partial(common, FALSE);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    }\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n  OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n  OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n  return;\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n  if (ref)\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP1, 0);\n  else\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw), TMP1, 0);\n\n  if (withchecks)\n    jump = JUMP(SLJIT_ZERO);\n\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n  partial = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    add_jump(compiler, backtracks, partial);\n\n  add_jump(compiler, *cc == OP_REF ? &common->casefulcmp : &common->caselesscmp, JUMP(SLJIT_FAST_CALL));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    nopartial = JUMP(SLJIT_JUMP);\n    JUMPHERE(partial);\n    /* TMP2 -= STR_END - STR_PTR */\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, STR_PTR, 0);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, STR_END, 0);\n    partial = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n    add_jump(compiler, *cc == OP_REF ? &common->casefulcmp : &common->caselesscmp, JUMP(SLJIT_FAST_CALL));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n    JUMPHERE(partial);\n    check_partial(common, FALSE);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(nopartial);\n    }\n  }\n\nif (jump != NULL)\n  {\n  if (emptyfail)\n    add_jump(compiler, backtracks, jump);\n  else\n    JUMPHERE(jump);\n  }\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_ref_iterator_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nbacktrack_common *backtrack;\nPCRE2_UCHAR type;\nint offset = 0;\nstruct sljit_label *label;\nstruct sljit_jump *zerolength;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin = cc;\nint min = 0, max = 0;\nBOOL minimize;\n\nPUSH_BACKTRACK(sizeof(ref_iterator_backtrack), cc, NULL);\n\nif (ref)\n  offset = GET2(cc, 1) << 1;\nelse\n  cc += IMM2_SIZE;\ntype = cc[1 + IMM2_SIZE];\n\nSLJIT_COMPILE_ASSERT((OP_CRSTAR & 0x1) == 0, crstar_opcode_must_be_even);\nminimize = (type & 0x1) != 0;\nswitch(type)\n  {\n  case OP_CRSTAR:\n  case OP_CRMINSTAR:\n  min = 0;\n  max = 0;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRPLUS:\n  case OP_CRMINPLUS:\n  min = 1;\n  max = 0;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  min = 0;\n  max = 1;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  min = GET2(cc, 1 + IMM2_SIZE + 1);\n  max = GET2(cc, 1 + IMM2_SIZE + 1 + IMM2_SIZE);\n  cc += 1 + IMM2_SIZE + 1 + 2 * IMM2_SIZE;\n  break;\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nif (!minimize)\n  {\n  if (min == 0)\n    {\n    allocate_stack(common, 2);\n    if (ref)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n    /* Temporary release of STR_PTR. */\n    OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n    /* Handles both invalid and empty cases. Since the minimum repeat,\n    is zero the invalid case is basically the same as an empty case. */\n    if (ref)\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    else\n      {\n      compile_dnref_search(common, ccbegin, NULL);\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, TMP2, 0);\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n      }\n    /* Restore if not zero length. */\n    OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n    }\n  else\n    {\n    allocate_stack(common, 1);\n    if (ref)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    if (ref)\n      {\n      add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n      }\n    else\n      {\n      compile_dnref_search(common, ccbegin, &backtrack->topbacktracks);\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, TMP2, 0);\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n      }\n    }\n\n  if (min > 1 || max > 1)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, SLJIT_IMM, 0);\n\n  label = LABEL();\n  if (!ref)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1);\n  compile_ref_matchingpath(common, ccbegin, &backtrack->topbacktracks, FALSE, FALSE);\n\n  if (min > 1 || max > 1)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, TMP1, 0);\n    if (min > 1)\n      CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, min, label);\n    if (max > 1)\n      {\n      jump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, max);\n      allocate_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, label);\n      JUMPHERE(jump);\n      }\n    }\n\n  if (max == 0)\n    {\n    /* Includes min > 1 case as well. */\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    JUMPTO(SLJIT_JUMP, label);\n    }\n\n  JUMPHERE(zerolength);\n  BACKTRACK_AS(ref_iterator_backtrack)->matchingpath = LABEL();\n\n  count_match(common);\n  return cc;\n  }\n\nallocate_stack(common, ref ? 2 : 3);\nif (ref)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\nif (type != OP_CRMINSTAR)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n\nif (min == 0)\n  {\n  /* Handles both invalid and empty cases. Since the minimum repeat,\n  is zero the invalid case is basically the same as an empty case. */\n  if (ref)\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  else\n    {\n    compile_dnref_search(common, ccbegin, NULL);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0);\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    }\n  /* Length is non-zero, we can match real repeats. */\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  jump = JUMP(SLJIT_JUMP);\n  }\nelse\n  {\n  if (ref)\n    {\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    }\n  else\n    {\n    compile_dnref_search(common, ccbegin, &backtrack->topbacktracks);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0);\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    }\n  }\n\nBACKTRACK_AS(ref_iterator_backtrack)->matchingpath = LABEL();\nif (max > 0)\n  add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, max));\n\nif (!ref)\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\ncompile_ref_matchingpath(common, ccbegin, &backtrack->topbacktracks, TRUE, TRUE);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\nif (min > 1)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, min, BACKTRACK_AS(ref_iterator_backtrack)->matchingpath);\n  }\nelse if (max > 0)\n  OP2(SLJIT_ADD, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 1);\n\nif (jump != NULL)\n  JUMPHERE(jump);\nJUMPHERE(zerolength);\n\ncount_match(common);\nreturn cc;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_recurse_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nrecurse_entry *entry = common->entries;\nrecurse_entry *prev = NULL;\nsljit_sw start = GET(cc, 1);\nPCRE2_SPTR start_cc;\nBOOL needs_control_head;\n\nPUSH_BACKTRACK(sizeof(recurse_backtrack), cc, NULL);\n\n/* Inlining simple patterns. */\nif (get_framesize(common, common->start + start, NULL, TRUE, &needs_control_head) == no_stack)\n  {\n  start_cc = common->start + start;\n  compile_matchingpath(common, next_opcode(common, start_cc), bracketend(start_cc) - (1 + LINK_SIZE), backtrack);\n  BACKTRACK_AS(recurse_backtrack)->inlined_pattern = TRUE;\n  return cc + 1 + LINK_SIZE;\n  }\n\nwhile (entry != NULL)\n  {\n  if (entry->start == start)\n    break;\n  prev = entry;\n  entry = entry->next;\n  }\n\nif (entry == NULL)\n  {\n  entry = sljit_alloc_memory(compiler, sizeof(recurse_entry));\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n  entry->next = NULL;\n  entry->entry_label = NULL;\n  entry->backtrack_label = NULL;\n  entry->entry_calls = NULL;\n  entry->backtrack_calls = NULL;\n  entry->start = start;\n\n  if (prev != NULL)\n    prev->next = entry;\n  else\n    common->entries = entry;\n  }\n\nBACKTRACK_AS(recurse_backtrack)->entry = entry;\n\nif (entry->entry_label == NULL)\n  add_jump(compiler, &entry->entry_calls, JUMP(SLJIT_FAST_CALL));\nelse\n  JUMPTO(SLJIT_FAST_CALL, entry->entry_label);\n/* Leave if the match is failed. */\nadd_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\nBACKTRACK_AS(recurse_backtrack)->matchingpath = LABEL();\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic sljit_s32 SLJIT_FUNC do_callout(struct jit_arguments *arguments, pcre2_callout_block *callout_block, PCRE2_SPTR *jit_ovector)\n{\nPCRE2_SPTR begin;\nPCRE2_SIZE *ovector;\nsljit_u32 oveccount, capture_top;\n\nif (arguments->callout == NULL)\n  return 0;\n\nSLJIT_COMPILE_ASSERT(sizeof (PCRE2_SIZE) <= sizeof (sljit_sw), pcre2_size_must_be_lower_than_sljit_sw_size);\n\nbegin = arguments->begin;\novector = (PCRE2_SIZE*)(callout_block + 1);\noveccount = callout_block->capture_top;\n\nSLJIT_ASSERT(oveccount >= 1);\n\ncallout_block->version = 2;\ncallout_block->callout_flags = 0;\n\n/* Offsets in subject. */\ncallout_block->subject_length = arguments->end - arguments->begin;\ncallout_block->start_match = jit_ovector[0] - begin;\ncallout_block->current_position = (PCRE2_SPTR)callout_block->offset_vector - begin;\ncallout_block->subject = begin;\n\n/* Convert and copy the JIT offset vector to the ovector array. */\ncallout_block->capture_top = 1;\ncallout_block->offset_vector = ovector;\n\novector[0] = PCRE2_UNSET;\novector[1] = PCRE2_UNSET;\novector += 2;\njit_ovector += 2;\ncapture_top = 1;\n\n/* Convert pointers to sizes. */\nwhile (--oveccount != 0)\n  {\n  capture_top++;\n\n  ovector[0] = (PCRE2_SIZE)(jit_ovector[0] - begin);\n  ovector[1] = (PCRE2_SIZE)(jit_ovector[1] - begin);\n\n  if (ovector[0] != PCRE2_UNSET)\n    callout_block->capture_top = capture_top;\n\n  ovector += 2;\n  jit_ovector += 2;\n  }\n\nreturn (arguments->callout)(callout_block, arguments->callout_data);\n}\n\n#define CALLOUT_ARG_OFFSET(arg) \\\n    SLJIT_OFFSETOF(pcre2_callout_block, arg)\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_callout_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nsljit_s32 mov_opcode;\nunsigned int callout_length = (*cc == OP_CALLOUT)\n    ? PRIV(OP_lengths)[OP_CALLOUT] : GET(cc, 1 + 2 * LINK_SIZE);\nsljit_sw value1;\nsljit_sw value2;\nsljit_sw value3;\nsljit_uw callout_arg_size = (common->re->top_bracket + 1) * 2 * sizeof(sljit_sw);\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\ncallout_arg_size = (sizeof(pcre2_callout_block) + callout_arg_size + sizeof(sljit_sw) - 1) / sizeof(sljit_sw);\n\nallocate_stack(common, callout_arg_size);\n\nSLJIT_ASSERT(common->capture_last_ptr != 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\nOP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\nvalue1 = (*cc == OP_CALLOUT) ? cc[1 + 2 * LINK_SIZE] : 0;\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_number), SLJIT_IMM, value1);\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(capture_last), TMP2, 0);\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(capture_top), SLJIT_IMM, common->re->top_bracket + 1);\n\n/* These pointer sized fields temporarly stores internal variables. */\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(offset_vector), STR_PTR, 0);\n\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, mark_ptr));\nmov_opcode = (sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV;\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(pattern_position), SLJIT_IMM, GET(cc, 1));\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(next_item_length), SLJIT_IMM, GET(cc, 1 + LINK_SIZE));\n\nif (*cc == OP_CALLOUT)\n  {\n  value1 = 0;\n  value2 = 0;\n  value3 = 0;\n  }\nelse\n  {\n  value1 = (sljit_sw) (cc + (1 + 4*LINK_SIZE) + 1);\n  value2 = (callout_length - (1 + 4*LINK_SIZE + 2));\n  value3 = (sljit_sw) (GET(cc, 1 + 3*LINK_SIZE));\n  }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string), SLJIT_IMM, value1);\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string_length), SLJIT_IMM, value2);\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string_offset), SLJIT_IMM, value3);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(mark), (common->mark_ptr != 0) ? TMP2 : SLJIT_IMM, 0);\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\n/* Needed to save important temporary registers. */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, STR_PTR, 0);\n/* SLJIT_R0 = arguments */\nOP1(SLJIT_MOV, SLJIT_R1, 0, STACK_TOP, 0);\nGET_LOCAL_BASE(SLJIT_R2, 0, OVECTOR_START);\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS3(32, W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_callout));\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nfree_stack(common, callout_arg_size);\n\n/* Check return value. */\nOP2U(SLJIT_SUB32 | SLJIT_SET_Z | SLJIT_SET_SIG_GREATER, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_SIG_GREATER));\nif (common->abort_label == NULL)\n  add_jump(compiler, &common->abort, JUMP(SLJIT_NOT_EQUAL) /* SIG_LESS */);\nelse\n  JUMPTO(SLJIT_NOT_EQUAL /* SIG_LESS */, common->abort_label);\nreturn cc + callout_length;\n}\n\n#undef CALLOUT_ARG_SIZE\n#undef CALLOUT_ARG_OFFSET\n\nstatic SLJIT_INLINE BOOL assert_needs_str_ptr_saving(PCRE2_SPTR cc)\n{\nwhile (TRUE)\n  {\n  switch (*cc)\n    {\n    case OP_CALLOUT_STR:\n    cc += GET(cc, 1 + 2*LINK_SIZE);\n    break;\n\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CALLOUT:\n    case OP_ALT:\n    cc += PRIV(OP_lengths)[*cc];\n    break;\n\n    case OP_KET:\n    return FALSE;\n\n    default:\n    return TRUE;\n    }\n  }\n}\n\nstatic PCRE2_SPTR compile_assert_matchingpath(compiler_common *common, PCRE2_SPTR cc, assert_backtrack *backtrack, BOOL conditional)\n{\nDEFINE_COMPILER;\nint framesize;\nint extrasize;\nBOOL local_quit_available = FALSE;\nBOOL needs_control_head;\nint private_data_ptr;\nbacktrack_common altbacktrack;\nPCRE2_SPTR ccbegin;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR bra = OP_BRA;\njump_list *tmp = NULL;\njump_list **target = (conditional) ? &backtrack->condfailed : &backtrack->common.topbacktracks;\njump_list **found;\n/* Saving previous accept variables. */\nBOOL save_local_quit_available = common->local_quit_available;\nBOOL save_in_positive_assertion = common->in_positive_assertion;\nthen_trap_backtrack *save_then_trap = common->then_trap;\nstruct sljit_label *save_quit_label = common->quit_label;\nstruct sljit_label *save_accept_label = common->accept_label;\njump_list *save_quit = common->quit;\njump_list *save_positive_assertion_quit = common->positive_assertion_quit;\njump_list *save_accept = common->accept;\nstruct sljit_jump *jump;\nstruct sljit_jump *brajump = NULL;\n\n/* Assert captures then. */\ncommon->then_trap = NULL;\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  SLJIT_ASSERT(!conditional);\n  bra = *cc;\n  cc++;\n  }\nprivate_data_ptr = PRIVATE_DATA(cc);\nSLJIT_ASSERT(private_data_ptr != 0);\nframesize = get_framesize(common, cc, NULL, FALSE, &needs_control_head);\nbacktrack->framesize = framesize;\nbacktrack->private_data_ptr = private_data_ptr;\nopcode = *cc;\nSLJIT_ASSERT(opcode >= OP_ASSERT && opcode <= OP_ASSERTBACK_NOT);\nfound = (opcode == OP_ASSERT || opcode == OP_ASSERTBACK) ? &tmp : target;\nccbegin = cc;\ncc += GET(cc, 1);\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a braminzero backtrack path. */\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  brajump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  }\n\nif (framesize < 0)\n  {\n  extrasize = 1;\n  if (bra == OP_BRA && !assert_needs_str_ptr_saving(ccbegin + 1 + LINK_SIZE))\n    extrasize = 0;\n\n  if (needs_control_head)\n    extrasize++;\n\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n\n  if (extrasize > 0)\n    allocate_stack(common, extrasize);\n\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n\n  if (extrasize > 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\n  if (needs_control_head)\n    {\n    SLJIT_ASSERT(extrasize == 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n    }\n  }\nelse\n  {\n  extrasize = needs_control_head ? 3 : 2;\n  allocate_stack(common, framesize + extrasize);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  OP2(SLJIT_ADD, TMP2, 0, STACK_TOP, 0, SLJIT_IMM, (framesize + extrasize) * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n    }\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n\n  init_frame(common, ccbegin, NULL, framesize + extrasize - 1, extrasize);\n  }\n\nmemset(&altbacktrack, 0, sizeof(backtrack_common));\nif (conditional || (opcode == OP_ASSERT_NOT || opcode == OP_ASSERTBACK_NOT))\n  {\n  /* Control verbs cannot escape from these asserts. */\n  local_quit_available = TRUE;\n  common->local_quit_available = TRUE;\n  common->quit_label = NULL;\n  common->quit = NULL;\n  }\n\ncommon->in_positive_assertion = (opcode == OP_ASSERT || opcode == OP_ASSERTBACK);\ncommon->positive_assertion_quit = NULL;\n\nwhile (1)\n  {\n  common->accept_label = NULL;\n  common->accept = NULL;\n  altbacktrack.top = NULL;\n  altbacktrack.topbacktracks = NULL;\n\n  if (*ccbegin == OP_ALT && extrasize > 0)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  altbacktrack.cc = ccbegin;\n  compile_matchingpath(common, ccbegin + 1 + LINK_SIZE, cc, &altbacktrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    if (local_quit_available)\n      {\n      common->local_quit_available = save_local_quit_available;\n      common->quit_label = save_quit_label;\n      common->quit = save_quit;\n      }\n    common->in_positive_assertion = save_in_positive_assertion;\n    common->then_trap = save_then_trap;\n    common->accept_label = save_accept_label;\n    common->positive_assertion_quit = save_positive_assertion_quit;\n    common->accept = save_accept;\n    return NULL;\n    }\n  common->accept_label = LABEL();\n  if (common->accept != NULL)\n    set_jumps(common->accept, common->accept_label);\n\n  /* Reset stack. */\n  if (framesize < 0)\n    {\n    if (framesize == no_frame)\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n    }\n  else\n    {\n    if ((opcode != OP_ASSERT_NOT && opcode != OP_ASSERTBACK_NOT) || conditional)\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 1) * sizeof(sljit_sw));\n      if (needs_control_head)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      if (needs_control_head)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 2));\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (framesize - 1) * sizeof(sljit_sw));\n      }\n    }\n\n  if (opcode == OP_ASSERT_NOT || opcode == OP_ASSERTBACK_NOT)\n    {\n    /* We know that STR_PTR was stored on the top of the stack. */\n    if (conditional)\n      {\n      if (extrasize > 0)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), needs_control_head ? STACK(-2) : STACK(-1));\n      }\n    else if (bra == OP_BRAZERO)\n      {\n      if (framesize < 0)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize));\n      else\n        {\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 1));\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-framesize - extrasize));\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n        }\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (framesize >= 0)\n      {\n      /* For OP_BRA and OP_BRAMINZERO. */\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 1));\n      }\n    }\n  add_jump(compiler, found, JUMP(SLJIT_JUMP));\n\n  compile_backtrackingpath(common, altbacktrack.top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    if (local_quit_available)\n      {\n      common->local_quit_available = save_local_quit_available;\n      common->quit_label = save_quit_label;\n      common->quit = save_quit;\n      }\n    common->in_positive_assertion = save_in_positive_assertion;\n    common->then_trap = save_then_trap;\n    common->accept_label = save_accept_label;\n    common->positive_assertion_quit = save_positive_assertion_quit;\n    common->accept = save_accept;\n    return NULL;\n    }\n  set_jumps(altbacktrack.topbacktracks, LABEL());\n\n  if (*cc != OP_ALT)\n    break;\n\n  ccbegin = cc;\n  cc += GET(cc, 1);\n  }\n\nif (local_quit_available)\n  {\n  SLJIT_ASSERT(common->positive_assertion_quit == NULL);\n  /* Makes the check less complicated below. */\n  common->positive_assertion_quit = common->quit;\n  }\n\n/* None of them matched. */\nif (common->positive_assertion_quit != NULL)\n  {\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(common->positive_assertion_quit, LABEL());\n  SLJIT_ASSERT(framesize != no_stack);\n  if (framesize < 0)\n    OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, extrasize * sizeof(sljit_sw));\n  else\n    {\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n    OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (extrasize + 1) * sizeof(sljit_sw));\n    }\n  JUMPHERE(jump);\n  }\n\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(1));\n\nif (opcode == OP_ASSERT || opcode == OP_ASSERTBACK)\n  {\n  /* Assert is failed. */\n  if ((conditional && extrasize > 0) || bra == OP_BRAZERO)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  if (framesize < 0)\n    {\n    /* The topmost item should be 0. */\n    if (bra == OP_BRAZERO)\n      {\n      if (extrasize == 2)\n        free_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(extrasize - 1));\n    /* The topmost item should be 0. */\n    if (bra == OP_BRAZERO)\n      {\n      free_stack(common, framesize + extrasize - 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, framesize + extrasize);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  jump = JUMP(SLJIT_JUMP);\n  if (bra != OP_BRAZERO)\n    add_jump(compiler, target, jump);\n\n  /* Assert is successful. */\n  set_jumps(tmp, LABEL());\n  if (framesize < 0)\n    {\n    /* We know that STR_PTR was stored on the top of the stack. */\n    if (extrasize > 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize));\n\n    /* Keep the STR_PTR on the top of the stack. */\n    if (bra == OP_BRAZERO)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      if (extrasize == 2)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n    else if (bra == OP_BRAMINZERO)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    }\n  else\n    {\n    if (bra == OP_BRA)\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize + 1));\n      }\n    else\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 2) * sizeof(sljit_sw));\n      if (extrasize == 2)\n        {\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n        if (bra == OP_BRAMINZERO)\n          OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n        }\n      else\n        {\n        SLJIT_ASSERT(extrasize == 3);\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), bra == OP_BRAZERO ? STR_PTR : SLJIT_IMM, 0);\n        }\n      }\n    }\n\n  if (bra == OP_BRAZERO)\n    {\n    backtrack->matchingpath = LABEL();\n    SET_LABEL(jump, backtrack->matchingpath);\n    }\n  else if (bra == OP_BRAMINZERO)\n    {\n    JUMPTO(SLJIT_JUMP, backtrack->matchingpath);\n    JUMPHERE(brajump);\n    if (framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n      }\n    set_jumps(backtrack->common.topbacktracks, LABEL());\n    }\n  }\nelse\n  {\n  /* AssertNot is successful. */\n  if (framesize < 0)\n    {\n    if (extrasize > 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n    if (bra != OP_BRA)\n      {\n      if (extrasize == 2)\n        free_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(extrasize - 1));\n    /* The topmost item should be 0. */\n    if (bra != OP_BRA)\n      {\n      free_stack(common, framesize + extrasize - 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, framesize + extrasize);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n\n  if (bra == OP_BRAZERO)\n    backtrack->matchingpath = LABEL();\n  else if (bra == OP_BRAMINZERO)\n    {\n    JUMPTO(SLJIT_JUMP, backtrack->matchingpath);\n    JUMPHERE(brajump);\n    }\n\n  if (bra != OP_BRA)\n    {\n    SLJIT_ASSERT(found == &backtrack->common.topbacktracks);\n    set_jumps(backtrack->common.topbacktracks, LABEL());\n    backtrack->common.topbacktracks = NULL;\n    }\n  }\n\nif (local_quit_available)\n  {\n  common->local_quit_available = save_local_quit_available;\n  common->quit_label = save_quit_label;\n  common->quit = save_quit;\n  }\ncommon->in_positive_assertion = save_in_positive_assertion;\ncommon->then_trap = save_then_trap;\ncommon->accept_label = save_accept_label;\ncommon->positive_assertion_quit = save_positive_assertion_quit;\ncommon->accept = save_accept;\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic SLJIT_INLINE void match_once_common(compiler_common *common, PCRE2_UCHAR ket, int framesize, int private_data_ptr, BOOL has_alternatives, BOOL needs_control_head)\n{\nDEFINE_COMPILER;\nint stacksize;\n\nif (framesize < 0)\n  {\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  else\n    {\n    stacksize = needs_control_head ? 1 : 0;\n    if (ket != OP_KET || has_alternatives)\n      stacksize++;\n\n    if (stacksize > 0)\n      free_stack(common, stacksize);\n    }\n\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), (ket != OP_KET || has_alternatives) ? STACK(-2) : STACK(-1));\n\n  /* TMP2 which is set here used by OP_KETRMAX below. */\n  if (ket == OP_KETRMAX)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n  else if (ket == OP_KETRMIN)\n    {\n    /* Move the STR_PTR to the private_data_ptr. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n    }\n  }\nelse\n  {\n  stacksize = (ket != OP_KET || has_alternatives) ? 2 : 1;\n  OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + stacksize) * sizeof(sljit_sw));\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n\n  if (ket == OP_KETRMAX)\n    {\n    /* TMP2 which is set here used by OP_KETRMAX below. */\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    }\n  }\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP1, 0);\n}\n\nstatic SLJIT_INLINE int match_capture_common(compiler_common *common, int stacksize, int offset, int private_data_ptr)\n{\nDEFINE_COMPILER;\n\nif (common->capture_last_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n  stacksize++;\n  }\nif (common->optimized_cbracket[offset >> 1] == 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize + 1), TMP2, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n  stacksize += 2;\n  }\nreturn stacksize;\n}\n\nstatic PCRE2_SPTR SLJIT_FUNC do_script_run(PCRE2_SPTR ptr, PCRE2_SPTR endptr)\n{\n  if (PRIV(script_run)(ptr, endptr, FALSE))\n    return endptr;\n  return NULL;\n}\n\n#ifdef SUPPORT_UNICODE\n\nstatic PCRE2_SPTR SLJIT_FUNC do_script_run_utf(PCRE2_SPTR ptr, PCRE2_SPTR endptr)\n{\n  if (PRIV(script_run)(ptr, endptr, TRUE))\n    return endptr;\n  return NULL;\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic SLJIT_INLINE void match_script_run_common(compiler_common *common, int private_data_ptr, backtrack_common *parent)\n{\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n#ifdef SUPPORT_UNICODE\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM,\n  common->utf ? SLJIT_FUNC_ADDR(do_script_run_utf) : SLJIT_FUNC_ADDR(do_script_run));\n#else\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_script_run));\n#endif\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_RETURN_REG, 0);\nadd_jump(compiler, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n}\n\n/*\n  Handling bracketed expressions is probably the most complex part.\n\n  Stack layout naming characters:\n    S - Push the current STR_PTR\n    0 - Push a 0 (NULL)\n    A - Push the current STR_PTR. Needed for restoring the STR_PTR\n        before the next alternative. Not pushed if there are no alternatives.\n    M - Any values pushed by the current alternative. Can be empty, or anything.\n    C - Push the previous OVECTOR(i), OVECTOR(i+1) and OVECTOR_PRIV(i) to the stack.\n    L - Push the previous local (pointed by localptr) to the stack\n   () - opional values stored on the stack\n  ()* - optonal, can be stored multiple times\n\n  The following list shows the regular expression templates, their PCRE byte codes\n  and stack layout supported by pcre-sljit.\n\n  (?:)                     OP_BRA     | OP_KET                A M\n  ()                       OP_CBRA    | OP_KET                C M\n  (?:)+                    OP_BRA     | OP_KETRMAX        0   A M S   ( A M S )*\n                           OP_SBRA    | OP_KETRMAX        0   L M S   ( L M S )*\n  (?:)+?                   OP_BRA     | OP_KETRMIN        0   A M S   ( A M S )*\n                           OP_SBRA    | OP_KETRMIN        0   L M S   ( L M S )*\n  ()+                      OP_CBRA    | OP_KETRMAX        0   C M S   ( C M S )*\n                           OP_SCBRA   | OP_KETRMAX        0   C M S   ( C M S )*\n  ()+?                     OP_CBRA    | OP_KETRMIN        0   C M S   ( C M S )*\n                           OP_SCBRA   | OP_KETRMIN        0   C M S   ( C M S )*\n  (?:)?    OP_BRAZERO    | OP_BRA     | OP_KET            S ( A M 0 )\n  (?:)??   OP_BRAMINZERO | OP_BRA     | OP_KET            S ( A M 0 )\n  ()?      OP_BRAZERO    | OP_CBRA    | OP_KET            S ( C M 0 )\n  ()??     OP_BRAMINZERO | OP_CBRA    | OP_KET            S ( C M 0 )\n  (?:)*    OP_BRAZERO    | OP_BRA     | OP_KETRMAX      S 0 ( A M S )*\n           OP_BRAZERO    | OP_SBRA    | OP_KETRMAX      S 0 ( L M S )*\n  (?:)*?   OP_BRAMINZERO | OP_BRA     | OP_KETRMIN      S 0 ( A M S )*\n           OP_BRAMINZERO | OP_SBRA    | OP_KETRMIN      S 0 ( L M S )*\n  ()*      OP_BRAZERO    | OP_CBRA    | OP_KETRMAX      S 0 ( C M S )*\n           OP_BRAZERO    | OP_SCBRA   | OP_KETRMAX      S 0 ( C M S )*\n  ()*?     OP_BRAMINZERO | OP_CBRA    | OP_KETRMIN      S 0 ( C M S )*\n           OP_BRAMINZERO | OP_SCBRA   | OP_KETRMIN      S 0 ( C M S )*\n\n\n  Stack layout naming characters:\n    A - Push the alternative index (starting from 0) on the stack.\n        Not pushed if there is no alternatives.\n    M - Any values pushed by the current alternative. Can be empty, or anything.\n\n  The next list shows the possible content of a bracket:\n  (|)     OP_*BRA    | OP_ALT ...         M A\n  (?()|)  OP_*COND   | OP_ALT             M A\n  (?>|)   OP_ONCE    | OP_ALT ...         [stack trace] M A\n                                          Or nothing, if trace is unnecessary\n*/\n\nstatic PCRE2_SPTR compile_bracket_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nint private_data_ptr = 0;\nint offset = 0;\nint i, stacksize;\nint repeat_ptr = 0, repeat_length = 0;\nint repeat_type = 0, repeat_count = 0;\nPCRE2_SPTR ccbegin;\nPCRE2_SPTR matchingpath;\nPCRE2_SPTR slot;\nPCRE2_UCHAR bra = OP_BRA;\nPCRE2_UCHAR ket;\nassert_backtrack *assert;\nBOOL has_alternatives;\nBOOL needs_control_head = FALSE;\nstruct sljit_jump *jump;\nstruct sljit_jump *skip;\nstruct sljit_label *rmax_label = NULL;\nstruct sljit_jump *braminzero = NULL;\n\nPUSH_BACKTRACK(sizeof(bracket_backtrack), cc, NULL);\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  bra = *cc;\n  cc++;\n  opcode = *cc;\n  }\n\nopcode = *cc;\nccbegin = cc;\nmatchingpath = bracketend(cc) - 1 - LINK_SIZE;\nket = *matchingpath;\nif (ket == OP_KET && PRIVATE_DATA(matchingpath) != 0)\n  {\n  repeat_ptr = PRIVATE_DATA(matchingpath);\n  repeat_length = PRIVATE_DATA(matchingpath + 1);\n  repeat_type = PRIVATE_DATA(matchingpath + 2);\n  repeat_count = PRIVATE_DATA(matchingpath + 3);\n  SLJIT_ASSERT(repeat_length != 0 && repeat_type != 0 && repeat_count != 0);\n  if (repeat_type == OP_UPTO)\n    ket = OP_KETRMAX;\n  if (repeat_type == OP_MINUPTO)\n    ket = OP_KETRMIN;\n  }\n\nmatchingpath = ccbegin + 1 + LINK_SIZE;\nSLJIT_ASSERT(ket == OP_KET || ket == OP_KETRMAX || ket == OP_KETRMIN);\nSLJIT_ASSERT(!((bra == OP_BRAZERO && ket == OP_KETRMIN) || (bra == OP_BRAMINZERO && ket == OP_KETRMAX)));\ncc += GET(cc, 1);\n\nhas_alternatives = *cc == OP_ALT;\nif (SLJIT_UNLIKELY(opcode == OP_COND || opcode == OP_SCOND))\n  {\n  SLJIT_COMPILE_ASSERT(OP_DNRREF == OP_RREF + 1 && OP_FALSE == OP_RREF + 2 && OP_TRUE == OP_RREF + 3,\n    compile_time_checks_must_be_grouped_together);\n  has_alternatives = ((*matchingpath >= OP_RREF && *matchingpath <= OP_TRUE) || *matchingpath == OP_FAIL) ? FALSE : TRUE;\n  }\n\nif (SLJIT_UNLIKELY(opcode == OP_COND) && (*cc == OP_KETRMAX || *cc == OP_KETRMIN))\n  opcode = OP_SCOND;\n\nif (opcode == OP_CBRA || opcode == OP_SCBRA)\n  {\n  /* Capturing brackets has a pre-allocated space. */\n  offset = GET2(ccbegin, 1 + LINK_SIZE);\n  if (common->optimized_cbracket[offset] == 0)\n    {\n    private_data_ptr = OVECTOR_PRIV(offset);\n    offset <<= 1;\n    }\n  else\n    {\n    offset <<= 1;\n    private_data_ptr = OVECTOR(offset);\n    }\n  BACKTRACK_AS(bracket_backtrack)->private_data_ptr = private_data_ptr;\n  matchingpath += IMM2_SIZE;\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_ONCE || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  /* Other brackets simply allocate the next entry. */\n  private_data_ptr = PRIVATE_DATA(ccbegin);\n  SLJIT_ASSERT(private_data_ptr != 0);\n  BACKTRACK_AS(bracket_backtrack)->private_data_ptr = private_data_ptr;\n  if (opcode == OP_ONCE)\n    BACKTRACK_AS(bracket_backtrack)->u.framesize = get_framesize(common, ccbegin, NULL, FALSE, &needs_control_head);\n  }\n\n/* Instructions before the first alternative. */\nstacksize = 0;\nif (ket == OP_KETRMAX || (ket == OP_KETRMIN && bra != OP_BRAMINZERO))\n  stacksize++;\nif (bra == OP_BRAZERO)\n  stacksize++;\n\nif (stacksize > 0)\n  allocate_stack(common, stacksize);\n\nstacksize = 0;\nif (ket == OP_KETRMAX || (ket == OP_KETRMIN && bra != OP_BRAMINZERO))\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n  stacksize++;\n  }\n\nif (bra == OP_BRAZERO)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a backtrack path! (Since the try-path of OP_BRAMINZERO matches to the empty string) */\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  if (ket != OP_KETRMIN)\n    {\n    free_stack(common, 1);\n    braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    }\n  else if (opcode == OP_ONCE || opcode >= OP_SBRA)\n    {\n    jump = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    /* Nothing stored during the first run. */\n    skip = JUMP(SLJIT_JUMP);\n    JUMPHERE(jump);\n    /* Checking zero-length iteration. */\n    if (opcode != OP_ONCE || BACKTRACK_AS(bracket_backtrack)->u.framesize < 0)\n      {\n      /* When we come from outside, private_data_ptr contains the previous STR_PTR. */\n      braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      }\n    else\n      {\n      /* Except when the whole stack frame must be saved. */\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(TMP1), STACK(-BACKTRACK_AS(bracket_backtrack)->u.framesize - 2));\n      }\n    JUMPHERE(skip);\n    }\n  else\n    {\n    jump = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    JUMPHERE(jump);\n    }\n  }\n\nif (repeat_type != 0)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, repeat_count);\n  if (repeat_type == OP_EXACT)\n    rmax_label = LABEL();\n  }\n\nif (ket == OP_KETRMIN)\n  BACKTRACK_AS(bracket_backtrack)->recursive_matchingpath = LABEL();\n\nif (ket == OP_KETRMAX)\n  {\n  rmax_label = LABEL();\n  if (has_alternatives && opcode >= OP_BRA && opcode < OP_SBRA && repeat_type == 0)\n    BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = rmax_label;\n  }\n\n/* Handling capturing brackets and alternatives. */\nif (opcode == OP_ONCE)\n  {\n  stacksize = 0;\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    stacksize++;\n    }\n\n  if (BACKTRACK_AS(bracket_backtrack)->u.framesize < 0)\n    {\n    /* Neither capturing brackets nor recursions are found in the block. */\n    if (ket == OP_KETRMIN)\n      {\n      stacksize += 2;\n      if (!needs_control_head)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      }\n    else\n      {\n      if (BACKTRACK_AS(bracket_backtrack)->u.framesize == no_frame)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n      if (ket == OP_KETRMAX || has_alternatives)\n        stacksize++;\n      }\n\n    if (stacksize > 0)\n      allocate_stack(common, stacksize);\n\n    stacksize = 0;\n    if (needs_control_head)\n      {\n      stacksize++;\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n      }\n\n    if (ket == OP_KETRMIN)\n      {\n      if (needs_control_head)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      if (BACKTRACK_AS(bracket_backtrack)->u.framesize == no_frame)\n        OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0, SLJIT_IMM, needs_control_head ? (2 * sizeof(sljit_sw)) : sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize + 1), TMP2, 0);\n      }\n    else if (ket == OP_KETRMAX || has_alternatives)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n    }\n  else\n    {\n    if (ket != OP_KET || has_alternatives)\n      stacksize++;\n\n    stacksize += BACKTRACK_AS(bracket_backtrack)->u.framesize + 1;\n    allocate_stack(common, stacksize);\n\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    OP2(SLJIT_ADD, TMP2, 0, STACK_TOP, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n\n    stacksize = needs_control_head ? 1 : 0;\n    if (ket != OP_KET || has_alternatives)\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n      stacksize++;\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n      }\n    init_frame(common, ccbegin, NULL, BACKTRACK_AS(bracket_backtrack)->u.framesize + stacksize, stacksize + 1);\n    }\n  }\nelse if (opcode == OP_CBRA || opcode == OP_SCBRA)\n  {\n  /* Saving the previous values. */\n  if (common->optimized_cbracket[offset >> 1] != 0)\n    {\n    SLJIT_ASSERT(private_data_ptr == OVECTOR(offset));\n    allocate_stack(common, 2);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n    }\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  /* Saving the previous value. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n  }\nelse if (has_alternatives)\n  {\n  /* Pushing the starting string pointer. */\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  }\n\n/* Generating code for the first alternative. */\nif (opcode == OP_COND || opcode == OP_SCOND)\n  {\n  if (*matchingpath == OP_CREF)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    add_jump(compiler, &(BACKTRACK_AS(bracket_backtrack)->u.condfailed),\n      CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(matchingpath, 1) << 1), SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n    matchingpath += 1 + IMM2_SIZE;\n    }\n  else if (*matchingpath == OP_DNCREF)\n    {\n    SLJIT_ASSERT(has_alternatives);\n\n    i = GET2(matchingpath, 1 + IMM2_SIZE);\n    slot = common->name_table + GET2(matchingpath, 1) * common->name_entry_size;\n    OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(slot, 0) << 1), TMP1, 0);\n    slot += common->name_entry_size;\n    i--;\n    while (i-- > 0)\n      {\n      OP2(SLJIT_SUB, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(slot, 0) << 1), TMP1, 0);\n      OP2(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, TMP2, 0, STR_PTR, 0);\n      slot += common->name_entry_size;\n      }\n    OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n    add_jump(compiler, &(BACKTRACK_AS(bracket_backtrack)->u.condfailed), JUMP(SLJIT_ZERO));\n    matchingpath += 1 + 2 * IMM2_SIZE;\n    }\n  else if ((*matchingpath >= OP_RREF && *matchingpath <= OP_TRUE) || *matchingpath == OP_FAIL)\n    {\n    /* Never has other case. */\n    BACKTRACK_AS(bracket_backtrack)->u.condfailed = NULL;\n    SLJIT_ASSERT(!has_alternatives);\n\n    if (*matchingpath == OP_TRUE)\n      {\n      stacksize = 1;\n      matchingpath++;\n      }\n    else if (*matchingpath == OP_FALSE || *matchingpath == OP_FAIL)\n      stacksize = 0;\n    else if (*matchingpath == OP_RREF)\n      {\n      stacksize = GET2(matchingpath, 1);\n      if (common->currententry == NULL)\n        stacksize = 0;\n      else if (stacksize == RREF_ANY)\n        stacksize = 1;\n      else if (common->currententry->start == 0)\n        stacksize = stacksize == 0;\n      else\n        stacksize = stacksize == (int)GET2(common->start, common->currententry->start + 1 + LINK_SIZE);\n\n      if (stacksize != 0)\n        matchingpath += 1 + IMM2_SIZE;\n      }\n    else\n      {\n      if (common->currententry == NULL || common->currententry->start == 0)\n        stacksize = 0;\n      else\n        {\n        stacksize = GET2(matchingpath, 1 + IMM2_SIZE);\n        slot = common->name_table + GET2(matchingpath, 1) * common->name_entry_size;\n        i = (int)GET2(common->start, common->currententry->start + 1 + LINK_SIZE);\n        while (stacksize > 0)\n          {\n          if ((int)GET2(slot, 0) == i)\n            break;\n          slot += common->name_entry_size;\n          stacksize--;\n          }\n        }\n\n      if (stacksize != 0)\n        matchingpath += 1 + 2 * IMM2_SIZE;\n      }\n\n      /* The stacksize == 0 is a common \"else\" case. */\n      if (stacksize == 0)\n        {\n        if (*cc == OP_ALT)\n          {\n          matchingpath = cc + 1 + LINK_SIZE;\n          cc += GET(cc, 1);\n          }\n        else\n          matchingpath = cc;\n        }\n    }\n  else\n    {\n    SLJIT_ASSERT(has_alternatives && *matchingpath >= OP_ASSERT && *matchingpath <= OP_ASSERTBACK_NOT);\n    /* Similar code as PUSH_BACKTRACK macro. */\n    assert = sljit_alloc_memory(compiler, sizeof(assert_backtrack));\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n      return NULL;\n    memset(assert, 0, sizeof(assert_backtrack));\n    assert->common.cc = matchingpath;\n    BACKTRACK_AS(bracket_backtrack)->u.assert = assert;\n    matchingpath = compile_assert_matchingpath(common, matchingpath, assert, TRUE);\n    }\n  }\n\ncompile_matchingpath(common, matchingpath, cc, backtrack);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  return NULL;\n\nif (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA)\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\nif (opcode == OP_ONCE)\n  match_once_common(common, ket, BACKTRACK_AS(bracket_backtrack)->u.framesize, private_data_ptr, has_alternatives, needs_control_head);\n\nif (opcode == OP_SCRIPT_RUN)\n  match_script_run_common(common, private_data_ptr, backtrack);\n\nstacksize = 0;\nif (repeat_type == OP_MINUPTO)\n  {\n  /* We need to preserve the counter. TMP2 will be used below. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n  stacksize++;\n  }\nif (ket != OP_KET || bra != OP_BRA)\n  stacksize++;\nif (offset != 0)\n  {\n  if (common->capture_last_ptr != 0)\n    stacksize++;\n  if (common->optimized_cbracket[offset >> 1] == 0)\n    stacksize += 2;\n  }\nif (has_alternatives && opcode != OP_ONCE)\n  stacksize++;\n\nif (stacksize > 0)\n  allocate_stack(common, stacksize);\n\nstacksize = 0;\nif (repeat_type == OP_MINUPTO)\n  {\n  /* TMP2 was set above. */\n  OP2(SLJIT_SUB, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP2, 0, SLJIT_IMM, 1);\n  stacksize++;\n  }\n\nif (ket != OP_KET || bra != OP_BRA)\n  {\n  if (ket != OP_KET)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n  stacksize++;\n  }\n\nif (offset != 0)\n  stacksize = match_capture_common(common, stacksize, offset, private_data_ptr);\n\n/* Skip and count the other alternatives. */\ni = 1;\nwhile (*cc == OP_ALT)\n  {\n  cc += GET(cc, 1);\n  i++;\n  }\n\nif (has_alternatives)\n  {\n  if (opcode != OP_ONCE)\n    {\n    if (i <= 3)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n    else\n      BACKTRACK_AS(bracket_backtrack)->u.matching_put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(stacksize));\n    }\n  if (ket != OP_KETRMAX)\n    BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n  }\n\n/* Must be after the matchingpath label. */\nif (offset != 0 && common->optimized_cbracket[offset >> 1] != 0)\n  {\n  SLJIT_ASSERT(private_data_ptr == OVECTOR(offset + 0));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n  }\n\nif (ket == OP_KETRMAX)\n  {\n  if (repeat_type != 0)\n    {\n    if (has_alternatives)\n      BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, rmax_label);\n    /* Drop STR_PTR for greedy plus quantifier. */\n    if (opcode != OP_ONCE)\n      free_stack(common, 1);\n    }\n  else if (opcode < OP_BRA || opcode >= OP_SBRA)\n    {\n    if (has_alternatives)\n      BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n\n    /* Checking zero-length iteration. */\n    if (opcode != OP_ONCE)\n      {\n      /* This case includes opcodes such as OP_SCRIPT_RUN. */\n      CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0, rmax_label);\n      /* Drop STR_PTR for greedy plus quantifier. */\n      if (bra != OP_BRAZERO)\n        free_stack(common, 1);\n      }\n    else\n      /* TMP2 must contain the starting STR_PTR. */\n      CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, rmax_label);\n    }\n  else\n    JUMPTO(SLJIT_JUMP, rmax_label);\n  BACKTRACK_AS(bracket_backtrack)->recursive_matchingpath = LABEL();\n  }\n\nif (repeat_type == OP_EXACT)\n  {\n  count_match(common);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  JUMPTO(SLJIT_NOT_ZERO, rmax_label);\n  }\nelse if (repeat_type == OP_UPTO)\n  {\n  /* We need to preserve the counter. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n  }\n\nif (bra == OP_BRAZERO)\n  BACKTRACK_AS(bracket_backtrack)->zero_matchingpath = LABEL();\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a backtrack path! (From the viewpoint of OP_BRAMINZERO) */\n  JUMPTO(SLJIT_JUMP, ((braminzero_backtrack *)parent)->matchingpath);\n  if (braminzero != NULL)\n    {\n    JUMPHERE(braminzero);\n    /* We need to release the end pointer to perform the\n    backtrack for the zero-length iteration. When\n    framesize is < 0, OP_ONCE will do the release itself. */\n    if (opcode == OP_ONCE && BACKTRACK_AS(bracket_backtrack)->u.framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (BACKTRACK_AS(bracket_backtrack)->u.framesize - 1) * sizeof(sljit_sw));\n      }\n    else if (ket == OP_KETRMIN && opcode != OP_ONCE)\n      free_stack(common, 1);\n    }\n  /* Continue to the normal backtrack. */\n  }\n\nif ((ket != OP_KET && bra != OP_BRAMINZERO) || bra == OP_BRAZERO)\n  count_match(common);\n\ncc += 1 + LINK_SIZE;\n\nif (opcode == OP_ONCE)\n  {\n  /* We temporarily encode the needs_control_head in the lowest bit.\n     Note: on the target architectures of SLJIT the ((x << 1) >> 1) returns\n     the same value for small signed numbers (including negative numbers). */\n  BACKTRACK_AS(bracket_backtrack)->u.framesize = (int)((unsigned)BACKTRACK_AS(bracket_backtrack)->u.framesize << 1) | (needs_control_head ? 1 : 0);\n  }\nreturn cc + repeat_length;\n}\n\nstatic PCRE2_SPTR compile_bracketpos_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nint private_data_ptr;\nint cbraprivptr = 0;\nBOOL needs_control_head;\nint framesize;\nint stacksize;\nint offset = 0;\nBOOL zero = FALSE;\nPCRE2_SPTR ccbegin = NULL;\nint stack; /* Also contains the offset of control head. */\nstruct sljit_label *loop = NULL;\nstruct jump_list *emptymatch = NULL;\n\nPUSH_BACKTRACK(sizeof(bracketpos_backtrack), cc, NULL);\nif (*cc == OP_BRAPOSZERO)\n  {\n  zero = TRUE;\n  cc++;\n  }\n\nopcode = *cc;\nprivate_data_ptr = PRIVATE_DATA(cc);\nSLJIT_ASSERT(private_data_ptr != 0);\nBACKTRACK_AS(bracketpos_backtrack)->private_data_ptr = private_data_ptr;\nswitch(opcode)\n  {\n  case OP_BRAPOS:\n  case OP_SBRAPOS:\n  ccbegin = cc + 1 + LINK_SIZE;\n  break;\n\n  case OP_CBRAPOS:\n  case OP_SCBRAPOS:\n  offset = GET2(cc, 1 + LINK_SIZE);\n  /* This case cannot be optimized in the same was as\n  normal capturing brackets. */\n  SLJIT_ASSERT(common->optimized_cbracket[offset] == 0);\n  cbraprivptr = OVECTOR_PRIV(offset);\n  offset <<= 1;\n  ccbegin = cc + 1 + LINK_SIZE + IMM2_SIZE;\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nframesize = get_framesize(common, cc, NULL, FALSE, &needs_control_head);\nBACKTRACK_AS(bracketpos_backtrack)->framesize = framesize;\nif (framesize < 0)\n  {\n  if (offset != 0)\n    {\n    stacksize = 2;\n    if (common->capture_last_ptr != 0)\n      stacksize++;\n    }\n  else\n    stacksize = 1;\n\n  if (needs_control_head)\n    stacksize++;\n  if (!zero)\n    stacksize++;\n\n  BACKTRACK_AS(bracketpos_backtrack)->stacksize = stacksize;\n  allocate_stack(common, stacksize);\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n\n  stack = 0;\n  if (offset != 0)\n    {\n    stack = 2;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    if (needs_control_head)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    if (common->capture_last_ptr != 0)\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP1, 0);\n      stack = 3;\n      }\n    }\n  else\n    {\n    if (needs_control_head)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    stack = 1;\n    }\n\n  if (needs_control_head)\n    stack++;\n  if (!zero)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), SLJIT_IMM, 1);\n  if (needs_control_head)\n    {\n    stack--;\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP2, 0);\n    }\n  }\nelse\n  {\n  stacksize = framesize + 1;\n  if (!zero)\n    stacksize++;\n  if (needs_control_head)\n    stacksize++;\n  if (offset == 0)\n    stacksize++;\n  BACKTRACK_AS(bracketpos_backtrack)->stacksize = stacksize;\n\n  allocate_stack(common, stacksize);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n\n  stack = 0;\n  if (!zero)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 1);\n    stack = 1;\n    }\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP2, 0);\n    stack++;\n    }\n  if (offset == 0)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), STR_PTR, 0);\n    stack++;\n    }\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP1, 0);\n  init_frame(common, cc, NULL, stacksize - 1, stacksize - framesize);\n  stack -= 1 + (offset == 0);\n  }\n\nif (offset != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n\nloop = LABEL();\nwhile (*cc != OP_KETRPOS)\n  {\n  backtrack->top = NULL;\n  backtrack->topbacktracks = NULL;\n  cc += GET(cc, 1);\n\n  compile_matchingpath(common, ccbegin, cc, backtrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n\n  if (framesize < 0)\n    {\n    if (framesize == no_frame)\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\n    if (offset != 0)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n      if (common->capture_last_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n      }\n    else\n      {\n      if (opcode == OP_SBRAPOS)\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n\n    /* Even if the match is empty, we need to reset the control head. */\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(stack));\n\n    if (opcode == OP_SBRAPOS || opcode == OP_SCBRAPOS)\n      add_jump(compiler, &emptymatch, CMP(SLJIT_EQUAL, TMP1, 0, STR_PTR, 0));\n\n    if (!zero)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0);\n    }\n  else\n    {\n    if (offset != 0)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n      if (common->capture_last_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP2(SLJIT_SUB, STACK_TOP, 0, TMP2, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n      if (opcode == OP_SBRAPOS)\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), STACK(-framesize - 2));\n      OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), STACK(-framesize - 2), STR_PTR, 0);\n      }\n\n    /* Even if the match is empty, we need to reset the control head. */\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(stack));\n\n    if (opcode == OP_SBRAPOS || opcode == OP_SCBRAPOS)\n      add_jump(compiler, &emptymatch, CMP(SLJIT_EQUAL, TMP1, 0, STR_PTR, 0));\n\n    if (!zero)\n      {\n      if (framesize < 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    }\n\n  JUMPTO(SLJIT_JUMP, loop);\n  flush_stubs(common);\n\n  compile_backtrackingpath(common, backtrack->top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n  set_jumps(backtrack->topbacktracks, LABEL());\n\n  if (framesize < 0)\n    {\n    if (offset != 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n    else\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    }\n  else\n    {\n    if (offset != 0)\n      {\n      /* Last alternative. */\n      if (*cc == OP_KETRPOS)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(TMP2), STACK(-framesize - 2));\n      }\n    }\n\n  if (*cc == OP_KETRPOS)\n    break;\n  ccbegin = cc + 1 + LINK_SIZE;\n  }\n\n/* We don't have to restore the control head in case of a failed match. */\n\nbacktrack->topbacktracks = NULL;\nif (!zero)\n  {\n  if (framesize < 0)\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0));\n  else /* TMP2 is set to [private_data_ptr] above. */\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(TMP2), STACK(-stacksize), SLJIT_IMM, 0));\n  }\n\n/* None of them matched. */\nset_jumps(emptymatch, LABEL());\ncount_match(common);\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR get_iterator_parameters(compiler_common *common, PCRE2_SPTR cc, PCRE2_UCHAR *opcode, PCRE2_UCHAR *type, sljit_u32 *max, sljit_u32 *exact, PCRE2_SPTR *end)\n{\nint class_len;\n\n*opcode = *cc;\n*exact = 0;\n\nif (*opcode >= OP_STAR && *opcode <= OP_POSUPTO)\n  {\n  cc++;\n  *type = OP_CHAR;\n  }\nelse if (*opcode >= OP_STARI && *opcode <= OP_POSUPTOI)\n  {\n  cc++;\n  *type = OP_CHARI;\n  *opcode -= OP_STARI - OP_STAR;\n  }\nelse if (*opcode >= OP_NOTSTAR && *opcode <= OP_NOTPOSUPTO)\n  {\n  cc++;\n  *type = OP_NOT;\n  *opcode -= OP_NOTSTAR - OP_STAR;\n  }\nelse if (*opcode >= OP_NOTSTARI && *opcode <= OP_NOTPOSUPTOI)\n  {\n  cc++;\n  *type = OP_NOTI;\n  *opcode -= OP_NOTSTARI - OP_STAR;\n  }\nelse if (*opcode >= OP_TYPESTAR && *opcode <= OP_TYPEPOSUPTO)\n  {\n  cc++;\n  *opcode -= OP_TYPESTAR - OP_STAR;\n  *type = OP_END;\n  }\nelse\n  {\n  SLJIT_ASSERT(*opcode == OP_CLASS || *opcode == OP_NCLASS || *opcode == OP_XCLASS);\n  *type = *opcode;\n  cc++;\n  class_len = (*type < OP_XCLASS) ? (int)(1 + (32 / sizeof(PCRE2_UCHAR))) : GET(cc, 0);\n  *opcode = cc[class_len - 1];\n\n  if (*opcode >= OP_CRSTAR && *opcode <= OP_CRMINQUERY)\n    {\n    *opcode -= OP_CRSTAR - OP_STAR;\n    *end = cc + class_len;\n\n    if (*opcode == OP_PLUS || *opcode == OP_MINPLUS)\n      {\n      *exact = 1;\n      *opcode -= OP_PLUS - OP_STAR;\n      }\n    }\n  else if (*opcode >= OP_CRPOSSTAR && *opcode <= OP_CRPOSQUERY)\n    {\n    *opcode -= OP_CRPOSSTAR - OP_POSSTAR;\n    *end = cc + class_len;\n\n    if (*opcode == OP_POSPLUS)\n      {\n      *exact = 1;\n      *opcode = OP_POSSTAR;\n      }\n    }\n  else\n    {\n    SLJIT_ASSERT(*opcode == OP_CRRANGE || *opcode == OP_CRMINRANGE || *opcode == OP_CRPOSRANGE);\n    *max = GET2(cc, (class_len + IMM2_SIZE));\n    *exact = GET2(cc, class_len);\n\n    if (*max == 0)\n      {\n      if (*opcode == OP_CRPOSRANGE)\n        *opcode = OP_POSSTAR;\n      else\n        *opcode -= OP_CRRANGE - OP_STAR;\n      }\n    else\n      {\n      *max -= *exact;\n      if (*max == 0)\n        *opcode = OP_EXACT;\n      else if (*max == 1)\n        {\n        if (*opcode == OP_CRPOSRANGE)\n          *opcode = OP_POSQUERY;\n        else\n          *opcode -= OP_CRRANGE - OP_QUERY;\n        }\n      else\n        {\n        if (*opcode == OP_CRPOSRANGE)\n          *opcode = OP_POSUPTO;\n        else\n          *opcode -= OP_CRRANGE - OP_UPTO;\n        }\n      }\n    *end = cc + class_len + 2 * IMM2_SIZE;\n    }\n  return cc;\n  }\n\nswitch(*opcode)\n  {\n  case OP_EXACT:\n  *exact = GET2(cc, 0);\n  cc += IMM2_SIZE;\n  break;\n\n  case OP_PLUS:\n  case OP_MINPLUS:\n  *exact = 1;\n  *opcode -= OP_PLUS - OP_STAR;\n  break;\n\n  case OP_POSPLUS:\n  *exact = 1;\n  *opcode = OP_POSSTAR;\n  break;\n\n  case OP_UPTO:\n  case OP_MINUPTO:\n  case OP_POSUPTO:\n  *max = GET2(cc, 0);\n  cc += IMM2_SIZE;\n  break;\n  }\n\nif (*type == OP_END)\n  {\n  *type = *cc;\n  *end = next_opcode(common, cc);\n  cc++;\n  return cc;\n  }\n\n*end = cc + 1;\n#ifdef SUPPORT_UNICODE\nif (common->utf && HAS_EXTRALEN(*cc)) *end += GET_EXTRALEN(*cc);\n#endif\nreturn cc;\n}\n\nstatic PCRE2_SPTR compile_iterator_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR type;\nsljit_u32 max = 0, exact;\nsljit_s32 early_fail_ptr = PRIVATE_DATA(cc + 1);\nsljit_s32 early_fail_type;\nBOOL charpos_enabled;\nPCRE2_UCHAR charpos_char;\nunsigned int charpos_othercasebit;\nPCRE2_SPTR end;\njump_list *no_match = NULL;\njump_list *no_char1_match = NULL;\nstruct sljit_jump *jump = NULL;\nstruct sljit_label *label;\nint private_data_ptr = PRIVATE_DATA(cc);\nint base = (private_data_ptr == 0) ? SLJIT_MEM1(STACK_TOP) : SLJIT_MEM1(SLJIT_SP);\nint offset0 = (private_data_ptr == 0) ? STACK(0) : private_data_ptr;\nint offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + (int)sizeof(sljit_sw);\nint tmp_base, tmp_offset;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nBOOL use_tmp;\n#endif\n\nPUSH_BACKTRACK(sizeof(char_iterator_backtrack), cc, NULL);\n\nearly_fail_type = (early_fail_ptr & 0x7);\nearly_fail_ptr >>= 3;\n\n/* During recursion, these optimizations are disabled. */\nif (common->early_fail_start_ptr == 0 && common->fast_forward_bc_ptr == NULL)\n  {\n  early_fail_ptr = 0;\n  early_fail_type = type_skip;\n  }\n\nSLJIT_ASSERT(common->fast_forward_bc_ptr != NULL || early_fail_ptr == 0\n  || (early_fail_ptr >= common->early_fail_start_ptr && early_fail_ptr <= common->early_fail_end_ptr));\n\nif (early_fail_type == type_fail)\n  add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr));\n\ncc = get_iterator_parameters(common, cc, &opcode, &type, &max, &exact, &end);\n\nif (type != OP_EXTUNI)\n  {\n  tmp_base = TMP3;\n  tmp_offset = 0;\n  }\nelse\n  {\n  tmp_base = SLJIT_MEM1(SLJIT_SP);\n  tmp_offset = POSSESSIVE0;\n  }\n\n/* Handle fixed part first. */\nif (exact > 1)\n  {\n  SLJIT_ASSERT(early_fail_ptr == 0);\n\n  if (common->mode == PCRE2_JIT_COMPLETE\n#ifdef SUPPORT_UNICODE\n      && !common->utf\n#endif\n      && type != OP_ANYNL && type != OP_EXTUNI)\n    {\n    OP2(SLJIT_ADD, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(exact));\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_GREATER, TMP1, 0, STR_END, 0));\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, exact);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, FALSE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, exact);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, TRUE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  }\nelse if (exact == 1)\n  {\n  compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, TRUE);\n\n  if (early_fail_type == type_fail_range)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + (int)sizeof(sljit_sw));\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP2(SLJIT_SUB, TMP2, 0, STR_PTR, 0, TMP2, 0);\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_LESS_EQUAL, TMP2, 0, TMP1, 0));\n\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + (int)sizeof(sljit_sw), STR_PTR, 0);\n    }\n  }\n\nswitch(opcode)\n  {\n  case OP_STAR:\n  case OP_UPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0 || opcode == OP_STAR);\n\n  if (type == OP_ANYNL || type == OP_EXTUNI)\n    {\n    SLJIT_ASSERT(private_data_ptr == 0);\n    SLJIT_ASSERT(early_fail_ptr == 0);\n\n    allocate_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, SLJIT_IMM, max);\n\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &BACKTRACK_AS(char_iterator_backtrack)->u.backtracks, TRUE);\n    if (opcode == OP_UPTO)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n      jump = JUMP(SLJIT_ZERO);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, TMP1, 0);\n      }\n\n    /* We cannot use TMP3 because of allocate_stack. */\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    JUMPTO(SLJIT_JUMP, label);\n    if (jump != NULL)\n      JUMPHERE(jump);\n    BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n    break;\n    }\n#ifdef SUPPORT_UNICODE\n  else if (type == OP_ALLANY && !common->invalid_utf)\n#else\n  else if (type == OP_ALLANY)\n#endif\n    {\n    if (opcode == OP_STAR)\n      {\n      if (private_data_ptr == 0)\n        allocate_stack(common, 2);\n\n      OP1(SLJIT_MOV, base, offset0, STR_END, 0);\n      OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n\n      OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n      process_partial_match(common);\n\n      if (early_fail_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_END, 0);\n      BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n      break;\n      }\n#ifdef SUPPORT_UNICODE\n    else if (!common->utf)\n#else\n    else\n#endif\n      {\n      if (private_data_ptr == 0)\n        allocate_stack(common, 2);\n\n      OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(max));\n\n      if (common->mode == PCRE2_JIT_COMPLETE)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_PTR, 0, STR_END, 0);\n        CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n        }\n      else\n        {\n        jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, STR_END, 0);\n        process_partial_match(common);\n        JUMPHERE(jump);\n        }\n\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n\n      if (early_fail_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n      BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n      break;\n      }\n    }\n\n  charpos_enabled = FALSE;\n  charpos_char = 0;\n  charpos_othercasebit = 0;\n\n  if ((type != OP_CHAR && type != OP_CHARI) && (*end == OP_CHAR || *end == OP_CHARI))\n    {\n#ifdef SUPPORT_UNICODE\n    charpos_enabled = !common->utf || !HAS_EXTRALEN(end[1]);\n#else\n    charpos_enabled = TRUE;\n#endif\n    if (charpos_enabled && *end == OP_CHARI && char_has_othercase(common, end + 1))\n      {\n      charpos_othercasebit = char_get_othercase_bit(common, end + 1);\n      if (charpos_othercasebit == 0)\n        charpos_enabled = FALSE;\n      }\n\n    if (charpos_enabled)\n      {\n      charpos_char = end[1];\n      /* Consume the OP_CHAR opcode. */\n      end += 2;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      SLJIT_ASSERT((charpos_othercasebit >> 8) == 0);\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n      SLJIT_ASSERT((charpos_othercasebit >> 9) == 0);\n      if ((charpos_othercasebit & 0x100) != 0)\n        charpos_othercasebit = (charpos_othercasebit & 0xff) << 8;\n#endif\n      if (charpos_othercasebit != 0)\n        charpos_char |= charpos_othercasebit;\n\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.enabled = TRUE;\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.chr = charpos_char;\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.othercasebit = charpos_othercasebit;\n      }\n    }\n\n  if (charpos_enabled)\n    {\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max + 1);\n\n    /* Search the first instance of charpos_char. */\n    jump = JUMP(SLJIT_JUMP);\n    label = LABEL();\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_ZERO));\n      }\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, FALSE);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    JUMPHERE(jump);\n\n    detect_partial_match(common, &backtrack->topbacktracks);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (charpos_othercasebit != 0)\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, charpos_othercasebit);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char, label);\n\n    if (private_data_ptr == 0)\n      allocate_stack(common, 2);\n    OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n    OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n      }\n\n    /* Search the last instance of charpos_char. */\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    detect_partial_match(common, &no_match);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (charpos_othercasebit != 0)\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, charpos_othercasebit);\n\n    if (opcode == OP_STAR)\n      {\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char, label);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, label);\n      }\n    else\n      {\n      jump = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPHERE(jump);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      JUMPTO(SLJIT_NOT_ZERO, label);\n      }\n\n    set_jumps(no_match, LABEL());\n    OP2(SLJIT_ADD, STR_PTR, 0, base, offset0, SLJIT_IMM, IN_UCHARS(1));\n    OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n    }\n  else\n    {\n    if (private_data_ptr == 0)\n      allocate_stack(common, 2);\n\n    OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    use_tmp = (!HAS_VIRTUAL_REGISTERS && opcode == OP_STAR);\n    SLJIT_ASSERT(!use_tmp || tmp_base == TMP3);\n\n    if (common->utf)\n      OP1(SLJIT_MOV, use_tmp ? TMP3 : base, use_tmp ? 0 : offset0, STR_PTR, 0);\n#endif\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf)\n      OP1(SLJIT_MOV, use_tmp ? TMP3 : base, use_tmp ? 0 : offset0, STR_PTR, 0);\n#endif\n\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n      }\n\n    detect_partial_match_to(common, label);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n    set_jumps(no_char1_match, LABEL());\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf)\n      {\n      set_jumps(no_match, LABEL());\n      if (use_tmp)\n        {\n        OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n        OP1(SLJIT_MOV, base, offset0, TMP3, 0);\n        }\n      else\n        OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      }\n    else\n#endif\n      {\n      OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      set_jumps(no_match, LABEL());\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      }\n\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    }\n\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_MINSTAR:\n  if (private_data_ptr == 0)\n    allocate_stack(common, 1);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  if (early_fail_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n  break;\n\n  case OP_MINUPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  if (private_data_ptr == 0)\n    allocate_stack(common, 2);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  OP1(SLJIT_MOV, base, offset1, SLJIT_IMM, max + 1);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_QUERY:\n  case OP_MINQUERY:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  if (private_data_ptr == 0)\n    allocate_stack(common, 1);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  if (opcode == OP_QUERY)\n    compile_char1_matchingpath(common, type, cc, &BACKTRACK_AS(char_iterator_backtrack)->u.backtracks, TRUE);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_EXACT:\n  break;\n\n  case OP_POSSTAR:\n#if defined SUPPORT_UNICODE\n  if (type == OP_ALLANY && !common->invalid_utf)\n#else\n  if (type == OP_ALLANY)\n#endif\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n    process_partial_match(common);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_END, 0);\n    break;\n    }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n    detect_partial_match_to(common, label);\n\n    set_jumps(no_match, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, tmp_base, tmp_offset);\n    if (early_fail_ptr != 0)\n      {\n      if (!HAS_VIRTUAL_REGISTERS && tmp_base == TMP3)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, TMP3, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n      }\n    break;\n    }\n#endif\n\n  detect_partial_match(common, &no_match);\n  label = LABEL();\n  compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n  detect_partial_match_to(common, label);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  set_jumps(no_char1_match, LABEL());\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  set_jumps(no_match, LABEL());\n  if (early_fail_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n  break;\n\n  case OP_POSUPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, STR_PTR, 0);\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, STR_PTR, 0);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n    detect_partial_match_to(common, label);\n\n    set_jumps(no_match, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1);\n    break;\n    }\n#endif\n\n  if (type == OP_ALLANY)\n    {\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(max));\n\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_PTR, 0, STR_END, 0);\n      CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, STR_END, 0);\n      process_partial_match(common);\n      JUMPHERE(jump);\n      }\n    break;\n    }\n\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n  detect_partial_match(common, &no_match);\n  label = LABEL();\n  compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n  add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n  detect_partial_match_to(common, label);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  set_jumps(no_char1_match, LABEL());\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  set_jumps(no_match, LABEL());\n  break;\n\n  case OP_POSQUERY:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n  compile_char1_matchingpath(common, type, cc, &no_match, TRUE);\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n  set_jumps(no_match, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, tmp_base, tmp_offset);\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\ncount_match(common);\nreturn end;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_fail_accept_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\nif (*cc == OP_FAIL)\n  {\n  add_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_JUMP));\n  return cc + 1;\n  }\n\nif (*cc == OP_ACCEPT && common->currententry == NULL && (common->re->overall_options & PCRE2_ENDANCHORED) != 0)\n  add_jump(compiler, &common->reset_match, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0));\n\nif (*cc == OP_ASSERT_ACCEPT || common->currententry != NULL || !common->might_be_empty)\n  {\n  /* No need to check notempty conditions. */\n  if (common->accept_label == NULL)\n    add_jump(compiler, &common->accept, JUMP(SLJIT_JUMP));\n  else\n    JUMPTO(SLJIT_JUMP, common->accept_label);\n  return cc + 1;\n  }\n\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0)));\nelse\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), common->accept_label);\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options));\n  }\nelse\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options));\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_NOT_ZERO));\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY_ATSTART);\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, JUMP(SLJIT_ZERO));\nelse\n  JUMPTO(SLJIT_ZERO, common->accept_label);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0));\nelse\n  CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, common->accept_label);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_JUMP));\nreturn cc + 1;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_close_matchingpath(compiler_common *common, PCRE2_SPTR cc)\n{\nDEFINE_COMPILER;\nint offset = GET2(cc, 1);\nBOOL optimized_cbracket = common->optimized_cbracket[offset] != 0;\n\n/* Data will be discarded anyway... */\nif (common->currententry != NULL)\n  return cc + 1 + IMM2_SIZE;\n\nif (!optimized_cbracket)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR_PRIV(offset));\noffset <<= 1;\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\nif (!optimized_cbracket)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\nreturn cc + 1 + IMM2_SIZE;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_control_verb_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode = *cc;\nPCRE2_SPTR ccend = cc + 1;\n\nif (opcode == OP_COMMIT_ARG || opcode == OP_PRUNE_ARG ||\n    opcode == OP_SKIP_ARG || opcode == OP_THEN_ARG)\n  ccend += 2 + cc[1];\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\nif (opcode == OP_SKIP)\n  {\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  return ccend;\n  }\n\nif (opcode == OP_COMMIT_ARG || opcode == OP_PRUNE_ARG || opcode == OP_THEN_ARG)\n  {\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)(cc + 2));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP2, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), TMP2, 0);\n  }\n\nreturn ccend;\n}\n\nstatic PCRE2_UCHAR then_trap_opcode[1] = { OP_THEN_TRAP };\n\nstatic SLJIT_INLINE void compile_then_trap_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nBOOL needs_control_head;\nint size;\n\nPUSH_BACKTRACK_NOVALUE(sizeof(then_trap_backtrack), cc);\ncommon->then_trap = BACKTRACK_AS(then_trap_backtrack);\nBACKTRACK_AS(then_trap_backtrack)->common.cc = then_trap_opcode;\nBACKTRACK_AS(then_trap_backtrack)->start = (sljit_sw)(cc - common->start);\nBACKTRACK_AS(then_trap_backtrack)->framesize = get_framesize(common, cc, ccend, FALSE, &needs_control_head);\n\nsize = BACKTRACK_AS(then_trap_backtrack)->framesize;\nsize = 3 + (size < 0 ? 0 : size);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\nallocate_stack(common, size);\nif (size > 3)\n  OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0, SLJIT_IMM, (size - 3) * sizeof(sljit_sw));\nelse\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 1), SLJIT_IMM, BACKTRACK_AS(then_trap_backtrack)->start);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 2), SLJIT_IMM, type_then_trap);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 3), TMP2, 0);\n\nsize = BACKTRACK_AS(then_trap_backtrack)->framesize;\nif (size >= 0)\n  init_frame(common, cc, ccend, size - 1, 0);\n}\n\nstatic void compile_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nBOOL has_then_trap = FALSE;\nthen_trap_backtrack *save_then_trap = NULL;\n\nSLJIT_ASSERT(*ccend == OP_END || (*ccend >= OP_ALT && *ccend <= OP_KETRPOS));\n\nif (common->has_then && common->then_offsets[cc - common->start] != 0)\n  {\n  SLJIT_ASSERT(*ccend != OP_END && common->control_head_ptr != 0);\n  has_then_trap = TRUE;\n  save_then_trap = common->then_trap;\n  /* Tail item on backtrack. */\n  compile_then_trap_matchingpath(common, cc, ccend, parent);\n  }\n\nwhile (cc < ccend)\n  {\n  switch(*cc)\n    {\n    case OP_SOD:\n    case OP_SOM:\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_REVERSE:\n    cc = compile_simple_assertion_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n    break;\n\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n    case OP_ANYBYTE:\n    case OP_NOTPROP:\n    case OP_PROP:\n    case OP_ANYNL:\n    case OP_NOT_HSPACE:\n    case OP_HSPACE:\n    case OP_NOT_VSPACE:\n    case OP_VSPACE:\n    case OP_EXTUNI:\n    case OP_NOT:\n    case OP_NOTI:\n    cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n    case OP_SET_SOM:\n    PUSH_BACKTRACK_NOVALUE(sizeof(backtrack_common), cc);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n    cc++;\n    break;\n\n    case OP_CHAR:\n    case OP_CHARI:\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      cc = compile_charn_matchingpath(common, cc, ccend, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n    cc = compile_iterator_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    if (cc[1 + (32 / sizeof(PCRE2_UCHAR))] >= OP_CRSTAR && cc[1 + (32 / sizeof(PCRE2_UCHAR))] <= OP_CRPOSRANGE)\n      cc = compile_iterator_matchingpath(common, cc, parent);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n    case OP_XCLASS:\n    if (*(cc + GET(cc, 1)) >= OP_CRSTAR && *(cc + GET(cc, 1)) <= OP_CRPOSRANGE)\n      cc = compile_iterator_matchingpath(common, cc, parent);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n#endif\n\n    case OP_REF:\n    case OP_REFI:\n    if (cc[1 + IMM2_SIZE] >= OP_CRSTAR && cc[1 + IMM2_SIZE] <= OP_CRPOSRANGE)\n      cc = compile_ref_iterator_matchingpath(common, cc, parent);\n    else\n      {\n      compile_ref_matchingpath(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE, FALSE);\n      cc += 1 + IMM2_SIZE;\n      }\n    break;\n\n    case OP_DNREF:\n    case OP_DNREFI:\n    if (cc[1 + 2 * IMM2_SIZE] >= OP_CRSTAR && cc[1 + 2 * IMM2_SIZE] <= OP_CRPOSRANGE)\n      cc = compile_ref_iterator_matchingpath(common, cc, parent);\n    else\n      {\n      compile_dnref_search(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n      compile_ref_matchingpath(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE, FALSE);\n      cc += 1 + 2 * IMM2_SIZE;\n      }\n    break;\n\n    case OP_RECURSE:\n    cc = compile_recurse_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    cc = compile_callout_matchingpath(common, cc, parent);\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    PUSH_BACKTRACK_NOVALUE(sizeof(assert_backtrack), cc);\n    cc = compile_assert_matchingpath(common, cc, BACKTRACK_AS(assert_backtrack), FALSE);\n    break;\n\n    case OP_BRAMINZERO:\n    PUSH_BACKTRACK_NOVALUE(sizeof(braminzero_backtrack), cc);\n    cc = bracketend(cc + 1);\n    if (*(cc - 1 - LINK_SIZE) != OP_KETRMIN)\n      {\n      allocate_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n    else\n      {\n      allocate_stack(common, 2);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), STR_PTR, 0);\n      }\n    BACKTRACK_AS(braminzero_backtrack)->matchingpath = LABEL();\n    count_match(common);\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRA:\n    case OP_CBRA:\n    case OP_COND:\n    case OP_SBRA:\n    case OP_SCBRA:\n    case OP_SCOND:\n    cc = compile_bracket_matchingpath(common, cc, parent);\n    break;\n\n    case OP_BRAZERO:\n    if (cc[1] > OP_ASSERTBACK_NOT)\n      cc = compile_bracket_matchingpath(common, cc, parent);\n    else\n      {\n      PUSH_BACKTRACK_NOVALUE(sizeof(assert_backtrack), cc);\n      cc = compile_assert_matchingpath(common, cc, BACKTRACK_AS(assert_backtrack), FALSE);\n      }\n    break;\n\n    case OP_BRAPOS:\n    case OP_CBRAPOS:\n    case OP_SBRAPOS:\n    case OP_SCBRAPOS:\n    case OP_BRAPOSZERO:\n    cc = compile_bracketpos_matchingpath(common, cc, parent);\n    break;\n\n    case OP_MARK:\n    PUSH_BACKTRACK_NOVALUE(sizeof(backtrack_common), cc);\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n    allocate_stack(common, common->has_skip_arg ? 5 : 1);\n    if (HAS_VIRTUAL_REGISTERS)\n      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(common->has_skip_arg ? 4 : 0), TMP2, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)(cc + 2));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), TMP2, 0);\n    if (common->has_skip_arg)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, type_mark);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), SLJIT_IMM, (sljit_sw)(cc + 2));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(3), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_PRUNE_ARG:\n    case OP_SKIP:\n    case OP_SKIP_ARG:\n    case OP_THEN:\n    case OP_THEN_ARG:\n    case OP_COMMIT:\n    case OP_COMMIT_ARG:\n    cc = compile_control_verb_matchingpath(common, cc, parent);\n    break;\n\n    case OP_FAIL:\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    cc = compile_fail_accept_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CLOSE:\n    cc = compile_close_matchingpath(common, cc);\n    break;\n\n    case OP_SKIPZERO:\n    cc = bracketend(cc + 1);\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    return;\n    }\n  if (cc == NULL)\n    return;\n  }\n\nif (has_then_trap)\n  {\n  /* Head item on backtrack. */\n  PUSH_BACKTRACK_NOVALUE(sizeof(then_trap_backtrack), cc);\n  BACKTRACK_AS(then_trap_backtrack)->common.cc = then_trap_opcode;\n  BACKTRACK_AS(then_trap_backtrack)->then_trap = common->then_trap;\n  common->then_trap = save_then_trap;\n  }\nSLJIT_ASSERT(cc == ccend);\n}\n\n#undef PUSH_BACKTRACK\n#undef PUSH_BACKTRACK_NOVALUE\n#undef BACKTRACK_AS\n\n#define COMPILE_BACKTRACKINGPATH(current) \\\n  do \\\n    { \\\n    compile_backtrackingpath(common, (current)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return; \\\n    } \\\n  while (0)\n\n#define CURRENT_AS(type) ((type *)current)\n\nstatic void compile_iterator_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR type;\nsljit_u32 max = 0, exact;\nstruct sljit_label *label = NULL;\nstruct sljit_jump *jump = NULL;\njump_list *jumplist = NULL;\nPCRE2_SPTR end;\nint private_data_ptr = PRIVATE_DATA(cc);\nint base = (private_data_ptr == 0) ? SLJIT_MEM1(STACK_TOP) : SLJIT_MEM1(SLJIT_SP);\nint offset0 = (private_data_ptr == 0) ? STACK(0) : private_data_ptr;\nint offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + (int)sizeof(sljit_sw);\n\ncc = get_iterator_parameters(common, cc, &opcode, &type, &max, &exact, &end);\n\nswitch(opcode)\n  {\n  case OP_STAR:\n  case OP_UPTO:\n  if (type == OP_ANYNL || type == OP_EXTUNI)\n    {\n    SLJIT_ASSERT(private_data_ptr == 0);\n    set_jumps(CURRENT_AS(char_iterator_backtrack)->u.backtracks, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n    }\n  else\n    {\n    if (CURRENT_AS(char_iterator_backtrack)->u.charpos.enabled)\n      {\n      OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      OP1(SLJIT_MOV, TMP2, 0, base, offset1);\n      OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n      label = LABEL();\n      OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      if (CURRENT_AS(char_iterator_backtrack)->u.charpos.othercasebit != 0)\n        OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, CURRENT_AS(char_iterator_backtrack)->u.charpos.othercasebit);\n      CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CURRENT_AS(char_iterator_backtrack)->u.charpos.chr, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n      move_back(common, NULL, TRUE);\n      CMPTO(SLJIT_GREATER, STR_PTR, 0, TMP2, 0, label);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, base, offset1);\n      move_back(common, NULL, TRUE);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n      }\n    JUMPHERE(jump);\n    if (private_data_ptr == 0)\n      free_stack(common, 2);\n    }\n  break;\n\n  case OP_MINSTAR:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  set_jumps(jumplist, LABEL());\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_MINUPTO:\n  OP1(SLJIT_MOV, TMP1, 0, base, offset1);\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n  add_jump(compiler, &jumplist, JUMP(SLJIT_ZERO));\n\n  OP1(SLJIT_MOV, base, offset1, TMP1, 0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n\n  set_jumps(jumplist, LABEL());\n  if (private_data_ptr == 0)\n    free_stack(common, 2);\n  break;\n\n  case OP_QUERY:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(CURRENT_AS(char_iterator_backtrack)->u.backtracks, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  JUMPHERE(jump);\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_MINQUERY:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  jump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  set_jumps(jumplist, LABEL());\n  JUMPHERE(jump);\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_EXACT:\n  case OP_POSSTAR:\n  case OP_POSQUERY:\n  case OP_POSUPTO:\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nset_jumps(current->topbacktracks, LABEL());\n}\n\nstatic SLJIT_INLINE void compile_ref_iterator_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nPCRE2_UCHAR type;\n\ntype = cc[ref ? 1 + IMM2_SIZE : 1 + 2 * IMM2_SIZE];\n\nif ((type & 0x1) == 0)\n  {\n  /* Maximize case. */\n  set_jumps(current->topbacktracks, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(ref_iterator_backtrack)->matchingpath);\n  return;\n  }\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nCMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(ref_iterator_backtrack)->matchingpath);\nset_jumps(current->topbacktracks, LABEL());\nfree_stack(common, ref ? 2 : 3);\n}\n\nstatic SLJIT_INLINE void compile_recurse_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nrecurse_entry *entry;\n\nif (!CURRENT_AS(recurse_backtrack)->inlined_pattern)\n  {\n  entry = CURRENT_AS(recurse_backtrack)->entry;\n  if (entry->backtrack_label == NULL)\n    add_jump(compiler, &entry->backtrack_calls, JUMP(SLJIT_FAST_CALL));\n  else\n    JUMPTO(SLJIT_FAST_CALL, entry->backtrack_label);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, CURRENT_AS(recurse_backtrack)->matchingpath);\n  }\nelse\n  compile_backtrackingpath(common, current->top);\n\nset_jumps(current->topbacktracks, LABEL());\n}\n\nstatic void compile_assert_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nPCRE2_UCHAR bra = OP_BRA;\nstruct sljit_jump *brajump = NULL;\n\nSLJIT_ASSERT(*cc != OP_BRAMINZERO);\nif (*cc == OP_BRAZERO)\n  {\n  bra = *cc;\n  cc++;\n  }\n\nif (bra == OP_BRAZERO)\n  {\n  SLJIT_ASSERT(current->topbacktracks == NULL);\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  }\n\nif (CURRENT_AS(assert_backtrack)->framesize < 0)\n  {\n  set_jumps(current->topbacktracks, LABEL());\n\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(assert_backtrack)->matchingpath);\n    free_stack(common, 1);\n    }\n  return;\n  }\n\nif (bra == OP_BRAZERO)\n  {\n  if (*cc == OP_ASSERT_NOT || *cc == OP_ASSERTBACK_NOT)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(assert_backtrack)->matchingpath);\n    free_stack(common, 1);\n    return;\n    }\n  free_stack(common, 1);\n  brajump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  }\n\nif (*cc == OP_ASSERT || *cc == OP_ASSERTBACK)\n  {\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(assert_backtrack)->private_data_ptr);\n  add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n  OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(assert_backtrack)->framesize - 1) * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(assert_backtrack)->private_data_ptr, TMP1, 0);\n\n  set_jumps(current->topbacktracks, LABEL());\n  }\nelse\n  set_jumps(current->topbacktracks, LABEL());\n\nif (bra == OP_BRAZERO)\n  {\n  /* We know there is enough place on the stack. */\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(assert_backtrack)->matchingpath);\n  JUMPHERE(brajump);\n  }\n}\n\nstatic void compile_bracket_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nint opcode, stacksize, alt_count, alt_max;\nint offset = 0;\nint private_data_ptr = CURRENT_AS(bracket_backtrack)->private_data_ptr;\nint repeat_ptr = 0, repeat_type = 0, repeat_count = 0;\nPCRE2_SPTR cc = current->cc;\nPCRE2_SPTR ccbegin;\nPCRE2_SPTR ccprev;\nPCRE2_UCHAR bra = OP_BRA;\nPCRE2_UCHAR ket;\nassert_backtrack *assert;\nBOOL has_alternatives;\nBOOL needs_control_head = FALSE;\nstruct sljit_jump *brazero = NULL;\nstruct sljit_jump *next_alt = NULL;\nstruct sljit_jump *once = NULL;\nstruct sljit_jump *cond = NULL;\nstruct sljit_label *rmin_label = NULL;\nstruct sljit_label *exact_label = NULL;\nstruct sljit_put_label *put_label = NULL;\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  bra = *cc;\n  cc++;\n  }\n\nopcode = *cc;\nccbegin = bracketend(cc) - 1 - LINK_SIZE;\nket = *ccbegin;\nif (ket == OP_KET && PRIVATE_DATA(ccbegin) != 0)\n  {\n  repeat_ptr = PRIVATE_DATA(ccbegin);\n  repeat_type = PRIVATE_DATA(ccbegin + 2);\n  repeat_count = PRIVATE_DATA(ccbegin + 3);\n  SLJIT_ASSERT(repeat_type != 0 && repeat_count != 0);\n  if (repeat_type == OP_UPTO)\n    ket = OP_KETRMAX;\n  if (repeat_type == OP_MINUPTO)\n    ket = OP_KETRMIN;\n  }\nccbegin = cc;\ncc += GET(cc, 1);\nhas_alternatives = *cc == OP_ALT;\nif (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  has_alternatives = (ccbegin[1 + LINK_SIZE] >= OP_ASSERT && ccbegin[1 + LINK_SIZE] <= OP_ASSERTBACK_NOT) || CURRENT_AS(bracket_backtrack)->u.condfailed != NULL;\nif (opcode == OP_CBRA || opcode == OP_SCBRA)\n  offset = (GET2(ccbegin, 1 + LINK_SIZE)) << 1;\nif (SLJIT_UNLIKELY(opcode == OP_COND) && (*cc == OP_KETRMAX || *cc == OP_KETRMIN))\n  opcode = OP_SCOND;\n\nalt_max = has_alternatives ? no_alternatives(ccbegin) : 0;\n\n/* Decoding the needs_control_head in framesize. */\nif (opcode == OP_ONCE)\n  {\n  needs_control_head = (CURRENT_AS(bracket_backtrack)->u.framesize & 0x1) != 0;\n  CURRENT_AS(bracket_backtrack)->u.framesize >>= 1;\n  }\n\nif (ket != OP_KET && repeat_type != 0)\n  {\n  /* TMP1 is used in OP_KETRMIN below. */\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  if (repeat_type == OP_UPTO)\n    OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0, SLJIT_IMM, 1);\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0);\n  }\n\nif (ket == OP_KETRMAX)\n  {\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    brazero = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n    }\n  }\nelse if (ket == OP_KETRMIN)\n  {\n  if (bra != OP_BRAMINZERO)\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    if (repeat_type != 0)\n      {\n      /* TMP1 was set a few lines above. */\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n      /* Drop STR_PTR for non-greedy plus quantifier. */\n      if (opcode != OP_ONCE)\n        free_stack(common, 1);\n      }\n    else if (opcode >= OP_SBRA || opcode == OP_ONCE)\n      {\n      /* Checking zero-length iteration. */\n      if (opcode != OP_ONCE || CURRENT_AS(bracket_backtrack)->u.framesize < 0)\n        CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n      else\n        {\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n        CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(TMP1), STACK(-CURRENT_AS(bracket_backtrack)->u.framesize - 2), CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n        }\n      /* Drop STR_PTR for non-greedy plus quantifier. */\n      if (opcode != OP_ONCE)\n        free_stack(common, 1);\n      }\n    else\n      JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n    }\n  rmin_label = LABEL();\n  if (repeat_type != 0)\n    OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  }\nelse if (bra == OP_BRAZERO)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  brazero = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n  }\nelse if (repeat_type == OP_EXACT)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  exact_label = LABEL();\n  }\n\nif (offset != 0)\n  {\n  if (common->capture_last_ptr != 0)\n    {\n    SLJIT_ASSERT(common->optimized_cbracket[offset >> 1] == 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, TMP1, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\n    free_stack(common, 3);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP1, 0);\n    }\n  else if (common->optimized_cbracket[offset >> 1] == 0)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    }\n  }\n\nif (SLJIT_UNLIKELY(opcode == OP_ONCE))\n  {\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    {\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n    OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(bracket_backtrack)->u.framesize - 1) * sizeof(sljit_sw));\n    }\n  once = JUMP(SLJIT_JUMP);\n  }\nelse if (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  {\n  if (has_alternatives)\n    {\n    /* Always exactly one alternative. */\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n\n    alt_max = 2;\n    next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n    }\n  }\nelse if (has_alternatives)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n\n  if (alt_max > 3)\n    {\n    sljit_emit_ijump(compiler, SLJIT_JUMP, TMP1, 0);\n\n    SLJIT_ASSERT(CURRENT_AS(bracket_backtrack)->u.matching_put_label);\n    sljit_set_put_label(CURRENT_AS(bracket_backtrack)->u.matching_put_label, LABEL());\n    sljit_emit_op0(compiler, SLJIT_ENDBR);\n    }\n  else\n    next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n  }\n\nCOMPILE_BACKTRACKINGPATH(current->top);\nif (current->topbacktracks)\n  set_jumps(current->topbacktracks, LABEL());\n\nif (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  {\n  /* Conditional block always has at most one alternative. */\n  if (ccbegin[1 + LINK_SIZE] >= OP_ASSERT && ccbegin[1 + LINK_SIZE] <= OP_ASSERTBACK_NOT)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    assert = CURRENT_AS(bracket_backtrack)->u.assert;\n    if (assert->framesize >= 0 && (ccbegin[1 + LINK_SIZE] == OP_ASSERT || ccbegin[1 + LINK_SIZE] == OP_ASSERTBACK))\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (assert->framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr, TMP1, 0);\n      }\n    cond = JUMP(SLJIT_JUMP);\n    set_jumps(CURRENT_AS(bracket_backtrack)->u.assert->condfailed, LABEL());\n    }\n  else if (CURRENT_AS(bracket_backtrack)->u.condfailed != NULL)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    cond = JUMP(SLJIT_JUMP);\n    set_jumps(CURRENT_AS(bracket_backtrack)->u.condfailed, LABEL());\n    }\n  else\n    SLJIT_ASSERT(!has_alternatives);\n  }\n\nif (has_alternatives)\n  {\n  alt_count = 1;\n  do\n    {\n    current->top = NULL;\n    current->topbacktracks = NULL;\n    current->nextbacktracks = NULL;\n    /* Conditional blocks always have an additional alternative, even if it is empty. */\n    if (*cc == OP_ALT)\n      {\n      ccprev = cc + 1 + LINK_SIZE;\n      cc += GET(cc, 1);\n      if (opcode != OP_COND && opcode != OP_SCOND)\n        {\n        if (opcode != OP_ONCE)\n          {\n          if (private_data_ptr != 0)\n            OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n          else\n            OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n          }\n        else\n          OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(needs_control_head ? 1 : 0));\n        }\n      compile_matchingpath(common, ccprev, cc, current);\n      if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n        return;\n\n      if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\n      if (opcode == OP_SCRIPT_RUN)\n        match_script_run_common(common, private_data_ptr, current);\n      }\n\n    /* Instructions after the current alternative is successfully matched. */\n    /* There is a similar code in compile_bracket_matchingpath. */\n    if (opcode == OP_ONCE)\n      match_once_common(common, ket, CURRENT_AS(bracket_backtrack)->u.framesize, private_data_ptr, has_alternatives, needs_control_head);\n\n    stacksize = 0;\n    if (repeat_type == OP_MINUPTO)\n      {\n      /* We need to preserve the counter. TMP2 will be used below. */\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n      stacksize++;\n      }\n    if (ket != OP_KET || bra != OP_BRA)\n      stacksize++;\n    if (offset != 0)\n      {\n      if (common->capture_last_ptr != 0)\n        stacksize++;\n      if (common->optimized_cbracket[offset >> 1] == 0)\n        stacksize += 2;\n      }\n    if (opcode != OP_ONCE)\n      stacksize++;\n\n    if (stacksize > 0)\n      allocate_stack(common, stacksize);\n\n    stacksize = 0;\n    if (repeat_type == OP_MINUPTO)\n      {\n      /* TMP2 was set above. */\n      OP2(SLJIT_SUB, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP2, 0, SLJIT_IMM, 1);\n      stacksize++;\n      }\n\n    if (ket != OP_KET || bra != OP_BRA)\n      {\n      if (ket != OP_KET)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n      stacksize++;\n      }\n\n    if (offset != 0)\n      stacksize = match_capture_common(common, stacksize, offset, private_data_ptr);\n\n    if (opcode != OP_ONCE)\n      {\n      if (alt_max <= 3)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, alt_count);\n      else\n        put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(stacksize));\n      }\n\n    if (offset != 0 && ket == OP_KETRMAX && common->optimized_cbracket[offset >> 1] != 0)\n      {\n      /* If ket is not OP_KETRMAX, this code path is executed after the jump to alternative_matchingpath. */\n      SLJIT_ASSERT(private_data_ptr == OVECTOR(offset + 0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      }\n\n    JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->alternative_matchingpath);\n\n    if (opcode != OP_ONCE)\n      {\n      if (alt_max <= 3)\n        {\n        JUMPHERE(next_alt);\n        alt_count++;\n        if (alt_count < alt_max)\n          {\n          SLJIT_ASSERT(alt_count == 2 && alt_max == 3);\n          next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 1);\n          }\n        }\n      else\n        {\n        sljit_set_put_label(put_label, LABEL());\n        sljit_emit_op0(compiler, SLJIT_ENDBR);\n        }\n      }\n\n    COMPILE_BACKTRACKINGPATH(current->top);\n    if (current->topbacktracks)\n      set_jumps(current->topbacktracks, LABEL());\n    SLJIT_ASSERT(!current->nextbacktracks);\n    }\n  while (*cc == OP_ALT);\n\n  if (cond != NULL)\n    {\n    SLJIT_ASSERT(opcode == OP_COND || opcode == OP_SCOND);\n    assert = CURRENT_AS(bracket_backtrack)->u.assert;\n    if ((ccbegin[1 + LINK_SIZE] == OP_ASSERT_NOT || ccbegin[1 + LINK_SIZE] == OP_ASSERTBACK_NOT) && assert->framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (assert->framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr, TMP1, 0);\n      }\n    JUMPHERE(cond);\n    }\n\n  /* Free the STR_PTR. */\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  }\n\nif (offset != 0)\n  {\n  /* Using both tmp register is better for instruction scheduling. */\n  if (common->optimized_cbracket[offset >> 1] != 0)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  }\nelse if (opcode == OP_ONCE)\n  {\n  cc = ccbegin + GET(ccbegin, 1);\n  stacksize = needs_control_head ? 1 : 0;\n\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    {\n    /* Reset head and drop saved frame. */\n    stacksize += CURRENT_AS(bracket_backtrack)->u.framesize + ((ket != OP_KET || *cc == OP_ALT) ? 2 : 1);\n    }\n  else if (ket == OP_KETRMAX || (*cc == OP_ALT && ket != OP_KETRMIN))\n    {\n    /* The STR_PTR must be released. */\n    stacksize++;\n    }\n\n  if (stacksize > 0)\n    free_stack(common, stacksize);\n\n  JUMPHERE(once);\n  /* Restore previous private_data_ptr */\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-CURRENT_AS(bracket_backtrack)->u.framesize - 1));\n  else if (ket == OP_KETRMIN)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    /* See the comment below. */\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  }\n\nif (repeat_type == OP_EXACT)\n  {\n  OP2(SLJIT_ADD, TMP1, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0);\n  CMPTO(SLJIT_LESS_EQUAL, TMP1, 0, SLJIT_IMM, repeat_count, exact_label);\n  }\nelse if (ket == OP_KETRMAX)\n  {\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  if (bra != OP_BRAZERO)\n    free_stack(common, 1);\n\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->zero_matchingpath);\n    JUMPHERE(brazero);\n    free_stack(common, 1);\n    }\n  }\nelse if (ket == OP_KETRMIN)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  /* OP_ONCE removes everything in case of a backtrack, so we don't\n  need to explicitly release the STR_PTR. The extra release would\n  affect badly the free_stack(2) above. */\n  if (opcode != OP_ONCE)\n    free_stack(common, 1);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, rmin_label);\n  if (opcode == OP_ONCE)\n    free_stack(common, bra == OP_BRAMINZERO ? 2 : 1);\n  else if (bra == OP_BRAMINZERO)\n    free_stack(common, 1);\n  }\nelse if (bra == OP_BRAZERO)\n  {\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->zero_matchingpath);\n  JUMPHERE(brazero);\n  }\n}\n\nstatic SLJIT_INLINE void compile_bracketpos_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nint offset;\nstruct sljit_jump *jump;\n\nif (CURRENT_AS(bracketpos_backtrack)->framesize < 0)\n  {\n  if (*current->cc == OP_CBRAPOS || *current->cc == OP_SCBRAPOS)\n    {\n    offset = (GET2(current->cc, 1 + LINK_SIZE)) << 1;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, TMP1, 0);\n    }\n  set_jumps(current->topbacktracks, LABEL());\n  free_stack(common, CURRENT_AS(bracketpos_backtrack)->stacksize);\n  return;\n  }\n\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(bracketpos_backtrack)->private_data_ptr);\nadd_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\nOP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(bracketpos_backtrack)->framesize - 1) * sizeof(sljit_sw));\n\nif (current->topbacktracks)\n  {\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(current->topbacktracks, LABEL());\n  /* Drop the stack frame. */\n  free_stack(common, CURRENT_AS(bracketpos_backtrack)->stacksize);\n  JUMPHERE(jump);\n  }\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(bracketpos_backtrack)->private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-CURRENT_AS(bracketpos_backtrack)->framesize - 1));\n}\n\nstatic SLJIT_INLINE void compile_braminzero_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nassert_backtrack backtrack;\n\ncurrent->top = NULL;\ncurrent->topbacktracks = NULL;\ncurrent->nextbacktracks = NULL;\nif (current->cc[1] > OP_ASSERTBACK_NOT)\n  {\n  /* Manual call of compile_bracket_matchingpath and compile_bracket_backtrackingpath. */\n  compile_bracket_matchingpath(common, current->cc, current);\n  compile_bracket_backtrackingpath(common, current->top);\n  }\nelse\n  {\n  memset(&backtrack, 0, sizeof(backtrack));\n  backtrack.common.cc = current->cc;\n  backtrack.matchingpath = CURRENT_AS(braminzero_backtrack)->matchingpath;\n  /* Manual call of compile_assert_matchingpath. */\n  compile_assert_matchingpath(common, current->cc, &backtrack, FALSE);\n  }\nSLJIT_ASSERT(!current->nextbacktracks && !current->topbacktracks);\n}\n\nstatic SLJIT_INLINE void compile_control_verb_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_UCHAR opcode = *current->cc;\nstruct sljit_label *loop;\nstruct sljit_jump *jump;\n\nif (opcode == OP_THEN || opcode == OP_THEN_ARG)\n  {\n  if (common->then_trap != NULL)\n    {\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, type_then_trap);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, common->then_trap->start);\n    jump = JUMP(SLJIT_JUMP);\n\n    loop = LABEL();\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    JUMPHERE(jump);\n    CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0, loop);\n    CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0, loop);\n    add_jump(compiler, &common->then_trap->quit, JUMP(SLJIT_JUMP));\n    return;\n    }\n  else if (!common->local_quit_available && common->in_positive_assertion)\n    {\n    add_jump(compiler, &common->positive_assertion_quit, JUMP(SLJIT_JUMP));\n    return;\n    }\n  }\n\nif (common->local_quit_available)\n  {\n  /* Abort match with a fail. */\n  if (common->quit_label == NULL)\n    add_jump(compiler, &common->quit, JUMP(SLJIT_JUMP));\n  else\n    JUMPTO(SLJIT_JUMP, common->quit_label);\n  return;\n  }\n\nif (opcode == OP_SKIP_ARG)\n  {\n  SLJIT_ASSERT(common->control_head_ptr != 0 && TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, (sljit_sw)(current->cc + 2));\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_search_mark));\n\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_R0, 0);\n  add_jump(compiler, &common->reset_match, CMP(SLJIT_NOT_EQUAL, SLJIT_R0, 0, SLJIT_IMM, 0));\n  return;\n  }\n\nif (opcode == OP_SKIP)\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nelse\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_IMM, 0);\nadd_jump(compiler, &common->reset_match, JUMP(SLJIT_JUMP));\n}\n\nstatic SLJIT_INLINE void compile_then_trap_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nint size;\n\nif (CURRENT_AS(then_trap_backtrack)->then_trap)\n  {\n  common->then_trap = CURRENT_AS(then_trap_backtrack)->then_trap;\n  return;\n  }\n\nsize = CURRENT_AS(then_trap_backtrack)->framesize;\nsize = 3 + (size < 0 ? 0 : size);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(size - 3));\nfree_stack(common, size);\njump = JUMP(SLJIT_JUMP);\n\nset_jumps(CURRENT_AS(then_trap_backtrack)->quit, LABEL());\n/* STACK_TOP is set by THEN. */\nif (CURRENT_AS(then_trap_backtrack)->framesize >= 0)\n  {\n  add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(then_trap_backtrack)->framesize - 1) * sizeof(sljit_sw));\n  }\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nfree_stack(common, 3);\n\nJUMPHERE(jump);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP1, 0);\n}\n\nstatic void compile_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nthen_trap_backtrack *save_then_trap = common->then_trap;\n\nwhile (current)\n  {\n  if (current->nextbacktracks != NULL)\n    set_jumps(current->nextbacktracks, LABEL());\n  switch(*current->cc)\n    {\n    case OP_SET_SOM:\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), TMP1, 0);\n    break;\n\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n#endif\n    compile_iterator_backtrackingpath(common, current);\n    break;\n\n    case OP_REF:\n    case OP_REFI:\n    case OP_DNREF:\n    case OP_DNREFI:\n    compile_ref_iterator_backtrackingpath(common, current);\n    break;\n\n    case OP_RECURSE:\n    compile_recurse_backtrackingpath(common, current);\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    compile_assert_backtrackingpath(common, current);\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRA:\n    case OP_CBRA:\n    case OP_COND:\n    case OP_SBRA:\n    case OP_SCBRA:\n    case OP_SCOND:\n    compile_bracket_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAZERO:\n    if (current->cc[1] > OP_ASSERTBACK_NOT)\n      compile_bracket_backtrackingpath(common, current);\n    else\n      compile_assert_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAPOS:\n    case OP_CBRAPOS:\n    case OP_SBRAPOS:\n    case OP_SCBRAPOS:\n    case OP_BRAPOSZERO:\n    compile_bracketpos_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAMINZERO:\n    compile_braminzero_backtrackingpath(common, current);\n    break;\n\n    case OP_MARK:\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(common->has_skip_arg ? 4 : 0));\n    if (common->has_skip_arg)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, common->has_skip_arg ? 5 : 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP1, 0);\n    if (common->has_skip_arg)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP2, 0);\n    break;\n\n    case OP_THEN:\n    case OP_THEN_ARG:\n    case OP_PRUNE:\n    case OP_PRUNE_ARG:\n    case OP_SKIP:\n    case OP_SKIP_ARG:\n    compile_control_verb_backtrackingpath(common, current);\n    break;\n\n    case OP_COMMIT:\n    case OP_COMMIT_ARG:\n    if (!common->local_quit_available)\n      OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n    if (common->quit_label == NULL)\n      add_jump(compiler, &common->quit, JUMP(SLJIT_JUMP));\n    else\n      JUMPTO(SLJIT_JUMP, common->quit_label);\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    case OP_FAIL:\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    set_jumps(current->topbacktracks, LABEL());\n    break;\n\n    case OP_THEN_TRAP:\n    /* A virtual opcode for then traps. */\n    compile_then_trap_backtrackingpath(common, current);\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    break;\n    }\n  current = current->prev;\n  }\ncommon->then_trap = save_then_trap;\n}\n\nstatic SLJIT_INLINE void compile_recurse(compiler_common *common)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = common->start + common->currententry->start;\nPCRE2_SPTR ccbegin = cc + 1 + LINK_SIZE + (*cc == OP_BRA ? 0 : IMM2_SIZE);\nPCRE2_SPTR ccend = bracketend(cc) - (1 + LINK_SIZE);\nBOOL needs_control_head;\nBOOL has_quit;\nBOOL has_accept;\nint private_data_size = get_recurse_data_length(common, ccbegin, ccend, &needs_control_head, &has_quit, &has_accept);\nint alt_count, alt_max, local_size;\nbacktrack_common altbacktrack;\njump_list *match = NULL;\nstruct sljit_jump *next_alt = NULL;\nstruct sljit_jump *accept_exit = NULL;\nstruct sljit_label *quit;\nstruct sljit_put_label *put_label = NULL;\n\n/* Recurse captures then. */\ncommon->then_trap = NULL;\n\nSLJIT_ASSERT(*cc == OP_BRA || *cc == OP_CBRA || *cc == OP_CBRAPOS || *cc == OP_SCBRA || *cc == OP_SCBRAPOS);\n\nalt_max = no_alternatives(cc);\nalt_count = 0;\n\n/* Matching path. */\nSLJIT_ASSERT(common->currententry->entry_label == NULL && common->recursive_head_ptr != 0);\ncommon->currententry->entry_label = LABEL();\nset_jumps(common->currententry->entry_calls, common->currententry->entry_label);\n\nsljit_emit_fast_enter(compiler, TMP2, 0);\ncount_match(common);\n\nlocal_size = (alt_max > 1) ? 2 : 1;\n\n/* (Reversed) stack layout:\n   [private data][return address][optional: str ptr] ... [optional: alternative index][recursive_head_ptr] */\n\nallocate_stack(common, private_data_size + local_size);\n/* Save return address. */\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1), TMP2, 0);\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_copy_from_global, local_size, private_data_size + local_size, has_quit);\n\n/* This variable is saved and restored all time when we enter or exit from a recursive context. */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr, STACK_TOP, 0);\n\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n\nif (alt_max > 1)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\nmemset(&altbacktrack, 0, sizeof(backtrack_common));\ncommon->quit_label = NULL;\ncommon->accept_label = NULL;\ncommon->quit = NULL;\ncommon->accept = NULL;\naltbacktrack.cc = ccbegin;\ncc += GET(cc, 1);\nwhile (1)\n  {\n  altbacktrack.top = NULL;\n  altbacktrack.topbacktracks = NULL;\n\n  if (altbacktrack.cc != ccbegin)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  compile_matchingpath(common, altbacktrack.cc, cc, &altbacktrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return;\n\n  allocate_stack(common, (alt_max > 1 || has_accept) ? 2 : 1);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n\n  if (alt_max > 1 || has_accept)\n    {\n    if (alt_max > 3)\n      put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(1));\n    else\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, alt_count);\n    }\n\n  add_jump(compiler, &match, JUMP(SLJIT_JUMP));\n\n  if (alt_count == 0)\n    {\n    /* Backtracking path entry. */\n    SLJIT_ASSERT(common->currententry->backtrack_label == NULL);\n    common->currententry->backtrack_label = LABEL();\n    set_jumps(common->currententry->backtrack_calls, common->currententry->backtrack_label);\n\n    sljit_emit_fast_enter(compiler, TMP1, 0);\n\n    if (has_accept)\n      accept_exit = CMP(SLJIT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, -1);\n\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    /* Save return address. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), STACK(local_size - 1), TMP1, 0);\n\n    copy_recurse_data(common, ccbegin, ccend, recurse_swap_global, local_size, private_data_size + local_size, has_quit);\n\n    if (alt_max > 1)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n      free_stack(common, 2);\n\n      if (alt_max > 3)\n        {\n        sljit_emit_ijump(compiler, SLJIT_JUMP, TMP1, 0);\n        sljit_set_put_label(put_label, LABEL());\n        sljit_emit_op0(compiler, SLJIT_ENDBR);\n        }\n      else\n        next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, has_accept ? 2 : 1);\n    }\n  else if (alt_max > 3)\n    {\n    sljit_set_put_label(put_label, LABEL());\n    sljit_emit_op0(compiler, SLJIT_ENDBR);\n    }\n  else\n    {\n    JUMPHERE(next_alt);\n    if (alt_count + 1 < alt_max)\n      {\n      SLJIT_ASSERT(alt_count == 1 && alt_max == 3);\n      next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 1);\n      }\n    }\n\n  alt_count++;\n\n  compile_backtrackingpath(common, altbacktrack.top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return;\n  set_jumps(altbacktrack.topbacktracks, LABEL());\n\n  if (*cc != OP_ALT)\n    break;\n\n  altbacktrack.cc = cc + 1 + LINK_SIZE;\n  cc += GET(cc, 1);\n  }\n\n/* No alternative is matched. */\n\nquit = LABEL();\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_copy_private_to_global, local_size, private_data_size + local_size, has_quit);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1));\nfree_stack(common, private_data_size + local_size);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n\nif (common->quit != NULL)\n  {\n  SLJIT_ASSERT(has_quit);\n\n  set_jumps(common->quit, LABEL());\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n  copy_recurse_data(common, ccbegin, ccend, recurse_copy_shared_to_global, local_size, private_data_size + local_size, has_quit);\n  JUMPTO(SLJIT_JUMP, quit);\n  }\n\nif (has_accept)\n  {\n  JUMPHERE(accept_exit);\n  free_stack(common, 2);\n\n  /* Save return address. */\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1), TMP1, 0);\n\n  copy_recurse_data(common, ccbegin, ccend, recurse_copy_kept_shared_to_global, local_size, private_data_size + local_size, has_quit);\n\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1));\n  free_stack(common, private_data_size + local_size);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n  OP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n  }\n\nif (common->accept != NULL)\n  {\n  SLJIT_ASSERT(has_accept);\n\n  set_jumps(common->accept, LABEL());\n\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n  OP1(SLJIT_MOV, TMP2, 0, STACK_TOP, 0);\n\n  allocate_stack(common, 2);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, -1);\n  }\n\nset_jumps(match, LABEL());\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_swap_global, local_size, private_data_size + local_size, has_quit);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), STACK(local_size - 1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n}\n\n#undef COMPILE_BACKTRACKINGPATH\n#undef CURRENT_AS\n\n#define PUBLIC_JIT_COMPILE_CONFIGURATION_OPTIONS \\\n  (PCRE2_JIT_INVALID_UTF)\n\nstatic int jit_compile(pcre2_code *code, sljit_u32 mode)\n{\npcre2_real_code *re = (pcre2_real_code *)code;\nstruct sljit_compiler *compiler;\nbacktrack_common rootbacktrack;\ncompiler_common common_data;\ncompiler_common *common = &common_data;\nconst sljit_u8 *tables = re->tables;\nvoid *allocator_data = &re->memctl;\nint private_data_size;\nPCRE2_SPTR ccend;\nexecutable_functions *functions;\nvoid *executable_func;\nsljit_uw executable_size;\nsljit_uw total_length;\nstruct sljit_label *mainloop_label = NULL;\nstruct sljit_label *continue_match_label;\nstruct sljit_label *empty_match_found_label = NULL;\nstruct sljit_label *empty_match_backtrack_label = NULL;\nstruct sljit_label *reset_match_label;\nstruct sljit_label *quit_label;\nstruct sljit_jump *jump;\nstruct sljit_jump *minlength_check_failed = NULL;\nstruct sljit_jump *empty_match = NULL;\nstruct sljit_jump *end_anchor_failed = NULL;\njump_list *reqcu_not_found = NULL;\n\nSLJIT_ASSERT(tables);\n\n#if HAS_VIRTUAL_REGISTERS == 1\nSLJIT_ASSERT(sljit_get_register_index(TMP3) < 0 && sljit_get_register_index(ARGUMENTS) < 0 && sljit_get_register_index(RETURN_ADDR) < 0);\n#elif HAS_VIRTUAL_REGISTERS == 0\nSLJIT_ASSERT(sljit_get_register_index(TMP3) >= 0 && sljit_get_register_index(ARGUMENTS) >= 0 && sljit_get_register_index(RETURN_ADDR) >= 0);\n#else\n#error \"Invalid value for HAS_VIRTUAL_REGISTERS\"\n#endif\n\nmemset(&rootbacktrack, 0, sizeof(backtrack_common));\nmemset(common, 0, sizeof(compiler_common));\ncommon->re = re;\ncommon->name_table = (PCRE2_SPTR)((uint8_t *)re + sizeof(pcre2_real_code));\nrootbacktrack.cc = common->name_table + re->name_count * re->name_entry_size;\n\n#ifdef SUPPORT_UNICODE\ncommon->invalid_utf = (mode & PCRE2_JIT_INVALID_UTF) != 0;\n#endif /* SUPPORT_UNICODE */\nmode &= ~PUBLIC_JIT_COMPILE_CONFIGURATION_OPTIONS;\n\ncommon->start = rootbacktrack.cc;\ncommon->read_only_data_head = NULL;\ncommon->fcc = tables + fcc_offset;\ncommon->lcc = (sljit_sw)(tables + lcc_offset);\ncommon->mode = mode;\ncommon->might_be_empty = (re->minlength == 0) || (re->flags & PCRE2_MATCH_EMPTY);\ncommon->allow_empty_partial = (re->max_lookbehind > 0) || (re->flags & PCRE2_MATCH_EMPTY);\ncommon->nltype = NLTYPE_FIXED;\nswitch(re->newline_convention)\n  {\n  case PCRE2_NEWLINE_CR: common->newline = CHAR_CR; break;\n  case PCRE2_NEWLINE_LF: common->newline = CHAR_NL; break;\n  case PCRE2_NEWLINE_CRLF: common->newline = (CHAR_CR << 8) | CHAR_NL; break;\n  case PCRE2_NEWLINE_ANY: common->newline = (CHAR_CR << 8) | CHAR_NL; common->nltype = NLTYPE_ANY; break;\n  case PCRE2_NEWLINE_ANYCRLF: common->newline = (CHAR_CR << 8) | CHAR_NL; common->nltype = NLTYPE_ANYCRLF; break;\n  case PCRE2_NEWLINE_NUL: common->newline = CHAR_NUL; break;\n  default: return PCRE2_ERROR_INTERNAL;\n  }\ncommon->nlmax = READ_CHAR_MAX;\ncommon->nlmin = 0;\nif (re->bsr_convention == PCRE2_BSR_UNICODE)\n  common->bsr_nltype = NLTYPE_ANY;\nelse if (re->bsr_convention == PCRE2_BSR_ANYCRLF)\n  common->bsr_nltype = NLTYPE_ANYCRLF;\nelse\n  {\n#ifdef BSR_ANYCRLF\n  common->bsr_nltype = NLTYPE_ANYCRLF;\n#else\n  common->bsr_nltype = NLTYPE_ANY;\n#endif\n  }\ncommon->bsr_nlmax = READ_CHAR_MAX;\ncommon->bsr_nlmin = 0;\ncommon->endonly = (re->overall_options & PCRE2_DOLLAR_ENDONLY) != 0;\ncommon->ctypes = (sljit_sw)(tables + ctypes_offset);\ncommon->name_count = re->name_count;\ncommon->name_entry_size = re->name_entry_size;\ncommon->unset_backref = (re->overall_options & PCRE2_MATCH_UNSET_BACKREF) != 0;\ncommon->alt_circumflex = (re->overall_options & PCRE2_ALT_CIRCUMFLEX) != 0;\n#ifdef SUPPORT_UNICODE\n/* PCRE_UTF[16|32] have the same value as PCRE_UTF8. */\ncommon->utf = (re->overall_options & PCRE2_UTF) != 0;\ncommon->ucp = (re->overall_options & PCRE2_UCP) != 0;\nif (common->utf)\n  {\n  if (common->nltype == NLTYPE_ANY)\n    common->nlmax = 0x2029;\n  else if (common->nltype == NLTYPE_ANYCRLF)\n    common->nlmax = (CHAR_CR > CHAR_NL) ? CHAR_CR : CHAR_NL;\n  else\n    {\n    /* We only care about the first newline character. */\n    common->nlmax = common->newline & 0xff;\n    }\n\n  if (common->nltype == NLTYPE_FIXED)\n    common->nlmin = common->newline & 0xff;\n  else\n    common->nlmin = (CHAR_CR < CHAR_NL) ? CHAR_CR : CHAR_NL;\n\n  if (common->bsr_nltype == NLTYPE_ANY)\n    common->bsr_nlmax = 0x2029;\n  else\n    common->bsr_nlmax = (CHAR_CR > CHAR_NL) ? CHAR_CR : CHAR_NL;\n  common->bsr_nlmin = (CHAR_CR < CHAR_NL) ? CHAR_CR : CHAR_NL;\n  }\nelse\n  common->invalid_utf = FALSE;\n#endif /* SUPPORT_UNICODE */\nccend = bracketend(common->start);\n\n/* Calculate the local space size on the stack. */\ncommon->ovector_start = LIMIT_MATCH + sizeof(sljit_sw);\ncommon->optimized_cbracket = (sljit_u8 *)SLJIT_MALLOC(re->top_bracket + 1, allocator_data);\nif (!common->optimized_cbracket)\n  return PCRE2_ERROR_NOMEMORY;\n#if defined DEBUG_FORCE_UNOPTIMIZED_CBRAS && DEBUG_FORCE_UNOPTIMIZED_CBRAS == 1\nmemset(common->optimized_cbracket, 0, re->top_bracket + 1);\n#else\nmemset(common->optimized_cbracket, 1, re->top_bracket + 1);\n#endif\n\nSLJIT_ASSERT(*common->start == OP_BRA && ccend[-(1 + LINK_SIZE)] == OP_KET);\n#if defined DEBUG_FORCE_UNOPTIMIZED_CBRAS && DEBUG_FORCE_UNOPTIMIZED_CBRAS == 2\ncommon->capture_last_ptr = common->ovector_start;\ncommon->ovector_start += sizeof(sljit_sw);\n#endif\nif (!check_opcode_types(common, common->start, ccend))\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\n/* Checking flags and updating ovector_start. */\nif (mode == PCRE2_JIT_COMPLETE && (re->flags & PCRE2_LASTSET) != 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n  {\n  common->req_char_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\nif (mode != PCRE2_JIT_COMPLETE)\n  {\n  common->start_used_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  if (mode == PCRE2_JIT_PARTIAL_SOFT)\n    {\n    common->hit_start = common->ovector_start;\n    common->ovector_start += sizeof(sljit_sw);\n    }\n  }\nif ((re->overall_options & (PCRE2_FIRSTLINE | PCRE2_USE_OFFSET_LIMIT)) != 0)\n  {\n  common->match_end_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\ncommon->control_head_ptr = 1;\n#endif\nif (common->control_head_ptr != 0)\n  {\n  common->control_head_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\nif (common->has_set_som)\n  {\n  /* Saving the real start pointer is necessary. */\n  common->start_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\n\n/* Aligning ovector to even number of sljit words. */\nif ((common->ovector_start & sizeof(sljit_sw)) != 0)\n  common->ovector_start += sizeof(sljit_sw);\n\nif (common->start_ptr == 0)\n  common->start_ptr = OVECTOR(0);\n\n/* Capturing brackets cannot be optimized if callouts are allowed. */\nif (common->capture_last_ptr != 0)\n  memset(common->optimized_cbracket, 0, re->top_bracket + 1);\n\nSLJIT_ASSERT(!(common->req_char_ptr != 0 && common->start_used_ptr != 0));\ncommon->cbra_ptr = OVECTOR_START + (re->top_bracket + 1) * 2 * sizeof(sljit_sw);\n\ntotal_length = ccend - common->start;\ncommon->private_data_ptrs = (sljit_s32 *)SLJIT_MALLOC(total_length * (sizeof(sljit_s32) + (common->has_then ? 1 : 0)), allocator_data);\nif (!common->private_data_ptrs)\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\nmemset(common->private_data_ptrs, 0, total_length * sizeof(sljit_s32));\n\nprivate_data_size = common->cbra_ptr + (re->top_bracket + 1) * sizeof(sljit_sw);\n\nif ((re->overall_options & PCRE2_ANCHORED) == 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0 && !common->has_skip_in_assert_back)\n  detect_early_fail(common, common->start, &private_data_size, 0, 0, TRUE);\n\nset_private_data_ptrs(common, &private_data_size, ccend);\n\nSLJIT_ASSERT(common->early_fail_start_ptr <= common->early_fail_end_ptr);\n\nif (private_data_size > SLJIT_MAX_LOCAL_SIZE)\n  {\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nif (common->has_then)\n  {\n  common->then_offsets = (sljit_u8 *)(common->private_data_ptrs + total_length);\n  memset(common->then_offsets, 0, total_length);\n  set_then_offsets(common, common->start, NULL);\n  }\n\ncompiler = sljit_create_compiler(allocator_data, NULL);\nif (!compiler)\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\ncommon->compiler = compiler;\n\n/* Main pcre2_jit_exec entry. */\nsljit_emit_enter(compiler, 0, SLJIT_ARGS1(W, W), 5, 5, 0, 0, private_data_size);\n\n/* Register init. */\nreset_ovector(common, (re->top_bracket + 1) * 2);\nif (common->req_char_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr, SLJIT_R0, 0);\n\nOP1(SLJIT_MOV, ARGUMENTS, 0, SLJIT_S0, 0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_S0, 0);\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\nOP1(SLJIT_MOV, STR_END, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, end));\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, stack));\nOP1(SLJIT_MOV_U32, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, limit_match));\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(struct sljit_stack, end));\nOP1(SLJIT_MOV, STACK_LIMIT, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(struct sljit_stack, start));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LIMIT_MATCH, TMP1, 0);\n\nif (common->early_fail_start_ptr < common->early_fail_end_ptr)\n  reset_early_fail(common);\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1);\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, SLJIT_IMM, 0);\nif (common->control_head_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n\n/* Main part of the matching */\nif ((re->overall_options & PCRE2_ANCHORED) == 0)\n  {\n  mainloop_label = mainloop_entry(common);\n  continue_match_label = LABEL();\n  /* Forward search if possible. */\n  if ((re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n    {\n    if (mode == PCRE2_JIT_COMPLETE && fast_forward_first_n_chars(common))\n      ;\n    else if ((re->flags & PCRE2_FIRSTSET) != 0)\n      fast_forward_first_char(common);\n    else if ((re->flags & PCRE2_STARTLINE) != 0)\n      fast_forward_newline(common);\n    else if ((re->flags & PCRE2_FIRSTMAPSET) != 0)\n      fast_forward_start_bits(common);\n    }\n  }\nelse\n  continue_match_label = LABEL();\n\nif (mode == PCRE2_JIT_COMPLETE && re->minlength > 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n  {\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(re->minlength));\n  minlength_check_failed = CMP(SLJIT_GREATER, TMP2, 0, STR_END, 0);\n  }\nif (common->req_char_ptr != 0)\n  reqcu_not_found = search_requested_char(common, (PCRE2_UCHAR)(re->last_codeunit), (re->flags & PCRE2_LASTCASELESS) != 0, (re->flags & PCRE2_FIRSTSET) != 0);\n\n/* Store the current STR_PTR in OVECTOR(0). */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), STR_PTR, 0);\n/* Copy the limit of allowed recursions. */\nOP1(SLJIT_MOV, COUNT_MATCH, 0, SLJIT_MEM1(SLJIT_SP), LIMIT_MATCH);\nif (common->capture_last_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, 0);\nif (common->fast_forward_bc_ptr != NULL)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), PRIVATE_DATA(common->fast_forward_bc_ptr + 1) >> 3, STR_PTR, 0);\n\nif (common->start_ptr != OVECTOR(0))\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_ptr, STR_PTR, 0);\n\n/* Copy the beginning of the string. */\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  jump = CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\nelse if (mode == PCRE2_JIT_PARTIAL_HARD)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n\ncompile_matchingpath(common, common->start, ccend, &rootbacktrack);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  {\n  sljit_free_compiler(compiler);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nif ((re->overall_options & PCRE2_ENDANCHORED) != 0)\n  end_anchor_failed = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0);\n\nif (common->might_be_empty)\n  {\n  empty_match = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n  empty_match_found_label = LABEL();\n  }\n\ncommon->accept_label = LABEL();\nif (common->accept != NULL)\n  set_jumps(common->accept, common->accept_label);\n\n/* This means we have a match. Update the ovector. */\ncopy_ovector(common, re->top_bracket + 1);\ncommon->quit_label = common->abort_label = LABEL();\nif (common->quit != NULL)\n  set_jumps(common->quit, common->quit_label);\nif (common->abort != NULL)\n  set_jumps(common->abort, common->abort_label);\nif (minlength_check_failed != NULL)\n  SET_LABEL(minlength_check_failed, common->abort_label);\n\nsljit_emit_op0(compiler, SLJIT_SKIP_FRAMES_BEFORE_RETURN);\nsljit_emit_return(compiler, SLJIT_MOV, SLJIT_RETURN_REG, 0);\n\nif (common->failed_match != NULL)\n  {\n  SLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE);\n  set_jumps(common->failed_match, LABEL());\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  JUMPTO(SLJIT_JUMP, common->abort_label);\n  }\n\nif ((re->overall_options & PCRE2_ENDANCHORED) != 0)\n  JUMPHERE(end_anchor_failed);\n\nif (mode != PCRE2_JIT_COMPLETE)\n  {\n  common->partialmatchlabel = LABEL();\n  set_jumps(common->partialmatch, common->partialmatchlabel);\n  return_with_partial_match(common, common->quit_label);\n  }\n\nif (common->might_be_empty)\n  empty_match_backtrack_label = LABEL();\ncompile_backtrackingpath(common, rootbacktrack.top);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  {\n  sljit_free_compiler(compiler);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nSLJIT_ASSERT(rootbacktrack.prev == NULL);\nreset_match_label = LABEL();\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  /* Update hit_start only in the first time. */\n  jump = CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, TMP1, 0);\n  JUMPHERE(jump);\n  }\n\n/* Check we have remaining characters. */\nif ((re->overall_options & PCRE2_ANCHORED) == 0 && common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  }\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP),\n    (common->fast_forward_bc_ptr != NULL) ? (PRIVATE_DATA(common->fast_forward_bc_ptr + 1) >> 3) : common->start_ptr);\n\nif ((re->overall_options & PCRE2_ANCHORED) == 0)\n  {\n  if (common->ff_newline_shortcut != NULL)\n    {\n    /* There cannot be more newlines if PCRE2_FIRSTLINE is set. */\n    if ((re->overall_options & PCRE2_FIRSTLINE) == 0)\n      {\n      if (common->match_end_ptr != 0)\n        {\n        OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n        OP1(SLJIT_MOV, STR_END, 0, TMP1, 0);\n        CMPTO(SLJIT_LESS, STR_PTR, 0, TMP1, 0, common->ff_newline_shortcut);\n        OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n        }\n      else\n        CMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, common->ff_newline_shortcut);\n      }\n    }\n  else\n    CMPTO(SLJIT_LESS, STR_PTR, 0, (common->match_end_ptr == 0) ? STR_END : TMP1, 0, mainloop_label);\n  }\n\n/* No more remaining characters. */\nif (reqcu_not_found != NULL)\n  set_jumps(reqcu_not_found, LABEL());\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1, common->partialmatchlabel);\n\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\nflush_stubs(common);\n\nif (common->might_be_empty)\n  {\n  JUMPHERE(empty_match);\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options));\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY);\n  JUMPTO(SLJIT_NOT_ZERO, empty_match_backtrack_label);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY_ATSTART);\n  JUMPTO(SLJIT_ZERO, empty_match_found_label);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n  CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, empty_match_found_label);\n  JUMPTO(SLJIT_JUMP, empty_match_backtrack_label);\n  }\n\ncommon->fast_forward_bc_ptr = NULL;\ncommon->early_fail_start_ptr = 0;\ncommon->early_fail_end_ptr = 0;\ncommon->currententry = common->entries;\ncommon->local_quit_available = TRUE;\nquit_label = common->quit_label;\nwhile (common->currententry != NULL)\n  {\n  /* Might add new entries. */\n  compile_recurse(common);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    sljit_free_compiler(compiler);\n    SLJIT_FREE(common->optimized_cbracket, allocator_data);\n    SLJIT_FREE(common->private_data_ptrs, allocator_data);\n    PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n    return PCRE2_ERROR_NOMEMORY;\n    }\n  flush_stubs(common);\n  common->currententry = common->currententry->next;\n  }\ncommon->local_quit_available = FALSE;\ncommon->quit_label = quit_label;\n\n/* Allocating stack, returns with PCRE_ERROR_JIT_STACKLIMIT if fails. */\n/* This is a (really) rare case. */\nset_jumps(common->stackalloc, LABEL());\n/* RETURN_ADDR is not a saved register. */\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, STR_PTR, 0);\nOP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\nOP2(SLJIT_SUB, SLJIT_R1, 0, STACK_LIMIT, 0, SLJIT_IMM, STACK_GROWTH_RATE);\nOP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, stack));\nOP1(SLJIT_MOV, STACK_LIMIT, 0, TMP2, 0);\n\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(sljit_stack_resize));\n\njump = CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\nOP1(SLJIT_MOV, TMP2, 0, STACK_LIMIT, 0);\nOP1(SLJIT_MOV, STACK_LIMIT, 0, SLJIT_RETURN_REG, 0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS1);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n/* Allocation failed. */\nJUMPHERE(jump);\n/* We break the return address cache here, but this is a really rare case. */\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_JIT_STACKLIMIT);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\n/* Call limit reached. */\nset_jumps(common->calllimit, LABEL());\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_MATCHLIMIT);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\nif (common->revertframes != NULL)\n  {\n  set_jumps(common->revertframes, LABEL());\n  do_revertframes(common);\n  }\nif (common->wordboundary != NULL)\n  {\n  set_jumps(common->wordboundary, LABEL());\n  check_wordboundary(common);\n  }\nif (common->anynewline != NULL)\n  {\n  set_jumps(common->anynewline, LABEL());\n  check_anynewline(common);\n  }\nif (common->hspace != NULL)\n  {\n  set_jumps(common->hspace, LABEL());\n  check_hspace(common);\n  }\nif (common->vspace != NULL)\n  {\n  set_jumps(common->vspace, LABEL());\n  check_vspace(common);\n  }\nif (common->casefulcmp != NULL)\n  {\n  set_jumps(common->casefulcmp, LABEL());\n  do_casefulcmp(common);\n  }\nif (common->caselesscmp != NULL)\n  {\n  set_jumps(common->caselesscmp, LABEL());\n  do_caselesscmp(common);\n  }\nif (common->reset_match != NULL)\n  {\n  set_jumps(common->reset_match, LABEL());\n  do_reset_match(common, (re->top_bracket + 1) * 2);\n  CMPTO(SLJIT_GREATER, STR_PTR, 0, TMP1, 0, continue_match_label);\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP1, 0);\n  JUMPTO(SLJIT_JUMP, reset_match_label);\n  }\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utfreadchar != NULL)\n  {\n  set_jumps(common->utfreadchar, LABEL());\n  do_utfreadchar(common);\n  }\nif (common->utfreadtype8 != NULL)\n  {\n  set_jumps(common->utfreadtype8, LABEL());\n  do_utfreadtype8(common);\n  }\nif (common->utfpeakcharback != NULL)\n  {\n  set_jumps(common->utfpeakcharback, LABEL());\n  do_utfpeakcharback(common);\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utfreadchar_invalid != NULL)\n  {\n  set_jumps(common->utfreadchar_invalid, LABEL());\n  do_utfreadchar_invalid(common);\n  }\nif (common->utfreadnewline_invalid != NULL)\n  {\n  set_jumps(common->utfreadnewline_invalid, LABEL());\n  do_utfreadnewline_invalid(common);\n  }\nif (common->utfmoveback_invalid)\n  {\n  set_jumps(common->utfmoveback_invalid, LABEL());\n  do_utfmoveback_invalid(common);\n  }\nif (common->utfpeakcharback_invalid)\n  {\n  set_jumps(common->utfpeakcharback_invalid, LABEL());\n  do_utfpeakcharback_invalid(common);\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16 */\nif (common->getucd != NULL)\n  {\n  set_jumps(common->getucd, LABEL());\n  do_getucd(common);\n  }\nif (common->getucdtype != NULL)\n  {\n  set_jumps(common->getucdtype, LABEL());\n  do_getucdtype(common);\n  }\n#endif /* SUPPORT_UNICODE */\n\nSLJIT_FREE(common->optimized_cbracket, allocator_data);\nSLJIT_FREE(common->private_data_ptrs, allocator_data);\n\nexecutable_func = sljit_generate_code(compiler);\nexecutable_size = sljit_get_generated_code_size(compiler);\nsljit_free_compiler(compiler);\n\nif (executable_func == NULL)\n  {\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\n/* Reuse the function descriptor if possible. */\nif (re->executable_jit != NULL)\n  functions = (executable_functions *)re->executable_jit;\nelse\n  {\n  functions = SLJIT_MALLOC(sizeof(executable_functions), allocator_data);\n  if (functions == NULL)\n    {\n    /* This case is highly unlikely since we just recently\n    freed a lot of memory. Not impossible though. */\n    sljit_free_code(executable_func, NULL);\n    PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n    return PCRE2_ERROR_NOMEMORY;\n    }\n  memset(functions, 0, sizeof(executable_functions));\n  functions->top_bracket = re->top_bracket + 1;\n  functions->limit_match = re->limit_match;\n  re->executable_jit = functions;\n  }\n\n/* Turn mode into an index. */\nif (mode == PCRE2_JIT_COMPLETE)\n  mode = 0;\nelse\n  mode = (mode == PCRE2_JIT_PARTIAL_SOFT) ? 1 : 2;\n\nSLJIT_ASSERT(mode < JIT_NUMBER_OF_COMPILE_MODES);\nfunctions->executable_funcs[mode] = executable_func;\nfunctions->read_only_data_heads[mode] = common->read_only_data_head;\nfunctions->executable_sizes[mode] = executable_size;\nreturn 0;\n}\n\n#endif\n\n/*************************************************\n*        JIT compile a Regular Expression        *\n*************************************************/\n\n/* This function used JIT to convert a previously-compiled pattern into machine\ncode.\n\nArguments:\n  code          a compiled pattern\n  options       JIT option bits\n\nReturns:        0: success or (*NOJIT) was used\n               <0: an error code\n*/\n\n#define PUBLIC_JIT_COMPILE_OPTIONS \\\n  (PCRE2_JIT_COMPLETE|PCRE2_JIT_PARTIAL_SOFT|PCRE2_JIT_PARTIAL_HARD|PCRE2_JIT_INVALID_UTF)\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_jit_compile(pcre2_code *code, uint32_t options)\n{\npcre2_real_code *re = (pcre2_real_code *)code;\n#ifdef SUPPORT_JIT\nexecutable_functions *functions;\nstatic int executable_allocator_is_working = 0;\n#endif\n\nif (code == NULL)\n  return PCRE2_ERROR_NULL;\n\nif ((options & ~PUBLIC_JIT_COMPILE_OPTIONS) != 0)\n  return PCRE2_ERROR_JIT_BADOPTION;\n\n/* Support for invalid UTF was first introduced in JIT, with the option\nPCRE2_JIT_INVALID_UTF. Later, support was added to the interpreter, and the\ncompile-time option PCRE2_MATCH_INVALID_UTF was created. This is now the\npreferred feature, with the earlier option deprecated. However, for backward\ncompatibility, if the earlier option is set, it forces the new option so that\nif JIT matching falls back to the interpreter, there is still support for\ninvalid UTF. However, if this function has already been successfully called\nwithout PCRE2_JIT_INVALID_UTF and without PCRE2_MATCH_INVALID_UTF (meaning that\nnon-invalid-supporting JIT code was compiled), give an error.\n\nIf in the future support for PCRE2_JIT_INVALID_UTF is withdrawn, the following\nactions are needed:\n\n  1. Remove the definition from pcre2.h.in and from the list in\n     PUBLIC_JIT_COMPILE_OPTIONS above.\n\n  2. Replace PCRE2_JIT_INVALID_UTF with a local flag in this module.\n\n  3. Replace PCRE2_JIT_INVALID_UTF in pcre2_jit_test.c.\n\n  4. Delete the following short block of code. The setting of \"re\" and\n     \"functions\" can be moved into the JIT-only block below, but if that is\n     done, (void)re and (void)functions will be needed in the non-JIT case, to\n     avoid compiler warnings.\n*/\n\n#ifdef SUPPORT_JIT\nfunctions = (executable_functions *)re->executable_jit;\n#endif\n\nif ((options & PCRE2_JIT_INVALID_UTF) != 0)\n  {\n  if ((re->overall_options & PCRE2_MATCH_INVALID_UTF) == 0)\n    {\n#ifdef SUPPORT_JIT\n    if (functions != NULL) return PCRE2_ERROR_JIT_BADOPTION;\n#endif\n    re->overall_options |= PCRE2_MATCH_INVALID_UTF;\n    }\n  }\n\n/* The above tests are run with and without JIT support. This means that\nPCRE2_JIT_INVALID_UTF propagates back into the regex options (ensuring\ninterpreter support) even in the absence of JIT. But now, if there is no JIT\nsupport, give an error return. */\n\n#ifndef SUPPORT_JIT\nreturn PCRE2_ERROR_JIT_BADOPTION;\n#else  /* SUPPORT_JIT */\n\n/* There is JIT support. Do the necessary. */\n\nif ((re->flags & PCRE2_NOJIT) != 0) return 0;\n\nif (executable_allocator_is_working == 0)\n  {\n  /* Checks whether the executable allocator is working. This check\n     might run multiple times in multi-threaded environments, but the\n     result should not be affected by it. */\n  void *ptr = SLJIT_MALLOC_EXEC(32, NULL);\n\n  executable_allocator_is_working = -1;\n\n  if (ptr != NULL)\n    {\n    SLJIT_FREE_EXEC(((sljit_u8*)(ptr)) + SLJIT_EXEC_OFFSET(ptr), NULL);\n    executable_allocator_is_working = 1;\n    }\n  }\n\nif (executable_allocator_is_working < 0)\n  return PCRE2_ERROR_NOMEMORY;\n\nif ((re->overall_options & PCRE2_MATCH_INVALID_UTF) != 0)\n  options |= PCRE2_JIT_INVALID_UTF;\n\nif ((options & PCRE2_JIT_COMPLETE) != 0 && (functions == NULL\n    || functions->executable_funcs[0] == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_PARTIAL_SOFT | PCRE2_JIT_PARTIAL_HARD);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nif ((options & PCRE2_JIT_PARTIAL_SOFT) != 0 && (functions == NULL\n    || functions->executable_funcs[1] == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_HARD);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nif ((options & PCRE2_JIT_PARTIAL_HARD) != 0 && (functions == NULL\n    || functions->executable_funcs[2] == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_SOFT);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nreturn 0;\n\n#endif  /* SUPPORT_JIT */\n}\n\n/* JIT compiler uses an all-in-one approach. This improves security,\n   since the code generator functions are not exported. */\n\n#define INCLUDED_FROM_PCRE2_JIT_COMPILE\n\n#include \"pcre2_jit_match.c\"\n#include \"pcre2_jit_misc.c\"\n\n/* End of pcre2_jit_compile.c */\n"], "filenames": ["src/pcre2_jit_compile.c"], "buggy_code_start_loc": [7492], "buggy_code_end_loc": [7493], "fixing_code_start_loc": [7492], "fixing_code_end_loc": [7493], "type": "CWE-125", "message": "An out-of-bounds read vulnerability was discovered in the PCRE2 library in the compile_xclass_matchingpath() function of the pcre2_jit_compile.c file. This involves a unicode property matching issue in JIT-compiled regular expressions. The issue occurs because the character was not fully read in case-less matching within JIT.", "other": {"cve": {"id": "CVE-2022-1586", "sourceIdentifier": "secalert@redhat.com", "published": "2022-05-16T21:15:07.793", "lastModified": "2023-03-16T05:15:51.230", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An out-of-bounds read vulnerability was discovered in the PCRE2 library in the compile_xclass_matchingpath() function of the pcre2_jit_compile.c file. This involves a unicode property matching issue in JIT-compiled regular expressions. The issue occurs because the character was not fully read in case-less matching within JIT."}, {"lang": "es", "value": "Se ha detectado una vulnerabilidad de lectura fuera de l\u00edmites en la biblioteca PCRE2 en la funci\u00f3n compile_xclass_matchingpath() del archivo pcre2_jit_compile.c. Esto implica un problema de coincidencia de propiedades unicode en expresiones regulares compiladas en JIT. El problema es producido porque el car\u00e1cter no ha sido le\u00eddo completamente en la coincidencia de may\u00fasculas y min\u00fasculas dentro de JIT"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pcre:pcre2:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.40", "matchCriteriaId": "EB329299-E960-45F2-80BA-5B6B9CD346D2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy_administration_utility:-:*:*:*:*:*:*:*", "matchCriteriaId": "E7CF3019-975D-40BB-A8A4-894E62BD3797"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2077976,", "source": "secalert@redhat.com", "tags": ["Broken Link", "Issue Tracking", "Patch"]}, {"url": "https://github.com/PCRE2Project/pcre2/commit/50a51cb7e67268e6ad417eb07c9de9bfea5cc55a,", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "https://github.com/PCRE2Project/pcre2/commit/d4fa336fbcc388f89095b184ba6d99422cfc676c", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/03/msg00014.html", "source": "secalert@redhat.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DWNG2NS3GINO6LQYUVC4BZLUQPJ3DYHA/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JXINO3KKI5DICQ45E2FKD6MKVMGJLEKJ/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KAX7767BCUFC7JMDGP7GOQ5GIZCAUGBB/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/M2GLQQUEY5VFM57CFYXVIFOXN2HUZPDM/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221028-0009/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/PCRE2Project/pcre2/commit/d4fa336fbcc388f89095b184ba6d99422cfc676c"}}