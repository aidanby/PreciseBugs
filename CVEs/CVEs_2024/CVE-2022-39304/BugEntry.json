{"buggy_code": ["package ghinstallation\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/go-github/v30/github\"\n)\n\nconst (\n\t// acceptHeader is the GitHub Apps Preview Accept header.\n\tacceptHeader = \"application/vnd.github.machine-man-preview+json\"\n\tapiBaseURL   = \"https://api.github.com\"\n)\n\n// Transport provides a http.RoundTripper by wrapping an existing\n// http.RoundTripper and provides GitHub Apps authentication as an\n// installation.\n//\n// Client can also be overwritten, and is useful to change to one which\n// provides retry logic if you do experience retryable errors.\n//\n// See https://developer.github.com/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps/\ntype Transport struct {\n\tBaseURL                  string                           // BaseURL is the scheme and host for GitHub API, defaults to https://api.github.com\n\tClient                   Client                           // Client to use to refresh tokens, defaults to http.Client with provided transport\n\ttr                       http.RoundTripper                // tr is the underlying roundtripper being wrapped\n\tappID                    int64                            // appID is the GitHub App's ID\n\tinstallationID           int64                            // installationID is the GitHub App Installation ID\n\tInstallationTokenOptions *github.InstallationTokenOptions // parameters restrict a token's access\n\tappsTransport            *AppsTransport\n\n\tmu    *sync.Mutex  // mu protects token\n\ttoken *accessToken // token is the installation's access token\n}\n\n// accessToken is an installation access token response from GitHub\ntype accessToken struct {\n\tToken        string                         `json:\"token\"`\n\tExpiresAt    time.Time                      `json:\"expires_at\"`\n\tPermissions  github.InstallationPermissions `json:\"permissions,omitempty\"`\n\tRepositories []github.Repository            `json:\"repositories,omitempty\"`\n}\n\nvar _ http.RoundTripper = &Transport{}\n\n// NewKeyFromFile returns a Transport using a private key from file.\nfunc NewKeyFromFile(tr http.RoundTripper, appID, installationID int64, privateKeyFile string) (*Transport, error) {\n\tprivateKey, err := ioutil.ReadFile(privateKeyFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not read private key: %s\", err)\n\t}\n\treturn New(tr, appID, installationID, privateKey)\n}\n\n// Client is a HTTP client which sends a http.Request and returns a http.Response\n// or an error.\ntype Client interface {\n\tDo(*http.Request) (*http.Response, error)\n}\n\n// New returns an Transport using private key. The key is parsed\n// and if any errors occur the error is non-nil.\n//\n// The provided tr http.RoundTripper should be shared between multiple\n// installations to ensure reuse of underlying TCP connections.\n//\n// The returned Transport's RoundTrip method is safe to be used concurrently.\nfunc New(tr http.RoundTripper, appID, installationID int64, privateKey []byte) (*Transport, error) {\n\tatr, err := NewAppsTransport(tr, appID, privateKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn NewFromAppsTransport(atr, installationID), nil\n}\n\n// NewFromAppsTransport returns a Transport using an existing *AppsTransport.\nfunc NewFromAppsTransport(atr *AppsTransport, installationID int64) *Transport {\n\treturn &Transport{\n\t\tBaseURL:        atr.BaseURL,\n\t\tClient:         &http.Client{Transport: atr.tr},\n\t\ttr:             atr.tr,\n\t\tappID:          atr.appID,\n\t\tinstallationID: installationID,\n\t\tappsTransport:  atr,\n\t\tmu:             &sync.Mutex{},\n\t}\n}\n\n// RoundTrip implements http.RoundTripper interface.\nfunc (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) {\n\ttoken, err := t.Token(req.Context())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"token \"+token)\n\treq.Header.Add(\"Accept\", acceptHeader) // We add to \"Accept\" header to avoid overwriting existing req headers.\n\tresp, err := t.tr.RoundTrip(req)\n\treturn resp, err\n}\n\n// Token checks the active token expiration and renews if necessary. Token returns\n// a valid access token. If renewal fails an error is returned.\nfunc (t *Transport) Token(ctx context.Context) (string, error) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tif t.token == nil || t.token.ExpiresAt.Add(-time.Minute).Before(time.Now()) {\n\t\t// Token is not set or expired/nearly expired, so refresh\n\t\tif err := t.refreshToken(ctx); err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"could not refresh installation id %v's token: %s\", t.installationID, err)\n\t\t}\n\t}\n\n\treturn t.token.Token, nil\n}\n\n// Permissions returns a transport token's GitHub installation permissions.\nfunc (t *Transport) Permissions() (github.InstallationPermissions, error) {\n\tif t.token == nil {\n\t\treturn github.InstallationPermissions{}, fmt.Errorf(\"Permissions() = nil, err: nil token\")\n\t}\n\treturn t.token.Permissions, nil\n}\n\n// Repositories returns a transport token's GitHub repositories.\nfunc (t *Transport) Repositories() ([]github.Repository, error) {\n\tif t.token == nil {\n\t\treturn nil, fmt.Errorf(\"Repositories() = nil, err: nil token\")\n\t}\n\treturn t.token.Repositories, nil\n}\n\nfunc (t *Transport) refreshToken(ctx context.Context) error {\n\t// Convert InstallationTokenOptions into a ReadWriter to pass as an argument to http.NewRequest.\n\tbody, err := GetReadWriter(t.InstallationTokenOptions)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not convert installation token parameters into json: %s\", err)\n\t}\n\n\treq, err := http.NewRequest(\"POST\", fmt.Sprintf(\"%s/app/installations/%v/access_tokens\", t.BaseURL, t.installationID), body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not create request: %s\", err)\n\t}\n\n\t// Set Content and Accept headers.\n\tif body != nil {\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\treq.Header.Set(\"Accept\", acceptHeader)\n\n\tif ctx != nil {\n\t\treq = req.WithContext(ctx)\n\t}\n\n\tt.appsTransport.BaseURL = t.BaseURL\n\tt.appsTransport.Client = t.Client\n\tresp, err := t.appsTransport.RoundTrip(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not get access_tokens from GitHub API for installation ID %v: %v\", t.installationID, err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode/100 != 2 {\n\t\treturn fmt.Errorf(\"request %+v received non 2xx response status %q with body %+v and TLS %+v\", resp.Request, resp.Body, resp.Request, resp.TLS)\n\t}\n\n\treturn json.NewDecoder(resp.Body).Decode(&t.token)\n}\n\n// GetReadWriter converts a body interface into an io.ReadWriter object.\nfunc GetReadWriter(i interface{}) (io.ReadWriter, error) {\n\tvar buf io.ReadWriter\n\tif i != nil {\n\t\tbuf = new(bytes.Buffer)\n\t\tenc := json.NewEncoder(buf)\n\t\terr := enc.Encode(i)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn buf, nil\n}\n"], "fixing_code": ["package ghinstallation\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/go-github/v30/github\"\n)\n\nconst (\n\t// acceptHeader is the GitHub Apps Preview Accept header.\n\tacceptHeader = \"application/vnd.github.machine-man-preview+json\"\n\tapiBaseURL   = \"https://api.github.com\"\n)\n\n// Transport provides a http.RoundTripper by wrapping an existing\n// http.RoundTripper and provides GitHub Apps authentication as an\n// installation.\n//\n// Client can also be overwritten, and is useful to change to one which\n// provides retry logic if you do experience retryable errors.\n//\n// See https://developer.github.com/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps/\ntype Transport struct {\n\tBaseURL                  string                           // BaseURL is the scheme and host for GitHub API, defaults to https://api.github.com\n\tClient                   Client                           // Client to use to refresh tokens, defaults to http.Client with provided transport\n\ttr                       http.RoundTripper                // tr is the underlying roundtripper being wrapped\n\tappID                    int64                            // appID is the GitHub App's ID\n\tinstallationID           int64                            // installationID is the GitHub App Installation ID\n\tInstallationTokenOptions *github.InstallationTokenOptions // parameters restrict a token's access\n\tappsTransport            *AppsTransport\n\n\tmu    *sync.Mutex  // mu protects token\n\ttoken *accessToken // token is the installation's access token\n}\n\n// accessToken is an installation access token response from GitHub\ntype accessToken struct {\n\tToken        string                         `json:\"token\"`\n\tExpiresAt    time.Time                      `json:\"expires_at\"`\n\tPermissions  github.InstallationPermissions `json:\"permissions,omitempty\"`\n\tRepositories []github.Repository            `json:\"repositories,omitempty\"`\n}\n\nvar _ http.RoundTripper = &Transport{}\n\n// NewKeyFromFile returns a Transport using a private key from file.\nfunc NewKeyFromFile(tr http.RoundTripper, appID, installationID int64, privateKeyFile string) (*Transport, error) {\n\tprivateKey, err := ioutil.ReadFile(privateKeyFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not read private key: %s\", err)\n\t}\n\treturn New(tr, appID, installationID, privateKey)\n}\n\n// Client is a HTTP client which sends a http.Request and returns a http.Response\n// or an error.\ntype Client interface {\n\tDo(*http.Request) (*http.Response, error)\n}\n\n// New returns an Transport using private key. The key is parsed\n// and if any errors occur the error is non-nil.\n//\n// The provided tr http.RoundTripper should be shared between multiple\n// installations to ensure reuse of underlying TCP connections.\n//\n// The returned Transport's RoundTrip method is safe to be used concurrently.\nfunc New(tr http.RoundTripper, appID, installationID int64, privateKey []byte) (*Transport, error) {\n\tatr, err := NewAppsTransport(tr, appID, privateKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn NewFromAppsTransport(atr, installationID), nil\n}\n\n// NewFromAppsTransport returns a Transport using an existing *AppsTransport.\nfunc NewFromAppsTransport(atr *AppsTransport, installationID int64) *Transport {\n\treturn &Transport{\n\t\tBaseURL:        atr.BaseURL,\n\t\tClient:         &http.Client{Transport: atr.tr},\n\t\ttr:             atr.tr,\n\t\tappID:          atr.appID,\n\t\tinstallationID: installationID,\n\t\tappsTransport:  atr,\n\t\tmu:             &sync.Mutex{},\n\t}\n}\n\n// RoundTrip implements http.RoundTripper interface.\nfunc (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) {\n\ttoken, err := t.Token(req.Context())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"token \"+token)\n\treq.Header.Add(\"Accept\", acceptHeader) // We add to \"Accept\" header to avoid overwriting existing req headers.\n\tresp, err := t.tr.RoundTrip(req)\n\treturn resp, err\n}\n\n// Token checks the active token expiration and renews if necessary. Token returns\n// a valid access token. If renewal fails an error is returned.\nfunc (t *Transport) Token(ctx context.Context) (string, error) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tif t.token == nil || t.token.ExpiresAt.Add(-time.Minute).Before(time.Now()) {\n\t\t// Token is not set or expired/nearly expired, so refresh\n\t\tif err := t.refreshToken(ctx); err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"could not refresh installation id %v's token: %s\", t.installationID, err)\n\t\t}\n\t}\n\n\treturn t.token.Token, nil\n}\n\n// Permissions returns a transport token's GitHub installation permissions.\nfunc (t *Transport) Permissions() (github.InstallationPermissions, error) {\n\tif t.token == nil {\n\t\treturn github.InstallationPermissions{}, fmt.Errorf(\"Permissions() = nil, err: nil token\")\n\t}\n\treturn t.token.Permissions, nil\n}\n\n// Repositories returns a transport token's GitHub repositories.\nfunc (t *Transport) Repositories() ([]github.Repository, error) {\n\tif t.token == nil {\n\t\treturn nil, fmt.Errorf(\"Repositories() = nil, err: nil token\")\n\t}\n\treturn t.token.Repositories, nil\n}\n\nfunc (t *Transport) refreshToken(ctx context.Context) error {\n\t// Convert InstallationTokenOptions into a ReadWriter to pass as an argument to http.NewRequest.\n\tbody, err := GetReadWriter(t.InstallationTokenOptions)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not convert installation token parameters into json: %s\", err)\n\t}\n\n\treq, err := http.NewRequest(\"POST\", fmt.Sprintf(\"%s/app/installations/%v/access_tokens\", t.BaseURL, t.installationID), body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not create request: %s\", err)\n\t}\n\n\t// Set Content and Accept headers.\n\tif body != nil {\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\treq.Header.Set(\"Accept\", acceptHeader)\n\n\tif ctx != nil {\n\t\treq = req.WithContext(ctx)\n\t}\n\n\tt.appsTransport.BaseURL = t.BaseURL\n\tt.appsTransport.Client = t.Client\n\tresp, err := t.appsTransport.RoundTrip(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not get access_tokens from GitHub API for installation ID %v: %v\", t.installationID, err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode/100 != 2 {\n\t\treturn fmt.Errorf(\"received non 2xx response status %q when fetching %v\", resp.Status, req.URL)\n\t}\n\n\treturn json.NewDecoder(resp.Body).Decode(&t.token)\n}\n\n// GetReadWriter converts a body interface into an io.ReadWriter object.\nfunc GetReadWriter(i interface{}) (io.ReadWriter, error) {\n\tvar buf io.ReadWriter\n\tif i != nil {\n\t\tbuf = new(bytes.Buffer)\n\t\tenc := json.NewEncoder(buf)\n\t\terr := enc.Encode(i)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn buf, nil\n}\n"], "filenames": ["transport.go"], "buggy_code_start_loc": [173], "buggy_code_end_loc": [174], "fixing_code_start_loc": [173], "fixing_code_end_loc": [174], "type": "CWE-209", "message": "ghinstallation provides transport, which implements http.RoundTripper to provide authentication as an installation for GitHub Apps. In ghinstallation version 1, when the request to refresh an installation token failed, the HTTP request and response would be returned for debugging. The request contained the bearer JWT for the App, and was returned back to clients. This token is short lived (10 minute maximum). This issue has been patched and is available in version 2.0.0.", "other": {"cve": {"id": "CVE-2022-39304", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-20T20:15:10.043", "lastModified": "2022-12-29T17:16:32.390", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ghinstallation provides transport, which implements http.RoundTripper to provide authentication as an installation for GitHub Apps. In ghinstallation version 1, when the request to refresh an installation token failed, the HTTP request and response would be returned for debugging. The request contained the bearer JWT for the App, and was returned back to clients. This token is short lived (10 minute maximum). This issue has been patched and is available in version 2.0.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:R/S:U/C:H/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 4.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-209"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ghinstallation_project:ghinstallation:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.0", "matchCriteriaId": "DBDED0BF-75D1-42F9-B5A5-D7D8A4D3A147"}]}]}], "references": [{"url": "https://docs.github.com/en/developers/apps/building-github-apps/authenticating-with-github-apps#authenticating-as-an-installation", "source": "security-advisories@github.com", "tags": ["Technical Description", "Third Party Advisory"]}, {"url": "https://github.com/bradleyfalzon/ghinstallation/blob/24e56b3fb7669f209134a01eff731d7e2ef72a5c/transport.go#L172-L174", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/bradleyfalzon/ghinstallation/commit/d24f14f8be70d94129d76026e8b0f4f9170c8c3e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bradleyfalzon/ghinstallation/security/advisories/GHSA-h4q8-96p6-jcgr", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bradleyfalzon/ghinstallation/commit/d24f14f8be70d94129d76026e8b0f4f9170c8c3e"}}