{"buggy_code": ["/* $OpenBSD: ssh-agent.c,v 1.276 2021/02/02 22:35:14 djm Exp $ */\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * The authentication agent program.\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n *\n * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#ifdef HAVE_SYS_UN_H\n# include <sys/un.h>\n#endif\n#include \"openbsd-compat/sys-queue.h\"\n\n#ifdef WITH_OPENSSL\n#include <openssl/evp.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#endif\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#endif\n#ifdef HAVE_POLL_H\n# include <poll.h>\n#endif\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n#include <unistd.h>\n#ifdef HAVE_UTIL_H\n# include <util.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfd.h\"\n#include \"compat.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"msg.h\"\n#include \"ssherr.h\"\n#include \"pathnames.h\"\n#include \"ssh-pkcs11.h\"\n#include \"sk-api.h\"\n\n#ifndef DEFAULT_ALLOWED_PROVIDERS\n# define DEFAULT_ALLOWED_PROVIDERS \"/usr/lib*/*,/usr/local/lib*/*\"\n#endif\n\n/* Maximum accepted message length */\n#define AGENT_MAX_LEN\t(256*1024)\n/* Maximum bytes to read from client socket */\n#define AGENT_RBUF_LEN\t(4096)\n\ntypedef enum {\n\tAUTH_UNUSED = 0,\n\tAUTH_SOCKET = 1,\n\tAUTH_CONNECTION = 2,\n} sock_type;\n\ntypedef struct socket_entry {\n\tint fd;\n\tsock_type type;\n\tstruct sshbuf *input;\n\tstruct sshbuf *output;\n\tstruct sshbuf *request;\n} SocketEntry;\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\ntypedef struct identity {\n\tTAILQ_ENTRY(identity) next;\n\tstruct sshkey *key;\n\tchar *comment;\n\tchar *provider;\n\ttime_t death;\n\tu_int confirm;\n\tchar *sk_provider;\n} Identity;\n\nstruct idtable {\n\tint nentries;\n\tTAILQ_HEAD(idqueue, identity) idlist;\n};\n\n/* private key table */\nstruct idtable *idtab;\n\nint max_fd = 0;\n\n/* pid of shell == parent of agent */\npid_t parent_pid = -1;\ntime_t parent_alive_interval = 0;\n\n/* pid of process for which cleanup_socket is applicable */\npid_t cleanup_pid = 0;\n\n/* pathname and directory for AUTH_SOCKET */\nchar socket_name[PATH_MAX];\nchar socket_dir[PATH_MAX];\n\n/* Pattern-list of allowed PKCS#11/Security key paths */\nstatic char *allowed_providers;\n\n/* locking */\n#define LOCK_SIZE\t32\n#define LOCK_SALT_SIZE\t16\n#define LOCK_ROUNDS\t1\nint locked = 0;\nu_char lock_pwhash[LOCK_SIZE];\nu_char lock_salt[LOCK_SALT_SIZE];\n\nextern char *__progname;\n\n/* Default lifetime in seconds (0 == forever) */\nstatic int lifetime = 0;\n\nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\n/* Refuse signing of non-SSH messages for web-origin FIDO keys */\nstatic int restrict_websafe = 1;\n\nstatic void\nclose_socket(SocketEntry *e)\n{\n\tclose(e->fd);\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n\tmemset(e, '\\0', sizeof(*e));\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n}\n\nstatic void\nidtab_init(void)\n{\n\tidtab = xcalloc(1, sizeof(*idtab));\n\tTAILQ_INIT(&idtab->idlist);\n\tidtab->nentries = 0;\n}\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id->sk_provider);\n\tfree(id);\n}\n\n/* return matching private key for given public key */\nstatic Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}\n\n/* Check confirmation of keysign request */\nstatic int\nconfirm_key(Identity *id, const char *extra)\n{\n\tchar *p;\n\tint ret = -1;\n\n\tp = sshkey_fingerprint(id->key, fingerprint_hash, SSH_FP_DEFAULT);\n\tif (p != NULL &&\n\t    ask_permission(\"Allow use of key %s?\\nKey fingerprint %s.%s%s\",\n\t    id->comment, p,\n\t    extra == NULL ? \"\" : \"\\n\", extra == NULL ? \"\" : extra))\n\t\tret = 0;\n\tfree(p);\n\n\treturn (ret);\n}\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal_fr(r, \"compose\");\n}\n\n/* send list of supported public keys to 'client' */\nstatic void\nprocess_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tdebug2_f(\"entering\");\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, idtab->nentries)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif ((r = sshkey_puts_opts(id->key, msg, SSHKEY_SERIALIZE_INFO))\n\t\t     != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n}\n\n\nstatic char *\nagent_decode_alg(struct sshkey *key, u_int flags)\n{\n\tif (key->type == KEY_RSA) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512\";\n\t} else if (key->type == KEY_RSA_CERT) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256-cert-v01@openssh.com\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512-cert-v01@openssh.com\";\n\t}\n\treturn NULL;\n}\n\n/*\n * Attempt to parse the contents of a buffer as a SSH publickey userauth\n * request, checking its contents for consistency and matching the embedded\n * key against the one that is being used for signing.\n * Note: does not modify msg buffer.\n * Optionally extract the username and session ID from the request.\n */\nstatic int\nparse_userauth_request(struct sshbuf *msg, const struct sshkey *expected_key,\n    char **userp, struct sshbuf **sess_idp)\n{\n\tstruct sshbuf *b = NULL, *sess_id = NULL;\n\tchar *user = NULL, *service = NULL, *method = NULL, *pkalg = NULL;\n\tint r;\n\tu_char t, sig_follows;\n\tstruct sshkey *mkey = NULL;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (sess_idp != NULL)\n\t\t*sess_idp = NULL;\n\tif ((b = sshbuf_fromb(msg)) == NULL)\n\t\tfatal_f(\"sshbuf_fromb\");\n\n\t/* SSH userauth request */\n\tif ((r = sshbuf_froms(b, &sess_id)) != 0)\n\t\tgoto out;\n\tif (sshbuf_len(sess_id) == 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u8(b, &t)) != 0 || /* SSH2_MSG_USERAUTH_REQUEST */\n\t    (r = sshbuf_get_cstring(b, &user, NULL)) != 0 || /* server user */\n\t    (r = sshbuf_get_cstring(b, &service, NULL)) != 0 || /* service */\n\t    (r = sshbuf_get_cstring(b, &method, NULL)) != 0 || /* method */\n\t    (r = sshbuf_get_u8(b, &sig_follows)) != 0 || /* sig-follows */\n\t    (r = sshbuf_get_cstring(b, &pkalg, NULL)) != 0 || /* alg */\n\t    (r = sshkey_froms(b, &mkey)) != 0) /* key */\n\t\tgoto out;\n\tif (t != SSH2_MSG_USERAUTH_REQUEST ||\n\t    sig_follows != 1 ||\n\t    strcmp(service, \"ssh-connection\") != 0 ||\n\t    !sshkey_equal(expected_key, mkey) ||\n\t    sshkey_type_from_name(pkalg) != expected_key->type) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (strcmp(method, \"publickey\") != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n\tdebug3_f(\"well formed userauth\");\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (sess_idp != NULL) {\n\t\t*sess_idp = sess_id;\n\t\tsess_id = NULL;\n\t}\n out:\n\tsshbuf_free(b);\n\tsshbuf_free(sess_id);\n\tfree(user);\n\tfree(service);\n\tfree(method);\n\tfree(pkalg);\n\tsshkey_free(mkey);\n\treturn r;\n}\n\n/*\n * Attempt to parse the contents of a buffer as a SSHSIG signature request.\n * Note: does not modify buffer.\n */\nstatic int\nparse_sshsig_request(struct sshbuf *msg)\n{\n\tint r;\n\tstruct sshbuf *b;\n\n\tif ((b = sshbuf_fromb(msg)) == NULL)\n\t\tfatal_f(\"sshbuf_fromb\");\n\n\tif ((r = sshbuf_cmp(b, 0, \"SSHSIG\", 6)) != 0 ||\n\t    (r = sshbuf_consume(b, 6)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, NULL, NULL)) != 0 || /* namespace */\n\t    (r = sshbuf_get_string_direct(b, NULL, NULL)) != 0 || /* reserved */\n\t    (r = sshbuf_get_cstring(b, NULL, NULL)) != 0 || /* hashalg */\n\t    (r = sshbuf_get_string_direct(b, NULL, NULL)) != 0) /* H(msg) */\n\t\tgoto out;\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n\n/*\n * This function inspects a message to be signed by a FIDO key that has a\n * web-like application string (i.e. one that does not begin with \"ssh:\".\n * It checks that the message is one of those expected for SSH operations\n * (pubkey userauth, sshsig, CA key signing) to exclude signing challenges\n * for the web.\n */\nstatic int\ncheck_websafe_message_contents(struct sshkey *key, struct sshbuf *data)\n{\n\tif (parse_userauth_request(data, key, NULL, NULL) == 0) {\n\t\tdebug_f(\"signed data matches public key userauth request\");\n\t\treturn 1;\n\t}\n\tif (parse_sshsig_request(data) == 0) {\n\t\tdebug_f(\"signed data matches SSHSIG signature request\");\n\t\treturn 1;\n\t}\n\n\t/* XXX check CA signature operation */\n\n\terror(\"web-origin key attempting to sign non-SSH message\");\n\treturn 0;\n}\n\n/* ssh2 only */\nstatic void\nprocess_sign_request2(SocketEntry *e)\n{\n\tu_char *signature = NULL;\n\tsize_t slen = 0;\n\tu_int compat = 0, flags;\n\tint r, ok = -1;\n\tchar *fp = NULL;\n\tstruct sshbuf *msg = NULL, *data = NULL;\n\tstruct sshkey *key = NULL;\n\tstruct identity *id;\n\tstruct notifier_ctx *notifier = NULL;\n\n\tdebug_f(\"entering\");\n\n\tif ((msg = sshbuf_new()) == NULL || (data = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshkey_froms(e->request, &key)) != 0 ||\n\t    (r = sshbuf_get_stringb(e->request, data)) != 0 ||\n\t    (r = sshbuf_get_u32(e->request, &flags)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tverbose_f(\"%s key not found\", sshkey_type(key));\n\t\tgoto send;\n\t}\n\tif (id->confirm && confirm_key(id, NULL) != 0) {\n\t\tverbose_f(\"user refused key\");\n\t\tgoto send;\n\t}\n\tif (sshkey_is_sk(id->key)) {\n\t\tif (strncmp(id->key->sk_application, \"ssh:\", 4) != 0 &&\n\t\t    !check_websafe_message_contents(key, data)) {\n\t\t\t/* error already logged */\n\t\t\tgoto send;\n\t\t}\n\t\tif ((id->key->sk_flags & SSH_SK_USER_PRESENCE_REQD)) {\n\t\t\tif ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,\n\t\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal_f(\"fingerprint failed\");\n\t\t\tnotifier = notify_start(0,\n\t\t\t    \"Confirm user presence for key %s %s\",\n\t\t\t    sshkey_type(id->key), fp);\n\t\t}\n\t}\n\t/* XXX support PIN required FIDO keys */\n\tif ((r = sshkey_sign(id->key, &signature, &slen,\n\t    sshbuf_ptr(data), sshbuf_len(data), agent_decode_alg(key, flags),\n\t    id->sk_provider, NULL, compat)) != 0) {\n\t\terror_fr(r, \"sshkey_sign\");\n\t\tgoto send;\n\t}\n\t/* Success */\n\tok = 0;\n send:\n\tnotify_complete(notifier, \"User presence confirmed\");\n\n\tif (ok == 0) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_SIGN_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, signature, slen)) != 0)\n\t\t\tfatal_fr(r, \"compose\");\n\t} else if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)\n\t\tfatal_fr(r, \"compose failure\");\n\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\n\tsshbuf_free(data);\n\tsshbuf_free(msg);\n\tsshkey_free(key);\n\tfree(fp);\n\tfree(signature);\n}\n\n/* shared */\nstatic void\nprocess_remove_identity(SocketEntry *e)\n{\n\tint r, success = 0;\n\tstruct sshkey *key = NULL;\n\tIdentity *id;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_froms(e->request, &key)) != 0) {\n\t\terror_fr(r, \"parse key\");\n\t\tgoto done;\n\t}\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tdebug_f(\"key not found\");\n\t\tgoto done;\n\t}\n\t/* We have this key, free it. */\n\tif (idtab->nentries < 1)\n\t\tfatal_f(\"internal error: nentries %d\", idtab->nentries);\n\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\tfree_identity(id);\n\tidtab->nentries--;\n\tsuccess = 1;\n done:\n\tsshkey_free(key);\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_all_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\n\tdebug2_f(\"entering\");\n\t/* Loop over all identities and clear the keys. */\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id;\n\t    id = TAILQ_FIRST(&idtab->idlist)) {\n\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\tfree_identity(id);\n\t}\n\n\t/* Mark that there are no identities. */\n\tidtab->nentries = 0;\n\n\t/* Send success. */\n\tsend_status(e, 1);\n}\n\n/* removes expired keys and returns number of seconds until the next expiry */\nstatic time_t\nreaper(void)\n{\n\ttime_t deadline = 0, now = monotime();\n\tIdentity *id, *nxt;\n\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\tif (id->death == 0)\n\t\t\tcontinue;\n\t\tif (now >= id->death) {\n\t\t\tdebug(\"expiring key '%s'\", id->comment);\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t} else\n\t\t\tdeadline = (deadline == 0) ? id->death :\n\t\t\t    MINIMUM(deadline, id->death);\n\t}\n\tif (deadline == 0 || deadline <= now)\n\t\treturn 0;\n\telse\n\t\treturn (deadline - now);\n}\n\nstatic int\nparse_key_constraints(struct sshbuf *m, struct sshkey *k, time_t *deathp,\n    u_int *secondsp, int *confirmp, char **sk_providerp)\n{\n\tu_char ctype;\n\tint r;\n\tu_int seconds, maxsign = 0;\n\tchar *ext_name = NULL;\n\tstruct sshbuf *b = NULL;\n\n\twhile (sshbuf_len(m)) {\n\t\tif ((r = sshbuf_get_u8(m, &ctype)) != 0) {\n\t\t\terror_fr(r, \"parse constraint type\");\n\t\t\tgoto err;\n\t\t}\n\t\tswitch (ctype) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif (*deathp != 0) {\n\t\t\t\terror_f(\"lifetime already set\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &seconds)) != 0) {\n\t\t\t\terror_fr(r, \"parse lifetime constraint\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t*deathp = monotime() + seconds;\n\t\t\t*secondsp = seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tif (*confirmp != 0) {\n\t\t\t\terror_f(\"confirm already set\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t*confirmp = 1;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_MAXSIGN:\n\t\t\tif (k == NULL) {\n\t\t\t\terror_f(\"maxsign not valid here\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (maxsign != 0) {\n\t\t\t\terror_f(\"maxsign already set\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"parse maxsign constraint\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"enable maxsign\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_EXTENSION:\n\t\t\tif ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {\n\t\t\t\terror_fr(r, \"parse constraint extension\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdebug_f(\"constraint ext %s\", ext_name);\n\t\t\tif (strcmp(ext_name, \"sk-provider@openssh.com\") == 0) {\n\t\t\t\tif (sk_providerp == NULL) {\n\t\t\t\t\terror_f(\"%s not valid here\", ext_name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (*sk_providerp != NULL) {\n\t\t\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif ((r = sshbuf_get_cstring(m,\n\t\t\t\t    sk_providerp, NULL)) != 0) {\n\t\t\t\t\terror_fr(r, \"parse %s\", ext_name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror_f(\"unsupported constraint \\\"%s\\\"\",\n\t\t\t\t    ext_name);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tfree(ext_name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror_f(\"Unknown constraint %d\", ctype);\n err:\n\t\t\tfree(ext_name);\n\t\t\tsshbuf_free(b);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* success */\n\treturn 0;\n}\n\nstatic void\nprocess_add_identity(SocketEntry *e)\n{\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tchar *fp, *comment = NULL, *sk_provider = NULL;\n\tchar canonical_provider[PATH_MAX];\n\ttime_t death = 0;\n\tu_int seconds = 0;\n\tstruct sshkey *k = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||\n\t    k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif (parse_key_constraints(e->request, k, &death, &seconds, &confirm,\n\t    &sk_provider) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tsshbuf_reset(e->request);\n\t\tgoto out;\n\t}\n\n\tif (sk_provider != NULL) {\n\t\tif (!sshkey_is_sk(k)) {\n\t\t\terror(\"Cannot add provider: %s is not an \"\n\t\t\t    \"authenticator-hosted key\", sshkey_type(k));\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(sk_provider, \"internal\") == 0) {\n\t\t\tdebug_f(\"internal provider\");\n\t\t} else {\n\t\t\tif (realpath(sk_provider, canonical_provider) == NULL) {\n\t\t\t\tverbose(\"failed provider \\\"%.100s\\\": \"\n\t\t\t\t    \"realpath: %s\", sk_provider,\n\t\t\t\t    strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(sk_provider);\n\t\t\tsk_provider = xstrdup(canonical_provider);\n\t\t\tif (match_pattern_list(sk_provider,\n\t\t\t    allowed_providers, 0) != 1) {\n\t\t\t\terror(\"Refusing add key: \"\n\t\t\t\t    \"provider %s not allowed\", sk_provider);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif ((r = sshkey_shield_private(k)) != 0) {\n\t\terror_fr(r, \"shield private\");\n\t\tgoto out;\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t/* Increment the number of identities. */\n\t\tidtab->nentries++;\n\t} else {\n\t\t/* key state might have been updated */\n\t\tsshkey_free(id->key);\n\t\tfree(id->comment);\n\t\tfree(id->sk_provider);\n\t}\n\t/* success */\n\tid->key = k;\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\n\tid->sk_provider = sk_provider;\n\n\tif ((fp = sshkey_fingerprint(k, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"sshkey_fingerprint failed\");\n\tdebug_f(\"add %s %s \\\"%.100s\\\" (life: %u) (confirm: %u) \"\n\t    \"(provider: %s)\", sshkey_ssh_name(k), fp, comment, seconds,\n\t    confirm, sk_provider == NULL ? \"none\" : sk_provider);\n\tfree(fp);\n\t/* transferred */\n\tk = NULL;\n\tcomment = NULL;\n\tsk_provider = NULL;\n\tsuccess = 1;\n out:\n\tfree(sk_provider);\n\tfree(comment);\n\tsshkey_free(k);\n\tsend_status(e, success);\n}\n\n/* XXX todo: encrypt sensitive data with passphrase */\nstatic void\nprocess_lock_agent(SocketEntry *e, int lock)\n{\n\tint r, success = 0, delay;\n\tchar *passwd;\n\tu_char passwdhash[LOCK_SIZE];\n\tstatic u_int fail_count = 0;\n\tsize_t pwlen;\n\n\tdebug2_f(\"entering\");\n\t/*\n\t * This is deliberately fatal: the user has requested that we lock,\n\t * but we can't parse their request properly. The only safe thing to\n\t * do is abort.\n\t */\n\tif ((r = sshbuf_get_cstring(e->request, &passwd, &pwlen)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (pwlen == 0) {\n\t\tdebug(\"empty password not supported\");\n\t} else if (locked && !lock) {\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    passwdhash, sizeof(passwdhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tif (timingsafe_bcmp(passwdhash, lock_pwhash, LOCK_SIZE) == 0) {\n\t\t\tdebug(\"agent unlocked\");\n\t\t\tlocked = 0;\n\t\t\tfail_count = 0;\n\t\t\texplicit_bzero(lock_pwhash, sizeof(lock_pwhash));\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* delay in 0.1s increments up to 10s */\n\t\t\tif (fail_count < 100)\n\t\t\t\tfail_count++;\n\t\t\tdelay = 100000 * fail_count;\n\t\t\tdebug(\"unlock failed, delaying %0.1lf seconds\",\n\t\t\t    (double)delay/1000000);\n\t\t\tusleep(delay);\n\t\t}\n\t\texplicit_bzero(passwdhash, sizeof(passwdhash));\n\t} else if (!locked && lock) {\n\t\tdebug(\"agent locked\");\n\t\tlocked = 1;\n\t\tarc4random_buf(lock_salt, sizeof(lock_salt));\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    lock_pwhash, sizeof(lock_pwhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tsuccess = 1;\n\t}\n\tfreezero(passwd, pwlen);\n\tsend_status(e, success);\n}\n\nstatic void\nno_identities(SocketEntry *e)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0 ||\n\t    (r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsshbuf_free(msg);\n}\n\n#ifdef ENABLE_PKCS11\nstatic void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tchar **comments = NULL;\n\tint r, i, count = 0, success = 0, confirm = 0;\n\tu_int seconds = 0;\n\ttime_t death = 0;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tif (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm,\n\t    NULL) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tgoto send;\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, allowed_providers, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not allowed\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug_f(\"add %.100s\", canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys, &comments);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tif (lookup_identity(k) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tkeys[i] = NULL; /* transferred */\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tif (*comments[i] != '\\0') {\n\t\t\t\tid->comment = comments[i];\n\t\t\t\tcomments[i] = NULL; /* transferred */\n\t\t\t} else {\n\t\t\t\tid->comment = xstrdup(canonical_provider);\n\t\t\t}\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t}\n\t\t/* XXX update constraints for existing keys */\n\t\tsshkey_free(keys[i]);\n\t\tfree(comments[i]);\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tfree(comments);\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tint r, success = 0;\n\tIdentity *id, *nxt;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tfree(pin);\n\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\n\tdebug_f(\"remove %.100s\", canonical_provider);\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\t/* Skip file--based keys */\n\t\tif (id->provider == NULL)\n\t\t\tcontinue;\n\t\tif (!strcmp(canonical_provider, id->provider)) {\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t}\n\t}\n\tif (pkcs11_del_provider(canonical_provider) == 0)\n\t\tsuccess = 1;\n\telse\n\t\terror_f(\"pkcs11_del_provider failed\");\nsend:\n\tfree(provider);\n\tsend_status(e, success);\n}\n#endif /* ENABLE_PKCS11 */\n\n/*\n * dispatch incoming message.\n * returns 1 on success, 0 for incomplete messages or -1 on error.\n */\nstatic int\nprocess_message(u_int socknum)\n{\n\tu_int msg_len;\n\tu_char type;\n\tconst u_char *cp;\n\tint r;\n\tSocketEntry *e;\n\n\tif (socknum >= sockets_alloc)\n\t\tfatal_f(\"sock %u >= allocated %u\", socknum, sockets_alloc);\n\te = &sockets[socknum];\n\n\tif (sshbuf_len(e->input) < 5)\n\t\treturn 0;\t\t/* Incomplete message header. */\n\tcp = sshbuf_ptr(e->input);\n\tmsg_len = PEEK_U32(cp);\n\tif (msg_len > AGENT_MAX_LEN) {\n\t\tdebug_f(\"socket %u (fd=%d) message too long %u > %u\",\n\t\t    socknum, e->fd, msg_len, AGENT_MAX_LEN);\n\t\treturn -1;\n\t}\n\tif (sshbuf_len(e->input) < msg_len + 4)\n\t\treturn 0;\t\t/* Incomplete message body. */\n\n\t/* move the current input to e->request */\n\tsshbuf_reset(e->request);\n\tif ((r = sshbuf_get_stringb(e->input, e->request)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &type)) != 0) {\n\t\tif (r == SSH_ERR_MESSAGE_INCOMPLETE ||\n\t\t    r == SSH_ERR_STRING_TOO_LARGE) {\n\t\t\terror_fr(r, \"parse\");\n\t\t\treturn -1;\n\t\t}\n\t\tfatal_fr(r, \"parse\");\n\t}\n\n\tdebug_f(\"socket %u (fd=%d) type %d\", socknum, e->fd, type);\n\n\t/* check whether agent is locked */\n\tif (locked && type != SSH_AGENTC_UNLOCK) {\n\t\tsshbuf_reset(e->request);\n\t\tswitch (type) {\n\t\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\t\t/* send empty lists */\n\t\t\tno_identities(e);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* send a fail message for all other request types */\n\t\t\tsend_status(e, 0);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase SSH_AGENTC_LOCK:\n\tcase SSH_AGENTC_UNLOCK:\n\t\tprocess_lock_agent(e, type == SSH_AGENTC_LOCK);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:\n\t\tprocess_remove_all_identities(e); /* safe for !WITH_SSH1 */\n\t\tbreak;\n\t/* ssh2 */\n\tcase SSH2_AGENTC_SIGN_REQUEST:\n\t\tprocess_sign_request2(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\tprocess_request_identities(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_ADD_IDENTITY:\n\tcase SSH2_AGENTC_ADD_ID_CONSTRAINED:\n\t\tprocess_add_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_IDENTITY:\n\t\tprocess_remove_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_ALL_IDENTITIES:\n\t\tprocess_remove_all_identities(e);\n\t\tbreak;\n#ifdef ENABLE_PKCS11\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY:\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:\n\t\tprocess_add_smartcard_key(e);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_SMARTCARD_KEY:\n\t\tprocess_remove_smartcard_key(e);\n\t\tbreak;\n#endif /* ENABLE_PKCS11 */\n\tdefault:\n\t\t/* Unknown message.  Respond with failure. */\n\t\terror(\"Unknown message %d\", type);\n\t\tsshbuf_reset(e->request);\n\t\tsend_status(e, 0);\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\nstatic void\nnew_socket(sock_type type, int fd)\n{\n\tu_int i, old_alloc, new_alloc;\n\n\tdebug_f(\"type = %s\", type == AUTH_CONNECTION ? \"CONNECTION\" :\n\t    (type == AUTH_SOCKET ? \"SOCKET\" : \"UNKNOWN\"));\n\tset_nonblock(fd);\n\n\tif (fd > max_fd)\n\t\tmax_fd = fd;\n\n\tfor (i = 0; i < sockets_alloc; i++)\n\t\tif (sockets[i].type == AUTH_UNUSED) {\n\t\t\tsockets[i].fd = fd;\n\t\t\tif ((sockets[i].input = sshbuf_new()) == NULL ||\n\t\t\t    (sockets[i].output = sshbuf_new()) == NULL ||\n\t\t\t    (sockets[i].request = sshbuf_new()) == NULL)\n\t\t\t\tfatal_f(\"sshbuf_new failed\");\n\t\t\tsockets[i].type = type;\n\t\t\treturn;\n\t\t}\n\told_alloc = sockets_alloc;\n\tnew_alloc = sockets_alloc + 10;\n\tsockets = xrecallocarray(sockets, old_alloc, new_alloc,\n\t    sizeof(sockets[0]));\n\tfor (i = old_alloc; i < new_alloc; i++)\n\t\tsockets[i].type = AUTH_UNUSED;\n\tsockets_alloc = new_alloc;\n\tsockets[old_alloc].fd = fd;\n\tif ((sockets[old_alloc].input = sshbuf_new()) == NULL ||\n\t    (sockets[old_alloc].output = sshbuf_new()) == NULL ||\n\t    (sockets[old_alloc].request = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tsockets[old_alloc].type = type;\n}\n\nstatic int\nhandle_socket_read(u_int socknum)\n{\n\tstruct sockaddr_un sunaddr;\n\tsocklen_t slen;\n\tuid_t euid;\n\tgid_t egid;\n\tint fd;\n\n\tslen = sizeof(sunaddr);\n\tfd = accept(sockets[socknum].fd, (struct sockaddr *)&sunaddr, &slen);\n\tif (fd == -1) {\n\t\terror(\"accept from AUTH_SOCKET: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getpeereid(fd, &euid, &egid) == -1) {\n\t\terror(\"getpeereid %d failed: %s\", fd, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif ((euid != 0) && (getuid() != euid)) {\n\t\terror(\"uid mismatch: peer euid %u != uid %u\",\n\t\t    (u_int) euid, (u_int) getuid());\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tnew_socket(AUTH_CONNECTION, fd);\n\treturn 0;\n}\n\nstatic int\nhandle_conn_read(u_int socknum)\n{\n\tchar buf[AGENT_RBUF_LEN];\n\tssize_t len;\n\tint r;\n\n\tif ((len = read(sockets[socknum].fd, buf, sizeof(buf))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror_f(\"read error on socket %u (fd %d): %s\",\n\t\t\t    socknum, sockets[socknum].fd, strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_put(sockets[socknum].input, buf, len)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\texplicit_bzero(buf, sizeof(buf));\n\tfor (;;) {\n\t\tif ((r = process_message(socknum)) == -1)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int\nhandle_conn_write(u_int socknum)\n{\n\tssize_t len;\n\tint r;\n\n\tif (sshbuf_len(sockets[socknum].output) == 0)\n\t\treturn 0; /* shouldn't happen */\n\tif ((len = write(sockets[socknum].fd,\n\t    sshbuf_ptr(sockets[socknum].output),\n\t    sshbuf_len(sockets[socknum].output))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror_f(\"read error on socket %u (fd %d): %s\",\n\t\t\t    socknum, sockets[socknum].fd, strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_consume(sockets[socknum].output, len)) != 0)\n\t\tfatal_fr(r, \"consume\");\n\treturn 0;\n}\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror_f(\"no socket for fd %d\", pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int\nprepare_poll(struct pollfd **pfdp, size_t *npfdp, int *timeoutp, u_int maxfds)\n{\n\tstruct pollfd *pfd = *pfdp;\n\tsize_t i, j, npfd = 0;\n\ttime_t deadline;\n\tint r;\n\n\t/* Count active sockets */\n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\tcase AUTH_CONNECTION:\n\t\t\tnpfd++;\n\t\t\tbreak;\n\t\tcase AUTH_UNUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Unknown socket type %d\", sockets[i].type);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (npfd != *npfdp &&\n\t    (pfd = recallocarray(pfd, *npfdp, npfd, sizeof(*pfd))) == NULL)\n\t\tfatal_f(\"recallocarray failed\");\n\t*pfdp = pfd;\n\t*npfdp = npfd;\n\n\tfor (i = j = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %zu >= limit %u); \"\n\t\t\t\t    \"skipping arming listener\", npfd, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\tpfd[j].events = POLLIN;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\t/*\n\t\t\t * Only prepare to read if we can handle a full-size\n\t\t\t * input read buffer and enqueue a max size reply..\n\t\t\t */\n\t\t\tif ((r = sshbuf_check_reserve(sockets[i].input,\n\t\t\t    AGENT_RBUF_LEN)) == 0 &&\n\t\t\t    (r = sshbuf_check_reserve(sockets[i].output,\n\t\t\t     AGENT_MAX_LEN)) == 0)\n\t\t\t\tpfd[j].events = POLLIN;\n\t\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\t\tfatal_fr(r, \"reserve\");\n\t\t\tif (sshbuf_len(sockets[i].output) > 0)\n\t\t\t\tpfd[j].events |= POLLOUT;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdeadline = reaper();\n\tif (parent_alive_interval != 0)\n\t\tdeadline = (deadline == 0) ? parent_alive_interval :\n\t\t    MINIMUM(deadline, parent_alive_interval);\n\tif (deadline == 0) {\n\t\t*timeoutp = -1; /* INFTIM */\n\t} else {\n\t\tif (deadline > INT_MAX / 1000)\n\t\t\t*timeoutp = INT_MAX / 1000;\n\t\telse\n\t\t\t*timeoutp = deadline * 1000;\n\t}\n\treturn (1);\n}\n\nstatic void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug_f(\"cleanup\");\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}\n\nvoid\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}\n\n/*ARGSUSED*/\nstatic void\ncleanup_handler(int sig)\n{\n\tcleanup_socket();\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\t_exit(2);\n}\n\nstatic void\ncheck_parent_exists(void)\n{\n\t/*\n\t * If our parent has exited then getppid() will return (pid_t)1,\n\t * so testing for that should be safe.\n\t */\n\tif (parent_pid != -1 && getppid() != parent_pid) {\n\t\t/* printf(\"Parent has died - Authentication agent exiting.\\n\"); */\n\t\tcleanup_socket();\n\t\t_exit(2);\n\t}\n}\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-P allowed_providers] [-t life]\\n\"\n\t    \"       ssh-agent [-a bind_address] [-E fingerprint_hash] [-P allowed_providers]\\n\"\n\t    \"                 [-t life] command [arg ...]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}\n\nint\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, ch, result, saved_errno;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n#ifdef HAVE_SETRLIMIT\n\tstruct rlimit rlim;\n#endif\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tsize_t len;\n\tmode_t prev_mask;\n\tint timeout = -1; /* INFTIM */\n\tstruct pollfd *pfd = NULL;\n\tsize_t npfd = 0;\n\tu_int maxfds;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\tsetegid(getgid());\n\tsetgid(getgid());\n\n\tplatform_disable_tracing(0);\t/* strict=no */\n\n#ifdef RLIMIT_NOFILE\n\tif (getrlimit(RLIMIT_NOFILE, &rlim) == -1)\n\t\tfatal(\"%s: getrlimit: %s\", __progname, strerror(errno));\n#endif\n\n\t__progname = ssh_get_progname(av[0]);\n\tseed_rng();\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:O:P:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (strcmp(optarg, \"no-restrict-websafe\") == 0)\n\t\t\t\trestrict_websafe  = 0;\n\t\t\telse\n\t\t\t\tfatal(\"Unknown -O option\");\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (allowed_providers != NULL)\n\t\t\t\tfatal(\"-P option already specified\");\n\t\t\tallowed_providers = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (allowed_providers == NULL)\n\t\tallowed_providers = xstrdup(DEFAULT_ALLOWED_PROVIDERS);\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\n\t/*\n\t * Minimum file descriptors:\n\t * stdio (3) + listener (1) + syslog (1 maybe) + connection (1) +\n\t * a few spare for libc / stack protectors / sanitisers, etc.\n\t */\n#define SSH_AGENT_MIN_FDS (3+1+1+1+4)\n\tif (rlim.rlim_cur < SSH_AGENT_MIN_FDS)\n\t\tfatal(\"%s: file descriptor rlimit %lld too low (minimum %u)\",\n\t\t    __progname, (long long)rlim.rlim_cur, SSH_AGENT_MIN_FDS);\n\tmaxfds = rlim.rlim_cur - SSH_AGENT_MIN_FDS;\n\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif (stdfd_devnull(1, 1, 1) == -1)\n\t\terror_f(\"stdfd_devnull failed\");\n\n#ifdef HAVE_SETRLIMIT\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) == -1) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n#endif\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tssh_signal(SIGPIPE, SIG_IGN);\n\tssh_signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tssh_signal(SIGHUP, cleanup_handler);\n\tssh_signal(SIGTERM, cleanup_handler);\n\n\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\tplatform_pledge_agent();\n\n\twhile (1) {\n\t\tprepare_poll(&pfd, &npfd, &timeout, maxfds);\n\t\tresult = poll(pfd, npfd, timeout);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result == -1) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"poll: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_poll(pfd, npfd, maxfds);\n\t}\n\t/* NOTREACHED */\n}\n"], "fixing_code": ["/* $OpenBSD: ssh-agent.c,v 1.277 2021/02/12 03:14:18 djm Exp $ */\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * The authentication agent program.\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n *\n * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#ifdef HAVE_SYS_UN_H\n# include <sys/un.h>\n#endif\n#include \"openbsd-compat/sys-queue.h\"\n\n#ifdef WITH_OPENSSL\n#include <openssl/evp.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#endif\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#endif\n#ifdef HAVE_POLL_H\n# include <poll.h>\n#endif\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n#include <unistd.h>\n#ifdef HAVE_UTIL_H\n# include <util.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfd.h\"\n#include \"compat.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"msg.h\"\n#include \"ssherr.h\"\n#include \"pathnames.h\"\n#include \"ssh-pkcs11.h\"\n#include \"sk-api.h\"\n\n#ifndef DEFAULT_ALLOWED_PROVIDERS\n# define DEFAULT_ALLOWED_PROVIDERS \"/usr/lib*/*,/usr/local/lib*/*\"\n#endif\n\n/* Maximum accepted message length */\n#define AGENT_MAX_LEN\t(256*1024)\n/* Maximum bytes to read from client socket */\n#define AGENT_RBUF_LEN\t(4096)\n\ntypedef enum {\n\tAUTH_UNUSED = 0,\n\tAUTH_SOCKET = 1,\n\tAUTH_CONNECTION = 2,\n} sock_type;\n\ntypedef struct socket_entry {\n\tint fd;\n\tsock_type type;\n\tstruct sshbuf *input;\n\tstruct sshbuf *output;\n\tstruct sshbuf *request;\n} SocketEntry;\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\ntypedef struct identity {\n\tTAILQ_ENTRY(identity) next;\n\tstruct sshkey *key;\n\tchar *comment;\n\tchar *provider;\n\ttime_t death;\n\tu_int confirm;\n\tchar *sk_provider;\n} Identity;\n\nstruct idtable {\n\tint nentries;\n\tTAILQ_HEAD(idqueue, identity) idlist;\n};\n\n/* private key table */\nstruct idtable *idtab;\n\nint max_fd = 0;\n\n/* pid of shell == parent of agent */\npid_t parent_pid = -1;\ntime_t parent_alive_interval = 0;\n\n/* pid of process for which cleanup_socket is applicable */\npid_t cleanup_pid = 0;\n\n/* pathname and directory for AUTH_SOCKET */\nchar socket_name[PATH_MAX];\nchar socket_dir[PATH_MAX];\n\n/* Pattern-list of allowed PKCS#11/Security key paths */\nstatic char *allowed_providers;\n\n/* locking */\n#define LOCK_SIZE\t32\n#define LOCK_SALT_SIZE\t16\n#define LOCK_ROUNDS\t1\nint locked = 0;\nu_char lock_pwhash[LOCK_SIZE];\nu_char lock_salt[LOCK_SALT_SIZE];\n\nextern char *__progname;\n\n/* Default lifetime in seconds (0 == forever) */\nstatic int lifetime = 0;\n\nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\n/* Refuse signing of non-SSH messages for web-origin FIDO keys */\nstatic int restrict_websafe = 1;\n\nstatic void\nclose_socket(SocketEntry *e)\n{\n\tclose(e->fd);\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n\tmemset(e, '\\0', sizeof(*e));\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n}\n\nstatic void\nidtab_init(void)\n{\n\tidtab = xcalloc(1, sizeof(*idtab));\n\tTAILQ_INIT(&idtab->idlist);\n\tidtab->nentries = 0;\n}\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id->sk_provider);\n\tfree(id);\n}\n\n/* return matching private key for given public key */\nstatic Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}\n\n/* Check confirmation of keysign request */\nstatic int\nconfirm_key(Identity *id, const char *extra)\n{\n\tchar *p;\n\tint ret = -1;\n\n\tp = sshkey_fingerprint(id->key, fingerprint_hash, SSH_FP_DEFAULT);\n\tif (p != NULL &&\n\t    ask_permission(\"Allow use of key %s?\\nKey fingerprint %s.%s%s\",\n\t    id->comment, p,\n\t    extra == NULL ? \"\" : \"\\n\", extra == NULL ? \"\" : extra))\n\t\tret = 0;\n\tfree(p);\n\n\treturn (ret);\n}\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal_fr(r, \"compose\");\n}\n\n/* send list of supported public keys to 'client' */\nstatic void\nprocess_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tdebug2_f(\"entering\");\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, idtab->nentries)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif ((r = sshkey_puts_opts(id->key, msg, SSHKEY_SERIALIZE_INFO))\n\t\t     != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n}\n\n\nstatic char *\nagent_decode_alg(struct sshkey *key, u_int flags)\n{\n\tif (key->type == KEY_RSA) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512\";\n\t} else if (key->type == KEY_RSA_CERT) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256-cert-v01@openssh.com\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512-cert-v01@openssh.com\";\n\t}\n\treturn NULL;\n}\n\n/*\n * Attempt to parse the contents of a buffer as a SSH publickey userauth\n * request, checking its contents for consistency and matching the embedded\n * key against the one that is being used for signing.\n * Note: does not modify msg buffer.\n * Optionally extract the username and session ID from the request.\n */\nstatic int\nparse_userauth_request(struct sshbuf *msg, const struct sshkey *expected_key,\n    char **userp, struct sshbuf **sess_idp)\n{\n\tstruct sshbuf *b = NULL, *sess_id = NULL;\n\tchar *user = NULL, *service = NULL, *method = NULL, *pkalg = NULL;\n\tint r;\n\tu_char t, sig_follows;\n\tstruct sshkey *mkey = NULL;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (sess_idp != NULL)\n\t\t*sess_idp = NULL;\n\tif ((b = sshbuf_fromb(msg)) == NULL)\n\t\tfatal_f(\"sshbuf_fromb\");\n\n\t/* SSH userauth request */\n\tif ((r = sshbuf_froms(b, &sess_id)) != 0)\n\t\tgoto out;\n\tif (sshbuf_len(sess_id) == 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u8(b, &t)) != 0 || /* SSH2_MSG_USERAUTH_REQUEST */\n\t    (r = sshbuf_get_cstring(b, &user, NULL)) != 0 || /* server user */\n\t    (r = sshbuf_get_cstring(b, &service, NULL)) != 0 || /* service */\n\t    (r = sshbuf_get_cstring(b, &method, NULL)) != 0 || /* method */\n\t    (r = sshbuf_get_u8(b, &sig_follows)) != 0 || /* sig-follows */\n\t    (r = sshbuf_get_cstring(b, &pkalg, NULL)) != 0 || /* alg */\n\t    (r = sshkey_froms(b, &mkey)) != 0) /* key */\n\t\tgoto out;\n\tif (t != SSH2_MSG_USERAUTH_REQUEST ||\n\t    sig_follows != 1 ||\n\t    strcmp(service, \"ssh-connection\") != 0 ||\n\t    !sshkey_equal(expected_key, mkey) ||\n\t    sshkey_type_from_name(pkalg) != expected_key->type) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (strcmp(method, \"publickey\") != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n\tdebug3_f(\"well formed userauth\");\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (sess_idp != NULL) {\n\t\t*sess_idp = sess_id;\n\t\tsess_id = NULL;\n\t}\n out:\n\tsshbuf_free(b);\n\tsshbuf_free(sess_id);\n\tfree(user);\n\tfree(service);\n\tfree(method);\n\tfree(pkalg);\n\tsshkey_free(mkey);\n\treturn r;\n}\n\n/*\n * Attempt to parse the contents of a buffer as a SSHSIG signature request.\n * Note: does not modify buffer.\n */\nstatic int\nparse_sshsig_request(struct sshbuf *msg)\n{\n\tint r;\n\tstruct sshbuf *b;\n\n\tif ((b = sshbuf_fromb(msg)) == NULL)\n\t\tfatal_f(\"sshbuf_fromb\");\n\n\tif ((r = sshbuf_cmp(b, 0, \"SSHSIG\", 6)) != 0 ||\n\t    (r = sshbuf_consume(b, 6)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, NULL, NULL)) != 0 || /* namespace */\n\t    (r = sshbuf_get_string_direct(b, NULL, NULL)) != 0 || /* reserved */\n\t    (r = sshbuf_get_cstring(b, NULL, NULL)) != 0 || /* hashalg */\n\t    (r = sshbuf_get_string_direct(b, NULL, NULL)) != 0) /* H(msg) */\n\t\tgoto out;\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n\n/*\n * This function inspects a message to be signed by a FIDO key that has a\n * web-like application string (i.e. one that does not begin with \"ssh:\".\n * It checks that the message is one of those expected for SSH operations\n * (pubkey userauth, sshsig, CA key signing) to exclude signing challenges\n * for the web.\n */\nstatic int\ncheck_websafe_message_contents(struct sshkey *key, struct sshbuf *data)\n{\n\tif (parse_userauth_request(data, key, NULL, NULL) == 0) {\n\t\tdebug_f(\"signed data matches public key userauth request\");\n\t\treturn 1;\n\t}\n\tif (parse_sshsig_request(data) == 0) {\n\t\tdebug_f(\"signed data matches SSHSIG signature request\");\n\t\treturn 1;\n\t}\n\n\t/* XXX check CA signature operation */\n\n\terror(\"web-origin key attempting to sign non-SSH message\");\n\treturn 0;\n}\n\n/* ssh2 only */\nstatic void\nprocess_sign_request2(SocketEntry *e)\n{\n\tu_char *signature = NULL;\n\tsize_t slen = 0;\n\tu_int compat = 0, flags;\n\tint r, ok = -1;\n\tchar *fp = NULL;\n\tstruct sshbuf *msg = NULL, *data = NULL;\n\tstruct sshkey *key = NULL;\n\tstruct identity *id;\n\tstruct notifier_ctx *notifier = NULL;\n\n\tdebug_f(\"entering\");\n\n\tif ((msg = sshbuf_new()) == NULL || (data = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshkey_froms(e->request, &key)) != 0 ||\n\t    (r = sshbuf_get_stringb(e->request, data)) != 0 ||\n\t    (r = sshbuf_get_u32(e->request, &flags)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tverbose_f(\"%s key not found\", sshkey_type(key));\n\t\tgoto send;\n\t}\n\tif (id->confirm && confirm_key(id, NULL) != 0) {\n\t\tverbose_f(\"user refused key\");\n\t\tgoto send;\n\t}\n\tif (sshkey_is_sk(id->key)) {\n\t\tif (strncmp(id->key->sk_application, \"ssh:\", 4) != 0 &&\n\t\t    !check_websafe_message_contents(key, data)) {\n\t\t\t/* error already logged */\n\t\t\tgoto send;\n\t\t}\n\t\tif ((id->key->sk_flags & SSH_SK_USER_PRESENCE_REQD)) {\n\t\t\tif ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,\n\t\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal_f(\"fingerprint failed\");\n\t\t\tnotifier = notify_start(0,\n\t\t\t    \"Confirm user presence for key %s %s\",\n\t\t\t    sshkey_type(id->key), fp);\n\t\t}\n\t}\n\t/* XXX support PIN required FIDO keys */\n\tif ((r = sshkey_sign(id->key, &signature, &slen,\n\t    sshbuf_ptr(data), sshbuf_len(data), agent_decode_alg(key, flags),\n\t    id->sk_provider, NULL, compat)) != 0) {\n\t\terror_fr(r, \"sshkey_sign\");\n\t\tgoto send;\n\t}\n\t/* Success */\n\tok = 0;\n send:\n\tnotify_complete(notifier, \"User presence confirmed\");\n\n\tif (ok == 0) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_SIGN_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, signature, slen)) != 0)\n\t\t\tfatal_fr(r, \"compose\");\n\t} else if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)\n\t\tfatal_fr(r, \"compose failure\");\n\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\n\tsshbuf_free(data);\n\tsshbuf_free(msg);\n\tsshkey_free(key);\n\tfree(fp);\n\tfree(signature);\n}\n\n/* shared */\nstatic void\nprocess_remove_identity(SocketEntry *e)\n{\n\tint r, success = 0;\n\tstruct sshkey *key = NULL;\n\tIdentity *id;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_froms(e->request, &key)) != 0) {\n\t\terror_fr(r, \"parse key\");\n\t\tgoto done;\n\t}\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tdebug_f(\"key not found\");\n\t\tgoto done;\n\t}\n\t/* We have this key, free it. */\n\tif (idtab->nentries < 1)\n\t\tfatal_f(\"internal error: nentries %d\", idtab->nentries);\n\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\tfree_identity(id);\n\tidtab->nentries--;\n\tsuccess = 1;\n done:\n\tsshkey_free(key);\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_all_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\n\tdebug2_f(\"entering\");\n\t/* Loop over all identities and clear the keys. */\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id;\n\t    id = TAILQ_FIRST(&idtab->idlist)) {\n\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\tfree_identity(id);\n\t}\n\n\t/* Mark that there are no identities. */\n\tidtab->nentries = 0;\n\n\t/* Send success. */\n\tsend_status(e, 1);\n}\n\n/* removes expired keys and returns number of seconds until the next expiry */\nstatic time_t\nreaper(void)\n{\n\ttime_t deadline = 0, now = monotime();\n\tIdentity *id, *nxt;\n\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\tif (id->death == 0)\n\t\t\tcontinue;\n\t\tif (now >= id->death) {\n\t\t\tdebug(\"expiring key '%s'\", id->comment);\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t} else\n\t\t\tdeadline = (deadline == 0) ? id->death :\n\t\t\t    MINIMUM(deadline, id->death);\n\t}\n\tif (deadline == 0 || deadline <= now)\n\t\treturn 0;\n\telse\n\t\treturn (deadline - now);\n}\n\nstatic int\nparse_key_constraint_extension(struct sshbuf *m, char **sk_providerp)\n{\n\tchar *ext_name = NULL;\n\tint r;\n\n\tif ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {\n\t\terror_fr(r, \"parse constraint extension\");\n\t\tgoto out;\n\t}\n\tdebug_f(\"constraint ext %s\", ext_name);\n\tif (strcmp(ext_name, \"sk-provider@openssh.com\") == 0) {\n\t\tif (sk_providerp == NULL) {\n\t\t\terror_f(\"%s not valid here\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (*sk_providerp != NULL) {\n\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(m, sk_providerp, NULL)) != 0) {\n\t\t\terror_fr(r, \"parse %s\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terror_f(\"unsupported constraint \\\"%s\\\"\", ext_name);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n out:\n\tfree(ext_name);\n\treturn r;\n}\n\nstatic int\nparse_key_constraints(struct sshbuf *m, struct sshkey *k, time_t *deathp,\n    u_int *secondsp, int *confirmp, char **sk_providerp)\n{\n\tu_char ctype;\n\tint r;\n\tu_int seconds, maxsign = 0;\n\n\twhile (sshbuf_len(m)) {\n\t\tif ((r = sshbuf_get_u8(m, &ctype)) != 0) {\n\t\t\terror_fr(r, \"parse constraint type\");\n\t\t\tgoto out;\n\t\t}\n\t\tswitch (ctype) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif (*deathp != 0) {\n\t\t\t\terror_f(\"lifetime already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &seconds)) != 0) {\n\t\t\t\terror_fr(r, \"parse lifetime constraint\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*deathp = monotime() + seconds;\n\t\t\t*secondsp = seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tif (*confirmp != 0) {\n\t\t\t\terror_f(\"confirm already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*confirmp = 1;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_MAXSIGN:\n\t\t\tif (k == NULL) {\n\t\t\t\terror_f(\"maxsign not valid here\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (maxsign != 0) {\n\t\t\t\terror_f(\"maxsign already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"parse maxsign constraint\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"enable maxsign\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_EXTENSION:\n\t\t\tif ((r = parse_key_constraint_extension(m,\n\t\t\t    sk_providerp)) != 0)\n\t\t\t\tgoto out; /* error already logged */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror_f(\"Unknown constraint %d\", ctype);\n\t\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}\n\nstatic void\nprocess_add_identity(SocketEntry *e)\n{\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tchar *fp, *comment = NULL, *sk_provider = NULL;\n\tchar canonical_provider[PATH_MAX];\n\ttime_t death = 0;\n\tu_int seconds = 0;\n\tstruct sshkey *k = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||\n\t    k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif (parse_key_constraints(e->request, k, &death, &seconds, &confirm,\n\t    &sk_provider) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tsshbuf_reset(e->request);\n\t\tgoto out;\n\t}\n\n\tif (sk_provider != NULL) {\n\t\tif (!sshkey_is_sk(k)) {\n\t\t\terror(\"Cannot add provider: %s is not an \"\n\t\t\t    \"authenticator-hosted key\", sshkey_type(k));\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(sk_provider, \"internal\") == 0) {\n\t\t\tdebug_f(\"internal provider\");\n\t\t} else {\n\t\t\tif (realpath(sk_provider, canonical_provider) == NULL) {\n\t\t\t\tverbose(\"failed provider \\\"%.100s\\\": \"\n\t\t\t\t    \"realpath: %s\", sk_provider,\n\t\t\t\t    strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(sk_provider);\n\t\t\tsk_provider = xstrdup(canonical_provider);\n\t\t\tif (match_pattern_list(sk_provider,\n\t\t\t    allowed_providers, 0) != 1) {\n\t\t\t\terror(\"Refusing add key: \"\n\t\t\t\t    \"provider %s not allowed\", sk_provider);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif ((r = sshkey_shield_private(k)) != 0) {\n\t\terror_fr(r, \"shield private\");\n\t\tgoto out;\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t/* Increment the number of identities. */\n\t\tidtab->nentries++;\n\t} else {\n\t\t/* key state might have been updated */\n\t\tsshkey_free(id->key);\n\t\tfree(id->comment);\n\t\tfree(id->sk_provider);\n\t}\n\t/* success */\n\tid->key = k;\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\n\tid->sk_provider = sk_provider;\n\n\tif ((fp = sshkey_fingerprint(k, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"sshkey_fingerprint failed\");\n\tdebug_f(\"add %s %s \\\"%.100s\\\" (life: %u) (confirm: %u) \"\n\t    \"(provider: %s)\", sshkey_ssh_name(k), fp, comment, seconds,\n\t    confirm, sk_provider == NULL ? \"none\" : sk_provider);\n\tfree(fp);\n\t/* transferred */\n\tk = NULL;\n\tcomment = NULL;\n\tsk_provider = NULL;\n\tsuccess = 1;\n out:\n\tfree(sk_provider);\n\tfree(comment);\n\tsshkey_free(k);\n\tsend_status(e, success);\n}\n\n/* XXX todo: encrypt sensitive data with passphrase */\nstatic void\nprocess_lock_agent(SocketEntry *e, int lock)\n{\n\tint r, success = 0, delay;\n\tchar *passwd;\n\tu_char passwdhash[LOCK_SIZE];\n\tstatic u_int fail_count = 0;\n\tsize_t pwlen;\n\n\tdebug2_f(\"entering\");\n\t/*\n\t * This is deliberately fatal: the user has requested that we lock,\n\t * but we can't parse their request properly. The only safe thing to\n\t * do is abort.\n\t */\n\tif ((r = sshbuf_get_cstring(e->request, &passwd, &pwlen)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (pwlen == 0) {\n\t\tdebug(\"empty password not supported\");\n\t} else if (locked && !lock) {\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    passwdhash, sizeof(passwdhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tif (timingsafe_bcmp(passwdhash, lock_pwhash, LOCK_SIZE) == 0) {\n\t\t\tdebug(\"agent unlocked\");\n\t\t\tlocked = 0;\n\t\t\tfail_count = 0;\n\t\t\texplicit_bzero(lock_pwhash, sizeof(lock_pwhash));\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* delay in 0.1s increments up to 10s */\n\t\t\tif (fail_count < 100)\n\t\t\t\tfail_count++;\n\t\t\tdelay = 100000 * fail_count;\n\t\t\tdebug(\"unlock failed, delaying %0.1lf seconds\",\n\t\t\t    (double)delay/1000000);\n\t\t\tusleep(delay);\n\t\t}\n\t\texplicit_bzero(passwdhash, sizeof(passwdhash));\n\t} else if (!locked && lock) {\n\t\tdebug(\"agent locked\");\n\t\tlocked = 1;\n\t\tarc4random_buf(lock_salt, sizeof(lock_salt));\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    lock_pwhash, sizeof(lock_pwhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tsuccess = 1;\n\t}\n\tfreezero(passwd, pwlen);\n\tsend_status(e, success);\n}\n\nstatic void\nno_identities(SocketEntry *e)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0 ||\n\t    (r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsshbuf_free(msg);\n}\n\n#ifdef ENABLE_PKCS11\nstatic void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tchar **comments = NULL;\n\tint r, i, count = 0, success = 0, confirm = 0;\n\tu_int seconds = 0;\n\ttime_t death = 0;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tif (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm,\n\t    NULL) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tgoto send;\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, allowed_providers, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not allowed\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug_f(\"add %.100s\", canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys, &comments);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tif (lookup_identity(k) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tkeys[i] = NULL; /* transferred */\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tif (*comments[i] != '\\0') {\n\t\t\t\tid->comment = comments[i];\n\t\t\t\tcomments[i] = NULL; /* transferred */\n\t\t\t} else {\n\t\t\t\tid->comment = xstrdup(canonical_provider);\n\t\t\t}\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t}\n\t\t/* XXX update constraints for existing keys */\n\t\tsshkey_free(keys[i]);\n\t\tfree(comments[i]);\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tfree(comments);\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tint r, success = 0;\n\tIdentity *id, *nxt;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tfree(pin);\n\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\n\tdebug_f(\"remove %.100s\", canonical_provider);\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\t/* Skip file--based keys */\n\t\tif (id->provider == NULL)\n\t\t\tcontinue;\n\t\tif (!strcmp(canonical_provider, id->provider)) {\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t}\n\t}\n\tif (pkcs11_del_provider(canonical_provider) == 0)\n\t\tsuccess = 1;\n\telse\n\t\terror_f(\"pkcs11_del_provider failed\");\nsend:\n\tfree(provider);\n\tsend_status(e, success);\n}\n#endif /* ENABLE_PKCS11 */\n\n/*\n * dispatch incoming message.\n * returns 1 on success, 0 for incomplete messages or -1 on error.\n */\nstatic int\nprocess_message(u_int socknum)\n{\n\tu_int msg_len;\n\tu_char type;\n\tconst u_char *cp;\n\tint r;\n\tSocketEntry *e;\n\n\tif (socknum >= sockets_alloc)\n\t\tfatal_f(\"sock %u >= allocated %u\", socknum, sockets_alloc);\n\te = &sockets[socknum];\n\n\tif (sshbuf_len(e->input) < 5)\n\t\treturn 0;\t\t/* Incomplete message header. */\n\tcp = sshbuf_ptr(e->input);\n\tmsg_len = PEEK_U32(cp);\n\tif (msg_len > AGENT_MAX_LEN) {\n\t\tdebug_f(\"socket %u (fd=%d) message too long %u > %u\",\n\t\t    socknum, e->fd, msg_len, AGENT_MAX_LEN);\n\t\treturn -1;\n\t}\n\tif (sshbuf_len(e->input) < msg_len + 4)\n\t\treturn 0;\t\t/* Incomplete message body. */\n\n\t/* move the current input to e->request */\n\tsshbuf_reset(e->request);\n\tif ((r = sshbuf_get_stringb(e->input, e->request)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &type)) != 0) {\n\t\tif (r == SSH_ERR_MESSAGE_INCOMPLETE ||\n\t\t    r == SSH_ERR_STRING_TOO_LARGE) {\n\t\t\terror_fr(r, \"parse\");\n\t\t\treturn -1;\n\t\t}\n\t\tfatal_fr(r, \"parse\");\n\t}\n\n\tdebug_f(\"socket %u (fd=%d) type %d\", socknum, e->fd, type);\n\n\t/* check whether agent is locked */\n\tif (locked && type != SSH_AGENTC_UNLOCK) {\n\t\tsshbuf_reset(e->request);\n\t\tswitch (type) {\n\t\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\t\t/* send empty lists */\n\t\t\tno_identities(e);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* send a fail message for all other request types */\n\t\t\tsend_status(e, 0);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase SSH_AGENTC_LOCK:\n\tcase SSH_AGENTC_UNLOCK:\n\t\tprocess_lock_agent(e, type == SSH_AGENTC_LOCK);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:\n\t\tprocess_remove_all_identities(e); /* safe for !WITH_SSH1 */\n\t\tbreak;\n\t/* ssh2 */\n\tcase SSH2_AGENTC_SIGN_REQUEST:\n\t\tprocess_sign_request2(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\tprocess_request_identities(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_ADD_IDENTITY:\n\tcase SSH2_AGENTC_ADD_ID_CONSTRAINED:\n\t\tprocess_add_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_IDENTITY:\n\t\tprocess_remove_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_ALL_IDENTITIES:\n\t\tprocess_remove_all_identities(e);\n\t\tbreak;\n#ifdef ENABLE_PKCS11\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY:\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:\n\t\tprocess_add_smartcard_key(e);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_SMARTCARD_KEY:\n\t\tprocess_remove_smartcard_key(e);\n\t\tbreak;\n#endif /* ENABLE_PKCS11 */\n\tdefault:\n\t\t/* Unknown message.  Respond with failure. */\n\t\terror(\"Unknown message %d\", type);\n\t\tsshbuf_reset(e->request);\n\t\tsend_status(e, 0);\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\nstatic void\nnew_socket(sock_type type, int fd)\n{\n\tu_int i, old_alloc, new_alloc;\n\n\tdebug_f(\"type = %s\", type == AUTH_CONNECTION ? \"CONNECTION\" :\n\t    (type == AUTH_SOCKET ? \"SOCKET\" : \"UNKNOWN\"));\n\tset_nonblock(fd);\n\n\tif (fd > max_fd)\n\t\tmax_fd = fd;\n\n\tfor (i = 0; i < sockets_alloc; i++)\n\t\tif (sockets[i].type == AUTH_UNUSED) {\n\t\t\tsockets[i].fd = fd;\n\t\t\tif ((sockets[i].input = sshbuf_new()) == NULL ||\n\t\t\t    (sockets[i].output = sshbuf_new()) == NULL ||\n\t\t\t    (sockets[i].request = sshbuf_new()) == NULL)\n\t\t\t\tfatal_f(\"sshbuf_new failed\");\n\t\t\tsockets[i].type = type;\n\t\t\treturn;\n\t\t}\n\told_alloc = sockets_alloc;\n\tnew_alloc = sockets_alloc + 10;\n\tsockets = xrecallocarray(sockets, old_alloc, new_alloc,\n\t    sizeof(sockets[0]));\n\tfor (i = old_alloc; i < new_alloc; i++)\n\t\tsockets[i].type = AUTH_UNUSED;\n\tsockets_alloc = new_alloc;\n\tsockets[old_alloc].fd = fd;\n\tif ((sockets[old_alloc].input = sshbuf_new()) == NULL ||\n\t    (sockets[old_alloc].output = sshbuf_new()) == NULL ||\n\t    (sockets[old_alloc].request = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tsockets[old_alloc].type = type;\n}\n\nstatic int\nhandle_socket_read(u_int socknum)\n{\n\tstruct sockaddr_un sunaddr;\n\tsocklen_t slen;\n\tuid_t euid;\n\tgid_t egid;\n\tint fd;\n\n\tslen = sizeof(sunaddr);\n\tfd = accept(sockets[socknum].fd, (struct sockaddr *)&sunaddr, &slen);\n\tif (fd == -1) {\n\t\terror(\"accept from AUTH_SOCKET: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getpeereid(fd, &euid, &egid) == -1) {\n\t\terror(\"getpeereid %d failed: %s\", fd, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif ((euid != 0) && (getuid() != euid)) {\n\t\terror(\"uid mismatch: peer euid %u != uid %u\",\n\t\t    (u_int) euid, (u_int) getuid());\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tnew_socket(AUTH_CONNECTION, fd);\n\treturn 0;\n}\n\nstatic int\nhandle_conn_read(u_int socknum)\n{\n\tchar buf[AGENT_RBUF_LEN];\n\tssize_t len;\n\tint r;\n\n\tif ((len = read(sockets[socknum].fd, buf, sizeof(buf))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror_f(\"read error on socket %u (fd %d): %s\",\n\t\t\t    socknum, sockets[socknum].fd, strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_put(sockets[socknum].input, buf, len)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\texplicit_bzero(buf, sizeof(buf));\n\tfor (;;) {\n\t\tif ((r = process_message(socknum)) == -1)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int\nhandle_conn_write(u_int socknum)\n{\n\tssize_t len;\n\tint r;\n\n\tif (sshbuf_len(sockets[socknum].output) == 0)\n\t\treturn 0; /* shouldn't happen */\n\tif ((len = write(sockets[socknum].fd,\n\t    sshbuf_ptr(sockets[socknum].output),\n\t    sshbuf_len(sockets[socknum].output))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror_f(\"read error on socket %u (fd %d): %s\",\n\t\t\t    socknum, sockets[socknum].fd, strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_consume(sockets[socknum].output, len)) != 0)\n\t\tfatal_fr(r, \"consume\");\n\treturn 0;\n}\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror_f(\"no socket for fd %d\", pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int\nprepare_poll(struct pollfd **pfdp, size_t *npfdp, int *timeoutp, u_int maxfds)\n{\n\tstruct pollfd *pfd = *pfdp;\n\tsize_t i, j, npfd = 0;\n\ttime_t deadline;\n\tint r;\n\n\t/* Count active sockets */\n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\tcase AUTH_CONNECTION:\n\t\t\tnpfd++;\n\t\t\tbreak;\n\t\tcase AUTH_UNUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Unknown socket type %d\", sockets[i].type);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (npfd != *npfdp &&\n\t    (pfd = recallocarray(pfd, *npfdp, npfd, sizeof(*pfd))) == NULL)\n\t\tfatal_f(\"recallocarray failed\");\n\t*pfdp = pfd;\n\t*npfdp = npfd;\n\n\tfor (i = j = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %zu >= limit %u); \"\n\t\t\t\t    \"skipping arming listener\", npfd, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\tpfd[j].events = POLLIN;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\t/*\n\t\t\t * Only prepare to read if we can handle a full-size\n\t\t\t * input read buffer and enqueue a max size reply..\n\t\t\t */\n\t\t\tif ((r = sshbuf_check_reserve(sockets[i].input,\n\t\t\t    AGENT_RBUF_LEN)) == 0 &&\n\t\t\t    (r = sshbuf_check_reserve(sockets[i].output,\n\t\t\t     AGENT_MAX_LEN)) == 0)\n\t\t\t\tpfd[j].events = POLLIN;\n\t\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\t\tfatal_fr(r, \"reserve\");\n\t\t\tif (sshbuf_len(sockets[i].output) > 0)\n\t\t\t\tpfd[j].events |= POLLOUT;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdeadline = reaper();\n\tif (parent_alive_interval != 0)\n\t\tdeadline = (deadline == 0) ? parent_alive_interval :\n\t\t    MINIMUM(deadline, parent_alive_interval);\n\tif (deadline == 0) {\n\t\t*timeoutp = -1; /* INFTIM */\n\t} else {\n\t\tif (deadline > INT_MAX / 1000)\n\t\t\t*timeoutp = INT_MAX / 1000;\n\t\telse\n\t\t\t*timeoutp = deadline * 1000;\n\t}\n\treturn (1);\n}\n\nstatic void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug_f(\"cleanup\");\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}\n\nvoid\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}\n\n/*ARGSUSED*/\nstatic void\ncleanup_handler(int sig)\n{\n\tcleanup_socket();\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\t_exit(2);\n}\n\nstatic void\ncheck_parent_exists(void)\n{\n\t/*\n\t * If our parent has exited then getppid() will return (pid_t)1,\n\t * so testing for that should be safe.\n\t */\n\tif (parent_pid != -1 && getppid() != parent_pid) {\n\t\t/* printf(\"Parent has died - Authentication agent exiting.\\n\"); */\n\t\tcleanup_socket();\n\t\t_exit(2);\n\t}\n}\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-P allowed_providers] [-t life]\\n\"\n\t    \"       ssh-agent [-a bind_address] [-E fingerprint_hash] [-P allowed_providers]\\n\"\n\t    \"                 [-t life] command [arg ...]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}\n\nint\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, ch, result, saved_errno;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n#ifdef HAVE_SETRLIMIT\n\tstruct rlimit rlim;\n#endif\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tsize_t len;\n\tmode_t prev_mask;\n\tint timeout = -1; /* INFTIM */\n\tstruct pollfd *pfd = NULL;\n\tsize_t npfd = 0;\n\tu_int maxfds;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\tsetegid(getgid());\n\tsetgid(getgid());\n\n\tplatform_disable_tracing(0);\t/* strict=no */\n\n#ifdef RLIMIT_NOFILE\n\tif (getrlimit(RLIMIT_NOFILE, &rlim) == -1)\n\t\tfatal(\"%s: getrlimit: %s\", __progname, strerror(errno));\n#endif\n\n\t__progname = ssh_get_progname(av[0]);\n\tseed_rng();\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:O:P:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (strcmp(optarg, \"no-restrict-websafe\") == 0)\n\t\t\t\trestrict_websafe  = 0;\n\t\t\telse\n\t\t\t\tfatal(\"Unknown -O option\");\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (allowed_providers != NULL)\n\t\t\t\tfatal(\"-P option already specified\");\n\t\t\tallowed_providers = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (allowed_providers == NULL)\n\t\tallowed_providers = xstrdup(DEFAULT_ALLOWED_PROVIDERS);\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\n\t/*\n\t * Minimum file descriptors:\n\t * stdio (3) + listener (1) + syslog (1 maybe) + connection (1) +\n\t * a few spare for libc / stack protectors / sanitisers, etc.\n\t */\n#define SSH_AGENT_MIN_FDS (3+1+1+1+4)\n\tif (rlim.rlim_cur < SSH_AGENT_MIN_FDS)\n\t\tfatal(\"%s: file descriptor rlimit %lld too low (minimum %u)\",\n\t\t    __progname, (long long)rlim.rlim_cur, SSH_AGENT_MIN_FDS);\n\tmaxfds = rlim.rlim_cur - SSH_AGENT_MIN_FDS;\n\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif (stdfd_devnull(1, 1, 1) == -1)\n\t\terror_f(\"stdfd_devnull failed\");\n\n#ifdef HAVE_SETRLIMIT\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) == -1) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n#endif\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tssh_signal(SIGPIPE, SIG_IGN);\n\tssh_signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tssh_signal(SIGHUP, cleanup_handler);\n\tssh_signal(SIGTERM, cleanup_handler);\n\n\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\tplatform_pledge_agent();\n\n\twhile (1) {\n\t\tprepare_poll(&pfd, &npfd, &timeout, maxfds);\n\t\tresult = poll(pfd, npfd, timeout);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result == -1) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"poll: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_poll(pfd, npfd, maxfds);\n\t}\n\t/* NOTREACHED */\n}\n"], "filenames": ["ssh-agent.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [667], "fixing_code_start_loc": [1], "fixing_code_end_loc": [685], "type": "CWE-415", "message": "ssh-agent in OpenSSH before 8.5 has a double free that may be relevant in a few less-common scenarios, such as unconstrained agent-socket access on a legacy operating system, or the forwarding of an agent to an attacker-controlled host.", "other": {"cve": {"id": "CVE-2021-28041", "sourceIdentifier": "cve@mitre.org", "published": "2021-03-05T21:15:13.200", "lastModified": "2022-05-20T20:47:47.243", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ssh-agent in OpenSSH before 8.5 has a double free that may be relevant in a few less-common scenarios, such as unconstrained agent-socket access on a legacy operating system, or the forwarding of an agent to an attacker-controlled host."}, {"lang": "es", "value": "ssh-agent en OpenSSH versiones anteriores a 8.5, presenta una doble liberaci\u00f3n que puede ser relevante en algunos escenarios menos comunes, como el acceso sin restricciones al socket del agente en un sistema operativo heredado o el reenv\u00edo de un agente a un host controlado por el atacante"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.2", "versionEndExcluding": "8.5", "matchCriteriaId": "7974AA7F-3FC7-437C-80C4-8581BC18F883"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_compute_node_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "F921BC85-568E-4B69-A3CD-CF75C76672F1"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_storage_node_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "4BC4299D-05D3-4875-BC79-C3DC02C88ECE"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "02DEB4FB-A21D-4CB1-B522-EEE5093E8521"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_offline_mediation_controller:12.0.0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "49ACFC73-A509-4D1C-8FC3-F68F495AB055"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:zfs_storage_appliance:8.8:*:*:*:*:*:*:*", "matchCriteriaId": "18096778-19E1-434F-BD96-A9FBF11A8C81"}]}]}], "references": [{"url": "https://github.com/openssh/openssh-portable/commit/e04fd6dde16de1cdc5a4d9946397ff60d96568db", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KQWGII3LQR4AOTPPFXGMTYE7UDEWIUKI/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TXST2CML2MWY3PNVUXX7FFJE3ATJMNVZ/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202105-35", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210416-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.openssh.com/security.html", "source": "cve@mitre.org", "tags": ["Not Applicable", "Vendor Advisory"]}, {"url": "https://www.openssh.com/txt/release-8.5", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2021/03/03/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openssh/openssh-portable/commit/e04fd6dde16de1cdc5a4d9946397ff60d96568db"}}