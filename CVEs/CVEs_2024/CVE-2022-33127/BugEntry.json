{"buggy_code": ["module Diffy\n  class Diff\n    ORIGINAL_DEFAULT_OPTIONS = {\n      :diff => '-U10000',\n      :source => 'strings',\n      :include_diff_info => false,\n      :include_plus_and_minus_in_html => false,\n      :context => nil,\n      :allow_empty_diff => true,\n    }\n\n    class << self\n      attr_writer :default_format\n      def default_format\n        @default_format ||= :text\n      end\n\n      # default options passed to new Diff objects\n      attr_writer :default_options\n      def default_options\n        @default_options ||= ORIGINAL_DEFAULT_OPTIONS.dup\n      end\n\n    end\n    include Enumerable\n    attr_reader :string1, :string2, :options\n\n    # supported options\n    # +:diff+::    A cli options string passed to diff\n    # +:source+::  Either _strings_ or _files_.  Determines whether string1\n    #              and string2 should be interpreted as strings or file paths.\n    # +:include_diff_info+::    Include diff header info\n    # +:include_plus_and_minus_in_html+::    Show the +, -, ' ' at the\n    #                                        beginning of lines in html output.\n    def initialize(string1, string2, options = {})\n      @options = self.class.default_options.merge(options)\n      if ! ['strings', 'files'].include?(@options[:source])\n        raise ArgumentError, \"Invalid :source option #{@options[:source].inspect}. Supported options are 'strings' and 'files'.\"\n      end\n      @string1, @string2 = string1, string2\n    end\n\n    def diff\n      @diff ||= begin\n        @paths = case options[:source]\n          when 'strings'\n            [tempfile(string1), tempfile(string2)]\n          when 'files'\n            [string1, string2]\n          end\n\n        if WINDOWS\n          # don't use open3 on windows\n          cmd = sprintf '\"%s\" %s %s', diff_bin, diff_options.join(' '), @paths.map { |s| %(\"#{s}\") }.join(' ')\n          diff = `#{cmd}`\n        else\n          diff = Open3.popen3(diff_bin, *(diff_options + @paths)) { |i, o, e| o.read }\n        end\n        diff.force_encoding('ASCII-8BIT') if diff.respond_to?(:valid_encoding?) && !diff.valid_encoding?\n        if diff =~ /\\A\\s*\\Z/ && !options[:allow_empty_diff]\n          diff = case options[:source]\n          when 'strings' then string1\n          when 'files' then File.read(string1)\n          end.gsub(/^/, \" \")\n        end\n        diff\n      end\n    ensure\n      # unlink the tempfiles explicitly now that the diff is generated\n      if defined? @tempfiles # to avoid Ruby warnings about undefined ins var.\n        Array(@tempfiles).each do |t|\n          begin\n            # check that the path is not nil and file still exists.\n            # REE seems to be very agressive with when it magically removes\n            # tempfiles\n            t.unlink if t.path && File.exist?(t.path)\n          rescue => e\n            warn \"#{e.class}: #{e}\"\n            warn e.backtrace.join(\"\\n\")\n          end\n        end\n      end\n    end\n\n    def each\n      lines = case @options[:include_diff_info]\n      when false\n        # this \"primes\" the diff and sets up the paths we'll reference below.\n        diff\n\n        # caching this regexp improves the performance of the loop by a\n        # considerable amount.\n        regexp = /^(--- \"?#{@paths[0]}\"?|\\+\\+\\+ \"?#{@paths[1]}\"?|@@|\\\\\\\\)/\n\n        diff.split(\"\\n\").reject{|x| x =~ regexp }.map {|line| line + \"\\n\" }\n\n      when true\n        diff.split(\"\\n\").map {|line| line + \"\\n\" }\n      end\n\n      if block_given?\n        lines.each{|line| yield line}\n      else\n        lines.to_enum\n      end\n    end\n\n    def each_chunk\n      old_state = nil\n      chunks = inject([]) do |cc, line|\n        state = line.each_char.first\n        if state == old_state\n          cc.last << line\n        else\n          cc.push line.dup\n        end\n        old_state = state\n        cc\n      end\n\n      if block_given?\n        chunks.each{|chunk| yield chunk }\n      else\n        chunks.to_enum\n      end\n    end\n\n    def tempfile(string)\n      t = Tempfile.new('diffy')\n      # ensure tempfiles aren't unlinked when GC runs by maintaining a\n      # reference to them.\n      @tempfiles ||=[]\n      @tempfiles.push(t)\n      t.print(string)\n      t.flush\n      t.close\n      t.path\n    end\n\n    def to_s(format = nil)\n      format ||= self.class.default_format\n      formats = Format.instance_methods(false).map{|x| x.to_s}\n      if formats.include? format.to_s\n        enum = self\n        enum.extend Format\n        enum.send format\n      else\n        raise ArgumentError,\n          \"Format #{format.inspect} not found in #{formats.inspect}\"\n      end\n    end\n    private\n\n    @@bin = nil\n    def diff_bin\n      return @@bin if @@bin\n\n      if @@bin = ENV['DIFFY_DIFF']\n        # system() trick from Minitest\n        raise \"Can't execute diff program '#@@bin'\" unless system(@@bin, __FILE__, __FILE__)\n        return @@bin\n      end\n\n      diffs = ['diff', 'ldiff']\n      diffs.first << '.exe' if WINDOWS  # ldiff does not have exe extension\n      @@bin = diffs.find { |name| system(name, __FILE__, __FILE__) }\n\n      if @@bin.nil?\n        raise \"Can't find a diff executable in PATH #{ENV['PATH']}\"\n      end\n\n      @@bin\n    end\n\n    # options pass to diff program\n    def diff_options\n      Array(options[:context] ? \"-U#{options[:context]}\" : options[:diff])\n    end\n\n  end\nend\n"], "fixing_code": ["module Diffy\n  class Diff\n    ORIGINAL_DEFAULT_OPTIONS = {\n      :diff => '-U10000',\n      :source => 'strings',\n      :include_diff_info => false,\n      :include_plus_and_minus_in_html => false,\n      :context => nil,\n      :allow_empty_diff => true,\n    }\n\n    class << self\n      attr_writer :default_format\n      def default_format\n        @default_format ||= :text\n      end\n\n      # default options passed to new Diff objects\n      attr_writer :default_options\n      def default_options\n        @default_options ||= ORIGINAL_DEFAULT_OPTIONS.dup\n      end\n\n    end\n    include Enumerable\n    attr_reader :string1, :string2, :options\n\n    # supported options\n    # +:diff+::    A cli options string passed to diff\n    # +:source+::  Either _strings_ or _files_.  Determines whether string1\n    #              and string2 should be interpreted as strings or file paths.\n    # +:include_diff_info+::    Include diff header info\n    # +:include_plus_and_minus_in_html+::    Show the +, -, ' ' at the\n    #                                        beginning of lines in html output.\n    def initialize(string1, string2, options = {})\n      @options = self.class.default_options.merge(options)\n      if ! ['strings', 'files'].include?(@options[:source])\n        raise ArgumentError, \"Invalid :source option #{@options[:source].inspect}. Supported options are 'strings' and 'files'.\"\n      end\n      @string1, @string2 = string1, string2\n    end\n\n    def diff\n      @diff ||= begin\n        @paths = case options[:source]\n          when 'strings'\n            [tempfile(string1), tempfile(string2)]\n          when 'files'\n            [string1, string2]\n          end\n\n        diff, stderr, process_status = Open3.capture3(diff_bin, *(diff_options + @paths))\n        diff.force_encoding('ASCII-8BIT') if diff.respond_to?(:valid_encoding?) && !diff.valid_encoding?\n        if diff =~ /\\A\\s*\\Z/ && !options[:allow_empty_diff]\n          diff = case options[:source]\n          when 'strings' then string1\n          when 'files' then File.read(string1)\n          end.gsub(/^/, \" \")\n        end\n        diff\n      end\n    ensure\n      # unlink the tempfiles explicitly now that the diff is generated\n      if defined? @tempfiles # to avoid Ruby warnings about undefined ins var.\n        Array(@tempfiles).each do |t|\n          begin\n            # check that the path is not nil and file still exists.\n            # REE seems to be very agressive with when it magically removes\n            # tempfiles\n            t.unlink if t.path && File.exist?(t.path)\n          rescue => e\n            warn \"#{e.class}: #{e}\"\n            warn e.backtrace.join(\"\\n\")\n          end\n        end\n      end\n    end\n\n    def each\n      lines = case @options[:include_diff_info]\n      when false\n        # this \"primes\" the diff and sets up the paths we'll reference below.\n        diff\n\n        # caching this regexp improves the performance of the loop by a\n        # considerable amount.\n        regexp = /^(--- \"?#{@paths[0]}\"?|\\+\\+\\+ \"?#{@paths[1]}\"?|@@|\\\\\\\\)/\n\n        diff.split(\"\\n\").reject{|x| x =~ regexp }.map {|line| line + \"\\n\" }\n\n      when true\n        diff.split(\"\\n\").map {|line| line + \"\\n\" }\n      end\n\n      if block_given?\n        lines.each{|line| yield line}\n      else\n        lines.to_enum\n      end\n    end\n\n    def each_chunk\n      old_state = nil\n      chunks = inject([]) do |cc, line|\n        state = line.each_char.first\n        if state == old_state\n          cc.last << line\n        else\n          cc.push line.dup\n        end\n        old_state = state\n        cc\n      end\n\n      if block_given?\n        chunks.each{|chunk| yield chunk }\n      else\n        chunks.to_enum\n      end\n    end\n\n    def tempfile(string)\n      t = Tempfile.new('diffy')\n      # ensure tempfiles aren't unlinked when GC runs by maintaining a\n      # reference to them.\n      @tempfiles ||=[]\n      @tempfiles.push(t)\n      t.print(string)\n      t.flush\n      t.close\n      t.path\n    end\n\n    def to_s(format = nil)\n      format ||= self.class.default_format\n      formats = Format.instance_methods(false).map{|x| x.to_s}\n      if formats.include? format.to_s\n        enum = self\n        enum.extend Format\n        enum.send format\n      else\n        raise ArgumentError,\n          \"Format #{format.inspect} not found in #{formats.inspect}\"\n      end\n    end\n    private\n\n    @@bin = nil\n    def diff_bin\n      return @@bin if @@bin\n\n      if @@bin = ENV['DIFFY_DIFF']\n        # system() trick from Minitest\n        raise \"Can't execute diff program '#@@bin'\" unless system(@@bin, __FILE__, __FILE__)\n        return @@bin\n      end\n\n      diffs = ['diff', 'ldiff']\n      diffs.first << '.exe' if WINDOWS  # ldiff does not have exe extension\n      @@bin = diffs.find { |name| system(name, __FILE__, __FILE__) }\n\n      if @@bin.nil?\n        raise \"Can't find a diff executable in PATH #{ENV['PATH']}\"\n      end\n\n      @@bin\n    end\n\n    # options pass to diff program\n    def diff_options\n      Array(options[:context] ? \"-U#{options[:context]}\" : options[:diff])\n    end\n\n  end\nend\n"], "filenames": ["lib/diffy/diff.rb"], "buggy_code_start_loc": [52], "buggy_code_end_loc": [59], "fixing_code_start_loc": [52], "fixing_code_end_loc": [53], "type": "NVD-CWE-noinfo", "message": "The function that calls the diff tool in Diffy 3.4.1 does not properly handle double quotes in a filename when run in a windows environment. This allows attackers to execute arbitrary commands via a crafted string.", "other": {"cve": {"id": "CVE-2022-33127", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-23T17:15:14.923", "lastModified": "2022-06-29T18:28:12.397", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The function that calls the diff tool in Diffy 3.4.1 does not properly handle double quotes in a filename when run in a windows environment. This allows attackers to execute arbitrary commands via a crafted string."}, {"lang": "es", "value": "La funci\u00f3n que llama a la herramienta diff en Diffy versi\u00f3n 3.4.1, no maneja correctamente las comillas dobles en un nombre de archivo cuando se ejecuta en un entorno Windows. Esto permite a atacantes ejecutar comandos arbitrarios por medio de una cadena dise\u00f1ada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:diffy_project:diffy:3.4.1:*:*:*:*:ruby:*:*", "matchCriteriaId": "BE4FF31C-DF2A-470B-8B6F-955269495149"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2572D17-1DE6-457B-99CC-64AFD54487EA"}]}]}], "references": [{"url": "https://github.com/samg/diffy/blob/56fd935aea256742f7352b050592542d3d153bf6/CHANGELOG#L1", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/samg/diffy/commit/478f392082b66d38f54a02b4bb9c41be32fd6593", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/samg/diffy/commit/478f392082b66d38f54a02b4bb9c41be32fd6593"}}