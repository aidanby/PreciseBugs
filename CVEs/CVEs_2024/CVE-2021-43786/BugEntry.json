{"buggy_code": ["'use strict';\n\nconst async = require('async');\nconst passport = require('passport');\nconst passportLocal = require('passport-local').Strategy;\nconst BearerStrategy = require('passport-http-bearer').Strategy;\nconst winston = require('winston');\n\nconst meta = require('../meta');\nconst controllers = require('../controllers');\nconst helpers = require('../controllers/helpers');\nconst plugins = require('../plugins');\n\nlet loginStrategies = [];\n\nconst Auth = module.exports;\n\nAuth.initialize = function (app, middleware) {\n\tapp.use(passport.initialize());\n\tapp.use(passport.session());\n\tapp.use((req, res, next) => {\n\t\tAuth.setAuthVars(req, res);\n\t\tnext();\n\t});\n\n\tAuth.app = app;\n\tAuth.middleware = middleware;\n};\n\nAuth.setAuthVars = function setAuthVars(req) {\n\tconst isSpider = req.isSpider();\n\treq.loggedIn = !isSpider && !!req.user;\n\tif (req.user) {\n\t\treq.uid = parseInt(req.user.uid, 10);\n\t} else if (isSpider) {\n\t\treq.uid = -1;\n\t} else {\n\t\treq.uid = 0;\n\t}\n};\n\nAuth.getLoginStrategies = function () {\n\treturn loginStrategies;\n};\n\nAuth.verifyToken = async function (token, done) {\n\tlet { tokens = [] } = await meta.settings.get('core.api');\n\ttokens = tokens.reduce((memo, cur) => {\n\t\tmemo[cur.token] = cur.uid;\n\t\treturn memo;\n\t}, {});\n\n\tconst uid = tokens[token];\n\n\tif (uid !== undefined) {\n\t\tif (parseInt(uid, 10) > 0) {\n\t\t\tdone(null, {\n\t\t\t\tuid: uid,\n\t\t\t});\n\t\t} else {\n\t\t\tdone(null, {\n\t\t\t\tmaster: true,\n\t\t\t});\n\t\t}\n\t} else {\n\t\tdone(false);\n\t}\n};\n\nAuth.reloadRoutes = async function (params) {\n\tloginStrategies.length = 0;\n\tconst { router } = params;\n\n\t// Local Logins\n\tif (plugins.hooks.hasListeners('action:auth.overrideLogin')) {\n\t\twinston.warn('[authentication] Login override detected, skipping local login strategy.');\n\t\tplugins.hooks.fire('action:auth.overrideLogin');\n\t} else {\n\t\tpassport.use(new passportLocal({ passReqToCallback: true }, controllers.authentication.localLogin));\n\t}\n\n\t// HTTP bearer authentication\n\tpassport.use('core.api', new BearerStrategy({}, Auth.verifyToken));\n\n\t// Additional logins via SSO plugins\n\ttry {\n\t\tloginStrategies = await plugins.hooks.fire('filter:auth.init', loginStrategies);\n\t} catch (err) {\n\t\twinston.error(`[authentication] ${err.stack}`);\n\t}\n\tloginStrategies = loginStrategies || [];\n\tloginStrategies.forEach((strategy) => {\n\t\tif (strategy.url) {\n\t\t\trouter[strategy.urlMethod || 'get'](strategy.url, Auth.middleware.applyCSRF, async (req, res, next) => {\n\t\t\t\tlet opts = {\n\t\t\t\t\tscope: strategy.scope,\n\t\t\t\t\tprompt: strategy.prompt || undefined,\n\t\t\t\t};\n\n\t\t\t\tif (strategy.checkState !== false) {\n\t\t\t\t\treq.session.ssoState = req.csrfToken && req.csrfToken();\n\t\t\t\t\topts.state = req.session.ssoState;\n\t\t\t\t}\n\n\t\t\t\t// Allow SSO plugins to override/append options (for use in passport prototype authorizationParams)\n\t\t\t\t({ opts } = await plugins.hooks.fire('filter:auth.options', { req, res, opts }));\n\t\t\t\tpassport.authenticate(strategy.name, opts)(req, res, next);\n\t\t\t});\n\t\t}\n\n\t\trouter[strategy.callbackMethod || 'get'](strategy.callbackURL, (req, res, next) => {\n\t\t\t// Ensure the passed-back state value is identical to the saved ssoState (unless explicitly skipped)\n\t\t\tif (strategy.checkState === false) {\n\t\t\t\treturn next();\n\t\t\t}\n\n\t\t\tnext(req.query.state !== req.session.ssoState ? new Error('[[error:csrf-invalid]]') : null);\n\t\t}, (req, res, next) => {\n\t\t\t// Trigger registration interstitial checks\n\t\t\treq.session.registration = req.session.registration || {};\n\t\t\t// save returnTo for later usage in /register/complete\n\t\t\t// passport seems to remove `req.session.returnTo` after it redirects\n\t\t\treq.session.registration.returnTo = req.session.returnTo;\n\n\t\t\tpassport.authenticate(strategy.name, (err, user) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (req.session && req.session.registration) {\n\t\t\t\t\t\tdelete req.session.registration;\n\t\t\t\t\t}\n\t\t\t\t\treturn next(err);\n\t\t\t\t}\n\n\t\t\t\tif (!user) {\n\t\t\t\t\tif (req.session && req.session.registration) {\n\t\t\t\t\t\tdelete req.session.registration;\n\t\t\t\t\t}\n\t\t\t\t\treturn helpers.redirect(res, strategy.failureUrl !== undefined ? strategy.failureUrl : '/login');\n\t\t\t\t}\n\n\t\t\t\tres.locals.user = user;\n\t\t\t\tres.locals.strategy = strategy;\n\t\t\t\tnext();\n\t\t\t})(req, res, next);\n\t\t},\n\t\tAuth.middleware.validateAuth,\n\t\t(req, res, next) => {\n\t\t\tasync.waterfall([\n\t\t\t\tasync.apply(req.login.bind(req), res.locals.user),\n\t\t\t\tasync.apply(controllers.authentication.onSuccessfulLogin, req, req.uid),\n\t\t\t], (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn next(err);\n\t\t\t\t}\n\n\t\t\t\thelpers.redirect(res, strategy.successUrl !== undefined ? strategy.successUrl : '/');\n\t\t\t});\n\t\t});\n\t});\n\n\tconst multipart = require('connect-multiparty');\n\tconst multipartMiddleware = multipart();\n\tconst middlewares = [multipartMiddleware, Auth.middleware.applyCSRF, Auth.middleware.applyBlacklist];\n\n\trouter.post('/register', middlewares, controllers.authentication.register);\n\trouter.post('/register/complete', middlewares, controllers.authentication.registerComplete);\n\trouter.post('/register/abort', controllers.authentication.registerAbort);\n\trouter.post('/login', Auth.middleware.applyCSRF, Auth.middleware.applyBlacklist, controllers.authentication.login);\n\trouter.post('/logout', Auth.middleware.applyCSRF, controllers.authentication.logout);\n};\n\npassport.serializeUser((user, done) => {\n\tdone(null, user.uid);\n});\n\npassport.deserializeUser((uid, done) => {\n\tdone(null, {\n\t\tuid: uid,\n\t});\n});\n"], "fixing_code": ["'use strict';\n\nconst async = require('async');\nconst passport = require('passport');\nconst passportLocal = require('passport-local').Strategy;\nconst BearerStrategy = require('passport-http-bearer').Strategy;\nconst winston = require('winston');\n\nconst meta = require('../meta');\nconst controllers = require('../controllers');\nconst helpers = require('../controllers/helpers');\nconst plugins = require('../plugins');\n\nlet loginStrategies = [];\n\nconst Auth = module.exports;\n\nAuth.initialize = function (app, middleware) {\n\tapp.use(passport.initialize());\n\tapp.use(passport.session());\n\tapp.use((req, res, next) => {\n\t\tAuth.setAuthVars(req, res);\n\t\tnext();\n\t});\n\n\tAuth.app = app;\n\tAuth.middleware = middleware;\n};\n\nAuth.setAuthVars = function setAuthVars(req) {\n\tconst isSpider = req.isSpider();\n\treq.loggedIn = !isSpider && !!req.user;\n\tif (req.user) {\n\t\treq.uid = parseInt(req.user.uid, 10);\n\t} else if (isSpider) {\n\t\treq.uid = -1;\n\t} else {\n\t\treq.uid = 0;\n\t}\n};\n\nAuth.getLoginStrategies = function () {\n\treturn loginStrategies;\n};\n\nAuth.verifyToken = async function (token, done) {\n\tconst { tokens = [] } = await meta.settings.get('core.api');\n\tconst tokenObj = tokens.find(t => t.token === token);\n\tconst uid = tokenObj ? tokenObj.uid : undefined;\n\n\tif (uid !== undefined) {\n\t\tif (parseInt(uid, 10) > 0) {\n\t\t\tdone(null, {\n\t\t\t\tuid: uid,\n\t\t\t});\n\t\t} else {\n\t\t\tdone(null, {\n\t\t\t\tmaster: true,\n\t\t\t});\n\t\t}\n\t} else {\n\t\tdone(false);\n\t}\n};\n\nAuth.reloadRoutes = async function (params) {\n\tloginStrategies.length = 0;\n\tconst { router } = params;\n\n\t// Local Logins\n\tif (plugins.hooks.hasListeners('action:auth.overrideLogin')) {\n\t\twinston.warn('[authentication] Login override detected, skipping local login strategy.');\n\t\tplugins.hooks.fire('action:auth.overrideLogin');\n\t} else {\n\t\tpassport.use(new passportLocal({ passReqToCallback: true }, controllers.authentication.localLogin));\n\t}\n\n\t// HTTP bearer authentication\n\tpassport.use('core.api', new BearerStrategy({}, Auth.verifyToken));\n\n\t// Additional logins via SSO plugins\n\ttry {\n\t\tloginStrategies = await plugins.hooks.fire('filter:auth.init', loginStrategies);\n\t} catch (err) {\n\t\twinston.error(`[authentication] ${err.stack}`);\n\t}\n\tloginStrategies = loginStrategies || [];\n\tloginStrategies.forEach((strategy) => {\n\t\tif (strategy.url) {\n\t\t\trouter[strategy.urlMethod || 'get'](strategy.url, Auth.middleware.applyCSRF, async (req, res, next) => {\n\t\t\t\tlet opts = {\n\t\t\t\t\tscope: strategy.scope,\n\t\t\t\t\tprompt: strategy.prompt || undefined,\n\t\t\t\t};\n\n\t\t\t\tif (strategy.checkState !== false) {\n\t\t\t\t\treq.session.ssoState = req.csrfToken && req.csrfToken();\n\t\t\t\t\topts.state = req.session.ssoState;\n\t\t\t\t}\n\n\t\t\t\t// Allow SSO plugins to override/append options (for use in passport prototype authorizationParams)\n\t\t\t\t({ opts } = await plugins.hooks.fire('filter:auth.options', { req, res, opts }));\n\t\t\t\tpassport.authenticate(strategy.name, opts)(req, res, next);\n\t\t\t});\n\t\t}\n\n\t\trouter[strategy.callbackMethod || 'get'](strategy.callbackURL, (req, res, next) => {\n\t\t\t// Ensure the passed-back state value is identical to the saved ssoState (unless explicitly skipped)\n\t\t\tif (strategy.checkState === false) {\n\t\t\t\treturn next();\n\t\t\t}\n\n\t\t\tnext(req.query.state !== req.session.ssoState ? new Error('[[error:csrf-invalid]]') : null);\n\t\t}, (req, res, next) => {\n\t\t\t// Trigger registration interstitial checks\n\t\t\treq.session.registration = req.session.registration || {};\n\t\t\t// save returnTo for later usage in /register/complete\n\t\t\t// passport seems to remove `req.session.returnTo` after it redirects\n\t\t\treq.session.registration.returnTo = req.session.returnTo;\n\n\t\t\tpassport.authenticate(strategy.name, (err, user) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (req.session && req.session.registration) {\n\t\t\t\t\t\tdelete req.session.registration;\n\t\t\t\t\t}\n\t\t\t\t\treturn next(err);\n\t\t\t\t}\n\n\t\t\t\tif (!user) {\n\t\t\t\t\tif (req.session && req.session.registration) {\n\t\t\t\t\t\tdelete req.session.registration;\n\t\t\t\t\t}\n\t\t\t\t\treturn helpers.redirect(res, strategy.failureUrl !== undefined ? strategy.failureUrl : '/login');\n\t\t\t\t}\n\n\t\t\t\tres.locals.user = user;\n\t\t\t\tres.locals.strategy = strategy;\n\t\t\t\tnext();\n\t\t\t})(req, res, next);\n\t\t},\n\t\tAuth.middleware.validateAuth,\n\t\t(req, res, next) => {\n\t\t\tasync.waterfall([\n\t\t\t\tasync.apply(req.login.bind(req), res.locals.user),\n\t\t\t\tasync.apply(controllers.authentication.onSuccessfulLogin, req, req.uid),\n\t\t\t], (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn next(err);\n\t\t\t\t}\n\n\t\t\t\thelpers.redirect(res, strategy.successUrl !== undefined ? strategy.successUrl : '/');\n\t\t\t});\n\t\t});\n\t});\n\n\tconst multipart = require('connect-multiparty');\n\tconst multipartMiddleware = multipart();\n\tconst middlewares = [multipartMiddleware, Auth.middleware.applyCSRF, Auth.middleware.applyBlacklist];\n\n\trouter.post('/register', middlewares, controllers.authentication.register);\n\trouter.post('/register/complete', middlewares, controllers.authentication.registerComplete);\n\trouter.post('/register/abort', controllers.authentication.registerAbort);\n\trouter.post('/login', Auth.middleware.applyCSRF, Auth.middleware.applyBlacklist, controllers.authentication.login);\n\trouter.post('/logout', Auth.middleware.applyCSRF, controllers.authentication.logout);\n};\n\npassport.serializeUser((user, done) => {\n\tdone(null, user.uid);\n});\n\npassport.deserializeUser((uid, done) => {\n\tdone(null, {\n\t\tuid: uid,\n\t});\n});\n"], "filenames": ["src/routes/authentication.js"], "buggy_code_start_loc": [47], "buggy_code_end_loc": [54], "fixing_code_start_loc": [47], "fixing_code_end_loc": [50], "type": "CWE-287", "message": "Nodebb is an open source Node.js based forum software. In affected versions incorrect logic present in the token verification step unintentionally allowed master token access to the API. The vulnerability has been patch as of v1.18.5. Users are advised to upgrade as soon as possible.", "other": {"cve": {"id": "CVE-2021-43786", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-29T20:15:08.133", "lastModified": "2022-10-27T19:13:01.800", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nodebb is an open source Node.js based forum software. In affected versions incorrect logic present in the token verification step unintentionally allowed master token access to the API. The vulnerability has been patch as of v1.18.5. Users are advised to upgrade as soon as possible."}, {"lang": "es", "value": "Nodebb es un software de foro de c\u00f3digo abierto basado en Node.js. En las versiones afectadas, una l\u00f3gica incorrecta presente en el paso de verificaci\u00f3n del token permit\u00eda involuntariamente el acceso del token maestro a la API. La vulnerabilidad ha sido parcheada a partir de la versi\u00f3n v1.18.5. Se recomienda a usuarios que actualicen lo antes posible"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodebb:nodebb:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.15.0", "versionEndIncluding": "1.18.4", "matchCriteriaId": "688C48BA-FEEB-401F-B323-B2E5DCDE248F"}]}]}], "references": [{"url": "https://blog.sonarsource.com/nodebb-remote-code-execution-with-one-shot/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/NodeBB/NodeBB/commit/04dab1d550cdebf4c1567bca9a51f8b9ca48a500", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/NodeBB/NodeBB/releases/tag/v1.18.5", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/NodeBB/NodeBB/security/advisories/GHSA-hf2m-j98r-4fqw", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NodeBB/NodeBB/commit/04dab1d550cdebf4c1567bca9a51f8b9ca48a500"}}