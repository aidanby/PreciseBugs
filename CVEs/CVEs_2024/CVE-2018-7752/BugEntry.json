{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / common tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#ifndef _GF_TOOLS_H_\n#define _GF_TOOLS_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <gpac/setup.h>\n#include <gpac/version.h>\n\n\n/*! \\file \"gpac/tools.h\"\n *\t\\brief Core definitions and tools of GPAC.\n *\n * This file contains basic functions and core definitions of the GPAC framework. This file is\n * usually included by all GPAC header files since it contains the error definitions.\n*/\n\n/*! \\defgroup utils_grp Core Tools\n *\t\\brief Core definitions and tools of GPAC.\n *\n * You will find in this module the documentation of the core tools used in GPAC.\n*/\n\n/*!\n *\t\\ingroup utils_grp\n *\t\\brief Base definitions and functions of GPAC.\n *\n *\tThis section documents some very basic functions and core definitions of the GPAC framework.\n *\t@{\n */\n\n/*!\n *\t\\brief Stringizer\n *\t\\hideinitializer\n *\n *\tMacro transforming its input name into a string\n*/\n#define gf_stringizer(x) #x\n\n/*!\n *\t\\brief Memory allocation for a structure\n *\t\\hideinitializer\n *\n *\tMacro allocating memory and zero-ing it\n*/\n#define GF_SAFEALLOC(__ptr, __struct) { __ptr = (__struct *) gf_malloc(sizeof(__struct)); if (__ptr) memset((void *) __ptr, 0, sizeof(__struct)); }\n\n/*!\n *\t\\brief Memory allocation for an array of n structs\n *\t\\hideinitializer\n *\n *\tMacro allocating memory for n structures and zero-ing it\n*/\n#define GF_SAFE_ALLOC_N(__ptr, __n, __struct) { __ptr = (__struct *) gf_malloc( __n * sizeof(__struct)); if (__ptr) memset((void *) __ptr, 0, __n * sizeof(__struct)); }\n\n/*!\n *\t\\brief 4CC Formatting\n *\t\\hideinitializer\n *\n *\tMacro formating a 4-character code (or 4CC) \"abcd\" as 0xAABBCCDD\n*/\n#ifndef GF_4CC\n#define GF_4CC(a,b,c,d) (((a)<<24)|((b)<<16)|((c)<<8)|(d))\n#endif\n\n/*!\n *\t\\brief GPAC feature list\n *\n *\treturns the list of features enabled/disabled in this GPAC build.\n*/\nconst char *gpac_features();\n\n/*!\n *\t\\brief 4CC Printing\n *\n *\treturns a 4CC printable form\n*/\nconst char *gf_4cc_to_str(u32 type);\n\n/*!\n *\t\\brief asprintf() portable implementation\n *\n *\tsimilar to sprintf, except it allows the string on the\n *  \\note asprintf implementation for windows\n*/\nint gf_asprintf(char **buffer, const char *fmt, ...);\n\n\nsize_t gf_fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\n\n/*!\n *\t\\brief file writing helper\n *\n *\tWrapper to properly handle calls to fwrite()\n *\tEnsures proper error handling is invoked when it fails.\n *\t\\return Same as gf_fwrite\n *\n*/\nsize_t gf_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n\n/*!\n *\t\\brief large file opening\n *\n *\tOpens a large file (>4GB)\n *\t\\param file_name Same semantics as fopen\n *\t\\param mode Same semantics as fopen\n *\t\\return stream handle of the file object\n *\t\\note You only need to call this function if you're suspecting the file to be a large one (usually only media files), otherwise use regular stdio.\n*/\nFILE *gf_fopen(const char *file_name, const char *mode);\n\n/*!\n *\t\\brief file closing\n *\n *\tCloses a file\n *\t\\param file file to close\n *\t\\note You only need to call this function if you're suspecting the file to be a large one (usually only media files), otherwise use regular stdio.\n*/\ns32 gf_fclose(FILE *file);\n\n/*!\n *\t\\brief large file position query\n *\n *\tQueries the current read/write position in a large file\n *\t\\param f Same semantics as ftell\n *\t\\return position in the file\n *\t\\note You only need to call this function if you're suspecting the file to be a large one (usually only media files), otherwise use regular stdio.\n*/\nu64 gf_ftell(FILE *f);\n/*!\n *\t\\brief large file seeking\n *\n *\tSeeks the current read/write position in a large file\n *\t\\param f Same semantics as fseek\n *\t\\param pos Same semantics as fseek\n *\t\\param whence Same semantics as fseek\n *\t\\return new position in the file\n *\t\\note You only need to call this function if you're suspecting the file to be a large one (usually only media files), otherwise use regular stdio.\n*/\nu64 gf_fseek(FILE *f, s64 pos, s32 whence);\n\n/*!\n *\t\\brief get basename from filename/path\n *\n *\tReturns a pointer to the start of a filepath basename or null\n *\t\\param filename Path of the file, can be an absolute path\n*/\nchar* gf_file_basename(const char* filename);\n\n/*!\n *\t\\brief get extension from filename\n *\n *\tReturns a pointer to the start of a filepath extension or null\n *\t\\param filename Path of the file, can be an absolute path\n*/\nchar* gf_file_ext_start(const char* filename);\n\n\n/*! @} */\n\n\n/*! \\addtogroup errors_grp Error codes\n *\t\\ingroup utils_grp\n *\t\\brief Errors used in GPAC.\n *\n *\tThis section documents all error codes used in the GPAC framework. Most of the GPAC's functions will use these as\n * return values, and some of these errors are also used for state communication with the different modules of the framework.\n *\t@{\n */\n\n/*!\n * GPAC Error\n *\t\\hideinitializer\n *\n *\tpositive values are warning and info, 0 means no error and negative values are errors\n */\ntypedef enum\n{\n\t/*!Message from any scripting engine used in the presentation (ECMAScript, MPEG-J, ...) (Info).*/\n\tGF_SCRIPT_INFO                                          = 3,\n\t/*!Indicates an data frame has several AU packed (not MPEG-4 compliant). This is used by decoders to force\n\tmultiple decoding of the same data frame (Info).*/\n\tGF_PACKED_FRAMES\t\t\t\t\t= 2,\n\t/*!Indicates the end of a stream or of a file (Info).*/\n\tGF_EOS\t\t\t\t\t\t\t\t= 1,\n\t/*!\n\t\\n\\n\n\t*/\n\t/*!Operation success (no error).*/\n\tGF_OK\t\t\t\t\t\t\t\t= 0,\n\t/*!\\n*/\n\t/*!One of the input parameter is not correct or cannot be used in the current operating mode of the framework.*/\n\tGF_BAD_PARAM\t\t\t\t\t\t\t= -1,\n\t/*! Memory allocation failure.*/\n\tGF_OUT_OF_MEM\t\t\t\t\t\t\t= -2,\n\t/*! Input/Output failure (disk access, system call failures)*/\n\tGF_IO_ERR\t\t\t\t\t\t\t\t= -3,\n\t/*! The desired feature or operation is not supported by the framework*/\n\tGF_NOT_SUPPORTED\t\t\t\t\t\t= -4,\n\t/*! Input data has been corrupted*/\n\tGF_CORRUPTED_DATA\t\t\t\t\t\t= -5,\n\t/*! A modification was attempted on a scene node which could not be found*/\n\tGF_SG_UNKNOWN_NODE\t\t\t\t\t\t= -6,\n\t/*! The PROTO node interface does not match the nodes using it*/\n\tGF_SG_INVALID_PROTO\t\t\t\t\t\t= -7,\n\t/*! An error occured in the scripting engine*/\n\tGF_SCRIPT_ERROR\t\t\t\t\t\t\t= -8,\n\t/*! Buffer is too small to contain decoded data. Decoders shall use this error whenever they need to resize their output memory buffers*/\n\tGF_BUFFER_TOO_SMALL\t\t\t\t\t\t= -9,\n\t/*! Bitstream is not compliant to the specfication it refers to*/\n\tGF_NON_COMPLIANT_BITSTREAM\t\t\t\t= -10,\n\t/*! No decoders could be found to handle the desired media type*/\n\tGF_CODEC_NOT_FOUND\t\t\t\t\t\t= -11,\n\t/*! The URL is not properly formatted or cannot be found*/\n\tGF_URL_ERROR\t\t\t\t\t\t\t= -12,\n\t/*! An service error has occured at the local side*/\n\tGF_SERVICE_ERROR\t\t\t\t\t\t= -13,\n\t/*! A service error has occured at the remote (server) side*/\n\tGF_REMOTE_SERVICE_ERROR\t\t\t\t\t= -14,\n\t/*! The desired stream could not be found in the service*/\n\tGF_STREAM_NOT_FOUND\t\t\t\t\t\t= -15,\n\t/*! The IsoMedia file is not a valid one*/\n\tGF_ISOM_INVALID_FILE\t\t\t\t\t= -20,\n\t/*! The IsoMedia file is not complete. Either the file is being downloaded, or it has been truncated*/\n\tGF_ISOM_INCOMPLETE_FILE\t\t\t\t\t= -21,\n\t/*! The media in this IsoMedia track is not valid (usually due to a broken stream description)*/\n\tGF_ISOM_INVALID_MEDIA\t\t\t\t\t= -22,\n\t/*! The requested operation cannot happen in the current opening mode of the IsoMedia file*/\n\tGF_ISOM_INVALID_MODE\t\t\t\t\t= -23,\n\t/*! This IsoMedia track refers to media outside the file in an unknown way*/\n\tGF_ISOM_UNKNOWN_DATA_REF\t\t\t\t= -24,\n\n\t/*! An invalid MPEG-4 Object Descriptor was found*/\n\tGF_ODF_INVALID_DESCRIPTOR\t\t\t\t= -30,\n\t/*! An MPEG-4 Object Descriptor was found or added to a forbidden descriptor*/\n\tGF_ODF_FORBIDDEN_DESCRIPTOR\t\t\t\t= -31,\n\t/*! An invalid MPEG-4 BIFS command was detected*/\n\tGF_ODF_INVALID_COMMAND\t\t\t\t\t= -32,\n\t/*! The scene has been encoded using an unknown BIFS version*/\n\tGF_BIFS_UNKNOWN_VERSION\t\t\t\t\t= -33,\n\n\t/*! The remote IP address could not be solved*/\n\tGF_IP_ADDRESS_NOT_FOUND\t\t\t\t\t= -40,\n\t/*! The connection to the remote peer has failed*/\n\tGF_IP_CONNECTION_FAILURE\t\t\t\t= -41,\n\t/*! The network operation has failed*/\n\tGF_IP_NETWORK_FAILURE\t\t\t\t\t= -42,\n\t/*! The network connection has been closed*/\n\tGF_IP_CONNECTION_CLOSED\t\t\t\t\t= -43,\n\t/*! The network operation has failed because no data is available*/\n\tGF_IP_NETWORK_EMPTY\t\t\t\t\t\t= -44,\n\t/*! The network operation has been discarded because it would be a blocking one*/\n\tGF_IP_SOCK_WOULD_BLOCK\t\t\t\t\t= -45,\n\t/*! UDP connection did not receive any data at all. Signaled by client services to reconfigure network if possible*/\n\tGF_IP_UDP_TIMEOUT\t\t\t\t\t\t= -46,\n\n\t/*! Authentication with the remote host has failed*/\n\tGF_AUTHENTICATION_FAILURE\t\t\t\t= -50,\n\t/*! Script not ready for playback */\n\tGF_SCRIPT_NOT_READY\t\t\t\t\t\t= -51,\n\t/*! Bad configuration for the current contex */\n\tGF_INVALID_CONFIGURATION\t\t\t\t= -52,\n\t/*! The element has not been found */\n\tGF_NOT_FOUND\t\t\t\t\t\t\t= -53,\n\t/*! Unexpected format of data */\n\tGF_PROFILE_NOT_SUPPORTED\t\t\t\t= -54,\n\t/*! the decoder buffers were filled, it is necessary to recuperate decoded data*/\n\tGF_CODEC_BUFFER_UNAVAILABLE\t\t\t\t= -55,\n} GF_Err;\n\n/*!\n *\t\\brief Error Printing\n *\n *\tReturns a printable version of a given error\n *\t\\param e Error code requested\n *\t\\return String representing the error\n*/\nconst char *gf_error_to_string(GF_Err e);\n\n/*! @} */\n\n/*! \\addtogroup log_grp Logging tools\n *\t\\ingroup utils_grp\n *\t\\brief Logging system of GPAC\n *\t@{\n */\n\n/*!\n * GPAC Log Levels\n *\t\\hideinitializer\n *\n * These levels describes messages priority used when filtering logs\n */\ntypedef enum\n{\n\t/*! Disable all Log message*/\n\tGF_LOG_QUIET = 0,\n\t/*! Log message describes an error*/\n\tGF_LOG_ERROR,\n\t/*! Log message describes a warning*/\n\tGF_LOG_WARNING,\n\t/*! Log message is informational (state, etc..)*/\n\tGF_LOG_INFO,\n\t/*! Log message is a debug info*/\n\tGF_LOG_DEBUG\n} GF_LOG_Level;\n\n/*!\n *\t\\brief Log exits at first error assignment\n *\n * When GF_LOG_ERROR happens, program leaves with instruction exit(1);\n *\t\\param strict strict behaviour when encoutering a serious error.\n *\n */\nvoid gf_log_set_strict_error(Bool strict);\n\n/*!\n *\t\\brief gets string-formated log tools\n *\n * Returns the string-formatted log tools and levels. Returned string shall be freed by the caller.\n *\t\\return string-formatted log tools.\n *\n */\nchar *gf_log_get_tools_levels();\n\n/*!\n * GPAC Log tools\n *\t\\hideinitializer\n *\n * These flags describes which sub-part of GPAC generates the log and are used when filtering logs\n */\ntypedef enum\n{\n\t/*! Log message from the core library (init, threads, network calls, etc)*/\n\tGF_LOG_CORE = 0,\n\t/*! Log message from a raw media parser (BIFS, LASeR, A/V formats)*/\n\tGF_LOG_CODING,\n\t/*! Log message from a bitstream parser (IsoMedia, MPEG-2 TS, OGG, ...)*/\n\tGF_LOG_CONTAINER,\n\t/*! Log message from the network/service stack (messages & co)*/\n\tGF_LOG_NETWORK,\n\t/*! Log message from the RTP/RTCP stack (TS info) and packet structure & hinting (debug)*/\n\tGF_LOG_RTP,\n\t/*! Log message from authoring subsystem (file manip, import/export)*/\n\tGF_LOG_AUTHOR,\n\t/*! Log message from the sync layer of the terminal*/\n\tGF_LOG_SYNC,\n\t/*! Log message from a codec*/\n\tGF_LOG_CODEC,\n\t/*! Log message from any XML parser (context loading, etc)*/\n\tGF_LOG_PARSER,\n\t/*! Log message from the terminal/compositor, indicating media object state*/\n\tGF_LOG_MEDIA,\n\t/*! Log message from the scene graph/scene manager (handling of nodes and attribute modif, DOM core)*/\n\tGF_LOG_SCENE,\n\t/*! Log message from the scripting engine APIs - does not cover alert() in the script code itself*/\n\tGF_LOG_SCRIPT,\n\t/*! Log message from event handling*/\n\tGF_LOG_INTERACT,\n\t/*! Log message from compositor*/\n\tGF_LOG_COMPOSE,\n\t/*! Log for video object cache */\n\tGF_LOG_CACHE,\n\t/*! Log message from multimedia I/O devices (audio/video input/output, ...)*/\n\tGF_LOG_MMIO,\n\t/*! Log for runtime info (times, memory, CPU usage)*/\n\tGF_LOG_RTI,\n\t/*! Log for SMIL timing and animation*/\n\tGF_LOG_SMIL,\n\t/*! Log for memory tracker*/\n\tGF_LOG_MEMORY,\n\t/*! Log for audio compositor*/\n\tGF_LOG_AUDIO,\n\t/*! Generic Log for modules*/\n\tGF_LOG_MODULE,\n\t/*! Log for threads and mutexes */\n\tGF_LOG_MUTEX,\n\t/*! Log for threads and condition */\n\tGF_LOG_CONDITION,\n\t/*! Log for all HTTP streaming */\n\tGF_LOG_DASH,\n\t/*! Log for all messages coming from GF_Terminal or script alert()*/\n\tGF_LOG_CONSOLE,\n\t/*! Log for all messages coming the application, not used by libgpac or the modules*/\n\tGF_LOG_APP,\n\t/*! Log for all messages coming from the scheduler */\n\tGF_LOG_SCHEDULER,\n\n\t/*! special value used to set a level for all tools*/\n\tGF_LOG_ALL,\n\tGF_LOG_TOOL_MAX = GF_LOG_ALL,\n} GF_LOG_Tool;\n\n/*!\n *\t\\brief Log modules assignment\n *\n * Sets the tools to be checked for log filtering. By default no logging is performed.\n *\t\\param tool tool to be logged.\n *\t\\param level level of logging for this tool.\n *\n */\nvoid gf_log_set_tool_level(GF_LOG_Tool tool, GF_LOG_Level level);\n\n/*!\n *\t\\brief Log Message Callback\n *\n * The gf_log_cbk type is the type for the callback of the \\ref gf_log_set_callback function. By default all logs are redirected to stderr\n *\t\\param cbck Opaque user data.\n *\t\\param log_level level of the log. This value is not guaranteed in multi-threaded context.\n *\t\\param log_tool tool emitting the log. This value is not guaranteed in multi-threaded context.\n *\t\\param fmt message log format.\n *\t\\param vlist message log param.\n *\n */\ntypedef void (*gf_log_cbk)(void *cbck, GF_LOG_Level log_level, GF_LOG_Tool log_tool, const char* fmt, va_list vlist);\n\n/*!\n *\t\\brief Log overwrite\n *\n *\tAssigns a user-defined callback for printing log messages. By default all logs are redirected to stderr\n *\t\\param usr_cbk Opaque user data\n *\t\\param cbk     Callback log function\n *\t\\return previous callback function\n*/\ngf_log_cbk gf_log_set_callback(void *usr_cbk, gf_log_cbk cbk);\n\n\n/*!\n \\cond DUMMY_DOXY_SECTION\n*/\n#ifndef GPAC_DISABLE_LOG\n/*note:\n\t\tto turn log on, change to GPAC_ENABLE_LOG\n\t\tto turn log off, change to GPAC_DISABLE_LOG\n\tthis is needed by configure+sed to modify this file directly\n*/\n#define GPAC_ENABLE_LOG\n#endif\n\n/*!\n \\endcond\n*/\n\n\n/*this is all a bit ugly, but most compilers don't properly handle variadic macros...*/\nvoid gf_log(const char *fmt, ...);\nvoid gf_log_lt(GF_LOG_Level ll, GF_LOG_Tool lt);\nvoid gf_log_va_list(GF_LOG_Level level, GF_LOG_Tool tool, const char *fmt, va_list vl);\n\n\n/*!\n *\t\\brief Log level checking\n *\n *\tChecks if a given tool is logged for the given level\n *\t\\param log_tool tool to check\n *\t\\param log_level level to check\n *\t\\return 1 if logged, 0 otherwise\n*/\nBool gf_log_tool_level_on(GF_LOG_Tool log_tool, GF_LOG_Level log_level);\n\n/*!\n *\t\\brief Set log tools and levels\n *\n *\tSet log tools and levels according to the log_tools_levels string. All previous log settings are discarded.\n *\t\\param log_tools_levels string specifying the tools and levels. It is formatted as logToolX\\@logLevelX:logToolZ\\@logLevelZ:...\n *\t\\return GF_OK or GF_BAD_PARAM\n*/\nGF_Err gf_log_set_tools_levels(const char *log_tools_levels);\n\n/*!\n *\t\\brief Modify log tools and levels\n *\n *\tModify log tools and levels according to the log_tools_levels string. Previous log settings are kept.\n *\t\\param val string specifying the tools and levels. It is formatted as logToolX\\@logLevelX:logToolZ\\@logLevelZ:...\n *\t\\return GF_OK or GF_BAD_PARAM\n*/\nGF_Err gf_log_modify_tools_levels(const char *val);\n\n/*!\n *\t\\brief Set log level for a given tool\n *\n *\tSet log level for a given tool.\n *\t\\param tool tool to log\n *\t\\param level log level for this tool\n*/\nvoid gf_log_set_tool_level(GF_LOG_Tool tool, GF_LOG_Level level);\n\n#ifdef GPAC_DISABLE_LOG\n#define GF_LOG(_ll, _lm, __args)\n#else\n/*!\n *\t\\brief Message logging\n *\t\\hideinitializer\n *\n *\tMacro for logging messages. Usage is GF_LOG(log_lev, log_module, (fmt, ...)). The log function is only called if log filtering allows it. This avoids fetching logged parameters when the tool is not being logged.\n*/\n#define GF_LOG(_log_level, _log_tools, __args) if (gf_log_tool_level_on(_log_tools, _log_level) ) { gf_log_lt(_log_level, _log_tools); gf_log __args ;}\n#endif\n\n\n/*!\n *\t\\brief PseudoRandom Integer Generation Initialization\n *\n *\tSets the starting point for generating a series of pseudorandom integers.\n *\t\\param Reset Re-initializes the random number generator\n*/\nvoid gf_rand_init(Bool Reset);\n/*!\n *\t\\brief PseudoRandom Integer Generation\n *\n *\tReturns a pseudorandom integer.\n*/\nu32 gf_rand();\n\n/*!\n *\t\\brief user name\n *\n *\tGets current user (login) name.\n*/\nvoid gf_get_user_name(char *buf, u32 buf_size);\n\n\n/*!\\brief FileEnum info object\n *\n *The FileEnumInfo object is used to get file attributes upon enumeration of a directory.\n*/\ntypedef struct\n{\n\t/*!File is marked as hidden*/\n\tBool hidden;\n\t/*!File is a directory*/\n\tBool directory;\n\t/*!File is a drive mountpoint*/\n\tBool drive;\n\t/*!File is a system file*/\n\tBool system;\n\t/*!File size in bytes*/\n\tu64 size;\n\t/*!File last modif time in UTC seconds*/\n\tu64 last_modified;\n} GF_FileEnumInfo;\n\n/*!\n *\t\\brief Directory Enumeration Callback\n *\n * The gf_enum_dir_item type is the type for the callback of the \\ref gf_enum_directory function\n *\t\\param cbck Opaque user data.\n *\t\\param item_name File or directory name.\n *\t\\param item_path File or directory full path and name from filesystem root.\n *\t\\param file_info information for the file or directory.\n *\t\\return 1 to abort enumeration, 0 to continue enumeration.\n *\n */\ntypedef Bool (*gf_enum_dir_item)(void *cbck, char *item_name, char *item_path, GF_FileEnumInfo *file_info);\n/*!\n *\t\\brief Directory enumeration\n *\n *\tEnumerates a directory content. Feedback is provided by the enum_dir_item function\n *\t\\param dir Directory to enumerate\n *\t\\param enum_directory If set, only directories will be enumerated, otherwise only files are.\n *\t\\param enum_dir \\ref gf_enum_dir_item callback function for enumeration.\n *\t\\param cbck Opaque user data passed to callback function.\n *\t\\param filter optional filter for file extensions. If a file extension without the dot '.' character is not found in the\n *\tfilter the file will be skipped.\n*/\nGF_Err gf_enum_directory(const char *dir, Bool enum_directory, gf_enum_dir_item enum_dir, void *cbck, const char *filter);\n\n\n/*!\n *\t\\brief File Deletion\n *\n *\tDeletes a file from the disk.\n *\t\\param fileName absolute name of the file or name relative to the current working directory.\n*/\nGF_Err gf_delete_file(const char *fileName);\n\n/*!\n *\t\\brief File Move\n *\n *\tMoves or renames a file or directory.\n *\t\\param fileName absolute path of the file / directory to move or rename\n *\t\\param newFileName absolute new path/name of the file / directory\n*/\nGF_Err gf_move_file(const char *fileName, const char *newFileName);\n\n/*!\n *\t\\brief Temporary File Creation\n *\n *\tCreates a new temporary file in binary mode\n *\t\\param fileName if not NULL, strdup() of the temporary filename when created by GPAC (NULL otherwise as the system automatically removes its own tmp files)\n *\t\\return stream handle to the new file ressoucre\n */\nFILE *gf_temp_file_new(char ** const fileName);\n\n\n/*!\n *\t\\brief File Modification Time\n *\n *\tReturns the modification time of the given file. The exact meaning of this value is system dependent\n *\t\\param filename file to check\n *\t\\return modification time of the file\n */\nu64 gf_file_modification_time(const char *filename);\n\n/*!\n *\t\\brief File existence check\n *\n *\tMoves or renames a file or directory.\n *\t\\param fileName absolute path of the file / directory to move or rename\n *\t\\return GF_TRUE if file exists\n */\nBool gf_file_exists(const char *fileName);\n\n/*!\n *\t\\brief Progress formatting\n *\n *\tSignals progress in GPAC's operations. Note that progress signaling with this function is not thread-safe, the main purpose is to use it for authoring tools only.\n *\t\\param title title string of the progress, or NULL for no progress\n *\t\\param done Current amount performed of the action.\n *\t\\param total Total amount of the action.\n */\nvoid gf_set_progress(const char *title, u64 done, u64 total);\n\n/*!\n *\t\\brief Progress Callback\n *\n * The gf_on_progress_cbk type is the type for the callback of the \\ref gf_set_progress_callback function\n *\t\\param cbck Opaque user data.\n *\t\\param title preogress title.\n *\t\\param done Current amount performed of the action\n *\t\\param total Total amount of the action.\n *\n */\ntypedef void (*gf_on_progress_cbk)(const void *cbck, const char *title, u64 done, u64 total);\n\n/*!\n *\t\\brief Progress overwriting\n *\n *\tIverwrites the progress signaling function by a user-defined one.\n *\t\\param user_cbk Opaque user data\n *\t\\param prog_cbk new callback function to use. Passing NULL restore default GPAC stderr notification.\n */\nvoid gf_set_progress_callback(void *user_cbk, gf_on_progress_cbk prog_cbk);\n\n\n/*!\n *\t\\brief Prompt checking\n *\n *\tChecks if a character is pending in the prompt buffer.\n *\t\\return 1 if a character is ready to be fetched, 0 otherwise.\n *\t\\note Function not available under WindowsCE nor SymbianOS\n*/\nBool gf_prompt_has_input();\n\n/*!\n *\t\\brief Prompt character flush\n *\n *\tReturns the current character entered at prompt if any.\n *\t\\return value of the character.\n *\t\\note Function not available under WindowsCE nor SymbianOS\n*/\nchar gf_prompt_get_char();\n\n\n/*!\n *\t\\brief turns prompt echo on/off\n *\n *\tTurns the prompt character echo on/off - this is useful when entering passwords.\n *\t\\param echo_off indicates whether echo should be turned on or off.\n *\t\\note Function not available under WindowsCE nor SymbianOS\n*/\nvoid gf_prompt_set_echo_off(Bool echo_off);\n\n/*!\t@} */\n\n/*!\n *\\addtogroup cpu_grp System time CPU and Memory tools\n *\\ingroup utils_grp\n *\\brief System time CPU and Memory functions\n *\n *This section documents time functionalities and CPU management in GPAC.\n  *\t@{\n */\n\n/*!\n * Selection flags for memory tracker\n *\t\\hideinitializer\n */\ntypedef enum\n{\n    /*! No memory tracking*/\n    GF_MemTrackerNone = 0,\n    /*! Memory tracking without backtrace*/\n    GF_MemTrackerSimple,\n    /*! Memory tracking with backtrace*/\n    GF_MemTrackerBackTrace,\n} GF_MemTrackerType;\n\n/*!\n *\t\\brief System setup\n *\n *\tInits the system high-resolution clock if any, and CPU usage manager. It is strongly recommended to call this\n * function before calling any other GPAC functions, since on some systems (like winCE) it may result in a better memory usage estimation.\n *\t\\note This can be called several times but only the first call will result in system setup.\n */\nvoid gf_sys_init(GF_MemTrackerType mem_tracker_type);\n/*!\n *\t\\brief System closing\n *\n *\tCloses the system high-resolution clock and any CPU associated ressources.\n *\t\\note This can be called several times but the system will be closed when no more users are counted.\n */\nvoid gf_sys_close();\n\n/*!\n *\t\\brief System arguments\n *\n *\tSets the user app arguments (used by GUI mode)\n *\t\\param argc Number of arguments\n *\t\\param argv Array of arguments\n */\nvoid gf_sys_set_args(s32 argc, const char **argv);\n\n/*!\n *\t\\brief Get number of args\n *\n *\tGets the number of argument of the user application if any\n *\t\\return number of argument of the user application\n */\nu32 gf_sys_get_argc();\n\n/*!\n *\t\\brief Get number of args\n *\n *\tGets the number of argument of the user application if any\n *\t\\param arg Index of argument to retrieve\n *\t\\return number of argument of the user application\n */\nconst char *gf_sys_get_arg(u32 arg);\n\n/*!\n *\t\\brief System clock query\n *\n *\tGets the system clock time.\n *\t\\return System clock value since GPAC initialization in milliseconds.\n */\nu32 gf_sys_clock();\n\n/*!\n *\t\\brief High precision system clock query\n *\n *\tGets the hight precision system clock time.\n *\t\\return System clock value since GPAC initialization in microseconds.\n */\nu64 gf_sys_clock_high_res();\n\n/*!\n *\t\\brief Sleeps thread/process\n *\n *\tLocks calling thread/process execution for a given time.\n *\t\\param ms Amount of time to sleep in milliseconds.\n */\nvoid gf_sleep(u32 ms);\n\n#ifdef WIN32\n/*!\n *\t\\brief WINCE time constant\n *\t\\hideinitializer\n *\n *\ttime between jan 1, 1601 and jan 1, 1970 in units of 100 nanoseconds\n*/\n#define TIMESPEC_TO_FILETIME_OFFSET (((LONGLONG)27111902 << 32) + (LONGLONG)3577643008)\n\n#endif\n\n/*!\n *\\brief gets UTC time in milliseconds\n *\n * Gets UTC clock in milliseconds\n * \\return UTC time in milliseconds\n */\nu64 gf_net_get_utc();\n\n/*!\n *\\brief parses date and returns UTC value for this date. Date format is an XSD dateTime format or any of the supported formats from HTTP 1.1:\n\tSun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123\n\tSunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036\n\tSun Nov  6 08:49:37 1994       ; ANSI C's asctime() formatgets UTC time in milliseconds\n *\n * \\param date string containing the date to parse\n * \\return UTC time in milliseconds\n */\nu64 gf_net_parse_date(const char *date);\n\n/*!\n *\\brief gets timezone adjustment in seconds\n *\n * Gets timezone adjustment in seconds, with localtime - timezone = UTC time\n * \\return timezone shift in seconds\n */\ns32 gf_net_get_timezone();\n\n/*!\\brief run-time system info object\n *\n *The Run-Time Info object is used to get CPU and memory occupation of the calling process.\n *All time values are expressed in milliseconds (accuracy is not guaranteed).\n*/\ntypedef struct\n{\n\t/*!start of the sampling period*/\n\tu32 sampling_instant;\n\t/*!duration of the sampling period*/\n\tu32 sampling_period_duration;\n\t/*!total amount of time (User+kernel) spent in CPU for all processes as evaluated at the end of the sampling period*/\n\tu32 total_cpu_time;\n\t/*!total amount of time (User+kernel) spent in CPU for the calling process as evaluated at the end of the sampling period*/\n\tu32 process_cpu_time;\n\t/*!amount of time (User+kernel) spent in CPU for all processes during the sampling period*/\n\tu32 total_cpu_time_diff;\n\t/*!total amount of time (User+kernel) spent in CPU for the calling process during the sampling period*/\n\tu32 process_cpu_time_diff;\n\t/*!total amount of idle time during the sampling period.*/\n\tu32 cpu_idle_time;\n\t/*!percentage (from 0 to 100) of CPU usage during the sampling period.*/\n\tu32 total_cpu_usage;\n\t/*!percentage (from 0 to 100) of the CPU usage by the calling process during the sampling period.*/\n\tu32 process_cpu_usage;\n\t/*!calling process ID*/\n\tu32 pid;\n\t/*!calling process thread count if known*/\n\tu32 thread_count;\n\t/*!size of calling process allocated heaps*/\n\tu64 process_memory;\n\t/*!total physical memory in system*/\n\tu64 physical_memory;\n\t/*!available physical memory in system*/\n\tu64 physical_memory_avail;\n\t/*!total memory currently allocated by gpac*/\n\tu64 gpac_memory;\n\t/*!total number of cores on the system*/\n\tu32 nb_cores;\n} GF_SystemRTInfo;\n\n/*!\n * Selection flags for run-time info retrieval\n *\t\\hideinitializer\n */\nenum\n{\n\t/*!Indicates all processes' times must be fetched. If not set, only the current process times will be retrieved, and the\n\tthread count and total times won't be available*/\n\tGF_RTI_ALL_PROCESSES_TIMES = 1,\n\t/*!Indicates the process allocated heap size must be fetch. If not set, only the system physical memory is fetched.\n\tFetching the entire ocess  allocated memory can have a large impact on performances*/\n\tGF_RTI_PROCESS_MEMORY = 1<<1,\n\t/*!Indicates that only system memory should be fetched. When set, all refreshing info is ignored*/\n\tGF_RTI_SYSTEM_MEMORY_ONLY = 1<<2\n};\n\n/*!\n *\t\\brief Gets Run-Time info\n *\n *\tGets CPU and memory usage info for the calling process and the system. Information gathering\n * is controled through timeout values.\n *\t\\param refresh_time_ms refresh time period in milliseconds. If the last sampling was done less than this period ago, the run-time info is not refreshed.\n *\t\\param rti holder to the run-time info structure to update.\n *\t\\param flags specify which info is to be retrieved.\n *\t\\return 1 if info has been updated, 0 otherwise.\n *\t\\note You should not try to use a too small refresh time. Typical values are 500 ms or one second.\n */\nBool gf_sys_get_rti(u32 refresh_time_ms, GF_SystemRTInfo *rti, u32 flags);\n\n\nBool gf_sys_get_battery_state(Bool *onBattery, u32 *onCharge, u32 *level, u32 *batteryLifeTime, u32 *batteryFullLifeTime);\n\ntypedef struct _GF_GlobalLock_opaque GF_GlobalLock;\n\n/*!\n * This function allows the user to create a global lock for all GPAC instances.\n * This allow to disable some features for other instances for instance.\n * \\param resourceName The name of the resource to lock\n * \\return false if resource has been locked, true if resource could not be locked\n */\nGF_GlobalLock * gf_global_resource_lock(const char * resourceName);\n\n/*!\n * Unlock a previouly locked resource\n * \\param lock The resource to unlock\n * \\return GF_OK if evertything went fine\n */\nGF_Err gf_global_resource_unlock(GF_GlobalLock * lock);\n\n/*!\t@} */\n\n/*!\n *\\addtogroup osfile_grp File System\n *\\ingroup utils_grp\n *\\brief File System tools\n *\n *This section documents time functionalities and CPU management in GPAC.\n  *\t@{\n */\n\n\n\n/*!\n *\\brief parses 128 bit from string\n *\n * Parses 128 bit from string\n *\n * \\param string the string containing the value in hexa. Non alphanum characters are skipped\n * \\param value the value parsed\n * \\return error code if any\n */\nGF_Err gf_bin128_parse(const char *string, bin128 value);\n\n/*!\n *\t\\brief Delete Directory\n *\n *\tDelete a  dir within the full path.\n *\t\\param DirPathName the file path name.\n */\nGF_Err gf_rmdir(const char *DirPathName);\n\n/*!\n *\t\\brief Create Directory\n *\n *\tCreate a directory within the full path.\n *\t\\param DirPathName the dir path name.\n */\nGF_Err gf_mkdir(const char* DirPathName);\n\n/*!\n *\t\\brief Check Directory Exists\n *\n *\tCreate a directory within the full path.\n *\t\\param DirPathName the dir path name.\n */\nBool gf_dir_exists(const char *DirPathName);\n\n/*!\n *\t\\brief Create Directory\n *\n *\tCleanup a directory within the full path, removing all the files and the directories.\n *\t\\param DirPathName the dir path name.\n */\nGF_Err gf_cleanup_dir(const char* DirPathName);\n\n\n/**\n * Gets a newly allocated string containing the default cache directory.\n * It is the responsibility of the caller to free the string.\n * \\return a fully qualified path to the default cache directory\n */\nchar * gf_get_default_cache_directory();\n\n/**\n * Gets the number of open file handles (gf_fopen/gf_fclose only).\n * \\return  number of open file handles\n */\nu32 gf_file_handles_count();\n\n/*!\t@} */\n\n/*!\n *\\addtogroup hash_grp RawData Misc\n *\\ingroup utils_grp\n *\\brief Data integrity and parsing\n *\n *This section documents misc data functions such as integrity and parsing such as SHA-1 hashing CRC checksum, 128 bit ID parsing...\n  *\t@{\n */\n\n\n/*!\n *\t\\brief CRC32 compute\n *\n *\tComputes the CRC32 value of a buffer.\n *\t\\param data buffer\n *\t\\param size buffer size\n *\t\\return computed CRC32\n */\nu32 gf_crc_32(const char *data, u32 size);\n\n\n/**\n * Compresses a data buffer in place using zlib. Buffer may be reallocated in the process.\n * \\param data pointer to the data buffer to be compressed\n * \\param data_len length of the data buffer to be compressed\n * \\param out_size pointer for output buffer size\n * \\return GF_OK if evertything went fine\n */\nGF_Err gf_gz_compress_payload(char **data, u32 data_len, u32 *out_size);\n\n/**\n * Decompresses a data buffer using zlib.\n * \\param data data buffer to be decompressed\n * \\param data_len length of the data buffer to be decompressed\n * \\param uncompressed_data pointer to the uncompressed data buffer. It is the responsibility of the caller to free this buffer.\n * \\param out_size size of the uncompressed buffer\n * \\return GF_OK if evertything went fine\n */\nGF_Err gf_gz_decompress_payload(char *data, u32 data_len, char **uncompressed_data, u32 *out_size);\n\n\n/*SHA1*/\ntypedef struct __sha1_context GF_SHA1Context;\n\n#define GF_SHA1_DIGEST_SIZE\t\t20\n#define GF_SHA1_DIGEST_SIZE_HEXA\t\t41\n/*  Create SHA-1 context */\nGF_SHA1Context *gf_sha1_starts();\n/*  Adds byte to the SHA-1 context */\nvoid gf_sha1_update(GF_SHA1Context *ctx, u8 *input, u32 length);\n/*  Generates SHA-1 of all bytes ingested */\nvoid gf_sha1_finish(GF_SHA1Context *ctx, u8 digest[GF_SHA1_DIGEST_SIZE] );\n\n/*\n * Output SHA-1(file contents), returns 0 if successful.\n */\nint gf_sha1_file(const char *filename, u8 digest[GF_SHA1_DIGEST_SIZE]);\n\n/*\n * Gets SHA-1 of input buffer\n */\nvoid gf_sha1_csum(u8 *buf, u32 buflen, u8 digest[GF_SHA1_DIGEST_SIZE]);\n/*\n * Gets SHA-1 of input buffer into hexa form\n */\nvoid gf_sha1_csum_hexa(u8 *buf, u32 buflen, u8 digest[GF_SHA1_DIGEST_SIZE_HEXA]);\n\n/*! @} */\n\n\n/* \\cond dummy */\n#ifdef GPAC_ANDROID\ntypedef void (*fm_callback_func)(void *cbk_obj, u32 type, u32 param, int *value);\nextern void gf_fm_request_set_callback(void *cbk_obj, fm_callback_func cbk_func);\nvoid gf_fm_request_call(u32 type, u32 param, int *value);\n#endif //GPAC_ANDROID\n\n/* \\endcond */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif\t\t/*_GF_CORE_H_*/\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n#include <gpac/internal/media_dev.h>\n#endif\n\n#ifndef GPAC_DISABLE_ISOM\n\n\nBool gf_isom_is_nalu_based_entry(GF_MediaBox *mdia, GF_SampleEntryBox *_entry)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (mdia->handler->handlerType != GF_ISOM_MEDIA_VISUAL) return GF_FALSE;\n\tswitch (_entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_SVC2:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC2:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_MHV1:\n\tcase GF_ISOM_BOX_TYPE_MHC1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_LHT1:\n\t\treturn GF_TRUE;\n\tcase GF_ISOM_BOX_TYPE_GNRV:\n\tcase GF_ISOM_BOX_TYPE_GNRA:\n\tcase GF_ISOM_BOX_TYPE_GNRM:\n\t\treturn GF_FALSE;\n\tdefault:\n\t\tbreak;\n\t}\n\tentry = (GF_MPEGVisualSampleEntryBox*)_entry;\n\tif (!entry) return GF_FALSE;\n\tif (entry->avc_config || entry->svc_config || entry->mvc_config || entry->hevc_config || entry->lhvc_config) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\n\nstatic void rewrite_nalus_list(GF_List *nalus, GF_BitStream *bs, Bool rewrite_start_codes, u32 nal_unit_size_field)\n{\n\tu32 i, count = gf_list_count(nalus);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot*)gf_list_get(nalus, i);\n\t\tif (rewrite_start_codes) gf_bs_write_u32(bs, 1);\n\t\telse gf_bs_write_int(bs, sl->size, 8*nal_unit_size_field);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n}\n\n\nstatic GF_Err process_extractor(GF_ISOFile *file, GF_MediaBox *mdia, u32 sampleNumber, u64 sampleDTS, u32 nal_size, u16 nal_hdr, u32 nal_unit_size_field, Bool is_hevc, Bool rewrite_ps, Bool rewrite_start_codes, GF_BitStream *src_bs, GF_BitStream *dst_bs, u32 extractor_mode)\n{\n\tGF_Err e;\n\tu32 di, ref_track_index, ref_track_num, data_offset, data_length, cur_extract_mode, ref_extract_mode, ref_nalu_size, nb_bytes_nalh;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_ISOSample *ref_samp;\n\tGF_BitStream *ref_bs;\n\tGF_TrackBox *ref_trak;\n\ts8 sample_offset;\n\tchar*buffer = NULL;\n\tu32 max_size = 0;\n\tu32 last_byte, ref_sample_num, prev_ref_sample_num;\n\tBool header_written = GF_FALSE;\n\tnb_bytes_nalh = is_hevc ? 2 : 1;\n\n\tswitch (extractor_mode) {\n\tcase 0:\n\t\tlast_byte = (u32) gf_bs_get_position(src_bs) + nal_size - (is_hevc ? 2 : 1);\n\t\tif (!is_hevc) gf_bs_read_int(src_bs, 24); //1 byte for HEVC , 3 bytes for AVC of NALUHeader in extractor\n\t\twhile (gf_bs_get_position(src_bs) < last_byte) {\n\t\t\tu32 xmode = 0;\n\t\t\t//hevc extractors use constructors\n\t\t\tif (is_hevc) xmode = gf_bs_read_u8(src_bs);\n\t\t\tif (xmode) {\n\t\t\t\tu8 done=0, len = gf_bs_read_u8(src_bs);\n\t\t\t\twhile (done<len) {\n\t\t\t\t\tu8 c = gf_bs_read_u8(src_bs);\n\t\t\t\t\tdone++;\n\t\t\t\t\tif (header_written) {\n\t\t\t\t\t\tgf_bs_write_u8(dst_bs, c);\n\t\t\t\t\t} else if (done==nal_unit_size_field) {\n\t\t\t\t\t\tif (rewrite_start_codes) {\n\t\t\t\t\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_bs_write_u8(dst_bs, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\theader_written = GF_TRUE;\n\t\t\t\t\t} else if (!rewrite_start_codes) {\n\t\t\t\t\t\tgf_bs_write_u8(dst_bs, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tref_track_index = gf_bs_read_u8(src_bs);\n\t\t\tsample_offset = (s8) gf_bs_read_int(src_bs, 8);\n\t\t\tdata_offset = gf_bs_read_int(src_bs, nal_unit_size_field*8);\n\t\t\tdata_length = gf_bs_read_int(src_bs, nal_unit_size_field*8);\n\n\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &dpnd);\n\t\t\tref_track_num = 0;\n\t\t\tif (dpnd && ref_track_index && (ref_track_index<=dpnd->trackIDCount))\n\t\t\t\tref_track_num = gf_isom_get_track_by_id(file, dpnd->trackIDs[ref_track_index-1]);\n\n\t\t\tif (!ref_track_num) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"ISOBMF: Extractor target track is not present in file - skipping.\\n\"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\n\t\t\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, ref_track_num);\n\n\t\t\t//we must be in inspect mode only otherwise the reference sample will not be the one stored on file (change in start codes, PS inserted or other NALUs inserted)\n\t\t\t//and this will corrupt extraction (wrong data offsets)\n\t\t\tref_extract_mode = GF_ISOM_NALU_EXTRACT_INSPECT;\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, ref_extract_mode);\n\n\t\t\tref_trak = gf_isom_get_track_from_file(file, ref_track_num);\n\t\t\tif (!ref_trak) return GF_ISOM_INVALID_FILE;\n\n\t\t\tref_samp = gf_isom_sample_new();\n\t\t\tif (!ref_samp) return GF_IO_ERR;\n\n\t\t\te = stbl_findEntryForTime(ref_trak->Media->information->sampleTable, sampleDTS, 0, &ref_sample_num, &prev_ref_sample_num);\n\t\t\tif (e) return e;\n\t\t\tif (!ref_sample_num) ref_sample_num = prev_ref_sample_num;\n\t\t\tif (!ref_sample_num) return GF_ISOM_INVALID_FILE;\n\t\t\tif ((sample_offset<0) && (ref_sample_num > (u32) -sample_offset)) return GF_ISOM_INVALID_FILE;\n\t\t\tref_sample_num = (u32) ( (s32) ref_sample_num + sample_offset);\n\n\t\t\te = Media_GetSample(ref_trak->Media, ref_sample_num, &ref_samp, &di, GF_FALSE, NULL);\n\t\t\tif (e) return e;\n\n#if 0\n\t\t\tif (!header_written && rewrite_start_codes) {\n\t\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\t\tif (is_hevc) {\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 1);\n\t\t\t\t\tgf_bs_write_int(dst_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 9);\n\t\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\t\tgf_bs_write_int(dst_bs, 2, 3);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 5);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_int(dst_bs, (ref_samp->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0xF0 , 8); /*7 \"all supported NALUs\" (=111) + rbsp trailing (10000)*/;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tref_bs = gf_bs_new(ref_samp->data + data_offset, ref_samp->dataLength - data_offset, GF_BITSTREAM_READ);\n\n\t\t\tif (ref_samp->dataLength - data_offset >= data_length) {\n\n\t\t\t\twhile (data_length && gf_bs_available(ref_bs)) {\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tref_nalu_size = gf_bs_read_int(ref_bs, 8*nal_unit_size_field);\n\n\t\t\t\t\t\tif (!data_length)\n\t\t\t\t\t\t\tdata_length = ref_nalu_size + nal_unit_size_field;\n\n\t\t\t\t\t\tassert(data_length>nal_unit_size_field);\n\t\t\t\t\t\tdata_length -= nal_unit_size_field;\n\t\t\t\t\t\tif (data_length > gf_bs_available(ref_bs)) {\n\t\t\t\t\t\t\tdata_length = (u32)gf_bs_available(ref_bs);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tref_nalu_size = data_length;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ref_nalu_size > max_size) {\n\t\t\t\t\t\tbuffer = (char*) gf_realloc(buffer, sizeof(char) * ref_nalu_size );\n\t\t\t\t\t\tmax_size = ref_nalu_size;\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_data(ref_bs, buffer, ref_nalu_size);\n\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\t\t\tgf_bs_write_u32(dst_bs, 1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgf_bs_write_int(dst_bs, ref_nalu_size, 8*nal_unit_size_field);\n\t\t\t\t\t}\n\t\t\t\t\tassert(data_length >= ref_nalu_size);\n\t\t\t\t\tgf_bs_write_data(dst_bs, buffer, ref_nalu_size);\n\t\t\t\t\tdata_length -= ref_nalu_size;\n\n\t\t\t\t\theader_written = GF_FALSE;\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Extractor size is larger than refered sample size - skipping.\\n\"));\n\t\t\t}\n\t\t\tgf_isom_sample_del(&ref_samp);\n\t\t\tref_samp = NULL;\n\t\t\tgf_bs_del(ref_bs);\n\t\t\tref_bs = NULL;\n\t\t\tif (buffer) gf_free(buffer);\n\t\t\tbuffer = NULL;\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, cur_extract_mode);\n\n\t\t\tif (!is_hevc) break;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\t//skip to end of this NALU\n\t\tgf_bs_skip_bytes(src_bs, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\tcase 2:\n\t\tbuffer = (char*) gf_malloc( sizeof(char) * (nal_size - nb_bytes_nalh));\n\t\tgf_bs_read_data(src_bs, buffer, nal_size - nb_bytes_nalh);\n\t\tif (rewrite_start_codes)\n\t\t\tgf_bs_write_u32(dst_bs, 1);\n\t\telse\n\t\t\tgf_bs_write_int(dst_bs, nal_size, 8*nal_unit_size_field);\n\n\t\tgf_bs_write_u8(dst_bs, nal_hdr);\n\t\tgf_bs_write_data(dst_bs, buffer, nal_size - nb_bytes_nalh);\n\t\tgf_free(buffer);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_HEVC\n/* returns the SAP type as defined in the 14496-12 specification */\nstatic SAPType sap_type_from_nal_type(u8 nal_type) {\n\tswitch (nal_type) {\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\treturn SAP_TYPE_3;\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\treturn SAP_TYPE_1;\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\treturn SAP_TYPE_2;\n\tdefault:\n\t\treturn RAP_NO;\n\t}\n}\n#endif\n\nstatic SAPType is_sample_idr(GF_ISOSample *sample, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tBool is_hevc = GF_FALSE;\n\tu32 nalu_size_field = 0;\n\tGF_BitStream *bs;\n\tif (entry->avc_config && entry->avc_config->config) nalu_size_field = entry->avc_config->config->nal_unit_size;\n\telse if (entry->svc_config && entry->svc_config->config) nalu_size_field = entry->svc_config->config->nal_unit_size;\n\telse if (entry->mvc_config && entry->mvc_config->config) nalu_size_field = entry->mvc_config->config->nal_unit_size;\n\telse if (entry->hevc_config && entry->hevc_config->config) {\n\t\tnalu_size_field = entry->hevc_config->config->nal_unit_size;\n\t\tis_hevc = GF_TRUE;\n\t}\n\telse if (entry->lhvc_config && entry->lhvc_config->config) {\n\t\tnalu_size_field = entry->lhvc_config->config->nal_unit_size;\n\t\tis_hevc = GF_TRUE;\n\t}\n\tif (!nalu_size_field) return RAP_NO;\n\n\tbs = gf_bs_new(sample->data, sample->dataLength, GF_BITSTREAM_READ);\n\tif (!bs) return RAP_NO;\n\n\twhile (gf_bs_available(bs)) {\n\t\tu8 nal_type;\n\t\tu32 size = gf_bs_read_int(bs, 8*nalu_size_field);\n\n\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tu16 nal_hdr = gf_bs_read_u16(bs);\n\t\t\tnal_type = (nal_hdr&0x7E00) >> 9;\n\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn SAP_TYPE_3;\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn SAP_TYPE_1;\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn SAP_TYPE_2;\n\t\t\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\t\t\tcase GF_HEVC_NALU_FILLER_DATA:\n\t\t\tcase GF_HEVC_NALU_SEI_PREFIX:\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn RAP_NO;\n\t\t\t}\n\t\t\tgf_bs_skip_bytes(bs, size - 2);\n#endif\n\t\t} else {\n\t\t\tu8 nal_hdr = gf_bs_read_u8(bs);\n\t\t\tnal_type = nal_hdr & 0x1F;\n\n\t\t\tswitch (nal_type) {\n\t\t\t/*\t\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\t\t\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\t\t\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\t\t\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t*/\t\t\tcase GF_AVC_NALU_IDR_SLICE:\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn SAP_TYPE_1;\n\t\t\tcase GF_AVC_NALU_ACCESS_UNIT:\n\t\t\tcase GF_AVC_NALU_FILLER_DATA:\n\t\t\tcase GF_AVC_NALU_SEI:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn RAP_NO;\n\t\t\t}\n\t\t\tgf_bs_skip_bytes(bs, size - 1);\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\treturn RAP_NO;\n}\n\nstatic void nalu_merge_ps(GF_BitStream *ps_bs, Bool rewrite_start_codes, u32 nal_unit_size_field, GF_MPEGVisualSampleEntryBox *entry, Bool is_hevc)\n{\n\tu32 i, count;\n\tif (is_hevc) {\n\t\tif (entry->hevc_config) {\n\t\t\tcount = gf_list_count(entry->hevc_config->config->param_array);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_HEVCParamArray *ar = (GF_HEVCParamArray*)gf_list_get(entry->hevc_config->config->param_array, i);\n\t\t\t\trewrite_nalus_list(ar->nalus, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\t}\n\t\t}\n\t\tif (entry->lhvc_config) {\n\t\t\tcount = gf_list_count(entry->lhvc_config->config->param_array);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_HEVCParamArray *ar = (GF_HEVCParamArray*)gf_list_get(entry->lhvc_config->config->param_array, i);\n\t\t\t\trewrite_nalus_list(ar->nalus, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (entry->avc_config) {\n\t\t\trewrite_nalus_list(entry->avc_config->config->sequenceParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->avc_config->config->sequenceParameterSetExtensions, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->avc_config->config->pictureParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t}\n\n\t\t/*add svc config */\n\t\tif (entry->svc_config) {\n\t\t\trewrite_nalus_list(entry->svc_config->config->sequenceParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->svc_config->config->pictureParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t}\n\t\t/*add mvc config */\n\t\tif (entry->mvc_config) {\n\t\t\trewrite_nalus_list(entry->mvc_config->config->sequenceParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->mvc_config->config->pictureParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t}\n\t}\n}\n\n\nGF_Err gf_isom_nalu_sample_rewrite(GF_MediaBox *mdia, GF_ISOSample *sample, u32 sampleNumber, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tBool is_hevc = GF_FALSE;\n\t//if only one sync given in the sample sync table, insert sps/pps/vps before cra/bla in hevc\n//\tBool check_cra_bla = (mdia->information->sampleTable->SyncSample && mdia->information->sampleTable->SyncSample->nb_entries>1) ? 0 : 1;\n\tBool check_cra_bla = GF_TRUE;\n\tBool insert_nalu_delim = GF_TRUE;\n\tBool force_sei_inspect = GF_FALSE;\n\tGF_Err e = GF_OK;\n\tGF_ISOSample *ref_samp;\n\tGF_BitStream *src_bs, *ref_bs, *dst_bs, *ps_bs, *sei_suffix_bs;\n\tu32 nal_size, max_size, nal_unit_size_field, extractor_mode;\n\tBool rewrite_ps, rewrite_start_codes, insert_vdrd_code;\n\ts8 nal_type;\n\tu32 nal_hdr, sabt_ref, i, track_num;\n\tu32 temporal_id = 0;\n\tchar *buffer;\n\tGF_ISOFile *file = mdia->mediaTrack->moov->mov;\n\tGF_TrackReferenceTypeBox *scal = NULL;\n\n\tsrc_bs = ref_bs = dst_bs = ps_bs = sei_suffix_bs = NULL;\n\tref_samp = NULL;\n\tbuffer = NULL;\n\n\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &scal);\n\n\trewrite_ps = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG) ? GF_TRUE : GF_FALSE;\n\trewrite_start_codes = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_ANNEXB_FLAG) ? GF_TRUE : GF_FALSE;\n\tinsert_vdrd_code = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_VDRD_FLAG) ? GF_TRUE : GF_FALSE;\n\tif (!entry->svc_config && !entry->mvc_config && !entry->lhvc_config) insert_vdrd_code = GF_FALSE;\n\textractor_mode = mdia->mediaTrack->extractor_mode&0x0000FFFF;\n\n\tif (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) {\n\t\tinsert_nalu_delim = GF_FALSE;\n\t}\n\n\ttrack_num = 1 + gf_list_find(mdia->mediaTrack->moov->trackList, mdia->mediaTrack);\n\n\tif ( (extractor_mode != GF_ISOM_NALU_EXTRACT_INSPECT) && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) ) {\n\t\tu32 ref_track, di;\n\t\t//aggregate all sabt samples with the same DTS\n\t\tif (entry->lhvc_config && !entry->hevc_config && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_LAYER_ONLY)) {\n\t\t\tGF_ISOSample *base_samp;\n\t\t\tif (gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SCAL) <= 0) {\n\t\t\t\t//FIXME - for now we only support two layers (base + enh) in implicit\n\t\t\t\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE) >= 1) {\n\t\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE, 1, &ref_track);\n\t\t\t\t\tswitch (gf_isom_get_media_subtype(mdia->mediaTrack->moov->mov , ref_track, 1)) {\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\n\t\t\t\t\t\tbase_samp = gf_isom_get_sample(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di);\n\t\t\t\t\t\tif (base_samp && base_samp->data) {\n\t\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+base_samp->dataLength);\n\t\t\t\t\t\t\tmemmove(sample->data + base_samp->dataLength, sample->data , sample->dataLength);\n\t\t\t\t\t\t\tmemcpy(sample->data, base_samp->data, base_samp->dataLength);\n\t\t\t\t\t\t\tsample->dataLength += base_samp->dataLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (base_samp) gf_isom_sample_del(&base_samp);\n\t\t\t\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_BASE, &scal);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsabt_ref = gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT);\n\t\tif ((s32) sabt_ref > 0) {\n\t\t\tforce_sei_inspect = GF_TRUE;\n\t\t\tfor (i=0; i<sabt_ref; i++) {\n\t\t\t\tGF_ISOSample *tile_samp;\n\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT, i+1, &ref_track);\n\t\t\t\ttile_samp = gf_isom_get_sample(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di);\n\t\t\t\tif (tile_samp  && tile_samp ->data) {\n\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+tile_samp->dataLength);\n\t\t\t\t\tmemcpy(sample->data + sample->dataLength, tile_samp->data, tile_samp->dataLength);\n\t\t\t\t\tsample->dataLength += tile_samp->dataLength;\n\t\t\t\t}\n\t\t\t\tif (tile_samp) gf_isom_sample_del(&tile_samp);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS) >= 1) {\n\t\tu32 ref_track;\n\t\tu32 idx = gf_list_find(mdia->information->sampleTable->SampleDescription->other_boxes, entry);\n\t\tGF_TrackBox *tbas;\n\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\ttbas = (GF_TrackBox *)gf_list_get(mdia->mediaTrack->moov->trackList, ref_track-1);\n\t\tentry = gf_list_get(tbas->Media->information->sampleTable->SampleDescription->other_boxes, idx);\n\t}\n\n\n\tif (sample->IsRAP < SAP_TYPE_2) {\n\t\tif (mdia->information->sampleTable->no_sync_found || (!sample->IsRAP && check_cra_bla) ) {\n\t\t\tsample->IsRAP = is_sample_idr(sample, entry);\n\t\t}\n\t}\n\tif (!sample->IsRAP)\n\t\trewrite_ps = GF_FALSE;\n\n\tif (extractor_mode != GF_ISOM_NALU_EXTRACT_LAYER_ONLY)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\t//this is a compatible HEVC, don't insert VDRD, insert NALU delim\n\tif (entry->lhvc_config && entry->hevc_config)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_INSPECT) {\n\t\tif (!rewrite_ps && !rewrite_start_codes)\n\t\t\treturn GF_OK;\n\t}\n\n\tif (!entry) return GF_BAD_PARAM;\n\tnal_unit_size_field = 0;\n\t/*if svc rewrite*/\n\tif (entry->svc_config && entry->svc_config->config)\n\t\tnal_unit_size_field = entry->svc_config->config->nal_unit_size;\n\t/*if mvc rewrite*/\n\tif (entry->mvc_config && entry->mvc_config->config)\n\t\tnal_unit_size_field = entry->mvc_config->config->nal_unit_size;\n\n\t/*if lhvc rewrite*/\n\telse if (entry->lhvc_config && entry->lhvc_config->config)  {\n\t\tis_hevc = GF_TRUE;\n\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t}\n\n\t/*otherwise do nothing*/\n\telse if (!rewrite_ps && !rewrite_start_codes && !scal && !force_sei_inspect) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!nal_unit_size_field) {\n\t\tif (entry->avc_config) nal_unit_size_field = entry->avc_config->config->nal_unit_size;\n\t\telse if (entry->hevc_config || entry->lhvc_config ) {\n\t\t\tnal_unit_size_field = entry->lhvc_config ? entry->lhvc_config->config->nal_unit_size : entry->hevc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t}\n\n\tif (!nal_unit_size_field) return GF_ISOM_INVALID_FILE;\n\n\tdst_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tps_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tsrc_bs = gf_bs_new(sample->data, sample->dataLength, GF_BITSTREAM_READ);\n\tif (!src_bs && sample->data) return GF_ISOM_INVALID_FILE;\n\tmax_size = 4096;\n\n\t/*rewrite start code with NALU delim*/\n\tif (rewrite_start_codes) {\n\n\t\t//we are SVC, don't write NALU delim, only insert VDRD NALU\n\t\tif (insert_vdrd_code) {\n\t\t\tif (is_hevc) {\n\t\t\t\t//spec is not clear here, we don't insert an NALU AU delimiter before the layer starts since it breaks openHEVC\n//\t\t\t\tinsert_nalu_delim=0;\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\t\tgf_bs_write_int(dst_bs, GF_AVC_NALU_VDRD , 8);\n\t\t\t\tinsert_nalu_delim=0;\n\t\t\t}\n\t\t}\n\n\t\t//AVC/HEVC base, insert NALU delim\n\t\tif (insert_nalu_delim) {\n\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\tgf_bs_write_int(dst_bs, 0, 1);\n\t\t\t\tgf_bs_write_int(dst_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\tgf_bs_write_int(dst_bs, insert_vdrd_code ? 1 : 0, 6); //we should pick the layerID of the following nalus ...\n\t\t\t\tgf_bs_write_int(dst_bs, 1, 3); //nuh_temporal_id_plus1 - cannot be 0, we use 1 by default, and overwrite it if needed at the end\n\n\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\tgf_bs_write_int(dst_bs, 2, 3);\n\t\t\t\tgf_bs_write_int(dst_bs, 0, 5);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(dst_bs, (sample->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\tgf_bs_write_int(dst_bs, 0xF0 , 8); /*7 \"all supported NALUs\" (=111) + rbsp trailing (10000)*/;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rewrite_ps) {\n\t\t//in inspect mode or single-layer mode just use the xPS from this layer\n\t\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_DEFAULT) {\n\t\t\tu32 i;\n\n\t\t\tif (scal) {\n\t\t\t\tfor (i=0; i<scal->trackIDCount; i++) {\n\t\t\t\t\tGF_TrackBox *a_track = GetTrackbyID(mdia->mediaTrack->moov, scal->trackIDs[i]);\n\t\t\t\t\tGF_MPEGVisualSampleEntryBox *an_entry = NULL;\n\t\t\t\t\tif (a_track && a_track->Media && a_track->Media->information && a_track->Media->information->sampleTable && a_track->Media->information->sampleTable->SampleDescription)\n\t\t\t\t\t\tan_entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(a_track->Media->information->sampleTable->SampleDescription->other_boxes, 0);\n\n\t\t\t\t\tif (an_entry)\n\t\t\t\t\t\tnalu_merge_ps(ps_bs, rewrite_start_codes, nal_unit_size_field, an_entry, is_hevc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnalu_merge_ps(ps_bs, rewrite_start_codes, nal_unit_size_field, entry, is_hevc);\n\n\n\t\tif (is_hevc) {\n\t\t\t/*little optimization if we are not asked to start codes: copy over the sample*/\n\t\t\tif (!rewrite_start_codes && !entry->lhvc_config && !scal) {\n\t\t\t\tif (ps_bs) {\n\t\t\t\t\tu8 nal_type = (sample->data[nal_unit_size_field] & 0x7E) >> 1;\n\t\t\t\t\t//temp fix - if we detect xPS in the beginning of the sample do NOT copy the ps bitstream\n\t\t\t\t\t//this is not correct since we are not sure whether they are the same xPS or not, but it crashes openHEVC ...\n\t\t\t\t\tswitch (nal_type) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\t\t\tbreak;\n#endif\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgf_bs_transfer(dst_bs, ps_bs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_del(ps_bs);\n\t\t\t\t\tps_bs = NULL;\n\t\t\t\t}\n\t\t\t\tgf_bs_write_data(dst_bs, sample->data, sample->dataLength);\n\t\t\t\tgf_free(sample->data);\n\t\t\t\tsample->data = NULL;\n\t\t\t\tgf_bs_get_content(dst_bs, &sample->data, &sample->dataLength);\n\t\t\t\tgf_bs_del(src_bs);\n\t\t\t\tgf_bs_del(dst_bs);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*little optimization if we are not asked to rewrite extractors or start codes: copy over the sample*/\n\tif (!scal && !rewrite_start_codes && !rewrite_ps && !force_sei_inspect) {\n\t\tif (ps_bs)\n\t\t{\n\t\t\tgf_bs_transfer(dst_bs, ps_bs);\n\t\t\tgf_bs_del(ps_bs);\n\t\t\tps_bs = NULL;\n\t\t}\n\t\tgf_bs_write_data(dst_bs, sample->data, sample->dataLength);\n\t\tgf_free(sample->data);\n\t\tsample->data = NULL;\n\t\tgf_bs_get_content(dst_bs, &sample->data, &sample->dataLength);\n\t\tgf_bs_del(src_bs);\n\t\tgf_bs_del(dst_bs);\n\t\treturn GF_OK;\n\t}\n\n\tbuffer = (char *)gf_malloc(sizeof(char)*max_size);\n\n\twhile (gf_bs_available(src_bs)) {\n\t\tnal_size = gf_bs_read_int(src_bs, 8*nal_unit_size_field);\n\t\tif (gf_bs_get_position(src_bs) + nal_size > sample->dataLength) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Sample %u (size %u) rewrite: corrupted NAL Unit (size %u)\\n\", sampleNumber, sample->dataLength, nal_size));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (nal_size>max_size) {\n\t\t\tbuffer = (char*) gf_realloc(buffer, sizeof(char)*nal_size);\n\t\t\tmax_size = nal_size;\n\t\t}\n\t\tif (is_hevc) {\n\t\t\tnal_hdr = gf_bs_read_u16(src_bs);\n\t\t\tnal_type = (nal_hdr&0x7E00) >> 9;\n\t\t} else {\n\t\t\tnal_hdr = gf_bs_read_u8(src_bs);\n\t\t\tnal_type = nal_hdr & 0x1F;\n\t\t}\n\n\t\tif (is_hevc) {\n\t\t\tGF_BitStream *write_to_bs = dst_bs;\n\t\t\tif (ps_bs) {\n\t\t\t\tgf_bs_transfer(dst_bs, ps_bs);\n\t\t\t\tgf_bs_del(ps_bs);\n\t\t\t\tps_bs = NULL;\n\t\t\t}\n\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t/*we already wrote this stuff*/\n\t\t\tif (nal_type==GF_HEVC_NALU_ACCESS_UNIT) {\n\t\t\t\tgf_bs_skip_bytes(src_bs, nal_size-2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (nal_type) {\n\t\t\t//extractor\n\t\t\tcase 49:\n\t\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_TRUE, rewrite_ps, rewrite_start_codes, src_bs, dst_bs, extractor_mode);\n\t\t\t\tif (e) goto exit;\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\t\t\t\tif (temporal_id < (nal_hdr & 0x7))\n\t\t\t\t\ttemporal_id = (nal_hdr & 0x7);\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tgf_bs_read_data(src_bs, buffer, nal_size-2);\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(dst_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(dst_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(dst_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(dst_bs, buffer, nal_size-2);\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\t//insert xPS before CRA/BLA\n\t\t\t\tif (check_cra_bla && !sample->IsRAP) {\n\t\t\t\t\tif (ref_samp) gf_isom_sample_del(&ref_samp);\n\t\t\t\t\tif (src_bs) gf_bs_del(src_bs);\n\t\t\t\t\tif (ref_bs) gf_bs_del(ref_bs);\n\t\t\t\t\tif (dst_bs) gf_bs_del(dst_bs);\n\t\t\t\t\tif (buffer) gf_free(buffer);\n\n\t\t\t\t\tsample->IsRAP = sap_type_from_nal_type(nal_type);\n\t\t\t\t\treturn gf_isom_nalu_sample_rewrite(mdia, sample, sampleNumber, entry);\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tif (nal_size<2) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid nal size %d in sample %d\\n\", nal_type, sampleNumber));\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tgf_bs_read_data(src_bs, buffer, nal_size-2);\n\n\t\t\t\tif (nal_type==GF_HEVC_NALU_SEI_SUFFIX) {\n\t\t\t\t\tif (!sei_suffix_bs) sei_suffix_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t\twrite_to_bs = sei_suffix_bs;\n\t\t\t\t}\n\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(write_to_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(write_to_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(write_to_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(write_to_bs, buffer, nal_size-2);\n\t\t\t}\n#endif\n\n\t\t\t//done with HEVC\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(nal_type) {\n\t\tcase GF_AVC_NALU_ACCESS_UNIT:\n\t\t\t/*we already wrote this stuff*/\n\t\t\tgf_bs_skip_bytes(src_bs, nal_size-1);\n\t\t\tcontinue;\n\t\t//extractor\n\t\tcase 31:\n\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_FALSE, rewrite_ps, rewrite_start_codes, src_bs, dst_bs, extractor_mode);\n\t\t\tif (e) goto exit;\n\t\t\tbreak;\n//\t\t\tcase GF_AVC_NALU_SEI:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t\t// we will rewrite the sps/pps if and only if there is no sps/pps in bistream\n\t\t\tif (ps_bs) {\n\t\t\t\tgf_bs_del(ps_bs);\n\t\t\t\tps_bs = NULL;\n\t\t\t}\n\t\tdefault:\n\t\t\tif (ps_bs) {\n\t\t\t\tgf_bs_transfer(dst_bs, ps_bs);\n\t\t\t\tgf_bs_del(ps_bs);\n\t\t\t\tps_bs = NULL;\n\t\t\t}\n\t\t\tgf_bs_read_data(src_bs, buffer, nal_size-1);\n\t\t\tif (rewrite_start_codes)\n\t\t\t\tgf_bs_write_u32(dst_bs, 1);\n\t\t\telse\n\t\t\t\tgf_bs_write_int(dst_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\tgf_bs_write_u8(dst_bs, nal_hdr);\n\t\t\tgf_bs_write_data(dst_bs, buffer, nal_size-1);\n\t\t}\n\t}\n\n\tif (sei_suffix_bs) {\n\t\tgf_bs_transfer(dst_bs, sei_suffix_bs);\n\t\tgf_bs_del(sei_suffix_bs);\n\t}\n\t/*done*/\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tgf_bs_get_content(dst_bs, &sample->data, &sample->dataLength);\n\n\t/*rewrite temporal ID of AU Ddelim NALU (first one)*/\n\tif (rewrite_start_codes && is_hevc && temporal_id) {\n\t\tsample->data[6] = (sample->data[6] & 0xF8) | (temporal_id+1);\n\t}\n\n\nexit:\n\tif (ref_samp) gf_isom_sample_del(&ref_samp);\n\tif (src_bs) gf_bs_del(src_bs);\n\tif (ref_bs) gf_bs_del(ref_bs);\n\tif (dst_bs) gf_bs_del(dst_bs);\n\tif (ps_bs)  gf_bs_del(ps_bs);\n\tif (buffer) gf_free(buffer);\n\treturn e;\n}\n\nGF_HEVCConfig *HEVC_DuplicateConfig(GF_HEVCConfig *cfg)\n{\n\tchar *data;\n\tu32 data_size;\n\tGF_HEVCConfig *new_cfg;\n\tGF_BitStream *bs;\n\n\tif (!cfg) return NULL;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_odf_hevc_cfg_write_bs(cfg, bs);\n\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\n\tnew_cfg = gf_odf_hevc_cfg_read_bs(bs, cfg->is_lhvc);\n\tnew_cfg->is_lhvc = cfg->is_lhvc;\n\tgf_bs_del(bs);\n\tgf_free(data);\n\treturn new_cfg;\n}\n\nstatic GF_AVCConfig *AVC_DuplicateConfig(GF_AVCConfig *cfg)\n{\n\tu32 i, count;\n\tGF_AVCConfigSlot *p1, *p2;\n\tGF_AVCConfig *cfg_new = gf_odf_avc_cfg_new();\n\tcfg_new->AVCLevelIndication = cfg->AVCLevelIndication;\n\tcfg_new->AVCProfileIndication = cfg->AVCProfileIndication;\n\tcfg_new->configurationVersion = cfg->configurationVersion;\n\tcfg_new->nal_unit_size = cfg->nal_unit_size;\n\tcfg_new->profile_compatibility = cfg->profile_compatibility;\n\tcfg_new->complete_representation = cfg->complete_representation;\n\tcfg_new->chroma_bit_depth = cfg->chroma_bit_depth;\n\tcfg_new->luma_bit_depth = cfg->luma_bit_depth;\n\tcfg_new->chroma_format = cfg->chroma_format;\n\n\tcount = gf_list_count(cfg->sequenceParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tp1 = (GF_AVCConfigSlot*)gf_list_get(cfg->sequenceParameterSets, i);\n\t\tp2 = (GF_AVCConfigSlot*)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\tp2->size = p1->size;\n\t\tp2->id = p1->id;\n\t\tp2->data = (char *)gf_malloc(sizeof(char)*p1->size);\n\t\tmemcpy(p2->data, p1->data, sizeof(char)*p1->size);\n\t\tgf_list_add(cfg_new->sequenceParameterSets, p2);\n\t}\n\n\tcount = gf_list_count(cfg->pictureParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tp1 = (GF_AVCConfigSlot*)gf_list_get(cfg->pictureParameterSets, i);\n\t\tp2 = (GF_AVCConfigSlot*)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\tp2->size = p1->size;\n\t\tp2->id = p1->id;\n\t\tp2->data = (char*)gf_malloc(sizeof(char)*p1->size);\n\t\tmemcpy(p2->data, p1->data, sizeof(char)*p1->size);\n\t\tgf_list_add(cfg_new->pictureParameterSets, p2);\n\t}\n\n\tif (cfg->sequenceParameterSetExtensions) {\n\t\tcfg_new->sequenceParameterSetExtensions = gf_list_new();\n\t\tcount = gf_list_count(cfg->sequenceParameterSetExtensions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tp1 = (GF_AVCConfigSlot*)gf_list_get(cfg->sequenceParameterSetExtensions, i);\n\t\t\tp2 = (GF_AVCConfigSlot*)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\t\tp2->size = p1->size;\n\t\t\tp2->id = p1->id;\n\t\t\tp2->data = (char*)gf_malloc(sizeof(char)*p1->size);\n\t\t\tmemcpy(p2->data, p1->data, sizeof(char)*p1->size);\n\t\t\tgf_list_add(cfg_new->sequenceParameterSetExtensions, p2);\n\t\t}\n\t}\n\treturn cfg_new;\n}\n\nstatic void merge_avc_config(GF_AVCConfig *dst_cfg, GF_AVCConfig *src_cfg)\n{\n\tGF_AVCConfig *cfg = AVC_DuplicateConfig(src_cfg);\n\tif (!cfg || !dst_cfg) return;\n\n\twhile (gf_list_count(cfg->sequenceParameterSets)) {\n\t\tGF_AVCConfigSlot *p = (GF_AVCConfigSlot*)gf_list_get(cfg->sequenceParameterSets, 0);\n\t\tgf_list_rem(cfg->sequenceParameterSets, 0);\n\t\tgf_list_insert(dst_cfg->sequenceParameterSets, p, 0);\n\t}\n\twhile (gf_list_count(cfg->pictureParameterSets)) {\n\t\tGF_AVCConfigSlot *p = (GF_AVCConfigSlot*)gf_list_get(cfg->pictureParameterSets, 0);\n\t\tgf_list_rem(cfg->pictureParameterSets, 0);\n\t\tgf_list_insert(dst_cfg->pictureParameterSets, p, 0);\n\t}\n\tgf_odf_avc_cfg_del(cfg);\n}\n\nvoid merge_hevc_config(GF_HEVCConfig *dst_cfg, GF_HEVCConfig *src_cfg, Bool force_insert)\n{\n\tGF_HEVCConfig *cfg = HEVC_DuplicateConfig(src_cfg);\n\t//merge all xPS\n\tu32 i, j, count = cfg->param_array ? gf_list_count(cfg->param_array) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_HEVCParamArray *ar_h = NULL;\n\t\tu32 count2 = dst_cfg->param_array ? gf_list_count(dst_cfg->param_array) : 0;\n\t\tGF_HEVCParamArray *ar = (GF_HEVCParamArray*)gf_list_get(cfg->param_array, i);\n\t\tfor (j=0; j<count2; j++) {\n\t\t\tar_h = (GF_HEVCParamArray*)gf_list_get(dst_cfg->param_array, j);\n\t\t\tif (ar_h->type==ar->type) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tar_h = NULL;\n\t\t}\n\t\tif (!ar_h) {\n\t\t\tgf_list_add(dst_cfg->param_array, ar);\n\t\t\tgf_list_rem(cfg->param_array, i);\n\t\t\tcount--;\n\t\t\ti--;\n\t\t} else {\n\t\t\twhile (gf_list_count(ar->nalus)) {\n\t\t\t\tGF_AVCConfigSlot *p = (GF_AVCConfigSlot*)gf_list_get(ar->nalus, 0);\n\t\t\t\tgf_list_rem(ar->nalus, 0);\n\t\t\t\tif (force_insert)\n\t\t\t\t\tgf_list_insert(ar_h->nalus, p, 0);\n\t\t\t\telse\n\t\t\t\t\tgf_list_add(ar_h->nalus, p);\n\t\t\t}\n\n\t\t}\n\t}\n\tgf_odf_hevc_cfg_del(cfg);\n\n#define CHECK_CODE(__code)\tif (dst_cfg->__code < src_cfg->__code) dst_cfg->__code = src_cfg->__code;\n\n\tCHECK_CODE(configurationVersion)\n\tCHECK_CODE(profile_idc)\n\tCHECK_CODE(profile_space)\n\tCHECK_CODE(tier_flag)\n\tCHECK_CODE(general_profile_compatibility_flags)\n\tCHECK_CODE(progressive_source_flag)\n\tCHECK_CODE(interlaced_source_flag)\n\tCHECK_CODE(constraint_indicator_flags)\n\tCHECK_CODE(level_idc)\n\tCHECK_CODE(min_spatial_segmentation_idc)\n\n}\n\nvoid merge_all_config(GF_AVCConfig *avc_cfg, GF_HEVCConfig *hevc_cfg, GF_MediaBox *mdia)\n{\n\tu32 i;\n\tGF_TrackReferenceTypeBox *scal = NULL;\n\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &scal);\n\n\tif (!scal) return;\n\n\tfor (i=0; i<scal->trackIDCount; i++) {\n\t\tGF_TrackBox *a_track = GetTrackbyID(mdia->mediaTrack->moov, scal->trackIDs[i]);\n\t\tGF_MPEGVisualSampleEntryBox *an_entry = NULL;\n\t\tif (a_track && a_track->Media && a_track->Media->information && a_track->Media->information->sampleTable && a_track->Media->information->sampleTable->SampleDescription)\n\t\t\tan_entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(a_track->Media->information->sampleTable->SampleDescription->other_boxes, 0);\n\n\t\tif (!an_entry) continue;\n\n\t\tif (avc_cfg && an_entry->svc_config && an_entry->svc_config->config)\n\t\t\tmerge_avc_config(avc_cfg, an_entry->svc_config->config);\n\n\t\tif (avc_cfg && an_entry->mvc_config && an_entry->mvc_config->config)\n\t\t\tmerge_avc_config(avc_cfg, an_entry->mvc_config->config);\n\n\t\tif (avc_cfg && an_entry->avc_config && an_entry->avc_config->config)\n\t\t\tmerge_avc_config(avc_cfg, an_entry->avc_config->config);\n\n\t\tif (hevc_cfg && an_entry->lhvc_config && an_entry->lhvc_config->config)\n\t\t\tmerge_hevc_config(hevc_cfg, an_entry->lhvc_config->config, GF_TRUE);\n\n\t\tif (hevc_cfg && an_entry->hevc_config && an_entry->hevc_config->config)\n\t\t\tmerge_hevc_config(hevc_cfg, an_entry->hevc_config->config, GF_TRUE);\n\t}\n\n\tif (hevc_cfg) hevc_cfg->is_lhvc = GF_FALSE;\n}\n\nvoid AVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia)\n{\n\tGF_AVCConfig *avcc, *svcc, *mvcc;\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)avc, GF_FALSE);\n\n\tif (avc->emul_esd) gf_odf_desc_del((GF_Descriptor *)avc->emul_esd);\n\tavc->emul_esd = gf_odf_desc_esd_new(2);\n\tavc->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t/*AVC OTI is 0x21, AVC parameter set stream OTI (not supported in gpac) is 0x22, SVC OTI is 0x24*/\n\t/*if we have only SVC stream, set objectTypeIndication to AVC OTI; else set it to AVC OTI*/\n\tif (avc->svc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_SVC;\n\telse if (avc->mvc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_MVC;\n\telse\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_AVC;\n\n\tif (btrt) {\n\t\tavc->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tavc->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tavc->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (avc->descr) {\n\t\tu32 i=0;\n\t\tGF_Descriptor *desc,*clone;\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor *)gf_list_enum(avc->descr->descriptors, &i))) {\n\t\t\tclone = NULL;\n\t\t\tgf_odf_desc_copy(desc, &clone);\n\t\t\tif (gf_odf_desc_add_desc((GF_Descriptor *)avc->emul_esd, clone) != GF_OK)\n\t\t\t\tgf_odf_desc_del(clone);\n\t\t}\n\t}\n\tif (avc->avc_config) {\n\t\tavcc = avc->avc_config->config ? AVC_DuplicateConfig(avc->avc_config->config) : NULL;\n\t\t/*merge SVC config*/\n\t\tif (avc->svc_config) {\n\t\t\tmerge_avc_config(avcc, avc->svc_config->config);\n\t\t}\n\t\t/*merge MVC config*/\n\t\tif (avc->mvc_config) {\n\t\t\tmerge_avc_config(avcc, avc->mvc_config->config);\n\t\t}\n\t\tif (avcc) {\n\t\t\tif (mdia) merge_all_config(avcc, NULL, mdia);\n\n\t\t\tgf_odf_avc_cfg_write(avcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t}\n\t} else if (avc->svc_config) {\n\t\tsvcc = AVC_DuplicateConfig(avc->svc_config->config);\n\n\t\tif (mdia) merge_all_config(svcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(svcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(svcc);\n\t}\n\telse if (avc->mvc_config) {\n\t\tmvcc = AVC_DuplicateConfig(avc->mvc_config->config);\n\n\t\tif (mdia) merge_all_config(mvcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(mvcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(mvcc);\n\t}\n}\n\nvoid AVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *avc)\n{\n\tAVC_RewriteESDescriptorEx(avc, NULL);\n}\n\nvoid HEVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *hevc, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)hevc, GF_FALSE);\n\n\tif (hevc->emul_esd) gf_odf_desc_del((GF_Descriptor *)hevc->emul_esd);\n\thevc->emul_esd = gf_odf_desc_esd_new(2);\n\thevc->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\thevc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_HEVC;\n\tif (hevc->lhvc_config /*&& !hevc->hevc_config*/)\n\t\thevc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_LHVC;\n\n\tif (btrt) {\n\t\thevc->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\thevc->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\thevc->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (hevc->descr) {\n\t\tu32 i=0;\n\t\tGF_Descriptor *desc,*clone;\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor *)gf_list_enum(hevc->descr->descriptors, &i))) {\n\t\t\tclone = NULL;\n\t\t\tgf_odf_desc_copy(desc, &clone);\n\t\t\tif (gf_odf_desc_add_desc((GF_Descriptor *)hevc->emul_esd, clone) != GF_OK)\n\t\t\t\tgf_odf_desc_del(clone);\n\t\t}\n\t}\n\n\tif (hevc->hevc_config || hevc->lhvc_config) {\n\t\tGF_HEVCConfig *hcfg = HEVC_DuplicateConfig(hevc->hevc_config ? hevc->hevc_config->config : hevc->lhvc_config->config);\n\n\t\tif (hevc->hevc_config && hevc->lhvc_config) {\n\t\t\t//merge LHVC config to HEVC conf, so we add entry rather than insert\n\t\t\tmerge_hevc_config(hcfg, hevc->lhvc_config->config, GF_FALSE);\n\t\t}\n\n\t\tif (mdia) merge_all_config(NULL, hcfg, mdia);\n\n\t\tif (hcfg) {\n\t\t\tif (mdia && ((mdia->mediaTrack->extractor_mode&0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)) {\n\t\t\t\thcfg->is_lhvc=GF_FALSE;\n\t\t\t}\n\t\t\tgf_odf_hevc_cfg_write(hcfg, &hevc->emul_esd->decoderConfig->decoderSpecificInfo->data, &hevc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_hevc_cfg_del(hcfg);\n\t\t}\n\t}\n}\nvoid HEVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *hevc)\n{\n\tHEVC_RewriteESDescriptorEx(hevc, NULL);\n}\n\nGF_Err AVC_HEVC_UpdateESD(GF_MPEGVisualSampleEntryBox *avc, GF_ESD *esd)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)avc, GF_TRUE);\n\n\tif (avc->descr) gf_isom_box_del((GF_Box *) avc->descr);\n\tavc->descr = NULL;\n\tbtrt->avgBitrate = esd->decoderConfig->avgBitrate;\n\tbtrt->maxBitrate = esd->decoderConfig->maxBitrate;\n\tbtrt->bufferSizeDB = esd->decoderConfig->bufferSizeDB;\n\n\tif (gf_list_count(esd->IPIDataSet)\n\t        || gf_list_count(esd->IPMPDescriptorPointers)\n\t        || esd->langDesc\n\t        || gf_list_count(esd->extensionDescriptors)\n\t        || esd->ipiPtr || esd->qos || esd->RegDescriptor) {\n\n\t\tavc->descr = (GF_MPEG4ExtensionDescriptorsBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_M4DS);\n\t\tif (esd->RegDescriptor) {\n\t\t\tgf_list_add(avc->descr->descriptors, esd->RegDescriptor);\n\t\t\tesd->RegDescriptor = NULL;\n\t\t}\n\t\tif (esd->qos) {\n\t\t\tgf_list_add(avc->descr->descriptors, esd->qos);\n\t\t\tesd->qos = NULL;\n\t\t}\n\t\tif (esd->ipiPtr) {\n\t\t\tgf_list_add(avc->descr->descriptors, esd->ipiPtr);\n\t\t\tesd->ipiPtr= NULL;\n\t\t}\n\n\t\twhile (gf_list_count(esd->IPIDataSet)) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *)gf_list_get(esd->IPIDataSet, 0);\n\t\t\tgf_list_rem(esd->IPIDataSet, 0);\n\t\t\tgf_list_add(avc->descr->descriptors, desc);\n\t\t}\n\t\twhile (gf_list_count(esd->IPMPDescriptorPointers)) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *)gf_list_get(esd->IPMPDescriptorPointers, 0);\n\t\t\tgf_list_rem(esd->IPMPDescriptorPointers, 0);\n\t\t\tgf_list_add(avc->descr->descriptors, desc);\n\t\t}\n\t\tif (esd->langDesc) {\n\t\t\tgf_list_add(avc->descr->descriptors, esd->langDesc);\n\t\t\tesd->langDesc = NULL;\n\t\t}\n\t\twhile (gf_list_count(esd->extensionDescriptors)) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *)gf_list_get(esd->extensionDescriptors, 0);\n\t\t\tgf_list_rem(esd->extensionDescriptors, 0);\n\t\t\tgf_list_add(avc->descr->descriptors, desc);\n\t\t}\n\t}\n\n\n\tif (!avc->lhvc_config && (esd->decoderConfig->objectTypeIndication==GPAC_OTI_VIDEO_HEVC)) {\n\t\tif (!avc->hevc_config) avc->hevc_config = (GF_HEVCConfigurationBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tif (avc->hevc_config->config) gf_odf_hevc_cfg_del(avc->hevc_config->config);\n\t\t\tavc->hevc_config->config = gf_odf_hevc_cfg_read(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, GF_FALSE);\n\t\t}\n\t}\n\telse if (!avc->svc_config && !avc->mvc_config && (esd->decoderConfig->objectTypeIndication==GPAC_OTI_VIDEO_AVC)) {\n\t\tif (!avc->avc_config) avc->avc_config = (GF_AVCConfigurationBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tif (avc->avc_config->config) gf_odf_avc_cfg_del(avc->avc_config->config);\n\t\t\tavc->avc_config->config = gf_odf_avc_cfg_read(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t}\n\n\tgf_odf_desc_del((GF_Descriptor *)esd);\n\tif (avc->hevc_config) {\n\t\tHEVC_RewriteESDescriptor(avc);\n\t} else {\n\t\tAVC_RewriteESDescriptor(avc);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_EXPORT\nGF_Err gf_isom_avc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, char *URLname, char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_AVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\tentry->avc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\tentry->avc_config->config = AVC_DuplicateConfig(cfg);\n\tentry->dataReferenceIndex = dataRefIndex;\n\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->other_boxes, entry);\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->other_boxes);\n\tAVC_RewriteESDescriptor(entry);\n\treturn e;\n}\n\nstatic GF_Err gf_isom_avc_config_update_ex(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg, u32 op_type)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tswitch (op_type) {\n\t/*AVCC replacement*/\n\tcase 0:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (!entry->avc_config) entry->avc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (entry->avc_config->config) gf_odf_avc_cfg_del(entry->avc_config->config);\n\t\tentry->avc_config->config = AVC_DuplicateConfig(cfg);\n\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\t/*SVCC replacement*/\n\tcase 1:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (!entry->svc_config) entry->svc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\tif (entry->svc_config->config) gf_odf_avc_cfg_del(entry->svc_config->config);\n\t\tentry->svc_config->config = AVC_DuplicateConfig(cfg);\n\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\t/*SVCC replacement and AVC removal*/\n\tcase 2:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (entry->avc_config) {\n\t\t\tgf_isom_box_del((GF_Box*)entry->avc_config);\n\t\t\tentry->avc_config = NULL;\n\t\t}\n\t\tif (!entry->svc_config) entry->svc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\tif (entry->svc_config->config) gf_odf_avc_cfg_del(entry->svc_config->config);\n\t\tentry->svc_config->config = AVC_DuplicateConfig(cfg);\n\t\tentry->type = GF_ISOM_BOX_TYPE_SVC1;\n\t\tbreak;\n\t/*AVCC removal and switch to avc3*/\n\tcase 3:\n\t\tif (!entry->avc_config || !entry->avc_config->config)\n\t\t\treturn GF_BAD_PARAM;\n\n\t\tif (entry->svc_config) {\n\t\t\tgf_isom_box_del((GF_Box*)entry->svc_config);\n\t\t\tentry->svc_config = NULL;\n\t\t}\n\t\tif (entry->mvc_config) {\n\t\t\tgf_isom_box_del((GF_Box*)entry->mvc_config);\n\t\t\tentry->mvc_config = NULL;\n\t\t}\n\n\t\twhile (gf_list_count(entry->avc_config->config->sequenceParameterSets)) {\n\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot*)gf_list_get(entry->avc_config->config->sequenceParameterSets, 0);\n\t\t\tgf_list_rem(entry->avc_config->config->sequenceParameterSets, 0);\n\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\tgf_free(sl);\n\t\t}\n\n\t\twhile (gf_list_count(entry->avc_config->config->pictureParameterSets)) {\n\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot*)gf_list_get(entry->avc_config->config->pictureParameterSets, 0);\n\t\t\tgf_list_rem(entry->avc_config->config->pictureParameterSets, 0);\n\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\tgf_free(sl);\n\t\t}\n\n\t\tif (entry->type == GF_ISOM_BOX_TYPE_AVC1)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC3;\n\t\telse if (entry->type == GF_ISOM_BOX_TYPE_AVC2)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC4;\n\t\tbreak;\n\t/*MVCC replacement*/\n\tcase 4:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (!entry->mvc_config) entry->mvc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\tif (entry->mvc_config->config) gf_odf_avc_cfg_del(entry->mvc_config->config);\n\t\tentry->mvc_config->config = AVC_DuplicateConfig(cfg);\n\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\t/*MVCC replacement and AVC removal*/\n\tcase 5:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (entry->avc_config) {\n\t\t\tgf_isom_box_del((GF_Box*)entry->avc_config);\n\t\t\tentry->avc_config = NULL;\n\t\t}\n\t\tif (!entry->mvc_config) entry->mvc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\tif (entry->mvc_config->config) gf_odf_avc_cfg_del(entry->mvc_config->config);\n\t\tentry->mvc_config->config = AVC_DuplicateConfig(cfg);\n\t\tentry->type = GF_ISOM_BOX_TYPE_MVC1;\n\t\tbreak;\n\t}\n\tAVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_avc_set_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, 3);\n}\n\nGF_EXPORT\nGF_Err gf_isom_avc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, 0);\n}\n\nGF_Err gf_isom_svc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg, Bool is_add)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, is_add ? 1 : 2);\n}\n\nGF_Err gf_isom_mvc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg, Bool is_add)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, is_add ? 4 : 5);\n}\n\nstatic GF_Err gf_isom_svc_mvc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool is_mvc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (is_mvc && entry->mvc_config) {\n\t\tgf_isom_box_del((GF_Box*)entry->mvc_config);\n\t\tentry->mvc_config = NULL;\n\t}\n\telse if (!is_mvc && entry->svc_config) {\n\t\tgf_isom_box_del((GF_Box*)entry->svc_config);\n\t\tentry->svc_config = NULL;\n\t}\n\tAVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_svc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_del(the_file, trackNumber, DescriptionIndex, GF_FALSE);\n}\n\nGF_Err gf_isom_mvc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_del(the_file, trackNumber, DescriptionIndex, GF_TRUE);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_ipod_compatible(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, 0);\n\tif (!entry) return GF_OK;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tif (!entry->ipod_ext) entry->ipod_ext = (GF_UnknownUUIDBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\tmemcpy(entry->ipod_ext->uuid, GF_ISOM_IPOD_EXT, sizeof(u8)*16);\n\tentry->ipod_ext->dataSize = 0;\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_svc_mvc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, Bool is_mvc, char *URLname, char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//create a new entry\n\tif (is_mvc) {\n\t\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MVC1);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->mvc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\tentry->mvc_config->config = AVC_DuplicateConfig(cfg);\n\t} else {\n\t\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SVC1);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->svc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\tentry->svc_config->config = AVC_DuplicateConfig(cfg);\n\t}\n\tentry->dataReferenceIndex = dataRefIndex;\n\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->other_boxes, entry);\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->other_boxes);\n\tAVC_RewriteESDescriptor(entry);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_svc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, char *URLname, char *URNname, u32 *outDescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_new(the_file, trackNumber, cfg, GF_FALSE, URLname, URNname,outDescriptionIndex);\n}\n\nGF_EXPORT\nGF_Err gf_isom_mvc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, char *URLname, char *URNname, u32 *outDescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_new(the_file, trackNumber, cfg, GF_TRUE, URLname, URNname,outDescriptionIndex);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_hevc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_HEVCConfig *cfg, char *URLname, char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_HVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\tentry->hevc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\tentry->hevc_config->config = HEVC_DuplicateConfig(cfg);\n\tentry->dataReferenceIndex = dataRefIndex;\n\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->other_boxes, entry);\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->other_boxes);\n\tHEVC_RewriteESDescriptor(entry);\n\treturn e;\n}\n\ntypedef enum\n{\n\tGF_ISOM_HVCC_UPDATE = 0,\n\tGF_ISOM_HVCC_SET_INBAND,\n\tGF_ISOM_HVCC_SET_TILE,\n\tGF_ISOM_HVCC_SET_TILE_BASE_TRACK,\n\tGF_ISOM_HVCC_SET_LHVC,\n\tGF_ISOM_HVCC_SET_LHVC_WITH_BASE,\n\tGF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD,\n\tGF_ISOM_LHCC_SET_INBAND\n} HevcConfigUpdateType;\n\nstatic Bool hevc_cleanup_config(GF_HEVCConfig *cfg, HevcConfigUpdateType operand_type)\n{\n\tu32 i;\n\tBool array_incomplete = (operand_type==GF_ISOM_HVCC_SET_INBAND) ? 1 : 0;\n\tif (!cfg) return 0;\n\n\tfor (i=0; i<gf_list_count(cfg->param_array); i++) {\n\t\tGF_HEVCParamArray *ar = (GF_HEVCParamArray*)gf_list_get(cfg->param_array, i);\n\n\t\t/*we want to force hev1*/\n\t\tif (operand_type==GF_ISOM_HVCC_SET_INBAND) {\n\t\t\tar->array_completeness = 0;\n\n\t\t\twhile (gf_list_count(ar->nalus)) {\n\t\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot*)gf_list_get(ar->nalus, 0);\n\t\t\t\tgf_list_rem(ar->nalus, 0);\n\t\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\t\tgf_free(sl);\n\t\t\t}\n\t\t\tgf_list_del(ar->nalus);\n\t\t\tgf_free(ar);\n\t\t\tgf_list_rem(cfg->param_array, i);\n\t\t\ti--;\n\t\t}\n\t\tif (!ar->array_completeness) \n\t\t\tarray_incomplete = 1;\n\t}\n\treturn array_incomplete;\n}\n\nstatic\nGF_Err gf_isom_hevc_config_update_ex(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg, u32 operand_type)\n{\n\tu32 array_incomplete;\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\n\tif (operand_type == GF_ISOM_HVCC_SET_TILE_BASE_TRACK) {\n\t\tif (entry->type==GF_ISOM_BOX_TYPE_HVC1)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HVC2;\n\t\telse if (entry->type==GF_ISOM_BOX_TYPE_HEV1)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HEV2;\n\t} else if (operand_type == GF_ISOM_HVCC_SET_TILE) {\n\t\tif (!entry->hevc_config) entry->hevc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\t\tif (entry->hevc_config->config) gf_odf_hevc_cfg_del(entry->hevc_config->config);\n\t\tentry->hevc_config->config = NULL;\n\t\tentry->type = GF_ISOM_BOX_TYPE_HVT1;\n\t} else if (operand_type < GF_ISOM_HVCC_SET_LHVC) {\n\t\tif ((operand_type != GF_ISOM_HVCC_SET_INBAND) && !entry->hevc_config)\n\t\t\tentry->hevc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\n\t\tif (cfg) {\n\t\t\tif (entry->hevc_config->config) gf_odf_hevc_cfg_del(entry->hevc_config->config);\n\t\t\tentry->hevc_config->config = HEVC_DuplicateConfig(cfg);\n\t\t} else if (operand_type != GF_ISOM_HVCC_SET_TILE) {\n\t\t\toperand_type=GF_ISOM_HVCC_SET_INBAND;\n\t\t}\n\t\tarray_incomplete = (operand_type==GF_ISOM_HVCC_SET_INBAND) ? 1 : 0;\n\t\tif (entry->hevc_config && hevc_cleanup_config(entry->hevc_config->config, operand_type))\n\t\t\tarray_incomplete=1;\n\n\t\tif (entry->lhvc_config && hevc_cleanup_config(entry->lhvc_config->config, operand_type))\n\t\t\tarray_incomplete=1;\n\n\t\tswitch (entry->type) {\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_HEV1 : GF_ISOM_BOX_TYPE_HVC1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_HEV2 : GF_ISOM_BOX_TYPE_HVC2;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_LHE1 : GF_ISOM_BOX_TYPE_LHV1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\n\t\t/*SVCC replacement/removal with HEVC base, backward compatible signaling*/\n\t\tif ((operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD) || (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE)) {\n\t\t\tif (!entry->hevc_config) return GF_BAD_PARAM;\n\t\t\tif (!cfg) {\n\t\t\t\tif (entry->lhvc_config) {\n\t\t\t\t\tgf_isom_box_del((GF_Box*)entry->lhvc_config);\n\t\t\t\t\tentry->lhvc_config = NULL;\n\t\t\t\t}\n\t\t\t\tif (entry->type==GF_ISOM_BOX_TYPE_LHE1) entry->type = (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) ? GF_ISOM_BOX_TYPE_HEV2 : GF_ISOM_BOX_TYPE_HEV1;\n\t\t\t\telse if (entry->type==GF_ISOM_BOX_TYPE_HEV1) entry->type = (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) ? GF_ISOM_BOX_TYPE_HEV2 : GF_ISOM_BOX_TYPE_HEV1;\n\t\t\t\telse entry->type =  (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) ? GF_ISOM_BOX_TYPE_HVC2 : GF_ISOM_BOX_TYPE_HVC1;\n\t\t\t} else {\n\t\t\t\tif (!entry->lhvc_config) entry->lhvc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_LHVC);\n\t\t\t\tif (entry->lhvc_config->config) gf_odf_hevc_cfg_del(entry->lhvc_config->config);\n\t\t\t\tentry->lhvc_config->config = HEVC_DuplicateConfig(cfg);\n\n\t\t\t\tif (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD) {\n\t\t\t\t\tif (entry->type==GF_ISOM_BOX_TYPE_HEV2) entry->type = GF_ISOM_BOX_TYPE_HEV1;\n\t\t\t\t\telse entry->type = GF_ISOM_BOX_TYPE_HVC1;\n\t\t\t\t} else {\n\t\t\t\t\tif (entry->type==GF_ISOM_BOX_TYPE_HEV1) entry->type = GF_ISOM_BOX_TYPE_HEV2;\n\t\t\t\t\telse entry->type = GF_ISOM_BOX_TYPE_HVC2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*LHEVC track without base*/\n\t\telse if (operand_type==GF_ISOM_HVCC_SET_LHVC) {\n\t\t\tif (entry->hevc_config) {\n\t\t\t\tgf_isom_box_del((GF_Box*)entry->hevc_config);\n\t\t\t\tentry->hevc_config=NULL;\n\t\t\t}\n\t\t\tif (!cfg) return GF_BAD_PARAM;\n\n\t\t\tif (!entry->lhvc_config) entry->lhvc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_LHVC);\n\t\t\tif (entry->lhvc_config->config) gf_odf_hevc_cfg_del(entry->lhvc_config->config);\n\t\t\tentry->lhvc_config->config = HEVC_DuplicateConfig(cfg);\n\n\t\t\tif ((entry->type==GF_ISOM_BOX_TYPE_HEV1) || (entry->type==GF_ISOM_BOX_TYPE_HEV2)) entry->type = GF_ISOM_BOX_TYPE_LHE1;\n\t\t\telse entry->type = GF_ISOM_BOX_TYPE_LHV1;\n\t\t}\n\t\t/*LHEVC inband, no config change*/\n\t\telse if (operand_type==GF_ISOM_LHCC_SET_INBAND) {\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_LHE1;\n\t\t}\n\t}\n\n\tHEVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_hevc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_UPDATE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_hevc_set_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, GF_ISOM_HVCC_SET_INBAND);\n}\n\nGF_EXPORT\nGF_Err gf_isom_lhvc_force_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, GF_ISOM_LHCC_SET_INBAND);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_hevc_set_tile_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg, Bool is_base_track)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, is_base_track ? GF_ISOM_HVCC_SET_TILE_BASE_TRACK : GF_ISOM_HVCC_SET_TILE);\n}\n\nGF_Err gf_isom_lhvc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg, GF_ISOMLHEVCTrackType track_type)\n{\n\tif (cfg) cfg->is_lhvc = GF_TRUE;\n\tswitch (track_type) {\n\tcase GF_ISOM_LEHVC_ONLY:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_LHVC);\n\tcase GF_ISOM_LEHVC_WITH_BASE:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_LHVC_WITH_BASE);\n\tcase GF_ISOM_LEHVC_WITH_BASE_BACKWARD:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD);\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_Box *gf_isom_clone_config_box(GF_Box *box)\n{\n\tGF_Box *clone;\n\tswitch (box->type)\n\t{\n\tcase GF_ISOM_BOX_TYPE_AVCC:\n\tcase GF_ISOM_BOX_TYPE_SVCC:\n\tcase GF_ISOM_BOX_TYPE_MVCC:\n\t\tclone = gf_isom_box_new(box->type);\n\t\t((GF_AVCConfigurationBox *)clone)->config = AVC_DuplicateConfig(((GF_AVCConfigurationBox *)box)->config);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVCC:\n\t\tclone = gf_isom_box_new(box->type);\n\t\t((GF_HEVCConfigurationBox *)clone)->config = HEVC_DuplicateConfig(((GF_HEVCConfigurationBox *)box)->config);\n\t\tbreak;\n\tdefault:\n\t\tclone = NULL;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Cloning of config not supported for type %s\\n\", gf_4cc_to_str(box->type)));\n\t\tbreak;\n\t}\n\treturn clone;\n}\n\nGF_EXPORT\nGF_AVCConfig *gf_isom_avc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\n\tif (!entry->avc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->avc_config->config);\n}\n\nGF_EXPORT\nGF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->hevc_config) return NULL;\n\treturn HEVC_DuplicateConfig(entry->hevc_config->config);\n}\n\nGF_EXPORT\nGF_AVCConfig *gf_isom_svc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->svc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->svc_config->config);\n}\n\n\nGF_EXPORT\nGF_AVCConfig *gf_isom_mvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->mvc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->mvc_config->config);\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_avc_svc_type(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tu32 type;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_ISOM_AVCTYPE_NONE;\n\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_VISUAL) return GF_ISOM_AVCTYPE_NONE;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_ISOM_AVCTYPE_NONE;\n\n\ttype = entry->type;\n\n\tif (type == GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_list_get(entry->protections, 0);\n\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t}\n\telse if (type == GF_ISOM_BOX_TYPE_RESV) {\n\t\tif (entry->rinf && entry->rinf->original_format) type = entry->rinf->original_format->data_format;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_AVCTYPE_NONE;\n\t}\n\tif (entry->avc_config && !entry->svc_config && !entry->mvc_config) return GF_ISOM_AVCTYPE_AVC_ONLY;\n\tif (entry->avc_config && entry->svc_config) return GF_ISOM_AVCTYPE_AVC_SVC;\n\tif (entry->avc_config && entry->mvc_config) return GF_ISOM_AVCTYPE_AVC_MVC;\n\tif (!entry->avc_config && entry->svc_config) return GF_ISOM_AVCTYPE_SVC_ONLY;\n\tif (!entry->avc_config && entry->mvc_config) return GF_ISOM_AVCTYPE_MVC_ONLY;\n\treturn GF_ISOM_AVCTYPE_NONE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_hevc_lhvc_type(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tu32 type;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_ISOM_HEVCTYPE_NONE;\n\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_VISUAL) return GF_ISOM_HEVCTYPE_NONE;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_ISOM_AVCTYPE_NONE;\n\ttype = entry->type;\n\n\tif (type == GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_list_get(entry->protections, 0);\n\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t}\n\telse if (type == GF_ISOM_BOX_TYPE_RESV) {\n\t\tif (entry->rinf && entry->rinf->original_format) type = entry->rinf->original_format->data_format;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_HEVCTYPE_NONE;\n\t}\n\tif (entry->hevc_config && !entry->lhvc_config) return GF_ISOM_HEVCTYPE_HEVC_ONLY;\n\tif (entry->hevc_config && entry->lhvc_config) return GF_ISOM_HEVCTYPE_HEVC_LHVC;\n\tif (!entry->hevc_config && entry->lhvc_config) return GF_ISOM_HEVCTYPE_LHVC_ONLY;\n\treturn GF_ISOM_HEVCTYPE_NONE;\n}\n\nGF_EXPORT\nGF_HEVCConfig *gf_isom_lhvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_HEVCConfig *lhvc;\n\tGF_OperatingPointsInformation *oinf=NULL;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->lhvc_config) return NULL;\n\tlhvc = HEVC_DuplicateConfig(entry->lhvc_config->config);\n\tif (!lhvc) return NULL;\n\n\tgf_isom_get_oinf_info(the_file, trackNumber, &oinf);\n\tif (oinf) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_last(oinf->profile_tier_levels);\n\t\tif (ptl) {\n\t\t\tlhvc->profile_space  = ptl->general_profile_space;\n\t\t\tlhvc->tier_flag = ptl->general_tier_flag;\n\t\t\tlhvc->profile_idc = ptl->general_profile_idc;\n\t\t\tlhvc->general_profile_compatibility_flags = ptl->general_profile_compatibility_flags;\n\t\t\tlhvc->constraint_indicator_flags = ptl->general_constraint_indicator_flags;\n\t\t}\n\t}\n\treturn lhvc;\n}\n\n\nvoid btrt_del(GF_Box *s)\n{\n\tGF_BitRateBox *ptr = (GF_BitRateBox *)s;\n\tif (ptr) gf_free(ptr);\n}\nGF_Err btrt_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_BitRateBox *ptr = (GF_BitRateBox *)s;\n\tptr->bufferSizeDB = gf_bs_read_u32(bs);\n\tptr->maxBitrate = gf_bs_read_u32(bs);\n\tptr->avgBitrate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *btrt_New()\n{\n\tGF_BitRateBox *tmp = (GF_BitRateBox *) gf_malloc(sizeof(GF_BitRateBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitRateBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_BTRT;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err btrt_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_BitRateBox *ptr = (GF_BitRateBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->bufferSizeDB);\n\tgf_bs_write_u32(bs, ptr->maxBitrate);\n\tgf_bs_write_u32(bs, ptr->avgBitrate);\n\treturn GF_OK;\n}\nGF_Err btrt_Size(GF_Box *s)\n{\n\tGF_BitRateBox *ptr = (GF_BitRateBox *)s;\n\tptr->size += 12;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid m4ds_del(GF_Box *s)\n{\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\tgf_odf_desc_list_del(ptr->descriptors);\n\tgf_list_del(ptr->descriptors);\n\tgf_free(ptr);\n}\nGF_Err m4ds_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tchar *enc_od;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\tu32 od_size = (u32) ptr->size;\n\tif (!od_size) return GF_OK;\n\tenc_od = (char *)gf_malloc(sizeof(char) * od_size);\n\tgf_bs_read_data(bs, enc_od, od_size);\n\te = gf_odf_desc_list_read((char *)enc_od, od_size, ptr->descriptors);\n\tgf_free(enc_od);\n\treturn e;\n}\nGF_Box *m4ds_New()\n{\n\tGF_MPEG4ExtensionDescriptorsBox *tmp = (GF_MPEG4ExtensionDescriptorsBox *) gf_malloc(sizeof(GF_MPEG4ExtensionDescriptorsBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_MPEG4ExtensionDescriptorsBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_M4DS;\n\ttmp->descriptors = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err m4ds_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tchar *enc_ods;\n\tu32 enc_od_size;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tenc_ods = NULL;\n\tenc_od_size = 0;\n\te = gf_odf_desc_list_write(ptr->descriptors, &enc_ods, &enc_od_size);\n\tif (e) return e;\n\tif (enc_od_size) {\n\t\tgf_bs_write_data(bs, enc_ods, enc_od_size);\n\t\tgf_free(enc_ods);\n\t}\n\treturn GF_OK;\n}\nGF_Err m4ds_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 descSize = 0;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\te = gf_odf_desc_list_size(ptr->descriptors, &descSize);\n\tptr->size += descSize;\n\treturn e;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid avcc_del(GF_Box *s)\n{\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;\n\tif (ptr->config) gf_odf_avc_cfg_del(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err avcc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count;\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;\n\n\tif (ptr->config) gf_odf_avc_cfg_del(ptr->config);\n\tptr->config = gf_odf_avc_cfg_new();\n\tptr->config->configurationVersion = gf_bs_read_u8(bs);\n\tptr->config->AVCProfileIndication = gf_bs_read_u8(bs);\n\tptr->config->profile_compatibility = gf_bs_read_u8(bs);\n\tptr->config->AVCLevelIndication = gf_bs_read_u8(bs);\n\tif (ptr->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tgf_bs_read_int(bs, 6);\n\t} else {\n\t\tptr->config->complete_representation = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 5);\n\t}\n\tptr->config->nal_unit_size = 1 + gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 3);\n\tcount = gf_bs_read_int(bs, 5);\n\n\tptr->size -= 7; //including 2nd count\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\tsl->size = gf_bs_read_u16(bs);\n\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\tgf_list_add(ptr->config->sequenceParameterSets, sl);\n\t\tptr->size -= 2+sl->size;\n\t}\n\n\tcount = gf_bs_read_u8(bs);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\tsl->size = gf_bs_read_u16(bs);\n\t\tif (gf_bs_available(bs) < sl->size) {\n\t\t\tgf_free(sl);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"AVCC: Not enough bits to parse. Aborting.\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\tgf_list_add(ptr->config->pictureParameterSets, sl);\n\t\tptr->size -= 2+sl->size;\n\t}\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tif (gf_avc_is_rext_profile(ptr->config->AVCProfileIndication)) {\n\t\t\tif (!ptr->size) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tAVCState avc;\n\t\t\t\ts32 idx, vui_flag_pos;\n\t\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot*)gf_list_get(ptr->config->sequenceParameterSets, 0);\n\t\t\t\tidx = gf_media_avc_read_sps(sl->data+1, sl->size-1, &avc, 0, (u32 *) &vui_flag_pos);\n\t\t\t\tif (idx>=0) {\n\t\t\t\t\tptr->config->chroma_format = avc.sps[idx].chroma_format;\n\t\t\t\t\tptr->config->luma_bit_depth = 8 + avc.sps[idx].luma_bit_depth_m8;\n\t\t\t\t\tptr->config->chroma_bit_depth = 8 + avc.sps[idx].chroma_bit_depth_m8;\n\t\t\t\t}\n#else\n\t\t\t\t/*set default values ...*/\n\t\t\t\tptr->config->chroma_format = 1;\n\t\t\t\tptr->config->luma_bit_depth = 8;\n\t\t\t\tptr->config->chroma_bit_depth = 8;\n#endif\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tptr->config->chroma_format = gf_bs_read_int(bs, 2);\n\t\t\tgf_bs_read_int(bs, 5);\n\t\t\tptr->config->luma_bit_depth = 8 + gf_bs_read_int(bs, 3);\n\t\t\tgf_bs_read_int(bs, 5);\n\t\t\tptr->config->chroma_bit_depth = 8 + gf_bs_read_int(bs, 3);\n\n\t\t\tcount = gf_bs_read_int(bs, 8);\n\t\t\tptr->size -= 4;\n\t\t\tif (count*2 > ptr->size) {\n\t\t\t\t//ffmpeg just ignores this part while allocating bytes (filled with garbage?)\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"AVCC: invalid numOfSequenceParameterSetExt value. Skipping.\\n\"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (count) {\n\t\t\t\tptr->config->sequenceParameterSetExtensions = gf_list_new();\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\t\t\t\tsl->size = gf_bs_read_u16(bs);\n\t\t\t\t\tif (gf_bs_available(bs) < sl->size) {\n\t\t\t\t\t\tgf_free(sl);\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"AVCC: Not enough bits to parse. Aborting.\\n\"));\n\t\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t\t}\n\t\t\t\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\t\t\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\t\t\t\tgf_list_add(ptr->config->sequenceParameterSetExtensions, sl);\n\t\t\t\t\tptr->size -= sl->size + 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *avcc_New()\n{\n\tGF_AVCConfigurationBox *tmp = (GF_AVCConfigurationBox *) gf_malloc(sizeof(GF_AVCConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_AVCConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_AVCC;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err avcc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count;\n\tGF_Err e;\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->config->configurationVersion);\n\tgf_bs_write_u8(bs, ptr->config->AVCProfileIndication);\n\tgf_bs_write_u8(bs, ptr->config->profile_compatibility);\n\tgf_bs_write_u8(bs, ptr->config->AVCLevelIndication);\n\tif (ptr->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tgf_bs_write_int(bs, 0x3F, 6);\n\t} else {\n\t\tgf_bs_write_int(bs, ptr->config->complete_representation, 1);\n\t\tgf_bs_write_int(bs, 0x1F, 5);\n\t}\n\tgf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);\n\tgf_bs_write_int(bs, 0x7, 3);\n\tcount = gf_list_count(ptr->config->sequenceParameterSets);\n\tgf_bs_write_int(bs, count, 5);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i);\n\t\tgf_bs_write_u16(bs, sl->size);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\n\tcount = gf_list_count(ptr->config->pictureParameterSets);\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i);\n\t\tgf_bs_write_u16(bs, sl->size);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tif (gf_avc_is_rext_profile(ptr->config->AVCProfileIndication)) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, ptr->config->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, ptr->config->luma_bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, ptr->config->chroma_bit_depth - 8, 3);\n\n\t\t\tcount = ptr->config->sequenceParameterSetExtensions ? gf_list_count(ptr->config->sequenceParameterSetExtensions) : 0;\n\t\t\tgf_bs_write_u8(bs, count);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSetExtensions, i);\n\t\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\nGF_Err avcc_Size(GF_Box *s)\n{\n\tu32 i, count;\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\tptr->size += 7;\n\tcount = gf_list_count(ptr->config->sequenceParameterSets);\n\tfor (i=0; i<count; i++)\n\t\tptr->size += 2 + ((GF_AVCConfigSlot *)gf_list_get(ptr->config->sequenceParameterSets, i))->size;\n\n\tcount = gf_list_count(ptr->config->pictureParameterSets);\n\tfor (i=0; i<count; i++)\n\t\tptr->size += 2 + ((GF_AVCConfigSlot *)gf_list_get(ptr->config->pictureParameterSets, i))->size;\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tif (gf_avc_is_rext_profile(ptr->config->AVCProfileIndication)) {\n\t\t\tptr->size += 4;\n\t\t\tcount = ptr->config->sequenceParameterSetExtensions ?gf_list_count(ptr->config->sequenceParameterSetExtensions) : 0;\n\t\t\tfor (i=0; i<count; i++)\n\t\t\t\tptr->size += 2 + ((GF_AVCConfigSlot *)gf_list_get(ptr->config->sequenceParameterSetExtensions, i))->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid hvcc_del(GF_Box *s)\n{\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox*)s;\n\tif (ptr->config) gf_odf_hevc_cfg_del(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err hvcc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 pos;\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox *)s;\n\n\tif (ptr->config) gf_odf_hevc_cfg_del(ptr->config);\n\n\tpos = gf_bs_get_position(bs);\n\tptr->config = gf_odf_hevc_cfg_read_bs(bs, (s->type == GF_ISOM_BOX_TYPE_HVCC) ? GF_FALSE : GF_TRUE);\n\tpos = gf_bs_get_position(bs) - pos ;\n\tif (pos < ptr->size)\n\t\tptr->size -= (u32) pos;\n\n\treturn ptr->config ? GF_OK : GF_ISOM_INVALID_FILE;\n}\nGF_Box *hvcc_New()\n{\n\tGF_HEVCConfigurationBox *tmp = (GF_HEVCConfigurationBox *) gf_malloc(sizeof(GF_HEVCConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_HEVCConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_HVCC;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hvcc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\treturn gf_odf_hevc_cfg_write_bs(ptr->config, bs);\n}\nGF_Err hvcc_Size(GF_Box *s)\n{\n\tu32 i, count, j, subcount;\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (!ptr->config->is_lhvc)\n\t\tptr->size += 23;\n\telse\n\t\tptr->size += 6;\n\n\tcount = gf_list_count(ptr->config->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_HEVCParamArray *ar = (GF_HEVCParamArray*)gf_list_get(ptr->config->param_array, i);\n\t\tptr->size += 3;\n\t\tsubcount = gf_list_count(ar->nalus);\n\t\tfor (j=0; j<subcount; j++) {\n\t\t\tptr->size += 2 + ((GF_AVCConfigSlot *)gf_list_get(ar->nalus, j))->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_OperatingPointsInformation *gf_isom_oinf_new_entry()\n{\n\tGF_OperatingPointsInformation* ptr;\n\tGF_SAFEALLOC(ptr, GF_OperatingPointsInformation);\n\tif (ptr) {\n\t\tptr->profile_tier_levels = gf_list_new();\n\t\tptr->operating_points = gf_list_new();\n\t\tptr->dependency_layers = gf_list_new();\n\t}\n\treturn ptr;\n\n}\n\nvoid gf_isom_oinf_del_entry(void *entry)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tif (!ptr) return;\n\tif (ptr->profile_tier_levels) {\n\t\twhile (gf_list_count(ptr->profile_tier_levels)) {\n\t\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, 0);\n\t\t\tgf_free(ptl);\n\t\t\tgf_list_rem(ptr->profile_tier_levels, 0);\n\t\t}\n\t\tgf_list_del(ptr->profile_tier_levels);\n\t}\n\tif (ptr->operating_points) {\n\t\twhile (gf_list_count(ptr->operating_points)) {\n\t\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, 0);\n\t\t\tgf_free(op);\n\t\t\tgf_list_rem(ptr->operating_points, 0);\n\t\t}\n\t\tgf_list_del(ptr->operating_points);\n\t}\n\tif (ptr->dependency_layers) {\n\t\twhile (gf_list_count(ptr->dependency_layers)) {\n\t\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, 0);\n\t\t\tgf_free(dep);\n\t\t\tgf_list_rem(ptr->dependency_layers, 0);\n\t\t}\n\t\tgf_list_del(ptr->dependency_layers);\n\t}\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tptr->scalability_mask = gf_bs_read_u16(bs);\n\tgf_bs_read_int(bs, 2);//reserved\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl;\n\t\tGF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);\n\t\tif (!ptl) return GF_OUT_OF_MEM;\n\t\tptl->general_profile_space = gf_bs_read_int(bs, 2);\n\t\tptl->general_tier_flag= gf_bs_read_int(bs, 1);\n\t\tptl->general_profile_idc = gf_bs_read_int(bs, 5);\n\t\tptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);\n\t\tptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);\n\t\tptl->general_level_idc = gf_bs_read_u8(bs);\n\t\tgf_list_add(ptr->profile_tier_levels, ptl);\n\t}\n\tcount = gf_bs_read_u16(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top->max_temporal_id = gf_bs_read_u8(bs);\n\t\top->layer_count = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\top->minPicWidth = gf_bs_read_u16(bs);\n\t\top->minPicHeight = gf_bs_read_u16(bs);\n\t\top->maxPicWidth = gf_bs_read_u16(bs);\n\t\top->maxPicHeight = gf_bs_read_u16(bs);\n\t\top->maxChromaFormat = gf_bs_read_int(bs, 2);\n\t\top->maxBitDepth = gf_bs_read_int(bs, 3) + 8;\n\t\tgf_bs_read_int(bs, 1);//reserved\n\t\top->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\top->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\tif (op->frame_rate_info_flag) {\n\t\t\top->avgFrameRate = gf_bs_read_u16(bs);\n\t\t\tgf_bs_read_int(bs, 6); //reserved\n\t\t\top->constantFrameRate = gf_bs_read_int(bs, 2);\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\top->maxBitRate = gf_bs_read_u32(bs);\n\t\t\top->avgBitRate = gf_bs_read_u32(bs);\n\t\t}\n\t\tgf_list_add(ptr->operating_points, op);\n\t}\n\tcount = gf_bs_read_u8(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep;\n\t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);\n\t\tif (!dep) return GF_OUT_OF_MEM;\n\t\tdep->dependent_layerID = gf_bs_read_u8(bs);\n\t\tdep->num_layers_dependent_on = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\tdep->dependent_on_layerID[j] = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tdep->dimension_identifier[j] = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_add(ptr->dependency_layers, dep);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_oinf_write_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\tif (!ptr) return GF_OK;\n\n\tgf_bs_write_u16(bs, ptr->scalability_mask);\n\tgf_bs_write_int(bs, 0xFF, 2);//reserved\n\tcount=gf_list_count(ptr->profile_tier_levels);\n\tgf_bs_write_int(bs, count, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, i);\n\t\tgf_bs_write_int(bs, ptl->general_profile_space, 2);\n\t\tgf_bs_write_int(bs, ptl->general_tier_flag, 1);\n\t\tgf_bs_write_int(bs, ptl->general_profile_idc, 5);\n\t\tgf_bs_write_u32(bs, ptl->general_profile_compatibility_flags);\n\t\tgf_bs_write_long_int(bs, ptl->general_constraint_indicator_flags, 48);\n\t\tgf_bs_write_u8(bs, ptl->general_level_idc);\n\t}\n\tcount=gf_list_count(ptr->operating_points);\n\tgf_bs_write_u16(bs, count);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);;\n\t\tgf_bs_write_u16(bs, op->output_layer_set_idx);\n\t\tgf_bs_write_u8(bs, op->max_temporal_id);\n\t\tgf_bs_write_u8(bs, op->layer_count);\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\tgf_bs_write_u8(bs, op->layers_info[j].ptl_idx);\n\t\t\tgf_bs_write_int(bs, op->layers_info[j].layer_id, 6);\n\t\t\top->layers_info[j].is_outputlayer ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\t\top->layers_info[j].is_alternate_outputlayer ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\t}\n\t\tgf_bs_write_u16(bs, op->minPicWidth);\n\t\tgf_bs_write_u16(bs, op->minPicHeight);\n\t\tgf_bs_write_u16(bs, op->maxPicWidth);\n\t\tgf_bs_write_u16(bs, op->maxPicHeight);\n\t\tgf_bs_write_int(bs, op->maxChromaFormat, 2);\n\t\tgf_bs_write_int(bs, op->maxBitDepth - 8, 3);\n\t\tgf_bs_write_int(bs, 0x1, 1);//resereved\n\t\top->frame_rate_info_flag ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\top->bit_rate_info_flag ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\tif (op->frame_rate_info_flag) {\n\t\t\tgf_bs_write_u16(bs, op->avgFrameRate);\n\t\t\tgf_bs_write_int(bs, 0xFF, 6); //reserved\n\t\t\tgf_bs_write_int(bs, op->constantFrameRate, 2);\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\tgf_bs_write_u32(bs, op->maxBitRate);\n\t\t\tgf_bs_write_u32(bs, op->avgBitRate);\n\t\t}\n\t}\n\tcount=gf_list_count(ptr->dependency_layers);\n\tgf_bs_write_u8(bs, count);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);\n\t\tgf_bs_write_u8(bs, dep->dependent_layerID);\n\t\tgf_bs_write_u8(bs, dep->num_layers_dependent_on);\n\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\tgf_bs_write_u8(bs, dep->dependent_on_layerID[j]);\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tgf_bs_write_u8(bs, dep->dimension_identifier[j]);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nu32 gf_isom_oinf_size_entry(void *entry)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 size = 0, i ,j, count;\n\tif (!ptr) return 0;\n\n\tsize += 3; //scalability_mask + reserved + num_profile_tier_level\n\tcount=gf_list_count(ptr->profile_tier_levels);\n\tsize += count * 12; //general_profile_space + general_tier_flag + general_profile_idc + general_profile_compatibility_flags + general_constraint_indicator_flags + general_level_idc\n\tsize += 2;//num_operating_points\n\tcount=gf_list_count(ptr->operating_points);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);;\n\t\tsize += 2/*output_layer_set_idx*/ + 1/*max_temporal_id*/ + 1/*layer_count*/;\n\t\tsize += op->layer_count * 2;\n\t\tsize += 9;\n\t\tif (op->frame_rate_info_flag) {\n\t\t\tsize += 3;\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\tsize += 8;\n\t\t}\n\t}\n\tsize += 1;//max_layer_count\n\tcount=gf_list_count(ptr->dependency_layers);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);\n\t\tsize += 1/*dependent_layerID*/ + 1/*num_layers_dependent_on*/;\n\t\tsize += dep->num_layers_dependent_on * 1;//dependent_on_layerID\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tsize += 1;//dimension_identifier\n\t\t}\n\t}\n\treturn size;\n}\n\n\nGF_LHVCLayerInformation *gf_isom_linf_new_entry()\n{\n\tGF_LHVCLayerInformation* ptr;\n\tGF_SAFEALLOC(ptr, GF_LHVCLayerInformation);\n\tif (ptr) ptr->num_layers_in_track = gf_list_new();\n\n\treturn ptr;\n\n}\n\nvoid gf_isom_linf_del_entry(void *entry)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tif (!ptr) return;\n\twhile (gf_list_count(ptr->num_layers_in_track)) {\n\t\tLHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, 0);\n\t\tgf_free(li);\n\t\tgf_list_rem(ptr->num_layers_in_track, 0);\n\t}\n\tgf_list_del(ptr->num_layers_in_track);\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err gf_isom_linf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tu32 i, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tgf_bs_read_int(bs, 2);\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHVCLayerInfoItem *li;\n\t\tGF_SAFEALLOC(li, LHVCLayerInfoItem);\n\t\tif (!li) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_int(bs, 4);\n\t\tli->layer_id = gf_bs_read_int(bs, 6);\n\t\tli->min_TemporalId = gf_bs_read_int(bs, 3);\n\t\tli->max_TemporalId = gf_bs_read_int(bs, 3);\n\t\tgf_bs_read_int(bs, 1);\n\t\tli->sub_layer_presence_flags = gf_bs_read_int(bs, 7);\n\t\tgf_list_add(ptr->num_layers_in_track, li);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_linf_write_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tu32 i, count;\n\tif (!ptr) return GF_OK;\n\n\tgf_bs_write_int(bs, 0, 2);\n\tcount=gf_list_count(ptr->num_layers_in_track);\n\tgf_bs_write_int(bs, count, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, i);\n\t\tgf_bs_write_int(bs, 0, 4);\n\t\tgf_bs_write_int(bs, li->layer_id, 6);\n\t\tgf_bs_write_int(bs, li->min_TemporalId, 3);\n\t\tgf_bs_write_int(bs, li->max_TemporalId, 3);\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, li->sub_layer_presence_flags, 7);\n\t}\n\treturn GF_OK;\n}\n\nu32 gf_isom_linf_size_entry(void *entry)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tu32 size = 0, count;\n\tif (!ptr) return 0;\n\n\tsize += 1;\n\tcount=gf_list_count(ptr->num_layers_in_track);\n\tsize += count * 3;\n\treturn size;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre, Romain Bouqueau, Cyril Concolato\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/media_dev.h>\n#include <gpac/constants.h>\n#include <gpac/mpeg4_odf.h>\n#include <gpac/maths.h>\n\n#ifndef GPAC_DISABLE_OGG\n#include <gpac/internal/ogg.h>\n#endif\n\nstatic const struct {\n\tu32 w, h;\n} std_par[ ] =\n{\n\t{ 4, 3}, {3, 2}, {16, 9}, {5, 3}, {5, 4}, {8, 5}, {2, 1},\n\t{0, 0},\n};\n\nGF_EXPORT\nvoid gf_media_reduce_aspect_ratio(u32 *width, u32 *height)\n{\n\tu32 i=0;\n\tu32 w = *width;\n\tu32 h = *height;\n\twhile (std_par[i].w) {\n\t\tif (std_par[i].w * h == std_par[i].h * w) {\n\t\t\t*width = std_par[i].w;\n\t\t\t*height = std_par[i].h;\n\t\t\treturn;\n\t\t}\n\t\ti++;\n\t}\n}\n\nGF_EXPORT\nvoid gf_media_get_reduced_frame_rate(u32 *timescale, u32 *sample_dur)\n{\n\tu32 res;\n\tif (! *sample_dur) return;\n\tres = *timescale / *sample_dur;\n\tif (res **sample_dur == *timescale) {\n\t\t*timescale = res;\n\t\t*sample_dur = 1;\n\t} else if ((double)(*timescale * 1001 - (res+1) * *sample_dur * 1000) / ((res+1) * *sample_dur * 1000) < 0.001) {\n\t\t*timescale = (res+1) * 1000;\n\t\t*sample_dur = 1001;\n\t}\n}\n\nGF_EXPORT\nconst char *gf_m4v_get_profile_name(u8 video_pl)\n{\n\tswitch (video_pl) {\n\tcase 0x00:\n\t\treturn \"Reserved (0x00) Profile\";\n\tcase 0x01:\n\t\treturn \"Simple Profile @ Level 1\";\n\tcase 0x02:\n\t\treturn \"Simple Profile @ Level 2\";\n\tcase 0x03:\n\t\treturn \"Simple Profile @ Level 3\";\n\tcase 0x08:\n\t\treturn \"Simple Profile @ Level 0\";\n\tcase 0x10:\n\t\treturn \"Simple Scalable Profile @ Level 0\";\n\tcase 0x11:\n\t\treturn \"Simple Scalable Profile @ Level 1\";\n\tcase 0x12:\n\t\treturn \"Simple Scalable Profile @ Level 2\";\n\tcase 0x21:\n\t\treturn \"Core Profile @ Level 1\";\n\tcase 0x22:\n\t\treturn \"Core Profile @ Level 2\";\n\tcase 0x32:\n\t\treturn \"Main Profile @ Level 2\";\n\tcase 0x33:\n\t\treturn \"Main Profile @ Level 3\";\n\tcase 0x34:\n\t\treturn \"Main Profile @ Level 4\";\n\tcase 0x42:\n\t\treturn \"N-bit Profile @ Level 2\";\n\tcase 0x51:\n\t\treturn \"Scalable Texture Profile @ Level 1\";\n\tcase 0x61:\n\t\treturn \"Simple Face Animation Profile @ Level 1\";\n\tcase 0x62:\n\t\treturn \"Simple Face Animation Profile @ Level 2\";\n\tcase 0x63:\n\t\treturn \"Simple FBA Profile @ Level 1\";\n\tcase 0x64:\n\t\treturn \"Simple FBA Profile @ Level 2\";\n\tcase 0x71:\n\t\treturn \"Basic Animated Texture Profile @ Level 1\";\n\tcase 0x72:\n\t\treturn \"Basic Animated Texture Profile @ Level 2\";\n\tcase 0x7F:\n\t\treturn \"AVC/H264 Profile\";\n\tcase 0x81:\n\t\treturn \"Hybrid Profile @ Level 1\";\n\tcase 0x82:\n\t\treturn \"Hybrid Profile @ Level 2\";\n\tcase 0x91:\n\t\treturn \"Advanced Real Time Simple Profile @ Level 1\";\n\tcase 0x92:\n\t\treturn \"Advanced Real Time Simple Profile @ Level 2\";\n\tcase 0x93:\n\t\treturn \"Advanced Real Time Simple Profile @ Level 3\";\n\tcase 0x94:\n\t\treturn \"Advanced Real Time Simple Profile @ Level 4\";\n\tcase 0xA1:\n\t\treturn \"Core Scalable Profile @ Level1\";\n\tcase 0xA2:\n\t\treturn \"Core Scalable Profile @ Level2\";\n\tcase 0xA3:\n\t\treturn \"Core Scalable Profile @ Level3\";\n\tcase 0xB1:\n\t\treturn \"Advanced Coding Efficiency Profile @ Level 1\";\n\tcase 0xB2:\n\t\treturn \"Advanced Coding Efficiency Profile @ Level 2\";\n\tcase 0xB3:\n\t\treturn \"Advanced Coding Efficiency Profile @ Level 3\";\n\tcase 0xB4:\n\t\treturn \"Advanced Coding Efficiency Profile @ Level 4\";\n\tcase 0xC1:\n\t\treturn \"Advanced Core Profile @ Level 1\";\n\tcase 0xC2:\n\t\treturn \"Advanced Core Profile @ Level 2\";\n\tcase 0xD1:\n\t\treturn \"Advanced Scalable Texture @ Level1\";\n\tcase 0xD2:\n\t\treturn \"Advanced Scalable Texture @ Level2\";\n\tcase 0xE1:\n\t\treturn \"Simple Studio Profile @ Level 1\";\n\tcase 0xE2:\n\t\treturn \"Simple Studio Profile @ Level 2\";\n\tcase 0xE3:\n\t\treturn \"Simple Studio Profile @ Level 3\";\n\tcase 0xE4:\n\t\treturn \"Simple Studio Profile @ Level 4\";\n\tcase 0xE5:\n\t\treturn \"Core Studio Profile @ Level 1\";\n\tcase 0xE6:\n\t\treturn \"Core Studio Profile @ Level 2\";\n\tcase 0xE7:\n\t\treturn \"Core Studio Profile @ Level 3\";\n\tcase 0xE8:\n\t\treturn \"Core Studio Profile @ Level 4\";\n\tcase 0xF0:\n\t\treturn \"Advanced Simple Profile @ Level 0\";\n\tcase 0xF1:\n\t\treturn \"Advanced Simple Profile @ Level 1\";\n\tcase 0xF2:\n\t\treturn \"Advanced Simple Profile @ Level 2\";\n\tcase 0xF3:\n\t\treturn \"Advanced Simple Profile @ Level 3\";\n\tcase 0xF4:\n\t\treturn \"Advanced Simple Profile @ Level 4\";\n\tcase 0xF5:\n\t\treturn \"Advanced Simple Profile @ Level 5\";\n\tcase 0xF7:\n\t\treturn \"Advanced Simple Profile @ Level 3b\";\n\tcase 0xF8:\n\t\treturn \"Fine Granularity Scalable Profile @ Level 0\";\n\tcase 0xF9:\n\t\treturn \"Fine Granularity Scalable Profile @ Level 1\";\n\tcase 0xFA:\n\t\treturn \"Fine Granularity Scalable Profile @ Level 2\";\n\tcase 0xFB:\n\t\treturn \"Fine Granularity Scalable Profile @ Level 3\";\n\tcase 0xFC:\n\t\treturn \"Fine Granularity Scalable Profile @ Level 4\";\n\tcase 0xFD:\n\t\treturn \"Fine Granularity Scalable Profile @ Level 5\";\n\tcase 0xFE:\n\t\treturn \"Not part of MPEG-4 Visual profiles\";\n\tcase 0xFF:\n\t\treturn \"No visual capability required\";\n\tdefault:\n\t\treturn \"ISO Reserved Profile\";\n\t}\n}\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n#define MPEG12_START_CODE_PREFIX\t\t0x000001\n#define MPEG12_PICTURE_START_CODE\t\t0x00000100\n#define MPEG12_SLICE_MIN_START\t\t\t0x00000101\n#define MPEG12_SLICE_MAX_START\t\t\t0x000001af\n#define MPEG12_USER_DATA_START_CODE\t\t0x000001b2\n#define MPEG12_SEQUENCE_START_CODE\t\t0x000001b3\n#define MPEG12_SEQUENCE_ERR_START_CODE\t0x000001b4\n#define MPEG12_EXT_START_CODE\t\t\t0x000001b5\n#define MPEG12_SEQUENCE_END_START_CODE\t0x000001b7\n#define MPEG12_GOP_START_CODE\t\t\t0x000001b8\n\ns32 gf_mv12_next_start_code(unsigned char *pbuffer, u32 buflen, u32 *optr, u32 *scode)\n{\n\tu32 value;\n\tu32 offset;\n\n\tif (buflen < 4) return -1;\n\tfor (offset = 0; offset < buflen - 3; offset++, pbuffer++) {\n#ifdef GPAC_BIG_ENDIAN\n\t\tvalue = *(u32 *)pbuffer >> 8;\n#else\n\t\tvalue = (pbuffer[0] << 16) | (pbuffer[1] << 8) | (pbuffer[2] << 0);\n#endif\n\n\t\tif (value == MPEG12_START_CODE_PREFIX) {\n\t\t\t*optr = offset;\n\t\t\t*scode = (value << 8) | pbuffer[3];\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\ns32 gf_mv12_next_slice_start(unsigned char *pbuffer, u32 startoffset, u32 buflen, u32 *slice_offset)\n{\n\tu32 slicestart, code;\n\twhile (gf_mv12_next_start_code(pbuffer + startoffset, buflen - startoffset, &slicestart, &code) >= 0) {\n\t\tif ((code >= MPEG12_SLICE_MIN_START) && (code <= MPEG12_SLICE_MAX_START)) {\n\t\t\t*slice_offset = slicestart + startoffset;\n\t\t\treturn 0;\n\t\t}\n\t\tstartoffset += slicestart + 4;\n\t}\n\treturn -1;\n}\n\n\n/*\n\tMPEG-4 video (14496-2)\n*/\n\n#define M4V_VO_START_CODE\t\t\t\t\t0x00\n#define M4V_VOL_START_CODE\t\t\t\t\t0x20\n#define M4V_VOP_START_CODE\t\t\t\t\t0xB6\n#define M4V_VISOBJ_START_CODE\t\t\t\t0xB5\n#define M4V_VOS_START_CODE\t\t\t\t\t0xB0\n#define M4V_GOV_START_CODE\t\t\t\t\t0xB3\n#define M4V_UDTA_START_CODE\t\t\t\t\t0xB2\n\n\n#define M2V_PIC_START_CODE\t\t\t\t\t0x00\n#define M2V_SEQ_START_CODE\t\t\t\t\t0xB3\n#define M2V_EXT_START_CODE\t\t\t\t\t0xB5\n#define M2V_GOP_START_CODE\t\t\t\t\t0xB8\n\nstruct __tag_m4v_parser\n{\n\tGF_BitStream *bs;\n\tBool mpeg12;\n\tu32 current_object_type;\n\tu64 current_object_start;\n\tu32 tc_dec, prev_tc_dec, tc_disp, prev_tc_disp;\n};\n\nGF_EXPORT\nGF_M4VParser *gf_m4v_parser_new(char *data, u64 data_size, Bool mpeg12video)\n{\n\tGF_M4VParser *tmp;\n\tif (!data || !data_size) return NULL;\n\tGF_SAFEALLOC(tmp, GF_M4VParser);\n\tif (!tmp) return NULL;\n\ttmp->bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\ttmp->mpeg12 = mpeg12video;\n\treturn tmp;\n}\n\nGF_M4VParser *gf_m4v_parser_bs_new(GF_BitStream *bs, Bool mpeg12video)\n{\n\tGF_M4VParser *tmp;\n\tGF_SAFEALLOC(tmp, GF_M4VParser);\n\tif (!tmp) return NULL;\n\ttmp->bs = bs;\n\ttmp->mpeg12 = mpeg12video;\n\treturn tmp;\n}\n\nGF_EXPORT\nvoid gf_m4v_parser_del(GF_M4VParser *m4v)\n{\n\tgf_bs_del(m4v->bs);\n\tgf_free(m4v);\n}\n\n\n#define M4V_CACHE_SIZE\t\t4096\ns32 M4V_LoadObject(GF_M4VParser *m4v)\n{\n\tu32 v, bpos, found;\n\tchar m4v_cache[M4V_CACHE_SIZE];\n\tu64 end, cache_start, load_size;\n\tif (!m4v) return 0;\n\tbpos = 0;\n\tfound = 0;\n\tload_size = 0;\n\tend = 0;\n\tcache_start = 0;\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\t/*refill cache*/\n\t\tif (bpos == (u32) load_size) {\n\t\t\tif (!gf_bs_available(m4v->bs)) break;\n\t\t\tload_size = gf_bs_available(m4v->bs);\n\t\t\tif (load_size>M4V_CACHE_SIZE) load_size=M4V_CACHE_SIZE;\n\t\t\tbpos = 0;\n\t\t\tcache_start = gf_bs_get_position(m4v->bs);\n\t\t\tgf_bs_read_data(m4v->bs, m4v_cache, (u32) load_size);\n\t\t}\n\t\tv = ( (v<<8) & 0xFFFFFF00) | ((u8) m4v_cache[bpos]);\n\t\tbpos++;\n\t\tif ((v & 0xFFFFFF00) == 0x00000100) {\n\t\t\tend = cache_start+bpos-4;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) return -1;\n\tm4v->current_object_start = end;\n\tgf_bs_seek(m4v->bs, end+3);\n\tm4v->current_object_type = gf_bs_read_u8(m4v->bs);\n\treturn (s32) m4v->current_object_type;\n}\n\n\nGF_EXPORT\nvoid gf_m4v_rewrite_pl(char **o_data, u32 *o_dataLen, u8 PL)\n{\n\tu32 pos = 0;\n\tunsigned char *data = (unsigned char *)*o_data;\n\tu32 dataLen = *o_dataLen;\n\n\twhile (pos+4<dataLen) {\n\t\tif (!data[pos] && !data[pos+1] && (data[pos+2]==0x01) && (data[pos+3]==M4V_VOS_START_CODE)) {\n\t\t\tdata[pos+4] = PL;\n\t\t\treturn;\n\t\t}\n\t\tpos ++;\n\t}\n\t/*emulate VOS at beggining*/\n\t(*o_data) = (char *)gf_malloc(sizeof(char)*(dataLen+5));\n\t(*o_data)[0] = 0;\n\t(*o_data)[1] = 0;\n\t(*o_data)[2] = 1;\n\t(*o_data)[3] = (char) M4V_VOS_START_CODE;\n\t(*o_data)[4] = PL;\n\tmemcpy( (*o_data + 5), data, sizeof(char)*dataLen);\n\tgf_free(data);\n\t(*o_dataLen) = dataLen + 5;\n}\n\nstatic GF_Err M4V_Reset(GF_M4VParser *m4v, u64 start)\n{\n\tgf_bs_seek(m4v->bs, start);\n\tassert(start < 1<<31);\n\tm4v->current_object_start = (u32) start;\n\tm4v->current_object_type = 0;\n\treturn GF_OK;\n}\n\n\nstatic GF_Err gf_m4v_parse_config_mpeg12(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\tunsigned char p[4];\n\tu32 ext_type;\n\ts32 o_type;\n\tu8 go, par;\n\n\tif (!m4v || !dsi) return GF_BAD_PARAM;\n\n\tmemset(dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tdsi->VideoPL = 0;\n\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M2V_SEQ_START_CODE:\n\t\t\tdsi->RAP_stream = 1;\n\t\t\tgf_bs_read_data(m4v->bs,  (char *) p, 4);\n\t\t\tdsi->width = (p[0] << 4) | ((p[1] >> 4) & 0xf);\n\t\t\tdsi->height = ((p[1] & 0xf) << 8) | p[2];\n\n\t\t\tdsi->VideoPL = GPAC_OTI_VIDEO_MPEG1;\n\t\t\tpar = (p[3] >> 4) & 0xf;\n\t\t\tswitch (par) {\n\t\t\tcase 2:\n\t\t\t\tdsi->par_num = dsi->height/3;\n\t\t\t\tdsi->par_den = dsi->width/4;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdsi->par_num = dsi->height/9;\n\t\t\t\tdsi->par_den = dsi->width/16;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdsi->par_num = dsi->height/2;\n\t\t\t\tdsi->par_den = dsi->width/21;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdsi->par_den = dsi->par_num = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (p[3] & 0xf) {\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tdsi->fps = 24000.0/1001.0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdsi->fps = 24.0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdsi->fps = 25.0;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdsi->fps = 30000.0/1001.0;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tdsi->fps = 30.0;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tdsi->fps = 50.0;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tdsi->fps = ((60.0*1000.0)/1001.0);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tdsi->fps = 60.0;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tdsi->fps = 1;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tdsi->fps = 5;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tdsi->fps = 10;\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\tdsi->fps = 12;\n\t\t\t\tbreak;\n\t\t\tcase 13:\n\t\t\t\tdsi->fps = 15;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase M2V_EXT_START_CODE:\n\t\t\tgf_bs_read_data(m4v->bs,  (char *) p, 4);\n\t\t\text_type = ((p[0] >> 4) & 0xf);\n\t\t\tif (ext_type == 1) {\n\t\t\t\tdsi->VideoPL = 0x65;\n\t\t\t\tdsi->height = ((p[1] & 0x1) << 13) | ((p[2] & 0x80) << 5) | (dsi->height & 0x0fff);\n\t\t\t\tdsi->width = (((p[2] >> 5) & 0x3) << 12) | (dsi->width & 0x0fff);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase M2V_PIC_START_CODE:\n\t\t\tif (dsi->width) go = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t/*EOS*/\n\t\tcase -1:\n\t\t\tgo = 0;\n\t\t\tm4v->current_object_start = gf_bs_get_position(m4v->bs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tM4V_Reset(m4v, 0);\n\treturn GF_OK;\n}\n\n\nstatic const struct {\n\tu32 w, h;\n} m4v_sar[6] = { { 0,   0 }, { 1,   1 }, { 12, 11 }, { 10, 11 }, { 16, 11 }, { 40, 33 } };\n\nstatic u8 m4v_get_sar_idx(u32 w, u32 h)\n{\n\tu32 i;\n\tfor (i=0; i<6; i++) {\n\t\tif ((m4v_sar[i].w==w) && (m4v_sar[i].h==h)) return i;\n\t}\n\treturn 0xF;\n}\n\nstatic GF_Err gf_m4v_parse_config_mpeg4(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\ts32 o_type;\n\tu8 go, verid, par;\n\ts32 clock_rate;\n\n\tif (!m4v || !dsi) return GF_BAD_PARAM;\n\n\tmemset(dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\t/*vosh*/\n\t\tcase M4V_VOS_START_CODE:\n\t\t\tdsi->VideoPL = (u8) gf_bs_read_u8(m4v->bs);\n\t\t\tbreak;\n\n\t\tcase M4V_VOL_START_CODE:\n\t\t\tverid = 0;\n\t\t\tdsi->RAP_stream = gf_bs_read_int(m4v->bs, 1);\n\t\t\tdsi->objectType = gf_bs_read_int(m4v->bs, 8);\n\t\t\tif (gf_bs_read_int(m4v->bs, 1)) {\n\t\t\t\tverid = gf_bs_read_int(m4v->bs, 4);\n\t\t\t\tgf_bs_read_int(m4v->bs, 3);\n\t\t\t}\n\t\t\tpar = gf_bs_read_int(m4v->bs, 4);\n\t\t\tif (par == 0xF) {\n\t\t\t\tdsi->par_num = gf_bs_read_int(m4v->bs, 8);\n\t\t\t\tdsi->par_den = gf_bs_read_int(m4v->bs, 8);\n\t\t\t} else if (par<6) {\n\t\t\t\tdsi->par_num = m4v_sar[par].w;\n\t\t\t\tdsi->par_den = m4v_sar[par].h;\n\t\t\t}\n\t\t\tif (gf_bs_read_int(m4v->bs, 1)) {\n\t\t\t\tgf_bs_read_int(m4v->bs, 3);\n\t\t\t\tif (gf_bs_read_int(m4v->bs, 1)) gf_bs_read_int(m4v->bs, 79);\n\t\t\t}\n\t\t\tdsi->has_shape = gf_bs_read_int(m4v->bs, 2);\n\t\t\tif (dsi->has_shape && (verid!=1) ) gf_bs_read_int(m4v->bs, 4);\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t/*clock rate*/\n\t\t\tdsi->clock_rate = gf_bs_read_int(m4v->bs, 16);\n\t\t\t/*marker*/\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\n\t\t\tclock_rate = dsi->clock_rate-1;\n\t\t\tif (clock_rate >= 65536) clock_rate = 65535;\n\t\t\tif (clock_rate > 0) {\n\t\t\t\tfor (dsi->NumBitsTimeIncrement = 1; dsi->NumBitsTimeIncrement < 16; dsi->NumBitsTimeIncrement++)\t{\n\t\t\t\t\tif (clock_rate == 1) break;\n\t\t\t\t\tclock_rate = (clock_rate >> 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*fix from vivien for divX*/\n\t\t\t\tdsi->NumBitsTimeIncrement = 1;\n\t\t\t}\n\t\t\t/*fixed FPS stream*/\n\t\t\tdsi->time_increment = 0;\n\t\t\tif (gf_bs_read_int(m4v->bs, 1)) {\n\t\t\t\tdsi->time_increment = gf_bs_read_int(m4v->bs, dsi->NumBitsTimeIncrement);\n\t\t\t}\n\t\t\tif (!dsi->has_shape) {\n\t\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t\tdsi->width = gf_bs_read_int(m4v->bs, 13);\n\t\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t\tdsi->height = gf_bs_read_int(m4v->bs, 13);\n\t\t\t} else {\n\t\t\t\tdsi->width = dsi->height = 0;\n\t\t\t}\n\t\t\t/*shape will be done later*/\n\t\t\tgf_bs_align(m4v->bs);\n\t\t\tbreak;\n\n\t\tcase M4V_VOP_START_CODE:\n\t\tcase M4V_GOV_START_CODE:\n\t\t\tgo = 0;\n\t\t\tbreak;\n\t\t/*EOS*/\n\t\tcase -1:\n\t\t\tgo = 0;\n\t\t\tm4v->current_object_start = gf_bs_get_position(m4v->bs);\n\t\t\tbreak;\n\t\t/*don't interest us*/\n\t\tcase M4V_UDTA_START_CODE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4v_parse_config(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\tif (m4v->mpeg12) {\n\t\treturn gf_m4v_parse_config_mpeg12(m4v, dsi);\n\t} else {\n\t\treturn gf_m4v_parse_config_mpeg4(m4v, dsi);\n\t}\n}\n\nstatic GF_Err gf_m4v_parse_frame_mpeg12(GF_M4VParser *m4v, GF_M4VDecSpecInfo dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tu8 go, hasVOP, firstObj, val;\n\ts32 o_type;\n\n\tif (!m4v || !size || !start || !frame_type) return GF_BAD_PARAM;\n\n\t*size = 0;\n\tfirstObj = 1;\n\thasVOP = 0;\n\t*is_coded = GF_FALSE;\n\tm4v->current_object_type = (u32) -1;\n\t*frame_type = 0;\n\n\tM4V_Reset(m4v, m4v->current_object_start);\n\tgo = 1;\n\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M2V_PIC_START_CODE:\n\t\t\t/*done*/\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\thasVOP = 1;\n\t\t\t*is_coded = 1;\n\n\t\t\t/*val = */gf_bs_read_u8(m4v->bs);\n\t\t\tval = gf_bs_read_u8(m4v->bs);\n\t\t\t*frame_type = ( (val >> 3) & 0x7 ) - 1;\n\t\t\tbreak;\n\t\tcase M2V_GOP_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) go = 0;\n\t\t\tbreak;\n\n\t\tcase M2V_SEQ_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/**/\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\n\t\tcase -1:\n\t\t\t*size = gf_bs_get_position(m4v->bs) - *start;\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\n\t*size = m4v->current_object_start - *start;\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_m4v_parse_frame_mpeg4(GF_M4VParser *m4v, GF_M4VDecSpecInfo dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tu8 go, hasVOP, firstObj, secs;\n\ts32 o_type;\n\tu32 vop_inc = 0;\n\n\tif (!m4v || !size || !start || !frame_type) return GF_BAD_PARAM;\n\n\t*size = 0;\n\tfirstObj = 1;\n\thasVOP = 0;\n\t*is_coded = 0;\n\tm4v->current_object_type = (u32) -1;\n\t*frame_type = 0;\n\n\tM4V_Reset(m4v, m4v->current_object_start);\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M4V_VOP_START_CODE:\n\t\t\t/*done*/\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\thasVOP = 1;\n\n\t\t\t/*coding type*/\n\t\t\t*frame_type = gf_bs_read_int(m4v->bs, 2);\n\t\t\t/*modulo time base*/\n\t\t\tsecs = 0;\n\t\t\twhile (gf_bs_read_int(m4v->bs, 1) != 0)\n\t\t\t\tsecs ++;\n\t\t\t/*no support for B frames in parsing*/\n\t\t\tsecs += (dsi.enh_layer || *frame_type!=2) ? m4v->tc_dec : m4v->tc_disp;\n\t\t\t/*marker*/\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t/*vop_time_inc*/\n\t\t\tif (dsi.NumBitsTimeIncrement)\n\t\t\t\tvop_inc = gf_bs_read_int(m4v->bs, dsi.NumBitsTimeIncrement);\n\n\t\t\tm4v->prev_tc_dec = m4v->tc_dec;\n\t\t\tm4v->prev_tc_disp = m4v->tc_disp;\n\t\t\tif (dsi.enh_layer || *frame_type!=2) {\n\t\t\t\tm4v->tc_disp = m4v->tc_dec;\n\t\t\t\tm4v->tc_dec = secs;\n\t\t\t}\n\t\t\t*time_inc = secs * dsi.clock_rate + vop_inc;\n\t\t\t/*marker*/\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t/*coded*/\n\t\t\t*is_coded = gf_bs_read_int(m4v->bs, 1);\n\t\t\tgf_bs_align(m4v->bs);\n\t\t\tbreak;\n\t\tcase M4V_GOV_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) go = 0;\n\t\t\tbreak;\n\n\t\tcase M4V_VOS_START_CODE:\n\t\tcase M4V_VOL_START_CODE:\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t} else if (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase M4V_VO_START_CODE:\n\t\tdefault:\n\t\t\tbreak;\n\n\t\tcase -1:\n\t\t\t*size = gf_bs_get_position(m4v->bs) - *start;\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\n\t*size = m4v->current_object_start - *start;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4v_parse_frame(GF_M4VParser *m4v, GF_M4VDecSpecInfo dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tif (m4v->mpeg12) {\n\t\treturn gf_m4v_parse_frame_mpeg12(m4v, dsi, frame_type, time_inc, size, start, is_coded);\n\t} else {\n\t\treturn gf_m4v_parse_frame_mpeg4(m4v, dsi, frame_type, time_inc, size, start, is_coded);\n\t}\n}\n\nGF_Err gf_m4v_rewrite_par(char **o_data, u32 *o_dataLen, s32 par_n, s32 par_d)\n{\n\tu64 start, end, size;\n\tGF_BitStream *mod;\n\tGF_M4VParser *m4v;\n\tBool go = 1;\n\n\tm4v = gf_m4v_parser_new(*o_data, *o_dataLen, 0);\n\tmod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tstart = 0;\n\twhile (go) {\n\t\tu32 type = M4V_LoadObject(m4v);\n\n\t\tend = gf_bs_get_position(m4v->bs) - 4;\n\t\tsize = end - start;\n\t\t/*store previous object*/\n\t\tif (size) {\n\t\t\tassert (size < 1<<31);\n\t\t\tif (size) gf_bs_write_data(mod, *o_data + start, (u32) size);\n\t\t\tstart = end;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase M4V_VOL_START_CODE:\n\t\t\tgf_bs_write_int(mod, 0, 8);\n\t\t\tgf_bs_write_int(mod, 0, 8);\n\t\t\tgf_bs_write_int(mod, 1, 8);\n\t\t\tgf_bs_write_int(mod, M4V_VOL_START_CODE, 8);\n\t\t\tgf_bs_write_int(mod, gf_bs_read_int(m4v->bs, 1), 1);\n\t\t\tgf_bs_write_int(mod, gf_bs_read_int(m4v->bs, 8), 8);\n\t\t\tstart = gf_bs_read_int(m4v->bs, 1);\n\t\t\tgf_bs_write_int(mod, (u32) start, 1);\n\t\t\tif (start) {\n\t\t\t\tgf_bs_write_int(mod, gf_bs_read_int(m4v->bs, 7), 7);\n\t\t\t}\n\t\t\tstart = gf_bs_read_int(m4v->bs, 4);\n\t\t\tif (start == 0xF) {\n\t\t\t\tgf_bs_read_int(m4v->bs, 8);\n\t\t\t\tgf_bs_read_int(m4v->bs, 8);\n\t\t\t}\n\t\t\tif ((par_n>=0) && (par_d>=0)) {\n\t\t\t\tu8 par = m4v_get_sar_idx(par_n, par_d);\n\t\t\t\tgf_bs_write_int(mod, par, 4);\n\t\t\t\tif (par==0xF) {\n\t\t\t\t\tgf_bs_write_int(mod, par_n, 8);\n\t\t\t\t\tgf_bs_write_int(mod, par_d, 8);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mod, 0x0, 4);\n\t\t\t}\n\t\tcase -1:\n\t\t\tgo = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (gf_bs_bits_available(m4v->bs)) {\n\t\tu32 b = gf_bs_read_int(m4v->bs, 1);\n\t\tgf_bs_write_int(mod, b, 1);\n\t}\n\n\tgf_m4v_parser_del(m4v);\n\tgf_free(*o_data);\n\tgf_bs_get_content(mod, o_data, o_dataLen);\n\tgf_bs_del(mod);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu64 gf_m4v_get_object_start(GF_M4VParser *m4v)\n{\n\treturn m4v->current_object_start;\n}\n\nGF_EXPORT\nBool gf_m4v_is_valid_object_type(GF_M4VParser *m4v)\n{\n\treturn ((s32) m4v->current_object_type==-1) ? 0 : 1;\n}\n\n\nGF_EXPORT\nGF_Err gf_m4v_get_config(char *rawdsi, u32 rawdsi_size, GF_M4VDecSpecInfo *dsi)\n{\n\tGF_Err e;\n\tGF_M4VParser *vparse;\n\tif (!rawdsi || !rawdsi_size) return GF_NON_COMPLIANT_BITSTREAM;\n\tvparse = gf_m4v_parser_new(rawdsi, rawdsi_size, 0);\n\te = gf_m4v_parse_config(vparse, dsi);\n\tdsi->next_object_start = (u32) vparse->current_object_start;\n\tgf_m4v_parser_del(vparse);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_mpegv12_get_config(char *rawdsi, u32 rawdsi_size, GF_M4VDecSpecInfo *dsi)\n{\n\tGF_Err e;\n\tGF_M4VParser *vparse;\n\tif (!rawdsi || !rawdsi_size) return GF_NON_COMPLIANT_BITSTREAM;\n\tvparse = gf_m4v_parser_new(rawdsi, rawdsi_size, GF_TRUE);\n\te = gf_m4v_parse_config(vparse, dsi);\n\tdsi->next_object_start = (u32) vparse->current_object_start;\n\tgf_m4v_parser_del(vparse);\n\treturn e;\n}\n\n#endif\n\n\n/*\n\tAAC parser\n*/\n\nGF_EXPORT\nconst char *gf_m4a_object_type_name(u32 objectType)\n{\n\tswitch (objectType) {\n\tcase 0:\n\t\treturn \"MPEG-4 Audio Reserved\";\n\tcase 1:\n\t\treturn \"MPEG-4 Audio AAC Main\";\n\tcase 2:\n\t\treturn \"MPEG-4 Audio AAC LC\";\n\tcase 3:\n\t\treturn \"MPEG-4 Audio AAC SSR\";\n\tcase 4:\n\t\treturn \"MPEG-4 Audio AAC LTP\";\n\tcase 5:\n\t\treturn \"MPEG-4 Audio SBR\";\n\tcase 6:\n\t\treturn \"MPEG-4 Audio AAC Scalable\";\n\tcase 7:\n\t\treturn \"MPEG-4 Audio TwinVQ\";\n\tcase 8:\n\t\treturn \"MPEG-4 Audio CELP\";\n\tcase 9:\n\t\treturn \"MPEG-4 Audio HVXC\";\n\tcase 10:\n\t\treturn \"MPEG-4 Audio Reserved\";\n\tcase 11:\n\t\treturn \"MPEG-4 Audio Reserved\";\n\tcase 12:\n\t\treturn \"MPEG-4 Audio TTSI\";\n\tcase 13:\n\t\treturn \"MPEG-4 Audio Main synthetic\";\n\tcase 14:\n\t\treturn \"MPEG-4 Audio Wavetable synthesis\";\n\tcase 15:\n\t\treturn \"MPEG-4 Audio General MIDI\";\n\tcase 16:\n\t\treturn \"MPEG-4 Audio Algorithmic Synthesis and Audio FX\";\n\tcase 17:\n\t\treturn \"MPEG-4 Audio ER AAC LC\";\n\tcase 18:\n\t\treturn \"MPEG-4 Audio Reserved\";\n\tcase 19:\n\t\treturn \"MPEG-4 Audio ER AAC LTP\";\n\tcase 20:\n\t\treturn \"MPEG-4 Audio ER AAC scalable\";\n\tcase 21:\n\t\treturn \"MPEG-4 Audio ER TwinVQ\";\n\tcase 22:\n\t\treturn \"MPEG-4 Audio ER BSAC\";\n\tcase 23:\n\t\treturn \"MPEG-4 Audio ER AAC LD\";\n\tcase 24:\n\t\treturn \"MPEG-4 Audio ER CELP\";\n\tcase 25:\n\t\treturn \"MPEG-4 Audio ER HVXC\";\n\tcase 26:\n\t\treturn \"MPEG-4 Audio ER HILN\";\n\tcase 27:\n\t\treturn \"MPEG-4 Audio ER Parametric\";\n\tcase 28:\n\t\treturn \"MPEG-4 Audio SSC\";\n\tcase 29:\n\t\treturn \"MPEG-4 Audio ParametricStereo\";\n\tcase 30:\n\t\treturn \"MPEG-4 Audio Reserved\";\n\tcase 31:\n\t\treturn \"MPEG-4 Audio Reserved\";\n\tcase 32:\n\t\treturn \"MPEG-1 Audio Layer-1\";\n\tcase 33:\n\t\treturn \"MPEG-1 Audio Layer-2\";\n\tcase 34:\n\t\treturn \"MPEG-1 Audio Layer-3\";\n\tcase 35:\n\t\treturn \"MPEG-4 Audio DST\";\n\tcase 36:\n\t\treturn \"MPEG-4 Audio ALS\";\n\tdefault:\n\t\treturn \"MPEG-4 Audio Unknown\";\n\t}\n}\n\nGF_EXPORT\nconst char *gf_m4a_get_profile_name(u8 audio_pl)\n{\n\tswitch (audio_pl) {\n\tcase 0x00:\n\t\treturn \"ISO Reserved (0x00)\";\n\tcase 0x01:\n\t\treturn \"Main Audio Profile @ Level 1\";\n\tcase 0x02:\n\t\treturn \"Main Audio Profile @ Level 2\";\n\tcase 0x03:\n\t\treturn \"Main Audio Profile @ Level 3\";\n\tcase 0x04:\n\t\treturn \"Main Audio Profile @ Level 4\";\n\tcase 0x05:\n\t\treturn \"Scalable Audio Profile @ Level 1\";\n\tcase 0x06:\n\t\treturn \"Scalable Audio Profile @ Level 2\";\n\tcase 0x07:\n\t\treturn \"Scalable Audio Profile @ Level 3\";\n\tcase 0x08:\n\t\treturn \"Scalable Audio Profile @ Level 4\";\n\tcase 0x09:\n\t\treturn \"Speech Audio Profile @ Level 1\";\n\tcase 0x0A:\n\t\treturn \"Speech Audio Profile @ Level 2\";\n\tcase 0x0B:\n\t\treturn \"Synthetic Audio Profile @ Level 1\";\n\tcase 0x0C:\n\t\treturn \"Synthetic Audio Profile @ Level 2\";\n\tcase 0x0D:\n\t\treturn \"Synthetic Audio Profile @ Level 3\";\n\tcase 0x0E:\n\t\treturn \"High Quality Audio Profile @ Level 1\";\n\tcase 0x0F:\n\t\treturn \"High Quality Audio Profile @ Level 2\";\n\tcase 0x10:\n\t\treturn \"High Quality Audio Profile @ Level 3\";\n\tcase 0x11:\n\t\treturn \"High Quality Audio Profile @ Level 4\";\n\tcase 0x12:\n\t\treturn \"High Quality Audio Profile @ Level 5\";\n\tcase 0x13:\n\t\treturn \"High Quality Audio Profile @ Level 6\";\n\tcase 0x14:\n\t\treturn \"High Quality Audio Profile @ Level 7\";\n\tcase 0x15:\n\t\treturn \"High Quality Audio Profile @ Level 8\";\n\tcase 0x16:\n\t\treturn \"Low Delay Audio Profile @ Level 1\";\n\tcase 0x17:\n\t\treturn \"Low Delay Audio Profile @ Level 2\";\n\tcase 0x18:\n\t\treturn \"Low Delay Audio Profile @ Level 3\";\n\tcase 0x19:\n\t\treturn \"Low Delay Audio Profile @ Level 4\";\n\tcase 0x1A:\n\t\treturn \"Low Delay Audio Profile @ Level 5\";\n\tcase 0x1B:\n\t\treturn \"Low Delay Audio Profile @ Level 6\";\n\tcase 0x1C:\n\t\treturn \"Low Delay Audio Profile @ Level 7\";\n\tcase 0x1D:\n\t\treturn \"Low Delay Audio Profile @ Level 8\";\n\tcase 0x1E:\n\t\treturn \"Natural Audio Profile @ Level 1\";\n\tcase 0x1F:\n\t\treturn \"Natural Audio Profile @ Level 2\";\n\tcase 0x20:\n\t\treturn \"Natural Audio Profile @ Level 3\";\n\tcase 0x21:\n\t\treturn \"Natural Audio Profile @ Level 4\";\n\tcase 0x22:\n\t\treturn \"Mobile Audio Internetworking Profile @ Level 1\";\n\tcase 0x23:\n\t\treturn \"Mobile Audio Internetworking Profile @ Level 2\";\n\tcase 0x24:\n\t\treturn \"Mobile Audio Internetworking Profile @ Level 3\";\n\tcase 0x25:\n\t\treturn \"Mobile Audio Internetworking Profile @ Level 4\";\n\tcase 0x26:\n\t\treturn \"Mobile Audio Internetworking Profile @ Level 5\";\n\tcase 0x27:\n\t\treturn \"Mobile Audio Internetworking Profile @ Level 6\";\n\tcase 0x28:\n\t\treturn \"AAC Profile @ Level 1\";\n\tcase 0x29:\n\t\treturn \"AAC Profile @ Level 2\";\n\tcase 0x2A:\n\t\treturn \"AAC Profile @ Level 4\";\n\tcase 0x2B:\n\t\treturn \"AAC Profile @ Level 5\";\n\tcase 0x2C:\n\t\treturn \"High Efficiency AAC Profile @ Level 2\";\n\tcase 0x2D:\n\t\treturn \"High Efficiency AAC Profile @ Level 3\";\n\tcase 0x2E:\n\t\treturn \"High Efficiency AAC Profile @ Level 4\";\n\tcase 0x2F:\n\t\treturn \"High Efficiency AAC Profile @ Level 5\";\n\tcase 0x30:\n\t\treturn \"High Efficiency AAC v2 Profile @ Level 2\";\n\tcase 0x31:\n\t\treturn \"High Efficiency AAC v2 Profile @ Level 3\";\n\tcase 0x32:\n\t\treturn \"High Efficiency AAC v2 Profile @ Level 4\";\n\tcase 0x33:\n\t\treturn \"High Efficiency AAC v2 Profile @ Level 5\";\n\tcase 0x34:\n\t\treturn \"Low Delay AAC Profile\";\n\tcase 0x35:\n\t\treturn \"Baseline MPEG Surround Profile @ Level 1\";\n\tcase 0x36:\n\t\treturn \"Baseline MPEG Surround Profile @ Level 2\";\n\tcase 0x37:\n\t\treturn \"Baseline MPEG Surround Profile @ Level 3\";\n\tcase 0x38:\n\t\treturn \"Baseline MPEG Surround Profile @ Level 4\";\n\tcase 0x39:\n\t\treturn \"Baseline MPEG Surround Profile @ Level 5\";\n\tcase 0x3A:\n\t\treturn \"Baseline MPEG Surround Profile @ Level 6\";\n\n\tcase 0x50:\n\t\treturn \"AAC Profile @ Level 6\";\n\tcase 0x51:\n\t\treturn \"AAC Profile @ Level 7\";\n\tcase 0x52:\n\t\treturn \"High Efficiency AAC Profile @ Level 6\";\n\tcase 0x53:\n\t\treturn \"High Efficiency AAC Profile @ Level 7\";\n\tcase 0x54:\n\t\treturn \"High Efficiency AAC v2 Profile @ Level 6\";\n\tcase 0x55:\n\t\treturn \"High Efficiency AAC v2 Profile @ Level 7\";\n\tcase 0x56:\n\t\treturn \"Extended High Efficiency AAC Profile @ Level 6\";\n\tcase 0x57:\n\t\treturn \"Extended High Efficiency AAC Profile @ Level 7\";\n\n\tcase 0xFE:\n\t\treturn \"Not part of MPEG-4 audio profiles\";\n\tcase 0xFF:\n\t\treturn \"No audio capability required\";\n\tdefault:\n\t\treturn \"ISO Reserved / User Private\";\n\t}\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\nGF_EXPORT\nu32 gf_m4a_get_profile(GF_M4ADecSpecInfo *cfg)\n{\n\tswitch (cfg->base_object_type) {\n\tcase 2: /*AAC LC*/\n\t\tif (cfg->nb_chan<=2)\n\t\t\treturn (cfg->base_sr<=24000) ? 0x28 : 0x29; /*LC@L1 or LC@L2*/\n\t\tif (cfg->nb_chan<=5)\n\t\t\treturn (cfg->base_sr<=48000) ? 0x2A : 0x2B; /*LC@L4 or LC@L5*/\n\t\treturn (cfg->base_sr<=48000) ? 0x50 : 0x51; /*LC@L4 or LC@L5*/\n\tcase 5: /*HE-AAC - SBR*/\n\t\tif (cfg->nb_chan<=2)\n\t\t\treturn (cfg->base_sr<=24000) ? 0x2C : 0x2D; /*HE@L2 or HE@L3*/\n\t\tif (cfg->nb_chan<=5)\n\t\t\treturn (cfg->base_sr<=48000) ? 0x2E : 0x2F; /*HE@L4 or HE@L5*/\n\t\treturn (cfg->base_sr<=48000) ? 0x52 : 0x53; /*HE@L6 or HE@L7*/\n\tcase 29: /*HE-AACv2 - SBR+PS*/\n\t\tif (cfg->nb_chan<=2)\n\t\t\treturn (cfg->base_sr<=24000) ? 0x30 : 0x31; /*HE-AACv2@L2 or HE-AACv2@L3*/\n\t\tif (cfg->nb_chan<=5)\n\t\t\treturn (cfg->base_sr<=48000) ? 0x32 : 0x33; /*HE-AACv2@L4 or HE-AACv2@L5*/\n\t\treturn (cfg->base_sr<=48000) ? 0x54 : 0x55; /*HE-AACv2@L6 or HE-AACv2@L7*/\n\t/*default to HQ*/\n\tdefault:\n\t\tif (cfg->nb_chan<=2) return (cfg->base_sr<24000) ? 0x0E : 0x0F; /*HQ@L1 or HQ@L2*/\n\t\treturn 0x10; /*HQ@L3*/\n\t}\n}\n\n\n\nGF_EXPORT\nGF_Err gf_m4a_parse_config(GF_BitStream *bs, GF_M4ADecSpecInfo *cfg, Bool size_known)\n{\n\tu32 channel_configuration = 0;\n\tmemset(cfg, 0, sizeof(GF_M4ADecSpecInfo));\n\tcfg->base_object_type = gf_bs_read_int(bs, 5);\n\t/*extended object type*/\n\tif (cfg->base_object_type==31) {\n\t\tcfg->base_object_type = 32 + gf_bs_read_int(bs, 6);\n\t}\n\tcfg->base_sr_index = gf_bs_read_int(bs, 4);\n\tif (cfg->base_sr_index == 0x0F) {\n\t\tcfg->base_sr = gf_bs_read_int(bs, 24);\n\t} else {\n\t\tcfg->base_sr = GF_M4ASampleRates[cfg->base_sr_index];\n\t}\n\n\tchannel_configuration = gf_bs_read_int(bs, 4);\n\n\tif (channel_configuration) {\n\t\tcfg->nb_chan = GF_M4ANumChannels[channel_configuration-1];\n\t}\n\n\tif (cfg->base_object_type==5 || cfg->base_object_type==29) {\n\t\tif (cfg->base_object_type==29) {\n\t\t\tcfg->has_ps = 1;\n\t\t\tcfg->nb_chan = 1;\n\t\t}\n\t\tcfg->has_sbr = GF_TRUE;\n\t\tcfg->sbr_sr_index = gf_bs_read_int(bs, 4);\n\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\tcfg->sbr_sr = gf_bs_read_int(bs, 24);\n\t\t} else {\n\t\t\tcfg->sbr_sr = GF_M4ASampleRates[cfg->sbr_sr_index];\n\t\t}\n\t\tcfg->sbr_object_type = gf_bs_read_int(bs, 5);\n\t}\n\n\t/*object cfg*/\n\tswitch (cfg->base_object_type) {\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 6:\n\tcase 7:\n\tcase 17:\n\tcase 19:\n\tcase 20:\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\t{\n\t\tBool ext_flag;\n\t\t/*frame length flag*/\n\t\t/*fl_flag = */gf_bs_read_int(bs, 1);\n\t\t/*depends on core coder*/\n\t\tif (gf_bs_read_int(bs, 1))\n\t\t\t/*delay = */gf_bs_read_int(bs, 14);\n\t\text_flag = gf_bs_read_int(bs, 1);\n\n\t\tif (! channel_configuration) {\n\t\t\tu32 i;\n\t\t\tcfg->program_config_element_present = 1;\n\t\t\tcfg->element_instance_tag = gf_bs_read_int(bs, 4);\n\t\t\tcfg->object_type = gf_bs_read_int(bs, 2);\n\t\t\tcfg->sampling_frequency_index = gf_bs_read_int(bs, 4);\n\t\t\tcfg->num_front_channel_elements = gf_bs_read_int(bs, 4);\n\t\t\tcfg->num_side_channel_elements = gf_bs_read_int(bs, 4);\n\t\t\tcfg->num_back_channel_elements = gf_bs_read_int(bs, 4);\n\t\t\tcfg->num_lfe_channel_elements = gf_bs_read_int(bs, 2);\n\t\t\tcfg->num_assoc_data_elements = gf_bs_read_int(bs, 3);\n\t\t\tcfg->num_valid_cc_elements = gf_bs_read_int(bs, 4);\n\t\t\tcfg-> mono_mixdown_present = (Bool) gf_bs_read_int(bs, 1);\n\t\t\tif (cfg->mono_mixdown_present) {\n\t\t\t\tcfg->mono_mixdown_element_number = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tcfg->stereo_mixdown_present = gf_bs_read_int(bs, 1);\n\t\t\tif (cfg->stereo_mixdown_present) {\n\t\t\t\tcfg->stereo_mixdown_element_number = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tcfg->matrix_mixdown_idx_present = gf_bs_read_int(bs, 1);\n\t\t\tif (cfg->matrix_mixdown_idx_present) {\n\t\t\t\tcfg->matrix_mixdown_idx = gf_bs_read_int(bs, 2);\n\t\t\t\tcfg->pseudo_surround_enable = gf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_front_channel_elements; i++) {\n\t\t\t\tcfg->front_element_is_cpe[i] = gf_bs_read_int(bs, 1);\n\t\t\t\tcfg->front_element_tag_select[i] = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_side_channel_elements; i++) {\n\t\t\t\tcfg->side_element_is_cpe[i] = gf_bs_read_int(bs, 1);\n\t\t\t\tcfg->side_element_tag_select[i] = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_back_channel_elements; i++) {\n\t\t\t\tcfg->back_element_is_cpe[i] = gf_bs_read_int(bs, 1);\n\t\t\t\tcfg->back_element_tag_select[i] = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_lfe_channel_elements; i++) {\n\t\t\t\tcfg->lfe_element_tag_select[i] = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tfor ( i = 0; i < cfg->num_assoc_data_elements; i++) {\n\t\t\t\tcfg->assoc_data_element_tag_select[i] = gf_bs_read_int(bs, 4);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < cfg->num_valid_cc_elements; i++) {\n\t\t\t\tcfg->cc_element_is_ind_sw[i] = gf_bs_read_int(bs, 1);\n\t\t\t\tcfg->valid_cc_element_tag_select[i] = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tgf_bs_align(bs);\n\t\t\tcfg->comment_field_bytes = gf_bs_read_int(bs, 8);\n\t\t\tgf_bs_read_data(bs, (char *) cfg->comments, cfg->comment_field_bytes);\n\n\t\t\tcfg->nb_chan = cfg->num_front_channel_elements + cfg->num_back_channel_elements + cfg->num_side_channel_elements + cfg->num_lfe_channel_elements;\n\t\t}\n\n\t\tif ((cfg->base_object_type == 6) || (cfg->base_object_type == 20)) {\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t}\n\t\tif (ext_flag) {\n\t\t\tif (cfg->base_object_type == 22) {\n\t\t\t\tgf_bs_read_int(bs, 5);\n\t\t\t\tgf_bs_read_int(bs, 11);\n\t\t\t}\n\t\t\tif ((cfg->base_object_type == 17)\n\t\t\t        || (cfg->base_object_type == 19)\n\t\t\t        || (cfg->base_object_type == 20)\n\t\t\t        || (cfg->base_object_type == 23)\n\t\t\t   ) {\n\t\t\t\tgf_bs_read_int(bs, 1);\n\t\t\t\tgf_bs_read_int(bs, 1);\n\t\t\t\tgf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t\t/*ext_flag = */gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\tbreak;\n\t}\n\t/*ER cfg*/\n\tswitch (cfg->base_object_type) {\n\tcase 17:\n\tcase 19:\n\tcase 20:\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\tcase 24:\n\tcase 25:\n\tcase 26:\n\tcase 27:\n\t{\n\t\tu32 epConfig = gf_bs_read_int(bs, 2);\n\t\tif ((epConfig == 2) || (epConfig == 3) ) {\n\t\t}\n\t\tif (epConfig == 3) {\n\t\t\tgf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\tbreak;\n\t}\n\n\tif (size_known && (cfg->base_object_type != 5) && (cfg->base_object_type != 29) ) {\n\t\twhile (gf_bs_available(bs)>=2) {\n\t\t\tu32 sync = gf_bs_peek_bits(bs, 11, 0);\n\t\t\tif (sync==0x2b7) {\n\t\t\t\tgf_bs_read_int(bs, 11);\n\t\t\t\tcfg->sbr_object_type = gf_bs_read_int(bs, 5);\n\t\t\t\tcfg->has_sbr = gf_bs_read_int(bs, 1);\n\t\t\t\tif (cfg->has_sbr) {\n\t\t\t\t\tcfg->sbr_sr_index = gf_bs_read_int(bs, 4);\n\t\t\t\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\t\t\t\tcfg->sbr_sr = gf_bs_read_int(bs, 24);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcfg->sbr_sr = GF_M4ASampleRates[cfg->sbr_sr_index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (sync == 0x548) {\n\t\t\t\tgf_bs_read_int(bs, 11);\n\t\t\t\tcfg->has_ps = gf_bs_read_int(bs, 1);\n\t\t\t\tif (cfg->has_ps)\n\t\t\t\t\tcfg->nb_chan = 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcfg->audioPL = gf_m4a_get_profile(cfg);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_get_config(char *dsi, u32 dsi_size, GF_M4ADecSpecInfo *cfg)\n{\n\tGF_BitStream *bs;\n\tif (!dsi || !dsi_size || (dsi_size<2) ) return GF_NON_COMPLIANT_BITSTREAM;\n\tbs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tgf_m4a_parse_config(bs, cfg, 1);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nu32 gf_latm_get_value(GF_BitStream *bs)\n{\n\tu32 i, tmp, value = 0;\n\tu32 bytesForValue = gf_bs_read_int(bs, 2);\n\tfor (i=0; i <= bytesForValue; i++) {\n\t\tvalue <<= 8;\n\t\ttmp = gf_bs_read_int(bs, 8);\n\t\tvalue += tmp;\n\t}\n\treturn value;\n}\n\nGF_EXPORT\nu32 gf_m4a_get_channel_cfg(u32 nb_chan)\n{\n\tu32 i, count = sizeof(GF_M4ANumChannels)/sizeof(u32);\n\tfor (i=0; i<count; i++) {\n\t\tif (GF_M4ANumChannels[i] == nb_chan) return i+1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_write_config_bs(GF_BitStream *bs, GF_M4ADecSpecInfo *cfg)\n{\n\tif (!cfg->base_sr_index) {\n\t\tif (!cfg->base_sr) return GF_BAD_PARAM;\n\t\twhile (GF_M4ASampleRates[cfg->base_sr_index]) {\n\t\t\tif (GF_M4ASampleRates[cfg->base_sr_index]==cfg->base_sr)\n\t\t\t\tbreak;\n\t\t\tcfg->base_sr_index++;\n\t\t}\n\t}\n\tif (cfg->sbr_sr && !cfg->sbr_sr_index) {\n\t\twhile (GF_M4ASampleRates[cfg->sbr_sr_index]) {\n\t\t\tif (GF_M4ASampleRates[cfg->sbr_sr_index]==cfg->sbr_sr)\n\t\t\t\tbreak;\n\t\t\tcfg->sbr_sr_index++;\n\t\t}\n\t}\n\t/*extended object type*/\n\tif (cfg->base_object_type>=32) {\n\t\tgf_bs_write_int(bs, 31, 5);\n\t\tgf_bs_write_int(bs, cfg->base_object_type-32, 6);\n\t} else {\n\t\tgf_bs_write_int(bs, cfg->base_object_type, 5);\n\t}\n\tgf_bs_write_int(bs, cfg->base_sr_index, 4);\n\tif (cfg->base_sr_index == 0x0F) {\n\t\tgf_bs_write_int(bs, cfg->base_sr, 24);\n\t}\n\n\tif (cfg->program_config_element_present) {\n\t\tgf_bs_write_int(bs, 0, 4);\n\t} else {\n\t\tgf_bs_write_int(bs, gf_m4a_get_channel_cfg( cfg->nb_chan) , 4);\n\t}\n\n\tif (cfg->base_object_type==5 || cfg->base_object_type==29) {\n\t\tif (cfg->base_object_type == 29) {\n\t\t\tcfg->has_ps = 1;\n\t\t\tcfg->nb_chan = 1;\n\t\t}\n\t\tcfg->has_sbr = 1;\n\t\tgf_bs_write_int(bs, cfg->sbr_sr_index, 4);\n\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\tgf_bs_write_int(bs, cfg->sbr_sr, 24);\n\t\t}\n\t\tgf_bs_write_int(bs, cfg->sbr_object_type, 5);\n\t}\n\n\t/*object cfg*/\n\tswitch (cfg->base_object_type) {\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 6:\n\tcase 7:\n\tcase 17:\n\tcase 19:\n\tcase 20:\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\t{\n\t\t/*frame length flag*/\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\t/*depends on core coder*/\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\t/*ext flag*/\n\t\tgf_bs_write_int(bs, 0, 1);\n\n\t\tif (cfg->program_config_element_present) {\n\t\t\tu32 i;\n\t\t\tgf_bs_write_int(bs, cfg->element_instance_tag, 4);\n\t\t\tgf_bs_write_int(bs, cfg->object_type, 2);\n\t\t\tgf_bs_write_int(bs, cfg->sampling_frequency_index, 4);\n\t\t\tgf_bs_write_int(bs, cfg->num_front_channel_elements, 4);\n\t\t\tgf_bs_write_int(bs, cfg->num_side_channel_elements, 4);\n\t\t\tgf_bs_write_int(bs, cfg->num_back_channel_elements, 4);\n\t\t\tgf_bs_write_int(bs, cfg->num_lfe_channel_elements, 2);\n\t\t\tgf_bs_write_int(bs, cfg->num_assoc_data_elements, 3);\n\t\t\tgf_bs_write_int(bs, cfg->num_valid_cc_elements, 4);\n\t\t\tgf_bs_write_int(bs, cfg-> mono_mixdown_present, 1);\n\t\t\tif (cfg->mono_mixdown_present) {\n\t\t\t\tgf_bs_write_int(bs, cfg->mono_mixdown_element_number, 4);\n\t\t\t}\n\t\t\tgf_bs_write_int(bs, cfg->stereo_mixdown_present, 1);\n\t\t\tif (cfg->stereo_mixdown_present) {\n\t\t\t\tgf_bs_write_int(bs, cfg->stereo_mixdown_element_number, 4);\n\t\t\t}\n\t\t\tgf_bs_write_int(bs, cfg->matrix_mixdown_idx_present, 1);\n\t\t\tif (cfg->matrix_mixdown_idx_present) {\n\t\t\t\tgf_bs_write_int(bs, cfg->matrix_mixdown_idx, 2);\n\t\t\t\tgf_bs_write_int(bs, cfg->pseudo_surround_enable, 1);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_front_channel_elements; i++) {\n\t\t\t\tgf_bs_write_int(bs, cfg->front_element_is_cpe[i], 1);\n\t\t\t\tgf_bs_write_int(bs, cfg->front_element_tag_select[i], 4);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_side_channel_elements; i++) {\n\t\t\t\tgf_bs_write_int(bs, cfg->side_element_is_cpe[i], 1);\n\t\t\t\tgf_bs_write_int(bs, cfg->side_element_tag_select[i], 4);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_back_channel_elements; i++) {\n\t\t\t\tgf_bs_write_int(bs, cfg->back_element_is_cpe[i], 1);\n\t\t\t\tgf_bs_write_int(bs, cfg->back_element_tag_select[i], 4);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_lfe_channel_elements; i++) {\n\t\t\t\tgf_bs_write_int(bs, cfg->lfe_element_tag_select[i], 4);\n\t\t\t}\n\t\t\tfor ( i = 0; i < cfg->num_assoc_data_elements; i++) {\n\t\t\t\tgf_bs_write_int(bs, cfg->assoc_data_element_tag_select[i], 4);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < cfg->num_valid_cc_elements; i++) {\n\t\t\t\tgf_bs_write_int(bs, cfg->cc_element_is_ind_sw[i], 1);\n\t\t\t\tgf_bs_write_int(bs, cfg->valid_cc_element_tag_select[i], 4);\n\t\t\t}\n\t\t\tgf_bs_align(bs);\n\t\t\tgf_bs_write_int(bs, cfg->comment_field_bytes, 8);\n\t\t\tgf_bs_write_data(bs, (char *) cfg->comments, cfg->comment_field_bytes);\n\t\t}\n\n\t\tif ((cfg->base_object_type == 6) || (cfg->base_object_type == 20)) {\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t}\n\t}\n\tbreak;\n\t}\n\t/*ER cfg - not supported*/\n\n\t/*implicit sbr - not used yet*/\n\tif (0 && (cfg->base_object_type != 5) && (cfg->base_object_type != 29) ) {\n\t\tgf_bs_write_int(bs, 0x2b7, 11);\n\t\tcfg->sbr_object_type = gf_bs_read_int(bs, 5);\n\t\tcfg->has_sbr = gf_bs_read_int(bs, 1);\n\t\tif (cfg->has_sbr) {\n\t\t\tcfg->sbr_sr_index = gf_bs_read_int(bs, 4);\n\t\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\t\tcfg->sbr_sr = gf_bs_read_int(bs, 24);\n\t\t\t} else {\n\t\t\t\tcfg->sbr_sr = GF_M4ASampleRates[cfg->sbr_sr_index];\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_write_config(GF_M4ADecSpecInfo *cfg, char **dsi, u32 *dsi_size)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_m4a_write_config_bs(bs, cfg);\n\tgf_bs_get_content(bs, dsi, dsi_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\nGF_EXPORT\nu8 gf_mp3_version(u32 hdr)\n{\n\treturn ((hdr >> 19) & 0x3);\n}\n\nGF_EXPORT\nconst char *gf_mp3_version_name(u32 hdr)\n{\n\tu32 v = gf_mp3_version(hdr);\n\tswitch (v) {\n\tcase 0:\n\t\treturn \"MPEG-2.5\";\n\tcase 1:\n\t\treturn \"Reserved\";\n\tcase 2:\n\t\treturn \"MPEG-2\";\n\tcase 3:\n\t\treturn \"MPEG-1\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n\nGF_EXPORT\nu8 gf_mp3_layer(u32 hdr)\n{\n\treturn 4 - (((hdr >> 17) & 0x3));\n}\n\nGF_EXPORT\nu8 gf_mp3_num_channels(u32 hdr)\n{\n\tif (((hdr >> 6) & 0x3) == 3) return 1;\n\treturn 2;\n}\n\nGF_EXPORT\nu16 gf_mp3_sampling_rate(u32 hdr)\n{\n\tu16 res;\n\t/* extract the necessary fields from the MP3 header */\n\tu8 version = gf_mp3_version(hdr);\n\tu8 sampleRateIndex = (hdr >> 10) & 0x3;\n\n\tswitch (sampleRateIndex) {\n\tcase 0:\n\t\tres = 44100;\n\t\tbreak;\n\tcase 1:\n\t\tres = 48000;\n\t\tbreak;\n\tcase 2:\n\t\tres = 32000;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[MPEG-1/2 Audio] Samplerate index not valid\\n\"));\n\t\treturn 0;\n\t}\n\t/*reserved or MPEG-1*/\n\tif (version & 1) return res;\n\n\t/*MPEG-2*/\n\tres /= 2;\n\t/*MPEG-2.5*/\n\tif (version == 0) res /= 2;\n\treturn res;\n}\n\nGF_EXPORT\nu16 gf_mp3_window_size(u32 hdr)\n{\n\tu8 version = gf_mp3_version(hdr);\n\tu8 layer = gf_mp3_layer(hdr);\n\n\tif (layer == 3) {\n\t\tif (version == 3) return 1152;\n\t\treturn 576;\n\t}\n\tif (layer == 2) return 1152;\n\treturn 384;\n}\n\nGF_EXPORT\nu8 gf_mp3_object_type_indication(u32 hdr)\n{\n\tswitch (gf_mp3_version(hdr)) {\n\tcase 3:\n\t\treturn GPAC_OTI_AUDIO_MPEG1;\n\tcase 2:\n\tcase 0:\n\t\treturn GPAC_OTI_AUDIO_MPEG2_PART3;\n\tdefault:\n\t\treturn 0x00;\n\t}\n}\n\n/*aligned bitrate parsing with libMAD*/\n\nstatic\nu32 const bitrate_table[5][15] = {\n\t/* MPEG-1 */\n\t{\t0,  32000,  64000,  96000, 128000, 160000, 192000, 224000,  /* Layer I   */\n\t\t256000, 288000, 320000, 352000, 384000, 416000, 448000\n\t},\n\t{\t0,  32000,  48000,  56000,  64000,  80000,  96000, 112000,  /* Layer II  */\n\t\t128000, 160000, 192000, 224000, 256000, 320000, 384000\n\t},\n\t{\t0,  32000,  40000,  48000,  56000,  64000,  80000,  96000,  /* Layer III */\n\t\t112000, 128000, 160000, 192000, 224000, 256000, 320000\n\t},\n\n\t/* MPEG-2 LSF */\n\t{\t0,  32000,  48000,  56000,  64000,  80000,  96000, 112000,  /* Layer I   */\n\t\t128000, 144000, 160000, 176000, 192000, 224000, 256000\n\t},\n\t{\t0,   8000,  16000,  24000,  32000,  40000,  48000,  56000,  /* Layers    */\n\t\t64000,  80000,  96000, 112000, 128000, 144000, 160000\n\t} /* II & III  */\n};\n\n\nu32 gf_mp3_bit_rate(u32 hdr)\n{\n\tu8 version = gf_mp3_version(hdr);\n\tu8 layer = gf_mp3_layer(hdr);\n\tu8 bitRateIndex = (hdr >> 12) & 0xF;\n\n\tif (bitRateIndex == 15) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[MPEG-1/2 Audio] Bitrate index not valid\\n\"));\n\t\treturn 0;\n\t}\n\n\t/*MPEG-1*/\n\tif (version & 1)\n\t\treturn bitrate_table[layer - 1][bitRateIndex];\n\t/*MPEG-2/2.5*/\n\telse\n\t\treturn bitrate_table[3 + (layer >> 1)][bitRateIndex];\n}\n\n\n\nGF_EXPORT\nu16 gf_mp3_frame_size(u32 hdr)\n{\n\tu8 version = gf_mp3_version(hdr);\n\tu8 layer = gf_mp3_layer(hdr);\n\tu32 pad = ( (hdr >> 9) & 0x1) ? 1 : 0;\n\tu32 bitrate = gf_mp3_bit_rate(hdr);\n\tu32 samplerate = gf_mp3_sampling_rate(hdr);\n\n\tu32 frameSize = 0;\n\tif (!samplerate || !bitrate) return 0;\n\n\tif (layer==1) {\n\t\tframeSize = (( 12 * bitrate / samplerate) + pad) * 4;\n\t} else {\n\t\tu32 slots_per_frame = 144;\n\t\tif ((layer == 3) && !(version & 1)) slots_per_frame = 72;\n\t\tframeSize = (slots_per_frame * bitrate / samplerate) + pad;\n\t}\n\treturn (u16) frameSize;\n}\n\n\nGF_EXPORT\nu32 gf_mp3_get_next_header(FILE* in)\n{\n\tu8 b, state = 0;\n\tu32 dropped = 0;\n\tunsigned char bytes[4];\n\tbytes[0] = bytes[1] = bytes[2] = bytes[3] = 0;\n\n\twhile (1) {\n\t\tif (fread(&b, 1, 1, in) == 0) return 0;\n\n\t\tif (state==3) {\n\t\t\tbytes[state] = b;\n\t\t\treturn GF_4CC(bytes[0], bytes[1], bytes[2], bytes[3]);\n\t\t}\n\t\tif (state==2) {\n\t\t\tif (((b & 0xF0) == 0) || ((b & 0xF0) == 0xF0) || ((b & 0x0C) == 0x0C)) {\n\t\t\t\tif (bytes[1] == 0xFF) state = 1;\n\t\t\t\telse state = 0;\n\t\t\t} else {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 3;\n\t\t\t}\n\t\t}\n\t\tif (state==1) {\n\t\t\tif (((b & 0xE0) == 0xE0) && ((b & 0x18) != 0x08) && ((b & 0x06) != 0)) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 2;\n\t\t\t} else {\n\t\t\t\tstate = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (state==0) {\n\t\t\tif (b == 0xFF) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 1;\n\t\t\t} else {\n\t\t\t\tif ((dropped == 0) && ((b & 0xE0) == 0xE0) && ((b & 0x18) != 0x08) && ((b & 0x06) != 0)) {\n\t\t\t\t\tbytes[0] = (u8) 0xFF;\n\t\t\t\t\tbytes[1] = b;\n\t\t\t\t\tstate = 2;\n\t\t\t\t} else {\n\t\t\t\t\tdropped++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nu32 gf_mp3_get_next_header_mem(const char *buffer, u32 size, u32 *pos)\n{\n\tu32 cur;\n\tu8 b, state = 0;\n\tu32 dropped = 0;\n\tunsigned char bytes[4];\n\tbytes[0] = bytes[1] = bytes[2] = bytes[3] = 0;\n\n\tcur = 0;\n\t*pos = 0;\n\twhile (cur<size) {\n\t\tb = (u8) buffer[cur];\n\t\tcur++;\n\n\t\tif (state==3) {\n\t\t\tu32 val;\n\t\t\tbytes[state] = b;\n\t\t\tval = GF_4CC(bytes[0], bytes[1], bytes[2], bytes[3]);\n\t\t\tif (gf_mp3_frame_size(val)) {\n\t\t\t\t*pos = dropped;\n\t\t\t\treturn val;\n\t\t\t}\n\t\t\tstate = 0;\n\t\t\tdropped = cur;\n\t\t}\n\t\tif (state==2) {\n\t\t\tif (((b & 0xF0) == 0) || ((b & 0xF0) == 0xF0) || ((b & 0x0C) == 0x0C)) {\n\t\t\t\tif (bytes[1] == 0xFF) {\n\t\t\t\t\tstate = 1;\n\t\t\t\t\tdropped+=1;\n\t\t\t\t} else {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tdropped = cur;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 3;\n\t\t\t}\n\t\t}\n\t\tif (state==1) {\n\t\t\tif (((b & 0xE0) == 0xE0) && ((b & 0x18) != 0x08) && ((b & 0x06) != 0)) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 2;\n\t\t\t} else {\n\t\t\t\tstate = 0;\n\t\t\t\tdropped = cur;\n\t\t\t}\n\t\t}\n\n\t\tif (state==0) {\n\t\t\tif (b == 0xFF) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 1;\n\t\t\t} else {\n\t\t\t\tdropped++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\n\nGF_EXPORT\nBool gf_avc_is_rext_profile(u8 profile_idc)\n{\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\tcase 138:\n\tcase 139:\n\tcase 134:\n\tcase 135:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nconst char *gf_avc_get_profile_name(u8 video_prof)\n{\n\tswitch (video_prof) {\n\tcase 0x42:\n\t\treturn \"Baseline\";\n\tcase 0x4D:\n\t\treturn \"Main\";\n\tcase 0x53:\n\t\treturn \"Scalable Baseline\";\n\tcase 0x56:\n\t\treturn \"Scalable High\";\n\tcase 0x58:\n\t\treturn \"Extended\";\n\tcase 0x64:\n\t\treturn \"High\";\n\tcase 0x6E:\n\t\treturn \"High 10\";\n\tcase 0x7A:\n\t\treturn \"High 4:2:2\";\n\tcase 0x90:\n\tcase 0xF4:\n\t\treturn \"High 4:4:4\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nGF_EXPORT\nconst char *gf_hevc_get_profile_name(u8 video_prof)\n{\n\tswitch (video_prof) {\n\tcase 0x01:\n\t\treturn \"Main\";\n\tcase 0x02:\n\t\treturn \"Main 10\";\n\tcase 0x03:\n\t\treturn \"Main Still Picture\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\nGF_EXPORT\nconst char *gf_avc_hevc_get_chroma_format_name(u8 chroma_format)\n{\n\tswitch (chroma_format) {\n\tcase 1:\n\t\treturn \"YUV 4:2:0\";\n\tcase 2:\n\t\treturn \"YUV 4:2:2\";\n\tcase 3:\n\t\treturn \"YUV 4:4:4\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n\nstatic u8 avc_golomb_bits[256] = {\n\t8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2,\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0\n};\n\nstatic u32 bs_get_ue(GF_BitStream *bs)\n{\n\tu8 coded;\n\tu32 bits = 0, read = 0;\n\twhile (1) {\n\t\tread = gf_bs_peek_bits(bs, 8, 0);\n\t\tif (read) break;\n\t\t//check whether we still have bits once the peek is done since we may have less than 8 bits available\n\t\tif (!gf_bs_available(bs)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AVC/HEVC] Not enough bits in bitstream !!\\n\"));\n\t\t\treturn 0;\n\t\t}\n\t\tgf_bs_read_int(bs, 8);\n\t\tbits += 8;\n\t}\n\tcoded = avc_golomb_bits[read];\n\tgf_bs_read_int(bs, coded);\n\tbits += coded;\n\treturn gf_bs_read_int(bs, bits + 1) - 1;\n}\n\nstatic s32 bs_get_se(GF_BitStream *bs)\n{\n\tu32 v = bs_get_ue(bs);\n\tif ((v & 0x1) == 0) return (s32) (0 - (v>>1));\n\treturn (v + 1) >> 1;\n}\n\nu32 gf_media_nalu_is_start_code(GF_BitStream *bs)\n{\n\tu8 s1, s2, s3, s4;\n\tBool is_sc = 0;\n\tu64 pos = gf_bs_get_position(bs);\n\ts1 = gf_bs_read_int(bs, 8);\n\ts2 = gf_bs_read_int(bs, 8);\n\tif (!s1 && !s2) {\n\t\ts3 = gf_bs_read_int(bs, 8);\n\t\tif (s3==0x01) is_sc = 3;\n\t\telse if (!s3) {\n\t\t\ts4 = gf_bs_read_int(bs, 8);\n\t\t\tif (s4==0x01) is_sc = 4;\n\t\t}\n\t}\n\tgf_bs_seek(bs, pos+is_sc);\n\treturn is_sc;\n}\n\n/*read that amount of data at each IO access rather than fetching byte by byte...*/\n#define AVC_CACHE_SIZE\t4096\n\nstatic u32 gf_media_nalu_locate_start_code_bs(GF_BitStream *bs, Bool locate_trailing)\n{\n\tu32 v, bpos, nb_cons_zeros=0;\n\tchar avc_cache[AVC_CACHE_SIZE];\n\tu64 end, cache_start, load_size;\n\tu64 start = gf_bs_get_position(bs);\n\tif (start<3) return 0;\n\n\tload_size = 0;\n\tbpos = 0;\n\tcache_start = 0;\n\tend = 0;\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\t/*refill cache*/\n\t\tif (bpos == (u32) load_size) {\n\t\t\tif (!gf_bs_available(bs)) break;\n\t\t\tload_size = gf_bs_available(bs);\n\t\t\tif (load_size>AVC_CACHE_SIZE) load_size=AVC_CACHE_SIZE;\n\t\t\tbpos = 0;\n\t\t\tcache_start = gf_bs_get_position(bs);\n\t\t\tgf_bs_read_data(bs, avc_cache, (u32) load_size);\n\t\t}\n\t\tv = ( (v<<8) & 0xFFFFFF00) | ((u32) avc_cache[bpos]);\n\n\t\tbpos++;\n\t\tif (locate_trailing) {\n\t\t\tif ( (v & 0x000000FF) == 0) nb_cons_zeros++;\n\t\t\telse nb_cons_zeros = 0;\n\t\t}\n\n\t\tif (v == 0x00000001) end = cache_start+bpos-4;\n\t\telse if ( (v & 0x00FFFFFF) == 0x00000001) end = cache_start+bpos-3;\n\t}\n\tgf_bs_seek(bs, start);\n\tif (!end) end = gf_bs_get_size(bs);\n\tif (locate_trailing) {\n\t\tif (nb_cons_zeros>=3)\n\t\t\treturn (u32) (end - start - nb_cons_zeros);\n\t}\n\treturn (u32) (end-start);\n}\n\nGF_EXPORT\nu32 gf_media_nalu_next_start_code_bs(GF_BitStream *bs)\n{\n\treturn gf_media_nalu_locate_start_code_bs(bs, 0);\n}\n\nGF_EXPORT\nu32 gf_media_nalu_payload_end_bs(GF_BitStream *bs)\n{\n\treturn gf_media_nalu_locate_start_code_bs(bs, 1);\n}\n\nGF_EXPORT\nu32 gf_media_nalu_next_start_code(const u8 *data, u32 data_len, u32 *sc_size)\n{\n\tu32 v, bpos;\n\tu32 end;\n\n\tbpos = 0;\n\tend = 0;\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\t/*refill cache*/\n\t\tif (bpos == (u32) data_len)\n\t\t\tbreak;\n\n\t\tv = ( (v<<8) & 0xFFFFFF00) | ((u32) data[bpos]);\n\t\tbpos++;\n\t\tif (v == 0x00000001) {\n\t\t\tend = bpos-4;\n\t\t\t*sc_size = 4;\n\t\t\treturn end;\n\t\t}\n\t\telse if ( (v & 0x00FFFFFF) == 0x00000001) {\n\t\t\tend = bpos-3;\n\t\t\t*sc_size = 3;\n\t\t\treturn end;\n\t\t}\n\t}\n\tif (!end) end = data_len;\n\treturn (u32) (end);\n}\n\nBool gf_media_avc_slice_is_intra(AVCState *avc)\n{\n\tswitch (avc->s_info.slice_type) {\n\tcase GF_AVC_TYPE_I:\n\tcase GF_AVC_TYPE2_I:\n\tcase GF_AVC_TYPE_SI:\n\tcase GF_AVC_TYPE2_SI:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nBool gf_media_avc_slice_is_IDR(AVCState *avc)\n{\n\tif (avc->sei.recovery_point.valid)\n\t{\n\t\tavc->sei.recovery_point.valid = 0;\n\t\treturn 1;\n\t}\n\tif (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE)\n\t\treturn 0;\n\treturn gf_media_avc_slice_is_intra(avc);\n}\n\nstatic const struct {\n\tu32 w, h;\n} avc_sar[14] =\n{\n\t{ 0,   0 }, { 1,   1 }, { 12, 11 }, { 10, 11 },\n\t{ 16, 11 }, { 40, 33 }, { 24, 11 }, { 20, 11 },\n\t{ 32, 11 }, { 80, 33 }, { 18, 11 }, { 15, 11 },\n\t{ 64, 33 }, { 160,99 },\n};\n\n\n/*ISO 14496-10 (N11084) E.1.2*/\nstatic void avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)\n{\n\tint i, cpb_cnt_minus1;\n\n\tcpb_cnt_minus1 = bs_get_ue(bs);\t\t/*cpb_cnt_minus1*/\n\tif (cpb_cnt_minus1 > 31)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] invalid cpb_cnt_minus1 value: %d (expected in [0;31])\\n\", cpb_cnt_minus1));\n\tgf_bs_read_int(bs, 4);\t\t\t\t/*bit_rate_scale*/\n\tgf_bs_read_int(bs, 4);\t\t\t\t/*cpb_size_scale*/\n\n\t/*for( SchedSelIdx = 0; SchedSelIdx <= cpb_cnt_minus1; SchedSelIdx++ ) {*/\n\tfor (i=0; i<=cpb_cnt_minus1; i++) {\n\t\tbs_get_ue(bs);\t\t\t\t\t/*bit_rate_value_minus1[ SchedSelIdx ]*/\n\t\tbs_get_ue(bs);\t\t\t\t\t/*cpb_size_value_minus1[ SchedSelIdx ]*/\n\t\tgf_bs_read_int(bs, 1);\t\t\t/*cbr_flag[ SchedSelIdx ]*/\n\t}\n\tgf_bs_read_int(bs, 5);\t\t\t\t\t\t\t\t\t\t\t/*initial_cpb_removal_delay_length_minus1*/\n\thrd->cpb_removal_delay_length_minus1 = gf_bs_read_int(bs, 5);\t/*cpb_removal_delay_length_minus1*/\n\thrd->dpb_output_delay_length_minus1  = gf_bs_read_int(bs, 5);\t/*dpb_output_delay_length_minus1*/\n\thrd->time_offset_length = gf_bs_read_int(bs, 5);\t\t\t\t/*time_offset_length*/\n\n\treturn;\n}\n\n/*returns the nal_size without emulation prevention bytes*/\nstatic u32 avc_emulation_bytes_add_count(char *buffer, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size) {\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\tother than the following sequences shall not occur at any byte-aligned position:\n\t\t\\96 0x00000300\n\t\t\\96 0x00000301\n\t\t\\96 0x00000302\n\t\t\\96 0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2 && buffer[i] < 0x04) {\n\t\t\t/*emulation code found*/\n\t\t\tnum_zero = 0;\n\t\t\temulation_bytes_count++;\n\t\t\tif (!buffer[i])\n\t\t\t\tnum_zero = 1;\n\t\t} else {\n\t\t\tif (!buffer[i])\n\t\t\t\tnum_zero++;\n\t\t\telse\n\t\t\t\tnum_zero = 0;\n\t\t}\n\t\ti++;\n\t}\n\treturn emulation_bytes_count;\n}\n\nstatic u32 avc_add_emulation_bytes(const char *buffer_src, char *buffer_dst, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size) {\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\tother than the following sequences shall not occur at any byte-aligned position:\n\t\t0x00000300\n\t\t0x00000301\n\t\t0x00000302\n\t\t0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2 && (u8)buffer_src[i] < 0x04) {\n\t\t\t/*add emulation code*/\n\t\t\tnum_zero = 0;\n\t\t\tbuffer_dst[i+emulation_bytes_count] = 0x03;\n\t\t\temulation_bytes_count++;\n\t\t\tif (!buffer_src[i])\n\t\t\t\tnum_zero = 1;\n\t\t} else {\n\t\t\tif (!buffer_src[i])\n\t\t\t\tnum_zero++;\n\t\t\telse\n\t\t\t\tnum_zero = 0;\n\t\t}\n\t\tbuffer_dst[i+emulation_bytes_count] = buffer_src[i];\n\t\ti++;\n\t}\n\treturn nal_size+emulation_bytes_count;\n}\n\n/*returns the nal_size without emulation prevention bytes*/\nstatic u32 avc_emulation_bytes_remove_count(const char *buffer, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size)\n\t{\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\t  other than the following sequences shall not occur at any byte-aligned position:\n\t\t  \\96 0x00000300\n\t\t  \\96 0x00000301\n\t\t  \\96 0x00000302\n\t\t  \\96 0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2\n\t\t        && buffer[i] == 0x03\n\t\t        && i+1 < nal_size /*next byte is readable*/\n\t\t        && buffer[i+1] < 0x04)\n\t\t{\n\t\t\t/*emulation code found*/\n\t\t\tnum_zero = 0;\n\t\t\temulation_bytes_count++;\n\t\t\ti++;\n\t\t}\n\n\t\tif (!buffer[i])\n\t\t\tnum_zero++;\n\t\telse\n\t\t\tnum_zero = 0;\n\n\t\ti++;\n\t}\n\n\treturn emulation_bytes_count;\n}\n\n/*nal_size is updated to allow better error detection*/\nstatic u32 avc_remove_emulation_bytes(const char *buffer_src, char *buffer_dst, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size)\n\t{\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\t  other than the following sequences shall not occur at any byte-aligned position:\n\t\t  0x00000300\n\t\t  0x00000301\n\t\t  0x00000302\n\t\t  0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2\n\t\t        && buffer_src[i] == 0x03\n\t\t        && i+1 < nal_size /*next byte is readable*/\n\t\t        && buffer_src[i+1] < 0x04)\n\t\t{\n\t\t\t/*emulation code found*/\n\t\t\tnum_zero = 0;\n\t\t\temulation_bytes_count++;\n\t\t\ti++;\n\t\t}\n\n\t\tbuffer_dst[i-emulation_bytes_count] = buffer_src[i];\n\n\t\tif (!buffer_src[i])\n\t\t\tnum_zero++;\n\t\telse\n\t\t\tnum_zero = 0;\n\n\t\ti++;\n\t}\n\n\treturn nal_size-emulation_bytes_count;\n}\n\nGF_EXPORT\ns32 gf_media_avc_read_sps(const char *sps_data, u32 sps_size, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos)\n{\n\tAVC_SPS *sps;\n\tu32 ChromaArrayType = 0;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl=0, cr=0, ct=0, cb=0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\tGF_BitStream *bs;\n\tchar *sps_data_without_emulation_bytes = NULL;\n\tu32 sps_data_without_emulation_bytes_size = 0;\n\n\t/*SPS still contains emulation bytes*/\n\tsps_data_without_emulation_bytes = gf_malloc(sps_size*sizeof(char));\n\tsps_data_without_emulation_bytes_size = avc_remove_emulation_bytes(sps_data, sps_data_without_emulation_bytes, sps_size);\n\tbs = gf_bs_new(sps_data_without_emulation_bytes, sps_data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t/*nal hdr*/ gf_bs_read_int(bs, 8);\n\n\tprofile_idc = gf_bs_read_int(bs, 8);\n\n\tpcomp = gf_bs_read_int(bs, 8);\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\tgoto exit;\n\n\tlevel_idc = gf_bs_read_int(bs, 8);\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = bs_get_ue(bs) + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif (sps_id >=32) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\tif (sps_id < 0) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tchroma_format_idc = ChromaArrayType = 1;\n\tsps = &avc->sps[sps_id];\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\tgoto exit;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = bs_get_ue(bs);\n\t\tChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int(bs, 1);\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = bs_get_ue(bs);\n\t\tchroma_bd = bs_get_ue(bs);\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int(bs, 1);\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\tu32 k;\n\t\t\tfor (k=0; k<8; k++) {\n\t\t\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k<6 ? 16 : 64;\n\t\t\t\t\tfor (z=0; z<sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = bs_get_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = bs_get_ue(bs) + 4;\n\tsps->poc_type = bs_get_ue(bs);\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = bs_get_ue(bs) + 4;\n\t} else if(sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int(bs, 1);\n\t\tsps->offset_for_non_ref_pic = bs_get_se(bs);\n\t\tsps->offset_for_top_to_bottom_field = bs_get_se(bs);\n\t\tsps->poc_cycle_length = bs_get_ue(bs);\n\t\tfor(i=0; i<sps->poc_cycle_length; i++) sps->offset_for_ref_frame[i] = bs_get_se(bs);\n\t}\n\tif (sps->poc_type > 2) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\tsps->max_num_ref_frames = bs_get_ue(bs); \n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int(bs, 1); \n\tmb_width = bs_get_ue(bs) + 1;\n\tmb_height= bs_get_ue(bs) + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int(bs, 1);\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2-sps->frame_mbs_only_flag) * mb_height * 16;\n\t\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 1); /*direct_8x8_inference_flag*/\n\t\n\tif (gf_bs_read_int(bs, 1)) { /*crop*/\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2, SubHeightC = 2;\n\t\t} else if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2, SubHeightC = 1;\n\t\t} else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1, SubHeightC = 1;\n\t\t}\n\n\t\tif (ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC==-1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2-sps->frame_mbs_only_flag;\n\t\t} else {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2-sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = bs_get_ue(bs); /*crop_left*/\n\t\tcr = bs_get_ue(bs); /*crop_right*/\n\t\tct = bs_get_ue(bs); /*crop_top*/\n\t\tcb = bs_get_ue(bs); /*crop_bottom*/\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t} \n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32) gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int(bs, 1);\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int(bs, 8);\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int(bs, 16); /*AR num*/\n\t\t\t\tsps->vui.par_den = gf_bs_read_int(bs, 16); /*AR den*/\n\t\t\t} else if (aspect_ratio_idc<14) {\n\t\t\t\tsps->vui.par_num = avc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif(sps->vui.overscan_info_present_flag)\t\t\n\t\t\tgf_bs_read_int(bs, 1);\t\t/* overscan_appropriate_flag */\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int(bs, 3);\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int(bs, 1);\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (sps->vui.colour_description_present_flag) { \n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int(bs, 8);  \n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int(bs, 8);  \n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int(bs, 8);  \n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int(bs, 1)) {\t/* chroma_location_info_present_flag */\n\t\t\tbs_get_ue(bs);\t\t\t\t/* chroma_sample_location_type_top_field */\n\t\t\tbs_get_ue(bs);\t\t\t\t/* chroma_sample_location_type_bottom_field */\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int(bs, 32);\n\t\t\tsps->vui.time_scale = gf_bs_read_int(bs, 32);\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int(bs, 1);\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int(bs, 1); \n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int(bs, 1);\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc==83) || (profile_idc==86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\t/*inter_layer_deblocking_filter_control_present_flag=*/\tgf_bs_read_int(bs, 1);\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int(bs, 2);\n\t\t\tif (ChromaArrayType == 1 || ChromaArrayType == 2) {\n\t\t\t\t/*chroma_phase_x_plus1_flag*/ gf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t\tif( ChromaArrayType  ==  1 ) {\n\t\t\t\t/*chroma_phase_y_plus1*/ gf_bs_read_int(bs, 2);\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif( ChromaArrayType > 0 ) {\n\t\t\t\t\t/*seq_ref_layer_chroma_phase_x_plus1_flag*/gf_bs_read_int(bs, 1);\n\t\t\t\t\t/*seq_ref_layer_chroma_phase_y_plus1*/gf_bs_read_int(bs, 2);\n\t\t\t\t}\n\t\t\t\t/*seq_scaled_ref_layer_left_offset*/ bs_get_se(bs);\n\t\t\t\t/*seq_scaled_ref_layer_top_offset*/bs_get_se(bs);\n\t\t\t\t/*seq_scaled_ref_layer_right_offset*/bs_get_se(bs);\n\t\t\t\t/*seq_scaled_ref_layer_bottom_offset*/bs_get_se(bs);\n\t\t\t}\n\t\t\tif (/*seq_tcoeff_level_prediction_flag*/gf_bs_read_int(bs, 1)) {\n\t\t\t\t/*adaptive_tcoeff_level_prediction_flag*/ gf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t\t/*slice_header_restriction_flag*/gf_bs_read_int(bs, 1);\n\n\t\t\t/*svc_vui_parameters_present*/\n\t\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t\tu32 i, vui_ext_num_entries_minus1;\n\t\t\t\tvui_ext_num_entries_minus1 = bs_get_ue(bs);\n\n\t\t\t\tfor (i=0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\t/*u8 vui_ext_dependency_id =*/ gf_bs_read_int(bs, 3);\n\t\t\t\t\t/*u8 vui_ext_quality_id =*/ gf_bs_read_int(bs, 4);\n\t\t\t\t\t/*u8 vui_ext_temporal_id =*/ gf_bs_read_int(bs, 3);\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int(bs, 1);\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\t/*u32 vui_ext_num_units_in_tick = */gf_bs_read_int(bs, 32);\n\t\t\t\t\t\t/*u32 vui_ext_time_scale = */gf_bs_read_int(bs, 32);\n\t\t\t\t\t\t/*u8 vui_ext_fixed_frame_rate_flag = */gf_bs_read_int(bs, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif ( vui_ext_nal_hrd_parameters_present_flag ||  vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t/*vui_ext_low_delay_hrd_flag*/gf_bs_read_int(bs, 1);\n\t\t\t\t\t}\n\t\t\t\t\t/*vui_ext_pic_struct_present_flag*/gf_bs_read_int(bs, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc==118) || (profile_idc==128)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] MVC not supported - skipping parsing end of Subset SPS\\n\"));\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\tgf_bs_del(bs);\n\tgf_free(sps_data_without_emulation_bytes);\n\treturn sps_id;\n}\n\nGF_EXPORT\ns32 gf_media_avc_read_pps(const char *pps_data, u32 pps_size, AVCState *avc)\n{\n\tGF_BitStream *bs;\n\tchar *pps_data_without_emulation_bytes = NULL;\n\tu32 pps_data_without_emulation_bytes_size = 0;\n\ts32 pps_id;\n\tAVC_PPS *pps;\n\n\t/*PPS still contains emulation bytes*/\n\tpps_data_without_emulation_bytes = gf_malloc(pps_size*sizeof(char));\n\tpps_data_without_emulation_bytes_size = avc_remove_emulation_bytes(pps_data, pps_data_without_emulation_bytes, pps_size);\n\tbs = gf_bs_new(pps_data_without_emulation_bytes, pps_data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\tpps_id = -1;\n\t\tgoto exit;\n\t}\n\t/*nal hdr*/gf_bs_read_u8(bs);\n\n\n\tpps_id = bs_get_ue(bs);\n\tif (pps_id>=255) {\n\t\tpps_id = -1;\n\t\tgoto exit;\n\t}\n\tpps = &avc->pps[pps_id];\n\tpps->id = pps_id;\n\n\tif (!pps->status) pps->status = 1;\n\tpps->sps_id = bs_get_ue(bs);\n\tif (pps->sps_id >= 32) {\n\t\tpps->sps_id = 0;\n\t\tpps_id = -1;\n\t\tgoto exit;\n\t}\n\t/*sps_id may be refer to regular SPS or subseq sps, depending on the coded slice refering to the pps*/\n\tif (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) {\n\t\tpps_id = -1;\n\t\tgoto exit;\n\t}\n\tavc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->entropy_coding_mode_flag = gf_bs_read_int(bs, 1);\n\tpps->pic_order_present= gf_bs_read_int(bs, 1);\n\tpps->slice_group_count= bs_get_ue(bs) + 1;\n\tif (pps->slice_group_count > 1 ) /*pps->mb_slice_group_map_type = */bs_get_ue(bs);\n\t/*pps->ref_count[0]= */bs_get_ue(bs) /*+ 1*/;\n\t/*pps->ref_count[1]= */bs_get_ue(bs) /*+ 1*/;\n\t/*\n\tif ((pps->ref_count[0] > 32) || (pps->ref_count[1] > 32)) goto exit;\n\t*/\n\n\t/*pps->weighted_pred = */gf_bs_read_int(bs, 1);\n\t/*pps->weighted_bipred_idc = */gf_bs_read_int(bs, 2);\n\t/*pps->init_qp = */bs_get_se(bs) /*+ 26*/;\n\t/*pps->init_qs= */bs_get_se(bs) /*+ 26*/;\n\t/*pps->chroma_qp_index_offset = */bs_get_se(bs);\n\t/*pps->deblocking_filter_parameters_present = */gf_bs_read_int(bs, 1);\n\t/*pps->constrained_intra_pred = */gf_bs_read_int(bs, 1);\n\tpps->redundant_pic_cnt_present = gf_bs_read_int(bs, 1);\n\nexit:\n\tgf_bs_del(bs);\n\tgf_free(pps_data_without_emulation_bytes);\n\treturn pps_id;\n}\n\ns32 gf_media_avc_read_sps_ext(const char *spse_data, u32 spse_size)\n{\n\tGF_BitStream *bs;\n\tchar *spse_data_without_emulation_bytes = NULL;\n\tu32 spse_data_without_emulation_bytes_size = 0;\n\ts32 sps_id;\n\n\t/*PPS still contains emulation bytes*/\n\tspse_data_without_emulation_bytes = gf_malloc(spse_size*sizeof(char));\n\tspse_data_without_emulation_bytes_size = avc_remove_emulation_bytes(spse_data, spse_data_without_emulation_bytes, spse_size);\n\tbs = gf_bs_new(spse_data_without_emulation_bytes, spse_data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\n\t/*nal header*/gf_bs_read_u8(bs);\n\n\tsps_id = bs_get_ue(bs);\n\n\tgf_bs_del(bs);\n\tgf_free(spse_data_without_emulation_bytes);\n\treturn sps_id;\n}\n\nstatic s32 SVC_ReadNal_header_extension(GF_BitStream *bs, SVC_NALUHeader *NalHeader)\n{\n\tgf_bs_read_int(bs, 1); //reserved_one_bits\n\tNalHeader->idr_pic_flag = gf_bs_read_int(bs, 1); //idr_flag\n\tNalHeader->priority_id = gf_bs_read_int(bs, 6); //priority_id\n\tgf_bs_read_int(bs, 1); //no_inter_layer_pred_flag\n\tNalHeader->dependency_id = gf_bs_read_int(bs, 3); //DependencyId\n\tNalHeader->quality_id = gf_bs_read_int(bs, 4); //quality_id\n\tNalHeader->temporal_id = gf_bs_read_int(bs, 3); //temporal_id\n\tgf_bs_read_int(bs, 1); //use_ref_base_pic_flag\n\tgf_bs_read_int(bs, 1); //discardable_flag\n\tgf_bs_read_int(bs, 1); //output_flag\n\tgf_bs_read_int(bs, 2); //reserved_three_2bits\n\treturn 1;\n}\n\nstatic s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\t/*first_mb_in_slice = */bs_get_ue(bs);\n\tsi->slice_type = bs_get_ue(bs);\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = bs_get_ue(bs);\n\tif (pps_id>255) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;\n\t\n\tsi->frame_num = gf_bs_read_int(bs, si->sps->log2_max_frame_num);\n\n\tsi->field_pic_flag = 0;\n\tsi->bottom_field_flag = 0;\n\tif (!si->sps->frame_mbs_only_flag) {\n\t\tsi->field_pic_flag = gf_bs_read_int(bs, 1);\n\t\tif (si->field_pic_flag)\n\t\t\tsi->bottom_field_flag = gf_bs_read_int(bs, 1);\n\t}\n\tif ((si->nal_unit_type==GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)\n\t\tsi->idr_pic_id = bs_get_ue(bs);\n\n\tif (si->sps->poc_type==0) {\n\t\tsi->poc_lsb = gf_bs_read_int(bs, si->sps->log2_max_poc_lsb);\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = bs_get_se(bs);\n\t\t}\n\t} else if ((si->sps->poc_type==1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = bs_get_se(bs);\n\t\tif ((si->pps->pic_order_present==1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = bs_get_se(bs);\n\t}\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = bs_get_ue(bs);\n\t}\n\treturn 0;\n}\n\n\nstatic s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\t/*first_mb_in_slice = */bs_get_ue(bs);\n\tsi->slice_type = bs_get_ue(bs);\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = bs_get_ue(bs);\n\tif (pps_id>255)\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;\n\tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n\tif (!si->sps->log2_max_frame_num)\n\t\treturn -2;\n\n\tsi->frame_num = gf_bs_read_int(bs, si->sps->log2_max_frame_num);\n\n\tsi->field_pic_flag = 0;\n\tif (si->sps->frame_mbs_only_flag) {\n\t\t/*s->picture_structure= PICT_FRAME;*/\n\t} else {\n\t\tsi->field_pic_flag = gf_bs_read_int(bs, 1);\n\t\tif (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int(bs, 1);\n\t}\n\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si ->NalHeader.idr_pic_flag)\n\t\tsi->idr_pic_id = bs_get_ue(bs);\n\n\tif (si->sps->poc_type==0) {\n\t\tsi->poc_lsb = gf_bs_read_int(bs, si->sps->log2_max_poc_lsb);\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = bs_get_se(bs);\n\t\t}\n\t} else if ((si->sps->poc_type==1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = bs_get_se(bs);\n\t\tif ((si->pps->pic_order_present==1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = bs_get_se(bs);\n\t}\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = bs_get_ue(bs);\n\t}\n\treturn 0;\n}\n\n\nstatic s32 avc_parse_recovery_point_sei(GF_BitStream *bs, AVCState *avc)\n{\n\tAVCSeiRecoveryPoint *rp = &avc->sei.recovery_point;\n\n\trp->frame_cnt = bs_get_ue(bs);\n\trp->exact_match_flag = gf_bs_read_int(bs, 1);\n\trp->broken_link_flag = gf_bs_read_int(bs, 1);\n\trp->changing_slice_group_idc = gf_bs_read_int(bs, 2);\n\trp->valid = 1;\n\n\treturn 0;\n}\n\n/*for interpretation see ISO 14496-10 N.11084, table D-1*/\nstatic s32 avc_parse_pic_timing_sei(GF_BitStream *bs, AVCState *avc)\n{\n\tint i;\n\tint sps_id = avc->sps_active_idx;\n\tconst char NumClockTS[] = {1, 1, 1, 2, 2, 3, 3, 2, 3};\n\tAVCSeiPicTiming *pt = &avc->sei.pic_timing;\n\n\tif (sps_id < 0) {\n\t\t/*sps_active_idx equals -1 when no sps has been detected. In this case SEI should not be decoded.*/\n\t\tassert(0);\n\t\treturn 1;\n\t}\n\tif (avc->sps[sps_id].vui.nal_hrd_parameters_present_flag || avc->sps[sps_id].vui.vcl_hrd_parameters_present_flag) { /*CpbDpbDelaysPresentFlag, see 14496-10(2003) E.11*/\n\t\tgf_bs_read_int(bs, 1+avc->sps[sps_id].vui.hrd.cpb_removal_delay_length_minus1); /*cpb_removal_delay*/\n\t\tgf_bs_read_int(bs, 1+avc->sps[sps_id].vui.hrd.dpb_output_delay_length_minus1);  /*dpb_output_delay*/\n\t}\n\n\t/*ISO 14496-10 (2003), D.8.2: we need to get pic_struct in order to know if we display top field first or bottom field first*/\n\tif (avc->sps[sps_id].vui.pic_struct_present_flag) {\n\t\tpt->pic_struct = gf_bs_read_int(bs, 4);\n\t\tif (pt->pic_struct > 8) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] invalid pic_struct value %d\\n\", pt->pic_struct));\n\t\t\treturn 1;\n\t\t}\n\n\t\tfor (i=0; i<NumClockTS[pt->pic_struct]; i++) {\n\t\t\tif (gf_bs_read_int(bs, 1)) {/*clock_timestamp_flag[i]*/\n\t\t\t\tBool full_timestamp_flag;\n\t\t\t\tgf_bs_read_int(bs, 2);\t\t\t\t\t\t/*ct_type*/\n\t\t\t\tgf_bs_read_int(bs, 1);\t\t\t\t\t\t/*nuit_field_based_flag*/\n\t\t\t\tgf_bs_read_int(bs, 5);\t\t\t\t\t\t/*counting_type*/\n\t\t\t\tfull_timestamp_flag = gf_bs_read_int(bs, 1);/*full_timestamp_flag*/\n\t\t\t\tgf_bs_read_int(bs, 1);\t\t\t\t\t\t/*discontinuity_flag*/\n\t\t\t\tgf_bs_read_int(bs, 1);\t\t\t\t\t\t/*cnt_dropped_flag*/\n\t\t\t\tgf_bs_read_int(bs, 8);\t\t\t\t\t\t/*n_frames*/\n\t\t\t\tif (full_timestamp_flag) {\n\t\t\t\t\tgf_bs_read_int(bs, 6);\t\t\t\t\t/*seconds_value*/\n\t\t\t\t\tgf_bs_read_int(bs, 6);\t\t\t\t\t/*minutes_value*/\n\t\t\t\t\tgf_bs_read_int(bs, 5);\t\t\t\t\t/*hours_value*/\n\t\t\t\t} else {\n\t\t\t\t\tif (gf_bs_read_int(bs, 1)) {\t\t\t/*seconds_flag*/\n\t\t\t\t\t\tgf_bs_read_int(bs, 6);\t\t\t\t/*seconds_value*/\n\t\t\t\t\t\tif (gf_bs_read_int(bs, 1)) {\t\t/*minutes_flag*/\n\t\t\t\t\t\t\tgf_bs_read_int(bs, 6);\t\t\t/*minutes_value*/\n\t\t\t\t\t\t\tif (gf_bs_read_int(bs, 1)) {\t/*hours_flag*/\n\t\t\t\t\t\t\t\tgf_bs_read_int(bs, 5);\t\t/*hours_value*/\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (avc->sps[sps_id].vui.hrd.time_offset_length > 0)\n\t\t\t\t\t\tgf_bs_read_int(bs, avc->sps[sps_id].vui.hrd.time_offset_length);\t/*time_offset*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic void avc_compute_poc(AVCSliceInfo *si)\n{\n\tenum {\n\t\tAVC_PIC_FRAME,\n\t\tAVC_PIC_FIELD_TOP,\n\t\tAVC_PIC_FIELD_BOTTOM,\n\t} pic_type;\n\ts32 field_poc[2] = {0,0};\n\ts32 max_frame_num = 1 << (si->sps->log2_max_frame_num);\n\n\t/* picture type */\n\tif (si->sps->frame_mbs_only_flag || !si->field_pic_flag) pic_type = AVC_PIC_FRAME;\n\telse if (si->bottom_field_flag) pic_type = AVC_PIC_FIELD_BOTTOM;\n\telse pic_type = AVC_PIC_FIELD_TOP;\n\n\t/* frame_num_offset */\n\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\tsi->poc_lsb_prev = 0;\n\t\tsi->poc_msb_prev = 0;\n\t\tsi->frame_num_offset = 0;\n\t} else {\n\t\tif (si->frame_num < si->frame_num_prev)\n\t\t\tsi->frame_num_offset = si->frame_num_offset_prev + max_frame_num;\n\t\telse\n\t\t\tsi->frame_num_offset = si->frame_num_offset_prev;\n\t}\n\n\t/*ISO 14496-10 N.11084 8.2.1.1*/\n\tif (si->sps->poc_type==0)\n\t{\n\t\tconst u32 max_poc_lsb = 1 << (si->sps->log2_max_poc_lsb);\n\n\t\t/*ISO 14496-10 N.11084 eq (8-3)*/\n\t\tif ((si->poc_lsb < si->poc_lsb_prev) &&\n\t\t        (si->poc_lsb_prev - si->poc_lsb >= max_poc_lsb / 2) )\n\t\t\tsi->poc_msb = si->poc_msb_prev + max_poc_lsb;\n\t\telse if ((si->poc_lsb > si->poc_lsb_prev) &&\n\t\t         (si->poc_lsb - si->poc_lsb_prev > max_poc_lsb / 2))\n\t\t\tsi->poc_msb = si->poc_msb_prev - max_poc_lsb;\n\t\telse\n\t\t\tsi->poc_msb = si->poc_msb_prev;\n\n\t\t/*ISO 14496-10 N.11084 eq (8-4)*/\n\t\tif (pic_type != AVC_PIC_FIELD_BOTTOM)\n\t\t\tfield_poc[0] = si->poc_msb + si->poc_lsb;\n\n\t\t/*ISO 14496-10 N.11084 eq (8-5)*/\n\t\tif (pic_type != AVC_PIC_FIELD_TOP) {\n\t\t\tif (!si->field_pic_flag)\n\t\t\t\tfield_poc[1] = field_poc[0] + si->delta_poc_bottom;\n\t\t\telse\n\t\t\t\tfield_poc[1] = si->poc_msb + si->poc_lsb;\n\t\t}\n\t}\n\t/*ISO 14496-10 N.11084 8.2.1.2*/\n\telse if (si->sps->poc_type==1)\n\t{\n\t\tu32 i;\n\t\ts32 abs_frame_num, expected_delta_per_poc_cycle, expected_poc;\n\n\t\tif (si->sps->poc_cycle_length)\n\t\t\tabs_frame_num = si->frame_num_offset + si->frame_num;\n\t\telse\n\t\t\tabs_frame_num = 0;\n\n\t\tif (!si->nal_ref_idc && (abs_frame_num > 0)) abs_frame_num--;\n\n\t\texpected_delta_per_poc_cycle = 0;\n\t\tfor (i=0; i < si->sps->poc_cycle_length; i++)\n\t\t\texpected_delta_per_poc_cycle += si->sps->offset_for_ref_frame[i];\n\n\t\tif (abs_frame_num > 0) {\n\t\t\tconst u32 poc_cycle_cnt = ( abs_frame_num - 1 ) / si->sps->poc_cycle_length;\n\t\t\tconst u32 frame_num_in_poc_cycle = ( abs_frame_num - 1 ) % si->sps->poc_cycle_length;\n\n\t\t\texpected_poc = poc_cycle_cnt * expected_delta_per_poc_cycle;\n\t\t\tfor (i = 0; i<=frame_num_in_poc_cycle; i++)\n\t\t\t\texpected_poc += si->sps->offset_for_ref_frame[i];\n\t\t} else {\n\t\t\texpected_poc = 0;\n\t\t}\n\n\t\tif (!si->nal_ref_idc) expected_poc += si->sps->offset_for_non_ref_pic;\n\n\t\tfield_poc[0] = expected_poc + si->delta_poc[0];\n\t\tfield_poc[1] = field_poc[0] + si->sps->offset_for_top_to_bottom_field;\n\t\tif (pic_type == AVC_PIC_FRAME) field_poc[1] += si->delta_poc[1];\n\t}\n\t/*ISO 14496-10 N.11084 8.2.1.3*/\n\telse if (si->sps->poc_type== 2)\n\t{\n\t\tint poc;\n\t\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\t\tpoc = 0;\n\t\t} else {\n\t\t\tconst int abs_frame_num = si->frame_num_offset + si->frame_num;\n\t\t\tpoc = 2 * abs_frame_num;\n\t\t\tif (!si->nal_ref_idc) poc -= 1;\n\t\t}\n\t\tfield_poc[0] = poc;\n\t\tfield_poc[1] = poc;\n\t}\n\n\t/*ISO 14496-10 N.11084 eq (8-1)*/\n\tif (pic_type == AVC_PIC_FRAME)\n\t\tsi->poc = MIN(field_poc[0], field_poc[1] );\n\telse if (pic_type == AVC_PIC_FIELD_TOP)\n\t\tsi->poc = field_poc[0];\n\telse\n\t\tsi->poc = field_poc[1];\n}\n\nGF_EXPORT\ns32 gf_media_avc_parse_nalu(GF_BitStream *bs, u32 nal_hdr, AVCState *avc)\n{\n\tu8 idr_flag;\n\ts32 slice, ret;\n\tAVCSliceInfo n_state;\n\n\tslice = 0;\n\tmemcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));\n\tn_state.nal_unit_type = nal_hdr & 0x1F;\n\tn_state.nal_ref_idc = (nal_hdr>>5) & 0x3;\n\n\tidr_flag = 0;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_AVC_NALU_ACCESS_UNIT:\n\tcase GF_AVC_NALU_END_OF_SEQ:\n\tcase GF_AVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\tcase GF_AVC_NALU_SVC_SLICE:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\tslice = 1;\n\t\t// slice buffer - read the info and compare.\n\t\t/*ret = */svc_parse_slice(bs, avc, &n_state);\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t\tif (slice)\n\t\t\tavc_compute_poc(&n_state);\n\n\t\tif (avc->s_info.poc != n_state.poc) {\n\t\t\tmemcpy(&avc -> s_info, &n_state, sizeof(AVCSliceInfo));\n\t\t\treturn 1;\n\t\t}\n\t\tmemcpy(&avc -> s_info, &n_state, sizeof(AVCSliceInfo));\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SVC_PREFIX_NALU:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_NON_IDR_SLICE:\n\tcase GF_AVC_NALU_DP_A_SLICE:\n\tcase GF_AVC_NALU_DP_B_SLICE:\n\tcase GF_AVC_NALU_DP_C_SLICE:\n\tcase GF_AVC_NALU_IDR_SLICE:\n\t\tslice = 1;\n\t\t/* slice buffer - read the info and compare.*/\n\t\tret = avc_parse_slice(bs, avc, idr_flag, &n_state);\n\t\tif (ret<0) return ret;\n\t\tret = 0;\n\t\tif (\n\t\t    ((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))\n\t\t    && (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)\n\t\t) {\n\t\t\tbreak;\n\t\t}\n\t\tif (avc->s_info.frame_num != n_state.frame_num) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (avc->s_info.field_pic_flag != n_state.field_pic_flag) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&\n\t\t        (!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tassert(avc->s_info.sps);\n\n\t\tif (avc->s_info.sps->poc_type == n_state.sps->poc_type) {\n\t\t\tif (!avc->s_info.sps->poc_type) {\n\t\t\t\tif (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (avc->s_info.sps->poc_type==1) {\n\t\t\t\tif (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {\n\t\t\t\t\tret =1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE)  {\n\t\t\tif (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) { /*IdrPicFlag differs in value*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (avc->s_info.idr_pic_id != n_state.idr_pic_id) { /*both IDR and idr_pic_id differs*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_AVC_NALU_SEQ_PARAM:\n\tcase GF_AVC_NALU_PIC_PARAM:\n\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\tcase GF_AVC_NALU_FILLER_DATA:\n\t\treturn 0;\n\tdefault:\n\t\tif (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;\n\t\t//To detect change of AU when multiple sps and pps in stream\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc -> s_info .nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc -> s_info .nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif (ret && avc->s_info.sps) {\n\t\tn_state.frame_num_offset_prev = avc->s_info.frame_num_offset;\n\t\tif ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))\n\t\t\tn_state.frame_num_prev = avc->s_info.frame_num;\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t}\n\tif (slice) avc_compute_poc(&n_state);\n\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\treturn ret;\n}\n\nu32 gf_media_avc_reformat_sei(char *buffer, u32 nal_size, AVCState *avc)\n{\n\tu32 ptype, psize, hdr, written, var;\n\tu64 start;\n\tchar *new_buffer;\n\tGF_BitStream *bs;\n\tchar *sei_without_emulation_bytes = NULL;\n\tu32 sei_without_emulation_bytes_size = 0;\n\n\thdr = buffer[0];\n\tif ((hdr & 0x1F) != GF_AVC_NALU_SEI) return 0;\n\n\t/*PPS still contains emulation bytes*/\n\tsei_without_emulation_bytes = gf_malloc(nal_size + 1/*for SEI null string termination*/);\n\tsei_without_emulation_bytes_size = avc_remove_emulation_bytes(buffer, sei_without_emulation_bytes, nal_size);\n\n\tbs = gf_bs_new(sei_without_emulation_bytes, sei_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\tgf_bs_read_int(bs, 8);\n\n\tnew_buffer = (char*)gf_malloc(sizeof(char)*nal_size);\n\tnew_buffer[0] = (char) hdr;\n\twritten = 1;\n\t/*parse SEI*/\n\twhile (gf_bs_available(bs)) {\n\t\tBool do_copy;\n\t\tptype = 0;\n\t\twhile (gf_bs_peek_bits(bs, 8, 0)==0xFF) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tptype += 255;\n\t\t}\n\t\tptype += gf_bs_read_int(bs, 8);\n\t\tpsize = 0;\n\t\twhile (gf_bs_peek_bits(bs, 8, 0)==0xFF) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tpsize += 255;\n\t\t}\n\t\tpsize += gf_bs_read_int(bs, 8);\n\n\t\tstart = gf_bs_get_position(bs);\n\n\t\tdo_copy = 1;\n\n\t\tif (start+psize >= nal_size) {\n\t\t\tif (written == 1) written = 0;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] SEI user message type %d size error (%d but %d remain), skiping %sSEI message\\n\", ptype, psize, nal_size-start, written ? \"end of \" : \"\"));\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ptype) {\n\t\t/*remove SEI messages forbidden in MP4*/\n\t\tcase 3: /*filler data*/\n\t\tcase 10: /*sub_seq info*/\n\t\tcase 11: /*sub_seq_layer char*/\n\t\tcase 12: /*sub_seq char*/\n\t\t\tdo_copy = 0;\n\t\t\tbreak;\n\t\tcase 5: /*user unregistered */\n\t\t{\n\t\t\tchar prev;\n\t\t\tprev = sei_without_emulation_bytes[start+psize+1];\n\t\t\tsei_without_emulation_bytes[start+psize+1] = 0;\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[avc-h264] SEI user message %s\\n\", sei_without_emulation_bytes+start+16));\n\t\t\tsei_without_emulation_bytes[start+psize+1] = prev;\n\t\t}\n\t\tbreak;\n\n\t\tcase 6: /*recovery point*/\n\t\t{\n\t\t\tGF_BitStream *rp_bs = gf_bs_new(sei_without_emulation_bytes + start, psize, GF_BITSTREAM_READ);\n\t\t\tavc_parse_recovery_point_sei(rp_bs, avc);\n\t\t\tgf_bs_del(rp_bs);\n\t\t}\n\t\tbreak;\n\n\t\tcase 1: /*pic_timing*/\n\t\t{\n\t\t\tGF_BitStream *pt_bs = gf_bs_new(sei_without_emulation_bytes + start, psize, GF_BITSTREAM_READ);\n\t\t\tavc_parse_pic_timing_sei(pt_bs, avc);\n\t\t\tgf_bs_del(pt_bs);\n\t\t}\n\t\tbreak;\n\n\t\tcase 0: /*buffering period*/\n\t\tcase 2: /*pan scan rect*/\n\t\tcase 4: /*user registered ITU t35*/\n\t\tcase 7: /*def_rec_pic_marking_repetition*/\n\t\tcase 8: /*spare_pic*/\n\t\tcase 9: /*scene info*/\n\t\tcase 13: /*full frame freeze*/\n\t\tcase 14: /*full frame freeze release*/\n\t\tcase 15: /*full frame snapshot*/\n\t\tcase 16: /*progressive refinement segment start*/\n\t\tcase 17: /*progressive refinement segment end*/\n\t\tcase 18: /*motion constrained slice group*/\n\t\t\tbreak;\n\t\tdefault: /*reserved*/\n\t\t\tdo_copy = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_copy) {\n\t\t\tvar = ptype;\n\t\t\twhile (var>=255) {\n\t\t\t\tnew_buffer[written] = (char) 0xff;\n\t\t\t\twritten++;\n\t\t\t\tvar-=255;\n\t\t\t}\n\t\t\tnew_buffer[written] = (char) var;\n\t\t\twritten++;\n\t\t\tvar = psize;\n\t\t\twhile (var>=255) {\n\t\t\t\tnew_buffer[written] = (char) 0xff;\n\t\t\t\twritten++;\n\t\t\t\tvar-=255;\n\t\t\t}\n\t\t\tnew_buffer[written] = (char) var;\n\t\t\twritten++;\n\t\t\tmemcpy(new_buffer+written, sei_without_emulation_bytes+start, sizeof(char) * psize);\n\t\t\twritten += psize;\n\t\t}\n\n\t\tgf_bs_skip_bytes(bs, (u64) psize);\n\t\tgf_bs_align(bs);\n\t\tif (gf_bs_available(bs)<=2) {\n\t\t\tif (gf_bs_peek_bits(bs, 8, 0)==0x80) {\n\t\t\t\tnew_buffer[written] = (char) 0x80;\n\t\t\t\twritten += 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\tgf_free(sei_without_emulation_bytes);\n\n\tif (written) {\n\t\tvar = avc_emulation_bytes_add_count(new_buffer, written);\n\t\tif (var) {\n\t\t\tif (written+var<=nal_size) {\n\t\t\t\twritten = avc_add_emulation_bytes(new_buffer, buffer, written);\n\t\t\t} else {\n\t\t\t\twritten = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (written<=nal_size) {\n\t\t\t\tmemcpy(buffer, new_buffer, sizeof(char)*written);\n\t\t\t} else {\n\t\t\t\twritten = 0;\n\t\t\t}\n\t\t}\n\t}\n\tgf_free(new_buffer);\n\n\t/*if only hdr written ignore*/\n\treturn (written>1) ? written : 0;\n}\n\n#ifndef GPAC_DISABLE_ISOM\n\nstatic u8 avc_get_sar_idx(u32 w, u32 h)\n{\n\tu32 i;\n\tfor (i=0; i<14; i++) {\n\t\tif ((avc_sar[i].w==w) && (avc_sar[i].h==h)) return i;\n\t}\n\treturn 0xFF;\n}\n\nGF_Err gf_media_avc_change_par(GF_AVCConfig *avcc, s32 ar_n, s32 ar_d)\n{\n\tGF_BitStream *orig, *mod;\n\tAVCState avc;\n\tu32 i, bit_offset, flag;\n\ts32 idx;\n\tGF_AVCConfigSlot *slc;\n\torig = NULL;\n\n\tmemset(&avc, 0, sizeof(AVCState));\n\tavc.sps_active_idx = -1;\n\n\ti=0;\n\twhile ((slc = (GF_AVCConfigSlot *)gf_list_enum(avcc->sequenceParameterSets, &i))) {\n\t\tchar *no_emulation_buf = NULL;\n\t\tu32 no_emulation_buf_size = 0, emulation_bytes = 0;\n\t\tidx = gf_media_avc_read_sps(slc->data, slc->size, &avc, 0, &bit_offset);\n\t\tif (idx<0) {\n\t\t\tif ( orig )\n\t\t\t\tgf_bs_del(orig);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*SPS still contains emulation bytes*/\n\t\tno_emulation_buf = gf_malloc((slc->size-1)*sizeof(char));\n\t\tno_emulation_buf_size = avc_remove_emulation_bytes(slc->data+1, no_emulation_buf, slc->size-1);\n\n\t\torig = gf_bs_new(no_emulation_buf, no_emulation_buf_size, GF_BITSTREAM_READ);\n\t\tgf_bs_read_data(orig, no_emulation_buf, no_emulation_buf_size);\n\t\tgf_bs_seek(orig, 0);\n\t\tmod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t/*copy over till vui flag*/\n\t\tassert(bit_offset>=8);\n\t\twhile (bit_offset-8/*bit_offset doesn't take care of the first byte (NALU type)*/) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t\tbit_offset--;\n\t\t}\n\t\t/*check VUI*/\n\t\tflag = gf_bs_read_int(orig, 1);\n\t\tgf_bs_write_int(mod, 1, 1); /*vui_parameters_present_flag*/\n\t\tif (flag) {\n\t\t\t/*aspect_ratio_info_present_flag*/\n\t\t\tif (gf_bs_read_int(orig, 1)) {\n\t\t\t\ts32 aspect_ratio_idc = gf_bs_read_int(orig, 8);\n\t\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\t\tgf_bs_read_int(orig, 16); /*AR num*/\n\t\t\t\t\tgf_bs_read_int(orig, 16); /*AR den*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((ar_d<0) || (ar_n<0)) {\n\t\t\t/*no AR signaled*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\n\t\t} else {\n\t\t\tu32 sarx;\n\t\t\tgf_bs_write_int(mod, 1, 1);\n\t\t\tsarx = avc_get_sar_idx((u32) ar_n, (u32) ar_d);\n\t\t\tgf_bs_write_int(mod, sarx, 8);\n\t\t\tif (sarx==0xFF) {\n\t\t\t\tgf_bs_write_int(mod, ar_n, 16);\n\t\t\t\tgf_bs_write_int(mod, ar_d, 16);\n\t\t\t}\n\t\t}\n\t\t/*no VUI in input bitstream, set all vui flags to 0*/\n\t\tif (!flag) {\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*overscan_info_present_flag */\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*video_signal_type_present_flag */\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*chroma_location_info_present_flag */\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*timing_info_present_flag*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*nal_hrd_parameters_present*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*vcl_hrd_parameters_present*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*pic_struct_present*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*bitstream_restriction*/\n\t\t}\n\n\t\t/*finally copy over remaining*/\n\t\twhile (gf_bs_bits_available(orig)) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t}\n\t\tgf_bs_del(orig);\n\t\torig = NULL;\n\t\tgf_free(no_emulation_buf);\n\n\t\t/*set anti-emulation*/\n\t\tgf_bs_get_content(mod, (char **) &no_emulation_buf, &flag);\n\t\temulation_bytes = avc_emulation_bytes_add_count(no_emulation_buf, flag);\n\t\tif (flag+emulation_bytes+1>slc->size)\n\t\t\tslc->data = (char*)gf_realloc(slc->data, flag+emulation_bytes+1);\n\t\tslc->size = avc_add_emulation_bytes(no_emulation_buf, slc->data+1, flag)+1;\n\n\t\tgf_bs_del(mod);\n\t\tgf_free(no_emulation_buf);\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_avc_get_sps_info(char *sps_data, u32 sps_size, u32 *sps_id, u32 *width, u32 *height, s32 *par_n, s32 *par_d)\n{\n\tAVCState avc;\n\ts32 idx;\n\tmemset(&avc, 0, sizeof(AVCState));\n\tavc.sps_active_idx = -1;\n\n\tidx = gf_media_avc_read_sps(sps_data, sps_size, &avc, 0, NULL);\n\tif (idx<0) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tif (sps_id) *sps_id = idx;\n\n\tif (width) *width = avc.sps[idx].width;\n\tif (height) *height = avc.sps[idx].height;\n\tif (par_n) *par_n = avc.sps[idx].vui.par_num ? avc.sps[idx].vui.par_num : (u32) -1;\n\tif (par_d) *par_d = avc.sps[idx].vui.par_den ? avc.sps[idx].vui.par_den : (u32) -1;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_avc_get_pps_info(char *pps_data, u32 pps_size, u32 *pps_id, u32 *sps_id)\n{\n\tGF_BitStream *bs;\n\tchar *pps_data_without_emulation_bytes = NULL;\n\tu32 pps_data_without_emulation_bytes_size = 0;\n\tGF_Err e = GF_OK;\n\n\t/*PPS still contains emulation bytes*/\n\tpps_data_without_emulation_bytes = gf_malloc(pps_size*sizeof(char));\n\tpps_data_without_emulation_bytes_size = avc_remove_emulation_bytes(pps_data, pps_data_without_emulation_bytes, pps_size);\n\tbs = gf_bs_new(pps_data_without_emulation_bytes, pps_data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tgoto exit;\n\t}\n\t/*nal hdr*/ gf_bs_read_int(bs, 8);\n\n\t*pps_id = bs_get_ue(bs);\n\t*sps_id = bs_get_ue(bs);\n\nexit:\n\tgf_bs_del(bs);\n\tgf_free(pps_data_without_emulation_bytes);\n\treturn e;\n}\n\n\n\n#ifndef GPAC_DISABLE_HEVC\n\n/**********\nHEVC parsing\n**********/\n\nBool gf_media_hevc_slice_is_intra(HEVCState *hevc)\n{\n\tswitch (hevc->s_info.nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nBool gf_media_hevc_slice_is_IDR(HEVCState *hevc)\n{\n\tif (hevc->sei.recovery_point.valid)\n\t{\n\t\thevc->sei.recovery_point.valid = 0;\n\t\treturn GF_TRUE;\n\t}\n\tswitch (hevc->s_info.nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nstatic Bool parse_short_term_ref_pic_set(GF_BitStream *bs, HEVC_SPS *sps, u32 idx_rps)\n{\n\tu32 i;\n\tBool inter_ref_pic_set_prediction_flag = 0;\n\tif (idx_rps != 0)\n\t\tinter_ref_pic_set_prediction_flag = gf_bs_read_int(bs, 1);\n\n\tif (inter_ref_pic_set_prediction_flag ) {\n\t\tHEVC_ReferencePictureSets *ref_ps, *rps;\n\t\tu32 delta_idx_minus1 = 0;\n\t\tu32 ref_idx;\n\t\tu32 delta_rps_sign;\n\t\tu32 abs_delta_rps_minus1, nb_ref_pics;\n\t\ts32 deltaRPS;\n\t\tu32 k = 0, k0 = 0, k1 = 0;\n\t\tif (idx_rps == sps->num_short_term_ref_pic_sets)\n\t\t\tdelta_idx_minus1 = bs_get_ue(bs);\n\n\t\tassert(delta_idx_minus1 <= idx_rps - 1);\n\t\tref_idx = idx_rps - 1 - delta_idx_minus1;\n\t\tdelta_rps_sign = gf_bs_read_int(bs, 1);\n\t\tabs_delta_rps_minus1 = bs_get_ue(bs);\n\t\tdeltaRPS = (1 - (delta_rps_sign<<1)) * (abs_delta_rps_minus1 + 1);\n\n\t\trps = &sps->rps[idx_rps];\n\t\tref_ps = &sps->rps[ref_idx];\n\t\tnb_ref_pics = ref_ps->num_negative_pics + ref_ps->num_positive_pics;\n\t\tfor (i=0; i<=nb_ref_pics; i++) {\n\t\t\ts32 ref_idc;\n\t\t\ts32 used_by_curr_pic_flag = gf_bs_read_int(bs, 1);\n\t\t\tref_idc = used_by_curr_pic_flag ? 1 : 0;\n\t\t\tif ( !used_by_curr_pic_flag ) {\n\t\t\t\tused_by_curr_pic_flag = gf_bs_read_int(bs, 1);\n\t\t\t\tref_idc = used_by_curr_pic_flag << 1;\n\t\t\t}\n\t\t\tif ((ref_idc==1) || (ref_idc== 2)) {\n\t\t\t\ts32 deltaPOC = deltaRPS;\n\t\t\t\tif (i < nb_ref_pics)\n\t\t\t\t\tdeltaPOC += ref_ps->delta_poc[i];\n\n\t\t\t\trps->delta_poc[k] = deltaPOC;\n\n\t\t\t\tif (deltaPOC < 0)  k0++;\n\t\t\t\telse k1++;\n\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\trps->num_negative_pics = k0;\n\t\trps->num_positive_pics = k1;\n\t} else {\n\t\ts32 prev = 0, poc = 0;\n\t\tsps->rps[idx_rps].num_negative_pics = bs_get_ue(bs);\n\t\tsps->rps[idx_rps].num_positive_pics = bs_get_ue(bs);\n\t\tif (sps->rps[idx_rps].num_negative_pics>16)\n\t\t\treturn GF_FALSE;\n\t\tif (sps->rps[idx_rps].num_positive_pics>16)\n\t\t\treturn GF_FALSE;\n\t\tfor (i=0; i<sps->rps[idx_rps].num_negative_pics; i++) {\n\t\t\tu32 delta_poc_s0_minus1 = bs_get_ue(bs);\n\t\t\tpoc = prev - delta_poc_s0_minus1 - 1;\n\t\t\tprev = poc;\n\t\t\tsps->rps[idx_rps].delta_poc[i] = poc;\n\t\t\t/*used_by_curr_pic_s1_flag[ i ] = */gf_bs_read_int(bs, 1);\n\t\t}\n\t\tfor (i=0; i<sps->rps[idx_rps].num_positive_pics; i++) {\n\t\t\tu32 delta_poc_s1_minus1 = bs_get_ue(bs);\n\t\t\tpoc = prev + delta_poc_s1_minus1 + 1;\n\t\t\tprev = poc;\n\t\t\tsps->rps[idx_rps].delta_poc[i] = poc;\n\t\t\t/*used_by_curr_pic_s1_flag[ i ] = */gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nvoid hevc_pred_weight_table(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si, HEVC_PPS *pps, HEVC_SPS *sps, u32 num_ref_idx_l0_active, u32 num_ref_idx_l1_active)\n{\n\tu32 i, num_ref_idx;\n\tBool first_pass=GF_TRUE;\n\tu8 luma_weights[20], chroma_weights[20];\n\tu32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;\n\n\tnum_ref_idx = num_ref_idx_l0_active;\n\n\t/*luma_log2_weight_denom=*/i=bs_get_ue(bs);\n\tif (ChromaArrayType != 0)\n\t\t/*delta_chroma_log2_weight_denom=*/i=bs_get_se(bs);\n\nparse_weights:\n\tfor (i=0; i<num_ref_idx; i++) {\n\t\tluma_weights[i] = gf_bs_read_int(bs, 1);\n\t\t//infered to be 0 if not present\n\t\tchroma_weights[i] = 0;\n\t}\n\tif (ChromaArrayType != 0) {\n\t\tfor (i=0; i<num_ref_idx; i++) {\n\t\t\tchroma_weights[i] = gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\tfor (i=0; i<num_ref_idx; i++) {\n\t\tif (luma_weights[i]) {\n\t\t\t/*delta_luma_weight_l0[ i ]=*/bs_get_se(bs);\n\t\t\t/*luma_offset_l0[ i ]=*/bs_get_se(bs);\n\t\t}\n\t\tif (chroma_weights[i]) {\n\t\t\t/*delta_chroma_weight_l0[ i ][ 0 ]=*/bs_get_se(bs);\n\t\t\t/*delta_chroma_offset_l0[ i ][ 0 ]=*/bs_get_se(bs);\n\n\t\t\t/*delta_chroma_weight_l0[ i ][ 1 ]=*/bs_get_se(bs);\n\t\t\t/*delta_chroma_offset_l0[ i ][ 1 ]=*/bs_get_se(bs);\n\t\t}\n\t}\n\n\tif (si->slice_type==GF_HEVC_SLICE_TYPE_B) {\n\t\tif (!first_pass) return;\n\t\tfirst_pass=GF_FALSE;\n\t\tnum_ref_idx = num_ref_idx_l1_active;\n\t\tgoto parse_weights;\n\t}\n}\n\nstatic\nBool ref_pic_lists_modification(GF_BitStream *bs, u32 slice_type, u32 num_ref_idx_l0_active, u32 num_ref_idx_l1_active)\n{\n\t//u32 i;\n\tBool ref_pic_list_modification_flag_l0 = gf_bs_read_int(bs, 1);\n\tif (ref_pic_list_modification_flag_l0) {\n\t\t/*for (i=0; i<num_ref_idx_l0_active; i++) {\n\t\t\tlist_entry_l0[i] = *//*gf_bs_read_int(bs, (u32)ceil(log(getNumPicTotalCurr())/log(2)));\n\t\t}*/\n\t\treturn GF_FALSE;\n\t}\n\tif (slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\tBool ref_pic_list_modification_flag_l1 = gf_bs_read_int(bs, 1);\n\t\tif (ref_pic_list_modification_flag_l1) {\n\t\t\t/*for (i=0; i<num_ref_idx_l1_active; i++) {\n\t\t\t\tlist_entry_l1[i] = *//*gf_bs_read_int(bs, (u32)ceil(log(getNumPicTotalCurr()) / log(2)));\n\t\t\t}*/\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\n\treturn GF_TRUE;\n}\n\nstatic\ns32 hevc_parse_slice_segment(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si)\n{\n\tu32 i, j;\n\tu32 num_ref_idx_l0_active=0, num_ref_idx_l1_active=0;\n\tHEVC_PPS *pps;\n\tHEVC_SPS *sps;\n\ts32 pps_id;\n\tBool RapPicFlag = GF_FALSE;\n\tBool IDRPicFlag = GF_FALSE;\n\n\tsi->first_slice_segment_in_pic_flag = gf_bs_read_int(bs, 1);\n\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\tIDRPicFlag = GF_TRUE;\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\t}\n\n\tif (RapPicFlag) {\n\t\t/*Bool no_output_of_prior_pics_flag = */gf_bs_read_int(bs, 1);\n\t}\n\n\tpps_id = bs_get_ue(bs);\n\tif (pps_id>=64)\n\t\treturn -1;\n\n\tpps = &hevc->pps[pps_id];\n\tsps = &hevc->sps[pps->sps_id];\n\tsi->sps = sps;\n\tsi->pps = pps;\n\n\tif (!si->first_slice_segment_in_pic_flag && pps->dependent_slice_segments_enabled_flag) {\n\t\tsi->dependent_slice_segment_flag = gf_bs_read_int(bs, 1);\n\t} else {\n\t\tsi->dependent_slice_segment_flag = GF_FALSE;\n\t}\n\n\tif (!si->first_slice_segment_in_pic_flag) {\n\t\tsi->slice_segment_address = gf_bs_read_int(bs, sps->bitsSliceSegmentAddress);\n\t} else {\n\t\tsi->slice_segment_address = 0;\n\t}\n\n\tif( !si->dependent_slice_segment_flag ) {\n\t\tBool deblocking_filter_override_flag=0;\n\t\tBool slice_temporal_mvp_enabled_flag = 0;\n\t\tBool slice_sao_luma_flag=0;\n\t\tBool slice_sao_chroma_flag=0;\n\t\tBool slice_deblocking_filter_disabled_flag=0;\n\n\t\t//\"slice_reserved_undetermined_flag[]\"\n\t\tgf_bs_read_int(bs, pps->num_extra_slice_header_bits);\n\n\t\tsi->slice_type = bs_get_ue(bs);\n\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_P)\n\t\t\tsi->slice_type = GF_HEVC_SLICE_TYPE_P;\n\n\t\tif(pps->output_flag_present_flag)\n\t\t\t/*pic_output_flag = */gf_bs_read_int(bs, 1);\n\n\t\tif (sps->separate_colour_plane_flag == 1)\n\t\t\t/*colour_plane_id = */gf_bs_read_int(bs, 2);\n\n\t\tif (IDRPicFlag) {\n\t\t\tsi->poc_lsb = 0;\n\n\t\t\t//if not asked to parse full header, abort since we know the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\t\t\t\n\t\t} else {\n\t\t\tsi->poc_lsb = gf_bs_read_int(bs, sps->log2_max_pic_order_cnt_lsb);\n\n\t\t\t//if not asked to parse full header, abort once we have the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t\tif (/*short_term_ref_pic_set_sps_flag =*/gf_bs_read_int(bs, 1) == 0) {\n\t\t\t\tBool ret = parse_short_term_ref_pic_set(bs, sps, sps->num_short_term_ref_pic_sets );\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn -1;\n\t\t\t} else if( sps->num_short_term_ref_pic_sets > 1 ) {\n\t\t\t\tu32 numbits = 0;\n\n\t\t\t\twhile ( (u32) (1 << numbits) < sps->num_short_term_ref_pic_sets)\n\t\t\t\t\tnumbits++;\n\t\t\t\tif (numbits > 0)\n\t\t\t\t\t/*s32 short_term_ref_pic_set_idx = */gf_bs_read_int(bs, numbits);\n\t\t\t\t/*else\n\t\t\t\t\tshort_term_ref_pic_set_idx = 0;*/\n\t\t\t}\n\t\t\tif (sps->long_term_ref_pics_present_flag ) {\n\t\t\t\tu8 DeltaPocMsbCycleLt[32];\n\t\t\t\tu32 num_long_term_sps = 0;\n\t\t\t\tu32 num_long_term_pics = 0;\n\t\t\t\tif (sps->num_long_term_ref_pic_sps > 0 ) {\n\t\t\t\t\tnum_long_term_sps = bs_get_ue(bs);\n\t\t\t\t}\n\t\t\t\tnum_long_term_pics = bs_get_ue(bs);\n\n\t\t\t\tfor (i = 0; i < num_long_term_sps + num_long_term_pics; i++ ) {\n\t\t\t\t\tif( i < num_long_term_sps ) {\n\t\t\t\t\t\tif (sps->num_long_term_ref_pic_sps > 1)\n\t\t\t\t\t\t\t/*u8 lt_idx_sps = */gf_bs_read_int(bs, gf_get_bit_size(sps->num_long_term_ref_pic_sps) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*PocLsbLt[ i ] = */ gf_bs_read_int(bs, sps->log2_max_pic_order_cnt_lsb);\n\t\t\t\t\t\t/*UsedByCurrPicLt[ i ] = */ gf_bs_read_int(bs, 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (/*delta_poc_msb_present_flag[ i ] = */ gf_bs_read_int(bs, 1) ) {\n\t\t\t\t\t\tif( i == 0 || i == num_long_term_sps )\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = bs_get_ue(bs);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = bs_get_ue(bs) + DeltaPocMsbCycleLt[i-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sps->temporal_mvp_enable_flag)\n\t\t\t\tslice_temporal_mvp_enabled_flag = gf_bs_read_int(bs, 1);\n\t\t}\n\t\tif (sps->sample_adaptive_offset_enabled_flag) {\n\t\t\tu32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;\n\t\t\tslice_sao_luma_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (ChromaArrayType!=0)\n\t\t\t\tslice_sao_chroma_flag = gf_bs_read_int(bs, 1);\n\t\t}\n\n\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_P || si->slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\t\t//u32 NumPocTotalCurr;\n\t\t\tnum_ref_idx_l0_active = pps->num_ref_idx_l0_default_active;\n\t\t\tnum_ref_idx_l1_active = 0;\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tnum_ref_idx_l1_active = pps->num_ref_idx_l1_default_active;\n\n\t\t\tif ( /*num_ref_idx_active_override_flag =*/gf_bs_read_int(bs, 1) ) {\n\t\t\t\tnum_ref_idx_l0_active = 1 + bs_get_ue(bs);\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tnum_ref_idx_l1_active = 1 + bs_get_ue(bs);\n\t\t\t}\n\n\t\t\tif (pps->lists_modification_present_flag /*TODO: && NumPicTotalCurr > 1*/) {\n\t\t\t\tif (!ref_pic_lists_modification(bs, si->slice_type, num_ref_idx_l0_active, num_ref_idx_l1_active)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[hevc] ref_pic_lists_modification( ) not implemented\\n\"));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t/*mvd_l1_zero_flag=*/gf_bs_read_int(bs, 1);\n\t\t\tif (pps->cabac_init_present_flag)\n\t\t\t\t/*cabac_init_flag=*/gf_bs_read_int(bs, 1);\n\n\t\t\tif (slice_temporal_mvp_enabled_flag) {\n\t\t\t\t// When collocated_from_l0_flag is not present, it is inferred to be equal to 1.\n\t\t\t\tBool collocated_from_l0_flag = 1;\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tcollocated_from_l0_flag = gf_bs_read_int(bs, 1);\n\n\t\t\t\tif ( (collocated_from_l0_flag && (num_ref_idx_l0_active>1) )\n\t\t\t\t        || ( !collocated_from_l0_flag && (num_ref_idx_l1_active>1) )\n\t\t\t\t   ) {\n\t\t\t\t\t/*collocated_ref_idx=*/bs_get_ue(bs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( (pps->weighted_pred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_P )\n\t\t\t        || ( pps->weighted_bipred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t   ) {\n\t\t\t\thevc_pred_weight_table(bs, hevc, si, pps, sps, num_ref_idx_l0_active, num_ref_idx_l1_active);\n\t\t\t}\n\t\t\t/*five_minus_max_num_merge_cand=*/bs_get_ue(bs);\n\t\t}\n\t\t/*slice_qp_delta = */bs_get_se(bs);\n\t\tif( pps->slice_chroma_qp_offsets_present_flag ) {\n\t\t\t/*slice_cb_qp_offset=*/bs_get_se(bs);\n\t\t\t/*slice_cr_qp_offset=*/bs_get_se(bs);\n\t\t}\n\t\tif ( pps->deblocking_filter_override_enabled_flag ) {\n\t\t\tdeblocking_filter_override_flag = gf_bs_read_int(bs, 1);\n\t\t}\n\n\t\tif (deblocking_filter_override_flag) {\n\t\t\tslice_deblocking_filter_disabled_flag = gf_bs_read_int(bs, 1);\n\t\t\tif ( !slice_deblocking_filter_disabled_flag) {\n\t\t\t\t/*slice_beta_offset_div2=*/ bs_get_se(bs);\n\t\t\t\t/*slice_tc_offset_div2=*/bs_get_se(bs);\n\t\t\t}\n\t\t}\n\t\tif( pps->loop_filter_across_slices_enabled_flag\n\t\t        && ( slice_sao_luma_flag || slice_sao_chroma_flag || !slice_deblocking_filter_disabled_flag )\n\t\t  ) {\n\t\t\t/*slice_loop_filter_across_slices_enabled_flag = */gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\t//dependent slice segment\n\telse {\n\t\t//if not asked to parse full header, abort\n\t\tif (!hevc->full_slice_header_parse) return 0;\n\t}\n\n\tsi->entry_point_start_bits = ((u32)gf_bs_get_position(bs)-1)*8 + gf_bs_get_bit_position(bs);\n\n\tif (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag ) {\n\t\tu32 num_entry_point_offsets = bs_get_ue(bs);\n\t\tif ( num_entry_point_offsets > 0) {\n\t\t\tu32 offset = bs_get_ue(bs) + 1;\n\t\t\tu32 segments = offset >> 4;\n\t\t\ts32 remain = (offset & 15);\n\n\t\t\tfor (i=0; i<num_entry_point_offsets; i++) {\n\t\t\t\tu32 res = 0;\n\t\t\t\tfor (j=0; j<segments; j++) {\n\t\t\t\t\tres <<= 16;\n\t\t\t\t\tres += gf_bs_read_int(bs, 16);\n\t\t\t\t}\n\t\t\t\tif (remain) {\n\t\t\t\t\tres <<= remain;\n\t\t\t\t\tres += gf_bs_read_int(bs, remain);\n\t\t\t\t}\n\t\t\t\t// entry_point_offset = val + 1; // +1; // +1 to get the size\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pps->slice_segment_header_extension_present_flag) {\n\t\tu32 size_ext = bs_get_ue(bs);\n\t\twhile (size_ext) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tsize_ext--;\n\t\t}\n\t}\n\n\tif (gf_bs_read_int(bs, 1) == 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Error parsing slice header: byte_align not found at end of header !\\n\"));\n\t}\n\n\tgf_bs_align(bs);\n\tsi->payload_start_offset = (s32)gf_bs_get_position(bs);\n\treturn 0;\n}\n\nstatic void hevc_compute_poc(HEVCSliceInfo *si)\n{\n\tu32 max_poc_lsb = 1 << (si->sps->log2_max_pic_order_cnt_lsb);\n\n\t/*POC reset for IDR frames, NOT for CRA*/\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\tsi->poc_lsb_prev = 0;\n\t\tsi->poc_msb_prev = 0;\n\t\tbreak;\n\t}\n\n\tif ((si->poc_lsb < si->poc_lsb_prev) && (\tsi->poc_lsb_prev - si->poc_lsb >= max_poc_lsb / 2) )\n\t\tsi->poc_msb = si->poc_msb_prev + max_poc_lsb;\n\telse if ((si->poc_lsb > si->poc_lsb_prev) && (si->poc_lsb - si->poc_lsb_prev > max_poc_lsb / 2))\n\t\tsi->poc_msb = si->poc_msb_prev - max_poc_lsb;\n\telse\n\t\tsi->poc_msb = si->poc_msb_prev;\n\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\tsi->poc_msb  = 0;\n\t\tbreak;\n\t}\n\tsi->poc = si->poc_msb + si->poc_lsb;\n}\n\n\nstatic Bool hevc_parse_nal_header(GF_BitStream *bs, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tu32 val;\n\tval = gf_bs_read_int(bs, 1);\n\tif (val) return GF_FALSE;\n\n\tval = gf_bs_read_int(bs, 6);\n\tif (nal_unit_type) *nal_unit_type = val;\n\n\tval = gf_bs_read_int(bs, 6);\n\tif (layer_id) *layer_id = val;\n\n\tval = gf_bs_read_int(bs, 3);\n\tif (! val)\n\t\treturn GF_FALSE;\n\tval -= 1;\n\tif (temporal_id) *temporal_id = val;\n\treturn GF_TRUE;\n}\n\n\nvoid profile_tier_level(GF_BitStream *bs, Bool ProfilePresentFlag, u8 MaxNumSubLayersMinus1, HEVC_ProfileTierLevel *ptl)\n{\n\tu32 i;\n\tif (ProfilePresentFlag) {\n\t\tptl->profile_space = gf_bs_read_int(bs, 2);\n\t\tptl->tier_flag = gf_bs_read_int(bs, 1);\n\t\tptl->profile_idc = gf_bs_read_int(bs, 5);\n\n\t\tptl->profile_compatibility_flag = gf_bs_read_int(bs, 32);\n\n\t\tptl->general_progressive_source_flag = gf_bs_read_int(bs, 1);\n\t\tptl->general_interlaced_source_flag = gf_bs_read_int(bs, 1);\n\t\tptl->general_non_packed_constraint_flag = gf_bs_read_int(bs, 1);\n\t\tptl->general_frame_only_constraint_flag = gf_bs_read_int(bs, 1);\n\t\tptl->general_reserved_44bits = gf_bs_read_long_int(bs, 44);\n\t}\n\tptl->level_idc = gf_bs_read_int(bs, 8);\n\tfor (i=0; i<MaxNumSubLayersMinus1; i++) {\n\t\tptl->sub_ptl[i].profile_present_flag = gf_bs_read_int(bs, 1);\n\t\tptl->sub_ptl[i].level_present_flag = gf_bs_read_int(bs, 1);\n\t}\n\tif (MaxNumSubLayersMinus1>0) {\n\t\tfor (i=MaxNumSubLayersMinus1; i<8; i++) {\n\t\t\t/*reserved_zero_2bits*/gf_bs_read_int(bs, 2);\n\t\t}\n\t}\n\n\tfor (i=0; i<MaxNumSubLayersMinus1; i++) {\n\t\tif (ptl->sub_ptl[i].profile_present_flag) {\n\t\t\tptl->sub_ptl[i].profile_space = gf_bs_read_int(bs, 2);\n\t\t\tptl->sub_ptl[i].tier_flag = gf_bs_read_int(bs, 1);\n\t\t\tptl->sub_ptl[i].profile_idc = gf_bs_read_int(bs, 5);\n\t\t\tptl->sub_ptl[i].profile_compatibility_flag = gf_bs_read_int(bs, 32);\n\t\t\t/*ptl->sub_ptl[i].progressive_source_flag =*/ gf_bs_read_int(bs, 1);\n\t\t\t/*ptl->sub_ptl[i].interlaced_source_flag =*/ gf_bs_read_int(bs, 1);\n\t\t\t/*ptl->sub_ptl[i].non_packed_constraint_flag =*/ gf_bs_read_int(bs, 1);\n\t\t\t/*ptl->sub_ptl[i].frame_only_constraint_flag =*/ gf_bs_read_int(bs, 1);\n\t\t\t/*ptl->sub_ptl[i].reserved_44bits =*/ gf_bs_read_long_int(bs, 44);\n\t\t}\n\t\tif (ptl->sub_ptl[i].level_present_flag)\n\t\t\tptl->sub_ptl[i].level_idc = gf_bs_read_int(bs, 8);\n\t}\n}\n\nstatic u32 scalability_type_to_idx(HEVC_VPS *vps, u32 scalability_type)\n{\n\tu32 idx = 0, type;\n\tfor (type=0; type < scalability_type; type++) {\n\t\tidx += (vps->scalability_mask[type] ? 1 : 0 );\n\t}\n\treturn idx;\n}\n\n#define LHVC_VIEW_ORDER_INDEX  1\n#define LHVC_SCALABILITY_INDEX\t2\n\nstatic u32 lhvc_get_scalability_id(HEVC_VPS *vps, u32 layer_id_in_vps, u32 scalability_type )\n{\n\tu32 idx;\n\tif (!vps->scalability_mask[scalability_type]) return 0;\n\tidx = scalability_type_to_idx(vps, scalability_type);\n\treturn vps->dimension_id[layer_id_in_vps][idx];\n}\n\nstatic u32 lhvc_get_view_index(HEVC_VPS *vps, u32 id)\n{\n\treturn lhvc_get_scalability_id(vps, vps->layer_id_in_vps[id], LHVC_VIEW_ORDER_INDEX);\n}\n\nstatic u32 lhvc_get_num_views(HEVC_VPS *vps)\n{\n\tu32 numViews = 1, i;\n\tfor (i=0; i<vps->max_layers; i++ ) {\n\t\tu32 layer_id = vps->layer_id_in_nuh[i];\n\t\tif (i>0 && ( lhvc_get_view_index( vps, layer_id) != lhvc_get_scalability_id( vps, i-1, LHVC_VIEW_ORDER_INDEX) )) {\n\t\t\tnumViews++;\n\t\t}\n\t}\n\treturn numViews;\n}\n\nstatic void lhvc_parse_rep_format(HEVC_RepFormat *fmt, GF_BitStream *bs)\n{\n\tu8 chroma_bitdepth_present_flag;\n\tfmt->pic_width_luma_samples = gf_bs_read_int(bs, 16);\n\tfmt->pic_height_luma_samples = gf_bs_read_int(bs, 16);\n\tchroma_bitdepth_present_flag = gf_bs_read_int(bs, 1);\n\tif (chroma_bitdepth_present_flag) {\n\t\tfmt->chroma_format_idc = gf_bs_read_int(bs, 2);\n\n\t\tif (fmt->chroma_format_idc == 3)\n\t\t\tfmt->separate_colour_plane_flag = gf_bs_read_int(bs, 1);\n\t\tfmt->bit_depth_luma = 8 + gf_bs_read_int(bs, 4);\n\t\tfmt->bit_depth_chroma = 8 + gf_bs_read_int(bs, 4);\n\t}\n\tif (/*conformance_window_vps_flag*/ gf_bs_read_int(bs, 1)) {\n\t\t/*conf_win_vps_left_offset*/bs_get_ue(bs);\n\t\t/*conf_win_vps_right_offset*/bs_get_ue(bs);\n\t\t/*conf_win_vps_top_offset*/bs_get_ue(bs);\n\t\t/*conf_win_vps_bottom_offset*/bs_get_ue(bs);\n\t}\n}\n\n\nstatic Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)\n{\n\tu8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;\n\tu32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc=0;\n\tu8 dimension_id_len[16], dim_bit_offset[16];\n\tu8 /*avc_base_layer_flag, */NumLayerSets, /*default_one_target_output_layer_flag, */rep_format_idx_present_flag, ols_ids_to_ls_idx;\n\tu8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];\n\tu8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS+1];\n\tu8 ols_highest_output_layer_id[MAX_LHVC_LAYERS+1];\n\n\tu32 k,d, r, p, iNuhLId, jNuhLId;\n\tu8 num_direct_ref_layers[64], num_pred_layers[64], num_layers_in_tree_partition[MAX_LHVC_LAYERS];\n\tu8 dependency_flag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS], id_pred_layers[64][MAX_LHVC_LAYERS];\n//\tu8 num_ref_layers[64];\n//\tu8 tree_partition_layer_id[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n//\tu8 id_ref_layers[64][MAX_LHVC_LAYERS];\n//\tu8 id_direct_ref_layers[64][MAX_LHVC_LAYERS];\n\tu8 layer_id_in_list_flag[64];\n\tBool OutputLayerFlag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\n\tvps->vps_extension_found=1;\n\tif ((vps->max_layers > 1) && vps->base_layer_internal_flag)\n\t\tprofile_tier_level(bs, 0, vps->max_sub_layers-1, &vps->ext_ptl[0]);\n\n\tsplitting_flag = gf_bs_read_int(bs, 1);\n\tnum_scalability_types = 0;\n\tfor (i=0; i<16; i++) {\n\t\tvps->scalability_mask[i] = gf_bs_read_int(bs, 1);\n\t\tnum_scalability_types += vps->scalability_mask[i];\n\t}\n\tif (num_scalability_types>=16) {\n\t\tnum_scalability_types=16;\n\t}\n\tdimension_id_len[0] = 0;\n\tfor (i=0; i<(num_scalability_types - splitting_flag); i++) {\n\t\tdimension_id_len[i] = 1 + gf_bs_read_int(bs, 3);\n\t}\n\t\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < num_scalability_types; i++) {\n\t\t\tdim_bit_offset[i] = 0;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tdim_bit_offset[i] +=  dimension_id_len[j];\n\t\t}\n\t\tdimension_id_len[num_scalability_types-1] = 1 + (5 - dim_bit_offset[num_scalability_types-1]);\n\t\tdim_bit_offset[num_scalability_types] = 6;\n\t}\n\n\tvps_nuh_layer_id_present_flag = gf_bs_read_int(bs, 1);\n\tvps->layer_id_in_nuh[0] = 0;\n\tvps->layer_id_in_vps[0] = 0;\n\tfor (i=1; i<vps->max_layers; i++) {\n\t\tif (vps_nuh_layer_id_present_flag) {\n\t\t\tvps->layer_id_in_nuh[i] = gf_bs_read_int(bs, 6);\n\t\t} else {\n\t\t\tvps->layer_id_in_nuh[i] = i;\n\t\t}\n\t\tvps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;\n\n\t\tif (!splitting_flag) {\n\t\t\tfor (j=0; j<num_scalability_types; j++) {\n\t\t\t\tvps->dimension_id[i][j] = gf_bs_read_int(bs, dimension_id_len[j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (splitting_flag) {\n\t\tfor (i = 0; i<vps->max_layers; i++)\n\t\t\tfor (j=0; j<num_scalability_types; j++)\n\t\t\t\tvps->dimension_id[i][j] = ((vps->layer_id_in_nuh[i] & ((1 << dim_bit_offset[j+1]) -1)) >> dim_bit_offset[j]);\n\t} else {\n\t\tfor (j=0; j<num_scalability_types; j++)\n\t\t\tvps->dimension_id[0][j] = 0;\n\t}\n\n\tview_id_len = gf_bs_read_int(bs, 4);\n\tif (view_id_len > 0) {\n\t\tfor( i = 0; i < lhvc_get_num_views(vps); i++ ) {\n\t\t\t/*m_viewIdVal[i] = */ gf_bs_read_int(bs, view_id_len);\n\t\t}\n\t}\n\n\tfor (i=1; i<vps->max_layers; i++) {\n\t\tfor (j=0; j<i; j++) {\n\t\t\tvps->direct_dependency_flag[i][j] = gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\n\t//we do the test on MAX_LHVC_LAYERS and break in the loop to avoid a wrong GCC 4.8 warning on array bounds\n\tfor (i = 0; i < MAX_LHVC_LAYERS; i++) {\n\t\tif (i >= vps->max_layers) break;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tdependency_flag[i][j] = vps->direct_dependency_flag[i][j];\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t\tif (vps->direct_dependency_flag[i][k] && vps->direct_dependency_flag[k][j])\n\t\t\t\t\tdependency_flag[i][j] = 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\td = r = p = 0;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tjNuhLId = vps->layer_id_in_nuh[j];\n\t\t\tif (vps->direct_dependency_flag[i][j]) {\n//\t\t\t\tid_direct_ref_layers[iNuhLId][d] = jNuhLId;\n\t\t\t\td++;\n\t\t\t}\n\t\t\tif (dependency_flag[i][j]) {\n//\t\t\t\tid_ref_layers[iNuhLId][r] = jNuhLId;\n\t\t\t\tr++;\n\t\t\t}\n\t\t\t\t\n\t\t\tif (dependency_flag[j][i])\n\t\t\t\tid_pred_layers[iNuhLId][p++] = jNuhLId;\n\t\t}\n\t\tnum_direct_ref_layers[iNuhLId] = d;\n//\t\tnum_ref_layers[iNuhLId] = r;\n\t\tnum_pred_layers[iNuhLId] = p;\n\t}\n\n\tmemset(layer_id_in_list_flag, 0, 64*sizeof(u8));\n\tk = 0; //num_indepentdent_layers\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\tif (!num_direct_ref_layers[iNuhLId]) {\n\t\t\tu32 h = 1;\n\t\t\t//tree_partition_layer_id[k][0] = iNuhLId;\t\t\n\t\t\tfor (j = 0; j < num_pred_layers[iNuhLId]; j++) {\n\t\t\t\tu32 predLId = id_pred_layers[iNuhLId][j];\n\t\t\t\tif (!layer_id_in_list_flag[predLId]) {\n\t\t\t\t\t//tree_partition_layer_id[k][h++] = predLId;\n\t\t\t\t\tlayer_id_in_list_flag[predLId] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_layers_in_tree_partition[k++] = h;\n\t\t}\n\t}\n\tnum_indepentdent_layers = k;\n\t\n\tnum_add_layer_set = 0;\n\tif (num_indepentdent_layers > 1)\n\t\tnum_add_layer_set = bs_get_ue(bs);\n\n\tfor (i = 0; i < num_add_layer_set; i++)\n\t\tfor (j = 1; j < num_indepentdent_layers; j++) {\n\t\t\tnb_bits =1;\n\t\t\t while ((1 << nb_bits) < (num_layers_in_tree_partition[j] + 1))\n\t\t\t\tnb_bits++;\n\t\t\t/*highest_layer_idx_plus1[i][j]*/gf_bs_read_int(bs, nb_bits);\n\t\t}\n\n\n\tif (/*vps_sub_layers_max_minus1_present_flag*/gf_bs_read_int(bs, 1)) {\n\t\tfor (i = 0; i < vps->max_layers; i++) {\n\t\t\t/*sub_layers_vps_max_minus1[ i ]*/gf_bs_read_int(bs, 3);\n\t\t}\n\t}\n\n\tif (/*max_tid_ref_present_flag = */gf_bs_read_int(bs, 1)) {\n\t\tfor (i=0; i<(vps->max_layers-1) ; i++) {\n\t\t\tfor (j= i+1; j < vps->max_layers; j++) {\n\t\t\t\tif (vps->direct_dependency_flag[j][i])\n\t\t\t\t\t/*max_tid_il_ref_pics_plus1[ i ][ j ]*/gf_bs_read_int(bs, 3);\n\t\t\t}\n\t\t}\n\t}\n\t/*default_ref_layers_active_flag*/gf_bs_read_int(bs, 1);\n\n\tvps->num_profile_tier_level = 1+bs_get_ue(bs);\n\tif (vps->num_profile_tier_level > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of PTLs in VPS %d\\n\", vps->num_profile_tier_level));\n\t\tvps->num_profile_tier_level=1;\n\t\treturn GF_FALSE;\n\t}\n\t\n\tfor (i=vps->base_layer_internal_flag ? 2 : 1; i < vps->num_profile_tier_level; i++) {\n\t\tBool vps_profile_present_flag = gf_bs_read_int(bs, 1);\n\t\tprofile_tier_level(bs, vps_profile_present_flag, vps->max_sub_layers-1, &vps->ext_ptl[i-1] );\n\t}\n\t\n\tNumLayerSets = vps->num_layer_sets + num_add_layer_set;\n\tnum_add_olss = 0;\n\t\n\tif (NumLayerSets > 1) {\n\t\tnum_add_olss = bs_get_ue(bs);\n\t\tdefault_output_layer_idc = gf_bs_read_int(bs,2);\n\t\tdefault_output_layer_idc = default_output_layer_idc < 2 ? default_output_layer_idc : 2;\n\t}\n\tvps->num_output_layer_sets = num_add_olss + NumLayerSets;\n\n\n\tlayer_set_idx_for_ols_minus1[0] = 1;\n\tvps->output_layer_flag[0][0] = 1;\n\n\tfor (i = 0; i < vps->num_output_layer_sets; i++) {\n\t\tif ((NumLayerSets > 2) && (i >= NumLayerSets)) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (NumLayerSets - 1))\n\t\t\t\tnb_bits++;\n\t\t\tlayer_set_idx_for_ols_minus1[i] = gf_bs_read_int(bs, nb_bits);\n\t\t}\n\t\telse\n\t\t\tlayer_set_idx_for_ols_minus1[i] = 0;\n\t\tols_ids_to_ls_idx = i < NumLayerSets ? i : layer_set_idx_for_ols_minus1[i] + 1;\n\n\t\tif ((i > (vps->num_layer_sets - 1)) || (default_output_layer_idc == 2)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\t\tvps->output_layer_flag[i][j] = gf_bs_read_int(bs, 1);\n\t\t}\n\n\t\tif ((default_output_layer_idc == 0) || (default_output_layer_idc == 1)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\t\tif ((default_output_layer_idc == 0) || (vps->LayerSetLayerIdList[i][j] == vps->LayerSetLayerIdListMax[i]))\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_TRUE;\n\t\t\t\telse\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tu32 curLayerID, k;\n\t\t\t\tvps->necessary_layers_flag[i][j] = GF_TRUE;\n\t\t\t\tcurLayerID = vps->LayerSetLayerIdList[i][j];\n\t\t\t\tfor (k = 0; k < j; k++) {\n\t\t\t\t\tu32 refLayerId = vps->LayerSetLayerIdList[i][k];\n\t\t\t\t\tif (dependency_flag[vps->layer_id_in_vps[curLayerID]][vps->layer_id_in_vps[refLayerId]])\n\t\t\t\t\t\tvps->necessary_layers_flag[i][k] = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_necessary_layers[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (vps->necessary_layers_flag[i][j])\n\t\t\t\tvps->num_necessary_layers[i] += 1;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tif (vps->base_layer_internal_flag) {\n\t\t\t\tif (vps->max_layers > 1)\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 1;\n\t\t\t\telse\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tnb_bits = 1;\n\t\twhile ((u32)(1 << nb_bits) < vps->num_profile_tier_level)\n\t\t\tnb_bits++;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\tif (vps->necessary_layers_flag[i][j] && vps->num_profile_tier_level)\n\t\t\t\tvps->profile_tier_level_idx[i][j] = gf_bs_read_int(bs, nb_bits);\n\t\t\telse\n\t\t\t\tvps->profile_tier_level_idx[i][j] = 0;\n\n\n\t\tnb_output_layers_in_output_layer_set[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tnb_output_layers_in_output_layer_set[i] += OutputLayerFlag[i][j];\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tols_highest_output_layer_id[i] = vps->LayerSetLayerIdList[ols_ids_to_ls_idx][j];\n\t\t\t}\n\t\t}\n\t\tif (nb_output_layers_in_output_layer_set[i] == 1 && ols_highest_output_layer_id[i] > 0)\n\t\t\t vps->alt_output_layer_flag[i] = gf_bs_read_int(bs, 1);\n\t}\n\n\tvps->num_rep_formats = 1 + bs_get_ue(bs);\n\tif (vps->num_rep_formats > 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of rep formats in VPS %d\\n\", vps->num_rep_formats));\n\t\tvps->num_rep_formats = 0;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = 0; i < vps->num_rep_formats; i++) {\n\t\tlhvc_parse_rep_format(&vps->rep_formats[i], bs);\n\t}\n\tif (vps->num_rep_formats > 1)\n\t\trep_format_idx_present_flag = gf_bs_read_int(bs, 1);\n\telse\n\t\trep_format_idx_present_flag = 0;\n\n\tvps->rep_format_idx[0] = 0;\n\tnb_bits = 1;\n\twhile ((u32)(1 << nb_bits) < vps->num_rep_formats)\n\t\tnb_bits++;\n\tfor (i = vps->base_layer_internal_flag ? 1 : 0; i < vps->max_layers; i++) {\n\t\tif (rep_format_idx_present_flag) {\n\t\t\tvps->rep_format_idx[i] = gf_bs_read_int(bs, nb_bits);\n\t\t}\n\t\telse {\n\t\t\tvps->rep_format_idx[i] = i < vps->num_rep_formats - 1 ? i : vps->num_rep_formats - 1;\n\t\t}\n\t}\n//TODO - we don't use the rest ...\n\nreturn GF_TRUE;\n}\n\nstatic void sub_layer_hrd_parameters(GF_BitStream *bs, int subLayerId, u32 cpb_cnt, Bool sub_pic_hrd_params_present_flag) {\n\tu32 i;\n\tfor (i = 0; i <= cpb_cnt; i++) {\n\t\t/*bit_rate_value_minus1[i] = */bs_get_ue(bs);\n\t\t/*cpb_size_value_minus1[i] = */bs_get_ue(bs);\n\t\tif (sub_pic_hrd_params_present_flag) {\n\t\t\t/*cpb_size_du_value_minus1[i] = */bs_get_ue(bs);\n\t\t\t/*bit_rate_du_value_minus1[i] = */bs_get_ue(bs);\n\t\t}\n\t\t/*cbr_flag[i] = */gf_bs_read_int(bs, 1);\n\t}\n}\n\nstatic void hevc_parse_hrd_parameters(GF_BitStream *bs, Bool commonInfPresentFlag, int maxNumSubLayersMinus1)\n{\n\tint i;\n\tBool nal_hrd_parameters_present_flag = GF_FALSE;\n\tBool vcl_hrd_parameters_present_flag = GF_FALSE;\n\tBool sub_pic_hrd_params_present_flag = GF_FALSE;\n\tif (commonInfPresentFlag) {\n\t\tnal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\tvcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\n\t\t\tsub_pic_hrd_params_present_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (sub_pic_hrd_params_present_flag) {\n\t\t\t\t/*tick_divisor_minus2 = */gf_bs_read_int(bs, 8);\n\t\t\t\t/*du_cpb_removal_delay_increment_length_minus1 = */gf_bs_read_int(bs, 5);\n\t\t\t\t/*sub_pic_cpb_params_in_pic_timing_sei_flag = */gf_bs_read_int(bs, 1);\n\t\t\t\t/*dpb_output_delay_du_length_minus1 = */gf_bs_read_int(bs, 5);\n\t\t\t}\n\t\t\t/*bit_rate_scale = */gf_bs_read_int(bs, 4);\n\t\t\t/*cpb_size_scale = */gf_bs_read_int(bs, 4);\n\t\t\tif (sub_pic_hrd_params_present_flag) {\n\t\t\t\t/*cpb_size_du_scale = */gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\t/*initial_cpb_removal_delay_length_minus1 = */gf_bs_read_int(bs, 5);\n\t\t\t/*au_cpb_removal_delay_length_minus1 = */gf_bs_read_int(bs, 5);\n\t\t\t/*dpb_output_delay_length_minus1 = */gf_bs_read_int(bs, 5);\n\t\t}\n\t}\n\tfor (i = 0; i <= maxNumSubLayersMinus1; i++) {\n\t\tBool fixed_pic_rate_general_flag_i = gf_bs_read_int(bs, 1);\n\t\tBool fixed_pic_rate_within_cvs_flag_i = GF_TRUE;\n\t\tBool low_delay_hrd_flag_i = GF_FALSE;\n\t\tu32 cpb_cnt_minus1_i = 0;\n\t\tif (!fixed_pic_rate_general_flag_i) {\n\t\t\tfixed_pic_rate_within_cvs_flag_i = gf_bs_read_int(bs, 1);\n\t\t}\n\t\tif (fixed_pic_rate_within_cvs_flag_i)\n\t\t\t/*elemental_duration_in_tc_minus1[i] = */bs_get_ue(bs);\n\t\telse\n\t\t\tlow_delay_hrd_flag_i = gf_bs_read_int(bs, 1);\n\t\tif (!low_delay_hrd_flag_i) {\n\t\t\tcpb_cnt_minus1_i = bs_get_ue(bs);\n\t\t}\n\t\tif (nal_hrd_parameters_present_flag) {\n\t\t\tsub_layer_hrd_parameters(bs, i, cpb_cnt_minus1_i, sub_pic_hrd_params_present_flag);\n\t\t}\n\t\tif (vcl_hrd_parameters_present_flag) {\n\t\t\tsub_layer_hrd_parameters(bs, i, cpb_cnt_minus1_i, sub_pic_hrd_params_present_flag);\n\t\t}\n\t}\n}\n\nstatic s32 gf_media_hevc_read_vps_bs(GF_BitStream *bs, HEVCState *hevc, Bool stop_at_vps_ext)\n{\n\tu8 vps_sub_layer_ordering_info_present_flag, vps_extension_flag;\n\tu32 i, j;\n\ts32 vps_id = -1;\n\tHEVC_VPS *vps;\n\tu8 layer_id_included_flag[MAX_LHVC_LAYERS][64];\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int(bs, 4);\n\n\tif (vps_id>=16) return -1;\n\n\tvps = &hevc->vps[vps_id];\n\tvps->bit_pos_vps_extensions = -1;\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\n\tvps->base_layer_internal_flag = gf_bs_read_int(bs, 1);\n\tvps->base_layer_available_flag = gf_bs_read_int(bs, 1);\n\tvps->max_layers = 1 + gf_bs_read_int(bs, 6);\n\tif (vps->max_layers>MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int(bs, 3) + 1;\n\tvps->temporal_id_nesting = gf_bs_read_int(bs, 1);\n\t/* vps_reserved_ffff_16bits = */ gf_bs_read_int(bs, 16);\n\tprofile_tier_level(bs, 1, vps->max_sub_layers-1, &vps->ptl);\n\n\tvps_sub_layer_ordering_info_present_flag = gf_bs_read_int(bs, 1);\n\tfor (i=(vps_sub_layer_ordering_info_present_flag ? 0 : vps->max_sub_layers - 1); i < vps->max_sub_layers; i++) {\n\t\t/*vps_max_dec_pic_buffering_minus1[i] = */bs_get_ue(bs);\n\t\t/*vps_max_num_reorder_pics[i] = */bs_get_ue(bs);\n\t\t/*vps_max_latency_increase_plus1[i] = */bs_get_ue(bs);\n\t}\n\tvps->max_layer_id = gf_bs_read_int(bs, 6);\n\tif (vps->max_layer_id > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] VPS max layer ID %u but GPAC only supports %u\\n\", vps->max_layer_id,  MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->num_layer_sets = bs_get_ue(bs) + 1;\n\tif (vps->num_layer_sets > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of layer sets in VPS %d\\n\", vps->num_layer_sets));\n\t\treturn -1;\n\t}\n\tfor (i=1; i < vps->num_layer_sets; i++) {\n\t\tfor (j=0; j <= vps->max_layer_id; j++) {\n\t\t\tlayer_id_included_flag[ i ][ j ] = gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\tvps->num_layers_in_id_list[0] = 1;\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tu32 n, m;\n\t\tn = 0;\n\t\tfor (m = 0; m <= vps->max_layer_id; m++)\n\t\t\tif (layer_id_included_flag[i][m]) {\n\t\t\t\tvps->LayerSetLayerIdList[i][n++] = m;\n\t\t\t\tif (vps->LayerSetLayerIdListMax[i] < m)\n\t\t\t\t\tvps->LayerSetLayerIdListMax[i] = m;\n\t\t\t}\n\t\tvps->num_layers_in_id_list[i] = n;\n\t}\n\tif (/*vps_timing_info_present_flag*/gf_bs_read_int(bs, 1)) {\n\t\tu32 vps_num_hrd_parameters;\n\t\t/*u32 vps_num_units_in_tick = */gf_bs_read_int(bs, 32);\n\t\t/*u32 vps_time_scale = */gf_bs_read_int(bs, 32);\n\t\tif (/*vps_poc_proportional_to_timing_flag*/gf_bs_read_int(bs, 1)) {\n\t\t\t/*vps_num_ticks_poc_diff_one_minus1*/bs_get_ue(bs);\n\t\t}\n\t\tvps_num_hrd_parameters = bs_get_ue(bs);\n\t\tfor( i = 0; i < vps_num_hrd_parameters; i++ ) {\n\t\t\tBool cprms_present_flag = GF_TRUE;\n\t\t\t/*hrd_layer_set_idx[i] = */bs_get_ue(bs);\n\t\t\tif (i>0)\n\t\t\t\tcprms_present_flag = gf_bs_read_int(bs, 1) ;\n\t\t\thevc_parse_hrd_parameters(bs, cprms_present_flag, vps->max_sub_layers - 1);\n\t\t}\n\t}\n\tif (stop_at_vps_ext) {\n\t\treturn vps_id;\n\t}\n\n\tvps_extension_flag = gf_bs_read_int(bs, 1);\n\tif (vps_extension_flag ) {\n\t\tBool res;\n\t\tgf_bs_align(bs);\n\t\tres = hevc_parse_vps_extension(vps, bs);\n\t\tif (res!=GF_TRUE) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Failed to parse VPS extensions\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tif (/*vps_extension2_flag*/gf_bs_read_int(bs, 1)) {\n\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t/*vps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn vps_id;\n}\n\nGF_EXPORT\ns32 gf_media_hevc_read_vps_ex(char *data, u32 *size, HEVCState *hevc, Bool remove_extensions)\n{\n\tGF_BitStream *bs;\n\tchar *data_without_emulation_bytes = NULL;\n\tu32 data_without_emulation_bytes_size = 0;\n\ts32 vps_id = -1;\n\n\t/*still contains emulation bytes*/\n\tdata_without_emulation_bytes_size = avc_emulation_bytes_remove_count(data, (*size));\n\tif (!data_without_emulation_bytes_size) {\n\t\tbs = gf_bs_new(data, (*size), GF_BITSTREAM_READ);\n\t} else {\n\t\tdata_without_emulation_bytes = gf_malloc((*size) * sizeof(char));\n\t\tdata_without_emulation_bytes_size = avc_remove_emulation_bytes(data, data_without_emulation_bytes, (*size) );\n\t\tbs = gf_bs_new(data_without_emulation_bytes, data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\t}\n\tif (!bs) goto exit;\n\n\n\tif (! hevc_parse_nal_header(bs, NULL, NULL, NULL)) goto exit;\n\n\tvps_id = gf_media_hevc_read_vps_bs(bs, hevc, remove_extensions);\n\tif (vps_id<0) goto exit;\n\n\tif (remove_extensions) {\n\t\tchar *new_vps;\n\t\tu32 new_vps_size, emulation_bytes;\n\t\tu32 bit_pos = gf_bs_get_bit_offset(bs);\n\t\tGF_BitStream *w_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u8(w_bs, data[0]);\n\t\tgf_bs_write_u8(w_bs, data[1]);\n\t\tgf_bs_write_u8(w_bs, data[2]);\n\t\tgf_bs_write_u8(w_bs, data[3]);\n\t\tgf_bs_write_u16(w_bs, 0xFFFF);\n\t\tgf_bs_seek(bs, 6);\n\t\tbit_pos-=48;\n\t\twhile (bit_pos) {\n\t\t\tu32 v = gf_bs_read_int(bs, 1);\n\t\t\tgf_bs_write_int(w_bs, v, 1);\n\t\t\tbit_pos--;\n\t\t}\n\t\t/*vps extension flag*/\n\t\tgf_bs_write_int(w_bs, 0, 1);\n\t\tnew_vps=NULL;\n\t\tgf_bs_get_content(w_bs, &new_vps, &new_vps_size);\n\t\tgf_bs_del(w_bs);\n\t\t\n\t\temulation_bytes = avc_emulation_bytes_add_count(new_vps, new_vps_size);\n\t\tif (emulation_bytes+new_vps_size > *size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"Buffer too small to rewrite VPS - skipping rewrite\\n\"));\n\t\t} else {\n\t\t\t*size = avc_add_emulation_bytes(new_vps, data, new_vps_size);\n\t\t}\n\t}\n\nexit:\n\tif (bs) gf_bs_del(bs);\n\tif (data_without_emulation_bytes) gf_free(data_without_emulation_bytes);\n\treturn vps_id;\n}\n\nGF_EXPORT\ns32 gf_media_hevc_read_vps(char *data, u32 size, HEVCState *hevc)\n{\n\treturn gf_media_hevc_read_vps_ex(data, &size, hevc, GF_FALSE);\n}\n\nstatic void hevc_scaling_list_data(GF_BitStream *bs)\n{\n\tu32 i, sizeId, matrixId;\n\tfor (sizeId = 0; sizeId < 4; sizeId++) {\n\t\tfor (matrixId=0; matrixId<6; matrixId += (sizeId == 3) ? 3:1 ) {\n\t\t\tu32 scaling_list_pred_mode_flag_sizeId_matrixId = gf_bs_read_int(bs, 1);\n\t\t\tif( ! scaling_list_pred_mode_flag_sizeId_matrixId ) {\n\t\t\t\t/*scaling_list_pred_matrix_id_delta[ sizeId ][ matrixId ] =*/ bs_get_ue(bs);\n\t\t\t} else {\n\t\t\t\t//u32 nextCoef = 8;\n\t\t\t\tu32 coefNum = MIN(64, (1 << (4+(sizeId << 1))));\n\t\t\t\tif ( sizeId > 1 ) {\n\t\t\t\t\t/*scaling_list_dc_coef_minus8[ sizeId \u2212 2 ][ matrixId ] = */bs_get_se(bs);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i<coefNum; i++) {\n\t\t\t\t\t/*scaling_list_delta_coef = */bs_get_se(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic const struct {\n\tu32 w, h;\n} hevc_sar[17] =\n{\n\t{ 0,   0 }, { 1,   1 }, { 12, 11 }, { 10, 11 },\n\t{ 16, 11 }, { 40, 33 }, { 24, 11 }, { 20, 11 },\n\t{ 32, 11 }, { 80, 33 }, { 18, 11 }, { 15, 11 },\n\t{ 64, 33 }, { 160,99 }, { 4,3}, { 3,2}, { 2,1}\n};\n\nstatic s32 gf_media_hevc_read_sps_bs(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id = -1;\n\tu8 max_sub_layers_minus1, flag;\n\tBool scaling_list_enable_flag;\n\tu32 i, nb_CTUs, depth;\n\tu32 log2_diff_max_min_luma_coding_block_size;\n\tu32 log2_min_transform_block_size, log2_min_luma_coding_block_size;\n\tBool sps_sub_layer_ordering_info_present_flag;\n\tHEVC_SPS *sps;\n\tHEVC_VPS *vps;\n\tHEVC_ProfileTierLevel ptl;\n\tu32 sps_ext_or_max_sub_layers_minus1;\n\tBool multiLayerExtSpsFlag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int(bs, 4);\n\tif (vps_id>=16) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;\n\tif (layer_id == 0)\n\t\tmax_sub_layers_minus1 = gf_bs_read_int(bs, 3);\n\telse\n\t\tsps_ext_or_max_sub_layers_minus1 = gf_bs_read_int(bs, 3);\n\tmultiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);\n\tif (!multiLayerExtSpsFlag) {\t\t\n\t\t/*temporal_id_nesting_flag = */gf_bs_read_int(bs, 1);\n\t\tprofile_tier_level(bs, 1, max_sub_layers_minus1, &ptl);\n\t}\n\n\tsps_id = bs_get_ue(bs);\n\tif ((sps_id<0) ||(sps_id>=16)) {\n\t\treturn -1;\n\t}\n\n\tsps = &hevc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->ptl = ptl;\n\tvps = &hevc->vps[vps_id];\n\n\t//sps_rep_format_idx = 0;\n\tif (multiLayerExtSpsFlag) {\n\t\tu8 update_rep_format_flag = gf_bs_read_int(bs, 1);\n\t\tif (update_rep_format_flag) {\n\t\t\tsps->rep_format_idx = gf_bs_read_int(bs, 8);\n\t\t} else {\n\t\t\tsps->rep_format_idx = vps->rep_format_idx[layer_id];\n\t\t}\n\t\tsps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;\n\t\tsps->height = vps->rep_formats[sps->rep_format_idx].pic_height_luma_samples;\n\t\tsps->chroma_format_idc = vps->rep_formats[sps->rep_format_idx].chroma_format_idc;\n\t\tsps->bit_depth_luma = vps->rep_formats[sps->rep_format_idx].bit_depth_luma;\n\t\tsps->bit_depth_chroma = vps->rep_formats[sps->rep_format_idx].bit_depth_chroma;\n\t\tsps->separate_colour_plane_flag = vps->rep_formats[sps->rep_format_idx].separate_colour_plane_flag;\n\n\t\t//TODO this is crude ...\n\t\tsps->ptl = vps->ext_ptl[0];\n\t} else {\n\t\tsps->chroma_format_idc = bs_get_ue(bs);\n\t\tif (sps->chroma_format_idc==3)\n\t\t\tsps->separate_colour_plane_flag = gf_bs_read_int(bs, 1);\n\t\tsps->width = bs_get_ue(bs);\n\t\tsps->height = bs_get_ue(bs);\n\t\tif (/*conformance_window_flag*/gf_bs_read_int(bs, 1)) {\n\t\t\tu32 SubWidthC, SubHeightC;\n\n\t\t\tif (sps->chroma_format_idc==1) {\n\t\t\t\tSubWidthC = SubHeightC = 2;\n\t\t\t}\n\t\t\telse if (sps->chroma_format_idc==2) {\n\t\t\t\tSubWidthC = 2;\n\t\t\t\tSubHeightC = 1;\n\t\t\t} else {\n\t\t\t\tSubWidthC = SubHeightC = 1;\n\t\t\t}\n\n\t\t\tsps->cw_left = bs_get_ue(bs);\n\t\t\tsps->cw_right = bs_get_ue(bs);\n\t\t\tsps->cw_top = bs_get_ue(bs);\n\t\t\tsps->cw_bottom = bs_get_ue(bs);\n\n\t\t\tsps->width -= SubWidthC * (sps->cw_left + sps->cw_right);\n\t\t\tsps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);\n\t\t}\n\t\tsps->bit_depth_luma = 8 + bs_get_ue(bs);\n\t\tsps->bit_depth_chroma = 8 + bs_get_ue(bs);\n\t}\n\n\tsps->log2_max_pic_order_cnt_lsb = 4 + bs_get_ue(bs);\n\n\tif (!multiLayerExtSpsFlag) {\n\t\tsps_sub_layer_ordering_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tfor(i=sps_sub_layer_ordering_info_present_flag ? 0 : max_sub_layers_minus1; i<=max_sub_layers_minus1; i++) {\n\t\t\t/*max_dec_pic_buffering = */ bs_get_ue(bs);\n\t\t\t/*num_reorder_pics = */ bs_get_ue(bs);\n\t\t\t/*max_latency_increase = */ bs_get_ue(bs);\n\t\t}\n\t}\n\n\tlog2_min_luma_coding_block_size = 3 + bs_get_ue(bs);\n\tlog2_diff_max_min_luma_coding_block_size = bs_get_ue(bs);\n\tsps->max_CU_width = ( 1<<(log2_min_luma_coding_block_size + log2_diff_max_min_luma_coding_block_size) );\n\tsps->max_CU_height = ( 1<<(log2_min_luma_coding_block_size + log2_diff_max_min_luma_coding_block_size) );\n\n\tlog2_min_transform_block_size = 2 + bs_get_ue(bs);\n\t/*log2_max_transform_block_size = log2_min_transform_block_size  + */bs_get_ue(bs);\n\n\tdepth = 0;\n\t/*u32 max_transform_hierarchy_depth_inter = */bs_get_ue(bs);\n\t/*u32 max_transform_hierarchy_depth_intra = */bs_get_ue(bs);\n\twhile( (u32) ( sps->max_CU_width >> log2_diff_max_min_luma_coding_block_size ) > (u32) ( 1 << ( log2_min_transform_block_size + depth )  ) )\n\t{\n\t\tdepth++;\n\t}\n\tsps->max_CU_depth = log2_diff_max_min_luma_coding_block_size + depth;\n\n\tnb_CTUs = ((sps->width + sps->max_CU_width -1) / sps->max_CU_width) * ((sps->height + sps->max_CU_height-1) / sps->max_CU_height);\n\tsps->bitsSliceSegmentAddress = 0;\n\twhile (nb_CTUs > (u32) (1 << sps->bitsSliceSegmentAddress)) {\n\t\tsps->bitsSliceSegmentAddress++;\n\t}\n\n\tscaling_list_enable_flag = gf_bs_read_int(bs, 1);\n\tif (scaling_list_enable_flag) {\n\t\tBool sps_infer_scaling_list_flag = 0;\n\t\t/*u8 sps_scaling_list_ref_layer_id = 0;*/\n\t\tif (multiLayerExtSpsFlag) {\n\t\t\tsps_infer_scaling_list_flag = gf_bs_read_int(bs, 1);\n\t\t}\n\n\t\tif (sps_infer_scaling_list_flag) {\n\t\t\t/*sps_scaling_list_ref_layer_id = */gf_bs_read_int(bs, 6);\n\t\t} else {\n\t\t\tif (/*sps_scaling_list_data_present_flag=*/gf_bs_read_int(bs, 1) ) {\n\t\t\t\thevc_scaling_list_data(bs);\n\t\t\t}\n\t\t}\n\t}\n\t/*asymmetric_motion_partitions_enabled_flag= */ gf_bs_read_int(bs, 1);\n\tsps->sample_adaptive_offset_enabled_flag = gf_bs_read_int(bs, 1);\n\tif (/*pcm_enabled_flag= */ gf_bs_read_int(bs, 1) ) {\n\t\t/*pcm_sample_bit_depth_luma_minus1=*/gf_bs_read_int(bs, 4);\n\t\t/*pcm_sample_bit_depth_chroma_minus1=*/gf_bs_read_int(bs, 4);\n\t\t/*log2_min_pcm_luma_coding_block_size_minus3= */ bs_get_ue(bs);\n\t\t/*log2_diff_max_min_pcm_luma_coding_block_size = */ bs_get_ue(bs);\n\t\t/*pcm_loop_filter_disable_flag=*/gf_bs_read_int(bs, 1);\n\t}\n\tsps->num_short_term_ref_pic_sets = bs_get_ue(bs);\n\tif (sps->num_short_term_ref_pic_sets>64) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid number of short term reference picture sets %d\\n\", sps->num_short_term_ref_pic_sets));\n\t\treturn -1;\n\t}\n\t\n\tfor (i=0; i<sps->num_short_term_ref_pic_sets; i++) {\n\t\tBool ret = parse_short_term_ref_pic_set(bs, sps, i);\n\t\t/*cannot parse short_term_ref_pic_set, skip VUI parsing*/\n\t\tif (!ret) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid short_term_ref_pic_set\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tsps->long_term_ref_pics_present_flag = gf_bs_read_int(bs, 1);\n\tif (sps->long_term_ref_pics_present_flag) {\n\t\tsps->num_long_term_ref_pic_sps = bs_get_ue(bs);\n\t\tfor (i=0; i<sps->num_long_term_ref_pic_sps; i++) {\n\t\t\t/*lt_ref_pic_poc_lsb_sps=*/gf_bs_read_int(bs, sps->log2_max_pic_order_cnt_lsb);\n\t\t\t/*used_by_curr_pic_lt_sps_flag*/gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\tsps->temporal_mvp_enable_flag = gf_bs_read_int(bs, 1);\n\t/*strong_intra_smoothing_enable_flag*/gf_bs_read_int(bs, 1);\n\n\tif (vui_flag_pos)\n\t\t*vui_flag_pos = (u32) gf_bs_get_bit_offset(bs);\n\n\tif (/*vui_parameters_present_flag*/gf_bs_read_int(bs, 1)) {\n\n\t\tsps->aspect_ratio_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->aspect_ratio_info_present_flag) {\n\t\t\tsps->sar_idc = gf_bs_read_int(bs, 8);\n\t\t\tif (sps->sar_idc == 255) {\n\t\t\t\tsps->sar_width = gf_bs_read_int(bs, 16);\n\t\t\t\tsps->sar_height = gf_bs_read_int(bs, 16);\n\t\t\t} else if (sps->sar_idc<17) {\n\t\t\t\tsps->sar_width = hevc_sar[sps->sar_idc].w;\n\t\t\t\tsps->sar_height = hevc_sar[sps->sar_idc].h;\n\t\t\t}\n\t\t}\n\n\t\tif (/*overscan_info_present = */ gf_bs_read_int(bs, 1))\n\t\t\t/*overscan_appropriate = */ gf_bs_read_int(bs, 1);\n\n\t\t/*video_signal_type_present_flag = */flag = gf_bs_read_int(bs, 1);\n\t\tif (flag) {\n\t\t\t/*video_format = */gf_bs_read_int(bs, 3);\n\t\t\t/*video_full_range_flag = */gf_bs_read_int(bs, 1);\n\t\t\tif (/*colour_description_present_flag = */gf_bs_read_int(bs, 1)) {\n\t\t\t\t/*colour_primaries = */ gf_bs_read_int(bs, 8);\n\t\t\t\t/* transfer_characteristic = */ gf_bs_read_int(bs, 8);\n\t\t\t\t/* matrix_coeffs = */ gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\n\t\tif (/*chroma_loc_info_present_flag = */ gf_bs_read_int(bs, 1)) {\n\t\t\t/*chroma_sample_loc_type_top_field = */ bs_get_ue(bs);\n\t\t\t/*chroma_sample_loc_type_bottom_field = */bs_get_ue(bs);\n\t\t}\n\n\t\t/*neutra_chroma_indication_flag = */gf_bs_read_int(bs, 1);\n\t\t/*field_seq_flag = */gf_bs_read_int(bs, 1);\n\t\t/*frame_field_info_present_flag = */gf_bs_read_int(bs, 1);\n\n\t\tif (/*default_display_window_flag=*/gf_bs_read_int(bs, 1)) {\n\t\t\t/*left_offset = */bs_get_ue(bs);\n\t\t\t/*right_offset = */bs_get_ue(bs);\n\t\t\t/*top_offset = */bs_get_ue(bs);\n\t\t\t/*bottom_offset = */bs_get_ue(bs);\n\t\t}\n\n\t\tsps->has_timing_info = gf_bs_read_int(bs, 1);\n\t\tif (sps->has_timing_info ) {\n\t\t\tsps->num_units_in_tick = gf_bs_read_int(bs, 32);\n\t\t\tsps->time_scale = gf_bs_read_int(bs, 32);\n\t\t\tsps->poc_proportional_to_timing_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (sps->poc_proportional_to_timing_flag)\n\t\t\t\tsps->num_ticks_poc_diff_one_minus1 = bs_get_ue(bs);\n\t\t\tif (/*hrd_parameters_present_flag=*/gf_bs_read_int(bs, 1) ) {\n//\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[HEVC] HRD param parsing not implemented\\n\"));\n\t\t\t\treturn sps_id;\n\t\t\t}\n\t\t}\n\n\t\tif (/*bitstream_restriction_flag=*/gf_bs_read_int(bs, 1)) {\n\t\t\t/*tiles_fixed_structure_flag = */gf_bs_read_int(bs, 1);\n\t\t\t/*motion_vectors_over_pic_boundaries_flag = */gf_bs_read_int(bs, 1);\n\t\t\t/*restricted_ref_pic_lists_flag = */gf_bs_read_int(bs, 1);\n\t\t\t/*min_spatial_segmentation_idc = */bs_get_ue(bs);\n\t\t\t/*max_bytes_per_pic_denom = */bs_get_ue(bs);\n\t\t\t/*max_bits_per_min_cu_denom = */bs_get_ue(bs);\n\t\t\t/*log2_max_mv_length_horizontal = */bs_get_ue(bs);\n\t\t\t/*log2_max_mv_length_vertical = */bs_get_ue(bs);\n\t\t}\n\t}\n\n\tif (/*sps_extension_flag*/gf_bs_read_int(bs, 1)) {\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*sps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\n\treturn sps_id;\n}\n\nGF_EXPORT\ns32 gf_media_hevc_read_sps_ex(char *data, u32 size, HEVCState *hevc, u32 *vui_flag_pos)\n{\n\tGF_BitStream *bs;\n\tchar *data_without_emulation_bytes = NULL;\n\tu32 data_without_emulation_bytes_size = 0;\n\ts32 sps_id= -1;\n\tu8 layer_id;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tdata_without_emulation_bytes_size = avc_emulation_bytes_remove_count(data, size);\n\tif (!data_without_emulation_bytes_size) {\n\t\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t} else {\n\t\t/*still contains emulation bytes*/\n\t\tdata_without_emulation_bytes = gf_malloc(size*sizeof(char));\n\t\tdata_without_emulation_bytes_size = avc_remove_emulation_bytes(data, data_without_emulation_bytes, size);\n\t\tbs = gf_bs_new(data_without_emulation_bytes, data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\t}\n\tif (!bs) goto exit;\n\tif (! hevc_parse_nal_header(bs, NULL, NULL, &layer_id)) goto exit;\n\tsps_id = gf_media_hevc_read_sps_bs(bs, hevc, layer_id, vui_flag_pos);\n\nexit:\n\tif (bs) gf_bs_del(bs);\n\tif (data_without_emulation_bytes) gf_free(data_without_emulation_bytes);\n\treturn sps_id;\n}\n\nGF_EXPORT\ns32 gf_media_hevc_read_sps(char *data, u32 size, HEVCState *hevc)\n{\n\treturn gf_media_hevc_read_sps_ex(data, size, hevc, NULL);\n}\n\n\nstatic s32 gf_media_hevc_read_pps_bs(GF_BitStream *bs, HEVCState *hevc)\n{\n\tu32 i;\n\ts32 pps_id = -1;\n\tHEVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = bs_get_ue(bs);\n\n\tif ((pps_id<0) || (pps_id>=64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &hevc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = bs_get_ue(bs);\n\tif (pps->sps_id>16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\treturn -1;\n\t}\n\thevc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->dependent_slice_segments_enabled_flag = gf_bs_read_int(bs, 1);\n\n\tpps->output_flag_present_flag = gf_bs_read_int(bs, 1);\n\tpps->num_extra_slice_header_bits = gf_bs_read_int(bs, 3);\n\t/*sign_data_hiding_flag = */gf_bs_read_int(bs, 1);\n\tpps->cabac_init_present_flag = gf_bs_read_int(bs, 1);\n\tpps->num_ref_idx_l0_default_active = 1 + bs_get_ue(bs);\n\tpps->num_ref_idx_l1_default_active = 1 + bs_get_ue(bs);\n\t/*pic_init_qp_minus26 = */bs_get_se(bs);\n\t/*constrained_intra_pred_flag = */gf_bs_read_int(bs, 1);\n\t/*transform_skip_enabled_flag = */gf_bs_read_int(bs, 1);\n\tif (/*cu_qp_delta_enabled_flag = */gf_bs_read_int(bs, 1) )\n\t\t/*diff_cu_qp_delta_depth = */bs_get_ue(bs);\n\n\t/*pic_cb_qp_offset = */bs_get_se(bs);\n\t/*pic_cr_qp_offset = */bs_get_se(bs);\n\tpps->slice_chroma_qp_offsets_present_flag = gf_bs_read_int(bs, 1);\n\tpps->weighted_pred_flag = gf_bs_read_int(bs, 1);\n\tpps->weighted_bipred_flag = gf_bs_read_int(bs, 1);\n\t/*transquant_bypass_enable_flag = */gf_bs_read_int(bs, 1);\n\tpps->tiles_enabled_flag = gf_bs_read_int(bs, 1);\n\tpps->entropy_coding_sync_enabled_flag = gf_bs_read_int(bs, 1);\n\tif (pps->tiles_enabled_flag) {\n\t\tpps->num_tile_columns = 1 + bs_get_ue(bs);\n\t\tpps->num_tile_rows = 1 + bs_get_ue(bs);\n\t\tpps->uniform_spacing_flag = gf_bs_read_int(bs, 1);\n\t\tif (!pps->uniform_spacing_flag ) {\n\t\t\tfor (i=0; i<pps->num_tile_columns-1; i++) {\n\t\t\t\tpps->column_width[i] = 1 + bs_get_ue(bs);\n\t\t\t}\n\t\t\tfor (i=0; i<pps->num_tile_rows-1; i++) {\n\t\t\t\tpps->row_height[i] = 1+bs_get_ue(bs);\n\t\t\t}\n\t\t}\n\t\tpps->loop_filter_across_tiles_enabled_flag = gf_bs_read_int(bs, 1);\n\t}\n\tpps->loop_filter_across_slices_enabled_flag = gf_bs_read_int(bs, 1);\n\tif( /*deblocking_filter_control_present_flag = */gf_bs_read_int(bs, 1)  ) {\n\t\tpps->deblocking_filter_override_enabled_flag = gf_bs_read_int(bs, 1);\n\t\tif (! /*pic_disable_deblocking_filter_flag= */gf_bs_read_int(bs, 1) ) {\n\t\t\t/*beta_offset_div2 = */bs_get_se(bs);\n\t\t\t/*tc_offset_div2 = */bs_get_se(bs);\n\t\t}\n\t}\n\tif (/*pic_scaling_list_data_present_flag\t= */gf_bs_read_int(bs, 1) ) {\n\t\thevc_scaling_list_data(bs);\n\t}\n\tpps->lists_modification_present_flag = gf_bs_read_int(bs, 1);\n\t/*log2_parallel_merge_level_minus2 = */bs_get_ue(bs);\n\tpps->slice_segment_header_extension_present_flag = gf_bs_read_int(bs, 1);\n\tif ( /*pps_extension_flag= */gf_bs_read_int(bs, 1) ) {\n\t\twhile (gf_bs_available(bs) ) {\n\t\t\t/*pps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\treturn pps_id;\n}\n\n\nGF_EXPORT\ns32 gf_media_hevc_read_pps(char *data, u32 size, HEVCState *hevc)\n{\n\tGF_BitStream *bs;\n\tchar *data_without_emulation_bytes = NULL;\n\tu32 data_without_emulation_bytes_size = 0;\n\ts32 pps_id = -1;\n\n\t/*still contains emulation bytes*/\n\tdata_without_emulation_bytes_size = avc_emulation_bytes_remove_count(data, size);\n\tif (!data_without_emulation_bytes_size) {\n\t\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t} else {\n\t\tdata_without_emulation_bytes = gf_malloc(size*sizeof(char));\n\t\tdata_without_emulation_bytes_size = avc_remove_emulation_bytes(data, data_without_emulation_bytes, size);\n\t\tbs = gf_bs_new(data_without_emulation_bytes, data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\t}\n\tif (!bs) goto exit;\n\n\tif (! hevc_parse_nal_header(bs, NULL, NULL, NULL)) goto exit;\n\n\tpps_id = gf_media_hevc_read_pps_bs(bs, hevc);\n\nexit:\n\tif (bs) gf_bs_del(bs);\n\tif (data_without_emulation_bytes) gf_free(data_without_emulation_bytes);\n\treturn pps_id;\n}\n\nGF_EXPORT\ns32 gf_media_hevc_parse_nalu(char *data, u32 size, HEVCState *hevc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tGF_BitStream *bs=NULL;\n\tchar *data_without_emulation_bytes = NULL;\n\tu32 data_without_emulation_bytes_size = 0;\n\tBool is_slice = GF_FALSE;\n\ts32 ret = -1;\n\tHEVCSliceInfo n_state;\n\n\tmemcpy(&n_state, &hevc->s_info, sizeof(HEVCSliceInfo));\n\n\thevc->last_parsed_vps_id = hevc->last_parsed_sps_id = hevc->last_parsed_pps_id = -1;\n\thevc->s_info.entry_point_start_bits = -1;\n\thevc->s_info.payload_start_offset = -1;\n\n\tdata_without_emulation_bytes_size = avc_emulation_bytes_remove_count(data, size);\n\tif (!data_without_emulation_bytes_size) {\n\t\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t} else {\n\t\t/*still contains emulation bytes*/\n\t\tdata_without_emulation_bytes = gf_malloc(size*sizeof(char));\n\t\tdata_without_emulation_bytes_size = avc_remove_emulation_bytes(data, data_without_emulation_bytes, size);\n\t\tbs = gf_bs_new(data_without_emulation_bytes, data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\t}\n\tif (!bs) goto exit;\n\n\tif (! hevc_parse_nal_header(bs, nal_unit_type, temporal_id, layer_id)) goto exit;\n\tn_state.nal_unit_type = *nal_unit_type;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\tcase GF_HEVC_NALU_END_OF_SEQ:\n\tcase GF_HEVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\t/*slice_segment_layer_rbsp*/\n\tcase GF_HEVC_NALU_SLICE_TRAIL_N:\n\tcase GF_HEVC_NALU_SLICE_TRAIL_R:\n\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\tcase GF_HEVC_NALU_SLICE_RADL_N:\n\tcase GF_HEVC_NALU_SLICE_RADL_R:\n\tcase GF_HEVC_NALU_SLICE_RASL_N:\n\tcase GF_HEVC_NALU_SLICE_RASL_R:\n\t\tis_slice = GF_TRUE;\n\t\t/* slice - read the info and compare.*/\n\t\tret = hevc_parse_slice_segment(bs, hevc, &n_state);\n\t\tif (ret<0) goto exit;\n\n\t\thevc_compute_poc(&n_state);\n\n\t\tret = 0;\n\n\t\tif (hevc->s_info.poc != n_state.poc) {\n\t\t\tret=1;\n\t\t\tbreak;\n\t\t}\n\t\tif (n_state.first_slice_segment_in_pic_flag) {\n\t\t\tif (!(*layer_id) || (n_state.prev_layer_id_plus1 && ((*layer_id) <= n_state.prev_layer_id_plus1 - 1)) ) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\thevc->last_parsed_sps_id = gf_media_hevc_read_sps_bs(bs, hevc, *layer_id, NULL);\n\t\tret = 0;\n\t\tbreak;\n\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\thevc->last_parsed_pps_id = gf_media_hevc_read_pps_bs(bs, hevc);\n\t\tret = 0;\n\t\tbreak;\n\tcase GF_HEVC_NALU_VID_PARAM:\n\t\thevc->last_parsed_vps_id = gf_media_hevc_read_vps_bs(bs, hevc, GF_FALSE);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif (ret && hevc->s_info.sps) {\n\t\tn_state.frame_num_offset_prev = hevc->s_info.frame_num_offset;\n\t\tn_state.frame_num_prev = hevc->s_info.frame_num;\n\n\t\tn_state.poc_lsb_prev = hevc->s_info.poc_lsb;\n\t\tn_state.poc_msb_prev = hevc->s_info.poc_msb;\n\t\tn_state.prev_layer_id_plus1 = *layer_id + 1;\n\t}\n\tif (is_slice) hevc_compute_poc(&n_state);\n\tmemcpy(&hevc->s_info, &n_state, sizeof(HEVCSliceInfo));\n\nexit:\n\tif (bs) gf_bs_del(bs);\n\tif (data_without_emulation_bytes) gf_free(data_without_emulation_bytes);\n\treturn ret;\n}\n\nstatic u8 hevc_get_sar_idx(u32 w, u32 h)\n{\n\tu32 i;\n\tfor (i=0; i<14; i++) {\n\t\tif ((avc_sar[i].w==w) && (avc_sar[i].h==h)) return i;\n\t}\n\treturn 0xFF;\n}\n\nGF_Err gf_media_hevc_change_par(GF_HEVCConfig *hvcc, s32 ar_n, s32 ar_d)\n{\n\tGF_BitStream *orig, *mod;\n\tHEVCState hevc;\n\tu32 i, bit_offset, flag;\n\ts32 idx;\n\tGF_HEVCParamArray *spss;\n\tGF_AVCConfigSlot *slc;\n\torig = NULL;\n\n\tmemset(&hevc, 0, sizeof(HEVCState));\n\thevc.sps_active_idx = -1;\n\n\ti=0;\n\tspss = NULL;\n\twhile ((spss = (GF_HEVCParamArray *)gf_list_enum(hvcc->param_array, &i))) {\n\t\tif (spss->type==GF_HEVC_NALU_SEQ_PARAM)\n\t\t\tbreak;\n\t\tspss = NULL;\n\t}\n\tif (!spss) return GF_NON_COMPLIANT_BITSTREAM;\n\n\ti=0;\n\twhile ((slc = (GF_AVCConfigSlot *)gf_list_enum(spss->nalus, &i))) {\n\t\tchar *no_emulation_buf = NULL;\n\t\tu32 no_emulation_buf_size = 0, emulation_bytes = 0;\n\n\t\t/*SPS may still contains emulation bytes*/\n\t\tno_emulation_buf = gf_malloc((slc->size)*sizeof(char));\n\t\tno_emulation_buf_size = avc_remove_emulation_bytes(slc->data, no_emulation_buf, slc->size);\n\n\t\tidx = gf_media_hevc_read_sps_ex(no_emulation_buf, no_emulation_buf_size, &hevc, &bit_offset);\n\t\tif (idx<0) {\n\t\t\tif ( orig )\n\t\t\t\tgf_bs_del(orig);\n\t\t\tgf_free(no_emulation_buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\torig = gf_bs_new(no_emulation_buf, no_emulation_buf_size, GF_BITSTREAM_READ);\n\t\tmod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t/*copy over till vui flag*/\n\t\tassert(bit_offset >= 0);\n\t\twhile (bit_offset) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t\tbit_offset--;\n\t\t}\n\n\t\t/*check VUI*/\n\t\tflag = gf_bs_read_int(orig, 1);\n\t\tgf_bs_write_int(mod, 1, 1); /*vui_parameters_present_flag*/\n\t\tif (flag) {\n\t\t\t/*aspect_ratio_info_present_flag*/\n\t\t\tif (gf_bs_read_int(orig, 1)) {\n\t\t\t\ts32 aspect_ratio_idc = gf_bs_read_int(orig, 8);\n\t\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\t\tgf_bs_read_int(orig, 16); /*AR num*/\n\t\t\t\t\tgf_bs_read_int(orig, 16); /*AR den*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((ar_d<0) || (ar_n<0)) {\n\t\t\t/*no AR signaled*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\n\t\t} else {\n\t\t\tu32 sarx;\n\t\t\tgf_bs_write_int(mod, 1, 1);\n\t\t\tsarx = hevc_get_sar_idx((u32) ar_n, (u32) ar_d);\n\t\t\tgf_bs_write_int(mod, sarx, 8);\n\t\t\tif (sarx==0xFF) {\n\t\t\t\tgf_bs_write_int(mod, ar_n, 16);\n\t\t\t\tgf_bs_write_int(mod, ar_d, 16);\n\t\t\t}\n\t\t}\n\t\t/*no VUI in input bitstream, set all vui flags to 0*/\n\t\tif (!flag) {\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*overscan_info_present_flag */\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*video_signal_type_present_flag */\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*chroma_location_info_present_flag */\n\n\t\t\tgf_bs_write_int(mod, 0, 1); /*neutra_chroma_indication_flag */;\n\t\t\tgf_bs_write_int(mod, 0, 1); /*field_seq_flag */;\n\t\t\tgf_bs_write_int(mod, 0, 1); /*frame_field_info_present_flag*/;\n\t\t\tgf_bs_write_int(mod, 0, 1); /*default_display_window_flag*/;\n\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*timing_info_present_flag*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*bitstream_restriction*/\n\t\t}\n\n\t\t/*finally copy over remaining*/\n\t\twhile (gf_bs_bits_available(orig)) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t}\n\t\tgf_bs_del(orig);\n\t\torig = NULL;\n\t\tgf_free(no_emulation_buf);\n\n\t\t/*set anti-emulation*/\n\t\tgf_bs_get_content(mod, (char **) &no_emulation_buf, &no_emulation_buf_size);\n\t\temulation_bytes = avc_emulation_bytes_add_count(no_emulation_buf, no_emulation_buf_size);\n\t\tif (no_emulation_buf_size + emulation_bytes > slc->size)\n\t\t\tslc->data = (char*)gf_realloc(slc->data, no_emulation_buf_size + emulation_bytes);\n\n\t\tslc->size = avc_add_emulation_bytes(no_emulation_buf, slc->data, no_emulation_buf_size);\n\n\t\tgf_bs_del(mod);\n\t\tgf_free(no_emulation_buf);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_hevc_get_sps_info_with_state(HEVCState *hevc, char *sps_data, u32 sps_size, u32 *sps_id, u32 *width, u32 *height, s32 *par_n, s32 *par_d)\n{\n\ts32 idx;\n\tidx = gf_media_hevc_read_sps(sps_data, sps_size, hevc);\n\tif (idx<0) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tif (sps_id) *sps_id = idx;\n\n\tif (width) *width = hevc->sps[idx].width;\n\tif (height) *height = hevc->sps[idx].height;\n\tif (par_n) *par_n = hevc->sps[idx].aspect_ratio_info_present_flag ? hevc->sps[idx].sar_width : (u32) -1;\n\tif (par_d) *par_d = hevc->sps[idx].aspect_ratio_info_present_flag ? hevc->sps[idx].sar_height : (u32) -1;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_hevc_get_sps_info(char *sps_data, u32 sps_size, u32 *sps_id, u32 *width, u32 *height, s32 *par_n, s32 *par_d)\n{\n\tHEVCState hevc;\n\tmemset(&hevc, 0, sizeof(HEVCState));\n\thevc.sps_active_idx = -1;\n\treturn gf_hevc_get_sps_info_with_state(&hevc, sps_data, sps_size, sps_id, width, height, par_n, par_d);\n}\n\n#endif //GPAC_DISABLE_HEVC\n\nstatic u32 AC3_FindSyncCode(u8 *buf, u32 buflen)\n{\n\tu32 end = buflen - 6;\n\tu32 offset = 0;\n\twhile (offset <= end) {\n\t\tif (buf[offset] == 0x0b && buf[offset + 1] == 0x77) {\n\t\t\treturn offset;\n\t\t}\n\t\toffset++;\n\t}\n\treturn buflen;\n}\n\n\nstatic Bool AC3_FindSyncCodeBS(GF_BitStream *bs)\n{\n\tu8 b1;\n\tu64 pos = gf_bs_get_position(bs);\n\tu64 end = gf_bs_get_size(bs) - 6;\n\n\tpos += 1;\n\tb1 = gf_bs_read_u8(bs);\n\twhile (pos <= end) {\n\t\tu8 b2 = gf_bs_read_u8(bs);\n\t\tif ((b1 == 0x0b) && (b2==0x77)) {\n\t\t\tgf_bs_seek(bs, pos-1);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tpos++;\n\t\tb1 = b2;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic const u32 ac3_sizecod_to_bitrate[] = {\n\t32000, 40000, 48000, 56000, 64000, 80000, 96000,\n\t112000, 128000, 160000, 192000, 224000, 256000,\n\t320000, 384000, 448000, 512000, 576000, 640000\n};\n\nstatic const u32 ac3_sizecod2_to_framesize[] = {\n\t96, 120, 144, 168, 192, 240, 288, 336, 384, 480, 576, 672,\n\t768, 960, 1152, 1344, 1536, 1728, 1920\n};\n\nstatic const u32 ac3_sizecod1_to_framesize[] = {\n\t69, 87, 104, 121, 139, 174, 208, 243, 278, 348, 417, 487,\n\t557, 696, 835, 975, 1114, 1253, 1393\n};\nstatic const u32 ac3_sizecod0_to_framesize[] = {\n\t64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 448,\n\t512, 640, 768, 896, 1024, 1152, 1280\n};\n\nstatic const u32 ac3_mod_to_chans[] = {\n\t2, 1, 2, 3, 3, 4, 4, 5\n};\n\nGF_EXPORT\nu32 gf_ac3_get_channels(u32 acmod)\n{\n\tu32 nb_ch;\n\tnb_ch = ac3_mod_to_chans[acmod];\n\treturn nb_ch;\n}\n\nGF_EXPORT\nu32 gf_ac3_get_bitrate(u32 brcode)\n{\n\treturn ac3_sizecod_to_bitrate[brcode];\n}\n\nBool gf_ac3_parser(u8 *buf, u32 buflen, u32 *pos, GF_AC3Header *hdr, Bool full_parse)\n{\n\tGF_BitStream *bs;\n\tBool ret;\n\n\tif (buflen < 6) return GF_FALSE;\n\t(*pos) = AC3_FindSyncCode(buf, buflen);\n\tif (*pos >= buflen) return GF_FALSE;\n\n\tbs = gf_bs_new((const char*)(buf+*pos), buflen, GF_BITSTREAM_READ);\n\tret = gf_ac3_parser_bs(bs, hdr, full_parse);\n\tgf_bs_del(bs);\n\n\treturn ret;\n}\n\nGF_EXPORT\nBool gf_ac3_parser_bs(GF_BitStream *bs, GF_AC3Header *hdr, Bool full_parse)\n{\n\tu32 fscod, frmsizecod, bsid, ac3_mod, freq, framesize, bsmod, syncword;\n\tu64 pos;\n\tif (!hdr || (gf_bs_available(bs) < 6)) return GF_FALSE;\n\tif (!AC3_FindSyncCodeBS(bs)) return GF_FALSE;\n\n\tpos = gf_bs_get_position(bs);\n\n\tsyncword = gf_bs_read_u16(bs);\n\tif (syncword != 0x0B77) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AC3] Wrong sync word detected (0x%X - expecting 0x0B77).\\n\", syncword));\n\t\treturn GF_FALSE;\n\t}\n\tgf_bs_read_u16(bs); //crc1\n\tfscod = gf_bs_read_int(bs, 2);\n\tfrmsizecod = gf_bs_read_int(bs, 6);\n\tbsid = gf_bs_read_int(bs, 5);\n\tbsmod = gf_bs_read_int(bs, 3);\n\tac3_mod = gf_bs_read_int(bs, 3);\n\n\thdr->bitrate = ac3_sizecod_to_bitrate[frmsizecod / 2];\n\tif (bsid > 8) hdr->bitrate = hdr->bitrate >> (bsid - 8);\n\n\tswitch (fscod) {\n\tcase 0:\n\t\tfreq = 48000;\n\t\tframesize = ac3_sizecod0_to_framesize[frmsizecod / 2] * 2;\n\t\tbreak;\n\tcase 1:\n\t\tfreq = 44100;\n\t\tframesize = (ac3_sizecod1_to_framesize[frmsizecod / 2] + (frmsizecod & 0x1)) * 2;\n\t\tbreak;\n\tcase 2:\n\t\tfreq = 32000;\n\t\tframesize = ac3_sizecod2_to_framesize[frmsizecod / 2] * 2;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\thdr->sample_rate = freq;\n\thdr->framesize = framesize;\n\n\tif (full_parse) {\n\t\thdr->bsid = bsid;\n\t\thdr->bsmod = bsmod;\n\t\thdr->acmod = ac3_mod;\n\t\thdr->lfon = 0;\n\t\thdr->fscod = fscod;\n\t\thdr->brcode = frmsizecod / 2;\n\t}\n\n\thdr->channels = ac3_mod_to_chans[ac3_mod];\n\tif ((ac3_mod & 0x1) && (ac3_mod != 1)) gf_bs_read_int(bs, 2);\n\tif (ac3_mod & 0x4) gf_bs_read_int(bs, 2);\n\tif (ac3_mod == 0x2) gf_bs_read_int(bs, 2);\n\t/*LFEon*/\n\tif (gf_bs_read_int(bs, 1)) {\n\t\thdr->channels += 1;\n\t\thdr->lfon = 1;\n\t}\n\n\tgf_bs_seek(bs, pos);\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_eac3_parser_bs(GF_BitStream *bs, GF_AC3Header *hdr, Bool full_parse)\n{\n\tu32 fscod, bsid, ac3_mod, freq, framesize, syncword, substreamid, lfon, channels, numblkscod;\n\tu64 pos;\n\nrestart:\n\tif (!hdr || (gf_bs_available(bs) < 6))\n\t\treturn GF_FALSE;\n\tif (!AC3_FindSyncCodeBS(bs))\n\t\treturn GF_FALSE;\n\n\tpos = gf_bs_get_position(bs);\n\tframesize = 0;\n\tnumblkscod = 0;\n\nblock:\n\tsyncword = gf_bs_read_u16(bs);\n\tif (syncword != 0x0B77) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[E-AC3] Wrong sync word detected (0x%X - expecting 0x0B77).\\n\", syncword));\n\t\treturn GF_FALSE;\n\t}\n\n\tgf_bs_read_int(bs, 2); //strmtyp\n\tsubstreamid = gf_bs_read_int(bs, 3);\n\tframesize += gf_bs_read_int(bs, 11);\n\tfscod = gf_bs_read_int(bs, 2);\n\tif (fscod == 0x3) {\n\t\tfscod = gf_bs_read_int(bs, 2);\n\t\tnumblkscod += 6;\n\t} else {\n\t\tnumblkscod += gf_bs_read_int(bs, 2);\n\t}\n\tassert(numblkscod <= 9);\n\n\tif ((hdr->substreams >> substreamid) & 0x1) {\n\t\tif (!substreamid) {\n\t\t\thdr->framesize = framesize;\n\n\t\t\tif (numblkscod < 6) { //we need 6 blocks to make a sample\n\t\t\t\tgf_bs_seek(bs, pos+2*framesize);\n\t\t\t\tif ((gf_bs_available(bs) < 6) || !AC3_FindSyncCodeBS(bs))\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t\tgoto block;\n\t\t\t}\n\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\treturn GF_TRUE;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[E-AC3] Detected sample in substream id=%u. Skipping.\\n\", substreamid));\n\t\t\tgf_bs_seek(bs, pos+framesize);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\thdr->substreams |= (1 << substreamid);\n\n\tswitch (fscod) {\n\tcase 0:\n\t\tfreq = 48000;\n\t\tbreak;\n\tcase 1:\n\t\tfreq = 44100;\n\t\tbreak;\n\tcase 2:\n\t\tfreq = 32000;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\n\tac3_mod = gf_bs_read_int(bs, 3);\n\tlfon = gf_bs_read_int(bs, 1);\n\tbsid = gf_bs_read_int(bs, 5);\n\tif (!substreamid && (bsid!=16/*E-AC3*/))\n\t\treturn GF_FALSE;\n\n\tchannels = ac3_mod_to_chans[ac3_mod];\n\tif (lfon)\n\t\tchannels += 1;\n\n\tif (substreamid) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[E-AC3] Detected additional %u channels in substream id=%u - may not be handled correctly. Skipping.\\n\", channels, substreamid));\n\t\tgf_bs_seek(bs, pos+framesize);\n\t\tgoto restart;\n\t} else {\n\t\thdr->bitrate = 0;\n\t\thdr->sample_rate = freq;\n\t\thdr->framesize = framesize;\n\t\thdr->lfon = lfon;\n\t\thdr->channels = channels;\n\t\tif (full_parse) {\n\t\t\thdr->bsid = bsid;\n\t\t\thdr->bsmod = 0;\n\t\t\thdr->acmod = ac3_mod;\n\t\t\thdr->fscod = fscod;\n\t\t\thdr->brcode = 0;\n\t\t}\n\t}\n\n\tif (numblkscod < 6) { //we need 6 blocks to make a sample\n\t\tgf_bs_seek(bs, pos+2*framesize);\n\t\tif ((gf_bs_available(bs) < 6) || !AC3_FindSyncCodeBS(bs))\n\t\t\treturn GF_FALSE;\n\t\tgoto block;\n\t}\n\n\tgf_bs_seek(bs, pos);\n\n\treturn GF_TRUE;\n}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined (GPAC_DISABLE_OGG)\n\n/*\n\tVorbis parser\n*/\n\nstatic u32 vorbis_book_maptype1_quantvals(u32 entries, u32 dim)\n{\n\tu32 vals = (u32) floor(pow(entries, 1.0/dim));\n\twhile(1) {\n\t\tu32 acc=1;\n\t\tu32 acc1=1;\n\t\tu32 i;\n\t\tfor (i=0; i<dim; i++) {\n\t\t\tacc*=vals;\n\t\t\tacc1*=vals+1;\n\t\t}\n\t\tif(acc<=entries && acc1>entries) return (vals);\n\t\telse {\n\t\t\tif (acc>entries) vals--;\n\t\t\telse vals++;\n\t\t}\n\t}\n}\n\nu32 _ilog_(u32 v)\n{\n\tu32 ret=0;\n\twhile(v) {\n\t\tret++;\n\t\tv>>=1;\n\t}\n\treturn(ret);\n}\n\nstatic u32 ilog(u32 v)\n{\n\tu32 ret=0;\n\tif(v) --v;\n\twhile(v) {\n\t\tret++;\n\t\tv>>=1;\n\t}\n\treturn (ret);\n}\n\nstatic u32 icount(u32 v)\n{\n\tu32 ret=0;\n\twhile(v) {\n\t\tret += v&1;\n\t\tv>>=1;\n\t}\n\treturn(ret);\n}\n\n\nGF_EXPORT\nBool gf_vorbis_parse_header(GF_VorbisParser *vp, char *data, u32 data_len)\n{\n\tu32 pack_type, i, j, k, times, nb_part, nb_books, nb_modes;\n\tchar szNAME[8];\n\toggpack_buffer opb;\n\n\toggpack_readinit(&opb, (u8*)data, data_len);\n\tpack_type = oggpack_read(&opb, 8);\n\ti=0;\n\twhile (i<6) {\n\t\tszNAME[i] = oggpack_read(&opb, 8);\n\t\ti++;\n\t}\n\tszNAME[i] = 0;\n\tif (strcmp(szNAME, \"vorbis\")) return vp->is_init = 0;\n\n\tswitch (pack_type) {\n\tcase 0x01:\n\t\tvp->version = oggpack_read(&opb, 32);\n\t\tif (vp->version!=0) return 0;\n\t\tvp->channels = oggpack_read(&opb, 8);\n\t\tvp->sample_rate = oggpack_read(&opb, 32);\n\t\tvp->max_r = oggpack_read(&opb, 32);\n\t\tvp->avg_r = oggpack_read(&opb, 32);\n\t\tvp->low_r = oggpack_read(&opb, 32);\n\n\t\tvp->min_block = 1<<oggpack_read(&opb, 4);\n\t\tvp->max_block = 1<<oggpack_read(&opb, 4);\n\t\tif (vp->sample_rate < 1) return vp->is_init = 0;\n\t\tif (vp->channels < 1) return vp->is_init = 0;\n\t\tif (vp->min_block<8) return vp->is_init = 0;\n\t\tif (vp->max_block < vp->min_block) return vp->is_init = 0;\n\t\tif (oggpack_read(&opb, 1) != 1) return vp->is_init = 0;\n\t\tvp->is_init = 1;\n\t\treturn 1;\n\tcase 0x03:\n\t\t/*trash comments*/\n\t\tvp->is_init ++;\n\t\treturn 1;\n\tcase 0x05:\n\t\t/*need at least bitstream header to make sure we're parsing the right thing*/\n\t\tif (!vp->is_init) return 0;\n\t\tbreak;\n\tdefault:\n\t\tvp->is_init = 0;\n\t\treturn 0;\n\t}\n\t/*OK parse codebook*/\n\tnb_books = oggpack_read(&opb, 8) + 1;\n\t/*skip vorbis static books*/\n\tfor (i=0; i<nb_books; i++) {\n\t\tu32 j, map_type, qb, qq;\n\t\tu32 entries, dim;\n\t\toggpack_read(&opb, 24);\n\t\tdim = oggpack_read(&opb, 16);\n\t\tentries = oggpack_read(&opb, 24);\n\t\tif ( (s32) entries < 0) entries = 0;\n\t\tif (oggpack_read(&opb, 1) == 0) {\n\t\t\tif (oggpack_read(&opb, 1)) {\n\t\t\t\tfor (j=0; j<entries; j++) {\n\t\t\t\t\tif (oggpack_read(&opb, 1)) {\n\t\t\t\t\t\toggpack_read(&opb, 5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (j=0; j<entries; j++)\n\t\t\t\t\toggpack_read(&opb, 5);\n\t\t\t}\n\t\t} else {\n\t\t\toggpack_read(&opb, 5);\n\t\t\tfor (j=0; j<entries;) {\n\t\t\t\tu32 num = oggpack_read(&opb, _ilog_(entries-j));\n\t\t\t\tfor (k=0; k<num && j<entries; k++, j++) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch ((map_type=oggpack_read(&opb, 4))) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\t\toggpack_read(&opb, 32);\n\t\t\toggpack_read(&opb, 32);\n\t\t\tqq = oggpack_read(&opb, 4)+1;\n\t\t\toggpack_read(&opb, 1);\n\t\t\tif (map_type==1) qb = vorbis_book_maptype1_quantvals(entries, dim);\n\t\t\telse if (map_type==2) qb = entries * dim;\n\t\t\telse qb = 0;\n\t\t\tfor (j=0; j<qb; j++) oggpack_read(&opb, qq);\n\t\t\tbreak;\n\t\t}\n\t}\n\ttimes = oggpack_read(&opb, 6)+1;\n\tfor (i=0; i<times; i++) oggpack_read(&opb, 16);\n\ttimes = oggpack_read(&opb, 6)+1;\n\tfor (i=0; i<times; i++) {\n\t\tu32 type = oggpack_read(&opb, 16);\n\t\tif (type) {\n\t\t\tu32 *parts, *class_dims, count, rangebits;\n\t\t\tu32 max_class = 0;\n\t\t\tnb_part = oggpack_read(&opb, 5);\n\t\t\tparts = (u32*)gf_malloc(sizeof(u32) * nb_part);\n\t\t\tfor (j=0; j<nb_part; j++) {\n\t\t\t\tparts[j] = oggpack_read(&opb, 4);\n\t\t\t\tif (max_class<parts[j]) max_class = parts[j];\n\t\t\t}\n\t\t\tclass_dims = (u32*)gf_malloc(sizeof(u32) * (max_class+1));\n\t\t\tfor (j=0; j<max_class+1; j++) {\n\t\t\t\tu32 class_sub;\n\t\t\t\tclass_dims[j] = oggpack_read(&opb, 3) + 1;\n\t\t\t\tclass_sub = oggpack_read(&opb, 2);\n\t\t\t\tif (class_sub) oggpack_read(&opb, 8);\n\t\t\t\tfor (k=0; k < (u32) (1<<class_sub); k++) oggpack_read(&opb, 8);\n\t\t\t}\n\t\t\toggpack_read(&opb, 2);\n\t\t\trangebits=oggpack_read(&opb, 4);\n\t\t\tcount = 0;\n\t\t\tfor (j=0,k=0; j<nb_part; j++) {\n\t\t\t\tcount+=class_dims[parts[j]];\n\t\t\t\tfor (; k<count; k++) oggpack_read(&opb, rangebits);\n\t\t\t}\n\t\t\tgf_free(parts);\n\t\t\tgf_free(class_dims);\n\t\t} else {\n\t\t\tu32 j, nb_books;\n\t\t\toggpack_read(&opb, 8+16+16+6+8);\n\t\t\tnb_books = oggpack_read(&opb, 4)+1;\n\t\t\tfor (j=0; j<nb_books; j++) oggpack_read(&opb, 8);\n\t\t}\n\t}\n\ttimes = oggpack_read(&opb, 6)+1;\n\tfor (i=0; i<times; i++) {\n\t\tu32 acc = 0;\n\t\toggpack_read(&opb, 16);/*type*/\n\t\toggpack_read(&opb, 24);\n\t\toggpack_read(&opb,24);\n\t\toggpack_read(&opb,24);\n\t\tnb_part = oggpack_read(&opb, 6)+1;\n\t\toggpack_read(&opb, 8);\n\t\tfor (j=0; j<nb_part; j++) {\n\t\t\tu32 cascade = oggpack_read(&opb, 3);\n\t\t\tif (oggpack_read(&opb, 1)) cascade |= (oggpack_read(&opb, 5)<<3);\n\t\t\tacc += icount(cascade);\n\t\t}\n\t\tfor (j=0; j<acc; j++) oggpack_read(&opb, 8);\n\t}\n\ttimes = oggpack_read(&opb, 6)+1;\n\tfor (i=0; i<times; i++) {\n\t\tu32 sub_maps = 1;\n\t\toggpack_read(&opb, 16);\n\t\tif (oggpack_read(&opb, 1)) sub_maps = oggpack_read(&opb, 4)+1;\n\t\tif (oggpack_read(&opb, 1)) {\n\t\t\tu32 nb_steps = oggpack_read(&opb, 8)+1;\n\t\t\tfor (j=0; j<nb_steps; j++) {\n\t\t\t\toggpack_read(&opb, ilog(vp->channels));\n\t\t\t\toggpack_read(&opb, ilog(vp->channels));\n\t\t\t}\n\t\t}\n\t\toggpack_read(&opb, 2);\n\t\tif (sub_maps>1) {\n\t\t\tfor(j=0; j<vp->channels; j++) oggpack_read(&opb, 4);\n\t\t}\n\t\tfor (j=0; j<sub_maps; j++) {\n\t\t\toggpack_read(&opb, 8);\n\t\t\toggpack_read(&opb, 8);\n\t\t\toggpack_read(&opb, 8);\n\t\t}\n\t}\n\tnb_modes = oggpack_read(&opb, 6)+1;\n\tfor (i=0; i<nb_modes; i++) {\n\t\tvp->mode_flag[i] = oggpack_read(&opb, 1);\n\t\toggpack_read(&opb, 16);\n\t\toggpack_read(&opb, 16);\n\t\toggpack_read(&opb, 8);\n\t}\n\n\tvp->modebits = 0;\n\tj = nb_modes;\n\twhile(j>1) {\n\t\tvp->modebits++;\n\t\tj>>=1;\n\t}\n\treturn 1;\n}\n\nGF_EXPORT\nu32 gf_vorbis_check_frame(GF_VorbisParser *vp, char *data, u32 data_length)\n{\n\ts32 block_size;\n\toggpack_buffer opb;\n\tif (!vp->is_init) return 0;\n\toggpack_readinit(&opb, (unsigned char*)data, data_length);\n\t/*not audio*/\n\tif (oggpack_read(&opb, 1) !=0) return 0;\n\tblock_size = oggpack_read(&opb, vp->modebits);\n\tif (block_size == -1) return 0;\n\treturn ((vp->mode_flag[block_size]) ? vp->max_block : vp->min_block) / (2);\n}\n\n#endif /*!defined(GPAC_DISABLE_AV_PARSERS) && !defined (GPAC_DISABLE_OGG)*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / common tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#ifndef _GF_TOOLS_H_\n#define _GF_TOOLS_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <gpac/setup.h>\n#include <gpac/version.h>\n\n\n/*! \\file \"gpac/tools.h\"\n *\t\\brief Core definitions and tools of GPAC.\n *\n * This file contains basic functions and core definitions of the GPAC framework. This file is\n * usually included by all GPAC header files since it contains the error definitions.\n*/\n\n/*! \\defgroup utils_grp Core Tools\n *\t\\brief Core definitions and tools of GPAC.\n *\n * You will find in this module the documentation of the core tools used in GPAC.\n*/\n\n/*!\n *\t\\ingroup utils_grp\n *\t\\brief Base definitions and functions of GPAC.\n *\n *\tThis section documents some very basic functions and core definitions of the GPAC framework.\n *\t@{\n */\n\n/*!\n *\t\\brief Stringizer\n *\t\\hideinitializer\n *\n *\tMacro transforming its input name into a string\n*/\n#define gf_stringizer(x) #x\n\n/*!\n *\t\\brief Memory allocation for a structure\n *\t\\hideinitializer\n *\n *\tMacro allocating memory and zero-ing it\n*/\n#define GF_SAFEALLOC(__ptr, __struct) { __ptr = (__struct *) gf_malloc(sizeof(__struct)); if (__ptr) memset((void *) __ptr, 0, sizeof(__struct)); }\n\n/*!\n *\t\\brief Memory allocation for an array of n structs\n *\t\\hideinitializer\n *\n *\tMacro allocating memory for n structures and zero-ing it\n*/\n#define GF_SAFE_ALLOC_N(__ptr, __n, __struct) { __ptr = (__struct *) gf_malloc( __n * sizeof(__struct)); if (__ptr) memset((void *) __ptr, 0, __n * sizeof(__struct)); }\n\n/*!\n *\t\\brief 4CC Formatting\n *\t\\hideinitializer\n *\n *\tMacro formating a 4-character code (or 4CC) \"abcd\" as 0xAABBCCDD\n*/\n#ifndef GF_4CC\n#define GF_4CC(a,b,c,d) (((a)<<24)|((b)<<16)|((c)<<8)|(d))\n#endif\n\n/*!\n *\t\\brief GPAC feature list\n *\n *\treturns the list of features enabled/disabled in this GPAC build.\n*/\nconst char *gpac_features();\n\n/*!\n *\t\\brief 4CC Printing\n *\n *\treturns a 4CC printable form\n*/\nconst char *gf_4cc_to_str(u32 type);\n\n/*!\n *\t\\brief asprintf() portable implementation\n *\n *\tsimilar to sprintf, except it allows the string on the\n *  \\note asprintf implementation for windows\n*/\nint gf_asprintf(char **buffer, const char *fmt, ...);\n\n\nsize_t gf_fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\n\n/*!\n *\t\\brief file writing helper\n *\n *\tWrapper to properly handle calls to fwrite()\n *\tEnsures proper error handling is invoked when it fails.\n *\t\\return Same as gf_fwrite\n *\n*/\nsize_t gf_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n\n/*!\n *\t\\brief large file opening\n *\n *\tOpens a large file (>4GB)\n *\t\\param file_name Same semantics as fopen\n *\t\\param mode Same semantics as fopen\n *\t\\return stream handle of the file object\n *\t\\note You only need to call this function if you're suspecting the file to be a large one (usually only media files), otherwise use regular stdio.\n*/\nFILE *gf_fopen(const char *file_name, const char *mode);\n\n/*!\n *\t\\brief file closing\n *\n *\tCloses a file\n *\t\\param file file to close\n *\t\\note You only need to call this function if you're suspecting the file to be a large one (usually only media files), otherwise use regular stdio.\n*/\ns32 gf_fclose(FILE *file);\n\n/*!\n *\t\\brief large file position query\n *\n *\tQueries the current read/write position in a large file\n *\t\\param f Same semantics as ftell\n *\t\\return position in the file\n *\t\\note You only need to call this function if you're suspecting the file to be a large one (usually only media files), otherwise use regular stdio.\n*/\nu64 gf_ftell(FILE *f);\n/*!\n *\t\\brief large file seeking\n *\n *\tSeeks the current read/write position in a large file\n *\t\\param f Same semantics as fseek\n *\t\\param pos Same semantics as fseek\n *\t\\param whence Same semantics as fseek\n *\t\\return new position in the file\n *\t\\note You only need to call this function if you're suspecting the file to be a large one (usually only media files), otherwise use regular stdio.\n*/\nu64 gf_fseek(FILE *f, s64 pos, s32 whence);\n\n/*!\n *\t\\brief get basename from filename/path\n *\n *\tReturns a pointer to the start of a filepath basename or null\n *\t\\param filename Path of the file, can be an absolute path\n*/\nchar* gf_file_basename(const char* filename);\n\n/*!\n *\t\\brief get extension from filename\n *\n *\tReturns a pointer to the start of a filepath extension or null\n *\t\\param filename Path of the file, can be an absolute path\n*/\nchar* gf_file_ext_start(const char* filename);\n\n\n/*! @} */\n\n\n/*! \\addtogroup errors_grp Error codes\n *\t\\ingroup utils_grp\n *\t\\brief Errors used in GPAC.\n *\n *\tThis section documents all error codes used in the GPAC framework. Most of the GPAC's functions will use these as\n * return values, and some of these errors are also used for state communication with the different modules of the framework.\n *\t@{\n */\n\n/*!\n * GPAC Error\n *\t\\hideinitializer\n *\n *\tpositive values are warning and info, 0 means no error and negative values are errors\n */\ntypedef enum\n{\n\t/*!Message from any scripting engine used in the presentation (ECMAScript, MPEG-J, ...) (Info).*/\n\tGF_SCRIPT_INFO                                          = 3,\n\t/*!Indicates an data frame has several AU packed (not MPEG-4 compliant). This is used by decoders to force\n\tmultiple decoding of the same data frame (Info).*/\n\tGF_PACKED_FRAMES\t\t\t\t\t= 2,\n\t/*!Indicates the end of a stream or of a file (Info).*/\n\tGF_EOS\t\t\t\t\t\t\t\t= 1,\n\t/*!\n\t\\n\\n\n\t*/\n\t/*!Operation success (no error).*/\n\tGF_OK\t\t\t\t\t\t\t\t= 0,\n\t/*!\\n*/\n\t/*!One of the input parameter is not correct or cannot be used in the current operating mode of the framework.*/\n\tGF_BAD_PARAM\t\t\t\t\t\t\t= -1,\n\t/*! Memory allocation failure.*/\n\tGF_OUT_OF_MEM\t\t\t\t\t\t\t= -2,\n\t/*! Input/Output failure (disk access, system call failures)*/\n\tGF_IO_ERR\t\t\t\t\t\t\t\t= -3,\n\t/*! The desired feature or operation is not supported by the framework*/\n\tGF_NOT_SUPPORTED\t\t\t\t\t\t= -4,\n\t/*! Input data has been corrupted*/\n\tGF_CORRUPTED_DATA\t\t\t\t\t\t= -5,\n\t/*! A modification was attempted on a scene node which could not be found*/\n\tGF_SG_UNKNOWN_NODE\t\t\t\t\t\t= -6,\n\t/*! The PROTO node interface does not match the nodes using it*/\n\tGF_SG_INVALID_PROTO\t\t\t\t\t\t= -7,\n\t/*! An error occured in the scripting engine*/\n\tGF_SCRIPT_ERROR\t\t\t\t\t\t\t= -8,\n\t/*! Buffer is too small to contain decoded data. Decoders shall use this error whenever they need to resize their output memory buffers*/\n\tGF_BUFFER_TOO_SMALL\t\t\t\t\t\t= -9,\n\t/*! Bitstream is not compliant to the specfication it refers to*/\n\tGF_NON_COMPLIANT_BITSTREAM\t\t\t\t= -10,\n\t/*! No decoders could be found to handle the desired media type*/\n\tGF_CODEC_NOT_FOUND\t\t\t\t\t\t= -11,\n\t/*! The URL is not properly formatted or cannot be found*/\n\tGF_URL_ERROR\t\t\t\t\t\t\t= -12,\n\t/*! An service error has occured at the local side*/\n\tGF_SERVICE_ERROR\t\t\t\t\t\t= -13,\n\t/*! A service error has occured at the remote (server) side*/\n\tGF_REMOTE_SERVICE_ERROR\t\t\t\t\t= -14,\n\t/*! The desired stream could not be found in the service*/\n\tGF_STREAM_NOT_FOUND\t\t\t\t\t\t= -15,\n\t/*! The IsoMedia file is not a valid one*/\n\tGF_ISOM_INVALID_FILE\t\t\t\t\t= -20,\n\t/*! The IsoMedia file is not complete. Either the file is being downloaded, or it has been truncated*/\n\tGF_ISOM_INCOMPLETE_FILE\t\t\t\t\t= -21,\n\t/*! The media in this IsoMedia track is not valid (usually due to a broken stream description)*/\n\tGF_ISOM_INVALID_MEDIA\t\t\t\t\t= -22,\n\t/*! The requested operation cannot happen in the current opening mode of the IsoMedia file*/\n\tGF_ISOM_INVALID_MODE\t\t\t\t\t= -23,\n\t/*! This IsoMedia track refers to media outside the file in an unknown way*/\n\tGF_ISOM_UNKNOWN_DATA_REF\t\t\t\t= -24,\n\n\t/*! An invalid MPEG-4 Object Descriptor was found*/\n\tGF_ODF_INVALID_DESCRIPTOR\t\t\t\t= -30,\n\t/*! An MPEG-4 Object Descriptor was found or added to a forbidden descriptor*/\n\tGF_ODF_FORBIDDEN_DESCRIPTOR\t\t\t\t= -31,\n\t/*! An invalid MPEG-4 BIFS command was detected*/\n\tGF_ODF_INVALID_COMMAND\t\t\t\t\t= -32,\n\t/*! The scene has been encoded using an unknown BIFS version*/\n\tGF_BIFS_UNKNOWN_VERSION\t\t\t\t\t= -33,\n\n\t/*! The remote IP address could not be solved*/\n\tGF_IP_ADDRESS_NOT_FOUND\t\t\t\t\t= -40,\n\t/*! The connection to the remote peer has failed*/\n\tGF_IP_CONNECTION_FAILURE\t\t\t\t= -41,\n\t/*! The network operation has failed*/\n\tGF_IP_NETWORK_FAILURE\t\t\t\t\t= -42,\n\t/*! The network connection has been closed*/\n\tGF_IP_CONNECTION_CLOSED\t\t\t\t\t= -43,\n\t/*! The network operation has failed because no data is available*/\n\tGF_IP_NETWORK_EMPTY\t\t\t\t\t\t= -44,\n\t/*! The network operation has been discarded because it would be a blocking one*/\n\tGF_IP_SOCK_WOULD_BLOCK\t\t\t\t\t= -45,\n\t/*! UDP connection did not receive any data at all. Signaled by client services to reconfigure network if possible*/\n\tGF_IP_UDP_TIMEOUT\t\t\t\t\t\t= -46,\n\n\t/*! Authentication with the remote host has failed*/\n\tGF_AUTHENTICATION_FAILURE\t\t\t\t= -50,\n\t/*! Script not ready for playback */\n\tGF_SCRIPT_NOT_READY\t\t\t\t\t\t= -51,\n\t/*! Bad configuration for the current contex */\n\tGF_INVALID_CONFIGURATION\t\t\t\t= -52,\n\t/*! The element has not been found */\n\tGF_NOT_FOUND\t\t\t\t\t\t\t= -53,\n\t/*! Unexpected format of data */\n\tGF_PROFILE_NOT_SUPPORTED\t\t\t\t= -54,\n\t/*! the decoder buffers were filled, it is necessary to recuperate decoded data*/\n\tGF_CODEC_BUFFER_UNAVAILABLE\t\t\t\t= -55,\n} GF_Err;\n\n/*!\n *\t\\brief Error Printing\n *\n *\tReturns a printable version of a given error\n *\t\\param e Error code requested\n *\t\\return String representing the error\n*/\nconst char *gf_error_to_string(GF_Err e);\n\n/*! @} */\n\n/*! \\addtogroup log_grp Logging tools\n *\t\\ingroup utils_grp\n *\t\\brief Logging system of GPAC\n *\t@{\n */\n\n/*!\n * GPAC Log Levels\n *\t\\hideinitializer\n *\n * These levels describes messages priority used when filtering logs\n */\ntypedef enum\n{\n\t/*! Disable all Log message*/\n\tGF_LOG_QUIET = 0,\n\t/*! Log message describes an error*/\n\tGF_LOG_ERROR,\n\t/*! Log message describes a warning*/\n\tGF_LOG_WARNING,\n\t/*! Log message is informational (state, etc..)*/\n\tGF_LOG_INFO,\n\t/*! Log message is a debug info*/\n\tGF_LOG_DEBUG\n} GF_LOG_Level;\n\n/*!\n *\t\\brief Log exits at first error assignment\n *\n * When GF_LOG_ERROR happens, program leaves with instruction exit(1);\n *\t\\param strict strict behaviour when encoutering a serious error.\n *\n */\nvoid gf_log_set_strict_error(Bool strict);\n\n/*!\n *\t\\brief gets string-formated log tools\n *\n * Returns the string-formatted log tools and levels. Returned string shall be freed by the caller.\n *\t\\return string-formatted log tools.\n *\n */\nchar *gf_log_get_tools_levels();\n\n/*!\n * GPAC Log tools\n *\t\\hideinitializer\n *\n * These flags describes which sub-part of GPAC generates the log and are used when filtering logs\n */\ntypedef enum\n{\n\t/*! Log message from the core library (init, threads, network calls, etc)*/\n\tGF_LOG_CORE = 0,\n\t/*! Log message from a raw media parser (BIFS, LASeR, A/V formats)*/\n\tGF_LOG_CODING,\n\t/*! Log message from a bitstream parser (IsoMedia, MPEG-2 TS, OGG, ...)*/\n\tGF_LOG_CONTAINER,\n\t/*! Log message from the network/service stack (messages & co)*/\n\tGF_LOG_NETWORK,\n\t/*! Log message from the RTP/RTCP stack (TS info) and packet structure & hinting (debug)*/\n\tGF_LOG_RTP,\n\t/*! Log message from authoring subsystem (file manip, import/export)*/\n\tGF_LOG_AUTHOR,\n\t/*! Log message from the sync layer of the terminal*/\n\tGF_LOG_SYNC,\n\t/*! Log message from a codec*/\n\tGF_LOG_CODEC,\n\t/*! Log message from any XML parser (context loading, etc)*/\n\tGF_LOG_PARSER,\n\t/*! Log message from the terminal/compositor, indicating media object state*/\n\tGF_LOG_MEDIA,\n\t/*! Log message from the scene graph/scene manager (handling of nodes and attribute modif, DOM core)*/\n\tGF_LOG_SCENE,\n\t/*! Log message from the scripting engine APIs - does not cover alert() in the script code itself*/\n\tGF_LOG_SCRIPT,\n\t/*! Log message from event handling*/\n\tGF_LOG_INTERACT,\n\t/*! Log message from compositor*/\n\tGF_LOG_COMPOSE,\n\t/*! Log for video object cache */\n\tGF_LOG_CACHE,\n\t/*! Log message from multimedia I/O devices (audio/video input/output, ...)*/\n\tGF_LOG_MMIO,\n\t/*! Log for runtime info (times, memory, CPU usage)*/\n\tGF_LOG_RTI,\n\t/*! Log for SMIL timing and animation*/\n\tGF_LOG_SMIL,\n\t/*! Log for memory tracker*/\n\tGF_LOG_MEMORY,\n\t/*! Log for audio compositor*/\n\tGF_LOG_AUDIO,\n\t/*! Generic Log for modules*/\n\tGF_LOG_MODULE,\n\t/*! Log for threads and mutexes */\n\tGF_LOG_MUTEX,\n\t/*! Log for threads and condition */\n\tGF_LOG_CONDITION,\n\t/*! Log for all HTTP streaming */\n\tGF_LOG_DASH,\n\t/*! Log for all messages coming from GF_Terminal or script alert()*/\n\tGF_LOG_CONSOLE,\n\t/*! Log for all messages coming the application, not used by libgpac or the modules*/\n\tGF_LOG_APP,\n\t/*! Log for all messages coming from the scheduler */\n\tGF_LOG_SCHEDULER,\n\n\t/*! special value used to set a level for all tools*/\n\tGF_LOG_ALL,\n\tGF_LOG_TOOL_MAX = GF_LOG_ALL,\n} GF_LOG_Tool;\n\n/*!\n *\t\\brief Log modules assignment\n *\n * Sets the tools to be checked for log filtering. By default no logging is performed.\n *\t\\param tool tool to be logged.\n *\t\\param level level of logging for this tool.\n *\n */\nvoid gf_log_set_tool_level(GF_LOG_Tool tool, GF_LOG_Level level);\n\n/*!\n *\t\\brief Log Message Callback\n *\n * The gf_log_cbk type is the type for the callback of the \\ref gf_log_set_callback function. By default all logs are redirected to stderr\n *\t\\param cbck Opaque user data.\n *\t\\param log_level level of the log. This value is not guaranteed in multi-threaded context.\n *\t\\param log_tool tool emitting the log. This value is not guaranteed in multi-threaded context.\n *\t\\param fmt message log format.\n *\t\\param vlist message log param.\n *\n */\ntypedef void (*gf_log_cbk)(void *cbck, GF_LOG_Level log_level, GF_LOG_Tool log_tool, const char* fmt, va_list vlist);\n\n/*!\n *\t\\brief Log overwrite\n *\n *\tAssigns a user-defined callback for printing log messages. By default all logs are redirected to stderr\n *\t\\param usr_cbk Opaque user data\n *\t\\param cbk     Callback log function\n *\t\\return previous callback function\n*/\ngf_log_cbk gf_log_set_callback(void *usr_cbk, gf_log_cbk cbk);\n\n\n/*!\n \\cond DUMMY_DOXY_SECTION\n*/\n#ifndef GPAC_DISABLE_LOG\n/*note:\n\t\tto turn log on, change to GPAC_ENABLE_LOG\n\t\tto turn log off, change to GPAC_DISABLE_LOG\n\tthis is needed by configure+sed to modify this file directly\n*/\n#define GPAC_ENABLE_LOG\n#endif\n\n/*!\n \\endcond\n*/\n\n\n/*this is all a bit ugly, but most compilers don't properly handle variadic macros...*/\nvoid gf_log(const char *fmt, ...);\nvoid gf_log_lt(GF_LOG_Level ll, GF_LOG_Tool lt);\nvoid gf_log_va_list(GF_LOG_Level level, GF_LOG_Tool tool, const char *fmt, va_list vl);\n\n\n/*!\n *\t\\brief Log level checking\n *\n *\tChecks if a given tool is logged for the given level\n *\t\\param log_tool tool to check\n *\t\\param log_level level to check\n *\t\\return 1 if logged, 0 otherwise\n*/\nBool gf_log_tool_level_on(GF_LOG_Tool log_tool, GF_LOG_Level log_level);\n\n/*!\n *\t\\brief Set log tools and levels\n *\n *\tSet log tools and levels according to the log_tools_levels string. All previous log settings are discarded.\n *\t\\param log_tools_levels string specifying the tools and levels. It is formatted as logToolX\\@logLevelX:logToolZ\\@logLevelZ:...\n *\t\\return GF_OK or GF_BAD_PARAM\n*/\nGF_Err gf_log_set_tools_levels(const char *log_tools_levels);\n\n/*!\n *\t\\brief Modify log tools and levels\n *\n *\tModify log tools and levels according to the log_tools_levels string. Previous log settings are kept.\n *\t\\param val string specifying the tools and levels. It is formatted as logToolX\\@logLevelX:logToolZ\\@logLevelZ:...\n *\t\\return GF_OK or GF_BAD_PARAM\n*/\nGF_Err gf_log_modify_tools_levels(const char *val);\n\n/*!\n *\t\\brief Set log level for a given tool\n *\n *\tSet log level for a given tool.\n *\t\\param tool tool to log\n *\t\\param level log level for this tool\n*/\nvoid gf_log_set_tool_level(GF_LOG_Tool tool, GF_LOG_Level level);\n\n#ifdef GPAC_DISABLE_LOG\n#define GF_LOG(_ll, _lm, __args)\n#else\n/*!\n *\t\\brief Message logging\n *\t\\hideinitializer\n *\n *\tMacro for logging messages. Usage is GF_LOG(log_lev, log_module, (fmt, ...)). The log function is only called if log filtering allows it. This avoids fetching logged parameters when the tool is not being logged.\n*/\n#define GF_LOG(_log_level, _log_tools, __args) if (gf_log_tool_level_on(_log_tools, _log_level) ) { gf_log_lt(_log_level, _log_tools); gf_log __args ;}\n#endif\n\n\n/*!\n *\t\\brief PseudoRandom Integer Generation Initialization\n *\n *\tSets the starting point for generating a series of pseudorandom integers.\n *\t\\param Reset Re-initializes the random number generator\n*/\nvoid gf_rand_init(Bool Reset);\n/*!\n *\t\\brief PseudoRandom Integer Generation\n *\n *\tReturns a pseudorandom integer.\n*/\nu32 gf_rand();\n\n/*!\n *\t\\brief user name\n *\n *\tGets current user (login) name.\n*/\nvoid gf_get_user_name(char *buf, u32 buf_size);\n\n\n/*!\\brief FileEnum info object\n *\n *The FileEnumInfo object is used to get file attributes upon enumeration of a directory.\n*/\ntypedef struct\n{\n\t/*!File is marked as hidden*/\n\tBool hidden;\n\t/*!File is a directory*/\n\tBool directory;\n\t/*!File is a drive mountpoint*/\n\tBool drive;\n\t/*!File is a system file*/\n\tBool system;\n\t/*!File size in bytes*/\n\tu64 size;\n\t/*!File last modif time in UTC seconds*/\n\tu64 last_modified;\n} GF_FileEnumInfo;\n\n/*!\n *\t\\brief Directory Enumeration Callback\n *\n * The gf_enum_dir_item type is the type for the callback of the \\ref gf_enum_directory function\n *\t\\param cbck Opaque user data.\n *\t\\param item_name File or directory name.\n *\t\\param item_path File or directory full path and name from filesystem root.\n *\t\\param file_info information for the file or directory.\n *\t\\return 1 to abort enumeration, 0 to continue enumeration.\n *\n */\ntypedef Bool (*gf_enum_dir_item)(void *cbck, char *item_name, char *item_path, GF_FileEnumInfo *file_info);\n/*!\n *\t\\brief Directory enumeration\n *\n *\tEnumerates a directory content. Feedback is provided by the enum_dir_item function\n *\t\\param dir Directory to enumerate\n *\t\\param enum_directory If set, only directories will be enumerated, otherwise only files are.\n *\t\\param enum_dir \\ref gf_enum_dir_item callback function for enumeration.\n *\t\\param cbck Opaque user data passed to callback function.\n *\t\\param filter optional filter for file extensions. If a file extension without the dot '.' character is not found in the\n *\tfilter the file will be skipped.\n*/\nGF_Err gf_enum_directory(const char *dir, Bool enum_directory, gf_enum_dir_item enum_dir, void *cbck, const char *filter);\n\n\n/*!\n *\t\\brief File Deletion\n *\n *\tDeletes a file from the disk.\n *\t\\param fileName absolute name of the file or name relative to the current working directory.\n*/\nGF_Err gf_delete_file(const char *fileName);\n\n/*!\n *\t\\brief File Move\n *\n *\tMoves or renames a file or directory.\n *\t\\param fileName absolute path of the file / directory to move or rename\n *\t\\param newFileName absolute new path/name of the file / directory\n*/\nGF_Err gf_move_file(const char *fileName, const char *newFileName);\n\n/*!\n *\t\\brief Temporary File Creation\n *\n *\tCreates a new temporary file in binary mode\n *\t\\param fileName if not NULL, strdup() of the temporary filename when created by GPAC (NULL otherwise as the system automatically removes its own tmp files)\n *\t\\return stream handle to the new file ressoucre\n */\nFILE *gf_temp_file_new(char ** const fileName);\n\n\n/*!\n *\t\\brief File Modification Time\n *\n *\tReturns the modification time of the given file. The exact meaning of this value is system dependent\n *\t\\param filename file to check\n *\t\\return modification time of the file\n */\nu64 gf_file_modification_time(const char *filename);\n\n/*!\n *\t\\brief File existence check\n *\n *\tMoves or renames a file or directory.\n *\t\\param fileName absolute path of the file / directory to move or rename\n *\t\\return GF_TRUE if file exists\n */\nBool gf_file_exists(const char *fileName);\n\n/*!\n *\t\\brief Progress formatting\n *\n *\tSignals progress in GPAC's operations. Note that progress signaling with this function is not thread-safe, the main purpose is to use it for authoring tools only.\n *\t\\param title title string of the progress, or NULL for no progress\n *\t\\param done Current amount performed of the action.\n *\t\\param total Total amount of the action.\n */\nvoid gf_set_progress(const char *title, u64 done, u64 total);\n\n/*!\n *\t\\brief Progress Callback\n *\n * The gf_on_progress_cbk type is the type for the callback of the \\ref gf_set_progress_callback function\n *\t\\param cbck Opaque user data.\n *\t\\param title preogress title.\n *\t\\param done Current amount performed of the action\n *\t\\param total Total amount of the action.\n *\n */\ntypedef void (*gf_on_progress_cbk)(const void *cbck, const char *title, u64 done, u64 total);\n\n/*!\n *\t\\brief Progress overwriting\n *\n *\tIverwrites the progress signaling function by a user-defined one.\n *\t\\param user_cbk Opaque user data\n *\t\\param prog_cbk new callback function to use. Passing NULL restore default GPAC stderr notification.\n */\nvoid gf_set_progress_callback(void *user_cbk, gf_on_progress_cbk prog_cbk);\n\n\n/*!\n *\t\\brief Prompt checking\n *\n *\tChecks if a character is pending in the prompt buffer.\n *\t\\return 1 if a character is ready to be fetched, 0 otherwise.\n *\t\\note Function not available under WindowsCE nor SymbianOS\n*/\nBool gf_prompt_has_input();\n\n/*!\n *\t\\brief Prompt character flush\n *\n *\tReturns the current character entered at prompt if any.\n *\t\\return value of the character.\n *\t\\note Function not available under WindowsCE nor SymbianOS\n*/\nchar gf_prompt_get_char();\n\n\n/*!\n *\t\\brief turns prompt echo on/off\n *\n *\tTurns the prompt character echo on/off - this is useful when entering passwords.\n *\t\\param echo_off indicates whether echo should be turned on or off.\n *\t\\note Function not available under WindowsCE nor SymbianOS\n*/\nvoid gf_prompt_set_echo_off(Bool echo_off);\n\n/*!\t@} */\n\n/*!\n *\\addtogroup cpu_grp System time CPU and Memory tools\n *\\ingroup utils_grp\n *\\brief System time CPU and Memory functions\n *\n *This section documents time functionalities and CPU management in GPAC.\n  *\t@{\n */\n\n/*!\n * Selection flags for memory tracker\n *\t\\hideinitializer\n */\ntypedef enum\n{\n    /*! No memory tracking*/\n    GF_MemTrackerNone = 0,\n    /*! Memory tracking without backtrace*/\n    GF_MemTrackerSimple,\n    /*! Memory tracking with backtrace*/\n    GF_MemTrackerBackTrace,\n} GF_MemTrackerType;\n\n/*!\n *\t\\brief System setup\n *\n *\tInits the system high-resolution clock if any, and CPU usage manager. It is strongly recommended to call this\n * function before calling any other GPAC functions, since on some systems (like winCE) it may result in a better memory usage estimation.\n *\t\\note This can be called several times but only the first call will result in system setup.\n */\nvoid gf_sys_init(GF_MemTrackerType mem_tracker_type);\n/*!\n *\t\\brief System closing\n *\n *\tCloses the system high-resolution clock and any CPU associated ressources.\n *\t\\note This can be called several times but the system will be closed when no more users are counted.\n */\nvoid gf_sys_close();\n\n/*!\n *\t\\brief System arguments\n *\n *\tSets the user app arguments (used by GUI mode)\n *\t\\param argc Number of arguments\n *\t\\param argv Array of arguments\n */\nvoid gf_sys_set_args(s32 argc, const char **argv);\n\n/*!\n *\t\\brief Get number of args\n *\n *\tGets the number of argument of the user application if any\n *\t\\return number of argument of the user application\n */\nu32 gf_sys_get_argc();\n\n/*!\n *\t\\brief Get number of args\n *\n *\tGets the number of argument of the user application if any\n *\t\\param arg Index of argument to retrieve\n *\t\\return number of argument of the user application\n */\nconst char *gf_sys_get_arg(u32 arg);\n\n/*!\n *\t\\brief System clock query\n *\n *\tGets the system clock time.\n *\t\\return System clock value since GPAC initialization in milliseconds.\n */\nu32 gf_sys_clock();\n\n/*!\n *\t\\brief High precision system clock query\n *\n *\tGets the hight precision system clock time.\n *\t\\return System clock value since GPAC initialization in microseconds.\n */\nu64 gf_sys_clock_high_res();\n\n/*!\n *\t\\brief Sleeps thread/process\n *\n *\tLocks calling thread/process execution for a given time.\n *\t\\param ms Amount of time to sleep in milliseconds.\n */\nvoid gf_sleep(u32 ms);\n\n#ifdef WIN32\n/*!\n *\t\\brief WINCE time constant\n *\t\\hideinitializer\n *\n *\ttime between jan 1, 1601 and jan 1, 1970 in units of 100 nanoseconds\n*/\n#define TIMESPEC_TO_FILETIME_OFFSET (((LONGLONG)27111902 << 32) + (LONGLONG)3577643008)\n\n#endif\n\n/*!\n *\\brief gets UTC time in milliseconds\n *\n * Gets UTC clock in milliseconds\n * \\return UTC time in milliseconds\n */\nu64 gf_net_get_utc();\n\n/*!\n *\\brief parses date and returns UTC value for this date. Date format is an XSD dateTime format or any of the supported formats from HTTP 1.1:\n\tSun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123\n\tSunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036\n\tSun Nov  6 08:49:37 1994       ; ANSI C's asctime() formatgets UTC time in milliseconds\n *\n * \\param date string containing the date to parse\n * \\return UTC time in milliseconds\n */\nu64 gf_net_parse_date(const char *date);\n\n/*!\n *\\brief gets timezone adjustment in seconds\n *\n * Gets timezone adjustment in seconds, with localtime - timezone = UTC time\n * \\return timezone shift in seconds\n */\ns32 gf_net_get_timezone();\n\n/*!\\brief run-time system info object\n *\n *The Run-Time Info object is used to get CPU and memory occupation of the calling process.\n *All time values are expressed in milliseconds (accuracy is not guaranteed).\n*/\ntypedef struct\n{\n\t/*!start of the sampling period*/\n\tu32 sampling_instant;\n\t/*!duration of the sampling period*/\n\tu32 sampling_period_duration;\n\t/*!total amount of time (User+kernel) spent in CPU for all processes as evaluated at the end of the sampling period*/\n\tu32 total_cpu_time;\n\t/*!total amount of time (User+kernel) spent in CPU for the calling process as evaluated at the end of the sampling period*/\n\tu32 process_cpu_time;\n\t/*!amount of time (User+kernel) spent in CPU for all processes during the sampling period*/\n\tu32 total_cpu_time_diff;\n\t/*!total amount of time (User+kernel) spent in CPU for the calling process during the sampling period*/\n\tu32 process_cpu_time_diff;\n\t/*!total amount of idle time during the sampling period.*/\n\tu32 cpu_idle_time;\n\t/*!percentage (from 0 to 100) of CPU usage during the sampling period.*/\n\tu32 total_cpu_usage;\n\t/*!percentage (from 0 to 100) of the CPU usage by the calling process during the sampling period.*/\n\tu32 process_cpu_usage;\n\t/*!calling process ID*/\n\tu32 pid;\n\t/*!calling process thread count if known*/\n\tu32 thread_count;\n\t/*!size of calling process allocated heaps*/\n\tu64 process_memory;\n\t/*!total physical memory in system*/\n\tu64 physical_memory;\n\t/*!available physical memory in system*/\n\tu64 physical_memory_avail;\n\t/*!total memory currently allocated by gpac*/\n\tu64 gpac_memory;\n\t/*!total number of cores on the system*/\n\tu32 nb_cores;\n} GF_SystemRTInfo;\n\n/*!\n * Selection flags for run-time info retrieval\n *\t\\hideinitializer\n */\nenum\n{\n\t/*!Indicates all processes' times must be fetched. If not set, only the current process times will be retrieved, and the\n\tthread count and total times won't be available*/\n\tGF_RTI_ALL_PROCESSES_TIMES = 1,\n\t/*!Indicates the process allocated heap size must be fetch. If not set, only the system physical memory is fetched.\n\tFetching the entire ocess  allocated memory can have a large impact on performances*/\n\tGF_RTI_PROCESS_MEMORY = 1<<1,\n\t/*!Indicates that only system memory should be fetched. When set, all refreshing info is ignored*/\n\tGF_RTI_SYSTEM_MEMORY_ONLY = 1<<2\n};\n\n/*!\n *\t\\brief Gets Run-Time info\n *\n *\tGets CPU and memory usage info for the calling process and the system. Information gathering\n * is controled through timeout values.\n *\t\\param refresh_time_ms refresh time period in milliseconds. If the last sampling was done less than this period ago, the run-time info is not refreshed.\n *\t\\param rti holder to the run-time info structure to update.\n *\t\\param flags specify which info is to be retrieved.\n *\t\\return 1 if info has been updated, 0 otherwise.\n *\t\\note You should not try to use a too small refresh time. Typical values are 500 ms or one second.\n */\nBool gf_sys_get_rti(u32 refresh_time_ms, GF_SystemRTInfo *rti, u32 flags);\n\n\nBool gf_sys_get_battery_state(Bool *onBattery, u32 *onCharge, u32 *level, u32 *batteryLifeTime, u32 *batteryFullLifeTime);\n\ntypedef struct _GF_GlobalLock_opaque GF_GlobalLock;\n\n/*!\n * This function allows the user to create a global lock for all GPAC instances.\n * This allow to disable some features for other instances for instance.\n * \\param resourceName The name of the resource to lock\n * \\return false if resource has been locked, true if resource could not be locked\n */\nGF_GlobalLock * gf_global_resource_lock(const char * resourceName);\n\n/*!\n * Unlock a previouly locked resource\n * \\param lock The resource to unlock\n * \\return GF_OK if evertything went fine\n */\nGF_Err gf_global_resource_unlock(GF_GlobalLock * lock);\n\n/*!\t@} */\n\n/*!\n *\\addtogroup osfile_grp File System\n *\\ingroup utils_grp\n *\\brief File System tools\n *\n *This section documents time functionalities and CPU management in GPAC.\n  *\t@{\n */\n\n\n\n/*!\n *\\brief parses 128 bit from string\n *\n * Parses 128 bit from string\n *\n * \\param string the string containing the value in hexa. Non alphanum characters are skipped\n * \\param value the value parsed\n * \\return error code if any\n */\nGF_Err gf_bin128_parse(const char *string, bin128 value);\n\n/*!\n *\t\\brief Delete Directory\n *\n *\tDelete a  dir within the full path.\n *\t\\param DirPathName the file path name.\n */\nGF_Err gf_rmdir(const char *DirPathName);\n\n/*!\n *\t\\brief Create Directory\n *\n *\tCreate a directory within the full path.\n *\t\\param DirPathName the dir path name.\n */\nGF_Err gf_mkdir(const char* DirPathName);\n\n/*!\n *\t\\brief Check Directory Exists\n *\n *\tCreate a directory within the full path.\n *\t\\param DirPathName the dir path name.\n */\nBool gf_dir_exists(const char *DirPathName);\n\n/*!\n *\t\\brief Create Directory\n *\n *\tCleanup a directory within the full path, removing all the files and the directories.\n *\t\\param DirPathName the dir path name.\n */\nGF_Err gf_cleanup_dir(const char* DirPathName);\n\n\n/**\n * Gets a newly allocated string containing the default cache directory.\n * It is the responsibility of the caller to free the string.\n * \\return a fully qualified path to the default cache directory\n */\nchar * gf_get_default_cache_directory();\n\n/**\n * Gets the number of open file handles (gf_fopen/gf_fclose only).\n * \\return  number of open file handles\n */\nu32 gf_file_handles_count();\n\n/*!\t@} */\n\n/*!\n *\\addtogroup hash_grp RawData Misc\n *\\ingroup utils_grp\n *\\brief Data integrity and parsing\n *\n *This section documents misc data functions such as integrity and parsing such as SHA-1 hashing CRC checksum, 128 bit ID parsing...\n  *\t@{\n */\n\n\n/*!\n *\t\\brief CRC32 compute\n *\n *\tComputes the CRC32 value of a buffer.\n *\t\\param data buffer\n *\t\\param size buffer size\n *\t\\return computed CRC32\n */\nu32 gf_crc_32(const char *data, u32 size);\n\n\n/**\n * Compresses a data buffer in place using zlib. Buffer may be reallocated in the process.\n * \\param data pointer to the data buffer to be compressed\n * \\param data_len length of the data buffer to be compressed\n * \\param out_size pointer for output buffer size\n * \\return GF_OK if evertything went fine\n */\nGF_Err gf_gz_compress_payload(char **data, u32 data_len, u32 *out_size);\n\n/**\n * Decompresses a data buffer using zlib.\n * \\param data data buffer to be decompressed\n * \\param data_len length of the data buffer to be decompressed\n * \\param uncompressed_data pointer to the uncompressed data buffer. It is the responsibility of the caller to free this buffer.\n * \\param out_size size of the uncompressed buffer\n * \\return GF_OK if evertything went fine\n */\nGF_Err gf_gz_decompress_payload(char *data, u32 data_len, char **uncompressed_data, u32 *out_size);\n\n\n/*SHA1*/\ntypedef struct __sha1_context GF_SHA1Context;\n\n#define GF_SHA1_DIGEST_SIZE\t\t20\n#define GF_SHA1_DIGEST_SIZE_HEXA\t\t41\n/*  Create SHA-1 context */\nGF_SHA1Context *gf_sha1_starts();\n/*  Adds byte to the SHA-1 context */\nvoid gf_sha1_update(GF_SHA1Context *ctx, u8 *input, u32 length);\n/*  Generates SHA-1 of all bytes ingested */\nvoid gf_sha1_finish(GF_SHA1Context *ctx, u8 digest[GF_SHA1_DIGEST_SIZE] );\n\n/*\n * Output SHA-1(file contents), returns 0 if successful.\n */\nint gf_sha1_file(const char *filename, u8 digest[GF_SHA1_DIGEST_SIZE]);\n\n/*\n * Gets SHA-1 of input buffer\n */\nvoid gf_sha1_csum(u8 *buf, u32 buflen, u8 digest[GF_SHA1_DIGEST_SIZE]);\n/*\n * Gets SHA-1 of input buffer into hexa form\n */\nvoid gf_sha1_csum_hexa(u8 *buf, u32 buflen, u8 digest[GF_SHA1_DIGEST_SIZE_HEXA]);\n\n/*! @} */\n\n\n/* \\cond dummy */\n#ifdef GPAC_ANDROID\ntypedef void (*fm_callback_func)(void *cbk_obj, u32 type, u32 param, int *value);\nextern void gf_fm_request_set_callback(void *cbk_obj, fm_callback_func cbk_func);\nvoid gf_fm_request_call(u32 type, u32 param, int *value);\n#endif //GPAC_ANDROID\n\n/* \\endcond */\n\n#define ARRAY_LENGTH(a) (sizeof(a) / sizeof((a)[0]))\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif\t\t/*_GF_CORE_H_*/\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n#include <gpac/internal/media_dev.h>\n#endif\n\n#ifndef GPAC_DISABLE_ISOM\n\n\nBool gf_isom_is_nalu_based_entry(GF_MediaBox *mdia, GF_SampleEntryBox *_entry)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (mdia->handler->handlerType != GF_ISOM_MEDIA_VISUAL) return GF_FALSE;\n\tswitch (_entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_SVC2:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC2:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_MHV1:\n\tcase GF_ISOM_BOX_TYPE_MHC1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_LHT1:\n\t\treturn GF_TRUE;\n\tcase GF_ISOM_BOX_TYPE_GNRV:\n\tcase GF_ISOM_BOX_TYPE_GNRA:\n\tcase GF_ISOM_BOX_TYPE_GNRM:\n\t\treturn GF_FALSE;\n\tdefault:\n\t\tbreak;\n\t}\n\tentry = (GF_MPEGVisualSampleEntryBox*)_entry;\n\tif (!entry) return GF_FALSE;\n\tif (entry->avc_config || entry->svc_config || entry->mvc_config || entry->hevc_config || entry->lhvc_config) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\n\nstatic void rewrite_nalus_list(GF_List *nalus, GF_BitStream *bs, Bool rewrite_start_codes, u32 nal_unit_size_field)\n{\n\tu32 i, count = gf_list_count(nalus);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot*)gf_list_get(nalus, i);\n\t\tif (rewrite_start_codes) gf_bs_write_u32(bs, 1);\n\t\telse gf_bs_write_int(bs, sl->size, 8*nal_unit_size_field);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n}\n\n\nstatic GF_Err process_extractor(GF_ISOFile *file, GF_MediaBox *mdia, u32 sampleNumber, u64 sampleDTS, u32 nal_size, u16 nal_hdr, u32 nal_unit_size_field, Bool is_hevc, Bool rewrite_ps, Bool rewrite_start_codes, GF_BitStream *src_bs, GF_BitStream *dst_bs, u32 extractor_mode)\n{\n\tGF_Err e;\n\tu32 di, ref_track_index, ref_track_num, data_offset, data_length, cur_extract_mode, ref_extract_mode, ref_nalu_size, nb_bytes_nalh;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_ISOSample *ref_samp;\n\tGF_BitStream *ref_bs;\n\tGF_TrackBox *ref_trak;\n\ts8 sample_offset;\n\tchar*buffer = NULL;\n\tu32 max_size = 0;\n\tu32 last_byte, ref_sample_num, prev_ref_sample_num;\n\tBool header_written = GF_FALSE;\n\tnb_bytes_nalh = is_hevc ? 2 : 1;\n\n\tswitch (extractor_mode) {\n\tcase 0:\n\t\tlast_byte = (u32) gf_bs_get_position(src_bs) + nal_size - (is_hevc ? 2 : 1);\n\t\tif (!is_hevc) gf_bs_read_int(src_bs, 24); //1 byte for HEVC , 3 bytes for AVC of NALUHeader in extractor\n\t\twhile (gf_bs_get_position(src_bs) < last_byte) {\n\t\t\tu32 xmode = 0;\n\t\t\t//hevc extractors use constructors\n\t\t\tif (is_hevc) xmode = gf_bs_read_u8(src_bs);\n\t\t\tif (xmode) {\n\t\t\t\tu8 done=0, len = gf_bs_read_u8(src_bs);\n\t\t\t\twhile (done<len) {\n\t\t\t\t\tu8 c = gf_bs_read_u8(src_bs);\n\t\t\t\t\tdone++;\n\t\t\t\t\tif (header_written) {\n\t\t\t\t\t\tgf_bs_write_u8(dst_bs, c);\n\t\t\t\t\t} else if (done==nal_unit_size_field) {\n\t\t\t\t\t\tif (rewrite_start_codes) {\n\t\t\t\t\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_bs_write_u8(dst_bs, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\theader_written = GF_TRUE;\n\t\t\t\t\t} else if (!rewrite_start_codes) {\n\t\t\t\t\t\tgf_bs_write_u8(dst_bs, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tref_track_index = gf_bs_read_u8(src_bs);\n\t\t\tsample_offset = (s8) gf_bs_read_int(src_bs, 8);\n\t\t\tdata_offset = gf_bs_read_int(src_bs, nal_unit_size_field*8);\n\t\t\tdata_length = gf_bs_read_int(src_bs, nal_unit_size_field*8);\n\n\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &dpnd);\n\t\t\tref_track_num = 0;\n\t\t\tif (dpnd && ref_track_index && (ref_track_index<=dpnd->trackIDCount))\n\t\t\t\tref_track_num = gf_isom_get_track_by_id(file, dpnd->trackIDs[ref_track_index-1]);\n\n\t\t\tif (!ref_track_num) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"ISOBMF: Extractor target track is not present in file - skipping.\\n\"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\n\t\t\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, ref_track_num);\n\n\t\t\t//we must be in inspect mode only otherwise the reference sample will not be the one stored on file (change in start codes, PS inserted or other NALUs inserted)\n\t\t\t//and this will corrupt extraction (wrong data offsets)\n\t\t\tref_extract_mode = GF_ISOM_NALU_EXTRACT_INSPECT;\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, ref_extract_mode);\n\n\t\t\tref_trak = gf_isom_get_track_from_file(file, ref_track_num);\n\t\t\tif (!ref_trak) return GF_ISOM_INVALID_FILE;\n\n\t\t\tref_samp = gf_isom_sample_new();\n\t\t\tif (!ref_samp) return GF_IO_ERR;\n\n\t\t\te = stbl_findEntryForTime(ref_trak->Media->information->sampleTable, sampleDTS, 0, &ref_sample_num, &prev_ref_sample_num);\n\t\t\tif (e) return e;\n\t\t\tif (!ref_sample_num) ref_sample_num = prev_ref_sample_num;\n\t\t\tif (!ref_sample_num) return GF_ISOM_INVALID_FILE;\n\t\t\tif ((sample_offset<0) && (ref_sample_num > (u32) -sample_offset)) return GF_ISOM_INVALID_FILE;\n\t\t\tref_sample_num = (u32) ( (s32) ref_sample_num + sample_offset);\n\n\t\t\te = Media_GetSample(ref_trak->Media, ref_sample_num, &ref_samp, &di, GF_FALSE, NULL);\n\t\t\tif (e) return e;\n\n#if 0\n\t\t\tif (!header_written && rewrite_start_codes) {\n\t\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\t\tif (is_hevc) {\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 1);\n\t\t\t\t\tgf_bs_write_int(dst_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 9);\n\t\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\t\tgf_bs_write_int(dst_bs, 2, 3);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 5);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_int(dst_bs, (ref_samp->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0xF0 , 8); /*7 \"all supported NALUs\" (=111) + rbsp trailing (10000)*/;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tref_bs = gf_bs_new(ref_samp->data + data_offset, ref_samp->dataLength - data_offset, GF_BITSTREAM_READ);\n\n\t\t\tif (ref_samp->dataLength - data_offset >= data_length) {\n\n\t\t\t\twhile (data_length && gf_bs_available(ref_bs)) {\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tref_nalu_size = gf_bs_read_int(ref_bs, 8*nal_unit_size_field);\n\n\t\t\t\t\t\tif (!data_length)\n\t\t\t\t\t\t\tdata_length = ref_nalu_size + nal_unit_size_field;\n\n\t\t\t\t\t\tassert(data_length>nal_unit_size_field);\n\t\t\t\t\t\tdata_length -= nal_unit_size_field;\n\t\t\t\t\t\tif (data_length > gf_bs_available(ref_bs)) {\n\t\t\t\t\t\t\tdata_length = (u32)gf_bs_available(ref_bs);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tref_nalu_size = data_length;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ref_nalu_size > max_size) {\n\t\t\t\t\t\tbuffer = (char*) gf_realloc(buffer, sizeof(char) * ref_nalu_size );\n\t\t\t\t\t\tmax_size = ref_nalu_size;\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_data(ref_bs, buffer, ref_nalu_size);\n\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\t\t\tgf_bs_write_u32(dst_bs, 1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgf_bs_write_int(dst_bs, ref_nalu_size, 8*nal_unit_size_field);\n\t\t\t\t\t}\n\t\t\t\t\tassert(data_length >= ref_nalu_size);\n\t\t\t\t\tgf_bs_write_data(dst_bs, buffer, ref_nalu_size);\n\t\t\t\t\tdata_length -= ref_nalu_size;\n\n\t\t\t\t\theader_written = GF_FALSE;\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Extractor size is larger than refered sample size - skipping.\\n\"));\n\t\t\t}\n\t\t\tgf_isom_sample_del(&ref_samp);\n\t\t\tref_samp = NULL;\n\t\t\tgf_bs_del(ref_bs);\n\t\t\tref_bs = NULL;\n\t\t\tif (buffer) gf_free(buffer);\n\t\t\tbuffer = NULL;\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, cur_extract_mode);\n\n\t\t\tif (!is_hevc) break;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\t//skip to end of this NALU\n\t\tgf_bs_skip_bytes(src_bs, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\tcase 2:\n\t\tbuffer = (char*) gf_malloc( sizeof(char) * (nal_size - nb_bytes_nalh));\n\t\tgf_bs_read_data(src_bs, buffer, nal_size - nb_bytes_nalh);\n\t\tif (rewrite_start_codes)\n\t\t\tgf_bs_write_u32(dst_bs, 1);\n\t\telse\n\t\t\tgf_bs_write_int(dst_bs, nal_size, 8*nal_unit_size_field);\n\n\t\tgf_bs_write_u8(dst_bs, nal_hdr);\n\t\tgf_bs_write_data(dst_bs, buffer, nal_size - nb_bytes_nalh);\n\t\tgf_free(buffer);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_HEVC\n/* returns the SAP type as defined in the 14496-12 specification */\nstatic SAPType sap_type_from_nal_type(u8 nal_type) {\n\tswitch (nal_type) {\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\treturn SAP_TYPE_3;\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\treturn SAP_TYPE_1;\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\treturn SAP_TYPE_2;\n\tdefault:\n\t\treturn RAP_NO;\n\t}\n}\n#endif\n\nstatic SAPType is_sample_idr(GF_ISOSample *sample, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tBool is_hevc = GF_FALSE;\n\tu32 nalu_size_field = 0;\n\tGF_BitStream *bs;\n\tif (entry->avc_config && entry->avc_config->config) nalu_size_field = entry->avc_config->config->nal_unit_size;\n\telse if (entry->svc_config && entry->svc_config->config) nalu_size_field = entry->svc_config->config->nal_unit_size;\n\telse if (entry->mvc_config && entry->mvc_config->config) nalu_size_field = entry->mvc_config->config->nal_unit_size;\n\telse if (entry->hevc_config && entry->hevc_config->config) {\n\t\tnalu_size_field = entry->hevc_config->config->nal_unit_size;\n\t\tis_hevc = GF_TRUE;\n\t}\n\telse if (entry->lhvc_config && entry->lhvc_config->config) {\n\t\tnalu_size_field = entry->lhvc_config->config->nal_unit_size;\n\t\tis_hevc = GF_TRUE;\n\t}\n\tif (!nalu_size_field) return RAP_NO;\n\n\tbs = gf_bs_new(sample->data, sample->dataLength, GF_BITSTREAM_READ);\n\tif (!bs) return RAP_NO;\n\n\twhile (gf_bs_available(bs)) {\n\t\tu8 nal_type;\n\t\tu32 size = gf_bs_read_int(bs, 8*nalu_size_field);\n\n\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tu16 nal_hdr = gf_bs_read_u16(bs);\n\t\t\tnal_type = (nal_hdr&0x7E00) >> 9;\n\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn SAP_TYPE_3;\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn SAP_TYPE_1;\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn SAP_TYPE_2;\n\t\t\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\t\t\tcase GF_HEVC_NALU_FILLER_DATA:\n\t\t\tcase GF_HEVC_NALU_SEI_PREFIX:\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn RAP_NO;\n\t\t\t}\n\t\t\tgf_bs_skip_bytes(bs, size - 2);\n#endif\n\t\t} else {\n\t\t\tu8 nal_hdr = gf_bs_read_u8(bs);\n\t\t\tnal_type = nal_hdr & 0x1F;\n\n\t\t\tswitch (nal_type) {\n\t\t\t/*\t\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\t\t\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\t\t\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\t\t\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t*/\t\t\tcase GF_AVC_NALU_IDR_SLICE:\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn SAP_TYPE_1;\n\t\t\tcase GF_AVC_NALU_ACCESS_UNIT:\n\t\t\tcase GF_AVC_NALU_FILLER_DATA:\n\t\t\tcase GF_AVC_NALU_SEI:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn RAP_NO;\n\t\t\t}\n\t\t\tgf_bs_skip_bytes(bs, size - 1);\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\treturn RAP_NO;\n}\n\nstatic void nalu_merge_ps(GF_BitStream *ps_bs, Bool rewrite_start_codes, u32 nal_unit_size_field, GF_MPEGVisualSampleEntryBox *entry, Bool is_hevc)\n{\n\tu32 i, count;\n\tif (is_hevc) {\n\t\tif (entry->hevc_config) {\n\t\t\tcount = gf_list_count(entry->hevc_config->config->param_array);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_HEVCParamArray *ar = (GF_HEVCParamArray*)gf_list_get(entry->hevc_config->config->param_array, i);\n\t\t\t\trewrite_nalus_list(ar->nalus, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\t}\n\t\t}\n\t\tif (entry->lhvc_config) {\n\t\t\tcount = gf_list_count(entry->lhvc_config->config->param_array);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_HEVCParamArray *ar = (GF_HEVCParamArray*)gf_list_get(entry->lhvc_config->config->param_array, i);\n\t\t\t\trewrite_nalus_list(ar->nalus, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (entry->avc_config) {\n\t\t\trewrite_nalus_list(entry->avc_config->config->sequenceParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->avc_config->config->sequenceParameterSetExtensions, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->avc_config->config->pictureParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t}\n\n\t\t/*add svc config */\n\t\tif (entry->svc_config) {\n\t\t\trewrite_nalus_list(entry->svc_config->config->sequenceParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->svc_config->config->pictureParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t}\n\t\t/*add mvc config */\n\t\tif (entry->mvc_config) {\n\t\t\trewrite_nalus_list(entry->mvc_config->config->sequenceParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t\trewrite_nalus_list(entry->mvc_config->config->pictureParameterSets, ps_bs, rewrite_start_codes, nal_unit_size_field);\n\t\t}\n\t}\n}\n\n\nGF_Err gf_isom_nalu_sample_rewrite(GF_MediaBox *mdia, GF_ISOSample *sample, u32 sampleNumber, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tBool is_hevc = GF_FALSE;\n\t//if only one sync given in the sample sync table, insert sps/pps/vps before cra/bla in hevc\n//\tBool check_cra_bla = (mdia->information->sampleTable->SyncSample && mdia->information->sampleTable->SyncSample->nb_entries>1) ? 0 : 1;\n\tBool check_cra_bla = GF_TRUE;\n\tBool insert_nalu_delim = GF_TRUE;\n\tBool force_sei_inspect = GF_FALSE;\n\tGF_Err e = GF_OK;\n\tGF_ISOSample *ref_samp;\n\tGF_BitStream *src_bs, *ref_bs, *dst_bs, *ps_bs, *sei_suffix_bs;\n\tu32 nal_size, max_size, nal_unit_size_field, extractor_mode;\n\tBool rewrite_ps, rewrite_start_codes, insert_vdrd_code;\n\ts8 nal_type;\n\tu32 nal_hdr, sabt_ref, i, track_num;\n\tu32 temporal_id = 0;\n\tchar *buffer;\n\tGF_ISOFile *file = mdia->mediaTrack->moov->mov;\n\tGF_TrackReferenceTypeBox *scal = NULL;\n\n\tsrc_bs = ref_bs = dst_bs = ps_bs = sei_suffix_bs = NULL;\n\tref_samp = NULL;\n\tbuffer = NULL;\n\n\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &scal);\n\n\trewrite_ps = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG) ? GF_TRUE : GF_FALSE;\n\trewrite_start_codes = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_ANNEXB_FLAG) ? GF_TRUE : GF_FALSE;\n\tinsert_vdrd_code = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_VDRD_FLAG) ? GF_TRUE : GF_FALSE;\n\tif (!entry->svc_config && !entry->mvc_config && !entry->lhvc_config) insert_vdrd_code = GF_FALSE;\n\textractor_mode = mdia->mediaTrack->extractor_mode&0x0000FFFF;\n\n\tif (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) {\n\t\tinsert_nalu_delim = GF_FALSE;\n\t}\n\n\ttrack_num = 1 + gf_list_find(mdia->mediaTrack->moov->trackList, mdia->mediaTrack);\n\n\tif ( (extractor_mode != GF_ISOM_NALU_EXTRACT_INSPECT) && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) ) {\n\t\tu32 ref_track, di;\n\t\t//aggregate all sabt samples with the same DTS\n\t\tif (entry->lhvc_config && !entry->hevc_config && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_LAYER_ONLY)) {\n\t\t\tGF_ISOSample *base_samp;\n\t\t\tif (gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SCAL) <= 0) {\n\t\t\t\t//FIXME - for now we only support two layers (base + enh) in implicit\n\t\t\t\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE) >= 1) {\n\t\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE, 1, &ref_track);\n\t\t\t\t\tswitch (gf_isom_get_media_subtype(mdia->mediaTrack->moov->mov , ref_track, 1)) {\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\n\t\t\t\t\t\tbase_samp = gf_isom_get_sample(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di);\n\t\t\t\t\t\tif (base_samp && base_samp->data) {\n\t\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+base_samp->dataLength);\n\t\t\t\t\t\t\tmemmove(sample->data + base_samp->dataLength, sample->data , sample->dataLength);\n\t\t\t\t\t\t\tmemcpy(sample->data, base_samp->data, base_samp->dataLength);\n\t\t\t\t\t\t\tsample->dataLength += base_samp->dataLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (base_samp) gf_isom_sample_del(&base_samp);\n\t\t\t\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_BASE, &scal);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsabt_ref = gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT);\n\t\tif ((s32) sabt_ref > 0) {\n\t\t\tforce_sei_inspect = GF_TRUE;\n\t\t\tfor (i=0; i<sabt_ref; i++) {\n\t\t\t\tGF_ISOSample *tile_samp;\n\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT, i+1, &ref_track);\n\t\t\t\ttile_samp = gf_isom_get_sample(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di);\n\t\t\t\tif (tile_samp  && tile_samp ->data) {\n\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+tile_samp->dataLength);\n\t\t\t\t\tmemcpy(sample->data + sample->dataLength, tile_samp->data, tile_samp->dataLength);\n\t\t\t\t\tsample->dataLength += tile_samp->dataLength;\n\t\t\t\t}\n\t\t\t\tif (tile_samp) gf_isom_sample_del(&tile_samp);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS) >= 1) {\n\t\tu32 ref_track;\n\t\tu32 idx = gf_list_find(mdia->information->sampleTable->SampleDescription->other_boxes, entry);\n\t\tGF_TrackBox *tbas;\n\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\ttbas = (GF_TrackBox *)gf_list_get(mdia->mediaTrack->moov->trackList, ref_track-1);\n\t\tentry = gf_list_get(tbas->Media->information->sampleTable->SampleDescription->other_boxes, idx);\n\t}\n\n\n\tif (sample->IsRAP < SAP_TYPE_2) {\n\t\tif (mdia->information->sampleTable->no_sync_found || (!sample->IsRAP && check_cra_bla) ) {\n\t\t\tsample->IsRAP = is_sample_idr(sample, entry);\n\t\t}\n\t}\n\tif (!sample->IsRAP)\n\t\trewrite_ps = GF_FALSE;\n\n\tif (extractor_mode != GF_ISOM_NALU_EXTRACT_LAYER_ONLY)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\t//this is a compatible HEVC, don't insert VDRD, insert NALU delim\n\tif (entry->lhvc_config && entry->hevc_config)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_INSPECT) {\n\t\tif (!rewrite_ps && !rewrite_start_codes)\n\t\t\treturn GF_OK;\n\t}\n\n\tif (!entry) return GF_BAD_PARAM;\n\tnal_unit_size_field = 0;\n\t/*if svc rewrite*/\n\tif (entry->svc_config && entry->svc_config->config)\n\t\tnal_unit_size_field = entry->svc_config->config->nal_unit_size;\n\t/*if mvc rewrite*/\n\tif (entry->mvc_config && entry->mvc_config->config)\n\t\tnal_unit_size_field = entry->mvc_config->config->nal_unit_size;\n\n\t/*if lhvc rewrite*/\n\telse if (entry->lhvc_config && entry->lhvc_config->config)  {\n\t\tis_hevc = GF_TRUE;\n\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t}\n\n\t/*otherwise do nothing*/\n\telse if (!rewrite_ps && !rewrite_start_codes && !scal && !force_sei_inspect) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!nal_unit_size_field) {\n\t\tif (entry->avc_config) nal_unit_size_field = entry->avc_config->config->nal_unit_size;\n\t\telse if (entry->hevc_config || entry->lhvc_config ) {\n\t\t\tnal_unit_size_field = entry->lhvc_config ? entry->lhvc_config->config->nal_unit_size : entry->hevc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t}\n\n\tif (!nal_unit_size_field) return GF_ISOM_INVALID_FILE;\n\n\tdst_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tps_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tsrc_bs = gf_bs_new(sample->data, sample->dataLength, GF_BITSTREAM_READ);\n\tif (!src_bs && sample->data) return GF_ISOM_INVALID_FILE;\n\tmax_size = 4096;\n\n\t/*rewrite start code with NALU delim*/\n\tif (rewrite_start_codes) {\n\n\t\t//we are SVC, don't write NALU delim, only insert VDRD NALU\n\t\tif (insert_vdrd_code) {\n\t\t\tif (is_hevc) {\n\t\t\t\t//spec is not clear here, we don't insert an NALU AU delimiter before the layer starts since it breaks openHEVC\n//\t\t\t\tinsert_nalu_delim=0;\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\t\tgf_bs_write_int(dst_bs, GF_AVC_NALU_VDRD , 8);\n\t\t\t\tinsert_nalu_delim=0;\n\t\t\t}\n\t\t}\n\n\t\t//AVC/HEVC base, insert NALU delim\n\t\tif (insert_nalu_delim) {\n\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\tgf_bs_write_int(dst_bs, 0, 1);\n\t\t\t\tgf_bs_write_int(dst_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\tgf_bs_write_int(dst_bs, insert_vdrd_code ? 1 : 0, 6); //we should pick the layerID of the following nalus ...\n\t\t\t\tgf_bs_write_int(dst_bs, 1, 3); //nuh_temporal_id_plus1 - cannot be 0, we use 1 by default, and overwrite it if needed at the end\n\n\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\tgf_bs_write_int(dst_bs, 2, 3);\n\t\t\t\tgf_bs_write_int(dst_bs, 0, 5);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(dst_bs, (sample->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\tgf_bs_write_int(dst_bs, 0xF0 , 8); /*7 \"all supported NALUs\" (=111) + rbsp trailing (10000)*/;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rewrite_ps) {\n\t\t//in inspect mode or single-layer mode just use the xPS from this layer\n\t\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_DEFAULT) {\n\t\t\tu32 i;\n\n\t\t\tif (scal) {\n\t\t\t\tfor (i=0; i<scal->trackIDCount; i++) {\n\t\t\t\t\tGF_TrackBox *a_track = GetTrackbyID(mdia->mediaTrack->moov, scal->trackIDs[i]);\n\t\t\t\t\tGF_MPEGVisualSampleEntryBox *an_entry = NULL;\n\t\t\t\t\tif (a_track && a_track->Media && a_track->Media->information && a_track->Media->information->sampleTable && a_track->Media->information->sampleTable->SampleDescription)\n\t\t\t\t\t\tan_entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(a_track->Media->information->sampleTable->SampleDescription->other_boxes, 0);\n\n\t\t\t\t\tif (an_entry)\n\t\t\t\t\t\tnalu_merge_ps(ps_bs, rewrite_start_codes, nal_unit_size_field, an_entry, is_hevc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnalu_merge_ps(ps_bs, rewrite_start_codes, nal_unit_size_field, entry, is_hevc);\n\n\n\t\tif (is_hevc) {\n\t\t\t/*little optimization if we are not asked to start codes: copy over the sample*/\n\t\t\tif (!rewrite_start_codes && !entry->lhvc_config && !scal) {\n\t\t\t\tif (ps_bs) {\n\t\t\t\t\tu8 nal_type = (sample->data[nal_unit_size_field] & 0x7E) >> 1;\n\t\t\t\t\t//temp fix - if we detect xPS in the beginning of the sample do NOT copy the ps bitstream\n\t\t\t\t\t//this is not correct since we are not sure whether they are the same xPS or not, but it crashes openHEVC ...\n\t\t\t\t\tswitch (nal_type) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\t\t\tbreak;\n#endif\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgf_bs_transfer(dst_bs, ps_bs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_del(ps_bs);\n\t\t\t\t\tps_bs = NULL;\n\t\t\t\t}\n\t\t\t\tgf_bs_write_data(dst_bs, sample->data, sample->dataLength);\n\t\t\t\tgf_free(sample->data);\n\t\t\t\tsample->data = NULL;\n\t\t\t\tgf_bs_get_content(dst_bs, &sample->data, &sample->dataLength);\n\t\t\t\tgf_bs_del(src_bs);\n\t\t\t\tgf_bs_del(dst_bs);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*little optimization if we are not asked to rewrite extractors or start codes: copy over the sample*/\n\tif (!scal && !rewrite_start_codes && !rewrite_ps && !force_sei_inspect) {\n\t\tif (ps_bs)\n\t\t{\n\t\t\tgf_bs_transfer(dst_bs, ps_bs);\n\t\t\tgf_bs_del(ps_bs);\n\t\t\tps_bs = NULL;\n\t\t}\n\t\tgf_bs_write_data(dst_bs, sample->data, sample->dataLength);\n\t\tgf_free(sample->data);\n\t\tsample->data = NULL;\n\t\tgf_bs_get_content(dst_bs, &sample->data, &sample->dataLength);\n\t\tgf_bs_del(src_bs);\n\t\tgf_bs_del(dst_bs);\n\t\treturn GF_OK;\n\t}\n\n\tbuffer = (char *)gf_malloc(sizeof(char)*max_size);\n\n\twhile (gf_bs_available(src_bs)) {\n\t\tnal_size = gf_bs_read_int(src_bs, 8*nal_unit_size_field);\n\t\tif (gf_bs_get_position(src_bs) + nal_size > sample->dataLength) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Sample %u (size %u) rewrite: corrupted NAL Unit (size %u)\\n\", sampleNumber, sample->dataLength, nal_size));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (nal_size>max_size) {\n\t\t\tbuffer = (char*) gf_realloc(buffer, sizeof(char)*nal_size);\n\t\t\tmax_size = nal_size;\n\t\t}\n\t\tif (is_hevc) {\n\t\t\tnal_hdr = gf_bs_read_u16(src_bs);\n\t\t\tnal_type = (nal_hdr&0x7E00) >> 9;\n\t\t} else {\n\t\t\tnal_hdr = gf_bs_read_u8(src_bs);\n\t\t\tnal_type = nal_hdr & 0x1F;\n\t\t}\n\n\t\tif (is_hevc) {\n\t\t\tGF_BitStream *write_to_bs = dst_bs;\n\t\t\tif (ps_bs) {\n\t\t\t\tgf_bs_transfer(dst_bs, ps_bs);\n\t\t\t\tgf_bs_del(ps_bs);\n\t\t\t\tps_bs = NULL;\n\t\t\t}\n\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t/*we already wrote this stuff*/\n\t\t\tif (nal_type==GF_HEVC_NALU_ACCESS_UNIT) {\n\t\t\t\tgf_bs_skip_bytes(src_bs, nal_size-2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (nal_type) {\n\t\t\t//extractor\n\t\t\tcase 49:\n\t\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_TRUE, rewrite_ps, rewrite_start_codes, src_bs, dst_bs, extractor_mode);\n\t\t\t\tif (e) goto exit;\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\t\t\t\tif (temporal_id < (nal_hdr & 0x7))\n\t\t\t\t\ttemporal_id = (nal_hdr & 0x7);\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tgf_bs_read_data(src_bs, buffer, nal_size-2);\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(dst_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(dst_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(dst_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(dst_bs, buffer, nal_size-2);\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\t//insert xPS before CRA/BLA\n\t\t\t\tif (check_cra_bla && !sample->IsRAP) {\n\t\t\t\t\tif (ref_samp) gf_isom_sample_del(&ref_samp);\n\t\t\t\t\tif (src_bs) gf_bs_del(src_bs);\n\t\t\t\t\tif (ref_bs) gf_bs_del(ref_bs);\n\t\t\t\t\tif (dst_bs) gf_bs_del(dst_bs);\n\t\t\t\t\tif (buffer) gf_free(buffer);\n\n\t\t\t\t\tsample->IsRAP = sap_type_from_nal_type(nal_type);\n\t\t\t\t\treturn gf_isom_nalu_sample_rewrite(mdia, sample, sampleNumber, entry);\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tif (nal_size<2) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid nal size %d in sample %d\\n\", nal_type, sampleNumber));\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tgf_bs_read_data(src_bs, buffer, nal_size-2);\n\n\t\t\t\tif (nal_type==GF_HEVC_NALU_SEI_SUFFIX) {\n\t\t\t\t\tif (!sei_suffix_bs) sei_suffix_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t\twrite_to_bs = sei_suffix_bs;\n\t\t\t\t}\n\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(write_to_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(write_to_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(write_to_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(write_to_bs, buffer, nal_size-2);\n\t\t\t}\n#endif\n\n\t\t\t//done with HEVC\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(nal_type) {\n\t\tcase GF_AVC_NALU_ACCESS_UNIT:\n\t\t\t/*we already wrote this stuff*/\n\t\t\tgf_bs_skip_bytes(src_bs, nal_size-1);\n\t\t\tcontinue;\n\t\t//extractor\n\t\tcase 31:\n\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_FALSE, rewrite_ps, rewrite_start_codes, src_bs, dst_bs, extractor_mode);\n\t\t\tif (e) goto exit;\n\t\t\tbreak;\n//\t\t\tcase GF_AVC_NALU_SEI:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t\t// we will rewrite the sps/pps if and only if there is no sps/pps in bistream\n\t\t\tif (ps_bs) {\n\t\t\t\tgf_bs_del(ps_bs);\n\t\t\t\tps_bs = NULL;\n\t\t\t}\n\t\tdefault:\n\t\t\tif (ps_bs) {\n\t\t\t\tgf_bs_transfer(dst_bs, ps_bs);\n\t\t\t\tgf_bs_del(ps_bs);\n\t\t\t\tps_bs = NULL;\n\t\t\t}\n\t\t\tgf_bs_read_data(src_bs, buffer, nal_size-1);\n\t\t\tif (rewrite_start_codes)\n\t\t\t\tgf_bs_write_u32(dst_bs, 1);\n\t\t\telse\n\t\t\t\tgf_bs_write_int(dst_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\tgf_bs_write_u8(dst_bs, nal_hdr);\n\t\t\tgf_bs_write_data(dst_bs, buffer, nal_size-1);\n\t\t}\n\t}\n\n\tif (sei_suffix_bs) {\n\t\tgf_bs_transfer(dst_bs, sei_suffix_bs);\n\t\tgf_bs_del(sei_suffix_bs);\n\t}\n\t/*done*/\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tgf_bs_get_content(dst_bs, &sample->data, &sample->dataLength);\n\n\t/*rewrite temporal ID of AU Ddelim NALU (first one)*/\n\tif (rewrite_start_codes && is_hevc && temporal_id) {\n\t\tsample->data[6] = (sample->data[6] & 0xF8) | (temporal_id+1);\n\t}\n\n\nexit:\n\tif (ref_samp) gf_isom_sample_del(&ref_samp);\n\tif (src_bs) gf_bs_del(src_bs);\n\tif (ref_bs) gf_bs_del(ref_bs);\n\tif (dst_bs) gf_bs_del(dst_bs);\n\tif (ps_bs)  gf_bs_del(ps_bs);\n\tif (buffer) gf_free(buffer);\n\treturn e;\n}\n\nGF_HEVCConfig *HEVC_DuplicateConfig(GF_HEVCConfig *cfg)\n{\n\tchar *data;\n\tu32 data_size;\n\tGF_HEVCConfig *new_cfg;\n\tGF_BitStream *bs;\n\n\tif (!cfg) return NULL;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_odf_hevc_cfg_write_bs(cfg, bs);\n\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\n\tnew_cfg = gf_odf_hevc_cfg_read_bs(bs, cfg->is_lhvc);\n\tnew_cfg->is_lhvc = cfg->is_lhvc;\n\tgf_bs_del(bs);\n\tgf_free(data);\n\treturn new_cfg;\n}\n\nstatic GF_AVCConfig *AVC_DuplicateConfig(GF_AVCConfig *cfg)\n{\n\tu32 i, count;\n\tGF_AVCConfigSlot *p1, *p2;\n\tGF_AVCConfig *cfg_new = gf_odf_avc_cfg_new();\n\tcfg_new->AVCLevelIndication = cfg->AVCLevelIndication;\n\tcfg_new->AVCProfileIndication = cfg->AVCProfileIndication;\n\tcfg_new->configurationVersion = cfg->configurationVersion;\n\tcfg_new->nal_unit_size = cfg->nal_unit_size;\n\tcfg_new->profile_compatibility = cfg->profile_compatibility;\n\tcfg_new->complete_representation = cfg->complete_representation;\n\tcfg_new->chroma_bit_depth = cfg->chroma_bit_depth;\n\tcfg_new->luma_bit_depth = cfg->luma_bit_depth;\n\tcfg_new->chroma_format = cfg->chroma_format;\n\n\tcount = gf_list_count(cfg->sequenceParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tp1 = (GF_AVCConfigSlot*)gf_list_get(cfg->sequenceParameterSets, i);\n\t\tp2 = (GF_AVCConfigSlot*)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\tp2->size = p1->size;\n\t\tp2->id = p1->id;\n\t\tp2->data = (char *)gf_malloc(sizeof(char)*p1->size);\n\t\tmemcpy(p2->data, p1->data, sizeof(char)*p1->size);\n\t\tgf_list_add(cfg_new->sequenceParameterSets, p2);\n\t}\n\n\tcount = gf_list_count(cfg->pictureParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tp1 = (GF_AVCConfigSlot*)gf_list_get(cfg->pictureParameterSets, i);\n\t\tp2 = (GF_AVCConfigSlot*)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\tp2->size = p1->size;\n\t\tp2->id = p1->id;\n\t\tp2->data = (char*)gf_malloc(sizeof(char)*p1->size);\n\t\tmemcpy(p2->data, p1->data, sizeof(char)*p1->size);\n\t\tgf_list_add(cfg_new->pictureParameterSets, p2);\n\t}\n\n\tif (cfg->sequenceParameterSetExtensions) {\n\t\tcfg_new->sequenceParameterSetExtensions = gf_list_new();\n\t\tcount = gf_list_count(cfg->sequenceParameterSetExtensions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tp1 = (GF_AVCConfigSlot*)gf_list_get(cfg->sequenceParameterSetExtensions, i);\n\t\t\tp2 = (GF_AVCConfigSlot*)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\t\tp2->size = p1->size;\n\t\t\tp2->id = p1->id;\n\t\t\tp2->data = (char*)gf_malloc(sizeof(char)*p1->size);\n\t\t\tmemcpy(p2->data, p1->data, sizeof(char)*p1->size);\n\t\t\tgf_list_add(cfg_new->sequenceParameterSetExtensions, p2);\n\t\t}\n\t}\n\treturn cfg_new;\n}\n\nstatic void merge_avc_config(GF_AVCConfig *dst_cfg, GF_AVCConfig *src_cfg)\n{\n\tGF_AVCConfig *cfg = AVC_DuplicateConfig(src_cfg);\n\tif (!cfg || !dst_cfg) return;\n\n\twhile (gf_list_count(cfg->sequenceParameterSets)) {\n\t\tGF_AVCConfigSlot *p = (GF_AVCConfigSlot*)gf_list_get(cfg->sequenceParameterSets, 0);\n\t\tgf_list_rem(cfg->sequenceParameterSets, 0);\n\t\tgf_list_insert(dst_cfg->sequenceParameterSets, p, 0);\n\t}\n\twhile (gf_list_count(cfg->pictureParameterSets)) {\n\t\tGF_AVCConfigSlot *p = (GF_AVCConfigSlot*)gf_list_get(cfg->pictureParameterSets, 0);\n\t\tgf_list_rem(cfg->pictureParameterSets, 0);\n\t\tgf_list_insert(dst_cfg->pictureParameterSets, p, 0);\n\t}\n\tgf_odf_avc_cfg_del(cfg);\n}\n\nvoid merge_hevc_config(GF_HEVCConfig *dst_cfg, GF_HEVCConfig *src_cfg, Bool force_insert)\n{\n\tGF_HEVCConfig *cfg = HEVC_DuplicateConfig(src_cfg);\n\t//merge all xPS\n\tu32 i, j, count = cfg->param_array ? gf_list_count(cfg->param_array) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_HEVCParamArray *ar_h = NULL;\n\t\tu32 count2 = dst_cfg->param_array ? gf_list_count(dst_cfg->param_array) : 0;\n\t\tGF_HEVCParamArray *ar = (GF_HEVCParamArray*)gf_list_get(cfg->param_array, i);\n\t\tfor (j=0; j<count2; j++) {\n\t\t\tar_h = (GF_HEVCParamArray*)gf_list_get(dst_cfg->param_array, j);\n\t\t\tif (ar_h->type==ar->type) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tar_h = NULL;\n\t\t}\n\t\tif (!ar_h) {\n\t\t\tgf_list_add(dst_cfg->param_array, ar);\n\t\t\tgf_list_rem(cfg->param_array, i);\n\t\t\tcount--;\n\t\t\ti--;\n\t\t} else {\n\t\t\twhile (gf_list_count(ar->nalus)) {\n\t\t\t\tGF_AVCConfigSlot *p = (GF_AVCConfigSlot*)gf_list_get(ar->nalus, 0);\n\t\t\t\tgf_list_rem(ar->nalus, 0);\n\t\t\t\tif (force_insert)\n\t\t\t\t\tgf_list_insert(ar_h->nalus, p, 0);\n\t\t\t\telse\n\t\t\t\t\tgf_list_add(ar_h->nalus, p);\n\t\t\t}\n\n\t\t}\n\t}\n\tgf_odf_hevc_cfg_del(cfg);\n\n#define CHECK_CODE(__code)\tif (dst_cfg->__code < src_cfg->__code) dst_cfg->__code = src_cfg->__code;\n\n\tCHECK_CODE(configurationVersion)\n\tCHECK_CODE(profile_idc)\n\tCHECK_CODE(profile_space)\n\tCHECK_CODE(tier_flag)\n\tCHECK_CODE(general_profile_compatibility_flags)\n\tCHECK_CODE(progressive_source_flag)\n\tCHECK_CODE(interlaced_source_flag)\n\tCHECK_CODE(constraint_indicator_flags)\n\tCHECK_CODE(level_idc)\n\tCHECK_CODE(min_spatial_segmentation_idc)\n\n}\n\nvoid merge_all_config(GF_AVCConfig *avc_cfg, GF_HEVCConfig *hevc_cfg, GF_MediaBox *mdia)\n{\n\tu32 i;\n\tGF_TrackReferenceTypeBox *scal = NULL;\n\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &scal);\n\n\tif (!scal) return;\n\n\tfor (i=0; i<scal->trackIDCount; i++) {\n\t\tGF_TrackBox *a_track = GetTrackbyID(mdia->mediaTrack->moov, scal->trackIDs[i]);\n\t\tGF_MPEGVisualSampleEntryBox *an_entry = NULL;\n\t\tif (a_track && a_track->Media && a_track->Media->information && a_track->Media->information->sampleTable && a_track->Media->information->sampleTable->SampleDescription)\n\t\t\tan_entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(a_track->Media->information->sampleTable->SampleDescription->other_boxes, 0);\n\n\t\tif (!an_entry) continue;\n\n\t\tif (avc_cfg && an_entry->svc_config && an_entry->svc_config->config)\n\t\t\tmerge_avc_config(avc_cfg, an_entry->svc_config->config);\n\n\t\tif (avc_cfg && an_entry->mvc_config && an_entry->mvc_config->config)\n\t\t\tmerge_avc_config(avc_cfg, an_entry->mvc_config->config);\n\n\t\tif (avc_cfg && an_entry->avc_config && an_entry->avc_config->config)\n\t\t\tmerge_avc_config(avc_cfg, an_entry->avc_config->config);\n\n\t\tif (hevc_cfg && an_entry->lhvc_config && an_entry->lhvc_config->config)\n\t\t\tmerge_hevc_config(hevc_cfg, an_entry->lhvc_config->config, GF_TRUE);\n\n\t\tif (hevc_cfg && an_entry->hevc_config && an_entry->hevc_config->config)\n\t\t\tmerge_hevc_config(hevc_cfg, an_entry->hevc_config->config, GF_TRUE);\n\t}\n\n\tif (hevc_cfg) hevc_cfg->is_lhvc = GF_FALSE;\n}\n\nvoid AVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia)\n{\n\tGF_AVCConfig *avcc, *svcc, *mvcc;\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)avc, GF_FALSE);\n\n\tif (avc->emul_esd) gf_odf_desc_del((GF_Descriptor *)avc->emul_esd);\n\tavc->emul_esd = gf_odf_desc_esd_new(2);\n\tavc->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t/*AVC OTI is 0x21, AVC parameter set stream OTI (not supported in gpac) is 0x22, SVC OTI is 0x24*/\n\t/*if we have only SVC stream, set objectTypeIndication to AVC OTI; else set it to AVC OTI*/\n\tif (avc->svc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_SVC;\n\telse if (avc->mvc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_MVC;\n\telse\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_AVC;\n\n\tif (btrt) {\n\t\tavc->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tavc->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tavc->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (avc->descr) {\n\t\tu32 i=0;\n\t\tGF_Descriptor *desc,*clone;\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor *)gf_list_enum(avc->descr->descriptors, &i))) {\n\t\t\tclone = NULL;\n\t\t\tgf_odf_desc_copy(desc, &clone);\n\t\t\tif (gf_odf_desc_add_desc((GF_Descriptor *)avc->emul_esd, clone) != GF_OK)\n\t\t\t\tgf_odf_desc_del(clone);\n\t\t}\n\t}\n\tif (avc->avc_config) {\n\t\tavcc = avc->avc_config->config ? AVC_DuplicateConfig(avc->avc_config->config) : NULL;\n\t\t/*merge SVC config*/\n\t\tif (avc->svc_config) {\n\t\t\tmerge_avc_config(avcc, avc->svc_config->config);\n\t\t}\n\t\t/*merge MVC config*/\n\t\tif (avc->mvc_config) {\n\t\t\tmerge_avc_config(avcc, avc->mvc_config->config);\n\t\t}\n\t\tif (avcc) {\n\t\t\tif (mdia) merge_all_config(avcc, NULL, mdia);\n\n\t\t\tgf_odf_avc_cfg_write(avcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t}\n\t} else if (avc->svc_config) {\n\t\tsvcc = AVC_DuplicateConfig(avc->svc_config->config);\n\n\t\tif (mdia) merge_all_config(svcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(svcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(svcc);\n\t}\n\telse if (avc->mvc_config) {\n\t\tmvcc = AVC_DuplicateConfig(avc->mvc_config->config);\n\n\t\tif (mdia) merge_all_config(mvcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(mvcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(mvcc);\n\t}\n}\n\nvoid AVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *avc)\n{\n\tAVC_RewriteESDescriptorEx(avc, NULL);\n}\n\nvoid HEVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *hevc, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)hevc, GF_FALSE);\n\n\tif (hevc->emul_esd) gf_odf_desc_del((GF_Descriptor *)hevc->emul_esd);\n\thevc->emul_esd = gf_odf_desc_esd_new(2);\n\thevc->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\thevc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_HEVC;\n\tif (hevc->lhvc_config /*&& !hevc->hevc_config*/)\n\t\thevc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_LHVC;\n\n\tif (btrt) {\n\t\thevc->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\thevc->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\thevc->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (hevc->descr) {\n\t\tu32 i=0;\n\t\tGF_Descriptor *desc,*clone;\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor *)gf_list_enum(hevc->descr->descriptors, &i))) {\n\t\t\tclone = NULL;\n\t\t\tgf_odf_desc_copy(desc, &clone);\n\t\t\tif (gf_odf_desc_add_desc((GF_Descriptor *)hevc->emul_esd, clone) != GF_OK)\n\t\t\t\tgf_odf_desc_del(clone);\n\t\t}\n\t}\n\n\tif (hevc->hevc_config || hevc->lhvc_config) {\n\t\tGF_HEVCConfig *hcfg = HEVC_DuplicateConfig(hevc->hevc_config ? hevc->hevc_config->config : hevc->lhvc_config->config);\n\n\t\tif (hevc->hevc_config && hevc->lhvc_config) {\n\t\t\t//merge LHVC config to HEVC conf, so we add entry rather than insert\n\t\t\tmerge_hevc_config(hcfg, hevc->lhvc_config->config, GF_FALSE);\n\t\t}\n\n\t\tif (mdia) merge_all_config(NULL, hcfg, mdia);\n\n\t\tif (hcfg) {\n\t\t\tif (mdia && ((mdia->mediaTrack->extractor_mode&0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)) {\n\t\t\t\thcfg->is_lhvc=GF_FALSE;\n\t\t\t}\n\t\t\tgf_odf_hevc_cfg_write(hcfg, &hevc->emul_esd->decoderConfig->decoderSpecificInfo->data, &hevc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_hevc_cfg_del(hcfg);\n\t\t}\n\t}\n}\nvoid HEVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *hevc)\n{\n\tHEVC_RewriteESDescriptorEx(hevc, NULL);\n}\n\nGF_Err AVC_HEVC_UpdateESD(GF_MPEGVisualSampleEntryBox *avc, GF_ESD *esd)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)avc, GF_TRUE);\n\n\tif (avc->descr) gf_isom_box_del((GF_Box *) avc->descr);\n\tavc->descr = NULL;\n\tbtrt->avgBitrate = esd->decoderConfig->avgBitrate;\n\tbtrt->maxBitrate = esd->decoderConfig->maxBitrate;\n\tbtrt->bufferSizeDB = esd->decoderConfig->bufferSizeDB;\n\n\tif (gf_list_count(esd->IPIDataSet)\n\t        || gf_list_count(esd->IPMPDescriptorPointers)\n\t        || esd->langDesc\n\t        || gf_list_count(esd->extensionDescriptors)\n\t        || esd->ipiPtr || esd->qos || esd->RegDescriptor) {\n\n\t\tavc->descr = (GF_MPEG4ExtensionDescriptorsBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_M4DS);\n\t\tif (esd->RegDescriptor) {\n\t\t\tgf_list_add(avc->descr->descriptors, esd->RegDescriptor);\n\t\t\tesd->RegDescriptor = NULL;\n\t\t}\n\t\tif (esd->qos) {\n\t\t\tgf_list_add(avc->descr->descriptors, esd->qos);\n\t\t\tesd->qos = NULL;\n\t\t}\n\t\tif (esd->ipiPtr) {\n\t\t\tgf_list_add(avc->descr->descriptors, esd->ipiPtr);\n\t\t\tesd->ipiPtr= NULL;\n\t\t}\n\n\t\twhile (gf_list_count(esd->IPIDataSet)) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *)gf_list_get(esd->IPIDataSet, 0);\n\t\t\tgf_list_rem(esd->IPIDataSet, 0);\n\t\t\tgf_list_add(avc->descr->descriptors, desc);\n\t\t}\n\t\twhile (gf_list_count(esd->IPMPDescriptorPointers)) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *)gf_list_get(esd->IPMPDescriptorPointers, 0);\n\t\t\tgf_list_rem(esd->IPMPDescriptorPointers, 0);\n\t\t\tgf_list_add(avc->descr->descriptors, desc);\n\t\t}\n\t\tif (esd->langDesc) {\n\t\t\tgf_list_add(avc->descr->descriptors, esd->langDesc);\n\t\t\tesd->langDesc = NULL;\n\t\t}\n\t\twhile (gf_list_count(esd->extensionDescriptors)) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *)gf_list_get(esd->extensionDescriptors, 0);\n\t\t\tgf_list_rem(esd->extensionDescriptors, 0);\n\t\t\tgf_list_add(avc->descr->descriptors, desc);\n\t\t}\n\t}\n\n\n\tif (!avc->lhvc_config && (esd->decoderConfig->objectTypeIndication==GPAC_OTI_VIDEO_HEVC)) {\n\t\tif (!avc->hevc_config) avc->hevc_config = (GF_HEVCConfigurationBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tif (avc->hevc_config->config) gf_odf_hevc_cfg_del(avc->hevc_config->config);\n\t\t\tavc->hevc_config->config = gf_odf_hevc_cfg_read(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, GF_FALSE);\n\t\t}\n\t}\n\telse if (!avc->svc_config && !avc->mvc_config && (esd->decoderConfig->objectTypeIndication==GPAC_OTI_VIDEO_AVC)) {\n\t\tif (!avc->avc_config) avc->avc_config = (GF_AVCConfigurationBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tif (avc->avc_config->config) gf_odf_avc_cfg_del(avc->avc_config->config);\n\t\t\tavc->avc_config->config = gf_odf_avc_cfg_read(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t}\n\n\tgf_odf_desc_del((GF_Descriptor *)esd);\n\tif (avc->hevc_config) {\n\t\tHEVC_RewriteESDescriptor(avc);\n\t} else {\n\t\tAVC_RewriteESDescriptor(avc);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_EXPORT\nGF_Err gf_isom_avc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, char *URLname, char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_AVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\tentry->avc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\tentry->avc_config->config = AVC_DuplicateConfig(cfg);\n\tentry->dataReferenceIndex = dataRefIndex;\n\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->other_boxes, entry);\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->other_boxes);\n\tAVC_RewriteESDescriptor(entry);\n\treturn e;\n}\n\nstatic GF_Err gf_isom_avc_config_update_ex(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg, u32 op_type)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tswitch (op_type) {\n\t/*AVCC replacement*/\n\tcase 0:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (!entry->avc_config) entry->avc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (entry->avc_config->config) gf_odf_avc_cfg_del(entry->avc_config->config);\n\t\tentry->avc_config->config = AVC_DuplicateConfig(cfg);\n\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\t/*SVCC replacement*/\n\tcase 1:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (!entry->svc_config) entry->svc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\tif (entry->svc_config->config) gf_odf_avc_cfg_del(entry->svc_config->config);\n\t\tentry->svc_config->config = AVC_DuplicateConfig(cfg);\n\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\t/*SVCC replacement and AVC removal*/\n\tcase 2:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (entry->avc_config) {\n\t\t\tgf_isom_box_del((GF_Box*)entry->avc_config);\n\t\t\tentry->avc_config = NULL;\n\t\t}\n\t\tif (!entry->svc_config) entry->svc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\tif (entry->svc_config->config) gf_odf_avc_cfg_del(entry->svc_config->config);\n\t\tentry->svc_config->config = AVC_DuplicateConfig(cfg);\n\t\tentry->type = GF_ISOM_BOX_TYPE_SVC1;\n\t\tbreak;\n\t/*AVCC removal and switch to avc3*/\n\tcase 3:\n\t\tif (!entry->avc_config || !entry->avc_config->config)\n\t\t\treturn GF_BAD_PARAM;\n\n\t\tif (entry->svc_config) {\n\t\t\tgf_isom_box_del((GF_Box*)entry->svc_config);\n\t\t\tentry->svc_config = NULL;\n\t\t}\n\t\tif (entry->mvc_config) {\n\t\t\tgf_isom_box_del((GF_Box*)entry->mvc_config);\n\t\t\tentry->mvc_config = NULL;\n\t\t}\n\n\t\twhile (gf_list_count(entry->avc_config->config->sequenceParameterSets)) {\n\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot*)gf_list_get(entry->avc_config->config->sequenceParameterSets, 0);\n\t\t\tgf_list_rem(entry->avc_config->config->sequenceParameterSets, 0);\n\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\tgf_free(sl);\n\t\t}\n\n\t\twhile (gf_list_count(entry->avc_config->config->pictureParameterSets)) {\n\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot*)gf_list_get(entry->avc_config->config->pictureParameterSets, 0);\n\t\t\tgf_list_rem(entry->avc_config->config->pictureParameterSets, 0);\n\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\tgf_free(sl);\n\t\t}\n\n\t\tif (entry->type == GF_ISOM_BOX_TYPE_AVC1)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC3;\n\t\telse if (entry->type == GF_ISOM_BOX_TYPE_AVC2)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC4;\n\t\tbreak;\n\t/*MVCC replacement*/\n\tcase 4:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (!entry->mvc_config) entry->mvc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\tif (entry->mvc_config->config) gf_odf_avc_cfg_del(entry->mvc_config->config);\n\t\tentry->mvc_config->config = AVC_DuplicateConfig(cfg);\n\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\t/*MVCC replacement and AVC removal*/\n\tcase 5:\n\t\tif (!cfg) return GF_BAD_PARAM;\n\t\tif (entry->avc_config) {\n\t\t\tgf_isom_box_del((GF_Box*)entry->avc_config);\n\t\t\tentry->avc_config = NULL;\n\t\t}\n\t\tif (!entry->mvc_config) entry->mvc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\tif (entry->mvc_config->config) gf_odf_avc_cfg_del(entry->mvc_config->config);\n\t\tentry->mvc_config->config = AVC_DuplicateConfig(cfg);\n\t\tentry->type = GF_ISOM_BOX_TYPE_MVC1;\n\t\tbreak;\n\t}\n\tAVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_avc_set_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, 3);\n}\n\nGF_EXPORT\nGF_Err gf_isom_avc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, 0);\n}\n\nGF_Err gf_isom_svc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg, Bool is_add)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, is_add ? 1 : 2);\n}\n\nGF_Err gf_isom_mvc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg, Bool is_add)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, is_add ? 4 : 5);\n}\n\nstatic GF_Err gf_isom_svc_mvc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool is_mvc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (is_mvc && entry->mvc_config) {\n\t\tgf_isom_box_del((GF_Box*)entry->mvc_config);\n\t\tentry->mvc_config = NULL;\n\t}\n\telse if (!is_mvc && entry->svc_config) {\n\t\tgf_isom_box_del((GF_Box*)entry->svc_config);\n\t\tentry->svc_config = NULL;\n\t}\n\tAVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_svc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_del(the_file, trackNumber, DescriptionIndex, GF_FALSE);\n}\n\nGF_Err gf_isom_mvc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_del(the_file, trackNumber, DescriptionIndex, GF_TRUE);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_ipod_compatible(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, 0);\n\tif (!entry) return GF_OK;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tif (!entry->ipod_ext) entry->ipod_ext = (GF_UnknownUUIDBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\tmemcpy(entry->ipod_ext->uuid, GF_ISOM_IPOD_EXT, sizeof(u8)*16);\n\tentry->ipod_ext->dataSize = 0;\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_svc_mvc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, Bool is_mvc, char *URLname, char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//create a new entry\n\tif (is_mvc) {\n\t\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MVC1);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->mvc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\tentry->mvc_config->config = AVC_DuplicateConfig(cfg);\n\t} else {\n\t\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SVC1);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->svc_config = (GF_AVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\tentry->svc_config->config = AVC_DuplicateConfig(cfg);\n\t}\n\tentry->dataReferenceIndex = dataRefIndex;\n\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->other_boxes, entry);\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->other_boxes);\n\tAVC_RewriteESDescriptor(entry);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_svc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, char *URLname, char *URNname, u32 *outDescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_new(the_file, trackNumber, cfg, GF_FALSE, URLname, URNname,outDescriptionIndex);\n}\n\nGF_EXPORT\nGF_Err gf_isom_mvc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, char *URLname, char *URNname, u32 *outDescriptionIndex)\n{\n\treturn gf_isom_svc_mvc_config_new(the_file, trackNumber, cfg, GF_TRUE, URLname, URNname,outDescriptionIndex);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_hevc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_HEVCConfig *cfg, char *URLname, char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//create a new entry\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_HVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\tentry->hevc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\tentry->hevc_config->config = HEVC_DuplicateConfig(cfg);\n\tentry->dataReferenceIndex = dataRefIndex;\n\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->other_boxes, entry);\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->other_boxes);\n\tHEVC_RewriteESDescriptor(entry);\n\treturn e;\n}\n\ntypedef enum\n{\n\tGF_ISOM_HVCC_UPDATE = 0,\n\tGF_ISOM_HVCC_SET_INBAND,\n\tGF_ISOM_HVCC_SET_TILE,\n\tGF_ISOM_HVCC_SET_TILE_BASE_TRACK,\n\tGF_ISOM_HVCC_SET_LHVC,\n\tGF_ISOM_HVCC_SET_LHVC_WITH_BASE,\n\tGF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD,\n\tGF_ISOM_LHCC_SET_INBAND\n} HevcConfigUpdateType;\n\nstatic Bool hevc_cleanup_config(GF_HEVCConfig *cfg, HevcConfigUpdateType operand_type)\n{\n\tu32 i;\n\tBool array_incomplete = (operand_type==GF_ISOM_HVCC_SET_INBAND) ? 1 : 0;\n\tif (!cfg) return 0;\n\n\tfor (i=0; i<gf_list_count(cfg->param_array); i++) {\n\t\tGF_HEVCParamArray *ar = (GF_HEVCParamArray*)gf_list_get(cfg->param_array, i);\n\n\t\t/*we want to force hev1*/\n\t\tif (operand_type==GF_ISOM_HVCC_SET_INBAND) {\n\t\t\tar->array_completeness = 0;\n\n\t\t\twhile (gf_list_count(ar->nalus)) {\n\t\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot*)gf_list_get(ar->nalus, 0);\n\t\t\t\tgf_list_rem(ar->nalus, 0);\n\t\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\t\tgf_free(sl);\n\t\t\t}\n\t\t\tgf_list_del(ar->nalus);\n\t\t\tgf_free(ar);\n\t\t\tgf_list_rem(cfg->param_array, i);\n\t\t\ti--;\n\t\t}\n\t\tif (!ar->array_completeness) \n\t\t\tarray_incomplete = 1;\n\t}\n\treturn array_incomplete;\n}\n\nstatic\nGF_Err gf_isom_hevc_config_update_ex(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg, u32 operand_type)\n{\n\tu32 array_incomplete;\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\n\tif (operand_type == GF_ISOM_HVCC_SET_TILE_BASE_TRACK) {\n\t\tif (entry->type==GF_ISOM_BOX_TYPE_HVC1)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HVC2;\n\t\telse if (entry->type==GF_ISOM_BOX_TYPE_HEV1)\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HEV2;\n\t} else if (operand_type == GF_ISOM_HVCC_SET_TILE) {\n\t\tif (!entry->hevc_config) entry->hevc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\t\tif (entry->hevc_config->config) gf_odf_hevc_cfg_del(entry->hevc_config->config);\n\t\tentry->hevc_config->config = NULL;\n\t\tentry->type = GF_ISOM_BOX_TYPE_HVT1;\n\t} else if (operand_type < GF_ISOM_HVCC_SET_LHVC) {\n\t\tif ((operand_type != GF_ISOM_HVCC_SET_INBAND) && !entry->hevc_config)\n\t\t\tentry->hevc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\n\t\tif (cfg) {\n\t\t\tif (entry->hevc_config->config) gf_odf_hevc_cfg_del(entry->hevc_config->config);\n\t\t\tentry->hevc_config->config = HEVC_DuplicateConfig(cfg);\n\t\t} else if (operand_type != GF_ISOM_HVCC_SET_TILE) {\n\t\t\toperand_type=GF_ISOM_HVCC_SET_INBAND;\n\t\t}\n\t\tarray_incomplete = (operand_type==GF_ISOM_HVCC_SET_INBAND) ? 1 : 0;\n\t\tif (entry->hevc_config && hevc_cleanup_config(entry->hevc_config->config, operand_type))\n\t\t\tarray_incomplete=1;\n\n\t\tif (entry->lhvc_config && hevc_cleanup_config(entry->lhvc_config->config, operand_type))\n\t\t\tarray_incomplete=1;\n\n\t\tswitch (entry->type) {\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_HEV1 : GF_ISOM_BOX_TYPE_HVC1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_HEV2 : GF_ISOM_BOX_TYPE_HVC2;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\t\tentry->type = array_incomplete ? GF_ISOM_BOX_TYPE_LHE1 : GF_ISOM_BOX_TYPE_LHV1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\n\t\t/*SVCC replacement/removal with HEVC base, backward compatible signaling*/\n\t\tif ((operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD) || (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE)) {\n\t\t\tif (!entry->hevc_config) return GF_BAD_PARAM;\n\t\t\tif (!cfg) {\n\t\t\t\tif (entry->lhvc_config) {\n\t\t\t\t\tgf_isom_box_del((GF_Box*)entry->lhvc_config);\n\t\t\t\t\tentry->lhvc_config = NULL;\n\t\t\t\t}\n\t\t\t\tif (entry->type==GF_ISOM_BOX_TYPE_LHE1) entry->type = (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) ? GF_ISOM_BOX_TYPE_HEV2 : GF_ISOM_BOX_TYPE_HEV1;\n\t\t\t\telse if (entry->type==GF_ISOM_BOX_TYPE_HEV1) entry->type = (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) ? GF_ISOM_BOX_TYPE_HEV2 : GF_ISOM_BOX_TYPE_HEV1;\n\t\t\t\telse entry->type =  (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE) ? GF_ISOM_BOX_TYPE_HVC2 : GF_ISOM_BOX_TYPE_HVC1;\n\t\t\t} else {\n\t\t\t\tif (!entry->lhvc_config) entry->lhvc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_LHVC);\n\t\t\t\tif (entry->lhvc_config->config) gf_odf_hevc_cfg_del(entry->lhvc_config->config);\n\t\t\t\tentry->lhvc_config->config = HEVC_DuplicateConfig(cfg);\n\n\t\t\t\tif (operand_type==GF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD) {\n\t\t\t\t\tif (entry->type==GF_ISOM_BOX_TYPE_HEV2) entry->type = GF_ISOM_BOX_TYPE_HEV1;\n\t\t\t\t\telse entry->type = GF_ISOM_BOX_TYPE_HVC1;\n\t\t\t\t} else {\n\t\t\t\t\tif (entry->type==GF_ISOM_BOX_TYPE_HEV1) entry->type = GF_ISOM_BOX_TYPE_HEV2;\n\t\t\t\t\telse entry->type = GF_ISOM_BOX_TYPE_HVC2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*LHEVC track without base*/\n\t\telse if (operand_type==GF_ISOM_HVCC_SET_LHVC) {\n\t\t\tif (entry->hevc_config) {\n\t\t\t\tgf_isom_box_del((GF_Box*)entry->hevc_config);\n\t\t\t\tentry->hevc_config=NULL;\n\t\t\t}\n\t\t\tif (!cfg) return GF_BAD_PARAM;\n\n\t\t\tif (!entry->lhvc_config) entry->lhvc_config = (GF_HEVCConfigurationBox*)gf_isom_box_new(GF_ISOM_BOX_TYPE_LHVC);\n\t\t\tif (entry->lhvc_config->config) gf_odf_hevc_cfg_del(entry->lhvc_config->config);\n\t\t\tentry->lhvc_config->config = HEVC_DuplicateConfig(cfg);\n\n\t\t\tif ((entry->type==GF_ISOM_BOX_TYPE_HEV1) || (entry->type==GF_ISOM_BOX_TYPE_HEV2)) entry->type = GF_ISOM_BOX_TYPE_LHE1;\n\t\t\telse entry->type = GF_ISOM_BOX_TYPE_LHV1;\n\t\t}\n\t\t/*LHEVC inband, no config change*/\n\t\telse if (operand_type==GF_ISOM_LHCC_SET_INBAND) {\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_LHE1;\n\t\t}\n\t}\n\n\tHEVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_hevc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_UPDATE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_hevc_set_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, GF_ISOM_HVCC_SET_INBAND);\n}\n\nGF_EXPORT\nGF_Err gf_isom_lhvc_force_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, GF_ISOM_LHCC_SET_INBAND);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_hevc_set_tile_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg, Bool is_base_track)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, is_base_track ? GF_ISOM_HVCC_SET_TILE_BASE_TRACK : GF_ISOM_HVCC_SET_TILE);\n}\n\nGF_Err gf_isom_lhvc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_HEVCConfig *cfg, GF_ISOMLHEVCTrackType track_type)\n{\n\tif (cfg) cfg->is_lhvc = GF_TRUE;\n\tswitch (track_type) {\n\tcase GF_ISOM_LEHVC_ONLY:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_LHVC);\n\tcase GF_ISOM_LEHVC_WITH_BASE:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_LHVC_WITH_BASE);\n\tcase GF_ISOM_LEHVC_WITH_BASE_BACKWARD:\n\t\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, GF_ISOM_HVCC_SET_LHVC_WITH_BASE_BACKWARD);\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_Box *gf_isom_clone_config_box(GF_Box *box)\n{\n\tGF_Box *clone;\n\tswitch (box->type)\n\t{\n\tcase GF_ISOM_BOX_TYPE_AVCC:\n\tcase GF_ISOM_BOX_TYPE_SVCC:\n\tcase GF_ISOM_BOX_TYPE_MVCC:\n\t\tclone = gf_isom_box_new(box->type);\n\t\t((GF_AVCConfigurationBox *)clone)->config = AVC_DuplicateConfig(((GF_AVCConfigurationBox *)box)->config);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVCC:\n\t\tclone = gf_isom_box_new(box->type);\n\t\t((GF_HEVCConfigurationBox *)clone)->config = HEVC_DuplicateConfig(((GF_HEVCConfigurationBox *)box)->config);\n\t\tbreak;\n\tdefault:\n\t\tclone = NULL;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Cloning of config not supported for type %s\\n\", gf_4cc_to_str(box->type)));\n\t\tbreak;\n\t}\n\treturn clone;\n}\n\nGF_EXPORT\nGF_AVCConfig *gf_isom_avc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\n\tif (!entry->avc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->avc_config->config);\n}\n\nGF_EXPORT\nGF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->hevc_config) return NULL;\n\treturn HEVC_DuplicateConfig(entry->hevc_config->config);\n}\n\nGF_EXPORT\nGF_AVCConfig *gf_isom_svc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->svc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->svc_config->config);\n}\n\n\nGF_EXPORT\nGF_AVCConfig *gf_isom_mvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->mvc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->mvc_config->config);\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_avc_svc_type(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tu32 type;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_ISOM_AVCTYPE_NONE;\n\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_VISUAL) return GF_ISOM_AVCTYPE_NONE;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_ISOM_AVCTYPE_NONE;\n\n\ttype = entry->type;\n\n\tif (type == GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_list_get(entry->protections, 0);\n\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t}\n\telse if (type == GF_ISOM_BOX_TYPE_RESV) {\n\t\tif (entry->rinf && entry->rinf->original_format) type = entry->rinf->original_format->data_format;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_AVCTYPE_NONE;\n\t}\n\tif (entry->avc_config && !entry->svc_config && !entry->mvc_config) return GF_ISOM_AVCTYPE_AVC_ONLY;\n\tif (entry->avc_config && entry->svc_config) return GF_ISOM_AVCTYPE_AVC_SVC;\n\tif (entry->avc_config && entry->mvc_config) return GF_ISOM_AVCTYPE_AVC_MVC;\n\tif (!entry->avc_config && entry->svc_config) return GF_ISOM_AVCTYPE_SVC_ONLY;\n\tif (!entry->avc_config && entry->mvc_config) return GF_ISOM_AVCTYPE_MVC_ONLY;\n\treturn GF_ISOM_AVCTYPE_NONE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_hevc_lhvc_type(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tu32 type;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_ISOM_HEVCTYPE_NONE;\n\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_VISUAL) return GF_ISOM_HEVCTYPE_NONE;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_ISOM_AVCTYPE_NONE;\n\ttype = entry->type;\n\n\tif (type == GF_ISOM_BOX_TYPE_ENCV) {\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_list_get(entry->protections, 0);\n\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t}\n\telse if (type == GF_ISOM_BOX_TYPE_RESV) {\n\t\tif (entry->rinf && entry->rinf->original_format) type = entry->rinf->original_format->data_format;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_HEVCTYPE_NONE;\n\t}\n\tif (entry->hevc_config && !entry->lhvc_config) return GF_ISOM_HEVCTYPE_HEVC_ONLY;\n\tif (entry->hevc_config && entry->lhvc_config) return GF_ISOM_HEVCTYPE_HEVC_LHVC;\n\tif (!entry->hevc_config && entry->lhvc_config) return GF_ISOM_HEVCTYPE_LHVC_ONLY;\n\treturn GF_ISOM_HEVCTYPE_NONE;\n}\n\nGF_EXPORT\nGF_HEVCConfig *gf_isom_lhvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_HEVCConfig *lhvc;\n\tGF_OperatingPointsInformation *oinf=NULL;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->lhvc_config) return NULL;\n\tlhvc = HEVC_DuplicateConfig(entry->lhvc_config->config);\n\tif (!lhvc) return NULL;\n\n\tgf_isom_get_oinf_info(the_file, trackNumber, &oinf);\n\tif (oinf) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_last(oinf->profile_tier_levels);\n\t\tif (ptl) {\n\t\t\tlhvc->profile_space  = ptl->general_profile_space;\n\t\t\tlhvc->tier_flag = ptl->general_tier_flag;\n\t\t\tlhvc->profile_idc = ptl->general_profile_idc;\n\t\t\tlhvc->general_profile_compatibility_flags = ptl->general_profile_compatibility_flags;\n\t\t\tlhvc->constraint_indicator_flags = ptl->general_constraint_indicator_flags;\n\t\t}\n\t}\n\treturn lhvc;\n}\n\n\nvoid btrt_del(GF_Box *s)\n{\n\tGF_BitRateBox *ptr = (GF_BitRateBox *)s;\n\tif (ptr) gf_free(ptr);\n}\nGF_Err btrt_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_BitRateBox *ptr = (GF_BitRateBox *)s;\n\tptr->bufferSizeDB = gf_bs_read_u32(bs);\n\tptr->maxBitrate = gf_bs_read_u32(bs);\n\tptr->avgBitrate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *btrt_New()\n{\n\tGF_BitRateBox *tmp = (GF_BitRateBox *) gf_malloc(sizeof(GF_BitRateBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitRateBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_BTRT;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err btrt_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_BitRateBox *ptr = (GF_BitRateBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->bufferSizeDB);\n\tgf_bs_write_u32(bs, ptr->maxBitrate);\n\tgf_bs_write_u32(bs, ptr->avgBitrate);\n\treturn GF_OK;\n}\nGF_Err btrt_Size(GF_Box *s)\n{\n\tGF_BitRateBox *ptr = (GF_BitRateBox *)s;\n\tptr->size += 12;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid m4ds_del(GF_Box *s)\n{\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\tgf_odf_desc_list_del(ptr->descriptors);\n\tgf_list_del(ptr->descriptors);\n\tgf_free(ptr);\n}\nGF_Err m4ds_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tchar *enc_od;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\tu32 od_size = (u32) ptr->size;\n\tif (!od_size) return GF_OK;\n\tenc_od = (char *)gf_malloc(sizeof(char) * od_size);\n\tgf_bs_read_data(bs, enc_od, od_size);\n\te = gf_odf_desc_list_read((char *)enc_od, od_size, ptr->descriptors);\n\tgf_free(enc_od);\n\treturn e;\n}\nGF_Box *m4ds_New()\n{\n\tGF_MPEG4ExtensionDescriptorsBox *tmp = (GF_MPEG4ExtensionDescriptorsBox *) gf_malloc(sizeof(GF_MPEG4ExtensionDescriptorsBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_MPEG4ExtensionDescriptorsBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_M4DS;\n\ttmp->descriptors = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err m4ds_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tchar *enc_ods;\n\tu32 enc_od_size;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tenc_ods = NULL;\n\tenc_od_size = 0;\n\te = gf_odf_desc_list_write(ptr->descriptors, &enc_ods, &enc_od_size);\n\tif (e) return e;\n\tif (enc_od_size) {\n\t\tgf_bs_write_data(bs, enc_ods, enc_od_size);\n\t\tgf_free(enc_ods);\n\t}\n\treturn GF_OK;\n}\nGF_Err m4ds_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 descSize = 0;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\te = gf_odf_desc_list_size(ptr->descriptors, &descSize);\n\tptr->size += descSize;\n\treturn e;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid avcc_del(GF_Box *s)\n{\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;\n\tif (ptr->config) gf_odf_avc_cfg_del(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err avcc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count;\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;\n\n\tif (ptr->config) gf_odf_avc_cfg_del(ptr->config);\n\tptr->config = gf_odf_avc_cfg_new();\n\tptr->config->configurationVersion = gf_bs_read_u8(bs);\n\tptr->config->AVCProfileIndication = gf_bs_read_u8(bs);\n\tptr->config->profile_compatibility = gf_bs_read_u8(bs);\n\tptr->config->AVCLevelIndication = gf_bs_read_u8(bs);\n\tif (ptr->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tgf_bs_read_int(bs, 6);\n\t} else {\n\t\tptr->config->complete_representation = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 5);\n\t}\n\tptr->config->nal_unit_size = 1 + gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 3);\n\tcount = gf_bs_read_int(bs, 5);\n\n\tptr->size -= 7; //including 2nd count\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\tsl->size = gf_bs_read_u16(bs);\n\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\tgf_list_add(ptr->config->sequenceParameterSets, sl);\n\t\tptr->size -= 2+sl->size;\n\t}\n\n\tcount = gf_bs_read_u8(bs);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\tsl->size = gf_bs_read_u16(bs);\n\t\tif (gf_bs_available(bs) < sl->size) {\n\t\t\tgf_free(sl);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"AVCC: Not enough bits to parse. Aborting.\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\tgf_list_add(ptr->config->pictureParameterSets, sl);\n\t\tptr->size -= 2+sl->size;\n\t}\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tif (gf_avc_is_rext_profile(ptr->config->AVCProfileIndication)) {\n\t\t\tif (!ptr->size) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tAVCState avc;\n\t\t\t\ts32 idx, vui_flag_pos;\n\t\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot*)gf_list_get(ptr->config->sequenceParameterSets, 0);\n\t\t\t\tidx = gf_media_avc_read_sps(sl->data+1, sl->size-1, &avc, 0, (u32 *) &vui_flag_pos);\n\t\t\t\tif (idx>=0) {\n\t\t\t\t\tptr->config->chroma_format = avc.sps[idx].chroma_format;\n\t\t\t\t\tptr->config->luma_bit_depth = 8 + avc.sps[idx].luma_bit_depth_m8;\n\t\t\t\t\tptr->config->chroma_bit_depth = 8 + avc.sps[idx].chroma_bit_depth_m8;\n\t\t\t\t}\n#else\n\t\t\t\t/*set default values ...*/\n\t\t\t\tptr->config->chroma_format = 1;\n\t\t\t\tptr->config->luma_bit_depth = 8;\n\t\t\t\tptr->config->chroma_bit_depth = 8;\n#endif\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tptr->config->chroma_format = gf_bs_read_int(bs, 2);\n\t\t\tgf_bs_read_int(bs, 5);\n\t\t\tptr->config->luma_bit_depth = 8 + gf_bs_read_int(bs, 3);\n\t\t\tgf_bs_read_int(bs, 5);\n\t\t\tptr->config->chroma_bit_depth = 8 + gf_bs_read_int(bs, 3);\n\n\t\t\tcount = gf_bs_read_int(bs, 8);\n\t\t\tptr->size -= 4;\n\t\t\tif (count*2 > ptr->size) {\n\t\t\t\t//ffmpeg just ignores this part while allocating bytes (filled with garbage?)\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"AVCC: invalid numOfSequenceParameterSetExt value. Skipping.\\n\"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (count) {\n\t\t\t\tptr->config->sequenceParameterSetExtensions = gf_list_new();\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\t\t\t\tsl->size = gf_bs_read_u16(bs);\n\t\t\t\t\tif (gf_bs_available(bs) < sl->size) {\n\t\t\t\t\t\tgf_free(sl);\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"AVCC: Not enough bits to parse. Aborting.\\n\"));\n\t\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t\t}\n\t\t\t\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\t\t\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\t\t\t\tgf_list_add(ptr->config->sequenceParameterSetExtensions, sl);\n\t\t\t\t\tptr->size -= sl->size + 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *avcc_New()\n{\n\tGF_AVCConfigurationBox *tmp = (GF_AVCConfigurationBox *) gf_malloc(sizeof(GF_AVCConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_AVCConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_AVCC;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err avcc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, count;\n\tGF_Err e;\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->config->configurationVersion);\n\tgf_bs_write_u8(bs, ptr->config->AVCProfileIndication);\n\tgf_bs_write_u8(bs, ptr->config->profile_compatibility);\n\tgf_bs_write_u8(bs, ptr->config->AVCLevelIndication);\n\tif (ptr->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tgf_bs_write_int(bs, 0x3F, 6);\n\t} else {\n\t\tgf_bs_write_int(bs, ptr->config->complete_representation, 1);\n\t\tgf_bs_write_int(bs, 0x1F, 5);\n\t}\n\tgf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);\n\tgf_bs_write_int(bs, 0x7, 3);\n\tcount = gf_list_count(ptr->config->sequenceParameterSets);\n\tgf_bs_write_int(bs, count, 5);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i);\n\t\tgf_bs_write_u16(bs, sl->size);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\n\tcount = gf_list_count(ptr->config->pictureParameterSets);\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i);\n\t\tgf_bs_write_u16(bs, sl->size);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tif (gf_avc_is_rext_profile(ptr->config->AVCProfileIndication)) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, ptr->config->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, ptr->config->luma_bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, ptr->config->chroma_bit_depth - 8, 3);\n\n\t\t\tcount = ptr->config->sequenceParameterSetExtensions ? gf_list_count(ptr->config->sequenceParameterSetExtensions) : 0;\n\t\t\tgf_bs_write_u8(bs, count);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSetExtensions, i);\n\t\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\nGF_Err avcc_Size(GF_Box *s)\n{\n\tu32 i, count;\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\tptr->size += 7;\n\tcount = gf_list_count(ptr->config->sequenceParameterSets);\n\tfor (i=0; i<count; i++)\n\t\tptr->size += 2 + ((GF_AVCConfigSlot *)gf_list_get(ptr->config->sequenceParameterSets, i))->size;\n\n\tcount = gf_list_count(ptr->config->pictureParameterSets);\n\tfor (i=0; i<count; i++)\n\t\tptr->size += 2 + ((GF_AVCConfigSlot *)gf_list_get(ptr->config->pictureParameterSets, i))->size;\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tif (gf_avc_is_rext_profile(ptr->config->AVCProfileIndication)) {\n\t\t\tptr->size += 4;\n\t\t\tcount = ptr->config->sequenceParameterSetExtensions ?gf_list_count(ptr->config->sequenceParameterSetExtensions) : 0;\n\t\t\tfor (i=0; i<count; i++)\n\t\t\t\tptr->size += 2 + ((GF_AVCConfigSlot *)gf_list_get(ptr->config->sequenceParameterSetExtensions, i))->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid hvcc_del(GF_Box *s)\n{\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox*)s;\n\tif (ptr->config) gf_odf_hevc_cfg_del(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err hvcc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu64 pos;\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox *)s;\n\n\tif (ptr->config) gf_odf_hevc_cfg_del(ptr->config);\n\n\tpos = gf_bs_get_position(bs);\n\tptr->config = gf_odf_hevc_cfg_read_bs(bs, (s->type == GF_ISOM_BOX_TYPE_HVCC) ? GF_FALSE : GF_TRUE);\n\tpos = gf_bs_get_position(bs) - pos ;\n\tif (pos < ptr->size)\n\t\tptr->size -= (u32) pos;\n\n\treturn ptr->config ? GF_OK : GF_ISOM_INVALID_FILE;\n}\nGF_Box *hvcc_New()\n{\n\tGF_HEVCConfigurationBox *tmp = (GF_HEVCConfigurationBox *) gf_malloc(sizeof(GF_HEVCConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_HEVCConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_HVCC;\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hvcc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\treturn gf_odf_hevc_cfg_write_bs(ptr->config, bs);\n}\nGF_Err hvcc_Size(GF_Box *s)\n{\n\tu32 i, count, j, subcount;\n\tGF_HEVCConfigurationBox *ptr = (GF_HEVCConfigurationBox *)s;\n\n\tif (!ptr->config) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (!ptr->config->is_lhvc)\n\t\tptr->size += 23;\n\telse\n\t\tptr->size += 6;\n\n\tcount = gf_list_count(ptr->config->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_HEVCParamArray *ar = (GF_HEVCParamArray*)gf_list_get(ptr->config->param_array, i);\n\t\tptr->size += 3;\n\t\tsubcount = gf_list_count(ar->nalus);\n\t\tfor (j=0; j<subcount; j++) {\n\t\t\tptr->size += 2 + ((GF_AVCConfigSlot *)gf_list_get(ar->nalus, j))->size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_OperatingPointsInformation *gf_isom_oinf_new_entry()\n{\n\tGF_OperatingPointsInformation* ptr;\n\tGF_SAFEALLOC(ptr, GF_OperatingPointsInformation);\n\tif (ptr) {\n\t\tptr->profile_tier_levels = gf_list_new();\n\t\tptr->operating_points = gf_list_new();\n\t\tptr->dependency_layers = gf_list_new();\n\t}\n\treturn ptr;\n\n}\n\nvoid gf_isom_oinf_del_entry(void *entry)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tif (!ptr) return;\n\tif (ptr->profile_tier_levels) {\n\t\twhile (gf_list_count(ptr->profile_tier_levels)) {\n\t\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, 0);\n\t\t\tgf_free(ptl);\n\t\t\tgf_list_rem(ptr->profile_tier_levels, 0);\n\t\t}\n\t\tgf_list_del(ptr->profile_tier_levels);\n\t}\n\tif (ptr->operating_points) {\n\t\twhile (gf_list_count(ptr->operating_points)) {\n\t\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, 0);\n\t\t\tgf_free(op);\n\t\t\tgf_list_rem(ptr->operating_points, 0);\n\t\t}\n\t\tgf_list_del(ptr->operating_points);\n\t}\n\tif (ptr->dependency_layers) {\n\t\twhile (gf_list_count(ptr->dependency_layers)) {\n\t\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, 0);\n\t\t\tgf_free(dep);\n\t\t\tgf_list_rem(ptr->dependency_layers, 0);\n\t\t}\n\t\tgf_list_del(ptr->dependency_layers);\n\t}\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tptr->scalability_mask = gf_bs_read_u16(bs);\n\tgf_bs_read_int(bs, 2);//reserved\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl;\n\t\tGF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);\n\t\tif (!ptl) return GF_OUT_OF_MEM;\n\t\tptl->general_profile_space = gf_bs_read_int(bs, 2);\n\t\tptl->general_tier_flag= gf_bs_read_int(bs, 1);\n\t\tptl->general_profile_idc = gf_bs_read_int(bs, 5);\n\t\tptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);\n\t\tptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);\n\t\tptl->general_level_idc = gf_bs_read_u8(bs);\n\t\tgf_list_add(ptr->profile_tier_levels, ptl);\n\t}\n\tcount = gf_bs_read_u16(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top->max_temporal_id = gf_bs_read_u8(bs);\n\t\top->layer_count = gf_bs_read_u8(bs);\n\t\tif (op->layer_count > ARRAY_LENGTH(op->layers_info))\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\top->minPicWidth = gf_bs_read_u16(bs);\n\t\top->minPicHeight = gf_bs_read_u16(bs);\n\t\top->maxPicWidth = gf_bs_read_u16(bs);\n\t\top->maxPicHeight = gf_bs_read_u16(bs);\n\t\top->maxChromaFormat = gf_bs_read_int(bs, 2);\n\t\top->maxBitDepth = gf_bs_read_int(bs, 3) + 8;\n\t\tgf_bs_read_int(bs, 1);//reserved\n\t\top->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\top->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\tif (op->frame_rate_info_flag) {\n\t\t\top->avgFrameRate = gf_bs_read_u16(bs);\n\t\t\tgf_bs_read_int(bs, 6); //reserved\n\t\t\top->constantFrameRate = gf_bs_read_int(bs, 2);\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\top->maxBitRate = gf_bs_read_u32(bs);\n\t\t\top->avgBitRate = gf_bs_read_u32(bs);\n\t\t}\n\t\tgf_list_add(ptr->operating_points, op);\n\t}\n\tcount = gf_bs_read_u8(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep;\n\t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);\n\t\tif (!dep) return GF_OUT_OF_MEM;\n\t\tdep->dependent_layerID = gf_bs_read_u8(bs);\n\t\tdep->num_layers_dependent_on = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\tdep->dependent_on_layerID[j] = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tdep->dimension_identifier[j] = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_add(ptr->dependency_layers, dep);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_oinf_write_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\tif (!ptr) return GF_OK;\n\n\tgf_bs_write_u16(bs, ptr->scalability_mask);\n\tgf_bs_write_int(bs, 0xFF, 2);//reserved\n\tcount=gf_list_count(ptr->profile_tier_levels);\n\tgf_bs_write_int(bs, count, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, i);\n\t\tgf_bs_write_int(bs, ptl->general_profile_space, 2);\n\t\tgf_bs_write_int(bs, ptl->general_tier_flag, 1);\n\t\tgf_bs_write_int(bs, ptl->general_profile_idc, 5);\n\t\tgf_bs_write_u32(bs, ptl->general_profile_compatibility_flags);\n\t\tgf_bs_write_long_int(bs, ptl->general_constraint_indicator_flags, 48);\n\t\tgf_bs_write_u8(bs, ptl->general_level_idc);\n\t}\n\tcount=gf_list_count(ptr->operating_points);\n\tgf_bs_write_u16(bs, count);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);;\n\t\tgf_bs_write_u16(bs, op->output_layer_set_idx);\n\t\tgf_bs_write_u8(bs, op->max_temporal_id);\n\t\tgf_bs_write_u8(bs, op->layer_count);\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\tgf_bs_write_u8(bs, op->layers_info[j].ptl_idx);\n\t\t\tgf_bs_write_int(bs, op->layers_info[j].layer_id, 6);\n\t\t\top->layers_info[j].is_outputlayer ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\t\top->layers_info[j].is_alternate_outputlayer ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\t}\n\t\tgf_bs_write_u16(bs, op->minPicWidth);\n\t\tgf_bs_write_u16(bs, op->minPicHeight);\n\t\tgf_bs_write_u16(bs, op->maxPicWidth);\n\t\tgf_bs_write_u16(bs, op->maxPicHeight);\n\t\tgf_bs_write_int(bs, op->maxChromaFormat, 2);\n\t\tgf_bs_write_int(bs, op->maxBitDepth - 8, 3);\n\t\tgf_bs_write_int(bs, 0x1, 1);//resereved\n\t\top->frame_rate_info_flag ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\top->bit_rate_info_flag ? gf_bs_write_int(bs, 0x1, 1)  : gf_bs_write_int(bs, 0x0, 1);\n\t\tif (op->frame_rate_info_flag) {\n\t\t\tgf_bs_write_u16(bs, op->avgFrameRate);\n\t\t\tgf_bs_write_int(bs, 0xFF, 6); //reserved\n\t\t\tgf_bs_write_int(bs, op->constantFrameRate, 2);\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\tgf_bs_write_u32(bs, op->maxBitRate);\n\t\t\tgf_bs_write_u32(bs, op->avgBitRate);\n\t\t}\n\t}\n\tcount=gf_list_count(ptr->dependency_layers);\n\tgf_bs_write_u8(bs, count);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);\n\t\tgf_bs_write_u8(bs, dep->dependent_layerID);\n\t\tgf_bs_write_u8(bs, dep->num_layers_dependent_on);\n\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\tgf_bs_write_u8(bs, dep->dependent_on_layerID[j]);\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tgf_bs_write_u8(bs, dep->dimension_identifier[j]);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nu32 gf_isom_oinf_size_entry(void *entry)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 size = 0, i ,j, count;\n\tif (!ptr) return 0;\n\n\tsize += 3; //scalability_mask + reserved + num_profile_tier_level\n\tcount=gf_list_count(ptr->profile_tier_levels);\n\tsize += count * 12; //general_profile_space + general_tier_flag + general_profile_idc + general_profile_compatibility_flags + general_constraint_indicator_flags + general_level_idc\n\tsize += 2;//num_operating_points\n\tcount=gf_list_count(ptr->operating_points);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);;\n\t\tsize += 2/*output_layer_set_idx*/ + 1/*max_temporal_id*/ + 1/*layer_count*/;\n\t\tsize += op->layer_count * 2;\n\t\tsize += 9;\n\t\tif (op->frame_rate_info_flag) {\n\t\t\tsize += 3;\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\tsize += 8;\n\t\t}\n\t}\n\tsize += 1;//max_layer_count\n\tcount=gf_list_count(ptr->dependency_layers);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);\n\t\tsize += 1/*dependent_layerID*/ + 1/*num_layers_dependent_on*/;\n\t\tsize += dep->num_layers_dependent_on * 1;//dependent_on_layerID\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tsize += 1;//dimension_identifier\n\t\t}\n\t}\n\treturn size;\n}\n\n\nGF_LHVCLayerInformation *gf_isom_linf_new_entry()\n{\n\tGF_LHVCLayerInformation* ptr;\n\tGF_SAFEALLOC(ptr, GF_LHVCLayerInformation);\n\tif (ptr) ptr->num_layers_in_track = gf_list_new();\n\n\treturn ptr;\n\n}\n\nvoid gf_isom_linf_del_entry(void *entry)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tif (!ptr) return;\n\twhile (gf_list_count(ptr->num_layers_in_track)) {\n\t\tLHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, 0);\n\t\tgf_free(li);\n\t\tgf_list_rem(ptr->num_layers_in_track, 0);\n\t}\n\tgf_list_del(ptr->num_layers_in_track);\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err gf_isom_linf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tu32 i, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tgf_bs_read_int(bs, 2);\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHVCLayerInfoItem *li;\n\t\tGF_SAFEALLOC(li, LHVCLayerInfoItem);\n\t\tif (!li) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_int(bs, 4);\n\t\tli->layer_id = gf_bs_read_int(bs, 6);\n\t\tli->min_TemporalId = gf_bs_read_int(bs, 3);\n\t\tli->max_TemporalId = gf_bs_read_int(bs, 3);\n\t\tgf_bs_read_int(bs, 1);\n\t\tli->sub_layer_presence_flags = gf_bs_read_int(bs, 7);\n\t\tgf_list_add(ptr->num_layers_in_track, li);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_linf_write_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tu32 i, count;\n\tif (!ptr) return GF_OK;\n\n\tgf_bs_write_int(bs, 0, 2);\n\tcount=gf_list_count(ptr->num_layers_in_track);\n\tgf_bs_write_int(bs, count, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, i);\n\t\tgf_bs_write_int(bs, 0, 4);\n\t\tgf_bs_write_int(bs, li->layer_id, 6);\n\t\tgf_bs_write_int(bs, li->min_TemporalId, 3);\n\t\tgf_bs_write_int(bs, li->max_TemporalId, 3);\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, li->sub_layer_presence_flags, 7);\n\t}\n\treturn GF_OK;\n}\n\nu32 gf_isom_linf_size_entry(void *entry)\n{\n\tGF_LHVCLayerInformation* ptr = (GF_LHVCLayerInformation *)entry;\n\tu32 size = 0, count;\n\tif (!ptr) return 0;\n\n\tsize += 1;\n\tcount=gf_list_count(ptr->num_layers_in_track);\n\tsize += count * 3;\n\treturn size;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre, Romain Bouqueau, Cyril Concolato\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/media_dev.h>\n#include <gpac/constants.h>\n#include <gpac/mpeg4_odf.h>\n#include <gpac/maths.h>\n\n#ifndef GPAC_DISABLE_OGG\n#include <gpac/internal/ogg.h>\n#endif\n\nstatic const struct {\n\tu32 w, h;\n} std_par[ ] =\n{\n\t{ 4, 3}, {3, 2}, {16, 9}, {5, 3}, {5, 4}, {8, 5}, {2, 1},\n\t{0, 0},\n};\n\nGF_EXPORT\nvoid gf_media_reduce_aspect_ratio(u32 *width, u32 *height)\n{\n\tu32 i=0;\n\tu32 w = *width;\n\tu32 h = *height;\n\twhile (std_par[i].w) {\n\t\tif (std_par[i].w * h == std_par[i].h * w) {\n\t\t\t*width = std_par[i].w;\n\t\t\t*height = std_par[i].h;\n\t\t\treturn;\n\t\t}\n\t\ti++;\n\t}\n}\n\nGF_EXPORT\nvoid gf_media_get_reduced_frame_rate(u32 *timescale, u32 *sample_dur)\n{\n\tu32 res;\n\tif (! *sample_dur) return;\n\tres = *timescale / *sample_dur;\n\tif (res **sample_dur == *timescale) {\n\t\t*timescale = res;\n\t\t*sample_dur = 1;\n\t} else if ((double)(*timescale * 1001 - (res+1) * *sample_dur * 1000) / ((res+1) * *sample_dur * 1000) < 0.001) {\n\t\t*timescale = (res+1) * 1000;\n\t\t*sample_dur = 1001;\n\t}\n}\n\nGF_EXPORT\nconst char *gf_m4v_get_profile_name(u8 video_pl)\n{\n\tswitch (video_pl) {\n\tcase 0x00:\n\t\treturn \"Reserved (0x00) Profile\";\n\tcase 0x01:\n\t\treturn \"Simple Profile @ Level 1\";\n\tcase 0x02:\n\t\treturn \"Simple Profile @ Level 2\";\n\tcase 0x03:\n\t\treturn \"Simple Profile @ Level 3\";\n\tcase 0x08:\n\t\treturn \"Simple Profile @ Level 0\";\n\tcase 0x10:\n\t\treturn \"Simple Scalable Profile @ Level 0\";\n\tcase 0x11:\n\t\treturn \"Simple Scalable Profile @ Level 1\";\n\tcase 0x12:\n\t\treturn \"Simple Scalable Profile @ Level 2\";\n\tcase 0x21:\n\t\treturn \"Core Profile @ Level 1\";\n\tcase 0x22:\n\t\treturn \"Core Profile @ Level 2\";\n\tcase 0x32:\n\t\treturn \"Main Profile @ Level 2\";\n\tcase 0x33:\n\t\treturn \"Main Profile @ Level 3\";\n\tcase 0x34:\n\t\treturn \"Main Profile @ Level 4\";\n\tcase 0x42:\n\t\treturn \"N-bit Profile @ Level 2\";\n\tcase 0x51:\n\t\treturn \"Scalable Texture Profile @ Level 1\";\n\tcase 0x61:\n\t\treturn \"Simple Face Animation Profile @ Level 1\";\n\tcase 0x62:\n\t\treturn \"Simple Face Animation Profile @ Level 2\";\n\tcase 0x63:\n\t\treturn \"Simple FBA Profile @ Level 1\";\n\tcase 0x64:\n\t\treturn \"Simple FBA Profile @ Level 2\";\n\tcase 0x71:\n\t\treturn \"Basic Animated Texture Profile @ Level 1\";\n\tcase 0x72:\n\t\treturn \"Basic Animated Texture Profile @ Level 2\";\n\tcase 0x7F:\n\t\treturn \"AVC/H264 Profile\";\n\tcase 0x81:\n\t\treturn \"Hybrid Profile @ Level 1\";\n\tcase 0x82:\n\t\treturn \"Hybrid Profile @ Level 2\";\n\tcase 0x91:\n\t\treturn \"Advanced Real Time Simple Profile @ Level 1\";\n\tcase 0x92:\n\t\treturn \"Advanced Real Time Simple Profile @ Level 2\";\n\tcase 0x93:\n\t\treturn \"Advanced Real Time Simple Profile @ Level 3\";\n\tcase 0x94:\n\t\treturn \"Advanced Real Time Simple Profile @ Level 4\";\n\tcase 0xA1:\n\t\treturn \"Core Scalable Profile @ Level1\";\n\tcase 0xA2:\n\t\treturn \"Core Scalable Profile @ Level2\";\n\tcase 0xA3:\n\t\treturn \"Core Scalable Profile @ Level3\";\n\tcase 0xB1:\n\t\treturn \"Advanced Coding Efficiency Profile @ Level 1\";\n\tcase 0xB2:\n\t\treturn \"Advanced Coding Efficiency Profile @ Level 2\";\n\tcase 0xB3:\n\t\treturn \"Advanced Coding Efficiency Profile @ Level 3\";\n\tcase 0xB4:\n\t\treturn \"Advanced Coding Efficiency Profile @ Level 4\";\n\tcase 0xC1:\n\t\treturn \"Advanced Core Profile @ Level 1\";\n\tcase 0xC2:\n\t\treturn \"Advanced Core Profile @ Level 2\";\n\tcase 0xD1:\n\t\treturn \"Advanced Scalable Texture @ Level1\";\n\tcase 0xD2:\n\t\treturn \"Advanced Scalable Texture @ Level2\";\n\tcase 0xE1:\n\t\treturn \"Simple Studio Profile @ Level 1\";\n\tcase 0xE2:\n\t\treturn \"Simple Studio Profile @ Level 2\";\n\tcase 0xE3:\n\t\treturn \"Simple Studio Profile @ Level 3\";\n\tcase 0xE4:\n\t\treturn \"Simple Studio Profile @ Level 4\";\n\tcase 0xE5:\n\t\treturn \"Core Studio Profile @ Level 1\";\n\tcase 0xE6:\n\t\treturn \"Core Studio Profile @ Level 2\";\n\tcase 0xE7:\n\t\treturn \"Core Studio Profile @ Level 3\";\n\tcase 0xE8:\n\t\treturn \"Core Studio Profile @ Level 4\";\n\tcase 0xF0:\n\t\treturn \"Advanced Simple Profile @ Level 0\";\n\tcase 0xF1:\n\t\treturn \"Advanced Simple Profile @ Level 1\";\n\tcase 0xF2:\n\t\treturn \"Advanced Simple Profile @ Level 2\";\n\tcase 0xF3:\n\t\treturn \"Advanced Simple Profile @ Level 3\";\n\tcase 0xF4:\n\t\treturn \"Advanced Simple Profile @ Level 4\";\n\tcase 0xF5:\n\t\treturn \"Advanced Simple Profile @ Level 5\";\n\tcase 0xF7:\n\t\treturn \"Advanced Simple Profile @ Level 3b\";\n\tcase 0xF8:\n\t\treturn \"Fine Granularity Scalable Profile @ Level 0\";\n\tcase 0xF9:\n\t\treturn \"Fine Granularity Scalable Profile @ Level 1\";\n\tcase 0xFA:\n\t\treturn \"Fine Granularity Scalable Profile @ Level 2\";\n\tcase 0xFB:\n\t\treturn \"Fine Granularity Scalable Profile @ Level 3\";\n\tcase 0xFC:\n\t\treturn \"Fine Granularity Scalable Profile @ Level 4\";\n\tcase 0xFD:\n\t\treturn \"Fine Granularity Scalable Profile @ Level 5\";\n\tcase 0xFE:\n\t\treturn \"Not part of MPEG-4 Visual profiles\";\n\tcase 0xFF:\n\t\treturn \"No visual capability required\";\n\tdefault:\n\t\treturn \"ISO Reserved Profile\";\n\t}\n}\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n#define MPEG12_START_CODE_PREFIX\t\t0x000001\n#define MPEG12_PICTURE_START_CODE\t\t0x00000100\n#define MPEG12_SLICE_MIN_START\t\t\t0x00000101\n#define MPEG12_SLICE_MAX_START\t\t\t0x000001af\n#define MPEG12_USER_DATA_START_CODE\t\t0x000001b2\n#define MPEG12_SEQUENCE_START_CODE\t\t0x000001b3\n#define MPEG12_SEQUENCE_ERR_START_CODE\t0x000001b4\n#define MPEG12_EXT_START_CODE\t\t\t0x000001b5\n#define MPEG12_SEQUENCE_END_START_CODE\t0x000001b7\n#define MPEG12_GOP_START_CODE\t\t\t0x000001b8\n\ns32 gf_mv12_next_start_code(unsigned char *pbuffer, u32 buflen, u32 *optr, u32 *scode)\n{\n\tu32 value;\n\tu32 offset;\n\n\tif (buflen < 4) return -1;\n\tfor (offset = 0; offset < buflen - 3; offset++, pbuffer++) {\n#ifdef GPAC_BIG_ENDIAN\n\t\tvalue = *(u32 *)pbuffer >> 8;\n#else\n\t\tvalue = (pbuffer[0] << 16) | (pbuffer[1] << 8) | (pbuffer[2] << 0);\n#endif\n\n\t\tif (value == MPEG12_START_CODE_PREFIX) {\n\t\t\t*optr = offset;\n\t\t\t*scode = (value << 8) | pbuffer[3];\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\ns32 gf_mv12_next_slice_start(unsigned char *pbuffer, u32 startoffset, u32 buflen, u32 *slice_offset)\n{\n\tu32 slicestart, code;\n\twhile (gf_mv12_next_start_code(pbuffer + startoffset, buflen - startoffset, &slicestart, &code) >= 0) {\n\t\tif ((code >= MPEG12_SLICE_MIN_START) && (code <= MPEG12_SLICE_MAX_START)) {\n\t\t\t*slice_offset = slicestart + startoffset;\n\t\t\treturn 0;\n\t\t}\n\t\tstartoffset += slicestart + 4;\n\t}\n\treturn -1;\n}\n\n\n/*\n\tMPEG-4 video (14496-2)\n*/\n\n#define M4V_VO_START_CODE\t\t\t\t\t0x00\n#define M4V_VOL_START_CODE\t\t\t\t\t0x20\n#define M4V_VOP_START_CODE\t\t\t\t\t0xB6\n#define M4V_VISOBJ_START_CODE\t\t\t\t0xB5\n#define M4V_VOS_START_CODE\t\t\t\t\t0xB0\n#define M4V_GOV_START_CODE\t\t\t\t\t0xB3\n#define M4V_UDTA_START_CODE\t\t\t\t\t0xB2\n\n\n#define M2V_PIC_START_CODE\t\t\t\t\t0x00\n#define M2V_SEQ_START_CODE\t\t\t\t\t0xB3\n#define M2V_EXT_START_CODE\t\t\t\t\t0xB5\n#define M2V_GOP_START_CODE\t\t\t\t\t0xB8\n\nstruct __tag_m4v_parser\n{\n\tGF_BitStream *bs;\n\tBool mpeg12;\n\tu32 current_object_type;\n\tu64 current_object_start;\n\tu32 tc_dec, prev_tc_dec, tc_disp, prev_tc_disp;\n};\n\nGF_EXPORT\nGF_M4VParser *gf_m4v_parser_new(char *data, u64 data_size, Bool mpeg12video)\n{\n\tGF_M4VParser *tmp;\n\tif (!data || !data_size) return NULL;\n\tGF_SAFEALLOC(tmp, GF_M4VParser);\n\tif (!tmp) return NULL;\n\ttmp->bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\ttmp->mpeg12 = mpeg12video;\n\treturn tmp;\n}\n\nGF_M4VParser *gf_m4v_parser_bs_new(GF_BitStream *bs, Bool mpeg12video)\n{\n\tGF_M4VParser *tmp;\n\tGF_SAFEALLOC(tmp, GF_M4VParser);\n\tif (!tmp) return NULL;\n\ttmp->bs = bs;\n\ttmp->mpeg12 = mpeg12video;\n\treturn tmp;\n}\n\nGF_EXPORT\nvoid gf_m4v_parser_del(GF_M4VParser *m4v)\n{\n\tgf_bs_del(m4v->bs);\n\tgf_free(m4v);\n}\n\n\n#define M4V_CACHE_SIZE\t\t4096\ns32 M4V_LoadObject(GF_M4VParser *m4v)\n{\n\tu32 v, bpos, found;\n\tchar m4v_cache[M4V_CACHE_SIZE];\n\tu64 end, cache_start, load_size;\n\tif (!m4v) return 0;\n\tbpos = 0;\n\tfound = 0;\n\tload_size = 0;\n\tend = 0;\n\tcache_start = 0;\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\t/*refill cache*/\n\t\tif (bpos == (u32) load_size) {\n\t\t\tif (!gf_bs_available(m4v->bs)) break;\n\t\t\tload_size = gf_bs_available(m4v->bs);\n\t\t\tif (load_size>M4V_CACHE_SIZE) load_size=M4V_CACHE_SIZE;\n\t\t\tbpos = 0;\n\t\t\tcache_start = gf_bs_get_position(m4v->bs);\n\t\t\tgf_bs_read_data(m4v->bs, m4v_cache, (u32) load_size);\n\t\t}\n\t\tv = ( (v<<8) & 0xFFFFFF00) | ((u8) m4v_cache[bpos]);\n\t\tbpos++;\n\t\tif ((v & 0xFFFFFF00) == 0x00000100) {\n\t\t\tend = cache_start+bpos-4;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) return -1;\n\tm4v->current_object_start = end;\n\tgf_bs_seek(m4v->bs, end+3);\n\tm4v->current_object_type = gf_bs_read_u8(m4v->bs);\n\treturn (s32) m4v->current_object_type;\n}\n\n\nGF_EXPORT\nvoid gf_m4v_rewrite_pl(char **o_data, u32 *o_dataLen, u8 PL)\n{\n\tu32 pos = 0;\n\tunsigned char *data = (unsigned char *)*o_data;\n\tu32 dataLen = *o_dataLen;\n\n\twhile (pos+4<dataLen) {\n\t\tif (!data[pos] && !data[pos+1] && (data[pos+2]==0x01) && (data[pos+3]==M4V_VOS_START_CODE)) {\n\t\t\tdata[pos+4] = PL;\n\t\t\treturn;\n\t\t}\n\t\tpos ++;\n\t}\n\t/*emulate VOS at beggining*/\n\t(*o_data) = (char *)gf_malloc(sizeof(char)*(dataLen+5));\n\t(*o_data)[0] = 0;\n\t(*o_data)[1] = 0;\n\t(*o_data)[2] = 1;\n\t(*o_data)[3] = (char) M4V_VOS_START_CODE;\n\t(*o_data)[4] = PL;\n\tmemcpy( (*o_data + 5), data, sizeof(char)*dataLen);\n\tgf_free(data);\n\t(*o_dataLen) = dataLen + 5;\n}\n\nstatic GF_Err M4V_Reset(GF_M4VParser *m4v, u64 start)\n{\n\tgf_bs_seek(m4v->bs, start);\n\tassert(start < 1<<31);\n\tm4v->current_object_start = (u32) start;\n\tm4v->current_object_type = 0;\n\treturn GF_OK;\n}\n\n\nstatic GF_Err gf_m4v_parse_config_mpeg12(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\tunsigned char p[4];\n\tu32 ext_type;\n\ts32 o_type;\n\tu8 go, par;\n\n\tif (!m4v || !dsi) return GF_BAD_PARAM;\n\n\tmemset(dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tdsi->VideoPL = 0;\n\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M2V_SEQ_START_CODE:\n\t\t\tdsi->RAP_stream = 1;\n\t\t\tgf_bs_read_data(m4v->bs,  (char *) p, 4);\n\t\t\tdsi->width = (p[0] << 4) | ((p[1] >> 4) & 0xf);\n\t\t\tdsi->height = ((p[1] & 0xf) << 8) | p[2];\n\n\t\t\tdsi->VideoPL = GPAC_OTI_VIDEO_MPEG1;\n\t\t\tpar = (p[3] >> 4) & 0xf;\n\t\t\tswitch (par) {\n\t\t\tcase 2:\n\t\t\t\tdsi->par_num = dsi->height/3;\n\t\t\t\tdsi->par_den = dsi->width/4;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdsi->par_num = dsi->height/9;\n\t\t\t\tdsi->par_den = dsi->width/16;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdsi->par_num = dsi->height/2;\n\t\t\t\tdsi->par_den = dsi->width/21;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdsi->par_den = dsi->par_num = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (p[3] & 0xf) {\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tdsi->fps = 24000.0/1001.0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdsi->fps = 24.0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdsi->fps = 25.0;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdsi->fps = 30000.0/1001.0;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tdsi->fps = 30.0;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tdsi->fps = 50.0;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tdsi->fps = ((60.0*1000.0)/1001.0);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tdsi->fps = 60.0;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tdsi->fps = 1;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tdsi->fps = 5;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tdsi->fps = 10;\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\tdsi->fps = 12;\n\t\t\t\tbreak;\n\t\t\tcase 13:\n\t\t\t\tdsi->fps = 15;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase M2V_EXT_START_CODE:\n\t\t\tgf_bs_read_data(m4v->bs,  (char *) p, 4);\n\t\t\text_type = ((p[0] >> 4) & 0xf);\n\t\t\tif (ext_type == 1) {\n\t\t\t\tdsi->VideoPL = 0x65;\n\t\t\t\tdsi->height = ((p[1] & 0x1) << 13) | ((p[2] & 0x80) << 5) | (dsi->height & 0x0fff);\n\t\t\t\tdsi->width = (((p[2] >> 5) & 0x3) << 12) | (dsi->width & 0x0fff);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase M2V_PIC_START_CODE:\n\t\t\tif (dsi->width) go = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t/*EOS*/\n\t\tcase -1:\n\t\t\tgo = 0;\n\t\t\tm4v->current_object_start = gf_bs_get_position(m4v->bs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tM4V_Reset(m4v, 0);\n\treturn GF_OK;\n}\n\n\nstatic const struct {\n\tu32 w, h;\n} m4v_sar[6] = { { 0,   0 }, { 1,   1 }, { 12, 11 }, { 10, 11 }, { 16, 11 }, { 40, 33 } };\n\nstatic u8 m4v_get_sar_idx(u32 w, u32 h)\n{\n\tu32 i;\n\tfor (i=0; i<6; i++) {\n\t\tif ((m4v_sar[i].w==w) && (m4v_sar[i].h==h)) return i;\n\t}\n\treturn 0xF;\n}\n\nstatic GF_Err gf_m4v_parse_config_mpeg4(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\ts32 o_type;\n\tu8 go, verid, par;\n\ts32 clock_rate;\n\n\tif (!m4v || !dsi) return GF_BAD_PARAM;\n\n\tmemset(dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\t/*vosh*/\n\t\tcase M4V_VOS_START_CODE:\n\t\t\tdsi->VideoPL = (u8) gf_bs_read_u8(m4v->bs);\n\t\t\tbreak;\n\n\t\tcase M4V_VOL_START_CODE:\n\t\t\tverid = 0;\n\t\t\tdsi->RAP_stream = gf_bs_read_int(m4v->bs, 1);\n\t\t\tdsi->objectType = gf_bs_read_int(m4v->bs, 8);\n\t\t\tif (gf_bs_read_int(m4v->bs, 1)) {\n\t\t\t\tverid = gf_bs_read_int(m4v->bs, 4);\n\t\t\t\tgf_bs_read_int(m4v->bs, 3);\n\t\t\t}\n\t\t\tpar = gf_bs_read_int(m4v->bs, 4);\n\t\t\tif (par == 0xF) {\n\t\t\t\tdsi->par_num = gf_bs_read_int(m4v->bs, 8);\n\t\t\t\tdsi->par_den = gf_bs_read_int(m4v->bs, 8);\n\t\t\t} else if (par<6) {\n\t\t\t\tdsi->par_num = m4v_sar[par].w;\n\t\t\t\tdsi->par_den = m4v_sar[par].h;\n\t\t\t}\n\t\t\tif (gf_bs_read_int(m4v->bs, 1)) {\n\t\t\t\tgf_bs_read_int(m4v->bs, 3);\n\t\t\t\tif (gf_bs_read_int(m4v->bs, 1)) gf_bs_read_int(m4v->bs, 79);\n\t\t\t}\n\t\t\tdsi->has_shape = gf_bs_read_int(m4v->bs, 2);\n\t\t\tif (dsi->has_shape && (verid!=1) ) gf_bs_read_int(m4v->bs, 4);\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t/*clock rate*/\n\t\t\tdsi->clock_rate = gf_bs_read_int(m4v->bs, 16);\n\t\t\t/*marker*/\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\n\t\t\tclock_rate = dsi->clock_rate-1;\n\t\t\tif (clock_rate >= 65536) clock_rate = 65535;\n\t\t\tif (clock_rate > 0) {\n\t\t\t\tfor (dsi->NumBitsTimeIncrement = 1; dsi->NumBitsTimeIncrement < 16; dsi->NumBitsTimeIncrement++)\t{\n\t\t\t\t\tif (clock_rate == 1) break;\n\t\t\t\t\tclock_rate = (clock_rate >> 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*fix from vivien for divX*/\n\t\t\t\tdsi->NumBitsTimeIncrement = 1;\n\t\t\t}\n\t\t\t/*fixed FPS stream*/\n\t\t\tdsi->time_increment = 0;\n\t\t\tif (gf_bs_read_int(m4v->bs, 1)) {\n\t\t\t\tdsi->time_increment = gf_bs_read_int(m4v->bs, dsi->NumBitsTimeIncrement);\n\t\t\t}\n\t\t\tif (!dsi->has_shape) {\n\t\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t\tdsi->width = gf_bs_read_int(m4v->bs, 13);\n\t\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t\tdsi->height = gf_bs_read_int(m4v->bs, 13);\n\t\t\t} else {\n\t\t\t\tdsi->width = dsi->height = 0;\n\t\t\t}\n\t\t\t/*shape will be done later*/\n\t\t\tgf_bs_align(m4v->bs);\n\t\t\tbreak;\n\n\t\tcase M4V_VOP_START_CODE:\n\t\tcase M4V_GOV_START_CODE:\n\t\t\tgo = 0;\n\t\t\tbreak;\n\t\t/*EOS*/\n\t\tcase -1:\n\t\t\tgo = 0;\n\t\t\tm4v->current_object_start = gf_bs_get_position(m4v->bs);\n\t\t\tbreak;\n\t\t/*don't interest us*/\n\t\tcase M4V_UDTA_START_CODE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4v_parse_config(GF_M4VParser *m4v, GF_M4VDecSpecInfo *dsi)\n{\n\tif (m4v->mpeg12) {\n\t\treturn gf_m4v_parse_config_mpeg12(m4v, dsi);\n\t} else {\n\t\treturn gf_m4v_parse_config_mpeg4(m4v, dsi);\n\t}\n}\n\nstatic GF_Err gf_m4v_parse_frame_mpeg12(GF_M4VParser *m4v, GF_M4VDecSpecInfo dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tu8 go, hasVOP, firstObj, val;\n\ts32 o_type;\n\n\tif (!m4v || !size || !start || !frame_type) return GF_BAD_PARAM;\n\n\t*size = 0;\n\tfirstObj = 1;\n\thasVOP = 0;\n\t*is_coded = GF_FALSE;\n\tm4v->current_object_type = (u32) -1;\n\t*frame_type = 0;\n\n\tM4V_Reset(m4v, m4v->current_object_start);\n\tgo = 1;\n\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M2V_PIC_START_CODE:\n\t\t\t/*done*/\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\thasVOP = 1;\n\t\t\t*is_coded = 1;\n\n\t\t\t/*val = */gf_bs_read_u8(m4v->bs);\n\t\t\tval = gf_bs_read_u8(m4v->bs);\n\t\t\t*frame_type = ( (val >> 3) & 0x7 ) - 1;\n\t\t\tbreak;\n\t\tcase M2V_GOP_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) go = 0;\n\t\t\tbreak;\n\n\t\tcase M2V_SEQ_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/**/\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\n\t\tcase -1:\n\t\t\t*size = gf_bs_get_position(m4v->bs) - *start;\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\n\t*size = m4v->current_object_start - *start;\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_m4v_parse_frame_mpeg4(GF_M4VParser *m4v, GF_M4VDecSpecInfo dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tu8 go, hasVOP, firstObj, secs;\n\ts32 o_type;\n\tu32 vop_inc = 0;\n\n\tif (!m4v || !size || !start || !frame_type) return GF_BAD_PARAM;\n\n\t*size = 0;\n\tfirstObj = 1;\n\thasVOP = 0;\n\t*is_coded = 0;\n\tm4v->current_object_type = (u32) -1;\n\t*frame_type = 0;\n\n\tM4V_Reset(m4v, m4v->current_object_start);\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M4V_VOP_START_CODE:\n\t\t\t/*done*/\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\thasVOP = 1;\n\n\t\t\t/*coding type*/\n\t\t\t*frame_type = gf_bs_read_int(m4v->bs, 2);\n\t\t\t/*modulo time base*/\n\t\t\tsecs = 0;\n\t\t\twhile (gf_bs_read_int(m4v->bs, 1) != 0)\n\t\t\t\tsecs ++;\n\t\t\t/*no support for B frames in parsing*/\n\t\t\tsecs += (dsi.enh_layer || *frame_type!=2) ? m4v->tc_dec : m4v->tc_disp;\n\t\t\t/*marker*/\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t/*vop_time_inc*/\n\t\t\tif (dsi.NumBitsTimeIncrement)\n\t\t\t\tvop_inc = gf_bs_read_int(m4v->bs, dsi.NumBitsTimeIncrement);\n\n\t\t\tm4v->prev_tc_dec = m4v->tc_dec;\n\t\t\tm4v->prev_tc_disp = m4v->tc_disp;\n\t\t\tif (dsi.enh_layer || *frame_type!=2) {\n\t\t\t\tm4v->tc_disp = m4v->tc_dec;\n\t\t\t\tm4v->tc_dec = secs;\n\t\t\t}\n\t\t\t*time_inc = secs * dsi.clock_rate + vop_inc;\n\t\t\t/*marker*/\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t/*coded*/\n\t\t\t*is_coded = gf_bs_read_int(m4v->bs, 1);\n\t\t\tgf_bs_align(m4v->bs);\n\t\t\tbreak;\n\t\tcase M4V_GOV_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) go = 0;\n\t\t\tbreak;\n\n\t\tcase M4V_VOS_START_CODE:\n\t\tcase M4V_VOL_START_CODE:\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t} else if (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase M4V_VO_START_CODE:\n\t\tdefault:\n\t\t\tbreak;\n\n\t\tcase -1:\n\t\t\t*size = gf_bs_get_position(m4v->bs) - *start;\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\n\t*size = m4v->current_object_start - *start;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4v_parse_frame(GF_M4VParser *m4v, GF_M4VDecSpecInfo dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tif (m4v->mpeg12) {\n\t\treturn gf_m4v_parse_frame_mpeg12(m4v, dsi, frame_type, time_inc, size, start, is_coded);\n\t} else {\n\t\treturn gf_m4v_parse_frame_mpeg4(m4v, dsi, frame_type, time_inc, size, start, is_coded);\n\t}\n}\n\nGF_Err gf_m4v_rewrite_par(char **o_data, u32 *o_dataLen, s32 par_n, s32 par_d)\n{\n\tu64 start, end, size;\n\tGF_BitStream *mod;\n\tGF_M4VParser *m4v;\n\tBool go = 1;\n\n\tm4v = gf_m4v_parser_new(*o_data, *o_dataLen, 0);\n\tmod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tstart = 0;\n\twhile (go) {\n\t\tu32 type = M4V_LoadObject(m4v);\n\n\t\tend = gf_bs_get_position(m4v->bs) - 4;\n\t\tsize = end - start;\n\t\t/*store previous object*/\n\t\tif (size) {\n\t\t\tassert (size < 1<<31);\n\t\t\tif (size) gf_bs_write_data(mod, *o_data + start, (u32) size);\n\t\t\tstart = end;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase M4V_VOL_START_CODE:\n\t\t\tgf_bs_write_int(mod, 0, 8);\n\t\t\tgf_bs_write_int(mod, 0, 8);\n\t\t\tgf_bs_write_int(mod, 1, 8);\n\t\t\tgf_bs_write_int(mod, M4V_VOL_START_CODE, 8);\n\t\t\tgf_bs_write_int(mod, gf_bs_read_int(m4v->bs, 1), 1);\n\t\t\tgf_bs_write_int(mod, gf_bs_read_int(m4v->bs, 8), 8);\n\t\t\tstart = gf_bs_read_int(m4v->bs, 1);\n\t\t\tgf_bs_write_int(mod, (u32) start, 1);\n\t\t\tif (start) {\n\t\t\t\tgf_bs_write_int(mod, gf_bs_read_int(m4v->bs, 7), 7);\n\t\t\t}\n\t\t\tstart = gf_bs_read_int(m4v->bs, 4);\n\t\t\tif (start == 0xF) {\n\t\t\t\tgf_bs_read_int(m4v->bs, 8);\n\t\t\t\tgf_bs_read_int(m4v->bs, 8);\n\t\t\t}\n\t\t\tif ((par_n>=0) && (par_d>=0)) {\n\t\t\t\tu8 par = m4v_get_sar_idx(par_n, par_d);\n\t\t\t\tgf_bs_write_int(mod, par, 4);\n\t\t\t\tif (par==0xF) {\n\t\t\t\t\tgf_bs_write_int(mod, par_n, 8);\n\t\t\t\t\tgf_bs_write_int(mod, par_d, 8);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mod, 0x0, 4);\n\t\t\t}\n\t\tcase -1:\n\t\t\tgo = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (gf_bs_bits_available(m4v->bs)) {\n\t\tu32 b = gf_bs_read_int(m4v->bs, 1);\n\t\tgf_bs_write_int(mod, b, 1);\n\t}\n\n\tgf_m4v_parser_del(m4v);\n\tgf_free(*o_data);\n\tgf_bs_get_content(mod, o_data, o_dataLen);\n\tgf_bs_del(mod);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu64 gf_m4v_get_object_start(GF_M4VParser *m4v)\n{\n\treturn m4v->current_object_start;\n}\n\nGF_EXPORT\nBool gf_m4v_is_valid_object_type(GF_M4VParser *m4v)\n{\n\treturn ((s32) m4v->current_object_type==-1) ? 0 : 1;\n}\n\n\nGF_EXPORT\nGF_Err gf_m4v_get_config(char *rawdsi, u32 rawdsi_size, GF_M4VDecSpecInfo *dsi)\n{\n\tGF_Err e;\n\tGF_M4VParser *vparse;\n\tif (!rawdsi || !rawdsi_size) return GF_NON_COMPLIANT_BITSTREAM;\n\tvparse = gf_m4v_parser_new(rawdsi, rawdsi_size, 0);\n\te = gf_m4v_parse_config(vparse, dsi);\n\tdsi->next_object_start = (u32) vparse->current_object_start;\n\tgf_m4v_parser_del(vparse);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_mpegv12_get_config(char *rawdsi, u32 rawdsi_size, GF_M4VDecSpecInfo *dsi)\n{\n\tGF_Err e;\n\tGF_M4VParser *vparse;\n\tif (!rawdsi || !rawdsi_size) return GF_NON_COMPLIANT_BITSTREAM;\n\tvparse = gf_m4v_parser_new(rawdsi, rawdsi_size, GF_TRUE);\n\te = gf_m4v_parse_config(vparse, dsi);\n\tdsi->next_object_start = (u32) vparse->current_object_start;\n\tgf_m4v_parser_del(vparse);\n\treturn e;\n}\n\n#endif\n\n\n/*\n\tAAC parser\n*/\n\nGF_EXPORT\nconst char *gf_m4a_object_type_name(u32 objectType)\n{\n\tswitch (objectType) {\n\tcase 0:\n\t\treturn \"MPEG-4 Audio Reserved\";\n\tcase 1:\n\t\treturn \"MPEG-4 Audio AAC Main\";\n\tcase 2:\n\t\treturn \"MPEG-4 Audio AAC LC\";\n\tcase 3:\n\t\treturn \"MPEG-4 Audio AAC SSR\";\n\tcase 4:\n\t\treturn \"MPEG-4 Audio AAC LTP\";\n\tcase 5:\n\t\treturn \"MPEG-4 Audio SBR\";\n\tcase 6:\n\t\treturn \"MPEG-4 Audio AAC Scalable\";\n\tcase 7:\n\t\treturn \"MPEG-4 Audio TwinVQ\";\n\tcase 8:\n\t\treturn \"MPEG-4 Audio CELP\";\n\tcase 9:\n\t\treturn \"MPEG-4 Audio HVXC\";\n\tcase 10:\n\t\treturn \"MPEG-4 Audio Reserved\";\n\tcase 11:\n\t\treturn \"MPEG-4 Audio Reserved\";\n\tcase 12:\n\t\treturn \"MPEG-4 Audio TTSI\";\n\tcase 13:\n\t\treturn \"MPEG-4 Audio Main synthetic\";\n\tcase 14:\n\t\treturn \"MPEG-4 Audio Wavetable synthesis\";\n\tcase 15:\n\t\treturn \"MPEG-4 Audio General MIDI\";\n\tcase 16:\n\t\treturn \"MPEG-4 Audio Algorithmic Synthesis and Audio FX\";\n\tcase 17:\n\t\treturn \"MPEG-4 Audio ER AAC LC\";\n\tcase 18:\n\t\treturn \"MPEG-4 Audio Reserved\";\n\tcase 19:\n\t\treturn \"MPEG-4 Audio ER AAC LTP\";\n\tcase 20:\n\t\treturn \"MPEG-4 Audio ER AAC scalable\";\n\tcase 21:\n\t\treturn \"MPEG-4 Audio ER TwinVQ\";\n\tcase 22:\n\t\treturn \"MPEG-4 Audio ER BSAC\";\n\tcase 23:\n\t\treturn \"MPEG-4 Audio ER AAC LD\";\n\tcase 24:\n\t\treturn \"MPEG-4 Audio ER CELP\";\n\tcase 25:\n\t\treturn \"MPEG-4 Audio ER HVXC\";\n\tcase 26:\n\t\treturn \"MPEG-4 Audio ER HILN\";\n\tcase 27:\n\t\treturn \"MPEG-4 Audio ER Parametric\";\n\tcase 28:\n\t\treturn \"MPEG-4 Audio SSC\";\n\tcase 29:\n\t\treturn \"MPEG-4 Audio ParametricStereo\";\n\tcase 30:\n\t\treturn \"MPEG-4 Audio Reserved\";\n\tcase 31:\n\t\treturn \"MPEG-4 Audio Reserved\";\n\tcase 32:\n\t\treturn \"MPEG-1 Audio Layer-1\";\n\tcase 33:\n\t\treturn \"MPEG-1 Audio Layer-2\";\n\tcase 34:\n\t\treturn \"MPEG-1 Audio Layer-3\";\n\tcase 35:\n\t\treturn \"MPEG-4 Audio DST\";\n\tcase 36:\n\t\treturn \"MPEG-4 Audio ALS\";\n\tdefault:\n\t\treturn \"MPEG-4 Audio Unknown\";\n\t}\n}\n\nGF_EXPORT\nconst char *gf_m4a_get_profile_name(u8 audio_pl)\n{\n\tswitch (audio_pl) {\n\tcase 0x00:\n\t\treturn \"ISO Reserved (0x00)\";\n\tcase 0x01:\n\t\treturn \"Main Audio Profile @ Level 1\";\n\tcase 0x02:\n\t\treturn \"Main Audio Profile @ Level 2\";\n\tcase 0x03:\n\t\treturn \"Main Audio Profile @ Level 3\";\n\tcase 0x04:\n\t\treturn \"Main Audio Profile @ Level 4\";\n\tcase 0x05:\n\t\treturn \"Scalable Audio Profile @ Level 1\";\n\tcase 0x06:\n\t\treturn \"Scalable Audio Profile @ Level 2\";\n\tcase 0x07:\n\t\treturn \"Scalable Audio Profile @ Level 3\";\n\tcase 0x08:\n\t\treturn \"Scalable Audio Profile @ Level 4\";\n\tcase 0x09:\n\t\treturn \"Speech Audio Profile @ Level 1\";\n\tcase 0x0A:\n\t\treturn \"Speech Audio Profile @ Level 2\";\n\tcase 0x0B:\n\t\treturn \"Synthetic Audio Profile @ Level 1\";\n\tcase 0x0C:\n\t\treturn \"Synthetic Audio Profile @ Level 2\";\n\tcase 0x0D:\n\t\treturn \"Synthetic Audio Profile @ Level 3\";\n\tcase 0x0E:\n\t\treturn \"High Quality Audio Profile @ Level 1\";\n\tcase 0x0F:\n\t\treturn \"High Quality Audio Profile @ Level 2\";\n\tcase 0x10:\n\t\treturn \"High Quality Audio Profile @ Level 3\";\n\tcase 0x11:\n\t\treturn \"High Quality Audio Profile @ Level 4\";\n\tcase 0x12:\n\t\treturn \"High Quality Audio Profile @ Level 5\";\n\tcase 0x13:\n\t\treturn \"High Quality Audio Profile @ Level 6\";\n\tcase 0x14:\n\t\treturn \"High Quality Audio Profile @ Level 7\";\n\tcase 0x15:\n\t\treturn \"High Quality Audio Profile @ Level 8\";\n\tcase 0x16:\n\t\treturn \"Low Delay Audio Profile @ Level 1\";\n\tcase 0x17:\n\t\treturn \"Low Delay Audio Profile @ Level 2\";\n\tcase 0x18:\n\t\treturn \"Low Delay Audio Profile @ Level 3\";\n\tcase 0x19:\n\t\treturn \"Low Delay Audio Profile @ Level 4\";\n\tcase 0x1A:\n\t\treturn \"Low Delay Audio Profile @ Level 5\";\n\tcase 0x1B:\n\t\treturn \"Low Delay Audio Profile @ Level 6\";\n\tcase 0x1C:\n\t\treturn \"Low Delay Audio Profile @ Level 7\";\n\tcase 0x1D:\n\t\treturn \"Low Delay Audio Profile @ Level 8\";\n\tcase 0x1E:\n\t\treturn \"Natural Audio Profile @ Level 1\";\n\tcase 0x1F:\n\t\treturn \"Natural Audio Profile @ Level 2\";\n\tcase 0x20:\n\t\treturn \"Natural Audio Profile @ Level 3\";\n\tcase 0x21:\n\t\treturn \"Natural Audio Profile @ Level 4\";\n\tcase 0x22:\n\t\treturn \"Mobile Audio Internetworking Profile @ Level 1\";\n\tcase 0x23:\n\t\treturn \"Mobile Audio Internetworking Profile @ Level 2\";\n\tcase 0x24:\n\t\treturn \"Mobile Audio Internetworking Profile @ Level 3\";\n\tcase 0x25:\n\t\treturn \"Mobile Audio Internetworking Profile @ Level 4\";\n\tcase 0x26:\n\t\treturn \"Mobile Audio Internetworking Profile @ Level 5\";\n\tcase 0x27:\n\t\treturn \"Mobile Audio Internetworking Profile @ Level 6\";\n\tcase 0x28:\n\t\treturn \"AAC Profile @ Level 1\";\n\tcase 0x29:\n\t\treturn \"AAC Profile @ Level 2\";\n\tcase 0x2A:\n\t\treturn \"AAC Profile @ Level 4\";\n\tcase 0x2B:\n\t\treturn \"AAC Profile @ Level 5\";\n\tcase 0x2C:\n\t\treturn \"High Efficiency AAC Profile @ Level 2\";\n\tcase 0x2D:\n\t\treturn \"High Efficiency AAC Profile @ Level 3\";\n\tcase 0x2E:\n\t\treturn \"High Efficiency AAC Profile @ Level 4\";\n\tcase 0x2F:\n\t\treturn \"High Efficiency AAC Profile @ Level 5\";\n\tcase 0x30:\n\t\treturn \"High Efficiency AAC v2 Profile @ Level 2\";\n\tcase 0x31:\n\t\treturn \"High Efficiency AAC v2 Profile @ Level 3\";\n\tcase 0x32:\n\t\treturn \"High Efficiency AAC v2 Profile @ Level 4\";\n\tcase 0x33:\n\t\treturn \"High Efficiency AAC v2 Profile @ Level 5\";\n\tcase 0x34:\n\t\treturn \"Low Delay AAC Profile\";\n\tcase 0x35:\n\t\treturn \"Baseline MPEG Surround Profile @ Level 1\";\n\tcase 0x36:\n\t\treturn \"Baseline MPEG Surround Profile @ Level 2\";\n\tcase 0x37:\n\t\treturn \"Baseline MPEG Surround Profile @ Level 3\";\n\tcase 0x38:\n\t\treturn \"Baseline MPEG Surround Profile @ Level 4\";\n\tcase 0x39:\n\t\treturn \"Baseline MPEG Surround Profile @ Level 5\";\n\tcase 0x3A:\n\t\treturn \"Baseline MPEG Surround Profile @ Level 6\";\n\n\tcase 0x50:\n\t\treturn \"AAC Profile @ Level 6\";\n\tcase 0x51:\n\t\treturn \"AAC Profile @ Level 7\";\n\tcase 0x52:\n\t\treturn \"High Efficiency AAC Profile @ Level 6\";\n\tcase 0x53:\n\t\treturn \"High Efficiency AAC Profile @ Level 7\";\n\tcase 0x54:\n\t\treturn \"High Efficiency AAC v2 Profile @ Level 6\";\n\tcase 0x55:\n\t\treturn \"High Efficiency AAC v2 Profile @ Level 7\";\n\tcase 0x56:\n\t\treturn \"Extended High Efficiency AAC Profile @ Level 6\";\n\tcase 0x57:\n\t\treturn \"Extended High Efficiency AAC Profile @ Level 7\";\n\n\tcase 0xFE:\n\t\treturn \"Not part of MPEG-4 audio profiles\";\n\tcase 0xFF:\n\t\treturn \"No audio capability required\";\n\tdefault:\n\t\treturn \"ISO Reserved / User Private\";\n\t}\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\nGF_EXPORT\nu32 gf_m4a_get_profile(GF_M4ADecSpecInfo *cfg)\n{\n\tswitch (cfg->base_object_type) {\n\tcase 2: /*AAC LC*/\n\t\tif (cfg->nb_chan<=2)\n\t\t\treturn (cfg->base_sr<=24000) ? 0x28 : 0x29; /*LC@L1 or LC@L2*/\n\t\tif (cfg->nb_chan<=5)\n\t\t\treturn (cfg->base_sr<=48000) ? 0x2A : 0x2B; /*LC@L4 or LC@L5*/\n\t\treturn (cfg->base_sr<=48000) ? 0x50 : 0x51; /*LC@L4 or LC@L5*/\n\tcase 5: /*HE-AAC - SBR*/\n\t\tif (cfg->nb_chan<=2)\n\t\t\treturn (cfg->base_sr<=24000) ? 0x2C : 0x2D; /*HE@L2 or HE@L3*/\n\t\tif (cfg->nb_chan<=5)\n\t\t\treturn (cfg->base_sr<=48000) ? 0x2E : 0x2F; /*HE@L4 or HE@L5*/\n\t\treturn (cfg->base_sr<=48000) ? 0x52 : 0x53; /*HE@L6 or HE@L7*/\n\tcase 29: /*HE-AACv2 - SBR+PS*/\n\t\tif (cfg->nb_chan<=2)\n\t\t\treturn (cfg->base_sr<=24000) ? 0x30 : 0x31; /*HE-AACv2@L2 or HE-AACv2@L3*/\n\t\tif (cfg->nb_chan<=5)\n\t\t\treturn (cfg->base_sr<=48000) ? 0x32 : 0x33; /*HE-AACv2@L4 or HE-AACv2@L5*/\n\t\treturn (cfg->base_sr<=48000) ? 0x54 : 0x55; /*HE-AACv2@L6 or HE-AACv2@L7*/\n\t/*default to HQ*/\n\tdefault:\n\t\tif (cfg->nb_chan<=2) return (cfg->base_sr<24000) ? 0x0E : 0x0F; /*HQ@L1 or HQ@L2*/\n\t\treturn 0x10; /*HQ@L3*/\n\t}\n}\n\n\n\nGF_EXPORT\nGF_Err gf_m4a_parse_config(GF_BitStream *bs, GF_M4ADecSpecInfo *cfg, Bool size_known)\n{\n\tu32 channel_configuration = 0;\n\tmemset(cfg, 0, sizeof(GF_M4ADecSpecInfo));\n\tcfg->base_object_type = gf_bs_read_int(bs, 5);\n\t/*extended object type*/\n\tif (cfg->base_object_type==31) {\n\t\tcfg->base_object_type = 32 + gf_bs_read_int(bs, 6);\n\t}\n\tcfg->base_sr_index = gf_bs_read_int(bs, 4);\n\tif (cfg->base_sr_index == 0x0F) {\n\t\tcfg->base_sr = gf_bs_read_int(bs, 24);\n\t} else {\n\t\tcfg->base_sr = GF_M4ASampleRates[cfg->base_sr_index];\n\t}\n\n\tchannel_configuration = gf_bs_read_int(bs, 4);\n\n\tif (channel_configuration) {\n\t\tcfg->nb_chan = GF_M4ANumChannels[channel_configuration-1];\n\t}\n\n\tif (cfg->base_object_type==5 || cfg->base_object_type==29) {\n\t\tif (cfg->base_object_type==29) {\n\t\t\tcfg->has_ps = 1;\n\t\t\tcfg->nb_chan = 1;\n\t\t}\n\t\tcfg->has_sbr = GF_TRUE;\n\t\tcfg->sbr_sr_index = gf_bs_read_int(bs, 4);\n\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\tcfg->sbr_sr = gf_bs_read_int(bs, 24);\n\t\t} else {\n\t\t\tcfg->sbr_sr = GF_M4ASampleRates[cfg->sbr_sr_index];\n\t\t}\n\t\tcfg->sbr_object_type = gf_bs_read_int(bs, 5);\n\t}\n\n\t/*object cfg*/\n\tswitch (cfg->base_object_type) {\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 6:\n\tcase 7:\n\tcase 17:\n\tcase 19:\n\tcase 20:\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\t{\n\t\tBool ext_flag;\n\t\t/*frame length flag*/\n\t\t/*fl_flag = */gf_bs_read_int(bs, 1);\n\t\t/*depends on core coder*/\n\t\tif (gf_bs_read_int(bs, 1))\n\t\t\t/*delay = */gf_bs_read_int(bs, 14);\n\t\text_flag = gf_bs_read_int(bs, 1);\n\n\t\tif (! channel_configuration) {\n\t\t\tu32 i;\n\t\t\tcfg->program_config_element_present = 1;\n\t\t\tcfg->element_instance_tag = gf_bs_read_int(bs, 4);\n\t\t\tcfg->object_type = gf_bs_read_int(bs, 2);\n\t\t\tcfg->sampling_frequency_index = gf_bs_read_int(bs, 4);\n\t\t\tcfg->num_front_channel_elements = gf_bs_read_int(bs, 4);\n\t\t\tcfg->num_side_channel_elements = gf_bs_read_int(bs, 4);\n\t\t\tcfg->num_back_channel_elements = gf_bs_read_int(bs, 4);\n\t\t\tcfg->num_lfe_channel_elements = gf_bs_read_int(bs, 2);\n\t\t\tcfg->num_assoc_data_elements = gf_bs_read_int(bs, 3);\n\t\t\tcfg->num_valid_cc_elements = gf_bs_read_int(bs, 4);\n\t\t\tcfg-> mono_mixdown_present = (Bool) gf_bs_read_int(bs, 1);\n\t\t\tif (cfg->mono_mixdown_present) {\n\t\t\t\tcfg->mono_mixdown_element_number = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tcfg->stereo_mixdown_present = gf_bs_read_int(bs, 1);\n\t\t\tif (cfg->stereo_mixdown_present) {\n\t\t\t\tcfg->stereo_mixdown_element_number = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tcfg->matrix_mixdown_idx_present = gf_bs_read_int(bs, 1);\n\t\t\tif (cfg->matrix_mixdown_idx_present) {\n\t\t\t\tcfg->matrix_mixdown_idx = gf_bs_read_int(bs, 2);\n\t\t\t\tcfg->pseudo_surround_enable = gf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_front_channel_elements; i++) {\n\t\t\t\tcfg->front_element_is_cpe[i] = gf_bs_read_int(bs, 1);\n\t\t\t\tcfg->front_element_tag_select[i] = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_side_channel_elements; i++) {\n\t\t\t\tcfg->side_element_is_cpe[i] = gf_bs_read_int(bs, 1);\n\t\t\t\tcfg->side_element_tag_select[i] = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_back_channel_elements; i++) {\n\t\t\t\tcfg->back_element_is_cpe[i] = gf_bs_read_int(bs, 1);\n\t\t\t\tcfg->back_element_tag_select[i] = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_lfe_channel_elements; i++) {\n\t\t\t\tcfg->lfe_element_tag_select[i] = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tfor ( i = 0; i < cfg->num_assoc_data_elements; i++) {\n\t\t\t\tcfg->assoc_data_element_tag_select[i] = gf_bs_read_int(bs, 4);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < cfg->num_valid_cc_elements; i++) {\n\t\t\t\tcfg->cc_element_is_ind_sw[i] = gf_bs_read_int(bs, 1);\n\t\t\t\tcfg->valid_cc_element_tag_select[i] = gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\tgf_bs_align(bs);\n\t\t\tcfg->comment_field_bytes = gf_bs_read_int(bs, 8);\n\t\t\tgf_bs_read_data(bs, (char *) cfg->comments, cfg->comment_field_bytes);\n\n\t\t\tcfg->nb_chan = cfg->num_front_channel_elements + cfg->num_back_channel_elements + cfg->num_side_channel_elements + cfg->num_lfe_channel_elements;\n\t\t}\n\n\t\tif ((cfg->base_object_type == 6) || (cfg->base_object_type == 20)) {\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t}\n\t\tif (ext_flag) {\n\t\t\tif (cfg->base_object_type == 22) {\n\t\t\t\tgf_bs_read_int(bs, 5);\n\t\t\t\tgf_bs_read_int(bs, 11);\n\t\t\t}\n\t\t\tif ((cfg->base_object_type == 17)\n\t\t\t        || (cfg->base_object_type == 19)\n\t\t\t        || (cfg->base_object_type == 20)\n\t\t\t        || (cfg->base_object_type == 23)\n\t\t\t   ) {\n\t\t\t\tgf_bs_read_int(bs, 1);\n\t\t\t\tgf_bs_read_int(bs, 1);\n\t\t\t\tgf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t\t/*ext_flag = */gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\tbreak;\n\t}\n\t/*ER cfg*/\n\tswitch (cfg->base_object_type) {\n\tcase 17:\n\tcase 19:\n\tcase 20:\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\tcase 24:\n\tcase 25:\n\tcase 26:\n\tcase 27:\n\t{\n\t\tu32 epConfig = gf_bs_read_int(bs, 2);\n\t\tif ((epConfig == 2) || (epConfig == 3) ) {\n\t\t}\n\t\tif (epConfig == 3) {\n\t\t\tgf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\tbreak;\n\t}\n\n\tif (size_known && (cfg->base_object_type != 5) && (cfg->base_object_type != 29) ) {\n\t\twhile (gf_bs_available(bs)>=2) {\n\t\t\tu32 sync = gf_bs_peek_bits(bs, 11, 0);\n\t\t\tif (sync==0x2b7) {\n\t\t\t\tgf_bs_read_int(bs, 11);\n\t\t\t\tcfg->sbr_object_type = gf_bs_read_int(bs, 5);\n\t\t\t\tcfg->has_sbr = gf_bs_read_int(bs, 1);\n\t\t\t\tif (cfg->has_sbr) {\n\t\t\t\t\tcfg->sbr_sr_index = gf_bs_read_int(bs, 4);\n\t\t\t\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\t\t\t\tcfg->sbr_sr = gf_bs_read_int(bs, 24);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcfg->sbr_sr = GF_M4ASampleRates[cfg->sbr_sr_index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (sync == 0x548) {\n\t\t\t\tgf_bs_read_int(bs, 11);\n\t\t\t\tcfg->has_ps = gf_bs_read_int(bs, 1);\n\t\t\t\tif (cfg->has_ps)\n\t\t\t\t\tcfg->nb_chan = 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcfg->audioPL = gf_m4a_get_profile(cfg);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_get_config(char *dsi, u32 dsi_size, GF_M4ADecSpecInfo *cfg)\n{\n\tGF_BitStream *bs;\n\tif (!dsi || !dsi_size || (dsi_size<2) ) return GF_NON_COMPLIANT_BITSTREAM;\n\tbs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tgf_m4a_parse_config(bs, cfg, 1);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nu32 gf_latm_get_value(GF_BitStream *bs)\n{\n\tu32 i, tmp, value = 0;\n\tu32 bytesForValue = gf_bs_read_int(bs, 2);\n\tfor (i=0; i <= bytesForValue; i++) {\n\t\tvalue <<= 8;\n\t\ttmp = gf_bs_read_int(bs, 8);\n\t\tvalue += tmp;\n\t}\n\treturn value;\n}\n\nGF_EXPORT\nu32 gf_m4a_get_channel_cfg(u32 nb_chan)\n{\n\tu32 i, count = sizeof(GF_M4ANumChannels)/sizeof(u32);\n\tfor (i=0; i<count; i++) {\n\t\tif (GF_M4ANumChannels[i] == nb_chan) return i+1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_write_config_bs(GF_BitStream *bs, GF_M4ADecSpecInfo *cfg)\n{\n\tif (!cfg->base_sr_index) {\n\t\tif (!cfg->base_sr) return GF_BAD_PARAM;\n\t\twhile (GF_M4ASampleRates[cfg->base_sr_index]) {\n\t\t\tif (GF_M4ASampleRates[cfg->base_sr_index]==cfg->base_sr)\n\t\t\t\tbreak;\n\t\t\tcfg->base_sr_index++;\n\t\t}\n\t}\n\tif (cfg->sbr_sr && !cfg->sbr_sr_index) {\n\t\twhile (GF_M4ASampleRates[cfg->sbr_sr_index]) {\n\t\t\tif (GF_M4ASampleRates[cfg->sbr_sr_index]==cfg->sbr_sr)\n\t\t\t\tbreak;\n\t\t\tcfg->sbr_sr_index++;\n\t\t}\n\t}\n\t/*extended object type*/\n\tif (cfg->base_object_type>=32) {\n\t\tgf_bs_write_int(bs, 31, 5);\n\t\tgf_bs_write_int(bs, cfg->base_object_type-32, 6);\n\t} else {\n\t\tgf_bs_write_int(bs, cfg->base_object_type, 5);\n\t}\n\tgf_bs_write_int(bs, cfg->base_sr_index, 4);\n\tif (cfg->base_sr_index == 0x0F) {\n\t\tgf_bs_write_int(bs, cfg->base_sr, 24);\n\t}\n\n\tif (cfg->program_config_element_present) {\n\t\tgf_bs_write_int(bs, 0, 4);\n\t} else {\n\t\tgf_bs_write_int(bs, gf_m4a_get_channel_cfg( cfg->nb_chan) , 4);\n\t}\n\n\tif (cfg->base_object_type==5 || cfg->base_object_type==29) {\n\t\tif (cfg->base_object_type == 29) {\n\t\t\tcfg->has_ps = 1;\n\t\t\tcfg->nb_chan = 1;\n\t\t}\n\t\tcfg->has_sbr = 1;\n\t\tgf_bs_write_int(bs, cfg->sbr_sr_index, 4);\n\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\tgf_bs_write_int(bs, cfg->sbr_sr, 24);\n\t\t}\n\t\tgf_bs_write_int(bs, cfg->sbr_object_type, 5);\n\t}\n\n\t/*object cfg*/\n\tswitch (cfg->base_object_type) {\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 6:\n\tcase 7:\n\tcase 17:\n\tcase 19:\n\tcase 20:\n\tcase 21:\n\tcase 22:\n\tcase 23:\n\t{\n\t\t/*frame length flag*/\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\t/*depends on core coder*/\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\t/*ext flag*/\n\t\tgf_bs_write_int(bs, 0, 1);\n\n\t\tif (cfg->program_config_element_present) {\n\t\t\tu32 i;\n\t\t\tgf_bs_write_int(bs, cfg->element_instance_tag, 4);\n\t\t\tgf_bs_write_int(bs, cfg->object_type, 2);\n\t\t\tgf_bs_write_int(bs, cfg->sampling_frequency_index, 4);\n\t\t\tgf_bs_write_int(bs, cfg->num_front_channel_elements, 4);\n\t\t\tgf_bs_write_int(bs, cfg->num_side_channel_elements, 4);\n\t\t\tgf_bs_write_int(bs, cfg->num_back_channel_elements, 4);\n\t\t\tgf_bs_write_int(bs, cfg->num_lfe_channel_elements, 2);\n\t\t\tgf_bs_write_int(bs, cfg->num_assoc_data_elements, 3);\n\t\t\tgf_bs_write_int(bs, cfg->num_valid_cc_elements, 4);\n\t\t\tgf_bs_write_int(bs, cfg-> mono_mixdown_present, 1);\n\t\t\tif (cfg->mono_mixdown_present) {\n\t\t\t\tgf_bs_write_int(bs, cfg->mono_mixdown_element_number, 4);\n\t\t\t}\n\t\t\tgf_bs_write_int(bs, cfg->stereo_mixdown_present, 1);\n\t\t\tif (cfg->stereo_mixdown_present) {\n\t\t\t\tgf_bs_write_int(bs, cfg->stereo_mixdown_element_number, 4);\n\t\t\t}\n\t\t\tgf_bs_write_int(bs, cfg->matrix_mixdown_idx_present, 1);\n\t\t\tif (cfg->matrix_mixdown_idx_present) {\n\t\t\t\tgf_bs_write_int(bs, cfg->matrix_mixdown_idx, 2);\n\t\t\t\tgf_bs_write_int(bs, cfg->pseudo_surround_enable, 1);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_front_channel_elements; i++) {\n\t\t\t\tgf_bs_write_int(bs, cfg->front_element_is_cpe[i], 1);\n\t\t\t\tgf_bs_write_int(bs, cfg->front_element_tag_select[i], 4);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_side_channel_elements; i++) {\n\t\t\t\tgf_bs_write_int(bs, cfg->side_element_is_cpe[i], 1);\n\t\t\t\tgf_bs_write_int(bs, cfg->side_element_tag_select[i], 4);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_back_channel_elements; i++) {\n\t\t\t\tgf_bs_write_int(bs, cfg->back_element_is_cpe[i], 1);\n\t\t\t\tgf_bs_write_int(bs, cfg->back_element_tag_select[i], 4);\n\t\t\t}\n\t\t\tfor (i = 0; i < cfg->num_lfe_channel_elements; i++) {\n\t\t\t\tgf_bs_write_int(bs, cfg->lfe_element_tag_select[i], 4);\n\t\t\t}\n\t\t\tfor ( i = 0; i < cfg->num_assoc_data_elements; i++) {\n\t\t\t\tgf_bs_write_int(bs, cfg->assoc_data_element_tag_select[i], 4);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < cfg->num_valid_cc_elements; i++) {\n\t\t\t\tgf_bs_write_int(bs, cfg->cc_element_is_ind_sw[i], 1);\n\t\t\t\tgf_bs_write_int(bs, cfg->valid_cc_element_tag_select[i], 4);\n\t\t\t}\n\t\t\tgf_bs_align(bs);\n\t\t\tgf_bs_write_int(bs, cfg->comment_field_bytes, 8);\n\t\t\tgf_bs_write_data(bs, (char *) cfg->comments, cfg->comment_field_bytes);\n\t\t}\n\n\t\tif ((cfg->base_object_type == 6) || (cfg->base_object_type == 20)) {\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t}\n\t}\n\tbreak;\n\t}\n\t/*ER cfg - not supported*/\n\n\t/*implicit sbr - not used yet*/\n\tif (0 && (cfg->base_object_type != 5) && (cfg->base_object_type != 29) ) {\n\t\tgf_bs_write_int(bs, 0x2b7, 11);\n\t\tcfg->sbr_object_type = gf_bs_read_int(bs, 5);\n\t\tcfg->has_sbr = gf_bs_read_int(bs, 1);\n\t\tif (cfg->has_sbr) {\n\t\t\tcfg->sbr_sr_index = gf_bs_read_int(bs, 4);\n\t\t\tif (cfg->sbr_sr_index == 0x0F) {\n\t\t\t\tcfg->sbr_sr = gf_bs_read_int(bs, 24);\n\t\t\t} else {\n\t\t\t\tcfg->sbr_sr = GF_M4ASampleRates[cfg->sbr_sr_index];\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m4a_write_config(GF_M4ADecSpecInfo *cfg, char **dsi, u32 *dsi_size)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_m4a_write_config_bs(bs, cfg);\n\tgf_bs_get_content(bs, dsi, dsi_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\nGF_EXPORT\nu8 gf_mp3_version(u32 hdr)\n{\n\treturn ((hdr >> 19) & 0x3);\n}\n\nGF_EXPORT\nconst char *gf_mp3_version_name(u32 hdr)\n{\n\tu32 v = gf_mp3_version(hdr);\n\tswitch (v) {\n\tcase 0:\n\t\treturn \"MPEG-2.5\";\n\tcase 1:\n\t\treturn \"Reserved\";\n\tcase 2:\n\t\treturn \"MPEG-2\";\n\tcase 3:\n\t\treturn \"MPEG-1\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n\nGF_EXPORT\nu8 gf_mp3_layer(u32 hdr)\n{\n\treturn 4 - (((hdr >> 17) & 0x3));\n}\n\nGF_EXPORT\nu8 gf_mp3_num_channels(u32 hdr)\n{\n\tif (((hdr >> 6) & 0x3) == 3) return 1;\n\treturn 2;\n}\n\nGF_EXPORT\nu16 gf_mp3_sampling_rate(u32 hdr)\n{\n\tu16 res;\n\t/* extract the necessary fields from the MP3 header */\n\tu8 version = gf_mp3_version(hdr);\n\tu8 sampleRateIndex = (hdr >> 10) & 0x3;\n\n\tswitch (sampleRateIndex) {\n\tcase 0:\n\t\tres = 44100;\n\t\tbreak;\n\tcase 1:\n\t\tres = 48000;\n\t\tbreak;\n\tcase 2:\n\t\tres = 32000;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[MPEG-1/2 Audio] Samplerate index not valid\\n\"));\n\t\treturn 0;\n\t}\n\t/*reserved or MPEG-1*/\n\tif (version & 1) return res;\n\n\t/*MPEG-2*/\n\tres /= 2;\n\t/*MPEG-2.5*/\n\tif (version == 0) res /= 2;\n\treturn res;\n}\n\nGF_EXPORT\nu16 gf_mp3_window_size(u32 hdr)\n{\n\tu8 version = gf_mp3_version(hdr);\n\tu8 layer = gf_mp3_layer(hdr);\n\n\tif (layer == 3) {\n\t\tif (version == 3) return 1152;\n\t\treturn 576;\n\t}\n\tif (layer == 2) return 1152;\n\treturn 384;\n}\n\nGF_EXPORT\nu8 gf_mp3_object_type_indication(u32 hdr)\n{\n\tswitch (gf_mp3_version(hdr)) {\n\tcase 3:\n\t\treturn GPAC_OTI_AUDIO_MPEG1;\n\tcase 2:\n\tcase 0:\n\t\treturn GPAC_OTI_AUDIO_MPEG2_PART3;\n\tdefault:\n\t\treturn 0x00;\n\t}\n}\n\n/*aligned bitrate parsing with libMAD*/\n\nstatic\nu32 const bitrate_table[5][15] = {\n\t/* MPEG-1 */\n\t{\t0,  32000,  64000,  96000, 128000, 160000, 192000, 224000,  /* Layer I   */\n\t\t256000, 288000, 320000, 352000, 384000, 416000, 448000\n\t},\n\t{\t0,  32000,  48000,  56000,  64000,  80000,  96000, 112000,  /* Layer II  */\n\t\t128000, 160000, 192000, 224000, 256000, 320000, 384000\n\t},\n\t{\t0,  32000,  40000,  48000,  56000,  64000,  80000,  96000,  /* Layer III */\n\t\t112000, 128000, 160000, 192000, 224000, 256000, 320000\n\t},\n\n\t/* MPEG-2 LSF */\n\t{\t0,  32000,  48000,  56000,  64000,  80000,  96000, 112000,  /* Layer I   */\n\t\t128000, 144000, 160000, 176000, 192000, 224000, 256000\n\t},\n\t{\t0,   8000,  16000,  24000,  32000,  40000,  48000,  56000,  /* Layers    */\n\t\t64000,  80000,  96000, 112000, 128000, 144000, 160000\n\t} /* II & III  */\n};\n\n\nu32 gf_mp3_bit_rate(u32 hdr)\n{\n\tu8 version = gf_mp3_version(hdr);\n\tu8 layer = gf_mp3_layer(hdr);\n\tu8 bitRateIndex = (hdr >> 12) & 0xF;\n\n\tif (bitRateIndex == 15) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[MPEG-1/2 Audio] Bitrate index not valid\\n\"));\n\t\treturn 0;\n\t}\n\n\t/*MPEG-1*/\n\tif (version & 1)\n\t\treturn bitrate_table[layer - 1][bitRateIndex];\n\t/*MPEG-2/2.5*/\n\telse\n\t\treturn bitrate_table[3 + (layer >> 1)][bitRateIndex];\n}\n\n\n\nGF_EXPORT\nu16 gf_mp3_frame_size(u32 hdr)\n{\n\tu8 version = gf_mp3_version(hdr);\n\tu8 layer = gf_mp3_layer(hdr);\n\tu32 pad = ( (hdr >> 9) & 0x1) ? 1 : 0;\n\tu32 bitrate = gf_mp3_bit_rate(hdr);\n\tu32 samplerate = gf_mp3_sampling_rate(hdr);\n\n\tu32 frameSize = 0;\n\tif (!samplerate || !bitrate) return 0;\n\n\tif (layer==1) {\n\t\tframeSize = (( 12 * bitrate / samplerate) + pad) * 4;\n\t} else {\n\t\tu32 slots_per_frame = 144;\n\t\tif ((layer == 3) && !(version & 1)) slots_per_frame = 72;\n\t\tframeSize = (slots_per_frame * bitrate / samplerate) + pad;\n\t}\n\treturn (u16) frameSize;\n}\n\n\nGF_EXPORT\nu32 gf_mp3_get_next_header(FILE* in)\n{\n\tu8 b, state = 0;\n\tu32 dropped = 0;\n\tunsigned char bytes[4];\n\tbytes[0] = bytes[1] = bytes[2] = bytes[3] = 0;\n\n\twhile (1) {\n\t\tif (fread(&b, 1, 1, in) == 0) return 0;\n\n\t\tif (state==3) {\n\t\t\tbytes[state] = b;\n\t\t\treturn GF_4CC(bytes[0], bytes[1], bytes[2], bytes[3]);\n\t\t}\n\t\tif (state==2) {\n\t\t\tif (((b & 0xF0) == 0) || ((b & 0xF0) == 0xF0) || ((b & 0x0C) == 0x0C)) {\n\t\t\t\tif (bytes[1] == 0xFF) state = 1;\n\t\t\t\telse state = 0;\n\t\t\t} else {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 3;\n\t\t\t}\n\t\t}\n\t\tif (state==1) {\n\t\t\tif (((b & 0xE0) == 0xE0) && ((b & 0x18) != 0x08) && ((b & 0x06) != 0)) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 2;\n\t\t\t} else {\n\t\t\t\tstate = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (state==0) {\n\t\t\tif (b == 0xFF) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 1;\n\t\t\t} else {\n\t\t\t\tif ((dropped == 0) && ((b & 0xE0) == 0xE0) && ((b & 0x18) != 0x08) && ((b & 0x06) != 0)) {\n\t\t\t\t\tbytes[0] = (u8) 0xFF;\n\t\t\t\t\tbytes[1] = b;\n\t\t\t\t\tstate = 2;\n\t\t\t\t} else {\n\t\t\t\t\tdropped++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nu32 gf_mp3_get_next_header_mem(const char *buffer, u32 size, u32 *pos)\n{\n\tu32 cur;\n\tu8 b, state = 0;\n\tu32 dropped = 0;\n\tunsigned char bytes[4];\n\tbytes[0] = bytes[1] = bytes[2] = bytes[3] = 0;\n\n\tcur = 0;\n\t*pos = 0;\n\twhile (cur<size) {\n\t\tb = (u8) buffer[cur];\n\t\tcur++;\n\n\t\tif (state==3) {\n\t\t\tu32 val;\n\t\t\tbytes[state] = b;\n\t\t\tval = GF_4CC(bytes[0], bytes[1], bytes[2], bytes[3]);\n\t\t\tif (gf_mp3_frame_size(val)) {\n\t\t\t\t*pos = dropped;\n\t\t\t\treturn val;\n\t\t\t}\n\t\t\tstate = 0;\n\t\t\tdropped = cur;\n\t\t}\n\t\tif (state==2) {\n\t\t\tif (((b & 0xF0) == 0) || ((b & 0xF0) == 0xF0) || ((b & 0x0C) == 0x0C)) {\n\t\t\t\tif (bytes[1] == 0xFF) {\n\t\t\t\t\tstate = 1;\n\t\t\t\t\tdropped+=1;\n\t\t\t\t} else {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tdropped = cur;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 3;\n\t\t\t}\n\t\t}\n\t\tif (state==1) {\n\t\t\tif (((b & 0xE0) == 0xE0) && ((b & 0x18) != 0x08) && ((b & 0x06) != 0)) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 2;\n\t\t\t} else {\n\t\t\t\tstate = 0;\n\t\t\t\tdropped = cur;\n\t\t\t}\n\t\t}\n\n\t\tif (state==0) {\n\t\t\tif (b == 0xFF) {\n\t\t\t\tbytes[state] = b;\n\t\t\t\tstate = 1;\n\t\t\t} else {\n\t\t\t\tdropped++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\n\nGF_EXPORT\nBool gf_avc_is_rext_profile(u8 profile_idc)\n{\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\tcase 138:\n\tcase 139:\n\tcase 134:\n\tcase 135:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nconst char *gf_avc_get_profile_name(u8 video_prof)\n{\n\tswitch (video_prof) {\n\tcase 0x42:\n\t\treturn \"Baseline\";\n\tcase 0x4D:\n\t\treturn \"Main\";\n\tcase 0x53:\n\t\treturn \"Scalable Baseline\";\n\tcase 0x56:\n\t\treturn \"Scalable High\";\n\tcase 0x58:\n\t\treturn \"Extended\";\n\tcase 0x64:\n\t\treturn \"High\";\n\tcase 0x6E:\n\t\treturn \"High 10\";\n\tcase 0x7A:\n\t\treturn \"High 4:2:2\";\n\tcase 0x90:\n\tcase 0xF4:\n\t\treturn \"High 4:4:4\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nGF_EXPORT\nconst char *gf_hevc_get_profile_name(u8 video_prof)\n{\n\tswitch (video_prof) {\n\tcase 0x01:\n\t\treturn \"Main\";\n\tcase 0x02:\n\t\treturn \"Main 10\";\n\tcase 0x03:\n\t\treturn \"Main Still Picture\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\nGF_EXPORT\nconst char *gf_avc_hevc_get_chroma_format_name(u8 chroma_format)\n{\n\tswitch (chroma_format) {\n\tcase 1:\n\t\treturn \"YUV 4:2:0\";\n\tcase 2:\n\t\treturn \"YUV 4:2:2\";\n\tcase 3:\n\t\treturn \"YUV 4:4:4\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n\nstatic u8 avc_golomb_bits[256] = {\n\t8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2,\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0\n};\n\nstatic u32 bs_get_ue(GF_BitStream *bs)\n{\n\tu8 coded;\n\tu32 bits = 0, read = 0;\n\twhile (1) {\n\t\tread = gf_bs_peek_bits(bs, 8, 0);\n\t\tif (read) break;\n\t\t//check whether we still have bits once the peek is done since we may have less than 8 bits available\n\t\tif (!gf_bs_available(bs)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AVC/HEVC] Not enough bits in bitstream !!\\n\"));\n\t\t\treturn 0;\n\t\t}\n\t\tgf_bs_read_int(bs, 8);\n\t\tbits += 8;\n\t}\n\tcoded = avc_golomb_bits[read];\n\tgf_bs_read_int(bs, coded);\n\tbits += coded;\n\treturn gf_bs_read_int(bs, bits + 1) - 1;\n}\n\nstatic s32 bs_get_se(GF_BitStream *bs)\n{\n\tu32 v = bs_get_ue(bs);\n\tif ((v & 0x1) == 0) return (s32) (0 - (v>>1));\n\treturn (v + 1) >> 1;\n}\n\nu32 gf_media_nalu_is_start_code(GF_BitStream *bs)\n{\n\tu8 s1, s2, s3, s4;\n\tBool is_sc = 0;\n\tu64 pos = gf_bs_get_position(bs);\n\ts1 = gf_bs_read_int(bs, 8);\n\ts2 = gf_bs_read_int(bs, 8);\n\tif (!s1 && !s2) {\n\t\ts3 = gf_bs_read_int(bs, 8);\n\t\tif (s3==0x01) is_sc = 3;\n\t\telse if (!s3) {\n\t\t\ts4 = gf_bs_read_int(bs, 8);\n\t\t\tif (s4==0x01) is_sc = 4;\n\t\t}\n\t}\n\tgf_bs_seek(bs, pos+is_sc);\n\treturn is_sc;\n}\n\n/*read that amount of data at each IO access rather than fetching byte by byte...*/\n#define AVC_CACHE_SIZE\t4096\n\nstatic u32 gf_media_nalu_locate_start_code_bs(GF_BitStream *bs, Bool locate_trailing)\n{\n\tu32 v, bpos, nb_cons_zeros=0;\n\tchar avc_cache[AVC_CACHE_SIZE];\n\tu64 end, cache_start, load_size;\n\tu64 start = gf_bs_get_position(bs);\n\tif (start<3) return 0;\n\n\tload_size = 0;\n\tbpos = 0;\n\tcache_start = 0;\n\tend = 0;\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\t/*refill cache*/\n\t\tif (bpos == (u32) load_size) {\n\t\t\tif (!gf_bs_available(bs)) break;\n\t\t\tload_size = gf_bs_available(bs);\n\t\t\tif (load_size>AVC_CACHE_SIZE) load_size=AVC_CACHE_SIZE;\n\t\t\tbpos = 0;\n\t\t\tcache_start = gf_bs_get_position(bs);\n\t\t\tgf_bs_read_data(bs, avc_cache, (u32) load_size);\n\t\t}\n\t\tv = ( (v<<8) & 0xFFFFFF00) | ((u32) avc_cache[bpos]);\n\n\t\tbpos++;\n\t\tif (locate_trailing) {\n\t\t\tif ( (v & 0x000000FF) == 0) nb_cons_zeros++;\n\t\t\telse nb_cons_zeros = 0;\n\t\t}\n\n\t\tif (v == 0x00000001) end = cache_start+bpos-4;\n\t\telse if ( (v & 0x00FFFFFF) == 0x00000001) end = cache_start+bpos-3;\n\t}\n\tgf_bs_seek(bs, start);\n\tif (!end) end = gf_bs_get_size(bs);\n\tif (locate_trailing) {\n\t\tif (nb_cons_zeros>=3)\n\t\t\treturn (u32) (end - start - nb_cons_zeros);\n\t}\n\treturn (u32) (end-start);\n}\n\nGF_EXPORT\nu32 gf_media_nalu_next_start_code_bs(GF_BitStream *bs)\n{\n\treturn gf_media_nalu_locate_start_code_bs(bs, 0);\n}\n\nGF_EXPORT\nu32 gf_media_nalu_payload_end_bs(GF_BitStream *bs)\n{\n\treturn gf_media_nalu_locate_start_code_bs(bs, 1);\n}\n\nGF_EXPORT\nu32 gf_media_nalu_next_start_code(const u8 *data, u32 data_len, u32 *sc_size)\n{\n\tu32 v, bpos;\n\tu32 end;\n\n\tbpos = 0;\n\tend = 0;\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\t/*refill cache*/\n\t\tif (bpos == (u32) data_len)\n\t\t\tbreak;\n\n\t\tv = ( (v<<8) & 0xFFFFFF00) | ((u32) data[bpos]);\n\t\tbpos++;\n\t\tif (v == 0x00000001) {\n\t\t\tend = bpos-4;\n\t\t\t*sc_size = 4;\n\t\t\treturn end;\n\t\t}\n\t\telse if ( (v & 0x00FFFFFF) == 0x00000001) {\n\t\t\tend = bpos-3;\n\t\t\t*sc_size = 3;\n\t\t\treturn end;\n\t\t}\n\t}\n\tif (!end) end = data_len;\n\treturn (u32) (end);\n}\n\nBool gf_media_avc_slice_is_intra(AVCState *avc)\n{\n\tswitch (avc->s_info.slice_type) {\n\tcase GF_AVC_TYPE_I:\n\tcase GF_AVC_TYPE2_I:\n\tcase GF_AVC_TYPE_SI:\n\tcase GF_AVC_TYPE2_SI:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nBool gf_media_avc_slice_is_IDR(AVCState *avc)\n{\n\tif (avc->sei.recovery_point.valid)\n\t{\n\t\tavc->sei.recovery_point.valid = 0;\n\t\treturn 1;\n\t}\n\tif (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE)\n\t\treturn 0;\n\treturn gf_media_avc_slice_is_intra(avc);\n}\n\nstatic const struct {\n\tu32 w, h;\n} avc_sar[14] =\n{\n\t{ 0,   0 }, { 1,   1 }, { 12, 11 }, { 10, 11 },\n\t{ 16, 11 }, { 40, 33 }, { 24, 11 }, { 20, 11 },\n\t{ 32, 11 }, { 80, 33 }, { 18, 11 }, { 15, 11 },\n\t{ 64, 33 }, { 160,99 },\n};\n\n\n/*ISO 14496-10 (N11084) E.1.2*/\nstatic void avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)\n{\n\tint i, cpb_cnt_minus1;\n\n\tcpb_cnt_minus1 = bs_get_ue(bs);\t\t/*cpb_cnt_minus1*/\n\tif (cpb_cnt_minus1 > 31)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] invalid cpb_cnt_minus1 value: %d (expected in [0;31])\\n\", cpb_cnt_minus1));\n\tgf_bs_read_int(bs, 4);\t\t\t\t/*bit_rate_scale*/\n\tgf_bs_read_int(bs, 4);\t\t\t\t/*cpb_size_scale*/\n\n\t/*for( SchedSelIdx = 0; SchedSelIdx <= cpb_cnt_minus1; SchedSelIdx++ ) {*/\n\tfor (i=0; i<=cpb_cnt_minus1; i++) {\n\t\tbs_get_ue(bs);\t\t\t\t\t/*bit_rate_value_minus1[ SchedSelIdx ]*/\n\t\tbs_get_ue(bs);\t\t\t\t\t/*cpb_size_value_minus1[ SchedSelIdx ]*/\n\t\tgf_bs_read_int(bs, 1);\t\t\t/*cbr_flag[ SchedSelIdx ]*/\n\t}\n\tgf_bs_read_int(bs, 5);\t\t\t\t\t\t\t\t\t\t\t/*initial_cpb_removal_delay_length_minus1*/\n\thrd->cpb_removal_delay_length_minus1 = gf_bs_read_int(bs, 5);\t/*cpb_removal_delay_length_minus1*/\n\thrd->dpb_output_delay_length_minus1  = gf_bs_read_int(bs, 5);\t/*dpb_output_delay_length_minus1*/\n\thrd->time_offset_length = gf_bs_read_int(bs, 5);\t\t\t\t/*time_offset_length*/\n\n\treturn;\n}\n\n/*returns the nal_size without emulation prevention bytes*/\nstatic u32 avc_emulation_bytes_add_count(char *buffer, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size) {\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\tother than the following sequences shall not occur at any byte-aligned position:\n\t\t\\96 0x00000300\n\t\t\\96 0x00000301\n\t\t\\96 0x00000302\n\t\t\\96 0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2 && buffer[i] < 0x04) {\n\t\t\t/*emulation code found*/\n\t\t\tnum_zero = 0;\n\t\t\temulation_bytes_count++;\n\t\t\tif (!buffer[i])\n\t\t\t\tnum_zero = 1;\n\t\t} else {\n\t\t\tif (!buffer[i])\n\t\t\t\tnum_zero++;\n\t\t\telse\n\t\t\t\tnum_zero = 0;\n\t\t}\n\t\ti++;\n\t}\n\treturn emulation_bytes_count;\n}\n\nstatic u32 avc_add_emulation_bytes(const char *buffer_src, char *buffer_dst, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size) {\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\tother than the following sequences shall not occur at any byte-aligned position:\n\t\t0x00000300\n\t\t0x00000301\n\t\t0x00000302\n\t\t0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2 && (u8)buffer_src[i] < 0x04) {\n\t\t\t/*add emulation code*/\n\t\t\tnum_zero = 0;\n\t\t\tbuffer_dst[i+emulation_bytes_count] = 0x03;\n\t\t\temulation_bytes_count++;\n\t\t\tif (!buffer_src[i])\n\t\t\t\tnum_zero = 1;\n\t\t} else {\n\t\t\tif (!buffer_src[i])\n\t\t\t\tnum_zero++;\n\t\t\telse\n\t\t\t\tnum_zero = 0;\n\t\t}\n\t\tbuffer_dst[i+emulation_bytes_count] = buffer_src[i];\n\t\ti++;\n\t}\n\treturn nal_size+emulation_bytes_count;\n}\n\n/*returns the nal_size without emulation prevention bytes*/\nstatic u32 avc_emulation_bytes_remove_count(const char *buffer, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size)\n\t{\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\t  other than the following sequences shall not occur at any byte-aligned position:\n\t\t  \\96 0x00000300\n\t\t  \\96 0x00000301\n\t\t  \\96 0x00000302\n\t\t  \\96 0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2\n\t\t        && buffer[i] == 0x03\n\t\t        && i+1 < nal_size /*next byte is readable*/\n\t\t        && buffer[i+1] < 0x04)\n\t\t{\n\t\t\t/*emulation code found*/\n\t\t\tnum_zero = 0;\n\t\t\temulation_bytes_count++;\n\t\t\ti++;\n\t\t}\n\n\t\tif (!buffer[i])\n\t\t\tnum_zero++;\n\t\telse\n\t\t\tnum_zero = 0;\n\n\t\ti++;\n\t}\n\n\treturn emulation_bytes_count;\n}\n\n/*nal_size is updated to allow better error detection*/\nstatic u32 avc_remove_emulation_bytes(const char *buffer_src, char *buffer_dst, u32 nal_size)\n{\n\tu32 i = 0, emulation_bytes_count = 0;\n\tu8 num_zero = 0;\n\n\twhile (i < nal_size)\n\t{\n\t\t/*ISO 14496-10: \"Within the NAL unit, any four-byte sequence that starts with 0x000003\n\t\t  other than the following sequences shall not occur at any byte-aligned position:\n\t\t  0x00000300\n\t\t  0x00000301\n\t\t  0x00000302\n\t\t  0x00000303\"\n\t\t*/\n\t\tif (num_zero == 2\n\t\t        && buffer_src[i] == 0x03\n\t\t        && i+1 < nal_size /*next byte is readable*/\n\t\t        && buffer_src[i+1] < 0x04)\n\t\t{\n\t\t\t/*emulation code found*/\n\t\t\tnum_zero = 0;\n\t\t\temulation_bytes_count++;\n\t\t\ti++;\n\t\t}\n\n\t\tbuffer_dst[i-emulation_bytes_count] = buffer_src[i];\n\n\t\tif (!buffer_src[i])\n\t\t\tnum_zero++;\n\t\telse\n\t\t\tnum_zero = 0;\n\n\t\ti++;\n\t}\n\n\treturn nal_size-emulation_bytes_count;\n}\n\nGF_EXPORT\ns32 gf_media_avc_read_sps(const char *sps_data, u32 sps_size, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos)\n{\n\tAVC_SPS *sps;\n\tu32 ChromaArrayType = 0;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl=0, cr=0, ct=0, cb=0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\tGF_BitStream *bs;\n\tchar *sps_data_without_emulation_bytes = NULL;\n\tu32 sps_data_without_emulation_bytes_size = 0;\n\n\t/*SPS still contains emulation bytes*/\n\tsps_data_without_emulation_bytes = gf_malloc(sps_size*sizeof(char));\n\tsps_data_without_emulation_bytes_size = avc_remove_emulation_bytes(sps_data, sps_data_without_emulation_bytes, sps_size);\n\tbs = gf_bs_new(sps_data_without_emulation_bytes, sps_data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t/*nal hdr*/ gf_bs_read_int(bs, 8);\n\n\tprofile_idc = gf_bs_read_int(bs, 8);\n\n\tpcomp = gf_bs_read_int(bs, 8);\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\tgoto exit;\n\n\tlevel_idc = gf_bs_read_int(bs, 8);\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = bs_get_ue(bs) + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif (sps_id >=32) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\tif (sps_id < 0) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tchroma_format_idc = ChromaArrayType = 1;\n\tsps = &avc->sps[sps_id];\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\tgoto exit;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = bs_get_ue(bs);\n\t\tChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int(bs, 1);\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = bs_get_ue(bs);\n\t\tchroma_bd = bs_get_ue(bs);\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int(bs, 1);\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\tu32 k;\n\t\t\tfor (k=0; k<8; k++) {\n\t\t\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k<6 ? 16 : 64;\n\t\t\t\t\tfor (z=0; z<sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = bs_get_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = bs_get_ue(bs) + 4;\n\tsps->poc_type = bs_get_ue(bs);\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = bs_get_ue(bs) + 4;\n\t} else if(sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int(bs, 1);\n\t\tsps->offset_for_non_ref_pic = bs_get_se(bs);\n\t\tsps->offset_for_top_to_bottom_field = bs_get_se(bs);\n\t\tsps->poc_cycle_length = bs_get_ue(bs);\n\t\tif (sps->poc_cycle_length > ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\tgoto exit;\n\t\t}\n\t\tfor(i=0; i<sps->poc_cycle_length; i++) sps->offset_for_ref_frame[i] = bs_get_se(bs);\n\t}\n\tif (sps->poc_type > 2) {\n\t\tsps_id = -1;\n\t\tgoto exit;\n\t}\n\tsps->max_num_ref_frames = bs_get_ue(bs); \n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int(bs, 1); \n\tmb_width = bs_get_ue(bs) + 1;\n\tmb_height= bs_get_ue(bs) + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int(bs, 1);\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2-sps->frame_mbs_only_flag) * mb_height * 16;\n\t\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 1); /*direct_8x8_inference_flag*/\n\t\n\tif (gf_bs_read_int(bs, 1)) { /*crop*/\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2, SubHeightC = 2;\n\t\t} else if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2, SubHeightC = 1;\n\t\t} else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1, SubHeightC = 1;\n\t\t}\n\n\t\tif (ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC==-1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2-sps->frame_mbs_only_flag;\n\t\t} else {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2-sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = bs_get_ue(bs); /*crop_left*/\n\t\tcr = bs_get_ue(bs); /*crop_right*/\n\t\tct = bs_get_ue(bs); /*crop_top*/\n\t\tcb = bs_get_ue(bs); /*crop_bottom*/\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t} \n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32) gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int(bs, 1);\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int(bs, 8);\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int(bs, 16); /*AR num*/\n\t\t\t\tsps->vui.par_den = gf_bs_read_int(bs, 16); /*AR den*/\n\t\t\t} else if (aspect_ratio_idc<14) {\n\t\t\t\tsps->vui.par_num = avc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif(sps->vui.overscan_info_present_flag)\t\t\n\t\t\tgf_bs_read_int(bs, 1);\t\t/* overscan_appropriate_flag */\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int(bs, 3);\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int(bs, 1);\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (sps->vui.colour_description_present_flag) { \n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int(bs, 8);  \n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int(bs, 8);  \n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int(bs, 8);  \n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int(bs, 1)) {\t/* chroma_location_info_present_flag */\n\t\t\tbs_get_ue(bs);\t\t\t\t/* chroma_sample_location_type_top_field */\n\t\t\tbs_get_ue(bs);\t\t\t\t/* chroma_sample_location_type_bottom_field */\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int(bs, 32);\n\t\t\tsps->vui.time_scale = gf_bs_read_int(bs, 32);\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int(bs, 1);\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int(bs, 1); \n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int(bs, 1);\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc==83) || (profile_idc==86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\t/*inter_layer_deblocking_filter_control_present_flag=*/\tgf_bs_read_int(bs, 1);\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int(bs, 2);\n\t\t\tif (ChromaArrayType == 1 || ChromaArrayType == 2) {\n\t\t\t\t/*chroma_phase_x_plus1_flag*/ gf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t\tif( ChromaArrayType  ==  1 ) {\n\t\t\t\t/*chroma_phase_y_plus1*/ gf_bs_read_int(bs, 2);\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif( ChromaArrayType > 0 ) {\n\t\t\t\t\t/*seq_ref_layer_chroma_phase_x_plus1_flag*/gf_bs_read_int(bs, 1);\n\t\t\t\t\t/*seq_ref_layer_chroma_phase_y_plus1*/gf_bs_read_int(bs, 2);\n\t\t\t\t}\n\t\t\t\t/*seq_scaled_ref_layer_left_offset*/ bs_get_se(bs);\n\t\t\t\t/*seq_scaled_ref_layer_top_offset*/bs_get_se(bs);\n\t\t\t\t/*seq_scaled_ref_layer_right_offset*/bs_get_se(bs);\n\t\t\t\t/*seq_scaled_ref_layer_bottom_offset*/bs_get_se(bs);\n\t\t\t}\n\t\t\tif (/*seq_tcoeff_level_prediction_flag*/gf_bs_read_int(bs, 1)) {\n\t\t\t\t/*adaptive_tcoeff_level_prediction_flag*/ gf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t\t/*slice_header_restriction_flag*/gf_bs_read_int(bs, 1);\n\n\t\t\t/*svc_vui_parameters_present*/\n\t\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t\tu32 i, vui_ext_num_entries_minus1;\n\t\t\t\tvui_ext_num_entries_minus1 = bs_get_ue(bs);\n\n\t\t\t\tfor (i=0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\t/*u8 vui_ext_dependency_id =*/ gf_bs_read_int(bs, 3);\n\t\t\t\t\t/*u8 vui_ext_quality_id =*/ gf_bs_read_int(bs, 4);\n\t\t\t\t\t/*u8 vui_ext_temporal_id =*/ gf_bs_read_int(bs, 3);\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int(bs, 1);\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\t/*u32 vui_ext_num_units_in_tick = */gf_bs_read_int(bs, 32);\n\t\t\t\t\t\t/*u32 vui_ext_time_scale = */gf_bs_read_int(bs, 32);\n\t\t\t\t\t\t/*u8 vui_ext_fixed_frame_rate_flag = */gf_bs_read_int(bs, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif ( vui_ext_nal_hrd_parameters_present_flag ||  vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t/*vui_ext_low_delay_hrd_flag*/gf_bs_read_int(bs, 1);\n\t\t\t\t\t}\n\t\t\t\t\t/*vui_ext_pic_struct_present_flag*/gf_bs_read_int(bs, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc==118) || (profile_idc==128)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] MVC not supported - skipping parsing end of Subset SPS\\n\"));\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\tgf_bs_del(bs);\n\tgf_free(sps_data_without_emulation_bytes);\n\treturn sps_id;\n}\n\nGF_EXPORT\ns32 gf_media_avc_read_pps(const char *pps_data, u32 pps_size, AVCState *avc)\n{\n\tGF_BitStream *bs;\n\tchar *pps_data_without_emulation_bytes = NULL;\n\tu32 pps_data_without_emulation_bytes_size = 0;\n\ts32 pps_id;\n\tAVC_PPS *pps;\n\n\t/*PPS still contains emulation bytes*/\n\tpps_data_without_emulation_bytes = gf_malloc(pps_size*sizeof(char));\n\tpps_data_without_emulation_bytes_size = avc_remove_emulation_bytes(pps_data, pps_data_without_emulation_bytes, pps_size);\n\tbs = gf_bs_new(pps_data_without_emulation_bytes, pps_data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\tpps_id = -1;\n\t\tgoto exit;\n\t}\n\t/*nal hdr*/gf_bs_read_u8(bs);\n\n\n\tpps_id = bs_get_ue(bs);\n\tif (pps_id>=255) {\n\t\tpps_id = -1;\n\t\tgoto exit;\n\t}\n\tpps = &avc->pps[pps_id];\n\tpps->id = pps_id;\n\n\tif (!pps->status) pps->status = 1;\n\tpps->sps_id = bs_get_ue(bs);\n\tif (pps->sps_id >= 32) {\n\t\tpps->sps_id = 0;\n\t\tpps_id = -1;\n\t\tgoto exit;\n\t}\n\t/*sps_id may be refer to regular SPS or subseq sps, depending on the coded slice refering to the pps*/\n\tif (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) {\n\t\tpps_id = -1;\n\t\tgoto exit;\n\t}\n\tavc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->entropy_coding_mode_flag = gf_bs_read_int(bs, 1);\n\tpps->pic_order_present= gf_bs_read_int(bs, 1);\n\tpps->slice_group_count= bs_get_ue(bs) + 1;\n\tif (pps->slice_group_count > 1 ) /*pps->mb_slice_group_map_type = */bs_get_ue(bs);\n\t/*pps->ref_count[0]= */bs_get_ue(bs) /*+ 1*/;\n\t/*pps->ref_count[1]= */bs_get_ue(bs) /*+ 1*/;\n\t/*\n\tif ((pps->ref_count[0] > 32) || (pps->ref_count[1] > 32)) goto exit;\n\t*/\n\n\t/*pps->weighted_pred = */gf_bs_read_int(bs, 1);\n\t/*pps->weighted_bipred_idc = */gf_bs_read_int(bs, 2);\n\t/*pps->init_qp = */bs_get_se(bs) /*+ 26*/;\n\t/*pps->init_qs= */bs_get_se(bs) /*+ 26*/;\n\t/*pps->chroma_qp_index_offset = */bs_get_se(bs);\n\t/*pps->deblocking_filter_parameters_present = */gf_bs_read_int(bs, 1);\n\t/*pps->constrained_intra_pred = */gf_bs_read_int(bs, 1);\n\tpps->redundant_pic_cnt_present = gf_bs_read_int(bs, 1);\n\nexit:\n\tgf_bs_del(bs);\n\tgf_free(pps_data_without_emulation_bytes);\n\treturn pps_id;\n}\n\ns32 gf_media_avc_read_sps_ext(const char *spse_data, u32 spse_size)\n{\n\tGF_BitStream *bs;\n\tchar *spse_data_without_emulation_bytes = NULL;\n\tu32 spse_data_without_emulation_bytes_size = 0;\n\ts32 sps_id;\n\n\t/*PPS still contains emulation bytes*/\n\tspse_data_without_emulation_bytes = gf_malloc(spse_size*sizeof(char));\n\tspse_data_without_emulation_bytes_size = avc_remove_emulation_bytes(spse_data, spse_data_without_emulation_bytes, spse_size);\n\tbs = gf_bs_new(spse_data_without_emulation_bytes, spse_data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\n\t/*nal header*/gf_bs_read_u8(bs);\n\n\tsps_id = bs_get_ue(bs);\n\n\tgf_bs_del(bs);\n\tgf_free(spse_data_without_emulation_bytes);\n\treturn sps_id;\n}\n\nstatic s32 SVC_ReadNal_header_extension(GF_BitStream *bs, SVC_NALUHeader *NalHeader)\n{\n\tgf_bs_read_int(bs, 1); //reserved_one_bits\n\tNalHeader->idr_pic_flag = gf_bs_read_int(bs, 1); //idr_flag\n\tNalHeader->priority_id = gf_bs_read_int(bs, 6); //priority_id\n\tgf_bs_read_int(bs, 1); //no_inter_layer_pred_flag\n\tNalHeader->dependency_id = gf_bs_read_int(bs, 3); //DependencyId\n\tNalHeader->quality_id = gf_bs_read_int(bs, 4); //quality_id\n\tNalHeader->temporal_id = gf_bs_read_int(bs, 3); //temporal_id\n\tgf_bs_read_int(bs, 1); //use_ref_base_pic_flag\n\tgf_bs_read_int(bs, 1); //discardable_flag\n\tgf_bs_read_int(bs, 1); //output_flag\n\tgf_bs_read_int(bs, 2); //reserved_three_2bits\n\treturn 1;\n}\n\nstatic s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\t/*first_mb_in_slice = */bs_get_ue(bs);\n\tsi->slice_type = bs_get_ue(bs);\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = bs_get_ue(bs);\n\tif (pps_id>255) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;\n\t\n\tsi->frame_num = gf_bs_read_int(bs, si->sps->log2_max_frame_num);\n\n\tsi->field_pic_flag = 0;\n\tsi->bottom_field_flag = 0;\n\tif (!si->sps->frame_mbs_only_flag) {\n\t\tsi->field_pic_flag = gf_bs_read_int(bs, 1);\n\t\tif (si->field_pic_flag)\n\t\t\tsi->bottom_field_flag = gf_bs_read_int(bs, 1);\n\t}\n\tif ((si->nal_unit_type==GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)\n\t\tsi->idr_pic_id = bs_get_ue(bs);\n\n\tif (si->sps->poc_type==0) {\n\t\tsi->poc_lsb = gf_bs_read_int(bs, si->sps->log2_max_poc_lsb);\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = bs_get_se(bs);\n\t\t}\n\t} else if ((si->sps->poc_type==1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = bs_get_se(bs);\n\t\tif ((si->pps->pic_order_present==1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = bs_get_se(bs);\n\t}\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = bs_get_ue(bs);\n\t}\n\treturn 0;\n}\n\n\nstatic s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\t/*first_mb_in_slice = */bs_get_ue(bs);\n\tsi->slice_type = bs_get_ue(bs);\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = bs_get_ue(bs);\n\tif (pps_id>255)\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;\n\tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n\tif (!si->sps->log2_max_frame_num)\n\t\treturn -2;\n\n\tsi->frame_num = gf_bs_read_int(bs, si->sps->log2_max_frame_num);\n\n\tsi->field_pic_flag = 0;\n\tif (si->sps->frame_mbs_only_flag) {\n\t\t/*s->picture_structure= PICT_FRAME;*/\n\t} else {\n\t\tsi->field_pic_flag = gf_bs_read_int(bs, 1);\n\t\tif (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int(bs, 1);\n\t}\n\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si ->NalHeader.idr_pic_flag)\n\t\tsi->idr_pic_id = bs_get_ue(bs);\n\n\tif (si->sps->poc_type==0) {\n\t\tsi->poc_lsb = gf_bs_read_int(bs, si->sps->log2_max_poc_lsb);\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = bs_get_se(bs);\n\t\t}\n\t} else if ((si->sps->poc_type==1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = bs_get_se(bs);\n\t\tif ((si->pps->pic_order_present==1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = bs_get_se(bs);\n\t}\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = bs_get_ue(bs);\n\t}\n\treturn 0;\n}\n\n\nstatic s32 avc_parse_recovery_point_sei(GF_BitStream *bs, AVCState *avc)\n{\n\tAVCSeiRecoveryPoint *rp = &avc->sei.recovery_point;\n\n\trp->frame_cnt = bs_get_ue(bs);\n\trp->exact_match_flag = gf_bs_read_int(bs, 1);\n\trp->broken_link_flag = gf_bs_read_int(bs, 1);\n\trp->changing_slice_group_idc = gf_bs_read_int(bs, 2);\n\trp->valid = 1;\n\n\treturn 0;\n}\n\n/*for interpretation see ISO 14496-10 N.11084, table D-1*/\nstatic s32 avc_parse_pic_timing_sei(GF_BitStream *bs, AVCState *avc)\n{\n\tint i;\n\tint sps_id = avc->sps_active_idx;\n\tconst char NumClockTS[] = {1, 1, 1, 2, 2, 3, 3, 2, 3};\n\tAVCSeiPicTiming *pt = &avc->sei.pic_timing;\n\n\tif (sps_id < 0) {\n\t\t/*sps_active_idx equals -1 when no sps has been detected. In this case SEI should not be decoded.*/\n\t\tassert(0);\n\t\treturn 1;\n\t}\n\tif (avc->sps[sps_id].vui.nal_hrd_parameters_present_flag || avc->sps[sps_id].vui.vcl_hrd_parameters_present_flag) { /*CpbDpbDelaysPresentFlag, see 14496-10(2003) E.11*/\n\t\tgf_bs_read_int(bs, 1+avc->sps[sps_id].vui.hrd.cpb_removal_delay_length_minus1); /*cpb_removal_delay*/\n\t\tgf_bs_read_int(bs, 1+avc->sps[sps_id].vui.hrd.dpb_output_delay_length_minus1);  /*dpb_output_delay*/\n\t}\n\n\t/*ISO 14496-10 (2003), D.8.2: we need to get pic_struct in order to know if we display top field first or bottom field first*/\n\tif (avc->sps[sps_id].vui.pic_struct_present_flag) {\n\t\tpt->pic_struct = gf_bs_read_int(bs, 4);\n\t\tif (pt->pic_struct > 8) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] invalid pic_struct value %d\\n\", pt->pic_struct));\n\t\t\treturn 1;\n\t\t}\n\n\t\tfor (i=0; i<NumClockTS[pt->pic_struct]; i++) {\n\t\t\tif (gf_bs_read_int(bs, 1)) {/*clock_timestamp_flag[i]*/\n\t\t\t\tBool full_timestamp_flag;\n\t\t\t\tgf_bs_read_int(bs, 2);\t\t\t\t\t\t/*ct_type*/\n\t\t\t\tgf_bs_read_int(bs, 1);\t\t\t\t\t\t/*nuit_field_based_flag*/\n\t\t\t\tgf_bs_read_int(bs, 5);\t\t\t\t\t\t/*counting_type*/\n\t\t\t\tfull_timestamp_flag = gf_bs_read_int(bs, 1);/*full_timestamp_flag*/\n\t\t\t\tgf_bs_read_int(bs, 1);\t\t\t\t\t\t/*discontinuity_flag*/\n\t\t\t\tgf_bs_read_int(bs, 1);\t\t\t\t\t\t/*cnt_dropped_flag*/\n\t\t\t\tgf_bs_read_int(bs, 8);\t\t\t\t\t\t/*n_frames*/\n\t\t\t\tif (full_timestamp_flag) {\n\t\t\t\t\tgf_bs_read_int(bs, 6);\t\t\t\t\t/*seconds_value*/\n\t\t\t\t\tgf_bs_read_int(bs, 6);\t\t\t\t\t/*minutes_value*/\n\t\t\t\t\tgf_bs_read_int(bs, 5);\t\t\t\t\t/*hours_value*/\n\t\t\t\t} else {\n\t\t\t\t\tif (gf_bs_read_int(bs, 1)) {\t\t\t/*seconds_flag*/\n\t\t\t\t\t\tgf_bs_read_int(bs, 6);\t\t\t\t/*seconds_value*/\n\t\t\t\t\t\tif (gf_bs_read_int(bs, 1)) {\t\t/*minutes_flag*/\n\t\t\t\t\t\t\tgf_bs_read_int(bs, 6);\t\t\t/*minutes_value*/\n\t\t\t\t\t\t\tif (gf_bs_read_int(bs, 1)) {\t/*hours_flag*/\n\t\t\t\t\t\t\t\tgf_bs_read_int(bs, 5);\t\t/*hours_value*/\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (avc->sps[sps_id].vui.hrd.time_offset_length > 0)\n\t\t\t\t\t\tgf_bs_read_int(bs, avc->sps[sps_id].vui.hrd.time_offset_length);\t/*time_offset*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic void avc_compute_poc(AVCSliceInfo *si)\n{\n\tenum {\n\t\tAVC_PIC_FRAME,\n\t\tAVC_PIC_FIELD_TOP,\n\t\tAVC_PIC_FIELD_BOTTOM,\n\t} pic_type;\n\ts32 field_poc[2] = {0,0};\n\ts32 max_frame_num = 1 << (si->sps->log2_max_frame_num);\n\n\t/* picture type */\n\tif (si->sps->frame_mbs_only_flag || !si->field_pic_flag) pic_type = AVC_PIC_FRAME;\n\telse if (si->bottom_field_flag) pic_type = AVC_PIC_FIELD_BOTTOM;\n\telse pic_type = AVC_PIC_FIELD_TOP;\n\n\t/* frame_num_offset */\n\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\tsi->poc_lsb_prev = 0;\n\t\tsi->poc_msb_prev = 0;\n\t\tsi->frame_num_offset = 0;\n\t} else {\n\t\tif (si->frame_num < si->frame_num_prev)\n\t\t\tsi->frame_num_offset = si->frame_num_offset_prev + max_frame_num;\n\t\telse\n\t\t\tsi->frame_num_offset = si->frame_num_offset_prev;\n\t}\n\n\t/*ISO 14496-10 N.11084 8.2.1.1*/\n\tif (si->sps->poc_type==0)\n\t{\n\t\tconst u32 max_poc_lsb = 1 << (si->sps->log2_max_poc_lsb);\n\n\t\t/*ISO 14496-10 N.11084 eq (8-3)*/\n\t\tif ((si->poc_lsb < si->poc_lsb_prev) &&\n\t\t        (si->poc_lsb_prev - si->poc_lsb >= max_poc_lsb / 2) )\n\t\t\tsi->poc_msb = si->poc_msb_prev + max_poc_lsb;\n\t\telse if ((si->poc_lsb > si->poc_lsb_prev) &&\n\t\t         (si->poc_lsb - si->poc_lsb_prev > max_poc_lsb / 2))\n\t\t\tsi->poc_msb = si->poc_msb_prev - max_poc_lsb;\n\t\telse\n\t\t\tsi->poc_msb = si->poc_msb_prev;\n\n\t\t/*ISO 14496-10 N.11084 eq (8-4)*/\n\t\tif (pic_type != AVC_PIC_FIELD_BOTTOM)\n\t\t\tfield_poc[0] = si->poc_msb + si->poc_lsb;\n\n\t\t/*ISO 14496-10 N.11084 eq (8-5)*/\n\t\tif (pic_type != AVC_PIC_FIELD_TOP) {\n\t\t\tif (!si->field_pic_flag)\n\t\t\t\tfield_poc[1] = field_poc[0] + si->delta_poc_bottom;\n\t\t\telse\n\t\t\t\tfield_poc[1] = si->poc_msb + si->poc_lsb;\n\t\t}\n\t}\n\t/*ISO 14496-10 N.11084 8.2.1.2*/\n\telse if (si->sps->poc_type==1)\n\t{\n\t\tu32 i;\n\t\ts32 abs_frame_num, expected_delta_per_poc_cycle, expected_poc;\n\n\t\tif (si->sps->poc_cycle_length)\n\t\t\tabs_frame_num = si->frame_num_offset + si->frame_num;\n\t\telse\n\t\t\tabs_frame_num = 0;\n\n\t\tif (!si->nal_ref_idc && (abs_frame_num > 0)) abs_frame_num--;\n\n\t\texpected_delta_per_poc_cycle = 0;\n\t\tfor (i=0; i < si->sps->poc_cycle_length; i++)\n\t\t\texpected_delta_per_poc_cycle += si->sps->offset_for_ref_frame[i];\n\n\t\tif (abs_frame_num > 0) {\n\t\t\tconst u32 poc_cycle_cnt = ( abs_frame_num - 1 ) / si->sps->poc_cycle_length;\n\t\t\tconst u32 frame_num_in_poc_cycle = ( abs_frame_num - 1 ) % si->sps->poc_cycle_length;\n\n\t\t\texpected_poc = poc_cycle_cnt * expected_delta_per_poc_cycle;\n\t\t\tfor (i = 0; i<=frame_num_in_poc_cycle; i++)\n\t\t\t\texpected_poc += si->sps->offset_for_ref_frame[i];\n\t\t} else {\n\t\t\texpected_poc = 0;\n\t\t}\n\n\t\tif (!si->nal_ref_idc) expected_poc += si->sps->offset_for_non_ref_pic;\n\n\t\tfield_poc[0] = expected_poc + si->delta_poc[0];\n\t\tfield_poc[1] = field_poc[0] + si->sps->offset_for_top_to_bottom_field;\n\t\tif (pic_type == AVC_PIC_FRAME) field_poc[1] += si->delta_poc[1];\n\t}\n\t/*ISO 14496-10 N.11084 8.2.1.3*/\n\telse if (si->sps->poc_type== 2)\n\t{\n\t\tint poc;\n\t\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) {\n\t\t\tpoc = 0;\n\t\t} else {\n\t\t\tconst int abs_frame_num = si->frame_num_offset + si->frame_num;\n\t\t\tpoc = 2 * abs_frame_num;\n\t\t\tif (!si->nal_ref_idc) poc -= 1;\n\t\t}\n\t\tfield_poc[0] = poc;\n\t\tfield_poc[1] = poc;\n\t}\n\n\t/*ISO 14496-10 N.11084 eq (8-1)*/\n\tif (pic_type == AVC_PIC_FRAME)\n\t\tsi->poc = MIN(field_poc[0], field_poc[1] );\n\telse if (pic_type == AVC_PIC_FIELD_TOP)\n\t\tsi->poc = field_poc[0];\n\telse\n\t\tsi->poc = field_poc[1];\n}\n\nGF_EXPORT\ns32 gf_media_avc_parse_nalu(GF_BitStream *bs, u32 nal_hdr, AVCState *avc)\n{\n\tu8 idr_flag;\n\ts32 slice, ret;\n\tAVCSliceInfo n_state;\n\n\tslice = 0;\n\tmemcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));\n\tn_state.nal_unit_type = nal_hdr & 0x1F;\n\tn_state.nal_ref_idc = (nal_hdr>>5) & 0x3;\n\n\tidr_flag = 0;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_AVC_NALU_ACCESS_UNIT:\n\tcase GF_AVC_NALU_END_OF_SEQ:\n\tcase GF_AVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\tcase GF_AVC_NALU_SVC_SLICE:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\tslice = 1;\n\t\t// slice buffer - read the info and compare.\n\t\t/*ret = */svc_parse_slice(bs, avc, &n_state);\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t\tif (slice)\n\t\t\tavc_compute_poc(&n_state);\n\n\t\tif (avc->s_info.poc != n_state.poc) {\n\t\t\tmemcpy(&avc -> s_info, &n_state, sizeof(AVCSliceInfo));\n\t\t\treturn 1;\n\t\t}\n\t\tmemcpy(&avc -> s_info, &n_state, sizeof(AVCSliceInfo));\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SVC_PREFIX_NALU:\n\t\tSVC_ReadNal_header_extension(bs, &n_state.NalHeader);\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_NON_IDR_SLICE:\n\tcase GF_AVC_NALU_DP_A_SLICE:\n\tcase GF_AVC_NALU_DP_B_SLICE:\n\tcase GF_AVC_NALU_DP_C_SLICE:\n\tcase GF_AVC_NALU_IDR_SLICE:\n\t\tslice = 1;\n\t\t/* slice buffer - read the info and compare.*/\n\t\tret = avc_parse_slice(bs, avc, idr_flag, &n_state);\n\t\tif (ret<0) return ret;\n\t\tret = 0;\n\t\tif (\n\t\t    ((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))\n\t\t    && (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)\n\t\t) {\n\t\t\tbreak;\n\t\t}\n\t\tif (avc->s_info.frame_num != n_state.frame_num) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (avc->s_info.field_pic_flag != n_state.field_pic_flag) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&\n\t\t        (!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tassert(avc->s_info.sps);\n\n\t\tif (avc->s_info.sps->poc_type == n_state.sps->poc_type) {\n\t\t\tif (!avc->s_info.sps->poc_type) {\n\t\t\t\tif (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (avc->s_info.sps->poc_type==1) {\n\t\t\t\tif (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {\n\t\t\t\t\tret =1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE)  {\n\t\t\tif (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) { /*IdrPicFlag differs in value*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (avc->s_info.idr_pic_id != n_state.idr_pic_id) { /*both IDR and idr_pic_id differs*/\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_AVC_NALU_SEQ_PARAM:\n\tcase GF_AVC_NALU_PIC_PARAM:\n\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\tcase GF_AVC_NALU_FILLER_DATA:\n\t\treturn 0;\n\tdefault:\n\t\tif (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;\n\t\t//To detect change of AU when multiple sps and pps in stream\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc -> s_info .nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc -> s_info .nal_unit_type == GF_AVC_NALU_SVC_SLICE)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif (ret && avc->s_info.sps) {\n\t\tn_state.frame_num_offset_prev = avc->s_info.frame_num_offset;\n\t\tif ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))\n\t\t\tn_state.frame_num_prev = avc->s_info.frame_num;\n\t\tif (avc->s_info.nal_ref_idc) {\n\t\t\tn_state.poc_lsb_prev = avc->s_info.poc_lsb;\n\t\t\tn_state.poc_msb_prev = avc->s_info.poc_msb;\n\t\t}\n\t}\n\tif (slice) avc_compute_poc(&n_state);\n\tmemcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));\n\treturn ret;\n}\n\nu32 gf_media_avc_reformat_sei(char *buffer, u32 nal_size, AVCState *avc)\n{\n\tu32 ptype, psize, hdr, written, var;\n\tu64 start;\n\tchar *new_buffer;\n\tGF_BitStream *bs;\n\tchar *sei_without_emulation_bytes = NULL;\n\tu32 sei_without_emulation_bytes_size = 0;\n\n\thdr = buffer[0];\n\tif ((hdr & 0x1F) != GF_AVC_NALU_SEI) return 0;\n\n\t/*PPS still contains emulation bytes*/\n\tsei_without_emulation_bytes = gf_malloc(nal_size + 1/*for SEI null string termination*/);\n\tsei_without_emulation_bytes_size = avc_remove_emulation_bytes(buffer, sei_without_emulation_bytes, nal_size);\n\n\tbs = gf_bs_new(sei_without_emulation_bytes, sei_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\tgf_bs_read_int(bs, 8);\n\n\tnew_buffer = (char*)gf_malloc(sizeof(char)*nal_size);\n\tnew_buffer[0] = (char) hdr;\n\twritten = 1;\n\t/*parse SEI*/\n\twhile (gf_bs_available(bs)) {\n\t\tBool do_copy;\n\t\tptype = 0;\n\t\twhile (gf_bs_peek_bits(bs, 8, 0)==0xFF) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tptype += 255;\n\t\t}\n\t\tptype += gf_bs_read_int(bs, 8);\n\t\tpsize = 0;\n\t\twhile (gf_bs_peek_bits(bs, 8, 0)==0xFF) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tpsize += 255;\n\t\t}\n\t\tpsize += gf_bs_read_int(bs, 8);\n\n\t\tstart = gf_bs_get_position(bs);\n\n\t\tdo_copy = 1;\n\n\t\tif (start+psize >= nal_size) {\n\t\t\tif (written == 1) written = 0;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] SEI user message type %d size error (%d but %d remain), skiping %sSEI message\\n\", ptype, psize, nal_size-start, written ? \"end of \" : \"\"));\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ptype) {\n\t\t/*remove SEI messages forbidden in MP4*/\n\t\tcase 3: /*filler data*/\n\t\tcase 10: /*sub_seq info*/\n\t\tcase 11: /*sub_seq_layer char*/\n\t\tcase 12: /*sub_seq char*/\n\t\t\tdo_copy = 0;\n\t\t\tbreak;\n\t\tcase 5: /*user unregistered */\n\t\t{\n\t\t\tchar prev;\n\t\t\tprev = sei_without_emulation_bytes[start+psize+1];\n\t\t\tsei_without_emulation_bytes[start+psize+1] = 0;\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[avc-h264] SEI user message %s\\n\", sei_without_emulation_bytes+start+16));\n\t\t\tsei_without_emulation_bytes[start+psize+1] = prev;\n\t\t}\n\t\tbreak;\n\n\t\tcase 6: /*recovery point*/\n\t\t{\n\t\t\tGF_BitStream *rp_bs = gf_bs_new(sei_without_emulation_bytes + start, psize, GF_BITSTREAM_READ);\n\t\t\tavc_parse_recovery_point_sei(rp_bs, avc);\n\t\t\tgf_bs_del(rp_bs);\n\t\t}\n\t\tbreak;\n\n\t\tcase 1: /*pic_timing*/\n\t\t{\n\t\t\tGF_BitStream *pt_bs = gf_bs_new(sei_without_emulation_bytes + start, psize, GF_BITSTREAM_READ);\n\t\t\tavc_parse_pic_timing_sei(pt_bs, avc);\n\t\t\tgf_bs_del(pt_bs);\n\t\t}\n\t\tbreak;\n\n\t\tcase 0: /*buffering period*/\n\t\tcase 2: /*pan scan rect*/\n\t\tcase 4: /*user registered ITU t35*/\n\t\tcase 7: /*def_rec_pic_marking_repetition*/\n\t\tcase 8: /*spare_pic*/\n\t\tcase 9: /*scene info*/\n\t\tcase 13: /*full frame freeze*/\n\t\tcase 14: /*full frame freeze release*/\n\t\tcase 15: /*full frame snapshot*/\n\t\tcase 16: /*progressive refinement segment start*/\n\t\tcase 17: /*progressive refinement segment end*/\n\t\tcase 18: /*motion constrained slice group*/\n\t\t\tbreak;\n\t\tdefault: /*reserved*/\n\t\t\tdo_copy = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_copy) {\n\t\t\tvar = ptype;\n\t\t\twhile (var>=255) {\n\t\t\t\tnew_buffer[written] = (char) 0xff;\n\t\t\t\twritten++;\n\t\t\t\tvar-=255;\n\t\t\t}\n\t\t\tnew_buffer[written] = (char) var;\n\t\t\twritten++;\n\t\t\tvar = psize;\n\t\t\twhile (var>=255) {\n\t\t\t\tnew_buffer[written] = (char) 0xff;\n\t\t\t\twritten++;\n\t\t\t\tvar-=255;\n\t\t\t}\n\t\t\tnew_buffer[written] = (char) var;\n\t\t\twritten++;\n\t\t\tmemcpy(new_buffer+written, sei_without_emulation_bytes+start, sizeof(char) * psize);\n\t\t\twritten += psize;\n\t\t}\n\n\t\tgf_bs_skip_bytes(bs, (u64) psize);\n\t\tgf_bs_align(bs);\n\t\tif (gf_bs_available(bs)<=2) {\n\t\t\tif (gf_bs_peek_bits(bs, 8, 0)==0x80) {\n\t\t\t\tnew_buffer[written] = (char) 0x80;\n\t\t\t\twritten += 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\tgf_free(sei_without_emulation_bytes);\n\n\tif (written) {\n\t\tvar = avc_emulation_bytes_add_count(new_buffer, written);\n\t\tif (var) {\n\t\t\tif (written+var<=nal_size) {\n\t\t\t\twritten = avc_add_emulation_bytes(new_buffer, buffer, written);\n\t\t\t} else {\n\t\t\t\twritten = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (written<=nal_size) {\n\t\t\t\tmemcpy(buffer, new_buffer, sizeof(char)*written);\n\t\t\t} else {\n\t\t\t\twritten = 0;\n\t\t\t}\n\t\t}\n\t}\n\tgf_free(new_buffer);\n\n\t/*if only hdr written ignore*/\n\treturn (written>1) ? written : 0;\n}\n\n#ifndef GPAC_DISABLE_ISOM\n\nstatic u8 avc_get_sar_idx(u32 w, u32 h)\n{\n\tu32 i;\n\tfor (i=0; i<14; i++) {\n\t\tif ((avc_sar[i].w==w) && (avc_sar[i].h==h)) return i;\n\t}\n\treturn 0xFF;\n}\n\nGF_Err gf_media_avc_change_par(GF_AVCConfig *avcc, s32 ar_n, s32 ar_d)\n{\n\tGF_BitStream *orig, *mod;\n\tAVCState avc;\n\tu32 i, bit_offset, flag;\n\ts32 idx;\n\tGF_AVCConfigSlot *slc;\n\torig = NULL;\n\n\tmemset(&avc, 0, sizeof(AVCState));\n\tavc.sps_active_idx = -1;\n\n\ti=0;\n\twhile ((slc = (GF_AVCConfigSlot *)gf_list_enum(avcc->sequenceParameterSets, &i))) {\n\t\tchar *no_emulation_buf = NULL;\n\t\tu32 no_emulation_buf_size = 0, emulation_bytes = 0;\n\t\tidx = gf_media_avc_read_sps(slc->data, slc->size, &avc, 0, &bit_offset);\n\t\tif (idx<0) {\n\t\t\tif ( orig )\n\t\t\t\tgf_bs_del(orig);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*SPS still contains emulation bytes*/\n\t\tno_emulation_buf = gf_malloc((slc->size-1)*sizeof(char));\n\t\tno_emulation_buf_size = avc_remove_emulation_bytes(slc->data+1, no_emulation_buf, slc->size-1);\n\n\t\torig = gf_bs_new(no_emulation_buf, no_emulation_buf_size, GF_BITSTREAM_READ);\n\t\tgf_bs_read_data(orig, no_emulation_buf, no_emulation_buf_size);\n\t\tgf_bs_seek(orig, 0);\n\t\tmod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t/*copy over till vui flag*/\n\t\tassert(bit_offset>=8);\n\t\twhile (bit_offset-8/*bit_offset doesn't take care of the first byte (NALU type)*/) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t\tbit_offset--;\n\t\t}\n\t\t/*check VUI*/\n\t\tflag = gf_bs_read_int(orig, 1);\n\t\tgf_bs_write_int(mod, 1, 1); /*vui_parameters_present_flag*/\n\t\tif (flag) {\n\t\t\t/*aspect_ratio_info_present_flag*/\n\t\t\tif (gf_bs_read_int(orig, 1)) {\n\t\t\t\ts32 aspect_ratio_idc = gf_bs_read_int(orig, 8);\n\t\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\t\tgf_bs_read_int(orig, 16); /*AR num*/\n\t\t\t\t\tgf_bs_read_int(orig, 16); /*AR den*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((ar_d<0) || (ar_n<0)) {\n\t\t\t/*no AR signaled*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\n\t\t} else {\n\t\t\tu32 sarx;\n\t\t\tgf_bs_write_int(mod, 1, 1);\n\t\t\tsarx = avc_get_sar_idx((u32) ar_n, (u32) ar_d);\n\t\t\tgf_bs_write_int(mod, sarx, 8);\n\t\t\tif (sarx==0xFF) {\n\t\t\t\tgf_bs_write_int(mod, ar_n, 16);\n\t\t\t\tgf_bs_write_int(mod, ar_d, 16);\n\t\t\t}\n\t\t}\n\t\t/*no VUI in input bitstream, set all vui flags to 0*/\n\t\tif (!flag) {\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*overscan_info_present_flag */\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*video_signal_type_present_flag */\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*chroma_location_info_present_flag */\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*timing_info_present_flag*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*nal_hrd_parameters_present*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*vcl_hrd_parameters_present*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*pic_struct_present*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*bitstream_restriction*/\n\t\t}\n\n\t\t/*finally copy over remaining*/\n\t\twhile (gf_bs_bits_available(orig)) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t}\n\t\tgf_bs_del(orig);\n\t\torig = NULL;\n\t\tgf_free(no_emulation_buf);\n\n\t\t/*set anti-emulation*/\n\t\tgf_bs_get_content(mod, (char **) &no_emulation_buf, &flag);\n\t\temulation_bytes = avc_emulation_bytes_add_count(no_emulation_buf, flag);\n\t\tif (flag+emulation_bytes+1>slc->size)\n\t\t\tslc->data = (char*)gf_realloc(slc->data, flag+emulation_bytes+1);\n\t\tslc->size = avc_add_emulation_bytes(no_emulation_buf, slc->data+1, flag)+1;\n\n\t\tgf_bs_del(mod);\n\t\tgf_free(no_emulation_buf);\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_avc_get_sps_info(char *sps_data, u32 sps_size, u32 *sps_id, u32 *width, u32 *height, s32 *par_n, s32 *par_d)\n{\n\tAVCState avc;\n\ts32 idx;\n\tmemset(&avc, 0, sizeof(AVCState));\n\tavc.sps_active_idx = -1;\n\n\tidx = gf_media_avc_read_sps(sps_data, sps_size, &avc, 0, NULL);\n\tif (idx<0) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tif (sps_id) *sps_id = idx;\n\n\tif (width) *width = avc.sps[idx].width;\n\tif (height) *height = avc.sps[idx].height;\n\tif (par_n) *par_n = avc.sps[idx].vui.par_num ? avc.sps[idx].vui.par_num : (u32) -1;\n\tif (par_d) *par_d = avc.sps[idx].vui.par_den ? avc.sps[idx].vui.par_den : (u32) -1;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_avc_get_pps_info(char *pps_data, u32 pps_size, u32 *pps_id, u32 *sps_id)\n{\n\tGF_BitStream *bs;\n\tchar *pps_data_without_emulation_bytes = NULL;\n\tu32 pps_data_without_emulation_bytes_size = 0;\n\tGF_Err e = GF_OK;\n\n\t/*PPS still contains emulation bytes*/\n\tpps_data_without_emulation_bytes = gf_malloc(pps_size*sizeof(char));\n\tpps_data_without_emulation_bytes_size = avc_remove_emulation_bytes(pps_data, pps_data_without_emulation_bytes, pps_size);\n\tbs = gf_bs_new(pps_data_without_emulation_bytes, pps_data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tgoto exit;\n\t}\n\t/*nal hdr*/ gf_bs_read_int(bs, 8);\n\n\t*pps_id = bs_get_ue(bs);\n\t*sps_id = bs_get_ue(bs);\n\nexit:\n\tgf_bs_del(bs);\n\tgf_free(pps_data_without_emulation_bytes);\n\treturn e;\n}\n\n\n\n#ifndef GPAC_DISABLE_HEVC\n\n/**********\nHEVC parsing\n**********/\n\nBool gf_media_hevc_slice_is_intra(HEVCState *hevc)\n{\n\tswitch (hevc->s_info.nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nBool gf_media_hevc_slice_is_IDR(HEVCState *hevc)\n{\n\tif (hevc->sei.recovery_point.valid)\n\t{\n\t\thevc->sei.recovery_point.valid = 0;\n\t\treturn GF_TRUE;\n\t}\n\tswitch (hevc->s_info.nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nstatic Bool parse_short_term_ref_pic_set(GF_BitStream *bs, HEVC_SPS *sps, u32 idx_rps)\n{\n\tu32 i;\n\tBool inter_ref_pic_set_prediction_flag = 0;\n\tif (idx_rps != 0)\n\t\tinter_ref_pic_set_prediction_flag = gf_bs_read_int(bs, 1);\n\n\tif (inter_ref_pic_set_prediction_flag ) {\n\t\tHEVC_ReferencePictureSets *ref_ps, *rps;\n\t\tu32 delta_idx_minus1 = 0;\n\t\tu32 ref_idx;\n\t\tu32 delta_rps_sign;\n\t\tu32 abs_delta_rps_minus1, nb_ref_pics;\n\t\ts32 deltaRPS;\n\t\tu32 k = 0, k0 = 0, k1 = 0;\n\t\tif (idx_rps == sps->num_short_term_ref_pic_sets)\n\t\t\tdelta_idx_minus1 = bs_get_ue(bs);\n\n\t\tassert(delta_idx_minus1 <= idx_rps - 1);\n\t\tref_idx = idx_rps - 1 - delta_idx_minus1;\n\t\tdelta_rps_sign = gf_bs_read_int(bs, 1);\n\t\tabs_delta_rps_minus1 = bs_get_ue(bs);\n\t\tdeltaRPS = (1 - (delta_rps_sign<<1)) * (abs_delta_rps_minus1 + 1);\n\n\t\trps = &sps->rps[idx_rps];\n\t\tref_ps = &sps->rps[ref_idx];\n\t\tnb_ref_pics = ref_ps->num_negative_pics + ref_ps->num_positive_pics;\n\t\tfor (i=0; i<=nb_ref_pics; i++) {\n\t\t\ts32 ref_idc;\n\t\t\ts32 used_by_curr_pic_flag = gf_bs_read_int(bs, 1);\n\t\t\tref_idc = used_by_curr_pic_flag ? 1 : 0;\n\t\t\tif ( !used_by_curr_pic_flag ) {\n\t\t\t\tused_by_curr_pic_flag = gf_bs_read_int(bs, 1);\n\t\t\t\tref_idc = used_by_curr_pic_flag << 1;\n\t\t\t}\n\t\t\tif ((ref_idc==1) || (ref_idc== 2)) {\n\t\t\t\ts32 deltaPOC = deltaRPS;\n\t\t\t\tif (i < nb_ref_pics)\n\t\t\t\t\tdeltaPOC += ref_ps->delta_poc[i];\n\n\t\t\t\trps->delta_poc[k] = deltaPOC;\n\n\t\t\t\tif (deltaPOC < 0)  k0++;\n\t\t\t\telse k1++;\n\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\trps->num_negative_pics = k0;\n\t\trps->num_positive_pics = k1;\n\t} else {\n\t\ts32 prev = 0, poc = 0;\n\t\tsps->rps[idx_rps].num_negative_pics = bs_get_ue(bs);\n\t\tsps->rps[idx_rps].num_positive_pics = bs_get_ue(bs);\n\t\tif (sps->rps[idx_rps].num_negative_pics>16)\n\t\t\treturn GF_FALSE;\n\t\tif (sps->rps[idx_rps].num_positive_pics>16)\n\t\t\treturn GF_FALSE;\n\t\tfor (i=0; i<sps->rps[idx_rps].num_negative_pics; i++) {\n\t\t\tu32 delta_poc_s0_minus1 = bs_get_ue(bs);\n\t\t\tpoc = prev - delta_poc_s0_minus1 - 1;\n\t\t\tprev = poc;\n\t\t\tsps->rps[idx_rps].delta_poc[i] = poc;\n\t\t\t/*used_by_curr_pic_s1_flag[ i ] = */gf_bs_read_int(bs, 1);\n\t\t}\n\t\tfor (i=0; i<sps->rps[idx_rps].num_positive_pics; i++) {\n\t\t\tu32 delta_poc_s1_minus1 = bs_get_ue(bs);\n\t\t\tpoc = prev + delta_poc_s1_minus1 + 1;\n\t\t\tprev = poc;\n\t\t\tsps->rps[idx_rps].delta_poc[i] = poc;\n\t\t\t/*used_by_curr_pic_s1_flag[ i ] = */gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nvoid hevc_pred_weight_table(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si, HEVC_PPS *pps, HEVC_SPS *sps, u32 num_ref_idx_l0_active, u32 num_ref_idx_l1_active)\n{\n\tu32 i, num_ref_idx;\n\tBool first_pass=GF_TRUE;\n\tu8 luma_weights[20], chroma_weights[20];\n\tu32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;\n\n\tnum_ref_idx = num_ref_idx_l0_active;\n\n\t/*luma_log2_weight_denom=*/i=bs_get_ue(bs);\n\tif (ChromaArrayType != 0)\n\t\t/*delta_chroma_log2_weight_denom=*/i=bs_get_se(bs);\n\nparse_weights:\n\tfor (i=0; i<num_ref_idx; i++) {\n\t\tluma_weights[i] = gf_bs_read_int(bs, 1);\n\t\t//infered to be 0 if not present\n\t\tchroma_weights[i] = 0;\n\t}\n\tif (ChromaArrayType != 0) {\n\t\tfor (i=0; i<num_ref_idx; i++) {\n\t\t\tchroma_weights[i] = gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\tfor (i=0; i<num_ref_idx; i++) {\n\t\tif (luma_weights[i]) {\n\t\t\t/*delta_luma_weight_l0[ i ]=*/bs_get_se(bs);\n\t\t\t/*luma_offset_l0[ i ]=*/bs_get_se(bs);\n\t\t}\n\t\tif (chroma_weights[i]) {\n\t\t\t/*delta_chroma_weight_l0[ i ][ 0 ]=*/bs_get_se(bs);\n\t\t\t/*delta_chroma_offset_l0[ i ][ 0 ]=*/bs_get_se(bs);\n\n\t\t\t/*delta_chroma_weight_l0[ i ][ 1 ]=*/bs_get_se(bs);\n\t\t\t/*delta_chroma_offset_l0[ i ][ 1 ]=*/bs_get_se(bs);\n\t\t}\n\t}\n\n\tif (si->slice_type==GF_HEVC_SLICE_TYPE_B) {\n\t\tif (!first_pass) return;\n\t\tfirst_pass=GF_FALSE;\n\t\tnum_ref_idx = num_ref_idx_l1_active;\n\t\tgoto parse_weights;\n\t}\n}\n\nstatic\nBool ref_pic_lists_modification(GF_BitStream *bs, u32 slice_type, u32 num_ref_idx_l0_active, u32 num_ref_idx_l1_active)\n{\n\t//u32 i;\n\tBool ref_pic_list_modification_flag_l0 = gf_bs_read_int(bs, 1);\n\tif (ref_pic_list_modification_flag_l0) {\n\t\t/*for (i=0; i<num_ref_idx_l0_active; i++) {\n\t\t\tlist_entry_l0[i] = *//*gf_bs_read_int(bs, (u32)ceil(log(getNumPicTotalCurr())/log(2)));\n\t\t}*/\n\t\treturn GF_FALSE;\n\t}\n\tif (slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\tBool ref_pic_list_modification_flag_l1 = gf_bs_read_int(bs, 1);\n\t\tif (ref_pic_list_modification_flag_l1) {\n\t\t\t/*for (i=0; i<num_ref_idx_l1_active; i++) {\n\t\t\t\tlist_entry_l1[i] = *//*gf_bs_read_int(bs, (u32)ceil(log(getNumPicTotalCurr()) / log(2)));\n\t\t\t}*/\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\n\treturn GF_TRUE;\n}\n\nstatic\ns32 hevc_parse_slice_segment(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si)\n{\n\tu32 i, j;\n\tu32 num_ref_idx_l0_active=0, num_ref_idx_l1_active=0;\n\tHEVC_PPS *pps;\n\tHEVC_SPS *sps;\n\ts32 pps_id;\n\tBool RapPicFlag = GF_FALSE;\n\tBool IDRPicFlag = GF_FALSE;\n\n\tsi->first_slice_segment_in_pic_flag = gf_bs_read_int(bs, 1);\n\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\tIDRPicFlag = GF_TRUE;\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\t}\n\n\tif (RapPicFlag) {\n\t\t/*Bool no_output_of_prior_pics_flag = */gf_bs_read_int(bs, 1);\n\t}\n\n\tpps_id = bs_get_ue(bs);\n\tif (pps_id>=64)\n\t\treturn -1;\n\n\tpps = &hevc->pps[pps_id];\n\tsps = &hevc->sps[pps->sps_id];\n\tsi->sps = sps;\n\tsi->pps = pps;\n\n\tif (!si->first_slice_segment_in_pic_flag && pps->dependent_slice_segments_enabled_flag) {\n\t\tsi->dependent_slice_segment_flag = gf_bs_read_int(bs, 1);\n\t} else {\n\t\tsi->dependent_slice_segment_flag = GF_FALSE;\n\t}\n\n\tif (!si->first_slice_segment_in_pic_flag) {\n\t\tsi->slice_segment_address = gf_bs_read_int(bs, sps->bitsSliceSegmentAddress);\n\t} else {\n\t\tsi->slice_segment_address = 0;\n\t}\n\n\tif( !si->dependent_slice_segment_flag ) {\n\t\tBool deblocking_filter_override_flag=0;\n\t\tBool slice_temporal_mvp_enabled_flag = 0;\n\t\tBool slice_sao_luma_flag=0;\n\t\tBool slice_sao_chroma_flag=0;\n\t\tBool slice_deblocking_filter_disabled_flag=0;\n\n\t\t//\"slice_reserved_undetermined_flag[]\"\n\t\tgf_bs_read_int(bs, pps->num_extra_slice_header_bits);\n\n\t\tsi->slice_type = bs_get_ue(bs);\n\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_P)\n\t\t\tsi->slice_type = GF_HEVC_SLICE_TYPE_P;\n\n\t\tif(pps->output_flag_present_flag)\n\t\t\t/*pic_output_flag = */gf_bs_read_int(bs, 1);\n\n\t\tif (sps->separate_colour_plane_flag == 1)\n\t\t\t/*colour_plane_id = */gf_bs_read_int(bs, 2);\n\n\t\tif (IDRPicFlag) {\n\t\t\tsi->poc_lsb = 0;\n\n\t\t\t//if not asked to parse full header, abort since we know the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\t\t\t\n\t\t} else {\n\t\t\tsi->poc_lsb = gf_bs_read_int(bs, sps->log2_max_pic_order_cnt_lsb);\n\n\t\t\t//if not asked to parse full header, abort once we have the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t\tif (/*short_term_ref_pic_set_sps_flag =*/gf_bs_read_int(bs, 1) == 0) {\n\t\t\t\tBool ret = parse_short_term_ref_pic_set(bs, sps, sps->num_short_term_ref_pic_sets );\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn -1;\n\t\t\t} else if( sps->num_short_term_ref_pic_sets > 1 ) {\n\t\t\t\tu32 numbits = 0;\n\n\t\t\t\twhile ( (u32) (1 << numbits) < sps->num_short_term_ref_pic_sets)\n\t\t\t\t\tnumbits++;\n\t\t\t\tif (numbits > 0)\n\t\t\t\t\t/*s32 short_term_ref_pic_set_idx = */gf_bs_read_int(bs, numbits);\n\t\t\t\t/*else\n\t\t\t\t\tshort_term_ref_pic_set_idx = 0;*/\n\t\t\t}\n\t\t\tif (sps->long_term_ref_pics_present_flag ) {\n\t\t\t\tu8 DeltaPocMsbCycleLt[32];\n\t\t\t\tu32 num_long_term_sps = 0;\n\t\t\t\tu32 num_long_term_pics = 0;\n\t\t\t\tif (sps->num_long_term_ref_pic_sps > 0 ) {\n\t\t\t\t\tnum_long_term_sps = bs_get_ue(bs);\n\t\t\t\t}\n\t\t\t\tnum_long_term_pics = bs_get_ue(bs);\n\n\t\t\t\tfor (i = 0; i < num_long_term_sps + num_long_term_pics; i++ ) {\n\t\t\t\t\tif( i < num_long_term_sps ) {\n\t\t\t\t\t\tif (sps->num_long_term_ref_pic_sps > 1)\n\t\t\t\t\t\t\t/*u8 lt_idx_sps = */gf_bs_read_int(bs, gf_get_bit_size(sps->num_long_term_ref_pic_sps) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*PocLsbLt[ i ] = */ gf_bs_read_int(bs, sps->log2_max_pic_order_cnt_lsb);\n\t\t\t\t\t\t/*UsedByCurrPicLt[ i ] = */ gf_bs_read_int(bs, 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (/*delta_poc_msb_present_flag[ i ] = */ gf_bs_read_int(bs, 1) ) {\n\t\t\t\t\t\tif( i == 0 || i == num_long_term_sps )\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = bs_get_ue(bs);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = bs_get_ue(bs) + DeltaPocMsbCycleLt[i-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sps->temporal_mvp_enable_flag)\n\t\t\t\tslice_temporal_mvp_enabled_flag = gf_bs_read_int(bs, 1);\n\t\t}\n\t\tif (sps->sample_adaptive_offset_enabled_flag) {\n\t\t\tu32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;\n\t\t\tslice_sao_luma_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (ChromaArrayType!=0)\n\t\t\t\tslice_sao_chroma_flag = gf_bs_read_int(bs, 1);\n\t\t}\n\n\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_P || si->slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\t\t//u32 NumPocTotalCurr;\n\t\t\tnum_ref_idx_l0_active = pps->num_ref_idx_l0_default_active;\n\t\t\tnum_ref_idx_l1_active = 0;\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tnum_ref_idx_l1_active = pps->num_ref_idx_l1_default_active;\n\n\t\t\tif ( /*num_ref_idx_active_override_flag =*/gf_bs_read_int(bs, 1) ) {\n\t\t\t\tnum_ref_idx_l0_active = 1 + bs_get_ue(bs);\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tnum_ref_idx_l1_active = 1 + bs_get_ue(bs);\n\t\t\t}\n\n\t\t\tif (pps->lists_modification_present_flag /*TODO: && NumPicTotalCurr > 1*/) {\n\t\t\t\tif (!ref_pic_lists_modification(bs, si->slice_type, num_ref_idx_l0_active, num_ref_idx_l1_active)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[hevc] ref_pic_lists_modification( ) not implemented\\n\"));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t/*mvd_l1_zero_flag=*/gf_bs_read_int(bs, 1);\n\t\t\tif (pps->cabac_init_present_flag)\n\t\t\t\t/*cabac_init_flag=*/gf_bs_read_int(bs, 1);\n\n\t\t\tif (slice_temporal_mvp_enabled_flag) {\n\t\t\t\t// When collocated_from_l0_flag is not present, it is inferred to be equal to 1.\n\t\t\t\tBool collocated_from_l0_flag = 1;\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tcollocated_from_l0_flag = gf_bs_read_int(bs, 1);\n\n\t\t\t\tif ( (collocated_from_l0_flag && (num_ref_idx_l0_active>1) )\n\t\t\t\t        || ( !collocated_from_l0_flag && (num_ref_idx_l1_active>1) )\n\t\t\t\t   ) {\n\t\t\t\t\t/*collocated_ref_idx=*/bs_get_ue(bs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( (pps->weighted_pred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_P )\n\t\t\t        || ( pps->weighted_bipred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t   ) {\n\t\t\t\thevc_pred_weight_table(bs, hevc, si, pps, sps, num_ref_idx_l0_active, num_ref_idx_l1_active);\n\t\t\t}\n\t\t\t/*five_minus_max_num_merge_cand=*/bs_get_ue(bs);\n\t\t}\n\t\t/*slice_qp_delta = */bs_get_se(bs);\n\t\tif( pps->slice_chroma_qp_offsets_present_flag ) {\n\t\t\t/*slice_cb_qp_offset=*/bs_get_se(bs);\n\t\t\t/*slice_cr_qp_offset=*/bs_get_se(bs);\n\t\t}\n\t\tif ( pps->deblocking_filter_override_enabled_flag ) {\n\t\t\tdeblocking_filter_override_flag = gf_bs_read_int(bs, 1);\n\t\t}\n\n\t\tif (deblocking_filter_override_flag) {\n\t\t\tslice_deblocking_filter_disabled_flag = gf_bs_read_int(bs, 1);\n\t\t\tif ( !slice_deblocking_filter_disabled_flag) {\n\t\t\t\t/*slice_beta_offset_div2=*/ bs_get_se(bs);\n\t\t\t\t/*slice_tc_offset_div2=*/bs_get_se(bs);\n\t\t\t}\n\t\t}\n\t\tif( pps->loop_filter_across_slices_enabled_flag\n\t\t        && ( slice_sao_luma_flag || slice_sao_chroma_flag || !slice_deblocking_filter_disabled_flag )\n\t\t  ) {\n\t\t\t/*slice_loop_filter_across_slices_enabled_flag = */gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\t//dependent slice segment\n\telse {\n\t\t//if not asked to parse full header, abort\n\t\tif (!hevc->full_slice_header_parse) return 0;\n\t}\n\n\tsi->entry_point_start_bits = ((u32)gf_bs_get_position(bs)-1)*8 + gf_bs_get_bit_position(bs);\n\n\tif (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag ) {\n\t\tu32 num_entry_point_offsets = bs_get_ue(bs);\n\t\tif ( num_entry_point_offsets > 0) {\n\t\t\tu32 offset = bs_get_ue(bs) + 1;\n\t\t\tu32 segments = offset >> 4;\n\t\t\ts32 remain = (offset & 15);\n\n\t\t\tfor (i=0; i<num_entry_point_offsets; i++) {\n\t\t\t\tu32 res = 0;\n\t\t\t\tfor (j=0; j<segments; j++) {\n\t\t\t\t\tres <<= 16;\n\t\t\t\t\tres += gf_bs_read_int(bs, 16);\n\t\t\t\t}\n\t\t\t\tif (remain) {\n\t\t\t\t\tres <<= remain;\n\t\t\t\t\tres += gf_bs_read_int(bs, remain);\n\t\t\t\t}\n\t\t\t\t// entry_point_offset = val + 1; // +1; // +1 to get the size\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pps->slice_segment_header_extension_present_flag) {\n\t\tu32 size_ext = bs_get_ue(bs);\n\t\twhile (size_ext) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tsize_ext--;\n\t\t}\n\t}\n\n\tif (gf_bs_read_int(bs, 1) == 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Error parsing slice header: byte_align not found at end of header !\\n\"));\n\t}\n\n\tgf_bs_align(bs);\n\tsi->payload_start_offset = (s32)gf_bs_get_position(bs);\n\treturn 0;\n}\n\nstatic void hevc_compute_poc(HEVCSliceInfo *si)\n{\n\tu32 max_poc_lsb = 1 << (si->sps->log2_max_pic_order_cnt_lsb);\n\n\t/*POC reset for IDR frames, NOT for CRA*/\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\tsi->poc_lsb_prev = 0;\n\t\tsi->poc_msb_prev = 0;\n\t\tbreak;\n\t}\n\n\tif ((si->poc_lsb < si->poc_lsb_prev) && (\tsi->poc_lsb_prev - si->poc_lsb >= max_poc_lsb / 2) )\n\t\tsi->poc_msb = si->poc_msb_prev + max_poc_lsb;\n\telse if ((si->poc_lsb > si->poc_lsb_prev) && (si->poc_lsb - si->poc_lsb_prev > max_poc_lsb / 2))\n\t\tsi->poc_msb = si->poc_msb_prev - max_poc_lsb;\n\telse\n\t\tsi->poc_msb = si->poc_msb_prev;\n\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\tsi->poc_msb  = 0;\n\t\tbreak;\n\t}\n\tsi->poc = si->poc_msb + si->poc_lsb;\n}\n\n\nstatic Bool hevc_parse_nal_header(GF_BitStream *bs, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tu32 val;\n\tval = gf_bs_read_int(bs, 1);\n\tif (val) return GF_FALSE;\n\n\tval = gf_bs_read_int(bs, 6);\n\tif (nal_unit_type) *nal_unit_type = val;\n\n\tval = gf_bs_read_int(bs, 6);\n\tif (layer_id) *layer_id = val;\n\n\tval = gf_bs_read_int(bs, 3);\n\tif (! val)\n\t\treturn GF_FALSE;\n\tval -= 1;\n\tif (temporal_id) *temporal_id = val;\n\treturn GF_TRUE;\n}\n\n\nvoid profile_tier_level(GF_BitStream *bs, Bool ProfilePresentFlag, u8 MaxNumSubLayersMinus1, HEVC_ProfileTierLevel *ptl)\n{\n\tu32 i;\n\tif (ProfilePresentFlag) {\n\t\tptl->profile_space = gf_bs_read_int(bs, 2);\n\t\tptl->tier_flag = gf_bs_read_int(bs, 1);\n\t\tptl->profile_idc = gf_bs_read_int(bs, 5);\n\n\t\tptl->profile_compatibility_flag = gf_bs_read_int(bs, 32);\n\n\t\tptl->general_progressive_source_flag = gf_bs_read_int(bs, 1);\n\t\tptl->general_interlaced_source_flag = gf_bs_read_int(bs, 1);\n\t\tptl->general_non_packed_constraint_flag = gf_bs_read_int(bs, 1);\n\t\tptl->general_frame_only_constraint_flag = gf_bs_read_int(bs, 1);\n\t\tptl->general_reserved_44bits = gf_bs_read_long_int(bs, 44);\n\t}\n\tptl->level_idc = gf_bs_read_int(bs, 8);\n\tfor (i=0; i<MaxNumSubLayersMinus1; i++) {\n\t\tptl->sub_ptl[i].profile_present_flag = gf_bs_read_int(bs, 1);\n\t\tptl->sub_ptl[i].level_present_flag = gf_bs_read_int(bs, 1);\n\t}\n\tif (MaxNumSubLayersMinus1>0) {\n\t\tfor (i=MaxNumSubLayersMinus1; i<8; i++) {\n\t\t\t/*reserved_zero_2bits*/gf_bs_read_int(bs, 2);\n\t\t}\n\t}\n\n\tfor (i=0; i<MaxNumSubLayersMinus1; i++) {\n\t\tif (ptl->sub_ptl[i].profile_present_flag) {\n\t\t\tptl->sub_ptl[i].profile_space = gf_bs_read_int(bs, 2);\n\t\t\tptl->sub_ptl[i].tier_flag = gf_bs_read_int(bs, 1);\n\t\t\tptl->sub_ptl[i].profile_idc = gf_bs_read_int(bs, 5);\n\t\t\tptl->sub_ptl[i].profile_compatibility_flag = gf_bs_read_int(bs, 32);\n\t\t\t/*ptl->sub_ptl[i].progressive_source_flag =*/ gf_bs_read_int(bs, 1);\n\t\t\t/*ptl->sub_ptl[i].interlaced_source_flag =*/ gf_bs_read_int(bs, 1);\n\t\t\t/*ptl->sub_ptl[i].non_packed_constraint_flag =*/ gf_bs_read_int(bs, 1);\n\t\t\t/*ptl->sub_ptl[i].frame_only_constraint_flag =*/ gf_bs_read_int(bs, 1);\n\t\t\t/*ptl->sub_ptl[i].reserved_44bits =*/ gf_bs_read_long_int(bs, 44);\n\t\t}\n\t\tif (ptl->sub_ptl[i].level_present_flag)\n\t\t\tptl->sub_ptl[i].level_idc = gf_bs_read_int(bs, 8);\n\t}\n}\n\nstatic u32 scalability_type_to_idx(HEVC_VPS *vps, u32 scalability_type)\n{\n\tu32 idx = 0, type;\n\tfor (type=0; type < scalability_type; type++) {\n\t\tidx += (vps->scalability_mask[type] ? 1 : 0 );\n\t}\n\treturn idx;\n}\n\n#define LHVC_VIEW_ORDER_INDEX  1\n#define LHVC_SCALABILITY_INDEX\t2\n\nstatic u32 lhvc_get_scalability_id(HEVC_VPS *vps, u32 layer_id_in_vps, u32 scalability_type )\n{\n\tu32 idx;\n\tif (!vps->scalability_mask[scalability_type]) return 0;\n\tidx = scalability_type_to_idx(vps, scalability_type);\n\treturn vps->dimension_id[layer_id_in_vps][idx];\n}\n\nstatic u32 lhvc_get_view_index(HEVC_VPS *vps, u32 id)\n{\n\treturn lhvc_get_scalability_id(vps, vps->layer_id_in_vps[id], LHVC_VIEW_ORDER_INDEX);\n}\n\nstatic u32 lhvc_get_num_views(HEVC_VPS *vps)\n{\n\tu32 numViews = 1, i;\n\tfor (i=0; i<vps->max_layers; i++ ) {\n\t\tu32 layer_id = vps->layer_id_in_nuh[i];\n\t\tif (i>0 && ( lhvc_get_view_index( vps, layer_id) != lhvc_get_scalability_id( vps, i-1, LHVC_VIEW_ORDER_INDEX) )) {\n\t\t\tnumViews++;\n\t\t}\n\t}\n\treturn numViews;\n}\n\nstatic void lhvc_parse_rep_format(HEVC_RepFormat *fmt, GF_BitStream *bs)\n{\n\tu8 chroma_bitdepth_present_flag;\n\tfmt->pic_width_luma_samples = gf_bs_read_int(bs, 16);\n\tfmt->pic_height_luma_samples = gf_bs_read_int(bs, 16);\n\tchroma_bitdepth_present_flag = gf_bs_read_int(bs, 1);\n\tif (chroma_bitdepth_present_flag) {\n\t\tfmt->chroma_format_idc = gf_bs_read_int(bs, 2);\n\n\t\tif (fmt->chroma_format_idc == 3)\n\t\t\tfmt->separate_colour_plane_flag = gf_bs_read_int(bs, 1);\n\t\tfmt->bit_depth_luma = 8 + gf_bs_read_int(bs, 4);\n\t\tfmt->bit_depth_chroma = 8 + gf_bs_read_int(bs, 4);\n\t}\n\tif (/*conformance_window_vps_flag*/ gf_bs_read_int(bs, 1)) {\n\t\t/*conf_win_vps_left_offset*/bs_get_ue(bs);\n\t\t/*conf_win_vps_right_offset*/bs_get_ue(bs);\n\t\t/*conf_win_vps_top_offset*/bs_get_ue(bs);\n\t\t/*conf_win_vps_bottom_offset*/bs_get_ue(bs);\n\t}\n}\n\n\nstatic Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)\n{\n\tu8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;\n\tu32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc=0;\n\tu8 dimension_id_len[16], dim_bit_offset[16];\n\tu8 /*avc_base_layer_flag, */NumLayerSets, /*default_one_target_output_layer_flag, */rep_format_idx_present_flag, ols_ids_to_ls_idx;\n\tu8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];\n\tu8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS+1];\n\tu8 ols_highest_output_layer_id[MAX_LHVC_LAYERS+1];\n\n\tu32 k,d, r, p, iNuhLId, jNuhLId;\n\tu8 num_direct_ref_layers[64], num_pred_layers[64], num_layers_in_tree_partition[MAX_LHVC_LAYERS];\n\tu8 dependency_flag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS], id_pred_layers[64][MAX_LHVC_LAYERS];\n//\tu8 num_ref_layers[64];\n//\tu8 tree_partition_layer_id[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n//\tu8 id_ref_layers[64][MAX_LHVC_LAYERS];\n//\tu8 id_direct_ref_layers[64][MAX_LHVC_LAYERS];\n\tu8 layer_id_in_list_flag[64];\n\tBool OutputLayerFlag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];\n\n\tvps->vps_extension_found=1;\n\tif ((vps->max_layers > 1) && vps->base_layer_internal_flag)\n\t\tprofile_tier_level(bs, 0, vps->max_sub_layers-1, &vps->ext_ptl[0]);\n\n\tsplitting_flag = gf_bs_read_int(bs, 1);\n\tnum_scalability_types = 0;\n\tfor (i=0; i<16; i++) {\n\t\tvps->scalability_mask[i] = gf_bs_read_int(bs, 1);\n\t\tnum_scalability_types += vps->scalability_mask[i];\n\t}\n\tif (num_scalability_types>=16) {\n\t\tnum_scalability_types=16;\n\t}\n\tdimension_id_len[0] = 0;\n\tfor (i=0; i<(num_scalability_types - splitting_flag); i++) {\n\t\tdimension_id_len[i] = 1 + gf_bs_read_int(bs, 3);\n\t}\n\t\n\tif (splitting_flag) {\n\t\tfor (i = 0; i < num_scalability_types; i++) {\n\t\t\tdim_bit_offset[i] = 0;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tdim_bit_offset[i] +=  dimension_id_len[j];\n\t\t}\n\t\tdimension_id_len[num_scalability_types-1] = 1 + (5 - dim_bit_offset[num_scalability_types-1]);\n\t\tdim_bit_offset[num_scalability_types] = 6;\n\t}\n\n\tvps_nuh_layer_id_present_flag = gf_bs_read_int(bs, 1);\n\tvps->layer_id_in_nuh[0] = 0;\n\tvps->layer_id_in_vps[0] = 0;\n\tfor (i=1; i<vps->max_layers; i++) {\n\t\tif (vps_nuh_layer_id_present_flag) {\n\t\t\tvps->layer_id_in_nuh[i] = gf_bs_read_int(bs, 6);\n\t\t} else {\n\t\t\tvps->layer_id_in_nuh[i] = i;\n\t\t}\n\t\tvps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;\n\n\t\tif (!splitting_flag) {\n\t\t\tfor (j=0; j<num_scalability_types; j++) {\n\t\t\t\tvps->dimension_id[i][j] = gf_bs_read_int(bs, dimension_id_len[j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (splitting_flag) {\n\t\tfor (i = 0; i<vps->max_layers; i++)\n\t\t\tfor (j=0; j<num_scalability_types; j++)\n\t\t\t\tvps->dimension_id[i][j] = ((vps->layer_id_in_nuh[i] & ((1 << dim_bit_offset[j+1]) -1)) >> dim_bit_offset[j]);\n\t} else {\n\t\tfor (j=0; j<num_scalability_types; j++)\n\t\t\tvps->dimension_id[0][j] = 0;\n\t}\n\n\tview_id_len = gf_bs_read_int(bs, 4);\n\tif (view_id_len > 0) {\n\t\tfor( i = 0; i < lhvc_get_num_views(vps); i++ ) {\n\t\t\t/*m_viewIdVal[i] = */ gf_bs_read_int(bs, view_id_len);\n\t\t}\n\t}\n\n\tfor (i=1; i<vps->max_layers; i++) {\n\t\tfor (j=0; j<i; j++) {\n\t\t\tvps->direct_dependency_flag[i][j] = gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\n\t//we do the test on MAX_LHVC_LAYERS and break in the loop to avoid a wrong GCC 4.8 warning on array bounds\n\tfor (i = 0; i < MAX_LHVC_LAYERS; i++) {\n\t\tif (i >= vps->max_layers) break;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tdependency_flag[i][j] = vps->direct_dependency_flag[i][j];\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t\tif (vps->direct_dependency_flag[i][k] && vps->direct_dependency_flag[k][j])\n\t\t\t\t\tdependency_flag[i][j] = 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\td = r = p = 0;\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tjNuhLId = vps->layer_id_in_nuh[j];\n\t\t\tif (vps->direct_dependency_flag[i][j]) {\n//\t\t\t\tid_direct_ref_layers[iNuhLId][d] = jNuhLId;\n\t\t\t\td++;\n\t\t\t}\n\t\t\tif (dependency_flag[i][j]) {\n//\t\t\t\tid_ref_layers[iNuhLId][r] = jNuhLId;\n\t\t\t\tr++;\n\t\t\t}\n\t\t\t\t\n\t\t\tif (dependency_flag[j][i])\n\t\t\t\tid_pred_layers[iNuhLId][p++] = jNuhLId;\n\t\t}\n\t\tnum_direct_ref_layers[iNuhLId] = d;\n//\t\tnum_ref_layers[iNuhLId] = r;\n\t\tnum_pred_layers[iNuhLId] = p;\n\t}\n\n\tmemset(layer_id_in_list_flag, 0, 64*sizeof(u8));\n\tk = 0; //num_indepentdent_layers\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tiNuhLId = vps->layer_id_in_nuh[i];\n\t\tif (!num_direct_ref_layers[iNuhLId]) {\n\t\t\tu32 h = 1;\n\t\t\t//tree_partition_layer_id[k][0] = iNuhLId;\t\t\n\t\t\tfor (j = 0; j < num_pred_layers[iNuhLId]; j++) {\n\t\t\t\tu32 predLId = id_pred_layers[iNuhLId][j];\n\t\t\t\tif (!layer_id_in_list_flag[predLId]) {\n\t\t\t\t\t//tree_partition_layer_id[k][h++] = predLId;\n\t\t\t\t\tlayer_id_in_list_flag[predLId] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_layers_in_tree_partition[k++] = h;\n\t\t}\n\t}\n\tnum_indepentdent_layers = k;\n\t\n\tnum_add_layer_set = 0;\n\tif (num_indepentdent_layers > 1)\n\t\tnum_add_layer_set = bs_get_ue(bs);\n\n\tfor (i = 0; i < num_add_layer_set; i++)\n\t\tfor (j = 1; j < num_indepentdent_layers; j++) {\n\t\t\tnb_bits =1;\n\t\t\t while ((1 << nb_bits) < (num_layers_in_tree_partition[j] + 1))\n\t\t\t\tnb_bits++;\n\t\t\t/*highest_layer_idx_plus1[i][j]*/gf_bs_read_int(bs, nb_bits);\n\t\t}\n\n\n\tif (/*vps_sub_layers_max_minus1_present_flag*/gf_bs_read_int(bs, 1)) {\n\t\tfor (i = 0; i < vps->max_layers; i++) {\n\t\t\t/*sub_layers_vps_max_minus1[ i ]*/gf_bs_read_int(bs, 3);\n\t\t}\n\t}\n\n\tif (/*max_tid_ref_present_flag = */gf_bs_read_int(bs, 1)) {\n\t\tfor (i=0; i<(vps->max_layers-1) ; i++) {\n\t\t\tfor (j= i+1; j < vps->max_layers; j++) {\n\t\t\t\tif (vps->direct_dependency_flag[j][i])\n\t\t\t\t\t/*max_tid_il_ref_pics_plus1[ i ][ j ]*/gf_bs_read_int(bs, 3);\n\t\t\t}\n\t\t}\n\t}\n\t/*default_ref_layers_active_flag*/gf_bs_read_int(bs, 1);\n\n\tvps->num_profile_tier_level = 1+bs_get_ue(bs);\n\tif (vps->num_profile_tier_level > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of PTLs in VPS %d\\n\", vps->num_profile_tier_level));\n\t\tvps->num_profile_tier_level=1;\n\t\treturn GF_FALSE;\n\t}\n\t\n\tfor (i=vps->base_layer_internal_flag ? 2 : 1; i < vps->num_profile_tier_level; i++) {\n\t\tBool vps_profile_present_flag = gf_bs_read_int(bs, 1);\n\t\tprofile_tier_level(bs, vps_profile_present_flag, vps->max_sub_layers-1, &vps->ext_ptl[i-1] );\n\t}\n\t\n\tNumLayerSets = vps->num_layer_sets + num_add_layer_set;\n\tnum_add_olss = 0;\n\t\n\tif (NumLayerSets > 1) {\n\t\tnum_add_olss = bs_get_ue(bs);\n\t\tdefault_output_layer_idc = gf_bs_read_int(bs,2);\n\t\tdefault_output_layer_idc = default_output_layer_idc < 2 ? default_output_layer_idc : 2;\n\t}\n\tvps->num_output_layer_sets = num_add_olss + NumLayerSets;\n\n\n\tlayer_set_idx_for_ols_minus1[0] = 1;\n\tvps->output_layer_flag[0][0] = 1;\n\n\tfor (i = 0; i < vps->num_output_layer_sets; i++) {\n\t\tif ((NumLayerSets > 2) && (i >= NumLayerSets)) {\n\t\t\tnb_bits = 1;\n\t\t\twhile ((1 << nb_bits) < (NumLayerSets - 1))\n\t\t\t\tnb_bits++;\n\t\t\tlayer_set_idx_for_ols_minus1[i] = gf_bs_read_int(bs, nb_bits);\n\t\t}\n\t\telse\n\t\t\tlayer_set_idx_for_ols_minus1[i] = 0;\n\t\tols_ids_to_ls_idx = i < NumLayerSets ? i : layer_set_idx_for_ols_minus1[i] + 1;\n\n\t\tif ((i > (vps->num_layer_sets - 1)) || (default_output_layer_idc == 2)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\t\tvps->output_layer_flag[i][j] = gf_bs_read_int(bs, 1);\n\t\t}\n\n\t\tif ((default_output_layer_idc == 0) || (default_output_layer_idc == 1)) {\n\t\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\t\tif ((default_output_layer_idc == 0) || (vps->LayerSetLayerIdList[i][j] == vps->LayerSetLayerIdListMax[i]))\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_TRUE;\n\t\t\t\telse\n\t\t\t\t\tOutputLayerFlag[i][j] = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tu32 curLayerID, k;\n\t\t\t\tvps->necessary_layers_flag[i][j] = GF_TRUE;\n\t\t\t\tcurLayerID = vps->LayerSetLayerIdList[i][j];\n\t\t\t\tfor (k = 0; k < j; k++) {\n\t\t\t\t\tu32 refLayerId = vps->LayerSetLayerIdList[i][k];\n\t\t\t\t\tif (dependency_flag[vps->layer_id_in_vps[curLayerID]][vps->layer_id_in_vps[refLayerId]])\n\t\t\t\t\t\tvps->necessary_layers_flag[i][k] = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_necessary_layers[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tif (vps->necessary_layers_flag[i][j])\n\t\t\t\tvps->num_necessary_layers[i] += 1;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tif (vps->base_layer_internal_flag) {\n\t\t\t\tif (vps->max_layers > 1)\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 1;\n\t\t\t\telse\n\t\t\t\t\tvps->profile_tier_level_idx[0][0] = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tnb_bits = 1;\n\t\twhile ((u32)(1 << nb_bits) < vps->num_profile_tier_level)\n\t\t\tnb_bits++;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)\n\t\t\tif (vps->necessary_layers_flag[i][j] && vps->num_profile_tier_level)\n\t\t\t\tvps->profile_tier_level_idx[i][j] = gf_bs_read_int(bs, nb_bits);\n\t\t\telse\n\t\t\t\tvps->profile_tier_level_idx[i][j] = 0;\n\n\n\t\tnb_output_layers_in_output_layer_set[i] = 0;\n\t\tfor (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {\n\t\t\tnb_output_layers_in_output_layer_set[i] += OutputLayerFlag[i][j];\n\t\t\tif (OutputLayerFlag[i][j]) {\n\t\t\t\tols_highest_output_layer_id[i] = vps->LayerSetLayerIdList[ols_ids_to_ls_idx][j];\n\t\t\t}\n\t\t}\n\t\tif (nb_output_layers_in_output_layer_set[i] == 1 && ols_highest_output_layer_id[i] > 0)\n\t\t\t vps->alt_output_layer_flag[i] = gf_bs_read_int(bs, 1);\n\t}\n\n\tvps->num_rep_formats = 1 + bs_get_ue(bs);\n\tif (vps->num_rep_formats > 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of rep formats in VPS %d\\n\", vps->num_rep_formats));\n\t\tvps->num_rep_formats = 0;\n\t\treturn GF_FALSE;\n\t}\n\n\tfor (i = 0; i < vps->num_rep_formats; i++) {\n\t\tlhvc_parse_rep_format(&vps->rep_formats[i], bs);\n\t}\n\tif (vps->num_rep_formats > 1)\n\t\trep_format_idx_present_flag = gf_bs_read_int(bs, 1);\n\telse\n\t\trep_format_idx_present_flag = 0;\n\n\tvps->rep_format_idx[0] = 0;\n\tnb_bits = 1;\n\twhile ((u32)(1 << nb_bits) < vps->num_rep_formats)\n\t\tnb_bits++;\n\tfor (i = vps->base_layer_internal_flag ? 1 : 0; i < vps->max_layers; i++) {\n\t\tif (rep_format_idx_present_flag) {\n\t\t\tvps->rep_format_idx[i] = gf_bs_read_int(bs, nb_bits);\n\t\t}\n\t\telse {\n\t\t\tvps->rep_format_idx[i] = i < vps->num_rep_formats - 1 ? i : vps->num_rep_formats - 1;\n\t\t}\n\t}\n//TODO - we don't use the rest ...\n\nreturn GF_TRUE;\n}\n\nstatic void sub_layer_hrd_parameters(GF_BitStream *bs, int subLayerId, u32 cpb_cnt, Bool sub_pic_hrd_params_present_flag) {\n\tu32 i;\n\tfor (i = 0; i <= cpb_cnt; i++) {\n\t\t/*bit_rate_value_minus1[i] = */bs_get_ue(bs);\n\t\t/*cpb_size_value_minus1[i] = */bs_get_ue(bs);\n\t\tif (sub_pic_hrd_params_present_flag) {\n\t\t\t/*cpb_size_du_value_minus1[i] = */bs_get_ue(bs);\n\t\t\t/*bit_rate_du_value_minus1[i] = */bs_get_ue(bs);\n\t\t}\n\t\t/*cbr_flag[i] = */gf_bs_read_int(bs, 1);\n\t}\n}\n\nstatic void hevc_parse_hrd_parameters(GF_BitStream *bs, Bool commonInfPresentFlag, int maxNumSubLayersMinus1)\n{\n\tint i;\n\tBool nal_hrd_parameters_present_flag = GF_FALSE;\n\tBool vcl_hrd_parameters_present_flag = GF_FALSE;\n\tBool sub_pic_hrd_params_present_flag = GF_FALSE;\n\tif (commonInfPresentFlag) {\n\t\tnal_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\tvcl_hrd_parameters_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\n\t\t\tsub_pic_hrd_params_present_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (sub_pic_hrd_params_present_flag) {\n\t\t\t\t/*tick_divisor_minus2 = */gf_bs_read_int(bs, 8);\n\t\t\t\t/*du_cpb_removal_delay_increment_length_minus1 = */gf_bs_read_int(bs, 5);\n\t\t\t\t/*sub_pic_cpb_params_in_pic_timing_sei_flag = */gf_bs_read_int(bs, 1);\n\t\t\t\t/*dpb_output_delay_du_length_minus1 = */gf_bs_read_int(bs, 5);\n\t\t\t}\n\t\t\t/*bit_rate_scale = */gf_bs_read_int(bs, 4);\n\t\t\t/*cpb_size_scale = */gf_bs_read_int(bs, 4);\n\t\t\tif (sub_pic_hrd_params_present_flag) {\n\t\t\t\t/*cpb_size_du_scale = */gf_bs_read_int(bs, 4);\n\t\t\t}\n\t\t\t/*initial_cpb_removal_delay_length_minus1 = */gf_bs_read_int(bs, 5);\n\t\t\t/*au_cpb_removal_delay_length_minus1 = */gf_bs_read_int(bs, 5);\n\t\t\t/*dpb_output_delay_length_minus1 = */gf_bs_read_int(bs, 5);\n\t\t}\n\t}\n\tfor (i = 0; i <= maxNumSubLayersMinus1; i++) {\n\t\tBool fixed_pic_rate_general_flag_i = gf_bs_read_int(bs, 1);\n\t\tBool fixed_pic_rate_within_cvs_flag_i = GF_TRUE;\n\t\tBool low_delay_hrd_flag_i = GF_FALSE;\n\t\tu32 cpb_cnt_minus1_i = 0;\n\t\tif (!fixed_pic_rate_general_flag_i) {\n\t\t\tfixed_pic_rate_within_cvs_flag_i = gf_bs_read_int(bs, 1);\n\t\t}\n\t\tif (fixed_pic_rate_within_cvs_flag_i)\n\t\t\t/*elemental_duration_in_tc_minus1[i] = */bs_get_ue(bs);\n\t\telse\n\t\t\tlow_delay_hrd_flag_i = gf_bs_read_int(bs, 1);\n\t\tif (!low_delay_hrd_flag_i) {\n\t\t\tcpb_cnt_minus1_i = bs_get_ue(bs);\n\t\t}\n\t\tif (nal_hrd_parameters_present_flag) {\n\t\t\tsub_layer_hrd_parameters(bs, i, cpb_cnt_minus1_i, sub_pic_hrd_params_present_flag);\n\t\t}\n\t\tif (vcl_hrd_parameters_present_flag) {\n\t\t\tsub_layer_hrd_parameters(bs, i, cpb_cnt_minus1_i, sub_pic_hrd_params_present_flag);\n\t\t}\n\t}\n}\n\nstatic s32 gf_media_hevc_read_vps_bs(GF_BitStream *bs, HEVCState *hevc, Bool stop_at_vps_ext)\n{\n\tu8 vps_sub_layer_ordering_info_present_flag, vps_extension_flag;\n\tu32 i, j;\n\ts32 vps_id = -1;\n\tHEVC_VPS *vps;\n\tu8 layer_id_included_flag[MAX_LHVC_LAYERS][64];\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int(bs, 4);\n\n\tif (vps_id>=16) return -1;\n\n\tvps = &hevc->vps[vps_id];\n\tvps->bit_pos_vps_extensions = -1;\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\n\tvps->base_layer_internal_flag = gf_bs_read_int(bs, 1);\n\tvps->base_layer_available_flag = gf_bs_read_int(bs, 1);\n\tvps->max_layers = 1 + gf_bs_read_int(bs, 6);\n\tif (vps->max_layers>MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] sorry, %d layers in VPS but only %d supported\\n\", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int(bs, 3) + 1;\n\tvps->temporal_id_nesting = gf_bs_read_int(bs, 1);\n\t/* vps_reserved_ffff_16bits = */ gf_bs_read_int(bs, 16);\n\tprofile_tier_level(bs, 1, vps->max_sub_layers-1, &vps->ptl);\n\n\tvps_sub_layer_ordering_info_present_flag = gf_bs_read_int(bs, 1);\n\tfor (i=(vps_sub_layer_ordering_info_present_flag ? 0 : vps->max_sub_layers - 1); i < vps->max_sub_layers; i++) {\n\t\t/*vps_max_dec_pic_buffering_minus1[i] = */bs_get_ue(bs);\n\t\t/*vps_max_num_reorder_pics[i] = */bs_get_ue(bs);\n\t\t/*vps_max_latency_increase_plus1[i] = */bs_get_ue(bs);\n\t}\n\tvps->max_layer_id = gf_bs_read_int(bs, 6);\n\tif (vps->max_layer_id > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] VPS max layer ID %u but GPAC only supports %u\\n\", vps->max_layer_id,  MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->num_layer_sets = bs_get_ue(bs) + 1;\n\tif (vps->num_layer_sets > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of layer sets in VPS %d\\n\", vps->num_layer_sets));\n\t\treturn -1;\n\t}\n\tfor (i=1; i < vps->num_layer_sets; i++) {\n\t\tfor (j=0; j <= vps->max_layer_id; j++) {\n\t\t\tlayer_id_included_flag[ i ][ j ] = gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\tvps->num_layers_in_id_list[0] = 1;\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tu32 n, m;\n\t\tn = 0;\n\t\tfor (m = 0; m <= vps->max_layer_id; m++)\n\t\t\tif (layer_id_included_flag[i][m]) {\n\t\t\t\tvps->LayerSetLayerIdList[i][n++] = m;\n\t\t\t\tif (vps->LayerSetLayerIdListMax[i] < m)\n\t\t\t\t\tvps->LayerSetLayerIdListMax[i] = m;\n\t\t\t}\n\t\tvps->num_layers_in_id_list[i] = n;\n\t}\n\tif (/*vps_timing_info_present_flag*/gf_bs_read_int(bs, 1)) {\n\t\tu32 vps_num_hrd_parameters;\n\t\t/*u32 vps_num_units_in_tick = */gf_bs_read_int(bs, 32);\n\t\t/*u32 vps_time_scale = */gf_bs_read_int(bs, 32);\n\t\tif (/*vps_poc_proportional_to_timing_flag*/gf_bs_read_int(bs, 1)) {\n\t\t\t/*vps_num_ticks_poc_diff_one_minus1*/bs_get_ue(bs);\n\t\t}\n\t\tvps_num_hrd_parameters = bs_get_ue(bs);\n\t\tfor( i = 0; i < vps_num_hrd_parameters; i++ ) {\n\t\t\tBool cprms_present_flag = GF_TRUE;\n\t\t\t/*hrd_layer_set_idx[i] = */bs_get_ue(bs);\n\t\t\tif (i>0)\n\t\t\t\tcprms_present_flag = gf_bs_read_int(bs, 1) ;\n\t\t\thevc_parse_hrd_parameters(bs, cprms_present_flag, vps->max_sub_layers - 1);\n\t\t}\n\t}\n\tif (stop_at_vps_ext) {\n\t\treturn vps_id;\n\t}\n\n\tvps_extension_flag = gf_bs_read_int(bs, 1);\n\tif (vps_extension_flag ) {\n\t\tBool res;\n\t\tgf_bs_align(bs);\n\t\tres = hevc_parse_vps_extension(vps, bs);\n\t\tif (res!=GF_TRUE) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Failed to parse VPS extensions\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tif (/*vps_extension2_flag*/gf_bs_read_int(bs, 1)) {\n\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t/*vps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn vps_id;\n}\n\nGF_EXPORT\ns32 gf_media_hevc_read_vps_ex(char *data, u32 *size, HEVCState *hevc, Bool remove_extensions)\n{\n\tGF_BitStream *bs;\n\tchar *data_without_emulation_bytes = NULL;\n\tu32 data_without_emulation_bytes_size = 0;\n\ts32 vps_id = -1;\n\n\t/*still contains emulation bytes*/\n\tdata_without_emulation_bytes_size = avc_emulation_bytes_remove_count(data, (*size));\n\tif (!data_without_emulation_bytes_size) {\n\t\tbs = gf_bs_new(data, (*size), GF_BITSTREAM_READ);\n\t} else {\n\t\tdata_without_emulation_bytes = gf_malloc((*size) * sizeof(char));\n\t\tdata_without_emulation_bytes_size = avc_remove_emulation_bytes(data, data_without_emulation_bytes, (*size) );\n\t\tbs = gf_bs_new(data_without_emulation_bytes, data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\t}\n\tif (!bs) goto exit;\n\n\n\tif (! hevc_parse_nal_header(bs, NULL, NULL, NULL)) goto exit;\n\n\tvps_id = gf_media_hevc_read_vps_bs(bs, hevc, remove_extensions);\n\tif (vps_id<0) goto exit;\n\n\tif (remove_extensions) {\n\t\tchar *new_vps;\n\t\tu32 new_vps_size, emulation_bytes;\n\t\tu32 bit_pos = gf_bs_get_bit_offset(bs);\n\t\tGF_BitStream *w_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u8(w_bs, data[0]);\n\t\tgf_bs_write_u8(w_bs, data[1]);\n\t\tgf_bs_write_u8(w_bs, data[2]);\n\t\tgf_bs_write_u8(w_bs, data[3]);\n\t\tgf_bs_write_u16(w_bs, 0xFFFF);\n\t\tgf_bs_seek(bs, 6);\n\t\tbit_pos-=48;\n\t\twhile (bit_pos) {\n\t\t\tu32 v = gf_bs_read_int(bs, 1);\n\t\t\tgf_bs_write_int(w_bs, v, 1);\n\t\t\tbit_pos--;\n\t\t}\n\t\t/*vps extension flag*/\n\t\tgf_bs_write_int(w_bs, 0, 1);\n\t\tnew_vps=NULL;\n\t\tgf_bs_get_content(w_bs, &new_vps, &new_vps_size);\n\t\tgf_bs_del(w_bs);\n\t\t\n\t\temulation_bytes = avc_emulation_bytes_add_count(new_vps, new_vps_size);\n\t\tif (emulation_bytes+new_vps_size > *size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"Buffer too small to rewrite VPS - skipping rewrite\\n\"));\n\t\t} else {\n\t\t\t*size = avc_add_emulation_bytes(new_vps, data, new_vps_size);\n\t\t}\n\t}\n\nexit:\n\tif (bs) gf_bs_del(bs);\n\tif (data_without_emulation_bytes) gf_free(data_without_emulation_bytes);\n\treturn vps_id;\n}\n\nGF_EXPORT\ns32 gf_media_hevc_read_vps(char *data, u32 size, HEVCState *hevc)\n{\n\treturn gf_media_hevc_read_vps_ex(data, &size, hevc, GF_FALSE);\n}\n\nstatic void hevc_scaling_list_data(GF_BitStream *bs)\n{\n\tu32 i, sizeId, matrixId;\n\tfor (sizeId = 0; sizeId < 4; sizeId++) {\n\t\tfor (matrixId=0; matrixId<6; matrixId += (sizeId == 3) ? 3:1 ) {\n\t\t\tu32 scaling_list_pred_mode_flag_sizeId_matrixId = gf_bs_read_int(bs, 1);\n\t\t\tif( ! scaling_list_pred_mode_flag_sizeId_matrixId ) {\n\t\t\t\t/*scaling_list_pred_matrix_id_delta[ sizeId ][ matrixId ] =*/ bs_get_ue(bs);\n\t\t\t} else {\n\t\t\t\t//u32 nextCoef = 8;\n\t\t\t\tu32 coefNum = MIN(64, (1 << (4+(sizeId << 1))));\n\t\t\t\tif ( sizeId > 1 ) {\n\t\t\t\t\t/*scaling_list_dc_coef_minus8[ sizeId \u2212 2 ][ matrixId ] = */bs_get_se(bs);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i<coefNum; i++) {\n\t\t\t\t\t/*scaling_list_delta_coef = */bs_get_se(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic const struct {\n\tu32 w, h;\n} hevc_sar[17] =\n{\n\t{ 0,   0 }, { 1,   1 }, { 12, 11 }, { 10, 11 },\n\t{ 16, 11 }, { 40, 33 }, { 24, 11 }, { 20, 11 },\n\t{ 32, 11 }, { 80, 33 }, { 18, 11 }, { 15, 11 },\n\t{ 64, 33 }, { 160,99 }, { 4,3}, { 3,2}, { 2,1}\n};\n\nstatic s32 gf_media_hevc_read_sps_bs(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id = -1;\n\tu8 max_sub_layers_minus1, flag;\n\tBool scaling_list_enable_flag;\n\tu32 i, nb_CTUs, depth;\n\tu32 log2_diff_max_min_luma_coding_block_size;\n\tu32 log2_min_transform_block_size, log2_min_luma_coding_block_size;\n\tBool sps_sub_layer_ordering_info_present_flag;\n\tHEVC_SPS *sps;\n\tHEVC_VPS *vps;\n\tHEVC_ProfileTierLevel ptl;\n\tu32 sps_ext_or_max_sub_layers_minus1;\n\tBool multiLayerExtSpsFlag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int(bs, 4);\n\tif (vps_id>=16) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;\n\tif (layer_id == 0)\n\t\tmax_sub_layers_minus1 = gf_bs_read_int(bs, 3);\n\telse\n\t\tsps_ext_or_max_sub_layers_minus1 = gf_bs_read_int(bs, 3);\n\tmultiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);\n\tif (!multiLayerExtSpsFlag) {\t\t\n\t\t/*temporal_id_nesting_flag = */gf_bs_read_int(bs, 1);\n\t\tprofile_tier_level(bs, 1, max_sub_layers_minus1, &ptl);\n\t}\n\n\tsps_id = bs_get_ue(bs);\n\tif ((sps_id<0) ||(sps_id>=16)) {\n\t\treturn -1;\n\t}\n\n\tsps = &hevc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->ptl = ptl;\n\tvps = &hevc->vps[vps_id];\n\n\t//sps_rep_format_idx = 0;\n\tif (multiLayerExtSpsFlag) {\n\t\tu8 update_rep_format_flag = gf_bs_read_int(bs, 1);\n\t\tif (update_rep_format_flag) {\n\t\t\tsps->rep_format_idx = gf_bs_read_int(bs, 8);\n\t\t} else {\n\t\t\tsps->rep_format_idx = vps->rep_format_idx[layer_id];\n\t\t}\n\t\tsps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;\n\t\tsps->height = vps->rep_formats[sps->rep_format_idx].pic_height_luma_samples;\n\t\tsps->chroma_format_idc = vps->rep_formats[sps->rep_format_idx].chroma_format_idc;\n\t\tsps->bit_depth_luma = vps->rep_formats[sps->rep_format_idx].bit_depth_luma;\n\t\tsps->bit_depth_chroma = vps->rep_formats[sps->rep_format_idx].bit_depth_chroma;\n\t\tsps->separate_colour_plane_flag = vps->rep_formats[sps->rep_format_idx].separate_colour_plane_flag;\n\n\t\t//TODO this is crude ...\n\t\tsps->ptl = vps->ext_ptl[0];\n\t} else {\n\t\tsps->chroma_format_idc = bs_get_ue(bs);\n\t\tif (sps->chroma_format_idc==3)\n\t\t\tsps->separate_colour_plane_flag = gf_bs_read_int(bs, 1);\n\t\tsps->width = bs_get_ue(bs);\n\t\tsps->height = bs_get_ue(bs);\n\t\tif (/*conformance_window_flag*/gf_bs_read_int(bs, 1)) {\n\t\t\tu32 SubWidthC, SubHeightC;\n\n\t\t\tif (sps->chroma_format_idc==1) {\n\t\t\t\tSubWidthC = SubHeightC = 2;\n\t\t\t}\n\t\t\telse if (sps->chroma_format_idc==2) {\n\t\t\t\tSubWidthC = 2;\n\t\t\t\tSubHeightC = 1;\n\t\t\t} else {\n\t\t\t\tSubWidthC = SubHeightC = 1;\n\t\t\t}\n\n\t\t\tsps->cw_left = bs_get_ue(bs);\n\t\t\tsps->cw_right = bs_get_ue(bs);\n\t\t\tsps->cw_top = bs_get_ue(bs);\n\t\t\tsps->cw_bottom = bs_get_ue(bs);\n\n\t\t\tsps->width -= SubWidthC * (sps->cw_left + sps->cw_right);\n\t\t\tsps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);\n\t\t}\n\t\tsps->bit_depth_luma = 8 + bs_get_ue(bs);\n\t\tsps->bit_depth_chroma = 8 + bs_get_ue(bs);\n\t}\n\n\tsps->log2_max_pic_order_cnt_lsb = 4 + bs_get_ue(bs);\n\n\tif (!multiLayerExtSpsFlag) {\n\t\tsps_sub_layer_ordering_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tfor(i=sps_sub_layer_ordering_info_present_flag ? 0 : max_sub_layers_minus1; i<=max_sub_layers_minus1; i++) {\n\t\t\t/*max_dec_pic_buffering = */ bs_get_ue(bs);\n\t\t\t/*num_reorder_pics = */ bs_get_ue(bs);\n\t\t\t/*max_latency_increase = */ bs_get_ue(bs);\n\t\t}\n\t}\n\n\tlog2_min_luma_coding_block_size = 3 + bs_get_ue(bs);\n\tlog2_diff_max_min_luma_coding_block_size = bs_get_ue(bs);\n\tsps->max_CU_width = ( 1<<(log2_min_luma_coding_block_size + log2_diff_max_min_luma_coding_block_size) );\n\tsps->max_CU_height = ( 1<<(log2_min_luma_coding_block_size + log2_diff_max_min_luma_coding_block_size) );\n\n\tlog2_min_transform_block_size = 2 + bs_get_ue(bs);\n\t/*log2_max_transform_block_size = log2_min_transform_block_size  + */bs_get_ue(bs);\n\n\tdepth = 0;\n\t/*u32 max_transform_hierarchy_depth_inter = */bs_get_ue(bs);\n\t/*u32 max_transform_hierarchy_depth_intra = */bs_get_ue(bs);\n\twhile( (u32) ( sps->max_CU_width >> log2_diff_max_min_luma_coding_block_size ) > (u32) ( 1 << ( log2_min_transform_block_size + depth )  ) )\n\t{\n\t\tdepth++;\n\t}\n\tsps->max_CU_depth = log2_diff_max_min_luma_coding_block_size + depth;\n\n\tnb_CTUs = ((sps->width + sps->max_CU_width -1) / sps->max_CU_width) * ((sps->height + sps->max_CU_height-1) / sps->max_CU_height);\n\tsps->bitsSliceSegmentAddress = 0;\n\twhile (nb_CTUs > (u32) (1 << sps->bitsSliceSegmentAddress)) {\n\t\tsps->bitsSliceSegmentAddress++;\n\t}\n\n\tscaling_list_enable_flag = gf_bs_read_int(bs, 1);\n\tif (scaling_list_enable_flag) {\n\t\tBool sps_infer_scaling_list_flag = 0;\n\t\t/*u8 sps_scaling_list_ref_layer_id = 0;*/\n\t\tif (multiLayerExtSpsFlag) {\n\t\t\tsps_infer_scaling_list_flag = gf_bs_read_int(bs, 1);\n\t\t}\n\n\t\tif (sps_infer_scaling_list_flag) {\n\t\t\t/*sps_scaling_list_ref_layer_id = */gf_bs_read_int(bs, 6);\n\t\t} else {\n\t\t\tif (/*sps_scaling_list_data_present_flag=*/gf_bs_read_int(bs, 1) ) {\n\t\t\t\thevc_scaling_list_data(bs);\n\t\t\t}\n\t\t}\n\t}\n\t/*asymmetric_motion_partitions_enabled_flag= */ gf_bs_read_int(bs, 1);\n\tsps->sample_adaptive_offset_enabled_flag = gf_bs_read_int(bs, 1);\n\tif (/*pcm_enabled_flag= */ gf_bs_read_int(bs, 1) ) {\n\t\t/*pcm_sample_bit_depth_luma_minus1=*/gf_bs_read_int(bs, 4);\n\t\t/*pcm_sample_bit_depth_chroma_minus1=*/gf_bs_read_int(bs, 4);\n\t\t/*log2_min_pcm_luma_coding_block_size_minus3= */ bs_get_ue(bs);\n\t\t/*log2_diff_max_min_pcm_luma_coding_block_size = */ bs_get_ue(bs);\n\t\t/*pcm_loop_filter_disable_flag=*/gf_bs_read_int(bs, 1);\n\t}\n\tsps->num_short_term_ref_pic_sets = bs_get_ue(bs);\n\tif (sps->num_short_term_ref_pic_sets>64) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid number of short term reference picture sets %d\\n\", sps->num_short_term_ref_pic_sets));\n\t\treturn -1;\n\t}\n\t\n\tfor (i=0; i<sps->num_short_term_ref_pic_sets; i++) {\n\t\tBool ret = parse_short_term_ref_pic_set(bs, sps, i);\n\t\t/*cannot parse short_term_ref_pic_set, skip VUI parsing*/\n\t\tif (!ret) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Invalid short_term_ref_pic_set\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tsps->long_term_ref_pics_present_flag = gf_bs_read_int(bs, 1);\n\tif (sps->long_term_ref_pics_present_flag) {\n\t\tsps->num_long_term_ref_pic_sps = bs_get_ue(bs);\n\t\tfor (i=0; i<sps->num_long_term_ref_pic_sps; i++) {\n\t\t\t/*lt_ref_pic_poc_lsb_sps=*/gf_bs_read_int(bs, sps->log2_max_pic_order_cnt_lsb);\n\t\t\t/*used_by_curr_pic_lt_sps_flag*/gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\tsps->temporal_mvp_enable_flag = gf_bs_read_int(bs, 1);\n\t/*strong_intra_smoothing_enable_flag*/gf_bs_read_int(bs, 1);\n\n\tif (vui_flag_pos)\n\t\t*vui_flag_pos = (u32) gf_bs_get_bit_offset(bs);\n\n\tif (/*vui_parameters_present_flag*/gf_bs_read_int(bs, 1)) {\n\n\t\tsps->aspect_ratio_info_present_flag = gf_bs_read_int(bs, 1);\n\t\tif (sps->aspect_ratio_info_present_flag) {\n\t\t\tsps->sar_idc = gf_bs_read_int(bs, 8);\n\t\t\tif (sps->sar_idc == 255) {\n\t\t\t\tsps->sar_width = gf_bs_read_int(bs, 16);\n\t\t\t\tsps->sar_height = gf_bs_read_int(bs, 16);\n\t\t\t} else if (sps->sar_idc<17) {\n\t\t\t\tsps->sar_width = hevc_sar[sps->sar_idc].w;\n\t\t\t\tsps->sar_height = hevc_sar[sps->sar_idc].h;\n\t\t\t}\n\t\t}\n\n\t\tif (/*overscan_info_present = */ gf_bs_read_int(bs, 1))\n\t\t\t/*overscan_appropriate = */ gf_bs_read_int(bs, 1);\n\n\t\t/*video_signal_type_present_flag = */flag = gf_bs_read_int(bs, 1);\n\t\tif (flag) {\n\t\t\t/*video_format = */gf_bs_read_int(bs, 3);\n\t\t\t/*video_full_range_flag = */gf_bs_read_int(bs, 1);\n\t\t\tif (/*colour_description_present_flag = */gf_bs_read_int(bs, 1)) {\n\t\t\t\t/*colour_primaries = */ gf_bs_read_int(bs, 8);\n\t\t\t\t/* transfer_characteristic = */ gf_bs_read_int(bs, 8);\n\t\t\t\t/* matrix_coeffs = */ gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\n\t\tif (/*chroma_loc_info_present_flag = */ gf_bs_read_int(bs, 1)) {\n\t\t\t/*chroma_sample_loc_type_top_field = */ bs_get_ue(bs);\n\t\t\t/*chroma_sample_loc_type_bottom_field = */bs_get_ue(bs);\n\t\t}\n\n\t\t/*neutra_chroma_indication_flag = */gf_bs_read_int(bs, 1);\n\t\t/*field_seq_flag = */gf_bs_read_int(bs, 1);\n\t\t/*frame_field_info_present_flag = */gf_bs_read_int(bs, 1);\n\n\t\tif (/*default_display_window_flag=*/gf_bs_read_int(bs, 1)) {\n\t\t\t/*left_offset = */bs_get_ue(bs);\n\t\t\t/*right_offset = */bs_get_ue(bs);\n\t\t\t/*top_offset = */bs_get_ue(bs);\n\t\t\t/*bottom_offset = */bs_get_ue(bs);\n\t\t}\n\n\t\tsps->has_timing_info = gf_bs_read_int(bs, 1);\n\t\tif (sps->has_timing_info ) {\n\t\t\tsps->num_units_in_tick = gf_bs_read_int(bs, 32);\n\t\t\tsps->time_scale = gf_bs_read_int(bs, 32);\n\t\t\tsps->poc_proportional_to_timing_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (sps->poc_proportional_to_timing_flag)\n\t\t\t\tsps->num_ticks_poc_diff_one_minus1 = bs_get_ue(bs);\n\t\t\tif (/*hrd_parameters_present_flag=*/gf_bs_read_int(bs, 1) ) {\n//\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[HEVC] HRD param parsing not implemented\\n\"));\n\t\t\t\treturn sps_id;\n\t\t\t}\n\t\t}\n\n\t\tif (/*bitstream_restriction_flag=*/gf_bs_read_int(bs, 1)) {\n\t\t\t/*tiles_fixed_structure_flag = */gf_bs_read_int(bs, 1);\n\t\t\t/*motion_vectors_over_pic_boundaries_flag = */gf_bs_read_int(bs, 1);\n\t\t\t/*restricted_ref_pic_lists_flag = */gf_bs_read_int(bs, 1);\n\t\t\t/*min_spatial_segmentation_idc = */bs_get_ue(bs);\n\t\t\t/*max_bytes_per_pic_denom = */bs_get_ue(bs);\n\t\t\t/*max_bits_per_min_cu_denom = */bs_get_ue(bs);\n\t\t\t/*log2_max_mv_length_horizontal = */bs_get_ue(bs);\n\t\t\t/*log2_max_mv_length_vertical = */bs_get_ue(bs);\n\t\t}\n\t}\n\n\tif (/*sps_extension_flag*/gf_bs_read_int(bs, 1)) {\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*sps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\n\treturn sps_id;\n}\n\nGF_EXPORT\ns32 gf_media_hevc_read_sps_ex(char *data, u32 size, HEVCState *hevc, u32 *vui_flag_pos)\n{\n\tGF_BitStream *bs;\n\tchar *data_without_emulation_bytes = NULL;\n\tu32 data_without_emulation_bytes_size = 0;\n\ts32 sps_id= -1;\n\tu8 layer_id;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tdata_without_emulation_bytes_size = avc_emulation_bytes_remove_count(data, size);\n\tif (!data_without_emulation_bytes_size) {\n\t\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t} else {\n\t\t/*still contains emulation bytes*/\n\t\tdata_without_emulation_bytes = gf_malloc(size*sizeof(char));\n\t\tdata_without_emulation_bytes_size = avc_remove_emulation_bytes(data, data_without_emulation_bytes, size);\n\t\tbs = gf_bs_new(data_without_emulation_bytes, data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\t}\n\tif (!bs) goto exit;\n\tif (! hevc_parse_nal_header(bs, NULL, NULL, &layer_id)) goto exit;\n\tsps_id = gf_media_hevc_read_sps_bs(bs, hevc, layer_id, vui_flag_pos);\n\nexit:\n\tif (bs) gf_bs_del(bs);\n\tif (data_without_emulation_bytes) gf_free(data_without_emulation_bytes);\n\treturn sps_id;\n}\n\nGF_EXPORT\ns32 gf_media_hevc_read_sps(char *data, u32 size, HEVCState *hevc)\n{\n\treturn gf_media_hevc_read_sps_ex(data, size, hevc, NULL);\n}\n\n\nstatic s32 gf_media_hevc_read_pps_bs(GF_BitStream *bs, HEVCState *hevc)\n{\n\tu32 i;\n\ts32 pps_id = -1;\n\tHEVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = bs_get_ue(bs);\n\n\tif ((pps_id<0) || (pps_id>=64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &hevc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = bs_get_ue(bs);\n\tif (pps->sps_id>16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\treturn -1;\n\t}\n\thevc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->dependent_slice_segments_enabled_flag = gf_bs_read_int(bs, 1);\n\n\tpps->output_flag_present_flag = gf_bs_read_int(bs, 1);\n\tpps->num_extra_slice_header_bits = gf_bs_read_int(bs, 3);\n\t/*sign_data_hiding_flag = */gf_bs_read_int(bs, 1);\n\tpps->cabac_init_present_flag = gf_bs_read_int(bs, 1);\n\tpps->num_ref_idx_l0_default_active = 1 + bs_get_ue(bs);\n\tpps->num_ref_idx_l1_default_active = 1 + bs_get_ue(bs);\n\t/*pic_init_qp_minus26 = */bs_get_se(bs);\n\t/*constrained_intra_pred_flag = */gf_bs_read_int(bs, 1);\n\t/*transform_skip_enabled_flag = */gf_bs_read_int(bs, 1);\n\tif (/*cu_qp_delta_enabled_flag = */gf_bs_read_int(bs, 1) )\n\t\t/*diff_cu_qp_delta_depth = */bs_get_ue(bs);\n\n\t/*pic_cb_qp_offset = */bs_get_se(bs);\n\t/*pic_cr_qp_offset = */bs_get_se(bs);\n\tpps->slice_chroma_qp_offsets_present_flag = gf_bs_read_int(bs, 1);\n\tpps->weighted_pred_flag = gf_bs_read_int(bs, 1);\n\tpps->weighted_bipred_flag = gf_bs_read_int(bs, 1);\n\t/*transquant_bypass_enable_flag = */gf_bs_read_int(bs, 1);\n\tpps->tiles_enabled_flag = gf_bs_read_int(bs, 1);\n\tpps->entropy_coding_sync_enabled_flag = gf_bs_read_int(bs, 1);\n\tif (pps->tiles_enabled_flag) {\n\t\tpps->num_tile_columns = 1 + bs_get_ue(bs);\n\t\tpps->num_tile_rows = 1 + bs_get_ue(bs);\n\t\tpps->uniform_spacing_flag = gf_bs_read_int(bs, 1);\n\t\tif (!pps->uniform_spacing_flag ) {\n\t\t\tfor (i=0; i<pps->num_tile_columns-1; i++) {\n\t\t\t\tpps->column_width[i] = 1 + bs_get_ue(bs);\n\t\t\t}\n\t\t\tfor (i=0; i<pps->num_tile_rows-1; i++) {\n\t\t\t\tpps->row_height[i] = 1+bs_get_ue(bs);\n\t\t\t}\n\t\t}\n\t\tpps->loop_filter_across_tiles_enabled_flag = gf_bs_read_int(bs, 1);\n\t}\n\tpps->loop_filter_across_slices_enabled_flag = gf_bs_read_int(bs, 1);\n\tif( /*deblocking_filter_control_present_flag = */gf_bs_read_int(bs, 1)  ) {\n\t\tpps->deblocking_filter_override_enabled_flag = gf_bs_read_int(bs, 1);\n\t\tif (! /*pic_disable_deblocking_filter_flag= */gf_bs_read_int(bs, 1) ) {\n\t\t\t/*beta_offset_div2 = */bs_get_se(bs);\n\t\t\t/*tc_offset_div2 = */bs_get_se(bs);\n\t\t}\n\t}\n\tif (/*pic_scaling_list_data_present_flag\t= */gf_bs_read_int(bs, 1) ) {\n\t\thevc_scaling_list_data(bs);\n\t}\n\tpps->lists_modification_present_flag = gf_bs_read_int(bs, 1);\n\t/*log2_parallel_merge_level_minus2 = */bs_get_ue(bs);\n\tpps->slice_segment_header_extension_present_flag = gf_bs_read_int(bs, 1);\n\tif ( /*pps_extension_flag= */gf_bs_read_int(bs, 1) ) {\n\t\twhile (gf_bs_available(bs) ) {\n\t\t\t/*pps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\treturn pps_id;\n}\n\n\nGF_EXPORT\ns32 gf_media_hevc_read_pps(char *data, u32 size, HEVCState *hevc)\n{\n\tGF_BitStream *bs;\n\tchar *data_without_emulation_bytes = NULL;\n\tu32 data_without_emulation_bytes_size = 0;\n\ts32 pps_id = -1;\n\n\t/*still contains emulation bytes*/\n\tdata_without_emulation_bytes_size = avc_emulation_bytes_remove_count(data, size);\n\tif (!data_without_emulation_bytes_size) {\n\t\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t} else {\n\t\tdata_without_emulation_bytes = gf_malloc(size*sizeof(char));\n\t\tdata_without_emulation_bytes_size = avc_remove_emulation_bytes(data, data_without_emulation_bytes, size);\n\t\tbs = gf_bs_new(data_without_emulation_bytes, data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\t}\n\tif (!bs) goto exit;\n\n\tif (! hevc_parse_nal_header(bs, NULL, NULL, NULL)) goto exit;\n\n\tpps_id = gf_media_hevc_read_pps_bs(bs, hevc);\n\nexit:\n\tif (bs) gf_bs_del(bs);\n\tif (data_without_emulation_bytes) gf_free(data_without_emulation_bytes);\n\treturn pps_id;\n}\n\nGF_EXPORT\ns32 gf_media_hevc_parse_nalu(char *data, u32 size, HEVCState *hevc, u8 *nal_unit_type, u8 *temporal_id, u8 *layer_id)\n{\n\tGF_BitStream *bs=NULL;\n\tchar *data_without_emulation_bytes = NULL;\n\tu32 data_without_emulation_bytes_size = 0;\n\tBool is_slice = GF_FALSE;\n\ts32 ret = -1;\n\tHEVCSliceInfo n_state;\n\n\tmemcpy(&n_state, &hevc->s_info, sizeof(HEVCSliceInfo));\n\n\thevc->last_parsed_vps_id = hevc->last_parsed_sps_id = hevc->last_parsed_pps_id = -1;\n\thevc->s_info.entry_point_start_bits = -1;\n\thevc->s_info.payload_start_offset = -1;\n\n\tdata_without_emulation_bytes_size = avc_emulation_bytes_remove_count(data, size);\n\tif (!data_without_emulation_bytes_size) {\n\t\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t} else {\n\t\t/*still contains emulation bytes*/\n\t\tdata_without_emulation_bytes = gf_malloc(size*sizeof(char));\n\t\tdata_without_emulation_bytes_size = avc_remove_emulation_bytes(data, data_without_emulation_bytes, size);\n\t\tbs = gf_bs_new(data_without_emulation_bytes, data_without_emulation_bytes_size, GF_BITSTREAM_READ);\n\t}\n\tif (!bs) goto exit;\n\n\tif (! hevc_parse_nal_header(bs, nal_unit_type, temporal_id, layer_id)) goto exit;\n\tn_state.nal_unit_type = *nal_unit_type;\n\n\tswitch (n_state.nal_unit_type) {\n\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\tcase GF_HEVC_NALU_END_OF_SEQ:\n\tcase GF_HEVC_NALU_END_OF_STREAM:\n\t\tret = 1;\n\t\tbreak;\n\n\t/*slice_segment_layer_rbsp*/\n\tcase GF_HEVC_NALU_SLICE_TRAIL_N:\n\tcase GF_HEVC_NALU_SLICE_TRAIL_R:\n\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\tcase GF_HEVC_NALU_SLICE_RADL_N:\n\tcase GF_HEVC_NALU_SLICE_RADL_R:\n\tcase GF_HEVC_NALU_SLICE_RASL_N:\n\tcase GF_HEVC_NALU_SLICE_RASL_R:\n\t\tis_slice = GF_TRUE;\n\t\t/* slice - read the info and compare.*/\n\t\tret = hevc_parse_slice_segment(bs, hevc, &n_state);\n\t\tif (ret<0) goto exit;\n\n\t\thevc_compute_poc(&n_state);\n\n\t\tret = 0;\n\n\t\tif (hevc->s_info.poc != n_state.poc) {\n\t\t\tret=1;\n\t\t\tbreak;\n\t\t}\n\t\tif (n_state.first_slice_segment_in_pic_flag) {\n\t\t\tif (!(*layer_id) || (n_state.prev_layer_id_plus1 && ((*layer_id) <= n_state.prev_layer_id_plus1 - 1)) ) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\thevc->last_parsed_sps_id = gf_media_hevc_read_sps_bs(bs, hevc, *layer_id, NULL);\n\t\tret = 0;\n\t\tbreak;\n\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\thevc->last_parsed_pps_id = gf_media_hevc_read_pps_bs(bs, hevc);\n\t\tret = 0;\n\t\tbreak;\n\tcase GF_HEVC_NALU_VID_PARAM:\n\t\thevc->last_parsed_vps_id = gf_media_hevc_read_vps_bs(bs, hevc, GF_FALSE);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t/* save _prev values */\n\tif (ret && hevc->s_info.sps) {\n\t\tn_state.frame_num_offset_prev = hevc->s_info.frame_num_offset;\n\t\tn_state.frame_num_prev = hevc->s_info.frame_num;\n\n\t\tn_state.poc_lsb_prev = hevc->s_info.poc_lsb;\n\t\tn_state.poc_msb_prev = hevc->s_info.poc_msb;\n\t\tn_state.prev_layer_id_plus1 = *layer_id + 1;\n\t}\n\tif (is_slice) hevc_compute_poc(&n_state);\n\tmemcpy(&hevc->s_info, &n_state, sizeof(HEVCSliceInfo));\n\nexit:\n\tif (bs) gf_bs_del(bs);\n\tif (data_without_emulation_bytes) gf_free(data_without_emulation_bytes);\n\treturn ret;\n}\n\nstatic u8 hevc_get_sar_idx(u32 w, u32 h)\n{\n\tu32 i;\n\tfor (i=0; i<14; i++) {\n\t\tif ((avc_sar[i].w==w) && (avc_sar[i].h==h)) return i;\n\t}\n\treturn 0xFF;\n}\n\nGF_Err gf_media_hevc_change_par(GF_HEVCConfig *hvcc, s32 ar_n, s32 ar_d)\n{\n\tGF_BitStream *orig, *mod;\n\tHEVCState hevc;\n\tu32 i, bit_offset, flag;\n\ts32 idx;\n\tGF_HEVCParamArray *spss;\n\tGF_AVCConfigSlot *slc;\n\torig = NULL;\n\n\tmemset(&hevc, 0, sizeof(HEVCState));\n\thevc.sps_active_idx = -1;\n\n\ti=0;\n\tspss = NULL;\n\twhile ((spss = (GF_HEVCParamArray *)gf_list_enum(hvcc->param_array, &i))) {\n\t\tif (spss->type==GF_HEVC_NALU_SEQ_PARAM)\n\t\t\tbreak;\n\t\tspss = NULL;\n\t}\n\tif (!spss) return GF_NON_COMPLIANT_BITSTREAM;\n\n\ti=0;\n\twhile ((slc = (GF_AVCConfigSlot *)gf_list_enum(spss->nalus, &i))) {\n\t\tchar *no_emulation_buf = NULL;\n\t\tu32 no_emulation_buf_size = 0, emulation_bytes = 0;\n\n\t\t/*SPS may still contains emulation bytes*/\n\t\tno_emulation_buf = gf_malloc((slc->size)*sizeof(char));\n\t\tno_emulation_buf_size = avc_remove_emulation_bytes(slc->data, no_emulation_buf, slc->size);\n\n\t\tidx = gf_media_hevc_read_sps_ex(no_emulation_buf, no_emulation_buf_size, &hevc, &bit_offset);\n\t\tif (idx<0) {\n\t\t\tif ( orig )\n\t\t\t\tgf_bs_del(orig);\n\t\t\tgf_free(no_emulation_buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\torig = gf_bs_new(no_emulation_buf, no_emulation_buf_size, GF_BITSTREAM_READ);\n\t\tmod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t/*copy over till vui flag*/\n\t\tassert(bit_offset >= 0);\n\t\twhile (bit_offset) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t\tbit_offset--;\n\t\t}\n\n\t\t/*check VUI*/\n\t\tflag = gf_bs_read_int(orig, 1);\n\t\tgf_bs_write_int(mod, 1, 1); /*vui_parameters_present_flag*/\n\t\tif (flag) {\n\t\t\t/*aspect_ratio_info_present_flag*/\n\t\t\tif (gf_bs_read_int(orig, 1)) {\n\t\t\t\ts32 aspect_ratio_idc = gf_bs_read_int(orig, 8);\n\t\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\t\tgf_bs_read_int(orig, 16); /*AR num*/\n\t\t\t\t\tgf_bs_read_int(orig, 16); /*AR den*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((ar_d<0) || (ar_n<0)) {\n\t\t\t/*no AR signaled*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\n\t\t} else {\n\t\t\tu32 sarx;\n\t\t\tgf_bs_write_int(mod, 1, 1);\n\t\t\tsarx = hevc_get_sar_idx((u32) ar_n, (u32) ar_d);\n\t\t\tgf_bs_write_int(mod, sarx, 8);\n\t\t\tif (sarx==0xFF) {\n\t\t\t\tgf_bs_write_int(mod, ar_n, 16);\n\t\t\t\tgf_bs_write_int(mod, ar_d, 16);\n\t\t\t}\n\t\t}\n\t\t/*no VUI in input bitstream, set all vui flags to 0*/\n\t\tif (!flag) {\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*overscan_info_present_flag */\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*video_signal_type_present_flag */\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*chroma_location_info_present_flag */\n\n\t\t\tgf_bs_write_int(mod, 0, 1); /*neutra_chroma_indication_flag */;\n\t\t\tgf_bs_write_int(mod, 0, 1); /*field_seq_flag */;\n\t\t\tgf_bs_write_int(mod, 0, 1); /*frame_field_info_present_flag*/;\n\t\t\tgf_bs_write_int(mod, 0, 1); /*default_display_window_flag*/;\n\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*timing_info_present_flag*/\n\t\t\tgf_bs_write_int(mod, 0, 1);\t\t/*bitstream_restriction*/\n\t\t}\n\n\t\t/*finally copy over remaining*/\n\t\twhile (gf_bs_bits_available(orig)) {\n\t\t\tflag = gf_bs_read_int(orig, 1);\n\t\t\tgf_bs_write_int(mod, flag, 1);\n\t\t}\n\t\tgf_bs_del(orig);\n\t\torig = NULL;\n\t\tgf_free(no_emulation_buf);\n\n\t\t/*set anti-emulation*/\n\t\tgf_bs_get_content(mod, (char **) &no_emulation_buf, &no_emulation_buf_size);\n\t\temulation_bytes = avc_emulation_bytes_add_count(no_emulation_buf, no_emulation_buf_size);\n\t\tif (no_emulation_buf_size + emulation_bytes > slc->size)\n\t\t\tslc->data = (char*)gf_realloc(slc->data, no_emulation_buf_size + emulation_bytes);\n\n\t\tslc->size = avc_add_emulation_bytes(no_emulation_buf, slc->data, no_emulation_buf_size);\n\n\t\tgf_bs_del(mod);\n\t\tgf_free(no_emulation_buf);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_hevc_get_sps_info_with_state(HEVCState *hevc, char *sps_data, u32 sps_size, u32 *sps_id, u32 *width, u32 *height, s32 *par_n, s32 *par_d)\n{\n\ts32 idx;\n\tidx = gf_media_hevc_read_sps(sps_data, sps_size, hevc);\n\tif (idx<0) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tif (sps_id) *sps_id = idx;\n\n\tif (width) *width = hevc->sps[idx].width;\n\tif (height) *height = hevc->sps[idx].height;\n\tif (par_n) *par_n = hevc->sps[idx].aspect_ratio_info_present_flag ? hevc->sps[idx].sar_width : (u32) -1;\n\tif (par_d) *par_d = hevc->sps[idx].aspect_ratio_info_present_flag ? hevc->sps[idx].sar_height : (u32) -1;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_hevc_get_sps_info(char *sps_data, u32 sps_size, u32 *sps_id, u32 *width, u32 *height, s32 *par_n, s32 *par_d)\n{\n\tHEVCState hevc;\n\tmemset(&hevc, 0, sizeof(HEVCState));\n\thevc.sps_active_idx = -1;\n\treturn gf_hevc_get_sps_info_with_state(&hevc, sps_data, sps_size, sps_id, width, height, par_n, par_d);\n}\n\n#endif //GPAC_DISABLE_HEVC\n\nstatic u32 AC3_FindSyncCode(u8 *buf, u32 buflen)\n{\n\tu32 end = buflen - 6;\n\tu32 offset = 0;\n\twhile (offset <= end) {\n\t\tif (buf[offset] == 0x0b && buf[offset + 1] == 0x77) {\n\t\t\treturn offset;\n\t\t}\n\t\toffset++;\n\t}\n\treturn buflen;\n}\n\n\nstatic Bool AC3_FindSyncCodeBS(GF_BitStream *bs)\n{\n\tu8 b1;\n\tu64 pos = gf_bs_get_position(bs);\n\tu64 end = gf_bs_get_size(bs) - 6;\n\n\tpos += 1;\n\tb1 = gf_bs_read_u8(bs);\n\twhile (pos <= end) {\n\t\tu8 b2 = gf_bs_read_u8(bs);\n\t\tif ((b1 == 0x0b) && (b2==0x77)) {\n\t\t\tgf_bs_seek(bs, pos-1);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tpos++;\n\t\tb1 = b2;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic const u32 ac3_sizecod_to_bitrate[] = {\n\t32000, 40000, 48000, 56000, 64000, 80000, 96000,\n\t112000, 128000, 160000, 192000, 224000, 256000,\n\t320000, 384000, 448000, 512000, 576000, 640000\n};\n\nstatic const u32 ac3_sizecod2_to_framesize[] = {\n\t96, 120, 144, 168, 192, 240, 288, 336, 384, 480, 576, 672,\n\t768, 960, 1152, 1344, 1536, 1728, 1920\n};\n\nstatic const u32 ac3_sizecod1_to_framesize[] = {\n\t69, 87, 104, 121, 139, 174, 208, 243, 278, 348, 417, 487,\n\t557, 696, 835, 975, 1114, 1253, 1393\n};\nstatic const u32 ac3_sizecod0_to_framesize[] = {\n\t64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 448,\n\t512, 640, 768, 896, 1024, 1152, 1280\n};\n\nstatic const u32 ac3_mod_to_chans[] = {\n\t2, 1, 2, 3, 3, 4, 4, 5\n};\n\nGF_EXPORT\nu32 gf_ac3_get_channels(u32 acmod)\n{\n\tu32 nb_ch;\n\tnb_ch = ac3_mod_to_chans[acmod];\n\treturn nb_ch;\n}\n\nGF_EXPORT\nu32 gf_ac3_get_bitrate(u32 brcode)\n{\n\treturn ac3_sizecod_to_bitrate[brcode];\n}\n\nBool gf_ac3_parser(u8 *buf, u32 buflen, u32 *pos, GF_AC3Header *hdr, Bool full_parse)\n{\n\tGF_BitStream *bs;\n\tBool ret;\n\n\tif (buflen < 6) return GF_FALSE;\n\t(*pos) = AC3_FindSyncCode(buf, buflen);\n\tif (*pos >= buflen) return GF_FALSE;\n\n\tbs = gf_bs_new((const char*)(buf+*pos), buflen, GF_BITSTREAM_READ);\n\tret = gf_ac3_parser_bs(bs, hdr, full_parse);\n\tgf_bs_del(bs);\n\n\treturn ret;\n}\n\nGF_EXPORT\nBool gf_ac3_parser_bs(GF_BitStream *bs, GF_AC3Header *hdr, Bool full_parse)\n{\n\tu32 fscod, frmsizecod, bsid, ac3_mod, freq, framesize, bsmod, syncword;\n\tu64 pos;\n\tif (!hdr || (gf_bs_available(bs) < 6)) return GF_FALSE;\n\tif (!AC3_FindSyncCodeBS(bs)) return GF_FALSE;\n\n\tpos = gf_bs_get_position(bs);\n\n\tsyncword = gf_bs_read_u16(bs);\n\tif (syncword != 0x0B77) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AC3] Wrong sync word detected (0x%X - expecting 0x0B77).\\n\", syncword));\n\t\treturn GF_FALSE;\n\t}\n\tgf_bs_read_u16(bs); //crc1\n\tfscod = gf_bs_read_int(bs, 2);\n\tfrmsizecod = gf_bs_read_int(bs, 6);\n\tbsid = gf_bs_read_int(bs, 5);\n\tbsmod = gf_bs_read_int(bs, 3);\n\tac3_mod = gf_bs_read_int(bs, 3);\n\n\thdr->bitrate = ac3_sizecod_to_bitrate[frmsizecod / 2];\n\tif (bsid > 8) hdr->bitrate = hdr->bitrate >> (bsid - 8);\n\n\tswitch (fscod) {\n\tcase 0:\n\t\tfreq = 48000;\n\t\tframesize = ac3_sizecod0_to_framesize[frmsizecod / 2] * 2;\n\t\tbreak;\n\tcase 1:\n\t\tfreq = 44100;\n\t\tframesize = (ac3_sizecod1_to_framesize[frmsizecod / 2] + (frmsizecod & 0x1)) * 2;\n\t\tbreak;\n\tcase 2:\n\t\tfreq = 32000;\n\t\tframesize = ac3_sizecod2_to_framesize[frmsizecod / 2] * 2;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\thdr->sample_rate = freq;\n\thdr->framesize = framesize;\n\n\tif (full_parse) {\n\t\thdr->bsid = bsid;\n\t\thdr->bsmod = bsmod;\n\t\thdr->acmod = ac3_mod;\n\t\thdr->lfon = 0;\n\t\thdr->fscod = fscod;\n\t\thdr->brcode = frmsizecod / 2;\n\t}\n\n\thdr->channels = ac3_mod_to_chans[ac3_mod];\n\tif ((ac3_mod & 0x1) && (ac3_mod != 1)) gf_bs_read_int(bs, 2);\n\tif (ac3_mod & 0x4) gf_bs_read_int(bs, 2);\n\tif (ac3_mod == 0x2) gf_bs_read_int(bs, 2);\n\t/*LFEon*/\n\tif (gf_bs_read_int(bs, 1)) {\n\t\thdr->channels += 1;\n\t\thdr->lfon = 1;\n\t}\n\n\tgf_bs_seek(bs, pos);\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_eac3_parser_bs(GF_BitStream *bs, GF_AC3Header *hdr, Bool full_parse)\n{\n\tu32 fscod, bsid, ac3_mod, freq, framesize, syncword, substreamid, lfon, channels, numblkscod;\n\tu64 pos;\n\nrestart:\n\tif (!hdr || (gf_bs_available(bs) < 6))\n\t\treturn GF_FALSE;\n\tif (!AC3_FindSyncCodeBS(bs))\n\t\treturn GF_FALSE;\n\n\tpos = gf_bs_get_position(bs);\n\tframesize = 0;\n\tnumblkscod = 0;\n\nblock:\n\tsyncword = gf_bs_read_u16(bs);\n\tif (syncword != 0x0B77) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[E-AC3] Wrong sync word detected (0x%X - expecting 0x0B77).\\n\", syncword));\n\t\treturn GF_FALSE;\n\t}\n\n\tgf_bs_read_int(bs, 2); //strmtyp\n\tsubstreamid = gf_bs_read_int(bs, 3);\n\tframesize += gf_bs_read_int(bs, 11);\n\tfscod = gf_bs_read_int(bs, 2);\n\tif (fscod == 0x3) {\n\t\tfscod = gf_bs_read_int(bs, 2);\n\t\tnumblkscod += 6;\n\t} else {\n\t\tnumblkscod += gf_bs_read_int(bs, 2);\n\t}\n\tassert(numblkscod <= 9);\n\n\tif ((hdr->substreams >> substreamid) & 0x1) {\n\t\tif (!substreamid) {\n\t\t\thdr->framesize = framesize;\n\n\t\t\tif (numblkscod < 6) { //we need 6 blocks to make a sample\n\t\t\t\tgf_bs_seek(bs, pos+2*framesize);\n\t\t\t\tif ((gf_bs_available(bs) < 6) || !AC3_FindSyncCodeBS(bs))\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t\tgoto block;\n\t\t\t}\n\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\treturn GF_TRUE;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[E-AC3] Detected sample in substream id=%u. Skipping.\\n\", substreamid));\n\t\t\tgf_bs_seek(bs, pos+framesize);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\thdr->substreams |= (1 << substreamid);\n\n\tswitch (fscod) {\n\tcase 0:\n\t\tfreq = 48000;\n\t\tbreak;\n\tcase 1:\n\t\tfreq = 44100;\n\t\tbreak;\n\tcase 2:\n\t\tfreq = 32000;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\n\tac3_mod = gf_bs_read_int(bs, 3);\n\tlfon = gf_bs_read_int(bs, 1);\n\tbsid = gf_bs_read_int(bs, 5);\n\tif (!substreamid && (bsid!=16/*E-AC3*/))\n\t\treturn GF_FALSE;\n\n\tchannels = ac3_mod_to_chans[ac3_mod];\n\tif (lfon)\n\t\tchannels += 1;\n\n\tif (substreamid) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[E-AC3] Detected additional %u channels in substream id=%u - may not be handled correctly. Skipping.\\n\", channels, substreamid));\n\t\tgf_bs_seek(bs, pos+framesize);\n\t\tgoto restart;\n\t} else {\n\t\thdr->bitrate = 0;\n\t\thdr->sample_rate = freq;\n\t\thdr->framesize = framesize;\n\t\thdr->lfon = lfon;\n\t\thdr->channels = channels;\n\t\tif (full_parse) {\n\t\t\thdr->bsid = bsid;\n\t\t\thdr->bsmod = 0;\n\t\t\thdr->acmod = ac3_mod;\n\t\t\thdr->fscod = fscod;\n\t\t\thdr->brcode = 0;\n\t\t}\n\t}\n\n\tif (numblkscod < 6) { //we need 6 blocks to make a sample\n\t\tgf_bs_seek(bs, pos+2*framesize);\n\t\tif ((gf_bs_available(bs) < 6) || !AC3_FindSyncCodeBS(bs))\n\t\t\treturn GF_FALSE;\n\t\tgoto block;\n\t}\n\n\tgf_bs_seek(bs, pos);\n\n\treturn GF_TRUE;\n}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined (GPAC_DISABLE_OGG)\n\n/*\n\tVorbis parser\n*/\n\nstatic u32 vorbis_book_maptype1_quantvals(u32 entries, u32 dim)\n{\n\tu32 vals = (u32) floor(pow(entries, 1.0/dim));\n\twhile(1) {\n\t\tu32 acc=1;\n\t\tu32 acc1=1;\n\t\tu32 i;\n\t\tfor (i=0; i<dim; i++) {\n\t\t\tacc*=vals;\n\t\t\tacc1*=vals+1;\n\t\t}\n\t\tif(acc<=entries && acc1>entries) return (vals);\n\t\telse {\n\t\t\tif (acc>entries) vals--;\n\t\t\telse vals++;\n\t\t}\n\t}\n}\n\nu32 _ilog_(u32 v)\n{\n\tu32 ret=0;\n\twhile(v) {\n\t\tret++;\n\t\tv>>=1;\n\t}\n\treturn(ret);\n}\n\nstatic u32 ilog(u32 v)\n{\n\tu32 ret=0;\n\tif(v) --v;\n\twhile(v) {\n\t\tret++;\n\t\tv>>=1;\n\t}\n\treturn (ret);\n}\n\nstatic u32 icount(u32 v)\n{\n\tu32 ret=0;\n\twhile(v) {\n\t\tret += v&1;\n\t\tv>>=1;\n\t}\n\treturn(ret);\n}\n\n\nGF_EXPORT\nBool gf_vorbis_parse_header(GF_VorbisParser *vp, char *data, u32 data_len)\n{\n\tu32 pack_type, i, j, k, times, nb_part, nb_books, nb_modes;\n\tchar szNAME[8];\n\toggpack_buffer opb;\n\n\toggpack_readinit(&opb, (u8*)data, data_len);\n\tpack_type = oggpack_read(&opb, 8);\n\ti=0;\n\twhile (i<6) {\n\t\tszNAME[i] = oggpack_read(&opb, 8);\n\t\ti++;\n\t}\n\tszNAME[i] = 0;\n\tif (strcmp(szNAME, \"vorbis\")) return vp->is_init = 0;\n\n\tswitch (pack_type) {\n\tcase 0x01:\n\t\tvp->version = oggpack_read(&opb, 32);\n\t\tif (vp->version!=0) return 0;\n\t\tvp->channels = oggpack_read(&opb, 8);\n\t\tvp->sample_rate = oggpack_read(&opb, 32);\n\t\tvp->max_r = oggpack_read(&opb, 32);\n\t\tvp->avg_r = oggpack_read(&opb, 32);\n\t\tvp->low_r = oggpack_read(&opb, 32);\n\n\t\tvp->min_block = 1<<oggpack_read(&opb, 4);\n\t\tvp->max_block = 1<<oggpack_read(&opb, 4);\n\t\tif (vp->sample_rate < 1) return vp->is_init = 0;\n\t\tif (vp->channels < 1) return vp->is_init = 0;\n\t\tif (vp->min_block<8) return vp->is_init = 0;\n\t\tif (vp->max_block < vp->min_block) return vp->is_init = 0;\n\t\tif (oggpack_read(&opb, 1) != 1) return vp->is_init = 0;\n\t\tvp->is_init = 1;\n\t\treturn 1;\n\tcase 0x03:\n\t\t/*trash comments*/\n\t\tvp->is_init ++;\n\t\treturn 1;\n\tcase 0x05:\n\t\t/*need at least bitstream header to make sure we're parsing the right thing*/\n\t\tif (!vp->is_init) return 0;\n\t\tbreak;\n\tdefault:\n\t\tvp->is_init = 0;\n\t\treturn 0;\n\t}\n\t/*OK parse codebook*/\n\tnb_books = oggpack_read(&opb, 8) + 1;\n\t/*skip vorbis static books*/\n\tfor (i=0; i<nb_books; i++) {\n\t\tu32 j, map_type, qb, qq;\n\t\tu32 entries, dim;\n\t\toggpack_read(&opb, 24);\n\t\tdim = oggpack_read(&opb, 16);\n\t\tentries = oggpack_read(&opb, 24);\n\t\tif ( (s32) entries < 0) entries = 0;\n\t\tif (oggpack_read(&opb, 1) == 0) {\n\t\t\tif (oggpack_read(&opb, 1)) {\n\t\t\t\tfor (j=0; j<entries; j++) {\n\t\t\t\t\tif (oggpack_read(&opb, 1)) {\n\t\t\t\t\t\toggpack_read(&opb, 5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (j=0; j<entries; j++)\n\t\t\t\t\toggpack_read(&opb, 5);\n\t\t\t}\n\t\t} else {\n\t\t\toggpack_read(&opb, 5);\n\t\t\tfor (j=0; j<entries;) {\n\t\t\t\tu32 num = oggpack_read(&opb, _ilog_(entries-j));\n\t\t\t\tfor (k=0; k<num && j<entries; k++, j++) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch ((map_type=oggpack_read(&opb, 4))) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\t\toggpack_read(&opb, 32);\n\t\t\toggpack_read(&opb, 32);\n\t\t\tqq = oggpack_read(&opb, 4)+1;\n\t\t\toggpack_read(&opb, 1);\n\t\t\tif (map_type==1) qb = vorbis_book_maptype1_quantvals(entries, dim);\n\t\t\telse if (map_type==2) qb = entries * dim;\n\t\t\telse qb = 0;\n\t\t\tfor (j=0; j<qb; j++) oggpack_read(&opb, qq);\n\t\t\tbreak;\n\t\t}\n\t}\n\ttimes = oggpack_read(&opb, 6)+1;\n\tfor (i=0; i<times; i++) oggpack_read(&opb, 16);\n\ttimes = oggpack_read(&opb, 6)+1;\n\tfor (i=0; i<times; i++) {\n\t\tu32 type = oggpack_read(&opb, 16);\n\t\tif (type) {\n\t\t\tu32 *parts, *class_dims, count, rangebits;\n\t\t\tu32 max_class = 0;\n\t\t\tnb_part = oggpack_read(&opb, 5);\n\t\t\tparts = (u32*)gf_malloc(sizeof(u32) * nb_part);\n\t\t\tfor (j=0; j<nb_part; j++) {\n\t\t\t\tparts[j] = oggpack_read(&opb, 4);\n\t\t\t\tif (max_class<parts[j]) max_class = parts[j];\n\t\t\t}\n\t\t\tclass_dims = (u32*)gf_malloc(sizeof(u32) * (max_class+1));\n\t\t\tfor (j=0; j<max_class+1; j++) {\n\t\t\t\tu32 class_sub;\n\t\t\t\tclass_dims[j] = oggpack_read(&opb, 3) + 1;\n\t\t\t\tclass_sub = oggpack_read(&opb, 2);\n\t\t\t\tif (class_sub) oggpack_read(&opb, 8);\n\t\t\t\tfor (k=0; k < (u32) (1<<class_sub); k++) oggpack_read(&opb, 8);\n\t\t\t}\n\t\t\toggpack_read(&opb, 2);\n\t\t\trangebits=oggpack_read(&opb, 4);\n\t\t\tcount = 0;\n\t\t\tfor (j=0,k=0; j<nb_part; j++) {\n\t\t\t\tcount+=class_dims[parts[j]];\n\t\t\t\tfor (; k<count; k++) oggpack_read(&opb, rangebits);\n\t\t\t}\n\t\t\tgf_free(parts);\n\t\t\tgf_free(class_dims);\n\t\t} else {\n\t\t\tu32 j, nb_books;\n\t\t\toggpack_read(&opb, 8+16+16+6+8);\n\t\t\tnb_books = oggpack_read(&opb, 4)+1;\n\t\t\tfor (j=0; j<nb_books; j++) oggpack_read(&opb, 8);\n\t\t}\n\t}\n\ttimes = oggpack_read(&opb, 6)+1;\n\tfor (i=0; i<times; i++) {\n\t\tu32 acc = 0;\n\t\toggpack_read(&opb, 16);/*type*/\n\t\toggpack_read(&opb, 24);\n\t\toggpack_read(&opb,24);\n\t\toggpack_read(&opb,24);\n\t\tnb_part = oggpack_read(&opb, 6)+1;\n\t\toggpack_read(&opb, 8);\n\t\tfor (j=0; j<nb_part; j++) {\n\t\t\tu32 cascade = oggpack_read(&opb, 3);\n\t\t\tif (oggpack_read(&opb, 1)) cascade |= (oggpack_read(&opb, 5)<<3);\n\t\t\tacc += icount(cascade);\n\t\t}\n\t\tfor (j=0; j<acc; j++) oggpack_read(&opb, 8);\n\t}\n\ttimes = oggpack_read(&opb, 6)+1;\n\tfor (i=0; i<times; i++) {\n\t\tu32 sub_maps = 1;\n\t\toggpack_read(&opb, 16);\n\t\tif (oggpack_read(&opb, 1)) sub_maps = oggpack_read(&opb, 4)+1;\n\t\tif (oggpack_read(&opb, 1)) {\n\t\t\tu32 nb_steps = oggpack_read(&opb, 8)+1;\n\t\t\tfor (j=0; j<nb_steps; j++) {\n\t\t\t\toggpack_read(&opb, ilog(vp->channels));\n\t\t\t\toggpack_read(&opb, ilog(vp->channels));\n\t\t\t}\n\t\t}\n\t\toggpack_read(&opb, 2);\n\t\tif (sub_maps>1) {\n\t\t\tfor(j=0; j<vp->channels; j++) oggpack_read(&opb, 4);\n\t\t}\n\t\tfor (j=0; j<sub_maps; j++) {\n\t\t\toggpack_read(&opb, 8);\n\t\t\toggpack_read(&opb, 8);\n\t\t\toggpack_read(&opb, 8);\n\t\t}\n\t}\n\tnb_modes = oggpack_read(&opb, 6)+1;\n\tfor (i=0; i<nb_modes; i++) {\n\t\tvp->mode_flag[i] = oggpack_read(&opb, 1);\n\t\toggpack_read(&opb, 16);\n\t\toggpack_read(&opb, 16);\n\t\toggpack_read(&opb, 8);\n\t}\n\n\tvp->modebits = 0;\n\tj = nb_modes;\n\twhile(j>1) {\n\t\tvp->modebits++;\n\t\tj>>=1;\n\t}\n\treturn 1;\n}\n\nGF_EXPORT\nu32 gf_vorbis_check_frame(GF_VorbisParser *vp, char *data, u32 data_length)\n{\n\ts32 block_size;\n\toggpack_buffer opb;\n\tif (!vp->is_init) return 0;\n\toggpack_readinit(&opb, (unsigned char*)data, data_length);\n\t/*not audio*/\n\tif (oggpack_read(&opb, 1) !=0) return 0;\n\tblock_size = oggpack_read(&opb, vp->modebits);\n\tif (block_size == -1) return 0;\n\treturn ((vp->mode_flag[block_size]) ? vp->max_block : vp->min_block) / (2);\n}\n\n#endif /*!defined(GPAC_DISABLE_AV_PARSERS) && !defined (GPAC_DISABLE_OGG)*/\n"], "filenames": ["include/gpac/tools.h", "src/isomedia/avc_ext.c", "src/media_tools/av_parsers.c"], "buggy_code_start_loc": [1069, 2415, 2387], "buggy_code_end_loc": [1069, 2415, 2387], "fixing_code_start_loc": [1070, 2416, 2388], "fixing_code_end_loc": [1071, 2418, 2392], "type": "CWE-119", "message": "GPAC through 0.7.1 has a Buffer Overflow in the gf_media_avc_read_sps function in media_tools/av_parsers.c, a different vulnerability than CVE-2018-1000100.", "other": {"cve": {"id": "CVE-2018-7752", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-07T23:29:00.227", "lastModified": "2019-04-15T19:13:06.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GPAC through 0.7.1 has a Buffer Overflow in the gf_media_avc_read_sps function in media_tools/av_parsers.c, a different vulnerability than CVE-2018-1000100."}, {"lang": "es", "value": "GPAC, hasta la versi\u00f3n 0.7.1, tiene un desbordamiento de b\u00fafer en la funci\u00f3n gf_media_avc_read_sps en media_tools/av_parsers.c. Esta vulnerabilidad es diferente de CVE-2018-1000100."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.7.1", "matchCriteriaId": "085CE50F-C216-47FB-A0A6-00BE575E4B4F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/90dc7f853d31b0a4e9441cba97feccf36d8b69a4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/gpac/gpac/issues/997", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00040.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3926-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/90dc7f853d31b0a4e9441cba97feccf36d8b69a4"}}