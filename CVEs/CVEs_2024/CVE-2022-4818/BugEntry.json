{"buggy_code": ["/*\n * Copyright (C) 2006-2019 Talend Inc. - www.talend.com\n *\n * This source code is available under agreement available at\n * %InstallDIR%\\features\\org.talend.rcp.branding.%PRODUCTNAME%\\%PRODUCTNAME%license.txt\n *\n * You should have received a copy of the agreement along with this program; if not, write to Talend SA 9 rue Pages\n * 92150 Suresnes, France\n */\npackage com.amalto.commons.core.utils;\n\nimport java.io.StringReader;\nimport java.io.StringWriter;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.dom4j.io.DocumentResult;\nimport org.dom4j.io.DocumentSource;\nimport org.w3c.dom.DOMImplementation;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport com.sun.org.apache.xpath.internal.XPathAPI;\nimport com.sun.org.apache.xpath.internal.objects.XObject;\n\n/**\n * XML Manipulation routines\n * @author Bruno Grieder\n *\n */\npublic final class XMLUtils {\n\n    private static final Logger logger = LogManager.getLogger(XMLUtils.class);\n\n    private static final TransformerFactory transformerFactory;\n\n    private static final TransformerFactory saxonTransformerFactory = new net.sf.saxon.TransformerFactoryImpl();\n\n    static {\n        // the open jdk implementation allows the disabling of the feature used for XXE\n        System.setProperty(\"javax.xml.transform.TransformerFactory\",\n                \"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\");\n        transformerFactory = TransformerFactory.newInstance();\n        try {\n            transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n\n            saxonTransformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            saxonTransformerFactory.setAttribute(\"http://saxon.sf.net/feature/version-warning\", Boolean.FALSE);\n            saxonTransformerFactory.setAttribute(\"http://saxon.sf.net/feature/allow-external-functions\", Boolean.FALSE);\n            saxonTransformerFactory.setAttribute(\"http://saxon.sf.net/feature/trace-external-functions\", Boolean.FALSE);\n        } catch (TransformerConfigurationException e) {\n            // Just catch this, as Xalan doesn't support the above\n        }\n    }\n\n    /**\n\t * Returns a namespaced root element of a document\n\t * Useful to create a namespace holder element\n\t * @param namespace\n\t * @return the root Element\n\t */\n\tpublic static Element getRootElement(String elementName, String namespace, String prefix) throws TransformerException{\n\t \tElement rootNS=null;\n    \ttry {\n\t    \tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t        factory.setNamespaceAware(true);\n\t        factory.setExpandEntityReferences(false);\n\t        DocumentBuilder builder = factory.newDocumentBuilder();\n\t    \tDOMImplementation impl = builder.getDOMImplementation();\n\t    \tDocument namespaceHolder = impl.createDocument(namespace,(prefix==null?\"\":prefix+\":\")+elementName, null);\n\t    \trootNS = namespaceHolder.getDocumentElement();\n\t    \trootNS.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:\"+prefix, namespace);\n    \t} catch (Exception e) {\n    \t    String err=\"Error creating a namespace holder document: \"+e.getLocalizedMessage();\n    \t    throw new TransformerException(err);\n    \t}\n    \treturn rootNS;\n\t}\n\n\t/**\n\t * Get a nodelist from an xPath\n\t * @throws TransformerException\n\t */\n\tpublic static NodeList getNodeList(Document d, String xPath) throws TransformerException{\n\t\treturn getNodeList(d.getDocumentElement(),xPath,null,null);\n\t}\n\t/**\n\t * Get a nodelist from an xPath\n\t * @throws TransformerException\n\t */\n\tpublic static NodeList getNodeList(Node contextNode, String xPath) throws TransformerException{\n\t\treturn getNodeList(contextNode,xPath,null,null);\n\t}\n\n\t/**\n\t * Get a nodelist from an xPath\n\t * @throws TransformerException\n\t */\n\tpublic static NodeList getNodeList(Node contextNode, String xPath, String namespace, String prefix) throws TransformerException{\n\t\ttry {\n\t\t    XObject xo = XPathAPI.eval(\n\t    \t\tcontextNode,\n\t\t\t\txPath,\n\t\t\t\t(namespace == null) ? contextNode : getRootElement(\"nsholder\",namespace,prefix)\n\t\t    );\n\t\t    if (xo.getType() != XObject.CLASS_NODESET) return null;\n\t\t    return xo.nodelist();\n    \t} catch (TransformerException e) {\n    \t    String err = \"Unable to get the Nodes List for xpath '\"+xPath+\"'\"\n    \t    \t+((contextNode==null) ? \"\" : \" for Node \"+contextNode.getLocalName())\n    \t\t\t+\": \"+e.getLocalizedMessage();\n    \t\tthrow new TransformerException(err);\n    \t}\n\t}\n\n    /**\n     * Returns the first Element of the Node List at xPath\n     * @param n\n     * @param xPath\n     * @return\n     * @throws XtentisWebappException\n     */\n\tpublic static Element getFirstElement(Node n, String xPath) throws TransformerException {\n\t\t\tNodeList nl = getNodeList(n, xPath);\n\t\t\tif ((nl==null) || (nl.getLength()==0)) return null;\n\t\t\treturn (Element)nl.item(0);\n\t}\n\n    public static String[] getAttributeNodeValue(Node contextNode, String xPath, Node namespaceNode) throws TransformerException{\n        String[] results;\n\n        //test for hard-coded values\n        if (xPath.startsWith(\"\\\"\") && xPath.endsWith(\"\\\"\"))\n            return new String[] { xPath.substring(1, xPath.length()-1)};\n\n        //test for incomplete path\n        //if (! xPath.endsWith(\")\")) xPath+=\"/text()\";\n\n        try {\n\t        XObject xo = XPathAPI.eval(contextNode, xPath,namespaceNode);\n\t        if (xo.getType() == XObject.CLASS_NODESET) {\n\t            NodeList l = xo.nodelist();\n\t            int len = l.getLength();\n\t            results = new String[len];\n\t            for (int i = 0; i < len; i++) {\n\t                Node n = l.item(i);\n\t                results[i] = n.getNodeValue();\n\t            }\n\t        } else {\n\t            results = new String[]{xo.toString()};\n\t        }\n\t\t} catch (TransformerException e) {\n\t\t\tString err = \"Unable to get the text node(s) of \"+xPath\n\t\t\t\t\t+\": \" + e.getClass().getName() + \": \"\n\t\t\t\t\t+ e.getLocalizedMessage();\n\t\t\tthrow new TransformerException(err);\n\t\t}\n\t\treturn results;\n    }\n\n    public static Transformer generateTransformer() throws TransformerConfigurationException {\n        return transformerFactory.newTransformer();\n    }\n\n    public static Transformer generateTransformer(boolean isOmitXmlDeclaration) throws TransformerConfigurationException {\n        Transformer transformer = generateTransformer();\n        if (isOmitXmlDeclaration) {\n            transformer.setOutputProperty(\"omit-xml-declaration\", \"yes\");\n        } else {\n            transformer.setOutputProperty(\"omit-xml-declaration\", \"no\");\n        }\n        return transformer;\n    }\n\n    public static Transformer generateTransformer(boolean isOmitXmlDeclaration, boolean isIndent)\n            throws TransformerConfigurationException {\n        Transformer transformer = generateTransformer(isOmitXmlDeclaration);\n        if (isIndent) {\n            transformer.setOutputProperty(\"indent\", \"yes\");\n        } else {\n            transformer.setOutputProperty(\"indent\", \"no\");\n        }\n        return transformer;\n    }\n\n    public static String nodeToString(Node n, boolean isOmitXmlDeclaration, boolean isIndent) throws TransformerException {\n        StringWriter sw = new StringWriter();\n        Transformer transformer = generateTransformer(isOmitXmlDeclaration, isIndent);\n        transformer.transform(new DOMSource(n), new StreamResult(sw));\n        return sw.toString();\n    }\n\n    public static String nodeToString(Node n) throws TransformerException {\n        return nodeToString(n, true, true);\n    }\n\n    public static org.dom4j.Document styleDocument(org.dom4j.Document document, String stylesheet) throws Exception {\n        // load the transformer using JAXP\n        Transformer transformer = saxonTransformerFactory.newTransformer(new StreamSource(new StringReader(stylesheet)));\n\n        // now lets style the given document\n        DocumentSource source = new DocumentSource(document);\n        DocumentResult result = new DocumentResult();\n        transformer.transform(source, result);\n\n        // return the transformed document\n        org.dom4j.Document transformedDoc = result.getDocument();\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"The xml file style transformed successfully \");\n        }\n        return transformedDoc;\n    }\n }\n", "/*\n * Copyright (C) 2006-2019 Talend Inc. - www.talend.com\n *\n * This source code is available under agreement available at\n * %InstallDIR%\\features\\org.talend.rcp.branding.%PRODUCTNAME%\\%PRODUCTNAME%license.txt\n *\n * You should have received a copy of the agreement along with this program; if not, write to Talend SA 9 rue Pages\n * 92150 Suresnes, France\n */\n\npackage com.amalto.core.storage;\n\nimport static com.amalto.core.query.user.UserQueryBuilder.eq;\nimport static com.amalto.core.query.user.UserQueryBuilder.from;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\nimport org.talend.mdm.commmon.metadata.ComplexTypeMetadata;\nimport org.talend.mdm.commmon.metadata.ContainedComplexTypeMetadata;\nimport org.talend.mdm.commmon.metadata.DefaultMetadataVisitor;\nimport org.talend.mdm.commmon.metadata.FieldMetadata;\nimport org.talend.mdm.commmon.metadata.MetadataRepository;\nimport org.talend.mdm.commmon.metadata.MetadataVisitor;\nimport org.talend.mdm.commmon.metadata.TypeMetadata;\nimport org.talend.mdm.commmon.util.core.MDMXMLUtils;\nimport org.talend.mdm.commmon.util.webapp.XSystemObjects;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.XMLReader;\n\nimport com.amalto.core.metadata.ClassRepository;\nimport com.amalto.core.objects.ObjectPOJO;\nimport com.amalto.core.query.user.Select;\nimport com.amalto.core.query.user.UserQueryBuilder;\nimport com.amalto.core.server.StorageAdmin;\nimport com.amalto.core.storage.record.DataRecord;\nimport com.amalto.core.storage.record.DataRecordReader;\nimport com.amalto.core.storage.record.XmlDOMDataRecordReader;\nimport com.amalto.core.storage.record.XmlSAXDataRecordReader;\nimport com.amalto.xmlserver.interfaces.ItemPKCriteria;\nimport com.amalto.xmlserver.interfaces.XmlServerException;\n\npublic class SystemStorageWrapper extends StorageWrapper {\n\n    private static final DocumentBuilderFactory DOCUMENT_BUILDER_FACTORY = DocumentBuilderFactory.newInstance();\n\n    private static final String SYSTEM_PREFIX = \"amaltoOBJECTS\"; //$NON-NLS-1$\n\n    private static final String CUSTOM_FORM_TYPE = \"custom-form-pOJO\"; //$NON-NLS-1$\n\n    private static final String DROPPED_ITEM_TYPE = \"dropped-item-pOJO\"; //$NON-NLS-1$\n\n    private static final String COMPLETED_ROUTING_ORDER = \"completed-routing-order-v2-pOJO\"; //$NON-NLS-1$\n\n    private static final String FAILED_ROUTING_ORDER = \"failed-routing-order-v2-pOJO\"; //$NON-NLS-1$\n\n    private static final String SYNCHRONIZATION_OBJECT_TYPE = \"synchronization-object-pOJO\"; //$NON-NLS-1$\n\n    private static final String BROWSEITEM_PREFIX_INFO = \"SearchTemplate.BrowseItem.\"; //$NON-NLS-1$\n\n    private static final Logger LOGGER = LogManager.getLogger(SystemStorageWrapper.class);\n\n    public SystemStorageWrapper() {\n        DOCUMENT_BUILDER_FACTORY.setNamespaceAware(true);\n        // Create \"system\" storage\n        StorageAdmin admin = getStorageAdmin();\n        if (!admin.exist(StorageAdmin.SYSTEM_STORAGE, StorageType.SYSTEM)) {\n            String datasource = admin.getDatasource(StorageAdmin.SYSTEM_STORAGE);\n            admin.create(StorageAdmin.SYSTEM_STORAGE, StorageAdmin.SYSTEM_STORAGE, StorageType.SYSTEM, datasource);\n        }\n    }\n\n    private ComplexTypeMetadata getType(String clusterName, Storage storage, String uniqueID) {\n        MetadataRepository repository = storage.getMetadataRepository();\n        if (uniqueID != null && uniqueID.startsWith(\"amalto_local_service_\")) { //$NON-NLS-1$\n            return repository.getComplexType(\"service-bMP\"); //$NON-NLS-1$\n        }\n        if (clusterName.startsWith(SYSTEM_PREFIX) || clusterName.startsWith(\"amalto\")) { //$NON-NLS-1$\n            if (!\"amaltoOBJECTSservices\".equals(clusterName)) { //$NON-NLS-1$\n                return repository.getComplexType(ClassRepository.format(clusterName.substring(SYSTEM_PREFIX.length()) + \"POJO\")); //$NON-NLS-1$\n            } else {\n                return repository.getComplexType(ClassRepository.format(clusterName.substring(SYSTEM_PREFIX.length())));\n            }\n        }\n        if (XSystemObjects.DC_MDMITEMSTRASH.getName().equals(clusterName)) {\n            return repository.getComplexType(DROPPED_ITEM_TYPE);\n        } else if (XSystemObjects.DC_PROVISIONING.getName().equals(clusterName)) {\n            String typeName = getTypeName(uniqueID);\n            if (\"Role\".equals(typeName)) { //$NON-NLS-1$\n                return repository.getComplexType(\"role-pOJO\"); //$NON-NLS-1$\n            }\n            return repository.getComplexType(typeName);\n        } else if (\"MDMDomainObjects\".equals(clusterName) || \"MDMItemImages\".equals(clusterName) || \"FailedAutoCommitSvnMessage\".equals(clusterName)) { //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n            return null; // Documents for these clusters don't have a predefined structure.\n        }\n        // No id, so no type to be read.\n        if (uniqueID == null) {\n            return null;\n        }\n        // MIGRATION.completed.record\n        return repository.getComplexType(getTypeName(uniqueID));\n    }\n\n    @Override\n    public List<String> getItemPKsByCriteria(ItemPKCriteria criteria) throws XmlServerException {\n        String clusterName = criteria.getClusterName();\n        Storage storage = getStorage(clusterName);\n        MetadataRepository repository = storage.getMetadataRepository();\n\n        int totalCount = 0;\n        List<String> itemPKResults = new LinkedList<String>();\n        String typeName = criteria.getConceptName();\n\n        try {\n            storage.begin();\n            if (typeName != null && !typeName.isEmpty()) {\n                String internalTypeName = typeName;\n                String objectRootElementName = ObjectPOJO.getObjectRootElementName(typeName);\n                if (objectRootElementName != null) {\n                    internalTypeName = objectRootElementName;\n                }\n                totalCount = getTypeItemCount(criteria, repository.getComplexType(internalTypeName), storage);\n                itemPKResults.addAll(getTypeItems(criteria, repository.getComplexType(internalTypeName), storage, typeName));\n            } else {\n                // TMDM-4651: Returns type in correct dependency order.\n                Collection<ComplexTypeMetadata> types = getClusterTypes(clusterName);\n                int maxCount = criteria.getMaxItems();\n                if (criteria.getSkip() < 0) { // MDM Studio may send negative values\n                    criteria.setSkip(0);\n                }\n                List<String> currentInstanceResults;\n                String objectRootElementName;\n                for (ComplexTypeMetadata type : types) {\n                    String internalTypeName = type.getName();\n                    objectRootElementName = ObjectPOJO.getObjectRootElementName(internalTypeName);\n                    if (objectRootElementName != null) {\n                        internalTypeName = objectRootElementName;\n                    }\n                    int count = getTypeItemCount(criteria, repository.getComplexType(internalTypeName), storage);\n                    totalCount += count;\n                    if (itemPKResults.size() < maxCount) {\n                        if (count > criteria.getSkip()) {\n                            currentInstanceResults = getTypeItems(criteria, repository.getComplexType(internalTypeName), storage,\n                                    type.getName());\n                            int n = maxCount - itemPKResults.size();\n                            if (n <= currentInstanceResults.size()) {\n                                itemPKResults.addAll(currentInstanceResults.subList(0, n));\n                            } else {\n                                itemPKResults.addAll(currentInstanceResults);\n                            }\n                            criteria.setMaxItems(criteria.getMaxItems() - currentInstanceResults.size());\n                            criteria.setSkip(0);\n                        } else {\n                            criteria.setSkip(criteria.getSkip() - count);\n                        }\n                    }\n                }\n            }\n            itemPKResults.add(0, \"<totalCount>\" + totalCount + \"</totalCount>\"); //$NON-NLS-1$ //$NON-NLS-2$\n        } finally {\n            storage.commit();\n        }\n        return itemPKResults;\n    }\n\n    @Override\n    protected Storage getStorage(String dataClusterName) {\n        return storageAdmin.get(StorageAdmin.SYSTEM_STORAGE, StorageType.SYSTEM);\n    }\n\n    @Override\n    public long deleteCluster(String clusterName) throws XmlServerException {\n        return 0;\n    }\n\n    @Override\n    public String[] getAllClusters() throws XmlServerException {\n        Set<String> internalClusterNames = DispatchWrapper.getInternalClusterNames();\n        return internalClusterNames.toArray(new String[internalClusterNames.size()]);\n    }\n\n    @Override\n    public long deleteAllClusters() throws XmlServerException {\n        return 0;\n    }\n\n    @Override\n    public long createCluster(String clusterName) throws XmlServerException {\n        return 0;\n    }\n\n    @Override\n    public boolean existCluster(String cluster) throws XmlServerException {\n        return true;\n    }\n\n    @Override\n    protected Collection<ComplexTypeMetadata> getClusterTypes(String clusterName) {\n        Storage storage = getStorage(clusterName);\n        MetadataRepository repository = storage.getMetadataRepository();\n        return filter(repository, clusterName);\n    }\n\n    public static Collection<ComplexTypeMetadata> filter(MetadataRepository repository, String clusterName) {\n        if (clusterName.startsWith(SYSTEM_PREFIX) || clusterName.startsWith(\"amalto\")) { //$NON-NLS-1$\n            if (!\"amaltoOBJECTSservices\".equals(clusterName)) { //$NON-NLS-1$\n                final String className = ClassRepository.format(clusterName.substring(SYSTEM_PREFIX.length()) + \"POJO\"); //$NON-NLS-1$\n                return filterRepository(repository, className);\n            } else {\n                final String className = ClassRepository.format(clusterName.substring(SYSTEM_PREFIX.length()));\n                return filterRepository(repository, className);\n            }\n        } else if (XSystemObjects.DC_MDMITEMSTRASH.getName().equals(clusterName)) {\n            return filterRepository(repository, DROPPED_ITEM_TYPE);\n        } else if (XSystemObjects.DC_CONF.getName().equals(clusterName)) {\n            return filterRepository(repository, \"Conf\", \"AutoIncrement\"); //$NON-NLS-1$ //$NON-NLS-2$\n        } else if (XSystemObjects.DC_CROSSREFERENCING.getName().equals(clusterName)) {\n            return Collections.emptyList(); // TODO Support crossreferencing\n        } else if (XSystemObjects.DC_PROVISIONING.getName().equals(clusterName)) {\n            return filterRepository(repository, \"User\", \"Role\"); //$NON-NLS-1$ //$NON-NLS-2$\n        } else if (XSystemObjects.DC_SEARCHTEMPLATE.getName().equals(clusterName)) {\n            return filterRepository(repository, \"BrowseItem\", \"HierarchySearchItem\"); //$NON-NLS-1$ //$NON-NLS-2$\n        } else {\n            return repository.getUserComplexTypes();\n        }\n    }\n\n    private static Collection<ComplexTypeMetadata> filterRepository(MetadataRepository repository, String... typeNames) {\n        final Set<ComplexTypeMetadata> filteredTypes = new HashSet<ComplexTypeMetadata>();\n        MetadataVisitor<Void> transitiveTypeClosure = new DefaultMetadataVisitor<Void>() {\n\n            private final Set<TypeMetadata> visitedTypes = new HashSet<>();\n\n            @Override\n            public Void visit(ComplexTypeMetadata complexType) {\n                if (!visitedTypes.add(complexType)) {\n                    return null;\n                }\n                if (complexType.isInstantiable()) {\n                    filteredTypes.add(complexType);\n                }\n                return super.visit(complexType);\n            }\n\n            @Override\n            public Void visit(ContainedComplexTypeMetadata containedType) {\n                if (!visitedTypes.add(containedType)) {\n                    return null;\n                }\n                if (containedType.isInstantiable()) {\n                    filteredTypes.add(containedType);\n                }\n                return super.visit(containedType);\n            }\n        };\n        for (String typeName : typeNames) {\n            ComplexTypeMetadata type = repository.getComplexType(typeName);\n            if (type != null) {\n                type.accept(transitiveTypeClosure);\n            }\n        }\n        return filteredTypes;\n    }\n\n    @Override\n    public String[] getAllDocumentsUniqueID(String clusterName) throws XmlServerException {\n        String pureClusterName = getPureClusterName(clusterName);\n        boolean includeClusterAndTypeName = getClusterTypes(pureClusterName).size() > 1;\n        return getAllDocumentsUniqueID(clusterName, includeClusterAndTypeName, false);\n    }\n\n    @Override\n    public String[] getAllDocumentsUniqueID(String clusterName, final boolean ignoreChild) throws XmlServerException {\n        String pureClusterName = getPureClusterName(clusterName);\n        boolean includeClusterAndTypeName = getClusterTypes(pureClusterName).size() > 1;\n        return getAllDocumentsUniqueID(clusterName, includeClusterAndTypeName, ignoreChild);\n    }\n\n    @Override\n    public long putDocumentFromDOM(Element root, String uniqueID, String clusterName) throws XmlServerException {\n        long start = System.currentTimeMillis();\n        {\n            DataRecordReader<Element> reader = new XmlDOMDataRecordReader();\n            Storage storage = getStorage(clusterName);\n            ComplexTypeMetadata type = getType(clusterName, storage, uniqueID);\n            if (type == null) {\n                return -1; // TODO\n            }\n            MetadataRepository repository = storage.getMetadataRepository();\n            DataRecord record = reader.read(repository, type, root);\n            for (FieldMetadata keyField : type.getKeyFields()) {\n                if (record.get(keyField) == null) {\n                    LOGGER.warn(\"Ignoring update for record '\" + uniqueID + \"' (does not provide key information).\"); //$NON-NLS-1$ //$NON-NLS-2$\n                    return 0;\n                }\n            }\n            storage.update(record);\n        }\n        return System.currentTimeMillis() - start;\n    }\n\n    @Override\n    public long putDocumentFromSAX(String dataClusterName, XMLReader docReader, InputSource input) throws XmlServerException {\n        long start = System.currentTimeMillis();\n        {\n            Storage storage = getStorage(dataClusterName);\n            ComplexTypeMetadata type = getType(dataClusterName, storage, input.getPublicId());\n            if (type == null) {\n                return -1; // TODO\n            }\n            DataRecordReader<XmlSAXDataRecordReader.Input> reader = new XmlSAXDataRecordReader();\n            XmlSAXDataRecordReader.Input readerInput = new XmlSAXDataRecordReader.Input(docReader, input);\n            DataRecord record = reader.read(storage.getMetadataRepository(), type, readerInput);\n            storage.update(record);\n        }\n        return System.currentTimeMillis() - start;\n    }\n\n    @Override\n    public long putDocumentFromString(String xmlString, String uniqueID, String clusterName) throws XmlServerException {\n        return putDocumentFromString(xmlString, uniqueID, clusterName, null);\n    }\n\n    @Override\n    public long putDocumentFromString(String xmlString, String uniqueID, String clusterName, String documentType)\n            throws XmlServerException {\n        try {\n            InputSource source = new InputSource(new StringReader(xmlString));\n            Document document = MDMXMLUtils.getDocumentBuilderWithNamespace().get().parse(source);\n            return putDocumentFromDOM(document.getDocumentElement(), uniqueID, clusterName);\n        } catch (Exception e) {\n            throw new XmlServerException(e);\n        }\n    }\n\n    @Override\n    public String getDocumentAsString(String clusterName, String uniqueID) throws XmlServerException {\n        return getDocumentAsString(clusterName, uniqueID, \"UTF-8\"); //$NON-NLS-1$\n    }\n\n    @Override\n    public String getDocumentAsString(String clusterName, String uniqueID, String encoding) throws XmlServerException {\n        if (encoding == null) {\n            encoding = \"UTF-8\"; //$NON-NLS-1$\n        }\n        Storage storage = getStorage(clusterName);\n        ComplexTypeMetadata type = getType(clusterName, storage, uniqueID);\n        if (type == null) {\n            return null; // TODO\n        }\n        UserQueryBuilder qb;\n        boolean isUserFormat = false;\n        String documentUniqueID;\n        if (DROPPED_ITEM_TYPE.equals(type.getName())) {\n            // head.Product.Product.0- (but DM1.Bird.bid3)\n            if (uniqueID.endsWith(\"-\")) { //$NON-NLS-1$\n                uniqueID = uniqueID.substring(0, uniqueID.length() - 1);\n            }\n            // TODO Code may not correctly handle composite id (but no system objects use this)\n            documentUniqueID = uniqueID;\n            if (StringUtils.countMatches(uniqueID, \".\") >= 3) { //$NON-NLS-1$\n                documentUniqueID = StringUtils.substringAfter(uniqueID, \".\"); //$NON-NLS-1$\n            }\n        } else if (COMPLETED_ROUTING_ORDER.equals(type.getName()) || FAILED_ROUTING_ORDER.equals(type.getName())) {\n            documentUniqueID = uniqueID;\n        } else {\n            // TMDM-5513 custom form layout pk contains double dot .. to split, but it's a system definition object\n            // like this Product..Product..product_layout\n            isUserFormat = !uniqueID.contains(\"..\") && uniqueID.indexOf('.') > 0; //$NON-NLS-1$\n            documentUniqueID = uniqueID;\n            if (uniqueID.startsWith(PROVISIONING_PREFIX_INFO)) {\n                documentUniqueID = StringUtils.substringAfter(uniqueID, PROVISIONING_PREFIX_INFO);\n            } else if (uniqueID.startsWith(BROWSEITEM_PREFIX_INFO)) {\n                documentUniqueID = StringUtils.substringAfter(uniqueID, BROWSEITEM_PREFIX_INFO);\n            } else if (isUserFormat) {\n                documentUniqueID = StringUtils.substringAfterLast(uniqueID, \".\"); //$NON-NLS-1$\n            }\n        }\n        qb = from(type).where(eq(type.getKeyFields().iterator().next(), documentUniqueID));\n        StorageResults results = null;\n        try {\n            storage.begin();\n            results = storage.fetch(qb.getSelect());\n            String xmlString = getXmlString(clusterName, type, results.iterator(), uniqueID, encoding, isUserFormat);\n            storage.commit();\n            return xmlString;\n        } catch (IOException e) {\n            storage.rollback();\n            throw new XmlServerException(e);\n        } finally {\n            if (results != null) {\n                results.close();\n            }\n        }\n    }\n\n    @Override\n    public long deleteDocument(String clusterName, String uniqueID, String documentType) throws XmlServerException {\n        Storage storage = getStorage(clusterName);\n        ComplexTypeMetadata type = getType(clusterName, storage, uniqueID);\n        if (type == null) {\n            return -1;\n        }\n        if (DROPPED_ITEM_TYPE.equals(type.getName())) {\n            // head.Product.Product.0-\n            uniqueID = uniqueID.substring(0, uniqueID.length() - 1);\n            uniqueID = StringUtils.substringAfter(uniqueID, \".\"); //$NON-NLS-1$\n        } else if (!COMPLETED_ROUTING_ORDER.equals(type.getName()) && !FAILED_ROUTING_ORDER.equals(type.getName())\n                && !CUSTOM_FORM_TYPE.equals(type.getName()) && !SYNCHRONIZATION_OBJECT_TYPE.equals(type.getName())) {\n            if (uniqueID.startsWith(PROVISIONING_PREFIX_INFO)) {\n                uniqueID = StringUtils.substringAfter(uniqueID, PROVISIONING_PREFIX_INFO);\n            } else if (uniqueID.startsWith(BROWSEITEM_PREFIX_INFO)) {\n                uniqueID = StringUtils.substringAfter(uniqueID, BROWSEITEM_PREFIX_INFO);\n            } else if (uniqueID.contains(\".\")) { //$NON-NLS-1$\n                uniqueID = StringUtils.substringAfterLast(uniqueID, \".\"); //$NON-NLS-1$\n            }\n        }\n        long start = System.currentTimeMillis();\n        {\n            UserQueryBuilder qb = from(type).where(eq(type.getKeyFields().iterator().next(), uniqueID));\n            StorageResults results = null;\n            try {\n                storage.begin();\n                Select select = qb.getSelect();\n                results = storage.fetch(select);\n                if (results.getCount() == 0) {\n                    throw new IllegalArgumentException(\"Could not find document to delete.\"); //$NON-NLS-1$\n                }\n                storage.delete(select);\n                storage.commit();\n            } catch (Exception e) {\n                storage.rollback();\n                throw new XmlServerException(e);\n            } finally {\n                if (results != null) {\n                    results.close();\n                }\n            }\n        }\n        return System.currentTimeMillis() - start;\n    }\n\n    @Override\n    public String[] getDocumentsAsString(String clusterName, String[] uniqueIDs) throws XmlServerException {\n        return getDocumentsAsString(clusterName, uniqueIDs, \"UTF-8\"); //$NON-NLS-1$\n    }\n\n    @Override\n    public String[] getDocumentsAsString(String clusterName, String[] uniqueIDs, String encoding) throws XmlServerException {\n        if (uniqueIDs == null || uniqueIDs.length == 0) {\n            return new String[0];\n        }\n        List<String> xmlStrings = new ArrayList<String>(uniqueIDs.length);\n        for (String uniqueID : uniqueIDs) {\n            xmlStrings.add(getDocumentAsString(clusterName, uniqueID, encoding));\n        }\n        return xmlStrings.toArray(new String[xmlStrings.size()]);\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2006-2019 Talend Inc. - www.talend.com\n *\n * This source code is available under agreement available at\n * %InstallDIR%\\features\\org.talend.rcp.branding.%PRODUCTNAME%\\%PRODUCTNAME%license.txt\n *\n * You should have received a copy of the agreement along with this program; if not, write to Talend SA 9 rue Pages\n * 92150 Suresnes, France\n */\npackage com.amalto.commons.core.utils;\n\nimport java.io.StringReader;\nimport java.io.StringWriter;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.dom4j.io.DocumentResult;\nimport org.dom4j.io.DocumentSource;\nimport org.w3c.dom.DOMImplementation;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport com.sun.org.apache.xpath.internal.XPathAPI;\nimport com.sun.org.apache.xpath.internal.objects.XObject;\n\n/**\n * XML Manipulation routines\n * @author Bruno Grieder\n *\n */\npublic final class XMLUtils {\n\n    private static final Logger logger = LogManager.getLogger(XMLUtils.class);\n\n    private static final TransformerFactory transformerFactory;\n\n    private static final TransformerFactory saxonTransformerFactory = new net.sf.saxon.TransformerFactoryImpl();\n\n    static {\n        // the open jdk implementation allows the disabling of the feature used for XXE\n        System.setProperty(\"javax.xml.transform.TransformerFactory\",\n                \"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\");\n        transformerFactory = TransformerFactory.newInstance();\n        try {\n            transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n\n            saxonTransformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            saxonTransformerFactory.setAttribute(\"http://saxon.sf.net/feature/version-warning\", Boolean.FALSE);\n            saxonTransformerFactory.setAttribute(\"http://saxon.sf.net/feature/allow-external-functions\", Boolean.FALSE);\n            saxonTransformerFactory.setAttribute(\"http://saxon.sf.net/feature/trace-external-functions\", Boolean.FALSE);\n        } catch (TransformerConfigurationException e) {\n            // Just catch this, as Xalan doesn't support the above\n        }\n    }\n\n    /**\n\t * Returns a namespaced root element of a document\n\t * Useful to create a namespace holder element\n\t * @param namespace\n\t * @return the root Element\n\t */\n\tpublic static Element getRootElement(String elementName, String namespace, String prefix) throws TransformerException{\n\t \tElement rootNS=null;\n    \ttry {\n\t    \tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t        factory.setNamespaceAware(true);\n\t        factory.setExpandEntityReferences(false);\n\t        factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t        DocumentBuilder builder = factory.newDocumentBuilder();\n\t    \tDOMImplementation impl = builder.getDOMImplementation();\n\t    \tDocument namespaceHolder = impl.createDocument(namespace,(prefix==null?\"\":prefix+\":\")+elementName, null);\n\t    \trootNS = namespaceHolder.getDocumentElement();\n\t    \trootNS.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:\"+prefix, namespace);\n    \t} catch (Exception e) {\n    \t    String err=\"Error creating a namespace holder document: \"+e.getLocalizedMessage();\n    \t    throw new TransformerException(err);\n    \t}\n    \treturn rootNS;\n\t}\n\n\t/**\n\t * Get a nodelist from an xPath\n\t * @throws TransformerException\n\t */\n\tpublic static NodeList getNodeList(Document d, String xPath) throws TransformerException{\n\t\treturn getNodeList(d.getDocumentElement(),xPath,null,null);\n\t}\n\t/**\n\t * Get a nodelist from an xPath\n\t * @throws TransformerException\n\t */\n\tpublic static NodeList getNodeList(Node contextNode, String xPath) throws TransformerException{\n\t\treturn getNodeList(contextNode,xPath,null,null);\n\t}\n\n\t/**\n\t * Get a nodelist from an xPath\n\t * @throws TransformerException\n\t */\n\tpublic static NodeList getNodeList(Node contextNode, String xPath, String namespace, String prefix) throws TransformerException{\n\t\ttry {\n\t\t    XObject xo = XPathAPI.eval(\n\t    \t\tcontextNode,\n\t\t\t\txPath,\n\t\t\t\t(namespace == null) ? contextNode : getRootElement(\"nsholder\",namespace,prefix)\n\t\t    );\n\t\t    if (xo.getType() != XObject.CLASS_NODESET) return null;\n\t\t    return xo.nodelist();\n    \t} catch (TransformerException e) {\n    \t    String err = \"Unable to get the Nodes List for xpath '\"+xPath+\"'\"\n    \t    \t+((contextNode==null) ? \"\" : \" for Node \"+contextNode.getLocalName())\n    \t\t\t+\": \"+e.getLocalizedMessage();\n    \t\tthrow new TransformerException(err);\n    \t}\n\t}\n\n    /**\n     * Returns the first Element of the Node List at xPath\n     * @param n\n     * @param xPath\n     * @return\n     * @throws XtentisWebappException\n     */\n\tpublic static Element getFirstElement(Node n, String xPath) throws TransformerException {\n\t\t\tNodeList nl = getNodeList(n, xPath);\n\t\t\tif ((nl==null) || (nl.getLength()==0)) return null;\n\t\t\treturn (Element)nl.item(0);\n\t}\n\n    public static String[] getAttributeNodeValue(Node contextNode, String xPath, Node namespaceNode) throws TransformerException{\n        String[] results;\n\n        //test for hard-coded values\n        if (xPath.startsWith(\"\\\"\") && xPath.endsWith(\"\\\"\"))\n            return new String[] { xPath.substring(1, xPath.length()-1)};\n\n        //test for incomplete path\n        //if (! xPath.endsWith(\")\")) xPath+=\"/text()\";\n\n        try {\n\t        XObject xo = XPathAPI.eval(contextNode, xPath,namespaceNode);\n\t        if (xo.getType() == XObject.CLASS_NODESET) {\n\t            NodeList l = xo.nodelist();\n\t            int len = l.getLength();\n\t            results = new String[len];\n\t            for (int i = 0; i < len; i++) {\n\t                Node n = l.item(i);\n\t                results[i] = n.getNodeValue();\n\t            }\n\t        } else {\n\t            results = new String[]{xo.toString()};\n\t        }\n\t\t} catch (TransformerException e) {\n\t\t\tString err = \"Unable to get the text node(s) of \"+xPath\n\t\t\t\t\t+\": \" + e.getClass().getName() + \": \"\n\t\t\t\t\t+ e.getLocalizedMessage();\n\t\t\tthrow new TransformerException(err);\n\t\t}\n\t\treturn results;\n    }\n\n    public static Transformer generateTransformer() throws TransformerConfigurationException {\n        return transformerFactory.newTransformer();\n    }\n\n    public static Transformer generateTransformer(boolean isOmitXmlDeclaration) throws TransformerConfigurationException {\n        Transformer transformer = generateTransformer();\n        if (isOmitXmlDeclaration) {\n            transformer.setOutputProperty(\"omit-xml-declaration\", \"yes\");\n        } else {\n            transformer.setOutputProperty(\"omit-xml-declaration\", \"no\");\n        }\n        return transformer;\n    }\n\n    public static Transformer generateTransformer(boolean isOmitXmlDeclaration, boolean isIndent)\n            throws TransformerConfigurationException {\n        Transformer transformer = generateTransformer(isOmitXmlDeclaration);\n        if (isIndent) {\n            transformer.setOutputProperty(\"indent\", \"yes\");\n        } else {\n            transformer.setOutputProperty(\"indent\", \"no\");\n        }\n        return transformer;\n    }\n\n    public static String nodeToString(Node n, boolean isOmitXmlDeclaration, boolean isIndent) throws TransformerException {\n        StringWriter sw = new StringWriter();\n        Transformer transformer = generateTransformer(isOmitXmlDeclaration, isIndent);\n        transformer.transform(new DOMSource(n), new StreamResult(sw));\n        return sw.toString();\n    }\n\n    public static String nodeToString(Node n) throws TransformerException {\n        return nodeToString(n, true, true);\n    }\n\n    public static org.dom4j.Document styleDocument(org.dom4j.Document document, String stylesheet) throws Exception {\n        // load the transformer using JAXP\n        Transformer transformer = saxonTransformerFactory.newTransformer(new StreamSource(new StringReader(stylesheet)));\n\n        // now lets style the given document\n        DocumentSource source = new DocumentSource(document);\n        DocumentResult result = new DocumentResult();\n        transformer.transform(source, result);\n\n        // return the transformed document\n        org.dom4j.Document transformedDoc = result.getDocument();\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"The xml file style transformed successfully \");\n        }\n        return transformedDoc;\n    }\n }\n", "/*\n * Copyright (C) 2006-2019 Talend Inc. - www.talend.com\n *\n * This source code is available under agreement available at\n * %InstallDIR%\\features\\org.talend.rcp.branding.%PRODUCTNAME%\\%PRODUCTNAME%license.txt\n *\n * You should have received a copy of the agreement along with this program; if not, write to Talend SA 9 rue Pages\n * 92150 Suresnes, France\n */\n\npackage com.amalto.core.storage;\n\nimport static com.amalto.core.query.user.UserQueryBuilder.eq;\nimport static com.amalto.core.query.user.UserQueryBuilder.from;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\nimport org.talend.mdm.commmon.metadata.ComplexTypeMetadata;\nimport org.talend.mdm.commmon.metadata.ContainedComplexTypeMetadata;\nimport org.talend.mdm.commmon.metadata.DefaultMetadataVisitor;\nimport org.talend.mdm.commmon.metadata.FieldMetadata;\nimport org.talend.mdm.commmon.metadata.MetadataRepository;\nimport org.talend.mdm.commmon.metadata.MetadataVisitor;\nimport org.talend.mdm.commmon.metadata.TypeMetadata;\nimport org.talend.mdm.commmon.util.core.MDMXMLUtils;\nimport org.talend.mdm.commmon.util.webapp.XSystemObjects;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.XMLReader;\n\nimport com.amalto.core.metadata.ClassRepository;\nimport com.amalto.core.objects.ObjectPOJO;\nimport com.amalto.core.query.user.Select;\nimport com.amalto.core.query.user.UserQueryBuilder;\nimport com.amalto.core.server.StorageAdmin;\nimport com.amalto.core.storage.record.DataRecord;\nimport com.amalto.core.storage.record.DataRecordReader;\nimport com.amalto.core.storage.record.XmlDOMDataRecordReader;\nimport com.amalto.core.storage.record.XmlSAXDataRecordReader;\nimport com.amalto.xmlserver.interfaces.ItemPKCriteria;\nimport com.amalto.xmlserver.interfaces.XmlServerException;\n\npublic class SystemStorageWrapper extends StorageWrapper {\n\n    private static final DocumentBuilderFactory DOCUMENT_BUILDER_FACTORY = DocumentBuilderFactory.newInstance();\n\n    private static final String SYSTEM_PREFIX = \"amaltoOBJECTS\"; //$NON-NLS-1$\n\n    private static final String CUSTOM_FORM_TYPE = \"custom-form-pOJO\"; //$NON-NLS-1$\n\n    private static final String DROPPED_ITEM_TYPE = \"dropped-item-pOJO\"; //$NON-NLS-1$\n\n    private static final String COMPLETED_ROUTING_ORDER = \"completed-routing-order-v2-pOJO\"; //$NON-NLS-1$\n\n    private static final String FAILED_ROUTING_ORDER = \"failed-routing-order-v2-pOJO\"; //$NON-NLS-1$\n\n    private static final String SYNCHRONIZATION_OBJECT_TYPE = \"synchronization-object-pOJO\"; //$NON-NLS-1$\n\n    private static final String BROWSEITEM_PREFIX_INFO = \"SearchTemplate.BrowseItem.\"; //$NON-NLS-1$\n\n    private static final Logger LOGGER = LogManager.getLogger(SystemStorageWrapper.class);\n\n    public SystemStorageWrapper() {\n        try {\n            DOCUMENT_BUILDER_FACTORY.setNamespaceAware(true);\n            DOCUMENT_BUILDER_FACTORY.setFeature(MDMXMLUtils.FEATURE_DISALLOW_DOCTYPE, true);\n        } catch (ParserConfigurationException e) {\n            throw new RuntimeException(\"Unable to initialize document builder.\", e);\n        }\n        // Create \"system\" storage\n        StorageAdmin admin = getStorageAdmin();\n        if (!admin.exist(StorageAdmin.SYSTEM_STORAGE, StorageType.SYSTEM)) {\n            String datasource = admin.getDatasource(StorageAdmin.SYSTEM_STORAGE);\n            admin.create(StorageAdmin.SYSTEM_STORAGE, StorageAdmin.SYSTEM_STORAGE, StorageType.SYSTEM, datasource);\n        }\n    }\n\n    private ComplexTypeMetadata getType(String clusterName, Storage storage, String uniqueID) {\n        MetadataRepository repository = storage.getMetadataRepository();\n        if (uniqueID != null && uniqueID.startsWith(\"amalto_local_service_\")) { //$NON-NLS-1$\n            return repository.getComplexType(\"service-bMP\"); //$NON-NLS-1$\n        }\n        if (clusterName.startsWith(SYSTEM_PREFIX) || clusterName.startsWith(\"amalto\")) { //$NON-NLS-1$\n            if (!\"amaltoOBJECTSservices\".equals(clusterName)) { //$NON-NLS-1$\n                return repository.getComplexType(ClassRepository.format(clusterName.substring(SYSTEM_PREFIX.length()) + \"POJO\")); //$NON-NLS-1$\n            } else {\n                return repository.getComplexType(ClassRepository.format(clusterName.substring(SYSTEM_PREFIX.length())));\n            }\n        }\n        if (XSystemObjects.DC_MDMITEMSTRASH.getName().equals(clusterName)) {\n            return repository.getComplexType(DROPPED_ITEM_TYPE);\n        } else if (XSystemObjects.DC_PROVISIONING.getName().equals(clusterName)) {\n            String typeName = getTypeName(uniqueID);\n            if (\"Role\".equals(typeName)) { //$NON-NLS-1$\n                return repository.getComplexType(\"role-pOJO\"); //$NON-NLS-1$\n            }\n            return repository.getComplexType(typeName);\n        } else if (\"MDMDomainObjects\".equals(clusterName) || \"MDMItemImages\".equals(clusterName) || \"FailedAutoCommitSvnMessage\".equals(clusterName)) { //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n            return null; // Documents for these clusters don't have a predefined structure.\n        }\n        // No id, so no type to be read.\n        if (uniqueID == null) {\n            return null;\n        }\n        // MIGRATION.completed.record\n        return repository.getComplexType(getTypeName(uniqueID));\n    }\n\n    @Override\n    public List<String> getItemPKsByCriteria(ItemPKCriteria criteria) throws XmlServerException {\n        String clusterName = criteria.getClusterName();\n        Storage storage = getStorage(clusterName);\n        MetadataRepository repository = storage.getMetadataRepository();\n\n        int totalCount = 0;\n        List<String> itemPKResults = new LinkedList<String>();\n        String typeName = criteria.getConceptName();\n\n        try {\n            storage.begin();\n            if (typeName != null && !typeName.isEmpty()) {\n                String internalTypeName = typeName;\n                String objectRootElementName = ObjectPOJO.getObjectRootElementName(typeName);\n                if (objectRootElementName != null) {\n                    internalTypeName = objectRootElementName;\n                }\n                totalCount = getTypeItemCount(criteria, repository.getComplexType(internalTypeName), storage);\n                itemPKResults.addAll(getTypeItems(criteria, repository.getComplexType(internalTypeName), storage, typeName));\n            } else {\n                // TMDM-4651: Returns type in correct dependency order.\n                Collection<ComplexTypeMetadata> types = getClusterTypes(clusterName);\n                int maxCount = criteria.getMaxItems();\n                if (criteria.getSkip() < 0) { // MDM Studio may send negative values\n                    criteria.setSkip(0);\n                }\n                List<String> currentInstanceResults;\n                String objectRootElementName;\n                for (ComplexTypeMetadata type : types) {\n                    String internalTypeName = type.getName();\n                    objectRootElementName = ObjectPOJO.getObjectRootElementName(internalTypeName);\n                    if (objectRootElementName != null) {\n                        internalTypeName = objectRootElementName;\n                    }\n                    int count = getTypeItemCount(criteria, repository.getComplexType(internalTypeName), storage);\n                    totalCount += count;\n                    if (itemPKResults.size() < maxCount) {\n                        if (count > criteria.getSkip()) {\n                            currentInstanceResults = getTypeItems(criteria, repository.getComplexType(internalTypeName), storage,\n                                    type.getName());\n                            int n = maxCount - itemPKResults.size();\n                            if (n <= currentInstanceResults.size()) {\n                                itemPKResults.addAll(currentInstanceResults.subList(0, n));\n                            } else {\n                                itemPKResults.addAll(currentInstanceResults);\n                            }\n                            criteria.setMaxItems(criteria.getMaxItems() - currentInstanceResults.size());\n                            criteria.setSkip(0);\n                        } else {\n                            criteria.setSkip(criteria.getSkip() - count);\n                        }\n                    }\n                }\n            }\n            itemPKResults.add(0, \"<totalCount>\" + totalCount + \"</totalCount>\"); //$NON-NLS-1$ //$NON-NLS-2$\n        } finally {\n            storage.commit();\n        }\n        return itemPKResults;\n    }\n\n    @Override\n    protected Storage getStorage(String dataClusterName) {\n        return storageAdmin.get(StorageAdmin.SYSTEM_STORAGE, StorageType.SYSTEM);\n    }\n\n    @Override\n    public long deleteCluster(String clusterName) throws XmlServerException {\n        return 0;\n    }\n\n    @Override\n    public String[] getAllClusters() throws XmlServerException {\n        Set<String> internalClusterNames = DispatchWrapper.getInternalClusterNames();\n        return internalClusterNames.toArray(new String[internalClusterNames.size()]);\n    }\n\n    @Override\n    public long deleteAllClusters() throws XmlServerException {\n        return 0;\n    }\n\n    @Override\n    public long createCluster(String clusterName) throws XmlServerException {\n        return 0;\n    }\n\n    @Override\n    public boolean existCluster(String cluster) throws XmlServerException {\n        return true;\n    }\n\n    @Override\n    protected Collection<ComplexTypeMetadata> getClusterTypes(String clusterName) {\n        Storage storage = getStorage(clusterName);\n        MetadataRepository repository = storage.getMetadataRepository();\n        return filter(repository, clusterName);\n    }\n\n    public static Collection<ComplexTypeMetadata> filter(MetadataRepository repository, String clusterName) {\n        if (clusterName.startsWith(SYSTEM_PREFIX) || clusterName.startsWith(\"amalto\")) { //$NON-NLS-1$\n            if (!\"amaltoOBJECTSservices\".equals(clusterName)) { //$NON-NLS-1$\n                final String className = ClassRepository.format(clusterName.substring(SYSTEM_PREFIX.length()) + \"POJO\"); //$NON-NLS-1$\n                return filterRepository(repository, className);\n            } else {\n                final String className = ClassRepository.format(clusterName.substring(SYSTEM_PREFIX.length()));\n                return filterRepository(repository, className);\n            }\n        } else if (XSystemObjects.DC_MDMITEMSTRASH.getName().equals(clusterName)) {\n            return filterRepository(repository, DROPPED_ITEM_TYPE);\n        } else if (XSystemObjects.DC_CONF.getName().equals(clusterName)) {\n            return filterRepository(repository, \"Conf\", \"AutoIncrement\"); //$NON-NLS-1$ //$NON-NLS-2$\n        } else if (XSystemObjects.DC_CROSSREFERENCING.getName().equals(clusterName)) {\n            return Collections.emptyList(); // TODO Support crossreferencing\n        } else if (XSystemObjects.DC_PROVISIONING.getName().equals(clusterName)) {\n            return filterRepository(repository, \"User\", \"Role\"); //$NON-NLS-1$ //$NON-NLS-2$\n        } else if (XSystemObjects.DC_SEARCHTEMPLATE.getName().equals(clusterName)) {\n            return filterRepository(repository, \"BrowseItem\", \"HierarchySearchItem\"); //$NON-NLS-1$ //$NON-NLS-2$\n        } else {\n            return repository.getUserComplexTypes();\n        }\n    }\n\n    private static Collection<ComplexTypeMetadata> filterRepository(MetadataRepository repository, String... typeNames) {\n        final Set<ComplexTypeMetadata> filteredTypes = new HashSet<ComplexTypeMetadata>();\n        MetadataVisitor<Void> transitiveTypeClosure = new DefaultMetadataVisitor<Void>() {\n\n            private final Set<TypeMetadata> visitedTypes = new HashSet<>();\n\n            @Override\n            public Void visit(ComplexTypeMetadata complexType) {\n                if (!visitedTypes.add(complexType)) {\n                    return null;\n                }\n                if (complexType.isInstantiable()) {\n                    filteredTypes.add(complexType);\n                }\n                return super.visit(complexType);\n            }\n\n            @Override\n            public Void visit(ContainedComplexTypeMetadata containedType) {\n                if (!visitedTypes.add(containedType)) {\n                    return null;\n                }\n                if (containedType.isInstantiable()) {\n                    filteredTypes.add(containedType);\n                }\n                return super.visit(containedType);\n            }\n        };\n        for (String typeName : typeNames) {\n            ComplexTypeMetadata type = repository.getComplexType(typeName);\n            if (type != null) {\n                type.accept(transitiveTypeClosure);\n            }\n        }\n        return filteredTypes;\n    }\n\n    @Override\n    public String[] getAllDocumentsUniqueID(String clusterName) throws XmlServerException {\n        String pureClusterName = getPureClusterName(clusterName);\n        boolean includeClusterAndTypeName = getClusterTypes(pureClusterName).size() > 1;\n        return getAllDocumentsUniqueID(clusterName, includeClusterAndTypeName, false);\n    }\n\n    @Override\n    public String[] getAllDocumentsUniqueID(String clusterName, final boolean ignoreChild) throws XmlServerException {\n        String pureClusterName = getPureClusterName(clusterName);\n        boolean includeClusterAndTypeName = getClusterTypes(pureClusterName).size() > 1;\n        return getAllDocumentsUniqueID(clusterName, includeClusterAndTypeName, ignoreChild);\n    }\n\n    @Override\n    public long putDocumentFromDOM(Element root, String uniqueID, String clusterName) throws XmlServerException {\n        long start = System.currentTimeMillis();\n        {\n            DataRecordReader<Element> reader = new XmlDOMDataRecordReader();\n            Storage storage = getStorage(clusterName);\n            ComplexTypeMetadata type = getType(clusterName, storage, uniqueID);\n            if (type == null) {\n                return -1; // TODO\n            }\n            MetadataRepository repository = storage.getMetadataRepository();\n            DataRecord record = reader.read(repository, type, root);\n            for (FieldMetadata keyField : type.getKeyFields()) {\n                if (record.get(keyField) == null) {\n                    LOGGER.warn(\"Ignoring update for record '\" + uniqueID + \"' (does not provide key information).\"); //$NON-NLS-1$ //$NON-NLS-2$\n                    return 0;\n                }\n            }\n            storage.update(record);\n        }\n        return System.currentTimeMillis() - start;\n    }\n\n    @Override\n    public long putDocumentFromSAX(String dataClusterName, XMLReader docReader, InputSource input) throws XmlServerException {\n        long start = System.currentTimeMillis();\n        {\n            Storage storage = getStorage(dataClusterName);\n            ComplexTypeMetadata type = getType(dataClusterName, storage, input.getPublicId());\n            if (type == null) {\n                return -1; // TODO\n            }\n            DataRecordReader<XmlSAXDataRecordReader.Input> reader = new XmlSAXDataRecordReader();\n            XmlSAXDataRecordReader.Input readerInput = new XmlSAXDataRecordReader.Input(docReader, input);\n            DataRecord record = reader.read(storage.getMetadataRepository(), type, readerInput);\n            storage.update(record);\n        }\n        return System.currentTimeMillis() - start;\n    }\n\n    @Override\n    public long putDocumentFromString(String xmlString, String uniqueID, String clusterName) throws XmlServerException {\n        return putDocumentFromString(xmlString, uniqueID, clusterName, null);\n    }\n\n    @Override\n    public long putDocumentFromString(String xmlString, String uniqueID, String clusterName, String documentType)\n            throws XmlServerException {\n        try {\n            InputSource source = new InputSource(new StringReader(xmlString));\n            Document document = MDMXMLUtils.getDocumentBuilderWithNamespace().get().parse(source);\n            return putDocumentFromDOM(document.getDocumentElement(), uniqueID, clusterName);\n        } catch (Exception e) {\n            throw new XmlServerException(e);\n        }\n    }\n\n    @Override\n    public String getDocumentAsString(String clusterName, String uniqueID) throws XmlServerException {\n        return getDocumentAsString(clusterName, uniqueID, \"UTF-8\"); //$NON-NLS-1$\n    }\n\n    @Override\n    public String getDocumentAsString(String clusterName, String uniqueID, String encoding) throws XmlServerException {\n        if (encoding == null) {\n            encoding = \"UTF-8\"; //$NON-NLS-1$\n        }\n        Storage storage = getStorage(clusterName);\n        ComplexTypeMetadata type = getType(clusterName, storage, uniqueID);\n        if (type == null) {\n            return null; // TODO\n        }\n        UserQueryBuilder qb;\n        boolean isUserFormat = false;\n        String documentUniqueID;\n        if (DROPPED_ITEM_TYPE.equals(type.getName())) {\n            // head.Product.Product.0- (but DM1.Bird.bid3)\n            if (uniqueID.endsWith(\"-\")) { //$NON-NLS-1$\n                uniqueID = uniqueID.substring(0, uniqueID.length() - 1);\n            }\n            // TODO Code may not correctly handle composite id (but no system objects use this)\n            documentUniqueID = uniqueID;\n            if (StringUtils.countMatches(uniqueID, \".\") >= 3) { //$NON-NLS-1$\n                documentUniqueID = StringUtils.substringAfter(uniqueID, \".\"); //$NON-NLS-1$\n            }\n        } else if (COMPLETED_ROUTING_ORDER.equals(type.getName()) || FAILED_ROUTING_ORDER.equals(type.getName())) {\n            documentUniqueID = uniqueID;\n        } else {\n            // TMDM-5513 custom form layout pk contains double dot .. to split, but it's a system definition object\n            // like this Product..Product..product_layout\n            isUserFormat = !uniqueID.contains(\"..\") && uniqueID.indexOf('.') > 0; //$NON-NLS-1$\n            documentUniqueID = uniqueID;\n            if (uniqueID.startsWith(PROVISIONING_PREFIX_INFO)) {\n                documentUniqueID = StringUtils.substringAfter(uniqueID, PROVISIONING_PREFIX_INFO);\n            } else if (uniqueID.startsWith(BROWSEITEM_PREFIX_INFO)) {\n                documentUniqueID = StringUtils.substringAfter(uniqueID, BROWSEITEM_PREFIX_INFO);\n            } else if (isUserFormat) {\n                documentUniqueID = StringUtils.substringAfterLast(uniqueID, \".\"); //$NON-NLS-1$\n            }\n        }\n        qb = from(type).where(eq(type.getKeyFields().iterator().next(), documentUniqueID));\n        StorageResults results = null;\n        try {\n            storage.begin();\n            results = storage.fetch(qb.getSelect());\n            String xmlString = getXmlString(clusterName, type, results.iterator(), uniqueID, encoding, isUserFormat);\n            storage.commit();\n            return xmlString;\n        } catch (IOException e) {\n            storage.rollback();\n            throw new XmlServerException(e);\n        } finally {\n            if (results != null) {\n                results.close();\n            }\n        }\n    }\n\n    @Override\n    public long deleteDocument(String clusterName, String uniqueID, String documentType) throws XmlServerException {\n        Storage storage = getStorage(clusterName);\n        ComplexTypeMetadata type = getType(clusterName, storage, uniqueID);\n        if (type == null) {\n            return -1;\n        }\n        if (DROPPED_ITEM_TYPE.equals(type.getName())) {\n            // head.Product.Product.0-\n            uniqueID = uniqueID.substring(0, uniqueID.length() - 1);\n            uniqueID = StringUtils.substringAfter(uniqueID, \".\"); //$NON-NLS-1$\n        } else if (!COMPLETED_ROUTING_ORDER.equals(type.getName()) && !FAILED_ROUTING_ORDER.equals(type.getName())\n                && !CUSTOM_FORM_TYPE.equals(type.getName()) && !SYNCHRONIZATION_OBJECT_TYPE.equals(type.getName())) {\n            if (uniqueID.startsWith(PROVISIONING_PREFIX_INFO)) {\n                uniqueID = StringUtils.substringAfter(uniqueID, PROVISIONING_PREFIX_INFO);\n            } else if (uniqueID.startsWith(BROWSEITEM_PREFIX_INFO)) {\n                uniqueID = StringUtils.substringAfter(uniqueID, BROWSEITEM_PREFIX_INFO);\n            } else if (uniqueID.contains(\".\")) { //$NON-NLS-1$\n                uniqueID = StringUtils.substringAfterLast(uniqueID, \".\"); //$NON-NLS-1$\n            }\n        }\n        long start = System.currentTimeMillis();\n        {\n            UserQueryBuilder qb = from(type).where(eq(type.getKeyFields().iterator().next(), uniqueID));\n            StorageResults results = null;\n            try {\n                storage.begin();\n                Select select = qb.getSelect();\n                results = storage.fetch(select);\n                if (results.getCount() == 0) {\n                    throw new IllegalArgumentException(\"Could not find document to delete.\"); //$NON-NLS-1$\n                }\n                storage.delete(select);\n                storage.commit();\n            } catch (Exception e) {\n                storage.rollback();\n                throw new XmlServerException(e);\n            } finally {\n                if (results != null) {\n                    results.close();\n                }\n            }\n        }\n        return System.currentTimeMillis() - start;\n    }\n\n    @Override\n    public String[] getDocumentsAsString(String clusterName, String[] uniqueIDs) throws XmlServerException {\n        return getDocumentsAsString(clusterName, uniqueIDs, \"UTF-8\"); //$NON-NLS-1$\n    }\n\n    @Override\n    public String[] getDocumentsAsString(String clusterName, String[] uniqueIDs, String encoding) throws XmlServerException {\n        if (uniqueIDs == null || uniqueIDs.length == 0) {\n            return new String[0];\n        }\n        List<String> xmlStrings = new ArrayList<String>(uniqueIDs.length);\n        for (String uniqueID : uniqueIDs) {\n            xmlStrings.add(getDocumentAsString(clusterName, uniqueID, encoding));\n        }\n        return xmlStrings.toArray(new String[xmlStrings.size()]);\n    }\n}\n"], "filenames": ["org.talend.mdm.commons.core/src/com/amalto/commons/core/utils/XMLUtils.java", "org.talend.mdm.core/src/com/amalto/core/storage/SystemStorageWrapper.java"], "buggy_code_start_loc": [82, 26], "buggy_code_end_loc": [82, 79], "fixing_code_start_loc": [83, 27], "fixing_code_end_loc": [84, 85], "type": "CWE-611", "message": "A vulnerability was found in Talend Open Studio for MDM. It has been declared as problematic. Affected by this vulnerability is an unknown functionality of the file org.talend.mdm.core/src/com/amalto/core/storage/SystemStorageWrapper.java. The manipulation leads to xml external entity reference. Upgrading to version 20221220_1938 is able to address this issue. The name of the patch is 95590db2ad6a582c371273ceab1a73ad6ed47853. It is recommended to upgrade the affected component. The identifier VDB-216997 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-4818", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-28T21:15:10.487", "lastModified": "2023-01-06T15:33:42.057", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Talend Open Studio for MDM. It has been declared as problematic. Affected by this vulnerability is an unknown functionality of the file org.talend.mdm.core/src/com/amalto/core/storage/SystemStorageWrapper.java. The manipulation leads to xml external entity reference. Upgrading to version 20221220_1938 is able to address this issue. The name of the patch is 95590db2ad6a582c371273ceab1a73ad6ed47853. It is recommended to upgrade the affected component. The identifier VDB-216997 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:talend:open_studio_for_mdm:*:*:*:*:*:*:*:*", "versionEndExcluding": "20221220_1938", "matchCriteriaId": "C2746E07-0BC8-4A01-9D56-259DC9F087C0"}]}]}], "references": [{"url": "https://github.com/Talend/tmdm-server-se/commit/95590db2ad6a582c371273ceab1a73ad6ed47853", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Talend/tmdm-server-se/pull/1598", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Talend/tmdm-server-se/releases/tag/snap%2Fmaster%2F20221220_1938", "source": "cna@vuldb.com", "tags": ["Broken Link", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216997", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216997", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Talend/tmdm-server-se/commit/95590db2ad6a582c371273ceab1a73ad6ed47853"}}