{"buggy_code": ["/* (c) 2014 Open Source Geospatial Foundation - all rights reserved\n * (c) 2001 - 2013 OpenPlans\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcconfig.internal;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Throwables.throwIfUnchecked;\nimport static org.geoserver.catalog.CatalogFacade.ANY_WORKSPACE;\nimport static org.geoserver.catalog.Predicates.and;\nimport static org.geoserver.catalog.Predicates.equal;\nimport static org.geoserver.catalog.Predicates.isNull;\nimport static org.geoserver.jdbcconfig.internal.DbUtils.logStatement;\nimport static org.geoserver.jdbcconfig.internal.DbUtils.params;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Iterators;\nimport com.google.common.collect.Lists;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Serializable;\nimport java.lang.reflect.Proxy;\nimport java.nio.charset.StandardCharsets;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\nimport javax.annotation.Nullable;\nimport javax.sql.DataSource;\nimport org.apache.commons.collections.CollectionUtils;\nimport org.apache.commons.collections.Predicate;\nimport org.geoserver.catalog.Catalog;\nimport org.geoserver.catalog.CatalogInfo;\nimport org.geoserver.catalog.CatalogVisitor;\nimport org.geoserver.catalog.CoverageInfo;\nimport org.geoserver.catalog.CoverageStoreInfo;\nimport org.geoserver.catalog.DataStoreInfo;\nimport org.geoserver.catalog.FeatureTypeInfo;\nimport org.geoserver.catalog.Info;\nimport org.geoserver.catalog.LayerGroupInfo;\nimport org.geoserver.catalog.LayerInfo;\nimport org.geoserver.catalog.MetadataMap;\nimport org.geoserver.catalog.NamespaceInfo;\nimport org.geoserver.catalog.Predicates;\nimport org.geoserver.catalog.PublishedInfo;\nimport org.geoserver.catalog.ResourceInfo;\nimport org.geoserver.catalog.StoreInfo;\nimport org.geoserver.catalog.StyleInfo;\nimport org.geoserver.catalog.WMSLayerInfo;\nimport org.geoserver.catalog.WMSStoreInfo;\nimport org.geoserver.catalog.WMTSLayerInfo;\nimport org.geoserver.catalog.WMTSStoreInfo;\nimport org.geoserver.catalog.WorkspaceInfo;\nimport org.geoserver.catalog.event.CatalogAddEvent;\nimport org.geoserver.catalog.event.CatalogListener;\nimport org.geoserver.catalog.event.CatalogModifyEvent;\nimport org.geoserver.catalog.event.CatalogPostModifyEvent;\nimport org.geoserver.catalog.event.CatalogRemoveEvent;\nimport org.geoserver.catalog.impl.CatalogImpl;\nimport org.geoserver.catalog.impl.ClassMappings;\nimport org.geoserver.catalog.impl.ModificationProxy;\nimport org.geoserver.catalog.impl.ResourceInfoImpl;\nimport org.geoserver.catalog.impl.StoreInfoImpl;\nimport org.geoserver.catalog.impl.StyleInfoImpl;\nimport org.geoserver.catalog.util.CloseableIterator;\nimport org.geoserver.catalog.util.CloseableIteratorAdapter;\nimport org.geoserver.config.ConfigurationListenerAdapter;\nimport org.geoserver.config.GeoServer;\nimport org.geoserver.config.GeoServerInfo;\nimport org.geoserver.config.LoggingInfo;\nimport org.geoserver.config.ServiceInfo;\nimport org.geoserver.config.SettingsInfo;\nimport org.geoserver.config.impl.CoverageAccessInfoImpl;\nimport org.geoserver.config.impl.GeoServerInfoImpl;\nimport org.geoserver.config.impl.JAIInfoImpl;\nimport org.geoserver.ows.util.OwsUtils;\nimport org.geoserver.platform.ExtensionPriority;\nimport org.geoserver.platform.resource.Resource;\nimport org.geoserver.util.CacheProvider;\nimport org.geoserver.util.DefaultCacheProvider;\nimport org.geotools.factory.CommonFactoryFinder;\nimport org.geotools.filter.visitor.SimplifyingFilterVisitor;\nimport org.geotools.util.Converters;\nimport org.geotools.util.logging.Logging;\nimport org.opengis.filter.Filter;\nimport org.opengis.filter.FilterFactory;\nimport org.opengis.filter.PropertyIsEqualTo;\nimport org.opengis.filter.expression.Literal;\nimport org.opengis.filter.expression.PropertyName;\nimport org.opengis.filter.sort.SortBy;\nimport org.springframework.beans.BeansException;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.dao.DataAccessException;\nimport org.springframework.dao.EmptyResultDataAccessException;\nimport org.springframework.jdbc.core.ResultSetExtractor;\nimport org.springframework.jdbc.core.RowMapper;\nimport org.springframework.jdbc.core.namedparam.MapSqlParameterSource;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\nimport org.springframework.jdbc.support.GeneratedKeyHolder;\nimport org.springframework.jdbc.support.KeyHolder;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.util.Assert;\n\n/**\n * Stores and retrieves actual {@link CatalogInfo} and {@link ServiceInfo} from the underlying\n * database, with an in memory cache for both objects.\n *\n * <p><b>Important implementation notes</b> This bean is annotated with {@link Transactional} in all\n * write methods and all exposed read methods. The write methods are obvious, the read ones less so.\n * The reads load XML from the database and use XStream to decode it. This can cause references to\n * object related objects to be resolved, which happen by calling again onto the catalog, the facade\n * and eventually again this class. Using a read only transaction around the read methods ensures\n * that a single connection is used in this process, which prevents deadlock at the connection pool\n * level. Also, methods returning a {@link CloseableIterator} of info objects just look up the\n * identifier, and resolve them to full objects during the iteration. This lazy loading also needs\n * to be protected by transactional loading, which is tricky. A trivial implementation would just\n * call itself, which ends up bypassing the transaction annotations (which are implemented as a\n * proxy around the object). To avoid deadlocks there, the {@link ConfigDatabase} also loads itself\n * from the application context, with full transactional proxying, and uses that instance for\n * deferred loading while iterating.\n */\npublic class ConfigDatabase implements ApplicationContextAware {\n\n    public static final Logger LOGGER = Logging.getLogger(ConfigDatabase.class);\n\n    private static final int LOCK_TIMEOUT_SECONDS = 60;\n\n    private Dialect dialect;\n\n    private DataSource dataSource;\n\n    private DbMappings dbMappings;\n\n    private CatalogImpl catalog;\n\n    private GeoServer geoServer;\n\n    private NamedParameterJdbcOperations template;\n\n    private XStreamInfoSerialBinding binding;\n\n    private Cache<String, Info> cache;\n\n    private Cache<InfoIdentity, String> identityCache;\n\n    private Cache<ServiceIdentity, ServiceInfo> serviceCache;\n\n    private InfoRowMapper<CatalogInfo> catalogRowMapper;\n\n    private InfoRowMapper<Info> configRowMapper;\n\n    private ConfigClearingListener configListener;\n\n    private ConcurrentMap<String, Semaphore> locks;\n\n    // transaction management works only if the method\n    // is called from a Spring proxy that processed the annotations,\n    // so we cannot call getId directly, it needs to be done from\n    // \"outside\"\n    /* the bean itself, but with the transactional proxy wrappers around */\n    private ConfigDatabase transactionalConfigDatabase;\n\n    /** Protected default constructor needed by spring-jdbc instrumentation */\n    protected ConfigDatabase() {\n        //\n    }\n\n    public ConfigDatabase(final DataSource dataSource, final XStreamInfoSerialBinding binding) {\n        this(dataSource, binding, null);\n    }\n\n    public ConfigDatabase(\n            final DataSource dataSource,\n            final XStreamInfoSerialBinding binding,\n            CacheProvider cacheProvider) {\n\n        this.binding = binding;\n        this.template = new NamedParameterJdbcTemplate(dataSource);\n        // cannot use dataSource at this point due to spring context config hack\n        // in place to support tx during testing\n        this.dataSource = dataSource;\n\n        this.catalogRowMapper = new InfoRowMapper<CatalogInfo>(CatalogInfo.class, binding);\n        this.configRowMapper = new InfoRowMapper<Info>(Info.class, binding);\n\n        if (cacheProvider == null) {\n            cacheProvider = DefaultCacheProvider.findProvider();\n        }\n        cache = cacheProvider.getCache(\"catalog\");\n        identityCache = cacheProvider.getCache(\"catalogNames\");\n        serviceCache = cacheProvider.getCache(\"services\");\n        locks = new ConcurrentHashMap<>();\n    }\n\n    private Dialect dialect() {\n        if (dialect == null) {\n            this.dialect = Dialect.detect(dataSource);\n        }\n        return dialect;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            rollbackFor = Exception.class)\n    public void initDb(@Nullable Resource resource) throws IOException {\n        this.dbMappings = new DbMappings(dialect());\n        if (resource != null) {\n            runInitScript(resource);\n        }\n        dbMappings.initDb(template);\n    }\n\n    private void runInitScript(Resource resource) throws IOException {\n\n        LOGGER.info(\n                \"------------- Running catalog database init script \"\n                        + resource.path()\n                        + \" ------------\");\n\n        try (InputStream in = resource.in()) {\n            Util.runScript(in, template.getJdbcOperations(), LOGGER);\n        }\n\n        LOGGER.info(\"Initialization SQL script run sucessfully\");\n    }\n\n    public DbMappings getDbMappings() {\n        return dbMappings;\n    }\n\n    /**\n     * CatalogClearingListener listener will be added to CatalogImpl when CatalogImpl is set, and\n     * CatalogImpl's addListener method will sort the listener\n     *\n     * @param catalog\n     */\n    public void setCatalog(CatalogImpl catalog) {\n        this.catalog = catalog;\n        this.binding.setCatalog(catalog);\n\n        catalog.removeListeners(CatalogClearingListener.class);\n        catalog.addListener(new CatalogClearingListener());\n    }\n\n    public CatalogImpl getCatalog() {\n        return this.catalog;\n    }\n\n    public void setGeoServer(GeoServer geoServer) {\n        this.geoServer = geoServer;\n\n        if (configListener != null) geoServer.removeListener(configListener);\n        configListener = new ConfigClearingListener();\n        geoServer.addListener(configListener);\n    }\n\n    public GeoServer getGeoServer() {\n        return geoServer;\n    }\n\n    public <T extends CatalogInfo> int count(final Class<T> of, final Filter filter) {\n\n        QueryBuilder<T> sqlBuilder = QueryBuilder.forCount(dialect, of, dbMappings).filter(filter);\n\n        final StringBuilder sql = sqlBuilder.build();\n        final Filter unsupportedFilter = sqlBuilder.getUnsupportedFilter();\n        final boolean fullySupported = Filter.INCLUDE.equals(unsupportedFilter);\n        if (LOGGER.isLoggable(Level.FINER)) {\n            LOGGER.finer(\"Original filter: \" + filter);\n            LOGGER.finer(\"Supported filter: \" + sqlBuilder.getSupportedFilter());\n            LOGGER.finer(\"Unsupported filter: \" + sqlBuilder.getUnsupportedFilter());\n        }\n        final int count;\n        if (fullySupported) {\n            final Map<String, Object> namedParameters = sqlBuilder.getNamedParameters();\n            logStatement(sql, namedParameters);\n\n            count = template.queryForObject(sql.toString(), namedParameters, Integer.class);\n        } else {\n            LOGGER.fine(\n                    \"Filter is not fully supported, doing scan of supported part to return the number of matches\");\n            // going the expensive route, filtering as much as possible\n            CloseableIterator<T> iterator = query(of, filter, null, null, (SortBy) null);\n            try {\n                return Iterators.size(iterator);\n            } finally {\n                iterator.close();\n            }\n        }\n        return count;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> CloseableIterator<T> query(\n            final Class<T> of,\n            final Filter filter,\n            @Nullable Integer offset,\n            @Nullable Integer limit,\n            @Nullable SortBy sortOrder) {\n        if (sortOrder == null) {\n            return query(of, filter, offset, limit);\n        } else {\n            return query(of, filter, offset, limit, sortOrder);\n        }\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> CloseableIterator<T> query(\n            final Class<T> of,\n            final Filter filter,\n            @Nullable Integer offset,\n            @Nullable Integer limit,\n            @Nullable SortBy... sortOrder) {\n\n        checkNotNull(of);\n        checkNotNull(filter);\n        checkArgument(offset == null || offset.intValue() >= 0);\n        checkArgument(limit == null || limit.intValue() >= 0);\n\n        QueryBuilder<T> sqlBuilder =\n                QueryBuilder.forIds(dialect, of, dbMappings)\n                        .filter(filter)\n                        .offset(offset)\n                        .limit(limit)\n                        .sortOrder(sortOrder);\n        final StringBuilder sql = sqlBuilder.build();\n\n        List<String> ids = null;\n\n        final SimplifyingFilterVisitor filterSimplifier = new SimplifyingFilterVisitor();\n        final Filter simplifiedFilter =\n                (Filter) sqlBuilder.getSupportedFilter().accept(filterSimplifier, null);\n        if (simplifiedFilter instanceof PropertyIsEqualTo) {\n            PropertyIsEqualTo isEqualTo = (PropertyIsEqualTo) simplifiedFilter;\n            if (isEqualTo.getExpression1() instanceof PropertyName\n                    && isEqualTo.getExpression2() instanceof Literal\n                    && ((PropertyName) isEqualTo.getExpression1()).getPropertyName().equals(\"id\")) {\n                ids =\n                        Collections.singletonList(\n                                ((Literal) isEqualTo.getExpression2()).getValue().toString());\n            }\n            if (isEqualTo.getExpression2() instanceof PropertyName\n                    && isEqualTo.getExpression1() instanceof Literal\n                    && ((PropertyName) isEqualTo.getExpression2()).getPropertyName().equals(\"id\")) {\n                ids =\n                        Collections.singletonList(\n                                ((Literal) isEqualTo.getExpression1()).getValue().toString());\n            }\n        }\n\n        final Filter unsupportedFilter = sqlBuilder.getUnsupportedFilter();\n        final boolean fullySupported = Filter.INCLUDE.equals(unsupportedFilter);\n\n        if (ids == null) {\n            final Map<String, Object> namedParameters = sqlBuilder.getNamedParameters();\n\n            if (LOGGER.isLoggable(Level.FINER)) {\n                LOGGER.finer(\"Original filter: \" + filter);\n                LOGGER.finer(\"Supported filter: \" + sqlBuilder.getSupportedFilter());\n                LOGGER.finer(\"Unsupported filter: \" + sqlBuilder.getUnsupportedFilter());\n            }\n            logStatement(sql, namedParameters);\n\n            Stopwatch sw = Stopwatch.createStarted();\n            // the oracle offset/limit implementation returns a two column result set\n            // with rownum in the 2nd - queryForList will throw an exception\n            ids =\n                    template.query(\n                            sql.toString(),\n                            namedParameters,\n                            new RowMapper<String>() {\n                                @Override\n                                public String mapRow(ResultSet rs, int rowNum) throws SQLException {\n                                    return rs.getString(1);\n                                }\n                            });\n            sw.stop();\n            if (LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine(\n                        Joiner.on(\"\")\n                                .join(\n                                        \"query returned \",\n                                        ids.size(),\n                                        \" records in \",\n                                        sw.toString()));\n            }\n        }\n\n        List<T> lazyTransformed =\n                Lists.transform(\n                        ids,\n                        new Function<String, T>() {\n                            @Nullable\n                            @Override\n                            public T apply(String id) {\n                                return getById(id, of);\n                            }\n                        });\n\n        CloseableIterator<T> result;\n        Iterator<T> iterator =\n                Iterators.filter(\n                        lazyTransformed.iterator(), com.google.common.base.Predicates.notNull());\n\n        if (fullySupported) {\n            result = new CloseableIteratorAdapter<T>(iterator);\n        } else {\n            // Apply the filter\n            result = CloseableIteratorAdapter.filter(iterator, filter);\n            // The offset and limit should not have been applied as part of the query\n            assert (!sqlBuilder.isOffsetLimitApplied());\n            // Apply offset and limits after filtering\n            result = applyOffsetLimit(result, offset, limit);\n        }\n\n        return result;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> CloseableIterator<String> queryIds(\n            final Class<T> of, final Filter filter) {\n\n        checkNotNull(of);\n        checkNotNull(filter);\n\n        QueryBuilder<T> sqlBuilder = QueryBuilder.forIds(dialect, of, dbMappings).filter(filter);\n\n        final StringBuilder sql = sqlBuilder.build();\n        final Map<String, Object> namedParameters = sqlBuilder.getNamedParameters();\n        final Filter unsupportedFilter = sqlBuilder.getUnsupportedFilter();\n        final boolean fullySupported = Filter.INCLUDE.equals(unsupportedFilter);\n\n        if (LOGGER.isLoggable(Level.FINER)) {\n            LOGGER.finer(\"Original filter: \" + filter);\n            LOGGER.finer(\"Supported filter: \" + sqlBuilder.getSupportedFilter());\n            LOGGER.finer(\"Unsupported filter: \" + sqlBuilder.getUnsupportedFilter());\n        }\n        logStatement(sql, namedParameters);\n\n        Stopwatch sw = Stopwatch.createStarted();\n        // the oracle offset/limit implementation returns a two column result set\n        // with rownum in the 2nd - queryForList will throw an exception\n        List<String> ids =\n                template.query(\n                        sql.toString(),\n                        namedParameters,\n                        new RowMapper<String>() {\n                            @Override\n                            public String mapRow(ResultSet rs, int rowNum) throws SQLException {\n                                return rs.getString(1);\n                            }\n                        });\n        sw.stop();\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.fine(\"query returned \" + ids.size() + \" records in \" + sw);\n        }\n\n        CloseableIterator<String> result;\n        Iterator<String> iterator =\n                Iterators.filter(ids.iterator(), com.google.common.base.Predicates.notNull());\n\n        if (fullySupported) {\n            result = new CloseableIteratorAdapter<String>(iterator);\n        } else {\n            // Apply the filter\n            result = CloseableIteratorAdapter.filter(iterator, filter);\n            // The offset and limit should not have been applied as part of the query\n            assert (!sqlBuilder.isOffsetLimitApplied());\n        }\n\n        return result;\n    }\n\n    private <T extends Info> CloseableIterator<T> applyOffsetLimit(\n            CloseableIterator<T> iterator, Integer offset, Integer limit) {\n        if (offset != null) {\n            Iterators.advance(iterator, offset.intValue());\n        }\n        if (limit != null) {\n            iterator = CloseableIteratorAdapter.limit(iterator, limit.intValue());\n        }\n        return iterator;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> List<T> queryAsList(\n            final Class<T> of,\n            final Filter filter,\n            Integer offset,\n            Integer count,\n            SortBy sortOrder) {\n\n        CloseableIterator<T> iterator = query(of, filter, offset, count, sortOrder);\n        List<T> list;\n        try {\n            list = ImmutableList.copyOf(iterator);\n        } finally {\n            iterator.close();\n        }\n        return list;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends CatalogInfo> T getDefault(final String key, Class<T> type) {\n        String sql = \"SELECT id FROM default_object WHERE def_key = :key\";\n\n        String defaultObjectId;\n        try {\n            ImmutableMap<String, String> params = ImmutableMap.of(\"key\", key);\n            logStatement(sql, params);\n            defaultObjectId = template.queryForObject(sql, params, String.class);\n        } catch (EmptyResultDataAccessException notFound) {\n            return null;\n        }\n        return getById(defaultObjectId, type);\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            rollbackFor = Exception.class)\n    public <T extends Info> T add(final T info) {\n        checkNotNull(info);\n        checkNotNull(info.getId(), \"Object has no id\");\n        checkArgument(!(info instanceof Proxy), \"Added object shall not be a dynamic proxy\");\n\n        final String id = info.getId();\n\n        byte[] value = binding.objectToEntry(info);\n        final String blob = new String(value, StandardCharsets.UTF_8);\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        final Class<T> interf = (Class) ClassMappings.fromImpl(info.getClass()).getInterface();\n        final Integer typeId = dbMappings.getTypeId(interf);\n\n        Map<String, ?> params = params(\"type_id\", typeId, \"id\", id, \"blob\", blob);\n        final String statement =\n                String.format(\n                        \"INSERT INTO object (oid, type_id, id, blob) VALUES (%s, :type_id, :id, :blob)\",\n                        dialect.nextVal(\"seq_OBJECT\"));\n        logStatement(statement, params);\n        KeyHolder keyHolder = new GeneratedKeyHolder();\n        int updateCount =\n                template.update(\n                        statement,\n                        new MapSqlParameterSource(params),\n                        keyHolder,\n                        new String[] {\"oid\"});\n        checkState(updateCount == 1, \"Insert statement failed\");\n        // looks like some db's return the pk different than others, so lets try both ways\n        Number key = (Number) keyHolder.getKeys().get(\"oid\");\n        if (key == null) {\n            key = keyHolder.getKey();\n        }\n        addAttributes(info, key);\n\n        return getById(id, interf);\n    }\n\n    public <T extends Info> void addNames(String id, String... names) {}\n\n    private void addAttributes(final Info info, final Number infoPk) {\n        final String id = info.getId();\n        if (LOGGER.isLoggable(Level.FINER)) {\n            LOGGER.finer(\"Storing properties of \" + id + \" with pk \" + infoPk);\n        }\n\n        final Iterable<Property> properties = dbMappings.properties(info);\n\n        for (Property prop : properties) {\n            if (LOGGER.isLoggable(Level.FINEST)) {\n                LOGGER.finest(\n                        \"Adding property \" + prop.getPropertyName() + \"='\" + prop.getValue() + \"'\");\n            }\n\n            final List<?> values = valueList(prop);\n\n            Object propValue;\n            Integer colIndex;\n\n            for (int index = 0; index < values.size(); index++) {\n                colIndex = prop.isCollectionProperty() ? (index + 1) : 0;\n                propValue = values.get(index);\n                final String storedValue = marshalValue(propValue);\n\n                Integer relatedOid = null;\n                Integer relatedPropertyType = null;\n                if (prop.isRelationship()) {\n                    final Info relatedObject = lookUpRelatedObject(info, prop, colIndex);\n                    // Layer styles might not be actually persisted, in the case of WMS cascaded\n                    // layers,\n                    // where they are created on the fly based on the style names found in the caps\n                    // documents. So check if the id is not null, in addition to checking\n                    // if the related object is not null.\n                    if (relatedObject != null && relatedObject.getId() != null) {\n                        relatedOid = findObjectId(relatedObject);\n                        relatedPropertyType = getRelatedPropertyType(prop, relatedObject);\n                    }\n                } else {\n                    // it's a self property, lets update the value on the property table\n                    relatedOid = null;\n                    relatedPropertyType = null;\n                }\n                addAttribute(\n                        info, infoPk, prop, colIndex, storedValue, relatedOid, relatedPropertyType);\n            }\n        }\n    }\n\n    private void addAttribute(\n            final Info info,\n            final Number infoPk,\n            Property prop,\n            Integer colIndex,\n            final String storedValue,\n            Integer relatedOid,\n            Integer relatedPropertyType) {\n\n        final String insertPropertySQL =\n                \"INSERT INTO object_property \"\n                        + \"(oid, property_type, related_oid, related_property_type, colindex, value, id) \"\n                        + \"VALUES (:object_id, :property_type, :related_oid, :related_property_type, :colindex, :value, :id)\";\n        final Number propertyType = prop.getPropertyType().getOid();\n        final String id = info.getId();\n\n        Map<String, ?> params =\n                params(\n                        \"object_id\",\n                        infoPk,\n                        \"property_type\",\n                        propertyType,\n                        \"related_oid\",\n                        relatedOid,\n                        \"related_property_type\",\n                        relatedPropertyType,\n                        \"colindex\",\n                        colIndex,\n                        \"value\",\n                        storedValue,\n                        \"id\",\n                        id);\n\n        logStatement(insertPropertySQL, params);\n        template.update(insertPropertySQL, params);\n    }\n\n    /** */\n    private Info lookUpRelatedObject(\n            final Info info, final Property prop, @Nullable Integer collectionIndex) {\n\n        checkArgument(collectionIndex == 0 || prop.isCollectionProperty());\n\n        final FilterFactory ff = CommonFactoryFinder.getFilterFactory();\n\n        final Integer targetPropertyTypeId = prop.getPropertyType().getTargetPropertyOid();\n        checkArgument(targetPropertyTypeId != null);\n\n        final PropertyType targetPropertyType = dbMappings.getPropertyType(targetPropertyTypeId);\n        checkState(targetPropertyType != null);\n\n        final Class<?> targetType = dbMappings.getType(targetPropertyType.getObjectTypeOid());\n        checkState(targetType != null);\n\n        final String localPropertyName = prop.getPropertyName();\n        String[] steps = localPropertyName.split(\"\\\\.\");\n        // Step back through ancestor property references If starting at a.b.c.d, then look at\n        // a.b.c, then a.b, then a\n        for (int len = steps.length - 1; len > 0; len--) {\n            String backPropName = Arrays.stream(steps).limit(len).collect(Collectors.joining(\".\"));\n            Object backProp = ff.property(backPropName).evaluate(info);\n            if (backProp != null) {\n                if (prop.isCollectionProperty()\n                        && (backProp instanceof Set || backProp instanceof List)) {\n                    List<?> list;\n                    if (backProp instanceof Set) {\n                        list = asValueList(backProp);\n                        if (list.size() > 0\n                                && list.get(0) != null\n                                && targetType.isAssignableFrom(list.get(0).getClass())) {\n                            String targetPropertyName = targetPropertyType.getPropertyName();\n                            final PropertyName expr = ff.property(targetPropertyName);\n                            Collections.sort(\n                                    list,\n                                    new Comparator<Object>() {\n                                        @Override\n                                        public int compare(Object o1, Object o2) {\n                                            Object v1 = expr.evaluate(o1);\n                                            Object v2 = expr.evaluate(o2);\n                                            String m1 = marshalValue(v1);\n                                            String m2 = marshalValue(v2);\n                                            return m1 == null\n                                                    ? (m2 == null ? 0 : -1)\n                                                    : (m2 == null ? 1 : m1.compareTo(m2));\n                                        }\n                                    });\n                        }\n                    } else {\n                        list = (List<?>) backProp;\n                    }\n                    if (collectionIndex <= list.size()) {\n                        backProp = list.get(collectionIndex - 1);\n                    }\n                }\n                if (targetType.isAssignableFrom(backProp.getClass())) {\n                    return ModificationProxy.unwrap((Info) backProp);\n                }\n            }\n        }\n        // throw new IllegalArgumentException(\"Found no related object of type \"\n        // + targetType.getName() + \" for property \" + localPropertyName + \" of \" + info);\n        return null;\n    }\n\n    private List<?> valueList(Property prop) {\n        final Object value = prop.getValue();\n        return asValueList(value);\n    }\n\n    private List<?> asValueList(final Object value) {\n        final List<?> values;\n        if (value instanceof List) {\n            values = (List<?>) value;\n        } else if (value instanceof Collection) {\n            values = Lists.newArrayList((Collection<?>) value);\n        } else {\n            values = Lists.newArrayList(value);\n        }\n        return values;\n    }\n\n    /** @return the stored representation of a scalar property value */\n    private String marshalValue(Object propValue) {\n        // TODO pad numeric values\n        String marshalled = Converters.convert(propValue, String.class);\n        return marshalled;\n    }\n\n    /** @param info */\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            rollbackFor = Exception.class)\n    public void remove(Info info) {\n        Integer oid;\n        try {\n            oid = findObjectId(info);\n        } catch (EmptyResultDataAccessException notFound) {\n            return;\n        }\n\n        String deleteObject = \"DELETE FROM object WHERE id = :id\";\n        String deleteRelatedProperties = \"DELETE FROM object_property WHERE related_oid = :oid\";\n\n        Map<String, ?> params = ImmutableMap.of(\"id\", info.getId());\n        logStatement(deleteObject, params);\n        int updateCount = template.update(deleteObject, params);\n        if (updateCount != 1) {\n            LOGGER.warning(\n                    \"Requested to delete \"\n                            + info\n                            + \" (\"\n                            + info.getId()\n                            + \") but nothing happened on the database.\");\n        }\n        params = params(\"oid\", oid);\n        logStatement(deleteRelatedProperties, params);\n        final int relatedPropCount = template.update(deleteRelatedProperties, params);\n        LOGGER.fine(\"Removed \" + relatedPropCount + \" related properties of \" + info.getId());\n    }\n\n    /** @param info */\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            rollbackFor = Exception.class)\n    public <T extends Info> T save(T info) {\n        checkNotNull(info);\n\n        final String id = info.getId();\n\n        checkNotNull(id, \"Can't modify an object with no id\");\n\n        final ModificationProxy modificationProxy = ModificationProxy.handler(info);\n        Preconditions.checkNotNull(modificationProxy, \"Not a modification proxy: \", info);\n\n        final Info oldObject = (Info) modificationProxy.getProxyObject();\n\n        // get changed properties before h.commit()s\n        final Iterable<Property> changedProperties = dbMappings.changedProperties(oldObject, info);\n\n        // see HACK block bellow\n        final boolean updateResouceLayersName =\n                info instanceof ResourceInfo\n                        && modificationProxy.getPropertyNames().contains(\"name\");\n        final boolean updateResouceLayersAdvertised =\n                info instanceof ResourceInfo\n                        && modificationProxy.getPropertyNames().contains(\"advertised\");\n        final boolean updateResourceLayersEnabled =\n                info instanceof ResourceInfo\n                        && modificationProxy.getPropertyNames().contains(\"enabled\");\n        final boolean updateResourceLayersKeywords =\n                CollectionUtils.exists(\n                        modificationProxy.getPropertyNames(),\n                        new Predicate() {\n                            @Override\n                            public boolean evaluate(Object input) {\n                                return ((String) input).contains(\"keyword\");\n                            }\n                        });\n\n        modificationProxy.commit();\n\n        Map<String, ?> params;\n\n        // get the object's internal id\n        final Integer objectId = findObjectId(info);\n        byte[] value = binding.objectToEntry(info);\n        final String blob = new String(value, StandardCharsets.UTF_8);\n        String updateStatement = \"UPDATE object SET blob = :blob WHERE oid = :oid\";\n        params = params(\"blob\", blob, \"oid\", objectId);\n        logStatement(updateStatement, params);\n        template.update(updateStatement, params);\n\n        updateQueryableProperties(oldObject, objectId, changedProperties);\n\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        Class<T> clazz = (Class) ClassMappings.fromImpl(oldObject.getClass()).getInterface();\n\n        // / <HACK>\n        // we're explicitly changing the resourceinfo's layer name property here because\n        // LayerInfo.getName() is a derived property. This can be removed once LayerInfo.name become\n        // a regular JavaBean property\n        if (info instanceof ResourceInfo) {\n            if (updateResouceLayersName) {\n                updateResourceLayerProperty(\n                        (ResourceInfo) info, \"name\", ((ResourceInfo) info).getName());\n                updateResourceLayerProperty(\n                        (ResourceInfo) info, \"prefixedName\", ((ResourceInfo) info).prefixedName());\n            }\n            if (updateResouceLayersAdvertised) {\n                updateResourceLayerProperty(\n                        (ResourceInfo) info, \"advertised\", ((ResourceInfo) info).isAdvertised());\n            }\n            if (updateResourceLayersEnabled) {\n                updateResourceLayerProperty(\n                        (ResourceInfo) info, \"enabled\", ((ResourceInfo) info).isEnabled());\n            }\n            if (updateResourceLayersKeywords) {\n                updateResourceLayerProperty(\n                        (ResourceInfo) info,\n                        \"resource.keywords.value\",\n                        ((ResourceInfo) info).getKeywords());\n            }\n        }\n        // / </HACK>\n\n        return getById(id, clazz);\n    }\n\n    private <T> void updateResourceLayerProperty(\n            ResourceInfo info, String propertyPath, Object newValue) {\n        Filter filter = Predicates.equal(\"resource.id\", info.getId());\n        List<LayerInfo> resourceLayers;\n        resourceLayers = this.queryAsList(LayerInfo.class, filter, null, null, null);\n        for (LayerInfo layer : resourceLayers) {\n            Set<PropertyType> propertyTypes =\n                    dbMappings.getPropertyTypes(LayerInfo.class, propertyPath);\n            PropertyType propertyType = propertyTypes.iterator().next();\n            Property changedProperty = new Property(propertyType, newValue);\n            Integer layerOid = findObjectId(layer);\n            updateQueryableProperties(layer, layerOid, ImmutableSet.of(changedProperty));\n        }\n    }\n\n    private Integer findObjectId(final Info info) {\n        final String id = info.getId();\n        final String oidQuery = \"SELECT oid FROM object WHERE id = :id\";\n        Map<String, ?> params = params(\"id\", id);\n        logStatement(oidQuery, params);\n        final Integer objectId = template.queryForObject(oidQuery, params, Integer.class);\n        Preconditions.checkState(objectId != null, \"Object not found: \" + id);\n        return objectId;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            rollbackFor = Exception.class)\n    public void repopulateQueryableProperties() {\n        InfoRowMapper<Info> mapper = new InfoRowMapper<Info>(Info.class, binding, 2);\n        String sql = \"SELECT oid, blob FROM object\";\n        logStatement(sql, null);\n        template.query(\n                sql,\n                new ResultSetExtractor<Void>() {\n\n                    @Override\n                    public Void extractData(ResultSet rs) throws SQLException, DataAccessException {\n                        while (rs.next()) {\n                            Integer oid = rs.getInt(1);\n                            Info info = mapper.mapRow(rs, rs.getRow());\n                            if (info instanceof CatalogInfo) {\n                                info = resolveCatalog((CatalogInfo) info);\n                            } else if (info instanceof ServiceInfo) {\n                                resolveTransient((ServiceInfo) info);\n                            }\n                            updateQueryableProperties(info, oid, dbMappings.allProperties(info));\n                        }\n                        return null;\n                    }\n                });\n    }\n\n    private void updateQueryableProperties(\n            final Info info, final Integer objectId, Iterable<Property> changedProperties) {\n\n        Map<String, ?> params;\n\n        final Integer oid = objectId;\n        Integer propertyType;\n        Integer relatedOid = null;\n        Integer relatedPropertyType = null;\n        Integer colIndex;\n        String storedValue;\n\n        for (Property changedProp : changedProperties) {\n            LOGGER.finer(\"Updating property \" + changedProp);\n\n            final boolean isRelationship = changedProp.isRelationship();\n            propertyType = changedProp.getPropertyType().getOid();\n\n            final List<?> values = valueList(changedProp);\n\n            for (int i = 0; i < values.size(); i++) {\n                final Object rawValue = values.get(i);\n                storedValue = marshalValue(rawValue);\n                checkArgument(\n                        changedProp.isCollectionProperty() || values.size() == 1,\n                        \"Got a multivalued value for a non collection property \"\n                                + changedProp.getPropertyName()\n                                + \"=\"\n                                + values);\n\n                colIndex = changedProp.isCollectionProperty() ? (i + 1) : 0;\n\n                if (isRelationship) {\n                    final Info relatedObject = lookUpRelatedObject(info, changedProp, colIndex);\n                    // Layer styles might not be actually persisted, in the case of WMS cascaded\n                    // layers,\n                    // where they are created on the fly based on the style names found in the caps\n                    // documents. So check if the id is not null, in addition to checking\n                    // if the related object is not null.\n                    if (relatedObject != null && relatedObject.getId() != null) {\n                        relatedOid = findObjectId(relatedObject);\n                        relatedPropertyType = getRelatedPropertyType(changedProp, relatedObject);\n                    }\n                } else {\n                    // it's a self property, lets update the value on the property table\n                    relatedOid = null;\n                    relatedPropertyType = null;\n                }\n                String sql =\n                        \"UPDATE object_property SET \"\n                                + \"related_oid = :related_oid, \"\n                                + \"related_property_type = :related_property_type, \"\n                                + \"value = :value \"\n                                + \"WHERE oid = :oid AND property_type = :property_type AND colindex = :colindex\";\n                params =\n                        params(\n                                \"related_oid\",\n                                relatedOid,\n                                \"related_property_type\",\n                                relatedPropertyType,\n                                \"value\",\n                                storedValue,\n                                \"oid\",\n                                oid,\n                                \"property_type\",\n                                propertyType,\n                                \"colindex\",\n                                colIndex);\n\n                logStatement(sql, params);\n                final int updateCnt = template.update(sql, params);\n\n                if (updateCnt == 0) {\n                    addAttribute(\n                            info,\n                            oid,\n                            changedProp,\n                            colIndex,\n                            storedValue,\n                            relatedOid,\n                            relatedPropertyType);\n                } else {\n                    // prop existed already, lets update any related property that points to its old\n                    // value\n                    String updateRelated =\n                            \"UPDATE object_property SET value = :value \"\n                                    + \"WHERE related_oid = :oid AND related_property_type = :property_type AND colindex = :colindex\";\n                    params =\n                            params(\n                                    \"value\",\n                                    storedValue,\n                                    \"oid\",\n                                    oid,\n                                    \"property_type\",\n                                    propertyType,\n                                    \"colindex\",\n                                    colIndex);\n                    logStatement(updateRelated, params);\n                    int relatedUpdateCnt = template.update(updateRelated, params);\n                    if (LOGGER.isLoggable(Level.FINER)) {\n                        LOGGER.finer(\n                                \"Updated \"\n                                        + relatedUpdateCnt\n                                        + \" back pointer properties to \"\n                                        + changedProp.getPropertyName()\n                                        + \" of \"\n                                        + info.getClass().getSimpleName()\n                                        + \"[\"\n                                        + info.getId()\n                                        + \"]\");\n                    }\n                }\n            }\n            if (changedProp.isCollectionProperty()) {\n                // delete any remaining collection value that's no longer in the value list\n                String sql =\n                        \"DELETE FROM object_property WHERE oid = :oid AND property_type = :property_type \"\n                                + \"AND colindex > :maxIndex\";\n                Integer maxIndex = Integer.valueOf(values.size());\n                params = params(\"oid\", oid, \"property_type\", propertyType, \"maxIndex\", maxIndex);\n                logStatement(sql, params);\n                template.update(sql, params);\n            }\n        }\n    }\n\n    private Integer getRelatedPropertyType(Property changedProp, final Info relatedObject) {\n        // the related property may refer to an abstract type (e.g.\n        // LayerInfo.resource.name), so we need to find out the actual property type id (for\n        // example, whether it belongs to FeatureTypeInfo or CoverageInfo)\n\n        Integer targetPropertyOid = changedProp.getPropertyType().getTargetPropertyOid();\n        PropertyType targetProperty;\n        String targetPropertyName;\n\n        Class<?> targetQueryType;\n        ClassMappings classMappings = ClassMappings.fromImpl(relatedObject.getClass());\n        targetQueryType = classMappings.getInterface();\n        targetProperty = dbMappings.getPropertyType(targetPropertyOid);\n        targetPropertyName = targetProperty.getPropertyName();\n\n        Set<Integer> propertyTypeIds;\n        propertyTypeIds = dbMappings.getPropertyTypeIds(targetQueryType, targetPropertyName);\n        checkState(propertyTypeIds.size() == 1);\n        return propertyTypeIds.iterator().next();\n    }\n\n    public <T extends Info> T getById(final String id, final Class<T> type) {\n        Assert.notNull(id, \"id\");\n\n        Info info = null;\n        try {\n            final Callable<? extends Info> valueLoader;\n            if (CatalogInfo.class.isAssignableFrom(type)) {\n                valueLoader = new CatalogLoader(id);\n            } else {\n                valueLoader = new ConfigLoader(id);\n            }\n\n            Semaphore lock = locks.computeIfAbsent(id, x -> new Semaphore(1));\n\n            info = cache.getIfPresent(id);\n            if (info == null) {\n                // we try the write lock\n                if (lock.tryAcquire()) {\n                    try {\n                        info = cache.get(id, valueLoader);\n                    } finally {\n                        lock.release();\n                    }\n                }\n            }\n\n            if (info == null) {\n                // if the write lock was locked, we fall back\n                // to a read-only method\n                try {\n                    info = valueLoader.call();\n                } catch (Exception e) {\n                    throw new ExecutionException(e);\n                }\n            }\n\n        } catch (CacheLoader.InvalidCacheLoadException notFound) {\n            return null;\n        } catch (ExecutionException e) {\n            throw new RuntimeException(e);\n        }\n\n        if (info == null) {\n            return null;\n        }\n        if (info instanceof CatalogInfo) {\n            info = resolveCatalog((CatalogInfo) info);\n        } else if (info instanceof ServiceInfo) {\n            resolveTransient((ServiceInfo) info);\n        }\n\n        if (type.isAssignableFrom(info.getClass())) {\n            // use ModificationProxy only in this case as returned object is cached. saveInternal\n            // follows suite checking whether the object being saved is a mod proxy, but that's not\n            // mandatory in this implementation and should only be the case when the object was\n            // obtained by id\n            return ModificationProxy.create(type.cast(info), type);\n        }\n\n        return null;\n    }\n\n    public <T extends Info> String getIdByIdentity(\n            final Class<T> type, final String... identityMappings) {\n        Assert.notNull(identityMappings, \"id\");\n        int length = identityMappings.length / 2;\n        String[] descriptor = new String[length];\n        String[] values = new String[length];\n        for (int i = 0; i < length; i++) {\n            descriptor[i] = identityMappings[i * 2];\n            values[i] = identityMappings[i * 2 + 1];\n        }\n        InfoIdentity infoIdentity = new InfoIdentity(InfoIdentities.root(type), descriptor, values);\n\n        String id = null;\n        try {\n            id = identityCache.get(infoIdentity, new IdentityLoader(infoIdentity));\n\n        } catch (CacheLoader.InvalidCacheLoadException notFound) {\n            return null;\n        } catch (ExecutionException e) {\n            throwIfUnchecked(e.getCause());\n            throw new RuntimeException(e.getCause());\n        }\n\n        return id;\n    }\n\n    @Nullable\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public ServiceInfo getService(\n            final WorkspaceInfo ws, final Class<? extends ServiceInfo> clazz) {\n        Assert.notNull(clazz, \"clazz\");\n\n        ServiceInfo info = null;\n        try {\n            ServiceIdentity id = new ServiceIdentity(clazz, ws);\n            info = serviceCache.get(id, new ServiceLoader(id));\n\n        } catch (CacheLoader.InvalidCacheLoadException notFound) {\n            return null;\n        } catch (ExecutionException e) {\n            Throwable throwable = e.getCause();\n            throwIfUnchecked(throwable);\n            throw new RuntimeException(throwable);\n        }\n\n        if (info == null) {\n            return null;\n        }\n        resolveTransient(info);\n\n        return info;\n    }\n\n    @Nullable\n    public List<ServiceInfo> getServices(final WorkspaceInfo ws) {\n\n        List<ServiceInfo> result = new ArrayList<>();\n        for (ServiceInfo info : serviceCache.asMap().values()) {\n            if (ws.equals(info.getWorkspace())) {\n                result.add(info);\n            }\n        }\n        return result;\n    }\n\n    @Nullable\n    public <T extends Info> T getByIdentity(final Class<T> type, final String... identityMappings) {\n        String id = getIdByIdentity(type, identityMappings);\n\n        if (id == null) {\n            return null;\n        } else {\n            return getById(id, type);\n        }\n    }\n\n    private <T extends CatalogInfo> T resolveCatalog(final T real) {\n        if (real == null) {\n            return null;\n        }\n        CatalogImpl catalog = getCatalog();\n        catalog.resolve(real);\n        // may the cached value have been serialized and hence lost transient fields? (that's why I\n        // don't like having transient fields foreign to the domain model in the catalog config\n        // objects)\n        resolveTransient(real);\n\n        // if this came from the cache, force update references\n        real.accept(new CatalogReferenceUpdater());\n\n        return real;\n    }\n\n    private <T extends CatalogInfo> void resolveTransient(T real) {\n        if (null == real) {\n            return;\n        }\n        real = ModificationProxy.unwrap(real);\n        if (real instanceof StyleInfoImpl\n                || real instanceof StoreInfoImpl\n                || real instanceof ResourceInfoImpl) {\n            OwsUtils.set(real, \"catalog\", catalog);\n        }\n        if (real instanceof ResourceInfoImpl) {\n            resolveTransient(((ResourceInfoImpl) real).getStore());\n        } else if (real instanceof LayerInfo) {\n            LayerInfo layer = (LayerInfo) real;\n            resolveTransient(layer.getDefaultStyle());\n            // avoids concurrent modification exceptions on the list contents\n            synchronized (layer) {\n                if (!layer.getStyles().isEmpty()) {\n                    for (StyleInfo s : layer.getStyles()) {\n                        resolveTransient(s);\n                    }\n                }\n            }\n            resolveTransient(layer.getResource());\n        } else if (real instanceof LayerGroupInfo) {\n            for (PublishedInfo p : ((LayerGroupInfo) real).getLayers()) {\n                resolveTransient(p);\n            }\n            for (StyleInfo s : ((LayerGroupInfo) real).getStyles()) {\n                resolveTransient(s);\n            }\n        }\n    }\n\n    private <T extends ServiceInfo> void resolveTransient(T real) {\n        real = ModificationProxy.unwrap(real);\n        OwsUtils.resolveCollections(real);\n        real.setGeoServer(getGeoServer());\n    }\n\n    /** @return immutable list of results */\n    @Nullable\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> List<T> getAll(final Class<T> clazz) {\n\n        Map<String, ?> params = params(\"types\", typesParam(clazz));\n\n        final String sql = \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY id\";\n\n        logStatement(sql, params);\n        Stopwatch sw = Stopwatch.createStarted();\n        List<String> ids = template.queryForList(sql, params, String.class);\n        sw.stop();\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.fine(\"query returned \" + ids.size() + \" records in \" + sw);\n        }\n\n        List<T> transformed =\n                Lists.transform(\n                        ids,\n                        new Function<String, T>() {\n                            @Nullable\n                            @Override\n                            public T apply(String input) {\n                                return getById(input, clazz);\n                            }\n                        });\n        Iterable<T> filtered =\n                Iterables.filter(transformed, com.google.common.base.Predicates.notNull());\n        return ImmutableList.copyOf(filtered);\n    }\n\n    private <T extends Info> List<Integer> typesParam(final Class<T> clazz) {\n\n        final Class<?>[] actualTypes;\n\n        actualTypes = ClassMappings.fromInterface(clazz).concreteInterfaces();\n\n        List<Integer> inValues = new ArrayList<Integer>(actualTypes.length);\n        for (Class<?> type : actualTypes) {\n            inValues.add(this.dbMappings.getTypeId(type));\n        }\n\n        return inValues;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            rollbackFor = Exception.class)\n    public void setDefault(final String key, @Nullable final String id) {\n        String sql = \"DELETE FROM default_object WHERE def_key = :key\";\n        Map<String, ?> params = params(\"key\", key);\n        logStatement(sql, params);\n        template.update(sql, params);\n        if (id != null) {\n            sql = \"INSERT INTO default_object (def_key, id) VALUES (:key, :id)\";\n            params = params(\"key\", key, \"id\", id);\n            logStatement(sql, params);\n            template.update(sql, params);\n        }\n    }\n\n    public void dispose() {\n        cache.invalidateAll();\n        cache.cleanUp();\n        identityCache.invalidateAll();\n        identityCache.cleanUp();\n        disposeServiceCache();\n    }\n\n    private void disposeServiceCache() {\n        serviceCache.invalidateAll();\n        serviceCache.cleanUp();\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.transactionalConfigDatabase = applicationContext.getBean(ConfigDatabase.class);\n    }\n\n    private final class CatalogLoader implements Callable<CatalogInfo> {\n\n        private final String id;\n\n        public CatalogLoader(final String id) {\n            this.id = id;\n        }\n\n        @Override\n        public CatalogInfo call() throws Exception {\n            return transactionalConfigDatabase.loadCatalog(id);\n        }\n    }\n\n    @Nullable\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public CatalogInfo loadCatalog(String id) {\n\n        CatalogInfo info;\n        try {\n            String sql = \"SELECT blob FROM object WHERE id = :id\";\n            Map<String, String> params = ImmutableMap.of(\"id\", id);\n            logStatement(sql, params);\n            info = template.queryForObject(sql, params, catalogRowMapper);\n        } catch (EmptyResultDataAccessException noSuchObject) {\n            return null;\n        }\n        return info;\n    }\n\n    private final class IdentityLoader implements Callable<String> {\n\n        private final InfoIdentity identity;\n\n        public IdentityLoader(final InfoIdentity identity) {\n            this.identity = identity;\n        }\n\n        @Override\n        public String call() throws Exception {\n            return transactionalConfigDatabase.loadIdentity(identity);\n        }\n    }\n\n    @Nullable\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public String loadIdentity(InfoIdentity identity) {\n        Filter filter = Filter.INCLUDE;\n        for (int i = 0; i < identity.getDescriptor().length; i++) {\n            filter =\n                    and(\n                            filter,\n                            identity.getValues()[i] == null\n                                    ? isNull(identity.getDescriptor()[i])\n                                    : equal(identity.getDescriptor()[i], identity.getValues()[i]));\n        }\n\n        try {\n            return getId(identity.getClazz(), filter);\n        } catch (IllegalArgumentException multipleResults) {\n            return null;\n        }\n    }\n\n    private static final class ServiceIdentity implements Serializable {\n        private static final long serialVersionUID = 4054478633697271203L;\n\n        private Class<? extends ServiceInfo> clazz;\n        private WorkspaceInfo workspace;\n\n        public ServiceIdentity(Class<? extends ServiceInfo> clazz, WorkspaceInfo workspace) {\n            this.clazz = clazz;\n            this.workspace = workspace;\n        }\n\n        public Class<? extends ServiceInfo> getClazz() {\n            return clazz;\n        }\n\n        public WorkspaceInfo getWorkspace() {\n            return workspace;\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + ((clazz == null) ? 0 : clazz.hashCode());\n            result = prime * result + ((workspace == null) ? 0 : workspace.hashCode());\n            return result;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null) return false;\n            if (getClass() != obj.getClass()) return false;\n            ServiceIdentity other = (ServiceIdentity) obj;\n            if (clazz == null) {\n                if (other.clazz != null) return false;\n            } else if (!clazz.equals(other.clazz)) return false;\n            if (workspace == null) {\n                if (other.workspace != null) return false;\n            } else if (!workspace.equals(other.workspace)) return false;\n            return true;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <T extends ServiceInfo> CloseableIterator<T> filterService(\n            final Class<T> clazz, CloseableIterator<ServiceInfo> it) {\n        return (CloseableIterator<T>)\n                CloseableIteratorAdapter.filter(\n                        it,\n                        new com.google.common.base.Predicate<ServiceInfo>() {\n\n                            @Override\n                            public boolean apply(@Nullable ServiceInfo input) {\n                                return clazz.isAssignableFrom(input.getClass());\n                            }\n                        });\n    }\n\n    private final class ServiceLoader implements Callable<ServiceInfo> {\n\n        private final ServiceIdentity id;\n\n        public ServiceLoader(final ServiceIdentity id) {\n            this.id = id;\n        }\n\n        @Override\n        public ServiceInfo call() throws Exception {\n            Filter filter;\n            if (id.getWorkspace() != null && id.getWorkspace() != ANY_WORKSPACE) {\n                filter = equal(\"workspace.id\", id.getWorkspace().getId());\n            } else {\n                filter = isNull(\"workspace.id\");\n            }\n\n            // In order to handle new service types, get all services, deserialize them, and then\n            // filter\n            // by checking if the implement the given interface.  Since there shouldn't be too many\n            // per\n            // workspace, this shouldn't be a significant performance problem.\n            CloseableIterator<? extends ServiceInfo> it =\n                    filterService(\n                            id.getClazz(),\n                            query(ServiceInfo.class, filter, null, null, (SortBy) null));\n\n            ServiceInfo service;\n            if (it.hasNext()) {\n                service = it.next();\n            } else {\n                if (LOGGER.isLoggable(Level.FINE))\n                    LOGGER.log(\n                            Level.FINE,\n                            \"Could not find service of type \"\n                                    + id.getClazz()\n                                    + \" in \"\n                                    + id.getWorkspace());\n                return null;\n            }\n\n            if (it.hasNext()) {\n                LOGGER.log(\n                        Level.WARNING,\n                        \"Found multiple services of type \"\n                                + id.getClass()\n                                + \" in \"\n                                + id.getWorkspace());\n                return null;\n            }\n            return service;\n        }\n    }\n\n    private final class ConfigLoader implements Callable<Info> {\n\n        private final String id;\n\n        public ConfigLoader(final String id) {\n            this.id = id;\n        }\n\n        @Override\n        public Info call() throws Exception {\n            return transactionalConfigDatabase.loadConfig(id);\n        }\n    }\n\n    @Nullable\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public Info loadConfig(String id) {\n        Info info;\n        try {\n            String sql = \"SELECT blob FROM object WHERE id = :id\";\n            Map<String, String> params = ImmutableMap.of(\"id\", id);\n            logStatement(sql, params);\n            info = template.queryForObject(sql, params, configRowMapper);\n        } catch (EmptyResultDataAccessException noSuchObject) {\n            return null;\n        }\n        OwsUtils.resolveCollections(info);\n        if (info instanceof GeoServerInfo) {\n\n            GeoServerInfoImpl global = (GeoServerInfoImpl) info;\n            if (global.getMetadata() == null) {\n                global.setMetadata(new MetadataMap());\n            }\n            if (global.getClientProperties() == null) {\n                global.setClientProperties(new HashMap<Object, Object>());\n            }\n            if (global.getCoverageAccess() == null) {\n                global.setCoverageAccess(new CoverageAccessInfoImpl());\n            }\n            if (global.getJAI() == null) {\n                global.setJAI(new JAIInfoImpl());\n            }\n        }\n        if (info instanceof ServiceInfo) {\n            ((ServiceInfo) info).setGeoServer(geoServer);\n        }\n\n        return info;\n    }\n\n    /**\n     * @return whether there exists a property named {@code propertyName} for the given type of\n     *     object, and hence native sorting can be done over it.\n     */\n    public boolean canSort(Class<? extends CatalogInfo> type, String propertyName) {\n        Set<PropertyType> propertyTypes = dbMappings.getPropertyTypes(type, propertyName);\n        return !propertyTypes.isEmpty();\n    }\n\n    public void clearCache() {\n        cache.invalidateAll();\n        serviceCache.invalidateAll();\n    }\n\n    public void clearCache(Info info) {\n        if (info instanceof ServiceInfo) {\n            // need to figure out how to remove only the relevant cache\n            // entries for the service info, like with InfoIdenties below,\n            // that will be able to handle new service types.\n            disposeServiceCache();\n        }\n        identityCache.invalidateAll(InfoIdentities.get().getIdentities(info));\n        cache.invalidate(info.getId());\n    }\n\n    public void clearCacheIfPresent(String id) {\n        Info info = cache.getIfPresent(id);\n        if (info != null) {\n            clearCache(info);\n        }\n    }\n\n    void updateCache(Info info) {\n        info = ModificationProxy.unwrap(info);\n        cache.put(info.getId(), info);\n        List<InfoIdentity> identities = InfoIdentities.get().getIdentities(info);\n        for (InfoIdentity identity : identities) {\n            if (identityCache.getIfPresent(identity) == null) {\n                identityCache.put(identity, info.getId());\n            } else {\n                // not a unique identity\n                identityCache.invalidate(identity);\n            }\n        }\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> T get(Class<T> type, Filter filter) throws IllegalArgumentException {\n\n        CloseableIterator<T> it =\n                query(type, filter, null, 2, (org.opengis.filter.sort.SortBy) null);\n        T result = null;\n        try {\n            if (it.hasNext()) {\n                result = it.next();\n                if (it.hasNext()) {\n                    throw new IllegalArgumentException(\n                            \"Specified query predicate resulted in more than one object\");\n                }\n            }\n        } finally {\n            it.close();\n        }\n        return result;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> String getId(Class<T> type, Filter filter)\n            throws IllegalArgumentException {\n\n        CloseableIterator<String> it = queryIds(type, filter);\n        String result = null;\n        try {\n            if (it.hasNext()) {\n                result = it.next();\n                if (it.hasNext()) {\n                    throw new IllegalArgumentException(\n                            \"Specified query predicate resulted in more than one object\");\n                }\n            }\n        } finally {\n            it.close();\n        }\n        return result;\n    }\n\n    private void acquireWriteLock(String id) {\n        Semaphore lock = locks.computeIfAbsent(id, x -> new Semaphore(1));\n        try {\n            if (!lock.tryAcquire(LOCK_TIMEOUT_SECONDS, TimeUnit.SECONDS)) {\n                LOGGER.severe(\n                        \"Time-out waiting for lock on \"\n                                + id\n                                + \", assuming it was abandoned and moving on. This shouldn't happen!\");\n            }\n        } catch (InterruptedException e) {\n\n        }\n    }\n\n    private void releaseWriteLock(String id) {\n        Semaphore lock = locks.get(id);\n        // while semaphores are thread safe by nature,\n        // the if-condition below isn't\n        synchronized (lock) {\n            if (lock.availablePermits() < 1) {\n                // we never give more than one permit\n                lock.release();\n            }\n        }\n    }\n\n    /** Only intended for testing purposes */\n    public void lock(String id, long millis) {\n        acquireWriteLock(id);\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n        }\n        releaseWriteLock(id);\n    }\n\n    /**\n     * Listens to catalog events clearing cache entires when resources are modified. Copied from\n     * org.geoserver.catalog.ResourcePool upgrade CatalogClearingListener clear old source default\n     * priority is 100\n     *\n     * @see CatalogImpl#addListener(CatalogListener)\n     */\n    public class CatalogClearingListener implements CatalogListener, ExtensionPriority {\n\n        @Override\n        public void handleAddEvent(CatalogAddEvent event) {\n            updateCache(event.getSource());\n        }\n\n        @Override\n        public void handleModifyEvent(CatalogModifyEvent event) {\n            // make sure that cache is not refilled before commit\n            if (event.getSource() instanceof ResourceInfo) {\n                String liId =\n                        getIdByIdentity(LayerInfo.class, \"resource.id\", event.getSource().getId());\n                acquireWriteLock(liId);\n                clearCacheIfPresent(liId);\n            }\n            acquireWriteLock(event.getSource().getId());\n            clearCache(event.getSource());\n        }\n\n        @Override\n        public void handlePostModifyEvent(CatalogPostModifyEvent event) {\n            updateCache(event.getSource());\n            releaseWriteLock(event.getSource().getId());\n            if (event.getSource() instanceof ResourceInfo) {\n                String liId =\n                        getIdByIdentity(LayerInfo.class, \"resource.id\", event.getSource().getId());\n                releaseWriteLock(liId);\n            }\n        }\n\n        @Override\n        public void handleRemoveEvent(CatalogRemoveEvent event) {\n            clearCache(event.getSource());\n        }\n\n        @Override\n        public void reloaded() {}\n\n        @Override\n        public int getPriority() {\n            return 999;\n        }\n    }\n    /** Listens to configuration events clearing cache entires when resources are modified. */\n    public class ConfigClearingListener extends ConfigurationListenerAdapter {\n\n        @Override\n        public void handleSettingsRemoved(SettingsInfo settings) {\n            clearCache(settings);\n        }\n\n        @Override\n        public void handleServiceRemove(ServiceInfo service) {\n            clearCache(service);\n        }\n\n        @Override\n        public void handleGlobalChange(\n                GeoServerInfo global,\n                List<String> propertyNames,\n                List<Object> oldValues,\n                List<Object> newValues) {\n            // make sure that cache is not refilled before commit\n            acquireWriteLock(global.getId());\n            clearCache(global);\n        }\n\n        @Override\n        public void handlePostGlobalChange(GeoServerInfo global) {\n            updateCache(global);\n            releaseWriteLock(global.getId());\n        }\n\n        @Override\n        public void handleSettingsModified(\n                SettingsInfo settings,\n                List<String> propertyNames,\n                List<Object> oldValues,\n                List<Object> newValues) {\n            // make sure that cache is not refilled before commit\n            acquireWriteLock(settings.getId());\n            clearCache(settings);\n        }\n\n        @Override\n        public void handleSettingsPostModified(SettingsInfo settings) {\n            updateCache(settings);\n            releaseWriteLock(settings.getId());\n        }\n\n        @Override\n        public void handleLoggingChange(\n                LoggingInfo logging,\n                List<String> propertyNames,\n                List<Object> oldValues,\n                List<Object> newValues) {\n            // make sure that cache is not refilled before commit\n            acquireWriteLock(logging.getId());\n            clearCache(logging);\n        }\n\n        @Override\n        public void handlePostLoggingChange(LoggingInfo logging) {\n            updateCache(logging);\n            releaseWriteLock(logging.getId());\n        }\n\n        @Override\n        public void handleServiceChange(\n                ServiceInfo service,\n                List<String> propertyNames,\n                List<Object> oldValues,\n                List<Object> newValues) {\n            // make sure that cache is not refilled before commit\n            acquireWriteLock(service.getId());\n            clearCache(service);\n        }\n\n        @Override\n        public void handlePostServiceChange(ServiceInfo service) {\n            updateCache(service);\n            releaseWriteLock(service.getId());\n        }\n\n        @Override\n        public void handleSettingsAdded(SettingsInfo settings) {\n            updateCache(settings);\n        }\n    }\n\n    public class CatalogReferenceUpdater implements CatalogVisitor {\n\n        private CatalogReferenceUpdater() {}\n\n        @Override\n        public void visit(Catalog catalog) {}\n\n        @Override\n        public void visit(WorkspaceInfo workspace) {}\n\n        @Override\n        public void visit(NamespaceInfo workspace) {}\n\n        public void visitStore(StoreInfo store) {\n            if (store.getWorkspace() != null) {\n                store.setWorkspace(getById(store.getWorkspace().getId(), WorkspaceInfo.class));\n            }\n        }\n\n        @Override\n        public void visit(DataStoreInfo dataStore) {\n            visitStore(dataStore);\n        }\n\n        @Override\n        public void visit(CoverageStoreInfo coverageStore) {\n            visitStore(coverageStore);\n        }\n\n        @Override\n        public void visit(WMSStoreInfo wmsStore) {\n            visitStore(wmsStore);\n        }\n\n        @Override\n        public void visit(WMTSStoreInfo wmsStore) {\n            visitStore(wmsStore);\n        }\n\n        public void visitResource(ResourceInfo resourceInfo) {\n            if (resourceInfo.getNamespace() != null) {\n                resourceInfo.setNamespace(\n                        getById(resourceInfo.getNamespace().getId(), NamespaceInfo.class));\n            }\n            resourceInfo.setStore(getById(resourceInfo.getStore().getId(), StoreInfo.class));\n        }\n\n        @Override\n        public void visit(FeatureTypeInfo featureType) {\n            visitResource(featureType);\n        }\n\n        @Override\n        public void visit(CoverageInfo coverage) {\n            visitResource(coverage);\n        }\n\n        @Override\n        public void visit(WMSLayerInfo wmsLayer) {\n            visitResource(wmsLayer);\n        }\n\n        @Override\n        public void visit(WMTSLayerInfo wmtsLayer) {\n            visitResource(wmtsLayer);\n        }\n\n        @Override\n        public void visit(LayerInfo layer) {\n            // avoids concurrent modification exceptions on the list contents\n            // Layer styles might not be actually persisted, in the case of WMS cascaded layers,\n            // where they are created on the fly based on the style names found in the caps\n            // documents. So check if the id is not null, in addition to checking if the style is\n            // not null.\n            synchronized (layer) {\n                if (layer.getDefaultStyle() != null && layer.getDefaultStyle().getId() != null) {\n                    layer.setDefaultStyle(\n                            getById(layer.getDefaultStyle().getId(), StyleInfo.class));\n                }\n                Set<StyleInfo> newStyles = new HashSet<>();\n                for (StyleInfo style : new ArrayList<>(layer.getStyles())) {\n                    if (style != null && style.getId() != null) {\n                        newStyles.add(getById(style.getId(), StyleInfo.class));\n                    }\n                }\n                layer.getStyles().clear();\n                layer.getStyles().addAll(newStyles);\n            }\n        }\n\n        @Override\n        public void visit(StyleInfo style) {\n            if (style.getWorkspace() != null) {\n                style.setWorkspace(getById(style.getWorkspace().getId(), WorkspaceInfo.class));\n            }\n        }\n\n        @Override\n        public void visit(LayerGroupInfo layerGroup) {\n            if (layerGroup.getWorkspace() != null) {\n                layerGroup.setWorkspace(\n                        getById(layerGroup.getWorkspace().getId(), WorkspaceInfo.class));\n            }\n            for (int i = 0; i < layerGroup.getLayers().size(); i++) {\n                if (layerGroup.getLayers().get(i) != null) {\n                    layerGroup\n                            .getLayers()\n                            .set(\n                                    i,\n                                    getById(\n                                            layerGroup.getLayers().get(i).getId(),\n                                            PublishedInfo.class));\n                }\n            }\n            if (layerGroup.getRootLayer() != null) {\n                layerGroup.setRootLayer(\n                        getById(layerGroup.getRootLayer().getId(), LayerInfo.class));\n            }\n            if (layerGroup.getRootLayerStyle() != null) {\n                layerGroup.setRootLayerStyle(\n                        getById(layerGroup.getRootLayerStyle().getId(), StyleInfo.class));\n            }\n            for (int i = 0; i < layerGroup.getStyles().size(); i++) {\n                if (layerGroup.getStyles().get(i) != null) {\n                    layerGroup\n                            .getStyles()\n                            .set(\n                                    i,\n                                    getById(\n                                            layerGroup.getStyles().get(i).getId(),\n                                            StyleInfo.class));\n                }\n            }\n        }\n    }\n}\n", "/* (c) 2014 Open Source Geospatial Foundation - all rights reserved\n * (c) 2001 - 2013 OpenPlans\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcconfig.internal;\n\nimport com.google.common.base.Joiner;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport javax.annotation.Nullable;\nimport javax.sql.DataSource;\n\npublic class Dialect {\n\n    public static Dialect detect(DataSource dataSource) {\n        Dialect dialect;\n        try {\n            Connection conn = dataSource.getConnection();\n            String driver = conn.getMetaData().getDriverName();\n            if (driver.contains(\"Oracle\")) {\n                dialect = new OracleDialect();\n            } else {\n                dialect = new Dialect();\n            }\n            conn.close();\n        } catch (SQLException ex) {\n            throw new RuntimeException(ex);\n        }\n        return dialect;\n    }\n\n    public void applyOffsetLimit(\n            StringBuilder sql, @Nullable Integer offset, @Nullable Integer limit) {\n        // some db's require limit to be present of offset is\n        if (offset != null && limit == null) {\n            limit = Integer.MAX_VALUE;\n        }\n        if (limit != null) {\n            sql.append(\" LIMIT \").append(limit);\n        }\n        if (offset != null) {\n            sql.append(\" OFFSET \").append(offset);\n        }\n    }\n\n    public String nextVal(String sequence) {\n        return \"DEFAULT\";\n    }\n\n    public CharSequence propertyName(String propertyName) {\n        return Joiner.on(\"\").join(identifierQualifier(), propertyName, identifierQualifier());\n    }\n\n    private String identifierQualifier() {\n        return \"\";\n    }\n\n    public CharSequence iLikeArgument(CharSequence subsequence) {\n        return Joiner.on(\"\").join(\"%\", String.valueOf(subsequence).toLowerCase(), \"%\");\n    }\n\n    public CharSequence iLikeNamedPreparedConstruct(String attributeName, String valueParam) {\n        return Joiner.on(\"\").join(\"LOWER(\", propertyName(attributeName), \") LIKE :\", valueParam);\n    }\n}\n", "/* (c) 2014 Open Source Geospatial Foundation - all rights reserved\n * (c) 2001 - 2013 OpenPlans\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcconfig.internal;\n\nimport static com.google.common.base.Preconditions.*;\n\nimport com.google.common.base.Preconditions;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.geoserver.catalog.Predicates;\nimport org.geoserver.function.IsInstanceOf;\nimport org.geotools.filter.Capabilities;\nimport org.geotools.filter.LikeFilterImpl;\nimport org.opengis.filter.And;\nimport org.opengis.filter.ExcludeFilter;\nimport org.opengis.filter.Filter;\nimport org.opengis.filter.FilterFactory;\nimport org.opengis.filter.FilterVisitor;\nimport org.opengis.filter.Id;\nimport org.opengis.filter.IncludeFilter;\nimport org.opengis.filter.MultiValuedFilter.MatchAction;\nimport org.opengis.filter.Not;\nimport org.opengis.filter.Or;\nimport org.opengis.filter.PropertyIsBetween;\nimport org.opengis.filter.PropertyIsEqualTo;\nimport org.opengis.filter.PropertyIsGreaterThan;\nimport org.opengis.filter.PropertyIsGreaterThanOrEqualTo;\nimport org.opengis.filter.PropertyIsLessThan;\nimport org.opengis.filter.PropertyIsLessThanOrEqualTo;\nimport org.opengis.filter.PropertyIsLike;\nimport org.opengis.filter.PropertyIsNil;\nimport org.opengis.filter.PropertyIsNotEqualTo;\nimport org.opengis.filter.PropertyIsNull;\nimport org.opengis.filter.capability.FilterCapabilities;\nimport org.opengis.filter.expression.Add;\nimport org.opengis.filter.expression.Divide;\nimport org.opengis.filter.expression.Expression;\nimport org.opengis.filter.expression.ExpressionVisitor;\nimport org.opengis.filter.expression.Function;\nimport org.opengis.filter.expression.Literal;\nimport org.opengis.filter.expression.Multiply;\nimport org.opengis.filter.expression.NilExpression;\nimport org.opengis.filter.expression.PropertyName;\nimport org.opengis.filter.expression.Subtract;\nimport org.opengis.filter.spatial.BBOX;\nimport org.opengis.filter.spatial.Beyond;\nimport org.opengis.filter.spatial.Contains;\nimport org.opengis.filter.spatial.Crosses;\nimport org.opengis.filter.spatial.DWithin;\nimport org.opengis.filter.spatial.Disjoint;\nimport org.opengis.filter.spatial.Equals;\nimport org.opengis.filter.spatial.Intersects;\nimport org.opengis.filter.spatial.Overlaps;\nimport org.opengis.filter.spatial.Touches;\nimport org.opengis.filter.spatial.Within;\nimport org.opengis.filter.temporal.After;\nimport org.opengis.filter.temporal.AnyInteracts;\nimport org.opengis.filter.temporal.Before;\nimport org.opengis.filter.temporal.Begins;\nimport org.opengis.filter.temporal.BegunBy;\nimport org.opengis.filter.temporal.During;\nimport org.opengis.filter.temporal.EndedBy;\nimport org.opengis.filter.temporal.Ends;\nimport org.opengis.filter.temporal.Meets;\nimport org.opengis.filter.temporal.MetBy;\nimport org.opengis.filter.temporal.OverlappedBy;\nimport org.opengis.filter.temporal.TContains;\nimport org.opengis.filter.temporal.TEquals;\nimport org.opengis.filter.temporal.TOverlaps;\n\n/** */\npublic class FilterToCatalogSQL implements FilterVisitor, ExpressionVisitor {\n\n    public static final FilterCapabilities CAPABILITIES;\n\n    static {\n        Capabilities builder = new Capabilities();\n        builder.addType(PropertyIsEqualTo.class);\n        builder.addType(PropertyIsNotEqualTo.class);\n        builder.addType(PropertyIsLike.class);\n        builder.addType(PropertyIsNull.class); // whether a property exists at all\n        builder.addType(PropertyIsNil.class); // whether the property exists AND it's value is null\n        builder.addType(And.class);\n        builder.addType(Or.class);\n        builder.addName(IsInstanceOf.NAME.getName());\n\n        CAPABILITIES = builder.getContents();\n    }\n\n    private final Class<?> queryType;\n\n    private final DbMappings dbMappings;\n\n    private final Map<String, Object> namedParams = new LinkedHashMap<>();\n\n    public FilterToCatalogSQL(Class<?> queryType, DbMappings dbMappings) {\n        this.queryType = queryType;\n        this.dbMappings = dbMappings;\n        List<Integer> concreteQueryTypes = dbMappings.getConcreteQueryTypes(queryType);\n        namedParams.put(\"types\", concreteQueryTypes);\n    }\n\n    /** */\n    public Map<String, Object> getNamedParameters() {\n        return namedParams;\n    }\n\n    private StringBuilder append(Object extraData, String... s) {\n        StringBuilder sb = (StringBuilder) extraData;\n        for (String p : s) {\n            sb.append(p);\n        }\n        return sb;\n    }\n\n    /** @see org.opengis.filter.FilterVisitor#visitNullFilter(java.lang.Object) */\n    @Override\n    public Object visitNullFilter(Object extraData) {\n        throw new UnsupportedOperationException(\"Do not use null as filter\");\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.ExcludeFilter,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(ExcludeFilter filter, Object extraData) {\n        append(extraData, \"0 = 1 /* EXCLUDE */\\n\");\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.IncludeFilter,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(IncludeFilter filter, Object extraData) {\n        append(extraData, \"1 = 1 /* INCLUDE */\\n\");\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsEqualTo,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsEqualTo filter, Object extraData) {\n\n        MatchAction matchAction = filter.getMatchAction();\n        boolean matchingCase = filter.isMatchingCase();\n\n        if (!(filter.getExpression1() instanceof Literal)\n                && !(filter.getExpression2() instanceof Literal)) {\n\n            // comparing two fields with each other\n\n            PropertyName expression1 = (PropertyName) filter.getExpression1();\n            PropertyName expression2 = (PropertyName) filter.getExpression2();\n\n            final String propertyTypesParam1 = propertyTypesParam(expression1);\n            final String propertyTypesParam2 = propertyTypesParam(expression2);\n\n            // respect matchCase\n            String valueCol1 = matchingCase ? \"o1.value\" : \"UPPER(o1.value)\";\n            String valueCol2 = matchingCase ? \"o2.value\" : \"UPPER(o2.value)\";\n\n            StringBuilder builder;\n\n            switch (matchAction) {\n                    // respect matchaction\n                case ALL: // all = another value for the property may not occur\n                    builder =\n                            append(\n                                    extraData,\n                                    \"oid NOT IN (SELECT o1.oid FROM object_property o1, object_property o2 WHERE o1.oid = o2.oid \",\n                                    \"AND o1.property_type IN (:\",\n                                    propertyTypesParam1,\n                                    \") \",\n                                    \"AND o2.property_type IN (:\",\n                                    propertyTypesParam2,\n                                    \") \",\n                                    \"AND \",\n                                    valueCol1,\n                                    \" != \",\n                                    valueCol2,\n                                    \") /* \",\n                                    filter.toString(),\n                                    \" */\\n\");\n                    break;\n                case ANY: // any = the value for the property must occur at least once\n                    builder =\n                            append(\n                                    extraData,\n                                    \"oid IN (SELECT o1.oid FROM object_property o1, object_property o2 WHERE o1.oid = o2.oid \",\n                                    \"AND o1.property_type IN (:\",\n                                    propertyTypesParam1,\n                                    \") \",\n                                    \"AND o2.property_type IN (:\",\n                                    propertyTypesParam2,\n                                    \") \",\n                                    \"AND \",\n                                    valueCol1,\n                                    \" = \",\n                                    valueCol2,\n                                    \") /* \",\n                                    filter.toString(),\n                                    \" */\\n\");\n                    break;\n                case ONE: // one = the value for the property must occur exactly once\n                    builder =\n                            append(\n                                    extraData,\n                                    \"oid IN (SELECT o1.oid FROM object_property o1, object_property o2 WHERE o1.oid = o2.oid \",\n                                    \"AND o1.property_type IN (:\",\n                                    propertyTypesParam1,\n                                    \") \",\n                                    \"AND o2.property_type IN (:\",\n                                    propertyTypesParam2,\n                                    \") \",\n                                    \"AND \",\n                                    valueCol1,\n                                    \" = \",\n                                    valueCol2,\n                                    \" GROUP BY (oid) HAVING COUNT(oid) = 1) /* \",\n                                    filter.toString(),\n                                    \"/* \",\n                                    filter.toString(),\n                                    \" */\\n\");\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"MatchAction: \" + matchAction);\n            }\n\n            return builder;\n\n        } else {\n\n            if (filter.getExpression1() instanceof IsInstanceOf) {\n                StringBuilder builder =\n                        append(extraData, handleInstanceOf((IsInstanceOf) filter.getExpression1()));\n                return builder;\n            }\n\n            // comparing a literal with a field\n\n            PropertyName expression1;\n            Literal expression2;\n\n            // decide which is the literal\n            if (filter.getExpression1() instanceof Literal) {\n                expression1 = (PropertyName) filter.getExpression2();\n                expression2 = (Literal) filter.getExpression1();\n\n            } else {\n                expression1 = (PropertyName) filter.getExpression1();\n                expression2 = (Literal) filter.getExpression2();\n            }\n\n            final String propertyTypesParam = propertyTypesParam(expression1);\n\n            // respect match case\n            String expectedValue = expression2.evaluate(null, String.class);\n            if (!matchingCase) {\n                expectedValue = expectedValue.toUpperCase();\n            }\n            String valueParam = newParam(\"value\", expectedValue);\n\n            StringBuilder builder;\n            String valueCol = matchingCase ? \"value\" : \"UPPER(value)\";\n\n            switch (matchAction) {\n                    // respect match action\n                case ALL: // all = another value for the property may not occur\n                    builder =\n                            append(\n                                    extraData,\n                                    \"oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                                    propertyTypesParam,\n                                    \") AND \",\n                                    valueCol,\n                                    \" != :\",\n                                    valueParam,\n                                    \") /* \",\n                                    filter.toString(),\n                                    \" */\\n\");\n                    break;\n                case ANY: // any = the value for the property must occur at least once\n                    builder =\n                            append(\n                                    extraData,\n                                    \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                                    propertyTypesParam,\n                                    \") AND \",\n                                    valueCol,\n                                    \" = :\",\n                                    valueParam,\n                                    \") /* \",\n                                    filter.toString(),\n                                    \" */\\n\");\n                    break;\n                case ONE: // one = the value for the property must occur exactly once\n                    builder =\n                            append(\n                                    extraData,\n                                    \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                                    propertyTypesParam,\n                                    \") AND \",\n                                    valueCol,\n                                    \" = :\",\n                                    valueParam,\n                                    \" GROUP BY (oid) HAVING COUNT(oid) = 1) /* \",\n                                    filter.toString(),\n                                    \" */\\n\");\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"MatchAction: \" + matchAction);\n            }\n\n            return builder;\n        }\n    }\n\n    private String handleInstanceOf(IsInstanceOf instanceOf) {\n        Expression expression1 = instanceOf.getParameters().get(0);\n\n        Class<?> clazz = expression1.evaluate(null, Class.class);\n\n        if (clazz == null || dbMappings.getTypeId(clazz) == null) {\n            return \"0 = 1 /* EXCLUDE */\\n\";\n        }\n\n        Integer typeId = dbMappings.getTypeId(clazz);\n\n        return \"type_id = \" + typeId + \" /* isInstanceOf \" + clazz.getName() + \" */\\n\";\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsLike,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsLike filter, Object extraData) {\n        final PropertyName expression1 = (PropertyName) filter.getExpression();\n        // TODO: check for indexed property name\n\n        final String propertyTypesParam = propertyTypesParam(expression1);\n\n        final String literal = filter.getLiteral();\n        final MatchAction matchAction = filter.getMatchAction();\n        final char esc = filter.getEscape().charAt(0);\n        final char multi = filter.getWildCard().charAt(0);\n        final char single = filter.getSingleChar().charAt(0);\n        final boolean matchCase = filter.isMatchingCase();\n\n        final String pattern =\n                LikeFilterImpl.convertToSQL92(esc, multi, single, matchCase, literal);\n\n        // respect match case\n        String valueCol = matchCase ? \"value\" : \"UPPER(value)\";\n\n        StringBuilder builder;\n\n        switch (matchAction) {\n                // respect match action\n            case ALL: // all = another value for the property may not occur\n                builder =\n                        append(\n                                extraData,\n                                \"oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                                propertyTypesParam,\n                                \") AND \",\n                                valueCol,\n                                \" NOT LIKE '\",\n                                pattern,\n                                \"') /* \",\n                                filter.toString(),\n                                \" */\\n\");\n                break;\n            case ANY: // any = the value for the property must occur at least once\n                builder =\n                        append(\n                                extraData,\n                                \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                                propertyTypesParam,\n                                \") AND \",\n                                valueCol,\n                                \" LIKE '\",\n                                pattern,\n                                \"') /* \",\n                                filter.toString(),\n                                \" */\\n\");\n                break;\n            case ONE: // one = the value for the property must occur exactly once\n                builder =\n                        append(\n                                extraData,\n                                \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                                propertyTypesParam,\n                                \") AND \",\n                                valueCol,\n                                \" LIKE '\",\n                                pattern,\n                                \"' \",\n                                \"GROUP BY (oid) HAVING COUNT(oid) = 1) /* \",\n                                filter.toString(),\n                                \" */\\n\");\n                break;\n            default:\n                throw new IllegalArgumentException(\"MatchAction: \" + matchAction);\n        }\n\n        return builder;\n    }\n\n    private String propertyTypesParam(final PropertyName property) {\n\n        final String propertyTypesParam;\n        final Set<PropertyType> propertyTypes;\n\n        String propertyName = property.getPropertyName();\n        propertyTypes = dbMappings.getPropertyTypes(queryType, propertyName);\n\n        Preconditions.checkState(\n                !propertyTypes.isEmpty(),\n                \"Found no mapping for property '\" + property + \"' of type \" + queryType.getName());\n\n        List<Integer> propTypeIds = new ArrayList<Integer>(propertyTypes.size());\n        for (PropertyType pt : propertyTypes) {\n            Integer propertyTypeId = pt.getOid();\n            propTypeIds.add(propertyTypeId);\n        }\n        propertyTypesParam = newParam(\"ptype\", propTypeIds);\n        return propertyTypesParam;\n    }\n\n    /** */\n    private String newParam(String paramNamePrefix, Object paramValue) {\n        int sufix = 0;\n        while (true) {\n            String paramName = paramNamePrefix + sufix;\n            if (!namedParams.containsKey(paramName)) {\n                namedParams.put(paramName, paramValue);\n                return paramName;\n            }\n            sufix++;\n        }\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsNotEqualTo,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsNotEqualTo filter, Object extraData) {\n        // equivalent to not(propertyisequalto)\n\n        FilterFactory ff = Predicates.factory;\n        Not not =\n                ff.not(\n                        ff.equal(\n                                filter.getExpression1(),\n                                filter.getExpression2(),\n                                filter.isMatchingCase(),\n                                filter.getMatchAction()));\n        visit(not, extraData);\n\n        return extraData;\n    }\n\n    /** @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.And, java.lang.Object) */\n    @Override\n    public Object visit(And filter, Object extraData) {\n        StringBuilder sql = (StringBuilder) extraData;\n\n        List<Filter> children = filter.getChildren();\n        checkArgument(children.size() > 0);\n        sql.append(\"(\\n    \");\n\n        for (Iterator<Filter> it = children.iterator(); it.hasNext(); ) {\n            Filter child = it.next();\n            sql = (StringBuilder) child.accept(this, sql);\n            if (it.hasNext()) {\n                sql = append(extraData, \"    AND\\n    \");\n            }\n        }\n        sql.append(\")\");\n        return sql;\n    }\n\n    /** @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.Or, java.lang.Object) */\n    @Override\n    public Object visit(Or filter, Object extraData) {\n        StringBuilder sql = (StringBuilder) extraData;\n\n        List<Filter> children = filter.getChildren();\n        checkArgument(children.size() > 0);\n        sql.append(\"(\");\n        for (Iterator<Filter> it = children.iterator(); it.hasNext(); ) {\n            Filter child = it.next();\n            sql = (StringBuilder) child.accept(this, sql);\n            if (it.hasNext()) {\n                sql = append(extraData, \"    OR\\n    \");\n            }\n        }\n        sql.append(\")\");\n        return sql;\n    }\n\n    /** @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.Id, java.lang.Object) */\n    @Override\n    public Object visit(Id filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /** @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.Not, java.lang.Object) */\n    @Override\n    public Object visit(Not filter, Object extraData) {\n        filter.getFilter().accept(this, append(extraData, \"NOT (\"));\n        return append(extraData, \")\");\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsBetween,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsBetween filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsGreaterThan,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsGreaterThan filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsGreaterThanOrEqualTo,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsGreaterThanOrEqualTo filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsLessThan,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsLessThan filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsLessThanOrEqualTo,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsLessThanOrEqualTo filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsNull,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsNull filter, Object extraData) {\n        final PropertyName propertyName = (PropertyName) filter.getExpression();\n        final String propertyTypesParam = propertyTypesParam(propertyName);\n\n        StringBuilder builder =\n                append(\n                        extraData,\n                        \"(oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                        propertyTypesParam,\n                        \") AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                                + propertyTypesParam\n                                + \"))) /* \",\n                        filter.toString(),\n                        \" */\\n\");\n        return builder;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsNil,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsNil filter, Object extraData) {\n        final PropertyName propertyName = (PropertyName) filter.getExpression();\n        final String propertyTypesParam = propertyTypesParam(propertyName);\n\n        StringBuilder builder =\n                append(\n                        extraData,\n                        \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                        propertyTypesParam,\n                        \") AND value IS NULL) /* \",\n                        filter.toString(),\n                        \" */\\n\");\n        return builder;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.BBOX,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(BBOX filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Beyond,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Beyond filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Contains,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Contains filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Crosses,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Crosses filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Disjoint,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Disjoint filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.DWithin,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(DWithin filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Equals,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Equals filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Intersects,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Intersects filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Overlaps,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Overlaps filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Touches,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Touches filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Within,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Within filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.After,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(After after, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.AnyInteracts,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(AnyInteracts anyInteracts, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.Before,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Before before, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.Begins,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Begins begins, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.BegunBy,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(BegunBy begunBy, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.During,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(During during, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.EndedBy,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(EndedBy endedBy, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.Ends,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Ends ends, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.Meets,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Meets meets, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.MetBy,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(MetBy metBy, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.OverlappedBy,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(OverlappedBy overlappedBy, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.TContains,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(TContains contains, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.TEquals,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(TEquals equals, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.TOverlaps,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(TOverlaps contains, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.NilExpression,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(NilExpression expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.Add,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Add expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.Divide,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Divide expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.Function,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Function expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.Literal,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Literal expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.Multiply,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Multiply expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.PropertyName,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyName expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.Subtract,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Subtract expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n}\n", "/* (c) 2014 Open Source Geospatial Foundation - all rights reserved\n * (c) 2001 - 2014 OpenPlans\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcconfig.internal;\n\nimport javax.annotation.Nullable;\n\npublic class OracleDialect extends Dialect {\n\n    @Override\n    public void applyOffsetLimit(\n            StringBuilder sql, @Nullable Integer offset, @Nullable Integer limit) {\n        // some db's require limit to be present of offset is\n        if (offset != null && limit == null) {\n            limit = Integer.MAX_VALUE; // ensure we don't wrap around\n        }\n        if (limit != null && offset == null) {\n            offset = 0;\n            limit += 1; // not zero-based\n        }\n        if (offset != null && limit != null) {\n            sql.insert(0, \"SELECT * FROM (SELECT query.*, rownum rnum FROM (\\n\");\n            sql.append(\") query\\n\");\n            if (limit != Integer.MAX_VALUE) {\n                limit = offset + limit;\n            }\n            sql.append(\"WHERE rownum <= \").append(limit).append(\")\\n\");\n            sql.append(\"WHERE rnum > \").append(offset);\n        }\n    }\n\n    @Override\n    public String nextVal(String sequence) {\n        return sequence + \".nextval\";\n    }\n}\n", "/* (c) 2014 Open Source Geospatial Foundation - all rights reserved\n * (c) 2001 - 2013 OpenPlans\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcconfig.internal;\n\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.geoserver.catalog.Info;\nimport org.geotools.factory.CommonFactoryFinder;\nimport org.geotools.filter.Capabilities;\nimport org.geotools.filter.visitor.CapabilitiesFilterSplitter;\nimport org.geotools.filter.visitor.ClientTransactionAccessor;\nimport org.geotools.filter.visitor.LiteralDemultiplyingFilterVisitor;\nimport org.geotools.filter.visitor.SimplifyingFilterVisitor;\nimport org.geotools.util.logging.Logging;\nimport org.opengis.feature.type.FeatureType;\nimport org.opengis.filter.Filter;\nimport org.opengis.filter.sort.SortBy;\nimport org.opengis.filter.sort.SortOrder;\n\nclass QueryBuilder<T extends Info> {\n\n    private static final Logger LOGGER = Logging.getLogger(QueryBuilder.class);\n\n    @SuppressWarnings(\"unused\")\n    private static final SortBy DEFAULT_ORDER =\n            CommonFactoryFinder.getFilterFactory().sort(\"id\", SortOrder.ASCENDING);\n\n    private Integer offset;\n\n    private Integer limit;\n\n    private SortBy[] sortOrder;\n\n    private final boolean isCountQuery;\n\n    // yuck\n    private final Dialect dialect;\n\n    private Class<T> queryType;\n\n    private FilterToCatalogSQL predicateBuilder;\n\n    private DbMappings dbMappings;\n\n    private Filter originalFilter;\n\n    private Filter supportedFilter;\n\n    private Filter unsupportedFilter;\n\n    private boolean offsetLimitApplied = false;\n\n    /** */\n    private QueryBuilder(\n            Dialect dialect,\n            final Class<T> clazz,\n            DbMappings dbMappings,\n            final boolean isCountQuery) {\n        this.dialect = dialect;\n        this.queryType = clazz;\n        this.dbMappings = dbMappings;\n        this.isCountQuery = isCountQuery;\n        this.originalFilter = this.supportedFilter = this.unsupportedFilter = Filter.INCLUDE;\n    }\n\n    public static <T extends Info> QueryBuilder<T> forCount(\n            Dialect dialect, final Class<T> clazz, DbMappings dbMappings) {\n        return new QueryBuilder<T>(dialect, clazz, dbMappings, true);\n    }\n\n    public static <T extends Info> QueryBuilder<T> forIds(\n            Dialect dialect, final Class<T> clazz, DbMappings dbMappings) {\n        return new QueryBuilder<T>(dialect, clazz, dbMappings, false);\n    }\n\n    public Filter getUnsupportedFilter() {\n        return unsupportedFilter;\n    }\n\n    public Filter getSupportedFilter() {\n        return supportedFilter;\n    }\n\n    public Map<String, Object> getNamedParameters() {\n        Map<String, Object> params = Collections.emptyMap();\n        if (predicateBuilder != null) {\n            params = predicateBuilder.getNamedParameters();\n        }\n        return params;\n    }\n\n    public QueryBuilder<T> offset(Integer offset) {\n        this.offset = offset;\n        return this;\n    }\n\n    public QueryBuilder<T> limit(Integer limit) {\n        this.limit = limit;\n        return this;\n    }\n\n    public QueryBuilder<T> sortOrder(SortBy order) {\n        if (order == null) {\n            this.sortOrder();\n        } else {\n            this.sortOrder(new SortBy[] {order});\n        }\n        return this;\n    }\n\n    public QueryBuilder<T> sortOrder(SortBy... order) {\n        if (order == null || order.length == 0) {\n            this.sortOrder = null;\n        } else {\n            this.sortOrder = order;\n        }\n        return this;\n    }\n\n    public QueryBuilder<T> filter(Filter filter) {\n        this.originalFilter = filter;\n        return this;\n    }\n\n    private void querySortBy(StringBuilder query, StringBuilder whereClause, SortBy[] orders) {\n\n        /*\n         * Start with the oid and id from the object table selecting for type and the filter.\n         *\n         * Then left join on oid for each property to sort by to turn it into an attribute.\n         *\n         * The sort each of the created attribute.\n         */\n\n        // Need to put together the ORDER BY clause as we go and then add it at the end\n        StringBuilder orderBy = new StringBuilder();\n        orderBy.append(\"ORDER BY \");\n\n        int i = 0;\n\n        query.append(\"SELECT id FROM \");\n\n        query.append(\"\\n    (SELECT oid, id FROM object WHERE \");\n        if (queryType != null) {\n            query.append(\"type_id IN (:types) /* \")\n                    .append(queryType.getCanonicalName())\n                    .append(\" */\\n      AND \");\n        }\n        query.append(whereClause).append(\") object\");\n\n        for (SortBy order : orders) {\n            final String sortProperty = order.getPropertyName().getPropertyName();\n            final String subSelectName = \"subSelect\" + i;\n            final String attributeName = \"prop\" + i;\n            final String propertyParamName = \"sortProperty\" + i;\n\n            final Set<Integer> sortPropertyTypeIds;\n            sortPropertyTypeIds = dbMappings.getPropertyTypeIds(queryType, sortProperty);\n\n            // Store the property type ID as a named parameter\n            Map<String, Object> namedParameters = getNamedParameters();\n            namedParameters.put(propertyParamName, sortPropertyTypeIds);\n\n            query.append(\"\\n  LEFT JOIN\");\n            query.append(\"\\n    (SELECT oid, value \")\n                    .append(attributeName)\n                    .append(\" FROM \\n      object_property WHERE property_type IN (:\")\n                    .append(propertyParamName)\n                    .append(\")) \")\n                    .append(subSelectName);\n\n            query.append(\" /* \")\n                    .append(order.getPropertyName().getPropertyName())\n                    .append(\" \")\n                    .append(ascDesc(order))\n                    .append(\" */\");\n\n            query.append(\"\\n  ON object.oid = \").append(subSelectName).append(\".oid\");\n            // Update the ORDER BY clause to be added later\n            if (i > 0) orderBy.append(\", \");\n            orderBy.append(attributeName).append(\" \").append(ascDesc(order));\n\n            i++;\n        }\n\n        query.append(\"\\n  \").append(orderBy);\n    }\n\n    private StringBuilder buildWhereClause() {\n        final SimplifyingFilterVisitor filterSimplifier = new SimplifyingFilterVisitor();\n\n        this.predicateBuilder = new FilterToCatalogSQL(this.queryType, this.dbMappings);\n        Capabilities fcs = new Capabilities(FilterToCatalogSQL.CAPABILITIES);\n        FeatureType parent = null;\n        // use this to instruct the filter splitter which filters can be encoded depending on\n        // whether a db mapping for a given property name exists\n        ClientTransactionAccessor transactionAccessor =\n                new ClientTransactionAccessor() {\n\n                    @Override\n                    public Filter getUpdateFilter(final String attributePath) {\n                        Set<PropertyType> propertyTypes;\n                        propertyTypes = dbMappings.getPropertyTypes(queryType, attributePath);\n\n                        final boolean isMappedProp = !propertyTypes.isEmpty();\n\n                        if (isMappedProp) {\n                            // continue normally\n                            return null;\n                        } else if (LOGGER.isLoggable(Level.FINER)) {\n                            LOGGER.finer(\"Unable to encode property: \" + attributePath);\n                        }\n                        // tell the caps filter splitter this property name is not encodable\n                        return Filter.EXCLUDE;\n                    }\n\n                    @Override\n                    public Filter getDeleteFilter() {\n                        return null;\n                    }\n                };\n\n        CapabilitiesFilterSplitter filterSplitter;\n        filterSplitter = new CapabilitiesFilterSplitter(fcs, parent, transactionAccessor);\n\n        final Filter filter = (Filter) this.originalFilter.accept(filterSimplifier, null);\n        filter.accept(filterSplitter, null);\n\n        Filter supported = filterSplitter.getFilterPre();\n        Filter unsupported = filterSplitter.getFilterPost();\n        Filter demultipliedFilter =\n                (Filter) supported.accept(new LiteralDemultiplyingFilterVisitor(), null);\n        this.supportedFilter = (Filter) demultipliedFilter.accept(filterSimplifier, null);\n        this.unsupportedFilter = (Filter) unsupported.accept(filterSimplifier, null);\n\n        StringBuilder whereClause = new StringBuilder();\n        return (StringBuilder) this.supportedFilter.accept(predicateBuilder, whereClause);\n    }\n\n    public StringBuilder build() {\n\n        StringBuilder whereClause = buildWhereClause();\n\n        StringBuilder query = new StringBuilder();\n        if (isCountQuery) {\n            if (Filter.INCLUDE.equals(this.originalFilter)) {\n                query.append(\"SELECT COUNT(oid) FROM object WHERE type_id IN (:types)\");\n            } else {\n                query.append(\"SELECT COUNT(oid) FROM object WHERE type_id IN (:types) AND (\\n\");\n                query.append(whereClause).append(\")\");\n            }\n        } else {\n            SortBy[] orders = this.sortOrder;\n            if (orders == null) {\n                query.append(\"SELECT id FROM object WHERE type_id IN (:types) AND (\\n\");\n                query.append(whereClause).append(\")\");\n                query.append(\" ORDER BY oid\");\n            } else {\n                querySortBy(query, whereClause, orders);\n            }\n            applyOffsetLimit(query);\n        }\n\n        return query;\n    }\n\n    /** When the query was built, were the offset and limit included. */\n    public boolean isOffsetLimitApplied() {\n        return offsetLimitApplied;\n    }\n\n    private static String ascDesc(SortBy order) {\n        return SortOrder.ASCENDING.equals(order.getSortOrder()) ? \"ASC\" : \"DESC\";\n    }\n\n    protected void applyOffsetLimit(StringBuilder sql) {\n        if (unsupportedFilter.equals(Filter.INCLUDE)) {\n            dialect.applyOffsetLimit(sql, offset, limit);\n            offsetLimitApplied = true;\n        } else {\n            offsetLimitApplied = false;\n        }\n    }\n}\n", "/* (c) 2017 Open Source Geospatial Foundation - all rights reserved\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcloader;\n\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.LinkedHashSet;\nimport java.util.Properties;\nimport org.geoserver.platform.resource.Resource;\nimport org.geoserver.platform.resource.Resources;\n\npublic class JDBCLoaderProperties extends Properties {\n\n    private static final long serialVersionUID = -6758388267074914346L;\n\n    // maintain order of keys to prevent writing out in random order\n    LinkedHashSet<Object> keys = new LinkedHashSet<Object>();\n\n    // factory\n    JDBCLoaderPropertiesFactoryBean factory;\n\n    String datasourceId = null;\n\n    public JDBCLoaderProperties(JDBCLoaderPropertiesFactoryBean factory) {\n        this.factory = factory;\n    }\n\n    @Override\n    public synchronized Enumeration<Object> keys() {\n        return Collections.enumeration(keys);\n    }\n\n    @Override\n    public synchronized Object put(Object key, Object value) {\n        keys.add(key);\n        return super.put(key, value);\n    }\n\n    public boolean isEnabled() {\n        return Boolean.valueOf(getProperty(\"enabled\", \"false\"));\n    }\n\n    public Optional<String> getJdbcUrl() {\n        return Optional.fromNullable(fillInPlaceholders(getProperty(\"jdbcUrl\")));\n    }\n\n    public void setJdbcUrl(String jdbcUrl) {\n        setProperty(\"jdbcUrl\", jdbcUrl);\n    }\n\n    public boolean isInitDb() {\n        return Boolean.parseBoolean(getProperty(\"initdb\", \"false\"));\n    }\n\n    public void setInitDb(boolean initdb) {\n        setProperty(\"initdb\", String.valueOf(initdb));\n    }\n\n    public Resource getInitScript() {\n        String initScript = getProperty(\"initScript\");\n        if (initScript == null) {\n            return null;\n        }\n\n        Resource resource = Resources.fromPath(initScript, factory.getDataDir());\n        Preconditions.checkState(\n                Resources.exists(resource), \"Init script does not exist: \" + resource.path());\n\n        return resource;\n    }\n\n    public boolean isImport() {\n        return Boolean.parseBoolean(getProperty(\"import\", \"false\"));\n    }\n\n    public void setImport(boolean imprt) {\n        setProperty(\"import\", String.valueOf(imprt));\n    }\n\n    public void save() throws IOException {\n        factory.saveConfig(this);\n    }\n\n    String fillInPlaceholders(String value) {\n        return value != null\n                ? value.replace(\"${GEOSERVER_DATA_DIR}\", factory.getDataDirStr())\n                : value;\n    }\n\n    public Optional<String> getJndiName() {\n        return Optional.fromNullable(getProperty(\"jndiName\"));\n    }\n\n    public void setJndiName(String name) {\n        setProperty(\"jndiName\", name);\n    }\n\n    public String getDatasourceId() {\n        return datasourceId;\n    }\n\n    public void setDatasourceId(String datasourceId) {\n        this.datasourceId = datasourceId;\n    }\n}\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\" \n  xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n  xmlns:tx = \"http://www.springframework.org/schema/tx\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n        http://www.springframework.org/schema/jdbc   http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd\n        http://www.springframework.org/schema/tx     http://www.springframework.org/schema/tx/spring-tx-3.0.xsd\n        \">\n\n  <!-- main configuration, loaded via factory bean -->\n  <bean id=\"jdbcConfigProperties\" \n    class=\"org.geoserver.jdbcconfig.internal.JDBCConfigPropertiesFactoryBean\">\n      <constructor-arg ref=\"resourceStore\"/>\n  </bean>\n\n  <!-- data source, also loaded and configured via factory bean -->\n  <bean id=\"jdbcConfigDataSource\" class=\"org.geoserver.jdbcloader.DataSourceFactoryBean\">\n    <constructor-arg ref=\"jdbcConfigProperties\" />\n  </bean>\n\n  <!-- transaction manager -->\n  <bean id=\"jdbcConfigTransactionManager\"\n  \tclass=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <property name=\"dataSource\" ref=\"jdbcConfigDataSource\" />\n  </bean>\n\n  <tx:annotation-driven />\n\n  <bean id=\"jdbcPersistenceBinding\" class=\"org.geoserver.jdbcconfig.internal.XStreamInfoSerialBinding\">\n    <constructor-arg ref=\"xstreamPersisterFactory\" />\n  </bean>\n\n  <bean id=\"JDBCConfigDB\" class=\"org.geoserver.jdbcconfig.internal.ConfigDatabase\">\n    <constructor-arg ref=\"jdbcConfigDataSource\" />\n    <constructor-arg ref=\"jdbcPersistenceBinding\" />\n  </bean>\n\n  <bean id=\"JDBCCatalogFacade\" class=\"org.geoserver.jdbcconfig.catalog.JDBCCatalogFacade\">\n    <constructor-arg ref=\"JDBCConfigDB\" />\n  </bean>\n\n  <bean id=\"JDBCGeoServerFacade\" class=\"org.geoserver.jdbcconfig.config.JDBCGeoServerFacade\">\n    <constructor-arg ref=\"JDBCConfigDB\" />\n    <property name=\"resourceLoader\" ref=\"resourceLoader\" />\n    <property name=\"ddResourceStore\" ref=\"dataDirectoryResourceStore\" />\n  </bean>\n\n  <bean id=\"JDBCGeoServerLoader\" class=\"org.geoserver.jdbcconfig.JDBCGeoServerLoader\">\n    <description>\n      Replaces the default GeoServerLoader to establish the JDBCCatalogFacade and JDBCGeoServerFacade\n    </description>\n    <constructor-arg ref=\"resourceLoader\" />\n    <constructor-arg ref=\"jdbcConfigProperties\" />\n    <property name=\"catalogFacade\" ref=\"JDBCCatalogFacade\" />\n    <property name=\"geoServerFacade\" ref=\"JDBCGeoServerFacade\" />\n  </bean>\n  \n  <bean id=\"JDBCConfigStatusProvider\" class=\"org.geoserver.jdbcconfig.web.JDBCConfigStatusProvider\">\n    <constructor-arg ref=\"jdbcConfigProperties\" />\n  </bean>\n  \n  <bean id=\"JDBCCacheProvider\" class=\"org.geoserver.jdbcconfig.internal.JDBCCacheProvider\"/>\n    <bean id=\"JDBCConfigXStreamPersisterInitializer\" class=\"org.geoserver.jdbcconfig.internal.JDBCConfigXStreamPersisterInitializer\"/>\n\n  <bean id=\"JDBCLifecycleHandler\" class=\"org.geoserver.jdbcconfig.internal.JDBCLifecycleHandler\">\n    <constructor-arg ref=\"JDBCConfigDB\"/>\n  </bean>\n</beans>\n", "# flag enabling/disabling jdbcconfig module\nenabled=false\n\n# flag controlling whether database should be initialized \ninitdb=true\n\n# script to use to initialize the database\ninitScript=jdbcconfig/scripts/initdb.postgres.sql\n\n# flag controlling whether the existing (non-db) catalog should be imported\nimport=true\n\n# database connection info\njdbcUrl=jdbc:postgresql://localhost:5432/gscatalog\ndriverClassName=org.postgresql.Driver\nusername=postgres\npassword=\n\n#\n# connection pooling/management parameters\n#\n\n# minimum connections in pool  \npool.minIdle=4\n\n# maximum connections in pool\npool.maxActive=10\n\n# whether to pool prepared statements\npool.poolPreparedStatements=true\n\n# size of prepared statement cache, only used if pool.poolPreparedStatements = true \npool.maxOpenPreparedStatements=50\n\n# whether to validate connections when obtaining from the pool\npool.testOnBorrow=true\n\n# validation query for connections from pool, must be set when pool.testOnBorrow = true\npool.validationQuery=SELECT now()\n\n# The indication of whether objects will be validated by the idle object evictor (if any). If an object fails to validate, it will be dropped from the pool. \npool.testWhileIdle=false\n\n# The number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no idle object evictor thread will be run. \npool.timeBetweenEvictionRunsMillis=-1L", "# This is a sample configuration file for running the GeoServer Catalog against a H2 database.\n# Adapt the url, user, password, and other configuration options to your set up and rename this\n# file as jdbcconfig.properties\n#\n# Note the initialization DDL script for H2 will be automatically run at startup.\n# The initialization script is located in the jdbcconfig_scripts directory, named initdb.h2.sql\n# The importCatalog configuration option tells GeoServer whether to import the current catalog from the file system\n# to the database or not. If set to true, it will be imported and the config option will be set the value 'false'\n# for the next start up to avoid trying to re-import the catalog configuration.\n\nenabled=true\n\ninitdb=true\ninitScript=jdbcconfig/scripts/initdb.h2.sql\nimport=true\n\njdbcUrl=jdbc:h2:file:${GEOSERVER_DATA_DIR}/jdbcconfig/catalog;AUTO_SERVER=TRUE\ndriverClassName=org.h2.Driver\nusername=sa\npassword=\n\n#\n# connection pooling/management parameters\n#\n\n# minimum connections in pool  \npool.minIdle=4\n\n# maximum connections in pool\npool.maxActive=10\n\n# whether to pool prepared statements\npool.poolPreparedStatements=true\n\n# size of prepared statement cache, only used if pool.poolPreparedStatements = true \npool.maxOpenPreparedStatements=50\n\n# whether to validate connections when obtaining from the pool\npool.testOnBorrow=true\n\n# validation query for connections from pool, must be set when pool.testOnBorrow = true\npool.validationQuery=SELECT now()\n\n\n# The indication of whether objects will be validated by the idle object evictor (if any). If an object fails to validate, it will be dropped from the pool. \npool.testWhileIdle=false\n\n# The number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no idle object evictor thread will be run. \npool.timeBetweenEvictionRunsMillis=-1L", "# This is a sample configuration file for running the GeoServer Catalog against a PostgreSQL \n# database.\n#\n# Set the jndiName for a JNDI dataSource provided by your container, or set the jdbcUrl, username, \n# password, and pool.* parameters appropriately to connect directly. If both are specified, then \n# JNDI lookup will be attempted first, and a direct JDBC connection if that fails.\n#\n# Note the initialization DDL script for PostgreSQL must have been run before starting GeoServer.\n# The initialization script is located in the jdbcconfig_scripts directory, named \n# 'initdb.postgres.sql'.\n#\n# The import configuration option tells GeoServer whether to import the current catalog from the \n# file system to the database or not. If set to true, it will be imported and the config option will\n# be set the value 'false' for the next start up to avoid trying to re-import the catalog \n# configuration.\n\n#\n# Use JDBCConfig.  Turn off to use the data directory for all configuration instead.\n#\nenabled=true\n\n#\n# Initialize an empty database.  Should be set to false and done manually before starting GeoServer \n# when using Postgres\n#\ninitdb=true\ninitScript=jdbcconfig/scripts/initdb.postgres.sql\n\n#\n# Import the data directory into a new database.  Should only be used on the first run.\n#\nimport=true\n\n#\n# The JNDI name for the data source.  Uncomment to use JNDI.\n#\n#jndiName=java\\:/comp/env/jdbc/gsconfig\n\n#\n# JDBC direct connection parameters.  Comment out following lines if using JNDI and you don't want \n# a fallback.\n#\njdbcUrl=jdbc:postgresql://localhost:5432/gscatalog\ndriverClassName=org.postgresql.Driver\nusername=postgres\npassword=\n\n#\n# connection pooling/management parameters\n#\n\n# minimum connections in pool  \npool.minIdle=4\n\n# maximum connections in pool\npool.maxActive=10\n\n# whether to pool prepared statements\npool.poolPreparedStatements=true\n\n# size of prepared statement cache, only used if pool.poolPreparedStatements = true \npool.maxOpenPreparedStatements=50\n\n# whether to validate connections when obtaining from the pool\npool.testOnBorrow=true\n\n# validation query for connections from pool, must be set when pool.testOnBorrow = true\npool.validationQuery=SELECT now()\n\n# The indication of whether objects will be validated by the idle object evictor (if any). If an object fails to validate, it will be dropped from the pool. \npool.testWhileIdle=false\n\n# The number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no idle object evictor thread will be run. \npool.timeBetweenEvictionRunsMillis=-1L", "/* (c) 2014 Open Source Geospatial Foundation - all rights reserved\n * (c) 2001 - 2013 OpenPlans\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcconfig;\n\nimport static org.easymock.EasyMock.*;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.servlet.ServletContext;\nimport javax.sql.DataSource;\nimport org.apache.commons.dbcp.BasicDataSource;\nimport org.geoserver.GeoServerConfigurationLock;\nimport org.geoserver.catalog.impl.CatalogImpl;\nimport org.geoserver.config.util.XStreamPersisterFactory;\nimport org.geoserver.config.util.XStreamPersisterInitializer;\nimport org.geoserver.jdbcconfig.catalog.JDBCCatalogFacade;\nimport org.geoserver.jdbcconfig.internal.ConfigDatabase;\nimport org.geoserver.jdbcconfig.internal.DbMappings;\nimport org.geoserver.jdbcconfig.internal.JDBCConfigProperties;\nimport org.geoserver.jdbcconfig.internal.JDBCConfigXStreamPersisterInitializer;\nimport org.geoserver.jdbcconfig.internal.Util;\nimport org.geoserver.jdbcconfig.internal.XStreamInfoSerialBinding;\nimport org.geoserver.platform.GeoServerExtensionsHelper;\nimport org.geoserver.platform.GeoServerResourceLoader;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcOperations;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.TransactionStatus;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport org.springframework.transaction.support.TransactionCallback;\nimport org.springframework.transaction.support.TransactionTemplate;\nimport org.springframework.web.context.WebApplicationContext;\n\n@SuppressWarnings(\"unused\")\npublic class JDBCConfigTestSupport {\n\n    public static File createTempDir() throws IOException {\n        File f = File.createTempFile(\"jdbcconfig\", \"data\", new File(\"target\"));\n        f.delete();\n        f.mkdirs();\n        return f;\n    }\n\n    public static class DBConfig {\n        String name;\n        String driver;\n        String connectionUrl;\n        String dbUser;\n        String dbPasswd;\n        BasicDataSource dataSource;\n        boolean initialized = false;\n\n        public DBConfig(\n                String name, String driver, String connectionUrl, String dbUser, String dbPasswd) {\n            this.name = name;\n            this.driver = driver;\n            this.connectionUrl = connectionUrl;\n            this.dbUser = dbUser;\n            this.dbPasswd = dbPasswd;\n        }\n\n        DBConfig() {}\n\n        BasicDataSource dataSource() throws Exception {\n            if (dataSource != null) return dataSource;\n\n            dataSource =\n                    new BasicDataSource() {\n\n                        @Override\n                        public synchronized void close() throws SQLException {\n                            // do nothing\n                        }\n                    };\n            dataSource.setDriverClassName(driver);\n            dataSource.setUrl(\n                    connectionUrl.replace(\"${DATA_DIR}\", createTempDir().getAbsolutePath()));\n            dataSource.setUsername(dbUser);\n            dataSource.setPassword(dbPasswd);\n\n            dataSource.setMinIdle(3);\n            dataSource.setMaxActive(10);\n            Connection connection = dataSource.getConnection();\n            connection.close();\n            return dataSource;\n        }\n\n        public String getInitScript() {\n            return \"initdb.\" + name + \".sql\";\n        }\n\n        public String getDropScript() {\n            return \"dropdb.\" + name + \".sql\";\n        }\n\n        public String getResetScript() {\n            return \"resetdb.\" + name + \".sql\";\n        }\n\n        @Override\n        public String toString() {\n            return name;\n        }\n\n        public String detailString() {\n            return \"DBConfig{\"\n                    + \"name=\"\n                    + name\n                    + \", driver=\"\n                    + driver\n                    + \", connectionUrl=\"\n                    + connectionUrl\n                    + \", dbUser=\"\n                    + dbUser\n                    + \", dbPasswd=\"\n                    + dbPasswd\n                    + '}';\n        }\n    }\n\n    private static List<Object[]> parameterizedDBConfigs;\n\n    public static final List<Object[]> parameterizedDBConfigs() {\n        if (parameterizedDBConfigs == null) {\n            parameterizedDBConfigs = new ArrayList<Object[]>();\n            for (DBConfig conf : getDBConfigurations()) {\n                parameterizedDBConfigs.add(new Object[] {conf});\n            }\n        }\n        return parameterizedDBConfigs;\n    }\n\n    static List<DBConfig> getDBConfigurations() {\n        ArrayList<DBConfig> configs = new ArrayList<DBConfig>();\n\n        dbConfig(configs, \"h2\", \"org.h2.Driver\", \"jdbc:h2:file:${DATA_DIR}/geoserver\");\n        dbConfig(\n                configs,\n                \"postgres\",\n                \"org.postgresql.Driver\",\n                \"jdbc:postgresql://localhost:5432/geoserver\");\n        dbConfig(\n                configs,\n                \"oracle\",\n                \"oracle.jdbc.OracleDriver\",\n                \"jdbc:oracle:thin:@//localhost:49161/xe\");\n\n        return configs;\n    }\n\n    static String getProperty(String dbName, String property) {\n        return System.getProperty(\"jdbcconfig.\" + dbName + \".\" + property);\n    }\n\n    public static void dbConfig(\n            List<DBConfig> configs, String name, String driver, String connectionUrl) {\n        try {\n            Class.forName(driver);\n        } catch (ClassNotFoundException cnfe) {\n            System.err.println(\"skipping \" + name + \" tests, enable via maven profile\");\n            return;\n        }\n        if (\"true\"\n                .equals(\n                        System.getProperty(\n                                \"jdbcconfig.\" + name + \".skip\",\n                                \"h2\".equals(name) ? \"false\" : \"true\"))) {\n            System.err.println(\"skipping \" + name + \" tests, enable via maven profile\");\n            return;\n        }\n        DBConfig conf = new DBConfig();\n        conf.name = name;\n        conf.driver = driver;\n        conf.connectionUrl = connectionUrl;\n        conf.dbUser = System.getProperty(\"user.name\");\n        conf.dbPasswd = \"\";\n\n        connectionUrl = getProperty(name, \"connectionUrl\");\n        if (connectionUrl != null) {\n            conf.connectionUrl = connectionUrl;\n        }\n        String dbUser = getProperty(name, \"dbUser\");\n        if (dbUser != null) {\n            conf.dbUser = dbUser;\n        }\n        String dbPass = getProperty(name, \"dbPasswd\");\n        if (dbPass != null) {\n            conf.dbPasswd = dbPass;\n        }\n        try {\n            conf.dataSource();\n        } catch (Exception ex) {\n            System.err.println(\n                    \"Unable to connect to datastore, either disable test or specify correct configuration:\");\n            System.out.println(ex.getMessage());\n            System.out.println(\"Current configuration : \" + conf.detailString());\n            return;\n        }\n        configs.add(conf);\n    }\n\n    private final DBConfig dbConfig;\n\n    private WebApplicationContext appContext;\n\n    private GeoServerResourceLoader resourceLoader;\n\n    private CatalogImpl catalog;\n\n    private BasicDataSource dataSource;\n\n    private ConfigDatabase configDb;\n\n    private JDBCCatalogFacade facade;\n\n    public JDBCConfigTestSupport(DBConfig dbConfig) {\n        this.dbConfig = dbConfig;\n    }\n\n    public void setUpWithoutAppContext() throws Exception {\n        ConfigDatabase.LOGGER.setLevel(Level.FINER);\n\n        resourceLoader = new GeoServerResourceLoader(createTempDir());\n\n        dataSource = dbConfig.dataSource();\n\n        dropDb();\n        initDb();\n\n        // use a context to initialize the ConfigDatabase as this will enable\n        // transaction management making the tests much faster (and correcter)\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(Config.class);\n        // use the dataSource we just created\n        context.getBean(Config.class).real = dataSource;\n        configDb = context.getBean(ConfigDatabase.class);\n\n        catalog = new CatalogImpl();\n        catalog.setFacade(facade = new JDBCCatalogFacade(configDb));\n        configDb.setCatalog(catalog);\n        configDb.initDb(null);\n    }\n\n    public void setUp() throws Exception {\n        ConfigDatabase.LOGGER.setLevel(Level.FINER);\n\n        // just to avoid hundreds of warnings in the logs about extension lookups with no app\n        // context set\n        appContext = createNiceMock(WebApplicationContext.class);\n        configureAppContext(appContext);\n\n        replay(appContext);\n\n        GeoServerExtensionsHelper.init(appContext);\n        GeoServerExtensionsHelper.singleton(\n                \"configurationLock\",\n                new GeoServerConfigurationLock(),\n                GeoServerConfigurationLock.class);\n        GeoServerExtensionsHelper.singleton(\n                \"JDBCConfigXStreamPersisterInitializer\",\n                new JDBCConfigXStreamPersisterInitializer(),\n                XStreamPersisterInitializer.class);\n\n        setUpWithoutAppContext();\n    }\n\n    protected void configureAppContext(WebApplicationContext appContext) {\n        expect(appContext.containsBean(\"JDBCConfigXStreamPersisterInitializer\"))\n                .andStubReturn(true);\n\n        expect(appContext.getBeansOfType((Class<?>) anyObject()))\n                .andReturn(Collections.emptyMap())\n                .anyTimes();\n        expect(appContext.getBeanNamesForType((Class<?>) anyObject()))\n                .andReturn(new String[] {})\n                .anyTimes();\n\n        ServletContext servletContext = createNiceMock(ServletContext.class);\n        replay(servletContext);\n\n        expect(appContext.getServletContext()).andReturn(servletContext);\n    }\n\n    public void tearDown() throws Exception {\n        try {\n            if (configDb != null) {\n                configDb.dispose();\n            }\n        } finally {\n            if (dataSource != null) {\n                dataSource.close();\n            }\n        }\n        GeoServerExtensionsHelper.clear();\n    }\n\n    public GeoServerResourceLoader getResourceLoader() {\n        return resourceLoader;\n    }\n\n    public WebApplicationContext getApplicationContext() {\n        return appContext;\n    }\n\n    public ConfigDatabase getDatabase() {\n        return configDb;\n    }\n\n    private void initDb() throws Exception {\n        if (!dbConfig.initialized) {\n            runScript(dbConfig.getInitScript(), null, true);\n            dbConfig.initialized = true;\n        }\n    }\n\n    private void dropDb() throws Exception {\n        URL url = JDBCGeoServerLoader.class.getResource(dbConfig.getResetScript());\n        if (url != null && dbConfig.initialized) {\n            runScript(dbConfig.getResetScript(), null, true);\n        } else {\n            // drop script cannot be run in a transaction - if a statement fails\n            // the whole thing aborts\n            runScript(dbConfig.getDropScript(), null, false);\n            dbConfig.initialized = false;\n        }\n    }\n\n    public void runScript(String dbScriptName, Logger logger, boolean tx) throws IOException {\n        try (InputStream script = JDBCConfigProperties.class.getResourceAsStream(dbScriptName)) {\n            if (script == null) {\n                throw new IllegalArgumentException(\n                        \"Script not found: \"\n                                + JDBCConfigProperties.class.getName()\n                                + \"/\"\n                                + dbScriptName);\n            }\n\n            if (!tx) {\n                NamedParameterJdbcTemplate template = new NamedParameterJdbcTemplate(dataSource);\n                Util.runScript(script, template.getJdbcOperations(), null);\n            } else {\n                DataSourceTransactionManager transactionManager =\n                        new DataSourceTransactionManager(dataSource);\n                NamedParameterJdbcTemplate template =\n                        new NamedParameterJdbcTemplate(transactionManager.getDataSource());\n                TransactionTemplate transactionTemplate =\n                        new TransactionTemplate(transactionManager);\n                final JdbcOperations jdbcOperations = template.getJdbcOperations();\n                transactionTemplate.execute(\n                        new TransactionCallback<Object>() {\n\n                            @Override\n                            public Object doInTransaction(TransactionStatus ts) {\n                                try {\n                                    Util.runScript(script, jdbcOperations, null);\n                                } catch (IOException ex) {\n                                    throw new RuntimeException(ex);\n                                }\n                                return null;\n                            }\n                        });\n            }\n        }\n    }\n\n    public DataSource getDataSource() {\n        return this.dataSource;\n    }\n\n    public DbMappings getDbMappings() {\n        return this.configDb.getDbMappings();\n    }\n\n    public CatalogImpl getCatalog() {\n        return catalog;\n    }\n\n    public JDBCCatalogFacade getFacade() {\n        return facade;\n    }\n\n    @Configuration\n    @EnableTransactionManagement\n    public static class Config {\n        DataSource real;\n        // we need a datasource immediately, but don't have one so use this as\n        // a delegate that uses the 'real' DataSource\n        DataSource lazy =\n                new BasicDataSource() {\n\n                    @Override\n                    protected synchronized DataSource createDataSource() throws SQLException {\n                        return real;\n                    }\n                };\n\n        @Bean\n        public PlatformTransactionManager jdbcConfigTransactionManager() {\n            return new DataSourceTransactionManager(dataSource());\n        }\n\n        @Bean\n        public ConfigDatabase configDatabase() {\n            return new ConfigDatabase(\n                    dataSource(), new XStreamInfoSerialBinding(new XStreamPersisterFactory()));\n        }\n\n        @Bean\n        public DataSource dataSource() {\n            return lazy;\n        }\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2002-2011, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geoserver.jdbcconfig.internal;\n\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\nimport org.geoserver.catalog.LayerInfo;\nimport org.geoserver.catalog.Predicates;\nimport org.geoserver.catalog.WorkspaceInfo;\nimport org.geoserver.jdbcconfig.JDBCConfigTestSupport;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.opengis.filter.Filter;\n\n/**\n * @author groldan\n * @author Kevin Smith, OpenGeo\n */\npublic class QueryBuilderTest {\n\n    private JDBCConfigTestSupport testSupport;\n\n    private DbMappings dbMappings;\n\n    Dialect dialect;\n\n    @Before\n    public void setUp() throws Exception {\n        dialect = new Dialect();\n        dbMappings = new DbMappings(dialect);\n        testSupport =\n                new JDBCConfigTestSupport(\n                        (JDBCConfigTestSupport.DBConfig)\n                                JDBCConfigTestSupport.parameterizedDBConfigs().get(0)[0]);\n        testSupport.setUp();\n        dbMappings = testSupport.getDbMappings();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        testSupport.tearDown();\n    }\n\n    @Test\n    public void testQueryAll() {\n        Filter filter = Predicates.equal(\"name\", \"ws1\");\n        StringBuilder build =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n                        .filter(filter)\n                        .build();\n    }\n\n    @Test\n    public void testSort1() {\n        Filter filter = Predicates.acceptAll();\n        StringBuilder build =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n                        .filter(filter)\n                        .sortOrder(Predicates.asc(\"foo\"))\n                        .build();\n    }\n\n    @Test\n    public void testSort2() {\n        Filter filter = Predicates.acceptAll();\n        StringBuilder build =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n                        .filter(filter)\n                        .sortOrder(Predicates.asc(\"foo\"), Predicates.desc(\"bar\"))\n                        .build();\n    }\n\n    @Test\n    public void testSort3() {\n        Filter filter = Predicates.acceptAll();\n        StringBuilder build =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n                        .filter(filter)\n                        .sortOrder(\n                                Predicates.asc(\"foo\"),\n                                Predicates.desc(\"bar\"),\n                                Predicates.asc(\"baz\"))\n                        .build();\n    }\n\n    @Test\n    public void testSort3WithFilter() {\n        Filter filter = Predicates.equal(\"name\", \"quux\");\n        StringBuilder build =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n                        .filter(filter)\n                        .sortOrder(\n                                Predicates.asc(\"foo\"),\n                                Predicates.desc(\"bar\"),\n                                Predicates.asc(\"baz\"))\n                        .build();\n    }\n\n    @Test\n    public void testNotEquals() {\n        // Create the filter\n        Filter filter = Predicates.notEqual(\"name\", \"quux\");\n        // Build it\n        StringBuilder build =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n                        .filter(filter)\n                        .build();\n        String sql = build.toString();\n        // Ensure the following sql is present\n        assertThat(\n                sql,\n                containsString(\n                        \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type IN (:ptype0) AND UPPER(value) = :value0)\"));\n    }\n\n    @Test\n    public void testIsInstanceOf() {\n        // Create the filter\n        Filter filter = Predicates.isInstanceOf(LayerInfo.class);\n        // Build it\n        StringBuilder build =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n                        .filter(filter)\n                        .build();\n        String sql = build.toString();\n        // Ensure the following sql is present\n        assertThat(sql, containsString(\"type_id = \" + dbMappings.getTypeId(LayerInfo.class)));\n    }\n\n    @Test\n    public void testIsNull() {\n        // Create the filter\n        Filter filter = Predicates.isNull(\"name\");\n        // Build it\n        StringBuilder build =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n                        .filter(filter)\n                        .build();\n        String sql = build.toString();\n\n        String sqlNull =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0))\";\n        // Ensure the following sql is present\n        assertThat(sql, containsString(sqlNull));\n    }\n\n    @Test\n    public void testIsNil() {\n        // Create the filter\n        Filter filter = Predicates.isNull(\"name\");\n        // Build it\n        StringBuilder build =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n                        .filter(filter)\n                        .build();\n        String sql = build.toString();\n\n        String sqlNil =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0) AND value IS NULL)\";\n        // Ensure the following sql is present\n        assertThat(sql, containsString(sqlNil));\n    }\n}\n"], "fixing_code": ["/* (c) 2014 Open Source Geospatial Foundation - all rights reserved\n * (c) 2001 - 2013 OpenPlans\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcconfig.internal;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Throwables.throwIfUnchecked;\nimport static org.geoserver.catalog.CatalogFacade.ANY_WORKSPACE;\nimport static org.geoserver.catalog.Predicates.and;\nimport static org.geoserver.catalog.Predicates.equal;\nimport static org.geoserver.catalog.Predicates.isNull;\nimport static org.geoserver.jdbcconfig.internal.DbUtils.logStatement;\nimport static org.geoserver.jdbcconfig.internal.DbUtils.params;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Iterators;\nimport com.google.common.collect.Lists;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Serializable;\nimport java.lang.reflect.Proxy;\nimport java.nio.charset.StandardCharsets;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\nimport javax.annotation.Nullable;\nimport javax.sql.DataSource;\nimport org.apache.commons.collections.CollectionUtils;\nimport org.apache.commons.collections.Predicate;\nimport org.geoserver.catalog.Catalog;\nimport org.geoserver.catalog.CatalogInfo;\nimport org.geoserver.catalog.CatalogVisitor;\nimport org.geoserver.catalog.CoverageInfo;\nimport org.geoserver.catalog.CoverageStoreInfo;\nimport org.geoserver.catalog.DataStoreInfo;\nimport org.geoserver.catalog.FeatureTypeInfo;\nimport org.geoserver.catalog.Info;\nimport org.geoserver.catalog.LayerGroupInfo;\nimport org.geoserver.catalog.LayerInfo;\nimport org.geoserver.catalog.MetadataMap;\nimport org.geoserver.catalog.NamespaceInfo;\nimport org.geoserver.catalog.Predicates;\nimport org.geoserver.catalog.PublishedInfo;\nimport org.geoserver.catalog.ResourceInfo;\nimport org.geoserver.catalog.StoreInfo;\nimport org.geoserver.catalog.StyleInfo;\nimport org.geoserver.catalog.WMSLayerInfo;\nimport org.geoserver.catalog.WMSStoreInfo;\nimport org.geoserver.catalog.WMTSLayerInfo;\nimport org.geoserver.catalog.WMTSStoreInfo;\nimport org.geoserver.catalog.WorkspaceInfo;\nimport org.geoserver.catalog.event.CatalogAddEvent;\nimport org.geoserver.catalog.event.CatalogListener;\nimport org.geoserver.catalog.event.CatalogModifyEvent;\nimport org.geoserver.catalog.event.CatalogPostModifyEvent;\nimport org.geoserver.catalog.event.CatalogRemoveEvent;\nimport org.geoserver.catalog.impl.CatalogImpl;\nimport org.geoserver.catalog.impl.ClassMappings;\nimport org.geoserver.catalog.impl.ModificationProxy;\nimport org.geoserver.catalog.impl.ResourceInfoImpl;\nimport org.geoserver.catalog.impl.StoreInfoImpl;\nimport org.geoserver.catalog.impl.StyleInfoImpl;\nimport org.geoserver.catalog.util.CloseableIterator;\nimport org.geoserver.catalog.util.CloseableIteratorAdapter;\nimport org.geoserver.config.ConfigurationListenerAdapter;\nimport org.geoserver.config.GeoServer;\nimport org.geoserver.config.GeoServerInfo;\nimport org.geoserver.config.LoggingInfo;\nimport org.geoserver.config.ServiceInfo;\nimport org.geoserver.config.SettingsInfo;\nimport org.geoserver.config.impl.CoverageAccessInfoImpl;\nimport org.geoserver.config.impl.GeoServerInfoImpl;\nimport org.geoserver.config.impl.JAIInfoImpl;\nimport org.geoserver.jdbcloader.JDBCLoaderProperties;\nimport org.geoserver.ows.util.OwsUtils;\nimport org.geoserver.platform.ExtensionPriority;\nimport org.geoserver.platform.resource.Resource;\nimport org.geoserver.util.CacheProvider;\nimport org.geoserver.util.DefaultCacheProvider;\nimport org.geotools.factory.CommonFactoryFinder;\nimport org.geotools.filter.visitor.SimplifyingFilterVisitor;\nimport org.geotools.util.Converters;\nimport org.geotools.util.logging.Logging;\nimport org.opengis.filter.Filter;\nimport org.opengis.filter.FilterFactory;\nimport org.opengis.filter.PropertyIsEqualTo;\nimport org.opengis.filter.expression.Literal;\nimport org.opengis.filter.expression.PropertyName;\nimport org.opengis.filter.sort.SortBy;\nimport org.springframework.beans.BeansException;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.dao.DataAccessException;\nimport org.springframework.dao.EmptyResultDataAccessException;\nimport org.springframework.jdbc.core.ResultSetExtractor;\nimport org.springframework.jdbc.core.RowMapper;\nimport org.springframework.jdbc.core.namedparam.MapSqlParameterSource;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\nimport org.springframework.jdbc.support.GeneratedKeyHolder;\nimport org.springframework.jdbc.support.KeyHolder;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.util.Assert;\n\n/**\n * Stores and retrieves actual {@link CatalogInfo} and {@link ServiceInfo} from the underlying\n * database, with an in memory cache for both objects.\n *\n * <p><b>Important implementation notes</b> This bean is annotated with {@link Transactional} in all\n * write methods and all exposed read methods. The write methods are obvious, the read ones less so.\n * The reads load XML from the database and use XStream to decode it. This can cause references to\n * object related objects to be resolved, which happen by calling again onto the catalog, the facade\n * and eventually again this class. Using a read only transaction around the read methods ensures\n * that a single connection is used in this process, which prevents deadlock at the connection pool\n * level. Also, methods returning a {@link CloseableIterator} of info objects just look up the\n * identifier, and resolve them to full objects during the iteration. This lazy loading also needs\n * to be protected by transactional loading, which is tricky. A trivial implementation would just\n * call itself, which ends up bypassing the transaction annotations (which are implemented as a\n * proxy around the object). To avoid deadlocks there, the {@link ConfigDatabase} also loads itself\n * from the application context, with full transactional proxying, and uses that instance for\n * deferred loading while iterating.\n */\npublic class ConfigDatabase implements ApplicationContextAware {\n\n    public static final Logger LOGGER = Logging.getLogger(ConfigDatabase.class);\n\n    private static final int LOCK_TIMEOUT_SECONDS = 60;\n\n    private Dialect dialect;\n\n    private JDBCLoaderProperties properties;\n\n    private DataSource dataSource;\n\n    private DbMappings dbMappings;\n\n    private CatalogImpl catalog;\n\n    private GeoServer geoServer;\n\n    private NamedParameterJdbcOperations template;\n\n    private XStreamInfoSerialBinding binding;\n\n    private Cache<String, Info> cache;\n\n    private Cache<InfoIdentity, String> identityCache;\n\n    private Cache<ServiceIdentity, ServiceInfo> serviceCache;\n\n    private InfoRowMapper<CatalogInfo> catalogRowMapper;\n\n    private InfoRowMapper<Info> configRowMapper;\n\n    private ConfigClearingListener configListener;\n\n    private ConcurrentMap<String, Semaphore> locks;\n\n    // transaction management works only if the method\n    // is called from a Spring proxy that processed the annotations,\n    // so we cannot call getId directly, it needs to be done from\n    // \"outside\"\n    /* the bean itself, but with the transactional proxy wrappers around */\n    private ConfigDatabase transactionalConfigDatabase;\n\n    /** Protected default constructor needed by spring-jdbc instrumentation */\n    protected ConfigDatabase() {\n        //\n    }\n\n    public ConfigDatabase(\n            JDBCLoaderProperties properties,\n            DataSource dataSource,\n            XStreamInfoSerialBinding binding) {\n        this(properties, dataSource, binding, null);\n    }\n\n    public ConfigDatabase(\n            JDBCLoaderProperties properties,\n            final DataSource dataSource,\n            final XStreamInfoSerialBinding binding,\n            CacheProvider cacheProvider) {\n        this.properties = properties;\n        this.binding = binding;\n        this.template = new NamedParameterJdbcTemplate(dataSource);\n        // cannot use dataSource at this point due to spring context config hack\n        // in place to support tx during testing\n        this.dataSource = dataSource;\n\n        this.catalogRowMapper = new InfoRowMapper<CatalogInfo>(CatalogInfo.class, binding);\n        this.configRowMapper = new InfoRowMapper<Info>(Info.class, binding);\n\n        if (cacheProvider == null) {\n            cacheProvider = DefaultCacheProvider.findProvider();\n        }\n        cache = cacheProvider.getCache(\"catalog\");\n        identityCache = cacheProvider.getCache(\"catalogNames\");\n        serviceCache = cacheProvider.getCache(\"services\");\n        locks = new ConcurrentHashMap<>();\n    }\n\n    private Dialect dialect() {\n        if (dialect == null) {\n            this.dialect = Dialect.detect(dataSource, properties.isDebugMode());\n        }\n        return dialect;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            rollbackFor = Exception.class)\n    public void initDb(@Nullable Resource resource) throws IOException {\n        this.dbMappings = new DbMappings(dialect());\n        if (resource != null) {\n            runInitScript(resource);\n        }\n        dbMappings.initDb(template);\n    }\n\n    private void runInitScript(Resource resource) throws IOException {\n\n        LOGGER.info(\n                \"------------- Running catalog database init script \"\n                        + resource.path()\n                        + \" ------------\");\n\n        try (InputStream in = resource.in()) {\n            Util.runScript(in, template.getJdbcOperations(), LOGGER);\n        }\n\n        LOGGER.info(\"Initialization SQL script run sucessfully\");\n    }\n\n    public DbMappings getDbMappings() {\n        return dbMappings;\n    }\n\n    /**\n     * CatalogClearingListener listener will be added to CatalogImpl when CatalogImpl is set, and\n     * CatalogImpl's addListener method will sort the listener\n     *\n     * @param catalog\n     */\n    public void setCatalog(CatalogImpl catalog) {\n        this.catalog = catalog;\n        this.binding.setCatalog(catalog);\n\n        catalog.removeListeners(CatalogClearingListener.class);\n        catalog.addListener(new CatalogClearingListener());\n    }\n\n    public CatalogImpl getCatalog() {\n        return this.catalog;\n    }\n\n    public void setGeoServer(GeoServer geoServer) {\n        this.geoServer = geoServer;\n\n        if (configListener != null) geoServer.removeListener(configListener);\n        configListener = new ConfigClearingListener();\n        geoServer.addListener(configListener);\n    }\n\n    public GeoServer getGeoServer() {\n        return geoServer;\n    }\n\n    public <T extends CatalogInfo> int count(final Class<T> of, final Filter filter) {\n\n        QueryBuilder<T> sqlBuilder = QueryBuilder.forCount(dialect, of, dbMappings).filter(filter);\n\n        final String sql = sqlBuilder.build();\n        final Filter unsupportedFilter = sqlBuilder.getUnsupportedFilter();\n        final boolean fullySupported = Filter.INCLUDE.equals(unsupportedFilter);\n        if (LOGGER.isLoggable(Level.FINER)) {\n            LOGGER.finer(\"Original filter: \" + filter);\n            LOGGER.finer(\"Supported filter: \" + sqlBuilder.getSupportedFilter());\n            LOGGER.finer(\"Unsupported filter: \" + sqlBuilder.getUnsupportedFilter());\n        }\n        final int count;\n        if (fullySupported) {\n            final Map<String, Object> namedParameters = sqlBuilder.getNamedParameters();\n            logStatement(sql, namedParameters);\n\n            count = template.queryForObject(sql, namedParameters, Integer.class);\n        } else {\n            LOGGER.fine(\n                    \"Filter is not fully supported, doing scan of supported part to return the number of matches\");\n            // going the expensive route, filtering as much as possible\n            CloseableIterator<T> iterator = query(of, filter, null, null, (SortBy) null);\n            try {\n                return Iterators.size(iterator);\n            } finally {\n                iterator.close();\n            }\n        }\n        return count;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> CloseableIterator<T> query(\n            final Class<T> of,\n            final Filter filter,\n            @Nullable Integer offset,\n            @Nullable Integer limit,\n            @Nullable SortBy sortOrder) {\n        if (sortOrder == null) {\n            return query(of, filter, offset, limit);\n        } else {\n            return query(of, filter, offset, limit, sortOrder);\n        }\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> CloseableIterator<T> query(\n            final Class<T> of,\n            final Filter filter,\n            @Nullable Integer offset,\n            @Nullable Integer limit,\n            @Nullable SortBy... sortOrder) {\n\n        checkNotNull(of);\n        checkNotNull(filter);\n        checkArgument(offset == null || offset.intValue() >= 0);\n        checkArgument(limit == null || limit.intValue() >= 0);\n\n        QueryBuilder<T> sqlBuilder =\n                QueryBuilder.forIds(dialect, of, dbMappings)\n                        .filter(filter)\n                        .offset(offset)\n                        .limit(limit)\n                        .sortOrder(sortOrder);\n        final String sql = sqlBuilder.build();\n\n        List<String> ids = null;\n\n        final SimplifyingFilterVisitor filterSimplifier = new SimplifyingFilterVisitor();\n        final Filter simplifiedFilter =\n                (Filter) sqlBuilder.getSupportedFilter().accept(filterSimplifier, null);\n        if (simplifiedFilter instanceof PropertyIsEqualTo) {\n            PropertyIsEqualTo isEqualTo = (PropertyIsEqualTo) simplifiedFilter;\n            if (isEqualTo.getExpression1() instanceof PropertyName\n                    && isEqualTo.getExpression2() instanceof Literal\n                    && ((PropertyName) isEqualTo.getExpression1()).getPropertyName().equals(\"id\")) {\n                ids =\n                        Collections.singletonList(\n                                ((Literal) isEqualTo.getExpression2()).getValue().toString());\n            }\n            if (isEqualTo.getExpression2() instanceof PropertyName\n                    && isEqualTo.getExpression1() instanceof Literal\n                    && ((PropertyName) isEqualTo.getExpression2()).getPropertyName().equals(\"id\")) {\n                ids =\n                        Collections.singletonList(\n                                ((Literal) isEqualTo.getExpression1()).getValue().toString());\n            }\n        }\n\n        final Filter unsupportedFilter = sqlBuilder.getUnsupportedFilter();\n        final boolean fullySupported = Filter.INCLUDE.equals(unsupportedFilter);\n\n        if (ids == null) {\n            final Map<String, Object> namedParameters = sqlBuilder.getNamedParameters();\n\n            if (LOGGER.isLoggable(Level.FINER)) {\n                LOGGER.finer(\"Original filter: \" + filter);\n                LOGGER.finer(\"Supported filter: \" + sqlBuilder.getSupportedFilter());\n                LOGGER.finer(\"Unsupported filter: \" + sqlBuilder.getUnsupportedFilter());\n            }\n            logStatement(sql, namedParameters);\n\n            Stopwatch sw = Stopwatch.createStarted();\n            // the oracle offset/limit implementation returns a two column result set\n            // with rownum in the 2nd - queryForList will throw an exception\n            ids =\n                    template.query(\n                            sql,\n                            namedParameters,\n                            new RowMapper<String>() {\n                                @Override\n                                public String mapRow(ResultSet rs, int rowNum) throws SQLException {\n                                    return rs.getString(1);\n                                }\n                            });\n            sw.stop();\n            if (LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine(\n                        Joiner.on(\"\")\n                                .join(\n                                        \"query returned \",\n                                        ids.size(),\n                                        \" records in \",\n                                        sw.toString()));\n            }\n        }\n\n        List<T> lazyTransformed =\n                Lists.transform(\n                        ids,\n                        new Function<String, T>() {\n                            @Nullable\n                            @Override\n                            public T apply(String id) {\n                                return getById(id, of);\n                            }\n                        });\n\n        CloseableIterator<T> result;\n        Iterator<T> iterator =\n                Iterators.filter(\n                        lazyTransformed.iterator(), com.google.common.base.Predicates.notNull());\n\n        if (fullySupported) {\n            result = new CloseableIteratorAdapter<T>(iterator);\n        } else {\n            // Apply the filter\n            result = CloseableIteratorAdapter.filter(iterator, filter);\n            // The offset and limit should not have been applied as part of the query\n            assert (!sqlBuilder.isOffsetLimitApplied());\n            // Apply offset and limits after filtering\n            result = applyOffsetLimit(result, offset, limit);\n        }\n\n        return result;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> CloseableIterator<String> queryIds(\n            final Class<T> of, final Filter filter) {\n\n        checkNotNull(of);\n        checkNotNull(filter);\n\n        QueryBuilder<T> sqlBuilder = QueryBuilder.forIds(dialect, of, dbMappings).filter(filter);\n\n        final String sql = sqlBuilder.build();\n        final Map<String, Object> namedParameters = sqlBuilder.getNamedParameters();\n        final Filter unsupportedFilter = sqlBuilder.getUnsupportedFilter();\n        final boolean fullySupported = Filter.INCLUDE.equals(unsupportedFilter);\n\n        if (LOGGER.isLoggable(Level.FINER)) {\n            LOGGER.finer(\"Original filter: \" + filter);\n            LOGGER.finer(\"Supported filter: \" + sqlBuilder.getSupportedFilter());\n            LOGGER.finer(\"Unsupported filter: \" + sqlBuilder.getUnsupportedFilter());\n        }\n        logStatement(sql, namedParameters);\n\n        Stopwatch sw = Stopwatch.createStarted();\n        // the oracle offset/limit implementation returns a two column result set\n        // with rownum in the 2nd - queryForList will throw an exception\n        List<String> ids =\n                template.query(\n                        sql,\n                        namedParameters,\n                        new RowMapper<String>() {\n                            @Override\n                            public String mapRow(ResultSet rs, int rowNum) throws SQLException {\n                                return rs.getString(1);\n                            }\n                        });\n        sw.stop();\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.fine(\"query returned \" + ids.size() + \" records in \" + sw);\n        }\n\n        CloseableIterator<String> result;\n        Iterator<String> iterator =\n                Iterators.filter(ids.iterator(), com.google.common.base.Predicates.notNull());\n\n        if (fullySupported) {\n            result = new CloseableIteratorAdapter<String>(iterator);\n        } else {\n            // Apply the filter\n            result = CloseableIteratorAdapter.filter(iterator, filter);\n            // The offset and limit should not have been applied as part of the query\n            assert (!sqlBuilder.isOffsetLimitApplied());\n        }\n\n        return result;\n    }\n\n    private <T extends Info> CloseableIterator<T> applyOffsetLimit(\n            CloseableIterator<T> iterator, Integer offset, Integer limit) {\n        if (offset != null) {\n            Iterators.advance(iterator, offset.intValue());\n        }\n        if (limit != null) {\n            iterator = CloseableIteratorAdapter.limit(iterator, limit.intValue());\n        }\n        return iterator;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> List<T> queryAsList(\n            final Class<T> of,\n            final Filter filter,\n            Integer offset,\n            Integer count,\n            SortBy sortOrder) {\n\n        CloseableIterator<T> iterator = query(of, filter, offset, count, sortOrder);\n        List<T> list;\n        try {\n            list = ImmutableList.copyOf(iterator);\n        } finally {\n            iterator.close();\n        }\n        return list;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends CatalogInfo> T getDefault(final String key, Class<T> type) {\n        String sql = \"SELECT id FROM default_object WHERE def_key = :key\";\n\n        String defaultObjectId;\n        try {\n            ImmutableMap<String, String> params = ImmutableMap.of(\"key\", key);\n            logStatement(sql, params);\n            defaultObjectId = template.queryForObject(sql, params, String.class);\n        } catch (EmptyResultDataAccessException notFound) {\n            return null;\n        }\n        return getById(defaultObjectId, type);\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            rollbackFor = Exception.class)\n    public <T extends Info> T add(final T info) {\n        checkNotNull(info);\n        checkNotNull(info.getId(), \"Object has no id\");\n        checkArgument(!(info instanceof Proxy), \"Added object shall not be a dynamic proxy\");\n\n        final String id = info.getId();\n\n        byte[] value = binding.objectToEntry(info);\n        final String blob = new String(value, StandardCharsets.UTF_8);\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        final Class<T> interf = (Class) ClassMappings.fromImpl(info.getClass()).getInterface();\n        final Integer typeId = dbMappings.getTypeId(interf);\n\n        Map<String, ?> params = params(\"type_id\", typeId, \"id\", id, \"blob\", blob);\n        final String statement =\n                String.format(\n                        \"INSERT INTO object (oid, type_id, id, blob) VALUES (%s, :type_id, :id, :blob)\",\n                        dialect.nextVal(\"seq_OBJECT\"));\n        logStatement(statement, params);\n        KeyHolder keyHolder = new GeneratedKeyHolder();\n        int updateCount =\n                template.update(\n                        statement,\n                        new MapSqlParameterSource(params),\n                        keyHolder,\n                        new String[] {\"oid\"});\n        checkState(updateCount == 1, \"Insert statement failed\");\n        // looks like some db's return the pk different than others, so lets try both ways\n        Number key = (Number) keyHolder.getKeys().get(\"oid\");\n        if (key == null) {\n            key = keyHolder.getKey();\n        }\n        addAttributes(info, key);\n\n        return getById(id, interf);\n    }\n\n    public <T extends Info> void addNames(String id, String... names) {}\n\n    private void addAttributes(final Info info, final Number infoPk) {\n        final String id = info.getId();\n        if (LOGGER.isLoggable(Level.FINER)) {\n            LOGGER.finer(\"Storing properties of \" + id + \" with pk \" + infoPk);\n        }\n\n        final Iterable<Property> properties = dbMappings.properties(info);\n\n        for (Property prop : properties) {\n            if (LOGGER.isLoggable(Level.FINEST)) {\n                LOGGER.finest(\n                        \"Adding property \" + prop.getPropertyName() + \"='\" + prop.getValue() + \"'\");\n            }\n\n            final List<?> values = valueList(prop);\n\n            Object propValue;\n            Integer colIndex;\n\n            for (int index = 0; index < values.size(); index++) {\n                colIndex = prop.isCollectionProperty() ? (index + 1) : 0;\n                propValue = values.get(index);\n                final String storedValue = marshalValue(propValue);\n\n                Integer relatedOid = null;\n                Integer relatedPropertyType = null;\n                if (prop.isRelationship()) {\n                    final Info relatedObject = lookUpRelatedObject(info, prop, colIndex);\n                    // Layer styles might not be actually persisted, in the case of WMS cascaded\n                    // layers,\n                    // where they are created on the fly based on the style names found in the caps\n                    // documents. So check if the id is not null, in addition to checking\n                    // if the related object is not null.\n                    if (relatedObject != null && relatedObject.getId() != null) {\n                        relatedOid = findObjectId(relatedObject);\n                        relatedPropertyType = getRelatedPropertyType(prop, relatedObject);\n                    }\n                } else {\n                    // it's a self property, lets update the value on the property table\n                    relatedOid = null;\n                    relatedPropertyType = null;\n                }\n                addAttribute(\n                        info, infoPk, prop, colIndex, storedValue, relatedOid, relatedPropertyType);\n            }\n        }\n    }\n\n    private void addAttribute(\n            final Info info,\n            final Number infoPk,\n            Property prop,\n            Integer colIndex,\n            final String storedValue,\n            Integer relatedOid,\n            Integer relatedPropertyType) {\n\n        final String insertPropertySQL =\n                \"INSERT INTO object_property \"\n                        + \"(oid, property_type, related_oid, related_property_type, colindex, value, id) \"\n                        + \"VALUES (:object_id, :property_type, :related_oid, :related_property_type, :colindex, :value, :id)\";\n        final Number propertyType = prop.getPropertyType().getOid();\n        final String id = info.getId();\n\n        Map<String, ?> params =\n                params(\n                        \"object_id\",\n                        infoPk,\n                        \"property_type\",\n                        propertyType,\n                        \"related_oid\",\n                        relatedOid,\n                        \"related_property_type\",\n                        relatedPropertyType,\n                        \"colindex\",\n                        colIndex,\n                        \"value\",\n                        storedValue,\n                        \"id\",\n                        id);\n\n        logStatement(insertPropertySQL, params);\n        template.update(insertPropertySQL, params);\n    }\n\n    /** */\n    private Info lookUpRelatedObject(\n            final Info info, final Property prop, @Nullable Integer collectionIndex) {\n\n        checkArgument(collectionIndex == 0 || prop.isCollectionProperty());\n\n        final FilterFactory ff = CommonFactoryFinder.getFilterFactory();\n\n        final Integer targetPropertyTypeId = prop.getPropertyType().getTargetPropertyOid();\n        checkArgument(targetPropertyTypeId != null);\n\n        final PropertyType targetPropertyType = dbMappings.getPropertyType(targetPropertyTypeId);\n        checkState(targetPropertyType != null);\n\n        final Class<?> targetType = dbMappings.getType(targetPropertyType.getObjectTypeOid());\n        checkState(targetType != null);\n\n        final String localPropertyName = prop.getPropertyName();\n        String[] steps = localPropertyName.split(\"\\\\.\");\n        // Step back through ancestor property references If starting at a.b.c.d, then look at\n        // a.b.c, then a.b, then a\n        for (int len = steps.length - 1; len > 0; len--) {\n            String backPropName = Arrays.stream(steps).limit(len).collect(Collectors.joining(\".\"));\n            Object backProp = ff.property(backPropName).evaluate(info);\n            if (backProp != null) {\n                if (prop.isCollectionProperty()\n                        && (backProp instanceof Set || backProp instanceof List)) {\n                    List<?> list;\n                    if (backProp instanceof Set) {\n                        list = asValueList(backProp);\n                        if (list.size() > 0\n                                && list.get(0) != null\n                                && targetType.isAssignableFrom(list.get(0).getClass())) {\n                            String targetPropertyName = targetPropertyType.getPropertyName();\n                            final PropertyName expr = ff.property(targetPropertyName);\n                            Collections.sort(\n                                    list,\n                                    new Comparator<Object>() {\n                                        @Override\n                                        public int compare(Object o1, Object o2) {\n                                            Object v1 = expr.evaluate(o1);\n                                            Object v2 = expr.evaluate(o2);\n                                            String m1 = marshalValue(v1);\n                                            String m2 = marshalValue(v2);\n                                            return m1 == null\n                                                    ? (m2 == null ? 0 : -1)\n                                                    : (m2 == null ? 1 : m1.compareTo(m2));\n                                        }\n                                    });\n                        }\n                    } else {\n                        list = (List<?>) backProp;\n                    }\n                    if (collectionIndex <= list.size()) {\n                        backProp = list.get(collectionIndex - 1);\n                    }\n                }\n                if (targetType.isAssignableFrom(backProp.getClass())) {\n                    return ModificationProxy.unwrap((Info) backProp);\n                }\n            }\n        }\n        // throw new IllegalArgumentException(\"Found no related object of type \"\n        // + targetType.getName() + \" for property \" + localPropertyName + \" of \" + info);\n        return null;\n    }\n\n    private List<?> valueList(Property prop) {\n        final Object value = prop.getValue();\n        return asValueList(value);\n    }\n\n    private List<?> asValueList(final Object value) {\n        final List<?> values;\n        if (value instanceof List) {\n            values = (List<?>) value;\n        } else if (value instanceof Collection) {\n            values = Lists.newArrayList((Collection<?>) value);\n        } else {\n            values = Lists.newArrayList(value);\n        }\n        return values;\n    }\n\n    /** @return the stored representation of a scalar property value */\n    private String marshalValue(Object propValue) {\n        // TODO pad numeric values\n        String marshalled = Converters.convert(propValue, String.class);\n        return marshalled;\n    }\n\n    /** @param info */\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            rollbackFor = Exception.class)\n    public void remove(Info info) {\n        Integer oid;\n        try {\n            oid = findObjectId(info);\n        } catch (EmptyResultDataAccessException notFound) {\n            return;\n        }\n\n        String deleteObject = \"DELETE FROM object WHERE id = :id\";\n        String deleteRelatedProperties = \"DELETE FROM object_property WHERE related_oid = :oid\";\n\n        Map<String, ?> params = ImmutableMap.of(\"id\", info.getId());\n        logStatement(deleteObject, params);\n        int updateCount = template.update(deleteObject, params);\n        if (updateCount != 1) {\n            LOGGER.warning(\n                    \"Requested to delete \"\n                            + info\n                            + \" (\"\n                            + info.getId()\n                            + \") but nothing happened on the database.\");\n        }\n        params = params(\"oid\", oid);\n        logStatement(deleteRelatedProperties, params);\n        final int relatedPropCount = template.update(deleteRelatedProperties, params);\n        LOGGER.fine(\"Removed \" + relatedPropCount + \" related properties of \" + info.getId());\n    }\n\n    /** @param info */\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            rollbackFor = Exception.class)\n    public <T extends Info> T save(T info) {\n        checkNotNull(info);\n\n        final String id = info.getId();\n\n        checkNotNull(id, \"Can't modify an object with no id\");\n\n        final ModificationProxy modificationProxy = ModificationProxy.handler(info);\n        Preconditions.checkNotNull(modificationProxy, \"Not a modification proxy: \", info);\n\n        final Info oldObject = (Info) modificationProxy.getProxyObject();\n\n        // get changed properties before h.commit()s\n        final Iterable<Property> changedProperties = dbMappings.changedProperties(oldObject, info);\n\n        // see HACK block bellow\n        final boolean updateResouceLayersName =\n                info instanceof ResourceInfo\n                        && modificationProxy.getPropertyNames().contains(\"name\");\n        final boolean updateResouceLayersAdvertised =\n                info instanceof ResourceInfo\n                        && modificationProxy.getPropertyNames().contains(\"advertised\");\n        final boolean updateResourceLayersEnabled =\n                info instanceof ResourceInfo\n                        && modificationProxy.getPropertyNames().contains(\"enabled\");\n        final boolean updateResourceLayersKeywords =\n                CollectionUtils.exists(\n                        modificationProxy.getPropertyNames(),\n                        new Predicate() {\n                            @Override\n                            public boolean evaluate(Object input) {\n                                return ((String) input).contains(\"keyword\");\n                            }\n                        });\n\n        modificationProxy.commit();\n\n        Map<String, ?> params;\n\n        // get the object's internal id\n        final Integer objectId = findObjectId(info);\n        byte[] value = binding.objectToEntry(info);\n        final String blob = new String(value, StandardCharsets.UTF_8);\n        String updateStatement = \"UPDATE object SET blob = :blob WHERE oid = :oid\";\n        params = params(\"blob\", blob, \"oid\", objectId);\n        logStatement(updateStatement, params);\n        template.update(updateStatement, params);\n\n        updateQueryableProperties(oldObject, objectId, changedProperties);\n\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        Class<T> clazz = (Class) ClassMappings.fromImpl(oldObject.getClass()).getInterface();\n\n        // / <HACK>\n        // we're explicitly changing the resourceinfo's layer name property here because\n        // LayerInfo.getName() is a derived property. This can be removed once LayerInfo.name become\n        // a regular JavaBean property\n        if (info instanceof ResourceInfo) {\n            if (updateResouceLayersName) {\n                updateResourceLayerProperty(\n                        (ResourceInfo) info, \"name\", ((ResourceInfo) info).getName());\n                updateResourceLayerProperty(\n                        (ResourceInfo) info, \"prefixedName\", ((ResourceInfo) info).prefixedName());\n            }\n            if (updateResouceLayersAdvertised) {\n                updateResourceLayerProperty(\n                        (ResourceInfo) info, \"advertised\", ((ResourceInfo) info).isAdvertised());\n            }\n            if (updateResourceLayersEnabled) {\n                updateResourceLayerProperty(\n                        (ResourceInfo) info, \"enabled\", ((ResourceInfo) info).isEnabled());\n            }\n            if (updateResourceLayersKeywords) {\n                updateResourceLayerProperty(\n                        (ResourceInfo) info,\n                        \"resource.keywords.value\",\n                        ((ResourceInfo) info).getKeywords());\n            }\n        }\n        // / </HACK>\n\n        return getById(id, clazz);\n    }\n\n    private <T> void updateResourceLayerProperty(\n            ResourceInfo info, String propertyPath, Object newValue) {\n        Filter filter = Predicates.equal(\"resource.id\", info.getId());\n        List<LayerInfo> resourceLayers;\n        resourceLayers = this.queryAsList(LayerInfo.class, filter, null, null, null);\n        for (LayerInfo layer : resourceLayers) {\n            Set<PropertyType> propertyTypes =\n                    dbMappings.getPropertyTypes(LayerInfo.class, propertyPath);\n            PropertyType propertyType = propertyTypes.iterator().next();\n            Property changedProperty = new Property(propertyType, newValue);\n            Integer layerOid = findObjectId(layer);\n            updateQueryableProperties(layer, layerOid, ImmutableSet.of(changedProperty));\n        }\n    }\n\n    private Integer findObjectId(final Info info) {\n        final String id = info.getId();\n        final String oidQuery = \"SELECT oid FROM object WHERE id = :id\";\n        Map<String, ?> params = params(\"id\", id);\n        logStatement(oidQuery, params);\n        final Integer objectId = template.queryForObject(oidQuery, params, Integer.class);\n        Preconditions.checkState(objectId != null, \"Object not found: \" + id);\n        return objectId;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            rollbackFor = Exception.class)\n    public void repopulateQueryableProperties() {\n        InfoRowMapper<Info> mapper = new InfoRowMapper<Info>(Info.class, binding, 2);\n        String sql = \"SELECT oid, blob FROM object\";\n        logStatement(sql, null);\n        template.query(\n                sql,\n                new ResultSetExtractor<Void>() {\n\n                    @Override\n                    public Void extractData(ResultSet rs) throws SQLException, DataAccessException {\n                        while (rs.next()) {\n                            Integer oid = rs.getInt(1);\n                            Info info = mapper.mapRow(rs, rs.getRow());\n                            if (info instanceof CatalogInfo) {\n                                info = resolveCatalog((CatalogInfo) info);\n                            } else if (info instanceof ServiceInfo) {\n                                resolveTransient((ServiceInfo) info);\n                            }\n                            updateQueryableProperties(info, oid, dbMappings.allProperties(info));\n                        }\n                        return null;\n                    }\n                });\n    }\n\n    private void updateQueryableProperties(\n            final Info info, final Integer objectId, Iterable<Property> changedProperties) {\n\n        Map<String, ?> params;\n\n        final Integer oid = objectId;\n        Integer propertyType;\n        Integer relatedOid = null;\n        Integer relatedPropertyType = null;\n        Integer colIndex;\n        String storedValue;\n\n        for (Property changedProp : changedProperties) {\n            LOGGER.finer(\"Updating property \" + changedProp);\n\n            final boolean isRelationship = changedProp.isRelationship();\n            propertyType = changedProp.getPropertyType().getOid();\n\n            final List<?> values = valueList(changedProp);\n\n            for (int i = 0; i < values.size(); i++) {\n                final Object rawValue = values.get(i);\n                storedValue = marshalValue(rawValue);\n                checkArgument(\n                        changedProp.isCollectionProperty() || values.size() == 1,\n                        \"Got a multivalued value for a non collection property \"\n                                + changedProp.getPropertyName()\n                                + \"=\"\n                                + values);\n\n                colIndex = changedProp.isCollectionProperty() ? (i + 1) : 0;\n\n                if (isRelationship) {\n                    final Info relatedObject = lookUpRelatedObject(info, changedProp, colIndex);\n                    // Layer styles might not be actually persisted, in the case of WMS cascaded\n                    // layers,\n                    // where they are created on the fly based on the style names found in the caps\n                    // documents. So check if the id is not null, in addition to checking\n                    // if the related object is not null.\n                    if (relatedObject != null && relatedObject.getId() != null) {\n                        relatedOid = findObjectId(relatedObject);\n                        relatedPropertyType = getRelatedPropertyType(changedProp, relatedObject);\n                    }\n                } else {\n                    // it's a self property, lets update the value on the property table\n                    relatedOid = null;\n                    relatedPropertyType = null;\n                }\n                String sql =\n                        \"UPDATE object_property SET \"\n                                + \"related_oid = :related_oid, \"\n                                + \"related_property_type = :related_property_type, \"\n                                + \"value = :value \"\n                                + \"WHERE oid = :oid AND property_type = :property_type AND colindex = :colindex\";\n                params =\n                        params(\n                                \"related_oid\",\n                                relatedOid,\n                                \"related_property_type\",\n                                relatedPropertyType,\n                                \"value\",\n                                storedValue,\n                                \"oid\",\n                                oid,\n                                \"property_type\",\n                                propertyType,\n                                \"colindex\",\n                                colIndex);\n\n                logStatement(sql, params);\n                final int updateCnt = template.update(sql, params);\n\n                if (updateCnt == 0) {\n                    addAttribute(\n                            info,\n                            oid,\n                            changedProp,\n                            colIndex,\n                            storedValue,\n                            relatedOid,\n                            relatedPropertyType);\n                } else {\n                    // prop existed already, lets update any related property that points to its old\n                    // value\n                    String updateRelated =\n                            \"UPDATE object_property SET value = :value \"\n                                    + \"WHERE related_oid = :oid AND related_property_type = :property_type AND colindex = :colindex\";\n                    params =\n                            params(\n                                    \"value\",\n                                    storedValue,\n                                    \"oid\",\n                                    oid,\n                                    \"property_type\",\n                                    propertyType,\n                                    \"colindex\",\n                                    colIndex);\n                    logStatement(updateRelated, params);\n                    int relatedUpdateCnt = template.update(updateRelated, params);\n                    if (LOGGER.isLoggable(Level.FINER)) {\n                        LOGGER.finer(\n                                \"Updated \"\n                                        + relatedUpdateCnt\n                                        + \" back pointer properties to \"\n                                        + changedProp.getPropertyName()\n                                        + \" of \"\n                                        + info.getClass().getSimpleName()\n                                        + \"[\"\n                                        + info.getId()\n                                        + \"]\");\n                    }\n                }\n            }\n            if (changedProp.isCollectionProperty()) {\n                // delete any remaining collection value that's no longer in the value list\n                String sql =\n                        \"DELETE FROM object_property WHERE oid = :oid AND property_type = :property_type \"\n                                + \"AND colindex > :maxIndex\";\n                Integer maxIndex = Integer.valueOf(values.size());\n                params = params(\"oid\", oid, \"property_type\", propertyType, \"maxIndex\", maxIndex);\n                logStatement(sql, params);\n                template.update(sql, params);\n            }\n        }\n    }\n\n    private Integer getRelatedPropertyType(Property changedProp, final Info relatedObject) {\n        // the related property may refer to an abstract type (e.g.\n        // LayerInfo.resource.name), so we need to find out the actual property type id (for\n        // example, whether it belongs to FeatureTypeInfo or CoverageInfo)\n\n        Integer targetPropertyOid = changedProp.getPropertyType().getTargetPropertyOid();\n        PropertyType targetProperty;\n        String targetPropertyName;\n\n        Class<?> targetQueryType;\n        ClassMappings classMappings = ClassMappings.fromImpl(relatedObject.getClass());\n        targetQueryType = classMappings.getInterface();\n        targetProperty = dbMappings.getPropertyType(targetPropertyOid);\n        targetPropertyName = targetProperty.getPropertyName();\n\n        Set<Integer> propertyTypeIds;\n        propertyTypeIds = dbMappings.getPropertyTypeIds(targetQueryType, targetPropertyName);\n        checkState(propertyTypeIds.size() == 1);\n        return propertyTypeIds.iterator().next();\n    }\n\n    public <T extends Info> T getById(final String id, final Class<T> type) {\n        Assert.notNull(id, \"id\");\n\n        Info info = null;\n        try {\n            final Callable<? extends Info> valueLoader;\n            if (CatalogInfo.class.isAssignableFrom(type)) {\n                valueLoader = new CatalogLoader(id);\n            } else {\n                valueLoader = new ConfigLoader(id);\n            }\n\n            Semaphore lock = locks.computeIfAbsent(id, x -> new Semaphore(1));\n\n            info = cache.getIfPresent(id);\n            if (info == null) {\n                // we try the write lock\n                if (lock.tryAcquire()) {\n                    try {\n                        info = cache.get(id, valueLoader);\n                    } finally {\n                        lock.release();\n                    }\n                }\n            }\n\n            if (info == null) {\n                // if the write lock was locked, we fall back\n                // to a read-only method\n                try {\n                    info = valueLoader.call();\n                } catch (Exception e) {\n                    throw new ExecutionException(e);\n                }\n            }\n\n        } catch (CacheLoader.InvalidCacheLoadException notFound) {\n            return null;\n        } catch (ExecutionException e) {\n            throw new RuntimeException(e);\n        }\n\n        if (info == null) {\n            return null;\n        }\n        if (info instanceof CatalogInfo) {\n            info = resolveCatalog((CatalogInfo) info);\n        } else if (info instanceof ServiceInfo) {\n            resolveTransient((ServiceInfo) info);\n        }\n\n        if (type.isAssignableFrom(info.getClass())) {\n            // use ModificationProxy only in this case as returned object is cached. saveInternal\n            // follows suite checking whether the object being saved is a mod proxy, but that's not\n            // mandatory in this implementation and should only be the case when the object was\n            // obtained by id\n            return ModificationProxy.create(type.cast(info), type);\n        }\n\n        return null;\n    }\n\n    public <T extends Info> String getIdByIdentity(\n            final Class<T> type, final String... identityMappings) {\n        Assert.notNull(identityMappings, \"id\");\n        int length = identityMappings.length / 2;\n        String[] descriptor = new String[length];\n        String[] values = new String[length];\n        for (int i = 0; i < length; i++) {\n            descriptor[i] = identityMappings[i * 2];\n            values[i] = identityMappings[i * 2 + 1];\n        }\n        InfoIdentity infoIdentity = new InfoIdentity(InfoIdentities.root(type), descriptor, values);\n\n        String id = null;\n        try {\n            id = identityCache.get(infoIdentity, new IdentityLoader(infoIdentity));\n\n        } catch (CacheLoader.InvalidCacheLoadException notFound) {\n            return null;\n        } catch (ExecutionException e) {\n            throwIfUnchecked(e.getCause());\n            throw new RuntimeException(e.getCause());\n        }\n\n        return id;\n    }\n\n    @Nullable\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public ServiceInfo getService(\n            final WorkspaceInfo ws, final Class<? extends ServiceInfo> clazz) {\n        Assert.notNull(clazz, \"clazz\");\n\n        ServiceInfo info = null;\n        try {\n            ServiceIdentity id = new ServiceIdentity(clazz, ws);\n            info = serviceCache.get(id, new ServiceLoader(id));\n\n        } catch (CacheLoader.InvalidCacheLoadException notFound) {\n            return null;\n        } catch (ExecutionException e) {\n            Throwable throwable = e.getCause();\n            throwIfUnchecked(throwable);\n            throw new RuntimeException(throwable);\n        }\n\n        if (info == null) {\n            return null;\n        }\n        resolveTransient(info);\n\n        return info;\n    }\n\n    @Nullable\n    public List<ServiceInfo> getServices(final WorkspaceInfo ws) {\n\n        List<ServiceInfo> result = new ArrayList<>();\n        for (ServiceInfo info : serviceCache.asMap().values()) {\n            if (ws.equals(info.getWorkspace())) {\n                result.add(info);\n            }\n        }\n        return result;\n    }\n\n    @Nullable\n    public <T extends Info> T getByIdentity(final Class<T> type, final String... identityMappings) {\n        String id = getIdByIdentity(type, identityMappings);\n\n        if (id == null) {\n            return null;\n        } else {\n            return getById(id, type);\n        }\n    }\n\n    private <T extends CatalogInfo> T resolveCatalog(final T real) {\n        if (real == null) {\n            return null;\n        }\n        CatalogImpl catalog = getCatalog();\n        catalog.resolve(real);\n        // may the cached value have been serialized and hence lost transient fields? (that's why I\n        // don't like having transient fields foreign to the domain model in the catalog config\n        // objects)\n        resolveTransient(real);\n\n        // if this came from the cache, force update references\n        real.accept(new CatalogReferenceUpdater());\n\n        return real;\n    }\n\n    private <T extends CatalogInfo> void resolveTransient(T real) {\n        if (null == real) {\n            return;\n        }\n        real = ModificationProxy.unwrap(real);\n        if (real instanceof StyleInfoImpl\n                || real instanceof StoreInfoImpl\n                || real instanceof ResourceInfoImpl) {\n            OwsUtils.set(real, \"catalog\", catalog);\n        }\n        if (real instanceof ResourceInfoImpl) {\n            resolveTransient(((ResourceInfoImpl) real).getStore());\n        } else if (real instanceof LayerInfo) {\n            LayerInfo layer = (LayerInfo) real;\n            resolveTransient(layer.getDefaultStyle());\n            // avoids concurrent modification exceptions on the list contents\n            synchronized (layer) {\n                if (!layer.getStyles().isEmpty()) {\n                    for (StyleInfo s : layer.getStyles()) {\n                        resolveTransient(s);\n                    }\n                }\n            }\n            resolveTransient(layer.getResource());\n        } else if (real instanceof LayerGroupInfo) {\n            for (PublishedInfo p : ((LayerGroupInfo) real).getLayers()) {\n                resolveTransient(p);\n            }\n            for (StyleInfo s : ((LayerGroupInfo) real).getStyles()) {\n                resolveTransient(s);\n            }\n        }\n    }\n\n    private <T extends ServiceInfo> void resolveTransient(T real) {\n        real = ModificationProxy.unwrap(real);\n        OwsUtils.resolveCollections(real);\n        real.setGeoServer(getGeoServer());\n    }\n\n    /** @return immutable list of results */\n    @Nullable\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> List<T> getAll(final Class<T> clazz) {\n\n        Map<String, ?> params = params(\"types\", typesParam(clazz));\n\n        final String sql = \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY id\";\n\n        logStatement(sql, params);\n        Stopwatch sw = Stopwatch.createStarted();\n        List<String> ids = template.queryForList(sql, params, String.class);\n        sw.stop();\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.fine(\"query returned \" + ids.size() + \" records in \" + sw);\n        }\n\n        List<T> transformed =\n                Lists.transform(\n                        ids,\n                        new Function<String, T>() {\n                            @Nullable\n                            @Override\n                            public T apply(String input) {\n                                return getById(input, clazz);\n                            }\n                        });\n        Iterable<T> filtered =\n                Iterables.filter(transformed, com.google.common.base.Predicates.notNull());\n        return ImmutableList.copyOf(filtered);\n    }\n\n    private <T extends Info> List<Integer> typesParam(final Class<T> clazz) {\n\n        final Class<?>[] actualTypes;\n\n        actualTypes = ClassMappings.fromInterface(clazz).concreteInterfaces();\n\n        List<Integer> inValues = new ArrayList<Integer>(actualTypes.length);\n        for (Class<?> type : actualTypes) {\n            inValues.add(this.dbMappings.getTypeId(type));\n        }\n\n        return inValues;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            rollbackFor = Exception.class)\n    public void setDefault(final String key, @Nullable final String id) {\n        String sql = \"DELETE FROM default_object WHERE def_key = :key\";\n        Map<String, ?> params = params(\"key\", key);\n        logStatement(sql, params);\n        template.update(sql, params);\n        if (id != null) {\n            sql = \"INSERT INTO default_object (def_key, id) VALUES (:key, :id)\";\n            params = params(\"key\", key, \"id\", id);\n            logStatement(sql, params);\n            template.update(sql, params);\n        }\n    }\n\n    public void dispose() {\n        cache.invalidateAll();\n        cache.cleanUp();\n        identityCache.invalidateAll();\n        identityCache.cleanUp();\n        disposeServiceCache();\n    }\n\n    private void disposeServiceCache() {\n        serviceCache.invalidateAll();\n        serviceCache.cleanUp();\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.transactionalConfigDatabase = applicationContext.getBean(ConfigDatabase.class);\n    }\n\n    private final class CatalogLoader implements Callable<CatalogInfo> {\n\n        private final String id;\n\n        public CatalogLoader(final String id) {\n            this.id = id;\n        }\n\n        @Override\n        public CatalogInfo call() throws Exception {\n            return transactionalConfigDatabase.loadCatalog(id);\n        }\n    }\n\n    @Nullable\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public CatalogInfo loadCatalog(String id) {\n\n        CatalogInfo info;\n        try {\n            String sql = \"SELECT blob FROM object WHERE id = :id\";\n            Map<String, String> params = ImmutableMap.of(\"id\", id);\n            logStatement(sql, params);\n            info = template.queryForObject(sql, params, catalogRowMapper);\n        } catch (EmptyResultDataAccessException noSuchObject) {\n            return null;\n        }\n        return info;\n    }\n\n    private final class IdentityLoader implements Callable<String> {\n\n        private final InfoIdentity identity;\n\n        public IdentityLoader(final InfoIdentity identity) {\n            this.identity = identity;\n        }\n\n        @Override\n        public String call() throws Exception {\n            return transactionalConfigDatabase.loadIdentity(identity);\n        }\n    }\n\n    @Nullable\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public String loadIdentity(InfoIdentity identity) {\n        Filter filter = Filter.INCLUDE;\n        for (int i = 0; i < identity.getDescriptor().length; i++) {\n            filter =\n                    and(\n                            filter,\n                            identity.getValues()[i] == null\n                                    ? isNull(identity.getDescriptor()[i])\n                                    : equal(identity.getDescriptor()[i], identity.getValues()[i]));\n        }\n\n        try {\n            return getId(identity.getClazz(), filter);\n        } catch (IllegalArgumentException multipleResults) {\n            return null;\n        }\n    }\n\n    private static final class ServiceIdentity implements Serializable {\n        private static final long serialVersionUID = 4054478633697271203L;\n\n        private Class<? extends ServiceInfo> clazz;\n        private WorkspaceInfo workspace;\n\n        public ServiceIdentity(Class<? extends ServiceInfo> clazz, WorkspaceInfo workspace) {\n            this.clazz = clazz;\n            this.workspace = workspace;\n        }\n\n        public Class<? extends ServiceInfo> getClazz() {\n            return clazz;\n        }\n\n        public WorkspaceInfo getWorkspace() {\n            return workspace;\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + ((clazz == null) ? 0 : clazz.hashCode());\n            result = prime * result + ((workspace == null) ? 0 : workspace.hashCode());\n            return result;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null) return false;\n            if (getClass() != obj.getClass()) return false;\n            ServiceIdentity other = (ServiceIdentity) obj;\n            if (clazz == null) {\n                if (other.clazz != null) return false;\n            } else if (!clazz.equals(other.clazz)) return false;\n            if (workspace == null) {\n                if (other.workspace != null) return false;\n            } else if (!workspace.equals(other.workspace)) return false;\n            return true;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <T extends ServiceInfo> CloseableIterator<T> filterService(\n            final Class<T> clazz, CloseableIterator<ServiceInfo> it) {\n        return (CloseableIterator<T>)\n                CloseableIteratorAdapter.filter(\n                        it,\n                        new com.google.common.base.Predicate<ServiceInfo>() {\n\n                            @Override\n                            public boolean apply(@Nullable ServiceInfo input) {\n                                return clazz.isAssignableFrom(input.getClass());\n                            }\n                        });\n    }\n\n    private final class ServiceLoader implements Callable<ServiceInfo> {\n\n        private final ServiceIdentity id;\n\n        public ServiceLoader(final ServiceIdentity id) {\n            this.id = id;\n        }\n\n        @Override\n        public ServiceInfo call() throws Exception {\n            Filter filter;\n            if (id.getWorkspace() != null && id.getWorkspace() != ANY_WORKSPACE) {\n                filter = equal(\"workspace.id\", id.getWorkspace().getId());\n            } else {\n                filter = isNull(\"workspace.id\");\n            }\n\n            // In order to handle new service types, get all services, deserialize them, and then\n            // filter\n            // by checking if the implement the given interface.  Since there shouldn't be too many\n            // per\n            // workspace, this shouldn't be a significant performance problem.\n            CloseableIterator<? extends ServiceInfo> it =\n                    filterService(\n                            id.getClazz(),\n                            query(ServiceInfo.class, filter, null, null, (SortBy) null));\n\n            ServiceInfo service;\n            if (it.hasNext()) {\n                service = it.next();\n            } else {\n                if (LOGGER.isLoggable(Level.FINE))\n                    LOGGER.log(\n                            Level.FINE,\n                            \"Could not find service of type \"\n                                    + id.getClazz()\n                                    + \" in \"\n                                    + id.getWorkspace());\n                return null;\n            }\n\n            if (it.hasNext()) {\n                LOGGER.log(\n                        Level.WARNING,\n                        \"Found multiple services of type \"\n                                + id.getClass()\n                                + \" in \"\n                                + id.getWorkspace());\n                return null;\n            }\n            return service;\n        }\n    }\n\n    private final class ConfigLoader implements Callable<Info> {\n\n        private final String id;\n\n        public ConfigLoader(final String id) {\n            this.id = id;\n        }\n\n        @Override\n        public Info call() throws Exception {\n            return transactionalConfigDatabase.loadConfig(id);\n        }\n    }\n\n    @Nullable\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public Info loadConfig(String id) {\n        Info info;\n        try {\n            String sql = \"SELECT blob FROM object WHERE id = :id\";\n            Map<String, String> params = ImmutableMap.of(\"id\", id);\n            logStatement(sql, params);\n            info = template.queryForObject(sql, params, configRowMapper);\n        } catch (EmptyResultDataAccessException noSuchObject) {\n            return null;\n        }\n        OwsUtils.resolveCollections(info);\n        if (info instanceof GeoServerInfo) {\n\n            GeoServerInfoImpl global = (GeoServerInfoImpl) info;\n            if (global.getMetadata() == null) {\n                global.setMetadata(new MetadataMap());\n            }\n            if (global.getClientProperties() == null) {\n                global.setClientProperties(new HashMap<Object, Object>());\n            }\n            if (global.getCoverageAccess() == null) {\n                global.setCoverageAccess(new CoverageAccessInfoImpl());\n            }\n            if (global.getJAI() == null) {\n                global.setJAI(new JAIInfoImpl());\n            }\n        }\n        if (info instanceof ServiceInfo) {\n            ((ServiceInfo) info).setGeoServer(geoServer);\n        }\n\n        return info;\n    }\n\n    /**\n     * @return whether there exists a property named {@code propertyName} for the given type of\n     *     object, and hence native sorting can be done over it.\n     */\n    public boolean canSort(Class<? extends CatalogInfo> type, String propertyName) {\n        Set<PropertyType> propertyTypes = dbMappings.getPropertyTypes(type, propertyName);\n        return !propertyTypes.isEmpty();\n    }\n\n    public void clearCache() {\n        cache.invalidateAll();\n        serviceCache.invalidateAll();\n    }\n\n    public void clearCache(Info info) {\n        if (info instanceof ServiceInfo) {\n            // need to figure out how to remove only the relevant cache\n            // entries for the service info, like with InfoIdenties below,\n            // that will be able to handle new service types.\n            disposeServiceCache();\n        }\n        identityCache.invalidateAll(InfoIdentities.get().getIdentities(info));\n        cache.invalidate(info.getId());\n    }\n\n    public void clearCacheIfPresent(String id) {\n        Info info = cache.getIfPresent(id);\n        if (info != null) {\n            clearCache(info);\n        }\n    }\n\n    void updateCache(Info info) {\n        info = ModificationProxy.unwrap(info);\n        cache.put(info.getId(), info);\n        List<InfoIdentity> identities = InfoIdentities.get().getIdentities(info);\n        for (InfoIdentity identity : identities) {\n            if (identityCache.getIfPresent(identity) == null) {\n                identityCache.put(identity, info.getId());\n            } else {\n                // not a unique identity\n                identityCache.invalidate(identity);\n            }\n        }\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> T get(Class<T> type, Filter filter) throws IllegalArgumentException {\n\n        CloseableIterator<T> it =\n                query(type, filter, null, 2, (org.opengis.filter.sort.SortBy) null);\n        T result = null;\n        try {\n            if (it.hasNext()) {\n                result = it.next();\n                if (it.hasNext()) {\n                    throw new IllegalArgumentException(\n                            \"Specified query predicate resulted in more than one object\");\n                }\n            }\n        } finally {\n            it.close();\n        }\n        return result;\n    }\n\n    @Transactional(\n            transactionManager = \"jdbcConfigTransactionManager\",\n            propagation = Propagation.REQUIRED,\n            readOnly = true)\n    public <T extends Info> String getId(Class<T> type, Filter filter)\n            throws IllegalArgumentException {\n\n        CloseableIterator<String> it = queryIds(type, filter);\n        String result = null;\n        try {\n            if (it.hasNext()) {\n                result = it.next();\n                if (it.hasNext()) {\n                    throw new IllegalArgumentException(\n                            \"Specified query predicate resulted in more than one object\");\n                }\n            }\n        } finally {\n            it.close();\n        }\n        return result;\n    }\n\n    private void acquireWriteLock(String id) {\n        Semaphore lock = locks.computeIfAbsent(id, x -> new Semaphore(1));\n        try {\n            if (!lock.tryAcquire(LOCK_TIMEOUT_SECONDS, TimeUnit.SECONDS)) {\n                LOGGER.severe(\n                        \"Time-out waiting for lock on \"\n                                + id\n                                + \", assuming it was abandoned and moving on. This shouldn't happen!\");\n            }\n        } catch (InterruptedException e) {\n\n        }\n    }\n\n    private void releaseWriteLock(String id) {\n        Semaphore lock = locks.get(id);\n        // while semaphores are thread safe by nature,\n        // the if-condition below isn't\n        synchronized (lock) {\n            if (lock.availablePermits() < 1) {\n                // we never give more than one permit\n                lock.release();\n            }\n        }\n    }\n\n    /** Only intended for testing purposes */\n    public void lock(String id, long millis) {\n        acquireWriteLock(id);\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n        }\n        releaseWriteLock(id);\n    }\n\n    /**\n     * Listens to catalog events clearing cache entires when resources are modified. Copied from\n     * org.geoserver.catalog.ResourcePool upgrade CatalogClearingListener clear old source default\n     * priority is 100\n     *\n     * @see CatalogImpl#addListener(CatalogListener)\n     */\n    public class CatalogClearingListener implements CatalogListener, ExtensionPriority {\n\n        @Override\n        public void handleAddEvent(CatalogAddEvent event) {\n            updateCache(event.getSource());\n        }\n\n        @Override\n        public void handleModifyEvent(CatalogModifyEvent event) {\n            // make sure that cache is not refilled before commit\n            if (event.getSource() instanceof ResourceInfo) {\n                String liId =\n                        getIdByIdentity(LayerInfo.class, \"resource.id\", event.getSource().getId());\n                acquireWriteLock(liId);\n                clearCacheIfPresent(liId);\n            }\n            acquireWriteLock(event.getSource().getId());\n            clearCache(event.getSource());\n        }\n\n        @Override\n        public void handlePostModifyEvent(CatalogPostModifyEvent event) {\n            updateCache(event.getSource());\n            releaseWriteLock(event.getSource().getId());\n            if (event.getSource() instanceof ResourceInfo) {\n                String liId =\n                        getIdByIdentity(LayerInfo.class, \"resource.id\", event.getSource().getId());\n                releaseWriteLock(liId);\n            }\n        }\n\n        @Override\n        public void handleRemoveEvent(CatalogRemoveEvent event) {\n            clearCache(event.getSource());\n        }\n\n        @Override\n        public void reloaded() {}\n\n        @Override\n        public int getPriority() {\n            return 999;\n        }\n    }\n    /** Listens to configuration events clearing cache entires when resources are modified. */\n    public class ConfigClearingListener extends ConfigurationListenerAdapter {\n\n        @Override\n        public void handleSettingsRemoved(SettingsInfo settings) {\n            clearCache(settings);\n        }\n\n        @Override\n        public void handleServiceRemove(ServiceInfo service) {\n            clearCache(service);\n        }\n\n        @Override\n        public void handleGlobalChange(\n                GeoServerInfo global,\n                List<String> propertyNames,\n                List<Object> oldValues,\n                List<Object> newValues) {\n            // make sure that cache is not refilled before commit\n            acquireWriteLock(global.getId());\n            clearCache(global);\n        }\n\n        @Override\n        public void handlePostGlobalChange(GeoServerInfo global) {\n            updateCache(global);\n            releaseWriteLock(global.getId());\n        }\n\n        @Override\n        public void handleSettingsModified(\n                SettingsInfo settings,\n                List<String> propertyNames,\n                List<Object> oldValues,\n                List<Object> newValues) {\n            // make sure that cache is not refilled before commit\n            acquireWriteLock(settings.getId());\n            clearCache(settings);\n        }\n\n        @Override\n        public void handleSettingsPostModified(SettingsInfo settings) {\n            updateCache(settings);\n            releaseWriteLock(settings.getId());\n        }\n\n        @Override\n        public void handleLoggingChange(\n                LoggingInfo logging,\n                List<String> propertyNames,\n                List<Object> oldValues,\n                List<Object> newValues) {\n            // make sure that cache is not refilled before commit\n            acquireWriteLock(logging.getId());\n            clearCache(logging);\n        }\n\n        @Override\n        public void handlePostLoggingChange(LoggingInfo logging) {\n            updateCache(logging);\n            releaseWriteLock(logging.getId());\n        }\n\n        @Override\n        public void handleServiceChange(\n                ServiceInfo service,\n                List<String> propertyNames,\n                List<Object> oldValues,\n                List<Object> newValues) {\n            // make sure that cache is not refilled before commit\n            acquireWriteLock(service.getId());\n            clearCache(service);\n        }\n\n        @Override\n        public void handlePostServiceChange(ServiceInfo service) {\n            updateCache(service);\n            releaseWriteLock(service.getId());\n        }\n\n        @Override\n        public void handleSettingsAdded(SettingsInfo settings) {\n            updateCache(settings);\n        }\n    }\n\n    public class CatalogReferenceUpdater implements CatalogVisitor {\n\n        private CatalogReferenceUpdater() {}\n\n        @Override\n        public void visit(Catalog catalog) {}\n\n        @Override\n        public void visit(WorkspaceInfo workspace) {}\n\n        @Override\n        public void visit(NamespaceInfo workspace) {}\n\n        public void visitStore(StoreInfo store) {\n            if (store.getWorkspace() != null) {\n                store.setWorkspace(getById(store.getWorkspace().getId(), WorkspaceInfo.class));\n            }\n        }\n\n        @Override\n        public void visit(DataStoreInfo dataStore) {\n            visitStore(dataStore);\n        }\n\n        @Override\n        public void visit(CoverageStoreInfo coverageStore) {\n            visitStore(coverageStore);\n        }\n\n        @Override\n        public void visit(WMSStoreInfo wmsStore) {\n            visitStore(wmsStore);\n        }\n\n        @Override\n        public void visit(WMTSStoreInfo wmsStore) {\n            visitStore(wmsStore);\n        }\n\n        public void visitResource(ResourceInfo resourceInfo) {\n            if (resourceInfo.getNamespace() != null) {\n                resourceInfo.setNamespace(\n                        getById(resourceInfo.getNamespace().getId(), NamespaceInfo.class));\n            }\n            resourceInfo.setStore(getById(resourceInfo.getStore().getId(), StoreInfo.class));\n        }\n\n        @Override\n        public void visit(FeatureTypeInfo featureType) {\n            visitResource(featureType);\n        }\n\n        @Override\n        public void visit(CoverageInfo coverage) {\n            visitResource(coverage);\n        }\n\n        @Override\n        public void visit(WMSLayerInfo wmsLayer) {\n            visitResource(wmsLayer);\n        }\n\n        @Override\n        public void visit(WMTSLayerInfo wmtsLayer) {\n            visitResource(wmtsLayer);\n        }\n\n        @Override\n        public void visit(LayerInfo layer) {\n            // avoids concurrent modification exceptions on the list contents\n            // Layer styles might not be actually persisted, in the case of WMS cascaded layers,\n            // where they are created on the fly based on the style names found in the caps\n            // documents. So check if the id is not null, in addition to checking if the style is\n            // not null.\n            synchronized (layer) {\n                if (layer.getDefaultStyle() != null && layer.getDefaultStyle().getId() != null) {\n                    layer.setDefaultStyle(\n                            getById(layer.getDefaultStyle().getId(), StyleInfo.class));\n                }\n                Set<StyleInfo> newStyles = new HashSet<>();\n                for (StyleInfo style : new ArrayList<>(layer.getStyles())) {\n                    if (style != null && style.getId() != null) {\n                        newStyles.add(getById(style.getId(), StyleInfo.class));\n                    }\n                }\n                layer.getStyles().clear();\n                layer.getStyles().addAll(newStyles);\n            }\n        }\n\n        @Override\n        public void visit(StyleInfo style) {\n            if (style.getWorkspace() != null) {\n                style.setWorkspace(getById(style.getWorkspace().getId(), WorkspaceInfo.class));\n            }\n        }\n\n        @Override\n        public void visit(LayerGroupInfo layerGroup) {\n            if (layerGroup.getWorkspace() != null) {\n                layerGroup.setWorkspace(\n                        getById(layerGroup.getWorkspace().getId(), WorkspaceInfo.class));\n            }\n            for (int i = 0; i < layerGroup.getLayers().size(); i++) {\n                if (layerGroup.getLayers().get(i) != null) {\n                    layerGroup\n                            .getLayers()\n                            .set(\n                                    i,\n                                    getById(\n                                            layerGroup.getLayers().get(i).getId(),\n                                            PublishedInfo.class));\n                }\n            }\n            if (layerGroup.getRootLayer() != null) {\n                layerGroup.setRootLayer(\n                        getById(layerGroup.getRootLayer().getId(), LayerInfo.class));\n            }\n            if (layerGroup.getRootLayerStyle() != null) {\n                layerGroup.setRootLayerStyle(\n                        getById(layerGroup.getRootLayerStyle().getId(), StyleInfo.class));\n            }\n            for (int i = 0; i < layerGroup.getStyles().size(); i++) {\n                if (layerGroup.getStyles().get(i) != null) {\n                    layerGroup\n                            .getStyles()\n                            .set(\n                                    i,\n                                    getById(\n                                            layerGroup.getStyles().get(i).getId(),\n                                            StyleInfo.class));\n                }\n            }\n        }\n    }\n}\n", "/* (c) 2014 Open Source Geospatial Foundation - all rights reserved\n * (c) 2001 - 2013 OpenPlans\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcconfig.internal;\n\nimport com.google.common.base.Joiner;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.regex.Pattern;\nimport javax.annotation.Nullable;\nimport javax.sql.DataSource;\n\npublic class Dialect {\n\n    // see https://github.com/hibernate/hibernate-orm/commit/59fede7acaaa1579b561407aefa582311f7ebe78\n    private static final Pattern ESCAPE_CLOSING_COMMENT_PATTERN = Pattern.compile(\"\\\\*/\");\n    private static final Pattern ESCAPE_OPENING_COMMENT_PATTERN = Pattern.compile(\"/\\\\*\");\n\n    private boolean debugMode;\n\n    public static Dialect detect(DataSource dataSource, boolean debugMode) {\n        Dialect dialect;\n        try {\n            Connection conn = dataSource.getConnection();\n            String driver = conn.getMetaData().getDriverName();\n            if (driver.contains(\"Oracle\")) {\n                dialect = new OracleDialect();\n            } else {\n                dialect = new Dialect();\n            }\n            conn.close();\n        } catch (SQLException ex) {\n            throw new RuntimeException(ex);\n        }\n        dialect.setDebugMode(debugMode);\n        return dialect;\n    }\n\n    public boolean isDebugMode() {\n        return debugMode;\n    }\n\n    public void setDebugMode(boolean debugMode) {\n        this.debugMode = debugMode;\n    }\n\n    /** Escapes the contents of the SQL comment to prevent SQL injection. */\n    public String escapeComment(String comment) {\n        String escaped = ESCAPE_CLOSING_COMMENT_PATTERN.matcher(comment).replaceAll(\"*\\\\\\\\/\");\n        return ESCAPE_OPENING_COMMENT_PATTERN.matcher(escaped).replaceAll(\"/\\\\\\\\*\");\n    }\n\n    /** Appends the objects to the SQL in a comment if debug mode is enabled. */\n    public StringBuilder appendComment(StringBuilder sql, Object... objects) {\n        if (!debugMode) {\n            return sql;\n        }\n        sql.append(\" /* \");\n        for (Object object : objects) {\n            sql.append(escapeComment(String.valueOf(object)));\n        }\n        return sql.append(\" */\\n\");\n    }\n\n    /** Appends the objects to the SQL in an comment if debug mode is enabled. */\n    public StringBuilder appendComment(Object sql, Object... objects) {\n        return appendComment((StringBuilder) sql, objects);\n    }\n\n    /** Appends one of the strings to the SQL depending on whether debug mode is enabled. */\n    public StringBuilder appendIfDebug(StringBuilder sql, String ifEnabled, String ifDisabled) {\n        return sql.append(debugMode ? ifEnabled : ifDisabled);\n    }\n\n    public void applyOffsetLimit(\n            StringBuilder sql, @Nullable Integer offset, @Nullable Integer limit) {\n        // some db's require limit to be present of offset is\n        if (offset != null && limit == null) {\n            limit = Integer.MAX_VALUE;\n        }\n        if (limit != null) {\n            sql.append(\" LIMIT \").append(limit);\n        }\n        if (offset != null) {\n            sql.append(\" OFFSET \").append(offset);\n        }\n    }\n\n    public String nextVal(String sequence) {\n        return \"DEFAULT\";\n    }\n\n    public CharSequence propertyName(String propertyName) {\n        return Joiner.on(\"\").join(identifierQualifier(), propertyName, identifierQualifier());\n    }\n\n    private String identifierQualifier() {\n        return \"\";\n    }\n\n    public CharSequence iLikeArgument(CharSequence subsequence) {\n        return Joiner.on(\"\").join(\"%\", String.valueOf(subsequence).toLowerCase(), \"%\");\n    }\n\n    public CharSequence iLikeNamedPreparedConstruct(String attributeName, String valueParam) {\n        return Joiner.on(\"\").join(\"LOWER(\", propertyName(attributeName), \") LIKE :\", valueParam);\n    }\n}\n", "/* (c) 2014 Open Source Geospatial Foundation - all rights reserved\n * (c) 2001 - 2013 OpenPlans\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcconfig.internal;\n\nimport static com.google.common.base.Preconditions.*;\n\nimport com.google.common.base.Preconditions;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.geoserver.catalog.Predicates;\nimport org.geoserver.function.IsInstanceOf;\nimport org.geotools.filter.Capabilities;\nimport org.geotools.filter.LikeFilterImpl;\nimport org.opengis.filter.And;\nimport org.opengis.filter.BinaryLogicOperator;\nimport org.opengis.filter.ExcludeFilter;\nimport org.opengis.filter.Filter;\nimport org.opengis.filter.FilterFactory;\nimport org.opengis.filter.FilterVisitor;\nimport org.opengis.filter.Id;\nimport org.opengis.filter.IncludeFilter;\nimport org.opengis.filter.MultiValuedFilter.MatchAction;\nimport org.opengis.filter.Not;\nimport org.opengis.filter.Or;\nimport org.opengis.filter.PropertyIsBetween;\nimport org.opengis.filter.PropertyIsEqualTo;\nimport org.opengis.filter.PropertyIsGreaterThan;\nimport org.opengis.filter.PropertyIsGreaterThanOrEqualTo;\nimport org.opengis.filter.PropertyIsLessThan;\nimport org.opengis.filter.PropertyIsLessThanOrEqualTo;\nimport org.opengis.filter.PropertyIsLike;\nimport org.opengis.filter.PropertyIsNil;\nimport org.opengis.filter.PropertyIsNotEqualTo;\nimport org.opengis.filter.PropertyIsNull;\nimport org.opengis.filter.capability.FilterCapabilities;\nimport org.opengis.filter.expression.Add;\nimport org.opengis.filter.expression.Divide;\nimport org.opengis.filter.expression.Expression;\nimport org.opengis.filter.expression.ExpressionVisitor;\nimport org.opengis.filter.expression.Function;\nimport org.opengis.filter.expression.Literal;\nimport org.opengis.filter.expression.Multiply;\nimport org.opengis.filter.expression.NilExpression;\nimport org.opengis.filter.expression.PropertyName;\nimport org.opengis.filter.expression.Subtract;\nimport org.opengis.filter.spatial.BBOX;\nimport org.opengis.filter.spatial.Beyond;\nimport org.opengis.filter.spatial.Contains;\nimport org.opengis.filter.spatial.Crosses;\nimport org.opengis.filter.spatial.DWithin;\nimport org.opengis.filter.spatial.Disjoint;\nimport org.opengis.filter.spatial.Equals;\nimport org.opengis.filter.spatial.Intersects;\nimport org.opengis.filter.spatial.Overlaps;\nimport org.opengis.filter.spatial.Touches;\nimport org.opengis.filter.spatial.Within;\nimport org.opengis.filter.temporal.After;\nimport org.opengis.filter.temporal.AnyInteracts;\nimport org.opengis.filter.temporal.Before;\nimport org.opengis.filter.temporal.Begins;\nimport org.opengis.filter.temporal.BegunBy;\nimport org.opengis.filter.temporal.During;\nimport org.opengis.filter.temporal.EndedBy;\nimport org.opengis.filter.temporal.Ends;\nimport org.opengis.filter.temporal.Meets;\nimport org.opengis.filter.temporal.MetBy;\nimport org.opengis.filter.temporal.OverlappedBy;\nimport org.opengis.filter.temporal.TContains;\nimport org.opengis.filter.temporal.TEquals;\nimport org.opengis.filter.temporal.TOverlaps;\n\n/** */\npublic class FilterToCatalogSQL implements FilterVisitor, ExpressionVisitor {\n\n    public static final FilterCapabilities CAPABILITIES;\n\n    static {\n        Capabilities builder = new Capabilities();\n        builder.addType(PropertyIsEqualTo.class);\n        builder.addType(PropertyIsNotEqualTo.class);\n        builder.addType(PropertyIsLike.class);\n        builder.addType(PropertyIsNull.class); // whether a property exists at all\n        builder.addType(PropertyIsNil.class); // whether the property exists AND it's value is null\n        builder.addType(And.class);\n        builder.addType(Or.class);\n        builder.addName(IsInstanceOf.NAME.getName());\n\n        CAPABILITIES = builder.getContents();\n    }\n\n    private final Dialect dialect;\n\n    private final Class<?> queryType;\n\n    private final DbMappings dbMappings;\n\n    private final Map<String, Object> namedParams = new LinkedHashMap<>();\n\n    public FilterToCatalogSQL(Dialect dialect, Class<?> queryType, DbMappings dbMappings) {\n        this.dialect = dialect;\n        this.queryType = queryType;\n        this.dbMappings = dbMappings;\n        List<Integer> concreteQueryTypes = dbMappings.getConcreteQueryTypes(queryType);\n        namedParams.put(\"types\", concreteQueryTypes);\n    }\n\n    /** */\n    public Map<String, Object> getNamedParameters() {\n        return namedParams;\n    }\n\n    private StringBuilder append(Object extraData, String... s) {\n        StringBuilder sb = (StringBuilder) extraData;\n        for (String p : s) {\n            sb.append(p);\n        }\n        return sb;\n    }\n\n    /** @see org.opengis.filter.FilterVisitor#visitNullFilter(java.lang.Object) */\n    @Override\n    public Object visitNullFilter(Object extraData) {\n        throw new UnsupportedOperationException(\"Do not use null as filter\");\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.ExcludeFilter,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(ExcludeFilter filter, Object extraData) {\n        return dialect.appendComment(append(extraData, \"0 = 1\"), \"EXCLUDE\");\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.IncludeFilter,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(IncludeFilter filter, Object extraData) {\n        return dialect.appendComment(append(extraData, \"1 = 1\"), \"INCLUDE\");\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsEqualTo,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsEqualTo filter, Object extraData) {\n\n        MatchAction matchAction = filter.getMatchAction();\n        boolean matchingCase = filter.isMatchingCase();\n\n        if (!(filter.getExpression1() instanceof Literal)\n                && !(filter.getExpression2() instanceof Literal)) {\n\n            // comparing two fields with each other\n\n            PropertyName expression1 = (PropertyName) filter.getExpression1();\n            PropertyName expression2 = (PropertyName) filter.getExpression2();\n\n            final String propertyTypesParam1 = propertyTypesParam(expression1);\n            final String propertyTypesParam2 = propertyTypesParam(expression2);\n\n            // respect matchCase\n            String valueCol1 = matchingCase ? \"o1.value\" : \"UPPER(o1.value)\";\n            String valueCol2 = matchingCase ? \"o2.value\" : \"UPPER(o2.value)\";\n\n            switch (matchAction) {\n                    // respect matchaction\n                case ALL: // all = another value for the property may not occur\n                    append(\n                            extraData,\n                            \"oid NOT IN (SELECT o1.oid FROM object_property o1, object_property o2 WHERE o1.oid = o2.oid \",\n                            \"AND o1.property_type IN (:\",\n                            propertyTypesParam1,\n                            \") AND o2.property_type IN (:\",\n                            propertyTypesParam2,\n                            \") AND \",\n                            valueCol1,\n                            \" != \",\n                            valueCol2,\n                            \")\");\n                    break;\n                case ANY: // any = the value for the property must occur at least once\n                    append(\n                            extraData,\n                            \"oid IN (SELECT o1.oid FROM object_property o1, object_property o2 WHERE o1.oid = o2.oid \",\n                            \"AND o1.property_type IN (:\",\n                            propertyTypesParam1,\n                            \") AND o2.property_type IN (:\",\n                            propertyTypesParam2,\n                            \") AND \",\n                            valueCol1,\n                            \" = \",\n                            valueCol2,\n                            \")\");\n                    break;\n                case ONE: // one = the value for the property must occur exactly once\n                    append(\n                            extraData,\n                            \"oid IN (SELECT o1.oid FROM object_property o1, object_property o2 WHERE o1.oid = o2.oid \",\n                            \"AND o1.property_type IN (:\",\n                            propertyTypesParam1,\n                            \") AND o2.property_type IN (:\",\n                            propertyTypesParam2,\n                            \") AND \",\n                            valueCol1,\n                            \" = \",\n                            valueCol2,\n                            \" GROUP BY (oid) HAVING COUNT(oid) = 1)\");\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"MatchAction: \" + matchAction);\n            }\n        } else {\n\n            if (filter.getExpression1() instanceof IsInstanceOf) {\n                return handleInstanceOf((IsInstanceOf) filter.getExpression1(), extraData);\n            }\n\n            // comparing a literal with a field\n\n            PropertyName expression1;\n            Literal expression2;\n\n            // decide which is the literal\n            if (filter.getExpression1() instanceof Literal) {\n                expression1 = (PropertyName) filter.getExpression2();\n                expression2 = (Literal) filter.getExpression1();\n\n            } else {\n                expression1 = (PropertyName) filter.getExpression1();\n                expression2 = (Literal) filter.getExpression2();\n            }\n\n            final String propertyTypesParam = propertyTypesParam(expression1);\n\n            // respect match case\n            String expectedValue = expression2.evaluate(null, String.class);\n            if (!matchingCase) {\n                expectedValue = expectedValue.toUpperCase();\n            }\n            String valueParam = newParam(\"value\", expectedValue);\n            String valueCol = matchingCase ? \"value\" : \"UPPER(value)\";\n\n            switch (matchAction) {\n                    // respect match action\n                case ALL: // all = another value for the property may not occur\n                    append(\n                            extraData,\n                            \"oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                            propertyTypesParam,\n                            \") AND \",\n                            valueCol,\n                            \" != :\",\n                            valueParam,\n                            \")\");\n                    break;\n                case ANY: // any = the value for the property must occur at least once\n                    append(\n                            extraData,\n                            \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                            propertyTypesParam,\n                            \") AND \",\n                            valueCol,\n                            \" = :\",\n                            valueParam,\n                            \")\");\n                    break;\n                case ONE: // one = the value for the property must occur exactly once\n                    append(\n                            extraData,\n                            \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                            propertyTypesParam,\n                            \") AND \",\n                            valueCol,\n                            \" = :\",\n                            valueParam,\n                            \" GROUP BY (oid) HAVING COUNT(oid) = 1)\");\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"MatchAction: \" + matchAction);\n            }\n        }\n        return dialect.appendComment(extraData, filter);\n    }\n\n    private Object handleInstanceOf(IsInstanceOf instanceOf, Object extraData) {\n        Expression expression1 = instanceOf.getParameters().get(0);\n\n        Class<?> clazz = expression1.evaluate(null, Class.class);\n        Integer typeId = dbMappings.getTypeId(clazz);\n        if (typeId == null) {\n            return visit(Filter.EXCLUDE, extraData);\n        }\n        append(extraData, \"type_id = \", typeId.toString());\n        return dialect.appendComment(extraData, \"isInstanceOf \", clazz.getName());\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsLike,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsLike filter, Object extraData) {\n        final PropertyName expression1 = (PropertyName) filter.getExpression();\n\n        final String propertyTypesParam = propertyTypesParam(expression1);\n\n        final String literal = filter.getLiteral();\n        final MatchAction matchAction = filter.getMatchAction();\n        final char esc = filter.getEscape().charAt(0);\n        final char multi = filter.getWildCard().charAt(0);\n        final char single = filter.getSingleChar().charAt(0);\n        final boolean matchCase = filter.isMatchingCase();\n\n        final String pattern =\n                LikeFilterImpl.convertToSQL92(esc, multi, single, matchCase, literal, false);\n\n        // respect match case\n        String valueParam = newParam(\"value\", pattern);\n        String valueCol = matchCase ? \"value\" : \"UPPER(value)\";\n\n        switch (matchAction) {\n                // respect match action\n            case ALL: // all = another value for the property may not occur\n                append(\n                        extraData,\n                        \"oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                        propertyTypesParam,\n                        \") AND \",\n                        valueCol,\n                        \" NOT LIKE :\",\n                        valueParam,\n                        \")\");\n                break;\n            case ANY: // any = the value for the property must occur at least once\n                append(\n                        extraData,\n                        \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                        propertyTypesParam,\n                        \") AND \",\n                        valueCol,\n                        \" LIKE :\",\n                        valueParam,\n                        \")\");\n                break;\n            case ONE: // one = the value for the property must occur exactly once\n                append(\n                        extraData,\n                        \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                        propertyTypesParam,\n                        \") AND \",\n                        valueCol,\n                        \" LIKE :\",\n                        valueParam,\n                        \" GROUP BY (oid) HAVING COUNT(oid) = 1)\");\n                break;\n            default:\n                throw new IllegalArgumentException(\"MatchAction: \" + matchAction);\n        }\n        return dialect.appendComment(extraData, filter);\n    }\n\n    private String propertyTypesParam(final PropertyName property) {\n\n        final String propertyTypesParam;\n        final Set<PropertyType> propertyTypes;\n\n        String propertyName = property.getPropertyName();\n        propertyTypes = dbMappings.getPropertyTypes(queryType, propertyName);\n\n        Preconditions.checkState(\n                !propertyTypes.isEmpty(),\n                \"Found no mapping for property '\" + property + \"' of type \" + queryType.getName());\n\n        List<Integer> propTypeIds = new ArrayList<Integer>(propertyTypes.size());\n        for (PropertyType pt : propertyTypes) {\n            Integer propertyTypeId = pt.getOid();\n            propTypeIds.add(propertyTypeId);\n        }\n        propertyTypesParam = newParam(\"ptype\", propTypeIds);\n        return propertyTypesParam;\n    }\n\n    /** */\n    private String newParam(String paramNamePrefix, Object paramValue) {\n        int sufix = 0;\n        while (true) {\n            String paramName = paramNamePrefix + sufix;\n            if (!namedParams.containsKey(paramName)) {\n                namedParams.put(paramName, paramValue);\n                return paramName;\n            }\n            sufix++;\n        }\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsNotEqualTo,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsNotEqualTo filter, Object extraData) {\n        // equivalent to not(propertyisequalto)\n\n        FilterFactory ff = Predicates.factory;\n        Not not =\n                ff.not(\n                        ff.equal(\n                                filter.getExpression1(),\n                                filter.getExpression2(),\n                                filter.isMatchingCase(),\n                                filter.getMatchAction()));\n        visit(not, extraData);\n\n        return extraData;\n    }\n\n    /** @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.And, java.lang.Object) */\n    @Override\n    public Object visit(And filter, Object extraData) {\n        return visit(filter, \"AND\", extraData);\n    }\n\n    /** @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.Or, java.lang.Object) */\n    @Override\n    public Object visit(Or filter, Object extraData) {\n        return visit(filter, \"OR\", extraData);\n    }\n\n    protected Object visit(BinaryLogicOperator filter, String type, Object extraData) {\n        StringBuilder sql = (StringBuilder) extraData;\n        List<Filter> children = filter.getChildren();\n        checkArgument(children.size() > 0);\n        sql.append('(');\n        dialect.appendIfDebug(sql, \"\\n    \", \"\");\n        for (Iterator<Filter> it = children.iterator(); it.hasNext(); ) {\n            it.next().accept(this, sql);\n            if (it.hasNext()) {\n                dialect.appendIfDebug(sql, \"    \", \" \");\n                sql.append(type);\n                dialect.appendIfDebug(sql, \"\\n    \", \" \");\n            }\n        }\n        return sql.append(')');\n    }\n\n    /** @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.Id, java.lang.Object) */\n    @Override\n    public Object visit(Id filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /** @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.Not, java.lang.Object) */\n    @Override\n    public Object visit(Not filter, Object extraData) {\n        Filter child = filter.getFilter();\n        // these filter types are already enclosed in parentheses\n        boolean extraParens =\n                !(child instanceof And || child instanceof Or || child instanceof PropertyIsNull);\n        append(extraData, \"NOT \", extraParens ? \"(\" : \"\");\n        child.accept(this, extraData);\n        return append(extraData, extraParens ? \")\" : \"\");\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsBetween,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsBetween filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsGreaterThan,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsGreaterThan filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsGreaterThanOrEqualTo,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsGreaterThanOrEqualTo filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsLessThan,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsLessThan filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsLessThanOrEqualTo,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsLessThanOrEqualTo filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsNull,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsNull filter, Object extraData) {\n        final PropertyName propertyName = (PropertyName) filter.getExpression();\n        final String propertyTypesParam = propertyTypesParam(propertyName);\n\n        append(\n                extraData,\n                \"(oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                propertyTypesParam,\n                \") AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                propertyTypesParam,\n                \")))\");\n        return dialect.appendComment(extraData, filter);\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.PropertyIsNil,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyIsNil filter, Object extraData) {\n        final PropertyName propertyName = (PropertyName) filter.getExpression();\n        final String propertyTypesParam = propertyTypesParam(propertyName);\n\n        append(\n                extraData,\n                \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n                propertyTypesParam,\n                \") AND value IS NULL)\");\n        return dialect.appendComment(extraData, filter);\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.BBOX,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(BBOX filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Beyond,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Beyond filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Contains,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Contains filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Crosses,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Crosses filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Disjoint,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Disjoint filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.DWithin,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(DWithin filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Equals,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Equals filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Intersects,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Intersects filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Overlaps,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Overlaps filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Touches,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Touches filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.spatial.Within,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Within filter, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.After,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(After after, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.AnyInteracts,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(AnyInteracts anyInteracts, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.Before,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Before before, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.Begins,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Begins begins, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.BegunBy,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(BegunBy begunBy, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.During,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(During during, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.EndedBy,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(EndedBy endedBy, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.Ends,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Ends ends, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.Meets,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Meets meets, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.MetBy,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(MetBy metBy, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.OverlappedBy,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(OverlappedBy overlappedBy, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.TContains,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(TContains contains, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.TEquals,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(TEquals equals, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.temporal.TOverlaps,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(TOverlaps contains, Object extraData) {\n\n        return extraData;\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.NilExpression,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(NilExpression expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.Add,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Add expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.Divide,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Divide expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.Function,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Function expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.Literal,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Literal expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.Multiply,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Multiply expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.PropertyName,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(PropertyName expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @see\n     *     org.opengis.filter.expression.ExpressionVisitor#visit(org.opengis.filter.expression.Subtract,\n     *     java.lang.Object)\n     */\n    @Override\n    public Object visit(Subtract expression, Object extraData) {\n\n        throw new UnsupportedOperationException();\n    }\n}\n", "/* (c) 2014 Open Source Geospatial Foundation - all rights reserved\n * (c) 2001 - 2014 OpenPlans\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcconfig.internal;\n\nimport javax.annotation.Nullable;\n\npublic class OracleDialect extends Dialect {\n\n    @Override\n    public void applyOffsetLimit(\n            StringBuilder sql, @Nullable Integer offset, @Nullable Integer limit) {\n        // some db's require limit to be present of offset is\n        if (offset != null && limit == null) {\n            limit = Integer.MAX_VALUE; // ensure we don't wrap around\n        }\n        if (limit != null && offset == null) {\n            offset = 0;\n            limit += 1; // not zero-based\n        }\n        if (offset != null && limit != null) {\n            sql.insert(\n                    0,\n                    \"SELECT * FROM (SELECT query.*, rownum rnum FROM (\"\n                            + (isDebugMode() ? \"\\n\" : \"\"));\n            sql.append(\") query\");\n            appendIfDebug(sql, \"\\n\", \" \");\n            if (limit != Integer.MAX_VALUE) {\n                limit = offset + limit;\n            }\n            sql.append(\"WHERE rownum <= \").append(limit).append(\")\");\n            appendIfDebug(sql, \"\\n\", \" \");\n            sql.append(\"WHERE rnum > \").append(offset);\n        }\n    }\n\n    @Override\n    public String nextVal(String sequence) {\n        return sequence + \".nextval\";\n    }\n}\n", "/* (c) 2014 Open Source Geospatial Foundation - all rights reserved\n * (c) 2001 - 2013 OpenPlans\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcconfig.internal;\n\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.geoserver.catalog.Info;\nimport org.geotools.factory.CommonFactoryFinder;\nimport org.geotools.filter.Capabilities;\nimport org.geotools.filter.visitor.CapabilitiesFilterSplitter;\nimport org.geotools.filter.visitor.ClientTransactionAccessor;\nimport org.geotools.filter.visitor.LiteralDemultiplyingFilterVisitor;\nimport org.geotools.filter.visitor.SimplifyingFilterVisitor;\nimport org.geotools.util.logging.Logging;\nimport org.opengis.feature.type.FeatureType;\nimport org.opengis.filter.Filter;\nimport org.opengis.filter.sort.SortBy;\nimport org.opengis.filter.sort.SortOrder;\n\nclass QueryBuilder<T extends Info> {\n\n    private static final Logger LOGGER = Logging.getLogger(QueryBuilder.class);\n\n    @SuppressWarnings(\"unused\")\n    private static final SortBy DEFAULT_ORDER =\n            CommonFactoryFinder.getFilterFactory().sort(\"id\", SortOrder.ASCENDING);\n\n    private Integer offset;\n\n    private Integer limit;\n\n    private SortBy[] sortOrder;\n\n    private final boolean isCountQuery;\n\n    // yuck\n    private final Dialect dialect;\n\n    private Class<T> queryType;\n\n    private FilterToCatalogSQL predicateBuilder;\n\n    private DbMappings dbMappings;\n\n    private Filter originalFilter;\n\n    private Filter supportedFilter;\n\n    private Filter unsupportedFilter;\n\n    private boolean offsetLimitApplied = false;\n\n    /** */\n    private QueryBuilder(\n            Dialect dialect,\n            final Class<T> clazz,\n            DbMappings dbMappings,\n            final boolean isCountQuery) {\n        this.dialect = dialect;\n        this.queryType = clazz;\n        this.dbMappings = dbMappings;\n        this.isCountQuery = isCountQuery;\n        this.originalFilter = this.supportedFilter = this.unsupportedFilter = Filter.INCLUDE;\n    }\n\n    public static <T extends Info> QueryBuilder<T> forCount(\n            Dialect dialect, final Class<T> clazz, DbMappings dbMappings) {\n        return new QueryBuilder<T>(dialect, clazz, dbMappings, true);\n    }\n\n    public static <T extends Info> QueryBuilder<T> forIds(\n            Dialect dialect, final Class<T> clazz, DbMappings dbMappings) {\n        return new QueryBuilder<T>(dialect, clazz, dbMappings, false);\n    }\n\n    public Filter getUnsupportedFilter() {\n        return unsupportedFilter;\n    }\n\n    public Filter getSupportedFilter() {\n        return supportedFilter;\n    }\n\n    public Map<String, Object> getNamedParameters() {\n        Map<String, Object> params = Collections.emptyMap();\n        if (predicateBuilder != null) {\n            params = predicateBuilder.getNamedParameters();\n        }\n        return params;\n    }\n\n    public QueryBuilder<T> offset(Integer offset) {\n        this.offset = offset;\n        return this;\n    }\n\n    public QueryBuilder<T> limit(Integer limit) {\n        this.limit = limit;\n        return this;\n    }\n\n    public QueryBuilder<T> sortOrder(SortBy order) {\n        if (order == null) {\n            this.sortOrder();\n        } else {\n            this.sortOrder(new SortBy[] {order});\n        }\n        return this;\n    }\n\n    public QueryBuilder<T> sortOrder(SortBy... order) {\n        if (order == null || order.length == 0) {\n            this.sortOrder = null;\n        } else {\n            this.sortOrder = order;\n        }\n        return this;\n    }\n\n    public QueryBuilder<T> filter(Filter filter) {\n        this.originalFilter = filter;\n        return this;\n    }\n\n    private void querySortBy(StringBuilder query, String whereClause, SortBy[] orders) {\n\n        /*\n         * Start with the oid and id from the object table selecting for type and the filter.\n         *\n         * Then left join on oid for each property to sort by to turn it into an attribute.\n         *\n         * The sort each of the created attribute.\n         */\n\n        // Need to put together the ORDER BY clause as we go and then add it at the end\n        StringBuilder orderBy = new StringBuilder();\n        orderBy.append(\"ORDER BY \");\n\n        int i = 0;\n\n        query.append(\"SELECT id FROM\");\n        dialect.appendIfDebug(query, \"\\n    \", \" \");\n        query.append(\"(SELECT oid, id FROM object WHERE type_id IN (:types)\");\n        dialect.appendComment(query, queryType.getName());\n        if (whereClause != null) {\n            dialect.appendIfDebug(query, \"      \", \" \");\n            query.append(\"AND \").append(whereClause);\n        }\n        query.append(\") object\");\n\n        for (SortBy order : orders) {\n            final String sortProperty = order.getPropertyName().getPropertyName();\n            final String subSelectName = \"subSelect\" + i;\n            final String attributeName = \"prop\" + i;\n            final String propertyParamName = \"sortProperty\" + i;\n\n            final Set<Integer> sortPropertyTypeIds;\n            sortPropertyTypeIds = dbMappings.getPropertyTypeIds(queryType, sortProperty);\n\n            // Store the property type ID as a named parameter\n            Map<String, Object> namedParameters = getNamedParameters();\n            namedParameters.put(propertyParamName, sortPropertyTypeIds);\n\n            dialect.appendIfDebug(query, \"\\n  \", \" \");\n            query.append(\"LEFT JOIN\");\n            dialect.appendIfDebug(query, \"\\n    \", \" \");\n            query.append(\"(SELECT oid, value \").append(attributeName).append(\" FROM\");\n            dialect.appendIfDebug(query, \"\\n      \", \" \");\n            query.append(\"object_property WHERE property_type IN (:\")\n                    .append(propertyParamName)\n                    .append(\")) \")\n                    .append(subSelectName);\n            dialect.appendComment(\n                    query, order.getPropertyName().getPropertyName(), \" \", ascDesc(order));\n            dialect.appendIfDebug(query, \"  \", \" \");\n            query.append(\"ON object.oid = \").append(subSelectName).append(\".oid\");\n            // Update the ORDER BY clause to be added later\n            if (i > 0) orderBy.append(\", \");\n            orderBy.append(attributeName).append(\" \").append(ascDesc(order));\n\n            i++;\n        }\n        dialect.appendIfDebug(query, \"\\n  \", \" \");\n        query.append(orderBy);\n    }\n\n    private String buildWhereClause() {\n        this.predicateBuilder =\n                new FilterToCatalogSQL(this.dialect, this.queryType, this.dbMappings);\n        if (Filter.INCLUDE.equals(this.originalFilter)) {\n            return null;\n        }\n        final SimplifyingFilterVisitor filterSimplifier = new SimplifyingFilterVisitor();\n        Capabilities fcs = new Capabilities(FilterToCatalogSQL.CAPABILITIES);\n        FeatureType parent = null;\n        // use this to instruct the filter splitter which filters can be encoded depending on\n        // whether a db mapping for a given property name exists\n        ClientTransactionAccessor transactionAccessor =\n                new ClientTransactionAccessor() {\n\n                    @Override\n                    public Filter getUpdateFilter(final String attributePath) {\n                        Set<PropertyType> propertyTypes;\n                        propertyTypes = dbMappings.getPropertyTypes(queryType, attributePath);\n\n                        final boolean isMappedProp = !propertyTypes.isEmpty();\n\n                        if (isMappedProp) {\n                            // continue normally\n                            return null;\n                        } else if (LOGGER.isLoggable(Level.FINER)) {\n                            LOGGER.finer(\"Unable to encode property: \" + attributePath);\n                        }\n                        // tell the caps filter splitter this property name is not encodable\n                        return Filter.EXCLUDE;\n                    }\n\n                    @Override\n                    public Filter getDeleteFilter() {\n                        return null;\n                    }\n                };\n\n        CapabilitiesFilterSplitter filterSplitter;\n        filterSplitter = new CapabilitiesFilterSplitter(fcs, parent, transactionAccessor);\n\n        final Filter filter = (Filter) this.originalFilter.accept(filterSimplifier, null);\n        filter.accept(filterSplitter, null);\n\n        Filter supported = filterSplitter.getFilterPre();\n        Filter unsupported = filterSplitter.getFilterPost();\n        Filter demultipliedFilter =\n                (Filter) supported.accept(new LiteralDemultiplyingFilterVisitor(), null);\n        this.supportedFilter = (Filter) demultipliedFilter.accept(filterSimplifier, null);\n        this.unsupportedFilter = (Filter) unsupported.accept(filterSimplifier, null);\n        if (Filter.INCLUDE.equals(this.supportedFilter)) {\n            return null;\n        }\n        StringBuilder whereClause = new StringBuilder();\n        return this.supportedFilter.accept(predicateBuilder, whereClause).toString();\n    }\n\n    public String build() {\n\n        String whereClause = buildWhereClause();\n\n        StringBuilder query = new StringBuilder();\n        if (isCountQuery) {\n            query.append(\"SELECT COUNT(oid) FROM object WHERE type_id IN (:types)\");\n            dialect.appendComment(query, queryType.getName());\n            if (whereClause != null) {\n                dialect.appendIfDebug(query, \"\", \" \");\n                query.append(\"AND \").append(whereClause);\n            }\n        } else {\n            if (sortOrder != null) {\n                querySortBy(query, whereClause, sortOrder);\n            } else {\n                query.append(\"SELECT id FROM object WHERE type_id IN (:types)\");\n                dialect.appendComment(query, queryType.getName());\n                dialect.appendIfDebug(query, \"\", \" \");\n                if (whereClause != null) {\n                    query.append(\"AND \").append(whereClause);\n                    dialect.appendIfDebug(query, whereClause.endsWith(\"\\n\") ? \"\" : \" \", \" \");\n                }\n                query.append(\"ORDER BY oid\");\n            }\n            applyOffsetLimit(query);\n        }\n\n        return query.toString().trim();\n    }\n\n    /** When the query was built, were the offset and limit included. */\n    public boolean isOffsetLimitApplied() {\n        return offsetLimitApplied;\n    }\n\n    private static String ascDesc(SortBy order) {\n        return SortOrder.ASCENDING.equals(order.getSortOrder()) ? \"ASC\" : \"DESC\";\n    }\n\n    protected void applyOffsetLimit(StringBuilder sql) {\n        if (unsupportedFilter.equals(Filter.INCLUDE)) {\n            dialect.applyOffsetLimit(sql, offset, limit);\n            offsetLimitApplied = true;\n        } else {\n            offsetLimitApplied = false;\n        }\n    }\n}\n", "/* (c) 2017 Open Source Geospatial Foundation - all rights reserved\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcloader;\n\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.LinkedHashSet;\nimport java.util.Properties;\nimport org.geoserver.platform.resource.Resource;\nimport org.geoserver.platform.resource.Resources;\n\npublic class JDBCLoaderProperties extends Properties {\n\n    private static final long serialVersionUID = -6758388267074914346L;\n\n    // maintain order of keys to prevent writing out in random order\n    LinkedHashSet<Object> keys = new LinkedHashSet<Object>();\n\n    // factory\n    JDBCLoaderPropertiesFactoryBean factory;\n\n    String datasourceId = null;\n\n    public JDBCLoaderProperties(JDBCLoaderPropertiesFactoryBean factory) {\n        this.factory = factory;\n    }\n\n    @Override\n    public synchronized Enumeration<Object> keys() {\n        return Collections.enumeration(keys);\n    }\n\n    @Override\n    public synchronized Object put(Object key, Object value) {\n        keys.add(key);\n        return super.put(key, value);\n    }\n\n    public boolean isEnabled() {\n        return Boolean.valueOf(getProperty(\"enabled\", \"false\"));\n    }\n\n    public Optional<String> getJdbcUrl() {\n        return Optional.fromNullable(fillInPlaceholders(getProperty(\"jdbcUrl\")));\n    }\n\n    public void setJdbcUrl(String jdbcUrl) {\n        setProperty(\"jdbcUrl\", jdbcUrl);\n    }\n\n    public boolean isInitDb() {\n        return Boolean.parseBoolean(getProperty(\"initdb\", \"false\"));\n    }\n\n    public void setInitDb(boolean initdb) {\n        setProperty(\"initdb\", String.valueOf(initdb));\n    }\n\n    public Resource getInitScript() {\n        String initScript = getProperty(\"initScript\");\n        if (initScript == null) {\n            return null;\n        }\n\n        Resource resource = Resources.fromPath(initScript, factory.getDataDir());\n        Preconditions.checkState(\n                Resources.exists(resource), \"Init script does not exist: \" + resource.path());\n\n        return resource;\n    }\n\n    public boolean isImport() {\n        return Boolean.parseBoolean(getProperty(\"import\", \"false\"));\n    }\n\n    public void setImport(boolean imprt) {\n        setProperty(\"import\", String.valueOf(imprt));\n    }\n\n    public void save() throws IOException {\n        factory.saveConfig(this);\n    }\n\n    String fillInPlaceholders(String value) {\n        return value != null\n                ? value.replace(\"${GEOSERVER_DATA_DIR}\", factory.getDataDirStr())\n                : value;\n    }\n\n    public Optional<String> getJndiName() {\n        return Optional.fromNullable(getProperty(\"jndiName\"));\n    }\n\n    public void setJndiName(String name) {\n        setProperty(\"jndiName\", name);\n    }\n\n    public String getDatasourceId() {\n        return datasourceId;\n    }\n\n    public void setDatasourceId(String datasourceId) {\n        this.datasourceId = datasourceId;\n    }\n\n    public boolean isDebugMode() {\n        return Boolean.parseBoolean(getProperty(\"debugMode\", \"false\"));\n    }\n\n    public void setDebugMode(boolean debugMode) {\n        setProperty(\"debugMode\", String.valueOf(debugMode));\n    }\n}\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\" \n  xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n  xmlns:tx = \"http://www.springframework.org/schema/tx\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n        http://www.springframework.org/schema/jdbc   http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd\n        http://www.springframework.org/schema/tx     http://www.springframework.org/schema/tx/spring-tx-3.0.xsd\n        \">\n\n  <!-- main configuration, loaded via factory bean -->\n  <bean id=\"jdbcConfigProperties\" \n    class=\"org.geoserver.jdbcconfig.internal.JDBCConfigPropertiesFactoryBean\">\n      <constructor-arg ref=\"resourceStore\"/>\n  </bean>\n\n  <!-- data source, also loaded and configured via factory bean -->\n  <bean id=\"jdbcConfigDataSource\" class=\"org.geoserver.jdbcloader.DataSourceFactoryBean\">\n    <constructor-arg ref=\"jdbcConfigProperties\" />\n  </bean>\n\n  <!-- transaction manager -->\n  <bean id=\"jdbcConfigTransactionManager\"\n  \tclass=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <property name=\"dataSource\" ref=\"jdbcConfigDataSource\" />\n  </bean>\n\n  <tx:annotation-driven />\n\n  <bean id=\"jdbcPersistenceBinding\" class=\"org.geoserver.jdbcconfig.internal.XStreamInfoSerialBinding\">\n    <constructor-arg ref=\"xstreamPersisterFactory\" />\n  </bean>\n\n  <bean id=\"JDBCConfigDB\" class=\"org.geoserver.jdbcconfig.internal.ConfigDatabase\">\n    <constructor-arg ref=\"jdbcConfigProperties\" />\n    <constructor-arg ref=\"jdbcConfigDataSource\" />\n    <constructor-arg ref=\"jdbcPersistenceBinding\" />\n  </bean>\n\n  <bean id=\"JDBCCatalogFacade\" class=\"org.geoserver.jdbcconfig.catalog.JDBCCatalogFacade\">\n    <constructor-arg ref=\"JDBCConfigDB\" />\n  </bean>\n\n  <bean id=\"JDBCGeoServerFacade\" class=\"org.geoserver.jdbcconfig.config.JDBCGeoServerFacade\">\n    <constructor-arg ref=\"JDBCConfigDB\" />\n    <property name=\"resourceLoader\" ref=\"resourceLoader\" />\n    <property name=\"ddResourceStore\" ref=\"dataDirectoryResourceStore\" />\n  </bean>\n\n  <bean id=\"JDBCGeoServerLoader\" class=\"org.geoserver.jdbcconfig.JDBCGeoServerLoader\">\n    <description>\n      Replaces the default GeoServerLoader to establish the JDBCCatalogFacade and JDBCGeoServerFacade\n    </description>\n    <constructor-arg ref=\"resourceLoader\" />\n    <constructor-arg ref=\"jdbcConfigProperties\" />\n    <property name=\"catalogFacade\" ref=\"JDBCCatalogFacade\" />\n    <property name=\"geoServerFacade\" ref=\"JDBCGeoServerFacade\" />\n  </bean>\n  \n  <bean id=\"JDBCConfigStatusProvider\" class=\"org.geoserver.jdbcconfig.web.JDBCConfigStatusProvider\">\n    <constructor-arg ref=\"jdbcConfigProperties\" />\n  </bean>\n  \n  <bean id=\"JDBCCacheProvider\" class=\"org.geoserver.jdbcconfig.internal.JDBCCacheProvider\"/>\n    <bean id=\"JDBCConfigXStreamPersisterInitializer\" class=\"org.geoserver.jdbcconfig.internal.JDBCConfigXStreamPersisterInitializer\"/>\n\n  <bean id=\"JDBCLifecycleHandler\" class=\"org.geoserver.jdbcconfig.internal.JDBCLifecycleHandler\">\n    <constructor-arg ref=\"JDBCConfigDB\"/>\n  </bean>\n</beans>\n", "# flag enabling/disabling jdbcconfig module\nenabled=false\n\n# flag controlling whether database should be initialized \ninitdb=true\n\n# script to use to initialize the database\ninitScript=jdbcconfig/scripts/initdb.postgres.sql\n\n# flag controlling whether the existing (non-db) catalog should be imported\nimport=true\n\n# Flag controlling whether to add comments and some pretty-printing to SQL queries to\n# assist with debugging.  Setting this to false may allow the module to better take\n# advantage of prepared statement caching.\ndebugMode=false\n\n# database connection info\njdbcUrl=jdbc:postgresql://localhost:5432/gscatalog\ndriverClassName=org.postgresql.Driver\nusername=postgres\npassword=\n\n#\n# connection pooling/management parameters\n#\n\n# minimum connections in pool  \npool.minIdle=4\n\n# maximum connections in pool\npool.maxActive=10\n\n# whether to pool prepared statements\npool.poolPreparedStatements=true\n\n# size of prepared statement cache, only used if pool.poolPreparedStatements = true \npool.maxOpenPreparedStatements=50\n\n# whether to validate connections when obtaining from the pool\npool.testOnBorrow=true\n\n# validation query for connections from pool, must be set when pool.testOnBorrow = true\npool.validationQuery=SELECT now()\n\n# The indication of whether objects will be validated by the idle object evictor (if any). If an object fails to validate, it will be dropped from the pool. \npool.testWhileIdle=false\n\n# The number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no idle object evictor thread will be run. \npool.timeBetweenEvictionRunsMillis=-1L", "# This is a sample configuration file for running the GeoServer Catalog against a H2 database.\n# Adapt the url, user, password, and other configuration options to your set up and rename this\n# file as jdbcconfig.properties\n#\n# Note the initialization DDL script for H2 will be automatically run at startup.\n# The initialization script is located in the jdbcconfig_scripts directory, named initdb.h2.sql\n# The importCatalog configuration option tells GeoServer whether to import the current catalog from the file system\n# to the database or not. If set to true, it will be imported and the config option will be set the value 'false'\n# for the next start up to avoid trying to re-import the catalog configuration.\n\nenabled=true\n\ninitdb=true\ninitScript=jdbcconfig/scripts/initdb.h2.sql\nimport=true\n\n# Flag controlling whether to add comments and some pretty-printing to SQL queries to\n# assist with debugging.  Setting this to false may allow the module to better take\n# advantage of prepared statement caching.\ndebugMode=false\n\njdbcUrl=jdbc:h2:file:${GEOSERVER_DATA_DIR}/jdbcconfig/catalog;AUTO_SERVER=TRUE\ndriverClassName=org.h2.Driver\nusername=sa\npassword=\n\n#\n# connection pooling/management parameters\n#\n\n# minimum connections in pool  \npool.minIdle=4\n\n# maximum connections in pool\npool.maxActive=10\n\n# whether to pool prepared statements\npool.poolPreparedStatements=true\n\n# size of prepared statement cache, only used if pool.poolPreparedStatements = true \npool.maxOpenPreparedStatements=50\n\n# whether to validate connections when obtaining from the pool\npool.testOnBorrow=true\n\n# validation query for connections from pool, must be set when pool.testOnBorrow = true\npool.validationQuery=SELECT now()\n\n\n# The indication of whether objects will be validated by the idle object evictor (if any). If an object fails to validate, it will be dropped from the pool. \npool.testWhileIdle=false\n\n# The number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no idle object evictor thread will be run. \npool.timeBetweenEvictionRunsMillis=-1L", "# This is a sample configuration file for running the GeoServer Catalog against a PostgreSQL \n# database.\n#\n# Set the jndiName for a JNDI dataSource provided by your container, or set the jdbcUrl, username, \n# password, and pool.* parameters appropriately to connect directly. If both are specified, then \n# JNDI lookup will be attempted first, and a direct JDBC connection if that fails.\n#\n# Note the initialization DDL script for PostgreSQL must have been run before starting GeoServer.\n# The initialization script is located in the jdbcconfig_scripts directory, named \n# 'initdb.postgres.sql'.\n#\n# The import configuration option tells GeoServer whether to import the current catalog from the \n# file system to the database or not. If set to true, it will be imported and the config option will\n# be set the value 'false' for the next start up to avoid trying to re-import the catalog \n# configuration.\n\n#\n# Use JDBCConfig.  Turn off to use the data directory for all configuration instead.\n#\nenabled=true\n\n#\n# Initialize an empty database.  Should be set to false and done manually before starting GeoServer \n# when using Postgres\n#\ninitdb=true\ninitScript=jdbcconfig/scripts/initdb.postgres.sql\n\n#\n# Import the data directory into a new database.  Should only be used on the first run.\n#\nimport=true\n\n# Flag controlling whether to add comments and some pretty-printing to SQL queries to\n# assist with debugging.  Setting this to false may allow the module to better take\n# advantage of prepared statement caching.\ndebugMode=false\n\n#\n# The JNDI name for the data source.  Uncomment to use JNDI.\n#\n#jndiName=java\\:/comp/env/jdbc/gsconfig\n\n#\n# JDBC direct connection parameters.  Comment out following lines if using JNDI and you don't want \n# a fallback.\n#\njdbcUrl=jdbc:postgresql://localhost:5432/gscatalog\ndriverClassName=org.postgresql.Driver\nusername=postgres\npassword=\n\n#\n# connection pooling/management parameters\n#\n\n# minimum connections in pool  \npool.minIdle=4\n\n# maximum connections in pool\npool.maxActive=10\n\n# whether to pool prepared statements\npool.poolPreparedStatements=true\n\n# size of prepared statement cache, only used if pool.poolPreparedStatements = true \npool.maxOpenPreparedStatements=50\n\n# whether to validate connections when obtaining from the pool\npool.testOnBorrow=true\n\n# validation query for connections from pool, must be set when pool.testOnBorrow = true\npool.validationQuery=SELECT now()\n\n# The indication of whether objects will be validated by the idle object evictor (if any). If an object fails to validate, it will be dropped from the pool. \npool.testWhileIdle=false\n\n# The number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no idle object evictor thread will be run. \npool.timeBetweenEvictionRunsMillis=-1L", "/* (c) 2014 Open Source Geospatial Foundation - all rights reserved\n * (c) 2001 - 2013 OpenPlans\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\npackage org.geoserver.jdbcconfig;\n\nimport static org.easymock.EasyMock.*;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.servlet.ServletContext;\nimport javax.sql.DataSource;\nimport org.apache.commons.dbcp.BasicDataSource;\nimport org.geoserver.GeoServerConfigurationLock;\nimport org.geoserver.catalog.impl.CatalogImpl;\nimport org.geoserver.config.util.XStreamPersisterFactory;\nimport org.geoserver.config.util.XStreamPersisterInitializer;\nimport org.geoserver.jdbcconfig.catalog.JDBCCatalogFacade;\nimport org.geoserver.jdbcconfig.internal.ConfigDatabase;\nimport org.geoserver.jdbcconfig.internal.DbMappings;\nimport org.geoserver.jdbcconfig.internal.JDBCConfigProperties;\nimport org.geoserver.jdbcconfig.internal.JDBCConfigXStreamPersisterInitializer;\nimport org.geoserver.jdbcconfig.internal.Util;\nimport org.geoserver.jdbcconfig.internal.XStreamInfoSerialBinding;\nimport org.geoserver.jdbcloader.JDBCLoaderProperties;\nimport org.geoserver.platform.GeoServerExtensionsHelper;\nimport org.geoserver.platform.GeoServerResourceLoader;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcOperations;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.TransactionStatus;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport org.springframework.transaction.support.TransactionCallback;\nimport org.springframework.transaction.support.TransactionTemplate;\nimport org.springframework.web.context.WebApplicationContext;\n\n@SuppressWarnings(\"unused\")\npublic class JDBCConfigTestSupport {\n\n    public static File createTempDir() throws IOException {\n        File f = File.createTempFile(\"jdbcconfig\", \"data\", new File(\"target\"));\n        f.delete();\n        f.mkdirs();\n        return f;\n    }\n\n    public static class DBConfig {\n        String name;\n        String driver;\n        String connectionUrl;\n        String dbUser;\n        String dbPasswd;\n        BasicDataSource dataSource;\n        boolean initialized = false;\n\n        public DBConfig(\n                String name, String driver, String connectionUrl, String dbUser, String dbPasswd) {\n            this.name = name;\n            this.driver = driver;\n            this.connectionUrl = connectionUrl;\n            this.dbUser = dbUser;\n            this.dbPasswd = dbPasswd;\n        }\n\n        DBConfig() {}\n\n        BasicDataSource dataSource() throws Exception {\n            if (dataSource != null) return dataSource;\n\n            dataSource =\n                    new BasicDataSource() {\n\n                        @Override\n                        public synchronized void close() throws SQLException {\n                            // do nothing\n                        }\n                    };\n            dataSource.setDriverClassName(driver);\n            dataSource.setUrl(\n                    connectionUrl.replace(\"${DATA_DIR}\", createTempDir().getAbsolutePath()));\n            dataSource.setUsername(dbUser);\n            dataSource.setPassword(dbPasswd);\n\n            dataSource.setMinIdle(3);\n            dataSource.setMaxActive(10);\n            Connection connection = dataSource.getConnection();\n            connection.close();\n            return dataSource;\n        }\n\n        public String getInitScript() {\n            return \"initdb.\" + name + \".sql\";\n        }\n\n        public String getDropScript() {\n            return \"dropdb.\" + name + \".sql\";\n        }\n\n        public String getResetScript() {\n            return \"resetdb.\" + name + \".sql\";\n        }\n\n        @Override\n        public String toString() {\n            return name;\n        }\n\n        public String detailString() {\n            return \"DBConfig{\"\n                    + \"name=\"\n                    + name\n                    + \", driver=\"\n                    + driver\n                    + \", connectionUrl=\"\n                    + connectionUrl\n                    + \", dbUser=\"\n                    + dbUser\n                    + \", dbPasswd=\"\n                    + dbPasswd\n                    + '}';\n        }\n    }\n\n    private static List<Object[]> parameterizedDBConfigs;\n\n    public static final List<Object[]> parameterizedDBConfigs() {\n        if (parameterizedDBConfigs == null) {\n            parameterizedDBConfigs = new ArrayList<Object[]>();\n            for (DBConfig conf : getDBConfigurations()) {\n                parameterizedDBConfigs.add(new Object[] {conf});\n            }\n        }\n        return parameterizedDBConfigs;\n    }\n\n    static List<DBConfig> getDBConfigurations() {\n        ArrayList<DBConfig> configs = new ArrayList<DBConfig>();\n\n        dbConfig(configs, \"h2\", \"org.h2.Driver\", \"jdbc:h2:file:${DATA_DIR}/geoserver\");\n        dbConfig(\n                configs,\n                \"postgres\",\n                \"org.postgresql.Driver\",\n                \"jdbc:postgresql://localhost:5432/geoserver\");\n        dbConfig(\n                configs,\n                \"oracle\",\n                \"oracle.jdbc.OracleDriver\",\n                \"jdbc:oracle:thin:@//localhost:49161/xe\");\n\n        return configs;\n    }\n\n    static String getProperty(String dbName, String property) {\n        return System.getProperty(\"jdbcconfig.\" + dbName + \".\" + property);\n    }\n\n    public static void dbConfig(\n            List<DBConfig> configs, String name, String driver, String connectionUrl) {\n        try {\n            Class.forName(driver);\n        } catch (ClassNotFoundException cnfe) {\n            System.err.println(\"skipping \" + name + \" tests, enable via maven profile\");\n            return;\n        }\n        if (\"true\"\n                .equals(\n                        System.getProperty(\n                                \"jdbcconfig.\" + name + \".skip\",\n                                \"h2\".equals(name) ? \"false\" : \"true\"))) {\n            System.err.println(\"skipping \" + name + \" tests, enable via maven profile\");\n            return;\n        }\n        DBConfig conf = new DBConfig();\n        conf.name = name;\n        conf.driver = driver;\n        conf.connectionUrl = connectionUrl;\n        conf.dbUser = System.getProperty(\"user.name\");\n        conf.dbPasswd = \"\";\n\n        connectionUrl = getProperty(name, \"connectionUrl\");\n        if (connectionUrl != null) {\n            conf.connectionUrl = connectionUrl;\n        }\n        String dbUser = getProperty(name, \"dbUser\");\n        if (dbUser != null) {\n            conf.dbUser = dbUser;\n        }\n        String dbPass = getProperty(name, \"dbPasswd\");\n        if (dbPass != null) {\n            conf.dbPasswd = dbPass;\n        }\n        try {\n            conf.dataSource();\n        } catch (Exception ex) {\n            System.err.println(\n                    \"Unable to connect to datastore, either disable test or specify correct configuration:\");\n            System.out.println(ex.getMessage());\n            System.out.println(\"Current configuration : \" + conf.detailString());\n            return;\n        }\n        configs.add(conf);\n    }\n\n    private final DBConfig dbConfig;\n\n    private WebApplicationContext appContext;\n\n    private GeoServerResourceLoader resourceLoader;\n\n    private CatalogImpl catalog;\n\n    private BasicDataSource dataSource;\n\n    private ConfigDatabase configDb;\n\n    private JDBCCatalogFacade facade;\n\n    public JDBCConfigTestSupport(DBConfig dbConfig) {\n        this.dbConfig = dbConfig;\n    }\n\n    public void setUpWithoutAppContext() throws Exception {\n        ConfigDatabase.LOGGER.setLevel(Level.FINER);\n\n        resourceLoader = new GeoServerResourceLoader(createTempDir());\n\n        dataSource = dbConfig.dataSource();\n\n        dropDb();\n        initDb();\n\n        // use a context to initialize the ConfigDatabase as this will enable\n        // transaction management making the tests much faster (and correcter)\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(Config.class);\n        // use the dataSource we just created\n        context.getBean(Config.class).real = dataSource;\n        configDb = context.getBean(ConfigDatabase.class);\n\n        catalog = new CatalogImpl();\n        catalog.setFacade(facade = new JDBCCatalogFacade(configDb));\n        configDb.setCatalog(catalog);\n        configDb.initDb(null);\n    }\n\n    public void setUp() throws Exception {\n        ConfigDatabase.LOGGER.setLevel(Level.FINER);\n\n        // just to avoid hundreds of warnings in the logs about extension lookups with no app\n        // context set\n        appContext = createNiceMock(WebApplicationContext.class);\n        configureAppContext(appContext);\n\n        replay(appContext);\n\n        GeoServerExtensionsHelper.init(appContext);\n        GeoServerExtensionsHelper.singleton(\n                \"configurationLock\",\n                new GeoServerConfigurationLock(),\n                GeoServerConfigurationLock.class);\n        GeoServerExtensionsHelper.singleton(\n                \"JDBCConfigXStreamPersisterInitializer\",\n                new JDBCConfigXStreamPersisterInitializer(),\n                XStreamPersisterInitializer.class);\n\n        setUpWithoutAppContext();\n    }\n\n    protected void configureAppContext(WebApplicationContext appContext) {\n        expect(appContext.containsBean(\"JDBCConfigXStreamPersisterInitializer\"))\n                .andStubReturn(true);\n\n        expect(appContext.getBeansOfType((Class<?>) anyObject()))\n                .andReturn(Collections.emptyMap())\n                .anyTimes();\n        expect(appContext.getBeanNamesForType((Class<?>) anyObject()))\n                .andReturn(new String[] {})\n                .anyTimes();\n\n        ServletContext servletContext = createNiceMock(ServletContext.class);\n        replay(servletContext);\n\n        expect(appContext.getServletContext()).andReturn(servletContext);\n    }\n\n    public void tearDown() throws Exception {\n        try {\n            if (configDb != null) {\n                configDb.dispose();\n            }\n        } finally {\n            if (dataSource != null) {\n                dataSource.close();\n            }\n        }\n        GeoServerExtensionsHelper.clear();\n    }\n\n    public GeoServerResourceLoader getResourceLoader() {\n        return resourceLoader;\n    }\n\n    public WebApplicationContext getApplicationContext() {\n        return appContext;\n    }\n\n    public ConfigDatabase getDatabase() {\n        return configDb;\n    }\n\n    private void initDb() throws Exception {\n        if (!dbConfig.initialized) {\n            runScript(dbConfig.getInitScript(), null, true);\n            dbConfig.initialized = true;\n        }\n    }\n\n    private void dropDb() throws Exception {\n        URL url = JDBCGeoServerLoader.class.getResource(dbConfig.getResetScript());\n        if (url != null && dbConfig.initialized) {\n            runScript(dbConfig.getResetScript(), null, true);\n        } else {\n            // drop script cannot be run in a transaction - if a statement fails\n            // the whole thing aborts\n            runScript(dbConfig.getDropScript(), null, false);\n            dbConfig.initialized = false;\n        }\n    }\n\n    public void runScript(String dbScriptName, Logger logger, boolean tx) throws IOException {\n        try (InputStream script = JDBCConfigProperties.class.getResourceAsStream(dbScriptName)) {\n            if (script == null) {\n                throw new IllegalArgumentException(\n                        \"Script not found: \"\n                                + JDBCConfigProperties.class.getName()\n                                + \"/\"\n                                + dbScriptName);\n            }\n\n            if (!tx) {\n                NamedParameterJdbcTemplate template = new NamedParameterJdbcTemplate(dataSource);\n                Util.runScript(script, template.getJdbcOperations(), null);\n            } else {\n                DataSourceTransactionManager transactionManager =\n                        new DataSourceTransactionManager(dataSource);\n                NamedParameterJdbcTemplate template =\n                        new NamedParameterJdbcTemplate(transactionManager.getDataSource());\n                TransactionTemplate transactionTemplate =\n                        new TransactionTemplate(transactionManager);\n                final JdbcOperations jdbcOperations = template.getJdbcOperations();\n                transactionTemplate.execute(\n                        new TransactionCallback<Object>() {\n\n                            @Override\n                            public Object doInTransaction(TransactionStatus ts) {\n                                try {\n                                    Util.runScript(script, jdbcOperations, null);\n                                } catch (IOException ex) {\n                                    throw new RuntimeException(ex);\n                                }\n                                return null;\n                            }\n                        });\n            }\n        }\n    }\n\n    public DataSource getDataSource() {\n        return this.dataSource;\n    }\n\n    public DbMappings getDbMappings() {\n        return this.configDb.getDbMappings();\n    }\n\n    public CatalogImpl getCatalog() {\n        return catalog;\n    }\n\n    public JDBCCatalogFacade getFacade() {\n        return facade;\n    }\n\n    @Configuration\n    @EnableTransactionManagement\n    public static class Config {\n        DataSource real;\n        // we need a datasource immediately, but don't have one so use this as\n        // a delegate that uses the 'real' DataSource\n        DataSource lazy =\n                new BasicDataSource() {\n\n                    @Override\n                    protected synchronized DataSource createDataSource() throws SQLException {\n                        return real;\n                    }\n                };\n\n        @Bean\n        public PlatformTransactionManager jdbcConfigTransactionManager() {\n            return new DataSourceTransactionManager(dataSource());\n        }\n\n        @Bean\n        public ConfigDatabase configDatabase() {\n            return new ConfigDatabase(\n                    new JDBCLoaderProperties(null),\n                    dataSource(),\n                    new XStreamInfoSerialBinding(new XStreamPersisterFactory()));\n        }\n\n        @Bean\n        public DataSource dataSource() {\n            return lazy;\n        }\n    }\n}\n", "/*\n *    GeoTools - The Open Source Java GIS Toolkit\n *    http://geotools.org\n *\n *    (C) 2002-2011, Open Source Geospatial Foundation (OSGeo)\n *\n *    This library is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU Lesser General Public\n *    License as published by the Free Software Foundation;\n *    version 2.1 of the License.\n *\n *    This library is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *    Lesser General Public License for more details.\n */\npackage org.geoserver.jdbcconfig.internal;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport org.geoserver.catalog.LayerInfo;\nimport org.geoserver.catalog.Predicates;\nimport org.geoserver.catalog.WorkspaceInfo;\nimport org.geoserver.jdbcconfig.JDBCConfigTestSupport;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.opengis.filter.Filter;\nimport org.opengis.filter.FilterFactory;\nimport org.opengis.filter.sort.SortBy;\n\n/**\n * @author groldan\n * @author Kevin Smith, OpenGeo\n */\npublic class QueryBuilderTest {\n\n    private static final FilterFactory FACTORY = Predicates.factory;\n\n    private JDBCConfigTestSupport testSupport;\n\n    private DbMappings dbMappings;\n\n    Dialect dialect;\n\n    @Before\n    public void setUp() throws Exception {\n        dialect = new Dialect();\n        testSupport =\n                new JDBCConfigTestSupport(\n                        (JDBCConfigTestSupport.DBConfig)\n                                JDBCConfigTestSupport.parameterizedDBConfigs().get(0)[0]);\n        testSupport.setUp();\n        dbMappings = testSupport.getDbMappings();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        testSupport.tearDown();\n    }\n\n    @Test\n    public void testForIdsSort1DebugDisabled() {\n        String expected =\n                \"SELECT id FROM (SELECT oid, id FROM object WHERE type_id IN (:types)) object \"\n                        + \"LEFT JOIN (SELECT oid, value prop0 FROM object_property \"\n                        + \"WHERE property_type IN (:sortProperty0)) subSelect0 ON object.oid = subSelect0.oid \"\n                        + \"ORDER BY prop0 ASC\";\n        verifyForIds(expected, false, Predicates.acceptAll(), Predicates.asc(\"foo\"));\n    }\n\n    @Test\n    public void testForIdsSort1DebugEnabled() {\n        String expected =\n                \"SELECT id FROM\"\n                        + \"\\n    (SELECT oid, id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n                        + \"\\n) object\"\n                        + \"\\n  LEFT JOIN\"\n                        + \"\\n    (SELECT oid, value prop0 FROM\"\n                        + \"\\n      object_property WHERE property_type IN (:sortProperty0)) subSelect0 /* foo ASC */\"\n                        + \"\\n  ON object.oid = subSelect0.oid\"\n                        + \"\\n  ORDER BY prop0 ASC\";\n        verifyForIds(expected, true, Predicates.acceptAll(), Predicates.asc(\"foo\"));\n    }\n\n    @Test\n    public void testForIdsSort2DebugDisabled() {\n        String expected =\n                \"SELECT id FROM (SELECT oid, id FROM object WHERE type_id IN (:types)) object \"\n                        + \"LEFT JOIN (SELECT oid, value prop0 FROM object_property \"\n                        + \"WHERE property_type IN (:sortProperty0)) subSelect0 ON object.oid = subSelect0.oid \"\n                        + \"LEFT JOIN (SELECT oid, value prop1 FROM object_property \"\n                        + \"WHERE property_type IN (:sortProperty1)) subSelect1 ON object.oid = subSelect1.oid \"\n                        + \"ORDER BY prop0 ASC, prop1 DESC\";\n        verifyForIds(\n                expected,\n                false,\n                Predicates.acceptAll(),\n                Predicates.asc(\"foo\"),\n                Predicates.desc(\"bar\"));\n    }\n\n    @Test\n    public void testForIdsSort2DebugEnabled() {\n        String expected =\n                \"SELECT id FROM\"\n                        + \"\\n    (SELECT oid, id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n                        + \"\\n) object\"\n                        + \"\\n  LEFT JOIN\"\n                        + \"\\n    (SELECT oid, value prop0 FROM\"\n                        + \"\\n      object_property WHERE property_type IN (:sortProperty0)) subSelect0 /* foo ASC */\"\n                        + \"\\n  ON object.oid = subSelect0.oid\"\n                        + \"\\n  LEFT JOIN\"\n                        + \"\\n    (SELECT oid, value prop1 FROM\"\n                        + \"\\n      object_property WHERE property_type IN (:sortProperty1)) subSelect1 /* bar DESC */\"\n                        + \"\\n  ON object.oid = subSelect1.oid\"\n                        + \"\\n  ORDER BY prop0 ASC, prop1 DESC\";\n        verifyForIds(\n                expected,\n                true,\n                Predicates.acceptAll(),\n                Predicates.asc(\"foo\"),\n                Predicates.desc(\"bar\"));\n    }\n\n    @Test\n    public void testForIdsSort3DebugDisabled() {\n        String expected =\n                \"SELECT id FROM (SELECT oid, id FROM object WHERE type_id IN (:types)) object \"\n                        + \"LEFT JOIN (SELECT oid, value prop0 FROM object_property \"\n                        + \"WHERE property_type IN (:sortProperty0)) subSelect0 ON object.oid = subSelect0.oid \"\n                        + \"LEFT JOIN (SELECT oid, value prop1 FROM object_property \"\n                        + \"WHERE property_type IN (:sortProperty1)) subSelect1 ON object.oid = subSelect1.oid \"\n                        + \"LEFT JOIN (SELECT oid, value prop2 FROM object_property \"\n                        + \"WHERE property_type IN (:sortProperty2)) subSelect2 ON object.oid = subSelect2.oid \"\n                        + \"ORDER BY prop0 ASC, prop1 DESC, prop2 ASC\";\n        verifyForIds(\n                expected,\n                false,\n                Predicates.acceptAll(),\n                Predicates.asc(\"foo\"),\n                Predicates.desc(\"bar\"),\n                Predicates.asc(\"baz\"));\n    }\n\n    @Test\n    public void testForIdsSort3DebugEnabled() {\n        String expected =\n                \"SELECT id FROM\"\n                        + \"\\n    (SELECT oid, id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n                        + \"\\n) object\"\n                        + \"\\n  LEFT JOIN\"\n                        + \"\\n    (SELECT oid, value prop0 FROM\"\n                        + \"\\n      object_property WHERE property_type IN (:sortProperty0)) subSelect0 /* foo ASC */\"\n                        + \"\\n  ON object.oid = subSelect0.oid\"\n                        + \"\\n  LEFT JOIN\"\n                        + \"\\n    (SELECT oid, value prop1 FROM\"\n                        + \"\\n      object_property WHERE property_type IN (:sortProperty1)) subSelect1 /* bar DESC */\"\n                        + \"\\n  ON object.oid = subSelect1.oid\"\n                        + \"\\n  LEFT JOIN\"\n                        + \"\\n    (SELECT oid, value prop2 FROM\"\n                        + \"\\n      object_property WHERE property_type IN (:sortProperty2)) subSelect2 /* baz ASC */\"\n                        + \"\\n  ON object.oid = subSelect2.oid\"\n                        + \"\\n  ORDER BY prop0 ASC, prop1 DESC, prop2 ASC\";\n        verifyForIds(\n                expected,\n                true,\n                Predicates.acceptAll(),\n                Predicates.asc(\"foo\"),\n                Predicates.desc(\"bar\"),\n                Predicates.asc(\"baz\"));\n    }\n\n    @Test\n    public void testForIdsSort3WithFilterDebugDisabled() {\n        String expected =\n                \"SELECT id FROM (SELECT oid, id FROM object WHERE type_id IN (:types) AND oid IN \"\n                        + \"(SELECT oid FROM object_property WHERE property_type IN (:ptype0) AND value = :value0)) object \"\n                        + \"LEFT JOIN (SELECT oid, value prop0 FROM object_property \"\n                        + \"WHERE property_type IN (:sortProperty0)) subSelect0 ON object.oid = subSelect0.oid \"\n                        + \"LEFT JOIN (SELECT oid, value prop1 FROM object_property \"\n                        + \"WHERE property_type IN (:sortProperty1)) subSelect1 ON object.oid = subSelect1.oid \"\n                        + \"LEFT JOIN (SELECT oid, value prop2 FROM object_property \"\n                        + \"WHERE property_type IN (:sortProperty2)) subSelect2 ON object.oid = subSelect2.oid \"\n                        + \"ORDER BY prop0 ASC, prop1 DESC, prop2 ASC\";\n        verifyForIds(\n                expected,\n                false,\n                Predicates.equal(\"name\", \"quux\"),\n                Predicates.asc(\"foo\"),\n                Predicates.desc(\"bar\"),\n                Predicates.asc(\"baz\"));\n    }\n\n    @Test\n    public void testForIdsSort3WithFilterDebugEnabled() {\n        String expected =\n                \"SELECT id FROM\"\n                        + \"\\n    (SELECT oid, id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n                        + \"\\n      AND oid IN (SELECT oid FROM object_property WHERE property_type IN (:ptype0) AND value = :value0) /* [ name = quux ] */\"\n                        + \"\\n) object\"\n                        + \"\\n  LEFT JOIN\"\n                        + \"\\n    (SELECT oid, value prop0 FROM\"\n                        + \"\\n      object_property WHERE property_type IN (:sortProperty0)) subSelect0 /* foo ASC */\"\n                        + \"\\n  ON object.oid = subSelect0.oid\"\n                        + \"\\n  LEFT JOIN\"\n                        + \"\\n    (SELECT oid, value prop1 FROM\"\n                        + \"\\n      object_property WHERE property_type IN (:sortProperty1)) subSelect1 /* bar DESC */\"\n                        + \"\\n  ON object.oid = subSelect1.oid\"\n                        + \"\\n  LEFT JOIN\"\n                        + \"\\n    (SELECT oid, value prop2 FROM\"\n                        + \"\\n      object_property WHERE property_type IN (:sortProperty2)) subSelect2 /* baz ASC */\"\n                        + \"\\n  ON object.oid = subSelect2.oid\"\n                        + \"\\n  ORDER BY prop0 ASC, prop1 DESC, prop2 ASC\";\n        verifyForIds(\n                expected,\n                true,\n                Predicates.equal(\"name\", \"quux\"),\n                Predicates.asc(\"foo\"),\n                Predicates.desc(\"bar\"),\n                Predicates.asc(\"baz\"));\n    }\n\n    @Test\n    public void testForCountUnknownProperty() {\n        dialect.setDebugMode(false);\n        String expected = \"SELECT COUNT(oid) FROM object WHERE type_id IN (:types)\";\n        Filter filter = Predicates.equal(\"foo.bar.baz\", \"quux\");\n        QueryBuilder<?> builder =\n                QueryBuilder.forCount(dialect, WorkspaceInfo.class, dbMappings).filter(filter);\n        String actual = builder.build();\n        assertEquals(expected, actual);\n        assertEquals(Filter.INCLUDE, builder.getSupportedFilter());\n        assertEquals(filter, builder.getUnsupportedFilter());\n        assertFalse(builder.isOffsetLimitApplied());\n        assertEquals(1, builder.getNamedParameters().size());\n    }\n\n    @Test\n    public void testForIdsUnknownProperty() {\n        dialect.setDebugMode(false);\n        String expected = \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY oid\";\n        Filter filter = Predicates.equal(\"foo.bar.baz\", \"quux\");\n        QueryBuilder<?> builder =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings).filter(filter);\n        String actual = builder.build();\n        assertEquals(expected, actual);\n        assertEquals(Filter.INCLUDE, builder.getSupportedFilter());\n        assertEquals(filter, builder.getUnsupportedFilter());\n        assertFalse(builder.isOffsetLimitApplied());\n        assertEquals(1, builder.getNamedParameters().size());\n    }\n\n    @Test\n    public void testForCountSimplifiedInclude() {\n        dialect.setDebugMode(false);\n        String expected = \"SELECT COUNT(oid) FROM object WHERE type_id IN (:types)\";\n        Filter filter = Predicates.and(Predicates.acceptAll(), Predicates.acceptAll());\n        QueryBuilder<?> builder =\n                QueryBuilder.forCount(dialect, WorkspaceInfo.class, dbMappings).filter(filter);\n        String actual = builder.build();\n        assertEquals(expected, actual);\n        assertEquals(Filter.INCLUDE, builder.getSupportedFilter());\n        assertEquals(Filter.INCLUDE, builder.getUnsupportedFilter());\n        assertFalse(builder.isOffsetLimitApplied());\n        assertEquals(1, builder.getNamedParameters().size());\n    }\n\n    @Test\n    public void testForIdsSimplifiedInclude() {\n        dialect.setDebugMode(false);\n        String expected = \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY oid\";\n        Filter filter = Predicates.and(Predicates.acceptAll(), Predicates.acceptAll());\n        QueryBuilder<?> builder =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings).filter(filter);\n        String actual = builder.build();\n        assertEquals(expected, actual);\n        assertEquals(Filter.INCLUDE, builder.getSupportedFilter());\n        assertEquals(Filter.INCLUDE, builder.getUnsupportedFilter());\n        assertTrue(builder.isOffsetLimitApplied());\n        assertEquals(1, builder.getNamedParameters().size());\n    }\n\n    @Test\n    public void testForIdsIncludeWithOffSetDebugDisabled() {\n        dialect.setDebugMode(false);\n        String expected =\n                \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY oid LIMIT 2147483647 OFFSET 5\";\n        String actual =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings).offset(5).build();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    public void testForIdsIncludeWithLimitDebugDisabled() {\n        dialect.setDebugMode(false);\n        String expected = \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY oid LIMIT 10\";\n        String actual =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings).limit(10).build();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    public void testForIdsIncludeWithOffSetAndLimitDebugDisabled() {\n        dialect.setDebugMode(false);\n        String expected =\n                \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY oid LIMIT 10 OFFSET 5\";\n        String actual =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n                        .offset(5)\n                        .limit(10)\n                        .build();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    public void testForIdsIncludeWithOffSetDebugEnabled() {\n        dialect.setDebugMode(true);\n        String expected =\n                \"SELECT id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n                        + \"\\nORDER BY oid LIMIT 2147483647 OFFSET 5\";\n        String actual =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings).offset(5).build();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    public void testForIdsIncludeWithLimitDebugEnabled() {\n        dialect.setDebugMode(true);\n        String expected =\n                \"SELECT id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n                        + \"\\nORDER BY oid LIMIT 10\";\n        String actual =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings).limit(10).build();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    public void testForIdsIncludeWithOffSetAndLimitDebugEnabled() {\n        dialect.setDebugMode(true);\n        String expected =\n                \"SELECT id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n                        + \"\\nORDER BY oid LIMIT 10 OFFSET 5\";\n        String actual =\n                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n                        .offset(5)\n                        .limit(10)\n                        .build();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    public void testForCountIncludeDebugDisabled() {\n        String expected = \"SELECT COUNT(oid) FROM object WHERE type_id IN (:types)\";\n        verifyForCount(expected, false, Predicates.acceptAll());\n    }\n\n    @Test\n    public void testForCountIncludeDebugEnabled() {\n        String expected =\n                \"SELECT COUNT(oid) FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\";\n        verifyForCount(expected, true, Predicates.acceptAll());\n    }\n\n    @Test\n    public void testForIdsIncludeDebugDisabled() {\n        String expected = \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY oid\";\n        verifyForIds(expected, false, Predicates.acceptAll());\n    }\n\n    @Test\n    public void testForIdsIncludeDebugEnabled() {\n        String expected =\n                \"SELECT id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n                        + \"\\nORDER BY oid\";\n        verifyForIds(expected, true, Predicates.acceptAll());\n    }\n\n    @Test\n    public void testForCountAndIsInstanceofDebugDisabled() {\n        String expected = \"(type_id = 14 AND 0 = 1)\";\n        Filter filter =\n                Predicates.and(\n                        Predicates.isInstanceOf(LayerInfo.class),\n                        Predicates.isInstanceOf(String.class));\n        verifyForCount(expected, false, filter);\n    }\n\n    @Test\n    public void testForCountAndIsInstanceofDebugEnabled() {\n        String expected =\n                \"(\\n    type_id = 14 /* isInstanceOf org.geoserver.catalog.LayerInfo */\"\n                        + \"\\n    AND\\n    0 = 1 /* EXCLUDE */\\n)\";\n        Filter filter =\n                Predicates.and(\n                        Predicates.isInstanceOf(LayerInfo.class),\n                        Predicates.isInstanceOf(String.class));\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsAndIsInstanceofDebugDisabled() {\n        String expected = \"(type_id = 14 AND 0 = 1) \";\n        Filter filter =\n                Predicates.and(\n                        Predicates.isInstanceOf(LayerInfo.class),\n                        Predicates.isInstanceOf(String.class));\n        verifyForIds(expected, false, filter);\n    }\n\n    @Test\n    public void testForIdsAndIsInstanceofDebugEnabled() {\n        String expected =\n                \"(\\n    type_id = 14 /* isInstanceOf org.geoserver.catalog.LayerInfo */\"\n                        + \"\\n    AND\\n    0 = 1 /* EXCLUDE */\\n) \";\n        Filter filter =\n                Predicates.and(\n                        Predicates.isInstanceOf(LayerInfo.class),\n                        Predicates.isInstanceOf(String.class));\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountOrIsInstanceofDebugDisabled() {\n        String expected = \"(type_id = 14 OR 0 = 1)\";\n        Filter filter =\n                Predicates.or(\n                        Predicates.isInstanceOf(LayerInfo.class),\n                        Predicates.isInstanceOf(String.class));\n        verifyForCount(expected, false, filter);\n    }\n\n    @Test\n    public void testForCountOrIsInstanceofDebugEnabled() {\n        String expected =\n                \"(\\n    type_id = 14 /* isInstanceOf org.geoserver.catalog.LayerInfo */\"\n                        + \"\\n    OR\\n    0 = 1 /* EXCLUDE */\\n)\";\n        Filter filter =\n                Predicates.or(\n                        Predicates.isInstanceOf(LayerInfo.class),\n                        Predicates.isInstanceOf(String.class));\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsOrIsInstanceofDebugDisabled() {\n        String expected = \"(type_id = 14 OR 0 = 1) \";\n        Filter filter =\n                Predicates.or(\n                        Predicates.isInstanceOf(LayerInfo.class),\n                        Predicates.isInstanceOf(String.class));\n        verifyForIds(expected, false, filter);\n    }\n\n    @Test\n    public void testForIdsOrIsInstanceofDebugEnabled() {\n        String expected =\n                \"(\\n    type_id = 14 /* isInstanceOf org.geoserver.catalog.LayerInfo */\"\n                        + \"\\n    OR\\n    0 = 1 /* EXCLUDE */\\n) \";\n        Filter filter =\n                Predicates.or(\n                        Predicates.isInstanceOf(LayerInfo.class),\n                        Predicates.isInstanceOf(String.class));\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsEqualToSensitiveDebugDisabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value = :value0)\";\n        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n        verifyForCount(expected, false, filter);\n    }\n\n    @Test\n    public void testForCountIsEqualToSensitiveDebugEnabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value = :value0) /* [ name = quux ] */\";\n        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsEqualToSensitiveDebugEnabledEscaping() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value = :value0) /* [ name = FOO*\\\\/BAR ] */\";\n        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), true);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsEqualToSensitiveDebugDisabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value = :value0) \";\n        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n        verifyForIds(expected, false, filter);\n    }\n\n    @Test\n    public void testForIdsIsEqualToSensitiveDebugEnabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value = :value0) /* [ name = quux ] */\\n\";\n        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsEqualToSensitiveDebugEnabledEscaping() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value = :value0) /* [ name = FOO*\\\\/BAR ] */\\n\";\n        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), true);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsEqualToInsensitiveDebugDisabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) = :value0)\";\n        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n        verifyForCount(expected, false, filter);\n    }\n\n    @Test\n    public void testForCountIsEqualToInsensitiveDebugEnabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = quux ] */\";\n        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsEqualToInsensitiveDebugEnabledEscaping() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = FOO*\\\\/BAR ] */\";\n        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), false);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsEqualToInsensitiveDebugDisabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) = :value0) \";\n        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n        verifyForIds(expected, false, filter);\n    }\n\n    @Test\n    public void testForIdsIsEqualToInsensitiveDebugEnabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = quux ] */\\n\";\n        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsEqualToInsensitiveDebugEnabledEscaping() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = FOO*\\\\/BAR ] */\\n\";\n        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), false);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsNotEqualToSensitiveDebugDisabled() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value = :value0))\";\n        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n        verifyForCount(expected, false, filter);\n    }\n\n    @Test\n    public void testForCountIsNotEqualToSensitiveDebugEnabled() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value = :value0) /* [ name = quux ] */\\n)\";\n        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsNotEqualToSensitiveDebugEnabledEscaping() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value = :value0) /* [ name = FOO*\\\\/BAR ] */\\n)\";\n        Filter filter =\n                FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), true);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsNotEqualToSensitiveDebugDisabled() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value = :value0)) \";\n        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n        verifyForIds(expected, false, filter);\n    }\n\n    @Test\n    public void testForIdsIsNotEqualToSensitiveDebugEnabled() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value = :value0) /* [ name = quux ] */\\n) \";\n        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsNotEqualToSensitiveDebugEnabledEscaping() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value = :value0) /* [ name = FOO*\\\\/BAR ] */\\n) \";\n        Filter filter =\n                FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), true);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsNotEqualToInsensitiveDebugDisabled() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) = :value0))\";\n        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n        verifyForCount(expected, false, filter);\n    }\n\n    @Test\n    public void testForCountIsNotEqualToInsensitiveDebugEnabled() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = quux ] */\\n)\";\n        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsNotEqualToInsensitiveDebugEnabledEscaping() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = FOO*\\\\/BAR ] */\\n)\";\n        Filter filter =\n                FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), false);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsNotEqualToInsensitiveDebugDisabled() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) = :value0)) \";\n        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n        verifyForIds(expected, false, filter);\n    }\n\n    @Test\n    public void testForIdsIsNotEqualToInsensitiveDebugEnabled() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = quux ] */\\n) \";\n        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsNotEqualToInsensitiveDebugEnabledEscaping() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = FOO*\\\\/BAR ] */\\n) \";\n        Filter filter =\n                FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), false);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsLikeSensitiveDebugDisabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value LIKE :value0)\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", true);\n        verifyForCount(expected, false, filter);\n    }\n\n    @Test\n    public void testForCountIsLikeSensitiveDebugDisabledEscaping() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value LIKE :value0)\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", true);\n        verifyForCount(expected, false, filter);\n    }\n\n    @Test\n    public void testForCountIsLikeSensitiveDebugEnabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value LIKE :value0) /* [ name is like %quux% ] */\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", true);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsLikeSensitiveDebugEnabledEscaping1() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value LIKE :value0) /* [ name is like %\\\\'FOO% ] */\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", true);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsLikeSensitiveDebugEnabledEscaping2() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value LIKE :value0) /* [ name is like %FOO*\\\\/BAR% ] */\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%FOO*/BAR%\", \"%\", \"_\", \"\\\\\", true);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsLikeSensitiveDebugDisabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value LIKE :value0) \";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", true);\n        verifyForIds(expected, false, filter);\n    }\n\n    @Test\n    public void testForIdsIsLikeSensitiveDebugDisabledEscaping() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value LIKE :value0) \";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", true);\n        verifyForIds(expected, false, filter);\n    }\n\n    @Test\n    public void testForIdsIsLikeSensitiveDebugEnabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value LIKE :value0) /* [ name is like %quux% ] */\\n\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", true);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsLikeSensitiveDebugEnabledEscaping1() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value LIKE :value0) /* [ name is like %\\\\'FOO% ] */\\n\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", true);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsLikeSensitiveDebugEnabledEscaping2() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND value LIKE :value0) /* [ name is like %FOO*\\\\/BAR% ] */\\n\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%FOO*/BAR%\", \"%\", \"_\", \"\\\\\", true);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsLikeInsensitiveDebugDisabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0)\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", false);\n        verifyForCount(expected, false, filter);\n    }\n\n    @Test\n    public void testForCountIsLikeInsensitiveDebugDisabledEscaping() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0)\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", false);\n        verifyForCount(expected, false, filter);\n    }\n\n    @Test\n    public void testForCountIsLikeInsensitiveDebugEnabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) /* [ name is like %quux% ] */\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", false);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsLikeInsensitiveDebugEnabledEscaping1() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) /* [ name is like %\\\\'FOO% ] */\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", false);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsLikeInsensitiveDebugEnabledEscaping2() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) /* [ name is like %FOO*\\\\/BAR% ] */\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%FOO*/BAR%\", \"%\", \"_\", \"\\\\\", false);\n        verifyForCount(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsLikeInsensitiveDebugDisabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) \";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", false);\n        verifyForIds(expected, false, filter);\n    }\n\n    @Test\n    public void testForIdsIsLikeInsensitiveDebugDisabledEscaping() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) \";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", false);\n        verifyForIds(expected, false, filter);\n    }\n\n    @Test\n    public void testForIdsIsLikeInsensitiveDebugEnabled() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) /* [ name is like %quux% ] */\\n\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", false);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsLikeInsensitiveDebugEnabledEscaping1() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) /* [ name is like %\\\\'FOO% ] */\\n\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", false);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForIdsIsLikeInsensitiveDebugEnabledEscaping2() {\n        String expected =\n                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) /* [ name is like %FOO*\\\\/BAR% ] */\\n\";\n        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%FOO*/BAR%\", \"%\", \"_\", \"\\\\\", false);\n        verifyForIds(expected, true, filter);\n    }\n\n    @Test\n    public void testForCountIsNullDebugDisabled() {\n        String expected =\n                \"(oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0)))\";\n        verifyForCount(expected, false, Predicates.isNull(\"name\"));\n    }\n\n    @Test\n    public void testForCountIsNullDebugEnabled() {\n        String expected =\n                \"(oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0))) /* [ name IS NULL ] */\";\n        verifyForCount(expected, true, Predicates.isNull(\"name\"));\n    }\n\n    @Test\n    public void testForIdsIsNullDebugDisabled() {\n        String expected =\n                \"(oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0))) \";\n        verifyForIds(expected, false, Predicates.isNull(\"name\"));\n    }\n\n    @Test\n    public void testForIdsIsNullDebugEnabled() {\n        String expected =\n                \"(oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0))) /* [ name IS NULL ] */\\n\";\n        verifyForIds(expected, true, Predicates.isNull(\"name\"));\n    }\n\n    @Test\n    public void testForCountIsNotNullDebugDisabled() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0)))\";\n        verifyForCount(expected, false, Predicates.not(Predicates.isNull(\"name\")));\n    }\n\n    @Test\n    public void testForCountIsNotNullDebugEnabled() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0))) /* [ name IS NULL ] */\";\n        verifyForCount(expected, true, Predicates.not(Predicates.isNull(\"name\")));\n    }\n\n    @Test\n    public void testForIdsIsNotNullDebugDisabled() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0))) \";\n        verifyForIds(expected, false, Predicates.not(Predicates.isNull(\"name\")));\n    }\n\n    @Test\n    public void testForIdsIsNotNullDebugEnabled() {\n        String expected =\n                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                        + \"ptype0))) /* [ name IS NULL ] */\\n\";\n        verifyForIds(expected, true, Predicates.not(Predicates.isNull(\"name\")));\n    }\n\n    private void verifyForCount(String expectedSQL, boolean debugMode, Filter filter) {\n        String expected = expectedSQL;\n        if (!expected.startsWith(\"SELECT\")) {\n            expected =\n                    \"SELECT COUNT(oid) FROM object WHERE type_id IN (:types) \"\n                            + (debugMode ? \"/* org.geoserver.catalog.WorkspaceInfo */\\n\" : \"\")\n                            + \"AND \"\n                            + expectedSQL;\n        }\n        QueryBuilder<?> builder = QueryBuilder.forCount(dialect, WorkspaceInfo.class, dbMappings);\n        verifyQuery(builder, expected, debugMode, filter);\n    }\n\n    private void verifyForIds(\n            String expectedSQL, boolean debugMode, Filter filter, SortBy... order) {\n        String expected = expectedSQL;\n        if (!expected.startsWith(\"SELECT\")) {\n            expected =\n                    \"SELECT id FROM object WHERE type_id IN (:types) \"\n                            + (debugMode ? \"/* org.geoserver.catalog.WorkspaceInfo */\\n\" : \"\")\n                            + \"AND \"\n                            + expectedSQL\n                            + \"ORDER BY oid\";\n        }\n        QueryBuilder<?> builder = QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings);\n        verifyQuery(builder, expected, debugMode, filter, order);\n    }\n\n    private void verifyQuery(\n            QueryBuilder<?> builder,\n            String expected,\n            boolean debugMode,\n            Filter filter,\n            SortBy... order) {\n        dialect.setDebugMode(debugMode);\n        String actual = builder.filter(filter).sortOrder(order).build();\n        assertEquals(expected, actual);\n        if (Filter.INCLUDE.equals(filter)) {\n            assertEquals(Filter.INCLUDE, builder.getSupportedFilter());\n        } else {\n            assertNotEquals(Filter.INCLUDE, builder.getSupportedFilter());\n        }\n        assertEquals(Filter.INCLUDE, builder.getUnsupportedFilter());\n        assertEquals(!actual.startsWith(\"SELECT COUNT\"), builder.isOffsetLimitApplied());\n        assertFalse(builder.getNamedParameters().isEmpty());\n    }\n}\n"], "filenames": ["src/community/jdbcconfig/src/main/java/org/geoserver/jdbcconfig/internal/ConfigDatabase.java", "src/community/jdbcconfig/src/main/java/org/geoserver/jdbcconfig/internal/Dialect.java", "src/community/jdbcconfig/src/main/java/org/geoserver/jdbcconfig/internal/FilterToCatalogSQL.java", "src/community/jdbcconfig/src/main/java/org/geoserver/jdbcconfig/internal/OracleDialect.java", "src/community/jdbcconfig/src/main/java/org/geoserver/jdbcconfig/internal/QueryBuilder.java", "src/community/jdbcconfig/src/main/java/org/geoserver/jdbcloader/JDBCLoaderProperties.java", "src/community/jdbcconfig/src/main/resources/applicationContext.xml", "src/community/jdbcconfig/src/main/resources/jdbcconfig.properties", "src/community/jdbcconfig/src/main/resources/jdbcconfig.properties.h2", "src/community/jdbcconfig/src/main/resources/jdbcconfig.properties.postgres", "src/community/jdbcconfig/src/test/java/org/geoserver/jdbcconfig/JDBCConfigTestSupport.java", "src/community/jdbcconfig/src/test/java/org/geoserver/jdbcconfig/internal/QueryBuilderTest.java"], "buggy_code_start_loc": [105, 10, 21, 24, 131, 109, 35, 11, 15, 32, 34, 19], "buggy_code_end_loc": [489, 30, 621, 30, 271, 109, 35, 11, 15, 32, 422, 181], "fixing_code_start_loc": [106, 11, 22, 24, 131, 110, 36, 12, 16, 33, 35, 19], "fixing_code_end_loc": [496, 75, 561, 35, 278, 118, 37, 17, 21, 38, 425, 987], "type": "CWE-89", "message": "GeoServer is an open source software server written in Java that allows users to share and edit geospatial data. GeoServer includes support for the OGC Filter expression language and the OGC Common Query Language (CQL) as part of the Web Feature Service (WFS) and Web Map Service (WMS) protocols. CQL is also supported through the Web Coverage Service (WCS) protocol for ImageMosaic coverages. Users are advised to upgrade to either version 2.21.4, or version 2.22.2 to resolve this issue. Users unable to upgrade should disable the PostGIS Datastore *encode functions* setting to mitigate ``strEndsWith``, ``strStartsWith`` and ``PropertyIsLike `` misuse and enable the PostGIS DataStore *preparedStatements* setting to mitigate the ``FeatureId`` misuse.", "other": {"cve": {"id": "CVE-2023-25157", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-21T22:15:10.620", "lastModified": "2023-03-03T16:36:34.017", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GeoServer is an open source software server written in Java that allows users to share and edit geospatial data. GeoServer includes support for the OGC Filter expression language and the OGC Common Query Language (CQL) as part of the Web Feature Service (WFS) and Web Map Service (WMS) protocols. CQL is also supported through the Web Coverage Service (WCS) protocol for ImageMosaic coverages. Users are advised to upgrade to either version 2.21.4, or version 2.22.2 to resolve this issue. Users unable to upgrade should disable the PostGIS Datastore *encode functions* setting to mitigate ``strEndsWith``, ``strStartsWith`` and ``PropertyIsLike `` misuse and enable the PostGIS DataStore *preparedStatements* setting to mitigate the ``FeatureId`` misuse."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:geoserver:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.18.7", "matchCriteriaId": "CAC1A80B-98D3-4625-8819-EA1B81CE00F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:geoserver:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.19.0", "versionEndExcluding": "2.19.7", "matchCriteriaId": "6FA3065D-87A8-4DC1-8E2D-0FFEF02CAC79"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:geoserver:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.20.0", "versionEndExcluding": "2.20.7", "matchCriteriaId": "10778C77-EB5C-4F66-B915-67BF09BDD364"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:geoserver:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.21.0", "versionEndExcluding": "2.21.4", "matchCriteriaId": "5CDCB1FA-BF94-4CB6-BC14-C38777BCDB89"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:geoserver:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.22.0", "versionEndExcluding": "2.22.2", "matchCriteriaId": "873D8AE3-D184-486E-86AB-E0D00454C533"}]}]}], "references": [{"url": "https://github.com/geoserver/geoserver/commit/145a8af798590288d270b240235e89c8f0b62e1d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/geoserver/geoserver/security/advisories/GHSA-7g5f-wrx8-5ccf", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/geoserver/geoserver/commit/145a8af798590288d270b240235e89c8f0b62e1d"}}