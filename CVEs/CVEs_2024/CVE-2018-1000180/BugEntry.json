{"buggy_code": ["package org.bouncycastle.crypto.generators;\n\nimport java.math.BigInteger;\n\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPair;\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator;\nimport org.bouncycastle.crypto.KeyGenerationParameters;\nimport org.bouncycastle.crypto.params.RSAKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.RSAKeyParameters;\nimport org.bouncycastle.crypto.params.RSAPrivateCrtKeyParameters;\nimport org.bouncycastle.math.Primes;\nimport org.bouncycastle.math.ec.WNafUtil;\n\n/**\n * an RSA key pair generator.\n */\npublic class RSAKeyPairGenerator\n    implements AsymmetricCipherKeyPairGenerator\n{\n    private static final BigInteger ONE = BigInteger.valueOf(1);\n\n    private RSAKeyGenerationParameters param;\n\n    public void init(KeyGenerationParameters param)\n    {\n        this.param = (RSAKeyGenerationParameters)param;\n    }\n\n    public AsymmetricCipherKeyPair generateKeyPair()\n    {\n        AsymmetricCipherKeyPair result = null;\n        boolean done = false;\n\n        //\n        // p and q values should have a length of half the strength in bits\n        //\n        int strength = param.getStrength();\n        int pbitlength = (strength + 1) / 2;\n        int qbitlength = strength - pbitlength;\n        int mindiffbits = (strength / 2) - 100;\n\n        if (mindiffbits < strength / 3)\n        {\n            mindiffbits = strength / 3;\n        }\n\n        int minWeight = strength >> 2;\n\n        // d lower bound is 2^(strength / 2)\n        BigInteger dLowerBound = BigInteger.valueOf(2).pow(strength / 2);\n        // squared bound (sqrt(2)*2^(nlen/2-1))^2\n        BigInteger squaredBound = ONE.shiftLeft(strength - 1);\n        // 2^(nlen/2 - 100)\n        BigInteger minDiff = ONE.shiftLeft(mindiffbits);\n\n        while (!done)\n        {\n            BigInteger p, q, n, d, e, pSub1, qSub1, gcd, lcm;\n\n            e = param.getPublicExponent();\n\n            p = chooseRandomPrime(pbitlength, e, squaredBound);\n\n            //\n            // generate a modulus of the required length\n            //\n            for (; ; )\n            {\n                q = chooseRandomPrime(qbitlength, e, squaredBound);\n\n                // p and q should not be too close together (or equal!)\n                BigInteger diff = q.subtract(p).abs();\n                if (diff.bitLength() < mindiffbits || diff.compareTo(minDiff) <= 0)\n                {\n                    continue;\n                }\n\n                //\n                // calculate the modulus\n                //\n                n = p.multiply(q);\n\n                if (n.bitLength() != strength)\n                {\n                    //\n                    // if we get here our primes aren't big enough, make the largest\n                    // of the two p and try again\n                    //\n                    p = p.max(q);\n                    continue;\n                }\n\n\t            /*\n                 * Require a minimum weight of the NAF representation, since low-weight composites may\n\t             * be weak against a version of the number-field-sieve for factoring.\n\t             *\n\t             * See \"The number field sieve for integers of low weight\", Oliver Schirokauer.\n\t             */\n                if (WNafUtil.getNafWeight(n) < minWeight)\n                {\n                    p = chooseRandomPrime(pbitlength, e, squaredBound);\n                    continue;\n                }\n\n                break;\n            }\n\n            if (p.compareTo(q) < 0)\n            {\n                gcd = p;\n                p = q;\n                q = gcd;\n            }\n\n            pSub1 = p.subtract(ONE);\n            qSub1 = q.subtract(ONE);\n            gcd = pSub1.gcd(qSub1);\n            lcm = pSub1.divide(gcd).multiply(qSub1);\n\n            //\n            // calculate the private exponent\n            //\n            d = e.modInverse(lcm);\n\n            if (d.compareTo(dLowerBound) <= 0)\n            {\n                continue;\n            }\n            else\n            {\n                done = true;\n            }\n\n            //\n            // calculate the CRT factors\n            //\n            BigInteger dP, dQ, qInv;\n\n            dP = d.remainder(pSub1);\n            dQ = d.remainder(qSub1);\n            qInv = q.modInverse(p);\n\n            result = new AsymmetricCipherKeyPair(\n                new RSAKeyParameters(false, n, e),\n                new RSAPrivateCrtKeyParameters(n, e, d, p, q, dP, dQ, qInv));\n        }\n\n        return result;\n    }\n\n    /**\n     * Choose a random prime value for use with RSA\n     *\n     * @param bitlength the bit-length of the returned prime\n     * @param e         the RSA public exponent\n     * @return A prime p, with (p-1) relatively prime to e\n     */\n    protected BigInteger chooseRandomPrime(int bitlength, BigInteger e, BigInteger sqrdBound)\n    {\n        int iterations = getNumberOfIterations(bitlength, param.getCertainty());\n\n        for (int i = 0; i != 5 * bitlength; i++)\n        {\n            BigInteger p = new BigInteger(bitlength, 1, param.getRandom());\n\n            if (p.mod(e).equals(ONE))\n            {\n                continue;\n            }\n\n            if (p.multiply(p).compareTo(sqrdBound) < 0)\n            {\n                continue;\n            }\n\n            if (!isProbablePrime(p, iterations))\n            {\n                continue;\n            }\n\n            if (!e.gcd(p.subtract(ONE)).equals(ONE))\n            {\n                continue;\n            }\n\n            return p;\n        }\n\n        throw new IllegalStateException(\"unable to generate prime number for RSA key\");\n    }\n\n    protected boolean isProbablePrime(BigInteger x, int iterations)\n    {\n        /*\n         * Primes class for FIPS 186-4 C.3 primality checking\n         */\n        return !Primes.hasAnySmallFactors(x) && Primes.isMRProbablePrime(x, param.getRandom(), iterations);\n    }\n\n    private static int getNumberOfIterations(int bits, int certainty)\n    {\n        /*\n         * NOTE: We enforce a minimum 'certainty' of 100 for bits >= 1024 (else 80). Where the\n         * certainty is higher than the FIPS 186-4 tables (C.2/C.3) cater to, extra iterations\n         * are added at the \"worst case rate\" for the excess.\n         */\n        if (bits >= 1536)\n        {\n            return  certainty <= 100 ? 3\n                :   certainty <= 128 ? 4\n                :   4 + (certainty - 128 + 1) / 2;\n        }\n        else if (bits >= 1024)\n        {\n            return  certainty <= 100 ? 4\n                :   certainty <= 112 ? 5\n                :   5 + (certainty - 112 + 1) / 2;\n        }\n        else if (bits >= 512)\n        {\n            return  certainty <= 80  ? 5\n                :   certainty <= 100 ? 7\n                :   7 + (certainty - 100 + 1) / 2;\n        }\n        else\n        {\n            return  certainty <= 80  ? 40\n                :   40 + (certainty - 80 + 1) / 2;\n        }\n    }\n}\n"], "fixing_code": ["package org.bouncycastle.crypto.generators;\n\nimport java.math.BigInteger;\n\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPair;\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator;\nimport org.bouncycastle.crypto.KeyGenerationParameters;\nimport org.bouncycastle.crypto.params.RSAKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.RSAKeyParameters;\nimport org.bouncycastle.crypto.params.RSAPrivateCrtKeyParameters;\nimport org.bouncycastle.math.Primes;\nimport org.bouncycastle.math.ec.WNafUtil;\n\n/**\n * an RSA key pair generator.\n */\npublic class RSAKeyPairGenerator\n    implements AsymmetricCipherKeyPairGenerator\n{\n    private static final BigInteger ONE = BigInteger.valueOf(1);\n\n    private RSAKeyGenerationParameters param;\n\n    public void init(KeyGenerationParameters param)\n    {\n        this.param = (RSAKeyGenerationParameters)param;\n    }\n\n    public AsymmetricCipherKeyPair generateKeyPair()\n    {\n        AsymmetricCipherKeyPair result = null;\n        boolean done = false;\n\n        //\n        // p and q values should have a length of half the strength in bits\n        //\n        int strength = param.getStrength();\n        int pbitlength = (strength + 1) / 2;\n        int qbitlength = strength - pbitlength;\n        int mindiffbits = (strength / 2) - 100;\n\n        if (mindiffbits < strength / 3)\n        {\n            mindiffbits = strength / 3;\n        }\n\n        int minWeight = strength >> 2;\n\n        // d lower bound is 2^(strength / 2)\n        BigInteger dLowerBound = BigInteger.valueOf(2).pow(strength / 2);\n        // squared bound (sqrt(2)*2^(nlen/2-1))^2\n        BigInteger squaredBound = ONE.shiftLeft(strength - 1);\n        // 2^(nlen/2 - 100)\n        BigInteger minDiff = ONE.shiftLeft(mindiffbits);\n\n        while (!done)\n        {\n            BigInteger p, q, n, d, e, pSub1, qSub1, gcd, lcm;\n\n            e = param.getPublicExponent();\n\n            p = chooseRandomPrime(pbitlength, e, squaredBound);\n\n            //\n            // generate a modulus of the required length\n            //\n            for (; ; )\n            {\n                q = chooseRandomPrime(qbitlength, e, squaredBound);\n\n                // p and q should not be too close together (or equal!)\n                BigInteger diff = q.subtract(p).abs();\n                if (diff.bitLength() < mindiffbits || diff.compareTo(minDiff) <= 0)\n                {\n                    continue;\n                }\n\n                //\n                // calculate the modulus\n                //\n                n = p.multiply(q);\n\n                if (n.bitLength() != strength)\n                {\n                    //\n                    // if we get here our primes aren't big enough, make the largest\n                    // of the two p and try again\n                    //\n                    p = p.max(q);\n                    continue;\n                }\n\n\t            /*\n                 * Require a minimum weight of the NAF representation, since low-weight composites may\n\t             * be weak against a version of the number-field-sieve for factoring.\n\t             *\n\t             * See \"The number field sieve for integers of low weight\", Oliver Schirokauer.\n\t             */\n                if (WNafUtil.getNafWeight(n) < minWeight)\n                {\n                    p = chooseRandomPrime(pbitlength, e, squaredBound);\n                    continue;\n                }\n\n                break;\n            }\n\n            if (p.compareTo(q) < 0)\n            {\n                gcd = p;\n                p = q;\n                q = gcd;\n            }\n\n            pSub1 = p.subtract(ONE);\n            qSub1 = q.subtract(ONE);\n            gcd = pSub1.gcd(qSub1);\n            lcm = pSub1.divide(gcd).multiply(qSub1);\n\n            //\n            // calculate the private exponent\n            //\n            d = e.modInverse(lcm);\n\n            if (d.compareTo(dLowerBound) <= 0)\n            {\n                continue;\n            }\n            else\n            {\n                done = true;\n            }\n\n            //\n            // calculate the CRT factors\n            //\n            BigInteger dP, dQ, qInv;\n\n            dP = d.remainder(pSub1);\n            dQ = d.remainder(qSub1);\n            qInv = q.modInverse(p);\n\n            result = new AsymmetricCipherKeyPair(\n                new RSAKeyParameters(false, n, e),\n                new RSAPrivateCrtKeyParameters(n, e, d, p, q, dP, dQ, qInv));\n        }\n\n        return result;\n    }\n\n    /**\n     * Choose a random prime value for use with RSA\n     *\n     * @param bitlength the bit-length of the returned prime\n     * @param e         the RSA public exponent\n     * @return A prime p, with (p-1) relatively prime to e\n     */\n    protected BigInteger chooseRandomPrime(int bitlength, BigInteger e, BigInteger sqrdBound)\n    {\n        for (int i = 0; i != 5 * bitlength; i++)\n        {\n            BigInteger p = new BigInteger(bitlength, 1, param.getRandom());\n\n            if (p.mod(e).equals(ONE))\n            {\n                continue;\n            }\n\n            if (p.multiply(p).compareTo(sqrdBound) < 0)\n            {\n                continue;\n            }\n\n            if (!isProbablePrime(p))\n            {\n                continue;\n            }\n\n            if (!e.gcd(p.subtract(ONE)).equals(ONE))\n            {\n                continue;\n            }\n\n            return p;\n        }\n\n        throw new IllegalStateException(\"unable to generate prime number for RSA key\");\n    }\n\n    protected boolean isProbablePrime(BigInteger x)\n    {\n        int iterations = getNumberOfIterations(x.bitLength(), param.getCertainty());\n\n        /*\n         * Primes class for FIPS 186-4 C.3 primality checking\n         */\n        return !Primes.hasAnySmallFactors(x) && Primes.isMRProbablePrime(x, param.getRandom(), iterations);\n    }\n\n    private static int getNumberOfIterations(int bits, int certainty)\n    {\n        /*\n         * NOTE: We enforce a minimum 'certainty' of 100 for bits >= 1024 (else 80). Where the\n         * certainty is higher than the FIPS 186-4 tables (C.2/C.3) cater to, extra iterations\n         * are added at the \"worst case rate\" for the excess.\n         */\n        if (bits >= 1536)\n        {\n            return  certainty <= 100 ? 3\n                :   certainty <= 128 ? 4\n                :   4 + (certainty - 128 + 1) / 2;\n        }\n        else if (bits >= 1024)\n        {\n            return  certainty <= 100 ? 4\n                :   certainty <= 112 ? 5\n                :   5 + (certainty - 112 + 1) / 2;\n        }\n        else if (bits >= 512)\n        {\n            return  certainty <= 80  ? 5\n                :   certainty <= 100 ? 7\n                :   7 + (certainty - 100 + 1) / 2;\n        }\n        else\n        {\n            return  certainty <= 80  ? 40\n                :   40 + (certainty - 80 + 1) / 2;\n        }\n    }\n}\n"], "filenames": ["core/src/main/java/org/bouncycastle/crypto/generators/RSAKeyPairGenerator.java"], "buggy_code_start_loc": [160], "buggy_code_end_loc": [194], "fixing_code_start_loc": [159], "fixing_code_end_loc": [194], "type": "CWE-327", "message": "Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later.", "other": {"cve": {"id": "CVE-2018-1000180", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-05T13:29:00.203", "lastModified": "2021-06-14T18:15:11.593", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later."}, {"lang": "es", "value": "Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 y anteriores tiene un vulnerabilidad en la interfaz de bajo nivel del generador de claves RSA; espec\u00edficamente, los pares de claves RSA generados en la API de bajo nivel con un valor certainty a\u00f1adido pueden tener menos tests M-R de lo esperado. Parece que se ha resuelto en versiones BC 1.60 beta 4 y posteriores y BC-FJA 1.0.2 y posteriores."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-327"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bouncycastle:fips_java_api:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.1", "matchCriteriaId": "ADE442C0-3BFD-41E2-B89B-57C5D77AAF01"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bouncycastle:legion-of-the-bouncy-castle-java-crytography-api:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.54", "versionEndIncluding": "1.59", "matchCriteriaId": "3787A4A3-DAB1-4ED8-834C-4E2598062877"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:api_gateway:11.1.2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "A5553591-073B-45E3-999F-21B8BA2EEE22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:business_process_management_suite:11.1.1.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "013043A2-0765-4AF5-ABFC-6A8960FFBFD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:business_process_management_suite:12.1.3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "B887E174-57AB-449D-AEE4-82DD1A3E5C84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:business_process_management_suite:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "E869C417-C0E6-4FC3-B406-45598A1D1906"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:business_transaction_management:12.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "FD9D7511-2934-4974-9C9E-3BE03B846734"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_application_session_controller:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "CC967A48-D834-4E9B-8CEC-057E7D5B8174"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_application_session_controller:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F920CDE4-DF29-4611-93E9-A386C89EDB62"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_converged_application_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.0.0.1", "matchCriteriaId": "EC361999-AAD8-4CB3-B00E-E3990C3529B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_webrtc_session_controller:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.2", "matchCriteriaId": "77120A3C-9A48-45FC-A620-5072AF325ACF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_repository:12.1.3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "F9E13DD9-F456-4802-84AD-A2A1F12FE999"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:managed_file_transfer:12.1.3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "AEB446C9-1AC2-4D7D-83DE-08934DDFC8B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:managed_file_transfer:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "A2E3E923-E2AD-400D-A618-26ADF7F841A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.55:*:*:*:*:*:*:*", "matchCriteriaId": "45CB30A1-B2C9-4BF5-B510-1F2F18B60C64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.56:*:*:*:*:*:*:*", "matchCriteriaId": "D0A735B4-4F3C-416B-8C08-9CB21BAD2889"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.57:*:*:*:*:*:*:*", "matchCriteriaId": "7E1E416B-920B-49A0-9523-382898C2979D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_convenience_and_fuel_pos_software:2.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "78DE9DFD-BB57-4BCF-BF73-FFCFF62420D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_xstore_point_of_service:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F87FC90-16D0-4051-8280-B0DD4441F10B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_xstore_point_of_service:7.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0ED83E3-E6BF-4EAA-AF8F-33485A88A218"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:soa_suite:12.1.3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "AF4C318C-5D1E-479B-9597-9FAD9E186111"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:soa_suite:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "65994DC4-C9C0-48B0-88AB-E2958B4EB9E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:webcenter_portal:11.1.1.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "D7756147-7168-4E03-93EE-31379F6BE88E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:webcenter_portal:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "D6A4F71A-4269-40FC-8F61-1D1301F2B728"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:weblogic_server:12.1.3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "C93CC705-1F8C-4870-99E6-14BF264C3811"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_workflow_automation:-:*:*:*:*:*:*:*", "matchCriteriaId": "5735E553-9731-4AAC-BCFF-989377F817B3"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:virtualization:4.2:*:*:*:*:*:*:*", "matchCriteriaId": "D53E13F7-469E-486C-8E86-69AA21091D23"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:jboss_enterprise_application_platform:7.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "868C0845-F25C-487F-A697-72917BE9D78E"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/106567", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2423", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2424", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2425", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2428", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2643", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2669", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0877", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/bcgit/bc-java/commit/22467b6e8fe19717ecdf201c0cf91bacf04a55ad", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bcgit/bc-java/commit/73780ac522b7795fc165630aba8d5f5729acc839", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bcgit/bc-java/wiki/CVE-2018-1000180", "source": "cve@mitre.org"}, {"url": "https://lists.apache.org/thread.html/708d94141126eac03011144a971a6411fcac16d9c248d1d535a39451@%3Csolr-user.lucene.apache.org%3E", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20190204-0003/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.bountysource.com/issues/58293083-rsa-key-generation-computation-of-iterations-for-mr-primality-test", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4233", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpuapr2020.html", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpuoct2020.html", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpuapr2019-5072813.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpujan2019-5072801.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpujul2019-5072835.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/bcgit/bc-java/commit/22467b6e8fe19717ecdf201c0cf91bacf04a55ad"}}