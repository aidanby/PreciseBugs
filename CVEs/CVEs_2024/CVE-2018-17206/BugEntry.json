{"buggy_code": ["/*\n * Copyright (c) 2008-2017 Nicira, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <config.h>\n#include <netinet/in.h>\n\n#include \"bundle.h\"\n#include \"byte-order.h\"\n#include \"colors.h\"\n#include \"compiler.h\"\n#include \"dummy.h\"\n#include \"openvswitch/hmap.h\"\n#include \"learn.h\"\n#include \"multipath.h\"\n#include \"nx-match.h\"\n#include \"odp-netlink.h\"\n#include \"openvswitch/dynamic-string.h\"\n#include \"openvswitch/meta-flow.h\"\n#include \"openvswitch/ofp-actions.h\"\n#include \"openvswitch/ofp-util.h\"\n#include \"openvswitch/ofp-parse.h\"\n#include \"openvswitch/ofp-prop.h\"\n#include \"openvswitch/ofpbuf.h\"\n#include \"openvswitch/vlog.h\"\n#include \"unaligned.h\"\n#include \"util.h\"\n#include \"vl-mff-map.h\"\n\nVLOG_DEFINE_THIS_MODULE(ofp_actions);\n\nstatic struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n\nstruct ofp_action_header;\n\n/* Header for Open vSwitch and ONF vendor extension actions.\n *\n * This is the entire header for a few Open vSwitch vendor extension actions,\n * the ones that either have no arguments or for which variable-length\n * arguments follow the header.\n *\n * This cannot be used as an entirely generic vendor extension action header,\n * because OpenFlow does not specify the location or size of the action\n * subtype; it just happens that ONF extensions and Nicira extensions share\n * this format. */\nstruct ext_action_header {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* At least 16. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID or ONF_VENDOR_ID. */\n    ovs_be16 subtype;               /* See enum ofp_raw_action_type. */\n    uint8_t pad[6];\n};\nOFP_ASSERT(sizeof(struct ext_action_header) == 16);\n\n/* Raw identifiers for OpenFlow actions.\n *\n * Decoding and encoding OpenFlow actions across multiple versions is difficult\n * to do in a clean, consistent way.  This enumeration lays out all of the\n * forms of actions that Open vSwitch supports.\n *\n * The comments here must follow a stylized form because the\n * \"extract-ofp-actions\" program parses them at build time to generate data\n * tables.\n *\n *   - The first part of each comment specifies the vendor, OpenFlow versions,\n *     and type for each protocol that supports the action:\n *\n *         # The vendor is OF for standard OpenFlow actions, NX for Nicira\n *           extension actions.  (Support for other vendors can be added, but\n *           it can't be done just based on a vendor ID definition alone\n *           because OpenFlow doesn't define a standard way to specify a\n *           subtype for vendor actions, so other vendors might do it different\n *           from Nicira.)\n *\n *         # The version can specify a specific OpenFlow version, a version\n *           range delimited by \"-\", or an open-ended range with \"+\".\n *\n *         # The type, in parentheses, is the action type number (for standard\n *           OpenFlow actions) or subtype (for vendor extension actions).\n *\n *         # Optionally one may add \"is deprecated\" followed by a\n *           human-readable reason in parentheses (which will be used in log\n *           messages), if a particular action should no longer be used.\n *\n *     Multiple such specifications may be separated by commas.\n *\n *   - The second part describes the action's wire format.  It may be:\n *\n *         # \"struct <name>\": The struct fully specifies the wire format.  The\n *           action is exactly the size of the struct.  (Thus, the struct must\n *           be an exact multiple of 8 bytes in size.)\n *\n *         # \"struct <name>, ...\": The struct specifies the beginning of the\n *           wire format.  An instance of the action is either the struct's\n *           exact size, or a multiple of 8 bytes longer.\n *\n *         # \"uint<N>_t\" or \"ovs_be<N>\": The action consists of a (standard or\n *           vendor extension) header, followed by 0 or more pad bytes to align\n *           to a multiple of <N> bits, followed by an argument of the given\n *           type, followed by 0 or more pad bytes to bring the total action up\n *           to a multiple of 8 bytes.\n *\n *         # \"void\": The action is just a (standard or vendor extension)\n *           header.\n *\n *         # Optionally, one may add \"VLMFF\" in the end of the second part if\n *           the Openflow action may use a variable length meta-flow field\n *           (i.e. tun_metadata). Adding \"VLMFF\" will pass the per-switch based\n *           variable length meta-flow field mapping map (struct vl_mff_map) to\n *           the corresponding action decoding function.\n *\n *   - Optional additional text enclosed in square brackets is commentary for\n *     the human reader.\n */\nenum ofp_raw_action_type {\n/* ## ----------------- ## */\n/* ## Standard actions. ## */\n/* ## ----------------- ## */\n\n    /* OF1.0(0): struct ofp10_action_output. */\n    OFPAT_RAW10_OUTPUT,\n    /* OF1.1+(0): struct ofp11_action_output. */\n    OFPAT_RAW11_OUTPUT,\n\n    /* OF1.0(1): uint16_t. */\n    OFPAT_RAW10_SET_VLAN_VID,\n    /* OF1.0(2): uint8_t. */\n    OFPAT_RAW10_SET_VLAN_PCP,\n\n    /* OF1.1(1), OF1.2+(1) is deprecated (use Set-Field): uint16_t.\n     *\n     * [Semantics differ slightly between the 1.0 and 1.1 versions of the VLAN\n     * modification actions: the 1.0 versions push a VLAN header if none is\n     * present, but the 1.1 versions do not.  That is the only reason that we\n     * distinguish their raw action types.] */\n    OFPAT_RAW11_SET_VLAN_VID,\n    /* OF1.1(2), OF1.2+(2) is deprecated (use Set-Field): uint8_t. */\n    OFPAT_RAW11_SET_VLAN_PCP,\n\n    /* OF1.1+(17): ovs_be16.\n     *\n     * [The argument is the Ethertype, e.g. ETH_TYPE_VLAN_8021Q, not the VID or\n     * TCI.] */\n    OFPAT_RAW11_PUSH_VLAN,\n\n    /* OF1.0(3): void. */\n    OFPAT_RAW10_STRIP_VLAN,\n    /* OF1.1+(18): void. */\n    OFPAT_RAW11_POP_VLAN,\n\n    /* OF1.0(4), OF1.1(3), OF1.2+(3) is deprecated (use Set-Field): struct\n     * ofp_action_dl_addr. */\n    OFPAT_RAW_SET_DL_SRC,\n\n    /* OF1.0(5), OF1.1(4), OF1.2+(4) is deprecated (use Set-Field): struct\n     * ofp_action_dl_addr. */\n    OFPAT_RAW_SET_DL_DST,\n\n    /* OF1.0(6), OF1.1(5), OF1.2+(5) is deprecated (use Set-Field):\n     * ovs_be32. */\n    OFPAT_RAW_SET_NW_SRC,\n\n    /* OF1.0(7), OF1.1(6), OF1.2+(6) is deprecated (use Set-Field):\n     * ovs_be32. */\n    OFPAT_RAW_SET_NW_DST,\n\n    /* OF1.0(8), OF1.1(7), OF1.2+(7) is deprecated (use Set-Field): uint8_t. */\n    OFPAT_RAW_SET_NW_TOS,\n\n    /* OF1.1(8), OF1.2+(8) is deprecated (use Set-Field): uint8_t. */\n    OFPAT_RAW11_SET_NW_ECN,\n\n    /* OF1.0(9), OF1.1(9), OF1.2+(9) is deprecated (use Set-Field):\n     * ovs_be16. */\n    OFPAT_RAW_SET_TP_SRC,\n\n    /* OF1.0(10), OF1.1(10), OF1.2+(10) is deprecated (use Set-Field):\n     * ovs_be16. */\n    OFPAT_RAW_SET_TP_DST,\n\n    /* OF1.0(11): struct ofp10_action_enqueue. */\n    OFPAT_RAW10_ENQUEUE,\n\n    /* NX1.0(30), OF1.1(13), OF1.2+(13) is deprecated (use Set-Field):\n     * ovs_be32. */\n    OFPAT_RAW_SET_MPLS_LABEL,\n\n    /* NX1.0(31), OF1.1(14), OF1.2+(14) is deprecated (use Set-Field):\n     * uint8_t. */\n    OFPAT_RAW_SET_MPLS_TC,\n\n    /* NX1.0(25), OF1.1(15), OF1.2+(15) is deprecated (use Set-Field):\n     * uint8_t. */\n    OFPAT_RAW_SET_MPLS_TTL,\n\n    /* NX1.0(26), OF1.1+(16): void. */\n    OFPAT_RAW_DEC_MPLS_TTL,\n\n    /* NX1.0(23), OF1.1+(19): ovs_be16.\n     *\n     * [The argument is the Ethertype, e.g. ETH_TYPE_MPLS, not the label.] */\n    OFPAT_RAW_PUSH_MPLS,\n\n    /* NX1.0(24), OF1.1+(20): ovs_be16.\n     *\n     * [The argument is the Ethertype, e.g. ETH_TYPE_IPV4 if at BoS or\n     * ETH_TYPE_MPLS otherwise, not the label.] */\n    OFPAT_RAW_POP_MPLS,\n\n    /* NX1.0(4), OF1.1+(21): uint32_t. */\n    OFPAT_RAW_SET_QUEUE,\n\n    /* NX1.0(40), OF1.1+(22): uint32_t. */\n    OFPAT_RAW_GROUP,\n\n    /* OF1.1+(23): uint8_t. */\n    OFPAT_RAW11_SET_NW_TTL,\n\n    /* NX1.0(18), OF1.1+(24): void. */\n    OFPAT_RAW_DEC_NW_TTL,\n    /* NX1.0+(21): struct nx_action_cnt_ids, ... */\n    NXAST_RAW_DEC_TTL_CNT_IDS,\n\n    /* OF1.2-1.4(25): struct ofp12_action_set_field, ... VLMFF */\n    OFPAT_RAW12_SET_FIELD,\n    /* OF1.5+(25): struct ofp12_action_set_field, ... VLMFF */\n    OFPAT_RAW15_SET_FIELD,\n    /* NX1.0-1.4(7): struct nx_action_reg_load. VLMFF\n     *\n     * [In OpenFlow 1.5, set_field is a superset of reg_load functionality, so\n     * we drop reg_load.] */\n    NXAST_RAW_REG_LOAD,\n    /* NX1.0-1.4(33): struct ext_action_header, ... VLMFF\n     *\n     * [In OpenFlow 1.5, set_field is a superset of reg_load2 functionality, so\n     * we drop reg_load2.] */\n    NXAST_RAW_REG_LOAD2,\n\n    /* OF1.5+(28): struct ofp15_action_copy_field, ... VLMFF */\n    OFPAT_RAW15_COPY_FIELD,\n    /* ONF1.3-1.4(3200): struct onf_action_copy_field, ... VLMFF */\n    ONFACT_RAW13_COPY_FIELD,\n    /* NX1.0-1.4(6): struct nx_action_reg_move, ... VLMFF */\n    NXAST_RAW_REG_MOVE,\n\n/* ## ------------------------- ## */\n/* ## Nicira extension actions. ## */\n/* ## ------------------------- ## */\n\n/* Actions similar to standard actions are listed with the standard actions. */\n\n    /* NX1.0+(1): uint16_t. */\n    NXAST_RAW_RESUBMIT,\n    /* NX1.0+(14): struct nx_action_resubmit. */\n    NXAST_RAW_RESUBMIT_TABLE,\n\n    /* NX1.0+(2): uint32_t. */\n    NXAST_RAW_SET_TUNNEL,\n    /* NX1.0+(9): uint64_t. */\n    NXAST_RAW_SET_TUNNEL64,\n\n    /* NX1.0+(5): void. */\n    NXAST_RAW_POP_QUEUE,\n\n    /* NX1.0+(8): struct nx_action_note, ... */\n    NXAST_RAW_NOTE,\n\n    /* NX1.0+(10): struct nx_action_multipath. VLMFF */\n    NXAST_RAW_MULTIPATH,\n\n    /* NX1.0+(12): struct nx_action_bundle, ... */\n    NXAST_RAW_BUNDLE,\n    /* NX1.0+(13): struct nx_action_bundle, ... VLMFF */\n    NXAST_RAW_BUNDLE_LOAD,\n\n    /* NX1.0+(15): struct nx_action_output_reg. VLMFF */\n    NXAST_RAW_OUTPUT_REG,\n    /* NX1.0+(32): struct nx_action_output_reg2. VLMFF */\n    NXAST_RAW_OUTPUT_REG2,\n\n    /* NX1.0+(16): struct nx_action_learn, ... VLMFF */\n    NXAST_RAW_LEARN,\n\n    /* NX1.0+(17): void. */\n    NXAST_RAW_EXIT,\n\n    /* NX1.0+(19): struct nx_action_fin_timeout. */\n    NXAST_RAW_FIN_TIMEOUT,\n\n    /* NX1.0+(20): struct nx_action_controller. */\n    NXAST_RAW_CONTROLLER,\n    /* NX1.0+(37): struct ext_action_header, ... */\n    NXAST_RAW_CONTROLLER2,\n\n    /* NX1.0+(22): struct nx_action_write_metadata. */\n    NXAST_RAW_WRITE_METADATA,\n\n    /* NX1.0+(27): struct nx_action_stack. VLMFF */\n    NXAST_RAW_STACK_PUSH,\n\n    /* NX1.0+(28): struct nx_action_stack. VLMFF */\n    NXAST_RAW_STACK_POP,\n\n    /* NX1.0+(29): struct nx_action_sample. */\n    NXAST_RAW_SAMPLE,\n    /* NX1.0+(38): struct nx_action_sample2. */\n    NXAST_RAW_SAMPLE2,\n    /* NX1.0+(41): struct nx_action_sample2. */\n    NXAST_RAW_SAMPLE3,\n\n    /* NX1.0+(34): struct nx_action_conjunction. */\n    NXAST_RAW_CONJUNCTION,\n\n    /* NX1.0+(35): struct nx_action_conntrack, ... VLMFF */\n    NXAST_RAW_CT,\n\n    /* NX1.0+(36): struct nx_action_nat, ... */\n    NXAST_RAW_NAT,\n\n    /* NX1.0+(39): struct nx_action_output_trunc. */\n    NXAST_RAW_OUTPUT_TRUNC,\n\n    /* NX1.0+(42): struct ext_action_header, ... VLMFF */\n    NXAST_RAW_CLONE,\n\n    /* NX1.0+(43): void. */\n    NXAST_RAW_CT_CLEAR,\n\n/* ## ------------------ ## */\n/* ## Debugging actions. ## */\n/* ## ------------------ ## */\n\n/* These are intentionally undocumented, subject to change, and ovs-vswitchd */\n/* accepts them only if started with --enable-dummy. */\n\n    /* NX1.0+(255): void. */\n    NXAST_RAW_DEBUG_RECIRC,\n};\n\n/* OpenFlow actions are always a multiple of 8 bytes in length. */\n#define OFP_ACTION_ALIGN 8\n\n/* Define a few functions for working with instructions. */\n#define DEFINE_INST(ENUM, STRUCT, EXTENSIBLE, NAME)             \\\n    static inline const struct STRUCT * OVS_UNUSED              \\\n    instruction_get_##ENUM(const struct ofp11_instruction *inst)\\\n    {                                                           \\\n        ovs_assert(inst->type == htons(ENUM));                  \\\n        return ALIGNED_CAST(struct STRUCT *, inst);             \\\n    }                                                           \\\n                                                                \\\n    static inline void OVS_UNUSED                               \\\n    instruction_init_##ENUM(struct STRUCT *s)                   \\\n    {                                                           \\\n        memset(s, 0, sizeof *s);                                \\\n        s->type = htons(ENUM);                                  \\\n        s->len = htons(sizeof *s);                              \\\n    }                                                           \\\n                                                                \\\n    static inline struct STRUCT * OVS_UNUSED                    \\\n    instruction_put_##ENUM(struct ofpbuf *buf)                  \\\n    {                                                           \\\n        struct STRUCT *s = ofpbuf_put_uninit(buf, sizeof *s);   \\\n        instruction_init_##ENUM(s);                             \\\n        return s;                                               \\\n    }\nOVS_INSTRUCTIONS\n#undef DEFINE_INST\n\nstatic void ofpacts_update_instruction_actions(struct ofpbuf *openflow,\n                                               size_t ofs);\nstatic void pad_ofpat(struct ofpbuf *openflow, size_t start_ofs);\n\nstatic enum ofperr ofpacts_verify(const struct ofpact[], size_t ofpacts_len,\n                                  uint32_t allowed_ovsinsts,\n                                  enum ofpact_type outer_action);\n\nstatic void put_set_field(struct ofpbuf *openflow, enum ofp_version,\n                          enum mf_field_id, uint64_t value);\n\nstatic void put_reg_load(struct ofpbuf *openflow,\n                         const struct mf_subfield *, uint64_t value);\n\nstatic enum ofperr ofpact_pull_raw(struct ofpbuf *, enum ofp_version,\n                                   enum ofp_raw_action_type *, uint64_t *arg);\nstatic void *ofpact_put_raw(struct ofpbuf *, enum ofp_version,\n                            enum ofp_raw_action_type, uint64_t arg);\n\nstatic char *OVS_WARN_UNUSED_RESULT ofpacts_parse(\n    char *str, struct ofpbuf *ofpacts, enum ofputil_protocol *usable_protocols,\n    bool allow_instructions, enum ofpact_type outer_action);\nstatic enum ofperr ofpacts_pull_openflow_actions__(\n    struct ofpbuf *openflow, unsigned int actions_len,\n    enum ofp_version version, uint32_t allowed_ovsinsts,\n    struct ofpbuf *ofpacts, enum ofpact_type outer_action,\n    const struct vl_mff_map *vl_mff_map, uint64_t *ofpacts_tlv_bitmap);\nstatic char * OVS_WARN_UNUSED_RESULT ofpacts_parse_copy(\n    const char *s_, struct ofpbuf *ofpacts,\n    enum ofputil_protocol *usable_protocols,\n    bool allow_instructions, enum ofpact_type outer_action);\n\n/* Returns the ofpact following 'ofpact', except that if 'ofpact' contains\n * nested ofpacts it returns the first one. */\nstruct ofpact *\nofpact_next_flattened(const struct ofpact *ofpact)\n{\n    switch (ofpact->type) {\n    case OFPACT_OUTPUT:\n    case OFPACT_GROUP:\n    case OFPACT_CONTROLLER:\n    case OFPACT_ENQUEUE:\n    case OFPACT_OUTPUT_REG:\n    case OFPACT_OUTPUT_TRUNC:\n    case OFPACT_BUNDLE:\n    case OFPACT_SET_FIELD:\n    case OFPACT_SET_VLAN_VID:\n    case OFPACT_SET_VLAN_PCP:\n    case OFPACT_STRIP_VLAN:\n    case OFPACT_PUSH_VLAN:\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_ETH_DST:\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_IPV4_DST:\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_L4_DST_PORT:\n    case OFPACT_REG_MOVE:\n    case OFPACT_STACK_PUSH:\n    case OFPACT_STACK_POP:\n    case OFPACT_DEC_TTL:\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_DEC_MPLS_TTL:\n    case OFPACT_PUSH_MPLS:\n    case OFPACT_POP_MPLS:\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_FIN_TIMEOUT:\n    case OFPACT_RESUBMIT:\n    case OFPACT_LEARN:\n    case OFPACT_CONJUNCTION:\n    case OFPACT_MULTIPATH:\n    case OFPACT_NOTE:\n    case OFPACT_EXIT:\n    case OFPACT_SAMPLE:\n    case OFPACT_UNROLL_XLATE:\n    case OFPACT_CT_CLEAR:\n    case OFPACT_DEBUG_RECIRC:\n    case OFPACT_METER:\n    case OFPACT_CLEAR_ACTIONS:\n    case OFPACT_WRITE_METADATA:\n    case OFPACT_GOTO_TABLE:\n    case OFPACT_NAT:\n        return ofpact_next(ofpact);\n\n    case OFPACT_CLONE:\n        return ofpact_get_CLONE(ofpact)->actions;\n\n    case OFPACT_CT:\n        return ofpact_get_CT(ofpact)->actions;\n\n    case OFPACT_WRITE_ACTIONS:\n        return ofpact_get_WRITE_ACTIONS(ofpact)->actions;\n    }\n\n    OVS_NOT_REACHED();\n}\n\n/* Pull off existing actions or instructions. Used by nesting actions to keep\n * ofpacts_parse() oblivious of actions nesting.\n *\n * Push the actions back on after nested parsing, e.g.:\n *\n *     size_t ofs = ofpacts_pull(ofpacts);\n *     ...nested parsing...\n *     ofpbuf_push_uninit(ofpacts, ofs);\n */\nstatic size_t\nofpacts_pull(struct ofpbuf *ofpacts)\n{\n    size_t ofs;\n\n    ofs = ofpacts->size;\n    ofpbuf_pull(ofpacts, ofs);\n\n    return ofs;\n}\n\n#include \"ofp-actions.inc1\"\n\f\n/* Output actions. */\n\n/* Action structure for OFPAT10_OUTPUT, which sends packets out 'port'.\n * When the 'port' is the OFPP_CONTROLLER, 'max_len' indicates the max\n * number of bytes to send.  A 'max_len' of zero means no bytes of the\n * packet should be sent. */\nstruct ofp10_action_output {\n    ovs_be16 type;                  /* OFPAT10_OUTPUT. */\n    ovs_be16 len;                   /* Length is 8. */\n    ovs_be16 port;                  /* Output port. */\n    ovs_be16 max_len;               /* Max length to send to controller. */\n};\nOFP_ASSERT(sizeof(struct ofp10_action_output) == 8);\n\n/* Action structure for OFPAT_OUTPUT, which sends packets out 'port'.\n   * When the 'port' is the OFPP_CONTROLLER, 'max_len' indicates the max\n   * number of bytes to send. A 'max_len' of zero means no bytes of the\n   * packet should be sent.*/\nstruct ofp11_action_output {\n    ovs_be16 type;                    /* OFPAT11_OUTPUT. */\n    ovs_be16 len;                     /* Length is 16. */\n    ovs_be32 port;                    /* Output port. */\n    ovs_be16 max_len;                 /* Max length to send to controller. */\n    uint8_t pad[6];                   /* Pad to 64 bits. */\n};\nOFP_ASSERT(sizeof(struct ofp11_action_output) == 16);\n\nstatic enum ofperr\ndecode_OFPAT_RAW10_OUTPUT(const struct ofp10_action_output *oao,\n                          enum ofp_version ofp_version OVS_UNUSED,\n                          struct ofpbuf *out)\n{\n    struct ofpact_output *output;\n\n    output = ofpact_put_OUTPUT(out);\n    output->port = u16_to_ofp(ntohs(oao->port));\n    output->max_len = ntohs(oao->max_len);\n\n    return ofpact_check_output_port(output->port, OFPP_MAX);\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_OUTPUT(const struct ofp11_action_output *oao,\n                          enum ofp_version ofp_version OVS_UNUSED,\n                          struct ofpbuf *out)\n{\n    struct ofpact_output *output;\n    enum ofperr error;\n\n    output = ofpact_put_OUTPUT(out);\n    output->max_len = ntohs(oao->max_len);\n\n    error = ofputil_port_from_ofp11(oao->port, &output->port);\n    if (error) {\n        return error;\n    }\n\n    return ofpact_check_output_port(output->port, OFPP_MAX);\n}\n\nstatic void\nencode_OUTPUT(const struct ofpact_output *output,\n              enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version == OFP10_VERSION) {\n        struct ofp10_action_output *oao;\n\n        oao = put_OFPAT10_OUTPUT(out);\n        oao->port = htons(ofp_to_u16(output->port));\n        oao->max_len = htons(output->max_len);\n    } else {\n        struct ofp11_action_output *oao;\n\n        oao = put_OFPAT11_OUTPUT(out);\n        oao->port = ofputil_port_to_ofp11(output->port);\n        oao->max_len = htons(output->max_len);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_truncate_subfield(struct ofpact_output_trunc *output_trunc,\n                        const char *arg_)\n{\n    char *key, *value;\n    char *arg = CONST_CAST(char *, arg_);\n\n    while (ofputil_parse_key_value(&arg, &key, &value)) {\n        if (!strcmp(key, \"port\")) {\n            if (!ofputil_port_from_string(value, &output_trunc->port)) {\n                return xasprintf(\"output to unknown truncate port: %s\",\n                                  value);\n            }\n            if (ofp_to_u16(output_trunc->port) > ofp_to_u16(OFPP_MAX)) {\n                if (output_trunc->port != OFPP_LOCAL &&\n                    output_trunc->port != OFPP_IN_PORT)\n                return xasprintf(\"output to unsupported truncate port: %s\",\n                                 value);\n            }\n        } else if (!strcmp(key, \"max_len\")) {\n            char *err;\n\n            err = str_to_u32(value, &output_trunc->max_len);\n            if (err) {\n                return err;\n            }\n        } else {\n            return xasprintf(\"invalid key '%s' in output_trunc argument\",\n                                key);\n        }\n    }\n    return NULL;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_OUTPUT(const char *arg, struct ofpbuf *ofpacts,\n             enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    if (strstr(arg, \"port\") && strstr(arg, \"max_len\")) {\n        struct ofpact_output_trunc *output_trunc;\n\n        output_trunc = ofpact_put_OUTPUT_TRUNC(ofpacts);\n        return parse_truncate_subfield(output_trunc, arg);\n    }\n\n    ofp_port_t port;\n    if (ofputil_port_from_string(arg, &port)) {\n        struct ofpact_output *output = ofpact_put_OUTPUT(ofpacts);\n        output->port = port;\n        output->max_len = output->port == OFPP_CONTROLLER ? UINT16_MAX : 0;\n        return NULL;\n    }\n\n    struct mf_subfield src;\n    char *error = mf_parse_subfield(&src, arg);\n    if (!error) {\n        struct ofpact_output_reg *output_reg;\n\n        output_reg = ofpact_put_OUTPUT_REG(ofpacts);\n        output_reg->max_len = UINT16_MAX;\n        output_reg->src = src;\n        return NULL;\n    }\n    free(error);\n\n    return xasprintf(\"%s: output to unknown port\", arg);\n}\n\nstatic void\nformat_OUTPUT(const struct ofpact_output *a, struct ds *s)\n{\n    if (ofp_to_u16(a->port) < ofp_to_u16(OFPP_MAX)) {\n        ds_put_format(s, \"%soutput:%s%\"PRIu32,\n                      colors.special, colors.end, a->port);\n    } else {\n        ofputil_format_port(a->port, s);\n        if (a->port == OFPP_CONTROLLER) {\n            ds_put_format(s, \":%\"PRIu16, a->max_len);\n        }\n    }\n}\n\f\n/* Group actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_GROUP(uint32_t group_id,\n                         enum ofp_version ofp_version OVS_UNUSED,\n                         struct ofpbuf *out)\n{\n    ofpact_put_GROUP(out)->group_id = group_id;\n    return 0;\n}\n\nstatic void\nencode_GROUP(const struct ofpact_group *group,\n             enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    put_OFPAT_GROUP(out, ofp_version, group->group_id);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_GROUP(char *arg, struct ofpbuf *ofpacts,\n                    enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_u32(arg, &ofpact_put_GROUP(ofpacts)->group_id);\n}\n\nstatic void\nformat_GROUP(const struct ofpact_group *a, struct ds *s)\n{\n    ds_put_format(s, \"%sgroup:%s%\"PRIu32,\n                  colors.special, colors.end, a->group_id);\n}\n\f\n/* Action structure for NXAST_CONTROLLER.\n *\n * This generalizes using OFPAT_OUTPUT to send a packet to OFPP_CONTROLLER.  In\n * addition to the 'max_len' that OFPAT_OUTPUT supports, it also allows\n * specifying:\n *\n *    - 'reason': The reason code to use in the ofp_packet_in or nx_packet_in.\n *\n *    - 'controller_id': The ID of the controller connection to which the\n *      ofp_packet_in should be sent.  The ofp_packet_in or nx_packet_in is\n *      sent only to controllers that have the specified controller connection\n *      ID.  See \"struct nx_controller_id\" for more information. */\nstruct nx_action_controller {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 16. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_CONTROLLER. */\n    ovs_be16 max_len;               /* Maximum length to send to controller. */\n    ovs_be16 controller_id;         /* Controller ID to send packet-in. */\n    uint8_t reason;                 /* enum ofp_packet_in_reason (OFPR_*). */\n    uint8_t zero;                   /* Must be zero. */\n};\nOFP_ASSERT(sizeof(struct nx_action_controller) == 16);\n\n/* Properties for NXAST_CONTROLLER2.\n *\n * For more information on the effect of NXAC2PT_PAUSE, see the large comment\n * on NXT_PACKET_IN2 in nicira-ext.h */\nenum nx_action_controller2_prop_type {\n    NXAC2PT_MAX_LEN,            /* ovs_be16 max bytes to send (default all). */\n    NXAC2PT_CONTROLLER_ID,      /* ovs_be16 dest controller ID (default 0). */\n    NXAC2PT_REASON,             /* uint8_t reason (OFPR_*), default 0. */\n    NXAC2PT_USERDATA,           /* Data to copy into NXPINT_USERDATA. */\n    NXAC2PT_PAUSE,              /* Flag to pause pipeline to resume later. */\n};\n\n/* The action structure for NXAST_CONTROLLER2 is \"struct ext_action_header\",\n * followed by NXAC2PT_* properties. */\n\nstatic enum ofperr\ndecode_NXAST_RAW_CONTROLLER(const struct nx_action_controller *nac,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    struct ofpact_controller *oc;\n\n    oc = ofpact_put_CONTROLLER(out);\n    oc->ofpact.raw = NXAST_RAW_CONTROLLER;\n    oc->max_len = ntohs(nac->max_len);\n    oc->controller_id = ntohs(nac->controller_id);\n    oc->reason = nac->reason;\n    ofpact_finish_CONTROLLER(out, &oc);\n\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_CONTROLLER2(const struct ext_action_header *eah,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             struct ofpbuf *out)\n{\n    if (!is_all_zeros(eah->pad, sizeof eah->pad)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    size_t start_ofs = out->size;\n    struct ofpact_controller *oc = ofpact_put_CONTROLLER(out);\n    oc->ofpact.raw = NXAST_RAW_CONTROLLER2;\n    oc->max_len = UINT16_MAX;\n    oc->reason = OFPR_ACTION;\n\n    struct ofpbuf properties;\n    ofpbuf_use_const(&properties, eah, ntohs(eah->len));\n    ofpbuf_pull(&properties, sizeof *eah);\n\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        uint64_t type;\n\n        enum ofperr error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch (type) {\n        case NXAC2PT_MAX_LEN:\n            error = ofpprop_parse_u16(&payload, &oc->max_len);\n            break;\n\n        case NXAC2PT_CONTROLLER_ID:\n            error = ofpprop_parse_u16(&payload, &oc->controller_id);\n            break;\n\n        case NXAC2PT_REASON: {\n            uint8_t u8;\n            error = ofpprop_parse_u8(&payload, &u8);\n            oc->reason = u8;\n            break;\n        }\n\n        case NXAC2PT_USERDATA:\n            out->size = start_ofs + OFPACT_CONTROLLER_SIZE;\n            ofpbuf_put(out, payload.msg, ofpbuf_msgsize(&payload));\n            oc = ofpbuf_at_assert(out, start_ofs, sizeof *oc);\n            oc->userdata_len = ofpbuf_msgsize(&payload);\n            break;\n\n        case NXAC2PT_PAUSE:\n            oc->pause = true;\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(false, \"NXAST_RAW_CONTROLLER2\", type);\n            break;\n        }\n        if (error) {\n            return error;\n        }\n    }\n\n    ofpact_finish_CONTROLLER(out, &oc);\n\n    return 0;\n}\n\nstatic void\nencode_CONTROLLER(const struct ofpact_controller *controller,\n                  enum ofp_version ofp_version OVS_UNUSED,\n                  struct ofpbuf *out)\n{\n    if (controller->userdata_len\n        || controller->pause\n        || controller->ofpact.raw == NXAST_RAW_CONTROLLER2) {\n        size_t start_ofs = out->size;\n        put_NXAST_CONTROLLER2(out);\n        if (controller->max_len != UINT16_MAX) {\n            ofpprop_put_u16(out, NXAC2PT_MAX_LEN, controller->max_len);\n        }\n        if (controller->controller_id != 0) {\n            ofpprop_put_u16(out, NXAC2PT_CONTROLLER_ID,\n                            controller->controller_id);\n        }\n        if (controller->reason != OFPR_ACTION) {\n            ofpprop_put_u8(out, NXAC2PT_REASON, controller->reason);\n        }\n        if (controller->userdata_len != 0) {\n            ofpprop_put(out, NXAC2PT_USERDATA, controller->userdata,\n                        controller->userdata_len);\n        }\n        if (controller->pause) {\n            ofpprop_put_flag(out, NXAC2PT_PAUSE);\n        }\n        pad_ofpat(out, start_ofs);\n    } else {\n        struct nx_action_controller *nac;\n\n        nac = put_NXAST_CONTROLLER(out);\n        nac->max_len = htons(controller->max_len);\n        nac->controller_id = htons(controller->controller_id);\n        nac->reason = controller->reason;\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_CONTROLLER(char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    enum ofp_packet_in_reason reason = OFPR_ACTION;\n    uint16_t controller_id = 0;\n    uint16_t max_len = UINT16_MAX;\n    const char *userdata = NULL;\n    bool pause = false;\n\n    if (!arg[0]) {\n        /* Use defaults. */\n    } else if (strspn(arg, \"0123456789\") == strlen(arg)) {\n        char *error = str_to_u16(arg, \"max_len\", &max_len);\n        if (error) {\n            return error;\n        }\n    } else {\n        char *name, *value;\n\n        while (ofputil_parse_key_value(&arg, &name, &value)) {\n            if (!strcmp(name, \"reason\")) {\n                if (!ofputil_packet_in_reason_from_string(value, &reason)) {\n                    return xasprintf(\"unknown reason \\\"%s\\\"\", value);\n                }\n            } else if (!strcmp(name, \"max_len\")) {\n                char *error = str_to_u16(value, \"max_len\", &max_len);\n                if (error) {\n                    return error;\n                }\n            } else if (!strcmp(name, \"id\")) {\n                char *error = str_to_u16(value, \"id\", &controller_id);\n                if (error) {\n                    return error;\n                }\n            } else if (!strcmp(name, \"userdata\")) {\n                userdata = value;\n            } else if (!strcmp(name, \"pause\")) {\n                pause = true;\n            } else {\n                return xasprintf(\"unknown key \\\"%s\\\" parsing controller \"\n                                 \"action\", name);\n            }\n        }\n    }\n\n    if (reason == OFPR_ACTION && controller_id == 0 && !userdata && !pause) {\n        struct ofpact_output *output;\n\n        output = ofpact_put_OUTPUT(ofpacts);\n        output->port = OFPP_CONTROLLER;\n        output->max_len = max_len;\n    } else {\n        struct ofpact_controller *controller;\n\n        controller = ofpact_put_CONTROLLER(ofpacts);\n        controller->max_len = max_len;\n        controller->reason = reason;\n        controller->controller_id = controller_id;\n        controller->pause = pause;\n\n        if (userdata) {\n            size_t start_ofs = ofpacts->size;\n            const char *end = ofpbuf_put_hex(ofpacts, userdata, NULL);\n            if (*end) {\n                return xstrdup(\"bad hex digit in `controller' \"\n                               \"action `userdata'\");\n            }\n            size_t userdata_len = ofpacts->size - start_ofs;\n            controller = ofpacts->header;\n            controller->userdata_len = userdata_len;\n        }\n        ofpact_finish_CONTROLLER(ofpacts, &controller);\n    }\n\n    return NULL;\n}\n\nstatic void\nformat_hex_arg(struct ds *s, const uint8_t *data, size_t len)\n{\n    for (size_t i = 0; i < len; i++) {\n        if (i) {\n            ds_put_char(s, '.');\n        }\n        ds_put_format(s, \"%02\"PRIx8, data[i]);\n    }\n}\n\nstatic void\nformat_CONTROLLER(const struct ofpact_controller *a, struct ds *s)\n{\n    if (a->reason == OFPR_ACTION && !a->controller_id && !a->userdata_len\n        && !a->pause) {\n        ds_put_format(s, \"%sCONTROLLER:%s%\"PRIu16,\n                      colors.special, colors.end, a->max_len);\n    } else {\n        enum ofp_packet_in_reason reason = a->reason;\n\n        ds_put_format(s, \"%scontroller(%s\", colors.paren, colors.end);\n        if (reason != OFPR_ACTION) {\n            char reasonbuf[OFPUTIL_PACKET_IN_REASON_BUFSIZE];\n\n            ds_put_format(s, \"%sreason=%s%s,\", colors.param, colors.end,\n                          ofputil_packet_in_reason_to_string(\n                              reason, reasonbuf, sizeof reasonbuf));\n        }\n        if (a->max_len != UINT16_MAX) {\n            ds_put_format(s, \"%smax_len=%s%\"PRIu16\",\",\n                          colors.param, colors.end, a->max_len);\n        }\n        if (a->controller_id != 0) {\n            ds_put_format(s, \"%sid=%s%\"PRIu16\",\",\n                          colors.param, colors.end, a->controller_id);\n        }\n        if (a->userdata_len) {\n            ds_put_format(s, \"%suserdata=%s\", colors.param, colors.end);\n            format_hex_arg(s, a->userdata, a->userdata_len);\n            ds_put_char(s, ',');\n        }\n        if (a->pause) {\n            ds_put_format(s, \"%spause%s,\", colors.value, colors.end);\n        }\n        ds_chomp(s, ',');\n        ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n    }\n}\n\f\n/* Enqueue action. */\nstruct ofp10_action_enqueue {\n    ovs_be16 type;            /* OFPAT10_ENQUEUE. */\n    ovs_be16 len;             /* Len is 16. */\n    ovs_be16 port;            /* Port that queue belongs. Should\n                                 refer to a valid physical port\n                                 (i.e. < OFPP_MAX) or OFPP_IN_PORT. */\n    uint8_t pad[6];           /* Pad for 64-bit alignment. */\n    ovs_be32 queue_id;        /* Where to enqueue the packets. */\n};\nOFP_ASSERT(sizeof(struct ofp10_action_enqueue) == 16);\n\nstatic enum ofperr\ndecode_OFPAT_RAW10_ENQUEUE(const struct ofp10_action_enqueue *oae,\n                           enum ofp_version ofp_version OVS_UNUSED,\n                           struct ofpbuf *out)\n{\n    struct ofpact_enqueue *enqueue;\n\n    enqueue = ofpact_put_ENQUEUE(out);\n    enqueue->port = u16_to_ofp(ntohs(oae->port));\n    enqueue->queue = ntohl(oae->queue_id);\n    if (ofp_to_u16(enqueue->port) >= ofp_to_u16(OFPP_MAX)\n        && enqueue->port != OFPP_IN_PORT\n        && enqueue->port != OFPP_LOCAL) {\n        return OFPERR_OFPBAC_BAD_OUT_PORT;\n    }\n    return 0;\n}\n\nstatic void\nencode_ENQUEUE(const struct ofpact_enqueue *enqueue,\n               enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version == OFP10_VERSION) {\n        struct ofp10_action_enqueue *oae;\n\n        oae = put_OFPAT10_ENQUEUE(out);\n        oae->port = htons(ofp_to_u16(enqueue->port));\n        oae->queue_id = htonl(enqueue->queue);\n    } else {\n        put_OFPAT_SET_QUEUE(out, ofp_version, enqueue->queue);\n\n        struct ofp11_action_output *oao = put_OFPAT11_OUTPUT(out);\n        oao->port = ofputil_port_to_ofp11(enqueue->port);\n        oao->max_len = OVS_BE16_MAX;\n\n        put_NXAST_POP_QUEUE(out);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_ENQUEUE(char *arg, struct ofpbuf *ofpacts,\n              enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    char *sp = NULL;\n    char *port = strtok_r(arg, \":q,\", &sp);\n    char *queue = strtok_r(NULL, \"\", &sp);\n    struct ofpact_enqueue *enqueue;\n\n    if (port == NULL || queue == NULL) {\n        return xstrdup(\"\\\"enqueue\\\" syntax is \\\"enqueue:PORT:QUEUE\\\" or \"\n                       \"\\\"enqueue(PORT,QUEUE)\\\"\");\n    }\n\n    enqueue = ofpact_put_ENQUEUE(ofpacts);\n    if (!ofputil_port_from_string(port, &enqueue->port)) {\n        return xasprintf(\"%s: enqueue to unknown port\", port);\n    }\n    return str_to_u32(queue, &enqueue->queue);\n}\n\nstatic void\nformat_ENQUEUE(const struct ofpact_enqueue *a, struct ds *s)\n{\n    ds_put_format(s, \"%senqueue:%s\", colors.param, colors.end);\n    ofputil_format_port(a->port, s);\n    ds_put_format(s, \":%\"PRIu32, a->queue);\n}\n\f\n/* Action structure for NXAST_OUTPUT_REG.\n *\n * Outputs to the OpenFlow port number written to src[ofs:ofs+nbits].\n *\n * The format and semantics of 'src' and 'ofs_nbits' are similar to those for\n * the NXAST_REG_LOAD action.\n *\n * The acceptable nxm_header values for 'src' are the same as the acceptable\n * nxm_header values for the 'src' field of NXAST_REG_MOVE.\n *\n * The 'max_len' field indicates the number of bytes to send when the chosen\n * port is OFPP_CONTROLLER.  Its semantics are equivalent to the 'max_len'\n * field of OFPAT_OUTPUT.\n *\n * The 'zero' field is required to be zeroed for forward compatibility. */\nstruct nx_action_output_reg {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* 24. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_OUTPUT_REG. */\n\n    ovs_be16 ofs_nbits;         /* (ofs << 6) | (n_bits - 1). */\n    ovs_be32 src;               /* Source. */\n\n    ovs_be16 max_len;           /* Max length to send to controller. */\n\n    uint8_t zero[6];            /* Reserved, must be zero. */\n};\nOFP_ASSERT(sizeof(struct nx_action_output_reg) == 24);\n\n/* Action structure for NXAST_OUTPUT_REG2.\n *\n * Like the NXAST_OUTPUT_REG but organized so that there is room for a 64-bit\n * experimenter OXM as 'src'.\n */\nstruct nx_action_output_reg2 {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* 24. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_OUTPUT_REG2. */\n\n    ovs_be16 ofs_nbits;         /* (ofs << 6) | (n_bits - 1). */\n    ovs_be16 max_len;           /* Max length to send to controller. */\n\n    /* Followed by:\n     * - 'src', as an OXM/NXM header (either 4 or 8 bytes).\n     * - Enough 0-bytes to pad the action out to 24 bytes. */\n    uint8_t pad[10];\n};\nOFP_ASSERT(sizeof(struct nx_action_output_reg2) == 24);\n\nstatic enum ofperr\ndecode_NXAST_RAW_OUTPUT_REG(const struct nx_action_output_reg *naor,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            const struct vl_mff_map *vl_mff_map,\n                            uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    struct ofpact_output_reg *output_reg;\n    enum ofperr error;\n\n    if (!is_all_zeros(naor->zero, sizeof naor->zero)) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    output_reg = ofpact_put_OUTPUT_REG(out);\n    output_reg->ofpact.raw = NXAST_RAW_OUTPUT_REG;\n    output_reg->src.ofs = nxm_decode_ofs(naor->ofs_nbits);\n    output_reg->src.n_bits = nxm_decode_n_bits(naor->ofs_nbits);\n    output_reg->max_len = ntohs(naor->max_len);\n    error = mf_vl_mff_mf_from_nxm_header(ntohl(naor->src), vl_mff_map,\n                                         &output_reg->src.field, tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    return mf_check_src(&output_reg->src, NULL);\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_OUTPUT_REG2(const struct nx_action_output_reg2 *naor,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             const struct vl_mff_map *vl_mff_map,\n                             uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    struct ofpact_output_reg *output_reg;\n    enum ofperr error;\n\n    output_reg = ofpact_put_OUTPUT_REG(out);\n    output_reg->ofpact.raw = NXAST_RAW_OUTPUT_REG2;\n    output_reg->src.ofs = nxm_decode_ofs(naor->ofs_nbits);\n    output_reg->src.n_bits = nxm_decode_n_bits(naor->ofs_nbits);\n    output_reg->max_len = ntohs(naor->max_len);\n\n    struct ofpbuf b = ofpbuf_const_initializer(naor, ntohs(naor->len));\n    ofpbuf_pull(&b, OBJECT_OFFSETOF(naor, pad));\n\n    error = mf_vl_mff_nx_pull_header(&b, vl_mff_map, &output_reg->src.field,\n                                     NULL, tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    if (!is_all_zeros(b.data, b.size)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    return mf_check_src(&output_reg->src, NULL);\n}\n\nstatic void\nencode_OUTPUT_REG(const struct ofpact_output_reg *output_reg,\n                  enum ofp_version ofp_version OVS_UNUSED,\n                  struct ofpbuf *out)\n{\n    /* If 'output_reg' came in as an NXAST_RAW_OUTPUT_REG2 action, or if it\n     * cannot be encoded in the older form, encode it as\n     * NXAST_RAW_OUTPUT_REG2. */\n    if (output_reg->ofpact.raw == NXAST_RAW_OUTPUT_REG2\n        || !mf_nxm_header(output_reg->src.field->id)) {\n        struct nx_action_output_reg2 *naor = put_NXAST_OUTPUT_REG2(out);\n        size_t size = out->size;\n\n        naor->ofs_nbits = nxm_encode_ofs_nbits(output_reg->src.ofs,\n                                               output_reg->src.n_bits);\n        naor->max_len = htons(output_reg->max_len);\n\n        out->size = size - sizeof naor->pad;\n        nx_put_mff_header(out, output_reg->src.field, 0, false);\n        out->size = size;\n    } else {\n        struct nx_action_output_reg *naor = put_NXAST_OUTPUT_REG(out);\n\n        naor->ofs_nbits = nxm_encode_ofs_nbits(output_reg->src.ofs,\n                                               output_reg->src.n_bits);\n        naor->src = htonl(nxm_header_from_mff(output_reg->src.field));\n        naor->max_len = htons(output_reg->max_len);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_OUTPUT_REG(const char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return parse_OUTPUT(arg, ofpacts, usable_protocols);\n}\n\nstatic void\nformat_OUTPUT_REG(const struct ofpact_output_reg *a, struct ds *s)\n{\n    ds_put_format(s, \"%soutput:%s\", colors.special, colors.end);\n    mf_format_subfield(&a->src, s);\n}\n\f\n/* Action structure for NXAST_BUNDLE and NXAST_BUNDLE_LOAD.\n *\n * The bundle actions choose a slave from a supplied list of options.\n * NXAST_BUNDLE outputs to its selection.  NXAST_BUNDLE_LOAD writes its\n * selection to a register.\n *\n * The list of possible slaves follows the nx_action_bundle structure. The size\n * of each slave is governed by its type as indicated by the 'slave_type'\n * parameter. The list of slaves should be padded at its end with zeros to make\n * the total length of the action a multiple of 8.\n *\n * Switches infer from the 'slave_type' parameter the size of each slave.  All\n * implementations must support the NXM_OF_IN_PORT 'slave_type' which indicates\n * that the slaves are OpenFlow port numbers with NXM_LENGTH(NXM_OF_IN_PORT) ==\n * 2 byte width.  Switches should reject actions which indicate unknown or\n * unsupported slave types.\n *\n * Switches use a strategy dictated by the 'algorithm' parameter to choose a\n * slave.  If the switch does not support the specified 'algorithm' parameter,\n * it should reject the action.\n *\n * Several algorithms take into account liveness when selecting slaves.  The\n * liveness of a slave is implementation defined (with one exception), but will\n * generally take into account things like its carrier status and the results\n * of any link monitoring protocols which happen to be running on it.  In order\n * to give controllers a place-holder value, the OFPP_NONE port is always\n * considered live, that is, NXAST_BUNDLE_LOAD stores OFPP_NONE in the output\n * register if no slave is live.\n *\n * Some slave selection strategies require the use of a hash function, in which\n * case the 'fields' and 'basis' parameters should be populated.  The 'fields'\n * parameter (one of NX_HASH_FIELDS_*) designates which parts of the flow to\n * hash.  Refer to the definition of \"enum nx_hash_fields\" for details.  The\n * 'basis' parameter is used as a universal hash parameter.  Different values\n * of 'basis' yield different hash results.\n *\n * The 'zero' parameter at the end of the action structure is reserved for\n * future use.  Switches are required to reject actions which have nonzero\n * bytes in the 'zero' field.\n *\n * NXAST_BUNDLE actions should have 'ofs_nbits' and 'dst' zeroed.  Switches\n * should reject actions which have nonzero bytes in either of these fields.\n *\n * NXAST_BUNDLE_LOAD stores the OpenFlow port number of the selected slave in\n * dst[ofs:ofs+n_bits].  The format and semantics of 'dst' and 'ofs_nbits' are\n * similar to those for the NXAST_REG_LOAD action. */\nstruct nx_action_bundle {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* Length including slaves. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_BUNDLE or NXAST_BUNDLE_LOAD. */\n\n    /* Slave choice algorithm to apply to hash value. */\n    ovs_be16 algorithm;         /* One of NX_BD_ALG_*. */\n\n    /* What fields to hash and how. */\n    ovs_be16 fields;            /* One of NX_HASH_FIELDS_*. */\n    ovs_be16 basis;             /* Universal hash parameter. */\n\n    ovs_be32 slave_type;        /* NXM_OF_IN_PORT. */\n    ovs_be16 n_slaves;          /* Number of slaves. */\n\n    ovs_be16 ofs_nbits;         /* (ofs << 6) | (n_bits - 1). */\n    ovs_be32 dst;               /* Destination. */\n\n    uint8_t zero[4];            /* Reserved. Must be zero. */\n};\nOFP_ASSERT(sizeof(struct nx_action_bundle) == 32);\n\nstatic enum ofperr\ndecode_bundle(bool load, const struct nx_action_bundle *nab,\n              const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap,\n              struct ofpbuf *ofpacts)\n{\n    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n    struct ofpact_bundle *bundle;\n    uint32_t slave_type;\n    size_t slaves_size, i;\n    enum ofperr error;\n\n    bundle = ofpact_put_BUNDLE(ofpacts);\n\n    bundle->n_slaves = ntohs(nab->n_slaves);\n    bundle->basis = ntohs(nab->basis);\n    bundle->fields = ntohs(nab->fields);\n    bundle->algorithm = ntohs(nab->algorithm);\n    slave_type = ntohl(nab->slave_type);\n    slaves_size = ntohs(nab->len) - sizeof *nab;\n\n    error = OFPERR_OFPBAC_BAD_ARGUMENT;\n    if (!flow_hash_fields_valid(bundle->fields)) {\n        VLOG_WARN_RL(&rl, \"unsupported fields %d\", (int) bundle->fields);\n    } else if (bundle->n_slaves > BUNDLE_MAX_SLAVES) {\n        VLOG_WARN_RL(&rl, \"too many slaves\");\n    } else if (bundle->algorithm != NX_BD_ALG_HRW\n               && bundle->algorithm != NX_BD_ALG_ACTIVE_BACKUP) {\n        VLOG_WARN_RL(&rl, \"unsupported algorithm %d\", (int) bundle->algorithm);\n    } else if (slave_type != mf_nxm_header(MFF_IN_PORT)) {\n        VLOG_WARN_RL(&rl, \"unsupported slave type %\"PRIu16, slave_type);\n    } else {\n        error = 0;\n    }\n\n    if (!is_all_zeros(nab->zero, sizeof nab->zero)) {\n        VLOG_WARN_RL(&rl, \"reserved field is nonzero\");\n        error = OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    if (load) {\n        bundle->dst.ofs = nxm_decode_ofs(nab->ofs_nbits);\n        bundle->dst.n_bits = nxm_decode_n_bits(nab->ofs_nbits);\n        error = mf_vl_mff_mf_from_nxm_header(ntohl(nab->dst), vl_mff_map,\n                                             &bundle->dst.field, tlv_bitmap);\n        if (error) {\n            return error;\n        }\n\n        if (bundle->dst.n_bits < 16) {\n            VLOG_WARN_RL(&rl, \"bundle_load action requires at least 16 bit \"\n                         \"destination.\");\n            error = OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n    } else {\n        if (nab->ofs_nbits || nab->dst) {\n            VLOG_WARN_RL(&rl, \"bundle action has nonzero reserved fields\");\n            error = OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n    }\n\n    if (slaves_size < bundle->n_slaves * sizeof(ovs_be16)) {\n        VLOG_WARN_RL(&rl, \"Nicira action %s only has %\"PRIuSIZE\" bytes \"\n                     \"allocated for slaves.  %\"PRIuSIZE\" bytes are required \"\n                     \"for %\"PRIu16\" slaves.\",\n                     load ? \"bundle_load\" : \"bundle\", slaves_size,\n                     bundle->n_slaves * sizeof(ovs_be16), bundle->n_slaves);\n        error = OFPERR_OFPBAC_BAD_LEN;\n    }\n\n    for (i = 0; i < bundle->n_slaves; i++) {\n        ofp_port_t ofp_port = u16_to_ofp(ntohs(((ovs_be16 *)(nab + 1))[i]));\n        ofpbuf_put(ofpacts, &ofp_port, sizeof ofp_port);\n        bundle = ofpacts->header;\n    }\n\n    ofpact_finish_BUNDLE(ofpacts, &bundle);\n    if (!error) {\n        error = bundle_check(bundle, OFPP_MAX, NULL);\n    }\n    return error;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_BUNDLE(const struct nx_action_bundle *nab,\n                        enum ofp_version ofp_version OVS_UNUSED,\n                        struct ofpbuf *out)\n{\n    return decode_bundle(false, nab, NULL, NULL, out);\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_BUNDLE_LOAD(const struct nx_action_bundle *nab,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             const struct vl_mff_map *vl_mff_map,\n                             uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    return decode_bundle(true, nab, vl_mff_map, tlv_bitmap, out);\n}\n\nstatic void\nencode_BUNDLE(const struct ofpact_bundle *bundle,\n              enum ofp_version ofp_version OVS_UNUSED,\n              struct ofpbuf *out)\n{\n    int slaves_len = ROUND_UP(2 * bundle->n_slaves, OFP_ACTION_ALIGN);\n    struct nx_action_bundle *nab;\n    ovs_be16 *slaves;\n    size_t i;\n\n    nab = (bundle->dst.field\n           ? put_NXAST_BUNDLE_LOAD(out)\n           : put_NXAST_BUNDLE(out));\n    nab->len = htons(ntohs(nab->len) + slaves_len);\n    nab->algorithm = htons(bundle->algorithm);\n    nab->fields = htons(bundle->fields);\n    nab->basis = htons(bundle->basis);\n    nab->slave_type = htonl(mf_nxm_header(MFF_IN_PORT));\n    nab->n_slaves = htons(bundle->n_slaves);\n    if (bundle->dst.field) {\n        nab->ofs_nbits = nxm_encode_ofs_nbits(bundle->dst.ofs,\n                                              bundle->dst.n_bits);\n        nab->dst = htonl(nxm_header_from_mff(bundle->dst.field));\n    }\n\n    slaves = ofpbuf_put_zeros(out, slaves_len);\n    for (i = 0; i < bundle->n_slaves; i++) {\n        slaves[i] = htons(ofp_to_u16(bundle->slaves[i]));\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_BUNDLE(const char *arg, struct ofpbuf *ofpacts,\n             enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return bundle_parse(arg, ofpacts);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_bundle_load(const char *arg, struct ofpbuf *ofpacts)\n{\n    return bundle_parse_load(arg, ofpacts);\n}\n\nstatic void\nformat_BUNDLE(const struct ofpact_bundle *a, struct ds *s)\n{\n    bundle_format(a, s);\n}\n\f\n/* Set VLAN actions. */\n\nstatic enum ofperr\ndecode_set_vlan_vid(uint16_t vid, bool push_vlan_if_needed, struct ofpbuf *out)\n{\n    if (vid & ~0xfff) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else {\n        struct ofpact_vlan_vid *vlan_vid = ofpact_put_SET_VLAN_VID(out);\n        vlan_vid->vlan_vid = vid;\n        vlan_vid->push_vlan_if_needed = push_vlan_if_needed;\n        return 0;\n    }\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW10_SET_VLAN_VID(uint16_t vid,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    return decode_set_vlan_vid(vid, true, out);\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_SET_VLAN_VID(uint16_t vid,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    return decode_set_vlan_vid(vid, false, out);\n}\n\nstatic void\nencode_SET_VLAN_VID(const struct ofpact_vlan_vid *vlan_vid,\n                    enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    uint16_t vid = vlan_vid->vlan_vid;\n\n    /* Push a VLAN tag, if none is present and this form of the action calls\n     * for such a feature. */\n    if (ofp_version > OFP10_VERSION\n        && vlan_vid->push_vlan_if_needed\n        && !vlan_vid->flow_has_vlan) {\n        put_OFPAT11_PUSH_VLAN(out, htons(ETH_TYPE_VLAN_8021Q));\n    }\n\n    if (ofp_version == OFP10_VERSION) {\n        put_OFPAT10_SET_VLAN_VID(out, vid);\n    } else if (ofp_version == OFP11_VERSION) {\n        put_OFPAT11_SET_VLAN_VID(out, vid);\n    } else {\n        put_set_field(out, ofp_version, MFF_VLAN_VID, vid | OFPVID12_PRESENT);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_set_vlan_vid(char *arg, struct ofpbuf *ofpacts, bool push_vlan_if_needed)\n{\n    struct ofpact_vlan_vid *vlan_vid;\n    uint16_t vid;\n    char *error;\n\n    error = str_to_u16(arg, \"VLAN VID\", &vid);\n    if (error) {\n        return error;\n    }\n\n    if (vid & ~VLAN_VID_MASK) {\n        return xasprintf(\"%s: not a valid VLAN VID\", arg);\n    }\n    vlan_vid = ofpact_put_SET_VLAN_VID(ofpacts);\n    vlan_vid->vlan_vid = vid;\n    vlan_vid->push_vlan_if_needed = push_vlan_if_needed;\n    return NULL;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_VLAN_VID(char *arg, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return parse_set_vlan_vid(arg, ofpacts, false);\n}\n\nstatic void\nformat_SET_VLAN_VID(const struct ofpact_vlan_vid *a, struct ds *s)\n{\n    ds_put_format(s, \"%s%s:%s%\"PRIu16, colors.param,\n                  a->push_vlan_if_needed ? \"mod_vlan_vid\" : \"set_vlan_vid\",\n                  colors.end, a->vlan_vid);\n}\n\f\n/* Set PCP actions. */\n\nstatic enum ofperr\ndecode_set_vlan_pcp(uint8_t pcp, bool push_vlan_if_needed, struct ofpbuf *out)\n{\n    if (pcp & ~7) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else {\n        struct ofpact_vlan_pcp *vlan_pcp = ofpact_put_SET_VLAN_PCP(out);\n        vlan_pcp->vlan_pcp = pcp;\n        vlan_pcp->push_vlan_if_needed = push_vlan_if_needed;\n        return 0;\n    }\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW10_SET_VLAN_PCP(uint8_t pcp,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    return decode_set_vlan_pcp(pcp, true, out);\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_SET_VLAN_PCP(uint8_t pcp,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    return decode_set_vlan_pcp(pcp, false, out);\n}\n\nstatic void\nencode_SET_VLAN_PCP(const struct ofpact_vlan_pcp *vlan_pcp,\n                    enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    uint8_t pcp = vlan_pcp->vlan_pcp;\n\n    /* Push a VLAN tag, if none is present and this form of the action calls\n     * for such a feature. */\n    if (ofp_version > OFP10_VERSION\n        && vlan_pcp->push_vlan_if_needed\n        && !vlan_pcp->flow_has_vlan) {\n        put_OFPAT11_PUSH_VLAN(out, htons(ETH_TYPE_VLAN_8021Q));\n    }\n\n    if (ofp_version == OFP10_VERSION) {\n        put_OFPAT10_SET_VLAN_PCP(out, pcp);\n    } else if (ofp_version == OFP11_VERSION) {\n        put_OFPAT11_SET_VLAN_PCP(out, pcp);\n    } else {\n        put_set_field(out, ofp_version, MFF_VLAN_PCP, pcp);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_set_vlan_pcp(char *arg, struct ofpbuf *ofpacts, bool push_vlan_if_needed)\n{\n    struct ofpact_vlan_pcp *vlan_pcp;\n    uint8_t pcp;\n    char *error;\n\n    error = str_to_u8(arg, \"VLAN PCP\", &pcp);\n    if (error) {\n        return error;\n    }\n\n    if (pcp & ~7) {\n        return xasprintf(\"%s: not a valid VLAN PCP\", arg);\n    }\n    vlan_pcp = ofpact_put_SET_VLAN_PCP(ofpacts);\n    vlan_pcp->vlan_pcp = pcp;\n    vlan_pcp->push_vlan_if_needed = push_vlan_if_needed;\n    return NULL;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_VLAN_PCP(char *arg, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return parse_set_vlan_pcp(arg, ofpacts, false);\n}\n\nstatic void\nformat_SET_VLAN_PCP(const struct ofpact_vlan_pcp *a, struct ds *s)\n{\n    ds_put_format(s, \"%s%s:%s%\"PRIu8, colors.param,\n                  a->push_vlan_if_needed ? \"mod_vlan_pcp\" : \"set_vlan_pcp\",\n                  colors.end, a->vlan_pcp);\n}\n\f\n/* Strip VLAN actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW10_STRIP_VLAN(struct ofpbuf *out)\n{\n    ofpact_put_STRIP_VLAN(out)->ofpact.raw = OFPAT_RAW10_STRIP_VLAN;\n    return 0;\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_POP_VLAN(struct ofpbuf *out)\n{\n    ofpact_put_STRIP_VLAN(out)->ofpact.raw = OFPAT_RAW11_POP_VLAN;\n    return 0;\n}\n\nstatic void\nencode_STRIP_VLAN(const struct ofpact_null *null OVS_UNUSED,\n                  enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version == OFP10_VERSION) {\n        put_OFPAT10_STRIP_VLAN(out);\n    } else {\n        put_OFPAT11_POP_VLAN(out);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_STRIP_VLAN(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_STRIP_VLAN(ofpacts)->ofpact.raw = OFPAT_RAW10_STRIP_VLAN;\n    return NULL;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_pop_vlan(struct ofpbuf *ofpacts)\n{\n    ofpact_put_STRIP_VLAN(ofpacts)->ofpact.raw = OFPAT_RAW11_POP_VLAN;\n    return NULL;\n}\n\nstatic void\nformat_STRIP_VLAN(const struct ofpact_null *a, struct ds *s)\n{\n    ds_put_format(s, (a->ofpact.raw == OFPAT_RAW11_POP_VLAN\n                    ? \"%spop_vlan%s\"\n                    : \"%sstrip_vlan%s\"),\n                  colors.value, colors.end);\n}\n\f\n/* Push VLAN action. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_PUSH_VLAN(ovs_be16 eth_type,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             struct ofpbuf *out)\n{\n    if (eth_type != htons(ETH_TYPE_VLAN_8021Q)) {\n        /* XXX 802.1AD(QinQ) isn't supported at the moment */\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n    ofpact_put_PUSH_VLAN(out);\n    return 0;\n}\n\nstatic void\nencode_PUSH_VLAN(const struct ofpact_null *null OVS_UNUSED,\n                 enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version == OFP10_VERSION) {\n        /* PUSH is a side effect of a SET_VLAN_VID/PCP, which should\n         * follow this action. */\n    } else {\n        /* XXX ETH_TYPE_VLAN_8021AD case */\n        put_OFPAT11_PUSH_VLAN(out, htons(ETH_TYPE_VLAN_8021Q));\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_PUSH_VLAN(char *arg, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint16_t ethertype;\n    char *error;\n\n    *usable_protocols &= OFPUTIL_P_OF11_UP;\n    error = str_to_u16(arg, \"ethertype\", &ethertype);\n    if (error) {\n        return error;\n    }\n\n    if (ethertype != ETH_TYPE_VLAN_8021Q) {\n        /* XXX ETH_TYPE_VLAN_8021AD case isn't supported */\n        return xasprintf(\"%s: not a valid VLAN ethertype\", arg);\n    }\n\n    ofpact_put_PUSH_VLAN(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_PUSH_VLAN(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    /* XXX 802.1AD case*/\n    ds_put_format(s, \"%spush_vlan:%s%#\"PRIx16,\n                  colors.param, colors.end, ETH_TYPE_VLAN_8021Q);\n}\n\f\n/* Action structure for OFPAT10_SET_DL_SRC/DST and OFPAT11_SET_DL_SRC/DST. */\nstruct ofp_action_dl_addr {\n    ovs_be16 type;                  /* Type. */\n    ovs_be16 len;                   /* Length is 16. */\n    struct eth_addr dl_addr;        /* Ethernet address. */\n    uint8_t pad[6];\n};\nOFP_ASSERT(sizeof(struct ofp_action_dl_addr) == 16);\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_DL_SRC(const struct ofp_action_dl_addr *a,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    ofpact_put_SET_ETH_SRC(out)->mac = a->dl_addr;\n    return 0;\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_DL_DST(const struct ofp_action_dl_addr *a,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    ofpact_put_SET_ETH_DST(out)->mac = a->dl_addr;\n    return 0;\n}\n\nstatic void\nencode_SET_ETH_addr(const struct ofpact_mac *mac, enum ofp_version ofp_version,\n                    enum ofp_raw_action_type raw, enum mf_field_id field,\n                    struct ofpbuf *out)\n{\n    if (ofp_version < OFP12_VERSION) {\n        struct ofp_action_dl_addr *oada;\n\n        oada = ofpact_put_raw(out, ofp_version, raw, 0);\n        oada->dl_addr = mac->mac;\n    } else {\n        put_set_field(out, ofp_version, field, eth_addr_to_uint64(mac->mac));\n    }\n}\n\nstatic void\nencode_SET_ETH_SRC(const struct ofpact_mac *mac, enum ofp_version ofp_version,\n                   struct ofpbuf *out)\n{\n    encode_SET_ETH_addr(mac, ofp_version, OFPAT_RAW_SET_DL_SRC, MFF_ETH_SRC,\n                        out);\n\n}\n\nstatic void\nencode_SET_ETH_DST(const struct ofpact_mac *mac,\n                               enum ofp_version ofp_version,\n                               struct ofpbuf *out)\n{\n    encode_SET_ETH_addr(mac, ofp_version, OFPAT_RAW_SET_DL_DST, MFF_ETH_DST,\n                        out);\n\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_ETH_SRC(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_mac(arg, &ofpact_put_SET_ETH_SRC(ofpacts)->mac);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_ETH_DST(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_mac(arg, &ofpact_put_SET_ETH_DST(ofpacts)->mac);\n}\n\nstatic void\nformat_SET_ETH_SRC(const struct ofpact_mac *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_dl_src:%s\"ETH_ADDR_FMT,\n                  colors.param, colors.end, ETH_ADDR_ARGS(a->mac));\n}\n\nstatic void\nformat_SET_ETH_DST(const struct ofpact_mac *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_dl_dst:%s\"ETH_ADDR_FMT,\n                  colors.param, colors.end, ETH_ADDR_ARGS(a->mac));\n}\n\f\n/* Set IPv4 address actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_NW_SRC(ovs_be32 ipv4,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    ofpact_put_SET_IPV4_SRC(out)->ipv4 = ipv4;\n    return 0;\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_NW_DST(ovs_be32 ipv4,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    ofpact_put_SET_IPV4_DST(out)->ipv4 = ipv4;\n    return 0;\n}\n\nstatic void\nencode_SET_IPV4_addr(const struct ofpact_ipv4 *ipv4,\n                     enum ofp_version ofp_version,\n                     enum ofp_raw_action_type raw, enum mf_field_id field,\n                     struct ofpbuf *out)\n{\n    ovs_be32 addr = ipv4->ipv4;\n    if (ofp_version < OFP12_VERSION) {\n        ofpact_put_raw(out, ofp_version, raw, ntohl(addr));\n    } else {\n        put_set_field(out, ofp_version, field, ntohl(addr));\n    }\n}\n\nstatic void\nencode_SET_IPV4_SRC(const struct ofpact_ipv4 *ipv4,\n                    enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    encode_SET_IPV4_addr(ipv4, ofp_version, OFPAT_RAW_SET_NW_SRC, MFF_IPV4_SRC,\n                         out);\n}\n\nstatic void\nencode_SET_IPV4_DST(const struct ofpact_ipv4 *ipv4,\n                    enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    encode_SET_IPV4_addr(ipv4, ofp_version, OFPAT_RAW_SET_NW_DST, MFF_IPV4_DST,\n                         out);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_IPV4_SRC(char *arg, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_ip(arg, &ofpact_put_SET_IPV4_SRC(ofpacts)->ipv4);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_IPV4_DST(char *arg, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_ip(arg, &ofpact_put_SET_IPV4_DST(ofpacts)->ipv4);\n}\n\nstatic void\nformat_SET_IPV4_SRC(const struct ofpact_ipv4 *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_nw_src:%s\"IP_FMT,\n                  colors.param, colors.end, IP_ARGS(a->ipv4));\n}\n\nstatic void\nformat_SET_IPV4_DST(const struct ofpact_ipv4 *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_nw_dst:%s\"IP_FMT,\n                  colors.param, colors.end, IP_ARGS(a->ipv4));\n}\n\f\n/* Set IPv4/v6 TOS actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_NW_TOS(uint8_t dscp,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    if (dscp & ~IP_DSCP_MASK) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else {\n        ofpact_put_SET_IP_DSCP(out)->dscp = dscp;\n        return 0;\n    }\n}\n\nstatic void\nencode_SET_IP_DSCP(const struct ofpact_dscp *dscp,\n                   enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version < OFP12_VERSION) {\n        put_OFPAT_SET_NW_TOS(out, ofp_version, dscp->dscp);\n    } else {\n        put_set_field(out, ofp_version, MFF_IP_DSCP_SHIFTED, dscp->dscp >> 2);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_IP_DSCP(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint8_t tos;\n    char *error;\n\n    error = str_to_u8(arg, \"TOS\", &tos);\n    if (error) {\n        return error;\n    }\n\n    if (tos & ~IP_DSCP_MASK) {\n        return xasprintf(\"%s: not a valid TOS\", arg);\n    }\n    ofpact_put_SET_IP_DSCP(ofpacts)->dscp = tos;\n    return NULL;\n}\n\nstatic void\nformat_SET_IP_DSCP(const struct ofpact_dscp *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_nw_tos:%s%d\", colors.param, colors.end, a->dscp);\n}\n\f\n/* Set IPv4/v6 ECN actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_SET_NW_ECN(uint8_t ecn,\n                              enum ofp_version ofp_version OVS_UNUSED,\n                              struct ofpbuf *out)\n{\n    if (ecn & ~IP_ECN_MASK) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else {\n        ofpact_put_SET_IP_ECN(out)->ecn = ecn;\n        return 0;\n    }\n}\n\nstatic void\nencode_SET_IP_ECN(const struct ofpact_ecn *ip_ecn,\n                  enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    uint8_t ecn = ip_ecn->ecn;\n    if (ofp_version == OFP10_VERSION) {\n        struct mf_subfield dst = { .field = mf_from_id(MFF_IP_ECN),\n                                   .ofs = 0, .n_bits = 2 };\n        put_reg_load(out, &dst, ecn);\n    } else if (ofp_version == OFP11_VERSION) {\n        put_OFPAT11_SET_NW_ECN(out, ecn);\n    } else {\n        put_set_field(out, ofp_version, MFF_IP_ECN, ecn);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_IP_ECN(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint8_t ecn;\n    char *error;\n\n    error = str_to_u8(arg, \"ECN\", &ecn);\n    if (error) {\n        return error;\n    }\n\n    if (ecn & ~IP_ECN_MASK) {\n        return xasprintf(\"%s: not a valid ECN\", arg);\n    }\n    ofpact_put_SET_IP_ECN(ofpacts)->ecn = ecn;\n    return NULL;\n}\n\nstatic void\nformat_SET_IP_ECN(const struct ofpact_ecn *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_nw_ecn:%s%d\",\n                  colors.param, colors.end, a->ecn);\n}\n\f\n/* Set IPv4/v6 TTL actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_SET_NW_TTL(uint8_t ttl,\n                              enum ofp_version ofp_version OVS_UNUSED,\n                              struct ofpbuf *out)\n{\n    ofpact_put_SET_IP_TTL(out)->ttl = ttl;\n    return 0;\n}\n\nstatic void\nencode_SET_IP_TTL(const struct ofpact_ip_ttl *ttl,\n                  enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version >= OFP11_VERSION) {\n        put_OFPAT11_SET_NW_TTL(out, ttl->ttl);\n    } else {\n        struct mf_subfield dst = { .field = mf_from_id(MFF_IP_TTL),\n                                   .ofs = 0, .n_bits = 8 };\n        put_reg_load(out, &dst, ttl->ttl);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_IP_TTL(char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint8_t ttl;\n    char *error;\n\n    error = str_to_u8(arg, \"TTL\", &ttl);\n    if (error) {\n        return error;\n    }\n\n    ofpact_put_SET_IP_TTL(ofpacts)->ttl = ttl;\n    return NULL;\n}\n\nstatic void\nformat_SET_IP_TTL(const struct ofpact_ip_ttl *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_nw_ttl:%s%d\", colors.param, colors.end, a->ttl);\n}\n\f\n/* Set TCP/UDP/SCTP port actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_TP_SRC(ovs_be16 port,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    ofpact_put_SET_L4_SRC_PORT(out)->port = ntohs(port);\n    return 0;\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_TP_DST(ovs_be16 port,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    ofpact_put_SET_L4_DST_PORT(out)->port = ntohs(port);\n    return 0;\n}\n\nstatic void\nencode_SET_L4_port(const struct ofpact_l4_port *l4_port,\n                   enum ofp_version ofp_version, enum ofp_raw_action_type raw,\n                   enum mf_field_id field, struct ofpbuf *out)\n{\n    uint16_t port = l4_port->port;\n\n    if (ofp_version >= OFP12_VERSION && field != MFF_N_IDS) {\n        put_set_field(out, ofp_version, field, port);\n    } else {\n        ofpact_put_raw(out, ofp_version, raw, port);\n    }\n}\n\nstatic void\nencode_SET_L4_SRC_PORT(const struct ofpact_l4_port *l4_port,\n                       enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    uint8_t proto = l4_port->flow_ip_proto;\n    enum mf_field_id field = (proto == IPPROTO_TCP ? MFF_TCP_SRC\n                              : proto == IPPROTO_UDP ? MFF_UDP_SRC\n                              : proto == IPPROTO_SCTP ? MFF_SCTP_SRC\n                              : MFF_N_IDS);\n\n    encode_SET_L4_port(l4_port, ofp_version, OFPAT_RAW_SET_TP_SRC, field, out);\n}\n\nstatic void\nencode_SET_L4_DST_PORT(const struct ofpact_l4_port *l4_port,\n                       enum ofp_version ofp_version,\n                       struct ofpbuf *out)\n{\n    uint8_t proto = l4_port->flow_ip_proto;\n    enum mf_field_id field = (proto == IPPROTO_TCP ? MFF_TCP_DST\n                              : proto == IPPROTO_UDP ? MFF_UDP_DST\n                              : proto == IPPROTO_SCTP ? MFF_SCTP_DST\n                              : MFF_N_IDS);\n\n    encode_SET_L4_port(l4_port, ofp_version, OFPAT_RAW_SET_TP_DST, field, out);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_L4_SRC_PORT(char *arg, struct ofpbuf *ofpacts,\n                      enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_u16(arg, \"source port\",\n                      &ofpact_put_SET_L4_SRC_PORT(ofpacts)->port);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_L4_DST_PORT(char *arg, struct ofpbuf *ofpacts,\n                      enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_u16(arg, \"destination port\",\n                      &ofpact_put_SET_L4_DST_PORT(ofpacts)->port);\n}\n\nstatic void\nformat_SET_L4_SRC_PORT(const struct ofpact_l4_port *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_tp_src:%s%d\", colors.param, colors.end, a->port);\n}\n\nstatic void\nformat_SET_L4_DST_PORT(const struct ofpact_l4_port *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_tp_dst:%s%d\", colors.param, colors.end, a->port);\n}\n\f\n/* Action structure for OFPAT_COPY_FIELD. */\nstruct ofp15_action_copy_field {\n    ovs_be16 type;              /* OFPAT_COPY_FIELD. */\n    ovs_be16 len;               /* Length is padded to 64 bits. */\n    ovs_be16 n_bits;            /* Number of bits to copy. */\n    ovs_be16 src_offset;        /* Starting bit offset in source. */\n    ovs_be16 dst_offset;        /* Starting bit offset in destination. */\n    uint8_t pad[2];\n    /* Followed by:\n     * - OXM header for source field.\n     * - OXM header for destination field.\n     * - Padding with 0-bytes to a multiple of 8 bytes.\n     * The \"pad2\" member is the beginning of the above. */\n    uint8_t pad2[4];\n};\nOFP_ASSERT(sizeof(struct ofp15_action_copy_field) == 16);\n\n/* Action structure for OpenFlow 1.3 extension copy-field action.. */\nstruct onf_action_copy_field {\n    ovs_be16 type;              /* OFPAT_EXPERIMENTER. */\n    ovs_be16 len;               /* Length is padded to 64 bits. */\n    ovs_be32 experimenter;      /* ONF_VENDOR_ID. */\n    ovs_be16 exp_type;          /* 3200. */\n    uint8_t pad[2];             /* Not used. */\n    ovs_be16 n_bits;            /* Number of bits to copy. */\n    ovs_be16 src_offset;        /* Starting bit offset in source. */\n    ovs_be16 dst_offset;        /* Starting bit offset in destination. */\n    uint8_t pad2[2];            /* Not used. */\n    /* Followed by:\n     * - OXM header for source field.\n     * - OXM header for destination field.\n     * - Padding with 0-bytes (either 0 or 4 of them) to a multiple of 8 bytes.\n     * The \"pad3\" member is the beginning of the above. */\n    uint8_t pad3[4];            /* Not used. */\n};\nOFP_ASSERT(sizeof(struct onf_action_copy_field) == 24);\n\n/* Action structure for NXAST_REG_MOVE.\n *\n * Copies src[src_ofs:src_ofs+n_bits] to dst[dst_ofs:dst_ofs+n_bits], where\n * a[b:c] denotes the bits within 'a' numbered 'b' through 'c' (not including\n * bit 'c').  Bit numbering starts at 0 for the least-significant bit, 1 for\n * the next most significant bit, and so on.\n *\n * 'src' and 'dst' are nxm_header values with nxm_hasmask=0.  (It doesn't make\n * sense to use nxm_hasmask=1 because the action does not do any kind of\n * matching; it uses the actual value of a field.)\n *\n * The following nxm_header values are potentially acceptable as 'src':\n *\n *   - NXM_OF_IN_PORT\n *   - NXM_OF_ETH_DST\n *   - NXM_OF_ETH_SRC\n *   - NXM_OF_ETH_TYPE\n *   - NXM_OF_VLAN_TCI\n *   - NXM_OF_IP_TOS\n *   - NXM_OF_IP_PROTO\n *   - NXM_OF_IP_SRC\n *   - NXM_OF_IP_DST\n *   - NXM_OF_TCP_SRC\n *   - NXM_OF_TCP_DST\n *   - NXM_OF_UDP_SRC\n *   - NXM_OF_UDP_DST\n *   - NXM_OF_ICMP_TYPE\n *   - NXM_OF_ICMP_CODE\n *   - NXM_OF_ARP_OP\n *   - NXM_OF_ARP_SPA\n *   - NXM_OF_ARP_TPA\n *   - NXM_NX_TUN_ID\n *   - NXM_NX_ARP_SHA\n *   - NXM_NX_ARP_THA\n *   - NXM_NX_ICMPV6_TYPE\n *   - NXM_NX_ICMPV6_CODE\n *   - NXM_NX_ND_SLL\n *   - NXM_NX_ND_TLL\n *   - NXM_NX_REG(idx) for idx in the switch's accepted range.\n *   - NXM_NX_PKT_MARK\n *   - NXM_NX_TUN_IPV4_SRC\n *   - NXM_NX_TUN_IPV4_DST\n *\n * The following nxm_header values are potentially acceptable as 'dst':\n *\n *   - NXM_OF_ETH_DST\n *   - NXM_OF_ETH_SRC\n *   - NXM_OF_IP_TOS\n *   - NXM_OF_IP_SRC\n *   - NXM_OF_IP_DST\n *   - NXM_OF_TCP_SRC\n *   - NXM_OF_TCP_DST\n *   - NXM_OF_UDP_SRC\n *   - NXM_OF_UDP_DST\n *   - NXM_OF_ICMP_TYPE\n *   - NXM_OF_ICMP_CODE\n *   - NXM_NX_ICMPV6_TYPE\n *   - NXM_NX_ICMPV6_CODE\n *   - NXM_NX_ARP_SHA\n *   - NXM_NX_ARP_THA\n *   - NXM_OF_ARP_OP\n *   - NXM_OF_ARP_SPA\n *   - NXM_OF_ARP_TPA\n *     Modifying any of the above fields changes the corresponding packet\n *     header.\n *\n *   - NXM_OF_IN_PORT\n *\n *   - NXM_NX_REG(idx) for idx in the switch's accepted range.\n *\n *   - NXM_NX_PKT_MARK\n *\n *   - NXM_OF_VLAN_TCI.  Modifying this field's value has side effects on the\n *     packet's 802.1Q header.  Setting a value with CFI=0 removes the 802.1Q\n *     header (if any), ignoring the other bits.  Setting a value with CFI=1\n *     adds or modifies the 802.1Q header appropriately, setting the TCI field\n *     to the field's new value (with the CFI bit masked out).\n *\n *   - NXM_NX_TUN_ID, NXM_NX_TUN_IPV4_SRC, NXM_NX_TUN_IPV4_DST.  Modifying\n *     any of these values modifies the corresponding tunnel header field used\n *     for the packet's next tunnel encapsulation, if allowed by the\n *     configuration of the output tunnel port.\n *\n * A given nxm_header value may be used as 'src' or 'dst' only on a flow whose\n * nx_match satisfies its prerequisites.  For example, NXM_OF_IP_TOS may be\n * used only if the flow's nx_match includes an nxm_entry that specifies\n * nxm_type=NXM_OF_ETH_TYPE, nxm_hasmask=0, and nxm_value=0x0800.\n *\n * The switch will reject actions for which src_ofs+n_bits is greater than the\n * width of 'src' or dst_ofs+n_bits is greater than the width of 'dst' with\n * error type OFPET_BAD_ACTION, code OFPBAC_BAD_ARGUMENT.\n *\n * This action behaves properly when 'src' overlaps with 'dst', that is, it\n * behaves as if 'src' were copied out to a temporary buffer, then the\n * temporary buffer copied to 'dst'.\n */\nstruct nx_action_reg_move {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 24. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_REG_MOVE. */\n    ovs_be16 n_bits;                /* Number of bits. */\n    ovs_be16 src_ofs;               /* Starting bit offset in source. */\n    ovs_be16 dst_ofs;               /* Starting bit offset in destination. */\n    /* Followed by:\n     * - OXM/NXM header for source field (4 or 8 bytes).\n     * - OXM/NXM header for destination field (4 or 8 bytes).\n     * - Padding with 0-bytes to a multiple of 8 bytes, if necessary. */\n};\nOFP_ASSERT(sizeof(struct nx_action_reg_move) == 16);\n\nstatic enum ofperr\ndecode_copy_field__(ovs_be16 src_offset, ovs_be16 dst_offset, ovs_be16 n_bits,\n                    const void *action, ovs_be16 action_len, size_t oxm_offset,\n                    const struct vl_mff_map *vl_mff_map,\n                    uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpact_reg_move *move = ofpact_put_REG_MOVE(ofpacts);\n    enum ofperr error;\n\n    move->ofpact.raw = ONFACT_RAW13_COPY_FIELD;\n    move->src.ofs = ntohs(src_offset);\n    move->src.n_bits = ntohs(n_bits);\n    move->dst.ofs = ntohs(dst_offset);\n    move->dst.n_bits = ntohs(n_bits);\n\n    struct ofpbuf b = ofpbuf_const_initializer(action, ntohs(action_len));\n    ofpbuf_pull(&b, oxm_offset);\n\n    error = mf_vl_mff_nx_pull_header(&b, vl_mff_map, &move->src.field, NULL,\n                                     tlv_bitmap);\n    if (error) {\n        return error;\n    }\n    error = mf_vl_mff_nx_pull_header(&b, vl_mff_map, &move->dst.field, NULL,\n                                     tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    if (!is_all_zeros(b.data, b.size)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    return nxm_reg_move_check(move, NULL);\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW15_COPY_FIELD(const struct ofp15_action_copy_field *oacf,\n                              enum ofp_version ofp_version OVS_UNUSED,\n                              const struct vl_mff_map *vl_mff_map,\n                              uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    return decode_copy_field__(oacf->src_offset, oacf->dst_offset,\n                               oacf->n_bits, oacf, oacf->len,\n                               OBJECT_OFFSETOF(oacf, pad2), vl_mff_map,\n                               tlv_bitmap, ofpacts);\n}\n\nstatic enum ofperr\ndecode_ONFACT_RAW13_COPY_FIELD(const struct onf_action_copy_field *oacf,\n                               enum ofp_version ofp_version OVS_UNUSED,\n                               const struct vl_mff_map *vl_mff_map,\n                               uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    return decode_copy_field__(oacf->src_offset, oacf->dst_offset,\n                               oacf->n_bits, oacf, oacf->len,\n                               OBJECT_OFFSETOF(oacf, pad3), vl_mff_map,\n                               tlv_bitmap, ofpacts);\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_REG_MOVE(const struct nx_action_reg_move *narm,\n                          enum ofp_version ofp_version OVS_UNUSED,\n                          const struct vl_mff_map *vl_mff_map,\n                          uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpact_reg_move *move = ofpact_put_REG_MOVE(ofpacts);\n    enum ofperr error;\n\n    move->ofpact.raw = NXAST_RAW_REG_MOVE;\n    move->src.ofs = ntohs(narm->src_ofs);\n    move->src.n_bits = ntohs(narm->n_bits);\n    move->dst.ofs = ntohs(narm->dst_ofs);\n    move->dst.n_bits = ntohs(narm->n_bits);\n\n    struct ofpbuf b = ofpbuf_const_initializer(narm, ntohs(narm->len));\n    ofpbuf_pull(&b, sizeof *narm);\n\n    error = mf_vl_mff_nx_pull_header(&b, vl_mff_map, &move->src.field, NULL,\n                                     tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    error = mf_vl_mff_nx_pull_header(&b, vl_mff_map, &move->dst.field, NULL,\n                                     tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    if (!is_all_zeros(b.data, b.size)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    return nxm_reg_move_check(move, NULL);\n}\n\nstatic void\nencode_REG_MOVE(const struct ofpact_reg_move *move,\n                enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    /* For OpenFlow 1.3, the choice of ONFACT_RAW13_COPY_FIELD versus\n     * NXAST_RAW_REG_MOVE is somewhat difficult.  Neither one is guaranteed to\n     * be supported by every OpenFlow 1.3 implementation.  It would be ideal to\n     * probe for support.  Until we have that ability, we currently prefer\n     * NXAST_RAW_REG_MOVE for backward compatibility with older Open vSwitch\n     * versions.  */\n    size_t start_ofs = out->size;\n    if (ofp_version >= OFP15_VERSION) {\n        struct ofp15_action_copy_field *copy = put_OFPAT15_COPY_FIELD(out);\n        copy->n_bits = htons(move->dst.n_bits);\n        copy->src_offset = htons(move->src.ofs);\n        copy->dst_offset = htons(move->dst.ofs);\n        out->size = out->size - sizeof copy->pad2;\n        nx_put_mff_header(out, move->src.field, ofp_version, false);\n        nx_put_mff_header(out, move->dst.field, ofp_version, false);\n    } else if (ofp_version == OFP13_VERSION\n               && move->ofpact.raw == ONFACT_RAW13_COPY_FIELD) {\n        struct onf_action_copy_field *copy = put_ONFACT13_COPY_FIELD(out);\n        copy->n_bits = htons(move->dst.n_bits);\n        copy->src_offset = htons(move->src.ofs);\n        copy->dst_offset = htons(move->dst.ofs);\n        out->size = out->size - sizeof copy->pad3;\n        nx_put_mff_header(out, move->src.field, ofp_version, false);\n        nx_put_mff_header(out, move->dst.field, ofp_version, false);\n    } else {\n        struct nx_action_reg_move *narm = put_NXAST_REG_MOVE(out);\n        narm->n_bits = htons(move->dst.n_bits);\n        narm->src_ofs = htons(move->src.ofs);\n        narm->dst_ofs = htons(move->dst.ofs);\n        nx_put_mff_header(out, move->src.field, 0, false);\n        nx_put_mff_header(out, move->dst.field, 0, false);\n    }\n    pad_ofpat(out, start_ofs);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_REG_MOVE(const char *arg, struct ofpbuf *ofpacts,\n               enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_reg_move *move = ofpact_put_REG_MOVE(ofpacts);\n    return nxm_parse_reg_move(move, arg);\n}\n\nstatic void\nformat_REG_MOVE(const struct ofpact_reg_move *a, struct ds *s)\n{\n    nxm_format_reg_move(a, s);\n}\n\f\n/* Action structure for OFPAT12_SET_FIELD. */\nstruct ofp12_action_set_field {\n    ovs_be16 type;                  /* OFPAT12_SET_FIELD. */\n    ovs_be16 len;                   /* Length is padded to 64 bits. */\n\n    /* Followed by:\n     * - An OXM header, value, and (in OpenFlow 1.5+) optionally a mask.\n     * - Enough 0-bytes to pad out to a multiple of 64 bits.\n     *\n     * The \"pad\" member is the beginning of the above. */\n    uint8_t pad[4];\n};\nOFP_ASSERT(sizeof(struct ofp12_action_set_field) == 8);\n\n/* Action structure for NXAST_REG_LOAD.\n *\n * Copies value[0:n_bits] to dst[ofs:ofs+n_bits], where a[b:c] denotes the bits\n * within 'a' numbered 'b' through 'c' (not including bit 'c').  Bit numbering\n * starts at 0 for the least-significant bit, 1 for the next most significant\n * bit, and so on.\n *\n * 'dst' is an nxm_header with nxm_hasmask=0.  See the documentation for\n * NXAST_REG_MOVE, above, for the permitted fields and for the side effects of\n * loading them.\n *\n * The 'ofs' and 'n_bits' fields are combined into a single 'ofs_nbits' field\n * to avoid enlarging the structure by another 8 bytes.  To allow 'n_bits' to\n * take a value between 1 and 64 (inclusive) while taking up only 6 bits, it is\n * also stored as one less than its true value:\n *\n *  15                           6 5                0\n * +------------------------------+------------------+\n * |              ofs             |    n_bits - 1    |\n * +------------------------------+------------------+\n *\n * The switch will reject actions for which ofs+n_bits is greater than the\n * width of 'dst', or in which any bits in 'value' with value 2**n_bits or\n * greater are set to 1, with error type OFPET_BAD_ACTION, code\n * OFPBAC_BAD_ARGUMENT.\n */\nstruct nx_action_reg_load {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 24. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_REG_LOAD. */\n    ovs_be16 ofs_nbits;             /* (ofs << 6) | (n_bits - 1). */\n    ovs_be32 dst;                   /* Destination register. */\n    ovs_be64 value;                 /* Immediate value. */\n};\nOFP_ASSERT(sizeof(struct nx_action_reg_load) == 24);\n\n/* The NXAST_REG_LOAD2 action structure is \"struct ext_action_header\",\n * followed by:\n *\n * - An NXM/OXM header, value, and optionally a mask.\n * - Enough 0-bytes to pad out to a multiple of 64 bits.\n *\n * The \"pad\" member is the beginning of the above. */\n\nstatic enum ofperr\ndecode_ofpat_set_field(const struct ofp12_action_set_field *oasf,\n                       bool may_mask, const struct vl_mff_map *vl_mff_map,\n                       uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oasf, ntohs(oasf->len));\n    ofpbuf_pull(&b, OBJECT_OFFSETOF(oasf, pad));\n\n    union mf_value value, mask;\n    const struct mf_field *field;\n    enum ofperr error;\n    error  = mf_vl_mff_nx_pull_entry(&b, vl_mff_map, &field, &value,\n                                     may_mask ? &mask : NULL, tlv_bitmap);\n    if (error) {\n        return (error == OFPERR_OFPBMC_BAD_MASK\n                ? OFPERR_OFPBAC_BAD_SET_MASK\n                : error);\n    }\n\n    if (!may_mask) {\n        memset(&mask, 0xff, field->n_bytes);\n    }\n\n    if (!is_all_zeros(b.data, b.size)) {\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n\n    /* OpenFlow says specifically that one may not set OXM_OF_IN_PORT via\n     * Set-Field. */\n    if (field->id == MFF_IN_PORT_OXM) {\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n\n    /* oxm_length is now validated to be compatible with mf_value. */\n    if (!field->writable) {\n        VLOG_WARN_RL(&rl, \"destination field %s is not writable\",\n                     field->name);\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n\n    /* The value must be valid for match.  OpenFlow 1.5 also says,\n     * \"In an OXM_OF_VLAN_VID set-field action, the OFPVID_PRESENT bit must be\n     * a 1-bit in oxm_value and in oxm_mask.\" */\n    if (!mf_is_value_valid(field, &value)\n        || (field->id == MFF_VLAN_VID\n            && (!(mask.be16 & htons(OFPVID12_PRESENT))\n                || !(value.be16 & htons(OFPVID12_PRESENT))))) {\n        struct ds ds = DS_EMPTY_INITIALIZER;\n        mf_format(field, &value, NULL, &ds);\n        VLOG_WARN_RL(&rl, \"Invalid value for set field %s: %s\",\n                     field->name, ds_cstr(&ds));\n        ds_destroy(&ds);\n\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n\n    ofpact_put_set_field(ofpacts, field, &value, &mask);\n    return 0;\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW12_SET_FIELD(const struct ofp12_action_set_field *oasf,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             const struct vl_mff_map *vl_mff_map,\n                             uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    return decode_ofpat_set_field(oasf, false, vl_mff_map, tlv_bitmap,\n                                  ofpacts);\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW15_SET_FIELD(const struct ofp12_action_set_field *oasf,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             const struct vl_mff_map *vl_mff_map,\n                             uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    return decode_ofpat_set_field(oasf, true, vl_mff_map, tlv_bitmap, ofpacts);\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_REG_LOAD(const struct nx_action_reg_load *narl,\n                          enum ofp_version ofp_version OVS_UNUSED,\n                          const struct vl_mff_map *vl_mff_map,\n                          uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    struct mf_subfield dst;\n    enum ofperr error;\n\n    dst.ofs = nxm_decode_ofs(narl->ofs_nbits);\n    dst.n_bits = nxm_decode_n_bits(narl->ofs_nbits);\n    error = mf_vl_mff_mf_from_nxm_header(ntohl(narl->dst), vl_mff_map,\n                                         &dst.field, tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    error = mf_check_dst(&dst, NULL);\n    if (error) {\n        return error;\n    }\n\n    /* Reject 'narl' if a bit numbered 'n_bits' or higher is set to 1 in\n     * narl->value. */\n    if (dst.n_bits < 64 && ntohll(narl->value) >> dst.n_bits) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    struct ofpact_set_field *sf = ofpact_put_reg_load(out, dst.field, NULL,\n                                                      NULL);\n    bitwise_put(ntohll(narl->value),\n                sf->value, dst.field->n_bytes, dst.ofs,\n                dst.n_bits);\n    bitwise_put(UINT64_MAX,\n                ofpact_set_field_mask(sf), dst.field->n_bytes, dst.ofs,\n                dst.n_bits);\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_REG_LOAD2(const struct ext_action_header *eah,\n                           enum ofp_version ofp_version OVS_UNUSED,\n                           const struct vl_mff_map *vl_mff_map,\n                           uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(eah, ntohs(eah->len));\n    ofpbuf_pull(&b, OBJECT_OFFSETOF(eah, pad));\n\n    union mf_value value, mask;\n    const struct mf_field *field;\n    enum ofperr error;\n    error = mf_vl_mff_nx_pull_entry(&b, vl_mff_map, &field, &value, &mask,\n                                    tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    if (!is_all_zeros(b.data, b.size)) {\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n\n    if (!field->writable) {\n        VLOG_WARN_RL(&rl, \"destination field %s is not writable\", field->name);\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n\n    /* Put value and mask. */\n    ofpact_put_reg_load2(out, field, &value, &mask);\n    return 0;\n}\n\nstatic void\nput_set_field(struct ofpbuf *openflow, enum ofp_version ofp_version,\n              enum mf_field_id field, uint64_t value_)\n{\n    struct ofp12_action_set_field *oasf OVS_UNUSED;\n    int n_bytes = mf_from_id(field)->n_bytes;\n    size_t start_ofs = openflow->size;\n    union mf_value value;\n\n    value.be64 = htonll(value_ << (8 * (8 - n_bytes)));\n\n    oasf = put_OFPAT12_SET_FIELD(openflow);\n    openflow->size = openflow->size - sizeof oasf->pad;\n    nx_put_entry(openflow, mf_from_id(field), ofp_version, &value, NULL);\n    pad_ofpat(openflow, start_ofs);\n}\n\nstatic void\nput_reg_load(struct ofpbuf *openflow,\n             const struct mf_subfield *dst, uint64_t value)\n{\n    ovs_assert(dst->n_bits <= 64);\n\n    struct nx_action_reg_load *narl = put_NXAST_REG_LOAD(openflow);\n    narl->ofs_nbits = nxm_encode_ofs_nbits(dst->ofs, dst->n_bits);\n    narl->dst = htonl(nxm_header_from_mff(dst->field));\n    narl->value = htonll(value);\n}\n\nstatic bool\nnext_load_segment(const struct ofpact_set_field *sf,\n                  struct mf_subfield *dst, uint64_t *value)\n{\n    int n_bits = sf->field->n_bits;\n    int n_bytes = sf->field->n_bytes;\n    int start = dst->ofs + dst->n_bits;\n\n    if (start < n_bits) {\n        dst->field = sf->field;\n        dst->ofs = bitwise_scan(ofpact_set_field_mask(sf), n_bytes, 1, start,\n                                n_bits);\n        if (dst->ofs < n_bits) {\n            dst->n_bits = bitwise_scan(ofpact_set_field_mask(sf), n_bytes, 0,\n                                       dst->ofs + 1,\n                                       MIN(dst->ofs + 64, n_bits)) - dst->ofs;\n            *value = bitwise_get(sf->value, n_bytes, dst->ofs, dst->n_bits);\n            return true;\n        }\n    }\n    return false;\n}\n\n/* Convert 'sf' to a series of REG_LOADs. */\nstatic void\nset_field_to_nxast(const struct ofpact_set_field *sf, struct ofpbuf *openflow)\n{\n    /* If 'sf' cannot be encoded as NXAST_REG_LOAD because it requires an\n     * experimenter OXM or is variable length (or if it came in as\n     * NXAST_REG_LOAD2), encode as NXAST_REG_LOAD2.  Otherwise use\n     * NXAST_REG_LOAD, which is backward compatible. */\n    if (sf->ofpact.raw == NXAST_RAW_REG_LOAD2\n        || !mf_nxm_header(sf->field->id) || sf->field->variable_len) {\n        struct ext_action_header *eah OVS_UNUSED;\n        size_t start_ofs = openflow->size;\n\n        eah = put_NXAST_REG_LOAD2(openflow);\n        openflow->size = openflow->size - sizeof eah->pad;\n        nx_put_entry(openflow, sf->field, 0, sf->value,\n                     ofpact_set_field_mask(sf));\n        pad_ofpat(openflow, start_ofs);\n    } else {\n        struct mf_subfield dst;\n        uint64_t value;\n\n        dst.ofs = dst.n_bits = 0;\n        while (next_load_segment(sf, &dst, &value)) {\n            put_reg_load(openflow, &dst, value);\n        }\n    }\n}\n\n/* Convert 'sf', which must set an entire field, to standard OpenFlow 1.0/1.1\n * actions, if we can, falling back to Nicira extensions if we must.\n *\n * We check only meta-flow types that can appear within set field actions and\n * that have a mapping to compatible action types.  These struct mf_field\n * definitions have a defined OXM or NXM header value and specify the field as\n * writable. */\nstatic void\nset_field_to_legacy_openflow(const struct ofpact_set_field *sf,\n                             enum ofp_version ofp_version,\n                             struct ofpbuf *out)\n{\n    switch ((int) sf->field->id) {\n    case MFF_VLAN_TCI: {\n        ovs_be16 tci = sf->value->be16;\n        bool cfi = (tci & htons(VLAN_CFI)) != 0;\n        uint16_t vid = vlan_tci_to_vid(tci);\n        uint8_t pcp = vlan_tci_to_pcp(tci);\n\n        if (ofp_version < OFP11_VERSION) {\n            /* NXM_OF_VLAN_TCI to OpenFlow 1.0 mapping:\n             *\n             * If CFI=1, Add or modify VLAN VID & PCP.\n             * If CFI=0, strip VLAN header, if any.\n             */\n            if (cfi) {\n                put_OFPAT10_SET_VLAN_VID(out, vid);\n                put_OFPAT10_SET_VLAN_PCP(out, pcp);\n            } else {\n                put_OFPAT10_STRIP_VLAN(out);\n            }\n        } else {\n            /* NXM_OF_VLAN_TCI to OpenFlow 1.1 mapping:\n             *\n             * If CFI=1, Add or modify VLAN VID & PCP.\n             *    OpenFlow 1.1 set actions only apply if the packet\n             *    already has VLAN tags.  To be sure that is the case\n             *    we have to push a VLAN header.  As we do not support\n             *    multiple layers of VLANs, this is a no-op, if a VLAN\n             *    header already exists.  This may backfire, however,\n             *    when we start supporting multiple layers of VLANs.\n             * If CFI=0, strip VLAN header, if any.\n             */\n            if (cfi) {\n                /* Push a VLAN tag, if one was not seen at action validation\n                 * time. */\n                if (!sf->flow_has_vlan) {\n                    put_OFPAT11_PUSH_VLAN(out, htons(ETH_TYPE_VLAN_8021Q));\n                }\n                put_OFPAT11_SET_VLAN_VID(out, vid);\n                put_OFPAT11_SET_VLAN_PCP(out, pcp);\n            } else {\n                /* If the flow did not match on vlan, we have no way of\n                 * knowing if the vlan tag exists, so we must POP just to be\n                 * sure. */\n                put_OFPAT11_POP_VLAN(out);\n            }\n        }\n        break;\n    }\n\n    case MFF_VLAN_VID: {\n        uint16_t vid = ntohs(sf->value->be16) & VLAN_VID_MASK;\n        if (ofp_version == OFP10_VERSION) {\n            put_OFPAT10_SET_VLAN_VID(out, vid);\n        } else {\n            put_OFPAT11_SET_VLAN_VID(out, vid);\n        }\n        break;\n    }\n\n    case MFF_VLAN_PCP:\n        if (ofp_version == OFP10_VERSION) {\n            put_OFPAT10_SET_VLAN_PCP(out, sf->value->u8);\n        } else {\n            put_OFPAT11_SET_VLAN_PCP(out, sf->value->u8);\n        }\n        break;\n\n    case MFF_ETH_SRC:\n        put_OFPAT_SET_DL_SRC(out, ofp_version)->dl_addr = sf->value->mac;\n        break;\n\n    case MFF_ETH_DST:\n        put_OFPAT_SET_DL_DST(out, ofp_version)->dl_addr = sf->value->mac;\n        break;\n\n    case MFF_IPV4_SRC:\n        put_OFPAT_SET_NW_SRC(out, ofp_version, sf->value->be32);\n        break;\n\n    case MFF_IPV4_DST:\n        put_OFPAT_SET_NW_DST(out, ofp_version, sf->value->be32);\n        break;\n\n    case MFF_IP_DSCP:\n        put_OFPAT_SET_NW_TOS(out, ofp_version, sf->value->u8);\n        break;\n\n    case MFF_IP_DSCP_SHIFTED:\n        put_OFPAT_SET_NW_TOS(out, ofp_version, sf->value->u8 << 2);\n        break;\n\n    case MFF_IP_ECN: {\n        struct ofpact_ecn ip_ecn = { .ecn = sf->value->u8 };\n        encode_SET_IP_ECN(&ip_ecn, ofp_version, out);\n        break;\n    }\n\n    case MFF_TCP_SRC:\n    case MFF_UDP_SRC:\n        put_OFPAT_SET_TP_SRC(out, sf->value->be16);\n        break;\n\n    case MFF_TCP_DST:\n    case MFF_UDP_DST:\n        put_OFPAT_SET_TP_DST(out, sf->value->be16);\n        break;\n\n    default:\n        set_field_to_nxast(sf, out);\n        break;\n    }\n}\n\nstatic void\nset_field_to_set_field(const struct ofpact_set_field *sf,\n                       enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    struct ofp12_action_set_field *oasf OVS_UNUSED;\n    size_t start_ofs = out->size;\n\n    oasf = put_OFPAT12_SET_FIELD(out);\n    out->size = out->size - sizeof oasf->pad;\n    nx_put_entry(out, sf->field, ofp_version, sf->value,\n                 ofpact_set_field_mask(sf));\n    pad_ofpat(out, start_ofs);\n}\n\nstatic void\nencode_SET_FIELD(const struct ofpact_set_field *sf,\n                 enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version >= OFP15_VERSION) {\n        /* OF1.5+ only has Set-Field (reg_load is redundant so we drop it\n         * entirely). */\n        set_field_to_set_field(sf, ofp_version, out);\n    } else if (sf->ofpact.raw == NXAST_RAW_REG_LOAD ||\n               sf->ofpact.raw == NXAST_RAW_REG_LOAD2) {\n        /* It came in as reg_load, send it out the same way. */\n        set_field_to_nxast(sf, out);\n    } else if (ofp_version < OFP12_VERSION) {\n        /* OpenFlow 1.0 and 1.1 don't have Set-Field. */\n        set_field_to_legacy_openflow(sf, ofp_version, out);\n    } else if (is_all_ones(ofpact_set_field_mask(sf), sf->field->n_bytes)) {\n        /* We're encoding to OpenFlow 1.2, 1.3, or 1.4.  The action sets an\n         * entire field, so encode it as OFPAT_SET_FIELD. */\n        set_field_to_set_field(sf, ofp_version, out);\n    } else {\n        /* We're encoding to OpenFlow 1.2, 1.3, or 1.4.  The action cannot be\n         * encoded as OFPAT_SET_FIELD because it does not set an entire field,\n         * so encode it as reg_load. */\n        set_field_to_nxast(sf, out);\n    }\n}\n\n/* Parses the input argument 'arg' into the key, value, and delimiter\n * components that are common across the reg_load and set_field action format.\n *\n * With an argument like \"1->metadata\", sets the following pointers to\n * point within 'arg':\n * key: \"metadata\"\n * value: \"1\"\n * delim: \"->\"\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nset_field_split_str(char *arg, char **key, char **value, char **delim)\n{\n    char *value_end;\n\n    *value = arg;\n    value_end = strstr(arg, \"->\");\n    *key = value_end + strlen(\"->\");\n    if (delim) {\n        *delim = value_end;\n    }\n\n    if (!value_end) {\n        return xasprintf(\"%s: missing `->'\", arg);\n    }\n    if (strlen(value_end) <= strlen(\"->\")) {\n        return xasprintf(\"%s: missing field name following `->'\", arg);\n    }\n\n    return NULL;\n}\n\n/* Parses a \"set_field\" action with argument 'arg', appending the parsed\n * action to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nset_field_parse__(char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols)\n{\n    char *value;\n    char *delim;\n    char *key;\n    const struct mf_field *mf;\n    union mf_value sf_value, sf_mask;\n    char *error;\n\n    error = set_field_split_str(arg, &key, &value, &delim);\n    if (error) {\n        return error;\n    }\n\n    mf = mf_from_name(key);\n    if (!mf) {\n        return xasprintf(\"%s is not a valid OXM field name\", key);\n    }\n    if (!mf->writable) {\n        return xasprintf(\"%s is read-only\", key);\n    }\n\n    delim[0] = '\\0';\n    error = mf_parse(mf, value, &sf_value, &sf_mask);\n    if (error) {\n        return error;\n    }\n\n    if (!mf_is_value_valid(mf, &sf_value)) {\n        return xasprintf(\"%s is not a valid value for field %s\", value, key);\n    }\n\n    *usable_protocols &= mf->usable_protocols_exact;\n\n    ofpact_put_set_field(ofpacts, mf, &sf_value, &sf_mask);\n    return NULL;\n}\n\n/* Parses 'arg' as the argument to a \"set_field\" action, and appends such an\n * action to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_FIELD(const char *arg, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols)\n{\n    char *copy = xstrdup(arg);\n    char *error = set_field_parse__(copy, ofpacts, usable_protocols);\n    free(copy);\n    return error;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_reg_load(char *arg, struct ofpbuf *ofpacts)\n{\n    struct mf_subfield dst;\n    char *key, *value_str;\n    union mf_value value;\n    char *error;\n\n    error = set_field_split_str(arg, &key, &value_str, NULL);\n    if (error) {\n        return error;\n    }\n\n    error = mf_parse_subfield(&dst, key);\n    if (error) {\n        return error;\n    }\n\n    if (parse_int_string(value_str, (uint8_t *)&value, dst.field->n_bytes,\n                         &key)) {\n        return xasprintf(\"%s: cannot parse integer value\", arg);\n    }\n\n    if (!bitwise_is_all_zeros(&value, dst.field->n_bytes, dst.n_bits,\n                              dst.field->n_bytes * 8 - dst.n_bits)) {\n        struct ds ds;\n\n        ds_init(&ds);\n        mf_format(dst.field, &value, NULL, &ds);\n        error = xasprintf(\"%s: value %s does not fit into %d bits\",\n                          arg, ds_cstr(&ds), dst.n_bits);\n        ds_destroy(&ds);\n        return error;\n    }\n\n    struct ofpact_set_field *sf = ofpact_put_reg_load(ofpacts, dst.field, NULL,\n                                                      NULL);\n\n    bitwise_copy(&value, dst.field->n_bytes, 0, sf->value,\n                 dst.field->n_bytes, dst.ofs, dst.n_bits);\n    bitwise_one(ofpact_set_field_mask(sf), dst.field->n_bytes, dst.ofs,\n                dst.n_bits);\n    return NULL;\n}\n\nstatic void\nformat_SET_FIELD(const struct ofpact_set_field *a, struct ds *s)\n{\n    if (a->ofpact.raw == NXAST_RAW_REG_LOAD) {\n        struct mf_subfield dst;\n        uint64_t value;\n\n        dst.ofs = dst.n_bits = 0;\n        while (next_load_segment(a, &dst, &value)) {\n            ds_put_format(s, \"%sload:%s%#\"PRIx64\"%s->%s\",\n                          colors.special, colors.end, value,\n                          colors.special, colors.end);\n            mf_format_subfield(&dst, s);\n            ds_put_char(s, ',');\n        }\n        ds_chomp(s, ',');\n    } else {\n        ds_put_format(s, \"%sset_field:%s\", colors.special, colors.end);\n        mf_format(a->field, a->value, ofpact_set_field_mask(a), s);\n        ds_put_format(s, \"%s->%s%s\",\n                      colors.special, colors.end, a->field->name);\n    }\n}\n\n/* Appends an OFPACT_SET_FIELD ofpact with enough space for the value and mask\n * for the 'field' to 'ofpacts' and returns it.  Fills in the value from\n * 'value', if non-NULL, and mask from 'mask' if non-NULL.  If 'value' is\n * non-NULL and 'mask' is NULL, an all-ones mask will be filled in. */\nstruct ofpact_set_field *\nofpact_put_set_field(struct ofpbuf *ofpacts, const struct mf_field *field,\n                     const void *value, const void *mask)\n{\n    struct ofpact_set_field *sf = ofpact_put_SET_FIELD(ofpacts);\n    sf->field = field;\n\n    /* Fill in the value and mask if given, otherwise put zeroes so that the\n     * caller may fill in the value and mask itself. */\n    if (value) {\n        ofpbuf_put_uninit(ofpacts, 2 * field->n_bytes);\n        sf = ofpacts->header;\n        memcpy(sf->value, value, field->n_bytes);\n        if (mask) {\n            memcpy(ofpact_set_field_mask(sf), mask, field->n_bytes);\n        } else {\n            memset(ofpact_set_field_mask(sf), 0xff, field->n_bytes);\n        }\n    } else {\n        ofpbuf_put_zeros(ofpacts, 2 * field->n_bytes);\n        sf = ofpacts->header;\n    }\n    /* Update length. */\n    ofpact_finish_SET_FIELD(ofpacts, &sf);\n\n    return sf;\n}\n\n/* Appends an OFPACT_SET_FIELD ofpact to 'ofpacts' and returns it.  The ofpact\n * is marked such that, if possible, it will be translated to OpenFlow as\n * NXAST_REG_LOAD extension actions rather than OFPAT_SET_FIELD, either because\n * that was the way that the action was expressed when it came into OVS or for\n * backward compatibility. */\nstruct ofpact_set_field *\nofpact_put_reg_load(struct ofpbuf *ofpacts, const struct mf_field *field,\n                    const void *value, const void *mask)\n{\n    struct ofpact_set_field *sf = ofpact_put_set_field(ofpacts, field, value,\n                                                       mask);\n    sf->ofpact.raw = NXAST_RAW_REG_LOAD;\n\n    return sf;\n}\n\nstruct ofpact_set_field *\nofpact_put_reg_load2(struct ofpbuf *ofpacts, const struct mf_field *field,\n                     const void *value, const void *mask)\n{\n    struct ofpact_set_field *sf = ofpact_put_set_field(ofpacts, field, value,\n                                                       mask);\n    sf->ofpact.raw = NXAST_RAW_REG_LOAD2;\n\n    return sf;\n}\n\n\f\n/* Action structure for NXAST_STACK_PUSH and NXAST_STACK_POP.\n *\n * Pushes (or pops) field[offset: offset + n_bits] to (or from)\n * top of the stack.\n */\nstruct nx_action_stack {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 16. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_STACK_PUSH or NXAST_STACK_POP. */\n    ovs_be16 offset;                /* Bit offset into the field. */\n    /* Followed by:\n     * - OXM/NXM header for field to push or pop (4 or 8 bytes).\n     * - ovs_be16 'n_bits', the number of bits to extract from the field.\n     * - Enough 0-bytes to pad out the action to 24 bytes. */\n    uint8_t pad[12];                /* See above. */\n};\nOFP_ASSERT(sizeof(struct nx_action_stack) == 24);\n\nstatic enum ofperr\ndecode_stack_action(const struct nx_action_stack *nasp,\n                    const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap,\n                    struct ofpact_stack *stack_action)\n{\n    enum ofperr error;\n    stack_action->subfield.ofs = ntohs(nasp->offset);\n\n    struct ofpbuf b = ofpbuf_const_initializer(nasp, sizeof *nasp);\n    ofpbuf_pull(&b, OBJECT_OFFSETOF(nasp, pad));\n    error  = mf_vl_mff_nx_pull_header(&b, vl_mff_map,\n                                      &stack_action->subfield.field, NULL,\n                                      tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    stack_action->subfield.n_bits = ntohs(*(const ovs_be16 *) b.data);\n    ofpbuf_pull(&b, 2);\n    if (!is_all_zeros(b.data, b.size)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_STACK_PUSH(const struct nx_action_stack *nasp,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            const struct vl_mff_map *vl_mff_map,\n                            uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpact_stack *push = ofpact_put_STACK_PUSH(ofpacts);\n    enum ofperr error = decode_stack_action(nasp, vl_mff_map, tlv_bitmap,\n                                            push);\n    return error ? error : nxm_stack_push_check(push, NULL);\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_STACK_POP(const struct nx_action_stack *nasp,\n                           enum ofp_version ofp_version OVS_UNUSED,\n                           const struct vl_mff_map *vl_mff_map,\n                           uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpact_stack *pop = ofpact_put_STACK_POP(ofpacts);\n    enum ofperr error = decode_stack_action(nasp, vl_mff_map, tlv_bitmap,\n                                            pop);\n    return error ? error : nxm_stack_pop_check(pop, NULL);\n}\n\nstatic void\nencode_STACK_op(const struct ofpact_stack *stack_action,\n                struct nx_action_stack *nasp)\n{\n    struct ofpbuf b;\n    ovs_be16 n_bits;\n\n    nasp->offset = htons(stack_action->subfield.ofs);\n\n    ofpbuf_use_stack(&b, nasp, ntohs(nasp->len));\n    ofpbuf_put_uninit(&b, OBJECT_OFFSETOF(nasp, pad));\n    nx_put_mff_header(&b, stack_action->subfield.field, 0, false);\n    n_bits = htons(stack_action->subfield.n_bits);\n    ofpbuf_put(&b, &n_bits, sizeof n_bits);\n}\n\nstatic void\nencode_STACK_PUSH(const struct ofpact_stack *stack,\n                  enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    encode_STACK_op(stack, put_NXAST_STACK_PUSH(out));\n}\n\nstatic void\nencode_STACK_POP(const struct ofpact_stack *stack,\n                 enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    encode_STACK_op(stack, put_NXAST_STACK_POP(out));\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_STACK_PUSH(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return nxm_parse_stack_action(ofpact_put_STACK_PUSH(ofpacts), arg);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_STACK_POP(char *arg, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return nxm_parse_stack_action(ofpact_put_STACK_POP(ofpacts), arg);\n}\n\nstatic void\nformat_STACK_PUSH(const struct ofpact_stack *a, struct ds *s)\n{\n    nxm_format_stack_push(a, s);\n}\n\nstatic void\nformat_STACK_POP(const struct ofpact_stack *a, struct ds *s)\n{\n    nxm_format_stack_pop(a, s);\n}\n\f\n/* Action structure for NXAST_DEC_TTL_CNT_IDS.\n *\n * If the packet is not IPv4 or IPv6, does nothing.  For IPv4 or IPv6, if the\n * TTL or hop limit is at least 2, decrements it by 1.  Otherwise, if TTL or\n * hop limit is 0 or 1, sends a packet-in to the controllers with each of the\n * 'n_controllers' controller IDs specified in 'cnt_ids'.\n *\n * (This differs from NXAST_DEC_TTL in that for NXAST_DEC_TTL the packet-in is\n * sent only to controllers with id 0.)\n */\nstruct nx_action_cnt_ids {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* Length including slaves. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_DEC_TTL_CNT_IDS. */\n\n    ovs_be16 n_controllers;     /* Number of controllers. */\n    uint8_t zeros[4];           /* Must be zero. */\n\n    /* Followed by 1 or more controller ids.\n     *\n     * uint16_t cnt_ids[];        // Controller ids.\n     * uint8_t pad[];           // Must be 0 to 8-byte align cnt_ids[].\n     */\n};\nOFP_ASSERT(sizeof(struct nx_action_cnt_ids) == 16);\n\nstatic enum ofperr\ndecode_OFPAT_RAW_DEC_NW_TTL(struct ofpbuf *out)\n{\n    uint16_t id = 0;\n    struct ofpact_cnt_ids *ids;\n    enum ofperr error = 0;\n\n    ids = ofpact_put_DEC_TTL(out);\n    ids->n_controllers = 1;\n    ofpbuf_put(out, &id, sizeof id);\n    ids = out->header;\n    ofpact_finish_DEC_TTL(out, &ids);\n    return error;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_DEC_TTL_CNT_IDS(const struct nx_action_cnt_ids *nac_ids,\n                                 enum ofp_version ofp_version OVS_UNUSED,\n                                 struct ofpbuf *out)\n{\n    struct ofpact_cnt_ids *ids;\n    size_t ids_size;\n    int i;\n\n    ids = ofpact_put_DEC_TTL(out);\n    ids->ofpact.raw = NXAST_RAW_DEC_TTL_CNT_IDS;\n    ids->n_controllers = ntohs(nac_ids->n_controllers);\n    ids_size = ntohs(nac_ids->len) - sizeof *nac_ids;\n\n    if (!is_all_zeros(nac_ids->zeros, sizeof nac_ids->zeros)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    if (ids_size < ids->n_controllers * sizeof(ovs_be16)) {\n        VLOG_WARN_RL(&rl, \"Nicira action dec_ttl_cnt_ids only has %\"PRIuSIZE\" \"\n                     \"bytes allocated for controller ids.  %\"PRIuSIZE\" bytes \"\n                     \"are required for %\"PRIu16\" controllers.\",\n                     ids_size, ids->n_controllers * sizeof(ovs_be16),\n                     ids->n_controllers);\n        return OFPERR_OFPBAC_BAD_LEN;\n    }\n\n    for (i = 0; i < ids->n_controllers; i++) {\n        uint16_t id = ntohs(((ovs_be16 *)(nac_ids + 1))[i]);\n        ofpbuf_put(out, &id, sizeof id);\n        ids = out->header;\n    }\n\n    ofpact_finish_DEC_TTL(out, &ids);\n\n    return 0;\n}\n\nstatic void\nencode_DEC_TTL(const struct ofpact_cnt_ids *dec_ttl,\n               enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (dec_ttl->ofpact.raw == NXAST_RAW_DEC_TTL_CNT_IDS\n        || dec_ttl->n_controllers != 1\n        || dec_ttl->cnt_ids[0] != 0) {\n        struct nx_action_cnt_ids *nac_ids = put_NXAST_DEC_TTL_CNT_IDS(out);\n        int ids_len = ROUND_UP(2 * dec_ttl->n_controllers, OFP_ACTION_ALIGN);\n        ovs_be16 *ids;\n        size_t i;\n\n        nac_ids->len = htons(ntohs(nac_ids->len) + ids_len);\n        nac_ids->n_controllers = htons(dec_ttl->n_controllers);\n\n        ids = ofpbuf_put_zeros(out, ids_len);\n        for (i = 0; i < dec_ttl->n_controllers; i++) {\n            ids[i] = htons(dec_ttl->cnt_ids[i]);\n        }\n    } else {\n        put_OFPAT_DEC_NW_TTL(out, ofp_version);\n    }\n}\n\nstatic void\nparse_noargs_dec_ttl(struct ofpbuf *ofpacts)\n{\n    struct ofpact_cnt_ids *ids;\n    uint16_t id = 0;\n\n    ofpact_put_DEC_TTL(ofpacts);\n    ofpbuf_put(ofpacts, &id, sizeof id);\n    ids = ofpacts->header;\n    ids->n_controllers++;\n    ofpact_finish_DEC_TTL(ofpacts, &ids);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_DEC_TTL(char *arg, struct ofpbuf *ofpacts,\n              enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    if (*arg == '\\0') {\n        parse_noargs_dec_ttl(ofpacts);\n    } else {\n        struct ofpact_cnt_ids *ids;\n        char *cntr;\n\n        ids = ofpact_put_DEC_TTL(ofpacts);\n        ids->ofpact.raw = NXAST_RAW_DEC_TTL_CNT_IDS;\n        for (cntr = strtok_r(arg, \", \", &arg); cntr != NULL;\n             cntr = strtok_r(NULL, \", \", &arg)) {\n            uint16_t id = atoi(cntr);\n\n            ofpbuf_put(ofpacts, &id, sizeof id);\n            ids = ofpacts->header;\n            ids->n_controllers++;\n        }\n        if (!ids->n_controllers) {\n            return xstrdup(\"dec_ttl_cnt_ids: expected at least one controller \"\n                           \"id.\");\n        }\n        ofpact_finish_DEC_TTL(ofpacts, &ids);\n    }\n    return NULL;\n}\n\nstatic void\nformat_DEC_TTL(const struct ofpact_cnt_ids *a, struct ds *s)\n{\n    size_t i;\n\n    ds_put_format(s, \"%sdec_ttl%s\", colors.paren, colors.end);\n    if (a->ofpact.raw == NXAST_RAW_DEC_TTL_CNT_IDS) {\n        ds_put_format(s, \"%s(%s\", colors.paren, colors.end);\n        for (i = 0; i < a->n_controllers; i++) {\n            if (i) {\n                ds_put_cstr(s, \",\");\n            }\n            ds_put_format(s, \"%\"PRIu16, a->cnt_ids[i]);\n        }\n        ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n    }\n}\n\f\n/* Set MPLS label actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_MPLS_LABEL(ovs_be32 label,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    ofpact_put_SET_MPLS_LABEL(out)->label = label;\n    return 0;\n}\n\nstatic void\nencode_SET_MPLS_LABEL(const struct ofpact_mpls_label *label,\n                      enum ofp_version ofp_version,\n                                  struct ofpbuf *out)\n{\n    if (ofp_version < OFP12_VERSION) {\n        put_OFPAT_SET_MPLS_LABEL(out, ofp_version, label->label);\n    } else {\n        put_set_field(out, ofp_version, MFF_MPLS_LABEL, ntohl(label->label));\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_MPLS_LABEL(char *arg, struct ofpbuf *ofpacts,\n                     enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_mpls_label *mpls_label = ofpact_put_SET_MPLS_LABEL(ofpacts);\n    if (*arg == '\\0') {\n        return xstrdup(\"set_mpls_label: expected label.\");\n    }\n\n    mpls_label->label = htonl(atoi(arg));\n    return NULL;\n}\n\nstatic void\nformat_SET_MPLS_LABEL(const struct ofpact_mpls_label *a, struct ds *s)\n{\n    ds_put_format(s, \"%sset_mpls_label(%s%\"PRIu32\"%s)%s\",\n                  colors.paren, colors.end, ntohl(a->label),\n                  colors.paren, colors.end);\n}\n\f\n/* Set MPLS TC actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_MPLS_TC(uint8_t tc,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             struct ofpbuf *out)\n{\n    ofpact_put_SET_MPLS_TC(out)->tc = tc;\n    return 0;\n}\n\nstatic void\nencode_SET_MPLS_TC(const struct ofpact_mpls_tc *tc,\n                   enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version < OFP12_VERSION) {\n        put_OFPAT_SET_MPLS_TC(out, ofp_version, tc->tc);\n    } else {\n        put_set_field(out, ofp_version, MFF_MPLS_TC, tc->tc);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_MPLS_TC(char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_mpls_tc *mpls_tc = ofpact_put_SET_MPLS_TC(ofpacts);\n\n    if (*arg == '\\0') {\n        return xstrdup(\"set_mpls_tc: expected tc.\");\n    }\n\n    mpls_tc->tc = atoi(arg);\n    return NULL;\n}\n\nstatic void\nformat_SET_MPLS_TC(const struct ofpact_mpls_tc *a, struct ds *s)\n{\n    ds_put_format(s, \"%sset_mpls_ttl(%s%\"PRIu8\"%s)%s\",\n                  colors.paren, colors.end, a->tc,\n                  colors.paren, colors.end);\n}\n\f\n/* Set MPLS TTL actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_MPLS_TTL(uint8_t ttl,\n                              enum ofp_version ofp_version OVS_UNUSED,\n                              struct ofpbuf *out)\n{\n    ofpact_put_SET_MPLS_TTL(out)->ttl = ttl;\n    return 0;\n}\n\nstatic void\nencode_SET_MPLS_TTL(const struct ofpact_mpls_ttl *ttl,\n                    enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    put_OFPAT_SET_MPLS_TTL(out, ofp_version, ttl->ttl);\n}\n\n/* Parses 'arg' as the argument to a \"set_mpls_ttl\" action, and appends such an\n * action to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_MPLS_TTL(char *arg, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_mpls_ttl *mpls_ttl = ofpact_put_SET_MPLS_TTL(ofpacts);\n\n    if (*arg == '\\0') {\n        return xstrdup(\"set_mpls_ttl: expected ttl.\");\n    }\n\n    mpls_ttl->ttl = atoi(arg);\n    return NULL;\n}\n\nstatic void\nformat_SET_MPLS_TTL(const struct ofpact_mpls_ttl *a, struct ds *s)\n{\n    ds_put_format(s, \"%sset_mpls_ttl(%s%\"PRIu8\"%s)%s\",\n                  colors.paren, colors.end, a->ttl,\n                  colors.paren, colors.end);\n}\n\f\n/* Decrement MPLS TTL actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_DEC_MPLS_TTL(struct ofpbuf *out)\n{\n    ofpact_put_DEC_MPLS_TTL(out);\n    return 0;\n}\n\nstatic void\nencode_DEC_MPLS_TTL(const struct ofpact_null *null OVS_UNUSED,\n                    enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    put_OFPAT_DEC_MPLS_TTL(out, ofp_version);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_DEC_MPLS_TTL(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_DEC_MPLS_TTL(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_DEC_MPLS_TTL(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%sdec_mpls_ttl%s\", colors.value, colors.end);\n}\n\f\n/* Push MPLS label action. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_PUSH_MPLS(ovs_be16 ethertype,\n                           enum ofp_version ofp_version OVS_UNUSED,\n                           struct ofpbuf *out)\n{\n    struct ofpact_push_mpls *oam;\n\n    if (!eth_type_mpls(ethertype)) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n    oam = ofpact_put_PUSH_MPLS(out);\n    oam->ethertype = ethertype;\n\n    return 0;\n}\n\nstatic void\nencode_PUSH_MPLS(const struct ofpact_push_mpls *push_mpls,\n                 enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    put_OFPAT_PUSH_MPLS(out, ofp_version, push_mpls->ethertype);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_PUSH_MPLS(char *arg, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint16_t ethertype;\n    char *error;\n\n    error = str_to_u16(arg, \"push_mpls\", &ethertype);\n    if (!error) {\n        ofpact_put_PUSH_MPLS(ofpacts)->ethertype = htons(ethertype);\n    }\n    return error;\n}\n\nstatic void\nformat_PUSH_MPLS(const struct ofpact_push_mpls *a, struct ds *s)\n{\n    ds_put_format(s, \"%spush_mpls:%s0x%04\"PRIx16,\n                  colors.param, colors.end, ntohs(a->ethertype));\n}\n\f\n/* Pop MPLS label action. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_POP_MPLS(ovs_be16 ethertype,\n                          enum ofp_version ofp_version OVS_UNUSED,\n                          struct ofpbuf *out)\n{\n    ofpact_put_POP_MPLS(out)->ethertype = ethertype;\n    return 0;\n}\n\nstatic void\nencode_POP_MPLS(const struct ofpact_pop_mpls *pop_mpls,\n                enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    put_OFPAT_POP_MPLS(out, ofp_version, pop_mpls->ethertype);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_POP_MPLS(char *arg, struct ofpbuf *ofpacts,\n                    enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint16_t ethertype;\n    char *error;\n\n    error = str_to_u16(arg, \"pop_mpls\", &ethertype);\n    if (!error) {\n        ofpact_put_POP_MPLS(ofpacts)->ethertype = htons(ethertype);\n    }\n    return error;\n}\n\nstatic void\nformat_POP_MPLS(const struct ofpact_pop_mpls *a, struct ds *s)\n{\n    ds_put_format(s, \"%spop_mpls:%s0x%04\"PRIx16,\n                  colors.param, colors.end, ntohs(a->ethertype));\n}\n\f\n/* Set tunnel ID actions. */\n\nstatic enum ofperr\ndecode_NXAST_RAW_SET_TUNNEL(uint32_t tun_id,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    struct ofpact_tunnel *tunnel = ofpact_put_SET_TUNNEL(out);\n    tunnel->ofpact.raw = NXAST_RAW_SET_TUNNEL;\n    tunnel->tun_id = tun_id;\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_SET_TUNNEL64(uint64_t tun_id,\n                              enum ofp_version ofp_version OVS_UNUSED,\n                              struct ofpbuf *out)\n{\n    struct ofpact_tunnel *tunnel = ofpact_put_SET_TUNNEL(out);\n    tunnel->ofpact.raw = NXAST_RAW_SET_TUNNEL64;\n    tunnel->tun_id = tun_id;\n    return 0;\n}\n\nstatic void\nencode_SET_TUNNEL(const struct ofpact_tunnel *tunnel,\n                  enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    uint64_t tun_id = tunnel->tun_id;\n\n    if (ofp_version < OFP12_VERSION) {\n        if (tun_id <= UINT32_MAX\n            && tunnel->ofpact.raw != NXAST_RAW_SET_TUNNEL64) {\n            put_NXAST_SET_TUNNEL(out, tun_id);\n        } else {\n            put_NXAST_SET_TUNNEL64(out, tun_id);\n        }\n    } else {\n        put_set_field(out, ofp_version, MFF_TUN_ID, tun_id);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_set_tunnel(char *arg, struct ofpbuf *ofpacts,\n                 enum ofp_raw_action_type raw)\n{\n    struct ofpact_tunnel *tunnel;\n\n    tunnel = ofpact_put_SET_TUNNEL(ofpacts);\n    tunnel->ofpact.raw = raw;\n    return str_to_u64(arg, &tunnel->tun_id);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_TUNNEL(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return parse_set_tunnel(arg, ofpacts, NXAST_RAW_SET_TUNNEL);\n}\n\nstatic void\nformat_SET_TUNNEL(const struct ofpact_tunnel *a, struct ds *s)\n{\n    ds_put_format(s, \"%sset_tunnel%s:%s%#\"PRIx64, colors.param,\n                  (a->tun_id > UINT32_MAX\n                   || a->ofpact.raw == NXAST_RAW_SET_TUNNEL64 ? \"64\" : \"\"),\n                  colors.end, a->tun_id);\n}\n\f\n/* Set queue action. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_QUEUE(uint32_t queue_id,\n                           enum ofp_version ofp_version OVS_UNUSED,\n                           struct ofpbuf *out)\n{\n    ofpact_put_SET_QUEUE(out)->queue_id = queue_id;\n    return 0;\n}\n\nstatic void\nencode_SET_QUEUE(const struct ofpact_queue *queue,\n                 enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    put_OFPAT_SET_QUEUE(out, ofp_version, queue->queue_id);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_QUEUE(char *arg, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_u32(arg, &ofpact_put_SET_QUEUE(ofpacts)->queue_id);\n}\n\nstatic void\nformat_SET_QUEUE(const struct ofpact_queue *a, struct ds *s)\n{\n    ds_put_format(s, \"%sset_queue:%s%\"PRIu32,\n                  colors.param, colors.end, a->queue_id);\n}\n\f\n/* Pop queue action. */\n\nstatic enum ofperr\ndecode_NXAST_RAW_POP_QUEUE(struct ofpbuf *out)\n{\n    ofpact_put_POP_QUEUE(out);\n    return 0;\n}\n\nstatic void\nencode_POP_QUEUE(const struct ofpact_null *null OVS_UNUSED,\n                 enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    put_NXAST_POP_QUEUE(out);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_POP_QUEUE(const char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_POP_QUEUE(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_POP_QUEUE(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%spop_queue%s\", colors.value, colors.end);\n}\n\f\n/* Action structure for NXAST_FIN_TIMEOUT.\n *\n * This action changes the idle timeout or hard timeout, or both, of this\n * OpenFlow rule when the rule matches a TCP packet with the FIN or RST flag.\n * When such a packet is observed, the action reduces the rule's idle timeout\n * to 'fin_idle_timeout' and its hard timeout to 'fin_hard_timeout'.  This\n * action has no effect on an existing timeout that is already shorter than the\n * one that the action specifies.  A 'fin_idle_timeout' or 'fin_hard_timeout'\n * of zero has no effect on the respective timeout.\n *\n * 'fin_idle_timeout' and 'fin_hard_timeout' are measured in seconds.\n * 'fin_hard_timeout' specifies time since the flow's creation, not since the\n * receipt of the FIN or RST.\n *\n * This is useful for quickly discarding learned TCP flows that otherwise will\n * take a long time to expire.\n *\n * This action is intended for use with an OpenFlow rule that matches only a\n * single TCP flow.  If the rule matches multiple TCP flows (e.g. it wildcards\n * all TCP traffic, or all TCP traffic to a particular port), then any FIN or\n * RST in any of those flows will cause the entire OpenFlow rule to expire\n * early, which is not normally desirable.\n */\nstruct nx_action_fin_timeout {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* 16. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_FIN_TIMEOUT. */\n    ovs_be16 fin_idle_timeout;  /* New idle timeout, if nonzero. */\n    ovs_be16 fin_hard_timeout;  /* New hard timeout, if nonzero. */\n    ovs_be16 pad;               /* Must be zero. */\n};\nOFP_ASSERT(sizeof(struct nx_action_fin_timeout) == 16);\n\nstatic enum ofperr\ndecode_NXAST_RAW_FIN_TIMEOUT(const struct nx_action_fin_timeout *naft,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             struct ofpbuf *out)\n{\n    struct ofpact_fin_timeout *oft;\n\n    oft = ofpact_put_FIN_TIMEOUT(out);\n    oft->fin_idle_timeout = ntohs(naft->fin_idle_timeout);\n    oft->fin_hard_timeout = ntohs(naft->fin_hard_timeout);\n    return 0;\n}\n\nstatic void\nencode_FIN_TIMEOUT(const struct ofpact_fin_timeout *fin_timeout,\n                   enum ofp_version ofp_version OVS_UNUSED,\n                   struct ofpbuf *out)\n{\n    struct nx_action_fin_timeout *naft = put_NXAST_FIN_TIMEOUT(out);\n    naft->fin_idle_timeout = htons(fin_timeout->fin_idle_timeout);\n    naft->fin_hard_timeout = htons(fin_timeout->fin_hard_timeout);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_FIN_TIMEOUT(char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_fin_timeout *oft = ofpact_put_FIN_TIMEOUT(ofpacts);\n    char *key, *value;\n\n    while (ofputil_parse_key_value(&arg, &key, &value)) {\n        char *error;\n\n        if (!strcmp(key, \"idle_timeout\")) {\n            error =  str_to_u16(value, key, &oft->fin_idle_timeout);\n        } else if (!strcmp(key, \"hard_timeout\")) {\n            error = str_to_u16(value, key, &oft->fin_hard_timeout);\n        } else {\n            error = xasprintf(\"invalid key '%s' in 'fin_timeout' argument\",\n                              key);\n        }\n\n        if (error) {\n            return error;\n        }\n    }\n    return NULL;\n}\n\nstatic void\nformat_FIN_TIMEOUT(const struct ofpact_fin_timeout *a, struct ds *s)\n{\n    ds_put_format(s, \"%sfin_timeout(%s\", colors.paren, colors.end);\n    if (a->fin_idle_timeout) {\n        ds_put_format(s, \"%sidle_timeout=%s%\"PRIu16\",\",\n                      colors.param, colors.end, a->fin_idle_timeout);\n    }\n    if (a->fin_hard_timeout) {\n        ds_put_format(s, \"%shard_timeout=%s%\"PRIu16\",\",\n                      colors.param, colors.end, a->fin_hard_timeout);\n    }\n    ds_chomp(s, ',');\n    ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n}\n\f\n/* Action structures for NXAST_RESUBMIT and NXAST_RESUBMIT_TABLE.\n *\n * These actions search one of the switch's flow tables:\n *\n *    - For NXAST_RESUBMIT_TABLE only, if the 'table' member is not 255, then\n *      it specifies the table to search.\n *\n *    - Otherwise (for NXAST_RESUBMIT_TABLE with a 'table' of 255, or for\n *      NXAST_RESUBMIT regardless of 'table'), it searches the current flow\n *      table, that is, the OpenFlow flow table that contains the flow from\n *      which this action was obtained.  If this action did not come from a\n *      flow table (e.g. it came from an OFPT_PACKET_OUT message), then table 0\n *      is the current table.\n *\n * The flow table lookup uses a flow that may be slightly modified from the\n * original lookup:\n *\n *    - For NXAST_RESUBMIT, the 'in_port' member of struct nx_action_resubmit\n *      is used as the flow's in_port.\n *\n *    - For NXAST_RESUBMIT_TABLE, if the 'in_port' member is not OFPP_IN_PORT,\n *      then its value is used as the flow's in_port.  Otherwise, the original\n *      in_port is used.\n *\n *    - If actions that modify the flow (e.g. OFPAT_SET_VLAN_VID) precede the\n *      resubmit action, then the flow is updated with the new values.\n *\n * Following the lookup, the original in_port is restored.\n *\n * If the modified flow matched in the flow table, then the corresponding\n * actions are executed.  Afterward, actions following the resubmit in the\n * original set of actions, if any, are executed; any changes made to the\n * packet (e.g. changes to VLAN) by secondary actions persist when those\n * actions are executed, although the original in_port is restored.\n *\n * Resubmit actions may be used any number of times within a set of actions.\n *\n * Resubmit actions may nest.  To prevent infinite loops and excessive resource\n * use, the implementation may limit nesting depth and the total number of\n * resubmits:\n *\n *    - Open vSwitch 1.0.1 and earlier did not support recursion.\n *\n *    - Open vSwitch 1.0.2 and 1.0.3 limited recursion to 8 levels.\n *\n *    - Open vSwitch 1.1 and 1.2 limited recursion to 16 levels.\n *\n *    - Open vSwitch 1.2 through 1.8 limited recursion to 32 levels.\n *\n *    - Open vSwitch 1.9 through 2.0 limited recursion to 64 levels.\n *\n *    - Open vSwitch 2.1 through 2.5 limited recursion to 64 levels and impose\n *      a total limit of 4,096 resubmits per flow translation (earlier versions\n *      did not impose any total limit).\n *\n * NXAST_RESUBMIT ignores 'table' and 'pad'.  NXAST_RESUBMIT_TABLE requires\n * 'pad' to be all-bits-zero.\n *\n * Open vSwitch 1.0.1 and earlier did not support recursion.  Open vSwitch\n * before 1.2.90 did not support NXAST_RESUBMIT_TABLE.\n */\nstruct nx_action_resubmit {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 16. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_RESUBMIT. */\n    ovs_be16 in_port;               /* New in_port for checking flow table. */\n    uint8_t table;                  /* NXAST_RESUBMIT_TABLE: table to use. */\n    uint8_t pad[3];\n};\nOFP_ASSERT(sizeof(struct nx_action_resubmit) == 16);\n\nstatic enum ofperr\ndecode_NXAST_RAW_RESUBMIT(uint16_t port,\n                          enum ofp_version ofp_version OVS_UNUSED,\n                          struct ofpbuf *out)\n{\n    struct ofpact_resubmit *resubmit;\n\n    resubmit = ofpact_put_RESUBMIT(out);\n    resubmit->ofpact.raw = NXAST_RAW_RESUBMIT;\n    resubmit->in_port = u16_to_ofp(port);\n    resubmit->table_id = 0xff;\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_RESUBMIT_TABLE(const struct nx_action_resubmit *nar,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    struct ofpact_resubmit *resubmit;\n\n    if (nar->pad[0] || nar->pad[1] || nar->pad[2]) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    resubmit = ofpact_put_RESUBMIT(out);\n    resubmit->ofpact.raw = NXAST_RAW_RESUBMIT_TABLE;\n    resubmit->in_port = u16_to_ofp(ntohs(nar->in_port));\n    resubmit->table_id = nar->table;\n    return 0;\n}\n\nstatic void\nencode_RESUBMIT(const struct ofpact_resubmit *resubmit,\n                enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    uint16_t in_port = ofp_to_u16(resubmit->in_port);\n\n    if (resubmit->table_id == 0xff\n        && resubmit->ofpact.raw != NXAST_RAW_RESUBMIT_TABLE) {\n        put_NXAST_RESUBMIT(out, in_port);\n    } else {\n        struct nx_action_resubmit *nar = put_NXAST_RESUBMIT_TABLE(out);\n        nar->table = resubmit->table_id;\n        nar->in_port = htons(in_port);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_RESUBMIT(char *arg, struct ofpbuf *ofpacts,\n               enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_resubmit *resubmit;\n    char *in_port_s, *table_s;\n\n    resubmit = ofpact_put_RESUBMIT(ofpacts);\n\n    in_port_s = strsep(&arg, \",\");\n    if (in_port_s && in_port_s[0]) {\n        if (!ofputil_port_from_string(in_port_s, &resubmit->in_port)) {\n            return xasprintf(\"%s: resubmit to unknown port\", in_port_s);\n        }\n    } else {\n        resubmit->in_port = OFPP_IN_PORT;\n    }\n\n    table_s = strsep(&arg, \",\");\n    if (table_s && table_s[0]) {\n        uint32_t table_id = 0;\n        char *error;\n\n        error = str_to_u32(table_s, &table_id);\n        if (error) {\n            return error;\n        }\n        resubmit->table_id = table_id;\n    } else {\n        resubmit->table_id = 255;\n    }\n\n    if (resubmit->in_port == OFPP_IN_PORT && resubmit->table_id == 255) {\n        return xstrdup(\"at least one \\\"in_port\\\" or \\\"table\\\" must be \"\n                       \"specified  on resubmit\");\n    }\n    return NULL;\n}\n\nstatic void\nformat_RESUBMIT(const struct ofpact_resubmit *a, struct ds *s)\n{\n    if (a->in_port != OFPP_IN_PORT && a->table_id == 255) {\n        ds_put_format(s, \"%sresubmit:%s\", colors.special, colors.end);\n        ofputil_format_port(a->in_port, s);\n    } else {\n        ds_put_format(s, \"%sresubmit(%s\", colors.paren, colors.end);\n        if (a->in_port != OFPP_IN_PORT) {\n            ofputil_format_port(a->in_port, s);\n        }\n        ds_put_char(s, ',');\n        if (a->table_id != 255) {\n            ds_put_format(s, \"%\"PRIu8, a->table_id);\n        }\n        ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n    }\n}\n\f\n/* Action structure for NXAST_LEARN.\n *\n * This action adds or modifies a flow in an OpenFlow table, similar to\n * OFPT_FLOW_MOD with OFPFC_MODIFY_STRICT as 'command'.  The new flow has the\n * specified idle timeout, hard timeout, priority, cookie, and flags.  The new\n * flow's match criteria and actions are built by applying each of the series\n * of flow_mod_spec elements included as part of the action.\n *\n * A flow_mod_spec starts with a 16-bit header.  A header that is all-bits-0 is\n * a no-op used for padding the action as a whole to a multiple of 8 bytes in\n * length.  Otherwise, the flow_mod_spec can be thought of as copying 'n_bits'\n * bits from a source to a destination.  In this case, the header contains\n * multiple fields:\n *\n *  15  14  13 12  11 10                              0\n * +------+---+------+---------------------------------+\n * |   0  |src|  dst |             n_bits              |\n * +------+---+------+---------------------------------+\n *\n * The meaning and format of a flow_mod_spec depends on 'src' and 'dst'.  The\n * following table summarizes the meaning of each possible combination.\n * Details follow the table:\n *\n *   src dst  meaning\n *   --- ---  ----------------------------------------------------------\n *    0   0   Add match criteria based on value in a field.\n *    1   0   Add match criteria based on an immediate value.\n *    0   1   Add NXAST_REG_LOAD action to copy field into a different field.\n *    1   1   Add NXAST_REG_LOAD action to load immediate value into a field.\n *    0   2   Add OFPAT_OUTPUT action to output to port from specified field.\n *   All other combinations are undefined and not allowed.\n *\n * The flow_mod_spec header is followed by a source specification and a\n * destination specification.  The format and meaning of the source\n * specification depends on 'src':\n *\n *   - If 'src' is 0, the source bits are taken from a field in the flow to\n *     which this action is attached.  (This should be a wildcarded field.  If\n *     its value is fully specified then the source bits being copied have\n *     constant values.)\n *\n *     The source specification is an ovs_be32 'field' and an ovs_be16 'ofs'.\n *     'field' is an nxm_header with nxm_hasmask=0, and 'ofs' the starting bit\n *     offset within that field.  The source bits are field[ofs:ofs+n_bits-1].\n *     'field' and 'ofs' are subject to the same restrictions as the source\n *     field in NXAST_REG_MOVE.\n *\n *   - If 'src' is 1, the source bits are a constant value.  The source\n *     specification is (n_bits+15)/16*2 bytes long.  Taking those bytes as a\n *     number in network order, the source bits are the 'n_bits'\n *     least-significant bits.  The switch will report an error if other bits\n *     in the constant are nonzero.\n *\n * The flow_mod_spec destination specification, for 'dst' of 0 or 1, is an\n * ovs_be32 'field' and an ovs_be16 'ofs'.  'field' is an nxm_header with\n * nxm_hasmask=0 and 'ofs' is a starting bit offset within that field.  The\n * meaning of the flow_mod_spec depends on 'dst':\n *\n *   - If 'dst' is 0, the flow_mod_spec specifies match criteria for the new\n *     flow.  The new flow matches only if bits field[ofs:ofs+n_bits-1] in a\n *     packet equal the source bits.  'field' may be any nxm_header with\n *     nxm_hasmask=0 that is allowed in NXT_FLOW_MOD.\n *\n *     Order is significant.  Earlier flow_mod_specs must satisfy any\n *     prerequisites for matching fields specified later, by copying constant\n *     values into prerequisite fields.\n *\n *     The switch will reject flow_mod_specs that do not satisfy NXM masking\n *     restrictions.\n *\n *   - If 'dst' is 1, the flow_mod_spec specifies an NXAST_REG_LOAD action for\n *     the new flow.  The new flow copies the source bits into\n *     field[ofs:ofs+n_bits-1].  Actions are executed in the same order as the\n *     flow_mod_specs.\n *\n *     A single NXAST_REG_LOAD action writes no more than 64 bits, so n_bits\n *     greater than 64 yields multiple NXAST_REG_LOAD actions.\n *\n * The flow_mod_spec destination spec for 'dst' of 2 (when 'src' is 0) is\n * empty.  It has the following meaning:\n *\n *   - The flow_mod_spec specifies an OFPAT_OUTPUT action for the new flow.\n *     The new flow outputs to the OpenFlow port specified by the source field.\n *     Of the special output ports with value OFPP_MAX or larger, OFPP_IN_PORT,\n *     OFPP_FLOOD, OFPP_LOCAL, and OFPP_ALL are supported.  Other special ports\n *     may not be used.\n *\n * Resource Management\n * -------------------\n *\n * A switch has a finite amount of flow table space available for learning.\n * When this space is exhausted, no new learning table entries will be learned\n * until some existing flow table entries expire.  The controller should be\n * prepared to handle this by flooding (which can be implemented as a\n * low-priority flow).\n *\n * If a learned flow matches a single TCP stream with a relatively long\n * timeout, one may make the best of resource constraints by setting\n * 'fin_idle_timeout' or 'fin_hard_timeout' (both measured in seconds), or\n * both, to shorter timeouts.  When either of these is specified as a nonzero\n * value, OVS adds a NXAST_FIN_TIMEOUT action, with the specified timeouts, to\n * the learned flow.\n *\n * Examples\n * --------\n *\n * The following examples give a prose description of the flow_mod_specs along\n * with informal notation for how those would be represented and a hex dump of\n * the bytes that would be required.\n *\n * These examples could work with various nx_action_learn parameters.  Typical\n * values would be idle_timeout=OFP_FLOW_PERMANENT, hard_timeout=60,\n * priority=OFP_DEFAULT_PRIORITY, flags=0, table_id=10.\n *\n * 1. Learn input port based on the source MAC, with lookup into\n *    NXM_NX_REG1[16:31] by resubmit to in_port=99:\n *\n *    Match on in_port=99:\n *       ovs_be16(src=1, dst=0, n_bits=16),               20 10\n *       ovs_be16(99),                                    00 63\n *       ovs_be32(NXM_OF_IN_PORT), ovs_be16(0)            00 00 00 02 00 00\n *\n *    Match Ethernet destination on Ethernet source from packet:\n *       ovs_be16(src=0, dst=0, n_bits=48),               00 30\n *       ovs_be32(NXM_OF_ETH_SRC), ovs_be16(0)            00 00 04 06 00 00\n *       ovs_be32(NXM_OF_ETH_DST), ovs_be16(0)            00 00 02 06 00 00\n *\n *    Set NXM_NX_REG1[16:31] to the packet's input port:\n *       ovs_be16(src=0, dst=1, n_bits=16),               08 10\n *       ovs_be32(NXM_OF_IN_PORT), ovs_be16(0)            00 00 00 02 00 00\n *       ovs_be32(NXM_NX_REG1), ovs_be16(16)              00 01 02 04 00 10\n *\n *    Given a packet that arrived on port A with Ethernet source address B,\n *    this would set up the flow \"in_port=99, dl_dst=B,\n *    actions=load:A->NXM_NX_REG1[16..31]\".\n *\n *    In syntax accepted by ovs-ofctl, this action is: learn(in_port=99,\n *    NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],\n *    load:NXM_OF_IN_PORT[]->NXM_NX_REG1[16..31])\n *\n * 2. Output to input port based on the source MAC and VLAN VID, with lookup\n *    into NXM_NX_REG1[16:31]:\n *\n *    Match on same VLAN ID as packet:\n *       ovs_be16(src=0, dst=0, n_bits=12),               00 0c\n *       ovs_be32(NXM_OF_VLAN_TCI), ovs_be16(0)           00 00 08 02 00 00\n *       ovs_be32(NXM_OF_VLAN_TCI), ovs_be16(0)           00 00 08 02 00 00\n *\n *    Match Ethernet destination on Ethernet source from packet:\n *       ovs_be16(src=0, dst=0, n_bits=48),               00 30\n *       ovs_be32(NXM_OF_ETH_SRC), ovs_be16(0)            00 00 04 06 00 00\n *       ovs_be32(NXM_OF_ETH_DST), ovs_be16(0)            00 00 02 06 00 00\n *\n *    Output to the packet's input port:\n *       ovs_be16(src=0, dst=2, n_bits=16),               10 10\n *       ovs_be32(NXM_OF_IN_PORT), ovs_be16(0)            00 00 00 02 00 00\n *\n *    Given a packet that arrived on port A with Ethernet source address B in\n *    VLAN C, this would set up the flow \"dl_dst=B, vlan_vid=C,\n *    actions=output:A\".\n *\n *    In syntax accepted by ovs-ofctl, this action is:\n *    learn(NXM_OF_VLAN_TCI[0..11], NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],\n *    output:NXM_OF_IN_PORT[])\n *\n * 3. Here's a recipe for a very simple-minded MAC learning switch.  It uses a\n *    10-second MAC expiration time to make it easier to see what's going on\n *\n *      ovs-vsctl del-controller br0\n *      ovs-ofctl del-flows br0\n *      ovs-ofctl add-flow br0 \"table=0 actions=learn(table=1, \\\n          hard_timeout=10, NXM_OF_VLAN_TCI[0..11],             \\\n          NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],                   \\\n          output:NXM_OF_IN_PORT[]), resubmit(,1)\"\n *      ovs-ofctl add-flow br0 \"table=1 priority=0 actions=flood\"\n *\n *    You can then dump the MAC learning table with:\n *\n *      ovs-ofctl dump-flows br0 table=1\n *\n * Usage Advice\n * ------------\n *\n * For best performance, segregate learned flows into a table that is not used\n * for any other flows except possibly for a lowest-priority \"catch-all\" flow\n * (a flow with no match criteria).  If different learning actions specify\n * different match criteria, use different tables for the learned flows.\n *\n * The meaning of 'hard_timeout' and 'idle_timeout' can be counterintuitive.\n * These timeouts apply to the flow that is added, which means that a flow with\n * an idle timeout will expire when no traffic has been sent *to* the learned\n * address.  This is not usually the intent in MAC learning; instead, we want\n * the MAC learn entry to expire when no traffic has been sent *from* the\n * learned address.  Use a hard timeout for that.\n *\n *\n * Visibility of Changes\n * ---------------------\n *\n * Prior to Open vSwitch 2.4, any changes made by a \"learn\" action in a given\n * flow translation are visible to flow table lookups made later in the flow\n * translation.  This means that, in the example above, a MAC learned by the\n * learn action in table 0 would be found in table 1 (if the packet being\n * processed had the same source and destination MAC address).\n *\n * In Open vSwitch 2.4 and later, changes to a flow table (whether to add or\n * modify a flow) by a \"learn\" action are visible only for later flow\n * translations, not for later lookups within the same flow translation.  In\n * the MAC learning example, a MAC learned by the learn action in table 0 would\n * not be found in table 1 if the flow translation would resubmit to table 1\n * after the processing of the learn action, meaning that if this MAC had not\n * been learned before then the packet would be flooded. */\nstruct nx_action_learn {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* At least 24. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_LEARN. */\n    ovs_be16 idle_timeout;      /* Idle time before discarding (seconds). */\n    ovs_be16 hard_timeout;      /* Max time before discarding (seconds). */\n    ovs_be16 priority;          /* Priority level of flow entry. */\n    ovs_be64 cookie;            /* Cookie for new flow. */\n    ovs_be16 flags;             /* NX_LEARN_F_*. */\n    uint8_t table_id;           /* Table to insert flow entry. */\n    uint8_t pad;                /* Must be zero. */\n    ovs_be16 fin_idle_timeout;  /* Idle timeout after FIN, if nonzero. */\n    ovs_be16 fin_hard_timeout;  /* Hard timeout after FIN, if nonzero. */\n    /* Followed by a sequence of flow_mod_spec elements, as described above,\n     * until the end of the action is reached. */\n};\nOFP_ASSERT(sizeof(struct nx_action_learn) == 32);\n\nstatic ovs_be16\nget_be16(const void **pp)\n{\n    const ovs_be16 *p = *pp;\n    ovs_be16 value = *p;\n    *pp = p + 1;\n    return value;\n}\n\nstatic ovs_be32\nget_be32(const void **pp)\n{\n    const ovs_be32 *p = *pp;\n    ovs_be32 value = get_unaligned_be32(p);\n    *pp = p + 1;\n    return value;\n}\n\nstatic enum ofperr\nget_subfield(int n_bits, const void **p, struct mf_subfield *sf,\n             const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap)\n{\n    enum ofperr error;\n\n    error = mf_vl_mff_mf_from_nxm_header(ntohl(get_be32(p)), vl_mff_map,\n                                         &sf->field, tlv_bitmap);\n    sf->ofs = ntohs(get_be16(p));\n    sf->n_bits = n_bits;\n    return error;\n}\n\nstatic unsigned int\nlearn_min_len(uint16_t header)\n{\n    int n_bits = header & NX_LEARN_N_BITS_MASK;\n    int src_type = header & NX_LEARN_SRC_MASK;\n    int dst_type = header & NX_LEARN_DST_MASK;\n    unsigned int min_len;\n\n    min_len = 0;\n    if (src_type == NX_LEARN_SRC_FIELD) {\n        min_len += sizeof(ovs_be32); /* src_field */\n        min_len += sizeof(ovs_be16); /* src_ofs */\n    } else {\n        min_len += DIV_ROUND_UP(n_bits, 16);\n    }\n    if (dst_type == NX_LEARN_DST_MATCH ||\n        dst_type == NX_LEARN_DST_LOAD) {\n        min_len += sizeof(ovs_be32); /* dst_field */\n        min_len += sizeof(ovs_be16); /* dst_ofs */\n    }\n    return min_len;\n}\n\n/* Converts 'nal' into a \"struct ofpact_learn\" and appends that struct to\n * 'ofpacts'.  Returns 0 if successful, otherwise an OFPERR_*. */\nstatic enum ofperr\ndecode_NXAST_RAW_LEARN(const struct nx_action_learn *nal,\n                       enum ofp_version ofp_version OVS_UNUSED,\n                       const struct vl_mff_map *vl_mff_map,\n                       uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpact_learn *learn;\n    const void *p, *end;\n\n    if (nal->pad) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    learn = ofpact_put_LEARN(ofpacts);\n\n    learn->idle_timeout = ntohs(nal->idle_timeout);\n    learn->hard_timeout = ntohs(nal->hard_timeout);\n    learn->priority = ntohs(nal->priority);\n    learn->cookie = nal->cookie;\n    learn->table_id = nal->table_id;\n    learn->fin_idle_timeout = ntohs(nal->fin_idle_timeout);\n    learn->fin_hard_timeout = ntohs(nal->fin_hard_timeout);\n\n    learn->flags = ntohs(nal->flags);\n    if (learn->flags & ~(NX_LEARN_F_SEND_FLOW_REM |\n                         NX_LEARN_F_DELETE_LEARNED)) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    if (learn->table_id == 0xff) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    end = (char *) nal + ntohs(nal->len);\n    for (p = nal + 1; p != end; ) {\n        struct ofpact_learn_spec *spec;\n        uint16_t header = ntohs(get_be16(&p));\n\n        if (!header) {\n            break;\n        }\n\n        spec = ofpbuf_put_zeros(ofpacts, sizeof *spec);\n        learn = ofpacts->header;\n\n        spec->src_type = header & NX_LEARN_SRC_MASK;\n        spec->dst_type = header & NX_LEARN_DST_MASK;\n        spec->n_bits = header & NX_LEARN_N_BITS_MASK;\n\n        /* Check for valid src and dst type combination. */\n        if (spec->dst_type == NX_LEARN_DST_MATCH ||\n            spec->dst_type == NX_LEARN_DST_LOAD ||\n            (spec->dst_type == NX_LEARN_DST_OUTPUT &&\n             spec->src_type == NX_LEARN_SRC_FIELD)) {\n            /* OK. */\n        } else {\n            return OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n\n        /* Check that the arguments don't overrun the end of the action. */\n        if ((char *) end - (char *) p < learn_min_len(header)) {\n            return OFPERR_OFPBAC_BAD_LEN;\n        }\n\n        /* Get the source. */\n        const uint8_t *imm = NULL;\n        unsigned int imm_bytes = 0;\n        enum ofperr error;\n        if (spec->src_type == NX_LEARN_SRC_FIELD) {\n            error = get_subfield(spec->n_bits, &p, &spec->src, vl_mff_map,\n                                 tlv_bitmap);\n            if (error) {\n                return error;\n            }\n        } else {\n            int p_bytes = 2 * DIV_ROUND_UP(spec->n_bits, 16);\n            p = (const uint8_t *) p + p_bytes;\n\n            imm_bytes = DIV_ROUND_UP(spec->n_bits, 8);\n            imm = (const uint8_t *) p - imm_bytes;\n        }\n\n        /* Get the destination. */\n        if (spec->dst_type == NX_LEARN_DST_MATCH ||\n            spec->dst_type == NX_LEARN_DST_LOAD) {\n            error = get_subfield(spec->n_bits, &p, &spec->dst, vl_mff_map,\n                                 tlv_bitmap);\n            if (error) {\n                return error;\n            }\n        }\n\n        if (imm) {\n            uint8_t *src_imm = ofpbuf_put_zeros(ofpacts,\n                                                OFPACT_ALIGN(imm_bytes));\n            memcpy(src_imm, imm, imm_bytes);\n\n            learn = ofpacts->header;\n        }\n    }\n    ofpact_finish_LEARN(ofpacts, &learn);\n\n    if (!is_all_zeros(p, (char *) end - (char *) p)) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    return 0;\n}\n\nstatic void\nput_be16(struct ofpbuf *b, ovs_be16 x)\n{\n    ofpbuf_put(b, &x, sizeof x);\n}\n\nstatic void\nput_be32(struct ofpbuf *b, ovs_be32 x)\n{\n    ofpbuf_put(b, &x, sizeof x);\n}\n\nstatic void\nput_u16(struct ofpbuf *b, uint16_t x)\n{\n    put_be16(b, htons(x));\n}\n\nstatic void\nput_u32(struct ofpbuf *b, uint32_t x)\n{\n    put_be32(b, htonl(x));\n}\n\nstatic void\nencode_LEARN(const struct ofpact_learn *learn,\n             enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    const struct ofpact_learn_spec *spec;\n    struct nx_action_learn *nal;\n    size_t start_ofs;\n\n    start_ofs = out->size;\n    nal = put_NXAST_LEARN(out);\n    nal->idle_timeout = htons(learn->idle_timeout);\n    nal->hard_timeout = htons(learn->hard_timeout);\n    nal->fin_idle_timeout = htons(learn->fin_idle_timeout);\n    nal->fin_hard_timeout = htons(learn->fin_hard_timeout);\n    nal->priority = htons(learn->priority);\n    nal->cookie = learn->cookie;\n    nal->flags = htons(learn->flags);\n    nal->table_id = learn->table_id;\n\n    OFPACT_LEARN_SPEC_FOR_EACH (spec, learn) {\n        put_u16(out, spec->n_bits | spec->dst_type | spec->src_type);\n\n        if (spec->src_type == NX_LEARN_SRC_FIELD) {\n            put_u32(out, nxm_header_from_mff(spec->src.field));\n            put_u16(out, spec->src.ofs);\n        } else {\n            size_t n_dst_bytes = 2 * DIV_ROUND_UP(spec->n_bits, 16);\n            uint8_t *bits = ofpbuf_put_zeros(out, n_dst_bytes);\n            unsigned int n_bytes = DIV_ROUND_UP(spec->n_bits, 8);\n\n            memcpy(bits + n_dst_bytes - n_bytes, ofpact_learn_spec_imm(spec),\n                   n_bytes);\n        }\n\n        if (spec->dst_type == NX_LEARN_DST_MATCH ||\n            spec->dst_type == NX_LEARN_DST_LOAD) {\n            put_u32(out, nxm_header_from_mff(spec->dst.field));\n            put_u16(out, spec->dst.ofs);\n        }\n    }\n\n    pad_ofpat(out, start_ofs);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_LEARN(char *arg, struct ofpbuf *ofpacts,\n            enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return learn_parse(arg, ofpacts);\n}\n\nstatic void\nformat_LEARN(const struct ofpact_learn *a, struct ds *s)\n{\n    learn_format(a, s);\n}\n\f\n/* Action structure for NXAST_CONJUNCTION. */\nstruct nx_action_conjunction {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* At least 16. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* See enum ofp_raw_action_type. */\n    uint8_t clause;\n    uint8_t n_clauses;\n    ovs_be32 id;\n};\nOFP_ASSERT(sizeof(struct nx_action_conjunction) == 16);\n\nstatic void\nadd_conjunction(struct ofpbuf *out,\n                uint32_t id, uint8_t clause, uint8_t n_clauses)\n{\n    struct ofpact_conjunction *oc;\n\n    oc = ofpact_put_CONJUNCTION(out);\n    oc->id = id;\n    oc->clause = clause;\n    oc->n_clauses = n_clauses;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_CONJUNCTION(const struct nx_action_conjunction *nac,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             struct ofpbuf *out)\n{\n    if (nac->n_clauses < 2 || nac->n_clauses > 64\n        || nac->clause >= nac->n_clauses) {\n        return OFPERR_NXBAC_BAD_CONJUNCTION;\n    } else {\n        add_conjunction(out, ntohl(nac->id), nac->clause, nac->n_clauses);\n        return 0;\n    }\n}\n\nstatic void\nencode_CONJUNCTION(const struct ofpact_conjunction *oc,\n                   enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    struct nx_action_conjunction *nac = put_NXAST_CONJUNCTION(out);\n    nac->clause = oc->clause;\n    nac->n_clauses = oc->n_clauses;\n    nac->id = htonl(oc->id);\n}\n\nstatic void\nformat_CONJUNCTION(const struct ofpact_conjunction *oc, struct ds *s)\n{\n    ds_put_format(s, \"%sconjunction(%s%\"PRIu32\",%\"PRIu8\"/%\"PRIu8\"%s)%s\",\n                  colors.paren, colors.end,\n                  oc->id, oc->clause + 1, oc->n_clauses,\n                  colors.paren, colors.end);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_CONJUNCTION(const char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint8_t n_clauses;\n    uint8_t clause;\n    uint32_t id;\n    int n;\n\n    if (!ovs_scan(arg, \"%\"SCNi32\" , %\"SCNu8\" / %\"SCNu8\" %n\",\n                  &id, &clause, &n_clauses, &n) || n != strlen(arg)) {\n        return xstrdup(\"\\\"conjunction\\\" syntax is \\\"conjunction(id,i/n)\\\"\");\n    }\n\n    if (n_clauses < 2) {\n        return xstrdup(\"conjunction must have at least 2 clauses\");\n    } else if (n_clauses > 64) {\n        return xstrdup(\"conjunction must have at most 64 clauses\");\n    } else if (clause < 1) {\n        return xstrdup(\"clause index must be positive\");\n    } else if (clause > n_clauses) {\n        return xstrdup(\"clause index must be less than or equal to \"\n                       \"number of clauses\");\n    }\n\n    add_conjunction(ofpacts, id, clause - 1, n_clauses);\n    return NULL;\n}\n\f\n/* Action structure for NXAST_MULTIPATH.\n *\n * This action performs the following steps in sequence:\n *\n *    1. Hashes the fields designated by 'fields', one of NX_HASH_FIELDS_*.\n *       Refer to the definition of \"enum nx_mp_fields\" for details.\n *\n *       The 'basis' value is used as a universal hash parameter, that is,\n *       different values of 'basis' yield different hash functions.  The\n *       particular universal hash function used is implementation-defined.\n *\n *       The hashed fields' values are drawn from the current state of the\n *       flow, including all modifications that have been made by actions up to\n *       this point.\n *\n *    2. Applies the multipath link choice algorithm specified by 'algorithm',\n *       one of NX_MP_ALG_*.  Refer to the definition of \"enum nx_mp_algorithm\"\n *       for details.\n *\n *       The output of the algorithm is 'link', an unsigned integer less than\n *       or equal to 'max_link'.\n *\n *       Some algorithms use 'arg' as an additional argument.\n *\n *    3. Stores 'link' in dst[ofs:ofs+n_bits].  The format and semantics of\n *       'dst' and 'ofs_nbits' are similar to those for the NXAST_REG_LOAD\n *       action.\n *\n * The switch will reject actions that have an unknown 'fields', or an unknown\n * 'algorithm', or in which ofs+n_bits is greater than the width of 'dst', or\n * in which 'max_link' is greater than or equal to 2**n_bits, with error type\n * OFPET_BAD_ACTION, code OFPBAC_BAD_ARGUMENT.\n */\nstruct nx_action_multipath {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* Length is 32. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_MULTIPATH. */\n\n    /* What fields to hash and how. */\n    ovs_be16 fields;            /* One of NX_HASH_FIELDS_*. */\n    ovs_be16 basis;             /* Universal hash parameter. */\n    ovs_be16 pad0;\n\n    /* Multipath link choice algorithm to apply to hash value. */\n    ovs_be16 algorithm;         /* One of NX_MP_ALG_*. */\n    ovs_be16 max_link;          /* Number of output links, minus 1. */\n    ovs_be32 arg;               /* Algorithm-specific argument. */\n    ovs_be16 pad1;\n\n    /* Where to store the result. */\n    ovs_be16 ofs_nbits;         /* (ofs << 6) | (n_bits - 1). */\n    ovs_be32 dst;               /* Destination. */\n};\nOFP_ASSERT(sizeof(struct nx_action_multipath) == 32);\n\nstatic enum ofperr\ndecode_NXAST_RAW_MULTIPATH(const struct nx_action_multipath *nam,\n                           enum ofp_version ofp_version OVS_UNUSED,\n                           const struct vl_mff_map *vl_mff_map,\n                           uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    uint32_t n_links = ntohs(nam->max_link) + 1;\n    size_t min_n_bits = log_2_ceil(n_links);\n    struct ofpact_multipath *mp;\n    enum ofperr error;\n\n    mp = ofpact_put_MULTIPATH(out);\n    mp->fields = ntohs(nam->fields);\n    mp->basis = ntohs(nam->basis);\n    mp->algorithm = ntohs(nam->algorithm);\n    mp->max_link = ntohs(nam->max_link);\n    mp->arg = ntohl(nam->arg);\n    mp->dst.ofs = nxm_decode_ofs(nam->ofs_nbits);\n    mp->dst.n_bits = nxm_decode_n_bits(nam->ofs_nbits);\n    error = mf_vl_mff_mf_from_nxm_header(ntohl(nam->dst), vl_mff_map,\n                                         &mp->dst.field, tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    if (!flow_hash_fields_valid(mp->fields)) {\n        VLOG_WARN_RL(&rl, \"unsupported fields %d\", (int) mp->fields);\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else if (mp->algorithm != NX_MP_ALG_MODULO_N\n               && mp->algorithm != NX_MP_ALG_HASH_THRESHOLD\n               && mp->algorithm != NX_MP_ALG_HRW\n               && mp->algorithm != NX_MP_ALG_ITER_HASH) {\n        VLOG_WARN_RL(&rl, \"unsupported algorithm %d\", (int) mp->algorithm);\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else if (mp->dst.n_bits < min_n_bits) {\n        VLOG_WARN_RL(&rl, \"multipath action requires at least %\"PRIuSIZE\" bits for \"\n                     \"%\"PRIu32\" links\", min_n_bits, n_links);\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    return multipath_check(mp, NULL);\n}\n\nstatic void\nencode_MULTIPATH(const struct ofpact_multipath *mp,\n                 enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    struct nx_action_multipath *nam = put_NXAST_MULTIPATH(out);\n\n    nam->fields = htons(mp->fields);\n    nam->basis = htons(mp->basis);\n    nam->algorithm = htons(mp->algorithm);\n    nam->max_link = htons(mp->max_link);\n    nam->arg = htonl(mp->arg);\n    nam->ofs_nbits = nxm_encode_ofs_nbits(mp->dst.ofs, mp->dst.n_bits);\n    nam->dst = htonl(nxm_header_from_mff(mp->dst.field));\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_MULTIPATH(const char *arg, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return multipath_parse(ofpact_put_MULTIPATH(ofpacts), arg);\n}\n\nstatic void\nformat_MULTIPATH(const struct ofpact_multipath *a, struct ds *s)\n{\n    multipath_format(a, s);\n}\n\f\n/* Action structure for NXAST_NOTE.\n *\n * This action has no effect.  It is variable length.  The switch does not\n * attempt to interpret the user-defined 'note' data in any way.  A controller\n * can use this action to attach arbitrary metadata to a flow.\n *\n * This action might go away in the future.\n */\nstruct nx_action_note {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* A multiple of 8, but at least 16. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_NOTE. */\n    uint8_t note[6];                /* Start of user-defined data. */\n    /* Possibly followed by additional user-defined data. */\n};\nOFP_ASSERT(sizeof(struct nx_action_note) == 16);\n\nstatic enum ofperr\ndecode_NXAST_RAW_NOTE(const struct nx_action_note *nan,\n                      enum ofp_version ofp_version OVS_UNUSED,\n                      struct ofpbuf *out)\n{\n    struct ofpact_note *note;\n    unsigned int length;\n\n    length = ntohs(nan->len) - offsetof(struct nx_action_note, note);\n    note = ofpact_put_NOTE(out);\n    note->length = length;\n    ofpbuf_put(out, nan->note, length);\n    note = out->header;\n    ofpact_finish_NOTE(out, &note);\n\n    return 0;\n}\n\nstatic void\nencode_NOTE(const struct ofpact_note *note,\n            enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    size_t start_ofs = out->size;\n    struct nx_action_note *nan;\n\n    put_NXAST_NOTE(out);\n    out->size = out->size - sizeof nan->note;\n\n    ofpbuf_put(out, note->data, note->length);\n    pad_ofpat(out, start_ofs);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_NOTE(const char *arg, struct ofpbuf *ofpacts,\n           enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    size_t start_ofs = ofpacts->size;\n    ofpact_put_NOTE(ofpacts);\n    arg = ofpbuf_put_hex(ofpacts, arg, NULL);\n    if (arg[0]) {\n        return xstrdup(\"bad hex digit in `note' argument\");\n    }\n    struct ofpact_note *note = ofpbuf_at_assert(ofpacts, start_ofs,\n                                                sizeof *note);\n    note->length = ofpacts->size - (start_ofs + sizeof *note);\n    ofpact_finish_NOTE(ofpacts, &note);\n    return NULL;\n}\n\nstatic void\nformat_NOTE(const struct ofpact_note *a, struct ds *s)\n{\n    ds_put_format(s, \"%snote:%s\", colors.param, colors.end);\n    format_hex_arg(s, a->data, a->length);\n}\n\f\n/* Exit action. */\n\nstatic enum ofperr\ndecode_NXAST_RAW_EXIT(struct ofpbuf *out)\n{\n    ofpact_put_EXIT(out);\n    return 0;\n}\n\nstatic void\nencode_EXIT(const struct ofpact_null *null OVS_UNUSED,\n            enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    put_NXAST_EXIT(out);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_EXIT(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n           enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_EXIT(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_EXIT(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%sexit%s\", colors.special, colors.end);\n}\n\f\n/* Unroll xlate action. */\n\nstatic void\nencode_UNROLL_XLATE(const struct ofpact_unroll_xlate *unroll OVS_UNUSED,\n                    enum ofp_version ofp_version OVS_UNUSED,\n                    struct ofpbuf *out OVS_UNUSED)\n{\n    OVS_NOT_REACHED();\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_UNROLL_XLATE(char *arg OVS_UNUSED, struct ofpbuf *ofpacts OVS_UNUSED,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    OVS_NOT_REACHED();\n    return NULL;\n}\n\nstatic void\nformat_UNROLL_XLATE(const struct ofpact_unroll_xlate *a, struct ds *s)\n{\n    ds_put_format(s, \"%sunroll_xlate(%s%stable=%s%\"PRIu8\n                  \", %scookie=%s%\"PRIu64\"%s)%s\",\n                  colors.paren,   colors.end,\n                  colors.special, colors.end, a->rule_table_id,\n                  colors.param,   colors.end, ntohll(a->rule_cookie),\n                  colors.paren,   colors.end);\n}\n\f\n/* The NXAST_CLONE action is \"struct ext_action_header\", followed by zero or\n * more embedded OpenFlow actions. */\n\nstatic enum ofperr\ndecode_NXAST_RAW_CLONE(const struct ext_action_header *eah,\n                       enum ofp_version ofp_version,\n                       const struct vl_mff_map *vl_mff_map,\n                       uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    int error;\n    struct ofpbuf openflow;\n    const size_t clone_offset = ofpacts_pull(out);\n    struct ofpact_nest *clone = ofpact_put_CLONE(out);\n\n    /* decode action list */\n    ofpbuf_pull(out, sizeof(*clone));\n    openflow = ofpbuf_const_initializer(\n                    eah + 1, ntohs(eah->len) - sizeof *eah);\n    error = ofpacts_pull_openflow_actions__(&openflow, openflow.size,\n                                            ofp_version,\n                                            1u << OVSINST_OFPIT11_APPLY_ACTIONS,\n                                            out, 0, vl_mff_map, tlv_bitmap);\n    clone = ofpbuf_push_uninit(out, sizeof *clone);\n    out->header = &clone->ofpact;\n    ofpact_finish_CLONE(out, &clone);\n    ofpbuf_push_uninit(out, clone_offset);\n    return error;\n}\n\nstatic void\nencode_CLONE(const struct ofpact_nest *clone,\n              enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    size_t len;\n    const size_t ofs = out->size;\n    struct ext_action_header *eah;\n\n    eah = put_NXAST_CLONE(out);\n    len = ofpacts_put_openflow_actions(clone->actions,\n                                       ofpact_nest_get_action_len(clone),\n                                       out, ofp_version);\n    len += sizeof *eah;\n    eah = ofpbuf_at(out, ofs, sizeof *eah);\n    eah->len = htons(len);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_CLONE(char *arg, struct ofpbuf *ofpacts,\n             enum ofputil_protocol *usable_protocols)\n{\n    const size_t clone_offset = ofpacts_pull(ofpacts);\n    struct ofpact_nest *clone = ofpact_put_CLONE(ofpacts);\n    char *error;\n\n    ofpbuf_pull(ofpacts, sizeof *clone);\n    error = ofpacts_parse_copy(arg, ofpacts, usable_protocols, false, 0);\n    /* header points to the action list */\n    ofpacts->header = ofpbuf_push_uninit(ofpacts, sizeof *clone);\n    clone = ofpacts->header;\n\n    ofpact_finish_CLONE(ofpacts, &clone);\n    ofpbuf_push_uninit(ofpacts, clone_offset);\n    return error;\n}\n\nstatic void\nformat_CLONE(const struct ofpact_nest *a, struct ds *s)\n{\n    ds_put_format(s, \"%sclone(%s\", colors.paren, colors.end);\n    ofpacts_format(a->actions, ofpact_nest_get_action_len(a), s);\n    ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n}\n\f\n/* Action structure for NXAST_SAMPLE.\n *\n * Samples matching packets with the given probability and sends them\n * each to the set of collectors identified with the given ID.  The\n * probability is expressed as a number of packets to be sampled out\n * of USHRT_MAX packets, and must be >0.\n *\n * When sending packet samples to IPFIX collectors, the IPFIX flow\n * record sent for each sampled packet is associated with the given\n * observation domain ID and observation point ID.  Each IPFIX flow\n * record contain the sampled packet's headers when executing this\n * rule.  If a sampled packet's headers are modified by previous\n * actions in the flow, those modified headers are sent. */\nstruct nx_action_sample {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 24. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_SAMPLE. */\n    ovs_be16 probability;           /* Fraction of packets to sample. */\n    ovs_be32 collector_set_id;      /* ID of collector set in OVSDB. */\n    ovs_be32 obs_domain_id;         /* ID of sampling observation domain. */\n    ovs_be32 obs_point_id;          /* ID of sampling observation point. */\n};\nOFP_ASSERT(sizeof(struct nx_action_sample) == 24);\n\n/* Action structure for NXAST_SAMPLE2 and NXAST_SAMPLE3.\n *\n * NXAST_SAMPLE2 was added in Open vSwitch 2.5.90.  Compared to NXAST_SAMPLE,\n * it adds support for exporting egress tunnel information.\n *\n * NXAST_SAMPLE3 was added in Open vSwitch 2.6.90.  Compared to NXAST_SAMPLE2,\n * it adds support for the 'direction' field. */\nstruct nx_action_sample2 {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 32. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_SAMPLE. */\n    ovs_be16 probability;           /* Fraction of packets to sample. */\n    ovs_be32 collector_set_id;      /* ID of collector set in OVSDB. */\n    ovs_be32 obs_domain_id;         /* ID of sampling observation domain. */\n    ovs_be32 obs_point_id;          /* ID of sampling observation point. */\n    ovs_be16 sampling_port;         /* Sampling port. */\n    uint8_t  direction;             /* NXAST_SAMPLE3 only. */\n    uint8_t  zeros[5];              /* Pad to a multiple of 8 bytes */\n };\n OFP_ASSERT(sizeof(struct nx_action_sample2) == 32);\n\nstatic enum ofperr\ndecode_NXAST_RAW_SAMPLE(const struct nx_action_sample *nas,\n                        enum ofp_version ofp_version OVS_UNUSED,\n                        struct ofpbuf *out)\n{\n    struct ofpact_sample *sample;\n\n    sample = ofpact_put_SAMPLE(out);\n    sample->ofpact.raw = NXAST_RAW_SAMPLE;\n    sample->probability = ntohs(nas->probability);\n    sample->collector_set_id = ntohl(nas->collector_set_id);\n    sample->obs_domain_id = ntohl(nas->obs_domain_id);\n    sample->obs_point_id = ntohl(nas->obs_point_id);\n    sample->sampling_port = OFPP_NONE;\n    sample->direction = NX_ACTION_SAMPLE_DEFAULT;\n\n    if (sample->probability == 0) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\ndecode_SAMPLE2(const struct nx_action_sample2 *nas,\n               enum ofp_raw_action_type raw,\n               enum nx_action_sample_direction direction,\n               struct ofpact_sample *sample)\n{\n    sample->ofpact.raw = raw;\n    sample->probability = ntohs(nas->probability);\n    sample->collector_set_id = ntohl(nas->collector_set_id);\n    sample->obs_domain_id = ntohl(nas->obs_domain_id);\n    sample->obs_point_id = ntohl(nas->obs_point_id);\n    sample->sampling_port = u16_to_ofp(ntohs(nas->sampling_port));\n    sample->direction = direction;\n\n    if (sample->probability == 0) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_SAMPLE2(const struct nx_action_sample2 *nas,\n                         enum ofp_version ofp_version OVS_UNUSED,\n                         struct ofpbuf *out)\n{\n    return decode_SAMPLE2(nas, NXAST_RAW_SAMPLE2, NX_ACTION_SAMPLE_DEFAULT,\n                          ofpact_put_SAMPLE(out));\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_SAMPLE3(const struct nx_action_sample2 *nas,\n                         enum ofp_version ofp_version OVS_UNUSED,\n                         struct ofpbuf *out)\n{\n    struct ofpact_sample *sample = ofpact_put_SAMPLE(out);\n    if (!is_all_zeros(nas->zeros, sizeof nas->zeros)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n    if (nas->direction != NX_ACTION_SAMPLE_DEFAULT &&\n        nas->direction != NX_ACTION_SAMPLE_INGRESS &&\n        nas->direction != NX_ACTION_SAMPLE_EGRESS) {\n        VLOG_WARN_RL(&rl, \"invalid sample direction %\"PRIu8, nas->direction);\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n    return decode_SAMPLE2(nas, NXAST_RAW_SAMPLE3, nas->direction, sample);\n}\n\nstatic void\nencode_SAMPLE2(const struct ofpact_sample *sample,\n               struct nx_action_sample2 *nas)\n{\n    nas->probability = htons(sample->probability);\n    nas->collector_set_id = htonl(sample->collector_set_id);\n    nas->obs_domain_id = htonl(sample->obs_domain_id);\n    nas->obs_point_id = htonl(sample->obs_point_id);\n    nas->sampling_port = htons(ofp_to_u16(sample->sampling_port));\n    nas->direction = sample->direction;\n}\n\nstatic void\nencode_SAMPLE(const struct ofpact_sample *sample,\n              enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    if (sample->ofpact.raw == NXAST_RAW_SAMPLE3\n        || sample->direction != NX_ACTION_SAMPLE_DEFAULT) {\n        encode_SAMPLE2(sample, put_NXAST_SAMPLE3(out));\n    } else if (sample->ofpact.raw == NXAST_RAW_SAMPLE2\n               || sample->sampling_port != OFPP_NONE) {\n        encode_SAMPLE2(sample, put_NXAST_SAMPLE2(out));\n    } else {\n        struct nx_action_sample *nas = put_NXAST_SAMPLE(out);\n        nas->probability = htons(sample->probability);\n        nas->collector_set_id = htonl(sample->collector_set_id);\n        nas->obs_domain_id = htonl(sample->obs_domain_id);\n        nas->obs_point_id = htonl(sample->obs_point_id);\n    }\n}\n\n/* Parses 'arg' as the argument to a \"sample\" action, and appends such an\n * action to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SAMPLE(char *arg, struct ofpbuf *ofpacts,\n             enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_sample *os = ofpact_put_SAMPLE(ofpacts);\n    os->sampling_port = OFPP_NONE;\n    os->direction = NX_ACTION_SAMPLE_DEFAULT;\n\n    char *key, *value;\n    while (ofputil_parse_key_value(&arg, &key, &value)) {\n        char *error = NULL;\n\n        if (!strcmp(key, \"probability\")) {\n            error = str_to_u16(value, \"probability\", &os->probability);\n            if (!error && os->probability == 0) {\n                error = xasprintf(\"invalid probability value \\\"%s\\\"\", value);\n            }\n        } else if (!strcmp(key, \"collector_set_id\")) {\n            error = str_to_u32(value, &os->collector_set_id);\n        } else if (!strcmp(key, \"obs_domain_id\")) {\n            error = str_to_u32(value, &os->obs_domain_id);\n        } else if (!strcmp(key, \"obs_point_id\")) {\n            error = str_to_u32(value, &os->obs_point_id);\n        } else if (!strcmp(key, \"sampling_port\")) {\n            if (!ofputil_port_from_string(value, &os->sampling_port)) {\n                error = xasprintf(\"%s: unknown port\", value);\n            }\n        } else if (!strcmp(key, \"ingress\")) {\n            os->direction = NX_ACTION_SAMPLE_INGRESS;\n        } else if (!strcmp(key, \"egress\")) {\n            os->direction = NX_ACTION_SAMPLE_EGRESS;\n        } else {\n            error = xasprintf(\"invalid key \\\"%s\\\" in \\\"sample\\\" argument\",\n                              key);\n        }\n        if (error) {\n            return error;\n        }\n    }\n    if (os->probability == 0) {\n        return xstrdup(\"non-zero \\\"probability\\\" must be specified on sample\");\n    }\n\n    return NULL;\n}\n\nstatic void\nformat_SAMPLE(const struct ofpact_sample *a, struct ds *s)\n{\n    ds_put_format(s, \"%ssample(%s%sprobability=%s%\"PRIu16\n                  \",%scollector_set_id=%s%\"PRIu32\n                  \",%sobs_domain_id=%s%\"PRIu32\n                  \",%sobs_point_id=%s%\"PRIu32,\n                  colors.paren, colors.end,\n                  colors.param, colors.end, a->probability,\n                  colors.param, colors.end, a->collector_set_id,\n                  colors.param, colors.end, a->obs_domain_id,\n                  colors.param, colors.end, a->obs_point_id);\n    if (a->sampling_port != OFPP_NONE) {\n        ds_put_format(s, \",%ssampling_port=%s%\"PRIu32,\n                      colors.param, colors.end, a->sampling_port);\n    }\n    if (a->direction == NX_ACTION_SAMPLE_INGRESS) {\n        ds_put_format(s, \",%singress%s\", colors.param, colors.end);\n    } else if (a->direction == NX_ACTION_SAMPLE_EGRESS) {\n        ds_put_format(s, \",%segress%s\", colors.param, colors.end);\n    }\n    ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n}\n\f\n/* debug_recirc instruction. */\n\nstatic bool enable_debug;\n\nvoid\nofpact_dummy_enable(void)\n{\n    enable_debug = true;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_DEBUG_RECIRC(struct ofpbuf *out)\n{\n    if (!enable_debug) {\n        return OFPERR_OFPBAC_BAD_VENDOR_TYPE;\n    }\n\n    ofpact_put_DEBUG_RECIRC(out);\n    return 0;\n}\n\nstatic void\nencode_DEBUG_RECIRC(const struct ofpact_null *n OVS_UNUSED,\n                    enum ofp_version ofp_version OVS_UNUSED,\n                    struct ofpbuf *out)\n{\n    put_NXAST_DEBUG_RECIRC(out);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_DEBUG_RECIRC(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_DEBUG_RECIRC(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_DEBUG_RECIRC(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%sdebug_recirc%s\", colors.value, colors.end);\n}\n\n/* Action structure for NXAST_CT.\n *\n * Pass traffic to the connection tracker.\n *\n * There are two important concepts to understanding the connection tracking\n * interface: Packet state and Connection state. Packets may be \"Untracked\" or\n * \"Tracked\". Connections may be \"Uncommitted\" or \"Committed\".\n *\n *   - Packet State:\n *\n *      Untracked packets have not yet passed through the connection tracker,\n *      and the connection state for such packets is unknown. In most cases,\n *      packets entering the OpenFlow pipeline will initially be in the\n *      untracked state. Untracked packets may become tracked by executing\n *      NXAST_CT with a \"recirc_table\" specified. This makes various aspects\n *      about the connection available, in particular the connection state.\n *\n *      Tracked packets have previously passed through the connection tracker.\n *      These packets will remain tracked through until the end of the OpenFlow\n *      pipeline. Tracked packets which have NXAST_CT executed with a\n *      \"recirc_table\" specified will return to the tracked state.\n *\n *      The packet state is only significant for the duration of packet\n *      processing within the OpenFlow pipeline.\n *\n *   - Connection State:\n *\n *      Multiple packets may be associated with a single connection. Initially,\n *      all connections are uncommitted. The connection state corresponding to\n *      a packet is available in the NXM_NX_CT_STATE field for tracked packets.\n *\n *      Uncommitted connections have no state stored about them. Uncommitted\n *      connections may transition into the committed state by executing\n *      NXAST_CT with the NX_CT_F_COMMIT flag.\n *\n *      Once a connection becomes committed, information may be gathered about\n *      the connection by passing subsequent packets through the connection\n *      tracker, and the state of the connection will be stored beyond the\n *      lifetime of packet processing.\n *\n *      Connections may transition back into the uncommitted state due to\n *      external timers, or due to the contents of packets that are sent to the\n *      connection tracker. This behaviour is outside of the scope of the\n *      OpenFlow interface.\n *\n * The \"zone\" specifies a context within which the tracking is done:\n *\n *      The connection tracking zone is a 16-bit number. Each zone is an\n *      independent connection tracking context. The connection state for each\n *      connection is completely separate for each zone, so if a connection\n *      is committed to zone A, then it will remain uncommitted in zone B.\n *      If NXAST_CT is executed with the same zone multiple times, later\n *      executions have no effect.\n *\n *      If 'zone_src' is nonzero, this specifies that the zone should be\n *      sourced from a field zone_src[ofs:ofs+nbits]. The format and semantics\n *      of 'zone_src' and 'zone_ofs_nbits' are similar to those for the\n *      NXAST_REG_LOAD action. The acceptable nxm_header values for 'zone_src'\n *      are the same as the acceptable nxm_header values for the 'src' field of\n *      NXAST_REG_MOVE.\n *\n *      If 'zone_src' is zero, then the value of 'zone_imm' will be used as the\n *      connection tracking zone.\n *\n * The \"recirc_table\" allows NXM_NX_CT_* fields to become available:\n *\n *      If \"recirc_table\" has a value other than NX_CT_RECIRC_NONE, then the\n *      packet will be logically cloned prior to executing this action. One\n *      copy will be sent to the connection tracker, then will be re-injected\n *      into the OpenFlow pipeline beginning at the OpenFlow table specified in\n *      this field. When the packet re-enters the pipeline, the NXM_NX_CT_*\n *      fields will be populated. The original instance of the packet will\n *      continue the current actions list. This can be thought of as similar to\n *      the effect of the \"output\" action: One copy is sent out (in this case,\n *      to the connection tracker), but the current copy continues processing.\n *\n *      It is strongly recommended that this table is later than the current\n *      table, to prevent loops.\n *\n * The \"alg\" attaches protocol-specific behaviour to this action:\n *\n *      The ALG is a 16-bit number which specifies that additional\n *      processing should be applied to this traffic.\n *\n *      Protocol | Value | Meaning\n *      --------------------------------------------------------------------\n *      None     |     0 | No protocol-specific behaviour.\n *      FTP      |    21 | Parse FTP control connections and observe the\n *               |       | negotiation of related data connections.\n *      Other    | Other | Unsupported protocols.\n *\n *      By way of example, if FTP control connections have this action applied\n *      with the ALG set to FTP (21), then the connection tracker will observe\n *      the negotiation of data connections. This allows the connection\n *      tracker to identify subsequent data connections as \"related\" to this\n *      existing connection. The \"related\" flag will be populated in the\n *      NXM_NX_CT_STATE field for such connections if the 'recirc_table' is\n *      specified.\n *\n * Zero or more actions may immediately follow this action. These actions will\n * be executed within the context of the connection tracker, and they require\n * the NX_CT_F_COMMIT flag to be set.\n */\nstruct nx_action_conntrack {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* At least 24. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_CT. */\n    ovs_be16 flags;             /* Zero or more NX_CT_F_* flags.\n                                 * Unspecified flag bits must be zero. */\n    ovs_be32 zone_src;          /* Connection tracking context. */\n    union {\n        ovs_be16 zone_ofs_nbits;/* Range to use from source field. */\n        ovs_be16 zone_imm;      /* Immediate value for zone. */\n    };\n    uint8_t recirc_table;       /* Recirculate to a specific table, or\n                                   NX_CT_RECIRC_NONE for no recirculation. */\n    uint8_t pad[3];             /* Zeroes */\n    ovs_be16 alg;               /* Well-known port number for the protocol.\n                                 * 0 indicates no ALG is required. */\n    /* Followed by a sequence of zero or more OpenFlow actions. The length of\n     * these is included in 'len'. */\n};\nOFP_ASSERT(sizeof(struct nx_action_conntrack) == 24);\n\nstatic enum ofperr\ndecode_ct_zone(const struct nx_action_conntrack *nac,\n               struct ofpact_conntrack *out,\n               const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap)\n{\n    if (nac->zone_src) {\n        enum ofperr error;\n\n        out->zone_src.ofs = nxm_decode_ofs(nac->zone_ofs_nbits);\n        out->zone_src.n_bits = nxm_decode_n_bits(nac->zone_ofs_nbits);\n        error = mf_vl_mff_mf_from_nxm_header(ntohl(nac->zone_src),\n                                             vl_mff_map, &out->zone_src.field,\n                                             tlv_bitmap);\n        if (error) {\n            return error;\n        }\n\n        error = mf_check_src(&out->zone_src, NULL);\n        if (error) {\n            return error;\n        }\n\n        if (out->zone_src.n_bits != 16) {\n            VLOG_WARN_RL(&rl, \"zone n_bits %d not within valid range [16..16]\",\n                         out->zone_src.n_bits);\n            return OFPERR_OFPBAC_BAD_SET_LEN;\n        }\n    } else {\n        out->zone_src.field = NULL;\n        out->zone_imm = ntohs(nac->zone_imm);\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_CT(const struct nx_action_conntrack *nac,\n                    enum ofp_version ofp_version,\n                    const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap,\n                    struct ofpbuf *out)\n{\n    const size_t ct_offset = ofpacts_pull(out);\n    struct ofpact_conntrack *conntrack = ofpact_put_CT(out);\n    conntrack->flags = ntohs(nac->flags);\n\n    int error = decode_ct_zone(nac, conntrack, vl_mff_map, tlv_bitmap);\n    if (error) {\n        goto out;\n    }\n    conntrack->recirc_table = nac->recirc_table;\n    conntrack->alg = ntohs(nac->alg);\n\n    ofpbuf_pull(out, sizeof(*conntrack));\n\n    struct ofpbuf openflow = ofpbuf_const_initializer(\n        nac + 1, ntohs(nac->len) - sizeof(*nac));\n    error = ofpacts_pull_openflow_actions__(&openflow, openflow.size,\n                                            ofp_version,\n                                            1u << OVSINST_OFPIT11_APPLY_ACTIONS,\n                                            out, OFPACT_CT, vl_mff_map,\n                                            tlv_bitmap);\n    if (error) {\n        goto out;\n    }\n\n    conntrack = ofpbuf_push_uninit(out, sizeof(*conntrack));\n    out->header = &conntrack->ofpact;\n    ofpact_finish_CT(out, &conntrack);\n\n    if (conntrack->ofpact.len > sizeof(*conntrack)\n        && !(conntrack->flags & NX_CT_F_COMMIT)) {\n        const struct ofpact *a;\n        size_t ofpacts_len = conntrack->ofpact.len - sizeof(*conntrack);\n\n        OFPACT_FOR_EACH (a, conntrack->actions, ofpacts_len) {\n            if (a->type != OFPACT_NAT || ofpact_get_NAT(a)->flags\n                || ofpact_get_NAT(a)->range_af != AF_UNSPEC) {\n                VLOG_WARN_RL(&rl, \"CT action requires commit flag if actions \"\n                             \"other than NAT without arguments are specified.\");\n                error = OFPERR_OFPBAC_BAD_ARGUMENT;\n                goto out;\n            }\n        }\n    }\n\nout:\n    ofpbuf_push_uninit(out, ct_offset);\n    return error;\n}\n\nstatic void\nencode_CT(const struct ofpact_conntrack *conntrack,\n          enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    struct nx_action_conntrack *nac;\n    const size_t ofs = out->size;\n    size_t len;\n\n    nac = put_NXAST_CT(out);\n    nac->flags = htons(conntrack->flags);\n    if (conntrack->zone_src.field) {\n        nac->zone_src = htonl(nxm_header_from_mff(conntrack->zone_src.field));\n        nac->zone_ofs_nbits = nxm_encode_ofs_nbits(conntrack->zone_src.ofs,\n                                                   conntrack->zone_src.n_bits);\n    } else {\n        nac->zone_src = htonl(0);\n        nac->zone_imm = htons(conntrack->zone_imm);\n    }\n    nac->recirc_table = conntrack->recirc_table;\n    nac->alg = htons(conntrack->alg);\n\n    len = ofpacts_put_openflow_actions(conntrack->actions,\n                                       ofpact_ct_get_action_len(conntrack),\n                                       out, ofp_version);\n    len += sizeof(*nac);\n    nac = ofpbuf_at(out, ofs, sizeof(*nac));\n    nac->len = htons(len);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT parse_NAT(char *arg, struct ofpbuf *,\n                                               enum ofputil_protocol * OVS_UNUSED);\n\n/* Parses 'arg' as the argument to a \"ct\" action, and appends such an\n * action to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_CT(char *arg, struct ofpbuf *ofpacts,\n         enum ofputil_protocol *usable_protocols)\n{\n    const size_t ct_offset = ofpacts_pull(ofpacts);\n    struct ofpact_conntrack *oc;\n    char *error = NULL;\n    char *key, *value;\n\n    oc = ofpact_put_CT(ofpacts);\n    oc->flags = 0;\n    oc->recirc_table = NX_CT_RECIRC_NONE;\n    while (ofputil_parse_key_value(&arg, &key, &value)) {\n        if (!strcmp(key, \"commit\")) {\n            oc->flags |= NX_CT_F_COMMIT;\n        } else if (!strcmp(key, \"table\")) {\n            error = str_to_u8(value, \"recirc_table\", &oc->recirc_table);\n            if (!error && oc->recirc_table == NX_CT_RECIRC_NONE) {\n                error = xasprintf(\"invalid table %#\"PRIx16, oc->recirc_table);\n            }\n        } else if (!strcmp(key, \"zone\")) {\n            error = str_to_u16(value, \"zone\", &oc->zone_imm);\n\n            if (error) {\n                free(error);\n                error = mf_parse_subfield(&oc->zone_src, value);\n                if (error) {\n                    return error;\n                }\n            }\n        } else if (!strcmp(key, \"alg\")) {\n            error = str_to_connhelper(value, &oc->alg);\n        } else if (!strcmp(key, \"nat\")) {\n            const size_t nat_offset = ofpacts_pull(ofpacts);\n\n            error = parse_NAT(value, ofpacts, usable_protocols);\n            /* Update CT action pointer and length. */\n            ofpacts->header = ofpbuf_push_uninit(ofpacts, nat_offset);\n            oc = ofpacts->header;\n        } else if (!strcmp(key, \"exec\")) {\n            /* Hide existing actions from ofpacts_parse_copy(), so the\n             * nesting can be handled transparently. */\n            enum ofputil_protocol usable_protocols2;\n            const size_t exec_offset = ofpacts_pull(ofpacts);\n\n            /* Initializes 'usable_protocol2', fold it back to\n             * '*usable_protocols' afterwards, so that we do not lose\n             * restrictions already in there. */\n            error = ofpacts_parse_copy(value, ofpacts, &usable_protocols2,\n                                       false, OFPACT_CT);\n            *usable_protocols &= usable_protocols2;\n            ofpacts->header = ofpbuf_push_uninit(ofpacts, exec_offset);\n            oc = ofpacts->header;\n        } else {\n            error = xasprintf(\"invalid argument to \\\"ct\\\" action: `%s'\", key);\n        }\n        if (error) {\n            break;\n        }\n    }\n\n    ofpact_finish_CT(ofpacts, &oc);\n    ofpbuf_push_uninit(ofpacts, ct_offset);\n    return error;\n}\n\nstatic void\nformat_alg(int port, struct ds *s)\n{\n    switch(port) {\n    case IPPORT_FTP:\n        ds_put_format(s, \"%salg=%sftp,\", colors.param, colors.end);\n        break;\n    case IPPORT_TFTP:\n        ds_put_format(s, \"%salg=%stftp,\", colors.param, colors.end);\n        break;\n    case 0:\n        /* Don't print. */\n        break;\n    default:\n        ds_put_format(s, \"%salg=%s%d,\", colors.param, colors.end, port);\n        break;\n    }\n}\n\nstatic void format_NAT(const struct ofpact_nat *a, struct ds *ds);\n\nstatic void\nformat_CT(const struct ofpact_conntrack *a, struct ds *s)\n{\n    ds_put_format(s, \"%sct(%s\", colors.paren, colors.end);\n    if (a->flags & NX_CT_F_COMMIT) {\n        ds_put_format(s, \"%scommit%s,\", colors.value, colors.end);\n    }\n    if (a->recirc_table != NX_CT_RECIRC_NONE) {\n        ds_put_format(s, \"%stable=%s%\"PRIu8\",\",\n                      colors.special, colors.end, a->recirc_table);\n    }\n    if (a->zone_src.field) {\n        ds_put_format(s, \"%szone=%s\", colors.param, colors.end);\n        mf_format_subfield(&a->zone_src, s);\n        ds_put_char(s, ',');\n    } else if (a->zone_imm) {\n        ds_put_format(s, \"%szone=%s%\"PRIu16\",\",\n                      colors.param, colors.end, a->zone_imm);\n    }\n    /* If the first action is a NAT action, format it outside of the 'exec'\n     * envelope. */\n    const struct ofpact *action = a->actions;\n    size_t actions_len = ofpact_ct_get_action_len(a);\n    if (actions_len && action->type == OFPACT_NAT) {\n        format_NAT(ofpact_get_NAT(action), s);\n        ds_put_char(s, ',');\n        actions_len -= OFPACT_ALIGN(action->len);\n        action = ofpact_next(action);\n    }\n    if (actions_len) {\n        ds_put_format(s, \"%sexec(%s\", colors.paren, colors.end);\n        ofpacts_format(action, actions_len, s);\n        ds_put_format(s, \"%s),%s\", colors.paren, colors.end);\n    }\n    format_alg(a->alg, s);\n    ds_chomp(s, ',');\n    ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n}\n\f\n/* ct_clear action. */\n\nstatic enum ofperr\ndecode_NXAST_RAW_CT_CLEAR(struct ofpbuf *out)\n{\n    ofpact_put_CT_CLEAR(out);\n    return 0;\n}\n\nstatic void\nencode_CT_CLEAR(const struct ofpact_null *null OVS_UNUSED,\n                enum ofp_version ofp_version OVS_UNUSED,\n                struct ofpbuf *out)\n{\n    put_NXAST_CT_CLEAR(out);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_CT_CLEAR(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n               enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_CT_CLEAR(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_CT_CLEAR(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%sct_clear%s\", colors.value, colors.end);\n}\f\n/* NAT action. */\n\n/* Which optional fields are present? */\nenum nx_nat_range {\n    NX_NAT_RANGE_IPV4_MIN  = 1 << 0, /* ovs_be32 */\n    NX_NAT_RANGE_IPV4_MAX  = 1 << 1, /* ovs_be32 */\n    NX_NAT_RANGE_IPV6_MIN  = 1 << 2, /* struct in6_addr */\n    NX_NAT_RANGE_IPV6_MAX  = 1 << 3, /* struct in6_addr */\n    NX_NAT_RANGE_PROTO_MIN = 1 << 4, /* ovs_be16 */\n    NX_NAT_RANGE_PROTO_MAX = 1 << 5, /* ovs_be16 */\n};\n\n/* Action structure for NXAST_NAT. */\nstruct nx_action_nat {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* At least 16. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_NAT. */\n    uint8_t  pad[2];            /* Must be zero. */\n    ovs_be16 flags;             /* Zero or more NX_NAT_F_* flags.\n                                 * Unspecified flag bits must be zero. */\n    ovs_be16 range_present;     /* NX_NAT_RANGE_* */\n    /* Followed by optional parameters as specified by 'range_present' */\n};\nOFP_ASSERT(sizeof(struct nx_action_nat) == 16);\n\nstatic void\nencode_NAT(const struct ofpact_nat *nat,\n           enum ofp_version ofp_version OVS_UNUSED,\n           struct ofpbuf *out)\n{\n    struct nx_action_nat *nan;\n    const size_t ofs = out->size;\n    uint16_t range_present = 0;\n\n    nan = put_NXAST_NAT(out);\n    nan->flags = htons(nat->flags);\n    if (nat->range_af == AF_INET) {\n        if (nat->range.addr.ipv4.min) {\n            ovs_be32 *min = ofpbuf_put_uninit(out, sizeof *min);\n            *min = nat->range.addr.ipv4.min;\n            range_present |= NX_NAT_RANGE_IPV4_MIN;\n        }\n        if (nat->range.addr.ipv4.max) {\n            ovs_be32 *max = ofpbuf_put_uninit(out, sizeof *max);\n            *max = nat->range.addr.ipv4.max;\n            range_present |= NX_NAT_RANGE_IPV4_MAX;\n        }\n    } else if (nat->range_af == AF_INET6) {\n        if (!ipv6_mask_is_any(&nat->range.addr.ipv6.min)) {\n            struct in6_addr *min = ofpbuf_put_uninit(out, sizeof *min);\n            *min = nat->range.addr.ipv6.min;\n            range_present |= NX_NAT_RANGE_IPV6_MIN;\n        }\n        if (!ipv6_mask_is_any(&nat->range.addr.ipv6.max)) {\n            struct in6_addr *max = ofpbuf_put_uninit(out, sizeof *max);\n            *max = nat->range.addr.ipv6.max;\n            range_present |= NX_NAT_RANGE_IPV6_MAX;\n        }\n    }\n    if (nat->range_af != AF_UNSPEC) {\n        if (nat->range.proto.min) {\n            ovs_be16 *min = ofpbuf_put_uninit(out, sizeof *min);\n            *min = htons(nat->range.proto.min);\n            range_present |= NX_NAT_RANGE_PROTO_MIN;\n        }\n        if (nat->range.proto.max) {\n            ovs_be16 *max = ofpbuf_put_uninit(out, sizeof *max);\n            *max = htons(nat->range.proto.max);\n            range_present |= NX_NAT_RANGE_PROTO_MAX;\n        }\n    }\n    pad_ofpat(out, ofs);\n    nan = ofpbuf_at(out, ofs, sizeof *nan);\n    nan->range_present = htons(range_present);\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_NAT(const struct nx_action_nat *nan,\n                     enum ofp_version ofp_version OVS_UNUSED,\n                     struct ofpbuf *out)\n{\n    struct ofpact_nat *nat;\n    uint16_t range_present = ntohs(nan->range_present);\n    const char *opts = (char *)(nan + 1);\n    uint16_t len = ntohs(nan->len) - sizeof *nan;\n\n    nat = ofpact_put_NAT(out);\n    nat->flags = ntohs(nan->flags);\n\n    /* Check for unknown or mutually exclusive flags. */\n    if ((nat->flags & ~NX_NAT_F_MASK)\n        || (nat->flags & NX_NAT_F_SRC && nat->flags & NX_NAT_F_DST)\n        || (nat->flags & NX_NAT_F_PROTO_HASH\n            && nat->flags & NX_NAT_F_PROTO_RANDOM)) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n#define NX_NAT_GET_OPT(DST, SRC, LEN, TYPE)                     \\\n    (LEN >= sizeof(TYPE)                                        \\\n     ? (memcpy(DST, SRC, sizeof(TYPE)), LEN -= sizeof(TYPE),    \\\n        SRC += sizeof(TYPE))                                    \\\n     : NULL)\n\n    nat->range_af = AF_UNSPEC;\n    if (range_present & NX_NAT_RANGE_IPV4_MIN) {\n        if (range_present & (NX_NAT_RANGE_IPV6_MIN | NX_NAT_RANGE_IPV6_MAX)) {\n            return OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n\n        if (!NX_NAT_GET_OPT(&nat->range.addr.ipv4.min, opts, len, ovs_be32)\n            || !nat->range.addr.ipv4.min) {\n            return OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n\n        nat->range_af = AF_INET;\n\n        if (range_present & NX_NAT_RANGE_IPV4_MAX) {\n            if (!NX_NAT_GET_OPT(&nat->range.addr.ipv4.max, opts, len,\n                                ovs_be32)) {\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n            if (ntohl(nat->range.addr.ipv4.max)\n                < ntohl(nat->range.addr.ipv4.min)) {\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n        }\n    } else if (range_present & NX_NAT_RANGE_IPV4_MAX) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else if (range_present & NX_NAT_RANGE_IPV6_MIN) {\n        if (!NX_NAT_GET_OPT(&nat->range.addr.ipv6.min, opts, len,\n                            struct in6_addr)\n            || ipv6_mask_is_any(&nat->range.addr.ipv6.min)) {\n            return OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n\n        nat->range_af = AF_INET6;\n\n        if (range_present & NX_NAT_RANGE_IPV6_MAX) {\n            if (!NX_NAT_GET_OPT(&nat->range.addr.ipv6.max, opts, len,\n                                struct in6_addr)) {\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n            if (memcmp(&nat->range.addr.ipv6.max, &nat->range.addr.ipv6.min,\n                       sizeof(struct in6_addr)) < 0) {\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n        }\n    } else if (range_present & NX_NAT_RANGE_IPV6_MAX) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    if (range_present & NX_NAT_RANGE_PROTO_MIN) {\n        ovs_be16 proto;\n\n        if (nat->range_af == AF_UNSPEC) {\n            return OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n        if (!NX_NAT_GET_OPT(&proto, opts, len, ovs_be16) || proto == 0) {\n            return OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n        nat->range.proto.min = ntohs(proto);\n        if (range_present & NX_NAT_RANGE_PROTO_MAX) {\n            if (!NX_NAT_GET_OPT(&proto, opts, len, ovs_be16)) {\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n            nat->range.proto.max = ntohs(proto);\n            if (nat->range.proto.max < nat->range.proto.min) {\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n        }\n    } else if (range_present & NX_NAT_RANGE_PROTO_MAX) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    return 0;\n}\n\nstatic void\nformat_NAT(const struct ofpact_nat *a, struct ds *ds)\n{\n    ds_put_format(ds, \"%snat%s\", colors.paren, colors.end);\n\n    if (a->flags & (NX_NAT_F_SRC | NX_NAT_F_DST)) {\n        ds_put_format(ds, \"%s(%s\", colors.paren, colors.end);\n        ds_put_format(ds, a->flags & NX_NAT_F_SRC ? \"%ssrc%s\" : \"%sdst%s\",\n                      colors.param, colors.end);\n\n        if (a->range_af != AF_UNSPEC) {\n            ds_put_format(ds, \"%s=%s\", colors.param, colors.end);\n\n            if (a->range_af == AF_INET) {\n                ds_put_format(ds, IP_FMT, IP_ARGS(a->range.addr.ipv4.min));\n\n                if (a->range.addr.ipv4.max\n                    && a->range.addr.ipv4.max != a->range.addr.ipv4.min) {\n                    ds_put_format(ds, \"-\"IP_FMT,\n                                  IP_ARGS(a->range.addr.ipv4.max));\n                }\n            } else if (a->range_af == AF_INET6) {\n                ipv6_format_addr_bracket(&a->range.addr.ipv6.min, ds,\n                                        a->range.proto.min);\n\n                if (!ipv6_mask_is_any(&a->range.addr.ipv6.max)\n                    && memcmp(&a->range.addr.ipv6.max, &a->range.addr.ipv6.min,\n                              sizeof(struct in6_addr)) != 0) {\n                    ds_put_char(ds, '-');\n                    ipv6_format_addr_bracket(&a->range.addr.ipv6.max, ds,\n                                            a->range.proto.min);\n                }\n            }\n            if (a->range.proto.min) {\n                ds_put_char(ds, ':');\n                ds_put_format(ds, \"%\"PRIu16, a->range.proto.min);\n\n                if (a->range.proto.max\n                    && a->range.proto.max != a->range.proto.min) {\n                    ds_put_format(ds, \"-%\"PRIu16, a->range.proto.max);\n                }\n            }\n            ds_put_char(ds, ',');\n\n            if (a->flags & NX_NAT_F_PERSISTENT) {\n                ds_put_format(ds, \"%spersistent%s,\",\n                              colors.value, colors.end);\n            }\n            if (a->flags & NX_NAT_F_PROTO_HASH) {\n                ds_put_format(ds, \"%shash%s,\", colors.value, colors.end);\n            }\n            if (a->flags & NX_NAT_F_PROTO_RANDOM) {\n                ds_put_format(ds, \"%srandom%s,\", colors.value, colors.end);\n            }\n        }\n        ds_chomp(ds, ',');\n        ds_put_format(ds, \"%s)%s\", colors.paren, colors.end);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nstr_to_nat_range(const char *s, struct ofpact_nat *on)\n{\n    char ipv6_s[IPV6_SCAN_LEN + 1];\n    int n = 0;\n\n    on->range_af = AF_UNSPEC;\n    if (ovs_scan_len(s, &n, IP_SCAN_FMT,\n                     IP_SCAN_ARGS(&on->range.addr.ipv4.min))) {\n        on->range_af = AF_INET;\n\n        if (s[n] == '-') {\n            n++;\n            if (!ovs_scan_len(s, &n, IP_SCAN_FMT,\n                              IP_SCAN_ARGS(&on->range.addr.ipv4.max))\n                || (ntohl(on->range.addr.ipv4.max)\n                    < ntohl(on->range.addr.ipv4.min))) {\n                goto error;\n            }\n        }\n    } else if ((ovs_scan_len(s, &n, IPV6_SCAN_FMT, ipv6_s)\n                || ovs_scan_len(s, &n, \"[\"IPV6_SCAN_FMT\"]\", ipv6_s))\n               && inet_pton(AF_INET6, ipv6_s, &on->range.addr.ipv6.min) == 1) {\n        on->range_af = AF_INET6;\n\n        if (s[n] == '-') {\n            n++;\n            if (!(ovs_scan_len(s, &n, IPV6_SCAN_FMT, ipv6_s)\n                  || ovs_scan_len(s, &n, \"[\"IPV6_SCAN_FMT\"]\", ipv6_s))\n                || inet_pton(AF_INET6, ipv6_s, &on->range.addr.ipv6.max) != 1\n                || memcmp(&on->range.addr.ipv6.max, &on->range.addr.ipv6.min,\n                          sizeof on->range.addr.ipv6.max) < 0) {\n                goto error;\n            }\n        }\n    }\n    if (on->range_af != AF_UNSPEC && s[n] == ':') {\n        n++;\n        if (!ovs_scan_len(s, &n, \"%\"SCNu16, &on->range.proto.min)) {\n            goto error;\n        }\n        if (s[n] == '-') {\n            n++;\n            if (!ovs_scan_len(s, &n, \"%\"SCNu16, &on->range.proto.max)\n                || on->range.proto.max < on->range.proto.min) {\n                goto error;\n            }\n        }\n    }\n    if (strlen(s) != n) {\n        return xasprintf(\"garbage (%s) after nat range \\\"%s\\\" (pos: %d)\",\n                         &s[n], s, n);\n    }\n    return NULL;\nerror:\n    return xasprintf(\"invalid nat range \\\"%s\\\"\", s);\n}\n\n\n/* Parses 'arg' as the argument to a \"nat\" action, and appends such an\n * action to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_NAT(char *arg, struct ofpbuf *ofpacts,\n          enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_nat *on = ofpact_put_NAT(ofpacts);\n    char *key, *value;\n\n    on->flags = 0;\n    on->range_af = AF_UNSPEC;\n\n    while (ofputil_parse_key_value(&arg, &key, &value)) {\n        char *error = NULL;\n\n        if (!strcmp(key, \"src\")) {\n            on->flags |= NX_NAT_F_SRC;\n            error = str_to_nat_range(value, on);\n        } else if (!strcmp(key, \"dst\")) {\n            on->flags |= NX_NAT_F_DST;\n            error = str_to_nat_range(value, on);\n        } else if (!strcmp(key, \"persistent\")) {\n            on->flags |= NX_NAT_F_PERSISTENT;\n        } else if (!strcmp(key, \"hash\")) {\n            on->flags |= NX_NAT_F_PROTO_HASH;\n        } else if (!strcmp(key, \"random\")) {\n            on->flags |= NX_NAT_F_PROTO_RANDOM;\n        } else {\n            error = xasprintf(\"invalid key \\\"%s\\\" in \\\"nat\\\" argument\",\n                              key);\n        }\n        if (error) {\n            return error;\n        }\n    }\n    if (on->flags & NX_NAT_F_SRC && on->flags & NX_NAT_F_DST) {\n        return xasprintf(\"May only specify one of \\\"src\\\" or \\\"dst\\\".\");\n    }\n    if (!(on->flags & NX_NAT_F_SRC || on->flags & NX_NAT_F_DST)) {\n        if (on->flags) {\n            return xasprintf(\"Flags allowed only with \\\"src\\\" or \\\"dst\\\".\");\n        }\n        if (on->range_af != AF_UNSPEC) {\n            return xasprintf(\"Range allowed only with \\\"src\\\" or \\\"dst\\\".\");\n        }\n    }\n    if (on->flags & NX_NAT_F_PROTO_HASH && on->flags & NX_NAT_F_PROTO_RANDOM) {\n        return xasprintf(\"Both \\\"hash\\\" and \\\"random\\\" are not allowed.\");\n    }\n\n    return NULL;\n}\n\n/* Truncate output action. */\nstruct nx_action_output_trunc {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* At least 16. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_OUTPUT_TRUNC. */\n    ovs_be16 port;              /* Output port */\n    ovs_be32 max_len;           /* Truncate packet to size bytes */\n};\nOFP_ASSERT(sizeof(struct nx_action_output_trunc) == 16);\n\nstatic enum ofperr\ndecode_NXAST_RAW_OUTPUT_TRUNC(const struct nx_action_output_trunc *natrc,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    struct ofpact_output_trunc *output_trunc;\n\n    output_trunc = ofpact_put_OUTPUT_TRUNC(out);\n    output_trunc->max_len = ntohl(natrc->max_len);\n    output_trunc->port = u16_to_ofp(ntohs(natrc->port));\n\n    if (output_trunc->max_len < ETH_HEADER_LEN) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n    return 0;\n}\n\nstatic void\nencode_OUTPUT_TRUNC(const struct ofpact_output_trunc *output_trunc,\n                  enum ofp_version ofp_version OVS_UNUSED,\n                  struct ofpbuf *out)\n{\n    struct nx_action_output_trunc *natrc = put_NXAST_OUTPUT_TRUNC(out);\n\n    natrc->max_len = htonl(output_trunc->max_len);\n    natrc->port = htons(ofp_to_u16(output_trunc->port));\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_OUTPUT_TRUNC(const char *arg, struct ofpbuf *ofpacts OVS_UNUSED,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    /* Disable output_trunc parsing.  Expose as output(port=N,max_len=M) and\n     * reuse parse_OUTPUT to parse output_trunc action. */\n    return xasprintf(\"unknown action %s\", arg);\n}\n\nstatic void\nformat_OUTPUT_TRUNC(const struct ofpact_output_trunc *a, struct ds *s)\n{\n     ds_put_format(s, \"%soutput%s(port=%\"PRIu32\",max_len=%\"PRIu32\")\",\n                   colors.special, colors.end, a->port, a->max_len);\n}\n\n\f\n/* Meter instruction. */\n\nstatic void\nencode_METER(const struct ofpact_meter *meter,\n             enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version >= OFP13_VERSION) {\n        instruction_put_OFPIT13_METER(out)->meter_id = htonl(meter->meter_id);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_METER(char *arg, struct ofpbuf *ofpacts,\n            enum ofputil_protocol *usable_protocols)\n{\n    *usable_protocols &= OFPUTIL_P_OF13_UP;\n    return str_to_u32(arg, &ofpact_put_METER(ofpacts)->meter_id);\n}\n\nstatic void\nformat_METER(const struct ofpact_meter *a, struct ds *s)\n{\n    ds_put_format(s, \"%smeter:%s%\"PRIu32,\n                  colors.param, colors.end, a->meter_id);\n}\n\f\n/* Clear-Actions instruction. */\n\nstatic void\nencode_CLEAR_ACTIONS(const struct ofpact_null *null OVS_UNUSED,\n                     enum ofp_version ofp_version OVS_UNUSED,\n                     struct ofpbuf *out OVS_UNUSED)\n{\n    if (ofp_version > OFP10_VERSION) {\n        instruction_put_OFPIT11_CLEAR_ACTIONS(out);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_CLEAR_ACTIONS(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n                    enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_CLEAR_ACTIONS(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_CLEAR_ACTIONS(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%sclear_actions%s\", colors.value, colors.end);\n}\n\f\n/* Write-Actions instruction. */\n\nstatic void\nencode_WRITE_ACTIONS(const struct ofpact_nest *actions,\n                     enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version > OFP10_VERSION) {\n        const size_t ofs = out->size;\n\n        instruction_put_OFPIT11_WRITE_ACTIONS(out);\n        ofpacts_put_openflow_actions(actions->actions,\n                                     ofpact_nest_get_action_len(actions),\n                                     out, ofp_version);\n        ofpacts_update_instruction_actions(out, ofs);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_WRITE_ACTIONS(char *arg, struct ofpbuf *ofpacts,\n                    enum ofputil_protocol *usable_protocols)\n{\n    size_t ofs = ofpacts_pull(ofpacts);\n    struct ofpact_nest *on;\n    char *error;\n\n    /* Add a Write-Actions instruction and then pull it off. */\n    ofpact_put(ofpacts, OFPACT_WRITE_ACTIONS, sizeof *on);\n    ofpbuf_pull(ofpacts, sizeof *on);\n\n    /* Parse nested actions.\n     *\n     * We pulled off \"write-actions\" and the previous actions because the\n     * OFPACT_WRITE_ACTIONS is only partially constructed: its length is such\n     * that it doesn't actually include the nested actions.  That means that\n     * ofpacts_parse() would reject them as being part of an Apply-Actions that\n     * follows a Write-Actions, which is an invalid order.  */\n    error = ofpacts_parse(arg, ofpacts, usable_protocols, false,\n                          OFPACT_WRITE_ACTIONS);\n\n    /* Put the Write-Actions back on and update its length. */\n    on = ofpbuf_push_uninit(ofpacts, sizeof *on);\n    on->ofpact.len = ofpacts->size;\n\n    /* Put any previous actions or instructions back on. */\n    ofpbuf_push_uninit(ofpacts, ofs);\n\n    return error;\n}\n\nstatic void\nformat_WRITE_ACTIONS(const struct ofpact_nest *a, struct ds *s)\n{\n    ds_put_format(s, \"%swrite_actions(%s\", colors.paren, colors.end);\n    ofpacts_format(a->actions, ofpact_nest_get_action_len(a), s);\n    ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n}\n\f\n/* Action structure for NXAST_WRITE_METADATA.\n *\n * Modifies the 'mask' bits of the metadata value. */\nstruct nx_action_write_metadata {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 32. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_WRITE_METADATA. */\n    uint8_t zeros[6];               /* Must be zero. */\n    ovs_be64 metadata;              /* Metadata register. */\n    ovs_be64 mask;                  /* Metadata mask. */\n};\nOFP_ASSERT(sizeof(struct nx_action_write_metadata) == 32);\n\nstatic enum ofperr\ndecode_NXAST_RAW_WRITE_METADATA(const struct nx_action_write_metadata *nawm,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    struct ofpact_metadata *om;\n\n    if (!is_all_zeros(nawm->zeros, sizeof nawm->zeros)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    om = ofpact_put_WRITE_METADATA(out);\n    om->metadata = nawm->metadata;\n    om->mask = nawm->mask;\n\n    return 0;\n}\n\nstatic void\nencode_WRITE_METADATA(const struct ofpact_metadata *metadata,\n                      enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version == OFP10_VERSION) {\n        struct nx_action_write_metadata *nawm;\n\n        nawm = put_NXAST_WRITE_METADATA(out);\n        nawm->metadata = metadata->metadata;\n        nawm->mask = metadata->mask;\n    } else {\n        struct ofp11_instruction_write_metadata *oiwm;\n\n        oiwm = instruction_put_OFPIT11_WRITE_METADATA(out);\n        oiwm->metadata = metadata->metadata;\n        oiwm->metadata_mask = metadata->mask;\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_WRITE_METADATA(char *arg, struct ofpbuf *ofpacts,\n                     enum ofputil_protocol *usable_protocols)\n{\n    struct ofpact_metadata *om;\n    char *mask = strchr(arg, '/');\n\n    *usable_protocols &= OFPUTIL_P_NXM_OF11_UP;\n\n    om = ofpact_put_WRITE_METADATA(ofpacts);\n    if (mask) {\n        char *error;\n\n        *mask = '\\0';\n        error = str_to_be64(mask + 1, &om->mask);\n        if (error) {\n            return error;\n        }\n    } else {\n        om->mask = OVS_BE64_MAX;\n    }\n\n    return str_to_be64(arg, &om->metadata);\n}\n\nstatic void\nformat_WRITE_METADATA(const struct ofpact_metadata *a, struct ds *s)\n{\n    ds_put_format(s, \"%swrite_metadata:%s%#\"PRIx64,\n                  colors.param, colors.end, ntohll(a->metadata));\n    if (a->mask != OVS_BE64_MAX) {\n        ds_put_format(s, \"/%#\"PRIx64, ntohll(a->mask));\n    }\n}\n\f\n/* Goto-Table instruction. */\n\nstatic void\nencode_GOTO_TABLE(const struct ofpact_goto_table *goto_table,\n                  enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version == OFP10_VERSION) {\n        struct nx_action_resubmit *nar;\n\n        nar = put_NXAST_RESUBMIT_TABLE(out);\n        nar->table = goto_table->table_id;\n        nar->in_port = htons(ofp_to_u16(OFPP_IN_PORT));\n    } else {\n        struct ofp11_instruction_goto_table *oigt;\n\n        oigt = instruction_put_OFPIT11_GOTO_TABLE(out);\n        oigt->table_id = goto_table->table_id;\n        memset(oigt->pad, 0, sizeof oigt->pad);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_GOTO_TABLE(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_goto_table *ogt = ofpact_put_GOTO_TABLE(ofpacts);\n    char *table_s = strsep(&arg, \",\");\n    if (!table_s || !table_s[0]) {\n        return xstrdup(\"instruction goto-table needs table id\");\n    }\n    return str_to_u8(table_s, \"table\", &ogt->table_id);\n}\n\nstatic void\nformat_GOTO_TABLE(const struct ofpact_goto_table *a, struct ds *s)\n{\n    ds_put_format(s, \"%sgoto_table:%s%\"PRIu8,\n                  colors.param, colors.end, a->table_id);\n}\n\f\nstatic void\nlog_bad_action(const struct ofp_action_header *actions, size_t actions_len,\n               const struct ofp_action_header *bad_action, enum ofperr error)\n{\n    if (!VLOG_DROP_WARN(&rl)) {\n        struct ds s;\n\n        ds_init(&s);\n        ds_put_hex_dump(&s, actions, actions_len, 0, false);\n        VLOG_WARN(\"bad action at offset %#\"PRIxPTR\" (%s):\\n%s\",\n                  (char *)bad_action - (char *)actions,\n                  ofperr_get_name(error), ds_cstr(&s));\n        ds_destroy(&s);\n    }\n}\n\nstatic enum ofperr\nofpacts_decode(const void *actions, size_t actions_len,\n               enum ofp_version ofp_version,\n               const struct vl_mff_map *vl_mff_map,\n               uint64_t *ofpacts_tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpbuf openflow = ofpbuf_const_initializer(actions, actions_len);\n    while (openflow.size) {\n        const struct ofp_action_header *action = openflow.data;\n        enum ofp_raw_action_type raw;\n        enum ofperr error;\n        uint64_t arg;\n\n        error = ofpact_pull_raw(&openflow, ofp_version, &raw, &arg);\n        if (!error) {\n            error = ofpact_decode(action, raw, ofp_version, arg, vl_mff_map,\n                                  ofpacts_tlv_bitmap, ofpacts);\n        }\n\n        if (error) {\n            log_bad_action(actions, actions_len, action, error);\n            return error;\n        }\n    }\n    return 0;\n}\n\nstatic enum ofperr\nofpacts_pull_openflow_actions__(struct ofpbuf *openflow,\n                                unsigned int actions_len,\n                                enum ofp_version version,\n                                uint32_t allowed_ovsinsts,\n                                struct ofpbuf *ofpacts,\n                                enum ofpact_type outer_action,\n                                const struct vl_mff_map *vl_mff_map,\n                                uint64_t *ofpacts_tlv_bitmap)\n{\n    const struct ofp_action_header *actions;\n    size_t orig_size = ofpacts->size;\n    enum ofperr error;\n\n    if (actions_len % OFP_ACTION_ALIGN != 0) {\n        VLOG_WARN_RL(&rl, \"OpenFlow message actions length %u is not a \"\n                     \"multiple of %d\", actions_len, OFP_ACTION_ALIGN);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    actions = ofpbuf_try_pull(openflow, actions_len);\n    if (actions == NULL) {\n        VLOG_WARN_RL(&rl, \"OpenFlow message actions length %u exceeds \"\n                     \"remaining message length (%\"PRIu32\")\",\n                     actions_len, openflow->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    error = ofpacts_decode(actions, actions_len, version, vl_mff_map,\n                           ofpacts_tlv_bitmap, ofpacts);\n    if (error) {\n        ofpacts->size = orig_size;\n        return error;\n    }\n\n    error = ofpacts_verify(ofpacts->data, ofpacts->size, allowed_ovsinsts,\n                           outer_action);\n    if (error) {\n        ofpacts->size = orig_size;\n    }\n    return error;\n}\n\n/* Attempts to convert 'actions_len' bytes of OpenFlow actions from the front\n * of 'openflow' into ofpacts.  On success, appends the converted actions to\n * 'ofpacts'; on failure, 'ofpacts' is unchanged (but might be reallocated) .\n * Returns 0 if successful, otherwise an OpenFlow error.\n *\n * Actions are processed according to their OpenFlow version which\n * is provided in the 'version' parameter.\n *\n * In most places in OpenFlow, actions appear encapsulated in instructions, so\n * you should call ofpacts_pull_openflow_instructions() instead of this\n * function.\n *\n * 'vl_mff_map' and 'ofpacts_tlv_bitmap' are optional. If 'vl_mff_map' is\n * provided, it is used to get variable length mf_fields with configured\n * length in the actions. If an action uses a variable length mf_field,\n * 'ofpacts_tlv_bitmap' is updated accordingly for ref counting. If\n * 'vl_mff_map' is not provided, the default mf_fields with maximum length\n * will be used.\n *\n * The parsed actions are valid generically, but they may not be valid in a\n * specific context.  For example, port numbers up to OFPP_MAX are valid\n * generically, but specific datapaths may only support port numbers in a\n * smaller range.  Use ofpacts_check() to additional check whether actions are\n * valid in a specific context. */\nenum ofperr\nofpacts_pull_openflow_actions(struct ofpbuf *openflow,\n                              unsigned int actions_len,\n                              enum ofp_version version,\n                              const struct vl_mff_map *vl_mff_map,\n                              uint64_t *ofpacts_tlv_bitmap,\n                              struct ofpbuf *ofpacts)\n{\n    return ofpacts_pull_openflow_actions__(openflow, actions_len, version,\n                                           1u << OVSINST_OFPIT11_APPLY_ACTIONS,\n                                           ofpacts, 0, vl_mff_map,\n                                           ofpacts_tlv_bitmap);\n}\n\f\n/* OpenFlow 1.1 actions. */\n\n\n/* True if an action sets the value of a field\n * in a way that is compatibile with the action set.\n * The field can be set via either a set or a move action.\n * False otherwise. */\nstatic bool\nofpact_is_set_or_move_action(const struct ofpact *a)\n{\n    switch (a->type) {\n    case OFPACT_SET_FIELD:\n    case OFPACT_REG_MOVE:\n    case OFPACT_SET_ETH_DST:\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_SET_IPV4_DST:\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_L4_DST_PORT:\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_SET_VLAN_PCP:\n    case OFPACT_SET_VLAN_VID:\n        return true;\n    case OFPACT_BUNDLE:\n    case OFPACT_CLEAR_ACTIONS:\n    case OFPACT_CT:\n    case OFPACT_CT_CLEAR:\n    case OFPACT_CLONE:\n    case OFPACT_NAT:\n    case OFPACT_CONTROLLER:\n    case OFPACT_DEC_MPLS_TTL:\n    case OFPACT_DEC_TTL:\n    case OFPACT_ENQUEUE:\n    case OFPACT_EXIT:\n    case OFPACT_UNROLL_XLATE:\n    case OFPACT_FIN_TIMEOUT:\n    case OFPACT_GOTO_TABLE:\n    case OFPACT_GROUP:\n    case OFPACT_LEARN:\n    case OFPACT_CONJUNCTION:\n    case OFPACT_METER:\n    case OFPACT_MULTIPATH:\n    case OFPACT_NOTE:\n    case OFPACT_OUTPUT:\n    case OFPACT_OUTPUT_REG:\n    case OFPACT_OUTPUT_TRUNC:\n    case OFPACT_POP_MPLS:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_PUSH_MPLS:\n    case OFPACT_PUSH_VLAN:\n    case OFPACT_RESUBMIT:\n    case OFPACT_SAMPLE:\n    case OFPACT_STACK_POP:\n    case OFPACT_STACK_PUSH:\n    case OFPACT_STRIP_VLAN:\n    case OFPACT_WRITE_ACTIONS:\n    case OFPACT_WRITE_METADATA:\n    case OFPACT_DEBUG_RECIRC:\n        return false;\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* True if an action is allowed in the action set.\n * False otherwise. */\nstatic bool\nofpact_is_allowed_in_actions_set(const struct ofpact *a)\n{\n    switch (a->type) {\n    case OFPACT_DEC_MPLS_TTL:\n    case OFPACT_DEC_TTL:\n    case OFPACT_GROUP:\n    case OFPACT_OUTPUT:\n    case OFPACT_OUTPUT_TRUNC:\n    case OFPACT_POP_MPLS:\n    case OFPACT_PUSH_MPLS:\n    case OFPACT_PUSH_VLAN:\n    case OFPACT_REG_MOVE:\n    case OFPACT_SET_FIELD:\n    case OFPACT_SET_ETH_DST:\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_SET_IPV4_DST:\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_L4_DST_PORT:\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_SET_VLAN_PCP:\n    case OFPACT_SET_VLAN_VID:\n    case OFPACT_STRIP_VLAN:\n        return true;\n\n    /* In general these actions are excluded because they are not part of\n     * the OpenFlow specification nor map to actions that are defined in\n     * the specification.  Thus the order in which they should be applied\n     * in the action set is undefined. */\n    case OFPACT_BUNDLE:\n    case OFPACT_CLONE:\n    case OFPACT_CONTROLLER:\n    case OFPACT_CT:\n    case OFPACT_CT_CLEAR:\n    case OFPACT_NAT:\n    case OFPACT_ENQUEUE:\n    case OFPACT_EXIT:\n    case OFPACT_UNROLL_XLATE:\n    case OFPACT_FIN_TIMEOUT:\n    case OFPACT_LEARN:\n    case OFPACT_CONJUNCTION:\n    case OFPACT_MULTIPATH:\n    case OFPACT_NOTE:\n    case OFPACT_OUTPUT_REG:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_RESUBMIT:\n    case OFPACT_SAMPLE:\n    case OFPACT_STACK_POP:\n    case OFPACT_STACK_PUSH:\n    case OFPACT_DEBUG_RECIRC:\n\n    /* The action set may only include actions and thus\n     * may not include any instructions */\n    case OFPACT_CLEAR_ACTIONS:\n    case OFPACT_GOTO_TABLE:\n    case OFPACT_METER:\n    case OFPACT_WRITE_ACTIONS:\n    case OFPACT_WRITE_METADATA:\n        return false;\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Append ofpact 'a' onto the tail of 'out' */\nstatic void\nofpact_copy(struct ofpbuf *out, const struct ofpact *a)\n{\n    ofpbuf_put(out, a, OFPACT_ALIGN(a->len));\n}\n\n/* Copies the last ofpact whose type is 'filter' from 'in' to 'out'. */\nstatic bool\nofpacts_copy_last(struct ofpbuf *out, const struct ofpbuf *in,\n                  enum ofpact_type filter)\n{\n    const struct ofpact *target;\n    const struct ofpact *a;\n\n    target = NULL;\n    OFPACT_FOR_EACH (a, in->data, in->size) {\n        if (a->type == filter) {\n            target = a;\n        }\n    }\n    if (target) {\n        ofpact_copy(out, target);\n    }\n    return target != NULL;\n}\n\n/* Append all ofpacts, for which 'filter' returns true, from 'in' to 'out'.\n * The order of appended ofpacts is preserved between 'in' and 'out' */\nstatic void\nofpacts_copy_all(struct ofpbuf *out, const struct ofpbuf *in,\n                 bool (*filter)(const struct ofpact *))\n{\n    const struct ofpact *a;\n\n    OFPACT_FOR_EACH (a, in->data, in->size) {\n        if (filter(a)) {\n            ofpact_copy(out, a);\n        }\n    }\n}\n\n/* Reads 'action_set', which contains ofpacts accumulated by\n * OFPACT_WRITE_ACTIONS instructions, and writes equivalent actions to be\n * executed directly into 'action_list'.  (These names correspond to the\n * \"Action Set\" and \"Action List\" terms used in OpenFlow 1.1+.)\n *\n * In general this involves appending the last instance of each action that is\n * admissible in the action set in the order described in the OpenFlow\n * specification.\n *\n * Exceptions:\n * + output action is only appended if no group action was present in 'in'.\n * + As a simplification all set actions are copied in the order the are\n *   provided in 'in' as many set actions applied to a field has the same\n *   affect as only applying the last action that sets a field and\n *   duplicates are removed by do_xlate_actions().\n *   This has an unwanted side-effect of compsoting multiple\n *   LOAD_REG actions that touch different regions of the same field. */\nvoid\nofpacts_execute_action_set(struct ofpbuf *action_list,\n                           const struct ofpbuf *action_set)\n{\n    /* The OpenFlow spec \"Action Set\" section specifies this order. */\n    ofpacts_copy_last(action_list, action_set, OFPACT_STRIP_VLAN);\n    ofpacts_copy_last(action_list, action_set, OFPACT_POP_MPLS);\n    ofpacts_copy_last(action_list, action_set, OFPACT_PUSH_MPLS);\n    ofpacts_copy_last(action_list, action_set, OFPACT_PUSH_VLAN);\n    ofpacts_copy_last(action_list, action_set, OFPACT_DEC_TTL);\n    ofpacts_copy_last(action_list, action_set, OFPACT_DEC_MPLS_TTL);\n    ofpacts_copy_all(action_list, action_set, ofpact_is_set_or_move_action);\n    ofpacts_copy_last(action_list, action_set, OFPACT_SET_QUEUE);\n\n    /* If both OFPACT_GROUP and OFPACT_OUTPUT are present, OpenFlow says that\n     * we should execute only OFPACT_GROUP.\n     *\n     * If neither OFPACT_GROUP nor OFPACT_OUTPUT is present, then we can drop\n     * all the actions because there's no point in modifying a packet that will\n     * not be sent anywhere. */\n    if (!ofpacts_copy_last(action_list, action_set, OFPACT_GROUP) &&\n        !ofpacts_copy_last(action_list, action_set, OFPACT_OUTPUT) &&\n        !ofpacts_copy_last(action_list, action_set, OFPACT_RESUBMIT) &&\n        !ofpacts_copy_last(action_list, action_set, OFPACT_CT)) {\n        ofpbuf_clear(action_list);\n    }\n}\n\n\nstatic enum ofperr\nofpacts_decode_for_action_set(const struct ofp_action_header *in,\n                              size_t n_in, enum ofp_version version,\n                              const struct vl_mff_map *vl_mff_map,\n                              uint64_t *ofpacts_tlv_bitmap,\n                              struct ofpbuf *out)\n{\n    enum ofperr error;\n    struct ofpact *a;\n    size_t start = out->size;\n\n    error = ofpacts_decode(in, n_in, version, vl_mff_map, ofpacts_tlv_bitmap,\n                           out);\n\n    if (error) {\n        return error;\n    }\n\n    OFPACT_FOR_EACH (a, ofpact_end(out->data, start), out->size - start) {\n        if (!ofpact_is_allowed_in_actions_set(a)) {\n            VLOG_WARN_RL(&rl, \"disallowed action in action set\");\n            return OFPERR_OFPBAC_BAD_TYPE;\n        }\n    }\n\n    return 0;\n}\n\f\n/* OpenFlow 1.1 instructions. */\n\nstruct instruction_type_info {\n    enum ovs_instruction_type type;\n    const char *name;\n};\n\nstatic const struct instruction_type_info inst_info[] = {\n#define DEFINE_INST(ENUM, STRUCT, EXTENSIBLE, NAME)    {OVSINST_##ENUM, NAME},\nOVS_INSTRUCTIONS\n#undef DEFINE_INST\n};\n\nconst char *\novs_instruction_name_from_type(enum ovs_instruction_type type)\n{\n    return type < ARRAY_SIZE(inst_info) ? inst_info[type].name : NULL;\n}\n\nint\novs_instruction_type_from_name(const char *name)\n{\n    const struct instruction_type_info *p;\n    for (p = inst_info; p < &inst_info[ARRAY_SIZE(inst_info)]; p++) {\n        if (!strcasecmp(name, p->name)) {\n            return p->type;\n        }\n    }\n    return -1;\n}\n\nenum ovs_instruction_type\novs_instruction_type_from_ofpact_type(enum ofpact_type type)\n{\n    switch (type) {\n    case OFPACT_METER:\n        return OVSINST_OFPIT13_METER;\n    case OFPACT_CLEAR_ACTIONS:\n        return OVSINST_OFPIT11_CLEAR_ACTIONS;\n    case OFPACT_WRITE_ACTIONS:\n        return OVSINST_OFPIT11_WRITE_ACTIONS;\n    case OFPACT_WRITE_METADATA:\n        return OVSINST_OFPIT11_WRITE_METADATA;\n    case OFPACT_GOTO_TABLE:\n        return OVSINST_OFPIT11_GOTO_TABLE;\n    case OFPACT_OUTPUT:\n    case OFPACT_GROUP:\n    case OFPACT_CLONE:\n    case OFPACT_CONTROLLER:\n    case OFPACT_ENQUEUE:\n    case OFPACT_OUTPUT_REG:\n    case OFPACT_OUTPUT_TRUNC:\n    case OFPACT_BUNDLE:\n    case OFPACT_SET_VLAN_VID:\n    case OFPACT_SET_VLAN_PCP:\n    case OFPACT_STRIP_VLAN:\n    case OFPACT_PUSH_VLAN:\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_ETH_DST:\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_IPV4_DST:\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_L4_DST_PORT:\n    case OFPACT_REG_MOVE:\n    case OFPACT_SET_FIELD:\n    case OFPACT_STACK_PUSH:\n    case OFPACT_STACK_POP:\n    case OFPACT_DEC_TTL:\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_DEC_MPLS_TTL:\n    case OFPACT_PUSH_MPLS:\n    case OFPACT_POP_MPLS:\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_FIN_TIMEOUT:\n    case OFPACT_RESUBMIT:\n    case OFPACT_LEARN:\n    case OFPACT_CONJUNCTION:\n    case OFPACT_MULTIPATH:\n    case OFPACT_NOTE:\n    case OFPACT_EXIT:\n    case OFPACT_UNROLL_XLATE:\n    case OFPACT_SAMPLE:\n    case OFPACT_DEBUG_RECIRC:\n    case OFPACT_CT:\n    case OFPACT_CT_CLEAR:\n    case OFPACT_NAT:\n    default:\n        return OVSINST_OFPIT11_APPLY_ACTIONS;\n    }\n}\n\nenum ofperr\novs_instruction_type_from_inst_type(enum ovs_instruction_type *instruction_type,\n                                    const uint16_t inst_type)\n{\n    switch (inst_type) {\n\n#define DEFINE_INST(ENUM, STRUCT, EXTENSIBLE, NAME) \\\n    case ENUM:                                      \\\n        *instruction_type = OVSINST_##ENUM;         \\\n        return 0;\nOVS_INSTRUCTIONS\n#undef DEFINE_INST\n\n    default:\n        return OFPERR_OFPBIC_UNKNOWN_INST;\n    }\n}\n\n/* Two-way translation between OVS's internal \"OVSINST_*\" representation of\n * instructions and the \"OFPIT_*\" representation used in OpenFlow. */\nstruct ovsinst_map {\n    enum ovs_instruction_type ovsinst; /* Internal name for instruction. */\n    int ofpit;                         /* OFPIT_* number from OpenFlow spec. */\n};\n\nstatic const struct ovsinst_map *\nget_ovsinst_map(enum ofp_version version)\n{\n    /* OpenFlow 1.1 and 1.2 instructions. */\n    static const struct ovsinst_map of11[] = {\n        { OVSINST_OFPIT11_GOTO_TABLE, 1 },\n        { OVSINST_OFPIT11_WRITE_METADATA, 2 },\n        { OVSINST_OFPIT11_WRITE_ACTIONS, 3 },\n        { OVSINST_OFPIT11_APPLY_ACTIONS, 4 },\n        { OVSINST_OFPIT11_CLEAR_ACTIONS, 5 },\n        { 0, -1 },\n    };\n\n    /* OpenFlow 1.3+ instructions. */\n    static const struct ovsinst_map of13[] = {\n        { OVSINST_OFPIT11_GOTO_TABLE, 1 },\n        { OVSINST_OFPIT11_WRITE_METADATA, 2 },\n        { OVSINST_OFPIT11_WRITE_ACTIONS, 3 },\n        { OVSINST_OFPIT11_APPLY_ACTIONS, 4 },\n        { OVSINST_OFPIT11_CLEAR_ACTIONS, 5 },\n        { OVSINST_OFPIT13_METER, 6 },\n        { 0, -1 },\n    };\n\n    return version < OFP13_VERSION ? of11 : of13;\n}\n\n/* Converts 'ovsinst_bitmap', a bitmap whose bits correspond to OVSINST_*\n * values, into a bitmap of instructions suitable for OpenFlow 'version'\n * (OFP11_VERSION or later), and returns the result. */\novs_be32\novsinst_bitmap_to_openflow(uint32_t ovsinst_bitmap, enum ofp_version version)\n{\n    uint32_t ofpit_bitmap = 0;\n    const struct ovsinst_map *x;\n\n    for (x = get_ovsinst_map(version); x->ofpit >= 0; x++) {\n        if (ovsinst_bitmap & (1u << x->ovsinst)) {\n            ofpit_bitmap |= 1u << x->ofpit;\n        }\n    }\n    return htonl(ofpit_bitmap);\n}\n\n/* Converts 'ofpit_bitmap', a bitmap of instructions from an OpenFlow message\n * with the given 'version' (OFP11_VERSION or later) into a bitmap whose bits\n * correspond to OVSINST_* values, and returns the result. */\nuint32_t\novsinst_bitmap_from_openflow(ovs_be32 ofpit_bitmap, enum ofp_version version)\n{\n    uint32_t ovsinst_bitmap = 0;\n    const struct ovsinst_map *x;\n\n    for (x = get_ovsinst_map(version); x->ofpit >= 0; x++) {\n        if (ofpit_bitmap & htonl(1u << x->ofpit)) {\n            ovsinst_bitmap |= 1u << x->ovsinst;\n        }\n    }\n    return ovsinst_bitmap;\n}\n\nstatic inline struct ofp11_instruction *\ninstruction_next(const struct ofp11_instruction *inst)\n{\n    return ((struct ofp11_instruction *) (void *)\n            ((uint8_t *) inst + ntohs(inst->len)));\n}\n\nstatic inline bool\ninstruction_is_valid(const struct ofp11_instruction *inst,\n                     size_t n_instructions)\n{\n    uint16_t len = ntohs(inst->len);\n    return (!(len % OFP11_INSTRUCTION_ALIGN)\n            && len >= sizeof *inst\n            && len / sizeof *inst <= n_instructions);\n}\n\n/* This macro is careful to check for instructions with bad lengths. */\n#define INSTRUCTION_FOR_EACH(ITER, LEFT, INSTRUCTIONS, N_INSTRUCTIONS)  \\\n    for ((ITER) = (INSTRUCTIONS), (LEFT) = (N_INSTRUCTIONS);            \\\n         (LEFT) > 0 && instruction_is_valid(ITER, LEFT);                \\\n         ((LEFT) -= (ntohs((ITER)->len)                                 \\\n                     / sizeof(struct ofp11_instruction)),               \\\n          (ITER) = instruction_next(ITER)))\n\nstatic enum ofperr\ndecode_openflow11_instruction(const struct ofp11_instruction *inst,\n                              enum ovs_instruction_type *type)\n{\n    uint16_t len = ntohs(inst->len);\n\n    switch (inst->type) {\n    case CONSTANT_HTONS(OFPIT11_EXPERIMENTER):\n        return OFPERR_OFPBIC_BAD_EXPERIMENTER;\n\n#define DEFINE_INST(ENUM, STRUCT, EXTENSIBLE, NAME)     \\\n        case CONSTANT_HTONS(ENUM):                      \\\n            if (EXTENSIBLE                              \\\n                ? len >= sizeof(struct STRUCT)          \\\n                : len == sizeof(struct STRUCT)) {       \\\n                *type = OVSINST_##ENUM;                 \\\n                return 0;                               \\\n            } else {                                    \\\n                return OFPERR_OFPBIC_BAD_LEN;           \\\n            }\nOVS_INSTRUCTIONS\n#undef DEFINE_INST\n\n    default:\n        return OFPERR_OFPBIC_UNKNOWN_INST;\n    }\n}\n\nstatic enum ofperr\ndecode_openflow11_instructions(const struct ofp11_instruction insts[],\n                               size_t n_insts,\n                               const struct ofp11_instruction *out[])\n{\n    const struct ofp11_instruction *inst;\n    size_t left;\n\n    memset(out, 0, N_OVS_INSTRUCTIONS * sizeof *out);\n    INSTRUCTION_FOR_EACH (inst, left, insts, n_insts) {\n        enum ovs_instruction_type type;\n        enum ofperr error;\n\n        error = decode_openflow11_instruction(inst, &type);\n        if (error) {\n            return error;\n        }\n\n        if (out[type]) {\n            return OFPERR_OFPBIC_DUP_INST;\n        }\n        out[type] = inst;\n    }\n\n    if (left) {\n        VLOG_WARN_RL(&rl, \"bad instruction format at offset %\"PRIuSIZE,\n                     (n_insts - left) * sizeof *inst);\n        return OFPERR_OFPBIC_BAD_LEN;\n    }\n    return 0;\n}\n\nstatic void\nget_actions_from_instruction(const struct ofp11_instruction *inst,\n                             const struct ofp_action_header **actions,\n                             size_t *actions_len)\n{\n    *actions = ALIGNED_CAST(const struct ofp_action_header *, inst + 1);\n    *actions_len = ntohs(inst->len) - sizeof *inst;\n}\n\nenum ofperr\nofpacts_pull_openflow_instructions(struct ofpbuf *openflow,\n                                   unsigned int instructions_len,\n                                   enum ofp_version version,\n                                   const struct vl_mff_map *vl_mff_map,\n                                   uint64_t *ofpacts_tlv_bitmap,\n                                   struct ofpbuf *ofpacts)\n{\n    const struct ofp11_instruction *instructions;\n    const struct ofp11_instruction *insts[N_OVS_INSTRUCTIONS];\n    enum ofperr error;\n\n    ofpbuf_clear(ofpacts);\n    if (version == OFP10_VERSION) {\n        return ofpacts_pull_openflow_actions__(openflow, instructions_len,\n                                               version,\n                                               (1u << N_OVS_INSTRUCTIONS) - 1,\n                                               ofpacts, 0, vl_mff_map,\n                                               ofpacts_tlv_bitmap);\n    }\n\n    if (instructions_len % OFP11_INSTRUCTION_ALIGN != 0) {\n        VLOG_WARN_RL(&rl, \"OpenFlow message instructions length %u is not a \"\n                     \"multiple of %d\",\n                     instructions_len, OFP11_INSTRUCTION_ALIGN);\n        error = OFPERR_OFPBIC_BAD_LEN;\n        goto exit;\n    }\n\n    instructions = ofpbuf_try_pull(openflow, instructions_len);\n    if (instructions == NULL) {\n        VLOG_WARN_RL(&rl, \"OpenFlow message instructions length %u exceeds \"\n                     \"remaining message length (%\"PRIu32\")\",\n                     instructions_len, openflow->size);\n        error = OFPERR_OFPBIC_BAD_LEN;\n        goto exit;\n    }\n\n    error = decode_openflow11_instructions(\n        instructions, instructions_len / OFP11_INSTRUCTION_ALIGN,\n        insts);\n    if (error) {\n        goto exit;\n    }\n\n    if (insts[OVSINST_OFPIT13_METER]) {\n        const struct ofp13_instruction_meter *oim;\n        struct ofpact_meter *om;\n\n        oim = ALIGNED_CAST(const struct ofp13_instruction_meter *,\n                           insts[OVSINST_OFPIT13_METER]);\n\n        om = ofpact_put_METER(ofpacts);\n        om->meter_id = ntohl(oim->meter_id);\n    }\n    if (insts[OVSINST_OFPIT11_APPLY_ACTIONS]) {\n        const struct ofp_action_header *actions;\n        size_t actions_len;\n\n        get_actions_from_instruction(insts[OVSINST_OFPIT11_APPLY_ACTIONS],\n                                     &actions, &actions_len);\n        error = ofpacts_decode(actions, actions_len, version, vl_mff_map,\n                               ofpacts_tlv_bitmap, ofpacts);\n        if (error) {\n            goto exit;\n        }\n    }\n    if (insts[OVSINST_OFPIT11_CLEAR_ACTIONS]) {\n        instruction_get_OFPIT11_CLEAR_ACTIONS(\n            insts[OVSINST_OFPIT11_CLEAR_ACTIONS]);\n        ofpact_put_CLEAR_ACTIONS(ofpacts);\n    }\n    if (insts[OVSINST_OFPIT11_WRITE_ACTIONS]) {\n        struct ofpact_nest *on;\n        const struct ofp_action_header *actions;\n        size_t actions_len;\n        size_t start = ofpacts->size;\n        ofpact_put(ofpacts, OFPACT_WRITE_ACTIONS,\n                   offsetof(struct ofpact_nest, actions));\n        get_actions_from_instruction(insts[OVSINST_OFPIT11_WRITE_ACTIONS],\n                                     &actions, &actions_len);\n        error = ofpacts_decode_for_action_set(actions, actions_len,\n                                              version, vl_mff_map,\n                                              ofpacts_tlv_bitmap, ofpacts);\n        if (error) {\n            goto exit;\n        }\n        on = ofpbuf_at_assert(ofpacts, start, sizeof *on);\n        on->ofpact.len = ofpacts->size - start;\n    }\n    if (insts[OVSINST_OFPIT11_WRITE_METADATA]) {\n        const struct ofp11_instruction_write_metadata *oiwm;\n        struct ofpact_metadata *om;\n\n        oiwm = ALIGNED_CAST(const struct ofp11_instruction_write_metadata *,\n                            insts[OVSINST_OFPIT11_WRITE_METADATA]);\n\n        om = ofpact_put_WRITE_METADATA(ofpacts);\n        om->metadata = oiwm->metadata;\n        om->mask = oiwm->metadata_mask;\n    }\n    if (insts[OVSINST_OFPIT11_GOTO_TABLE]) {\n        const struct ofp11_instruction_goto_table *oigt;\n        struct ofpact_goto_table *ogt;\n\n        oigt = instruction_get_OFPIT11_GOTO_TABLE(\n            insts[OVSINST_OFPIT11_GOTO_TABLE]);\n        ogt = ofpact_put_GOTO_TABLE(ofpacts);\n        ogt->table_id = oigt->table_id;\n    }\n\n    error = ofpacts_verify(ofpacts->data, ofpacts->size,\n                           (1u << N_OVS_INSTRUCTIONS) - 1, 0);\nexit:\n    if (error) {\n        ofpbuf_clear(ofpacts);\n    }\n    return error;\n}\n\n/* Update the length of the instruction that begins at offset 'ofs' within\n * 'openflow' and contains nested actions that extend to the end of 'openflow'.\n * If the instruction contains no nested actions, deletes it entirely. */\nstatic void\nofpacts_update_instruction_actions(struct ofpbuf *openflow, size_t ofs)\n{\n    struct ofp11_instruction_actions *oia;\n\n    oia = ofpbuf_at_assert(openflow, ofs, sizeof *oia);\n    if (openflow->size > ofs + sizeof *oia) {\n        oia->len = htons(openflow->size - ofs);\n    } else {\n        openflow->size = ofs;\n    }\n}\n\f\n/* Checks that 'port' is a valid output port for OFPACT_OUTPUT, given that the\n * switch will never have more than 'max_ports' ports.  Returns 0 if 'port' is\n * valid, otherwise an OpenFlow error code. */\nenum ofperr\nofpact_check_output_port(ofp_port_t port, ofp_port_t max_ports)\n{\n    switch (port) {\n    case OFPP_IN_PORT:\n    case OFPP_TABLE:\n    case OFPP_NORMAL:\n    case OFPP_FLOOD:\n    case OFPP_ALL:\n    case OFPP_CONTROLLER:\n    case OFPP_LOCAL:\n        return 0;\n\n    case OFPP_NONE:\n        return OFPERR_OFPBAC_BAD_OUT_PORT;\n\n    default:\n        if (ofp_to_u16(port) < ofp_to_u16(max_ports)) {\n            return 0;\n        }\n        return OFPERR_OFPBAC_BAD_OUT_PORT;\n    }\n}\n\n/* Removes the protocols that require consistency between match and actions\n * (that's everything but OpenFlow 1.0) from '*usable_protocols'.\n *\n * (An example of an inconsistency between match and actions is a flow that\n * does not match on an MPLS Ethertype but has an action that pops an MPLS\n * label.) */\nstatic void\ninconsistent_match(enum ofputil_protocol *usable_protocols)\n{\n    *usable_protocols &= OFPUTIL_P_OF10_ANY;\n}\n\n/* May modify flow->dl_type, flow->nw_proto and flow->vlan_tci,\n * caller must restore them.\n *\n * Modifies some actions, filling in fields that could not be properly set\n * without context. */\nstatic enum ofperr\nofpact_check__(enum ofputil_protocol *usable_protocols, struct ofpact *a,\n               struct flow *flow, ofp_port_t max_ports,\n               uint8_t table_id, uint8_t n_tables)\n{\n    const struct ofpact_enqueue *enqueue;\n    const struct mf_field *mf;\n\n    switch (a->type) {\n    case OFPACT_OUTPUT:\n        return ofpact_check_output_port(ofpact_get_OUTPUT(a)->port,\n                                        max_ports);\n\n    case OFPACT_CONTROLLER:\n        return 0;\n\n    case OFPACT_ENQUEUE:\n        enqueue = ofpact_get_ENQUEUE(a);\n        if (ofp_to_u16(enqueue->port) >= ofp_to_u16(max_ports)\n            && enqueue->port != OFPP_IN_PORT\n            && enqueue->port != OFPP_LOCAL) {\n            return OFPERR_OFPBAC_BAD_OUT_PORT;\n        }\n        return 0;\n\n    case OFPACT_OUTPUT_REG:\n        return mf_check_src(&ofpact_get_OUTPUT_REG(a)->src, flow);\n\n    case OFPACT_OUTPUT_TRUNC:\n        return ofpact_check_output_port(ofpact_get_OUTPUT_TRUNC(a)->port,\n                                        max_ports);\n\n    case OFPACT_BUNDLE:\n        return bundle_check(ofpact_get_BUNDLE(a), max_ports, flow);\n\n    case OFPACT_SET_VLAN_VID:\n        /* Remember if we saw a vlan tag in the flow to aid translating to\n         * OpenFlow 1.1+ if need be. */\n        ofpact_get_SET_VLAN_VID(a)->flow_has_vlan =\n            (flow->vlan_tci & htons(VLAN_CFI)) == htons(VLAN_CFI);\n        if (!(flow->vlan_tci & htons(VLAN_CFI)) &&\n            !ofpact_get_SET_VLAN_VID(a)->push_vlan_if_needed) {\n            inconsistent_match(usable_protocols);\n        }\n        /* Temporary mark that we have a vlan tag. */\n        flow->vlan_tci |= htons(VLAN_CFI);\n        return 0;\n\n    case OFPACT_SET_VLAN_PCP:\n        /* Remember if we saw a vlan tag in the flow to aid translating to\n         * OpenFlow 1.1+ if need be. */\n        ofpact_get_SET_VLAN_PCP(a)->flow_has_vlan =\n            (flow->vlan_tci & htons(VLAN_CFI)) == htons(VLAN_CFI);\n        if (!(flow->vlan_tci & htons(VLAN_CFI)) &&\n            !ofpact_get_SET_VLAN_PCP(a)->push_vlan_if_needed) {\n            inconsistent_match(usable_protocols);\n        }\n        /* Temporary mark that we have a vlan tag. */\n        flow->vlan_tci |= htons(VLAN_CFI);\n        return 0;\n\n    case OFPACT_STRIP_VLAN:\n        if (!(flow->vlan_tci & htons(VLAN_CFI))) {\n            inconsistent_match(usable_protocols);\n        }\n        /* Temporary mark that we have no vlan tag. */\n        flow->vlan_tci = htons(0);\n        return 0;\n\n    case OFPACT_PUSH_VLAN:\n        if (flow->vlan_tci & htons(VLAN_CFI)) {\n            /* Multiple VLAN headers not supported. */\n            return OFPERR_OFPBAC_BAD_TAG;\n        }\n        /* Temporary mark that we have a vlan tag. */\n        flow->vlan_tci |= htons(VLAN_CFI);\n        return 0;\n\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_ETH_DST:\n        return 0;\n\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_IPV4_DST:\n        if (flow->dl_type != htons(ETH_TYPE_IP)) {\n            inconsistent_match(usable_protocols);\n        }\n        return 0;\n\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_DEC_TTL:\n        if (!is_ip_any(flow)) {\n            inconsistent_match(usable_protocols);\n        }\n        return 0;\n\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_L4_DST_PORT:\n        if (!is_ip_any(flow) || (flow->nw_frag & FLOW_NW_FRAG_LATER) ||\n            (flow->nw_proto != IPPROTO_TCP && flow->nw_proto != IPPROTO_UDP\n             && flow->nw_proto != IPPROTO_SCTP)) {\n            inconsistent_match(usable_protocols);\n        }\n        /* Note on which transport protocol the port numbers are set.\n         * This allows this set action to be converted to an OF1.2 set field\n         * action. */\n        if (a->type == OFPACT_SET_L4_SRC_PORT) {\n            ofpact_get_SET_L4_SRC_PORT(a)->flow_ip_proto = flow->nw_proto;\n        } else {\n            ofpact_get_SET_L4_DST_PORT(a)->flow_ip_proto = flow->nw_proto;\n        }\n        return 0;\n\n    case OFPACT_REG_MOVE:\n        return nxm_reg_move_check(ofpact_get_REG_MOVE(a), flow);\n\n    case OFPACT_SET_FIELD:\n        mf = ofpact_get_SET_FIELD(a)->field;\n        /* Require OXM_OF_VLAN_VID to have an existing VLAN header. */\n        if (!mf_are_prereqs_ok(mf, flow, NULL) ||\n            (mf->id == MFF_VLAN_VID && !(flow->vlan_tci & htons(VLAN_CFI)))) {\n            VLOG_WARN_RL(&rl, \"set_field %s lacks correct prerequisities\",\n                         mf->name);\n            return OFPERR_OFPBAC_MATCH_INCONSISTENT;\n        }\n        /* Remember if we saw a vlan tag in the flow to aid translating to\n         * OpenFlow 1.1 if need be. */\n        ofpact_get_SET_FIELD(a)->flow_has_vlan =\n            (flow->vlan_tci & htons(VLAN_CFI)) == htons(VLAN_CFI);\n        if (mf->id == MFF_VLAN_TCI) {\n            /* The set field may add or remove the vlan tag,\n             * Mark the status temporarily. */\n            flow->vlan_tci = ofpact_get_SET_FIELD(a)->value->be16;\n        }\n        return 0;\n\n    case OFPACT_STACK_PUSH:\n        return nxm_stack_push_check(ofpact_get_STACK_PUSH(a), flow);\n\n    case OFPACT_STACK_POP:\n        return nxm_stack_pop_check(ofpact_get_STACK_POP(a), flow);\n\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_DEC_MPLS_TTL:\n        if (!eth_type_mpls(flow->dl_type)) {\n            inconsistent_match(usable_protocols);\n        }\n        return 0;\n\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_RESUBMIT:\n        return 0;\n\n    case OFPACT_FIN_TIMEOUT:\n        if (flow->nw_proto != IPPROTO_TCP) {\n            inconsistent_match(usable_protocols);\n        }\n        return 0;\n\n    case OFPACT_LEARN:\n        return learn_check(ofpact_get_LEARN(a), flow);\n\n    case OFPACT_CONJUNCTION:\n        return 0;\n\n    case OFPACT_MULTIPATH:\n        return multipath_check(ofpact_get_MULTIPATH(a), flow);\n\n    case OFPACT_NOTE:\n    case OFPACT_EXIT:\n        return 0;\n\n    case OFPACT_PUSH_MPLS:\n        flow->dl_type = ofpact_get_PUSH_MPLS(a)->ethertype;\n        /* The packet is now MPLS and the MPLS payload is opaque.\n         * Thus nothing can be assumed about the network protocol.\n         * Temporarily mark that we have no nw_proto. */\n        flow->nw_proto = 0;\n        return 0;\n\n    case OFPACT_POP_MPLS:\n        if (!eth_type_mpls(flow->dl_type)) {\n            inconsistent_match(usable_protocols);\n        }\n        flow->dl_type = ofpact_get_POP_MPLS(a)->ethertype;\n        return 0;\n\n    case OFPACT_SAMPLE:\n        return 0;\n\n    case OFPACT_CLONE: {\n        struct ofpact_nest *on = ofpact_get_CLONE(a);\n        return ofpacts_check(on->actions, ofpact_nest_get_action_len(on),\n                             flow, max_ports, table_id, n_tables,\n                             usable_protocols);\n    }\n\n    case OFPACT_CT: {\n        struct ofpact_conntrack *oc = ofpact_get_CT(a);\n\n        if (!dl_type_is_ip_any(flow->dl_type)\n            || (flow->ct_state & CS_INVALID && oc->flags & NX_CT_F_COMMIT)\n            || (oc->alg == IPPORT_FTP && flow->nw_proto != IPPROTO_TCP)\n            || (oc->alg == IPPORT_TFTP && flow->nw_proto != IPPROTO_UDP)) {\n            /* We can't downgrade to OF1.0 and expect inconsistent CT actions\n             * be silently discarded.  Instead, datapath flow install fails, so\n             * it is better to flag inconsistent CT actions as hard errors. */\n            return OFPERR_OFPBAC_MATCH_INCONSISTENT;\n        }\n\n        if (oc->zone_src.field) {\n            return mf_check_src(&oc->zone_src, flow);\n        }\n\n        return ofpacts_check(oc->actions, ofpact_ct_get_action_len(oc),\n                             flow, max_ports, table_id, n_tables,\n                             usable_protocols);\n    }\n\n    case OFPACT_CT_CLEAR:\n        return 0;\n\n    case OFPACT_NAT: {\n        struct ofpact_nat *on = ofpact_get_NAT(a);\n\n        if (!dl_type_is_ip_any(flow->dl_type) ||\n            (on->range_af == AF_INET && flow->dl_type != htons(ETH_TYPE_IP)) ||\n            (on->range_af == AF_INET6\n             && flow->dl_type != htons(ETH_TYPE_IPV6))) {\n            return OFPERR_OFPBAC_MATCH_INCONSISTENT;\n        }\n        return 0;\n    }\n\n    case OFPACT_CLEAR_ACTIONS:\n        return 0;\n\n    case OFPACT_WRITE_ACTIONS: {\n        /* Use a temporary copy of 'usable_protocols' because we can't check\n         * consistency of an action set. */\n        struct ofpact_nest *on = ofpact_get_WRITE_ACTIONS(a);\n        enum ofputil_protocol p = *usable_protocols;\n        return ofpacts_check(on->actions, ofpact_nest_get_action_len(on),\n                             flow, max_ports, table_id, n_tables, &p);\n    }\n\n    case OFPACT_WRITE_METADATA:\n        return 0;\n\n    case OFPACT_METER: {\n        uint32_t mid = ofpact_get_METER(a)->meter_id;\n        if (mid == 0 || mid > OFPM13_MAX) {\n            return OFPERR_OFPMMFC_INVALID_METER;\n        }\n        return 0;\n    }\n\n    case OFPACT_GOTO_TABLE: {\n        uint8_t goto_table = ofpact_get_GOTO_TABLE(a)->table_id;\n        if ((table_id != 255 && goto_table <= table_id)\n            || (n_tables != 255 && goto_table >= n_tables)) {\n            return OFPERR_OFPBIC_BAD_TABLE_ID;\n        }\n        return 0;\n    }\n\n    case OFPACT_GROUP:\n        return 0;\n\n    case OFPACT_UNROLL_XLATE:\n        /* UNROLL is an internal action that should never be seen via\n         * OpenFlow. */\n        return OFPERR_OFPBAC_BAD_TYPE;\n\n    case OFPACT_DEBUG_RECIRC:\n        return 0;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Checks that the 'ofpacts_len' bytes of actions in 'ofpacts' are\n * appropriate for a packet with the prerequisites satisfied by 'flow' in a\n * switch with no more than 'max_ports' ports.\n *\n * If 'ofpacts' and 'flow' are inconsistent with one another, un-sets in\n * '*usable_protocols' the protocols that forbid the inconsistency.  (An\n * example of an inconsistency between match and actions is a flow that does\n * not match on an MPLS Ethertype but has an action that pops an MPLS label.)\n *\n * May annotate ofpacts with information gathered from the 'flow'.\n *\n * May temporarily modify 'flow', but restores the changes before returning. */\nenum ofperr\nofpacts_check(struct ofpact ofpacts[], size_t ofpacts_len,\n              struct flow *flow, ofp_port_t max_ports,\n              uint8_t table_id, uint8_t n_tables,\n              enum ofputil_protocol *usable_protocols)\n{\n    struct ofpact *a;\n    ovs_be16 dl_type = flow->dl_type;\n    ovs_be16 vlan_tci = flow->vlan_tci;\n    uint8_t nw_proto = flow->nw_proto;\n    enum ofperr error = 0;\n\n    OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {\n        error = ofpact_check__(usable_protocols, a, flow,\n                               max_ports, table_id, n_tables);\n        if (error) {\n            break;\n        }\n    }\n    /* Restore fields that may have been modified. */\n    flow->dl_type = dl_type;\n    flow->vlan_tci = vlan_tci;\n    flow->nw_proto = nw_proto;\n    return error;\n}\n\n/* Like ofpacts_check(), but reports inconsistencies as\n * OFPERR_OFPBAC_MATCH_INCONSISTENT rather than clearing bits. */\nenum ofperr\nofpacts_check_consistency(struct ofpact ofpacts[], size_t ofpacts_len,\n                          struct flow *flow, ofp_port_t max_ports,\n                          uint8_t table_id, uint8_t n_tables,\n                          enum ofputil_protocol usable_protocols)\n{\n    enum ofputil_protocol p = usable_protocols;\n    enum ofperr error;\n\n    error = ofpacts_check(ofpacts, ofpacts_len, flow, max_ports,\n                          table_id, n_tables, &p);\n    return (error ? error\n            : p != usable_protocols ? OFPERR_OFPBAC_MATCH_INCONSISTENT\n            : 0);\n}\n\n/* Returns the destination field that 'ofpact' would write to, or NULL\n * if the action would not write to an mf_field. */\nconst struct mf_field *\nofpact_get_mf_dst(const struct ofpact *ofpact)\n{\n    if (ofpact->type == OFPACT_SET_FIELD) {\n        const struct ofpact_set_field *orl;\n\n        orl = CONTAINER_OF(ofpact, struct ofpact_set_field, ofpact);\n        return orl->field;\n    } else if (ofpact->type == OFPACT_REG_MOVE) {\n        const struct ofpact_reg_move *orm;\n\n        orm = CONTAINER_OF(ofpact, struct ofpact_reg_move, ofpact);\n        return orm->dst.field;\n    }\n\n    return NULL;\n}\n\nstatic enum ofperr\nunsupported_nesting(enum ofpact_type action, enum ofpact_type outer_action)\n{\n    VLOG_WARN(\"%s action doesn't support nested action %s\",\n              ofpact_name(outer_action), ofpact_name(action));\n    return OFPERR_OFPBAC_BAD_ARGUMENT;\n}\n\nstatic bool\nfield_requires_ct(enum mf_field_id field)\n{\n    return field == MFF_CT_MARK || field == MFF_CT_LABEL;\n}\n\n/* Apply nesting constraints for actions */\nstatic enum ofperr\nofpacts_verify_nested(const struct ofpact *a, enum ofpact_type outer_action)\n{\n    const struct mf_field *field = ofpact_get_mf_dst(a);\n\n    if (field && field_requires_ct(field->id) && outer_action != OFPACT_CT) {\n        VLOG_WARN(\"cannot set CT fields outside of ct action\");\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n    if (a->type == OFPACT_NAT) {\n        if (outer_action != OFPACT_CT) {\n            VLOG_WARN(\"Cannot have NAT action outside of \\\"ct\\\" action\");\n            return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n        }\n        return 0;\n    }\n\n    if (outer_action) {\n        ovs_assert(outer_action == OFPACT_WRITE_ACTIONS\n                   || outer_action == OFPACT_CT);\n\n        if (outer_action == OFPACT_CT) {\n            if (!field) {\n                return unsupported_nesting(a->type, outer_action);\n            } else if (!field_requires_ct(field->id)) {\n                VLOG_WARN(\"%s action doesn't support nested modification \"\n                          \"of %s\", ofpact_name(outer_action), field->name);\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/* Verifies that the 'ofpacts_len' bytes of actions in 'ofpacts' are in the\n * appropriate order as defined by the OpenFlow spec and as required by Open\n * vSwitch.\n *\n * 'allowed_ovsinsts' is a bitmap of OVSINST_* values, in which 1-bits indicate\n * instructions that are allowed within 'ofpacts[]'.\n *\n * If 'outer_action' is not zero, it specifies that the actions are nested\n * within another action of type 'outer_action'. */\nstatic enum ofperr\nofpacts_verify(const struct ofpact ofpacts[], size_t ofpacts_len,\n               uint32_t allowed_ovsinsts, enum ofpact_type outer_action)\n{\n    const struct ofpact *a;\n    enum ovs_instruction_type inst;\n\n    inst = OVSINST_OFPIT13_METER;\n    OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {\n        enum ovs_instruction_type next;\n        enum ofperr error;\n\n        if (a->type == OFPACT_CONJUNCTION) {\n            OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {\n                if (a->type != OFPACT_CONJUNCTION && a->type != OFPACT_NOTE) {\n                    VLOG_WARN(\"\\\"conjunction\\\" actions may be used along with \"\n                              \"\\\"note\\\" but not any other kind of action \"\n                              \"(such as the \\\"%s\\\" action used here)\",\n                              ofpact_name(a->type));\n                    return OFPERR_NXBAC_BAD_CONJUNCTION;\n                }\n            }\n            return 0;\n        }\n\n        error = ofpacts_verify_nested(a, outer_action);\n        if (error) {\n            return error;\n        }\n\n        next = ovs_instruction_type_from_ofpact_type(a->type);\n        if (a > ofpacts\n            && (inst == OVSINST_OFPIT11_APPLY_ACTIONS\n                ? next < inst\n                : next <= inst)) {\n            const char *name = ovs_instruction_name_from_type(inst);\n            const char *next_name = ovs_instruction_name_from_type(next);\n\n            if (next == inst) {\n                VLOG_WARN(\"duplicate %s instruction not allowed, for OpenFlow \"\n                          \"1.1+ compatibility\", name);\n            } else {\n                VLOG_WARN(\"invalid instruction ordering: %s must appear \"\n                          \"before %s, for OpenFlow 1.1+ compatibility\",\n                          next_name, name);\n            }\n            return OFPERR_OFPBAC_UNSUPPORTED_ORDER;\n        }\n        if (!((1u << next) & allowed_ovsinsts)) {\n            const char *name = ovs_instruction_name_from_type(next);\n\n            VLOG_WARN(\"%s instruction not allowed here\", name);\n            return OFPERR_OFPBIC_UNSUP_INST;\n        }\n\n        inst = next;\n    }\n\n    return 0;\n}\n\f\n/* Converting ofpacts to OpenFlow. */\n\nstatic void\nencode_ofpact(const struct ofpact *a, enum ofp_version ofp_version,\n              struct ofpbuf *out)\n{\n    switch (a->type) {\n#define OFPACT(ENUM, STRUCT, MEMBER, NAME)                              \\\n        case OFPACT_##ENUM:                                             \\\n            encode_##ENUM(ofpact_get_##ENUM(a), ofp_version, out);      \\\n            return;\n        OFPACTS\n#undef OFPACT\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Converts the 'ofpacts_len' bytes of ofpacts in 'ofpacts' into OpenFlow\n * actions in 'openflow', appending the actions to any existing data in\n * 'openflow'. */\nsize_t\nofpacts_put_openflow_actions(const struct ofpact ofpacts[], size_t ofpacts_len,\n                             struct ofpbuf *openflow,\n                             enum ofp_version ofp_version)\n{\n    const struct ofpact *a;\n    size_t start_size = openflow->size;\n\n    OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {\n        encode_ofpact(a, ofp_version, openflow);\n    }\n    return openflow->size - start_size;\n}\n\nstatic enum ovs_instruction_type\nofpact_is_apply_actions(const struct ofpact *a)\n{\n    return (ovs_instruction_type_from_ofpact_type(a->type)\n            == OVSINST_OFPIT11_APPLY_ACTIONS);\n}\n\nvoid\nofpacts_put_openflow_instructions(const struct ofpact ofpacts[],\n                                  size_t ofpacts_len,\n                                  struct ofpbuf *openflow,\n                                  enum ofp_version ofp_version)\n{\n    const struct ofpact *end = ofpact_end(ofpacts, ofpacts_len);\n    const struct ofpact *a;\n\n    if (ofp_version == OFP10_VERSION) {\n        ofpacts_put_openflow_actions(ofpacts, ofpacts_len, openflow,\n                                     ofp_version);\n        return;\n    }\n\n    a = ofpacts;\n    while (a < end) {\n        if (ofpact_is_apply_actions(a)) {\n            size_t ofs = openflow->size;\n\n            instruction_put_OFPIT11_APPLY_ACTIONS(openflow);\n            do {\n                encode_ofpact(a, ofp_version, openflow);\n                a = ofpact_next(a);\n            } while (a < end && ofpact_is_apply_actions(a));\n            ofpacts_update_instruction_actions(openflow, ofs);\n        } else {\n            encode_ofpact(a, ofp_version, openflow);\n            a = ofpact_next(a);\n        }\n    }\n}\n\f\n/* Sets of supported actions. */\n\n/* Two-way translation between OVS's internal \"OFPACT_*\" representation of\n * actions and the \"OFPAT_*\" representation used in some OpenFlow version.\n * (OFPAT_* numbering varies from one OpenFlow version to another, so a given\n * instance is specific to one OpenFlow version.) */\nstruct ofpact_map {\n    enum ofpact_type ofpact;    /* Internal name for action type. */\n    int ofpat;                  /* OFPAT_* number from OpenFlow spec. */\n};\n\nstatic const struct ofpact_map *\nget_ofpact_map(enum ofp_version version)\n{\n    /* OpenFlow 1.0 actions. */\n    static const struct ofpact_map of10[] = {\n        { OFPACT_OUTPUT, 0 },\n        { OFPACT_SET_VLAN_VID, 1 },\n        { OFPACT_SET_VLAN_PCP, 2 },\n        { OFPACT_STRIP_VLAN, 3 },\n        { OFPACT_SET_ETH_SRC, 4 },\n        { OFPACT_SET_ETH_DST, 5 },\n        { OFPACT_SET_IPV4_SRC, 6 },\n        { OFPACT_SET_IPV4_DST, 7 },\n        { OFPACT_SET_IP_DSCP, 8 },\n        { OFPACT_SET_L4_SRC_PORT, 9 },\n        { OFPACT_SET_L4_DST_PORT, 10 },\n        { OFPACT_ENQUEUE, 11 },\n        { 0, -1 },\n    };\n\n    /* OpenFlow 1.1 actions. */\n    static const struct ofpact_map of11[] = {\n        { OFPACT_OUTPUT, 0 },\n        { OFPACT_SET_VLAN_VID, 1 },\n        { OFPACT_SET_VLAN_PCP, 2 },\n        { OFPACT_SET_ETH_SRC, 3 },\n        { OFPACT_SET_ETH_DST, 4 },\n        { OFPACT_SET_IPV4_SRC, 5 },\n        { OFPACT_SET_IPV4_DST, 6 },\n        { OFPACT_SET_IP_DSCP, 7 },\n        { OFPACT_SET_IP_ECN, 8 },\n        { OFPACT_SET_L4_SRC_PORT, 9 },\n        { OFPACT_SET_L4_DST_PORT, 10 },\n        /* OFPAT_COPY_TTL_OUT (11) not supported. */\n        /* OFPAT_COPY_TTL_IN (12) not supported. */\n        { OFPACT_SET_MPLS_LABEL, 13 },\n        { OFPACT_SET_MPLS_TC, 14 },\n        { OFPACT_SET_MPLS_TTL, 15 },\n        { OFPACT_DEC_MPLS_TTL, 16 },\n        { OFPACT_PUSH_VLAN, 17 },\n        { OFPACT_STRIP_VLAN, 18 },\n        { OFPACT_PUSH_MPLS, 19 },\n        { OFPACT_POP_MPLS, 20 },\n        { OFPACT_SET_QUEUE, 21 },\n        { OFPACT_GROUP, 22 },\n        { OFPACT_SET_IP_TTL, 23 },\n        { OFPACT_DEC_TTL, 24 },\n        { 0, -1 },\n    };\n\n    /* OpenFlow 1.2, 1.3, and 1.4 actions. */\n    static const struct ofpact_map of12[] = {\n        { OFPACT_OUTPUT, 0 },\n        /* OFPAT_COPY_TTL_OUT (11) not supported. */\n        /* OFPAT_COPY_TTL_IN (12) not supported. */\n        { OFPACT_SET_MPLS_TTL, 15 },\n        { OFPACT_DEC_MPLS_TTL, 16 },\n        { OFPACT_PUSH_VLAN, 17 },\n        { OFPACT_STRIP_VLAN, 18 },\n        { OFPACT_PUSH_MPLS, 19 },\n        { OFPACT_POP_MPLS, 20 },\n        { OFPACT_SET_QUEUE, 21 },\n        { OFPACT_GROUP, 22 },\n        { OFPACT_SET_IP_TTL, 23 },\n        { OFPACT_DEC_TTL, 24 },\n        { OFPACT_SET_FIELD, 25 },\n        /* OF1.3+ OFPAT_PUSH_PBB (26) not supported. */\n        /* OF1.3+ OFPAT_POP_PBB (27) not supported. */\n        { 0, -1 },\n    };\n\n    switch (version) {\n    case OFP10_VERSION:\n        return of10;\n\n    case OFP11_VERSION:\n        return of11;\n\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n    default:\n        return of12;\n    }\n}\n\n/* Converts 'ofpacts_bitmap', a bitmap whose bits correspond to OFPACT_*\n * values, into a bitmap of actions suitable for OpenFlow 'version', and\n * returns the result. */\novs_be32\nofpact_bitmap_to_openflow(uint64_t ofpacts_bitmap, enum ofp_version version)\n{\n    uint32_t openflow_bitmap = 0;\n    const struct ofpact_map *x;\n\n    for (x = get_ofpact_map(version); x->ofpat >= 0; x++) {\n        if (ofpacts_bitmap & (UINT64_C(1) << x->ofpact)) {\n            openflow_bitmap |= 1u << x->ofpat;\n        }\n    }\n    return htonl(openflow_bitmap);\n}\n\n/* Converts 'ofpat_bitmap', a bitmap of actions from an OpenFlow message with\n * the given 'version' into a bitmap whose bits correspond to OFPACT_* values,\n * and returns the result. */\nuint64_t\nofpact_bitmap_from_openflow(ovs_be32 ofpat_bitmap, enum ofp_version version)\n{\n    uint64_t ofpact_bitmap = 0;\n    const struct ofpact_map *x;\n\n    for (x = get_ofpact_map(version); x->ofpat >= 0; x++) {\n        if (ofpat_bitmap & htonl(1u << x->ofpat)) {\n            ofpact_bitmap |= UINT64_C(1) << x->ofpact;\n        }\n    }\n    return ofpact_bitmap;\n}\n\n/* Appends to 's' a string representation of the set of OFPACT_* represented\n * by 'ofpacts_bitmap'. */\nvoid\nofpact_bitmap_format(uint64_t ofpacts_bitmap, struct ds *s)\n{\n    if (!ofpacts_bitmap) {\n        ds_put_cstr(s, \"<none>\");\n    } else {\n        while (ofpacts_bitmap) {\n            ds_put_format(s, \"%s \",\n                          ofpact_name(rightmost_1bit_idx(ofpacts_bitmap)));\n            ofpacts_bitmap = zero_rightmost_1bit(ofpacts_bitmap);\n        }\n        ds_chomp(s, ' ');\n    }\n}\n\f\n/* Returns true if 'action' outputs to 'port', false otherwise. */\nstatic bool\nofpact_outputs_to_port(const struct ofpact *ofpact, ofp_port_t port)\n{\n    switch (ofpact->type) {\n    case OFPACT_OUTPUT:\n        return ofpact_get_OUTPUT(ofpact)->port == port;\n    case OFPACT_ENQUEUE:\n        return ofpact_get_ENQUEUE(ofpact)->port == port;\n    case OFPACT_CONTROLLER:\n        return port == OFPP_CONTROLLER;\n\n    case OFPACT_OUTPUT_REG:\n    case OFPACT_OUTPUT_TRUNC:\n    case OFPACT_BUNDLE:\n    case OFPACT_SET_VLAN_VID:\n    case OFPACT_SET_VLAN_PCP:\n    case OFPACT_STRIP_VLAN:\n    case OFPACT_PUSH_VLAN:\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_ETH_DST:\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_IPV4_DST:\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_L4_DST_PORT:\n    case OFPACT_REG_MOVE:\n    case OFPACT_SET_FIELD:\n    case OFPACT_STACK_PUSH:\n    case OFPACT_STACK_POP:\n    case OFPACT_DEC_TTL:\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_DEC_MPLS_TTL:\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_WRITE_METADATA:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_FIN_TIMEOUT:\n    case OFPACT_RESUBMIT:\n    case OFPACT_LEARN:\n    case OFPACT_CONJUNCTION:\n    case OFPACT_MULTIPATH:\n    case OFPACT_NOTE:\n    case OFPACT_EXIT:\n    case OFPACT_UNROLL_XLATE:\n    case OFPACT_PUSH_MPLS:\n    case OFPACT_POP_MPLS:\n    case OFPACT_SAMPLE:\n    case OFPACT_CLEAR_ACTIONS:\n    case OFPACT_CLONE:\n    case OFPACT_WRITE_ACTIONS:\n    case OFPACT_GOTO_TABLE:\n    case OFPACT_METER:\n    case OFPACT_GROUP:\n    case OFPACT_DEBUG_RECIRC:\n    case OFPACT_CT:\n    case OFPACT_CT_CLEAR:\n    case OFPACT_NAT:\n    default:\n        return false;\n    }\n}\n\n/* Returns true if any action in the 'ofpacts_len' bytes of 'ofpacts' outputs\n * to 'port', false otherwise. */\nbool\nofpacts_output_to_port(const struct ofpact *ofpacts, size_t ofpacts_len,\n                       ofp_port_t port)\n{\n    const struct ofpact *a;\n\n    OFPACT_FOR_EACH_FLATTENED (a, ofpacts, ofpacts_len) {\n        if (ofpact_outputs_to_port(a, port)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/* Returns true if any action in the 'ofpacts_len' bytes of 'ofpacts' outputs\n * to 'group', false otherwise. */\nbool\nofpacts_output_to_group(const struct ofpact *ofpacts, size_t ofpacts_len,\n                        uint32_t group_id)\n{\n    const struct ofpact *a;\n\n    OFPACT_FOR_EACH_FLATTENED (a, ofpacts, ofpacts_len) {\n        if (a->type == OFPACT_GROUP\n            && ofpact_get_GROUP(a)->group_id == group_id) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool\nofpacts_equal(const struct ofpact *a, size_t a_len,\n              const struct ofpact *b, size_t b_len)\n{\n    return a_len == b_len && !memcmp(a, b, a_len);\n}\n\n/* Finds the OFPACT_METER action, if any, in the 'ofpacts_len' bytes of\n * 'ofpacts'.  If found, returns its meter ID; if not, returns 0.\n *\n * This function relies on the order of 'ofpacts' being correct (as checked by\n * ofpacts_verify()). */\nuint32_t\nofpacts_get_meter(const struct ofpact ofpacts[], size_t ofpacts_len)\n{\n    const struct ofpact *a;\n\n    OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {\n        enum ovs_instruction_type inst;\n\n        inst = ovs_instruction_type_from_ofpact_type(a->type);\n        if (a->type == OFPACT_METER) {\n            return ofpact_get_METER(a)->meter_id;\n        } else if (inst > OVSINST_OFPIT13_METER) {\n            break;\n        }\n    }\n\n    return 0;\n}\n\f\n/* Formatting ofpacts. */\n\nstatic void\nofpact_format(const struct ofpact *a, struct ds *s)\n{\n    switch (a->type) {\n#define OFPACT(ENUM, STRUCT, MEMBER, NAME)                              \\\n        case OFPACT_##ENUM:                                             \\\n            format_##ENUM(ALIGNED_CAST(const struct STRUCT *, a), s);   \\\n            break;\n        OFPACTS\n#undef OFPACT\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Appends a string representing the 'ofpacts_len' bytes of ofpacts in\n * 'ofpacts' to 'string'. */\nvoid\nofpacts_format(const struct ofpact *ofpacts, size_t ofpacts_len,\n               struct ds *string)\n{\n    if (!ofpacts_len) {\n        ds_put_format(string, \"%sdrop%s\", colors.drop, colors.end);\n    } else {\n        const struct ofpact *a;\n\n        OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {\n            if (a != ofpacts) {\n                ds_put_char(string, ',');\n            }\n\n            ofpact_format(a, string);\n        }\n    }\n}\n\f\n/* Internal use by helpers. */\n\n/* Implementation of ofpact_put_<ENUM>(). */\nvoid *\nofpact_put(struct ofpbuf *ofpacts, enum ofpact_type type, size_t len)\n{\n    struct ofpact *ofpact;\n\n    ofpacts->header = ofpbuf_put_uninit(ofpacts, len);\n    ofpact = ofpacts->header;\n    ofpact_init(ofpact, type, len);\n    return ofpact;\n}\n\n/* Implementation of ofpact_init_<ENUM>(). */\nvoid\nofpact_init(struct ofpact *ofpact, enum ofpact_type type, size_t len)\n{\n    memset(ofpact, 0, len);\n    ofpact->type = type;\n    ofpact->raw = -1;\n    ofpact->len = len;\n}\n\n/* Implementation of ofpact_finish_<ENUM>().\n *\n * Finishes composing a variable-length action (begun using\n * ofpact_put_<NAME>()), by padding the action to a multiple of OFPACT_ALIGNTO\n * bytes and updating its embedded length field.  See the large comment near\n * the end of ofp-actions.h for more information.\n *\n * May reallocate 'ofpacts'. Callers should consider updating their 'ofpact'\n * pointer to the return value of this function. */\nvoid *\nofpact_finish(struct ofpbuf *ofpacts, struct ofpact *ofpact)\n{\n    ptrdiff_t len;\n\n    ovs_assert(ofpact == ofpacts->header);\n    len = (char *) ofpbuf_tail(ofpacts) - (char *) ofpact;\n    ovs_assert(len > 0 && len <= UINT16_MAX);\n    ofpact->len = len;\n    ofpbuf_padto(ofpacts, OFPACT_ALIGN(ofpacts->size));\n\n    return ofpacts->header;\n}\n\f\nstatic char * OVS_WARN_UNUSED_RESULT\nofpact_parse(enum ofpact_type type, char *value, struct ofpbuf *ofpacts,\n             enum ofputil_protocol *usable_protocols)\n{\n    switch (type) {\n#define OFPACT(ENUM, STRUCT, MEMBER, NAME)                            \\\n        case OFPACT_##ENUM:                                             \\\n            return parse_##ENUM(value, ofpacts, usable_protocols);\n        OFPACTS\n#undef OFPACT\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic bool\nofpact_type_from_name(const char *name, enum ofpact_type *type)\n{\n#define OFPACT(ENUM, STRUCT, MEMBER, NAME)                            \\\n    if (!strcasecmp(name, NAME)) {                                    \\\n        *type = OFPACT_##ENUM;                                          \\\n        return true;                                                    \\\n    }\n    OFPACTS\n#undef OFPACT\n\n    return false;\n}\n\n/* Parses 'str' as a series of instructions, and appends them to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string.\n *\n * If 'outer_action' is specified, indicates that the actions being parsed\n * are nested within another action of the type specified in 'outer_action'. */\nstatic char * OVS_WARN_UNUSED_RESULT\nofpacts_parse__(char *str, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols,\n                bool allow_instructions, enum ofpact_type outer_action)\n{\n    int prev_inst = -1;\n    enum ofperr retval;\n    char *key, *value;\n    bool drop = false;\n    char *pos;\n\n    pos = str;\n    while (ofputil_parse_key_value(&pos, &key, &value)) {\n        enum ovs_instruction_type inst = OVSINST_OFPIT11_APPLY_ACTIONS;\n        enum ofpact_type type;\n        char *error = NULL;\n        ofp_port_t port;\n\n        if (ofpact_type_from_name(key, &type)) {\n            error = ofpact_parse(type, value, ofpacts, usable_protocols);\n            inst = ovs_instruction_type_from_ofpact_type(type);\n        } else if (!strcasecmp(key, \"mod_vlan_vid\")) {\n            error = parse_set_vlan_vid(value, ofpacts, true);\n        } else if (!strcasecmp(key, \"mod_vlan_pcp\")) {\n            error = parse_set_vlan_pcp(value, ofpacts, true);\n        } else if (!strcasecmp(key, \"set_nw_ttl\")) {\n            error = parse_SET_IP_TTL(value, ofpacts, usable_protocols);\n        } else if (!strcasecmp(key, \"pop_vlan\")) {\n            error = parse_pop_vlan(ofpacts);\n        } else if (!strcasecmp(key, \"set_tunnel64\")) {\n            error = parse_set_tunnel(value, ofpacts,\n                                     NXAST_RAW_SET_TUNNEL64);\n        } else if (!strcasecmp(key, \"load\")) {\n            error = parse_reg_load(value, ofpacts);\n        } else if (!strcasecmp(key, \"bundle_load\")) {\n            error = parse_bundle_load(value, ofpacts);\n        } else if (!strcasecmp(key, \"drop\")) {\n            drop = true;\n        } else if (!strcasecmp(key, \"apply_actions\")) {\n            return xstrdup(\"apply_actions is the default instruction\");\n        } else if (ofputil_port_from_string(key, &port)) {\n            ofpact_put_OUTPUT(ofpacts)->port = port;\n        } else {\n            return xasprintf(\"unknown action %s\", key);\n        }\n        if (error) {\n            return error;\n        }\n\n        if (inst != OVSINST_OFPIT11_APPLY_ACTIONS) {\n            if (!allow_instructions) {\n                return xasprintf(\"only actions are allowed here (not \"\n                                 \"instruction %s)\",\n                                 ovs_instruction_name_from_type(inst));\n            }\n            if (inst == prev_inst) {\n                return xasprintf(\"instruction %s may be specified only once\",\n                                 ovs_instruction_name_from_type(inst));\n            }\n        }\n        if (prev_inst != -1 && inst < prev_inst) {\n            return xasprintf(\"instruction %s must be specified before %s\",\n                             ovs_instruction_name_from_type(inst),\n                             ovs_instruction_name_from_type(prev_inst));\n        }\n        prev_inst = inst;\n    }\n\n    if (drop && ofpacts->size) {\n        return xstrdup(\"\\\"drop\\\" must not be accompanied by any other action \"\n                       \"or instruction\");\n    }\n\n    retval = ofpacts_verify(ofpacts->data, ofpacts->size,\n                            (allow_instructions\n                             ? (1u << N_OVS_INSTRUCTIONS) - 1\n                             : 1u << OVSINST_OFPIT11_APPLY_ACTIONS),\n                            outer_action);\n    if (retval) {\n        return xstrdup(\"Incorrect instruction ordering\");\n    }\n\n    return NULL;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nofpacts_parse(char *str, struct ofpbuf *ofpacts,\n              enum ofputil_protocol *usable_protocols, bool allow_instructions,\n              enum ofpact_type outer_action)\n{\n    uint32_t orig_size = ofpacts->size;\n    char *error = ofpacts_parse__(str, ofpacts, usable_protocols,\n                                  allow_instructions, outer_action);\n    if (error) {\n        ofpacts->size = orig_size;\n    }\n    return error;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nofpacts_parse_copy(const char *s_, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols,\n                   bool allow_instructions, enum ofpact_type outer_action)\n{\n    char *error, *s;\n\n    *usable_protocols = OFPUTIL_P_ANY;\n\n    s = xstrdup(s_);\n    error = ofpacts_parse(s, ofpacts, usable_protocols, allow_instructions,\n                          outer_action);\n    free(s);\n\n    return error;\n}\n\n/* Parses 's' as a set of OpenFlow actions and appends the actions to\n * 'ofpacts'. 'outer_action', if nonzero, specifies that 's' contains actions\n * that are nested within the action of type 'outer_action'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nchar * OVS_WARN_UNUSED_RESULT\nofpacts_parse_actions(const char *s, struct ofpbuf *ofpacts,\n                      enum ofputil_protocol *usable_protocols)\n{\n    return ofpacts_parse_copy(s, ofpacts, usable_protocols, false, 0);\n}\n\n/* Parses 's' as a set of OpenFlow instructions and appends the instructions to\n * 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nchar * OVS_WARN_UNUSED_RESULT\nofpacts_parse_instructions(const char *s, struct ofpbuf *ofpacts,\n                           enum ofputil_protocol *usable_protocols)\n{\n    return ofpacts_parse_copy(s, ofpacts, usable_protocols, true, 0);\n}\n\nconst char *\nofpact_name(enum ofpact_type type)\n{\n    switch (type) {\n#define OFPACT(ENUM, STRUCT, MEMBER, NAME) case OFPACT_##ENUM: return NAME;\n        OFPACTS\n#undef OFPACT\n    }\n    return \"<unknown>\";\n}\n\f\n/* Low-level action decoding and encoding functions. */\n\n/* Everything needed to identify a particular OpenFlow action. */\nstruct ofpact_hdrs {\n    uint32_t vendor;              /* 0 if standard, otherwise a vendor code. */\n    uint16_t type;                /* Type if standard, otherwise subtype. */\n    uint8_t ofp_version;          /* From ofp_header. */\n};\n\n/* Information about a particular OpenFlow action. */\nstruct ofpact_raw_instance {\n    /* The action's identity. */\n    struct ofpact_hdrs hdrs;\n    enum ofp_raw_action_type raw;\n\n    /* Looking up the action. */\n    struct hmap_node decode_node; /* Based on 'hdrs'. */\n    struct hmap_node encode_node; /* Based on 'raw' + 'hdrs.ofp_version'. */\n\n    /* The action's encoded size.\n     *\n     * If this action is fixed-length, 'min_length' == 'max_length'.\n     * If it is variable length, then 'max_length' is ROUND_DOWN(UINT16_MAX,\n     * OFP_ACTION_ALIGN) == 65528. */\n    unsigned short int min_length;\n    unsigned short int max_length;\n\n    /* For actions with a simple integer numeric argument, 'arg_ofs' is the\n     * offset of that argument from the beginning of the action and 'arg_len'\n     * its length, both in bytes.\n     *\n     * For actions that take other forms, these are both zero. */\n    unsigned short int arg_ofs;\n    unsigned short int arg_len;\n\n    /* The name of the action, e.g. \"OFPAT_OUTPUT\" or \"NXAST_RESUBMIT\". */\n    const char *name;\n\n    /* If this action is deprecated, a human-readable string with a brief\n     * explanation. */\n    const char *deprecation;\n};\n\n/* Action header. */\nstruct ofp_action_header {\n    /* The meaning of other values of 'type' generally depends on the OpenFlow\n     * version (see enum ofp_raw_action_type).\n     *\n     * Across all OpenFlow versions, OFPAT_VENDOR indicates that 'vendor'\n     * designates an OpenFlow vendor ID and that the remainder of the action\n     * structure has a vendor-defined meaning.\n     */\n#define OFPAT_VENDOR 0xffff\n    ovs_be16 type;\n\n    /* Always a multiple of 8. */\n    ovs_be16 len;\n\n    /* For type == OFPAT_VENDOR only, this is a vendor ID, e.g. NX_VENDOR_ID or\n     * ONF_VENDOR_ID.  Other 'type's use this space for some other purpose. */\n    ovs_be32 vendor;\n};\nOFP_ASSERT(sizeof(struct ofp_action_header) == 8);\n\nstatic bool\nofpact_hdrs_equal(const struct ofpact_hdrs *a,\n                  const struct ofpact_hdrs *b)\n{\n    return (a->vendor == b->vendor\n            && a->type == b->type\n            && a->ofp_version == b->ofp_version);\n}\n\nstatic uint32_t\nofpact_hdrs_hash(const struct ofpact_hdrs *hdrs)\n{\n    return hash_2words(hdrs->vendor, (hdrs->type << 16) | hdrs->ofp_version);\n}\n\n#include \"ofp-actions.inc2\"\n\nstatic struct hmap *\nofpact_decode_hmap(void)\n{\n    static struct ovsthread_once once = OVSTHREAD_ONCE_INITIALIZER;\n    static struct hmap hmap;\n\n    if (ovsthread_once_start(&once)) {\n        struct ofpact_raw_instance *inst;\n\n        hmap_init(&hmap);\n        for (inst = all_raw_instances;\n             inst < &all_raw_instances[ARRAY_SIZE(all_raw_instances)];\n             inst++) {\n            hmap_insert(&hmap, &inst->decode_node,\n                        ofpact_hdrs_hash(&inst->hdrs));\n        }\n        ovsthread_once_done(&once);\n    }\n    return &hmap;\n}\n\nstatic struct hmap *\nofpact_encode_hmap(void)\n{\n    static struct ovsthread_once once = OVSTHREAD_ONCE_INITIALIZER;\n    static struct hmap hmap;\n\n    if (ovsthread_once_start(&once)) {\n        struct ofpact_raw_instance *inst;\n\n        hmap_init(&hmap);\n        for (inst = all_raw_instances;\n             inst < &all_raw_instances[ARRAY_SIZE(all_raw_instances)];\n             inst++) {\n            hmap_insert(&hmap, &inst->encode_node,\n                        hash_2words(inst->raw, inst->hdrs.ofp_version));\n        }\n        ovsthread_once_done(&once);\n    }\n    return &hmap;\n}\n\nstatic enum ofperr\nofpact_decode_raw(enum ofp_version ofp_version,\n                  const struct ofp_action_header *oah, size_t length,\n                  const struct ofpact_raw_instance **instp)\n{\n    const struct ofpact_raw_instance *inst;\n    struct ofpact_hdrs hdrs;\n\n    *instp = NULL;\n    if (length < sizeof *oah) {\n        return OFPERR_OFPBAC_BAD_LEN;\n    }\n\n    /* Get base action type. */\n    if (oah->type == htons(OFPAT_VENDOR)) {\n        /* Get vendor. */\n        hdrs.vendor = ntohl(oah->vendor);\n        if (hdrs.vendor == NX_VENDOR_ID || hdrs.vendor == ONF_VENDOR_ID) {\n            /* Get extension subtype. */\n            const struct ext_action_header *nah;\n\n            nah = ALIGNED_CAST(const struct ext_action_header *, oah);\n            if (length < sizeof *nah) {\n                return OFPERR_OFPBAC_BAD_LEN;\n            }\n            hdrs.type = ntohs(nah->subtype);\n        } else {\n            VLOG_WARN_RL(&rl, \"OpenFlow action has unknown vendor %#\"PRIx32,\n                         hdrs.vendor);\n            return OFPERR_OFPBAC_BAD_VENDOR;\n        }\n    } else {\n        hdrs.vendor = 0;\n        hdrs.type = ntohs(oah->type);\n    }\n\n    hdrs.ofp_version = ofp_version;\n    HMAP_FOR_EACH_WITH_HASH (inst, decode_node, ofpact_hdrs_hash(&hdrs),\n                             ofpact_decode_hmap()) {\n        if (ofpact_hdrs_equal(&hdrs, &inst->hdrs)) {\n            *instp = inst;\n            return 0;\n        }\n    }\n\n    return (hdrs.vendor\n            ? OFPERR_OFPBAC_BAD_VENDOR_TYPE\n            : OFPERR_OFPBAC_BAD_TYPE);\n}\n\nstatic enum ofperr\nofpact_pull_raw(struct ofpbuf *buf, enum ofp_version ofp_version,\n                enum ofp_raw_action_type *raw, uint64_t *arg)\n{\n    const struct ofp_action_header *oah = buf->data;\n    const struct ofpact_raw_instance *action;\n    unsigned int length;\n    enum ofperr error;\n\n    *raw = *arg = 0;\n    error = ofpact_decode_raw(ofp_version, oah, buf->size, &action);\n    if (error) {\n        return error;\n    }\n\n    if (action->deprecation) {\n        VLOG_INFO_RL(&rl, \"%s is deprecated in %s (%s)\",\n                     action->name, ofputil_version_to_string(ofp_version),\n                     action->deprecation);\n    }\n\n    length = ntohs(oah->len);\n    if (length > buf->size) {\n        VLOG_WARN_RL(&rl, \"OpenFlow action %s length %u exceeds action buffer \"\n                     \"length %\"PRIu32, action->name, length, buf->size);\n        return OFPERR_OFPBAC_BAD_LEN;\n    }\n    if (length < action->min_length || length > action->max_length) {\n        VLOG_WARN_RL(&rl, \"OpenFlow action %s length %u not in valid range \"\n                     \"[%hu,%hu]\", action->name, length,\n                     action->min_length, action->max_length);\n        return OFPERR_OFPBAC_BAD_LEN;\n    }\n    if (length % 8) {\n        VLOG_WARN_RL(&rl, \"OpenFlow action %s length %u is not a multiple \"\n                     \"of 8\", action->name, length);\n        return OFPERR_OFPBAC_BAD_LEN;\n    }\n\n    *raw = action->raw;\n    *arg = 0;\n    if (action->arg_len) {\n        const uint8_t *p;\n        int i;\n\n        p = ofpbuf_at_assert(buf, action->arg_ofs, action->arg_len);\n        for (i = 0; i < action->arg_len; i++) {\n            *arg = (*arg << 8) | p[i];\n        }\n    }\n\n    ofpbuf_pull(buf, length);\n\n    return 0;\n}\n\nstatic const struct ofpact_raw_instance *\nofpact_raw_lookup(enum ofp_version ofp_version, enum ofp_raw_action_type raw)\n{\n    const struct ofpact_raw_instance *inst;\n\n    HMAP_FOR_EACH_WITH_HASH (inst, encode_node, hash_2words(raw, ofp_version),\n                             ofpact_encode_hmap()) {\n        if (inst->raw == raw && inst->hdrs.ofp_version == ofp_version) {\n            return inst;\n        }\n    }\n    OVS_NOT_REACHED();\n}\n\nstatic void *\nofpact_put_raw(struct ofpbuf *buf, enum ofp_version ofp_version,\n               enum ofp_raw_action_type raw, uint64_t arg)\n{\n    const struct ofpact_raw_instance *inst;\n    struct ofp_action_header *oah;\n    const struct ofpact_hdrs *hdrs;\n\n    inst = ofpact_raw_lookup(ofp_version, raw);\n    hdrs = &inst->hdrs;\n\n    oah = ofpbuf_put_zeros(buf, inst->min_length);\n    oah->type = htons(hdrs->vendor ? OFPAT_VENDOR : hdrs->type);\n    oah->len = htons(inst->min_length);\n    oah->vendor = htonl(hdrs->vendor);\n\n    switch (hdrs->vendor) {\n    case 0:\n        break;\n\n    case NX_VENDOR_ID:\n    case ONF_VENDOR_ID: {\n        struct ext_action_header *nah = (struct ext_action_header *) oah;\n        nah->subtype = htons(hdrs->type);\n        break;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    if (inst->arg_len) {\n        uint8_t *p = (uint8_t *) oah + inst->arg_ofs + inst->arg_len;\n        int i;\n\n        for (i = 0; i < inst->arg_len; i++) {\n            *--p = arg;\n            arg >>= 8;\n        }\n    } else {\n        ovs_assert(!arg);\n    }\n\n    return oah;\n}\n\nstatic void\npad_ofpat(struct ofpbuf *openflow, size_t start_ofs)\n{\n    struct ofp_action_header *oah;\n\n    ofpbuf_put_zeros(openflow, PAD_SIZE(openflow->size - start_ofs,\n                                        OFP_ACTION_ALIGN));\n\n    oah = ofpbuf_at_assert(openflow, start_ofs, sizeof *oah);\n    oah->len = htons(openflow->size - start_ofs);\n}\n\n"], "fixing_code": ["/*\n * Copyright (c) 2008-2017 Nicira, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <config.h>\n#include <netinet/in.h>\n\n#include \"bundle.h\"\n#include \"byte-order.h\"\n#include \"colors.h\"\n#include \"compiler.h\"\n#include \"dummy.h\"\n#include \"openvswitch/hmap.h\"\n#include \"learn.h\"\n#include \"multipath.h\"\n#include \"nx-match.h\"\n#include \"odp-netlink.h\"\n#include \"openvswitch/dynamic-string.h\"\n#include \"openvswitch/meta-flow.h\"\n#include \"openvswitch/ofp-actions.h\"\n#include \"openvswitch/ofp-util.h\"\n#include \"openvswitch/ofp-parse.h\"\n#include \"openvswitch/ofp-prop.h\"\n#include \"openvswitch/ofpbuf.h\"\n#include \"openvswitch/vlog.h\"\n#include \"unaligned.h\"\n#include \"util.h\"\n#include \"vl-mff-map.h\"\n\nVLOG_DEFINE_THIS_MODULE(ofp_actions);\n\nstatic struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n\nstruct ofp_action_header;\n\n/* Header for Open vSwitch and ONF vendor extension actions.\n *\n * This is the entire header for a few Open vSwitch vendor extension actions,\n * the ones that either have no arguments or for which variable-length\n * arguments follow the header.\n *\n * This cannot be used as an entirely generic vendor extension action header,\n * because OpenFlow does not specify the location or size of the action\n * subtype; it just happens that ONF extensions and Nicira extensions share\n * this format. */\nstruct ext_action_header {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* At least 16. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID or ONF_VENDOR_ID. */\n    ovs_be16 subtype;               /* See enum ofp_raw_action_type. */\n    uint8_t pad[6];\n};\nOFP_ASSERT(sizeof(struct ext_action_header) == 16);\n\n/* Raw identifiers for OpenFlow actions.\n *\n * Decoding and encoding OpenFlow actions across multiple versions is difficult\n * to do in a clean, consistent way.  This enumeration lays out all of the\n * forms of actions that Open vSwitch supports.\n *\n * The comments here must follow a stylized form because the\n * \"extract-ofp-actions\" program parses them at build time to generate data\n * tables.\n *\n *   - The first part of each comment specifies the vendor, OpenFlow versions,\n *     and type for each protocol that supports the action:\n *\n *         # The vendor is OF for standard OpenFlow actions, NX for Nicira\n *           extension actions.  (Support for other vendors can be added, but\n *           it can't be done just based on a vendor ID definition alone\n *           because OpenFlow doesn't define a standard way to specify a\n *           subtype for vendor actions, so other vendors might do it different\n *           from Nicira.)\n *\n *         # The version can specify a specific OpenFlow version, a version\n *           range delimited by \"-\", or an open-ended range with \"+\".\n *\n *         # The type, in parentheses, is the action type number (for standard\n *           OpenFlow actions) or subtype (for vendor extension actions).\n *\n *         # Optionally one may add \"is deprecated\" followed by a\n *           human-readable reason in parentheses (which will be used in log\n *           messages), if a particular action should no longer be used.\n *\n *     Multiple such specifications may be separated by commas.\n *\n *   - The second part describes the action's wire format.  It may be:\n *\n *         # \"struct <name>\": The struct fully specifies the wire format.  The\n *           action is exactly the size of the struct.  (Thus, the struct must\n *           be an exact multiple of 8 bytes in size.)\n *\n *         # \"struct <name>, ...\": The struct specifies the beginning of the\n *           wire format.  An instance of the action is either the struct's\n *           exact size, or a multiple of 8 bytes longer.\n *\n *         # \"uint<N>_t\" or \"ovs_be<N>\": The action consists of a (standard or\n *           vendor extension) header, followed by 0 or more pad bytes to align\n *           to a multiple of <N> bits, followed by an argument of the given\n *           type, followed by 0 or more pad bytes to bring the total action up\n *           to a multiple of 8 bytes.\n *\n *         # \"void\": The action is just a (standard or vendor extension)\n *           header.\n *\n *         # Optionally, one may add \"VLMFF\" in the end of the second part if\n *           the Openflow action may use a variable length meta-flow field\n *           (i.e. tun_metadata). Adding \"VLMFF\" will pass the per-switch based\n *           variable length meta-flow field mapping map (struct vl_mff_map) to\n *           the corresponding action decoding function.\n *\n *   - Optional additional text enclosed in square brackets is commentary for\n *     the human reader.\n */\nenum ofp_raw_action_type {\n/* ## ----------------- ## */\n/* ## Standard actions. ## */\n/* ## ----------------- ## */\n\n    /* OF1.0(0): struct ofp10_action_output. */\n    OFPAT_RAW10_OUTPUT,\n    /* OF1.1+(0): struct ofp11_action_output. */\n    OFPAT_RAW11_OUTPUT,\n\n    /* OF1.0(1): uint16_t. */\n    OFPAT_RAW10_SET_VLAN_VID,\n    /* OF1.0(2): uint8_t. */\n    OFPAT_RAW10_SET_VLAN_PCP,\n\n    /* OF1.1(1), OF1.2+(1) is deprecated (use Set-Field): uint16_t.\n     *\n     * [Semantics differ slightly between the 1.0 and 1.1 versions of the VLAN\n     * modification actions: the 1.0 versions push a VLAN header if none is\n     * present, but the 1.1 versions do not.  That is the only reason that we\n     * distinguish their raw action types.] */\n    OFPAT_RAW11_SET_VLAN_VID,\n    /* OF1.1(2), OF1.2+(2) is deprecated (use Set-Field): uint8_t. */\n    OFPAT_RAW11_SET_VLAN_PCP,\n\n    /* OF1.1+(17): ovs_be16.\n     *\n     * [The argument is the Ethertype, e.g. ETH_TYPE_VLAN_8021Q, not the VID or\n     * TCI.] */\n    OFPAT_RAW11_PUSH_VLAN,\n\n    /* OF1.0(3): void. */\n    OFPAT_RAW10_STRIP_VLAN,\n    /* OF1.1+(18): void. */\n    OFPAT_RAW11_POP_VLAN,\n\n    /* OF1.0(4), OF1.1(3), OF1.2+(3) is deprecated (use Set-Field): struct\n     * ofp_action_dl_addr. */\n    OFPAT_RAW_SET_DL_SRC,\n\n    /* OF1.0(5), OF1.1(4), OF1.2+(4) is deprecated (use Set-Field): struct\n     * ofp_action_dl_addr. */\n    OFPAT_RAW_SET_DL_DST,\n\n    /* OF1.0(6), OF1.1(5), OF1.2+(5) is deprecated (use Set-Field):\n     * ovs_be32. */\n    OFPAT_RAW_SET_NW_SRC,\n\n    /* OF1.0(7), OF1.1(6), OF1.2+(6) is deprecated (use Set-Field):\n     * ovs_be32. */\n    OFPAT_RAW_SET_NW_DST,\n\n    /* OF1.0(8), OF1.1(7), OF1.2+(7) is deprecated (use Set-Field): uint8_t. */\n    OFPAT_RAW_SET_NW_TOS,\n\n    /* OF1.1(8), OF1.2+(8) is deprecated (use Set-Field): uint8_t. */\n    OFPAT_RAW11_SET_NW_ECN,\n\n    /* OF1.0(9), OF1.1(9), OF1.2+(9) is deprecated (use Set-Field):\n     * ovs_be16. */\n    OFPAT_RAW_SET_TP_SRC,\n\n    /* OF1.0(10), OF1.1(10), OF1.2+(10) is deprecated (use Set-Field):\n     * ovs_be16. */\n    OFPAT_RAW_SET_TP_DST,\n\n    /* OF1.0(11): struct ofp10_action_enqueue. */\n    OFPAT_RAW10_ENQUEUE,\n\n    /* NX1.0(30), OF1.1(13), OF1.2+(13) is deprecated (use Set-Field):\n     * ovs_be32. */\n    OFPAT_RAW_SET_MPLS_LABEL,\n\n    /* NX1.0(31), OF1.1(14), OF1.2+(14) is deprecated (use Set-Field):\n     * uint8_t. */\n    OFPAT_RAW_SET_MPLS_TC,\n\n    /* NX1.0(25), OF1.1(15), OF1.2+(15) is deprecated (use Set-Field):\n     * uint8_t. */\n    OFPAT_RAW_SET_MPLS_TTL,\n\n    /* NX1.0(26), OF1.1+(16): void. */\n    OFPAT_RAW_DEC_MPLS_TTL,\n\n    /* NX1.0(23), OF1.1+(19): ovs_be16.\n     *\n     * [The argument is the Ethertype, e.g. ETH_TYPE_MPLS, not the label.] */\n    OFPAT_RAW_PUSH_MPLS,\n\n    /* NX1.0(24), OF1.1+(20): ovs_be16.\n     *\n     * [The argument is the Ethertype, e.g. ETH_TYPE_IPV4 if at BoS or\n     * ETH_TYPE_MPLS otherwise, not the label.] */\n    OFPAT_RAW_POP_MPLS,\n\n    /* NX1.0(4), OF1.1+(21): uint32_t. */\n    OFPAT_RAW_SET_QUEUE,\n\n    /* NX1.0(40), OF1.1+(22): uint32_t. */\n    OFPAT_RAW_GROUP,\n\n    /* OF1.1+(23): uint8_t. */\n    OFPAT_RAW11_SET_NW_TTL,\n\n    /* NX1.0(18), OF1.1+(24): void. */\n    OFPAT_RAW_DEC_NW_TTL,\n    /* NX1.0+(21): struct nx_action_cnt_ids, ... */\n    NXAST_RAW_DEC_TTL_CNT_IDS,\n\n    /* OF1.2-1.4(25): struct ofp12_action_set_field, ... VLMFF */\n    OFPAT_RAW12_SET_FIELD,\n    /* OF1.5+(25): struct ofp12_action_set_field, ... VLMFF */\n    OFPAT_RAW15_SET_FIELD,\n    /* NX1.0-1.4(7): struct nx_action_reg_load. VLMFF\n     *\n     * [In OpenFlow 1.5, set_field is a superset of reg_load functionality, so\n     * we drop reg_load.] */\n    NXAST_RAW_REG_LOAD,\n    /* NX1.0-1.4(33): struct ext_action_header, ... VLMFF\n     *\n     * [In OpenFlow 1.5, set_field is a superset of reg_load2 functionality, so\n     * we drop reg_load2.] */\n    NXAST_RAW_REG_LOAD2,\n\n    /* OF1.5+(28): struct ofp15_action_copy_field, ... VLMFF */\n    OFPAT_RAW15_COPY_FIELD,\n    /* ONF1.3-1.4(3200): struct onf_action_copy_field, ... VLMFF */\n    ONFACT_RAW13_COPY_FIELD,\n    /* NX1.0-1.4(6): struct nx_action_reg_move, ... VLMFF */\n    NXAST_RAW_REG_MOVE,\n\n/* ## ------------------------- ## */\n/* ## Nicira extension actions. ## */\n/* ## ------------------------- ## */\n\n/* Actions similar to standard actions are listed with the standard actions. */\n\n    /* NX1.0+(1): uint16_t. */\n    NXAST_RAW_RESUBMIT,\n    /* NX1.0+(14): struct nx_action_resubmit. */\n    NXAST_RAW_RESUBMIT_TABLE,\n\n    /* NX1.0+(2): uint32_t. */\n    NXAST_RAW_SET_TUNNEL,\n    /* NX1.0+(9): uint64_t. */\n    NXAST_RAW_SET_TUNNEL64,\n\n    /* NX1.0+(5): void. */\n    NXAST_RAW_POP_QUEUE,\n\n    /* NX1.0+(8): struct nx_action_note, ... */\n    NXAST_RAW_NOTE,\n\n    /* NX1.0+(10): struct nx_action_multipath. VLMFF */\n    NXAST_RAW_MULTIPATH,\n\n    /* NX1.0+(12): struct nx_action_bundle, ... */\n    NXAST_RAW_BUNDLE,\n    /* NX1.0+(13): struct nx_action_bundle, ... VLMFF */\n    NXAST_RAW_BUNDLE_LOAD,\n\n    /* NX1.0+(15): struct nx_action_output_reg. VLMFF */\n    NXAST_RAW_OUTPUT_REG,\n    /* NX1.0+(32): struct nx_action_output_reg2. VLMFF */\n    NXAST_RAW_OUTPUT_REG2,\n\n    /* NX1.0+(16): struct nx_action_learn, ... VLMFF */\n    NXAST_RAW_LEARN,\n\n    /* NX1.0+(17): void. */\n    NXAST_RAW_EXIT,\n\n    /* NX1.0+(19): struct nx_action_fin_timeout. */\n    NXAST_RAW_FIN_TIMEOUT,\n\n    /* NX1.0+(20): struct nx_action_controller. */\n    NXAST_RAW_CONTROLLER,\n    /* NX1.0+(37): struct ext_action_header, ... */\n    NXAST_RAW_CONTROLLER2,\n\n    /* NX1.0+(22): struct nx_action_write_metadata. */\n    NXAST_RAW_WRITE_METADATA,\n\n    /* NX1.0+(27): struct nx_action_stack. VLMFF */\n    NXAST_RAW_STACK_PUSH,\n\n    /* NX1.0+(28): struct nx_action_stack. VLMFF */\n    NXAST_RAW_STACK_POP,\n\n    /* NX1.0+(29): struct nx_action_sample. */\n    NXAST_RAW_SAMPLE,\n    /* NX1.0+(38): struct nx_action_sample2. */\n    NXAST_RAW_SAMPLE2,\n    /* NX1.0+(41): struct nx_action_sample2. */\n    NXAST_RAW_SAMPLE3,\n\n    /* NX1.0+(34): struct nx_action_conjunction. */\n    NXAST_RAW_CONJUNCTION,\n\n    /* NX1.0+(35): struct nx_action_conntrack, ... VLMFF */\n    NXAST_RAW_CT,\n\n    /* NX1.0+(36): struct nx_action_nat, ... */\n    NXAST_RAW_NAT,\n\n    /* NX1.0+(39): struct nx_action_output_trunc. */\n    NXAST_RAW_OUTPUT_TRUNC,\n\n    /* NX1.0+(42): struct ext_action_header, ... VLMFF */\n    NXAST_RAW_CLONE,\n\n    /* NX1.0+(43): void. */\n    NXAST_RAW_CT_CLEAR,\n\n/* ## ------------------ ## */\n/* ## Debugging actions. ## */\n/* ## ------------------ ## */\n\n/* These are intentionally undocumented, subject to change, and ovs-vswitchd */\n/* accepts them only if started with --enable-dummy. */\n\n    /* NX1.0+(255): void. */\n    NXAST_RAW_DEBUG_RECIRC,\n};\n\n/* OpenFlow actions are always a multiple of 8 bytes in length. */\n#define OFP_ACTION_ALIGN 8\n\n/* Define a few functions for working with instructions. */\n#define DEFINE_INST(ENUM, STRUCT, EXTENSIBLE, NAME)             \\\n    static inline const struct STRUCT * OVS_UNUSED              \\\n    instruction_get_##ENUM(const struct ofp11_instruction *inst)\\\n    {                                                           \\\n        ovs_assert(inst->type == htons(ENUM));                  \\\n        return ALIGNED_CAST(struct STRUCT *, inst);             \\\n    }                                                           \\\n                                                                \\\n    static inline void OVS_UNUSED                               \\\n    instruction_init_##ENUM(struct STRUCT *s)                   \\\n    {                                                           \\\n        memset(s, 0, sizeof *s);                                \\\n        s->type = htons(ENUM);                                  \\\n        s->len = htons(sizeof *s);                              \\\n    }                                                           \\\n                                                                \\\n    static inline struct STRUCT * OVS_UNUSED                    \\\n    instruction_put_##ENUM(struct ofpbuf *buf)                  \\\n    {                                                           \\\n        struct STRUCT *s = ofpbuf_put_uninit(buf, sizeof *s);   \\\n        instruction_init_##ENUM(s);                             \\\n        return s;                                               \\\n    }\nOVS_INSTRUCTIONS\n#undef DEFINE_INST\n\nstatic void ofpacts_update_instruction_actions(struct ofpbuf *openflow,\n                                               size_t ofs);\nstatic void pad_ofpat(struct ofpbuf *openflow, size_t start_ofs);\n\nstatic enum ofperr ofpacts_verify(const struct ofpact[], size_t ofpacts_len,\n                                  uint32_t allowed_ovsinsts,\n                                  enum ofpact_type outer_action);\n\nstatic void put_set_field(struct ofpbuf *openflow, enum ofp_version,\n                          enum mf_field_id, uint64_t value);\n\nstatic void put_reg_load(struct ofpbuf *openflow,\n                         const struct mf_subfield *, uint64_t value);\n\nstatic enum ofperr ofpact_pull_raw(struct ofpbuf *, enum ofp_version,\n                                   enum ofp_raw_action_type *, uint64_t *arg);\nstatic void *ofpact_put_raw(struct ofpbuf *, enum ofp_version,\n                            enum ofp_raw_action_type, uint64_t arg);\n\nstatic char *OVS_WARN_UNUSED_RESULT ofpacts_parse(\n    char *str, struct ofpbuf *ofpacts, enum ofputil_protocol *usable_protocols,\n    bool allow_instructions, enum ofpact_type outer_action);\nstatic enum ofperr ofpacts_pull_openflow_actions__(\n    struct ofpbuf *openflow, unsigned int actions_len,\n    enum ofp_version version, uint32_t allowed_ovsinsts,\n    struct ofpbuf *ofpacts, enum ofpact_type outer_action,\n    const struct vl_mff_map *vl_mff_map, uint64_t *ofpacts_tlv_bitmap);\nstatic char * OVS_WARN_UNUSED_RESULT ofpacts_parse_copy(\n    const char *s_, struct ofpbuf *ofpacts,\n    enum ofputil_protocol *usable_protocols,\n    bool allow_instructions, enum ofpact_type outer_action);\n\n/* Returns the ofpact following 'ofpact', except that if 'ofpact' contains\n * nested ofpacts it returns the first one. */\nstruct ofpact *\nofpact_next_flattened(const struct ofpact *ofpact)\n{\n    switch (ofpact->type) {\n    case OFPACT_OUTPUT:\n    case OFPACT_GROUP:\n    case OFPACT_CONTROLLER:\n    case OFPACT_ENQUEUE:\n    case OFPACT_OUTPUT_REG:\n    case OFPACT_OUTPUT_TRUNC:\n    case OFPACT_BUNDLE:\n    case OFPACT_SET_FIELD:\n    case OFPACT_SET_VLAN_VID:\n    case OFPACT_SET_VLAN_PCP:\n    case OFPACT_STRIP_VLAN:\n    case OFPACT_PUSH_VLAN:\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_ETH_DST:\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_IPV4_DST:\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_L4_DST_PORT:\n    case OFPACT_REG_MOVE:\n    case OFPACT_STACK_PUSH:\n    case OFPACT_STACK_POP:\n    case OFPACT_DEC_TTL:\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_DEC_MPLS_TTL:\n    case OFPACT_PUSH_MPLS:\n    case OFPACT_POP_MPLS:\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_FIN_TIMEOUT:\n    case OFPACT_RESUBMIT:\n    case OFPACT_LEARN:\n    case OFPACT_CONJUNCTION:\n    case OFPACT_MULTIPATH:\n    case OFPACT_NOTE:\n    case OFPACT_EXIT:\n    case OFPACT_SAMPLE:\n    case OFPACT_UNROLL_XLATE:\n    case OFPACT_CT_CLEAR:\n    case OFPACT_DEBUG_RECIRC:\n    case OFPACT_METER:\n    case OFPACT_CLEAR_ACTIONS:\n    case OFPACT_WRITE_METADATA:\n    case OFPACT_GOTO_TABLE:\n    case OFPACT_NAT:\n        return ofpact_next(ofpact);\n\n    case OFPACT_CLONE:\n        return ofpact_get_CLONE(ofpact)->actions;\n\n    case OFPACT_CT:\n        return ofpact_get_CT(ofpact)->actions;\n\n    case OFPACT_WRITE_ACTIONS:\n        return ofpact_get_WRITE_ACTIONS(ofpact)->actions;\n    }\n\n    OVS_NOT_REACHED();\n}\n\n/* Pull off existing actions or instructions. Used by nesting actions to keep\n * ofpacts_parse() oblivious of actions nesting.\n *\n * Push the actions back on after nested parsing, e.g.:\n *\n *     size_t ofs = ofpacts_pull(ofpacts);\n *     ...nested parsing...\n *     ofpbuf_push_uninit(ofpacts, ofs);\n */\nstatic size_t\nofpacts_pull(struct ofpbuf *ofpacts)\n{\n    size_t ofs;\n\n    ofs = ofpacts->size;\n    ofpbuf_pull(ofpacts, ofs);\n\n    return ofs;\n}\n\n#include \"ofp-actions.inc1\"\n\f\n/* Output actions. */\n\n/* Action structure for OFPAT10_OUTPUT, which sends packets out 'port'.\n * When the 'port' is the OFPP_CONTROLLER, 'max_len' indicates the max\n * number of bytes to send.  A 'max_len' of zero means no bytes of the\n * packet should be sent. */\nstruct ofp10_action_output {\n    ovs_be16 type;                  /* OFPAT10_OUTPUT. */\n    ovs_be16 len;                   /* Length is 8. */\n    ovs_be16 port;                  /* Output port. */\n    ovs_be16 max_len;               /* Max length to send to controller. */\n};\nOFP_ASSERT(sizeof(struct ofp10_action_output) == 8);\n\n/* Action structure for OFPAT_OUTPUT, which sends packets out 'port'.\n   * When the 'port' is the OFPP_CONTROLLER, 'max_len' indicates the max\n   * number of bytes to send. A 'max_len' of zero means no bytes of the\n   * packet should be sent.*/\nstruct ofp11_action_output {\n    ovs_be16 type;                    /* OFPAT11_OUTPUT. */\n    ovs_be16 len;                     /* Length is 16. */\n    ovs_be32 port;                    /* Output port. */\n    ovs_be16 max_len;                 /* Max length to send to controller. */\n    uint8_t pad[6];                   /* Pad to 64 bits. */\n};\nOFP_ASSERT(sizeof(struct ofp11_action_output) == 16);\n\nstatic enum ofperr\ndecode_OFPAT_RAW10_OUTPUT(const struct ofp10_action_output *oao,\n                          enum ofp_version ofp_version OVS_UNUSED,\n                          struct ofpbuf *out)\n{\n    struct ofpact_output *output;\n\n    output = ofpact_put_OUTPUT(out);\n    output->port = u16_to_ofp(ntohs(oao->port));\n    output->max_len = ntohs(oao->max_len);\n\n    return ofpact_check_output_port(output->port, OFPP_MAX);\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_OUTPUT(const struct ofp11_action_output *oao,\n                          enum ofp_version ofp_version OVS_UNUSED,\n                          struct ofpbuf *out)\n{\n    struct ofpact_output *output;\n    enum ofperr error;\n\n    output = ofpact_put_OUTPUT(out);\n    output->max_len = ntohs(oao->max_len);\n\n    error = ofputil_port_from_ofp11(oao->port, &output->port);\n    if (error) {\n        return error;\n    }\n\n    return ofpact_check_output_port(output->port, OFPP_MAX);\n}\n\nstatic void\nencode_OUTPUT(const struct ofpact_output *output,\n              enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version == OFP10_VERSION) {\n        struct ofp10_action_output *oao;\n\n        oao = put_OFPAT10_OUTPUT(out);\n        oao->port = htons(ofp_to_u16(output->port));\n        oao->max_len = htons(output->max_len);\n    } else {\n        struct ofp11_action_output *oao;\n\n        oao = put_OFPAT11_OUTPUT(out);\n        oao->port = ofputil_port_to_ofp11(output->port);\n        oao->max_len = htons(output->max_len);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_truncate_subfield(struct ofpact_output_trunc *output_trunc,\n                        const char *arg_)\n{\n    char *key, *value;\n    char *arg = CONST_CAST(char *, arg_);\n\n    while (ofputil_parse_key_value(&arg, &key, &value)) {\n        if (!strcmp(key, \"port\")) {\n            if (!ofputil_port_from_string(value, &output_trunc->port)) {\n                return xasprintf(\"output to unknown truncate port: %s\",\n                                  value);\n            }\n            if (ofp_to_u16(output_trunc->port) > ofp_to_u16(OFPP_MAX)) {\n                if (output_trunc->port != OFPP_LOCAL &&\n                    output_trunc->port != OFPP_IN_PORT)\n                return xasprintf(\"output to unsupported truncate port: %s\",\n                                 value);\n            }\n        } else if (!strcmp(key, \"max_len\")) {\n            char *err;\n\n            err = str_to_u32(value, &output_trunc->max_len);\n            if (err) {\n                return err;\n            }\n        } else {\n            return xasprintf(\"invalid key '%s' in output_trunc argument\",\n                                key);\n        }\n    }\n    return NULL;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_OUTPUT(const char *arg, struct ofpbuf *ofpacts,\n             enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    if (strstr(arg, \"port\") && strstr(arg, \"max_len\")) {\n        struct ofpact_output_trunc *output_trunc;\n\n        output_trunc = ofpact_put_OUTPUT_TRUNC(ofpacts);\n        return parse_truncate_subfield(output_trunc, arg);\n    }\n\n    ofp_port_t port;\n    if (ofputil_port_from_string(arg, &port)) {\n        struct ofpact_output *output = ofpact_put_OUTPUT(ofpacts);\n        output->port = port;\n        output->max_len = output->port == OFPP_CONTROLLER ? UINT16_MAX : 0;\n        return NULL;\n    }\n\n    struct mf_subfield src;\n    char *error = mf_parse_subfield(&src, arg);\n    if (!error) {\n        struct ofpact_output_reg *output_reg;\n\n        output_reg = ofpact_put_OUTPUT_REG(ofpacts);\n        output_reg->max_len = UINT16_MAX;\n        output_reg->src = src;\n        return NULL;\n    }\n    free(error);\n\n    return xasprintf(\"%s: output to unknown port\", arg);\n}\n\nstatic void\nformat_OUTPUT(const struct ofpact_output *a, struct ds *s)\n{\n    if (ofp_to_u16(a->port) < ofp_to_u16(OFPP_MAX)) {\n        ds_put_format(s, \"%soutput:%s%\"PRIu32,\n                      colors.special, colors.end, a->port);\n    } else {\n        ofputil_format_port(a->port, s);\n        if (a->port == OFPP_CONTROLLER) {\n            ds_put_format(s, \":%\"PRIu16, a->max_len);\n        }\n    }\n}\n\f\n/* Group actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_GROUP(uint32_t group_id,\n                         enum ofp_version ofp_version OVS_UNUSED,\n                         struct ofpbuf *out)\n{\n    ofpact_put_GROUP(out)->group_id = group_id;\n    return 0;\n}\n\nstatic void\nencode_GROUP(const struct ofpact_group *group,\n             enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    put_OFPAT_GROUP(out, ofp_version, group->group_id);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_GROUP(char *arg, struct ofpbuf *ofpacts,\n                    enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_u32(arg, &ofpact_put_GROUP(ofpacts)->group_id);\n}\n\nstatic void\nformat_GROUP(const struct ofpact_group *a, struct ds *s)\n{\n    ds_put_format(s, \"%sgroup:%s%\"PRIu32,\n                  colors.special, colors.end, a->group_id);\n}\n\f\n/* Action structure for NXAST_CONTROLLER.\n *\n * This generalizes using OFPAT_OUTPUT to send a packet to OFPP_CONTROLLER.  In\n * addition to the 'max_len' that OFPAT_OUTPUT supports, it also allows\n * specifying:\n *\n *    - 'reason': The reason code to use in the ofp_packet_in or nx_packet_in.\n *\n *    - 'controller_id': The ID of the controller connection to which the\n *      ofp_packet_in should be sent.  The ofp_packet_in or nx_packet_in is\n *      sent only to controllers that have the specified controller connection\n *      ID.  See \"struct nx_controller_id\" for more information. */\nstruct nx_action_controller {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 16. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_CONTROLLER. */\n    ovs_be16 max_len;               /* Maximum length to send to controller. */\n    ovs_be16 controller_id;         /* Controller ID to send packet-in. */\n    uint8_t reason;                 /* enum ofp_packet_in_reason (OFPR_*). */\n    uint8_t zero;                   /* Must be zero. */\n};\nOFP_ASSERT(sizeof(struct nx_action_controller) == 16);\n\n/* Properties for NXAST_CONTROLLER2.\n *\n * For more information on the effect of NXAC2PT_PAUSE, see the large comment\n * on NXT_PACKET_IN2 in nicira-ext.h */\nenum nx_action_controller2_prop_type {\n    NXAC2PT_MAX_LEN,            /* ovs_be16 max bytes to send (default all). */\n    NXAC2PT_CONTROLLER_ID,      /* ovs_be16 dest controller ID (default 0). */\n    NXAC2PT_REASON,             /* uint8_t reason (OFPR_*), default 0. */\n    NXAC2PT_USERDATA,           /* Data to copy into NXPINT_USERDATA. */\n    NXAC2PT_PAUSE,              /* Flag to pause pipeline to resume later. */\n};\n\n/* The action structure for NXAST_CONTROLLER2 is \"struct ext_action_header\",\n * followed by NXAC2PT_* properties. */\n\nstatic enum ofperr\ndecode_NXAST_RAW_CONTROLLER(const struct nx_action_controller *nac,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    struct ofpact_controller *oc;\n\n    oc = ofpact_put_CONTROLLER(out);\n    oc->ofpact.raw = NXAST_RAW_CONTROLLER;\n    oc->max_len = ntohs(nac->max_len);\n    oc->controller_id = ntohs(nac->controller_id);\n    oc->reason = nac->reason;\n    ofpact_finish_CONTROLLER(out, &oc);\n\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_CONTROLLER2(const struct ext_action_header *eah,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             struct ofpbuf *out)\n{\n    if (!is_all_zeros(eah->pad, sizeof eah->pad)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    size_t start_ofs = out->size;\n    struct ofpact_controller *oc = ofpact_put_CONTROLLER(out);\n    oc->ofpact.raw = NXAST_RAW_CONTROLLER2;\n    oc->max_len = UINT16_MAX;\n    oc->reason = OFPR_ACTION;\n\n    struct ofpbuf properties;\n    ofpbuf_use_const(&properties, eah, ntohs(eah->len));\n    ofpbuf_pull(&properties, sizeof *eah);\n\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        uint64_t type;\n\n        enum ofperr error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch (type) {\n        case NXAC2PT_MAX_LEN:\n            error = ofpprop_parse_u16(&payload, &oc->max_len);\n            break;\n\n        case NXAC2PT_CONTROLLER_ID:\n            error = ofpprop_parse_u16(&payload, &oc->controller_id);\n            break;\n\n        case NXAC2PT_REASON: {\n            uint8_t u8;\n            error = ofpprop_parse_u8(&payload, &u8);\n            oc->reason = u8;\n            break;\n        }\n\n        case NXAC2PT_USERDATA:\n            out->size = start_ofs + OFPACT_CONTROLLER_SIZE;\n            ofpbuf_put(out, payload.msg, ofpbuf_msgsize(&payload));\n            oc = ofpbuf_at_assert(out, start_ofs, sizeof *oc);\n            oc->userdata_len = ofpbuf_msgsize(&payload);\n            break;\n\n        case NXAC2PT_PAUSE:\n            oc->pause = true;\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(false, \"NXAST_RAW_CONTROLLER2\", type);\n            break;\n        }\n        if (error) {\n            return error;\n        }\n    }\n\n    ofpact_finish_CONTROLLER(out, &oc);\n\n    return 0;\n}\n\nstatic void\nencode_CONTROLLER(const struct ofpact_controller *controller,\n                  enum ofp_version ofp_version OVS_UNUSED,\n                  struct ofpbuf *out)\n{\n    if (controller->userdata_len\n        || controller->pause\n        || controller->ofpact.raw == NXAST_RAW_CONTROLLER2) {\n        size_t start_ofs = out->size;\n        put_NXAST_CONTROLLER2(out);\n        if (controller->max_len != UINT16_MAX) {\n            ofpprop_put_u16(out, NXAC2PT_MAX_LEN, controller->max_len);\n        }\n        if (controller->controller_id != 0) {\n            ofpprop_put_u16(out, NXAC2PT_CONTROLLER_ID,\n                            controller->controller_id);\n        }\n        if (controller->reason != OFPR_ACTION) {\n            ofpprop_put_u8(out, NXAC2PT_REASON, controller->reason);\n        }\n        if (controller->userdata_len != 0) {\n            ofpprop_put(out, NXAC2PT_USERDATA, controller->userdata,\n                        controller->userdata_len);\n        }\n        if (controller->pause) {\n            ofpprop_put_flag(out, NXAC2PT_PAUSE);\n        }\n        pad_ofpat(out, start_ofs);\n    } else {\n        struct nx_action_controller *nac;\n\n        nac = put_NXAST_CONTROLLER(out);\n        nac->max_len = htons(controller->max_len);\n        nac->controller_id = htons(controller->controller_id);\n        nac->reason = controller->reason;\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_CONTROLLER(char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    enum ofp_packet_in_reason reason = OFPR_ACTION;\n    uint16_t controller_id = 0;\n    uint16_t max_len = UINT16_MAX;\n    const char *userdata = NULL;\n    bool pause = false;\n\n    if (!arg[0]) {\n        /* Use defaults. */\n    } else if (strspn(arg, \"0123456789\") == strlen(arg)) {\n        char *error = str_to_u16(arg, \"max_len\", &max_len);\n        if (error) {\n            return error;\n        }\n    } else {\n        char *name, *value;\n\n        while (ofputil_parse_key_value(&arg, &name, &value)) {\n            if (!strcmp(name, \"reason\")) {\n                if (!ofputil_packet_in_reason_from_string(value, &reason)) {\n                    return xasprintf(\"unknown reason \\\"%s\\\"\", value);\n                }\n            } else if (!strcmp(name, \"max_len\")) {\n                char *error = str_to_u16(value, \"max_len\", &max_len);\n                if (error) {\n                    return error;\n                }\n            } else if (!strcmp(name, \"id\")) {\n                char *error = str_to_u16(value, \"id\", &controller_id);\n                if (error) {\n                    return error;\n                }\n            } else if (!strcmp(name, \"userdata\")) {\n                userdata = value;\n            } else if (!strcmp(name, \"pause\")) {\n                pause = true;\n            } else {\n                return xasprintf(\"unknown key \\\"%s\\\" parsing controller \"\n                                 \"action\", name);\n            }\n        }\n    }\n\n    if (reason == OFPR_ACTION && controller_id == 0 && !userdata && !pause) {\n        struct ofpact_output *output;\n\n        output = ofpact_put_OUTPUT(ofpacts);\n        output->port = OFPP_CONTROLLER;\n        output->max_len = max_len;\n    } else {\n        struct ofpact_controller *controller;\n\n        controller = ofpact_put_CONTROLLER(ofpacts);\n        controller->max_len = max_len;\n        controller->reason = reason;\n        controller->controller_id = controller_id;\n        controller->pause = pause;\n\n        if (userdata) {\n            size_t start_ofs = ofpacts->size;\n            const char *end = ofpbuf_put_hex(ofpacts, userdata, NULL);\n            if (*end) {\n                return xstrdup(\"bad hex digit in `controller' \"\n                               \"action `userdata'\");\n            }\n            size_t userdata_len = ofpacts->size - start_ofs;\n            controller = ofpacts->header;\n            controller->userdata_len = userdata_len;\n        }\n        ofpact_finish_CONTROLLER(ofpacts, &controller);\n    }\n\n    return NULL;\n}\n\nstatic void\nformat_hex_arg(struct ds *s, const uint8_t *data, size_t len)\n{\n    for (size_t i = 0; i < len; i++) {\n        if (i) {\n            ds_put_char(s, '.');\n        }\n        ds_put_format(s, \"%02\"PRIx8, data[i]);\n    }\n}\n\nstatic void\nformat_CONTROLLER(const struct ofpact_controller *a, struct ds *s)\n{\n    if (a->reason == OFPR_ACTION && !a->controller_id && !a->userdata_len\n        && !a->pause) {\n        ds_put_format(s, \"%sCONTROLLER:%s%\"PRIu16,\n                      colors.special, colors.end, a->max_len);\n    } else {\n        enum ofp_packet_in_reason reason = a->reason;\n\n        ds_put_format(s, \"%scontroller(%s\", colors.paren, colors.end);\n        if (reason != OFPR_ACTION) {\n            char reasonbuf[OFPUTIL_PACKET_IN_REASON_BUFSIZE];\n\n            ds_put_format(s, \"%sreason=%s%s,\", colors.param, colors.end,\n                          ofputil_packet_in_reason_to_string(\n                              reason, reasonbuf, sizeof reasonbuf));\n        }\n        if (a->max_len != UINT16_MAX) {\n            ds_put_format(s, \"%smax_len=%s%\"PRIu16\",\",\n                          colors.param, colors.end, a->max_len);\n        }\n        if (a->controller_id != 0) {\n            ds_put_format(s, \"%sid=%s%\"PRIu16\",\",\n                          colors.param, colors.end, a->controller_id);\n        }\n        if (a->userdata_len) {\n            ds_put_format(s, \"%suserdata=%s\", colors.param, colors.end);\n            format_hex_arg(s, a->userdata, a->userdata_len);\n            ds_put_char(s, ',');\n        }\n        if (a->pause) {\n            ds_put_format(s, \"%spause%s,\", colors.value, colors.end);\n        }\n        ds_chomp(s, ',');\n        ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n    }\n}\n\f\n/* Enqueue action. */\nstruct ofp10_action_enqueue {\n    ovs_be16 type;            /* OFPAT10_ENQUEUE. */\n    ovs_be16 len;             /* Len is 16. */\n    ovs_be16 port;            /* Port that queue belongs. Should\n                                 refer to a valid physical port\n                                 (i.e. < OFPP_MAX) or OFPP_IN_PORT. */\n    uint8_t pad[6];           /* Pad for 64-bit alignment. */\n    ovs_be32 queue_id;        /* Where to enqueue the packets. */\n};\nOFP_ASSERT(sizeof(struct ofp10_action_enqueue) == 16);\n\nstatic enum ofperr\ndecode_OFPAT_RAW10_ENQUEUE(const struct ofp10_action_enqueue *oae,\n                           enum ofp_version ofp_version OVS_UNUSED,\n                           struct ofpbuf *out)\n{\n    struct ofpact_enqueue *enqueue;\n\n    enqueue = ofpact_put_ENQUEUE(out);\n    enqueue->port = u16_to_ofp(ntohs(oae->port));\n    enqueue->queue = ntohl(oae->queue_id);\n    if (ofp_to_u16(enqueue->port) >= ofp_to_u16(OFPP_MAX)\n        && enqueue->port != OFPP_IN_PORT\n        && enqueue->port != OFPP_LOCAL) {\n        return OFPERR_OFPBAC_BAD_OUT_PORT;\n    }\n    return 0;\n}\n\nstatic void\nencode_ENQUEUE(const struct ofpact_enqueue *enqueue,\n               enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version == OFP10_VERSION) {\n        struct ofp10_action_enqueue *oae;\n\n        oae = put_OFPAT10_ENQUEUE(out);\n        oae->port = htons(ofp_to_u16(enqueue->port));\n        oae->queue_id = htonl(enqueue->queue);\n    } else {\n        put_OFPAT_SET_QUEUE(out, ofp_version, enqueue->queue);\n\n        struct ofp11_action_output *oao = put_OFPAT11_OUTPUT(out);\n        oao->port = ofputil_port_to_ofp11(enqueue->port);\n        oao->max_len = OVS_BE16_MAX;\n\n        put_NXAST_POP_QUEUE(out);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_ENQUEUE(char *arg, struct ofpbuf *ofpacts,\n              enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    char *sp = NULL;\n    char *port = strtok_r(arg, \":q,\", &sp);\n    char *queue = strtok_r(NULL, \"\", &sp);\n    struct ofpact_enqueue *enqueue;\n\n    if (port == NULL || queue == NULL) {\n        return xstrdup(\"\\\"enqueue\\\" syntax is \\\"enqueue:PORT:QUEUE\\\" or \"\n                       \"\\\"enqueue(PORT,QUEUE)\\\"\");\n    }\n\n    enqueue = ofpact_put_ENQUEUE(ofpacts);\n    if (!ofputil_port_from_string(port, &enqueue->port)) {\n        return xasprintf(\"%s: enqueue to unknown port\", port);\n    }\n    return str_to_u32(queue, &enqueue->queue);\n}\n\nstatic void\nformat_ENQUEUE(const struct ofpact_enqueue *a, struct ds *s)\n{\n    ds_put_format(s, \"%senqueue:%s\", colors.param, colors.end);\n    ofputil_format_port(a->port, s);\n    ds_put_format(s, \":%\"PRIu32, a->queue);\n}\n\f\n/* Action structure for NXAST_OUTPUT_REG.\n *\n * Outputs to the OpenFlow port number written to src[ofs:ofs+nbits].\n *\n * The format and semantics of 'src' and 'ofs_nbits' are similar to those for\n * the NXAST_REG_LOAD action.\n *\n * The acceptable nxm_header values for 'src' are the same as the acceptable\n * nxm_header values for the 'src' field of NXAST_REG_MOVE.\n *\n * The 'max_len' field indicates the number of bytes to send when the chosen\n * port is OFPP_CONTROLLER.  Its semantics are equivalent to the 'max_len'\n * field of OFPAT_OUTPUT.\n *\n * The 'zero' field is required to be zeroed for forward compatibility. */\nstruct nx_action_output_reg {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* 24. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_OUTPUT_REG. */\n\n    ovs_be16 ofs_nbits;         /* (ofs << 6) | (n_bits - 1). */\n    ovs_be32 src;               /* Source. */\n\n    ovs_be16 max_len;           /* Max length to send to controller. */\n\n    uint8_t zero[6];            /* Reserved, must be zero. */\n};\nOFP_ASSERT(sizeof(struct nx_action_output_reg) == 24);\n\n/* Action structure for NXAST_OUTPUT_REG2.\n *\n * Like the NXAST_OUTPUT_REG but organized so that there is room for a 64-bit\n * experimenter OXM as 'src'.\n */\nstruct nx_action_output_reg2 {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* 24. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_OUTPUT_REG2. */\n\n    ovs_be16 ofs_nbits;         /* (ofs << 6) | (n_bits - 1). */\n    ovs_be16 max_len;           /* Max length to send to controller. */\n\n    /* Followed by:\n     * - 'src', as an OXM/NXM header (either 4 or 8 bytes).\n     * - Enough 0-bytes to pad the action out to 24 bytes. */\n    uint8_t pad[10];\n};\nOFP_ASSERT(sizeof(struct nx_action_output_reg2) == 24);\n\nstatic enum ofperr\ndecode_NXAST_RAW_OUTPUT_REG(const struct nx_action_output_reg *naor,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            const struct vl_mff_map *vl_mff_map,\n                            uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    struct ofpact_output_reg *output_reg;\n    enum ofperr error;\n\n    if (!is_all_zeros(naor->zero, sizeof naor->zero)) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    output_reg = ofpact_put_OUTPUT_REG(out);\n    output_reg->ofpact.raw = NXAST_RAW_OUTPUT_REG;\n    output_reg->src.ofs = nxm_decode_ofs(naor->ofs_nbits);\n    output_reg->src.n_bits = nxm_decode_n_bits(naor->ofs_nbits);\n    output_reg->max_len = ntohs(naor->max_len);\n    error = mf_vl_mff_mf_from_nxm_header(ntohl(naor->src), vl_mff_map,\n                                         &output_reg->src.field, tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    return mf_check_src(&output_reg->src, NULL);\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_OUTPUT_REG2(const struct nx_action_output_reg2 *naor,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             const struct vl_mff_map *vl_mff_map,\n                             uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    struct ofpact_output_reg *output_reg;\n    enum ofperr error;\n\n    output_reg = ofpact_put_OUTPUT_REG(out);\n    output_reg->ofpact.raw = NXAST_RAW_OUTPUT_REG2;\n    output_reg->src.ofs = nxm_decode_ofs(naor->ofs_nbits);\n    output_reg->src.n_bits = nxm_decode_n_bits(naor->ofs_nbits);\n    output_reg->max_len = ntohs(naor->max_len);\n\n    struct ofpbuf b = ofpbuf_const_initializer(naor, ntohs(naor->len));\n    ofpbuf_pull(&b, OBJECT_OFFSETOF(naor, pad));\n\n    error = mf_vl_mff_nx_pull_header(&b, vl_mff_map, &output_reg->src.field,\n                                     NULL, tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    if (!is_all_zeros(b.data, b.size)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    return mf_check_src(&output_reg->src, NULL);\n}\n\nstatic void\nencode_OUTPUT_REG(const struct ofpact_output_reg *output_reg,\n                  enum ofp_version ofp_version OVS_UNUSED,\n                  struct ofpbuf *out)\n{\n    /* If 'output_reg' came in as an NXAST_RAW_OUTPUT_REG2 action, or if it\n     * cannot be encoded in the older form, encode it as\n     * NXAST_RAW_OUTPUT_REG2. */\n    if (output_reg->ofpact.raw == NXAST_RAW_OUTPUT_REG2\n        || !mf_nxm_header(output_reg->src.field->id)) {\n        struct nx_action_output_reg2 *naor = put_NXAST_OUTPUT_REG2(out);\n        size_t size = out->size;\n\n        naor->ofs_nbits = nxm_encode_ofs_nbits(output_reg->src.ofs,\n                                               output_reg->src.n_bits);\n        naor->max_len = htons(output_reg->max_len);\n\n        out->size = size - sizeof naor->pad;\n        nx_put_mff_header(out, output_reg->src.field, 0, false);\n        out->size = size;\n    } else {\n        struct nx_action_output_reg *naor = put_NXAST_OUTPUT_REG(out);\n\n        naor->ofs_nbits = nxm_encode_ofs_nbits(output_reg->src.ofs,\n                                               output_reg->src.n_bits);\n        naor->src = htonl(nxm_header_from_mff(output_reg->src.field));\n        naor->max_len = htons(output_reg->max_len);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_OUTPUT_REG(const char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return parse_OUTPUT(arg, ofpacts, usable_protocols);\n}\n\nstatic void\nformat_OUTPUT_REG(const struct ofpact_output_reg *a, struct ds *s)\n{\n    ds_put_format(s, \"%soutput:%s\", colors.special, colors.end);\n    mf_format_subfield(&a->src, s);\n}\n\f\n/* Action structure for NXAST_BUNDLE and NXAST_BUNDLE_LOAD.\n *\n * The bundle actions choose a slave from a supplied list of options.\n * NXAST_BUNDLE outputs to its selection.  NXAST_BUNDLE_LOAD writes its\n * selection to a register.\n *\n * The list of possible slaves follows the nx_action_bundle structure. The size\n * of each slave is governed by its type as indicated by the 'slave_type'\n * parameter. The list of slaves should be padded at its end with zeros to make\n * the total length of the action a multiple of 8.\n *\n * Switches infer from the 'slave_type' parameter the size of each slave.  All\n * implementations must support the NXM_OF_IN_PORT 'slave_type' which indicates\n * that the slaves are OpenFlow port numbers with NXM_LENGTH(NXM_OF_IN_PORT) ==\n * 2 byte width.  Switches should reject actions which indicate unknown or\n * unsupported slave types.\n *\n * Switches use a strategy dictated by the 'algorithm' parameter to choose a\n * slave.  If the switch does not support the specified 'algorithm' parameter,\n * it should reject the action.\n *\n * Several algorithms take into account liveness when selecting slaves.  The\n * liveness of a slave is implementation defined (with one exception), but will\n * generally take into account things like its carrier status and the results\n * of any link monitoring protocols which happen to be running on it.  In order\n * to give controllers a place-holder value, the OFPP_NONE port is always\n * considered live, that is, NXAST_BUNDLE_LOAD stores OFPP_NONE in the output\n * register if no slave is live.\n *\n * Some slave selection strategies require the use of a hash function, in which\n * case the 'fields' and 'basis' parameters should be populated.  The 'fields'\n * parameter (one of NX_HASH_FIELDS_*) designates which parts of the flow to\n * hash.  Refer to the definition of \"enum nx_hash_fields\" for details.  The\n * 'basis' parameter is used as a universal hash parameter.  Different values\n * of 'basis' yield different hash results.\n *\n * The 'zero' parameter at the end of the action structure is reserved for\n * future use.  Switches are required to reject actions which have nonzero\n * bytes in the 'zero' field.\n *\n * NXAST_BUNDLE actions should have 'ofs_nbits' and 'dst' zeroed.  Switches\n * should reject actions which have nonzero bytes in either of these fields.\n *\n * NXAST_BUNDLE_LOAD stores the OpenFlow port number of the selected slave in\n * dst[ofs:ofs+n_bits].  The format and semantics of 'dst' and 'ofs_nbits' are\n * similar to those for the NXAST_REG_LOAD action. */\nstruct nx_action_bundle {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* Length including slaves. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_BUNDLE or NXAST_BUNDLE_LOAD. */\n\n    /* Slave choice algorithm to apply to hash value. */\n    ovs_be16 algorithm;         /* One of NX_BD_ALG_*. */\n\n    /* What fields to hash and how. */\n    ovs_be16 fields;            /* One of NX_HASH_FIELDS_*. */\n    ovs_be16 basis;             /* Universal hash parameter. */\n\n    ovs_be32 slave_type;        /* NXM_OF_IN_PORT. */\n    ovs_be16 n_slaves;          /* Number of slaves. */\n\n    ovs_be16 ofs_nbits;         /* (ofs << 6) | (n_bits - 1). */\n    ovs_be32 dst;               /* Destination. */\n\n    uint8_t zero[4];            /* Reserved. Must be zero. */\n};\nOFP_ASSERT(sizeof(struct nx_action_bundle) == 32);\n\nstatic enum ofperr\ndecode_bundle(bool load, const struct nx_action_bundle *nab,\n              const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap,\n              struct ofpbuf *ofpacts)\n{\n    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n    struct ofpact_bundle *bundle;\n    uint32_t slave_type;\n    size_t slaves_size, i;\n    enum ofperr error;\n\n    bundle = ofpact_put_BUNDLE(ofpacts);\n\n    bundle->n_slaves = ntohs(nab->n_slaves);\n    bundle->basis = ntohs(nab->basis);\n    bundle->fields = ntohs(nab->fields);\n    bundle->algorithm = ntohs(nab->algorithm);\n    slave_type = ntohl(nab->slave_type);\n    slaves_size = ntohs(nab->len) - sizeof *nab;\n\n    error = OFPERR_OFPBAC_BAD_ARGUMENT;\n    if (!flow_hash_fields_valid(bundle->fields)) {\n        VLOG_WARN_RL(&rl, \"unsupported fields %d\", (int) bundle->fields);\n    } else if (bundle->n_slaves > BUNDLE_MAX_SLAVES) {\n        VLOG_WARN_RL(&rl, \"too many slaves\");\n    } else if (bundle->algorithm != NX_BD_ALG_HRW\n               && bundle->algorithm != NX_BD_ALG_ACTIVE_BACKUP) {\n        VLOG_WARN_RL(&rl, \"unsupported algorithm %d\", (int) bundle->algorithm);\n    } else if (slave_type != mf_nxm_header(MFF_IN_PORT)) {\n        VLOG_WARN_RL(&rl, \"unsupported slave type %\"PRIu16, slave_type);\n    } else {\n        error = 0;\n    }\n\n    if (!is_all_zeros(nab->zero, sizeof nab->zero)) {\n        VLOG_WARN_RL(&rl, \"reserved field is nonzero\");\n        error = OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    if (load) {\n        bundle->dst.ofs = nxm_decode_ofs(nab->ofs_nbits);\n        bundle->dst.n_bits = nxm_decode_n_bits(nab->ofs_nbits);\n        error = mf_vl_mff_mf_from_nxm_header(ntohl(nab->dst), vl_mff_map,\n                                             &bundle->dst.field, tlv_bitmap);\n        if (error) {\n            return error;\n        }\n\n        if (bundle->dst.n_bits < 16) {\n            VLOG_WARN_RL(&rl, \"bundle_load action requires at least 16 bit \"\n                         \"destination.\");\n            error = OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n    } else {\n        if (nab->ofs_nbits || nab->dst) {\n            VLOG_WARN_RL(&rl, \"bundle action has nonzero reserved fields\");\n            error = OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n    }\n\n    if (slaves_size < bundle->n_slaves * sizeof(ovs_be16)) {\n        VLOG_WARN_RL(&rl, \"Nicira action %s only has %\"PRIuSIZE\" bytes \"\n                     \"allocated for slaves.  %\"PRIuSIZE\" bytes are required \"\n                     \"for %\"PRIu16\" slaves.\",\n                     load ? \"bundle_load\" : \"bundle\", slaves_size,\n                     bundle->n_slaves * sizeof(ovs_be16), bundle->n_slaves);\n        error = OFPERR_OFPBAC_BAD_LEN;\n    } else {\n        for (i = 0; i < bundle->n_slaves; i++) {\n            ofp_port_t ofp_port\n                = u16_to_ofp(ntohs(((ovs_be16 *)(nab + 1))[i]));\n            ofpbuf_put(ofpacts, &ofp_port, sizeof ofp_port);\n            bundle = ofpacts->header;\n        }\n    }\n\n    ofpact_finish_BUNDLE(ofpacts, &bundle);\n    if (!error) {\n        error = bundle_check(bundle, OFPP_MAX, NULL);\n    }\n    return error;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_BUNDLE(const struct nx_action_bundle *nab,\n                        enum ofp_version ofp_version OVS_UNUSED,\n                        struct ofpbuf *out)\n{\n    return decode_bundle(false, nab, NULL, NULL, out);\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_BUNDLE_LOAD(const struct nx_action_bundle *nab,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             const struct vl_mff_map *vl_mff_map,\n                             uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    return decode_bundle(true, nab, vl_mff_map, tlv_bitmap, out);\n}\n\nstatic void\nencode_BUNDLE(const struct ofpact_bundle *bundle,\n              enum ofp_version ofp_version OVS_UNUSED,\n              struct ofpbuf *out)\n{\n    int slaves_len = ROUND_UP(2 * bundle->n_slaves, OFP_ACTION_ALIGN);\n    struct nx_action_bundle *nab;\n    ovs_be16 *slaves;\n    size_t i;\n\n    nab = (bundle->dst.field\n           ? put_NXAST_BUNDLE_LOAD(out)\n           : put_NXAST_BUNDLE(out));\n    nab->len = htons(ntohs(nab->len) + slaves_len);\n    nab->algorithm = htons(bundle->algorithm);\n    nab->fields = htons(bundle->fields);\n    nab->basis = htons(bundle->basis);\n    nab->slave_type = htonl(mf_nxm_header(MFF_IN_PORT));\n    nab->n_slaves = htons(bundle->n_slaves);\n    if (bundle->dst.field) {\n        nab->ofs_nbits = nxm_encode_ofs_nbits(bundle->dst.ofs,\n                                              bundle->dst.n_bits);\n        nab->dst = htonl(nxm_header_from_mff(bundle->dst.field));\n    }\n\n    slaves = ofpbuf_put_zeros(out, slaves_len);\n    for (i = 0; i < bundle->n_slaves; i++) {\n        slaves[i] = htons(ofp_to_u16(bundle->slaves[i]));\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_BUNDLE(const char *arg, struct ofpbuf *ofpacts,\n             enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return bundle_parse(arg, ofpacts);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_bundle_load(const char *arg, struct ofpbuf *ofpacts)\n{\n    return bundle_parse_load(arg, ofpacts);\n}\n\nstatic void\nformat_BUNDLE(const struct ofpact_bundle *a, struct ds *s)\n{\n    bundle_format(a, s);\n}\n\f\n/* Set VLAN actions. */\n\nstatic enum ofperr\ndecode_set_vlan_vid(uint16_t vid, bool push_vlan_if_needed, struct ofpbuf *out)\n{\n    if (vid & ~0xfff) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else {\n        struct ofpact_vlan_vid *vlan_vid = ofpact_put_SET_VLAN_VID(out);\n        vlan_vid->vlan_vid = vid;\n        vlan_vid->push_vlan_if_needed = push_vlan_if_needed;\n        return 0;\n    }\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW10_SET_VLAN_VID(uint16_t vid,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    return decode_set_vlan_vid(vid, true, out);\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_SET_VLAN_VID(uint16_t vid,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    return decode_set_vlan_vid(vid, false, out);\n}\n\nstatic void\nencode_SET_VLAN_VID(const struct ofpact_vlan_vid *vlan_vid,\n                    enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    uint16_t vid = vlan_vid->vlan_vid;\n\n    /* Push a VLAN tag, if none is present and this form of the action calls\n     * for such a feature. */\n    if (ofp_version > OFP10_VERSION\n        && vlan_vid->push_vlan_if_needed\n        && !vlan_vid->flow_has_vlan) {\n        put_OFPAT11_PUSH_VLAN(out, htons(ETH_TYPE_VLAN_8021Q));\n    }\n\n    if (ofp_version == OFP10_VERSION) {\n        put_OFPAT10_SET_VLAN_VID(out, vid);\n    } else if (ofp_version == OFP11_VERSION) {\n        put_OFPAT11_SET_VLAN_VID(out, vid);\n    } else {\n        put_set_field(out, ofp_version, MFF_VLAN_VID, vid | OFPVID12_PRESENT);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_set_vlan_vid(char *arg, struct ofpbuf *ofpacts, bool push_vlan_if_needed)\n{\n    struct ofpact_vlan_vid *vlan_vid;\n    uint16_t vid;\n    char *error;\n\n    error = str_to_u16(arg, \"VLAN VID\", &vid);\n    if (error) {\n        return error;\n    }\n\n    if (vid & ~VLAN_VID_MASK) {\n        return xasprintf(\"%s: not a valid VLAN VID\", arg);\n    }\n    vlan_vid = ofpact_put_SET_VLAN_VID(ofpacts);\n    vlan_vid->vlan_vid = vid;\n    vlan_vid->push_vlan_if_needed = push_vlan_if_needed;\n    return NULL;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_VLAN_VID(char *arg, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return parse_set_vlan_vid(arg, ofpacts, false);\n}\n\nstatic void\nformat_SET_VLAN_VID(const struct ofpact_vlan_vid *a, struct ds *s)\n{\n    ds_put_format(s, \"%s%s:%s%\"PRIu16, colors.param,\n                  a->push_vlan_if_needed ? \"mod_vlan_vid\" : \"set_vlan_vid\",\n                  colors.end, a->vlan_vid);\n}\n\f\n/* Set PCP actions. */\n\nstatic enum ofperr\ndecode_set_vlan_pcp(uint8_t pcp, bool push_vlan_if_needed, struct ofpbuf *out)\n{\n    if (pcp & ~7) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else {\n        struct ofpact_vlan_pcp *vlan_pcp = ofpact_put_SET_VLAN_PCP(out);\n        vlan_pcp->vlan_pcp = pcp;\n        vlan_pcp->push_vlan_if_needed = push_vlan_if_needed;\n        return 0;\n    }\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW10_SET_VLAN_PCP(uint8_t pcp,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    return decode_set_vlan_pcp(pcp, true, out);\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_SET_VLAN_PCP(uint8_t pcp,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    return decode_set_vlan_pcp(pcp, false, out);\n}\n\nstatic void\nencode_SET_VLAN_PCP(const struct ofpact_vlan_pcp *vlan_pcp,\n                    enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    uint8_t pcp = vlan_pcp->vlan_pcp;\n\n    /* Push a VLAN tag, if none is present and this form of the action calls\n     * for such a feature. */\n    if (ofp_version > OFP10_VERSION\n        && vlan_pcp->push_vlan_if_needed\n        && !vlan_pcp->flow_has_vlan) {\n        put_OFPAT11_PUSH_VLAN(out, htons(ETH_TYPE_VLAN_8021Q));\n    }\n\n    if (ofp_version == OFP10_VERSION) {\n        put_OFPAT10_SET_VLAN_PCP(out, pcp);\n    } else if (ofp_version == OFP11_VERSION) {\n        put_OFPAT11_SET_VLAN_PCP(out, pcp);\n    } else {\n        put_set_field(out, ofp_version, MFF_VLAN_PCP, pcp);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_set_vlan_pcp(char *arg, struct ofpbuf *ofpacts, bool push_vlan_if_needed)\n{\n    struct ofpact_vlan_pcp *vlan_pcp;\n    uint8_t pcp;\n    char *error;\n\n    error = str_to_u8(arg, \"VLAN PCP\", &pcp);\n    if (error) {\n        return error;\n    }\n\n    if (pcp & ~7) {\n        return xasprintf(\"%s: not a valid VLAN PCP\", arg);\n    }\n    vlan_pcp = ofpact_put_SET_VLAN_PCP(ofpacts);\n    vlan_pcp->vlan_pcp = pcp;\n    vlan_pcp->push_vlan_if_needed = push_vlan_if_needed;\n    return NULL;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_VLAN_PCP(char *arg, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return parse_set_vlan_pcp(arg, ofpacts, false);\n}\n\nstatic void\nformat_SET_VLAN_PCP(const struct ofpact_vlan_pcp *a, struct ds *s)\n{\n    ds_put_format(s, \"%s%s:%s%\"PRIu8, colors.param,\n                  a->push_vlan_if_needed ? \"mod_vlan_pcp\" : \"set_vlan_pcp\",\n                  colors.end, a->vlan_pcp);\n}\n\f\n/* Strip VLAN actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW10_STRIP_VLAN(struct ofpbuf *out)\n{\n    ofpact_put_STRIP_VLAN(out)->ofpact.raw = OFPAT_RAW10_STRIP_VLAN;\n    return 0;\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_POP_VLAN(struct ofpbuf *out)\n{\n    ofpact_put_STRIP_VLAN(out)->ofpact.raw = OFPAT_RAW11_POP_VLAN;\n    return 0;\n}\n\nstatic void\nencode_STRIP_VLAN(const struct ofpact_null *null OVS_UNUSED,\n                  enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version == OFP10_VERSION) {\n        put_OFPAT10_STRIP_VLAN(out);\n    } else {\n        put_OFPAT11_POP_VLAN(out);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_STRIP_VLAN(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_STRIP_VLAN(ofpacts)->ofpact.raw = OFPAT_RAW10_STRIP_VLAN;\n    return NULL;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_pop_vlan(struct ofpbuf *ofpacts)\n{\n    ofpact_put_STRIP_VLAN(ofpacts)->ofpact.raw = OFPAT_RAW11_POP_VLAN;\n    return NULL;\n}\n\nstatic void\nformat_STRIP_VLAN(const struct ofpact_null *a, struct ds *s)\n{\n    ds_put_format(s, (a->ofpact.raw == OFPAT_RAW11_POP_VLAN\n                    ? \"%spop_vlan%s\"\n                    : \"%sstrip_vlan%s\"),\n                  colors.value, colors.end);\n}\n\f\n/* Push VLAN action. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_PUSH_VLAN(ovs_be16 eth_type,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             struct ofpbuf *out)\n{\n    if (eth_type != htons(ETH_TYPE_VLAN_8021Q)) {\n        /* XXX 802.1AD(QinQ) isn't supported at the moment */\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n    ofpact_put_PUSH_VLAN(out);\n    return 0;\n}\n\nstatic void\nencode_PUSH_VLAN(const struct ofpact_null *null OVS_UNUSED,\n                 enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version == OFP10_VERSION) {\n        /* PUSH is a side effect of a SET_VLAN_VID/PCP, which should\n         * follow this action. */\n    } else {\n        /* XXX ETH_TYPE_VLAN_8021AD case */\n        put_OFPAT11_PUSH_VLAN(out, htons(ETH_TYPE_VLAN_8021Q));\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_PUSH_VLAN(char *arg, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint16_t ethertype;\n    char *error;\n\n    *usable_protocols &= OFPUTIL_P_OF11_UP;\n    error = str_to_u16(arg, \"ethertype\", &ethertype);\n    if (error) {\n        return error;\n    }\n\n    if (ethertype != ETH_TYPE_VLAN_8021Q) {\n        /* XXX ETH_TYPE_VLAN_8021AD case isn't supported */\n        return xasprintf(\"%s: not a valid VLAN ethertype\", arg);\n    }\n\n    ofpact_put_PUSH_VLAN(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_PUSH_VLAN(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    /* XXX 802.1AD case*/\n    ds_put_format(s, \"%spush_vlan:%s%#\"PRIx16,\n                  colors.param, colors.end, ETH_TYPE_VLAN_8021Q);\n}\n\f\n/* Action structure for OFPAT10_SET_DL_SRC/DST and OFPAT11_SET_DL_SRC/DST. */\nstruct ofp_action_dl_addr {\n    ovs_be16 type;                  /* Type. */\n    ovs_be16 len;                   /* Length is 16. */\n    struct eth_addr dl_addr;        /* Ethernet address. */\n    uint8_t pad[6];\n};\nOFP_ASSERT(sizeof(struct ofp_action_dl_addr) == 16);\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_DL_SRC(const struct ofp_action_dl_addr *a,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    ofpact_put_SET_ETH_SRC(out)->mac = a->dl_addr;\n    return 0;\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_DL_DST(const struct ofp_action_dl_addr *a,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    ofpact_put_SET_ETH_DST(out)->mac = a->dl_addr;\n    return 0;\n}\n\nstatic void\nencode_SET_ETH_addr(const struct ofpact_mac *mac, enum ofp_version ofp_version,\n                    enum ofp_raw_action_type raw, enum mf_field_id field,\n                    struct ofpbuf *out)\n{\n    if (ofp_version < OFP12_VERSION) {\n        struct ofp_action_dl_addr *oada;\n\n        oada = ofpact_put_raw(out, ofp_version, raw, 0);\n        oada->dl_addr = mac->mac;\n    } else {\n        put_set_field(out, ofp_version, field, eth_addr_to_uint64(mac->mac));\n    }\n}\n\nstatic void\nencode_SET_ETH_SRC(const struct ofpact_mac *mac, enum ofp_version ofp_version,\n                   struct ofpbuf *out)\n{\n    encode_SET_ETH_addr(mac, ofp_version, OFPAT_RAW_SET_DL_SRC, MFF_ETH_SRC,\n                        out);\n\n}\n\nstatic void\nencode_SET_ETH_DST(const struct ofpact_mac *mac,\n                               enum ofp_version ofp_version,\n                               struct ofpbuf *out)\n{\n    encode_SET_ETH_addr(mac, ofp_version, OFPAT_RAW_SET_DL_DST, MFF_ETH_DST,\n                        out);\n\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_ETH_SRC(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_mac(arg, &ofpact_put_SET_ETH_SRC(ofpacts)->mac);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_ETH_DST(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_mac(arg, &ofpact_put_SET_ETH_DST(ofpacts)->mac);\n}\n\nstatic void\nformat_SET_ETH_SRC(const struct ofpact_mac *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_dl_src:%s\"ETH_ADDR_FMT,\n                  colors.param, colors.end, ETH_ADDR_ARGS(a->mac));\n}\n\nstatic void\nformat_SET_ETH_DST(const struct ofpact_mac *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_dl_dst:%s\"ETH_ADDR_FMT,\n                  colors.param, colors.end, ETH_ADDR_ARGS(a->mac));\n}\n\f\n/* Set IPv4 address actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_NW_SRC(ovs_be32 ipv4,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    ofpact_put_SET_IPV4_SRC(out)->ipv4 = ipv4;\n    return 0;\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_NW_DST(ovs_be32 ipv4,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    ofpact_put_SET_IPV4_DST(out)->ipv4 = ipv4;\n    return 0;\n}\n\nstatic void\nencode_SET_IPV4_addr(const struct ofpact_ipv4 *ipv4,\n                     enum ofp_version ofp_version,\n                     enum ofp_raw_action_type raw, enum mf_field_id field,\n                     struct ofpbuf *out)\n{\n    ovs_be32 addr = ipv4->ipv4;\n    if (ofp_version < OFP12_VERSION) {\n        ofpact_put_raw(out, ofp_version, raw, ntohl(addr));\n    } else {\n        put_set_field(out, ofp_version, field, ntohl(addr));\n    }\n}\n\nstatic void\nencode_SET_IPV4_SRC(const struct ofpact_ipv4 *ipv4,\n                    enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    encode_SET_IPV4_addr(ipv4, ofp_version, OFPAT_RAW_SET_NW_SRC, MFF_IPV4_SRC,\n                         out);\n}\n\nstatic void\nencode_SET_IPV4_DST(const struct ofpact_ipv4 *ipv4,\n                    enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    encode_SET_IPV4_addr(ipv4, ofp_version, OFPAT_RAW_SET_NW_DST, MFF_IPV4_DST,\n                         out);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_IPV4_SRC(char *arg, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_ip(arg, &ofpact_put_SET_IPV4_SRC(ofpacts)->ipv4);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_IPV4_DST(char *arg, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_ip(arg, &ofpact_put_SET_IPV4_DST(ofpacts)->ipv4);\n}\n\nstatic void\nformat_SET_IPV4_SRC(const struct ofpact_ipv4 *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_nw_src:%s\"IP_FMT,\n                  colors.param, colors.end, IP_ARGS(a->ipv4));\n}\n\nstatic void\nformat_SET_IPV4_DST(const struct ofpact_ipv4 *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_nw_dst:%s\"IP_FMT,\n                  colors.param, colors.end, IP_ARGS(a->ipv4));\n}\n\f\n/* Set IPv4/v6 TOS actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_NW_TOS(uint8_t dscp,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    if (dscp & ~IP_DSCP_MASK) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else {\n        ofpact_put_SET_IP_DSCP(out)->dscp = dscp;\n        return 0;\n    }\n}\n\nstatic void\nencode_SET_IP_DSCP(const struct ofpact_dscp *dscp,\n                   enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version < OFP12_VERSION) {\n        put_OFPAT_SET_NW_TOS(out, ofp_version, dscp->dscp);\n    } else {\n        put_set_field(out, ofp_version, MFF_IP_DSCP_SHIFTED, dscp->dscp >> 2);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_IP_DSCP(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint8_t tos;\n    char *error;\n\n    error = str_to_u8(arg, \"TOS\", &tos);\n    if (error) {\n        return error;\n    }\n\n    if (tos & ~IP_DSCP_MASK) {\n        return xasprintf(\"%s: not a valid TOS\", arg);\n    }\n    ofpact_put_SET_IP_DSCP(ofpacts)->dscp = tos;\n    return NULL;\n}\n\nstatic void\nformat_SET_IP_DSCP(const struct ofpact_dscp *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_nw_tos:%s%d\", colors.param, colors.end, a->dscp);\n}\n\f\n/* Set IPv4/v6 ECN actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_SET_NW_ECN(uint8_t ecn,\n                              enum ofp_version ofp_version OVS_UNUSED,\n                              struct ofpbuf *out)\n{\n    if (ecn & ~IP_ECN_MASK) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else {\n        ofpact_put_SET_IP_ECN(out)->ecn = ecn;\n        return 0;\n    }\n}\n\nstatic void\nencode_SET_IP_ECN(const struct ofpact_ecn *ip_ecn,\n                  enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    uint8_t ecn = ip_ecn->ecn;\n    if (ofp_version == OFP10_VERSION) {\n        struct mf_subfield dst = { .field = mf_from_id(MFF_IP_ECN),\n                                   .ofs = 0, .n_bits = 2 };\n        put_reg_load(out, &dst, ecn);\n    } else if (ofp_version == OFP11_VERSION) {\n        put_OFPAT11_SET_NW_ECN(out, ecn);\n    } else {\n        put_set_field(out, ofp_version, MFF_IP_ECN, ecn);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_IP_ECN(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint8_t ecn;\n    char *error;\n\n    error = str_to_u8(arg, \"ECN\", &ecn);\n    if (error) {\n        return error;\n    }\n\n    if (ecn & ~IP_ECN_MASK) {\n        return xasprintf(\"%s: not a valid ECN\", arg);\n    }\n    ofpact_put_SET_IP_ECN(ofpacts)->ecn = ecn;\n    return NULL;\n}\n\nstatic void\nformat_SET_IP_ECN(const struct ofpact_ecn *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_nw_ecn:%s%d\",\n                  colors.param, colors.end, a->ecn);\n}\n\f\n/* Set IPv4/v6 TTL actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW11_SET_NW_TTL(uint8_t ttl,\n                              enum ofp_version ofp_version OVS_UNUSED,\n                              struct ofpbuf *out)\n{\n    ofpact_put_SET_IP_TTL(out)->ttl = ttl;\n    return 0;\n}\n\nstatic void\nencode_SET_IP_TTL(const struct ofpact_ip_ttl *ttl,\n                  enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version >= OFP11_VERSION) {\n        put_OFPAT11_SET_NW_TTL(out, ttl->ttl);\n    } else {\n        struct mf_subfield dst = { .field = mf_from_id(MFF_IP_TTL),\n                                   .ofs = 0, .n_bits = 8 };\n        put_reg_load(out, &dst, ttl->ttl);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_IP_TTL(char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint8_t ttl;\n    char *error;\n\n    error = str_to_u8(arg, \"TTL\", &ttl);\n    if (error) {\n        return error;\n    }\n\n    ofpact_put_SET_IP_TTL(ofpacts)->ttl = ttl;\n    return NULL;\n}\n\nstatic void\nformat_SET_IP_TTL(const struct ofpact_ip_ttl *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_nw_ttl:%s%d\", colors.param, colors.end, a->ttl);\n}\n\f\n/* Set TCP/UDP/SCTP port actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_TP_SRC(ovs_be16 port,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    ofpact_put_SET_L4_SRC_PORT(out)->port = ntohs(port);\n    return 0;\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_TP_DST(ovs_be16 port,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    ofpact_put_SET_L4_DST_PORT(out)->port = ntohs(port);\n    return 0;\n}\n\nstatic void\nencode_SET_L4_port(const struct ofpact_l4_port *l4_port,\n                   enum ofp_version ofp_version, enum ofp_raw_action_type raw,\n                   enum mf_field_id field, struct ofpbuf *out)\n{\n    uint16_t port = l4_port->port;\n\n    if (ofp_version >= OFP12_VERSION && field != MFF_N_IDS) {\n        put_set_field(out, ofp_version, field, port);\n    } else {\n        ofpact_put_raw(out, ofp_version, raw, port);\n    }\n}\n\nstatic void\nencode_SET_L4_SRC_PORT(const struct ofpact_l4_port *l4_port,\n                       enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    uint8_t proto = l4_port->flow_ip_proto;\n    enum mf_field_id field = (proto == IPPROTO_TCP ? MFF_TCP_SRC\n                              : proto == IPPROTO_UDP ? MFF_UDP_SRC\n                              : proto == IPPROTO_SCTP ? MFF_SCTP_SRC\n                              : MFF_N_IDS);\n\n    encode_SET_L4_port(l4_port, ofp_version, OFPAT_RAW_SET_TP_SRC, field, out);\n}\n\nstatic void\nencode_SET_L4_DST_PORT(const struct ofpact_l4_port *l4_port,\n                       enum ofp_version ofp_version,\n                       struct ofpbuf *out)\n{\n    uint8_t proto = l4_port->flow_ip_proto;\n    enum mf_field_id field = (proto == IPPROTO_TCP ? MFF_TCP_DST\n                              : proto == IPPROTO_UDP ? MFF_UDP_DST\n                              : proto == IPPROTO_SCTP ? MFF_SCTP_DST\n                              : MFF_N_IDS);\n\n    encode_SET_L4_port(l4_port, ofp_version, OFPAT_RAW_SET_TP_DST, field, out);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_L4_SRC_PORT(char *arg, struct ofpbuf *ofpacts,\n                      enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_u16(arg, \"source port\",\n                      &ofpact_put_SET_L4_SRC_PORT(ofpacts)->port);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_L4_DST_PORT(char *arg, struct ofpbuf *ofpacts,\n                      enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_u16(arg, \"destination port\",\n                      &ofpact_put_SET_L4_DST_PORT(ofpacts)->port);\n}\n\nstatic void\nformat_SET_L4_SRC_PORT(const struct ofpact_l4_port *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_tp_src:%s%d\", colors.param, colors.end, a->port);\n}\n\nstatic void\nformat_SET_L4_DST_PORT(const struct ofpact_l4_port *a, struct ds *s)\n{\n    ds_put_format(s, \"%smod_tp_dst:%s%d\", colors.param, colors.end, a->port);\n}\n\f\n/* Action structure for OFPAT_COPY_FIELD. */\nstruct ofp15_action_copy_field {\n    ovs_be16 type;              /* OFPAT_COPY_FIELD. */\n    ovs_be16 len;               /* Length is padded to 64 bits. */\n    ovs_be16 n_bits;            /* Number of bits to copy. */\n    ovs_be16 src_offset;        /* Starting bit offset in source. */\n    ovs_be16 dst_offset;        /* Starting bit offset in destination. */\n    uint8_t pad[2];\n    /* Followed by:\n     * - OXM header for source field.\n     * - OXM header for destination field.\n     * - Padding with 0-bytes to a multiple of 8 bytes.\n     * The \"pad2\" member is the beginning of the above. */\n    uint8_t pad2[4];\n};\nOFP_ASSERT(sizeof(struct ofp15_action_copy_field) == 16);\n\n/* Action structure for OpenFlow 1.3 extension copy-field action.. */\nstruct onf_action_copy_field {\n    ovs_be16 type;              /* OFPAT_EXPERIMENTER. */\n    ovs_be16 len;               /* Length is padded to 64 bits. */\n    ovs_be32 experimenter;      /* ONF_VENDOR_ID. */\n    ovs_be16 exp_type;          /* 3200. */\n    uint8_t pad[2];             /* Not used. */\n    ovs_be16 n_bits;            /* Number of bits to copy. */\n    ovs_be16 src_offset;        /* Starting bit offset in source. */\n    ovs_be16 dst_offset;        /* Starting bit offset in destination. */\n    uint8_t pad2[2];            /* Not used. */\n    /* Followed by:\n     * - OXM header for source field.\n     * - OXM header for destination field.\n     * - Padding with 0-bytes (either 0 or 4 of them) to a multiple of 8 bytes.\n     * The \"pad3\" member is the beginning of the above. */\n    uint8_t pad3[4];            /* Not used. */\n};\nOFP_ASSERT(sizeof(struct onf_action_copy_field) == 24);\n\n/* Action structure for NXAST_REG_MOVE.\n *\n * Copies src[src_ofs:src_ofs+n_bits] to dst[dst_ofs:dst_ofs+n_bits], where\n * a[b:c] denotes the bits within 'a' numbered 'b' through 'c' (not including\n * bit 'c').  Bit numbering starts at 0 for the least-significant bit, 1 for\n * the next most significant bit, and so on.\n *\n * 'src' and 'dst' are nxm_header values with nxm_hasmask=0.  (It doesn't make\n * sense to use nxm_hasmask=1 because the action does not do any kind of\n * matching; it uses the actual value of a field.)\n *\n * The following nxm_header values are potentially acceptable as 'src':\n *\n *   - NXM_OF_IN_PORT\n *   - NXM_OF_ETH_DST\n *   - NXM_OF_ETH_SRC\n *   - NXM_OF_ETH_TYPE\n *   - NXM_OF_VLAN_TCI\n *   - NXM_OF_IP_TOS\n *   - NXM_OF_IP_PROTO\n *   - NXM_OF_IP_SRC\n *   - NXM_OF_IP_DST\n *   - NXM_OF_TCP_SRC\n *   - NXM_OF_TCP_DST\n *   - NXM_OF_UDP_SRC\n *   - NXM_OF_UDP_DST\n *   - NXM_OF_ICMP_TYPE\n *   - NXM_OF_ICMP_CODE\n *   - NXM_OF_ARP_OP\n *   - NXM_OF_ARP_SPA\n *   - NXM_OF_ARP_TPA\n *   - NXM_NX_TUN_ID\n *   - NXM_NX_ARP_SHA\n *   - NXM_NX_ARP_THA\n *   - NXM_NX_ICMPV6_TYPE\n *   - NXM_NX_ICMPV6_CODE\n *   - NXM_NX_ND_SLL\n *   - NXM_NX_ND_TLL\n *   - NXM_NX_REG(idx) for idx in the switch's accepted range.\n *   - NXM_NX_PKT_MARK\n *   - NXM_NX_TUN_IPV4_SRC\n *   - NXM_NX_TUN_IPV4_DST\n *\n * The following nxm_header values are potentially acceptable as 'dst':\n *\n *   - NXM_OF_ETH_DST\n *   - NXM_OF_ETH_SRC\n *   - NXM_OF_IP_TOS\n *   - NXM_OF_IP_SRC\n *   - NXM_OF_IP_DST\n *   - NXM_OF_TCP_SRC\n *   - NXM_OF_TCP_DST\n *   - NXM_OF_UDP_SRC\n *   - NXM_OF_UDP_DST\n *   - NXM_OF_ICMP_TYPE\n *   - NXM_OF_ICMP_CODE\n *   - NXM_NX_ICMPV6_TYPE\n *   - NXM_NX_ICMPV6_CODE\n *   - NXM_NX_ARP_SHA\n *   - NXM_NX_ARP_THA\n *   - NXM_OF_ARP_OP\n *   - NXM_OF_ARP_SPA\n *   - NXM_OF_ARP_TPA\n *     Modifying any of the above fields changes the corresponding packet\n *     header.\n *\n *   - NXM_OF_IN_PORT\n *\n *   - NXM_NX_REG(idx) for idx in the switch's accepted range.\n *\n *   - NXM_NX_PKT_MARK\n *\n *   - NXM_OF_VLAN_TCI.  Modifying this field's value has side effects on the\n *     packet's 802.1Q header.  Setting a value with CFI=0 removes the 802.1Q\n *     header (if any), ignoring the other bits.  Setting a value with CFI=1\n *     adds or modifies the 802.1Q header appropriately, setting the TCI field\n *     to the field's new value (with the CFI bit masked out).\n *\n *   - NXM_NX_TUN_ID, NXM_NX_TUN_IPV4_SRC, NXM_NX_TUN_IPV4_DST.  Modifying\n *     any of these values modifies the corresponding tunnel header field used\n *     for the packet's next tunnel encapsulation, if allowed by the\n *     configuration of the output tunnel port.\n *\n * A given nxm_header value may be used as 'src' or 'dst' only on a flow whose\n * nx_match satisfies its prerequisites.  For example, NXM_OF_IP_TOS may be\n * used only if the flow's nx_match includes an nxm_entry that specifies\n * nxm_type=NXM_OF_ETH_TYPE, nxm_hasmask=0, and nxm_value=0x0800.\n *\n * The switch will reject actions for which src_ofs+n_bits is greater than the\n * width of 'src' or dst_ofs+n_bits is greater than the width of 'dst' with\n * error type OFPET_BAD_ACTION, code OFPBAC_BAD_ARGUMENT.\n *\n * This action behaves properly when 'src' overlaps with 'dst', that is, it\n * behaves as if 'src' were copied out to a temporary buffer, then the\n * temporary buffer copied to 'dst'.\n */\nstruct nx_action_reg_move {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 24. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_REG_MOVE. */\n    ovs_be16 n_bits;                /* Number of bits. */\n    ovs_be16 src_ofs;               /* Starting bit offset in source. */\n    ovs_be16 dst_ofs;               /* Starting bit offset in destination. */\n    /* Followed by:\n     * - OXM/NXM header for source field (4 or 8 bytes).\n     * - OXM/NXM header for destination field (4 or 8 bytes).\n     * - Padding with 0-bytes to a multiple of 8 bytes, if necessary. */\n};\nOFP_ASSERT(sizeof(struct nx_action_reg_move) == 16);\n\nstatic enum ofperr\ndecode_copy_field__(ovs_be16 src_offset, ovs_be16 dst_offset, ovs_be16 n_bits,\n                    const void *action, ovs_be16 action_len, size_t oxm_offset,\n                    const struct vl_mff_map *vl_mff_map,\n                    uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpact_reg_move *move = ofpact_put_REG_MOVE(ofpacts);\n    enum ofperr error;\n\n    move->ofpact.raw = ONFACT_RAW13_COPY_FIELD;\n    move->src.ofs = ntohs(src_offset);\n    move->src.n_bits = ntohs(n_bits);\n    move->dst.ofs = ntohs(dst_offset);\n    move->dst.n_bits = ntohs(n_bits);\n\n    struct ofpbuf b = ofpbuf_const_initializer(action, ntohs(action_len));\n    ofpbuf_pull(&b, oxm_offset);\n\n    error = mf_vl_mff_nx_pull_header(&b, vl_mff_map, &move->src.field, NULL,\n                                     tlv_bitmap);\n    if (error) {\n        return error;\n    }\n    error = mf_vl_mff_nx_pull_header(&b, vl_mff_map, &move->dst.field, NULL,\n                                     tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    if (!is_all_zeros(b.data, b.size)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    return nxm_reg_move_check(move, NULL);\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW15_COPY_FIELD(const struct ofp15_action_copy_field *oacf,\n                              enum ofp_version ofp_version OVS_UNUSED,\n                              const struct vl_mff_map *vl_mff_map,\n                              uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    return decode_copy_field__(oacf->src_offset, oacf->dst_offset,\n                               oacf->n_bits, oacf, oacf->len,\n                               OBJECT_OFFSETOF(oacf, pad2), vl_mff_map,\n                               tlv_bitmap, ofpacts);\n}\n\nstatic enum ofperr\ndecode_ONFACT_RAW13_COPY_FIELD(const struct onf_action_copy_field *oacf,\n                               enum ofp_version ofp_version OVS_UNUSED,\n                               const struct vl_mff_map *vl_mff_map,\n                               uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    return decode_copy_field__(oacf->src_offset, oacf->dst_offset,\n                               oacf->n_bits, oacf, oacf->len,\n                               OBJECT_OFFSETOF(oacf, pad3), vl_mff_map,\n                               tlv_bitmap, ofpacts);\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_REG_MOVE(const struct nx_action_reg_move *narm,\n                          enum ofp_version ofp_version OVS_UNUSED,\n                          const struct vl_mff_map *vl_mff_map,\n                          uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpact_reg_move *move = ofpact_put_REG_MOVE(ofpacts);\n    enum ofperr error;\n\n    move->ofpact.raw = NXAST_RAW_REG_MOVE;\n    move->src.ofs = ntohs(narm->src_ofs);\n    move->src.n_bits = ntohs(narm->n_bits);\n    move->dst.ofs = ntohs(narm->dst_ofs);\n    move->dst.n_bits = ntohs(narm->n_bits);\n\n    struct ofpbuf b = ofpbuf_const_initializer(narm, ntohs(narm->len));\n    ofpbuf_pull(&b, sizeof *narm);\n\n    error = mf_vl_mff_nx_pull_header(&b, vl_mff_map, &move->src.field, NULL,\n                                     tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    error = mf_vl_mff_nx_pull_header(&b, vl_mff_map, &move->dst.field, NULL,\n                                     tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    if (!is_all_zeros(b.data, b.size)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    return nxm_reg_move_check(move, NULL);\n}\n\nstatic void\nencode_REG_MOVE(const struct ofpact_reg_move *move,\n                enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    /* For OpenFlow 1.3, the choice of ONFACT_RAW13_COPY_FIELD versus\n     * NXAST_RAW_REG_MOVE is somewhat difficult.  Neither one is guaranteed to\n     * be supported by every OpenFlow 1.3 implementation.  It would be ideal to\n     * probe for support.  Until we have that ability, we currently prefer\n     * NXAST_RAW_REG_MOVE for backward compatibility with older Open vSwitch\n     * versions.  */\n    size_t start_ofs = out->size;\n    if (ofp_version >= OFP15_VERSION) {\n        struct ofp15_action_copy_field *copy = put_OFPAT15_COPY_FIELD(out);\n        copy->n_bits = htons(move->dst.n_bits);\n        copy->src_offset = htons(move->src.ofs);\n        copy->dst_offset = htons(move->dst.ofs);\n        out->size = out->size - sizeof copy->pad2;\n        nx_put_mff_header(out, move->src.field, ofp_version, false);\n        nx_put_mff_header(out, move->dst.field, ofp_version, false);\n    } else if (ofp_version == OFP13_VERSION\n               && move->ofpact.raw == ONFACT_RAW13_COPY_FIELD) {\n        struct onf_action_copy_field *copy = put_ONFACT13_COPY_FIELD(out);\n        copy->n_bits = htons(move->dst.n_bits);\n        copy->src_offset = htons(move->src.ofs);\n        copy->dst_offset = htons(move->dst.ofs);\n        out->size = out->size - sizeof copy->pad3;\n        nx_put_mff_header(out, move->src.field, ofp_version, false);\n        nx_put_mff_header(out, move->dst.field, ofp_version, false);\n    } else {\n        struct nx_action_reg_move *narm = put_NXAST_REG_MOVE(out);\n        narm->n_bits = htons(move->dst.n_bits);\n        narm->src_ofs = htons(move->src.ofs);\n        narm->dst_ofs = htons(move->dst.ofs);\n        nx_put_mff_header(out, move->src.field, 0, false);\n        nx_put_mff_header(out, move->dst.field, 0, false);\n    }\n    pad_ofpat(out, start_ofs);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_REG_MOVE(const char *arg, struct ofpbuf *ofpacts,\n               enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_reg_move *move = ofpact_put_REG_MOVE(ofpacts);\n    return nxm_parse_reg_move(move, arg);\n}\n\nstatic void\nformat_REG_MOVE(const struct ofpact_reg_move *a, struct ds *s)\n{\n    nxm_format_reg_move(a, s);\n}\n\f\n/* Action structure for OFPAT12_SET_FIELD. */\nstruct ofp12_action_set_field {\n    ovs_be16 type;                  /* OFPAT12_SET_FIELD. */\n    ovs_be16 len;                   /* Length is padded to 64 bits. */\n\n    /* Followed by:\n     * - An OXM header, value, and (in OpenFlow 1.5+) optionally a mask.\n     * - Enough 0-bytes to pad out to a multiple of 64 bits.\n     *\n     * The \"pad\" member is the beginning of the above. */\n    uint8_t pad[4];\n};\nOFP_ASSERT(sizeof(struct ofp12_action_set_field) == 8);\n\n/* Action structure for NXAST_REG_LOAD.\n *\n * Copies value[0:n_bits] to dst[ofs:ofs+n_bits], where a[b:c] denotes the bits\n * within 'a' numbered 'b' through 'c' (not including bit 'c').  Bit numbering\n * starts at 0 for the least-significant bit, 1 for the next most significant\n * bit, and so on.\n *\n * 'dst' is an nxm_header with nxm_hasmask=0.  See the documentation for\n * NXAST_REG_MOVE, above, for the permitted fields and for the side effects of\n * loading them.\n *\n * The 'ofs' and 'n_bits' fields are combined into a single 'ofs_nbits' field\n * to avoid enlarging the structure by another 8 bytes.  To allow 'n_bits' to\n * take a value between 1 and 64 (inclusive) while taking up only 6 bits, it is\n * also stored as one less than its true value:\n *\n *  15                           6 5                0\n * +------------------------------+------------------+\n * |              ofs             |    n_bits - 1    |\n * +------------------------------+------------------+\n *\n * The switch will reject actions for which ofs+n_bits is greater than the\n * width of 'dst', or in which any bits in 'value' with value 2**n_bits or\n * greater are set to 1, with error type OFPET_BAD_ACTION, code\n * OFPBAC_BAD_ARGUMENT.\n */\nstruct nx_action_reg_load {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 24. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_REG_LOAD. */\n    ovs_be16 ofs_nbits;             /* (ofs << 6) | (n_bits - 1). */\n    ovs_be32 dst;                   /* Destination register. */\n    ovs_be64 value;                 /* Immediate value. */\n};\nOFP_ASSERT(sizeof(struct nx_action_reg_load) == 24);\n\n/* The NXAST_REG_LOAD2 action structure is \"struct ext_action_header\",\n * followed by:\n *\n * - An NXM/OXM header, value, and optionally a mask.\n * - Enough 0-bytes to pad out to a multiple of 64 bits.\n *\n * The \"pad\" member is the beginning of the above. */\n\nstatic enum ofperr\ndecode_ofpat_set_field(const struct ofp12_action_set_field *oasf,\n                       bool may_mask, const struct vl_mff_map *vl_mff_map,\n                       uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oasf, ntohs(oasf->len));\n    ofpbuf_pull(&b, OBJECT_OFFSETOF(oasf, pad));\n\n    union mf_value value, mask;\n    const struct mf_field *field;\n    enum ofperr error;\n    error  = mf_vl_mff_nx_pull_entry(&b, vl_mff_map, &field, &value,\n                                     may_mask ? &mask : NULL, tlv_bitmap);\n    if (error) {\n        return (error == OFPERR_OFPBMC_BAD_MASK\n                ? OFPERR_OFPBAC_BAD_SET_MASK\n                : error);\n    }\n\n    if (!may_mask) {\n        memset(&mask, 0xff, field->n_bytes);\n    }\n\n    if (!is_all_zeros(b.data, b.size)) {\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n\n    /* OpenFlow says specifically that one may not set OXM_OF_IN_PORT via\n     * Set-Field. */\n    if (field->id == MFF_IN_PORT_OXM) {\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n\n    /* oxm_length is now validated to be compatible with mf_value. */\n    if (!field->writable) {\n        VLOG_WARN_RL(&rl, \"destination field %s is not writable\",\n                     field->name);\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n\n    /* The value must be valid for match.  OpenFlow 1.5 also says,\n     * \"In an OXM_OF_VLAN_VID set-field action, the OFPVID_PRESENT bit must be\n     * a 1-bit in oxm_value and in oxm_mask.\" */\n    if (!mf_is_value_valid(field, &value)\n        || (field->id == MFF_VLAN_VID\n            && (!(mask.be16 & htons(OFPVID12_PRESENT))\n                || !(value.be16 & htons(OFPVID12_PRESENT))))) {\n        struct ds ds = DS_EMPTY_INITIALIZER;\n        mf_format(field, &value, NULL, &ds);\n        VLOG_WARN_RL(&rl, \"Invalid value for set field %s: %s\",\n                     field->name, ds_cstr(&ds));\n        ds_destroy(&ds);\n\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n\n    ofpact_put_set_field(ofpacts, field, &value, &mask);\n    return 0;\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW12_SET_FIELD(const struct ofp12_action_set_field *oasf,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             const struct vl_mff_map *vl_mff_map,\n                             uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    return decode_ofpat_set_field(oasf, false, vl_mff_map, tlv_bitmap,\n                                  ofpacts);\n}\n\nstatic enum ofperr\ndecode_OFPAT_RAW15_SET_FIELD(const struct ofp12_action_set_field *oasf,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             const struct vl_mff_map *vl_mff_map,\n                             uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    return decode_ofpat_set_field(oasf, true, vl_mff_map, tlv_bitmap, ofpacts);\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_REG_LOAD(const struct nx_action_reg_load *narl,\n                          enum ofp_version ofp_version OVS_UNUSED,\n                          const struct vl_mff_map *vl_mff_map,\n                          uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    struct mf_subfield dst;\n    enum ofperr error;\n\n    dst.ofs = nxm_decode_ofs(narl->ofs_nbits);\n    dst.n_bits = nxm_decode_n_bits(narl->ofs_nbits);\n    error = mf_vl_mff_mf_from_nxm_header(ntohl(narl->dst), vl_mff_map,\n                                         &dst.field, tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    error = mf_check_dst(&dst, NULL);\n    if (error) {\n        return error;\n    }\n\n    /* Reject 'narl' if a bit numbered 'n_bits' or higher is set to 1 in\n     * narl->value. */\n    if (dst.n_bits < 64 && ntohll(narl->value) >> dst.n_bits) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    struct ofpact_set_field *sf = ofpact_put_reg_load(out, dst.field, NULL,\n                                                      NULL);\n    bitwise_put(ntohll(narl->value),\n                sf->value, dst.field->n_bytes, dst.ofs,\n                dst.n_bits);\n    bitwise_put(UINT64_MAX,\n                ofpact_set_field_mask(sf), dst.field->n_bytes, dst.ofs,\n                dst.n_bits);\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_REG_LOAD2(const struct ext_action_header *eah,\n                           enum ofp_version ofp_version OVS_UNUSED,\n                           const struct vl_mff_map *vl_mff_map,\n                           uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(eah, ntohs(eah->len));\n    ofpbuf_pull(&b, OBJECT_OFFSETOF(eah, pad));\n\n    union mf_value value, mask;\n    const struct mf_field *field;\n    enum ofperr error;\n    error = mf_vl_mff_nx_pull_entry(&b, vl_mff_map, &field, &value, &mask,\n                                    tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    if (!is_all_zeros(b.data, b.size)) {\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n\n    if (!field->writable) {\n        VLOG_WARN_RL(&rl, \"destination field %s is not writable\", field->name);\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n\n    /* Put value and mask. */\n    ofpact_put_reg_load2(out, field, &value, &mask);\n    return 0;\n}\n\nstatic void\nput_set_field(struct ofpbuf *openflow, enum ofp_version ofp_version,\n              enum mf_field_id field, uint64_t value_)\n{\n    struct ofp12_action_set_field *oasf OVS_UNUSED;\n    int n_bytes = mf_from_id(field)->n_bytes;\n    size_t start_ofs = openflow->size;\n    union mf_value value;\n\n    value.be64 = htonll(value_ << (8 * (8 - n_bytes)));\n\n    oasf = put_OFPAT12_SET_FIELD(openflow);\n    openflow->size = openflow->size - sizeof oasf->pad;\n    nx_put_entry(openflow, mf_from_id(field), ofp_version, &value, NULL);\n    pad_ofpat(openflow, start_ofs);\n}\n\nstatic void\nput_reg_load(struct ofpbuf *openflow,\n             const struct mf_subfield *dst, uint64_t value)\n{\n    ovs_assert(dst->n_bits <= 64);\n\n    struct nx_action_reg_load *narl = put_NXAST_REG_LOAD(openflow);\n    narl->ofs_nbits = nxm_encode_ofs_nbits(dst->ofs, dst->n_bits);\n    narl->dst = htonl(nxm_header_from_mff(dst->field));\n    narl->value = htonll(value);\n}\n\nstatic bool\nnext_load_segment(const struct ofpact_set_field *sf,\n                  struct mf_subfield *dst, uint64_t *value)\n{\n    int n_bits = sf->field->n_bits;\n    int n_bytes = sf->field->n_bytes;\n    int start = dst->ofs + dst->n_bits;\n\n    if (start < n_bits) {\n        dst->field = sf->field;\n        dst->ofs = bitwise_scan(ofpact_set_field_mask(sf), n_bytes, 1, start,\n                                n_bits);\n        if (dst->ofs < n_bits) {\n            dst->n_bits = bitwise_scan(ofpact_set_field_mask(sf), n_bytes, 0,\n                                       dst->ofs + 1,\n                                       MIN(dst->ofs + 64, n_bits)) - dst->ofs;\n            *value = bitwise_get(sf->value, n_bytes, dst->ofs, dst->n_bits);\n            return true;\n        }\n    }\n    return false;\n}\n\n/* Convert 'sf' to a series of REG_LOADs. */\nstatic void\nset_field_to_nxast(const struct ofpact_set_field *sf, struct ofpbuf *openflow)\n{\n    /* If 'sf' cannot be encoded as NXAST_REG_LOAD because it requires an\n     * experimenter OXM or is variable length (or if it came in as\n     * NXAST_REG_LOAD2), encode as NXAST_REG_LOAD2.  Otherwise use\n     * NXAST_REG_LOAD, which is backward compatible. */\n    if (sf->ofpact.raw == NXAST_RAW_REG_LOAD2\n        || !mf_nxm_header(sf->field->id) || sf->field->variable_len) {\n        struct ext_action_header *eah OVS_UNUSED;\n        size_t start_ofs = openflow->size;\n\n        eah = put_NXAST_REG_LOAD2(openflow);\n        openflow->size = openflow->size - sizeof eah->pad;\n        nx_put_entry(openflow, sf->field, 0, sf->value,\n                     ofpact_set_field_mask(sf));\n        pad_ofpat(openflow, start_ofs);\n    } else {\n        struct mf_subfield dst;\n        uint64_t value;\n\n        dst.ofs = dst.n_bits = 0;\n        while (next_load_segment(sf, &dst, &value)) {\n            put_reg_load(openflow, &dst, value);\n        }\n    }\n}\n\n/* Convert 'sf', which must set an entire field, to standard OpenFlow 1.0/1.1\n * actions, if we can, falling back to Nicira extensions if we must.\n *\n * We check only meta-flow types that can appear within set field actions and\n * that have a mapping to compatible action types.  These struct mf_field\n * definitions have a defined OXM or NXM header value and specify the field as\n * writable. */\nstatic void\nset_field_to_legacy_openflow(const struct ofpact_set_field *sf,\n                             enum ofp_version ofp_version,\n                             struct ofpbuf *out)\n{\n    switch ((int) sf->field->id) {\n    case MFF_VLAN_TCI: {\n        ovs_be16 tci = sf->value->be16;\n        bool cfi = (tci & htons(VLAN_CFI)) != 0;\n        uint16_t vid = vlan_tci_to_vid(tci);\n        uint8_t pcp = vlan_tci_to_pcp(tci);\n\n        if (ofp_version < OFP11_VERSION) {\n            /* NXM_OF_VLAN_TCI to OpenFlow 1.0 mapping:\n             *\n             * If CFI=1, Add or modify VLAN VID & PCP.\n             * If CFI=0, strip VLAN header, if any.\n             */\n            if (cfi) {\n                put_OFPAT10_SET_VLAN_VID(out, vid);\n                put_OFPAT10_SET_VLAN_PCP(out, pcp);\n            } else {\n                put_OFPAT10_STRIP_VLAN(out);\n            }\n        } else {\n            /* NXM_OF_VLAN_TCI to OpenFlow 1.1 mapping:\n             *\n             * If CFI=1, Add or modify VLAN VID & PCP.\n             *    OpenFlow 1.1 set actions only apply if the packet\n             *    already has VLAN tags.  To be sure that is the case\n             *    we have to push a VLAN header.  As we do not support\n             *    multiple layers of VLANs, this is a no-op, if a VLAN\n             *    header already exists.  This may backfire, however,\n             *    when we start supporting multiple layers of VLANs.\n             * If CFI=0, strip VLAN header, if any.\n             */\n            if (cfi) {\n                /* Push a VLAN tag, if one was not seen at action validation\n                 * time. */\n                if (!sf->flow_has_vlan) {\n                    put_OFPAT11_PUSH_VLAN(out, htons(ETH_TYPE_VLAN_8021Q));\n                }\n                put_OFPAT11_SET_VLAN_VID(out, vid);\n                put_OFPAT11_SET_VLAN_PCP(out, pcp);\n            } else {\n                /* If the flow did not match on vlan, we have no way of\n                 * knowing if the vlan tag exists, so we must POP just to be\n                 * sure. */\n                put_OFPAT11_POP_VLAN(out);\n            }\n        }\n        break;\n    }\n\n    case MFF_VLAN_VID: {\n        uint16_t vid = ntohs(sf->value->be16) & VLAN_VID_MASK;\n        if (ofp_version == OFP10_VERSION) {\n            put_OFPAT10_SET_VLAN_VID(out, vid);\n        } else {\n            put_OFPAT11_SET_VLAN_VID(out, vid);\n        }\n        break;\n    }\n\n    case MFF_VLAN_PCP:\n        if (ofp_version == OFP10_VERSION) {\n            put_OFPAT10_SET_VLAN_PCP(out, sf->value->u8);\n        } else {\n            put_OFPAT11_SET_VLAN_PCP(out, sf->value->u8);\n        }\n        break;\n\n    case MFF_ETH_SRC:\n        put_OFPAT_SET_DL_SRC(out, ofp_version)->dl_addr = sf->value->mac;\n        break;\n\n    case MFF_ETH_DST:\n        put_OFPAT_SET_DL_DST(out, ofp_version)->dl_addr = sf->value->mac;\n        break;\n\n    case MFF_IPV4_SRC:\n        put_OFPAT_SET_NW_SRC(out, ofp_version, sf->value->be32);\n        break;\n\n    case MFF_IPV4_DST:\n        put_OFPAT_SET_NW_DST(out, ofp_version, sf->value->be32);\n        break;\n\n    case MFF_IP_DSCP:\n        put_OFPAT_SET_NW_TOS(out, ofp_version, sf->value->u8);\n        break;\n\n    case MFF_IP_DSCP_SHIFTED:\n        put_OFPAT_SET_NW_TOS(out, ofp_version, sf->value->u8 << 2);\n        break;\n\n    case MFF_IP_ECN: {\n        struct ofpact_ecn ip_ecn = { .ecn = sf->value->u8 };\n        encode_SET_IP_ECN(&ip_ecn, ofp_version, out);\n        break;\n    }\n\n    case MFF_TCP_SRC:\n    case MFF_UDP_SRC:\n        put_OFPAT_SET_TP_SRC(out, sf->value->be16);\n        break;\n\n    case MFF_TCP_DST:\n    case MFF_UDP_DST:\n        put_OFPAT_SET_TP_DST(out, sf->value->be16);\n        break;\n\n    default:\n        set_field_to_nxast(sf, out);\n        break;\n    }\n}\n\nstatic void\nset_field_to_set_field(const struct ofpact_set_field *sf,\n                       enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    struct ofp12_action_set_field *oasf OVS_UNUSED;\n    size_t start_ofs = out->size;\n\n    oasf = put_OFPAT12_SET_FIELD(out);\n    out->size = out->size - sizeof oasf->pad;\n    nx_put_entry(out, sf->field, ofp_version, sf->value,\n                 ofpact_set_field_mask(sf));\n    pad_ofpat(out, start_ofs);\n}\n\nstatic void\nencode_SET_FIELD(const struct ofpact_set_field *sf,\n                 enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version >= OFP15_VERSION) {\n        /* OF1.5+ only has Set-Field (reg_load is redundant so we drop it\n         * entirely). */\n        set_field_to_set_field(sf, ofp_version, out);\n    } else if (sf->ofpact.raw == NXAST_RAW_REG_LOAD ||\n               sf->ofpact.raw == NXAST_RAW_REG_LOAD2) {\n        /* It came in as reg_load, send it out the same way. */\n        set_field_to_nxast(sf, out);\n    } else if (ofp_version < OFP12_VERSION) {\n        /* OpenFlow 1.0 and 1.1 don't have Set-Field. */\n        set_field_to_legacy_openflow(sf, ofp_version, out);\n    } else if (is_all_ones(ofpact_set_field_mask(sf), sf->field->n_bytes)) {\n        /* We're encoding to OpenFlow 1.2, 1.3, or 1.4.  The action sets an\n         * entire field, so encode it as OFPAT_SET_FIELD. */\n        set_field_to_set_field(sf, ofp_version, out);\n    } else {\n        /* We're encoding to OpenFlow 1.2, 1.3, or 1.4.  The action cannot be\n         * encoded as OFPAT_SET_FIELD because it does not set an entire field,\n         * so encode it as reg_load. */\n        set_field_to_nxast(sf, out);\n    }\n}\n\n/* Parses the input argument 'arg' into the key, value, and delimiter\n * components that are common across the reg_load and set_field action format.\n *\n * With an argument like \"1->metadata\", sets the following pointers to\n * point within 'arg':\n * key: \"metadata\"\n * value: \"1\"\n * delim: \"->\"\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nset_field_split_str(char *arg, char **key, char **value, char **delim)\n{\n    char *value_end;\n\n    *value = arg;\n    value_end = strstr(arg, \"->\");\n    *key = value_end + strlen(\"->\");\n    if (delim) {\n        *delim = value_end;\n    }\n\n    if (!value_end) {\n        return xasprintf(\"%s: missing `->'\", arg);\n    }\n    if (strlen(value_end) <= strlen(\"->\")) {\n        return xasprintf(\"%s: missing field name following `->'\", arg);\n    }\n\n    return NULL;\n}\n\n/* Parses a \"set_field\" action with argument 'arg', appending the parsed\n * action to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nset_field_parse__(char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols)\n{\n    char *value;\n    char *delim;\n    char *key;\n    const struct mf_field *mf;\n    union mf_value sf_value, sf_mask;\n    char *error;\n\n    error = set_field_split_str(arg, &key, &value, &delim);\n    if (error) {\n        return error;\n    }\n\n    mf = mf_from_name(key);\n    if (!mf) {\n        return xasprintf(\"%s is not a valid OXM field name\", key);\n    }\n    if (!mf->writable) {\n        return xasprintf(\"%s is read-only\", key);\n    }\n\n    delim[0] = '\\0';\n    error = mf_parse(mf, value, &sf_value, &sf_mask);\n    if (error) {\n        return error;\n    }\n\n    if (!mf_is_value_valid(mf, &sf_value)) {\n        return xasprintf(\"%s is not a valid value for field %s\", value, key);\n    }\n\n    *usable_protocols &= mf->usable_protocols_exact;\n\n    ofpact_put_set_field(ofpacts, mf, &sf_value, &sf_mask);\n    return NULL;\n}\n\n/* Parses 'arg' as the argument to a \"set_field\" action, and appends such an\n * action to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_FIELD(const char *arg, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols)\n{\n    char *copy = xstrdup(arg);\n    char *error = set_field_parse__(copy, ofpacts, usable_protocols);\n    free(copy);\n    return error;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_reg_load(char *arg, struct ofpbuf *ofpacts)\n{\n    struct mf_subfield dst;\n    char *key, *value_str;\n    union mf_value value;\n    char *error;\n\n    error = set_field_split_str(arg, &key, &value_str, NULL);\n    if (error) {\n        return error;\n    }\n\n    error = mf_parse_subfield(&dst, key);\n    if (error) {\n        return error;\n    }\n\n    if (parse_int_string(value_str, (uint8_t *)&value, dst.field->n_bytes,\n                         &key)) {\n        return xasprintf(\"%s: cannot parse integer value\", arg);\n    }\n\n    if (!bitwise_is_all_zeros(&value, dst.field->n_bytes, dst.n_bits,\n                              dst.field->n_bytes * 8 - dst.n_bits)) {\n        struct ds ds;\n\n        ds_init(&ds);\n        mf_format(dst.field, &value, NULL, &ds);\n        error = xasprintf(\"%s: value %s does not fit into %d bits\",\n                          arg, ds_cstr(&ds), dst.n_bits);\n        ds_destroy(&ds);\n        return error;\n    }\n\n    struct ofpact_set_field *sf = ofpact_put_reg_load(ofpacts, dst.field, NULL,\n                                                      NULL);\n\n    bitwise_copy(&value, dst.field->n_bytes, 0, sf->value,\n                 dst.field->n_bytes, dst.ofs, dst.n_bits);\n    bitwise_one(ofpact_set_field_mask(sf), dst.field->n_bytes, dst.ofs,\n                dst.n_bits);\n    return NULL;\n}\n\nstatic void\nformat_SET_FIELD(const struct ofpact_set_field *a, struct ds *s)\n{\n    if (a->ofpact.raw == NXAST_RAW_REG_LOAD) {\n        struct mf_subfield dst;\n        uint64_t value;\n\n        dst.ofs = dst.n_bits = 0;\n        while (next_load_segment(a, &dst, &value)) {\n            ds_put_format(s, \"%sload:%s%#\"PRIx64\"%s->%s\",\n                          colors.special, colors.end, value,\n                          colors.special, colors.end);\n            mf_format_subfield(&dst, s);\n            ds_put_char(s, ',');\n        }\n        ds_chomp(s, ',');\n    } else {\n        ds_put_format(s, \"%sset_field:%s\", colors.special, colors.end);\n        mf_format(a->field, a->value, ofpact_set_field_mask(a), s);\n        ds_put_format(s, \"%s->%s%s\",\n                      colors.special, colors.end, a->field->name);\n    }\n}\n\n/* Appends an OFPACT_SET_FIELD ofpact with enough space for the value and mask\n * for the 'field' to 'ofpacts' and returns it.  Fills in the value from\n * 'value', if non-NULL, and mask from 'mask' if non-NULL.  If 'value' is\n * non-NULL and 'mask' is NULL, an all-ones mask will be filled in. */\nstruct ofpact_set_field *\nofpact_put_set_field(struct ofpbuf *ofpacts, const struct mf_field *field,\n                     const void *value, const void *mask)\n{\n    struct ofpact_set_field *sf = ofpact_put_SET_FIELD(ofpacts);\n    sf->field = field;\n\n    /* Fill in the value and mask if given, otherwise put zeroes so that the\n     * caller may fill in the value and mask itself. */\n    if (value) {\n        ofpbuf_put_uninit(ofpacts, 2 * field->n_bytes);\n        sf = ofpacts->header;\n        memcpy(sf->value, value, field->n_bytes);\n        if (mask) {\n            memcpy(ofpact_set_field_mask(sf), mask, field->n_bytes);\n        } else {\n            memset(ofpact_set_field_mask(sf), 0xff, field->n_bytes);\n        }\n    } else {\n        ofpbuf_put_zeros(ofpacts, 2 * field->n_bytes);\n        sf = ofpacts->header;\n    }\n    /* Update length. */\n    ofpact_finish_SET_FIELD(ofpacts, &sf);\n\n    return sf;\n}\n\n/* Appends an OFPACT_SET_FIELD ofpact to 'ofpacts' and returns it.  The ofpact\n * is marked such that, if possible, it will be translated to OpenFlow as\n * NXAST_REG_LOAD extension actions rather than OFPAT_SET_FIELD, either because\n * that was the way that the action was expressed when it came into OVS or for\n * backward compatibility. */\nstruct ofpact_set_field *\nofpact_put_reg_load(struct ofpbuf *ofpacts, const struct mf_field *field,\n                    const void *value, const void *mask)\n{\n    struct ofpact_set_field *sf = ofpact_put_set_field(ofpacts, field, value,\n                                                       mask);\n    sf->ofpact.raw = NXAST_RAW_REG_LOAD;\n\n    return sf;\n}\n\nstruct ofpact_set_field *\nofpact_put_reg_load2(struct ofpbuf *ofpacts, const struct mf_field *field,\n                     const void *value, const void *mask)\n{\n    struct ofpact_set_field *sf = ofpact_put_set_field(ofpacts, field, value,\n                                                       mask);\n    sf->ofpact.raw = NXAST_RAW_REG_LOAD2;\n\n    return sf;\n}\n\n\f\n/* Action structure for NXAST_STACK_PUSH and NXAST_STACK_POP.\n *\n * Pushes (or pops) field[offset: offset + n_bits] to (or from)\n * top of the stack.\n */\nstruct nx_action_stack {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 16. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_STACK_PUSH or NXAST_STACK_POP. */\n    ovs_be16 offset;                /* Bit offset into the field. */\n    /* Followed by:\n     * - OXM/NXM header for field to push or pop (4 or 8 bytes).\n     * - ovs_be16 'n_bits', the number of bits to extract from the field.\n     * - Enough 0-bytes to pad out the action to 24 bytes. */\n    uint8_t pad[12];                /* See above. */\n};\nOFP_ASSERT(sizeof(struct nx_action_stack) == 24);\n\nstatic enum ofperr\ndecode_stack_action(const struct nx_action_stack *nasp,\n                    const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap,\n                    struct ofpact_stack *stack_action)\n{\n    enum ofperr error;\n    stack_action->subfield.ofs = ntohs(nasp->offset);\n\n    struct ofpbuf b = ofpbuf_const_initializer(nasp, sizeof *nasp);\n    ofpbuf_pull(&b, OBJECT_OFFSETOF(nasp, pad));\n    error  = mf_vl_mff_nx_pull_header(&b, vl_mff_map,\n                                      &stack_action->subfield.field, NULL,\n                                      tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    stack_action->subfield.n_bits = ntohs(*(const ovs_be16 *) b.data);\n    ofpbuf_pull(&b, 2);\n    if (!is_all_zeros(b.data, b.size)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_STACK_PUSH(const struct nx_action_stack *nasp,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            const struct vl_mff_map *vl_mff_map,\n                            uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpact_stack *push = ofpact_put_STACK_PUSH(ofpacts);\n    enum ofperr error = decode_stack_action(nasp, vl_mff_map, tlv_bitmap,\n                                            push);\n    return error ? error : nxm_stack_push_check(push, NULL);\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_STACK_POP(const struct nx_action_stack *nasp,\n                           enum ofp_version ofp_version OVS_UNUSED,\n                           const struct vl_mff_map *vl_mff_map,\n                           uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpact_stack *pop = ofpact_put_STACK_POP(ofpacts);\n    enum ofperr error = decode_stack_action(nasp, vl_mff_map, tlv_bitmap,\n                                            pop);\n    return error ? error : nxm_stack_pop_check(pop, NULL);\n}\n\nstatic void\nencode_STACK_op(const struct ofpact_stack *stack_action,\n                struct nx_action_stack *nasp)\n{\n    struct ofpbuf b;\n    ovs_be16 n_bits;\n\n    nasp->offset = htons(stack_action->subfield.ofs);\n\n    ofpbuf_use_stack(&b, nasp, ntohs(nasp->len));\n    ofpbuf_put_uninit(&b, OBJECT_OFFSETOF(nasp, pad));\n    nx_put_mff_header(&b, stack_action->subfield.field, 0, false);\n    n_bits = htons(stack_action->subfield.n_bits);\n    ofpbuf_put(&b, &n_bits, sizeof n_bits);\n}\n\nstatic void\nencode_STACK_PUSH(const struct ofpact_stack *stack,\n                  enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    encode_STACK_op(stack, put_NXAST_STACK_PUSH(out));\n}\n\nstatic void\nencode_STACK_POP(const struct ofpact_stack *stack,\n                 enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    encode_STACK_op(stack, put_NXAST_STACK_POP(out));\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_STACK_PUSH(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return nxm_parse_stack_action(ofpact_put_STACK_PUSH(ofpacts), arg);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_STACK_POP(char *arg, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return nxm_parse_stack_action(ofpact_put_STACK_POP(ofpacts), arg);\n}\n\nstatic void\nformat_STACK_PUSH(const struct ofpact_stack *a, struct ds *s)\n{\n    nxm_format_stack_push(a, s);\n}\n\nstatic void\nformat_STACK_POP(const struct ofpact_stack *a, struct ds *s)\n{\n    nxm_format_stack_pop(a, s);\n}\n\f\n/* Action structure for NXAST_DEC_TTL_CNT_IDS.\n *\n * If the packet is not IPv4 or IPv6, does nothing.  For IPv4 or IPv6, if the\n * TTL or hop limit is at least 2, decrements it by 1.  Otherwise, if TTL or\n * hop limit is 0 or 1, sends a packet-in to the controllers with each of the\n * 'n_controllers' controller IDs specified in 'cnt_ids'.\n *\n * (This differs from NXAST_DEC_TTL in that for NXAST_DEC_TTL the packet-in is\n * sent only to controllers with id 0.)\n */\nstruct nx_action_cnt_ids {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* Length including slaves. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_DEC_TTL_CNT_IDS. */\n\n    ovs_be16 n_controllers;     /* Number of controllers. */\n    uint8_t zeros[4];           /* Must be zero. */\n\n    /* Followed by 1 or more controller ids.\n     *\n     * uint16_t cnt_ids[];        // Controller ids.\n     * uint8_t pad[];           // Must be 0 to 8-byte align cnt_ids[].\n     */\n};\nOFP_ASSERT(sizeof(struct nx_action_cnt_ids) == 16);\n\nstatic enum ofperr\ndecode_OFPAT_RAW_DEC_NW_TTL(struct ofpbuf *out)\n{\n    uint16_t id = 0;\n    struct ofpact_cnt_ids *ids;\n    enum ofperr error = 0;\n\n    ids = ofpact_put_DEC_TTL(out);\n    ids->n_controllers = 1;\n    ofpbuf_put(out, &id, sizeof id);\n    ids = out->header;\n    ofpact_finish_DEC_TTL(out, &ids);\n    return error;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_DEC_TTL_CNT_IDS(const struct nx_action_cnt_ids *nac_ids,\n                                 enum ofp_version ofp_version OVS_UNUSED,\n                                 struct ofpbuf *out)\n{\n    struct ofpact_cnt_ids *ids;\n    size_t ids_size;\n    int i;\n\n    ids = ofpact_put_DEC_TTL(out);\n    ids->ofpact.raw = NXAST_RAW_DEC_TTL_CNT_IDS;\n    ids->n_controllers = ntohs(nac_ids->n_controllers);\n    ids_size = ntohs(nac_ids->len) - sizeof *nac_ids;\n\n    if (!is_all_zeros(nac_ids->zeros, sizeof nac_ids->zeros)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    if (ids_size < ids->n_controllers * sizeof(ovs_be16)) {\n        VLOG_WARN_RL(&rl, \"Nicira action dec_ttl_cnt_ids only has %\"PRIuSIZE\" \"\n                     \"bytes allocated for controller ids.  %\"PRIuSIZE\" bytes \"\n                     \"are required for %\"PRIu16\" controllers.\",\n                     ids_size, ids->n_controllers * sizeof(ovs_be16),\n                     ids->n_controllers);\n        return OFPERR_OFPBAC_BAD_LEN;\n    }\n\n    for (i = 0; i < ids->n_controllers; i++) {\n        uint16_t id = ntohs(((ovs_be16 *)(nac_ids + 1))[i]);\n        ofpbuf_put(out, &id, sizeof id);\n        ids = out->header;\n    }\n\n    ofpact_finish_DEC_TTL(out, &ids);\n\n    return 0;\n}\n\nstatic void\nencode_DEC_TTL(const struct ofpact_cnt_ids *dec_ttl,\n               enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (dec_ttl->ofpact.raw == NXAST_RAW_DEC_TTL_CNT_IDS\n        || dec_ttl->n_controllers != 1\n        || dec_ttl->cnt_ids[0] != 0) {\n        struct nx_action_cnt_ids *nac_ids = put_NXAST_DEC_TTL_CNT_IDS(out);\n        int ids_len = ROUND_UP(2 * dec_ttl->n_controllers, OFP_ACTION_ALIGN);\n        ovs_be16 *ids;\n        size_t i;\n\n        nac_ids->len = htons(ntohs(nac_ids->len) + ids_len);\n        nac_ids->n_controllers = htons(dec_ttl->n_controllers);\n\n        ids = ofpbuf_put_zeros(out, ids_len);\n        for (i = 0; i < dec_ttl->n_controllers; i++) {\n            ids[i] = htons(dec_ttl->cnt_ids[i]);\n        }\n    } else {\n        put_OFPAT_DEC_NW_TTL(out, ofp_version);\n    }\n}\n\nstatic void\nparse_noargs_dec_ttl(struct ofpbuf *ofpacts)\n{\n    struct ofpact_cnt_ids *ids;\n    uint16_t id = 0;\n\n    ofpact_put_DEC_TTL(ofpacts);\n    ofpbuf_put(ofpacts, &id, sizeof id);\n    ids = ofpacts->header;\n    ids->n_controllers++;\n    ofpact_finish_DEC_TTL(ofpacts, &ids);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_DEC_TTL(char *arg, struct ofpbuf *ofpacts,\n              enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    if (*arg == '\\0') {\n        parse_noargs_dec_ttl(ofpacts);\n    } else {\n        struct ofpact_cnt_ids *ids;\n        char *cntr;\n\n        ids = ofpact_put_DEC_TTL(ofpacts);\n        ids->ofpact.raw = NXAST_RAW_DEC_TTL_CNT_IDS;\n        for (cntr = strtok_r(arg, \", \", &arg); cntr != NULL;\n             cntr = strtok_r(NULL, \", \", &arg)) {\n            uint16_t id = atoi(cntr);\n\n            ofpbuf_put(ofpacts, &id, sizeof id);\n            ids = ofpacts->header;\n            ids->n_controllers++;\n        }\n        if (!ids->n_controllers) {\n            return xstrdup(\"dec_ttl_cnt_ids: expected at least one controller \"\n                           \"id.\");\n        }\n        ofpact_finish_DEC_TTL(ofpacts, &ids);\n    }\n    return NULL;\n}\n\nstatic void\nformat_DEC_TTL(const struct ofpact_cnt_ids *a, struct ds *s)\n{\n    size_t i;\n\n    ds_put_format(s, \"%sdec_ttl%s\", colors.paren, colors.end);\n    if (a->ofpact.raw == NXAST_RAW_DEC_TTL_CNT_IDS) {\n        ds_put_format(s, \"%s(%s\", colors.paren, colors.end);\n        for (i = 0; i < a->n_controllers; i++) {\n            if (i) {\n                ds_put_cstr(s, \",\");\n            }\n            ds_put_format(s, \"%\"PRIu16, a->cnt_ids[i]);\n        }\n        ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n    }\n}\n\f\n/* Set MPLS label actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_MPLS_LABEL(ovs_be32 label,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    ofpact_put_SET_MPLS_LABEL(out)->label = label;\n    return 0;\n}\n\nstatic void\nencode_SET_MPLS_LABEL(const struct ofpact_mpls_label *label,\n                      enum ofp_version ofp_version,\n                                  struct ofpbuf *out)\n{\n    if (ofp_version < OFP12_VERSION) {\n        put_OFPAT_SET_MPLS_LABEL(out, ofp_version, label->label);\n    } else {\n        put_set_field(out, ofp_version, MFF_MPLS_LABEL, ntohl(label->label));\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_MPLS_LABEL(char *arg, struct ofpbuf *ofpacts,\n                     enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_mpls_label *mpls_label = ofpact_put_SET_MPLS_LABEL(ofpacts);\n    if (*arg == '\\0') {\n        return xstrdup(\"set_mpls_label: expected label.\");\n    }\n\n    mpls_label->label = htonl(atoi(arg));\n    return NULL;\n}\n\nstatic void\nformat_SET_MPLS_LABEL(const struct ofpact_mpls_label *a, struct ds *s)\n{\n    ds_put_format(s, \"%sset_mpls_label(%s%\"PRIu32\"%s)%s\",\n                  colors.paren, colors.end, ntohl(a->label),\n                  colors.paren, colors.end);\n}\n\f\n/* Set MPLS TC actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_MPLS_TC(uint8_t tc,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             struct ofpbuf *out)\n{\n    ofpact_put_SET_MPLS_TC(out)->tc = tc;\n    return 0;\n}\n\nstatic void\nencode_SET_MPLS_TC(const struct ofpact_mpls_tc *tc,\n                   enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version < OFP12_VERSION) {\n        put_OFPAT_SET_MPLS_TC(out, ofp_version, tc->tc);\n    } else {\n        put_set_field(out, ofp_version, MFF_MPLS_TC, tc->tc);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_MPLS_TC(char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_mpls_tc *mpls_tc = ofpact_put_SET_MPLS_TC(ofpacts);\n\n    if (*arg == '\\0') {\n        return xstrdup(\"set_mpls_tc: expected tc.\");\n    }\n\n    mpls_tc->tc = atoi(arg);\n    return NULL;\n}\n\nstatic void\nformat_SET_MPLS_TC(const struct ofpact_mpls_tc *a, struct ds *s)\n{\n    ds_put_format(s, \"%sset_mpls_ttl(%s%\"PRIu8\"%s)%s\",\n                  colors.paren, colors.end, a->tc,\n                  colors.paren, colors.end);\n}\n\f\n/* Set MPLS TTL actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_MPLS_TTL(uint8_t ttl,\n                              enum ofp_version ofp_version OVS_UNUSED,\n                              struct ofpbuf *out)\n{\n    ofpact_put_SET_MPLS_TTL(out)->ttl = ttl;\n    return 0;\n}\n\nstatic void\nencode_SET_MPLS_TTL(const struct ofpact_mpls_ttl *ttl,\n                    enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    put_OFPAT_SET_MPLS_TTL(out, ofp_version, ttl->ttl);\n}\n\n/* Parses 'arg' as the argument to a \"set_mpls_ttl\" action, and appends such an\n * action to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_MPLS_TTL(char *arg, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_mpls_ttl *mpls_ttl = ofpact_put_SET_MPLS_TTL(ofpacts);\n\n    if (*arg == '\\0') {\n        return xstrdup(\"set_mpls_ttl: expected ttl.\");\n    }\n\n    mpls_ttl->ttl = atoi(arg);\n    return NULL;\n}\n\nstatic void\nformat_SET_MPLS_TTL(const struct ofpact_mpls_ttl *a, struct ds *s)\n{\n    ds_put_format(s, \"%sset_mpls_ttl(%s%\"PRIu8\"%s)%s\",\n                  colors.paren, colors.end, a->ttl,\n                  colors.paren, colors.end);\n}\n\f\n/* Decrement MPLS TTL actions. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_DEC_MPLS_TTL(struct ofpbuf *out)\n{\n    ofpact_put_DEC_MPLS_TTL(out);\n    return 0;\n}\n\nstatic void\nencode_DEC_MPLS_TTL(const struct ofpact_null *null OVS_UNUSED,\n                    enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    put_OFPAT_DEC_MPLS_TTL(out, ofp_version);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_DEC_MPLS_TTL(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_DEC_MPLS_TTL(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_DEC_MPLS_TTL(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%sdec_mpls_ttl%s\", colors.value, colors.end);\n}\n\f\n/* Push MPLS label action. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_PUSH_MPLS(ovs_be16 ethertype,\n                           enum ofp_version ofp_version OVS_UNUSED,\n                           struct ofpbuf *out)\n{\n    struct ofpact_push_mpls *oam;\n\n    if (!eth_type_mpls(ethertype)) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n    oam = ofpact_put_PUSH_MPLS(out);\n    oam->ethertype = ethertype;\n\n    return 0;\n}\n\nstatic void\nencode_PUSH_MPLS(const struct ofpact_push_mpls *push_mpls,\n                 enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    put_OFPAT_PUSH_MPLS(out, ofp_version, push_mpls->ethertype);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_PUSH_MPLS(char *arg, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint16_t ethertype;\n    char *error;\n\n    error = str_to_u16(arg, \"push_mpls\", &ethertype);\n    if (!error) {\n        ofpact_put_PUSH_MPLS(ofpacts)->ethertype = htons(ethertype);\n    }\n    return error;\n}\n\nstatic void\nformat_PUSH_MPLS(const struct ofpact_push_mpls *a, struct ds *s)\n{\n    ds_put_format(s, \"%spush_mpls:%s0x%04\"PRIx16,\n                  colors.param, colors.end, ntohs(a->ethertype));\n}\n\f\n/* Pop MPLS label action. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_POP_MPLS(ovs_be16 ethertype,\n                          enum ofp_version ofp_version OVS_UNUSED,\n                          struct ofpbuf *out)\n{\n    ofpact_put_POP_MPLS(out)->ethertype = ethertype;\n    return 0;\n}\n\nstatic void\nencode_POP_MPLS(const struct ofpact_pop_mpls *pop_mpls,\n                enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    put_OFPAT_POP_MPLS(out, ofp_version, pop_mpls->ethertype);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_POP_MPLS(char *arg, struct ofpbuf *ofpacts,\n                    enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint16_t ethertype;\n    char *error;\n\n    error = str_to_u16(arg, \"pop_mpls\", &ethertype);\n    if (!error) {\n        ofpact_put_POP_MPLS(ofpacts)->ethertype = htons(ethertype);\n    }\n    return error;\n}\n\nstatic void\nformat_POP_MPLS(const struct ofpact_pop_mpls *a, struct ds *s)\n{\n    ds_put_format(s, \"%spop_mpls:%s0x%04\"PRIx16,\n                  colors.param, colors.end, ntohs(a->ethertype));\n}\n\f\n/* Set tunnel ID actions. */\n\nstatic enum ofperr\ndecode_NXAST_RAW_SET_TUNNEL(uint32_t tun_id,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    struct ofpact_tunnel *tunnel = ofpact_put_SET_TUNNEL(out);\n    tunnel->ofpact.raw = NXAST_RAW_SET_TUNNEL;\n    tunnel->tun_id = tun_id;\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_SET_TUNNEL64(uint64_t tun_id,\n                              enum ofp_version ofp_version OVS_UNUSED,\n                              struct ofpbuf *out)\n{\n    struct ofpact_tunnel *tunnel = ofpact_put_SET_TUNNEL(out);\n    tunnel->ofpact.raw = NXAST_RAW_SET_TUNNEL64;\n    tunnel->tun_id = tun_id;\n    return 0;\n}\n\nstatic void\nencode_SET_TUNNEL(const struct ofpact_tunnel *tunnel,\n                  enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    uint64_t tun_id = tunnel->tun_id;\n\n    if (ofp_version < OFP12_VERSION) {\n        if (tun_id <= UINT32_MAX\n            && tunnel->ofpact.raw != NXAST_RAW_SET_TUNNEL64) {\n            put_NXAST_SET_TUNNEL(out, tun_id);\n        } else {\n            put_NXAST_SET_TUNNEL64(out, tun_id);\n        }\n    } else {\n        put_set_field(out, ofp_version, MFF_TUN_ID, tun_id);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_set_tunnel(char *arg, struct ofpbuf *ofpacts,\n                 enum ofp_raw_action_type raw)\n{\n    struct ofpact_tunnel *tunnel;\n\n    tunnel = ofpact_put_SET_TUNNEL(ofpacts);\n    tunnel->ofpact.raw = raw;\n    return str_to_u64(arg, &tunnel->tun_id);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_TUNNEL(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return parse_set_tunnel(arg, ofpacts, NXAST_RAW_SET_TUNNEL);\n}\n\nstatic void\nformat_SET_TUNNEL(const struct ofpact_tunnel *a, struct ds *s)\n{\n    ds_put_format(s, \"%sset_tunnel%s:%s%#\"PRIx64, colors.param,\n                  (a->tun_id > UINT32_MAX\n                   || a->ofpact.raw == NXAST_RAW_SET_TUNNEL64 ? \"64\" : \"\"),\n                  colors.end, a->tun_id);\n}\n\f\n/* Set queue action. */\n\nstatic enum ofperr\ndecode_OFPAT_RAW_SET_QUEUE(uint32_t queue_id,\n                           enum ofp_version ofp_version OVS_UNUSED,\n                           struct ofpbuf *out)\n{\n    ofpact_put_SET_QUEUE(out)->queue_id = queue_id;\n    return 0;\n}\n\nstatic void\nencode_SET_QUEUE(const struct ofpact_queue *queue,\n                 enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    put_OFPAT_SET_QUEUE(out, ofp_version, queue->queue_id);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SET_QUEUE(char *arg, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return str_to_u32(arg, &ofpact_put_SET_QUEUE(ofpacts)->queue_id);\n}\n\nstatic void\nformat_SET_QUEUE(const struct ofpact_queue *a, struct ds *s)\n{\n    ds_put_format(s, \"%sset_queue:%s%\"PRIu32,\n                  colors.param, colors.end, a->queue_id);\n}\n\f\n/* Pop queue action. */\n\nstatic enum ofperr\ndecode_NXAST_RAW_POP_QUEUE(struct ofpbuf *out)\n{\n    ofpact_put_POP_QUEUE(out);\n    return 0;\n}\n\nstatic void\nencode_POP_QUEUE(const struct ofpact_null *null OVS_UNUSED,\n                 enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    put_NXAST_POP_QUEUE(out);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_POP_QUEUE(const char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_POP_QUEUE(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_POP_QUEUE(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%spop_queue%s\", colors.value, colors.end);\n}\n\f\n/* Action structure for NXAST_FIN_TIMEOUT.\n *\n * This action changes the idle timeout or hard timeout, or both, of this\n * OpenFlow rule when the rule matches a TCP packet with the FIN or RST flag.\n * When such a packet is observed, the action reduces the rule's idle timeout\n * to 'fin_idle_timeout' and its hard timeout to 'fin_hard_timeout'.  This\n * action has no effect on an existing timeout that is already shorter than the\n * one that the action specifies.  A 'fin_idle_timeout' or 'fin_hard_timeout'\n * of zero has no effect on the respective timeout.\n *\n * 'fin_idle_timeout' and 'fin_hard_timeout' are measured in seconds.\n * 'fin_hard_timeout' specifies time since the flow's creation, not since the\n * receipt of the FIN or RST.\n *\n * This is useful for quickly discarding learned TCP flows that otherwise will\n * take a long time to expire.\n *\n * This action is intended for use with an OpenFlow rule that matches only a\n * single TCP flow.  If the rule matches multiple TCP flows (e.g. it wildcards\n * all TCP traffic, or all TCP traffic to a particular port), then any FIN or\n * RST in any of those flows will cause the entire OpenFlow rule to expire\n * early, which is not normally desirable.\n */\nstruct nx_action_fin_timeout {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* 16. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_FIN_TIMEOUT. */\n    ovs_be16 fin_idle_timeout;  /* New idle timeout, if nonzero. */\n    ovs_be16 fin_hard_timeout;  /* New hard timeout, if nonzero. */\n    ovs_be16 pad;               /* Must be zero. */\n};\nOFP_ASSERT(sizeof(struct nx_action_fin_timeout) == 16);\n\nstatic enum ofperr\ndecode_NXAST_RAW_FIN_TIMEOUT(const struct nx_action_fin_timeout *naft,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             struct ofpbuf *out)\n{\n    struct ofpact_fin_timeout *oft;\n\n    oft = ofpact_put_FIN_TIMEOUT(out);\n    oft->fin_idle_timeout = ntohs(naft->fin_idle_timeout);\n    oft->fin_hard_timeout = ntohs(naft->fin_hard_timeout);\n    return 0;\n}\n\nstatic void\nencode_FIN_TIMEOUT(const struct ofpact_fin_timeout *fin_timeout,\n                   enum ofp_version ofp_version OVS_UNUSED,\n                   struct ofpbuf *out)\n{\n    struct nx_action_fin_timeout *naft = put_NXAST_FIN_TIMEOUT(out);\n    naft->fin_idle_timeout = htons(fin_timeout->fin_idle_timeout);\n    naft->fin_hard_timeout = htons(fin_timeout->fin_hard_timeout);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_FIN_TIMEOUT(char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_fin_timeout *oft = ofpact_put_FIN_TIMEOUT(ofpacts);\n    char *key, *value;\n\n    while (ofputil_parse_key_value(&arg, &key, &value)) {\n        char *error;\n\n        if (!strcmp(key, \"idle_timeout\")) {\n            error =  str_to_u16(value, key, &oft->fin_idle_timeout);\n        } else if (!strcmp(key, \"hard_timeout\")) {\n            error = str_to_u16(value, key, &oft->fin_hard_timeout);\n        } else {\n            error = xasprintf(\"invalid key '%s' in 'fin_timeout' argument\",\n                              key);\n        }\n\n        if (error) {\n            return error;\n        }\n    }\n    return NULL;\n}\n\nstatic void\nformat_FIN_TIMEOUT(const struct ofpact_fin_timeout *a, struct ds *s)\n{\n    ds_put_format(s, \"%sfin_timeout(%s\", colors.paren, colors.end);\n    if (a->fin_idle_timeout) {\n        ds_put_format(s, \"%sidle_timeout=%s%\"PRIu16\",\",\n                      colors.param, colors.end, a->fin_idle_timeout);\n    }\n    if (a->fin_hard_timeout) {\n        ds_put_format(s, \"%shard_timeout=%s%\"PRIu16\",\",\n                      colors.param, colors.end, a->fin_hard_timeout);\n    }\n    ds_chomp(s, ',');\n    ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n}\n\f\n/* Action structures for NXAST_RESUBMIT and NXAST_RESUBMIT_TABLE.\n *\n * These actions search one of the switch's flow tables:\n *\n *    - For NXAST_RESUBMIT_TABLE only, if the 'table' member is not 255, then\n *      it specifies the table to search.\n *\n *    - Otherwise (for NXAST_RESUBMIT_TABLE with a 'table' of 255, or for\n *      NXAST_RESUBMIT regardless of 'table'), it searches the current flow\n *      table, that is, the OpenFlow flow table that contains the flow from\n *      which this action was obtained.  If this action did not come from a\n *      flow table (e.g. it came from an OFPT_PACKET_OUT message), then table 0\n *      is the current table.\n *\n * The flow table lookup uses a flow that may be slightly modified from the\n * original lookup:\n *\n *    - For NXAST_RESUBMIT, the 'in_port' member of struct nx_action_resubmit\n *      is used as the flow's in_port.\n *\n *    - For NXAST_RESUBMIT_TABLE, if the 'in_port' member is not OFPP_IN_PORT,\n *      then its value is used as the flow's in_port.  Otherwise, the original\n *      in_port is used.\n *\n *    - If actions that modify the flow (e.g. OFPAT_SET_VLAN_VID) precede the\n *      resubmit action, then the flow is updated with the new values.\n *\n * Following the lookup, the original in_port is restored.\n *\n * If the modified flow matched in the flow table, then the corresponding\n * actions are executed.  Afterward, actions following the resubmit in the\n * original set of actions, if any, are executed; any changes made to the\n * packet (e.g. changes to VLAN) by secondary actions persist when those\n * actions are executed, although the original in_port is restored.\n *\n * Resubmit actions may be used any number of times within a set of actions.\n *\n * Resubmit actions may nest.  To prevent infinite loops and excessive resource\n * use, the implementation may limit nesting depth and the total number of\n * resubmits:\n *\n *    - Open vSwitch 1.0.1 and earlier did not support recursion.\n *\n *    - Open vSwitch 1.0.2 and 1.0.3 limited recursion to 8 levels.\n *\n *    - Open vSwitch 1.1 and 1.2 limited recursion to 16 levels.\n *\n *    - Open vSwitch 1.2 through 1.8 limited recursion to 32 levels.\n *\n *    - Open vSwitch 1.9 through 2.0 limited recursion to 64 levels.\n *\n *    - Open vSwitch 2.1 through 2.5 limited recursion to 64 levels and impose\n *      a total limit of 4,096 resubmits per flow translation (earlier versions\n *      did not impose any total limit).\n *\n * NXAST_RESUBMIT ignores 'table' and 'pad'.  NXAST_RESUBMIT_TABLE requires\n * 'pad' to be all-bits-zero.\n *\n * Open vSwitch 1.0.1 and earlier did not support recursion.  Open vSwitch\n * before 1.2.90 did not support NXAST_RESUBMIT_TABLE.\n */\nstruct nx_action_resubmit {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 16. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_RESUBMIT. */\n    ovs_be16 in_port;               /* New in_port for checking flow table. */\n    uint8_t table;                  /* NXAST_RESUBMIT_TABLE: table to use. */\n    uint8_t pad[3];\n};\nOFP_ASSERT(sizeof(struct nx_action_resubmit) == 16);\n\nstatic enum ofperr\ndecode_NXAST_RAW_RESUBMIT(uint16_t port,\n                          enum ofp_version ofp_version OVS_UNUSED,\n                          struct ofpbuf *out)\n{\n    struct ofpact_resubmit *resubmit;\n\n    resubmit = ofpact_put_RESUBMIT(out);\n    resubmit->ofpact.raw = NXAST_RAW_RESUBMIT;\n    resubmit->in_port = u16_to_ofp(port);\n    resubmit->table_id = 0xff;\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_RESUBMIT_TABLE(const struct nx_action_resubmit *nar,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    struct ofpact_resubmit *resubmit;\n\n    if (nar->pad[0] || nar->pad[1] || nar->pad[2]) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    resubmit = ofpact_put_RESUBMIT(out);\n    resubmit->ofpact.raw = NXAST_RAW_RESUBMIT_TABLE;\n    resubmit->in_port = u16_to_ofp(ntohs(nar->in_port));\n    resubmit->table_id = nar->table;\n    return 0;\n}\n\nstatic void\nencode_RESUBMIT(const struct ofpact_resubmit *resubmit,\n                enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    uint16_t in_port = ofp_to_u16(resubmit->in_port);\n\n    if (resubmit->table_id == 0xff\n        && resubmit->ofpact.raw != NXAST_RAW_RESUBMIT_TABLE) {\n        put_NXAST_RESUBMIT(out, in_port);\n    } else {\n        struct nx_action_resubmit *nar = put_NXAST_RESUBMIT_TABLE(out);\n        nar->table = resubmit->table_id;\n        nar->in_port = htons(in_port);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_RESUBMIT(char *arg, struct ofpbuf *ofpacts,\n               enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_resubmit *resubmit;\n    char *in_port_s, *table_s;\n\n    resubmit = ofpact_put_RESUBMIT(ofpacts);\n\n    in_port_s = strsep(&arg, \",\");\n    if (in_port_s && in_port_s[0]) {\n        if (!ofputil_port_from_string(in_port_s, &resubmit->in_port)) {\n            return xasprintf(\"%s: resubmit to unknown port\", in_port_s);\n        }\n    } else {\n        resubmit->in_port = OFPP_IN_PORT;\n    }\n\n    table_s = strsep(&arg, \",\");\n    if (table_s && table_s[0]) {\n        uint32_t table_id = 0;\n        char *error;\n\n        error = str_to_u32(table_s, &table_id);\n        if (error) {\n            return error;\n        }\n        resubmit->table_id = table_id;\n    } else {\n        resubmit->table_id = 255;\n    }\n\n    if (resubmit->in_port == OFPP_IN_PORT && resubmit->table_id == 255) {\n        return xstrdup(\"at least one \\\"in_port\\\" or \\\"table\\\" must be \"\n                       \"specified  on resubmit\");\n    }\n    return NULL;\n}\n\nstatic void\nformat_RESUBMIT(const struct ofpact_resubmit *a, struct ds *s)\n{\n    if (a->in_port != OFPP_IN_PORT && a->table_id == 255) {\n        ds_put_format(s, \"%sresubmit:%s\", colors.special, colors.end);\n        ofputil_format_port(a->in_port, s);\n    } else {\n        ds_put_format(s, \"%sresubmit(%s\", colors.paren, colors.end);\n        if (a->in_port != OFPP_IN_PORT) {\n            ofputil_format_port(a->in_port, s);\n        }\n        ds_put_char(s, ',');\n        if (a->table_id != 255) {\n            ds_put_format(s, \"%\"PRIu8, a->table_id);\n        }\n        ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n    }\n}\n\f\n/* Action structure for NXAST_LEARN.\n *\n * This action adds or modifies a flow in an OpenFlow table, similar to\n * OFPT_FLOW_MOD with OFPFC_MODIFY_STRICT as 'command'.  The new flow has the\n * specified idle timeout, hard timeout, priority, cookie, and flags.  The new\n * flow's match criteria and actions are built by applying each of the series\n * of flow_mod_spec elements included as part of the action.\n *\n * A flow_mod_spec starts with a 16-bit header.  A header that is all-bits-0 is\n * a no-op used for padding the action as a whole to a multiple of 8 bytes in\n * length.  Otherwise, the flow_mod_spec can be thought of as copying 'n_bits'\n * bits from a source to a destination.  In this case, the header contains\n * multiple fields:\n *\n *  15  14  13 12  11 10                              0\n * +------+---+------+---------------------------------+\n * |   0  |src|  dst |             n_bits              |\n * +------+---+------+---------------------------------+\n *\n * The meaning and format of a flow_mod_spec depends on 'src' and 'dst'.  The\n * following table summarizes the meaning of each possible combination.\n * Details follow the table:\n *\n *   src dst  meaning\n *   --- ---  ----------------------------------------------------------\n *    0   0   Add match criteria based on value in a field.\n *    1   0   Add match criteria based on an immediate value.\n *    0   1   Add NXAST_REG_LOAD action to copy field into a different field.\n *    1   1   Add NXAST_REG_LOAD action to load immediate value into a field.\n *    0   2   Add OFPAT_OUTPUT action to output to port from specified field.\n *   All other combinations are undefined and not allowed.\n *\n * The flow_mod_spec header is followed by a source specification and a\n * destination specification.  The format and meaning of the source\n * specification depends on 'src':\n *\n *   - If 'src' is 0, the source bits are taken from a field in the flow to\n *     which this action is attached.  (This should be a wildcarded field.  If\n *     its value is fully specified then the source bits being copied have\n *     constant values.)\n *\n *     The source specification is an ovs_be32 'field' and an ovs_be16 'ofs'.\n *     'field' is an nxm_header with nxm_hasmask=0, and 'ofs' the starting bit\n *     offset within that field.  The source bits are field[ofs:ofs+n_bits-1].\n *     'field' and 'ofs' are subject to the same restrictions as the source\n *     field in NXAST_REG_MOVE.\n *\n *   - If 'src' is 1, the source bits are a constant value.  The source\n *     specification is (n_bits+15)/16*2 bytes long.  Taking those bytes as a\n *     number in network order, the source bits are the 'n_bits'\n *     least-significant bits.  The switch will report an error if other bits\n *     in the constant are nonzero.\n *\n * The flow_mod_spec destination specification, for 'dst' of 0 or 1, is an\n * ovs_be32 'field' and an ovs_be16 'ofs'.  'field' is an nxm_header with\n * nxm_hasmask=0 and 'ofs' is a starting bit offset within that field.  The\n * meaning of the flow_mod_spec depends on 'dst':\n *\n *   - If 'dst' is 0, the flow_mod_spec specifies match criteria for the new\n *     flow.  The new flow matches only if bits field[ofs:ofs+n_bits-1] in a\n *     packet equal the source bits.  'field' may be any nxm_header with\n *     nxm_hasmask=0 that is allowed in NXT_FLOW_MOD.\n *\n *     Order is significant.  Earlier flow_mod_specs must satisfy any\n *     prerequisites for matching fields specified later, by copying constant\n *     values into prerequisite fields.\n *\n *     The switch will reject flow_mod_specs that do not satisfy NXM masking\n *     restrictions.\n *\n *   - If 'dst' is 1, the flow_mod_spec specifies an NXAST_REG_LOAD action for\n *     the new flow.  The new flow copies the source bits into\n *     field[ofs:ofs+n_bits-1].  Actions are executed in the same order as the\n *     flow_mod_specs.\n *\n *     A single NXAST_REG_LOAD action writes no more than 64 bits, so n_bits\n *     greater than 64 yields multiple NXAST_REG_LOAD actions.\n *\n * The flow_mod_spec destination spec for 'dst' of 2 (when 'src' is 0) is\n * empty.  It has the following meaning:\n *\n *   - The flow_mod_spec specifies an OFPAT_OUTPUT action for the new flow.\n *     The new flow outputs to the OpenFlow port specified by the source field.\n *     Of the special output ports with value OFPP_MAX or larger, OFPP_IN_PORT,\n *     OFPP_FLOOD, OFPP_LOCAL, and OFPP_ALL are supported.  Other special ports\n *     may not be used.\n *\n * Resource Management\n * -------------------\n *\n * A switch has a finite amount of flow table space available for learning.\n * When this space is exhausted, no new learning table entries will be learned\n * until some existing flow table entries expire.  The controller should be\n * prepared to handle this by flooding (which can be implemented as a\n * low-priority flow).\n *\n * If a learned flow matches a single TCP stream with a relatively long\n * timeout, one may make the best of resource constraints by setting\n * 'fin_idle_timeout' or 'fin_hard_timeout' (both measured in seconds), or\n * both, to shorter timeouts.  When either of these is specified as a nonzero\n * value, OVS adds a NXAST_FIN_TIMEOUT action, with the specified timeouts, to\n * the learned flow.\n *\n * Examples\n * --------\n *\n * The following examples give a prose description of the flow_mod_specs along\n * with informal notation for how those would be represented and a hex dump of\n * the bytes that would be required.\n *\n * These examples could work with various nx_action_learn parameters.  Typical\n * values would be idle_timeout=OFP_FLOW_PERMANENT, hard_timeout=60,\n * priority=OFP_DEFAULT_PRIORITY, flags=0, table_id=10.\n *\n * 1. Learn input port based on the source MAC, with lookup into\n *    NXM_NX_REG1[16:31] by resubmit to in_port=99:\n *\n *    Match on in_port=99:\n *       ovs_be16(src=1, dst=0, n_bits=16),               20 10\n *       ovs_be16(99),                                    00 63\n *       ovs_be32(NXM_OF_IN_PORT), ovs_be16(0)            00 00 00 02 00 00\n *\n *    Match Ethernet destination on Ethernet source from packet:\n *       ovs_be16(src=0, dst=0, n_bits=48),               00 30\n *       ovs_be32(NXM_OF_ETH_SRC), ovs_be16(0)            00 00 04 06 00 00\n *       ovs_be32(NXM_OF_ETH_DST), ovs_be16(0)            00 00 02 06 00 00\n *\n *    Set NXM_NX_REG1[16:31] to the packet's input port:\n *       ovs_be16(src=0, dst=1, n_bits=16),               08 10\n *       ovs_be32(NXM_OF_IN_PORT), ovs_be16(0)            00 00 00 02 00 00\n *       ovs_be32(NXM_NX_REG1), ovs_be16(16)              00 01 02 04 00 10\n *\n *    Given a packet that arrived on port A with Ethernet source address B,\n *    this would set up the flow \"in_port=99, dl_dst=B,\n *    actions=load:A->NXM_NX_REG1[16..31]\".\n *\n *    In syntax accepted by ovs-ofctl, this action is: learn(in_port=99,\n *    NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],\n *    load:NXM_OF_IN_PORT[]->NXM_NX_REG1[16..31])\n *\n * 2. Output to input port based on the source MAC and VLAN VID, with lookup\n *    into NXM_NX_REG1[16:31]:\n *\n *    Match on same VLAN ID as packet:\n *       ovs_be16(src=0, dst=0, n_bits=12),               00 0c\n *       ovs_be32(NXM_OF_VLAN_TCI), ovs_be16(0)           00 00 08 02 00 00\n *       ovs_be32(NXM_OF_VLAN_TCI), ovs_be16(0)           00 00 08 02 00 00\n *\n *    Match Ethernet destination on Ethernet source from packet:\n *       ovs_be16(src=0, dst=0, n_bits=48),               00 30\n *       ovs_be32(NXM_OF_ETH_SRC), ovs_be16(0)            00 00 04 06 00 00\n *       ovs_be32(NXM_OF_ETH_DST), ovs_be16(0)            00 00 02 06 00 00\n *\n *    Output to the packet's input port:\n *       ovs_be16(src=0, dst=2, n_bits=16),               10 10\n *       ovs_be32(NXM_OF_IN_PORT), ovs_be16(0)            00 00 00 02 00 00\n *\n *    Given a packet that arrived on port A with Ethernet source address B in\n *    VLAN C, this would set up the flow \"dl_dst=B, vlan_vid=C,\n *    actions=output:A\".\n *\n *    In syntax accepted by ovs-ofctl, this action is:\n *    learn(NXM_OF_VLAN_TCI[0..11], NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],\n *    output:NXM_OF_IN_PORT[])\n *\n * 3. Here's a recipe for a very simple-minded MAC learning switch.  It uses a\n *    10-second MAC expiration time to make it easier to see what's going on\n *\n *      ovs-vsctl del-controller br0\n *      ovs-ofctl del-flows br0\n *      ovs-ofctl add-flow br0 \"table=0 actions=learn(table=1, \\\n          hard_timeout=10, NXM_OF_VLAN_TCI[0..11],             \\\n          NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],                   \\\n          output:NXM_OF_IN_PORT[]), resubmit(,1)\"\n *      ovs-ofctl add-flow br0 \"table=1 priority=0 actions=flood\"\n *\n *    You can then dump the MAC learning table with:\n *\n *      ovs-ofctl dump-flows br0 table=1\n *\n * Usage Advice\n * ------------\n *\n * For best performance, segregate learned flows into a table that is not used\n * for any other flows except possibly for a lowest-priority \"catch-all\" flow\n * (a flow with no match criteria).  If different learning actions specify\n * different match criteria, use different tables for the learned flows.\n *\n * The meaning of 'hard_timeout' and 'idle_timeout' can be counterintuitive.\n * These timeouts apply to the flow that is added, which means that a flow with\n * an idle timeout will expire when no traffic has been sent *to* the learned\n * address.  This is not usually the intent in MAC learning; instead, we want\n * the MAC learn entry to expire when no traffic has been sent *from* the\n * learned address.  Use a hard timeout for that.\n *\n *\n * Visibility of Changes\n * ---------------------\n *\n * Prior to Open vSwitch 2.4, any changes made by a \"learn\" action in a given\n * flow translation are visible to flow table lookups made later in the flow\n * translation.  This means that, in the example above, a MAC learned by the\n * learn action in table 0 would be found in table 1 (if the packet being\n * processed had the same source and destination MAC address).\n *\n * In Open vSwitch 2.4 and later, changes to a flow table (whether to add or\n * modify a flow) by a \"learn\" action are visible only for later flow\n * translations, not for later lookups within the same flow translation.  In\n * the MAC learning example, a MAC learned by the learn action in table 0 would\n * not be found in table 1 if the flow translation would resubmit to table 1\n * after the processing of the learn action, meaning that if this MAC had not\n * been learned before then the packet would be flooded. */\nstruct nx_action_learn {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* At least 24. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_LEARN. */\n    ovs_be16 idle_timeout;      /* Idle time before discarding (seconds). */\n    ovs_be16 hard_timeout;      /* Max time before discarding (seconds). */\n    ovs_be16 priority;          /* Priority level of flow entry. */\n    ovs_be64 cookie;            /* Cookie for new flow. */\n    ovs_be16 flags;             /* NX_LEARN_F_*. */\n    uint8_t table_id;           /* Table to insert flow entry. */\n    uint8_t pad;                /* Must be zero. */\n    ovs_be16 fin_idle_timeout;  /* Idle timeout after FIN, if nonzero. */\n    ovs_be16 fin_hard_timeout;  /* Hard timeout after FIN, if nonzero. */\n    /* Followed by a sequence of flow_mod_spec elements, as described above,\n     * until the end of the action is reached. */\n};\nOFP_ASSERT(sizeof(struct nx_action_learn) == 32);\n\nstatic ovs_be16\nget_be16(const void **pp)\n{\n    const ovs_be16 *p = *pp;\n    ovs_be16 value = *p;\n    *pp = p + 1;\n    return value;\n}\n\nstatic ovs_be32\nget_be32(const void **pp)\n{\n    const ovs_be32 *p = *pp;\n    ovs_be32 value = get_unaligned_be32(p);\n    *pp = p + 1;\n    return value;\n}\n\nstatic enum ofperr\nget_subfield(int n_bits, const void **p, struct mf_subfield *sf,\n             const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap)\n{\n    enum ofperr error;\n\n    error = mf_vl_mff_mf_from_nxm_header(ntohl(get_be32(p)), vl_mff_map,\n                                         &sf->field, tlv_bitmap);\n    sf->ofs = ntohs(get_be16(p));\n    sf->n_bits = n_bits;\n    return error;\n}\n\nstatic unsigned int\nlearn_min_len(uint16_t header)\n{\n    int n_bits = header & NX_LEARN_N_BITS_MASK;\n    int src_type = header & NX_LEARN_SRC_MASK;\n    int dst_type = header & NX_LEARN_DST_MASK;\n    unsigned int min_len;\n\n    min_len = 0;\n    if (src_type == NX_LEARN_SRC_FIELD) {\n        min_len += sizeof(ovs_be32); /* src_field */\n        min_len += sizeof(ovs_be16); /* src_ofs */\n    } else {\n        min_len += DIV_ROUND_UP(n_bits, 16);\n    }\n    if (dst_type == NX_LEARN_DST_MATCH ||\n        dst_type == NX_LEARN_DST_LOAD) {\n        min_len += sizeof(ovs_be32); /* dst_field */\n        min_len += sizeof(ovs_be16); /* dst_ofs */\n    }\n    return min_len;\n}\n\n/* Converts 'nal' into a \"struct ofpact_learn\" and appends that struct to\n * 'ofpacts'.  Returns 0 if successful, otherwise an OFPERR_*. */\nstatic enum ofperr\ndecode_NXAST_RAW_LEARN(const struct nx_action_learn *nal,\n                       enum ofp_version ofp_version OVS_UNUSED,\n                       const struct vl_mff_map *vl_mff_map,\n                       uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpact_learn *learn;\n    const void *p, *end;\n\n    if (nal->pad) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    learn = ofpact_put_LEARN(ofpacts);\n\n    learn->idle_timeout = ntohs(nal->idle_timeout);\n    learn->hard_timeout = ntohs(nal->hard_timeout);\n    learn->priority = ntohs(nal->priority);\n    learn->cookie = nal->cookie;\n    learn->table_id = nal->table_id;\n    learn->fin_idle_timeout = ntohs(nal->fin_idle_timeout);\n    learn->fin_hard_timeout = ntohs(nal->fin_hard_timeout);\n\n    learn->flags = ntohs(nal->flags);\n    if (learn->flags & ~(NX_LEARN_F_SEND_FLOW_REM |\n                         NX_LEARN_F_DELETE_LEARNED)) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    if (learn->table_id == 0xff) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    end = (char *) nal + ntohs(nal->len);\n    for (p = nal + 1; p != end; ) {\n        struct ofpact_learn_spec *spec;\n        uint16_t header = ntohs(get_be16(&p));\n\n        if (!header) {\n            break;\n        }\n\n        spec = ofpbuf_put_zeros(ofpacts, sizeof *spec);\n        learn = ofpacts->header;\n\n        spec->src_type = header & NX_LEARN_SRC_MASK;\n        spec->dst_type = header & NX_LEARN_DST_MASK;\n        spec->n_bits = header & NX_LEARN_N_BITS_MASK;\n\n        /* Check for valid src and dst type combination. */\n        if (spec->dst_type == NX_LEARN_DST_MATCH ||\n            spec->dst_type == NX_LEARN_DST_LOAD ||\n            (spec->dst_type == NX_LEARN_DST_OUTPUT &&\n             spec->src_type == NX_LEARN_SRC_FIELD)) {\n            /* OK. */\n        } else {\n            return OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n\n        /* Check that the arguments don't overrun the end of the action. */\n        if ((char *) end - (char *) p < learn_min_len(header)) {\n            return OFPERR_OFPBAC_BAD_LEN;\n        }\n\n        /* Get the source. */\n        const uint8_t *imm = NULL;\n        unsigned int imm_bytes = 0;\n        enum ofperr error;\n        if (spec->src_type == NX_LEARN_SRC_FIELD) {\n            error = get_subfield(spec->n_bits, &p, &spec->src, vl_mff_map,\n                                 tlv_bitmap);\n            if (error) {\n                return error;\n            }\n        } else {\n            int p_bytes = 2 * DIV_ROUND_UP(spec->n_bits, 16);\n            p = (const uint8_t *) p + p_bytes;\n\n            imm_bytes = DIV_ROUND_UP(spec->n_bits, 8);\n            imm = (const uint8_t *) p - imm_bytes;\n        }\n\n        /* Get the destination. */\n        if (spec->dst_type == NX_LEARN_DST_MATCH ||\n            spec->dst_type == NX_LEARN_DST_LOAD) {\n            error = get_subfield(spec->n_bits, &p, &spec->dst, vl_mff_map,\n                                 tlv_bitmap);\n            if (error) {\n                return error;\n            }\n        }\n\n        if (imm) {\n            uint8_t *src_imm = ofpbuf_put_zeros(ofpacts,\n                                                OFPACT_ALIGN(imm_bytes));\n            memcpy(src_imm, imm, imm_bytes);\n\n            learn = ofpacts->header;\n        }\n    }\n    ofpact_finish_LEARN(ofpacts, &learn);\n\n    if (!is_all_zeros(p, (char *) end - (char *) p)) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    return 0;\n}\n\nstatic void\nput_be16(struct ofpbuf *b, ovs_be16 x)\n{\n    ofpbuf_put(b, &x, sizeof x);\n}\n\nstatic void\nput_be32(struct ofpbuf *b, ovs_be32 x)\n{\n    ofpbuf_put(b, &x, sizeof x);\n}\n\nstatic void\nput_u16(struct ofpbuf *b, uint16_t x)\n{\n    put_be16(b, htons(x));\n}\n\nstatic void\nput_u32(struct ofpbuf *b, uint32_t x)\n{\n    put_be32(b, htonl(x));\n}\n\nstatic void\nencode_LEARN(const struct ofpact_learn *learn,\n             enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    const struct ofpact_learn_spec *spec;\n    struct nx_action_learn *nal;\n    size_t start_ofs;\n\n    start_ofs = out->size;\n    nal = put_NXAST_LEARN(out);\n    nal->idle_timeout = htons(learn->idle_timeout);\n    nal->hard_timeout = htons(learn->hard_timeout);\n    nal->fin_idle_timeout = htons(learn->fin_idle_timeout);\n    nal->fin_hard_timeout = htons(learn->fin_hard_timeout);\n    nal->priority = htons(learn->priority);\n    nal->cookie = learn->cookie;\n    nal->flags = htons(learn->flags);\n    nal->table_id = learn->table_id;\n\n    OFPACT_LEARN_SPEC_FOR_EACH (spec, learn) {\n        put_u16(out, spec->n_bits | spec->dst_type | spec->src_type);\n\n        if (spec->src_type == NX_LEARN_SRC_FIELD) {\n            put_u32(out, nxm_header_from_mff(spec->src.field));\n            put_u16(out, spec->src.ofs);\n        } else {\n            size_t n_dst_bytes = 2 * DIV_ROUND_UP(spec->n_bits, 16);\n            uint8_t *bits = ofpbuf_put_zeros(out, n_dst_bytes);\n            unsigned int n_bytes = DIV_ROUND_UP(spec->n_bits, 8);\n\n            memcpy(bits + n_dst_bytes - n_bytes, ofpact_learn_spec_imm(spec),\n                   n_bytes);\n        }\n\n        if (spec->dst_type == NX_LEARN_DST_MATCH ||\n            spec->dst_type == NX_LEARN_DST_LOAD) {\n            put_u32(out, nxm_header_from_mff(spec->dst.field));\n            put_u16(out, spec->dst.ofs);\n        }\n    }\n\n    pad_ofpat(out, start_ofs);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_LEARN(char *arg, struct ofpbuf *ofpacts,\n            enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return learn_parse(arg, ofpacts);\n}\n\nstatic void\nformat_LEARN(const struct ofpact_learn *a, struct ds *s)\n{\n    learn_format(a, s);\n}\n\f\n/* Action structure for NXAST_CONJUNCTION. */\nstruct nx_action_conjunction {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* At least 16. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* See enum ofp_raw_action_type. */\n    uint8_t clause;\n    uint8_t n_clauses;\n    ovs_be32 id;\n};\nOFP_ASSERT(sizeof(struct nx_action_conjunction) == 16);\n\nstatic void\nadd_conjunction(struct ofpbuf *out,\n                uint32_t id, uint8_t clause, uint8_t n_clauses)\n{\n    struct ofpact_conjunction *oc;\n\n    oc = ofpact_put_CONJUNCTION(out);\n    oc->id = id;\n    oc->clause = clause;\n    oc->n_clauses = n_clauses;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_CONJUNCTION(const struct nx_action_conjunction *nac,\n                             enum ofp_version ofp_version OVS_UNUSED,\n                             struct ofpbuf *out)\n{\n    if (nac->n_clauses < 2 || nac->n_clauses > 64\n        || nac->clause >= nac->n_clauses) {\n        return OFPERR_NXBAC_BAD_CONJUNCTION;\n    } else {\n        add_conjunction(out, ntohl(nac->id), nac->clause, nac->n_clauses);\n        return 0;\n    }\n}\n\nstatic void\nencode_CONJUNCTION(const struct ofpact_conjunction *oc,\n                   enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    struct nx_action_conjunction *nac = put_NXAST_CONJUNCTION(out);\n    nac->clause = oc->clause;\n    nac->n_clauses = oc->n_clauses;\n    nac->id = htonl(oc->id);\n}\n\nstatic void\nformat_CONJUNCTION(const struct ofpact_conjunction *oc, struct ds *s)\n{\n    ds_put_format(s, \"%sconjunction(%s%\"PRIu32\",%\"PRIu8\"/%\"PRIu8\"%s)%s\",\n                  colors.paren, colors.end,\n                  oc->id, oc->clause + 1, oc->n_clauses,\n                  colors.paren, colors.end);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_CONJUNCTION(const char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint8_t n_clauses;\n    uint8_t clause;\n    uint32_t id;\n    int n;\n\n    if (!ovs_scan(arg, \"%\"SCNi32\" , %\"SCNu8\" / %\"SCNu8\" %n\",\n                  &id, &clause, &n_clauses, &n) || n != strlen(arg)) {\n        return xstrdup(\"\\\"conjunction\\\" syntax is \\\"conjunction(id,i/n)\\\"\");\n    }\n\n    if (n_clauses < 2) {\n        return xstrdup(\"conjunction must have at least 2 clauses\");\n    } else if (n_clauses > 64) {\n        return xstrdup(\"conjunction must have at most 64 clauses\");\n    } else if (clause < 1) {\n        return xstrdup(\"clause index must be positive\");\n    } else if (clause > n_clauses) {\n        return xstrdup(\"clause index must be less than or equal to \"\n                       \"number of clauses\");\n    }\n\n    add_conjunction(ofpacts, id, clause - 1, n_clauses);\n    return NULL;\n}\n\f\n/* Action structure for NXAST_MULTIPATH.\n *\n * This action performs the following steps in sequence:\n *\n *    1. Hashes the fields designated by 'fields', one of NX_HASH_FIELDS_*.\n *       Refer to the definition of \"enum nx_mp_fields\" for details.\n *\n *       The 'basis' value is used as a universal hash parameter, that is,\n *       different values of 'basis' yield different hash functions.  The\n *       particular universal hash function used is implementation-defined.\n *\n *       The hashed fields' values are drawn from the current state of the\n *       flow, including all modifications that have been made by actions up to\n *       this point.\n *\n *    2. Applies the multipath link choice algorithm specified by 'algorithm',\n *       one of NX_MP_ALG_*.  Refer to the definition of \"enum nx_mp_algorithm\"\n *       for details.\n *\n *       The output of the algorithm is 'link', an unsigned integer less than\n *       or equal to 'max_link'.\n *\n *       Some algorithms use 'arg' as an additional argument.\n *\n *    3. Stores 'link' in dst[ofs:ofs+n_bits].  The format and semantics of\n *       'dst' and 'ofs_nbits' are similar to those for the NXAST_REG_LOAD\n *       action.\n *\n * The switch will reject actions that have an unknown 'fields', or an unknown\n * 'algorithm', or in which ofs+n_bits is greater than the width of 'dst', or\n * in which 'max_link' is greater than or equal to 2**n_bits, with error type\n * OFPET_BAD_ACTION, code OFPBAC_BAD_ARGUMENT.\n */\nstruct nx_action_multipath {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* Length is 32. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_MULTIPATH. */\n\n    /* What fields to hash and how. */\n    ovs_be16 fields;            /* One of NX_HASH_FIELDS_*. */\n    ovs_be16 basis;             /* Universal hash parameter. */\n    ovs_be16 pad0;\n\n    /* Multipath link choice algorithm to apply to hash value. */\n    ovs_be16 algorithm;         /* One of NX_MP_ALG_*. */\n    ovs_be16 max_link;          /* Number of output links, minus 1. */\n    ovs_be32 arg;               /* Algorithm-specific argument. */\n    ovs_be16 pad1;\n\n    /* Where to store the result. */\n    ovs_be16 ofs_nbits;         /* (ofs << 6) | (n_bits - 1). */\n    ovs_be32 dst;               /* Destination. */\n};\nOFP_ASSERT(sizeof(struct nx_action_multipath) == 32);\n\nstatic enum ofperr\ndecode_NXAST_RAW_MULTIPATH(const struct nx_action_multipath *nam,\n                           enum ofp_version ofp_version OVS_UNUSED,\n                           const struct vl_mff_map *vl_mff_map,\n                           uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    uint32_t n_links = ntohs(nam->max_link) + 1;\n    size_t min_n_bits = log_2_ceil(n_links);\n    struct ofpact_multipath *mp;\n    enum ofperr error;\n\n    mp = ofpact_put_MULTIPATH(out);\n    mp->fields = ntohs(nam->fields);\n    mp->basis = ntohs(nam->basis);\n    mp->algorithm = ntohs(nam->algorithm);\n    mp->max_link = ntohs(nam->max_link);\n    mp->arg = ntohl(nam->arg);\n    mp->dst.ofs = nxm_decode_ofs(nam->ofs_nbits);\n    mp->dst.n_bits = nxm_decode_n_bits(nam->ofs_nbits);\n    error = mf_vl_mff_mf_from_nxm_header(ntohl(nam->dst), vl_mff_map,\n                                         &mp->dst.field, tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    if (!flow_hash_fields_valid(mp->fields)) {\n        VLOG_WARN_RL(&rl, \"unsupported fields %d\", (int) mp->fields);\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else if (mp->algorithm != NX_MP_ALG_MODULO_N\n               && mp->algorithm != NX_MP_ALG_HASH_THRESHOLD\n               && mp->algorithm != NX_MP_ALG_HRW\n               && mp->algorithm != NX_MP_ALG_ITER_HASH) {\n        VLOG_WARN_RL(&rl, \"unsupported algorithm %d\", (int) mp->algorithm);\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else if (mp->dst.n_bits < min_n_bits) {\n        VLOG_WARN_RL(&rl, \"multipath action requires at least %\"PRIuSIZE\" bits for \"\n                     \"%\"PRIu32\" links\", min_n_bits, n_links);\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    return multipath_check(mp, NULL);\n}\n\nstatic void\nencode_MULTIPATH(const struct ofpact_multipath *mp,\n                 enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    struct nx_action_multipath *nam = put_NXAST_MULTIPATH(out);\n\n    nam->fields = htons(mp->fields);\n    nam->basis = htons(mp->basis);\n    nam->algorithm = htons(mp->algorithm);\n    nam->max_link = htons(mp->max_link);\n    nam->arg = htonl(mp->arg);\n    nam->ofs_nbits = nxm_encode_ofs_nbits(mp->dst.ofs, mp->dst.n_bits);\n    nam->dst = htonl(nxm_header_from_mff(mp->dst.field));\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_MULTIPATH(const char *arg, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return multipath_parse(ofpact_put_MULTIPATH(ofpacts), arg);\n}\n\nstatic void\nformat_MULTIPATH(const struct ofpact_multipath *a, struct ds *s)\n{\n    multipath_format(a, s);\n}\n\f\n/* Action structure for NXAST_NOTE.\n *\n * This action has no effect.  It is variable length.  The switch does not\n * attempt to interpret the user-defined 'note' data in any way.  A controller\n * can use this action to attach arbitrary metadata to a flow.\n *\n * This action might go away in the future.\n */\nstruct nx_action_note {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* A multiple of 8, but at least 16. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_NOTE. */\n    uint8_t note[6];                /* Start of user-defined data. */\n    /* Possibly followed by additional user-defined data. */\n};\nOFP_ASSERT(sizeof(struct nx_action_note) == 16);\n\nstatic enum ofperr\ndecode_NXAST_RAW_NOTE(const struct nx_action_note *nan,\n                      enum ofp_version ofp_version OVS_UNUSED,\n                      struct ofpbuf *out)\n{\n    struct ofpact_note *note;\n    unsigned int length;\n\n    length = ntohs(nan->len) - offsetof(struct nx_action_note, note);\n    note = ofpact_put_NOTE(out);\n    note->length = length;\n    ofpbuf_put(out, nan->note, length);\n    note = out->header;\n    ofpact_finish_NOTE(out, &note);\n\n    return 0;\n}\n\nstatic void\nencode_NOTE(const struct ofpact_note *note,\n            enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    size_t start_ofs = out->size;\n    struct nx_action_note *nan;\n\n    put_NXAST_NOTE(out);\n    out->size = out->size - sizeof nan->note;\n\n    ofpbuf_put(out, note->data, note->length);\n    pad_ofpat(out, start_ofs);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_NOTE(const char *arg, struct ofpbuf *ofpacts,\n           enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    size_t start_ofs = ofpacts->size;\n    ofpact_put_NOTE(ofpacts);\n    arg = ofpbuf_put_hex(ofpacts, arg, NULL);\n    if (arg[0]) {\n        return xstrdup(\"bad hex digit in `note' argument\");\n    }\n    struct ofpact_note *note = ofpbuf_at_assert(ofpacts, start_ofs,\n                                                sizeof *note);\n    note->length = ofpacts->size - (start_ofs + sizeof *note);\n    ofpact_finish_NOTE(ofpacts, &note);\n    return NULL;\n}\n\nstatic void\nformat_NOTE(const struct ofpact_note *a, struct ds *s)\n{\n    ds_put_format(s, \"%snote:%s\", colors.param, colors.end);\n    format_hex_arg(s, a->data, a->length);\n}\n\f\n/* Exit action. */\n\nstatic enum ofperr\ndecode_NXAST_RAW_EXIT(struct ofpbuf *out)\n{\n    ofpact_put_EXIT(out);\n    return 0;\n}\n\nstatic void\nencode_EXIT(const struct ofpact_null *null OVS_UNUSED,\n            enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    put_NXAST_EXIT(out);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_EXIT(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n           enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_EXIT(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_EXIT(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%sexit%s\", colors.special, colors.end);\n}\n\f\n/* Unroll xlate action. */\n\nstatic void\nencode_UNROLL_XLATE(const struct ofpact_unroll_xlate *unroll OVS_UNUSED,\n                    enum ofp_version ofp_version OVS_UNUSED,\n                    struct ofpbuf *out OVS_UNUSED)\n{\n    OVS_NOT_REACHED();\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_UNROLL_XLATE(char *arg OVS_UNUSED, struct ofpbuf *ofpacts OVS_UNUSED,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    OVS_NOT_REACHED();\n    return NULL;\n}\n\nstatic void\nformat_UNROLL_XLATE(const struct ofpact_unroll_xlate *a, struct ds *s)\n{\n    ds_put_format(s, \"%sunroll_xlate(%s%stable=%s%\"PRIu8\n                  \", %scookie=%s%\"PRIu64\"%s)%s\",\n                  colors.paren,   colors.end,\n                  colors.special, colors.end, a->rule_table_id,\n                  colors.param,   colors.end, ntohll(a->rule_cookie),\n                  colors.paren,   colors.end);\n}\n\f\n/* The NXAST_CLONE action is \"struct ext_action_header\", followed by zero or\n * more embedded OpenFlow actions. */\n\nstatic enum ofperr\ndecode_NXAST_RAW_CLONE(const struct ext_action_header *eah,\n                       enum ofp_version ofp_version,\n                       const struct vl_mff_map *vl_mff_map,\n                       uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    int error;\n    struct ofpbuf openflow;\n    const size_t clone_offset = ofpacts_pull(out);\n    struct ofpact_nest *clone = ofpact_put_CLONE(out);\n\n    /* decode action list */\n    ofpbuf_pull(out, sizeof(*clone));\n    openflow = ofpbuf_const_initializer(\n                    eah + 1, ntohs(eah->len) - sizeof *eah);\n    error = ofpacts_pull_openflow_actions__(&openflow, openflow.size,\n                                            ofp_version,\n                                            1u << OVSINST_OFPIT11_APPLY_ACTIONS,\n                                            out, 0, vl_mff_map, tlv_bitmap);\n    clone = ofpbuf_push_uninit(out, sizeof *clone);\n    out->header = &clone->ofpact;\n    ofpact_finish_CLONE(out, &clone);\n    ofpbuf_push_uninit(out, clone_offset);\n    return error;\n}\n\nstatic void\nencode_CLONE(const struct ofpact_nest *clone,\n              enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    size_t len;\n    const size_t ofs = out->size;\n    struct ext_action_header *eah;\n\n    eah = put_NXAST_CLONE(out);\n    len = ofpacts_put_openflow_actions(clone->actions,\n                                       ofpact_nest_get_action_len(clone),\n                                       out, ofp_version);\n    len += sizeof *eah;\n    eah = ofpbuf_at(out, ofs, sizeof *eah);\n    eah->len = htons(len);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_CLONE(char *arg, struct ofpbuf *ofpacts,\n             enum ofputil_protocol *usable_protocols)\n{\n    const size_t clone_offset = ofpacts_pull(ofpacts);\n    struct ofpact_nest *clone = ofpact_put_CLONE(ofpacts);\n    char *error;\n\n    ofpbuf_pull(ofpacts, sizeof *clone);\n    error = ofpacts_parse_copy(arg, ofpacts, usable_protocols, false, 0);\n    /* header points to the action list */\n    ofpacts->header = ofpbuf_push_uninit(ofpacts, sizeof *clone);\n    clone = ofpacts->header;\n\n    ofpact_finish_CLONE(ofpacts, &clone);\n    ofpbuf_push_uninit(ofpacts, clone_offset);\n    return error;\n}\n\nstatic void\nformat_CLONE(const struct ofpact_nest *a, struct ds *s)\n{\n    ds_put_format(s, \"%sclone(%s\", colors.paren, colors.end);\n    ofpacts_format(a->actions, ofpact_nest_get_action_len(a), s);\n    ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n}\n\f\n/* Action structure for NXAST_SAMPLE.\n *\n * Samples matching packets with the given probability and sends them\n * each to the set of collectors identified with the given ID.  The\n * probability is expressed as a number of packets to be sampled out\n * of USHRT_MAX packets, and must be >0.\n *\n * When sending packet samples to IPFIX collectors, the IPFIX flow\n * record sent for each sampled packet is associated with the given\n * observation domain ID and observation point ID.  Each IPFIX flow\n * record contain the sampled packet's headers when executing this\n * rule.  If a sampled packet's headers are modified by previous\n * actions in the flow, those modified headers are sent. */\nstruct nx_action_sample {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 24. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_SAMPLE. */\n    ovs_be16 probability;           /* Fraction of packets to sample. */\n    ovs_be32 collector_set_id;      /* ID of collector set in OVSDB. */\n    ovs_be32 obs_domain_id;         /* ID of sampling observation domain. */\n    ovs_be32 obs_point_id;          /* ID of sampling observation point. */\n};\nOFP_ASSERT(sizeof(struct nx_action_sample) == 24);\n\n/* Action structure for NXAST_SAMPLE2 and NXAST_SAMPLE3.\n *\n * NXAST_SAMPLE2 was added in Open vSwitch 2.5.90.  Compared to NXAST_SAMPLE,\n * it adds support for exporting egress tunnel information.\n *\n * NXAST_SAMPLE3 was added in Open vSwitch 2.6.90.  Compared to NXAST_SAMPLE2,\n * it adds support for the 'direction' field. */\nstruct nx_action_sample2 {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 32. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_SAMPLE. */\n    ovs_be16 probability;           /* Fraction of packets to sample. */\n    ovs_be32 collector_set_id;      /* ID of collector set in OVSDB. */\n    ovs_be32 obs_domain_id;         /* ID of sampling observation domain. */\n    ovs_be32 obs_point_id;          /* ID of sampling observation point. */\n    ovs_be16 sampling_port;         /* Sampling port. */\n    uint8_t  direction;             /* NXAST_SAMPLE3 only. */\n    uint8_t  zeros[5];              /* Pad to a multiple of 8 bytes */\n };\n OFP_ASSERT(sizeof(struct nx_action_sample2) == 32);\n\nstatic enum ofperr\ndecode_NXAST_RAW_SAMPLE(const struct nx_action_sample *nas,\n                        enum ofp_version ofp_version OVS_UNUSED,\n                        struct ofpbuf *out)\n{\n    struct ofpact_sample *sample;\n\n    sample = ofpact_put_SAMPLE(out);\n    sample->ofpact.raw = NXAST_RAW_SAMPLE;\n    sample->probability = ntohs(nas->probability);\n    sample->collector_set_id = ntohl(nas->collector_set_id);\n    sample->obs_domain_id = ntohl(nas->obs_domain_id);\n    sample->obs_point_id = ntohl(nas->obs_point_id);\n    sample->sampling_port = OFPP_NONE;\n    sample->direction = NX_ACTION_SAMPLE_DEFAULT;\n\n    if (sample->probability == 0) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\ndecode_SAMPLE2(const struct nx_action_sample2 *nas,\n               enum ofp_raw_action_type raw,\n               enum nx_action_sample_direction direction,\n               struct ofpact_sample *sample)\n{\n    sample->ofpact.raw = raw;\n    sample->probability = ntohs(nas->probability);\n    sample->collector_set_id = ntohl(nas->collector_set_id);\n    sample->obs_domain_id = ntohl(nas->obs_domain_id);\n    sample->obs_point_id = ntohl(nas->obs_point_id);\n    sample->sampling_port = u16_to_ofp(ntohs(nas->sampling_port));\n    sample->direction = direction;\n\n    if (sample->probability == 0) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_SAMPLE2(const struct nx_action_sample2 *nas,\n                         enum ofp_version ofp_version OVS_UNUSED,\n                         struct ofpbuf *out)\n{\n    return decode_SAMPLE2(nas, NXAST_RAW_SAMPLE2, NX_ACTION_SAMPLE_DEFAULT,\n                          ofpact_put_SAMPLE(out));\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_SAMPLE3(const struct nx_action_sample2 *nas,\n                         enum ofp_version ofp_version OVS_UNUSED,\n                         struct ofpbuf *out)\n{\n    struct ofpact_sample *sample = ofpact_put_SAMPLE(out);\n    if (!is_all_zeros(nas->zeros, sizeof nas->zeros)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n    if (nas->direction != NX_ACTION_SAMPLE_DEFAULT &&\n        nas->direction != NX_ACTION_SAMPLE_INGRESS &&\n        nas->direction != NX_ACTION_SAMPLE_EGRESS) {\n        VLOG_WARN_RL(&rl, \"invalid sample direction %\"PRIu8, nas->direction);\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n    return decode_SAMPLE2(nas, NXAST_RAW_SAMPLE3, nas->direction, sample);\n}\n\nstatic void\nencode_SAMPLE2(const struct ofpact_sample *sample,\n               struct nx_action_sample2 *nas)\n{\n    nas->probability = htons(sample->probability);\n    nas->collector_set_id = htonl(sample->collector_set_id);\n    nas->obs_domain_id = htonl(sample->obs_domain_id);\n    nas->obs_point_id = htonl(sample->obs_point_id);\n    nas->sampling_port = htons(ofp_to_u16(sample->sampling_port));\n    nas->direction = sample->direction;\n}\n\nstatic void\nencode_SAMPLE(const struct ofpact_sample *sample,\n              enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    if (sample->ofpact.raw == NXAST_RAW_SAMPLE3\n        || sample->direction != NX_ACTION_SAMPLE_DEFAULT) {\n        encode_SAMPLE2(sample, put_NXAST_SAMPLE3(out));\n    } else if (sample->ofpact.raw == NXAST_RAW_SAMPLE2\n               || sample->sampling_port != OFPP_NONE) {\n        encode_SAMPLE2(sample, put_NXAST_SAMPLE2(out));\n    } else {\n        struct nx_action_sample *nas = put_NXAST_SAMPLE(out);\n        nas->probability = htons(sample->probability);\n        nas->collector_set_id = htonl(sample->collector_set_id);\n        nas->obs_domain_id = htonl(sample->obs_domain_id);\n        nas->obs_point_id = htonl(sample->obs_point_id);\n    }\n}\n\n/* Parses 'arg' as the argument to a \"sample\" action, and appends such an\n * action to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_SAMPLE(char *arg, struct ofpbuf *ofpacts,\n             enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_sample *os = ofpact_put_SAMPLE(ofpacts);\n    os->sampling_port = OFPP_NONE;\n    os->direction = NX_ACTION_SAMPLE_DEFAULT;\n\n    char *key, *value;\n    while (ofputil_parse_key_value(&arg, &key, &value)) {\n        char *error = NULL;\n\n        if (!strcmp(key, \"probability\")) {\n            error = str_to_u16(value, \"probability\", &os->probability);\n            if (!error && os->probability == 0) {\n                error = xasprintf(\"invalid probability value \\\"%s\\\"\", value);\n            }\n        } else if (!strcmp(key, \"collector_set_id\")) {\n            error = str_to_u32(value, &os->collector_set_id);\n        } else if (!strcmp(key, \"obs_domain_id\")) {\n            error = str_to_u32(value, &os->obs_domain_id);\n        } else if (!strcmp(key, \"obs_point_id\")) {\n            error = str_to_u32(value, &os->obs_point_id);\n        } else if (!strcmp(key, \"sampling_port\")) {\n            if (!ofputil_port_from_string(value, &os->sampling_port)) {\n                error = xasprintf(\"%s: unknown port\", value);\n            }\n        } else if (!strcmp(key, \"ingress\")) {\n            os->direction = NX_ACTION_SAMPLE_INGRESS;\n        } else if (!strcmp(key, \"egress\")) {\n            os->direction = NX_ACTION_SAMPLE_EGRESS;\n        } else {\n            error = xasprintf(\"invalid key \\\"%s\\\" in \\\"sample\\\" argument\",\n                              key);\n        }\n        if (error) {\n            return error;\n        }\n    }\n    if (os->probability == 0) {\n        return xstrdup(\"non-zero \\\"probability\\\" must be specified on sample\");\n    }\n\n    return NULL;\n}\n\nstatic void\nformat_SAMPLE(const struct ofpact_sample *a, struct ds *s)\n{\n    ds_put_format(s, \"%ssample(%s%sprobability=%s%\"PRIu16\n                  \",%scollector_set_id=%s%\"PRIu32\n                  \",%sobs_domain_id=%s%\"PRIu32\n                  \",%sobs_point_id=%s%\"PRIu32,\n                  colors.paren, colors.end,\n                  colors.param, colors.end, a->probability,\n                  colors.param, colors.end, a->collector_set_id,\n                  colors.param, colors.end, a->obs_domain_id,\n                  colors.param, colors.end, a->obs_point_id);\n    if (a->sampling_port != OFPP_NONE) {\n        ds_put_format(s, \",%ssampling_port=%s%\"PRIu32,\n                      colors.param, colors.end, a->sampling_port);\n    }\n    if (a->direction == NX_ACTION_SAMPLE_INGRESS) {\n        ds_put_format(s, \",%singress%s\", colors.param, colors.end);\n    } else if (a->direction == NX_ACTION_SAMPLE_EGRESS) {\n        ds_put_format(s, \",%segress%s\", colors.param, colors.end);\n    }\n    ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n}\n\f\n/* debug_recirc instruction. */\n\nstatic bool enable_debug;\n\nvoid\nofpact_dummy_enable(void)\n{\n    enable_debug = true;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_DEBUG_RECIRC(struct ofpbuf *out)\n{\n    if (!enable_debug) {\n        return OFPERR_OFPBAC_BAD_VENDOR_TYPE;\n    }\n\n    ofpact_put_DEBUG_RECIRC(out);\n    return 0;\n}\n\nstatic void\nencode_DEBUG_RECIRC(const struct ofpact_null *n OVS_UNUSED,\n                    enum ofp_version ofp_version OVS_UNUSED,\n                    struct ofpbuf *out)\n{\n    put_NXAST_DEBUG_RECIRC(out);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_DEBUG_RECIRC(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_DEBUG_RECIRC(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_DEBUG_RECIRC(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%sdebug_recirc%s\", colors.value, colors.end);\n}\n\n/* Action structure for NXAST_CT.\n *\n * Pass traffic to the connection tracker.\n *\n * There are two important concepts to understanding the connection tracking\n * interface: Packet state and Connection state. Packets may be \"Untracked\" or\n * \"Tracked\". Connections may be \"Uncommitted\" or \"Committed\".\n *\n *   - Packet State:\n *\n *      Untracked packets have not yet passed through the connection tracker,\n *      and the connection state for such packets is unknown. In most cases,\n *      packets entering the OpenFlow pipeline will initially be in the\n *      untracked state. Untracked packets may become tracked by executing\n *      NXAST_CT with a \"recirc_table\" specified. This makes various aspects\n *      about the connection available, in particular the connection state.\n *\n *      Tracked packets have previously passed through the connection tracker.\n *      These packets will remain tracked through until the end of the OpenFlow\n *      pipeline. Tracked packets which have NXAST_CT executed with a\n *      \"recirc_table\" specified will return to the tracked state.\n *\n *      The packet state is only significant for the duration of packet\n *      processing within the OpenFlow pipeline.\n *\n *   - Connection State:\n *\n *      Multiple packets may be associated with a single connection. Initially,\n *      all connections are uncommitted. The connection state corresponding to\n *      a packet is available in the NXM_NX_CT_STATE field for tracked packets.\n *\n *      Uncommitted connections have no state stored about them. Uncommitted\n *      connections may transition into the committed state by executing\n *      NXAST_CT with the NX_CT_F_COMMIT flag.\n *\n *      Once a connection becomes committed, information may be gathered about\n *      the connection by passing subsequent packets through the connection\n *      tracker, and the state of the connection will be stored beyond the\n *      lifetime of packet processing.\n *\n *      Connections may transition back into the uncommitted state due to\n *      external timers, or due to the contents of packets that are sent to the\n *      connection tracker. This behaviour is outside of the scope of the\n *      OpenFlow interface.\n *\n * The \"zone\" specifies a context within which the tracking is done:\n *\n *      The connection tracking zone is a 16-bit number. Each zone is an\n *      independent connection tracking context. The connection state for each\n *      connection is completely separate for each zone, so if a connection\n *      is committed to zone A, then it will remain uncommitted in zone B.\n *      If NXAST_CT is executed with the same zone multiple times, later\n *      executions have no effect.\n *\n *      If 'zone_src' is nonzero, this specifies that the zone should be\n *      sourced from a field zone_src[ofs:ofs+nbits]. The format and semantics\n *      of 'zone_src' and 'zone_ofs_nbits' are similar to those for the\n *      NXAST_REG_LOAD action. The acceptable nxm_header values for 'zone_src'\n *      are the same as the acceptable nxm_header values for the 'src' field of\n *      NXAST_REG_MOVE.\n *\n *      If 'zone_src' is zero, then the value of 'zone_imm' will be used as the\n *      connection tracking zone.\n *\n * The \"recirc_table\" allows NXM_NX_CT_* fields to become available:\n *\n *      If \"recirc_table\" has a value other than NX_CT_RECIRC_NONE, then the\n *      packet will be logically cloned prior to executing this action. One\n *      copy will be sent to the connection tracker, then will be re-injected\n *      into the OpenFlow pipeline beginning at the OpenFlow table specified in\n *      this field. When the packet re-enters the pipeline, the NXM_NX_CT_*\n *      fields will be populated. The original instance of the packet will\n *      continue the current actions list. This can be thought of as similar to\n *      the effect of the \"output\" action: One copy is sent out (in this case,\n *      to the connection tracker), but the current copy continues processing.\n *\n *      It is strongly recommended that this table is later than the current\n *      table, to prevent loops.\n *\n * The \"alg\" attaches protocol-specific behaviour to this action:\n *\n *      The ALG is a 16-bit number which specifies that additional\n *      processing should be applied to this traffic.\n *\n *      Protocol | Value | Meaning\n *      --------------------------------------------------------------------\n *      None     |     0 | No protocol-specific behaviour.\n *      FTP      |    21 | Parse FTP control connections and observe the\n *               |       | negotiation of related data connections.\n *      Other    | Other | Unsupported protocols.\n *\n *      By way of example, if FTP control connections have this action applied\n *      with the ALG set to FTP (21), then the connection tracker will observe\n *      the negotiation of data connections. This allows the connection\n *      tracker to identify subsequent data connections as \"related\" to this\n *      existing connection. The \"related\" flag will be populated in the\n *      NXM_NX_CT_STATE field for such connections if the 'recirc_table' is\n *      specified.\n *\n * Zero or more actions may immediately follow this action. These actions will\n * be executed within the context of the connection tracker, and they require\n * the NX_CT_F_COMMIT flag to be set.\n */\nstruct nx_action_conntrack {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* At least 24. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_CT. */\n    ovs_be16 flags;             /* Zero or more NX_CT_F_* flags.\n                                 * Unspecified flag bits must be zero. */\n    ovs_be32 zone_src;          /* Connection tracking context. */\n    union {\n        ovs_be16 zone_ofs_nbits;/* Range to use from source field. */\n        ovs_be16 zone_imm;      /* Immediate value for zone. */\n    };\n    uint8_t recirc_table;       /* Recirculate to a specific table, or\n                                   NX_CT_RECIRC_NONE for no recirculation. */\n    uint8_t pad[3];             /* Zeroes */\n    ovs_be16 alg;               /* Well-known port number for the protocol.\n                                 * 0 indicates no ALG is required. */\n    /* Followed by a sequence of zero or more OpenFlow actions. The length of\n     * these is included in 'len'. */\n};\nOFP_ASSERT(sizeof(struct nx_action_conntrack) == 24);\n\nstatic enum ofperr\ndecode_ct_zone(const struct nx_action_conntrack *nac,\n               struct ofpact_conntrack *out,\n               const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap)\n{\n    if (nac->zone_src) {\n        enum ofperr error;\n\n        out->zone_src.ofs = nxm_decode_ofs(nac->zone_ofs_nbits);\n        out->zone_src.n_bits = nxm_decode_n_bits(nac->zone_ofs_nbits);\n        error = mf_vl_mff_mf_from_nxm_header(ntohl(nac->zone_src),\n                                             vl_mff_map, &out->zone_src.field,\n                                             tlv_bitmap);\n        if (error) {\n            return error;\n        }\n\n        error = mf_check_src(&out->zone_src, NULL);\n        if (error) {\n            return error;\n        }\n\n        if (out->zone_src.n_bits != 16) {\n            VLOG_WARN_RL(&rl, \"zone n_bits %d not within valid range [16..16]\",\n                         out->zone_src.n_bits);\n            return OFPERR_OFPBAC_BAD_SET_LEN;\n        }\n    } else {\n        out->zone_src.field = NULL;\n        out->zone_imm = ntohs(nac->zone_imm);\n    }\n\n    return 0;\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_CT(const struct nx_action_conntrack *nac,\n                    enum ofp_version ofp_version,\n                    const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap,\n                    struct ofpbuf *out)\n{\n    const size_t ct_offset = ofpacts_pull(out);\n    struct ofpact_conntrack *conntrack = ofpact_put_CT(out);\n    conntrack->flags = ntohs(nac->flags);\n\n    int error = decode_ct_zone(nac, conntrack, vl_mff_map, tlv_bitmap);\n    if (error) {\n        goto out;\n    }\n    conntrack->recirc_table = nac->recirc_table;\n    conntrack->alg = ntohs(nac->alg);\n\n    ofpbuf_pull(out, sizeof(*conntrack));\n\n    struct ofpbuf openflow = ofpbuf_const_initializer(\n        nac + 1, ntohs(nac->len) - sizeof(*nac));\n    error = ofpacts_pull_openflow_actions__(&openflow, openflow.size,\n                                            ofp_version,\n                                            1u << OVSINST_OFPIT11_APPLY_ACTIONS,\n                                            out, OFPACT_CT, vl_mff_map,\n                                            tlv_bitmap);\n    if (error) {\n        goto out;\n    }\n\n    conntrack = ofpbuf_push_uninit(out, sizeof(*conntrack));\n    out->header = &conntrack->ofpact;\n    ofpact_finish_CT(out, &conntrack);\n\n    if (conntrack->ofpact.len > sizeof(*conntrack)\n        && !(conntrack->flags & NX_CT_F_COMMIT)) {\n        const struct ofpact *a;\n        size_t ofpacts_len = conntrack->ofpact.len - sizeof(*conntrack);\n\n        OFPACT_FOR_EACH (a, conntrack->actions, ofpacts_len) {\n            if (a->type != OFPACT_NAT || ofpact_get_NAT(a)->flags\n                || ofpact_get_NAT(a)->range_af != AF_UNSPEC) {\n                VLOG_WARN_RL(&rl, \"CT action requires commit flag if actions \"\n                             \"other than NAT without arguments are specified.\");\n                error = OFPERR_OFPBAC_BAD_ARGUMENT;\n                goto out;\n            }\n        }\n    }\n\nout:\n    ofpbuf_push_uninit(out, ct_offset);\n    return error;\n}\n\nstatic void\nencode_CT(const struct ofpact_conntrack *conntrack,\n          enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    struct nx_action_conntrack *nac;\n    const size_t ofs = out->size;\n    size_t len;\n\n    nac = put_NXAST_CT(out);\n    nac->flags = htons(conntrack->flags);\n    if (conntrack->zone_src.field) {\n        nac->zone_src = htonl(nxm_header_from_mff(conntrack->zone_src.field));\n        nac->zone_ofs_nbits = nxm_encode_ofs_nbits(conntrack->zone_src.ofs,\n                                                   conntrack->zone_src.n_bits);\n    } else {\n        nac->zone_src = htonl(0);\n        nac->zone_imm = htons(conntrack->zone_imm);\n    }\n    nac->recirc_table = conntrack->recirc_table;\n    nac->alg = htons(conntrack->alg);\n\n    len = ofpacts_put_openflow_actions(conntrack->actions,\n                                       ofpact_ct_get_action_len(conntrack),\n                                       out, ofp_version);\n    len += sizeof(*nac);\n    nac = ofpbuf_at(out, ofs, sizeof(*nac));\n    nac->len = htons(len);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT parse_NAT(char *arg, struct ofpbuf *,\n                                               enum ofputil_protocol * OVS_UNUSED);\n\n/* Parses 'arg' as the argument to a \"ct\" action, and appends such an\n * action to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_CT(char *arg, struct ofpbuf *ofpacts,\n         enum ofputil_protocol *usable_protocols)\n{\n    const size_t ct_offset = ofpacts_pull(ofpacts);\n    struct ofpact_conntrack *oc;\n    char *error = NULL;\n    char *key, *value;\n\n    oc = ofpact_put_CT(ofpacts);\n    oc->flags = 0;\n    oc->recirc_table = NX_CT_RECIRC_NONE;\n    while (ofputil_parse_key_value(&arg, &key, &value)) {\n        if (!strcmp(key, \"commit\")) {\n            oc->flags |= NX_CT_F_COMMIT;\n        } else if (!strcmp(key, \"table\")) {\n            error = str_to_u8(value, \"recirc_table\", &oc->recirc_table);\n            if (!error && oc->recirc_table == NX_CT_RECIRC_NONE) {\n                error = xasprintf(\"invalid table %#\"PRIx16, oc->recirc_table);\n            }\n        } else if (!strcmp(key, \"zone\")) {\n            error = str_to_u16(value, \"zone\", &oc->zone_imm);\n\n            if (error) {\n                free(error);\n                error = mf_parse_subfield(&oc->zone_src, value);\n                if (error) {\n                    return error;\n                }\n            }\n        } else if (!strcmp(key, \"alg\")) {\n            error = str_to_connhelper(value, &oc->alg);\n        } else if (!strcmp(key, \"nat\")) {\n            const size_t nat_offset = ofpacts_pull(ofpacts);\n\n            error = parse_NAT(value, ofpacts, usable_protocols);\n            /* Update CT action pointer and length. */\n            ofpacts->header = ofpbuf_push_uninit(ofpacts, nat_offset);\n            oc = ofpacts->header;\n        } else if (!strcmp(key, \"exec\")) {\n            /* Hide existing actions from ofpacts_parse_copy(), so the\n             * nesting can be handled transparently. */\n            enum ofputil_protocol usable_protocols2;\n            const size_t exec_offset = ofpacts_pull(ofpacts);\n\n            /* Initializes 'usable_protocol2', fold it back to\n             * '*usable_protocols' afterwards, so that we do not lose\n             * restrictions already in there. */\n            error = ofpacts_parse_copy(value, ofpacts, &usable_protocols2,\n                                       false, OFPACT_CT);\n            *usable_protocols &= usable_protocols2;\n            ofpacts->header = ofpbuf_push_uninit(ofpacts, exec_offset);\n            oc = ofpacts->header;\n        } else {\n            error = xasprintf(\"invalid argument to \\\"ct\\\" action: `%s'\", key);\n        }\n        if (error) {\n            break;\n        }\n    }\n\n    ofpact_finish_CT(ofpacts, &oc);\n    ofpbuf_push_uninit(ofpacts, ct_offset);\n    return error;\n}\n\nstatic void\nformat_alg(int port, struct ds *s)\n{\n    switch(port) {\n    case IPPORT_FTP:\n        ds_put_format(s, \"%salg=%sftp,\", colors.param, colors.end);\n        break;\n    case IPPORT_TFTP:\n        ds_put_format(s, \"%salg=%stftp,\", colors.param, colors.end);\n        break;\n    case 0:\n        /* Don't print. */\n        break;\n    default:\n        ds_put_format(s, \"%salg=%s%d,\", colors.param, colors.end, port);\n        break;\n    }\n}\n\nstatic void format_NAT(const struct ofpact_nat *a, struct ds *ds);\n\nstatic void\nformat_CT(const struct ofpact_conntrack *a, struct ds *s)\n{\n    ds_put_format(s, \"%sct(%s\", colors.paren, colors.end);\n    if (a->flags & NX_CT_F_COMMIT) {\n        ds_put_format(s, \"%scommit%s,\", colors.value, colors.end);\n    }\n    if (a->recirc_table != NX_CT_RECIRC_NONE) {\n        ds_put_format(s, \"%stable=%s%\"PRIu8\",\",\n                      colors.special, colors.end, a->recirc_table);\n    }\n    if (a->zone_src.field) {\n        ds_put_format(s, \"%szone=%s\", colors.param, colors.end);\n        mf_format_subfield(&a->zone_src, s);\n        ds_put_char(s, ',');\n    } else if (a->zone_imm) {\n        ds_put_format(s, \"%szone=%s%\"PRIu16\",\",\n                      colors.param, colors.end, a->zone_imm);\n    }\n    /* If the first action is a NAT action, format it outside of the 'exec'\n     * envelope. */\n    const struct ofpact *action = a->actions;\n    size_t actions_len = ofpact_ct_get_action_len(a);\n    if (actions_len && action->type == OFPACT_NAT) {\n        format_NAT(ofpact_get_NAT(action), s);\n        ds_put_char(s, ',');\n        actions_len -= OFPACT_ALIGN(action->len);\n        action = ofpact_next(action);\n    }\n    if (actions_len) {\n        ds_put_format(s, \"%sexec(%s\", colors.paren, colors.end);\n        ofpacts_format(action, actions_len, s);\n        ds_put_format(s, \"%s),%s\", colors.paren, colors.end);\n    }\n    format_alg(a->alg, s);\n    ds_chomp(s, ',');\n    ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n}\n\f\n/* ct_clear action. */\n\nstatic enum ofperr\ndecode_NXAST_RAW_CT_CLEAR(struct ofpbuf *out)\n{\n    ofpact_put_CT_CLEAR(out);\n    return 0;\n}\n\nstatic void\nencode_CT_CLEAR(const struct ofpact_null *null OVS_UNUSED,\n                enum ofp_version ofp_version OVS_UNUSED,\n                struct ofpbuf *out)\n{\n    put_NXAST_CT_CLEAR(out);\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_CT_CLEAR(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n               enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_CT_CLEAR(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_CT_CLEAR(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%sct_clear%s\", colors.value, colors.end);\n}\f\n/* NAT action. */\n\n/* Which optional fields are present? */\nenum nx_nat_range {\n    NX_NAT_RANGE_IPV4_MIN  = 1 << 0, /* ovs_be32 */\n    NX_NAT_RANGE_IPV4_MAX  = 1 << 1, /* ovs_be32 */\n    NX_NAT_RANGE_IPV6_MIN  = 1 << 2, /* struct in6_addr */\n    NX_NAT_RANGE_IPV6_MAX  = 1 << 3, /* struct in6_addr */\n    NX_NAT_RANGE_PROTO_MIN = 1 << 4, /* ovs_be16 */\n    NX_NAT_RANGE_PROTO_MAX = 1 << 5, /* ovs_be16 */\n};\n\n/* Action structure for NXAST_NAT. */\nstruct nx_action_nat {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* At least 16. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_NAT. */\n    uint8_t  pad[2];            /* Must be zero. */\n    ovs_be16 flags;             /* Zero or more NX_NAT_F_* flags.\n                                 * Unspecified flag bits must be zero. */\n    ovs_be16 range_present;     /* NX_NAT_RANGE_* */\n    /* Followed by optional parameters as specified by 'range_present' */\n};\nOFP_ASSERT(sizeof(struct nx_action_nat) == 16);\n\nstatic void\nencode_NAT(const struct ofpact_nat *nat,\n           enum ofp_version ofp_version OVS_UNUSED,\n           struct ofpbuf *out)\n{\n    struct nx_action_nat *nan;\n    const size_t ofs = out->size;\n    uint16_t range_present = 0;\n\n    nan = put_NXAST_NAT(out);\n    nan->flags = htons(nat->flags);\n    if (nat->range_af == AF_INET) {\n        if (nat->range.addr.ipv4.min) {\n            ovs_be32 *min = ofpbuf_put_uninit(out, sizeof *min);\n            *min = nat->range.addr.ipv4.min;\n            range_present |= NX_NAT_RANGE_IPV4_MIN;\n        }\n        if (nat->range.addr.ipv4.max) {\n            ovs_be32 *max = ofpbuf_put_uninit(out, sizeof *max);\n            *max = nat->range.addr.ipv4.max;\n            range_present |= NX_NAT_RANGE_IPV4_MAX;\n        }\n    } else if (nat->range_af == AF_INET6) {\n        if (!ipv6_mask_is_any(&nat->range.addr.ipv6.min)) {\n            struct in6_addr *min = ofpbuf_put_uninit(out, sizeof *min);\n            *min = nat->range.addr.ipv6.min;\n            range_present |= NX_NAT_RANGE_IPV6_MIN;\n        }\n        if (!ipv6_mask_is_any(&nat->range.addr.ipv6.max)) {\n            struct in6_addr *max = ofpbuf_put_uninit(out, sizeof *max);\n            *max = nat->range.addr.ipv6.max;\n            range_present |= NX_NAT_RANGE_IPV6_MAX;\n        }\n    }\n    if (nat->range_af != AF_UNSPEC) {\n        if (nat->range.proto.min) {\n            ovs_be16 *min = ofpbuf_put_uninit(out, sizeof *min);\n            *min = htons(nat->range.proto.min);\n            range_present |= NX_NAT_RANGE_PROTO_MIN;\n        }\n        if (nat->range.proto.max) {\n            ovs_be16 *max = ofpbuf_put_uninit(out, sizeof *max);\n            *max = htons(nat->range.proto.max);\n            range_present |= NX_NAT_RANGE_PROTO_MAX;\n        }\n    }\n    pad_ofpat(out, ofs);\n    nan = ofpbuf_at(out, ofs, sizeof *nan);\n    nan->range_present = htons(range_present);\n}\n\nstatic enum ofperr\ndecode_NXAST_RAW_NAT(const struct nx_action_nat *nan,\n                     enum ofp_version ofp_version OVS_UNUSED,\n                     struct ofpbuf *out)\n{\n    struct ofpact_nat *nat;\n    uint16_t range_present = ntohs(nan->range_present);\n    const char *opts = (char *)(nan + 1);\n    uint16_t len = ntohs(nan->len) - sizeof *nan;\n\n    nat = ofpact_put_NAT(out);\n    nat->flags = ntohs(nan->flags);\n\n    /* Check for unknown or mutually exclusive flags. */\n    if ((nat->flags & ~NX_NAT_F_MASK)\n        || (nat->flags & NX_NAT_F_SRC && nat->flags & NX_NAT_F_DST)\n        || (nat->flags & NX_NAT_F_PROTO_HASH\n            && nat->flags & NX_NAT_F_PROTO_RANDOM)) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n#define NX_NAT_GET_OPT(DST, SRC, LEN, TYPE)                     \\\n    (LEN >= sizeof(TYPE)                                        \\\n     ? (memcpy(DST, SRC, sizeof(TYPE)), LEN -= sizeof(TYPE),    \\\n        SRC += sizeof(TYPE))                                    \\\n     : NULL)\n\n    nat->range_af = AF_UNSPEC;\n    if (range_present & NX_NAT_RANGE_IPV4_MIN) {\n        if (range_present & (NX_NAT_RANGE_IPV6_MIN | NX_NAT_RANGE_IPV6_MAX)) {\n            return OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n\n        if (!NX_NAT_GET_OPT(&nat->range.addr.ipv4.min, opts, len, ovs_be32)\n            || !nat->range.addr.ipv4.min) {\n            return OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n\n        nat->range_af = AF_INET;\n\n        if (range_present & NX_NAT_RANGE_IPV4_MAX) {\n            if (!NX_NAT_GET_OPT(&nat->range.addr.ipv4.max, opts, len,\n                                ovs_be32)) {\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n            if (ntohl(nat->range.addr.ipv4.max)\n                < ntohl(nat->range.addr.ipv4.min)) {\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n        }\n    } else if (range_present & NX_NAT_RANGE_IPV4_MAX) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    } else if (range_present & NX_NAT_RANGE_IPV6_MIN) {\n        if (!NX_NAT_GET_OPT(&nat->range.addr.ipv6.min, opts, len,\n                            struct in6_addr)\n            || ipv6_mask_is_any(&nat->range.addr.ipv6.min)) {\n            return OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n\n        nat->range_af = AF_INET6;\n\n        if (range_present & NX_NAT_RANGE_IPV6_MAX) {\n            if (!NX_NAT_GET_OPT(&nat->range.addr.ipv6.max, opts, len,\n                                struct in6_addr)) {\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n            if (memcmp(&nat->range.addr.ipv6.max, &nat->range.addr.ipv6.min,\n                       sizeof(struct in6_addr)) < 0) {\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n        }\n    } else if (range_present & NX_NAT_RANGE_IPV6_MAX) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    if (range_present & NX_NAT_RANGE_PROTO_MIN) {\n        ovs_be16 proto;\n\n        if (nat->range_af == AF_UNSPEC) {\n            return OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n        if (!NX_NAT_GET_OPT(&proto, opts, len, ovs_be16) || proto == 0) {\n            return OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n        nat->range.proto.min = ntohs(proto);\n        if (range_present & NX_NAT_RANGE_PROTO_MAX) {\n            if (!NX_NAT_GET_OPT(&proto, opts, len, ovs_be16)) {\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n            nat->range.proto.max = ntohs(proto);\n            if (nat->range.proto.max < nat->range.proto.min) {\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n        }\n    } else if (range_present & NX_NAT_RANGE_PROTO_MAX) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    return 0;\n}\n\nstatic void\nformat_NAT(const struct ofpact_nat *a, struct ds *ds)\n{\n    ds_put_format(ds, \"%snat%s\", colors.paren, colors.end);\n\n    if (a->flags & (NX_NAT_F_SRC | NX_NAT_F_DST)) {\n        ds_put_format(ds, \"%s(%s\", colors.paren, colors.end);\n        ds_put_format(ds, a->flags & NX_NAT_F_SRC ? \"%ssrc%s\" : \"%sdst%s\",\n                      colors.param, colors.end);\n\n        if (a->range_af != AF_UNSPEC) {\n            ds_put_format(ds, \"%s=%s\", colors.param, colors.end);\n\n            if (a->range_af == AF_INET) {\n                ds_put_format(ds, IP_FMT, IP_ARGS(a->range.addr.ipv4.min));\n\n                if (a->range.addr.ipv4.max\n                    && a->range.addr.ipv4.max != a->range.addr.ipv4.min) {\n                    ds_put_format(ds, \"-\"IP_FMT,\n                                  IP_ARGS(a->range.addr.ipv4.max));\n                }\n            } else if (a->range_af == AF_INET6) {\n                ipv6_format_addr_bracket(&a->range.addr.ipv6.min, ds,\n                                        a->range.proto.min);\n\n                if (!ipv6_mask_is_any(&a->range.addr.ipv6.max)\n                    && memcmp(&a->range.addr.ipv6.max, &a->range.addr.ipv6.min,\n                              sizeof(struct in6_addr)) != 0) {\n                    ds_put_char(ds, '-');\n                    ipv6_format_addr_bracket(&a->range.addr.ipv6.max, ds,\n                                            a->range.proto.min);\n                }\n            }\n            if (a->range.proto.min) {\n                ds_put_char(ds, ':');\n                ds_put_format(ds, \"%\"PRIu16, a->range.proto.min);\n\n                if (a->range.proto.max\n                    && a->range.proto.max != a->range.proto.min) {\n                    ds_put_format(ds, \"-%\"PRIu16, a->range.proto.max);\n                }\n            }\n            ds_put_char(ds, ',');\n\n            if (a->flags & NX_NAT_F_PERSISTENT) {\n                ds_put_format(ds, \"%spersistent%s,\",\n                              colors.value, colors.end);\n            }\n            if (a->flags & NX_NAT_F_PROTO_HASH) {\n                ds_put_format(ds, \"%shash%s,\", colors.value, colors.end);\n            }\n            if (a->flags & NX_NAT_F_PROTO_RANDOM) {\n                ds_put_format(ds, \"%srandom%s,\", colors.value, colors.end);\n            }\n        }\n        ds_chomp(ds, ',');\n        ds_put_format(ds, \"%s)%s\", colors.paren, colors.end);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nstr_to_nat_range(const char *s, struct ofpact_nat *on)\n{\n    char ipv6_s[IPV6_SCAN_LEN + 1];\n    int n = 0;\n\n    on->range_af = AF_UNSPEC;\n    if (ovs_scan_len(s, &n, IP_SCAN_FMT,\n                     IP_SCAN_ARGS(&on->range.addr.ipv4.min))) {\n        on->range_af = AF_INET;\n\n        if (s[n] == '-') {\n            n++;\n            if (!ovs_scan_len(s, &n, IP_SCAN_FMT,\n                              IP_SCAN_ARGS(&on->range.addr.ipv4.max))\n                || (ntohl(on->range.addr.ipv4.max)\n                    < ntohl(on->range.addr.ipv4.min))) {\n                goto error;\n            }\n        }\n    } else if ((ovs_scan_len(s, &n, IPV6_SCAN_FMT, ipv6_s)\n                || ovs_scan_len(s, &n, \"[\"IPV6_SCAN_FMT\"]\", ipv6_s))\n               && inet_pton(AF_INET6, ipv6_s, &on->range.addr.ipv6.min) == 1) {\n        on->range_af = AF_INET6;\n\n        if (s[n] == '-') {\n            n++;\n            if (!(ovs_scan_len(s, &n, IPV6_SCAN_FMT, ipv6_s)\n                  || ovs_scan_len(s, &n, \"[\"IPV6_SCAN_FMT\"]\", ipv6_s))\n                || inet_pton(AF_INET6, ipv6_s, &on->range.addr.ipv6.max) != 1\n                || memcmp(&on->range.addr.ipv6.max, &on->range.addr.ipv6.min,\n                          sizeof on->range.addr.ipv6.max) < 0) {\n                goto error;\n            }\n        }\n    }\n    if (on->range_af != AF_UNSPEC && s[n] == ':') {\n        n++;\n        if (!ovs_scan_len(s, &n, \"%\"SCNu16, &on->range.proto.min)) {\n            goto error;\n        }\n        if (s[n] == '-') {\n            n++;\n            if (!ovs_scan_len(s, &n, \"%\"SCNu16, &on->range.proto.max)\n                || on->range.proto.max < on->range.proto.min) {\n                goto error;\n            }\n        }\n    }\n    if (strlen(s) != n) {\n        return xasprintf(\"garbage (%s) after nat range \\\"%s\\\" (pos: %d)\",\n                         &s[n], s, n);\n    }\n    return NULL;\nerror:\n    return xasprintf(\"invalid nat range \\\"%s\\\"\", s);\n}\n\n\n/* Parses 'arg' as the argument to a \"nat\" action, and appends such an\n * action to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_NAT(char *arg, struct ofpbuf *ofpacts,\n          enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_nat *on = ofpact_put_NAT(ofpacts);\n    char *key, *value;\n\n    on->flags = 0;\n    on->range_af = AF_UNSPEC;\n\n    while (ofputil_parse_key_value(&arg, &key, &value)) {\n        char *error = NULL;\n\n        if (!strcmp(key, \"src\")) {\n            on->flags |= NX_NAT_F_SRC;\n            error = str_to_nat_range(value, on);\n        } else if (!strcmp(key, \"dst\")) {\n            on->flags |= NX_NAT_F_DST;\n            error = str_to_nat_range(value, on);\n        } else if (!strcmp(key, \"persistent\")) {\n            on->flags |= NX_NAT_F_PERSISTENT;\n        } else if (!strcmp(key, \"hash\")) {\n            on->flags |= NX_NAT_F_PROTO_HASH;\n        } else if (!strcmp(key, \"random\")) {\n            on->flags |= NX_NAT_F_PROTO_RANDOM;\n        } else {\n            error = xasprintf(\"invalid key \\\"%s\\\" in \\\"nat\\\" argument\",\n                              key);\n        }\n        if (error) {\n            return error;\n        }\n    }\n    if (on->flags & NX_NAT_F_SRC && on->flags & NX_NAT_F_DST) {\n        return xasprintf(\"May only specify one of \\\"src\\\" or \\\"dst\\\".\");\n    }\n    if (!(on->flags & NX_NAT_F_SRC || on->flags & NX_NAT_F_DST)) {\n        if (on->flags) {\n            return xasprintf(\"Flags allowed only with \\\"src\\\" or \\\"dst\\\".\");\n        }\n        if (on->range_af != AF_UNSPEC) {\n            return xasprintf(\"Range allowed only with \\\"src\\\" or \\\"dst\\\".\");\n        }\n    }\n    if (on->flags & NX_NAT_F_PROTO_HASH && on->flags & NX_NAT_F_PROTO_RANDOM) {\n        return xasprintf(\"Both \\\"hash\\\" and \\\"random\\\" are not allowed.\");\n    }\n\n    return NULL;\n}\n\n/* Truncate output action. */\nstruct nx_action_output_trunc {\n    ovs_be16 type;              /* OFPAT_VENDOR. */\n    ovs_be16 len;               /* At least 16. */\n    ovs_be32 vendor;            /* NX_VENDOR_ID. */\n    ovs_be16 subtype;           /* NXAST_OUTPUT_TRUNC. */\n    ovs_be16 port;              /* Output port */\n    ovs_be32 max_len;           /* Truncate packet to size bytes */\n};\nOFP_ASSERT(sizeof(struct nx_action_output_trunc) == 16);\n\nstatic enum ofperr\ndecode_NXAST_RAW_OUTPUT_TRUNC(const struct nx_action_output_trunc *natrc,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            struct ofpbuf *out)\n{\n    struct ofpact_output_trunc *output_trunc;\n\n    output_trunc = ofpact_put_OUTPUT_TRUNC(out);\n    output_trunc->max_len = ntohl(natrc->max_len);\n    output_trunc->port = u16_to_ofp(ntohs(natrc->port));\n\n    if (output_trunc->max_len < ETH_HEADER_LEN) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n    return 0;\n}\n\nstatic void\nencode_OUTPUT_TRUNC(const struct ofpact_output_trunc *output_trunc,\n                  enum ofp_version ofp_version OVS_UNUSED,\n                  struct ofpbuf *out)\n{\n    struct nx_action_output_trunc *natrc = put_NXAST_OUTPUT_TRUNC(out);\n\n    natrc->max_len = htonl(output_trunc->max_len);\n    natrc->port = htons(ofp_to_u16(output_trunc->port));\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_OUTPUT_TRUNC(const char *arg, struct ofpbuf *ofpacts OVS_UNUSED,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    /* Disable output_trunc parsing.  Expose as output(port=N,max_len=M) and\n     * reuse parse_OUTPUT to parse output_trunc action. */\n    return xasprintf(\"unknown action %s\", arg);\n}\n\nstatic void\nformat_OUTPUT_TRUNC(const struct ofpact_output_trunc *a, struct ds *s)\n{\n     ds_put_format(s, \"%soutput%s(port=%\"PRIu32\",max_len=%\"PRIu32\")\",\n                   colors.special, colors.end, a->port, a->max_len);\n}\n\n\f\n/* Meter instruction. */\n\nstatic void\nencode_METER(const struct ofpact_meter *meter,\n             enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version >= OFP13_VERSION) {\n        instruction_put_OFPIT13_METER(out)->meter_id = htonl(meter->meter_id);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_METER(char *arg, struct ofpbuf *ofpacts,\n            enum ofputil_protocol *usable_protocols)\n{\n    *usable_protocols &= OFPUTIL_P_OF13_UP;\n    return str_to_u32(arg, &ofpact_put_METER(ofpacts)->meter_id);\n}\n\nstatic void\nformat_METER(const struct ofpact_meter *a, struct ds *s)\n{\n    ds_put_format(s, \"%smeter:%s%\"PRIu32,\n                  colors.param, colors.end, a->meter_id);\n}\n\f\n/* Clear-Actions instruction. */\n\nstatic void\nencode_CLEAR_ACTIONS(const struct ofpact_null *null OVS_UNUSED,\n                     enum ofp_version ofp_version OVS_UNUSED,\n                     struct ofpbuf *out OVS_UNUSED)\n{\n    if (ofp_version > OFP10_VERSION) {\n        instruction_put_OFPIT11_CLEAR_ACTIONS(out);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_CLEAR_ACTIONS(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n                    enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_CLEAR_ACTIONS(ofpacts);\n    return NULL;\n}\n\nstatic void\nformat_CLEAR_ACTIONS(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%sclear_actions%s\", colors.value, colors.end);\n}\n\f\n/* Write-Actions instruction. */\n\nstatic void\nencode_WRITE_ACTIONS(const struct ofpact_nest *actions,\n                     enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version > OFP10_VERSION) {\n        const size_t ofs = out->size;\n\n        instruction_put_OFPIT11_WRITE_ACTIONS(out);\n        ofpacts_put_openflow_actions(actions->actions,\n                                     ofpact_nest_get_action_len(actions),\n                                     out, ofp_version);\n        ofpacts_update_instruction_actions(out, ofs);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_WRITE_ACTIONS(char *arg, struct ofpbuf *ofpacts,\n                    enum ofputil_protocol *usable_protocols)\n{\n    size_t ofs = ofpacts_pull(ofpacts);\n    struct ofpact_nest *on;\n    char *error;\n\n    /* Add a Write-Actions instruction and then pull it off. */\n    ofpact_put(ofpacts, OFPACT_WRITE_ACTIONS, sizeof *on);\n    ofpbuf_pull(ofpacts, sizeof *on);\n\n    /* Parse nested actions.\n     *\n     * We pulled off \"write-actions\" and the previous actions because the\n     * OFPACT_WRITE_ACTIONS is only partially constructed: its length is such\n     * that it doesn't actually include the nested actions.  That means that\n     * ofpacts_parse() would reject them as being part of an Apply-Actions that\n     * follows a Write-Actions, which is an invalid order.  */\n    error = ofpacts_parse(arg, ofpacts, usable_protocols, false,\n                          OFPACT_WRITE_ACTIONS);\n\n    /* Put the Write-Actions back on and update its length. */\n    on = ofpbuf_push_uninit(ofpacts, sizeof *on);\n    on->ofpact.len = ofpacts->size;\n\n    /* Put any previous actions or instructions back on. */\n    ofpbuf_push_uninit(ofpacts, ofs);\n\n    return error;\n}\n\nstatic void\nformat_WRITE_ACTIONS(const struct ofpact_nest *a, struct ds *s)\n{\n    ds_put_format(s, \"%swrite_actions(%s\", colors.paren, colors.end);\n    ofpacts_format(a->actions, ofpact_nest_get_action_len(a), s);\n    ds_put_format(s, \"%s)%s\", colors.paren, colors.end);\n}\n\f\n/* Action structure for NXAST_WRITE_METADATA.\n *\n * Modifies the 'mask' bits of the metadata value. */\nstruct nx_action_write_metadata {\n    ovs_be16 type;                  /* OFPAT_VENDOR. */\n    ovs_be16 len;                   /* Length is 32. */\n    ovs_be32 vendor;                /* NX_VENDOR_ID. */\n    ovs_be16 subtype;               /* NXAST_WRITE_METADATA. */\n    uint8_t zeros[6];               /* Must be zero. */\n    ovs_be64 metadata;              /* Metadata register. */\n    ovs_be64 mask;                  /* Metadata mask. */\n};\nOFP_ASSERT(sizeof(struct nx_action_write_metadata) == 32);\n\nstatic enum ofperr\ndecode_NXAST_RAW_WRITE_METADATA(const struct nx_action_write_metadata *nawm,\n                                enum ofp_version ofp_version OVS_UNUSED,\n                                struct ofpbuf *out)\n{\n    struct ofpact_metadata *om;\n\n    if (!is_all_zeros(nawm->zeros, sizeof nawm->zeros)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n\n    om = ofpact_put_WRITE_METADATA(out);\n    om->metadata = nawm->metadata;\n    om->mask = nawm->mask;\n\n    return 0;\n}\n\nstatic void\nencode_WRITE_METADATA(const struct ofpact_metadata *metadata,\n                      enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version == OFP10_VERSION) {\n        struct nx_action_write_metadata *nawm;\n\n        nawm = put_NXAST_WRITE_METADATA(out);\n        nawm->metadata = metadata->metadata;\n        nawm->mask = metadata->mask;\n    } else {\n        struct ofp11_instruction_write_metadata *oiwm;\n\n        oiwm = instruction_put_OFPIT11_WRITE_METADATA(out);\n        oiwm->metadata = metadata->metadata;\n        oiwm->metadata_mask = metadata->mask;\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_WRITE_METADATA(char *arg, struct ofpbuf *ofpacts,\n                     enum ofputil_protocol *usable_protocols)\n{\n    struct ofpact_metadata *om;\n    char *mask = strchr(arg, '/');\n\n    *usable_protocols &= OFPUTIL_P_NXM_OF11_UP;\n\n    om = ofpact_put_WRITE_METADATA(ofpacts);\n    if (mask) {\n        char *error;\n\n        *mask = '\\0';\n        error = str_to_be64(mask + 1, &om->mask);\n        if (error) {\n            return error;\n        }\n    } else {\n        om->mask = OVS_BE64_MAX;\n    }\n\n    return str_to_be64(arg, &om->metadata);\n}\n\nstatic void\nformat_WRITE_METADATA(const struct ofpact_metadata *a, struct ds *s)\n{\n    ds_put_format(s, \"%swrite_metadata:%s%#\"PRIx64,\n                  colors.param, colors.end, ntohll(a->metadata));\n    if (a->mask != OVS_BE64_MAX) {\n        ds_put_format(s, \"/%#\"PRIx64, ntohll(a->mask));\n    }\n}\n\f\n/* Goto-Table instruction. */\n\nstatic void\nencode_GOTO_TABLE(const struct ofpact_goto_table *goto_table,\n                  enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    if (ofp_version == OFP10_VERSION) {\n        struct nx_action_resubmit *nar;\n\n        nar = put_NXAST_RESUBMIT_TABLE(out);\n        nar->table = goto_table->table_id;\n        nar->in_port = htons(ofp_to_u16(OFPP_IN_PORT));\n    } else {\n        struct ofp11_instruction_goto_table *oigt;\n\n        oigt = instruction_put_OFPIT11_GOTO_TABLE(out);\n        oigt->table_id = goto_table->table_id;\n        memset(oigt->pad, 0, sizeof oigt->pad);\n    }\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nparse_GOTO_TABLE(char *arg, struct ofpbuf *ofpacts,\n                 enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_goto_table *ogt = ofpact_put_GOTO_TABLE(ofpacts);\n    char *table_s = strsep(&arg, \",\");\n    if (!table_s || !table_s[0]) {\n        return xstrdup(\"instruction goto-table needs table id\");\n    }\n    return str_to_u8(table_s, \"table\", &ogt->table_id);\n}\n\nstatic void\nformat_GOTO_TABLE(const struct ofpact_goto_table *a, struct ds *s)\n{\n    ds_put_format(s, \"%sgoto_table:%s%\"PRIu8,\n                  colors.param, colors.end, a->table_id);\n}\n\f\nstatic void\nlog_bad_action(const struct ofp_action_header *actions, size_t actions_len,\n               const struct ofp_action_header *bad_action, enum ofperr error)\n{\n    if (!VLOG_DROP_WARN(&rl)) {\n        struct ds s;\n\n        ds_init(&s);\n        ds_put_hex_dump(&s, actions, actions_len, 0, false);\n        VLOG_WARN(\"bad action at offset %#\"PRIxPTR\" (%s):\\n%s\",\n                  (char *)bad_action - (char *)actions,\n                  ofperr_get_name(error), ds_cstr(&s));\n        ds_destroy(&s);\n    }\n}\n\nstatic enum ofperr\nofpacts_decode(const void *actions, size_t actions_len,\n               enum ofp_version ofp_version,\n               const struct vl_mff_map *vl_mff_map,\n               uint64_t *ofpacts_tlv_bitmap, struct ofpbuf *ofpacts)\n{\n    struct ofpbuf openflow = ofpbuf_const_initializer(actions, actions_len);\n    while (openflow.size) {\n        const struct ofp_action_header *action = openflow.data;\n        enum ofp_raw_action_type raw;\n        enum ofperr error;\n        uint64_t arg;\n\n        error = ofpact_pull_raw(&openflow, ofp_version, &raw, &arg);\n        if (!error) {\n            error = ofpact_decode(action, raw, ofp_version, arg, vl_mff_map,\n                                  ofpacts_tlv_bitmap, ofpacts);\n        }\n\n        if (error) {\n            log_bad_action(actions, actions_len, action, error);\n            return error;\n        }\n    }\n    return 0;\n}\n\nstatic enum ofperr\nofpacts_pull_openflow_actions__(struct ofpbuf *openflow,\n                                unsigned int actions_len,\n                                enum ofp_version version,\n                                uint32_t allowed_ovsinsts,\n                                struct ofpbuf *ofpacts,\n                                enum ofpact_type outer_action,\n                                const struct vl_mff_map *vl_mff_map,\n                                uint64_t *ofpacts_tlv_bitmap)\n{\n    const struct ofp_action_header *actions;\n    size_t orig_size = ofpacts->size;\n    enum ofperr error;\n\n    if (actions_len % OFP_ACTION_ALIGN != 0) {\n        VLOG_WARN_RL(&rl, \"OpenFlow message actions length %u is not a \"\n                     \"multiple of %d\", actions_len, OFP_ACTION_ALIGN);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    actions = ofpbuf_try_pull(openflow, actions_len);\n    if (actions == NULL) {\n        VLOG_WARN_RL(&rl, \"OpenFlow message actions length %u exceeds \"\n                     \"remaining message length (%\"PRIu32\")\",\n                     actions_len, openflow->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    error = ofpacts_decode(actions, actions_len, version, vl_mff_map,\n                           ofpacts_tlv_bitmap, ofpacts);\n    if (error) {\n        ofpacts->size = orig_size;\n        return error;\n    }\n\n    error = ofpacts_verify(ofpacts->data, ofpacts->size, allowed_ovsinsts,\n                           outer_action);\n    if (error) {\n        ofpacts->size = orig_size;\n    }\n    return error;\n}\n\n/* Attempts to convert 'actions_len' bytes of OpenFlow actions from the front\n * of 'openflow' into ofpacts.  On success, appends the converted actions to\n * 'ofpacts'; on failure, 'ofpacts' is unchanged (but might be reallocated) .\n * Returns 0 if successful, otherwise an OpenFlow error.\n *\n * Actions are processed according to their OpenFlow version which\n * is provided in the 'version' parameter.\n *\n * In most places in OpenFlow, actions appear encapsulated in instructions, so\n * you should call ofpacts_pull_openflow_instructions() instead of this\n * function.\n *\n * 'vl_mff_map' and 'ofpacts_tlv_bitmap' are optional. If 'vl_mff_map' is\n * provided, it is used to get variable length mf_fields with configured\n * length in the actions. If an action uses a variable length mf_field,\n * 'ofpacts_tlv_bitmap' is updated accordingly for ref counting. If\n * 'vl_mff_map' is not provided, the default mf_fields with maximum length\n * will be used.\n *\n * The parsed actions are valid generically, but they may not be valid in a\n * specific context.  For example, port numbers up to OFPP_MAX are valid\n * generically, but specific datapaths may only support port numbers in a\n * smaller range.  Use ofpacts_check() to additional check whether actions are\n * valid in a specific context. */\nenum ofperr\nofpacts_pull_openflow_actions(struct ofpbuf *openflow,\n                              unsigned int actions_len,\n                              enum ofp_version version,\n                              const struct vl_mff_map *vl_mff_map,\n                              uint64_t *ofpacts_tlv_bitmap,\n                              struct ofpbuf *ofpacts)\n{\n    return ofpacts_pull_openflow_actions__(openflow, actions_len, version,\n                                           1u << OVSINST_OFPIT11_APPLY_ACTIONS,\n                                           ofpacts, 0, vl_mff_map,\n                                           ofpacts_tlv_bitmap);\n}\n\f\n/* OpenFlow 1.1 actions. */\n\n\n/* True if an action sets the value of a field\n * in a way that is compatibile with the action set.\n * The field can be set via either a set or a move action.\n * False otherwise. */\nstatic bool\nofpact_is_set_or_move_action(const struct ofpact *a)\n{\n    switch (a->type) {\n    case OFPACT_SET_FIELD:\n    case OFPACT_REG_MOVE:\n    case OFPACT_SET_ETH_DST:\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_SET_IPV4_DST:\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_L4_DST_PORT:\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_SET_VLAN_PCP:\n    case OFPACT_SET_VLAN_VID:\n        return true;\n    case OFPACT_BUNDLE:\n    case OFPACT_CLEAR_ACTIONS:\n    case OFPACT_CT:\n    case OFPACT_CT_CLEAR:\n    case OFPACT_CLONE:\n    case OFPACT_NAT:\n    case OFPACT_CONTROLLER:\n    case OFPACT_DEC_MPLS_TTL:\n    case OFPACT_DEC_TTL:\n    case OFPACT_ENQUEUE:\n    case OFPACT_EXIT:\n    case OFPACT_UNROLL_XLATE:\n    case OFPACT_FIN_TIMEOUT:\n    case OFPACT_GOTO_TABLE:\n    case OFPACT_GROUP:\n    case OFPACT_LEARN:\n    case OFPACT_CONJUNCTION:\n    case OFPACT_METER:\n    case OFPACT_MULTIPATH:\n    case OFPACT_NOTE:\n    case OFPACT_OUTPUT:\n    case OFPACT_OUTPUT_REG:\n    case OFPACT_OUTPUT_TRUNC:\n    case OFPACT_POP_MPLS:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_PUSH_MPLS:\n    case OFPACT_PUSH_VLAN:\n    case OFPACT_RESUBMIT:\n    case OFPACT_SAMPLE:\n    case OFPACT_STACK_POP:\n    case OFPACT_STACK_PUSH:\n    case OFPACT_STRIP_VLAN:\n    case OFPACT_WRITE_ACTIONS:\n    case OFPACT_WRITE_METADATA:\n    case OFPACT_DEBUG_RECIRC:\n        return false;\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* True if an action is allowed in the action set.\n * False otherwise. */\nstatic bool\nofpact_is_allowed_in_actions_set(const struct ofpact *a)\n{\n    switch (a->type) {\n    case OFPACT_DEC_MPLS_TTL:\n    case OFPACT_DEC_TTL:\n    case OFPACT_GROUP:\n    case OFPACT_OUTPUT:\n    case OFPACT_OUTPUT_TRUNC:\n    case OFPACT_POP_MPLS:\n    case OFPACT_PUSH_MPLS:\n    case OFPACT_PUSH_VLAN:\n    case OFPACT_REG_MOVE:\n    case OFPACT_SET_FIELD:\n    case OFPACT_SET_ETH_DST:\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_SET_IPV4_DST:\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_L4_DST_PORT:\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_SET_VLAN_PCP:\n    case OFPACT_SET_VLAN_VID:\n    case OFPACT_STRIP_VLAN:\n        return true;\n\n    /* In general these actions are excluded because they are not part of\n     * the OpenFlow specification nor map to actions that are defined in\n     * the specification.  Thus the order in which they should be applied\n     * in the action set is undefined. */\n    case OFPACT_BUNDLE:\n    case OFPACT_CLONE:\n    case OFPACT_CONTROLLER:\n    case OFPACT_CT:\n    case OFPACT_CT_CLEAR:\n    case OFPACT_NAT:\n    case OFPACT_ENQUEUE:\n    case OFPACT_EXIT:\n    case OFPACT_UNROLL_XLATE:\n    case OFPACT_FIN_TIMEOUT:\n    case OFPACT_LEARN:\n    case OFPACT_CONJUNCTION:\n    case OFPACT_MULTIPATH:\n    case OFPACT_NOTE:\n    case OFPACT_OUTPUT_REG:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_RESUBMIT:\n    case OFPACT_SAMPLE:\n    case OFPACT_STACK_POP:\n    case OFPACT_STACK_PUSH:\n    case OFPACT_DEBUG_RECIRC:\n\n    /* The action set may only include actions and thus\n     * may not include any instructions */\n    case OFPACT_CLEAR_ACTIONS:\n    case OFPACT_GOTO_TABLE:\n    case OFPACT_METER:\n    case OFPACT_WRITE_ACTIONS:\n    case OFPACT_WRITE_METADATA:\n        return false;\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Append ofpact 'a' onto the tail of 'out' */\nstatic void\nofpact_copy(struct ofpbuf *out, const struct ofpact *a)\n{\n    ofpbuf_put(out, a, OFPACT_ALIGN(a->len));\n}\n\n/* Copies the last ofpact whose type is 'filter' from 'in' to 'out'. */\nstatic bool\nofpacts_copy_last(struct ofpbuf *out, const struct ofpbuf *in,\n                  enum ofpact_type filter)\n{\n    const struct ofpact *target;\n    const struct ofpact *a;\n\n    target = NULL;\n    OFPACT_FOR_EACH (a, in->data, in->size) {\n        if (a->type == filter) {\n            target = a;\n        }\n    }\n    if (target) {\n        ofpact_copy(out, target);\n    }\n    return target != NULL;\n}\n\n/* Append all ofpacts, for which 'filter' returns true, from 'in' to 'out'.\n * The order of appended ofpacts is preserved between 'in' and 'out' */\nstatic void\nofpacts_copy_all(struct ofpbuf *out, const struct ofpbuf *in,\n                 bool (*filter)(const struct ofpact *))\n{\n    const struct ofpact *a;\n\n    OFPACT_FOR_EACH (a, in->data, in->size) {\n        if (filter(a)) {\n            ofpact_copy(out, a);\n        }\n    }\n}\n\n/* Reads 'action_set', which contains ofpacts accumulated by\n * OFPACT_WRITE_ACTIONS instructions, and writes equivalent actions to be\n * executed directly into 'action_list'.  (These names correspond to the\n * \"Action Set\" and \"Action List\" terms used in OpenFlow 1.1+.)\n *\n * In general this involves appending the last instance of each action that is\n * admissible in the action set in the order described in the OpenFlow\n * specification.\n *\n * Exceptions:\n * + output action is only appended if no group action was present in 'in'.\n * + As a simplification all set actions are copied in the order the are\n *   provided in 'in' as many set actions applied to a field has the same\n *   affect as only applying the last action that sets a field and\n *   duplicates are removed by do_xlate_actions().\n *   This has an unwanted side-effect of compsoting multiple\n *   LOAD_REG actions that touch different regions of the same field. */\nvoid\nofpacts_execute_action_set(struct ofpbuf *action_list,\n                           const struct ofpbuf *action_set)\n{\n    /* The OpenFlow spec \"Action Set\" section specifies this order. */\n    ofpacts_copy_last(action_list, action_set, OFPACT_STRIP_VLAN);\n    ofpacts_copy_last(action_list, action_set, OFPACT_POP_MPLS);\n    ofpacts_copy_last(action_list, action_set, OFPACT_PUSH_MPLS);\n    ofpacts_copy_last(action_list, action_set, OFPACT_PUSH_VLAN);\n    ofpacts_copy_last(action_list, action_set, OFPACT_DEC_TTL);\n    ofpacts_copy_last(action_list, action_set, OFPACT_DEC_MPLS_TTL);\n    ofpacts_copy_all(action_list, action_set, ofpact_is_set_or_move_action);\n    ofpacts_copy_last(action_list, action_set, OFPACT_SET_QUEUE);\n\n    /* If both OFPACT_GROUP and OFPACT_OUTPUT are present, OpenFlow says that\n     * we should execute only OFPACT_GROUP.\n     *\n     * If neither OFPACT_GROUP nor OFPACT_OUTPUT is present, then we can drop\n     * all the actions because there's no point in modifying a packet that will\n     * not be sent anywhere. */\n    if (!ofpacts_copy_last(action_list, action_set, OFPACT_GROUP) &&\n        !ofpacts_copy_last(action_list, action_set, OFPACT_OUTPUT) &&\n        !ofpacts_copy_last(action_list, action_set, OFPACT_RESUBMIT) &&\n        !ofpacts_copy_last(action_list, action_set, OFPACT_CT)) {\n        ofpbuf_clear(action_list);\n    }\n}\n\n\nstatic enum ofperr\nofpacts_decode_for_action_set(const struct ofp_action_header *in,\n                              size_t n_in, enum ofp_version version,\n                              const struct vl_mff_map *vl_mff_map,\n                              uint64_t *ofpacts_tlv_bitmap,\n                              struct ofpbuf *out)\n{\n    enum ofperr error;\n    struct ofpact *a;\n    size_t start = out->size;\n\n    error = ofpacts_decode(in, n_in, version, vl_mff_map, ofpacts_tlv_bitmap,\n                           out);\n\n    if (error) {\n        return error;\n    }\n\n    OFPACT_FOR_EACH (a, ofpact_end(out->data, start), out->size - start) {\n        if (!ofpact_is_allowed_in_actions_set(a)) {\n            VLOG_WARN_RL(&rl, \"disallowed action in action set\");\n            return OFPERR_OFPBAC_BAD_TYPE;\n        }\n    }\n\n    return 0;\n}\n\f\n/* OpenFlow 1.1 instructions. */\n\nstruct instruction_type_info {\n    enum ovs_instruction_type type;\n    const char *name;\n};\n\nstatic const struct instruction_type_info inst_info[] = {\n#define DEFINE_INST(ENUM, STRUCT, EXTENSIBLE, NAME)    {OVSINST_##ENUM, NAME},\nOVS_INSTRUCTIONS\n#undef DEFINE_INST\n};\n\nconst char *\novs_instruction_name_from_type(enum ovs_instruction_type type)\n{\n    return type < ARRAY_SIZE(inst_info) ? inst_info[type].name : NULL;\n}\n\nint\novs_instruction_type_from_name(const char *name)\n{\n    const struct instruction_type_info *p;\n    for (p = inst_info; p < &inst_info[ARRAY_SIZE(inst_info)]; p++) {\n        if (!strcasecmp(name, p->name)) {\n            return p->type;\n        }\n    }\n    return -1;\n}\n\nenum ovs_instruction_type\novs_instruction_type_from_ofpact_type(enum ofpact_type type)\n{\n    switch (type) {\n    case OFPACT_METER:\n        return OVSINST_OFPIT13_METER;\n    case OFPACT_CLEAR_ACTIONS:\n        return OVSINST_OFPIT11_CLEAR_ACTIONS;\n    case OFPACT_WRITE_ACTIONS:\n        return OVSINST_OFPIT11_WRITE_ACTIONS;\n    case OFPACT_WRITE_METADATA:\n        return OVSINST_OFPIT11_WRITE_METADATA;\n    case OFPACT_GOTO_TABLE:\n        return OVSINST_OFPIT11_GOTO_TABLE;\n    case OFPACT_OUTPUT:\n    case OFPACT_GROUP:\n    case OFPACT_CLONE:\n    case OFPACT_CONTROLLER:\n    case OFPACT_ENQUEUE:\n    case OFPACT_OUTPUT_REG:\n    case OFPACT_OUTPUT_TRUNC:\n    case OFPACT_BUNDLE:\n    case OFPACT_SET_VLAN_VID:\n    case OFPACT_SET_VLAN_PCP:\n    case OFPACT_STRIP_VLAN:\n    case OFPACT_PUSH_VLAN:\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_ETH_DST:\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_IPV4_DST:\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_L4_DST_PORT:\n    case OFPACT_REG_MOVE:\n    case OFPACT_SET_FIELD:\n    case OFPACT_STACK_PUSH:\n    case OFPACT_STACK_POP:\n    case OFPACT_DEC_TTL:\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_DEC_MPLS_TTL:\n    case OFPACT_PUSH_MPLS:\n    case OFPACT_POP_MPLS:\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_FIN_TIMEOUT:\n    case OFPACT_RESUBMIT:\n    case OFPACT_LEARN:\n    case OFPACT_CONJUNCTION:\n    case OFPACT_MULTIPATH:\n    case OFPACT_NOTE:\n    case OFPACT_EXIT:\n    case OFPACT_UNROLL_XLATE:\n    case OFPACT_SAMPLE:\n    case OFPACT_DEBUG_RECIRC:\n    case OFPACT_CT:\n    case OFPACT_CT_CLEAR:\n    case OFPACT_NAT:\n    default:\n        return OVSINST_OFPIT11_APPLY_ACTIONS;\n    }\n}\n\nenum ofperr\novs_instruction_type_from_inst_type(enum ovs_instruction_type *instruction_type,\n                                    const uint16_t inst_type)\n{\n    switch (inst_type) {\n\n#define DEFINE_INST(ENUM, STRUCT, EXTENSIBLE, NAME) \\\n    case ENUM:                                      \\\n        *instruction_type = OVSINST_##ENUM;         \\\n        return 0;\nOVS_INSTRUCTIONS\n#undef DEFINE_INST\n\n    default:\n        return OFPERR_OFPBIC_UNKNOWN_INST;\n    }\n}\n\n/* Two-way translation between OVS's internal \"OVSINST_*\" representation of\n * instructions and the \"OFPIT_*\" representation used in OpenFlow. */\nstruct ovsinst_map {\n    enum ovs_instruction_type ovsinst; /* Internal name for instruction. */\n    int ofpit;                         /* OFPIT_* number from OpenFlow spec. */\n};\n\nstatic const struct ovsinst_map *\nget_ovsinst_map(enum ofp_version version)\n{\n    /* OpenFlow 1.1 and 1.2 instructions. */\n    static const struct ovsinst_map of11[] = {\n        { OVSINST_OFPIT11_GOTO_TABLE, 1 },\n        { OVSINST_OFPIT11_WRITE_METADATA, 2 },\n        { OVSINST_OFPIT11_WRITE_ACTIONS, 3 },\n        { OVSINST_OFPIT11_APPLY_ACTIONS, 4 },\n        { OVSINST_OFPIT11_CLEAR_ACTIONS, 5 },\n        { 0, -1 },\n    };\n\n    /* OpenFlow 1.3+ instructions. */\n    static const struct ovsinst_map of13[] = {\n        { OVSINST_OFPIT11_GOTO_TABLE, 1 },\n        { OVSINST_OFPIT11_WRITE_METADATA, 2 },\n        { OVSINST_OFPIT11_WRITE_ACTIONS, 3 },\n        { OVSINST_OFPIT11_APPLY_ACTIONS, 4 },\n        { OVSINST_OFPIT11_CLEAR_ACTIONS, 5 },\n        { OVSINST_OFPIT13_METER, 6 },\n        { 0, -1 },\n    };\n\n    return version < OFP13_VERSION ? of11 : of13;\n}\n\n/* Converts 'ovsinst_bitmap', a bitmap whose bits correspond to OVSINST_*\n * values, into a bitmap of instructions suitable for OpenFlow 'version'\n * (OFP11_VERSION or later), and returns the result. */\novs_be32\novsinst_bitmap_to_openflow(uint32_t ovsinst_bitmap, enum ofp_version version)\n{\n    uint32_t ofpit_bitmap = 0;\n    const struct ovsinst_map *x;\n\n    for (x = get_ovsinst_map(version); x->ofpit >= 0; x++) {\n        if (ovsinst_bitmap & (1u << x->ovsinst)) {\n            ofpit_bitmap |= 1u << x->ofpit;\n        }\n    }\n    return htonl(ofpit_bitmap);\n}\n\n/* Converts 'ofpit_bitmap', a bitmap of instructions from an OpenFlow message\n * with the given 'version' (OFP11_VERSION or later) into a bitmap whose bits\n * correspond to OVSINST_* values, and returns the result. */\nuint32_t\novsinst_bitmap_from_openflow(ovs_be32 ofpit_bitmap, enum ofp_version version)\n{\n    uint32_t ovsinst_bitmap = 0;\n    const struct ovsinst_map *x;\n\n    for (x = get_ovsinst_map(version); x->ofpit >= 0; x++) {\n        if (ofpit_bitmap & htonl(1u << x->ofpit)) {\n            ovsinst_bitmap |= 1u << x->ovsinst;\n        }\n    }\n    return ovsinst_bitmap;\n}\n\nstatic inline struct ofp11_instruction *\ninstruction_next(const struct ofp11_instruction *inst)\n{\n    return ((struct ofp11_instruction *) (void *)\n            ((uint8_t *) inst + ntohs(inst->len)));\n}\n\nstatic inline bool\ninstruction_is_valid(const struct ofp11_instruction *inst,\n                     size_t n_instructions)\n{\n    uint16_t len = ntohs(inst->len);\n    return (!(len % OFP11_INSTRUCTION_ALIGN)\n            && len >= sizeof *inst\n            && len / sizeof *inst <= n_instructions);\n}\n\n/* This macro is careful to check for instructions with bad lengths. */\n#define INSTRUCTION_FOR_EACH(ITER, LEFT, INSTRUCTIONS, N_INSTRUCTIONS)  \\\n    for ((ITER) = (INSTRUCTIONS), (LEFT) = (N_INSTRUCTIONS);            \\\n         (LEFT) > 0 && instruction_is_valid(ITER, LEFT);                \\\n         ((LEFT) -= (ntohs((ITER)->len)                                 \\\n                     / sizeof(struct ofp11_instruction)),               \\\n          (ITER) = instruction_next(ITER)))\n\nstatic enum ofperr\ndecode_openflow11_instruction(const struct ofp11_instruction *inst,\n                              enum ovs_instruction_type *type)\n{\n    uint16_t len = ntohs(inst->len);\n\n    switch (inst->type) {\n    case CONSTANT_HTONS(OFPIT11_EXPERIMENTER):\n        return OFPERR_OFPBIC_BAD_EXPERIMENTER;\n\n#define DEFINE_INST(ENUM, STRUCT, EXTENSIBLE, NAME)     \\\n        case CONSTANT_HTONS(ENUM):                      \\\n            if (EXTENSIBLE                              \\\n                ? len >= sizeof(struct STRUCT)          \\\n                : len == sizeof(struct STRUCT)) {       \\\n                *type = OVSINST_##ENUM;                 \\\n                return 0;                               \\\n            } else {                                    \\\n                return OFPERR_OFPBIC_BAD_LEN;           \\\n            }\nOVS_INSTRUCTIONS\n#undef DEFINE_INST\n\n    default:\n        return OFPERR_OFPBIC_UNKNOWN_INST;\n    }\n}\n\nstatic enum ofperr\ndecode_openflow11_instructions(const struct ofp11_instruction insts[],\n                               size_t n_insts,\n                               const struct ofp11_instruction *out[])\n{\n    const struct ofp11_instruction *inst;\n    size_t left;\n\n    memset(out, 0, N_OVS_INSTRUCTIONS * sizeof *out);\n    INSTRUCTION_FOR_EACH (inst, left, insts, n_insts) {\n        enum ovs_instruction_type type;\n        enum ofperr error;\n\n        error = decode_openflow11_instruction(inst, &type);\n        if (error) {\n            return error;\n        }\n\n        if (out[type]) {\n            return OFPERR_OFPBIC_DUP_INST;\n        }\n        out[type] = inst;\n    }\n\n    if (left) {\n        VLOG_WARN_RL(&rl, \"bad instruction format at offset %\"PRIuSIZE,\n                     (n_insts - left) * sizeof *inst);\n        return OFPERR_OFPBIC_BAD_LEN;\n    }\n    return 0;\n}\n\nstatic void\nget_actions_from_instruction(const struct ofp11_instruction *inst,\n                             const struct ofp_action_header **actions,\n                             size_t *actions_len)\n{\n    *actions = ALIGNED_CAST(const struct ofp_action_header *, inst + 1);\n    *actions_len = ntohs(inst->len) - sizeof *inst;\n}\n\nenum ofperr\nofpacts_pull_openflow_instructions(struct ofpbuf *openflow,\n                                   unsigned int instructions_len,\n                                   enum ofp_version version,\n                                   const struct vl_mff_map *vl_mff_map,\n                                   uint64_t *ofpacts_tlv_bitmap,\n                                   struct ofpbuf *ofpacts)\n{\n    const struct ofp11_instruction *instructions;\n    const struct ofp11_instruction *insts[N_OVS_INSTRUCTIONS];\n    enum ofperr error;\n\n    ofpbuf_clear(ofpacts);\n    if (version == OFP10_VERSION) {\n        return ofpacts_pull_openflow_actions__(openflow, instructions_len,\n                                               version,\n                                               (1u << N_OVS_INSTRUCTIONS) - 1,\n                                               ofpacts, 0, vl_mff_map,\n                                               ofpacts_tlv_bitmap);\n    }\n\n    if (instructions_len % OFP11_INSTRUCTION_ALIGN != 0) {\n        VLOG_WARN_RL(&rl, \"OpenFlow message instructions length %u is not a \"\n                     \"multiple of %d\",\n                     instructions_len, OFP11_INSTRUCTION_ALIGN);\n        error = OFPERR_OFPBIC_BAD_LEN;\n        goto exit;\n    }\n\n    instructions = ofpbuf_try_pull(openflow, instructions_len);\n    if (instructions == NULL) {\n        VLOG_WARN_RL(&rl, \"OpenFlow message instructions length %u exceeds \"\n                     \"remaining message length (%\"PRIu32\")\",\n                     instructions_len, openflow->size);\n        error = OFPERR_OFPBIC_BAD_LEN;\n        goto exit;\n    }\n\n    error = decode_openflow11_instructions(\n        instructions, instructions_len / OFP11_INSTRUCTION_ALIGN,\n        insts);\n    if (error) {\n        goto exit;\n    }\n\n    if (insts[OVSINST_OFPIT13_METER]) {\n        const struct ofp13_instruction_meter *oim;\n        struct ofpact_meter *om;\n\n        oim = ALIGNED_CAST(const struct ofp13_instruction_meter *,\n                           insts[OVSINST_OFPIT13_METER]);\n\n        om = ofpact_put_METER(ofpacts);\n        om->meter_id = ntohl(oim->meter_id);\n    }\n    if (insts[OVSINST_OFPIT11_APPLY_ACTIONS]) {\n        const struct ofp_action_header *actions;\n        size_t actions_len;\n\n        get_actions_from_instruction(insts[OVSINST_OFPIT11_APPLY_ACTIONS],\n                                     &actions, &actions_len);\n        error = ofpacts_decode(actions, actions_len, version, vl_mff_map,\n                               ofpacts_tlv_bitmap, ofpacts);\n        if (error) {\n            goto exit;\n        }\n    }\n    if (insts[OVSINST_OFPIT11_CLEAR_ACTIONS]) {\n        instruction_get_OFPIT11_CLEAR_ACTIONS(\n            insts[OVSINST_OFPIT11_CLEAR_ACTIONS]);\n        ofpact_put_CLEAR_ACTIONS(ofpacts);\n    }\n    if (insts[OVSINST_OFPIT11_WRITE_ACTIONS]) {\n        struct ofpact_nest *on;\n        const struct ofp_action_header *actions;\n        size_t actions_len;\n        size_t start = ofpacts->size;\n        ofpact_put(ofpacts, OFPACT_WRITE_ACTIONS,\n                   offsetof(struct ofpact_nest, actions));\n        get_actions_from_instruction(insts[OVSINST_OFPIT11_WRITE_ACTIONS],\n                                     &actions, &actions_len);\n        error = ofpacts_decode_for_action_set(actions, actions_len,\n                                              version, vl_mff_map,\n                                              ofpacts_tlv_bitmap, ofpacts);\n        if (error) {\n            goto exit;\n        }\n        on = ofpbuf_at_assert(ofpacts, start, sizeof *on);\n        on->ofpact.len = ofpacts->size - start;\n    }\n    if (insts[OVSINST_OFPIT11_WRITE_METADATA]) {\n        const struct ofp11_instruction_write_metadata *oiwm;\n        struct ofpact_metadata *om;\n\n        oiwm = ALIGNED_CAST(const struct ofp11_instruction_write_metadata *,\n                            insts[OVSINST_OFPIT11_WRITE_METADATA]);\n\n        om = ofpact_put_WRITE_METADATA(ofpacts);\n        om->metadata = oiwm->metadata;\n        om->mask = oiwm->metadata_mask;\n    }\n    if (insts[OVSINST_OFPIT11_GOTO_TABLE]) {\n        const struct ofp11_instruction_goto_table *oigt;\n        struct ofpact_goto_table *ogt;\n\n        oigt = instruction_get_OFPIT11_GOTO_TABLE(\n            insts[OVSINST_OFPIT11_GOTO_TABLE]);\n        ogt = ofpact_put_GOTO_TABLE(ofpacts);\n        ogt->table_id = oigt->table_id;\n    }\n\n    error = ofpacts_verify(ofpacts->data, ofpacts->size,\n                           (1u << N_OVS_INSTRUCTIONS) - 1, 0);\nexit:\n    if (error) {\n        ofpbuf_clear(ofpacts);\n    }\n    return error;\n}\n\n/* Update the length of the instruction that begins at offset 'ofs' within\n * 'openflow' and contains nested actions that extend to the end of 'openflow'.\n * If the instruction contains no nested actions, deletes it entirely. */\nstatic void\nofpacts_update_instruction_actions(struct ofpbuf *openflow, size_t ofs)\n{\n    struct ofp11_instruction_actions *oia;\n\n    oia = ofpbuf_at_assert(openflow, ofs, sizeof *oia);\n    if (openflow->size > ofs + sizeof *oia) {\n        oia->len = htons(openflow->size - ofs);\n    } else {\n        openflow->size = ofs;\n    }\n}\n\f\n/* Checks that 'port' is a valid output port for OFPACT_OUTPUT, given that the\n * switch will never have more than 'max_ports' ports.  Returns 0 if 'port' is\n * valid, otherwise an OpenFlow error code. */\nenum ofperr\nofpact_check_output_port(ofp_port_t port, ofp_port_t max_ports)\n{\n    switch (port) {\n    case OFPP_IN_PORT:\n    case OFPP_TABLE:\n    case OFPP_NORMAL:\n    case OFPP_FLOOD:\n    case OFPP_ALL:\n    case OFPP_CONTROLLER:\n    case OFPP_LOCAL:\n        return 0;\n\n    case OFPP_NONE:\n        return OFPERR_OFPBAC_BAD_OUT_PORT;\n\n    default:\n        if (ofp_to_u16(port) < ofp_to_u16(max_ports)) {\n            return 0;\n        }\n        return OFPERR_OFPBAC_BAD_OUT_PORT;\n    }\n}\n\n/* Removes the protocols that require consistency between match and actions\n * (that's everything but OpenFlow 1.0) from '*usable_protocols'.\n *\n * (An example of an inconsistency between match and actions is a flow that\n * does not match on an MPLS Ethertype but has an action that pops an MPLS\n * label.) */\nstatic void\ninconsistent_match(enum ofputil_protocol *usable_protocols)\n{\n    *usable_protocols &= OFPUTIL_P_OF10_ANY;\n}\n\n/* May modify flow->dl_type, flow->nw_proto and flow->vlan_tci,\n * caller must restore them.\n *\n * Modifies some actions, filling in fields that could not be properly set\n * without context. */\nstatic enum ofperr\nofpact_check__(enum ofputil_protocol *usable_protocols, struct ofpact *a,\n               struct flow *flow, ofp_port_t max_ports,\n               uint8_t table_id, uint8_t n_tables)\n{\n    const struct ofpact_enqueue *enqueue;\n    const struct mf_field *mf;\n\n    switch (a->type) {\n    case OFPACT_OUTPUT:\n        return ofpact_check_output_port(ofpact_get_OUTPUT(a)->port,\n                                        max_ports);\n\n    case OFPACT_CONTROLLER:\n        return 0;\n\n    case OFPACT_ENQUEUE:\n        enqueue = ofpact_get_ENQUEUE(a);\n        if (ofp_to_u16(enqueue->port) >= ofp_to_u16(max_ports)\n            && enqueue->port != OFPP_IN_PORT\n            && enqueue->port != OFPP_LOCAL) {\n            return OFPERR_OFPBAC_BAD_OUT_PORT;\n        }\n        return 0;\n\n    case OFPACT_OUTPUT_REG:\n        return mf_check_src(&ofpact_get_OUTPUT_REG(a)->src, flow);\n\n    case OFPACT_OUTPUT_TRUNC:\n        return ofpact_check_output_port(ofpact_get_OUTPUT_TRUNC(a)->port,\n                                        max_ports);\n\n    case OFPACT_BUNDLE:\n        return bundle_check(ofpact_get_BUNDLE(a), max_ports, flow);\n\n    case OFPACT_SET_VLAN_VID:\n        /* Remember if we saw a vlan tag in the flow to aid translating to\n         * OpenFlow 1.1+ if need be. */\n        ofpact_get_SET_VLAN_VID(a)->flow_has_vlan =\n            (flow->vlan_tci & htons(VLAN_CFI)) == htons(VLAN_CFI);\n        if (!(flow->vlan_tci & htons(VLAN_CFI)) &&\n            !ofpact_get_SET_VLAN_VID(a)->push_vlan_if_needed) {\n            inconsistent_match(usable_protocols);\n        }\n        /* Temporary mark that we have a vlan tag. */\n        flow->vlan_tci |= htons(VLAN_CFI);\n        return 0;\n\n    case OFPACT_SET_VLAN_PCP:\n        /* Remember if we saw a vlan tag in the flow to aid translating to\n         * OpenFlow 1.1+ if need be. */\n        ofpact_get_SET_VLAN_PCP(a)->flow_has_vlan =\n            (flow->vlan_tci & htons(VLAN_CFI)) == htons(VLAN_CFI);\n        if (!(flow->vlan_tci & htons(VLAN_CFI)) &&\n            !ofpact_get_SET_VLAN_PCP(a)->push_vlan_if_needed) {\n            inconsistent_match(usable_protocols);\n        }\n        /* Temporary mark that we have a vlan tag. */\n        flow->vlan_tci |= htons(VLAN_CFI);\n        return 0;\n\n    case OFPACT_STRIP_VLAN:\n        if (!(flow->vlan_tci & htons(VLAN_CFI))) {\n            inconsistent_match(usable_protocols);\n        }\n        /* Temporary mark that we have no vlan tag. */\n        flow->vlan_tci = htons(0);\n        return 0;\n\n    case OFPACT_PUSH_VLAN:\n        if (flow->vlan_tci & htons(VLAN_CFI)) {\n            /* Multiple VLAN headers not supported. */\n            return OFPERR_OFPBAC_BAD_TAG;\n        }\n        /* Temporary mark that we have a vlan tag. */\n        flow->vlan_tci |= htons(VLAN_CFI);\n        return 0;\n\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_ETH_DST:\n        return 0;\n\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_IPV4_DST:\n        if (flow->dl_type != htons(ETH_TYPE_IP)) {\n            inconsistent_match(usable_protocols);\n        }\n        return 0;\n\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_DEC_TTL:\n        if (!is_ip_any(flow)) {\n            inconsistent_match(usable_protocols);\n        }\n        return 0;\n\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_L4_DST_PORT:\n        if (!is_ip_any(flow) || (flow->nw_frag & FLOW_NW_FRAG_LATER) ||\n            (flow->nw_proto != IPPROTO_TCP && flow->nw_proto != IPPROTO_UDP\n             && flow->nw_proto != IPPROTO_SCTP)) {\n            inconsistent_match(usable_protocols);\n        }\n        /* Note on which transport protocol the port numbers are set.\n         * This allows this set action to be converted to an OF1.2 set field\n         * action. */\n        if (a->type == OFPACT_SET_L4_SRC_PORT) {\n            ofpact_get_SET_L4_SRC_PORT(a)->flow_ip_proto = flow->nw_proto;\n        } else {\n            ofpact_get_SET_L4_DST_PORT(a)->flow_ip_proto = flow->nw_proto;\n        }\n        return 0;\n\n    case OFPACT_REG_MOVE:\n        return nxm_reg_move_check(ofpact_get_REG_MOVE(a), flow);\n\n    case OFPACT_SET_FIELD:\n        mf = ofpact_get_SET_FIELD(a)->field;\n        /* Require OXM_OF_VLAN_VID to have an existing VLAN header. */\n        if (!mf_are_prereqs_ok(mf, flow, NULL) ||\n            (mf->id == MFF_VLAN_VID && !(flow->vlan_tci & htons(VLAN_CFI)))) {\n            VLOG_WARN_RL(&rl, \"set_field %s lacks correct prerequisities\",\n                         mf->name);\n            return OFPERR_OFPBAC_MATCH_INCONSISTENT;\n        }\n        /* Remember if we saw a vlan tag in the flow to aid translating to\n         * OpenFlow 1.1 if need be. */\n        ofpact_get_SET_FIELD(a)->flow_has_vlan =\n            (flow->vlan_tci & htons(VLAN_CFI)) == htons(VLAN_CFI);\n        if (mf->id == MFF_VLAN_TCI) {\n            /* The set field may add or remove the vlan tag,\n             * Mark the status temporarily. */\n            flow->vlan_tci = ofpact_get_SET_FIELD(a)->value->be16;\n        }\n        return 0;\n\n    case OFPACT_STACK_PUSH:\n        return nxm_stack_push_check(ofpact_get_STACK_PUSH(a), flow);\n\n    case OFPACT_STACK_POP:\n        return nxm_stack_pop_check(ofpact_get_STACK_POP(a), flow);\n\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_DEC_MPLS_TTL:\n        if (!eth_type_mpls(flow->dl_type)) {\n            inconsistent_match(usable_protocols);\n        }\n        return 0;\n\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_RESUBMIT:\n        return 0;\n\n    case OFPACT_FIN_TIMEOUT:\n        if (flow->nw_proto != IPPROTO_TCP) {\n            inconsistent_match(usable_protocols);\n        }\n        return 0;\n\n    case OFPACT_LEARN:\n        return learn_check(ofpact_get_LEARN(a), flow);\n\n    case OFPACT_CONJUNCTION:\n        return 0;\n\n    case OFPACT_MULTIPATH:\n        return multipath_check(ofpact_get_MULTIPATH(a), flow);\n\n    case OFPACT_NOTE:\n    case OFPACT_EXIT:\n        return 0;\n\n    case OFPACT_PUSH_MPLS:\n        flow->dl_type = ofpact_get_PUSH_MPLS(a)->ethertype;\n        /* The packet is now MPLS and the MPLS payload is opaque.\n         * Thus nothing can be assumed about the network protocol.\n         * Temporarily mark that we have no nw_proto. */\n        flow->nw_proto = 0;\n        return 0;\n\n    case OFPACT_POP_MPLS:\n        if (!eth_type_mpls(flow->dl_type)) {\n            inconsistent_match(usable_protocols);\n        }\n        flow->dl_type = ofpact_get_POP_MPLS(a)->ethertype;\n        return 0;\n\n    case OFPACT_SAMPLE:\n        return 0;\n\n    case OFPACT_CLONE: {\n        struct ofpact_nest *on = ofpact_get_CLONE(a);\n        return ofpacts_check(on->actions, ofpact_nest_get_action_len(on),\n                             flow, max_ports, table_id, n_tables,\n                             usable_protocols);\n    }\n\n    case OFPACT_CT: {\n        struct ofpact_conntrack *oc = ofpact_get_CT(a);\n\n        if (!dl_type_is_ip_any(flow->dl_type)\n            || (flow->ct_state & CS_INVALID && oc->flags & NX_CT_F_COMMIT)\n            || (oc->alg == IPPORT_FTP && flow->nw_proto != IPPROTO_TCP)\n            || (oc->alg == IPPORT_TFTP && flow->nw_proto != IPPROTO_UDP)) {\n            /* We can't downgrade to OF1.0 and expect inconsistent CT actions\n             * be silently discarded.  Instead, datapath flow install fails, so\n             * it is better to flag inconsistent CT actions as hard errors. */\n            return OFPERR_OFPBAC_MATCH_INCONSISTENT;\n        }\n\n        if (oc->zone_src.field) {\n            return mf_check_src(&oc->zone_src, flow);\n        }\n\n        return ofpacts_check(oc->actions, ofpact_ct_get_action_len(oc),\n                             flow, max_ports, table_id, n_tables,\n                             usable_protocols);\n    }\n\n    case OFPACT_CT_CLEAR:\n        return 0;\n\n    case OFPACT_NAT: {\n        struct ofpact_nat *on = ofpact_get_NAT(a);\n\n        if (!dl_type_is_ip_any(flow->dl_type) ||\n            (on->range_af == AF_INET && flow->dl_type != htons(ETH_TYPE_IP)) ||\n            (on->range_af == AF_INET6\n             && flow->dl_type != htons(ETH_TYPE_IPV6))) {\n            return OFPERR_OFPBAC_MATCH_INCONSISTENT;\n        }\n        return 0;\n    }\n\n    case OFPACT_CLEAR_ACTIONS:\n        return 0;\n\n    case OFPACT_WRITE_ACTIONS: {\n        /* Use a temporary copy of 'usable_protocols' because we can't check\n         * consistency of an action set. */\n        struct ofpact_nest *on = ofpact_get_WRITE_ACTIONS(a);\n        enum ofputil_protocol p = *usable_protocols;\n        return ofpacts_check(on->actions, ofpact_nest_get_action_len(on),\n                             flow, max_ports, table_id, n_tables, &p);\n    }\n\n    case OFPACT_WRITE_METADATA:\n        return 0;\n\n    case OFPACT_METER: {\n        uint32_t mid = ofpact_get_METER(a)->meter_id;\n        if (mid == 0 || mid > OFPM13_MAX) {\n            return OFPERR_OFPMMFC_INVALID_METER;\n        }\n        return 0;\n    }\n\n    case OFPACT_GOTO_TABLE: {\n        uint8_t goto_table = ofpact_get_GOTO_TABLE(a)->table_id;\n        if ((table_id != 255 && goto_table <= table_id)\n            || (n_tables != 255 && goto_table >= n_tables)) {\n            return OFPERR_OFPBIC_BAD_TABLE_ID;\n        }\n        return 0;\n    }\n\n    case OFPACT_GROUP:\n        return 0;\n\n    case OFPACT_UNROLL_XLATE:\n        /* UNROLL is an internal action that should never be seen via\n         * OpenFlow. */\n        return OFPERR_OFPBAC_BAD_TYPE;\n\n    case OFPACT_DEBUG_RECIRC:\n        return 0;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Checks that the 'ofpacts_len' bytes of actions in 'ofpacts' are\n * appropriate for a packet with the prerequisites satisfied by 'flow' in a\n * switch with no more than 'max_ports' ports.\n *\n * If 'ofpacts' and 'flow' are inconsistent with one another, un-sets in\n * '*usable_protocols' the protocols that forbid the inconsistency.  (An\n * example of an inconsistency between match and actions is a flow that does\n * not match on an MPLS Ethertype but has an action that pops an MPLS label.)\n *\n * May annotate ofpacts with information gathered from the 'flow'.\n *\n * May temporarily modify 'flow', but restores the changes before returning. */\nenum ofperr\nofpacts_check(struct ofpact ofpacts[], size_t ofpacts_len,\n              struct flow *flow, ofp_port_t max_ports,\n              uint8_t table_id, uint8_t n_tables,\n              enum ofputil_protocol *usable_protocols)\n{\n    struct ofpact *a;\n    ovs_be16 dl_type = flow->dl_type;\n    ovs_be16 vlan_tci = flow->vlan_tci;\n    uint8_t nw_proto = flow->nw_proto;\n    enum ofperr error = 0;\n\n    OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {\n        error = ofpact_check__(usable_protocols, a, flow,\n                               max_ports, table_id, n_tables);\n        if (error) {\n            break;\n        }\n    }\n    /* Restore fields that may have been modified. */\n    flow->dl_type = dl_type;\n    flow->vlan_tci = vlan_tci;\n    flow->nw_proto = nw_proto;\n    return error;\n}\n\n/* Like ofpacts_check(), but reports inconsistencies as\n * OFPERR_OFPBAC_MATCH_INCONSISTENT rather than clearing bits. */\nenum ofperr\nofpacts_check_consistency(struct ofpact ofpacts[], size_t ofpacts_len,\n                          struct flow *flow, ofp_port_t max_ports,\n                          uint8_t table_id, uint8_t n_tables,\n                          enum ofputil_protocol usable_protocols)\n{\n    enum ofputil_protocol p = usable_protocols;\n    enum ofperr error;\n\n    error = ofpacts_check(ofpacts, ofpacts_len, flow, max_ports,\n                          table_id, n_tables, &p);\n    return (error ? error\n            : p != usable_protocols ? OFPERR_OFPBAC_MATCH_INCONSISTENT\n            : 0);\n}\n\n/* Returns the destination field that 'ofpact' would write to, or NULL\n * if the action would not write to an mf_field. */\nconst struct mf_field *\nofpact_get_mf_dst(const struct ofpact *ofpact)\n{\n    if (ofpact->type == OFPACT_SET_FIELD) {\n        const struct ofpact_set_field *orl;\n\n        orl = CONTAINER_OF(ofpact, struct ofpact_set_field, ofpact);\n        return orl->field;\n    } else if (ofpact->type == OFPACT_REG_MOVE) {\n        const struct ofpact_reg_move *orm;\n\n        orm = CONTAINER_OF(ofpact, struct ofpact_reg_move, ofpact);\n        return orm->dst.field;\n    }\n\n    return NULL;\n}\n\nstatic enum ofperr\nunsupported_nesting(enum ofpact_type action, enum ofpact_type outer_action)\n{\n    VLOG_WARN(\"%s action doesn't support nested action %s\",\n              ofpact_name(outer_action), ofpact_name(action));\n    return OFPERR_OFPBAC_BAD_ARGUMENT;\n}\n\nstatic bool\nfield_requires_ct(enum mf_field_id field)\n{\n    return field == MFF_CT_MARK || field == MFF_CT_LABEL;\n}\n\n/* Apply nesting constraints for actions */\nstatic enum ofperr\nofpacts_verify_nested(const struct ofpact *a, enum ofpact_type outer_action)\n{\n    const struct mf_field *field = ofpact_get_mf_dst(a);\n\n    if (field && field_requires_ct(field->id) && outer_action != OFPACT_CT) {\n        VLOG_WARN(\"cannot set CT fields outside of ct action\");\n        return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n    }\n    if (a->type == OFPACT_NAT) {\n        if (outer_action != OFPACT_CT) {\n            VLOG_WARN(\"Cannot have NAT action outside of \\\"ct\\\" action\");\n            return OFPERR_OFPBAC_BAD_SET_ARGUMENT;\n        }\n        return 0;\n    }\n\n    if (outer_action) {\n        ovs_assert(outer_action == OFPACT_WRITE_ACTIONS\n                   || outer_action == OFPACT_CT);\n\n        if (outer_action == OFPACT_CT) {\n            if (!field) {\n                return unsupported_nesting(a->type, outer_action);\n            } else if (!field_requires_ct(field->id)) {\n                VLOG_WARN(\"%s action doesn't support nested modification \"\n                          \"of %s\", ofpact_name(outer_action), field->name);\n                return OFPERR_OFPBAC_BAD_ARGUMENT;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/* Verifies that the 'ofpacts_len' bytes of actions in 'ofpacts' are in the\n * appropriate order as defined by the OpenFlow spec and as required by Open\n * vSwitch.\n *\n * 'allowed_ovsinsts' is a bitmap of OVSINST_* values, in which 1-bits indicate\n * instructions that are allowed within 'ofpacts[]'.\n *\n * If 'outer_action' is not zero, it specifies that the actions are nested\n * within another action of type 'outer_action'. */\nstatic enum ofperr\nofpacts_verify(const struct ofpact ofpacts[], size_t ofpacts_len,\n               uint32_t allowed_ovsinsts, enum ofpact_type outer_action)\n{\n    const struct ofpact *a;\n    enum ovs_instruction_type inst;\n\n    inst = OVSINST_OFPIT13_METER;\n    OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {\n        enum ovs_instruction_type next;\n        enum ofperr error;\n\n        if (a->type == OFPACT_CONJUNCTION) {\n            OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {\n                if (a->type != OFPACT_CONJUNCTION && a->type != OFPACT_NOTE) {\n                    VLOG_WARN(\"\\\"conjunction\\\" actions may be used along with \"\n                              \"\\\"note\\\" but not any other kind of action \"\n                              \"(such as the \\\"%s\\\" action used here)\",\n                              ofpact_name(a->type));\n                    return OFPERR_NXBAC_BAD_CONJUNCTION;\n                }\n            }\n            return 0;\n        }\n\n        error = ofpacts_verify_nested(a, outer_action);\n        if (error) {\n            return error;\n        }\n\n        next = ovs_instruction_type_from_ofpact_type(a->type);\n        if (a > ofpacts\n            && (inst == OVSINST_OFPIT11_APPLY_ACTIONS\n                ? next < inst\n                : next <= inst)) {\n            const char *name = ovs_instruction_name_from_type(inst);\n            const char *next_name = ovs_instruction_name_from_type(next);\n\n            if (next == inst) {\n                VLOG_WARN(\"duplicate %s instruction not allowed, for OpenFlow \"\n                          \"1.1+ compatibility\", name);\n            } else {\n                VLOG_WARN(\"invalid instruction ordering: %s must appear \"\n                          \"before %s, for OpenFlow 1.1+ compatibility\",\n                          next_name, name);\n            }\n            return OFPERR_OFPBAC_UNSUPPORTED_ORDER;\n        }\n        if (!((1u << next) & allowed_ovsinsts)) {\n            const char *name = ovs_instruction_name_from_type(next);\n\n            VLOG_WARN(\"%s instruction not allowed here\", name);\n            return OFPERR_OFPBIC_UNSUP_INST;\n        }\n\n        inst = next;\n    }\n\n    return 0;\n}\n\f\n/* Converting ofpacts to OpenFlow. */\n\nstatic void\nencode_ofpact(const struct ofpact *a, enum ofp_version ofp_version,\n              struct ofpbuf *out)\n{\n    switch (a->type) {\n#define OFPACT(ENUM, STRUCT, MEMBER, NAME)                              \\\n        case OFPACT_##ENUM:                                             \\\n            encode_##ENUM(ofpact_get_##ENUM(a), ofp_version, out);      \\\n            return;\n        OFPACTS\n#undef OFPACT\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Converts the 'ofpacts_len' bytes of ofpacts in 'ofpacts' into OpenFlow\n * actions in 'openflow', appending the actions to any existing data in\n * 'openflow'. */\nsize_t\nofpacts_put_openflow_actions(const struct ofpact ofpacts[], size_t ofpacts_len,\n                             struct ofpbuf *openflow,\n                             enum ofp_version ofp_version)\n{\n    const struct ofpact *a;\n    size_t start_size = openflow->size;\n\n    OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {\n        encode_ofpact(a, ofp_version, openflow);\n    }\n    return openflow->size - start_size;\n}\n\nstatic enum ovs_instruction_type\nofpact_is_apply_actions(const struct ofpact *a)\n{\n    return (ovs_instruction_type_from_ofpact_type(a->type)\n            == OVSINST_OFPIT11_APPLY_ACTIONS);\n}\n\nvoid\nofpacts_put_openflow_instructions(const struct ofpact ofpacts[],\n                                  size_t ofpacts_len,\n                                  struct ofpbuf *openflow,\n                                  enum ofp_version ofp_version)\n{\n    const struct ofpact *end = ofpact_end(ofpacts, ofpacts_len);\n    const struct ofpact *a;\n\n    if (ofp_version == OFP10_VERSION) {\n        ofpacts_put_openflow_actions(ofpacts, ofpacts_len, openflow,\n                                     ofp_version);\n        return;\n    }\n\n    a = ofpacts;\n    while (a < end) {\n        if (ofpact_is_apply_actions(a)) {\n            size_t ofs = openflow->size;\n\n            instruction_put_OFPIT11_APPLY_ACTIONS(openflow);\n            do {\n                encode_ofpact(a, ofp_version, openflow);\n                a = ofpact_next(a);\n            } while (a < end && ofpact_is_apply_actions(a));\n            ofpacts_update_instruction_actions(openflow, ofs);\n        } else {\n            encode_ofpact(a, ofp_version, openflow);\n            a = ofpact_next(a);\n        }\n    }\n}\n\f\n/* Sets of supported actions. */\n\n/* Two-way translation between OVS's internal \"OFPACT_*\" representation of\n * actions and the \"OFPAT_*\" representation used in some OpenFlow version.\n * (OFPAT_* numbering varies from one OpenFlow version to another, so a given\n * instance is specific to one OpenFlow version.) */\nstruct ofpact_map {\n    enum ofpact_type ofpact;    /* Internal name for action type. */\n    int ofpat;                  /* OFPAT_* number from OpenFlow spec. */\n};\n\nstatic const struct ofpact_map *\nget_ofpact_map(enum ofp_version version)\n{\n    /* OpenFlow 1.0 actions. */\n    static const struct ofpact_map of10[] = {\n        { OFPACT_OUTPUT, 0 },\n        { OFPACT_SET_VLAN_VID, 1 },\n        { OFPACT_SET_VLAN_PCP, 2 },\n        { OFPACT_STRIP_VLAN, 3 },\n        { OFPACT_SET_ETH_SRC, 4 },\n        { OFPACT_SET_ETH_DST, 5 },\n        { OFPACT_SET_IPV4_SRC, 6 },\n        { OFPACT_SET_IPV4_DST, 7 },\n        { OFPACT_SET_IP_DSCP, 8 },\n        { OFPACT_SET_L4_SRC_PORT, 9 },\n        { OFPACT_SET_L4_DST_PORT, 10 },\n        { OFPACT_ENQUEUE, 11 },\n        { 0, -1 },\n    };\n\n    /* OpenFlow 1.1 actions. */\n    static const struct ofpact_map of11[] = {\n        { OFPACT_OUTPUT, 0 },\n        { OFPACT_SET_VLAN_VID, 1 },\n        { OFPACT_SET_VLAN_PCP, 2 },\n        { OFPACT_SET_ETH_SRC, 3 },\n        { OFPACT_SET_ETH_DST, 4 },\n        { OFPACT_SET_IPV4_SRC, 5 },\n        { OFPACT_SET_IPV4_DST, 6 },\n        { OFPACT_SET_IP_DSCP, 7 },\n        { OFPACT_SET_IP_ECN, 8 },\n        { OFPACT_SET_L4_SRC_PORT, 9 },\n        { OFPACT_SET_L4_DST_PORT, 10 },\n        /* OFPAT_COPY_TTL_OUT (11) not supported. */\n        /* OFPAT_COPY_TTL_IN (12) not supported. */\n        { OFPACT_SET_MPLS_LABEL, 13 },\n        { OFPACT_SET_MPLS_TC, 14 },\n        { OFPACT_SET_MPLS_TTL, 15 },\n        { OFPACT_DEC_MPLS_TTL, 16 },\n        { OFPACT_PUSH_VLAN, 17 },\n        { OFPACT_STRIP_VLAN, 18 },\n        { OFPACT_PUSH_MPLS, 19 },\n        { OFPACT_POP_MPLS, 20 },\n        { OFPACT_SET_QUEUE, 21 },\n        { OFPACT_GROUP, 22 },\n        { OFPACT_SET_IP_TTL, 23 },\n        { OFPACT_DEC_TTL, 24 },\n        { 0, -1 },\n    };\n\n    /* OpenFlow 1.2, 1.3, and 1.4 actions. */\n    static const struct ofpact_map of12[] = {\n        { OFPACT_OUTPUT, 0 },\n        /* OFPAT_COPY_TTL_OUT (11) not supported. */\n        /* OFPAT_COPY_TTL_IN (12) not supported. */\n        { OFPACT_SET_MPLS_TTL, 15 },\n        { OFPACT_DEC_MPLS_TTL, 16 },\n        { OFPACT_PUSH_VLAN, 17 },\n        { OFPACT_STRIP_VLAN, 18 },\n        { OFPACT_PUSH_MPLS, 19 },\n        { OFPACT_POP_MPLS, 20 },\n        { OFPACT_SET_QUEUE, 21 },\n        { OFPACT_GROUP, 22 },\n        { OFPACT_SET_IP_TTL, 23 },\n        { OFPACT_DEC_TTL, 24 },\n        { OFPACT_SET_FIELD, 25 },\n        /* OF1.3+ OFPAT_PUSH_PBB (26) not supported. */\n        /* OF1.3+ OFPAT_POP_PBB (27) not supported. */\n        { 0, -1 },\n    };\n\n    switch (version) {\n    case OFP10_VERSION:\n        return of10;\n\n    case OFP11_VERSION:\n        return of11;\n\n    case OFP12_VERSION:\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n    default:\n        return of12;\n    }\n}\n\n/* Converts 'ofpacts_bitmap', a bitmap whose bits correspond to OFPACT_*\n * values, into a bitmap of actions suitable for OpenFlow 'version', and\n * returns the result. */\novs_be32\nofpact_bitmap_to_openflow(uint64_t ofpacts_bitmap, enum ofp_version version)\n{\n    uint32_t openflow_bitmap = 0;\n    const struct ofpact_map *x;\n\n    for (x = get_ofpact_map(version); x->ofpat >= 0; x++) {\n        if (ofpacts_bitmap & (UINT64_C(1) << x->ofpact)) {\n            openflow_bitmap |= 1u << x->ofpat;\n        }\n    }\n    return htonl(openflow_bitmap);\n}\n\n/* Converts 'ofpat_bitmap', a bitmap of actions from an OpenFlow message with\n * the given 'version' into a bitmap whose bits correspond to OFPACT_* values,\n * and returns the result. */\nuint64_t\nofpact_bitmap_from_openflow(ovs_be32 ofpat_bitmap, enum ofp_version version)\n{\n    uint64_t ofpact_bitmap = 0;\n    const struct ofpact_map *x;\n\n    for (x = get_ofpact_map(version); x->ofpat >= 0; x++) {\n        if (ofpat_bitmap & htonl(1u << x->ofpat)) {\n            ofpact_bitmap |= UINT64_C(1) << x->ofpact;\n        }\n    }\n    return ofpact_bitmap;\n}\n\n/* Appends to 's' a string representation of the set of OFPACT_* represented\n * by 'ofpacts_bitmap'. */\nvoid\nofpact_bitmap_format(uint64_t ofpacts_bitmap, struct ds *s)\n{\n    if (!ofpacts_bitmap) {\n        ds_put_cstr(s, \"<none>\");\n    } else {\n        while (ofpacts_bitmap) {\n            ds_put_format(s, \"%s \",\n                          ofpact_name(rightmost_1bit_idx(ofpacts_bitmap)));\n            ofpacts_bitmap = zero_rightmost_1bit(ofpacts_bitmap);\n        }\n        ds_chomp(s, ' ');\n    }\n}\n\f\n/* Returns true if 'action' outputs to 'port', false otherwise. */\nstatic bool\nofpact_outputs_to_port(const struct ofpact *ofpact, ofp_port_t port)\n{\n    switch (ofpact->type) {\n    case OFPACT_OUTPUT:\n        return ofpact_get_OUTPUT(ofpact)->port == port;\n    case OFPACT_ENQUEUE:\n        return ofpact_get_ENQUEUE(ofpact)->port == port;\n    case OFPACT_CONTROLLER:\n        return port == OFPP_CONTROLLER;\n\n    case OFPACT_OUTPUT_REG:\n    case OFPACT_OUTPUT_TRUNC:\n    case OFPACT_BUNDLE:\n    case OFPACT_SET_VLAN_VID:\n    case OFPACT_SET_VLAN_PCP:\n    case OFPACT_STRIP_VLAN:\n    case OFPACT_PUSH_VLAN:\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_ETH_DST:\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_IPV4_DST:\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_L4_DST_PORT:\n    case OFPACT_REG_MOVE:\n    case OFPACT_SET_FIELD:\n    case OFPACT_STACK_PUSH:\n    case OFPACT_STACK_POP:\n    case OFPACT_DEC_TTL:\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_DEC_MPLS_TTL:\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_WRITE_METADATA:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_FIN_TIMEOUT:\n    case OFPACT_RESUBMIT:\n    case OFPACT_LEARN:\n    case OFPACT_CONJUNCTION:\n    case OFPACT_MULTIPATH:\n    case OFPACT_NOTE:\n    case OFPACT_EXIT:\n    case OFPACT_UNROLL_XLATE:\n    case OFPACT_PUSH_MPLS:\n    case OFPACT_POP_MPLS:\n    case OFPACT_SAMPLE:\n    case OFPACT_CLEAR_ACTIONS:\n    case OFPACT_CLONE:\n    case OFPACT_WRITE_ACTIONS:\n    case OFPACT_GOTO_TABLE:\n    case OFPACT_METER:\n    case OFPACT_GROUP:\n    case OFPACT_DEBUG_RECIRC:\n    case OFPACT_CT:\n    case OFPACT_CT_CLEAR:\n    case OFPACT_NAT:\n    default:\n        return false;\n    }\n}\n\n/* Returns true if any action in the 'ofpacts_len' bytes of 'ofpacts' outputs\n * to 'port', false otherwise. */\nbool\nofpacts_output_to_port(const struct ofpact *ofpacts, size_t ofpacts_len,\n                       ofp_port_t port)\n{\n    const struct ofpact *a;\n\n    OFPACT_FOR_EACH_FLATTENED (a, ofpacts, ofpacts_len) {\n        if (ofpact_outputs_to_port(a, port)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/* Returns true if any action in the 'ofpacts_len' bytes of 'ofpacts' outputs\n * to 'group', false otherwise. */\nbool\nofpacts_output_to_group(const struct ofpact *ofpacts, size_t ofpacts_len,\n                        uint32_t group_id)\n{\n    const struct ofpact *a;\n\n    OFPACT_FOR_EACH_FLATTENED (a, ofpacts, ofpacts_len) {\n        if (a->type == OFPACT_GROUP\n            && ofpact_get_GROUP(a)->group_id == group_id) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool\nofpacts_equal(const struct ofpact *a, size_t a_len,\n              const struct ofpact *b, size_t b_len)\n{\n    return a_len == b_len && !memcmp(a, b, a_len);\n}\n\n/* Finds the OFPACT_METER action, if any, in the 'ofpacts_len' bytes of\n * 'ofpacts'.  If found, returns its meter ID; if not, returns 0.\n *\n * This function relies on the order of 'ofpacts' being correct (as checked by\n * ofpacts_verify()). */\nuint32_t\nofpacts_get_meter(const struct ofpact ofpacts[], size_t ofpacts_len)\n{\n    const struct ofpact *a;\n\n    OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {\n        enum ovs_instruction_type inst;\n\n        inst = ovs_instruction_type_from_ofpact_type(a->type);\n        if (a->type == OFPACT_METER) {\n            return ofpact_get_METER(a)->meter_id;\n        } else if (inst > OVSINST_OFPIT13_METER) {\n            break;\n        }\n    }\n\n    return 0;\n}\n\f\n/* Formatting ofpacts. */\n\nstatic void\nofpact_format(const struct ofpact *a, struct ds *s)\n{\n    switch (a->type) {\n#define OFPACT(ENUM, STRUCT, MEMBER, NAME)                              \\\n        case OFPACT_##ENUM:                                             \\\n            format_##ENUM(ALIGNED_CAST(const struct STRUCT *, a), s);   \\\n            break;\n        OFPACTS\n#undef OFPACT\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\n/* Appends a string representing the 'ofpacts_len' bytes of ofpacts in\n * 'ofpacts' to 'string'. */\nvoid\nofpacts_format(const struct ofpact *ofpacts, size_t ofpacts_len,\n               struct ds *string)\n{\n    if (!ofpacts_len) {\n        ds_put_format(string, \"%sdrop%s\", colors.drop, colors.end);\n    } else {\n        const struct ofpact *a;\n\n        OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {\n            if (a != ofpacts) {\n                ds_put_char(string, ',');\n            }\n\n            ofpact_format(a, string);\n        }\n    }\n}\n\f\n/* Internal use by helpers. */\n\n/* Implementation of ofpact_put_<ENUM>(). */\nvoid *\nofpact_put(struct ofpbuf *ofpacts, enum ofpact_type type, size_t len)\n{\n    struct ofpact *ofpact;\n\n    ofpacts->header = ofpbuf_put_uninit(ofpacts, len);\n    ofpact = ofpacts->header;\n    ofpact_init(ofpact, type, len);\n    return ofpact;\n}\n\n/* Implementation of ofpact_init_<ENUM>(). */\nvoid\nofpact_init(struct ofpact *ofpact, enum ofpact_type type, size_t len)\n{\n    memset(ofpact, 0, len);\n    ofpact->type = type;\n    ofpact->raw = -1;\n    ofpact->len = len;\n}\n\n/* Implementation of ofpact_finish_<ENUM>().\n *\n * Finishes composing a variable-length action (begun using\n * ofpact_put_<NAME>()), by padding the action to a multiple of OFPACT_ALIGNTO\n * bytes and updating its embedded length field.  See the large comment near\n * the end of ofp-actions.h for more information.\n *\n * May reallocate 'ofpacts'. Callers should consider updating their 'ofpact'\n * pointer to the return value of this function. */\nvoid *\nofpact_finish(struct ofpbuf *ofpacts, struct ofpact *ofpact)\n{\n    ptrdiff_t len;\n\n    ovs_assert(ofpact == ofpacts->header);\n    len = (char *) ofpbuf_tail(ofpacts) - (char *) ofpact;\n    ovs_assert(len > 0 && len <= UINT16_MAX);\n    ofpact->len = len;\n    ofpbuf_padto(ofpacts, OFPACT_ALIGN(ofpacts->size));\n\n    return ofpacts->header;\n}\n\f\nstatic char * OVS_WARN_UNUSED_RESULT\nofpact_parse(enum ofpact_type type, char *value, struct ofpbuf *ofpacts,\n             enum ofputil_protocol *usable_protocols)\n{\n    switch (type) {\n#define OFPACT(ENUM, STRUCT, MEMBER, NAME)                            \\\n        case OFPACT_##ENUM:                                             \\\n            return parse_##ENUM(value, ofpacts, usable_protocols);\n        OFPACTS\n#undef OFPACT\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n\nstatic bool\nofpact_type_from_name(const char *name, enum ofpact_type *type)\n{\n#define OFPACT(ENUM, STRUCT, MEMBER, NAME)                            \\\n    if (!strcasecmp(name, NAME)) {                                    \\\n        *type = OFPACT_##ENUM;                                          \\\n        return true;                                                    \\\n    }\n    OFPACTS\n#undef OFPACT\n\n    return false;\n}\n\n/* Parses 'str' as a series of instructions, and appends them to 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string.\n *\n * If 'outer_action' is specified, indicates that the actions being parsed\n * are nested within another action of the type specified in 'outer_action'. */\nstatic char * OVS_WARN_UNUSED_RESULT\nofpacts_parse__(char *str, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols,\n                bool allow_instructions, enum ofpact_type outer_action)\n{\n    int prev_inst = -1;\n    enum ofperr retval;\n    char *key, *value;\n    bool drop = false;\n    char *pos;\n\n    pos = str;\n    while (ofputil_parse_key_value(&pos, &key, &value)) {\n        enum ovs_instruction_type inst = OVSINST_OFPIT11_APPLY_ACTIONS;\n        enum ofpact_type type;\n        char *error = NULL;\n        ofp_port_t port;\n\n        if (ofpact_type_from_name(key, &type)) {\n            error = ofpact_parse(type, value, ofpacts, usable_protocols);\n            inst = ovs_instruction_type_from_ofpact_type(type);\n        } else if (!strcasecmp(key, \"mod_vlan_vid\")) {\n            error = parse_set_vlan_vid(value, ofpacts, true);\n        } else if (!strcasecmp(key, \"mod_vlan_pcp\")) {\n            error = parse_set_vlan_pcp(value, ofpacts, true);\n        } else if (!strcasecmp(key, \"set_nw_ttl\")) {\n            error = parse_SET_IP_TTL(value, ofpacts, usable_protocols);\n        } else if (!strcasecmp(key, \"pop_vlan\")) {\n            error = parse_pop_vlan(ofpacts);\n        } else if (!strcasecmp(key, \"set_tunnel64\")) {\n            error = parse_set_tunnel(value, ofpacts,\n                                     NXAST_RAW_SET_TUNNEL64);\n        } else if (!strcasecmp(key, \"load\")) {\n            error = parse_reg_load(value, ofpacts);\n        } else if (!strcasecmp(key, \"bundle_load\")) {\n            error = parse_bundle_load(value, ofpacts);\n        } else if (!strcasecmp(key, \"drop\")) {\n            drop = true;\n        } else if (!strcasecmp(key, \"apply_actions\")) {\n            return xstrdup(\"apply_actions is the default instruction\");\n        } else if (ofputil_port_from_string(key, &port)) {\n            ofpact_put_OUTPUT(ofpacts)->port = port;\n        } else {\n            return xasprintf(\"unknown action %s\", key);\n        }\n        if (error) {\n            return error;\n        }\n\n        if (inst != OVSINST_OFPIT11_APPLY_ACTIONS) {\n            if (!allow_instructions) {\n                return xasprintf(\"only actions are allowed here (not \"\n                                 \"instruction %s)\",\n                                 ovs_instruction_name_from_type(inst));\n            }\n            if (inst == prev_inst) {\n                return xasprintf(\"instruction %s may be specified only once\",\n                                 ovs_instruction_name_from_type(inst));\n            }\n        }\n        if (prev_inst != -1 && inst < prev_inst) {\n            return xasprintf(\"instruction %s must be specified before %s\",\n                             ovs_instruction_name_from_type(inst),\n                             ovs_instruction_name_from_type(prev_inst));\n        }\n        prev_inst = inst;\n    }\n\n    if (drop && ofpacts->size) {\n        return xstrdup(\"\\\"drop\\\" must not be accompanied by any other action \"\n                       \"or instruction\");\n    }\n\n    retval = ofpacts_verify(ofpacts->data, ofpacts->size,\n                            (allow_instructions\n                             ? (1u << N_OVS_INSTRUCTIONS) - 1\n                             : 1u << OVSINST_OFPIT11_APPLY_ACTIONS),\n                            outer_action);\n    if (retval) {\n        return xstrdup(\"Incorrect instruction ordering\");\n    }\n\n    return NULL;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nofpacts_parse(char *str, struct ofpbuf *ofpacts,\n              enum ofputil_protocol *usable_protocols, bool allow_instructions,\n              enum ofpact_type outer_action)\n{\n    uint32_t orig_size = ofpacts->size;\n    char *error = ofpacts_parse__(str, ofpacts, usable_protocols,\n                                  allow_instructions, outer_action);\n    if (error) {\n        ofpacts->size = orig_size;\n    }\n    return error;\n}\n\nstatic char * OVS_WARN_UNUSED_RESULT\nofpacts_parse_copy(const char *s_, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols,\n                   bool allow_instructions, enum ofpact_type outer_action)\n{\n    char *error, *s;\n\n    *usable_protocols = OFPUTIL_P_ANY;\n\n    s = xstrdup(s_);\n    error = ofpacts_parse(s, ofpacts, usable_protocols, allow_instructions,\n                          outer_action);\n    free(s);\n\n    return error;\n}\n\n/* Parses 's' as a set of OpenFlow actions and appends the actions to\n * 'ofpacts'. 'outer_action', if nonzero, specifies that 's' contains actions\n * that are nested within the action of type 'outer_action'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nchar * OVS_WARN_UNUSED_RESULT\nofpacts_parse_actions(const char *s, struct ofpbuf *ofpacts,\n                      enum ofputil_protocol *usable_protocols)\n{\n    return ofpacts_parse_copy(s, ofpacts, usable_protocols, false, 0);\n}\n\n/* Parses 's' as a set of OpenFlow instructions and appends the instructions to\n * 'ofpacts'.\n *\n * Returns NULL if successful, otherwise a malloc()'d string describing the\n * error.  The caller is responsible for freeing the returned string. */\nchar * OVS_WARN_UNUSED_RESULT\nofpacts_parse_instructions(const char *s, struct ofpbuf *ofpacts,\n                           enum ofputil_protocol *usable_protocols)\n{\n    return ofpacts_parse_copy(s, ofpacts, usable_protocols, true, 0);\n}\n\nconst char *\nofpact_name(enum ofpact_type type)\n{\n    switch (type) {\n#define OFPACT(ENUM, STRUCT, MEMBER, NAME) case OFPACT_##ENUM: return NAME;\n        OFPACTS\n#undef OFPACT\n    }\n    return \"<unknown>\";\n}\n\f\n/* Low-level action decoding and encoding functions. */\n\n/* Everything needed to identify a particular OpenFlow action. */\nstruct ofpact_hdrs {\n    uint32_t vendor;              /* 0 if standard, otherwise a vendor code. */\n    uint16_t type;                /* Type if standard, otherwise subtype. */\n    uint8_t ofp_version;          /* From ofp_header. */\n};\n\n/* Information about a particular OpenFlow action. */\nstruct ofpact_raw_instance {\n    /* The action's identity. */\n    struct ofpact_hdrs hdrs;\n    enum ofp_raw_action_type raw;\n\n    /* Looking up the action. */\n    struct hmap_node decode_node; /* Based on 'hdrs'. */\n    struct hmap_node encode_node; /* Based on 'raw' + 'hdrs.ofp_version'. */\n\n    /* The action's encoded size.\n     *\n     * If this action is fixed-length, 'min_length' == 'max_length'.\n     * If it is variable length, then 'max_length' is ROUND_DOWN(UINT16_MAX,\n     * OFP_ACTION_ALIGN) == 65528. */\n    unsigned short int min_length;\n    unsigned short int max_length;\n\n    /* For actions with a simple integer numeric argument, 'arg_ofs' is the\n     * offset of that argument from the beginning of the action and 'arg_len'\n     * its length, both in bytes.\n     *\n     * For actions that take other forms, these are both zero. */\n    unsigned short int arg_ofs;\n    unsigned short int arg_len;\n\n    /* The name of the action, e.g. \"OFPAT_OUTPUT\" or \"NXAST_RESUBMIT\". */\n    const char *name;\n\n    /* If this action is deprecated, a human-readable string with a brief\n     * explanation. */\n    const char *deprecation;\n};\n\n/* Action header. */\nstruct ofp_action_header {\n    /* The meaning of other values of 'type' generally depends on the OpenFlow\n     * version (see enum ofp_raw_action_type).\n     *\n     * Across all OpenFlow versions, OFPAT_VENDOR indicates that 'vendor'\n     * designates an OpenFlow vendor ID and that the remainder of the action\n     * structure has a vendor-defined meaning.\n     */\n#define OFPAT_VENDOR 0xffff\n    ovs_be16 type;\n\n    /* Always a multiple of 8. */\n    ovs_be16 len;\n\n    /* For type == OFPAT_VENDOR only, this is a vendor ID, e.g. NX_VENDOR_ID or\n     * ONF_VENDOR_ID.  Other 'type's use this space for some other purpose. */\n    ovs_be32 vendor;\n};\nOFP_ASSERT(sizeof(struct ofp_action_header) == 8);\n\nstatic bool\nofpact_hdrs_equal(const struct ofpact_hdrs *a,\n                  const struct ofpact_hdrs *b)\n{\n    return (a->vendor == b->vendor\n            && a->type == b->type\n            && a->ofp_version == b->ofp_version);\n}\n\nstatic uint32_t\nofpact_hdrs_hash(const struct ofpact_hdrs *hdrs)\n{\n    return hash_2words(hdrs->vendor, (hdrs->type << 16) | hdrs->ofp_version);\n}\n\n#include \"ofp-actions.inc2\"\n\nstatic struct hmap *\nofpact_decode_hmap(void)\n{\n    static struct ovsthread_once once = OVSTHREAD_ONCE_INITIALIZER;\n    static struct hmap hmap;\n\n    if (ovsthread_once_start(&once)) {\n        struct ofpact_raw_instance *inst;\n\n        hmap_init(&hmap);\n        for (inst = all_raw_instances;\n             inst < &all_raw_instances[ARRAY_SIZE(all_raw_instances)];\n             inst++) {\n            hmap_insert(&hmap, &inst->decode_node,\n                        ofpact_hdrs_hash(&inst->hdrs));\n        }\n        ovsthread_once_done(&once);\n    }\n    return &hmap;\n}\n\nstatic struct hmap *\nofpact_encode_hmap(void)\n{\n    static struct ovsthread_once once = OVSTHREAD_ONCE_INITIALIZER;\n    static struct hmap hmap;\n\n    if (ovsthread_once_start(&once)) {\n        struct ofpact_raw_instance *inst;\n\n        hmap_init(&hmap);\n        for (inst = all_raw_instances;\n             inst < &all_raw_instances[ARRAY_SIZE(all_raw_instances)];\n             inst++) {\n            hmap_insert(&hmap, &inst->encode_node,\n                        hash_2words(inst->raw, inst->hdrs.ofp_version));\n        }\n        ovsthread_once_done(&once);\n    }\n    return &hmap;\n}\n\nstatic enum ofperr\nofpact_decode_raw(enum ofp_version ofp_version,\n                  const struct ofp_action_header *oah, size_t length,\n                  const struct ofpact_raw_instance **instp)\n{\n    const struct ofpact_raw_instance *inst;\n    struct ofpact_hdrs hdrs;\n\n    *instp = NULL;\n    if (length < sizeof *oah) {\n        return OFPERR_OFPBAC_BAD_LEN;\n    }\n\n    /* Get base action type. */\n    if (oah->type == htons(OFPAT_VENDOR)) {\n        /* Get vendor. */\n        hdrs.vendor = ntohl(oah->vendor);\n        if (hdrs.vendor == NX_VENDOR_ID || hdrs.vendor == ONF_VENDOR_ID) {\n            /* Get extension subtype. */\n            const struct ext_action_header *nah;\n\n            nah = ALIGNED_CAST(const struct ext_action_header *, oah);\n            if (length < sizeof *nah) {\n                return OFPERR_OFPBAC_BAD_LEN;\n            }\n            hdrs.type = ntohs(nah->subtype);\n        } else {\n            VLOG_WARN_RL(&rl, \"OpenFlow action has unknown vendor %#\"PRIx32,\n                         hdrs.vendor);\n            return OFPERR_OFPBAC_BAD_VENDOR;\n        }\n    } else {\n        hdrs.vendor = 0;\n        hdrs.type = ntohs(oah->type);\n    }\n\n    hdrs.ofp_version = ofp_version;\n    HMAP_FOR_EACH_WITH_HASH (inst, decode_node, ofpact_hdrs_hash(&hdrs),\n                             ofpact_decode_hmap()) {\n        if (ofpact_hdrs_equal(&hdrs, &inst->hdrs)) {\n            *instp = inst;\n            return 0;\n        }\n    }\n\n    return (hdrs.vendor\n            ? OFPERR_OFPBAC_BAD_VENDOR_TYPE\n            : OFPERR_OFPBAC_BAD_TYPE);\n}\n\nstatic enum ofperr\nofpact_pull_raw(struct ofpbuf *buf, enum ofp_version ofp_version,\n                enum ofp_raw_action_type *raw, uint64_t *arg)\n{\n    const struct ofp_action_header *oah = buf->data;\n    const struct ofpact_raw_instance *action;\n    unsigned int length;\n    enum ofperr error;\n\n    *raw = *arg = 0;\n    error = ofpact_decode_raw(ofp_version, oah, buf->size, &action);\n    if (error) {\n        return error;\n    }\n\n    if (action->deprecation) {\n        VLOG_INFO_RL(&rl, \"%s is deprecated in %s (%s)\",\n                     action->name, ofputil_version_to_string(ofp_version),\n                     action->deprecation);\n    }\n\n    length = ntohs(oah->len);\n    if (length > buf->size) {\n        VLOG_WARN_RL(&rl, \"OpenFlow action %s length %u exceeds action buffer \"\n                     \"length %\"PRIu32, action->name, length, buf->size);\n        return OFPERR_OFPBAC_BAD_LEN;\n    }\n    if (length < action->min_length || length > action->max_length) {\n        VLOG_WARN_RL(&rl, \"OpenFlow action %s length %u not in valid range \"\n                     \"[%hu,%hu]\", action->name, length,\n                     action->min_length, action->max_length);\n        return OFPERR_OFPBAC_BAD_LEN;\n    }\n    if (length % 8) {\n        VLOG_WARN_RL(&rl, \"OpenFlow action %s length %u is not a multiple \"\n                     \"of 8\", action->name, length);\n        return OFPERR_OFPBAC_BAD_LEN;\n    }\n\n    *raw = action->raw;\n    *arg = 0;\n    if (action->arg_len) {\n        const uint8_t *p;\n        int i;\n\n        p = ofpbuf_at_assert(buf, action->arg_ofs, action->arg_len);\n        for (i = 0; i < action->arg_len; i++) {\n            *arg = (*arg << 8) | p[i];\n        }\n    }\n\n    ofpbuf_pull(buf, length);\n\n    return 0;\n}\n\nstatic const struct ofpact_raw_instance *\nofpact_raw_lookup(enum ofp_version ofp_version, enum ofp_raw_action_type raw)\n{\n    const struct ofpact_raw_instance *inst;\n\n    HMAP_FOR_EACH_WITH_HASH (inst, encode_node, hash_2words(raw, ofp_version),\n                             ofpact_encode_hmap()) {\n        if (inst->raw == raw && inst->hdrs.ofp_version == ofp_version) {\n            return inst;\n        }\n    }\n    OVS_NOT_REACHED();\n}\n\nstatic void *\nofpact_put_raw(struct ofpbuf *buf, enum ofp_version ofp_version,\n               enum ofp_raw_action_type raw, uint64_t arg)\n{\n    const struct ofpact_raw_instance *inst;\n    struct ofp_action_header *oah;\n    const struct ofpact_hdrs *hdrs;\n\n    inst = ofpact_raw_lookup(ofp_version, raw);\n    hdrs = &inst->hdrs;\n\n    oah = ofpbuf_put_zeros(buf, inst->min_length);\n    oah->type = htons(hdrs->vendor ? OFPAT_VENDOR : hdrs->type);\n    oah->len = htons(inst->min_length);\n    oah->vendor = htonl(hdrs->vendor);\n\n    switch (hdrs->vendor) {\n    case 0:\n        break;\n\n    case NX_VENDOR_ID:\n    case ONF_VENDOR_ID: {\n        struct ext_action_header *nah = (struct ext_action_header *) oah;\n        nah->subtype = htons(hdrs->type);\n        break;\n    }\n\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    if (inst->arg_len) {\n        uint8_t *p = (uint8_t *) oah + inst->arg_ofs + inst->arg_len;\n        int i;\n\n        for (i = 0; i < inst->arg_len; i++) {\n            *--p = arg;\n            arg >>= 8;\n        }\n    } else {\n        ovs_assert(!arg);\n    }\n\n    return oah;\n}\n\nstatic void\npad_ofpat(struct ofpbuf *openflow, size_t start_ofs)\n{\n    struct ofp_action_header *oah;\n\n    ofpbuf_put_zeros(openflow, PAD_SIZE(openflow->size - start_ofs,\n                                        OFP_ACTION_ALIGN));\n\n    oah = ofpbuf_at_assert(openflow, start_ofs, sizeof *oah);\n    oah->len = htons(openflow->size - start_ofs);\n}\n\n"], "filenames": ["lib/ofp-actions.c"], "buggy_code_start_loc": [1366], "buggy_code_end_loc": [1372], "fixing_code_start_loc": [1366], "fixing_code_end_loc": [1373], "type": "CWE-125", "message": "An issue was discovered in Open vSwitch (OvS) 2.7.x through 2.7.6. The decode_bundle function inside lib/ofp-actions.c is affected by a buffer over-read issue during BUNDLE action decoding.", "other": {"cve": {"id": "CVE-2018-17206", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-19T16:29:01.113", "lastModified": "2021-08-04T17:14:46.777", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Open vSwitch (OvS) 2.7.x through 2.7.6. The decode_bundle function inside lib/ofp-actions.c is affected by a buffer over-read issue during BUNDLE action decoding."}, {"lang": "es", "value": "Se ha descubierto un problema en Open vSwitch, en versiones 2.7.x hasta la 2.7.6. La funci\u00f3n decode_bundle dentro de lib/ofp-actions.c se ve afectada por un problema de sobrelectura de b\u00fafer durante la decodificaci\u00f3n de la acci\u00f3n BUNDLE."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openvswitch:openvswitch:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndIncluding": "2.7.6", "matchCriteriaId": "682FD155-6A56-43D5-9953-852BB3AA0109"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack:10:*:*:*:*:*:*:*", "matchCriteriaId": "E722FEF7-58A6-47AD-B1D0-DB0B71B0C7AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack:13:*:*:*:*:*:*:*", "matchCriteriaId": "704CFA1A-953E-4105-BFBE-406034B83DED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:3500", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0053", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0081", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/openvswitch/ovs/commit/9237a63c47bd314b807cda0bd2216264e82edbe8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/02/msg00032.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3873-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openvswitch/ovs/commit/9237a63c47bd314b807cda0bd2216264e82edbe8"}}