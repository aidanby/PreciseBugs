{"buggy_code": ["import os\nimport shutil\nimport zipfile\n\nfrom django.conf import settings\nfrom django.shortcuts import get_object_or_404\nfrom django.utils.translation import gettext_lazy as _\nfrom rest_framework import status\n\nfrom common.exceptions import JMSException\nfrom orgs.mixins.api import OrgBulkModelViewSet\nfrom rbac.permissions import RBACPermission\nfrom ..exception import PlaybookNoValidEntry\nfrom ..models import Playbook\nfrom ..serializers.playbook import PlaybookSerializer\n\n__all__ = [\"PlaybookViewSet\", \"PlaybookFileBrowserAPIView\"]\n\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\n\n\ndef unzip_playbook(src, dist):\n    fz = zipfile.ZipFile(src, 'r')\n    for file in fz.namelist():\n        fz.extract(file, dist)\n\n\nclass PlaybookViewSet(OrgBulkModelViewSet):\n    serializer_class = PlaybookSerializer\n    permission_classes = (RBACPermission,)\n    model = Playbook\n    search_fields = ('name', 'comment')\n\n    def perform_destroy(self, instance):\n        if instance.job_set.exists():\n            raise JMSException(code='playbook_has_job', detail={\"msg\": _(\"Currently playbook is being used in a job\")})\n        instance_id = instance.id\n        super().perform_destroy(instance)\n        dest_path = os.path.join(settings.DATA_DIR, \"ops\", \"playbook\", instance_id.__str__())\n        shutil.rmtree(dest_path)\n\n    def get_queryset(self):\n        queryset = super().get_queryset()\n        queryset = queryset.filter(creator=self.request.user)\n        return queryset\n\n    def perform_create(self, serializer):\n        instance = serializer.save()\n        if 'multipart/form-data' in self.request.headers['Content-Type']:\n            src_path = os.path.join(settings.MEDIA_ROOT, instance.path.name)\n            dest_path = os.path.join(settings.DATA_DIR, \"ops\", \"playbook\", instance.id.__str__())\n            try:\n                unzip_playbook(src_path, dest_path)\n            except RuntimeError as e:\n                raise JMSException(code='invalid_playbook_file', detail={\"msg\": \"Unzip failed\"})\n\n            if 'main.yml' not in os.listdir(dest_path):\n                raise PlaybookNoValidEntry\n\n        else:\n            if instance.create_method == 'blank':\n                dest_path = os.path.join(settings.DATA_DIR, \"ops\", \"playbook\", instance.id.__str__())\n                os.makedirs(dest_path)\n                with open(os.path.join(dest_path, 'main.yml'), 'w') as f:\n                    f.write('## write your playbook here')\n\n\nclass PlaybookFileBrowserAPIView(APIView):\n    rbac_perms = ()\n    permission_classes = (RBACPermission,)\n    rbac_perms = {\n        'GET': 'ops.change_playbook',\n        'POST': 'ops.change_playbook',\n        'DELETE': 'ops.change_playbook',\n        'PATCH': 'ops.change_playbook',\n    }\n    protected_files = ['root', 'main.yml']\n\n    def get(self, request, **kwargs):\n        playbook_id = kwargs.get('pk')\n        playbook = get_object_or_404(Playbook, id=playbook_id)\n        work_path = playbook.work_dir\n        file_key = request.query_params.get('key', '')\n        if file_key:\n            file_path = os.path.join(work_path, file_key)\n            with open(file_path, 'r') as f:\n                try:\n                    content = f.read()\n                except UnicodeDecodeError:\n                    content = _('Unsupported file content')\n                return Response({'content': content})\n        else:\n            expand_key = request.query_params.get('expand', '')\n            nodes = self.generate_tree(playbook, work_path, expand_key)\n            return Response(nodes)\n\n    def post(self, request, **kwargs):\n        playbook_id = kwargs.get('pk')\n        playbook = get_object_or_404(Playbook, id=playbook_id)\n        work_path = playbook.work_dir\n\n        parent_key = request.data.get('key', '')\n        if parent_key == 'root':\n            parent_key = ''\n        if os.path.dirname(parent_key) == 'root':\n            parent_key = os.path.basename(parent_key)\n        full_path = os.path.join(work_path, parent_key)\n\n        is_directory = request.data.get('is_directory', False)\n        content = request.data.get('content', '')\n        name = request.data.get('name', '')\n\n        def find_new_name(p, is_file=False):\n            if not p:\n                if is_file:\n                    p = 'new_file.yml'\n                else:\n                    p = 'new_dir'\n            np = os.path.join(full_path, p)\n            n = 0\n            while os.path.exists(np):\n                n += 1\n                np = os.path.join(full_path, '{}({})'.format(p, n))\n            return np\n\n        if is_directory:\n            new_file_path = find_new_name(name)\n            os.makedirs(new_file_path)\n        else:\n            new_file_path = find_new_name(name, True)\n            with open(new_file_path, 'w') as f:\n                f.write(content)\n\n        relative_path = os.path.relpath(os.path.dirname(new_file_path), work_path)\n        new_node = {\n            \"name\": os.path.basename(new_file_path),\n            \"title\": os.path.basename(new_file_path),\n            \"id\": os.path.join(relative_path, os.path.basename(new_file_path))\n            if not os.path.join(relative_path, os.path.basename(new_file_path)).startswith('.')\n            else os.path.basename(new_file_path),\n            \"isParent\": is_directory,\n            \"pId\": relative_path if not relative_path.startswith('.') else 'root',\n            \"open\": True,\n        }\n        if not is_directory:\n            new_node['iconSkin'] = 'file'\n        return Response(new_node)\n\n    def patch(self, request, **kwargs):\n        playbook_id = kwargs.get('pk')\n        playbook = get_object_or_404(Playbook, id=playbook_id)\n        work_path = playbook.work_dir\n\n        file_key = request.data.get('key', '')\n        new_name = request.data.get('new_name', '')\n\n        if file_key in self.protected_files and new_name:\n            return Response({'msg': '{} can not be rename'.format(file_key)}, status=status.HTTP_400_BAD_REQUEST)\n\n        if os.path.dirname(file_key) == 'root':\n            file_key = os.path.basename(file_key)\n\n        content = request.data.get('content', '')\n        is_directory = request.data.get('is_directory', False)\n\n        if not file_key or file_key == 'root':\n            return Response(status=status.HTTP_400_BAD_REQUEST)\n        file_path = os.path.join(work_path, file_key)\n\n        # rename\n        if new_name:\n            new_file_path = os.path.join(os.path.dirname(file_path), new_name)\n            if new_file_path == file_path:\n                return Response(status=status.HTTP_200_OK)\n            if os.path.exists(new_file_path):\n                return Response({'msg': '{} already exists'.format(new_name)}, status=status.HTTP_400_BAD_REQUEST)\n            os.rename(file_path, new_file_path)\n        # edit content\n        else:\n            if not is_directory:\n                with open(file_path, 'w') as f:\n                    f.write(content)\n        return Response(status=status.HTTP_200_OK)\n\n    def delete(self, request, **kwargs):\n        playbook_id = kwargs.get('pk')\n        playbook = get_object_or_404(Playbook, id=playbook_id)\n        work_path = playbook.work_dir\n        file_key = request.query_params.get('key', '')\n        if not file_key:\n            return Response({'msg': 'key is required'}, status=status.HTTP_400_BAD_REQUEST)\n        if file_key in self.protected_files:\n            return Response({'msg': ' {} can not be delete'.format(file_key)}, status=status.HTTP_400_BAD_REQUEST)\n        file_path = os.path.join(work_path, file_key)\n        if os.path.isdir(file_path):\n            shutil.rmtree(file_path)\n        else:\n            os.remove(file_path)\n        return Response({'msg': 'ok'})\n\n    @staticmethod\n    def generate_tree(playbook, root_path, expand_key=None):\n        nodes = [{\n            \"name\": playbook.name,\n            \"title\": playbook.name,\n            \"id\": 'root',\n            \"isParent\": True,\n            \"open\": True,\n            \"pId\": '',\n            \"temp\": False\n        }]\n        for path, dirs, files in os.walk(root_path):\n            dirs.sort()\n            files.sort()\n\n            relative_path = os.path.relpath(path, root_path)\n            for d in dirs:\n                node = {\n                    \"name\": d,\n                    \"title\": d,\n                    \"id\": os.path.join(relative_path, d) if not os.path.join(relative_path, d).startswith(\n                        '.') else d,\n                    \"isParent\": True,\n                    \"open\": True,\n                    \"pId\": relative_path if not relative_path.startswith('.') else 'root',\n                    \"temp\": False\n                }\n                if expand_key == node['id']:\n                    node['open'] = True\n                nodes.append(node)\n            for f in files:\n                node = {\n                    \"name\": f,\n                    \"title\": f,\n                    \"iconSkin\": 'file',\n                    \"id\": os.path.join(relative_path, f) if not os.path.join(relative_path, f).startswith(\n                        '.') else f,\n                    \"isParent\": False,\n                    \"open\": False,\n                    \"pId\": relative_path if not relative_path.startswith('.') else 'root',\n                    \"temp\": False\n                }\n                nodes.append(node)\n        return nodes\n"], "fixing_code": ["import os\nimport shutil\nimport zipfile\n\nfrom django.conf import settings\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.shortcuts import get_object_or_404\nfrom django.utils.translation import gettext_lazy as _\nfrom rest_framework import status\n\nfrom common.exceptions import JMSException\nfrom orgs.mixins.api import OrgBulkModelViewSet\nfrom rbac.permissions import RBACPermission\nfrom ..exception import PlaybookNoValidEntry\nfrom ..models import Playbook\nfrom ..serializers.playbook import PlaybookSerializer\n\n__all__ = [\"PlaybookViewSet\", \"PlaybookFileBrowserAPIView\"]\n\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom django.utils._os import safe_join\n\n\ndef unzip_playbook(src, dist):\n    fz = zipfile.ZipFile(src, 'r')\n    for file in fz.namelist():\n        fz.extract(file, dist)\n\n\nclass PlaybookViewSet(OrgBulkModelViewSet):\n    serializer_class = PlaybookSerializer\n    permission_classes = (RBACPermission,)\n    model = Playbook\n    search_fields = ('name', 'comment')\n\n    def perform_destroy(self, instance):\n        if instance.job_set.exists():\n            raise JMSException(code='playbook_has_job', detail={\"msg\": _(\"Currently playbook is being used in a job\")})\n        instance_id = instance.id\n        super().perform_destroy(instance)\n        dest_path = safe_join(settings.DATA_DIR, \"ops\", \"playbook\", instance_id.__str__())\n        shutil.rmtree(dest_path)\n\n    def get_queryset(self):\n        queryset = super().get_queryset()\n        queryset = queryset.filter(creator=self.request.user)\n        return queryset\n\n    def perform_create(self, serializer):\n        instance = serializer.save()\n        if 'multipart/form-data' in self.request.headers['Content-Type']:\n            src_path = safe_join(settings.MEDIA_ROOT, instance.path.name)\n            dest_path = safe_join(settings.DATA_DIR, \"ops\", \"playbook\", instance.id.__str__())\n            try:\n                unzip_playbook(src_path, dest_path)\n            except RuntimeError as e:\n                raise JMSException(code='invalid_playbook_file', detail={\"msg\": \"Unzip failed\"})\n\n            if 'main.yml' not in os.listdir(dest_path):\n                raise PlaybookNoValidEntry\n\n        else:\n            if instance.create_method == 'blank':\n                dest_path = safe_join(settings.DATA_DIR, \"ops\", \"playbook\", instance.id.__str__())\n                os.makedirs(dest_path)\n                with open(safe_join(dest_path, 'main.yml'), 'w') as f:\n                    f.write('## write your playbook here')\n\n\nclass PlaybookFileBrowserAPIView(APIView):\n    rbac_perms = ()\n    permission_classes = (RBACPermission,)\n    rbac_perms = {\n        'GET': 'ops.change_playbook',\n        'POST': 'ops.change_playbook',\n        'DELETE': 'ops.change_playbook',\n        'PATCH': 'ops.change_playbook',\n    }\n    protected_files = ['root', 'main.yml']\n\n    def get(self, request, **kwargs):\n        playbook_id = kwargs.get('pk')\n        playbook = get_object_or_404(Playbook, id=playbook_id)\n        work_path = playbook.work_dir\n        file_key = request.query_params.get('key', '')\n        if file_key:\n            try:\n                file_path = safe_join(work_path, file_key)\n                with open(file_path, 'r') as f:\n                    content = f.read()\n            except UnicodeDecodeError:\n                content = _('Unsupported file content')\n            except SuspiciousFileOperation:\n                raise JMSException(code='invalid_file_path', detail={\"msg\": _(\"Invalid file path\")})\n            return Response({'content': content})\n        else:\n            expand_key = request.query_params.get('expand', '')\n            nodes = self.generate_tree(playbook, work_path, expand_key)\n            return Response(nodes)\n\n    def post(self, request, **kwargs):\n        playbook_id = kwargs.get('pk')\n        playbook = get_object_or_404(Playbook, id=playbook_id)\n        work_path = playbook.work_dir\n\n        parent_key = request.data.get('key', '')\n        if parent_key == 'root':\n            parent_key = ''\n        if os.path.dirname(parent_key) == 'root':\n            parent_key = os.path.basename(parent_key)\n\n        full_path = safe_join(work_path, parent_key)\n\n        is_directory = request.data.get('is_directory', False)\n        content = request.data.get('content', '')\n        name = request.data.get('name', '')\n\n        def find_new_name(p, is_file=False):\n            if not p:\n                if is_file:\n                    p = 'new_file.yml'\n                else:\n                    p = 'new_dir'\n            np = safe_join(full_path, p)\n            n = 0\n            while os.path.exists(np):\n                n += 1\n                np = safe_join(full_path, '{}({})'.format(p, n))\n            return np\n\n        try:\n            if is_directory:\n                new_file_path = find_new_name(name)\n                os.makedirs(new_file_path)\n            else:\n                new_file_path = find_new_name(name, True)\n                with open(new_file_path, 'w') as f:\n                    f.write(content)\n        except SuspiciousFileOperation:\n            raise JMSException(code='invalid_file_path', detail={\"msg\": _(\"Invalid file path\")})\n\n        relative_path = os.path.relpath(os.path.dirname(new_file_path), work_path)\n        new_node = {\n            \"name\": os.path.basename(new_file_path),\n            \"title\": os.path.basename(new_file_path),\n            \"id\": safe_join(relative_path, os.path.basename(new_file_path))\n            if not safe_join(relative_path, os.path.basename(new_file_path)).startswith('.')\n            else os.path.basename(new_file_path),\n            \"isParent\": is_directory,\n            \"pId\": relative_path if not relative_path.startswith('.') else 'root',\n            \"open\": True,\n        }\n        if not is_directory:\n            new_node['iconSkin'] = 'file'\n        return Response(new_node)\n\n    def patch(self, request, **kwargs):\n        playbook_id = kwargs.get('pk')\n        playbook = get_object_or_404(Playbook, id=playbook_id)\n        work_path = playbook.work_dir\n\n        file_key = request.data.get('key', '')\n        new_name = request.data.get('new_name', '')\n\n        if file_key in self.protected_files and new_name:\n            raise JMSException(code='this_file_can_not_be_rename', detail={\"msg\": _(\"This file can not be rename\")})\n\n        if os.path.dirname(file_key) == 'root':\n            file_key = os.path.basename(file_key)\n\n        content = request.data.get('content', '')\n        is_directory = request.data.get('is_directory', False)\n\n        if not file_key or file_key == 'root':\n            return Response(status=status.HTTP_400_BAD_REQUEST)\n        file_path = safe_join(work_path, file_key)\n\n        # rename\n        if new_name:\n            try:\n                new_file_path = safe_join(os.path.dirname(file_path), new_name)\n                if new_file_path == file_path:\n                    return Response(status=status.HTTP_200_OK)\n                if os.path.exists(new_file_path):\n                    raise JMSException(code='file_already exists', detail={\"msg\": _(\"File already exists\")})\n                os.rename(file_path, new_file_path)\n            except SuspiciousFileOperation:\n                raise JMSException(code='invalid_file_path', detail={\"msg\": _(\"Invalid file path\")})\n\n        # edit content\n        else:\n            if not is_directory:\n                with open(file_path, 'w') as f:\n                    f.write(content)\n        return Response(status=status.HTTP_200_OK)\n\n    def delete(self, request, **kwargs):\n        playbook_id = kwargs.get('pk')\n        playbook = get_object_or_404(Playbook, id=playbook_id)\n        work_path = playbook.work_dir\n        file_key = request.query_params.get('key', '')\n        if not file_key:\n            raise JMSException(code='file_key_is_required', detail={\"msg\": _(\"File key is required\")})\n\n        if file_key in self.protected_files:\n            raise JMSException(code='This file can not be delete', detail={\"msg\": _(\"This file can not be delete\")})\n        file_path = safe_join(work_path, file_key)\n        if os.path.isdir(file_path):\n            shutil.rmtree(file_path)\n        else:\n            os.remove(file_path)\n        return Response({'msg': 'ok'})\n\n    @staticmethod\n    def generate_tree(playbook, root_path, expand_key=None):\n        nodes = [{\n            \"name\": playbook.name,\n            \"title\": playbook.name,\n            \"id\": 'root',\n            \"isParent\": True,\n            \"open\": True,\n            \"pId\": '',\n            \"temp\": False\n        }]\n        for path, dirs, files in os.walk(root_path):\n            dirs.sort()\n            files.sort()\n\n            relative_path = os.path.relpath(path, root_path)\n            for d in dirs:\n                dir_id = os.path.relpath(safe_join(path, d), root_path)\n\n                node = {\n                    \"name\": d,\n                    \"title\": d,\n                    \"id\": dir_id,\n                    \"isParent\": True,\n                    \"open\": True,\n                    \"pId\": relative_path if not relative_path.startswith('.') else 'root',\n                    \"temp\": False\n                }\n                if expand_key == node['id']:\n                    node['open'] = True\n                nodes.append(node)\n            for f in files:\n                file_id = os.path.relpath(safe_join(path, f), root_path)\n                node = {\n                    \"name\": f,\n                    \"title\": f,\n                    \"iconSkin\": 'file',\n                    \"id\": file_id,\n                    \"isParent\": False,\n                    \"open\": False,\n                    \"pId\": relative_path if not relative_path.startswith('.') else 'root',\n                    \"temp\": False\n                }\n                nodes.append(node)\n        return nodes\n"], "filenames": ["apps/ops/api/playbook.py"], "buggy_code_start_loc": [5], "buggy_code_end_loc": [239], "fixing_code_start_loc": [6], "fixing_code_end_loc": [253], "type": "CWE-22", "message": "JumpServer is an open source bastion host. Logged-in users can access and modify the contents of any file on the system. A user can use the 'Job-Template' menu and create a playbook named 'test'. Get the playbook id from the detail page, like 'e0adabef-c38f-492d-bd92-832bacc3df5f'. An attacker can exploit the directory traversal flaw using the provided URL to access and retrieve the contents of the file. `https://jumpserver-ip/api/v1/ops/playbook/e0adabef-c38f-492d-bd92-832bacc3df5f/file/?key=../../../../../../../etc/passwd` a similar method to modify the file content is also present. This issue has been addressed in version 3.6.5. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n", "other": {"cve": {"id": "CVE-2023-42819", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-27T15:19:33.143", "lastModified": "2023-09-29T14:42:30.233", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "JumpServer is an open source bastion host. Logged-in users can access and modify the contents of any file on the system. A user can use the 'Job-Template' menu and create a playbook named 'test'. Get the playbook id from the detail page, like 'e0adabef-c38f-492d-bd92-832bacc3df5f'. An attacker can exploit the directory traversal flaw using the provided URL to access and retrieve the contents of the file. `https://jumpserver-ip/api/v1/ops/playbook/e0adabef-c38f-492d-bd92-832bacc3df5f/file/?key=../../../../../../../etc/passwd` a similar method to modify the file content is also present. This issue has been addressed in version 3.6.5. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n"}, {"lang": "es", "value": "JumpServer es un host bastionado de c\u00f3digo abierto. Los usuarios que hayan iniciado sesi\u00f3n pueden acceder y modificar el contenido de cualquier archivo del sistema. Un usuario puede utilizar el men\u00fa 'Job-Template' y crear un playbook llamado 'test'. Obtenga la identificaci\u00f3n del playbook en la p\u00e1gina de detalles, como 'e0adabef-c38f-492d-bd92-832bacc3df5f'. Un atacante puede aprovechar la falla de directory traversal utilizando la URL proporcionada para acceder y recuperar el contenido del archivo. `https://jumpserver-ip/api/v1/ops/playbook/e0adabef-c38f-492d-bd92-832bacc3df5f/file/?key=../../../../../../ ../etc/passwd` tambi\u00e9n est\u00e1 presente un m\u00e9todo similar para modificar el contenido del archivo. Este problema se solucion\u00f3 en la versi\u00f3n 3.6.5. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.9, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fit2cloud:jumpserver:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.6.5", "matchCriteriaId": "3102E381-1725-4710-BA7F-F41189347AFE"}]}]}], "references": [{"url": "https://github.com/jumpserver/jumpserver/commit/d0321a74f1713d031560341c8fd0a1859e6510d8", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/jumpserver/jumpserver/security/advisories/GHSA-ghg2-2whp-6m33", "source": "security-advisories@github.com", "tags": ["Mitigation", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jumpserver/jumpserver/commit/d0321a74f1713d031560341c8fd0a1859e6510d8"}}