{"buggy_code": ["CONFIG_PPC64=y\nCONFIG_ALTIVEC=y\nCONFIG_SMP=y\nCONFIG_NR_CPUS=2\nCONFIG_SYSVIPC=y\nCONFIG_NO_HZ=y\nCONFIG_HIGH_RES_TIMERS=y\nCONFIG_BLK_DEV_INITRD=y\nCONFIG_PROFILING=y\nCONFIG_OPROFILE=y\nCONFIG_MODULES=y\nCONFIG_MODULE_UNLOAD=y\n# CONFIG_BLK_DEV_BSG is not set\nCONFIG_PARTITION_ADVANCED=y\nCONFIG_MAC_PARTITION=y\n# CONFIG_PPC_POWERNV is not set\n# CONFIG_PPC_PSERIES is not set\n# CONFIG_PPC_PMAC is not set\nCONFIG_PPC_PASEMI=y\nCONFIG_PPC_PASEMI_IOMMU=y\nCONFIG_CPU_FREQ=y\nCONFIG_CPU_FREQ_GOV_POWERSAVE=y\nCONFIG_CPU_FREQ_GOV_USERSPACE=y\nCONFIG_CPU_FREQ_GOV_ONDEMAND=y\nCONFIG_HZ_1000=y\nCONFIG_PPC_64K_PAGES=y\n# CONFIG_SECCOMP is not set\nCONFIG_PCI_MSI=y\nCONFIG_PCCARD=y\nCONFIG_ELECTRA_CF=y\nCONFIG_NET=y\nCONFIG_PACKET=y\nCONFIG_UNIX=y\nCONFIG_XFRM_USER=y\nCONFIG_NET_KEY=y\nCONFIG_INET=y\nCONFIG_IP_MULTICAST=y\nCONFIG_IP_PNP=y\nCONFIG_IP_PNP_DHCP=y\nCONFIG_IP_PNP_BOOTP=y\nCONFIG_IP_PNP_RARP=y\nCONFIG_NET_IPIP=y\nCONFIG_SYN_COOKIES=y\nCONFIG_INET_AH=y\nCONFIG_INET_ESP=y\n# CONFIG_IPV6 is not set\nCONFIG_DEVTMPFS=y\nCONFIG_DEVTMPFS_MOUNT=y\nCONFIG_MTD=y\nCONFIG_MTD_BLOCK=y\nCONFIG_MTD_SLRAM=y\nCONFIG_MTD_PHRAM=y\nCONFIG_MTD_RAW_NAND=y\nCONFIG_MTD_NAND_PASEMI=y\nCONFIG_BLK_DEV_LOOP=y\nCONFIG_BLK_DEV_RAM=y\nCONFIG_BLK_DEV_RAM_SIZE=16384\nCONFIG_EEPROM_LEGACY=y\nCONFIG_BLK_DEV_SD=y\nCONFIG_CHR_DEV_ST=y\nCONFIG_BLK_DEV_SR=y\nCONFIG_CHR_DEV_SG=y\nCONFIG_CHR_DEV_SCH=y\nCONFIG_SCSI_CONSTANTS=y\nCONFIG_SCSI_LOGGING=y\nCONFIG_ATA=y\nCONFIG_SATA_SIL24=y\nCONFIG_SATA_MV=y\nCONFIG_PATA_PCMCIA=y\nCONFIG_PATA_PLATFORM=y\nCONFIG_PATA_OF_PLATFORM=y\nCONFIG_ATA_GENERIC=y\nCONFIG_MD=y\nCONFIG_BLK_DEV_MD=y\nCONFIG_MD_LINEAR=y\nCONFIG_MD_RAID0=y\nCONFIG_MD_RAID1=y\nCONFIG_MD_RAID10=y\nCONFIG_MD_RAID456=y\nCONFIG_BLK_DEV_DM=y\nCONFIG_DM_CRYPT=y\nCONFIG_NETDEVICES=y\nCONFIG_DUMMY=y\nCONFIG_TIGON3=y\nCONFIG_E1000=y\nCONFIG_PASEMI_MAC=y\nCONFIG_MARVELL_PHY=y\nCONFIG_INPUT_JOYDEV=y\nCONFIG_INPUT_EVDEV=y\n# CONFIG_KEYBOARD_ATKBD is not set\n# CONFIG_MOUSE_PS2 is not set\n# CONFIG_SERIO is not set\nCONFIG_LEGACY_PTY_COUNT=4\nCONFIG_SERIAL_8250=y\nCONFIG_SERIAL_8250_CONSOLE=y\nCONFIG_HW_RANDOM=y\nCONFIG_RAW_DRIVER=y\nCONFIG_I2C_CHARDEV=y\nCONFIG_I2C_PASEMI=y\nCONFIG_SENSORS_LM85=y\nCONFIG_SENSORS_LM90=y\nCONFIG_DRM=y\nCONFIG_DRM_RADEON=y\nCONFIG_FIRMWARE_EDID=y\nCONFIG_FB_TILEBLITTING=y\nCONFIG_FB_VGA16=y\nCONFIG_FB_NVIDIA=y\nCONFIG_FB_NVIDIA_I2C=y\nCONFIG_FB_RADEON=y\n# CONFIG_LCD_CLASS_DEVICE is not set\nCONFIG_VGACON_SOFT_SCROLLBACK=y\nCONFIG_LOGO=y\nCONFIG_SOUND=y\nCONFIG_SND=y\nCONFIG_SND_OSSEMUL=y\nCONFIG_SND_MIXER_OSS=y\nCONFIG_SND_PCM_OSS=y\nCONFIG_SND_SEQUENCER=y\nCONFIG_SND_SEQUENCER_OSS=y\nCONFIG_SND_USB_AUDIO=y\nCONFIG_SND_USB_USX2Y=y\nCONFIG_HID_DRAGONRISE=y\nCONFIG_HID_GYRATION=y\nCONFIG_HID_TWINHAN=y\nCONFIG_HID_NTRIG=y\nCONFIG_HID_PANTHERLORD=y\nCONFIG_HID_PETALYNX=y\nCONFIG_HID_SAMSUNG=y\nCONFIG_HID_SUNPLUS=y\nCONFIG_HID_GREENASIA=y\nCONFIG_HID_SMARTJOYPLUS=y\nCONFIG_HID_TOPSEED=y\nCONFIG_HID_THRUSTMASTER=y\nCONFIG_HID_ZEROPLUS=y\nCONFIG_USB=y\nCONFIG_USB_EHCI_HCD=y\nCONFIG_USB_OHCI_HCD=y\nCONFIG_USB_UHCI_HCD=y\nCONFIG_USB_SL811_HCD=y\nCONFIG_USB_STORAGE=y\nCONFIG_EDAC=y\nCONFIG_EDAC_PASEMI=y\nCONFIG_RTC_CLASS=y\nCONFIG_RTC_DRV_DS1307=y\nCONFIG_RAS=y\nCONFIG_EXT2_FS=y\nCONFIG_EXT2_FS_XATTR=y\nCONFIG_EXT2_FS_POSIX_ACL=y\nCONFIG_EXT4_FS=y\nCONFIG_AUTOFS4_FS=y\nCONFIG_ISO9660_FS=y\nCONFIG_UDF_FS=y\nCONFIG_MSDOS_FS=y\nCONFIG_VFAT_FS=y\nCONFIG_PROC_KCORE=y\nCONFIG_TMPFS=y\nCONFIG_HUGETLBFS=y\nCONFIG_CONFIGFS_FS=y\nCONFIG_JFFS2_FS=y\nCONFIG_NFS_FS=y\nCONFIG_ROOT_NFS=y\nCONFIG_NFSD=y\nCONFIG_NFSD_V4=y\nCONFIG_NLS_CODEPAGE_437=y\nCONFIG_NLS_ISO8859_1=y\nCONFIG_CRC_CCITT=y\nCONFIG_PRINTK_TIME=y\nCONFIG_MAGIC_SYSRQ=y\nCONFIG_DEBUG_KERNEL=y\nCONFIG_DETECT_HUNG_TASK=y\n# CONFIG_SCHED_DEBUG is not set\nCONFIG_XMON=y\nCONFIG_XMON_DEFAULT=y\nCONFIG_CRYPTO_MD4=y\nCONFIG_CRYPTO_SHA512=y\nCONFIG_CRYPTO_BLOWFISH=y\n", "CONFIG_FSL_EMB_PERFMON=y\n# CONFIG_LOCALVERSION_AUTO is not set\nCONFIG_SYSVIPC=y\nCONFIG_POSIX_MQUEUE=y\nCONFIG_AUDIT=y\nCONFIG_NO_HZ=y\nCONFIG_HIGH_RES_TIMERS=y\nCONFIG_BSD_PROCESS_ACCT=y\nCONFIG_TASKSTATS=y\nCONFIG_TASK_DELAY_ACCT=y\nCONFIG_TASK_XACCT=y\nCONFIG_TASK_IO_ACCOUNTING=y\nCONFIG_CGROUPS=y\nCONFIG_CGROUP_SCHED=y\nCONFIG_RT_GROUP_SCHED=y\nCONFIG_CGROUP_DEVICE=y\nCONFIG_CGROUP_CPUACCT=y\nCONFIG_USER_NS=y\nCONFIG_BLK_DEV_INITRD=y\n# CONFIG_COMPAT_BRK is not set\nCONFIG_PROFILING=y\nCONFIG_OPROFILE=m\nCONFIG_KPROBES=y\nCONFIG_MODULES=y\nCONFIG_MODULE_UNLOAD=y\nCONFIG_MODULE_SRCVERSION_ALL=y\nCONFIG_BLK_DEV_INTEGRITY=y\nCONFIG_PARTITION_ADVANCED=y\nCONFIG_OSF_PARTITION=y\nCONFIG_AMIGA_PARTITION=y\nCONFIG_BSD_DISKLABEL=y\nCONFIG_MINIX_SUBPARTITION=y\nCONFIG_SOLARIS_X86_PARTITION=y\nCONFIG_UNIXWARE_DISKLABEL=y\nCONFIG_SGI_PARTITION=y\nCONFIG_SUN_PARTITION=y\nCONFIG_KARMA_PARTITION=y\nCONFIG_PPC_MPC52xx=y\nCONFIG_PPC_EFIKA=y\nCONFIG_PPC_MPC5200_BUGFIX=y\nCONFIG_PPC_82xx=y\nCONFIG_MPC8272_ADS=y\nCONFIG_PQ2FADS=y\nCONFIG_EP8248E=y\nCONFIG_MGCOGE=y\nCONFIG_PPC_83xx=y\nCONFIG_MPC831x_RDB=y\nCONFIG_MPC832x_MDS=y\nCONFIG_MPC832x_RDB=y\nCONFIG_MPC834x_MDS=y\nCONFIG_MPC834x_ITX=y\nCONFIG_MPC836x_MDS=y\nCONFIG_MPC836x_RDK=y\nCONFIG_MPC837x_MDS=y\nCONFIG_MPC837x_RDB=y\nCONFIG_ASP834x=y\nCONFIG_PPC_86xx=y\nCONFIG_MPC8641_HPCN=y\nCONFIG_SBC8641D=y\nCONFIG_MPC8610_HPCD=y\nCONFIG_GEF_SBC610=y\nCONFIG_CPU_FREQ=y\nCONFIG_CPU_FREQ_STAT=y\nCONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y\nCONFIG_CPU_FREQ_GOV_PERFORMANCE=y\nCONFIG_CPU_FREQ_GOV_POWERSAVE=m\nCONFIG_CPU_FREQ_GOV_ONDEMAND=m\nCONFIG_CPU_FREQ_GOV_CONSERVATIVE=m\nCONFIG_CPU_FREQ_PMAC=y\nCONFIG_TAU=y\nCONFIG_TAU_AVERAGE=y\nCONFIG_QE_GPIO=y\nCONFIG_MCU_MPC8349EMITX=y\nCONFIG_HIGHMEM=y\nCONFIG_HZ_1000=y\nCONFIG_PREEMPT_VOLUNTARY=y\nCONFIG_BINFMT_MISC=y\nCONFIG_HIBERNATION=y\nCONFIG_PM_DEBUG=y\nCONFIG_ISA=y\nCONFIG_PCIEPORTBUS=y\nCONFIG_PCI_MSI=y\nCONFIG_PCCARD=y\nCONFIG_YENTA=y\nCONFIG_PD6729=m\nCONFIG_I82092=m\nCONFIG_I82365=m\nCONFIG_ADVANCED_OPTIONS=y\nCONFIG_NET=y\nCONFIG_PACKET=y\nCONFIG_UNIX=y\nCONFIG_XFRM_USER=y\nCONFIG_XFRM_SUB_POLICY=y\nCONFIG_XFRM_STATISTICS=y\nCONFIG_NET_KEY=m\nCONFIG_NET_KEY_MIGRATE=y\nCONFIG_INET=y\nCONFIG_IP_MULTICAST=y\nCONFIG_IP_ADVANCED_ROUTER=y\nCONFIG_IP_MULTIPLE_TABLES=y\nCONFIG_IP_ROUTE_MULTIPATH=y\nCONFIG_IP_ROUTE_VERBOSE=y\nCONFIG_NET_IPIP=m\nCONFIG_IP_MROUTE=y\nCONFIG_IP_PIMSM_V1=y\nCONFIG_IP_PIMSM_V2=y\nCONFIG_SYN_COOKIES=y\nCONFIG_INET_AH=m\nCONFIG_INET_ESP=m\nCONFIG_INET_IPCOMP=m\nCONFIG_INET_DIAG=m\nCONFIG_TCP_CONG_ADVANCED=y\nCONFIG_TCP_CONG_HSTCP=m\nCONFIG_TCP_CONG_HYBLA=m\nCONFIG_TCP_CONG_SCALABLE=m\nCONFIG_TCP_CONG_LP=m\nCONFIG_TCP_CONG_VENO=m\nCONFIG_TCP_CONG_YEAH=m\nCONFIG_TCP_CONG_ILLINOIS=m\nCONFIG_TCP_MD5SIG=y\nCONFIG_IPV6_ROUTER_PREF=y\nCONFIG_IPV6_ROUTE_INFO=y\nCONFIG_IPV6_OPTIMISTIC_DAD=y\nCONFIG_INET6_AH=m\nCONFIG_INET6_ESP=m\nCONFIG_INET6_IPCOMP=m\nCONFIG_IPV6_MIP6=m\nCONFIG_IPV6_TUNNEL=m\nCONFIG_IPV6_MULTIPLE_TABLES=y\nCONFIG_IPV6_SUBTREES=y\nCONFIG_IPV6_MROUTE=y\nCONFIG_IPV6_PIMSM_V2=y\nCONFIG_NETLABEL=y\nCONFIG_NETFILTER=y\nCONFIG_NF_CONNTRACK=m\nCONFIG_NF_CONNTRACK_SECMARK=y\nCONFIG_NF_CONNTRACK_EVENTS=y\nCONFIG_NF_CONNTRACK_AMANDA=m\nCONFIG_NF_CONNTRACK_FTP=m\nCONFIG_NF_CONNTRACK_H323=m\nCONFIG_NF_CONNTRACK_IRC=m\nCONFIG_NF_CONNTRACK_NETBIOS_NS=m\nCONFIG_NF_CONNTRACK_PPTP=m\nCONFIG_NF_CONNTRACK_SANE=m\nCONFIG_NF_CONNTRACK_SIP=m\nCONFIG_NF_CONNTRACK_TFTP=m\nCONFIG_NF_CT_NETLINK=m\nCONFIG_NETFILTER_XT_TARGET_CLASSIFY=m\nCONFIG_NETFILTER_XT_TARGET_CONNMARK=m\nCONFIG_NETFILTER_XT_TARGET_CONNSECMARK=m\nCONFIG_NETFILTER_XT_TARGET_DSCP=m\nCONFIG_NETFILTER_XT_TARGET_MARK=m\nCONFIG_NETFILTER_XT_TARGET_NFLOG=m\nCONFIG_NETFILTER_XT_TARGET_NFQUEUE=m\nCONFIG_NETFILTER_XT_TARGET_TPROXY=m\nCONFIG_NETFILTER_XT_TARGET_TRACE=m\nCONFIG_NETFILTER_XT_TARGET_SECMARK=m\nCONFIG_NETFILTER_XT_TARGET_TCPMSS=m\nCONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=m\nCONFIG_NETFILTER_XT_MATCH_COMMENT=m\nCONFIG_NETFILTER_XT_MATCH_CONNBYTES=m\nCONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m\nCONFIG_NETFILTER_XT_MATCH_CONNMARK=m\nCONFIG_NETFILTER_XT_MATCH_CONNTRACK=m\nCONFIG_NETFILTER_XT_MATCH_DSCP=m\nCONFIG_NETFILTER_XT_MATCH_ESP=m\nCONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m\nCONFIG_NETFILTER_XT_MATCH_HELPER=m\nCONFIG_NETFILTER_XT_MATCH_IPRANGE=m\nCONFIG_NETFILTER_XT_MATCH_LENGTH=m\nCONFIG_NETFILTER_XT_MATCH_LIMIT=m\nCONFIG_NETFILTER_XT_MATCH_MAC=m\nCONFIG_NETFILTER_XT_MATCH_MARK=m\nCONFIG_NETFILTER_XT_MATCH_MULTIPORT=m\nCONFIG_NETFILTER_XT_MATCH_OWNER=m\nCONFIG_NETFILTER_XT_MATCH_POLICY=m\nCONFIG_NETFILTER_XT_MATCH_PHYSDEV=m\nCONFIG_NETFILTER_XT_MATCH_PKTTYPE=m\nCONFIG_NETFILTER_XT_MATCH_QUOTA=m\nCONFIG_NETFILTER_XT_MATCH_RATEEST=m\nCONFIG_NETFILTER_XT_MATCH_REALM=m\nCONFIG_NETFILTER_XT_MATCH_RECENT=m\nCONFIG_NETFILTER_XT_MATCH_STATE=m\nCONFIG_NETFILTER_XT_MATCH_STATISTIC=m\nCONFIG_NETFILTER_XT_MATCH_STRING=m\nCONFIG_NETFILTER_XT_MATCH_TCPMSS=m\nCONFIG_NETFILTER_XT_MATCH_TIME=m\nCONFIG_NETFILTER_XT_MATCH_U32=m\nCONFIG_IP_NF_IPTABLES=m\nCONFIG_IP_NF_MATCH_AH=m\nCONFIG_IP_NF_MATCH_ECN=m\nCONFIG_IP_NF_MATCH_TTL=m\nCONFIG_IP_NF_FILTER=m\nCONFIG_IP_NF_TARGET_REJECT=m\nCONFIG_IP_NF_MANGLE=m\nCONFIG_IP_NF_TARGET_CLUSTERIP=m\nCONFIG_IP_NF_TARGET_ECN=m\nCONFIG_IP_NF_TARGET_TTL=m\nCONFIG_IP_NF_RAW=m\nCONFIG_IP_NF_SECURITY=m\nCONFIG_IP_NF_ARPTABLES=m\nCONFIG_IP_NF_ARPFILTER=m\nCONFIG_IP_NF_ARP_MANGLE=m\nCONFIG_IP6_NF_IPTABLES=m\nCONFIG_IP6_NF_MATCH_AH=m\nCONFIG_IP6_NF_MATCH_EUI64=m\nCONFIG_IP6_NF_MATCH_FRAG=m\nCONFIG_IP6_NF_MATCH_OPTS=m\nCONFIG_IP6_NF_MATCH_HL=m\nCONFIG_IP6_NF_MATCH_IPV6HEADER=m\nCONFIG_IP6_NF_MATCH_MH=m\nCONFIG_IP6_NF_MATCH_RT=m\nCONFIG_IP6_NF_TARGET_HL=m\nCONFIG_IP6_NF_FILTER=m\nCONFIG_IP6_NF_TARGET_REJECT=m\nCONFIG_IP6_NF_MANGLE=m\nCONFIG_IP6_NF_RAW=m\nCONFIG_IP6_NF_SECURITY=m\nCONFIG_BRIDGE_NF_EBTABLES=m\nCONFIG_BRIDGE_EBT_BROUTE=m\nCONFIG_BRIDGE_EBT_T_FILTER=m\nCONFIG_BRIDGE_EBT_T_NAT=m\nCONFIG_BRIDGE_EBT_802_3=m\nCONFIG_BRIDGE_EBT_AMONG=m\nCONFIG_BRIDGE_EBT_ARP=m\nCONFIG_BRIDGE_EBT_IP=m\nCONFIG_BRIDGE_EBT_IP6=m\nCONFIG_BRIDGE_EBT_LIMIT=m\nCONFIG_BRIDGE_EBT_MARK=m\nCONFIG_BRIDGE_EBT_PKTTYPE=m\nCONFIG_BRIDGE_EBT_STP=m\nCONFIG_BRIDGE_EBT_VLAN=m\nCONFIG_BRIDGE_EBT_ARPREPLY=m\nCONFIG_BRIDGE_EBT_DNAT=m\nCONFIG_BRIDGE_EBT_MARK_T=m\nCONFIG_BRIDGE_EBT_REDIRECT=m\nCONFIG_BRIDGE_EBT_SNAT=m\nCONFIG_BRIDGE_EBT_LOG=m\nCONFIG_BRIDGE_EBT_NFLOG=m\nCONFIG_IP_DCCP=m\nCONFIG_TIPC=m\nCONFIG_ATM=m\nCONFIG_ATM_CLIP=m\nCONFIG_ATM_LANE=m\nCONFIG_ATM_BR2684=m\nCONFIG_BRIDGE=m\nCONFIG_VLAN_8021Q=m\nCONFIG_DECNET=m\nCONFIG_DECNET_ROUTER=y\nCONFIG_ATALK=m\nCONFIG_DEV_APPLETALK=m\nCONFIG_IPDDP=m\nCONFIG_IPDDP_ENCAP=y\nCONFIG_NET_SCHED=y\nCONFIG_NET_SCH_CBQ=m\nCONFIG_NET_SCH_HTB=m\nCONFIG_NET_SCH_HFSC=m\nCONFIG_NET_SCH_ATM=m\nCONFIG_NET_SCH_PRIO=m\nCONFIG_NET_SCH_MULTIQ=m\nCONFIG_NET_SCH_RED=m\nCONFIG_NET_SCH_SFQ=m\nCONFIG_NET_SCH_TEQL=m\nCONFIG_NET_SCH_TBF=m\nCONFIG_NET_SCH_GRED=m\nCONFIG_NET_SCH_DSMARK=m\nCONFIG_NET_SCH_NETEM=m\nCONFIG_NET_SCH_INGRESS=m\nCONFIG_NET_CLS_BASIC=m\nCONFIG_NET_CLS_TCINDEX=m\nCONFIG_NET_CLS_ROUTE4=m\nCONFIG_NET_CLS_FW=m\nCONFIG_NET_CLS_U32=m\nCONFIG_CLS_U32_PERF=y\nCONFIG_CLS_U32_MARK=y\nCONFIG_NET_CLS_RSVP=m\nCONFIG_NET_CLS_RSVP6=m\nCONFIG_NET_CLS_FLOW=m\nCONFIG_NET_EMATCH=y\nCONFIG_NET_EMATCH_CMP=m\nCONFIG_NET_EMATCH_NBYTE=m\nCONFIG_NET_EMATCH_U32=m\nCONFIG_NET_EMATCH_META=m\nCONFIG_NET_EMATCH_TEXT=m\nCONFIG_NET_CLS_ACT=y\nCONFIG_NET_ACT_POLICE=m\nCONFIG_NET_ACT_GACT=m\nCONFIG_GACT_PROB=y\nCONFIG_NET_ACT_MIRRED=m\nCONFIG_NET_ACT_IPT=m\nCONFIG_NET_ACT_NAT=m\nCONFIG_NET_ACT_PEDIT=m\nCONFIG_NET_ACT_SIMP=m\nCONFIG_NET_ACT_SKBEDIT=m\nCONFIG_BT=m\nCONFIG_BT_RFCOMM=m\nCONFIG_BT_RFCOMM_TTY=y\nCONFIG_BT_BNEP=m\nCONFIG_BT_BNEP_MC_FILTER=y\nCONFIG_BT_BNEP_PROTO_FILTER=y\nCONFIG_BT_HIDP=m\nCONFIG_BT_HCIUART=m\nCONFIG_BT_HCIUART_BCSP=y\nCONFIG_BT_HCIBCM203X=m\nCONFIG_BT_HCIBPA10X=m\nCONFIG_BT_HCIBFUSB=m\nCONFIG_BT_HCIDTL1=m\nCONFIG_BT_HCIBT3C=m\nCONFIG_BT_HCIBLUECARD=m\nCONFIG_BT_HCIVHCI=m\nCONFIG_CFG80211=m\nCONFIG_MAC80211=m\nCONFIG_MAC80211_MESH=y\nCONFIG_MAC80211_LEDS=y\nCONFIG_MAC80211_DEBUGFS=y\nCONFIG_NET_9P=m\nCONFIG_NET_9P_VIRTIO=m\nCONFIG_DEBUG_DEVRES=y\nCONFIG_CONNECTOR=y\nCONFIG_PARPORT=m\nCONFIG_PARPORT_PC=m\nCONFIG_PARPORT_SERIAL=m\nCONFIG_PARPORT_1284=y\nCONFIG_PNP=y\nCONFIG_ISAPNP=y\nCONFIG_MAC_FLOPPY=m\nCONFIG_BLK_DEV_LOOP=m\nCONFIG_BLK_DEV_CRYPTOLOOP=m\nCONFIG_BLK_DEV_NBD=m\nCONFIG_BLK_DEV_RAM=y\nCONFIG_BLK_DEV_RAM_SIZE=16384\nCONFIG_CDROM_PKTCDVD=m\nCONFIG_VIRTIO_BLK=m\nCONFIG_ENCLOSURE_SERVICES=m\nCONFIG_SENSORS_TSL2550=m\nCONFIG_EEPROM_AT24=m\nCONFIG_EEPROM_LEGACY=m\nCONFIG_EEPROM_MAX6875=m\nCONFIG_EEPROM_93CX6=m\nCONFIG_RAID_ATTRS=m\nCONFIG_BLK_DEV_SD=y\nCONFIG_CHR_DEV_ST=m\nCONFIG_BLK_DEV_SR=m\nCONFIG_CHR_DEV_SG=y\nCONFIG_CHR_DEV_SCH=m\nCONFIG_SCSI_ENCLOSURE=m\nCONFIG_SCSI_CONSTANTS=y\nCONFIG_SCSI_LOGGING=y\nCONFIG_SCSI_SCAN_ASYNC=y\nCONFIG_SCSI_SPI_ATTRS=m\nCONFIG_SCSI_SRP_ATTRS=m\nCONFIG_SCSI_MESH=m\nCONFIG_SCSI_MAC53C94=m\nCONFIG_SCSI_LOWLEVEL_PCMCIA=y\nCONFIG_SCSI_DH=y\nCONFIG_SCSI_DH_RDAC=m\nCONFIG_SCSI_DH_HP_SW=m\nCONFIG_SCSI_DH_EMC=m\nCONFIG_ATA=y\n# CONFIG_SATA_PMP is not set\nCONFIG_SATA_FSL=m\nCONFIG_PDC_ADMA=m\nCONFIG_ATA_PIIX=m\nCONFIG_PATA_MACIO=y\nCONFIG_PATA_MPC52xx=m\nCONFIG_PATA_OPTIDMA=m\nCONFIG_PATA_SCH=m\nCONFIG_PATA_VIA=m\nCONFIG_PATA_PLATFORM=m\nCONFIG_PATA_OF_PLATFORM=m\nCONFIG_ATA_GENERIC=y\nCONFIG_MD=y\nCONFIG_BLK_DEV_MD=y\nCONFIG_MD_LINEAR=m\nCONFIG_MD_RAID0=m\nCONFIG_MD_RAID1=m\nCONFIG_MD_RAID10=m\nCONFIG_MD_RAID456=m\nCONFIG_MD_MULTIPATH=m\nCONFIG_MD_FAULTY=m\nCONFIG_BLK_DEV_DM=m\nCONFIG_DM_DEBUG=y\nCONFIG_DM_CRYPT=m\nCONFIG_DM_SNAPSHOT=m\nCONFIG_DM_MIRROR=m\nCONFIG_DM_ZERO=m\nCONFIG_DM_MULTIPATH=m\nCONFIG_DM_UEVENT=y\nCONFIG_FIREWIRE=m\nCONFIG_FIREWIRE_OHCI=m\nCONFIG_FIREWIRE_SBP2=m\nCONFIG_ADB=y\nCONFIG_ADB_CUDA=y\nCONFIG_ADB_PMU=y\nCONFIG_ADB_PMU_LED=y\nCONFIG_ADB_PMU_LED_DISK=y\nCONFIG_PMAC_APM_EMU=y\nCONFIG_PMAC_MEDIABAY=y\nCONFIG_PMAC_BACKLIGHT=y\nCONFIG_ADB_MACIO=y\nCONFIG_INPUT_ADBHID=y\nCONFIG_MAC_EMUMOUSEBTN=y\nCONFIG_THERM_WINDTUNNEL=m\nCONFIG_THERM_ADT746X=m\nCONFIG_WINDFARM=y\nCONFIG_PMAC_RACKMETER=m\nCONFIG_SENSORS_AMS=m\nCONFIG_NETDEVICES=y\nCONFIG_BONDING=m\nCONFIG_DUMMY=m\nCONFIG_EQUALIZER=m\nCONFIG_NET_FC=y\nCONFIG_IFB=m\nCONFIG_MACVLAN=m\nCONFIG_NETCONSOLE=m\nCONFIG_TUN=m\nCONFIG_VETH=m\nCONFIG_VIRTIO_NET=m\nCONFIG_ATM_TCP=m\nCONFIG_ATM_LANAI=m\nCONFIG_ATM_ENI=m\nCONFIG_ATM_NICSTAR=m\nCONFIG_ATM_IDT77252=m\nCONFIG_ATM_HE=m\nCONFIG_EL3=m\nCONFIG_PCMCIA_3C574=m\nCONFIG_PCMCIA_3C589=m\nCONFIG_VORTEX=m\nCONFIG_TYPHOON=m\nCONFIG_ADAPTEC_STARFIRE=m\nCONFIG_ACENIC=m\nCONFIG_AMD8111_ETH=m\nCONFIG_PCNET32=m\nCONFIG_PCMCIA_NMCLAN=m\nCONFIG_MACE=m\nCONFIG_BMAC=m\nCONFIG_ATL1=m\nCONFIG_B44=m\nCONFIG_BNX2=m\nCONFIG_TIGON3=m\nCONFIG_BNX2X=m\nCONFIG_CHELSIO_T1=m\nCONFIG_CHELSIO_T1_1G=y\nCONFIG_CHELSIO_T3=m\nCONFIG_NET_TULIP=y\nCONFIG_DE2104X=m\nCONFIG_TULIP=m\nCONFIG_TULIP_MMIO=y\nCONFIG_DE4X5=m\nCONFIG_WINBOND_840=m\nCONFIG_DM9102=m\nCONFIG_ULI526X=m\nCONFIG_PCMCIA_XIRCOM=m\nCONFIG_DL2K=m\nCONFIG_SUNDANCE=m\nCONFIG_S2IO=m\nCONFIG_FEC_MPC52xx=m\nCONFIG_GIANFAR=m\nCONFIG_PCMCIA_FMVJ18X=m\nCONFIG_E100=m\nCONFIG_E1000=m\nCONFIG_E1000E=m\nCONFIG_IGB=m\nCONFIG_IXGB=m\nCONFIG_IXGBE=m\nCONFIG_MV643XX_ETH=m\nCONFIG_SKGE=m\nCONFIG_SKY2=m\nCONFIG_MYRI10GE=m\nCONFIG_FEALNX=m\nCONFIG_NATSEMI=m\nCONFIG_NS83820=m\nCONFIG_PCMCIA_AXNET=m\nCONFIG_NE2000=m\nCONFIG_NE2K_PCI=m\nCONFIG_PCMCIA_PCNET=m\nCONFIG_ULTRA=m\nCONFIG_FORCEDETH=m\nCONFIG_HAMACHI=m\nCONFIG_YELLOWFIN=m\nCONFIG_QLA3XXX=m\nCONFIG_NETXEN_NIC=m\nCONFIG_8139CP=m\nCONFIG_8139TOO=m\n# CONFIG_8139TOO_PIO is not set\nCONFIG_8139TOO_8129=y\nCONFIG_R8169=m\nCONFIG_R6040=m\nCONFIG_SC92031=m\nCONFIG_SIS900=m\nCONFIG_SIS190=m\nCONFIG_SFC=m\nCONFIG_PCMCIA_SMC91C92=m\nCONFIG_EPIC100=m\nCONFIG_HAPPYMEAL=m\nCONFIG_SUNGEM=m\nCONFIG_CASSINI=m\nCONFIG_NIU=m\nCONFIG_TEHUTI=m\nCONFIG_TLAN=m\nCONFIG_VIA_RHINE=m\nCONFIG_VIA_RHINE_MMIO=y\nCONFIG_VIA_VELOCITY=m\nCONFIG_PCMCIA_XIRC2PS=m\nCONFIG_FDDI=y\nCONFIG_SKFP=m\nCONFIG_NET_SB1000=m\nCONFIG_BROADCOM_PHY=m\nCONFIG_CICADA_PHY=m\nCONFIG_DAVICOM_PHY=m\nCONFIG_ICPLUS_PHY=m\nCONFIG_LXT_PHY=m\nCONFIG_MARVELL_PHY=m\nCONFIG_QSEMI_PHY=m\nCONFIG_REALTEK_PHY=m\nCONFIG_SMSC_PHY=m\nCONFIG_VITESSE_PHY=m\nCONFIG_PLIP=m\nCONFIG_PPP_DEFLATE=m\nCONFIG_PPP_FILTER=y\nCONFIG_PPP_MPPE=m\nCONFIG_PPP_MULTILINK=y\nCONFIG_PPPOATM=m\nCONFIG_PPPOE=m\nCONFIG_PPP_ASYNC=m\nCONFIG_PPP_SYNC_TTY=m\nCONFIG_SLIP=m\nCONFIG_SLIP_COMPRESSED=y\nCONFIG_SLIP_SMART=y\nCONFIG_USB_CATC=m\nCONFIG_USB_KAWETH=m\nCONFIG_USB_PEGASUS=m\nCONFIG_USB_RTL8150=m\nCONFIG_USB_USBNET=m\nCONFIG_USB_NET_DM9601=m\nCONFIG_USB_NET_SMSC95XX=m\nCONFIG_USB_NET_GL620A=m\nCONFIG_USB_NET_PLUSB=m\nCONFIG_USB_NET_MCS7830=m\nCONFIG_USB_NET_RNDIS_HOST=m\nCONFIG_USB_ALI_M5632=y\nCONFIG_USB_AN2720=y\nCONFIG_USB_EPSON2888=y\nCONFIG_USB_KC2190=y\nCONFIG_INPUT_JOYDEV=m\nCONFIG_INPUT_EVDEV=y\nCONFIG_MOUSE_SERIAL=m\nCONFIG_MOUSE_APPLETOUCH=m\nCONFIG_MOUSE_VSXXXAA=m\nCONFIG_INPUT_JOYSTICK=y\nCONFIG_JOYSTICK_ANALOG=m\nCONFIG_JOYSTICK_A3D=m\nCONFIG_JOYSTICK_ADI=m\nCONFIG_JOYSTICK_COBRA=m\nCONFIG_JOYSTICK_GF2K=m\nCONFIG_JOYSTICK_GRIP=m\nCONFIG_JOYSTICK_GRIP_MP=m\nCONFIG_JOYSTICK_GUILLEMOT=m\nCONFIG_JOYSTICK_INTERACT=m\nCONFIG_JOYSTICK_SIDEWINDER=m\nCONFIG_JOYSTICK_TMDC=m\nCONFIG_JOYSTICK_IFORCE=m\nCONFIG_JOYSTICK_IFORCE_USB=y\nCONFIG_JOYSTICK_IFORCE_232=y\nCONFIG_JOYSTICK_WARRIOR=m\nCONFIG_JOYSTICK_MAGELLAN=m\nCONFIG_JOYSTICK_SPACEORB=m\nCONFIG_JOYSTICK_SPACEBALL=m\nCONFIG_JOYSTICK_STINGER=m\nCONFIG_JOYSTICK_TWIDJOY=m\nCONFIG_JOYSTICK_ZHENHUA=m\nCONFIG_JOYSTICK_DB9=m\nCONFIG_JOYSTICK_GAMECON=m\nCONFIG_JOYSTICK_TURBOGRAFX=m\nCONFIG_JOYSTICK_JOYDUMP=m\nCONFIG_JOYSTICK_XPAD=m\nCONFIG_JOYSTICK_XPAD_FF=y\nCONFIG_JOYSTICK_XPAD_LEDS=y\nCONFIG_INPUT_TABLET=y\nCONFIG_TABLET_USB_ACECAD=m\nCONFIG_TABLET_USB_AIPTEK=m\nCONFIG_TABLET_USB_GTCO=m\nCONFIG_TABLET_USB_KBTAB=m\nCONFIG_INPUT_MISC=y\nCONFIG_INPUT_PCSPKR=m\nCONFIG_INPUT_ATI_REMOTE2=m\nCONFIG_INPUT_KEYSPAN_REMOTE=m\nCONFIG_INPUT_POWERMATE=m\nCONFIG_INPUT_YEALINK=m\nCONFIG_INPUT_CM109=m\nCONFIG_INPUT_UINPUT=m\nCONFIG_SERIO_RAW=m\nCONFIG_GAMEPORT_NS558=m\nCONFIG_GAMEPORT_L4=m\nCONFIG_GAMEPORT_EMU10K1=m\nCONFIG_GAMEPORT_FM801=m\n# CONFIG_LEGACY_PTYS is not set\nCONFIG_SERIAL_NONSTANDARD=y\nCONFIG_ROCKETPORT=m\nCONFIG_CYCLADES=m\nCONFIG_SYNCLINK=m\nCONFIG_SYNCLINKMP=m\nCONFIG_SYNCLINK_GT=m\nCONFIG_NOZOMI=m\nCONFIG_N_HDLC=m\nCONFIG_SERIAL_8250=y\nCONFIG_SERIAL_8250_CONSOLE=y\nCONFIG_SERIAL_8250_CS=m\nCONFIG_SERIAL_8250_NR_UARTS=32\nCONFIG_SERIAL_8250_EXTENDED=y\nCONFIG_SERIAL_8250_MANY_PORTS=y\nCONFIG_SERIAL_8250_SHARE_IRQ=y\nCONFIG_SERIAL_8250_DETECT_IRQ=y\nCONFIG_SERIAL_8250_RSA=y\nCONFIG_SERIAL_OF_PLATFORM=y\nCONFIG_SERIAL_UARTLITE=m\nCONFIG_SERIAL_PMACZILOG=m\nCONFIG_SERIAL_MPC52xx=y\nCONFIG_SERIAL_MPC52xx_CONSOLE=y\nCONFIG_SERIAL_MPC52xx_CONSOLE_BAUD=115200\nCONFIG_SERIAL_JSM=m\nCONFIG_PRINTER=m\nCONFIG_LP_CONSOLE=y\nCONFIG_PPDEV=m\nCONFIG_HW_RANDOM=y\nCONFIG_HW_RANDOM_VIRTIO=m\nCONFIG_NVRAM=y\nCONFIG_DTLK=m\nCONFIG_R3964=m\nCONFIG_CARDMAN_4000=m\nCONFIG_CARDMAN_4040=m\nCONFIG_IPWIRELESS=m\nCONFIG_I2C_CHARDEV=m\nCONFIG_I2C_HYDRA=m\nCONFIG_I2C_MPC=m\nCONFIG_I2C_PCA_PLATFORM=m\nCONFIG_I2C_SIMTEC=m\nCONFIG_I2C_PARPORT=m\nCONFIG_I2C_TINY_USB=m\nCONFIG_I2C_PCA_ISA=m\nCONFIG_I2C_STUB=m\nCONFIG_GPIO_SYSFS=y\nCONFIG_GPIO_MPC8XXX=y\nCONFIG_W1=m\nCONFIG_W1_MASTER_DS2490=m\nCONFIG_W1_MASTER_DS2482=m\nCONFIG_W1_SLAVE_THERM=m\nCONFIG_W1_SLAVE_SMEM=m\nCONFIG_W1_SLAVE_DS2433=m\nCONFIG_W1_SLAVE_DS2433_CRC=y\nCONFIG_APM_POWER=m\nCONFIG_BATTERY_PMU=m\nCONFIG_HWMON=m\nCONFIG_SENSORS_AD7418=m\nCONFIG_SENSORS_ADM1021=m\nCONFIG_SENSORS_ADM1025=m\nCONFIG_SENSORS_ADM1026=m\nCONFIG_SENSORS_ADM1029=m\nCONFIG_SENSORS_ADM1031=m\nCONFIG_SENSORS_ADM9240=m\nCONFIG_SENSORS_ADT7470=m\nCONFIG_SENSORS_ATXP1=m\nCONFIG_SENSORS_DS1621=m\nCONFIG_SENSORS_F75375S=m\nCONFIG_SENSORS_GL518SM=m\nCONFIG_SENSORS_GL520SM=m\nCONFIG_SENSORS_MAX1619=m\nCONFIG_SENSORS_MAX6650=m\nCONFIG_SENSORS_LM63=m\nCONFIG_SENSORS_LM75=m\nCONFIG_SENSORS_LM77=m\nCONFIG_SENSORS_LM78=m\nCONFIG_SENSORS_LM80=m\nCONFIG_SENSORS_LM83=m\nCONFIG_SENSORS_LM85=m\nCONFIG_SENSORS_LM87=m\nCONFIG_SENSORS_LM90=m\nCONFIG_SENSORS_LM92=m\nCONFIG_SENSORS_LM93=m\nCONFIG_SENSORS_PCF8591=m\nCONFIG_SENSORS_SIS5595=m\nCONFIG_SENSORS_SMSC47M192=m\nCONFIG_SENSORS_ADS7828=m\nCONFIG_SENSORS_THMC50=m\nCONFIG_SENSORS_VIA686A=m\nCONFIG_SENSORS_VT8231=m\nCONFIG_SENSORS_W83781D=m\nCONFIG_SENSORS_W83791D=m\nCONFIG_SENSORS_W83792D=m\nCONFIG_SENSORS_W83793=m\nCONFIG_SENSORS_W83L785TS=m\nCONFIG_SENSORS_W83L786NG=m\nCONFIG_THERMAL=y\nCONFIG_WATCHDOG=y\nCONFIG_SOFT_WATCHDOG=m\nCONFIG_WATCHDOG_RTAS=m\nCONFIG_USBPCWATCHDOG=m\nCONFIG_SSB_PCMCIAHOST=y\nCONFIG_MFD_SM501=m\nCONFIG_MFD_SM501_GPIO=y\nCONFIG_AGP=y\nCONFIG_AGP_UNINORTH=y\nCONFIG_DRM=m\nCONFIG_DRM_RADEON=m\nCONFIG_DRM_LEGACY=y\nCONFIG_DRM_TDFX=m\nCONFIG_DRM_R128=m\nCONFIG_DRM_MGA=m\nCONFIG_DRM_SIS=m\nCONFIG_DRM_VIA=m\nCONFIG_DRM_SAVAGE=m\nCONFIG_FB=y\nCONFIG_FB_CIRRUS=m\nCONFIG_FB_OF=y\nCONFIG_FB_PLATINUM=y\nCONFIG_FB_VALKYRIE=y\nCONFIG_FB_CT65550=y\nCONFIG_FB_NVIDIA=y\nCONFIG_FB_NVIDIA_I2C=y\nCONFIG_FB_RIVA=m\nCONFIG_FB_MATROX=y\nCONFIG_FB_MATROX_MILLENIUM=y\nCONFIG_FB_MATROX_MYSTIQUE=y\nCONFIG_FB_MATROX_G=y\nCONFIG_FB_MATROX_I2C=m\nCONFIG_FB_MATROX_MAVEN=m\nCONFIG_FB_RADEON=y\nCONFIG_FB_ATY128=y\nCONFIG_FB_ATY=y\nCONFIG_FB_ATY_CT=y\nCONFIG_FB_ATY_GENERIC_LCD=y\nCONFIG_FB_ATY_GX=y\nCONFIG_FB_S3=m\nCONFIG_FB_SAVAGE=m\nCONFIG_FB_SAVAGE_I2C=y\nCONFIG_FB_SAVAGE_ACCEL=y\nCONFIG_FB_NEOMAGIC=m\nCONFIG_FB_KYRO=m\nCONFIG_FB_3DFX=m\nCONFIG_FB_3DFX_ACCEL=y\nCONFIG_FB_VOODOO1=m\nCONFIG_FB_TRIDENT=m\nCONFIG_FB_SM501=m\nCONFIG_FB_IBM_GXT4500=y\nCONFIG_LCD_PLATFORM=m\nCONFIG_VGACON_SOFT_SCROLLBACK=y\nCONFIG_FRAMEBUFFER_CONSOLE=y\nCONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y\nCONFIG_LOGO=y\n# CONFIG_LOGO_LINUX_MONO is not set\n# CONFIG_LOGO_LINUX_VGA16 is not set\nCONFIG_SOUND=m\nCONFIG_SND=m\nCONFIG_SND_OSSEMUL=y\nCONFIG_SND_MIXER_OSS=m\nCONFIG_SND_PCM_OSS=m\nCONFIG_SND_DYNAMIC_MINORS=y\n# CONFIG_SND_SUPPORT_OLD_API is not set\nCONFIG_SND_VERBOSE_PRINTK=y\nCONFIG_SND_DEBUG=y\nCONFIG_SND_DEBUG_VERBOSE=y\nCONFIG_SND_PCM_XRUN_DEBUG=y\nCONFIG_SND_SEQUENCER=m\nCONFIG_SND_SEQ_DUMMY=m\nCONFIG_SND_SEQUENCER_OSS=m\nCONFIG_SND_DUMMY=m\nCONFIG_SND_VIRMIDI=m\nCONFIG_SND_MTPAV=m\nCONFIG_SND_MTS64=m\nCONFIG_SND_SERIAL_U16550=m\nCONFIG_SND_MPU401=m\nCONFIG_SND_PORTMAN2X4=m\nCONFIG_SND_AC97_POWER_SAVE=y\nCONFIG_SND_AC97_POWER_SAVE_DEFAULT=5\nCONFIG_SND_AD1889=m\nCONFIG_SND_ALS300=m\nCONFIG_SND_ALS4000=m\nCONFIG_SND_ALI5451=m\nCONFIG_SND_ATIIXP=m\nCONFIG_SND_ATIIXP_MODEM=m\nCONFIG_SND_AU8810=m\nCONFIG_SND_AU8820=m\nCONFIG_SND_AU8830=m\nCONFIG_SND_AW2=m\nCONFIG_SND_AZT3328=m\nCONFIG_SND_BT87X=m\nCONFIG_SND_CA0106=m\nCONFIG_SND_CMIPCI=m\nCONFIG_SND_OXYGEN=m\nCONFIG_SND_CS4281=m\nCONFIG_SND_CS46XX=m\nCONFIG_SND_DARLA20=m\nCONFIG_SND_GINA20=m\nCONFIG_SND_LAYLA20=m\nCONFIG_SND_DARLA24=m\nCONFIG_SND_GINA24=m\nCONFIG_SND_LAYLA24=m\nCONFIG_SND_MONA=m\nCONFIG_SND_MIA=m\nCONFIG_SND_ECHO3G=m\nCONFIG_SND_INDIGO=m\nCONFIG_SND_INDIGOIO=m\nCONFIG_SND_INDIGODJ=m\nCONFIG_SND_EMU10K1=m\nCONFIG_SND_EMU10K1X=m\nCONFIG_SND_ENS1370=m\nCONFIG_SND_ENS1371=m\nCONFIG_SND_ES1938=m\nCONFIG_SND_ES1968=m\nCONFIG_SND_FM801=m\nCONFIG_SND_HDSP=m\nCONFIG_SND_HDSPM=m\nCONFIG_SND_ICE1712=m\nCONFIG_SND_ICE1724=m\nCONFIG_SND_KORG1212=m\nCONFIG_SND_MAESTRO3=m\nCONFIG_SND_MIXART=m\nCONFIG_SND_NM256=m\nCONFIG_SND_PCXHR=m\nCONFIG_SND_RIPTIDE=m\nCONFIG_SND_RME32=m\nCONFIG_SND_RME96=m\nCONFIG_SND_RME9652=m\nCONFIG_SND_SONICVIBES=m\nCONFIG_SND_TRIDENT=m\nCONFIG_SND_VIA82XX=m\nCONFIG_SND_VIA82XX_MODEM=m\nCONFIG_SND_VIRTUOSO=m\nCONFIG_SND_VX222=m\nCONFIG_SND_POWERMAC=m\nCONFIG_SND_AOA=m\nCONFIG_SND_AOA_FABRIC_LAYOUT=m\nCONFIG_SND_AOA_ONYX=m\nCONFIG_SND_AOA_TAS=m\nCONFIG_SND_AOA_TOONIE=m\nCONFIG_SND_USB_AUDIO=m\nCONFIG_SND_USB_USX2Y=m\nCONFIG_SND_USB_CAIAQ=m\nCONFIG_SND_USB_CAIAQ_INPUT=y\n# CONFIG_SND_PCMCIA is not set\nCONFIG_HIDRAW=y\nCONFIG_HID_GYRATION=y\nCONFIG_LOGITECH_FF=y\nCONFIG_LOGIRUMBLEPAD2_FF=y\nCONFIG_HID_PANTHERLORD=y\nCONFIG_PANTHERLORD_FF=y\nCONFIG_HID_PETALYNX=y\nCONFIG_HID_SAMSUNG=y\nCONFIG_HID_SONY=y\nCONFIG_HID_SUNPLUS=y\nCONFIG_HID_PID=y\nCONFIG_USB_HIDDEV=y\nCONFIG_USB=y\nCONFIG_USB_ANNOUNCE_NEW_DEVICES=y\nCONFIG_USB_MON=y\nCONFIG_USB_EHCI_HCD=m\nCONFIG_USB_EHCI_FSL=m\nCONFIG_USB_OHCI_HCD=m\nCONFIG_USB_OHCI_HCD_PPC_OF_BE=y\nCONFIG_USB_OHCI_HCD_PPC_OF_LE=y\nCONFIG_USB_UHCI_HCD=m\nCONFIG_USB_U132_HCD=m\nCONFIG_USB_SL811_HCD=m\nCONFIG_USB_ACM=m\nCONFIG_USB_PRINTER=m\nCONFIG_USB_WDM=m\nCONFIG_USB_STORAGE=m\nCONFIG_USB_STORAGE_DATAFAB=m\nCONFIG_USB_STORAGE_FREECOM=m\nCONFIG_USB_STORAGE_USBAT=m\nCONFIG_USB_STORAGE_SDDR09=m\nCONFIG_USB_STORAGE_SDDR55=m\nCONFIG_USB_STORAGE_JUMPSHOT=m\nCONFIG_USB_STORAGE_ALAUDA=m\nCONFIG_USB_STORAGE_ONETOUCH=m\nCONFIG_USB_STORAGE_KARMA=m\nCONFIG_USB_STORAGE_CYPRESS_ATACB=m\nCONFIG_USB_MDC800=m\nCONFIG_USB_MICROTEK=m\nCONFIG_USB_USS720=m\nCONFIG_USB_SERIAL=m\nCONFIG_USB_SERIAL_GENERIC=y\nCONFIG_USB_SERIAL_AIRCABLE=m\nCONFIG_USB_SERIAL_ARK3116=m\nCONFIG_USB_SERIAL_BELKIN=m\nCONFIG_USB_SERIAL_CH341=m\nCONFIG_USB_SERIAL_WHITEHEAT=m\nCONFIG_USB_SERIAL_DIGI_ACCELEPORT=m\nCONFIG_USB_SERIAL_CYPRESS_M8=m\nCONFIG_USB_SERIAL_EMPEG=m\nCONFIG_USB_SERIAL_FTDI_SIO=m\nCONFIG_USB_SERIAL_VISOR=m\nCONFIG_USB_SERIAL_IPAQ=m\nCONFIG_USB_SERIAL_IR=m\nCONFIG_USB_SERIAL_EDGEPORT=m\nCONFIG_USB_SERIAL_EDGEPORT_TI=m\nCONFIG_USB_SERIAL_IPW=m\nCONFIG_USB_SERIAL_IUU=m\nCONFIG_USB_SERIAL_KEYSPAN_PDA=m\nCONFIG_USB_SERIAL_KEYSPAN=m\nCONFIG_USB_SERIAL_KLSI=m\nCONFIG_USB_SERIAL_KOBIL_SCT=m\nCONFIG_USB_SERIAL_MCT_U232=m\nCONFIG_USB_SERIAL_MOS7720=m\nCONFIG_USB_SERIAL_MOS7840=m\nCONFIG_USB_SERIAL_NAVMAN=m\nCONFIG_USB_SERIAL_PL2303=m\nCONFIG_USB_SERIAL_OTI6858=m\nCONFIG_USB_SERIAL_SPCP8X5=m\nCONFIG_USB_SERIAL_SAFE=m\nCONFIG_USB_SERIAL_SAFE_PADDED=y\nCONFIG_USB_SERIAL_SIERRAWIRELESS=m\nCONFIG_USB_SERIAL_TI=m\nCONFIG_USB_SERIAL_CYBERJACK=m\nCONFIG_USB_SERIAL_XIRCOM=m\nCONFIG_USB_SERIAL_OPTION=m\nCONFIG_USB_SERIAL_OMNINET=m\nCONFIG_USB_SERIAL_DEBUG=m\nCONFIG_USB_EMI62=m\nCONFIG_USB_EMI26=m\nCONFIG_USB_ADUTUX=m\nCONFIG_USB_SEVSEG=m\nCONFIG_USB_LEGOTOWER=m\nCONFIG_USB_LCD=m\nCONFIG_USB_IDMOUSE=m\nCONFIG_USB_FTDI_ELAN=m\nCONFIG_USB_APPLEDISPLAY=m\nCONFIG_USB_SISUSBVGA=m\nCONFIG_USB_SISUSBVGA_CON=y\nCONFIG_USB_LD=m\nCONFIG_USB_TRANCEVIBRATOR=m\nCONFIG_USB_IOWARRIOR=m\nCONFIG_USB_ISIGHTFW=m\nCONFIG_USB_ATM=m\nCONFIG_USB_SPEEDTOUCH=m\nCONFIG_USB_CXACRU=m\nCONFIG_USB_UEAGLEATM=m\nCONFIG_USB_XUSBATM=m\nCONFIG_LEDS_TRIGGER_TIMER=m\nCONFIG_LEDS_TRIGGER_HEARTBEAT=m\nCONFIG_LEDS_TRIGGER_BACKLIGHT=m\nCONFIG_LEDS_TRIGGER_DEFAULT_ON=m\nCONFIG_ACCESSIBILITY=y\nCONFIG_A11Y_BRAILLE_CONSOLE=y\nCONFIG_EDAC=m\nCONFIG_RTC_CLASS=y\n# CONFIG_RTC_HCTOSYS is not set\nCONFIG_RTC_DRV_DS1307=m\nCONFIG_RTC_DRV_DS1374=m\nCONFIG_RTC_DRV_DS1672=m\nCONFIG_RTC_DRV_MAX6900=m\nCONFIG_RTC_DRV_RS5C372=m\nCONFIG_RTC_DRV_ISL1208=m\nCONFIG_RTC_DRV_X1205=m\nCONFIG_RTC_DRV_PCF8563=m\nCONFIG_RTC_DRV_PCF8583=m\nCONFIG_RTC_DRV_M41T80=m\nCONFIG_RTC_DRV_M41T80_WDT=y\nCONFIG_RTC_DRV_FM3130=m\nCONFIG_RTC_DRV_CMOS=y\nCONFIG_RTC_DRV_DS1511=m\nCONFIG_RTC_DRV_DS1553=m\nCONFIG_RTC_DRV_DS1742=m\nCONFIG_RTC_DRV_STK17TA8=m\nCONFIG_RTC_DRV_M48T35=m\nCONFIG_RTC_DRV_M48T59=m\nCONFIG_RTC_DRV_V3020=m\nCONFIG_DMADEVICES=y\nCONFIG_PPC_BESTCOMM=y\nCONFIG_AUXDISPLAY=y\nCONFIG_KS0108=m\nCONFIG_UIO=m\nCONFIG_UIO_CIF=m\nCONFIG_UIO_PDRV_GENIRQ=m\nCONFIG_VIRTIO_PCI=m\nCONFIG_VIRTIO_BALLOON=m\nCONFIG_QUICC_ENGINE=y\nCONFIG_EXT2_FS=m\nCONFIG_EXT2_FS_XATTR=y\nCONFIG_EXT2_FS_POSIX_ACL=y\nCONFIG_EXT2_FS_SECURITY=y\nCONFIG_EXT4_FS=y\nCONFIG_EXT4_FS_POSIX_ACL=y\nCONFIG_EXT4_FS_SECURITY=y\nCONFIG_JBD2_DEBUG=y\nCONFIG_REISERFS_FS=m\nCONFIG_REISERFS_PROC_INFO=y\nCONFIG_REISERFS_FS_XATTR=y\nCONFIG_REISERFS_FS_POSIX_ACL=y\nCONFIG_REISERFS_FS_SECURITY=y\nCONFIG_JFS_FS=m\nCONFIG_JFS_POSIX_ACL=y\nCONFIG_JFS_SECURITY=y\nCONFIG_XFS_FS=m\nCONFIG_XFS_QUOTA=y\nCONFIG_XFS_POSIX_ACL=y\nCONFIG_GFS2_FS=m\nCONFIG_FS_DAX=y\nCONFIG_QUOTA_NETLINK_INTERFACE=y\nCONFIG_AUTOFS4_FS=m\nCONFIG_FUSE_FS=m\nCONFIG_ISO9660_FS=y\nCONFIG_JOLIET=y\nCONFIG_ZISOFS=y\nCONFIG_UDF_FS=m\nCONFIG_MSDOS_FS=m\nCONFIG_VFAT_FS=m\nCONFIG_FAT_DEFAULT_IOCHARSET=\"ascii\"\nCONFIG_PROC_KCORE=y\nCONFIG_TMPFS=y\nCONFIG_TMPFS_POSIX_ACL=y\nCONFIG_AFFS_FS=m\nCONFIG_ECRYPT_FS=m\nCONFIG_HFS_FS=m\nCONFIG_HFSPLUS_FS=m\nCONFIG_BEFS_FS=m\nCONFIG_BFS_FS=m\nCONFIG_EFS_FS=m\nCONFIG_CRAMFS=m\nCONFIG_VXFS_FS=m\nCONFIG_MINIX_FS=m\nCONFIG_OMFS_FS=m\nCONFIG_QNX4FS_FS=m\nCONFIG_ROMFS_FS=m\nCONFIG_SYSV_FS=m\nCONFIG_UFS_FS=m\nCONFIG_NFS_FS=m\nCONFIG_NFS_V3_ACL=y\nCONFIG_NFS_V4=m\nCONFIG_NFSD=m\nCONFIG_NFSD_V3_ACL=y\nCONFIG_NFSD_V4=y\nCONFIG_CIFS=m\nCONFIG_CIFS_WEAK_PW_HASH=y\nCONFIG_CIFS_UPCALL=y\nCONFIG_CIFS_XATTR=y\nCONFIG_CIFS_POSIX=y\nCONFIG_CIFS_DFS_UPCALL=y\nCONFIG_CODA_FS=m\nCONFIG_9P_FS=m\nCONFIG_NLS_DEFAULT=\"utf8\"\nCONFIG_NLS_CODEPAGE_437=y\nCONFIG_NLS_CODEPAGE_737=m\nCONFIG_NLS_CODEPAGE_775=m\nCONFIG_NLS_CODEPAGE_850=m\nCONFIG_NLS_CODEPAGE_852=m\nCONFIG_NLS_CODEPAGE_855=m\nCONFIG_NLS_CODEPAGE_857=m\nCONFIG_NLS_CODEPAGE_860=m\nCONFIG_NLS_CODEPAGE_861=m\nCONFIG_NLS_CODEPAGE_862=m\nCONFIG_NLS_CODEPAGE_863=m\nCONFIG_NLS_CODEPAGE_864=m\nCONFIG_NLS_CODEPAGE_865=m\nCONFIG_NLS_CODEPAGE_866=m\nCONFIG_NLS_CODEPAGE_869=m\nCONFIG_NLS_CODEPAGE_936=m\nCONFIG_NLS_CODEPAGE_950=m\nCONFIG_NLS_CODEPAGE_932=m\nCONFIG_NLS_CODEPAGE_949=m\nCONFIG_NLS_CODEPAGE_874=m\nCONFIG_NLS_ISO8859_8=m\nCONFIG_NLS_CODEPAGE_1250=m\nCONFIG_NLS_CODEPAGE_1251=m\nCONFIG_NLS_ASCII=y\nCONFIG_NLS_ISO8859_1=m\nCONFIG_NLS_ISO8859_2=m\nCONFIG_NLS_ISO8859_3=m\nCONFIG_NLS_ISO8859_4=m\nCONFIG_NLS_ISO8859_5=m\nCONFIG_NLS_ISO8859_6=m\nCONFIG_NLS_ISO8859_7=m\nCONFIG_NLS_ISO8859_9=m\nCONFIG_NLS_ISO8859_13=m\nCONFIG_NLS_ISO8859_14=m\nCONFIG_NLS_ISO8859_15=m\nCONFIG_NLS_KOI8_R=m\nCONFIG_NLS_KOI8_U=m\nCONFIG_DEBUG_INFO=y\nCONFIG_UNUSED_SYMBOLS=y\nCONFIG_HEADERS_INSTALL=y\nCONFIG_MAGIC_SYSRQ=y\nCONFIG_DEBUG_KERNEL=y\nCONFIG_DEBUG_OBJECTS=y\nCONFIG_DEBUG_OBJECTS_FREE=y\nCONFIG_DEBUG_OBJECTS_TIMERS=y\nCONFIG_SLUB_DEBUG_ON=y\nCONFIG_DEBUG_STACK_USAGE=y\nCONFIG_DEBUG_VM=y\nCONFIG_DEBUG_HIGHMEM=y\nCONFIG_DEBUG_STACKOVERFLOW=y\nCONFIG_DEBUG_SHIRQ=y\nCONFIG_DEBUG_RT_MUTEXES=y\nCONFIG_DEBUG_SPINLOCK=y\nCONFIG_DEBUG_MUTEXES=y\nCONFIG_DEBUG_LIST=y\nCONFIG_DEBUG_SG=y\nCONFIG_FAULT_INJECTION=y\nCONFIG_FAILSLAB=y\nCONFIG_FAIL_PAGE_ALLOC=y\nCONFIG_FAIL_MAKE_REQUEST=y\nCONFIG_FAIL_IO_TIMEOUT=y\nCONFIG_FAULT_INJECTION_DEBUG_FS=y\nCONFIG_FAULT_INJECTION_STACKTRACE_FILTER=y\nCONFIG_SCHED_TRACER=y\nCONFIG_STACK_TRACER=y\nCONFIG_BLK_DEV_IO_TRACE=y\nCONFIG_XMON=y\nCONFIG_BOOTX_TEXT=y\nCONFIG_SECURITY=y\nCONFIG_SECURITY_NETWORK=y\nCONFIG_SECURITY_NETWORK_XFRM=y\nCONFIG_SECURITY_SELINUX=y\nCONFIG_SECURITY_SELINUX_BOOTPARAM=y\nCONFIG_SECURITY_SELINUX_DISABLE=y\nCONFIG_CRYPTO_TEST=m\nCONFIG_CRYPTO_CTS=m\nCONFIG_CRYPTO_LRW=m\nCONFIG_CRYPTO_PCBC=m\nCONFIG_CRYPTO_XTS=m\nCONFIG_CRYPTO_HMAC=y\nCONFIG_CRYPTO_XCBC=m\nCONFIG_CRYPTO_MICHAEL_MIC=m\nCONFIG_CRYPTO_RMD128=m\nCONFIG_CRYPTO_RMD160=m\nCONFIG_CRYPTO_RMD256=m\nCONFIG_CRYPTO_RMD320=m\nCONFIG_CRYPTO_SHA1=y\nCONFIG_CRYPTO_SHA512=m\nCONFIG_CRYPTO_TGR192=m\nCONFIG_CRYPTO_WP512=m\nCONFIG_CRYPTO_ANUBIS=m\nCONFIG_CRYPTO_BLOWFISH=m\nCONFIG_CRYPTO_CAMELLIA=m\nCONFIG_CRYPTO_CAST6=m\nCONFIG_CRYPTO_FCRYPT=m\nCONFIG_CRYPTO_KHAZAD=m\nCONFIG_CRYPTO_SALSA20=m\nCONFIG_CRYPTO_SEED=m\nCONFIG_CRYPTO_SERPENT=m\nCONFIG_CRYPTO_TEA=m\nCONFIG_CRYPTO_TWOFISH=m\nCONFIG_CRYPTO_LZO=m\nCONFIG_CRYPTO_DEV_HIFN_795X=m\nCONFIG_CRYPTO_DEV_HIFN_795X_RNG=y\nCONFIG_CRYPTO_DEV_TALITOS=m\nCONFIG_VIRTUALIZATION=y\n", "# CONFIG_LOCALVERSION_AUTO is not set\nCONFIG_SYSVIPC=y\nCONFIG_POSIX_MQUEUE=y\nCONFIG_AUDIT=y\nCONFIG_NO_HZ=y\nCONFIG_HIGH_RES_TIMERS=y\nCONFIG_PREEMPT_VOLUNTARY=y\nCONFIG_BSD_PROCESS_ACCT=y\nCONFIG_TASKSTATS=y\nCONFIG_TASK_DELAY_ACCT=y\nCONFIG_TASK_XACCT=y\nCONFIG_TASK_IO_ACCOUNTING=y\nCONFIG_LOG_BUF_SHIFT=18\nCONFIG_CGROUPS=y\nCONFIG_CGROUP_SCHED=y\nCONFIG_CGROUP_FREEZER=y\nCONFIG_CPUSETS=y\nCONFIG_CGROUP_CPUACCT=y\nCONFIG_BLK_DEV_INITRD=y\n# CONFIG_COMPAT_BRK is not set\nCONFIG_PROFILING=y\nCONFIG_SMP=y\nCONFIG_X86_GENERIC=y\nCONFIG_HPET_TIMER=y\nCONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y\nCONFIG_X86_REBOOTFIXUPS=y\nCONFIG_MICROCODE_AMD=y\nCONFIG_X86_MSR=y\nCONFIG_X86_CPUID=y\nCONFIG_HIGHPTE=y\nCONFIG_X86_CHECK_BIOS_CORRUPTION=y\n# CONFIG_MTRR_SANITIZER is not set\nCONFIG_EFI=y\nCONFIG_EFI_STUB=y\nCONFIG_HZ_1000=y\nCONFIG_KEXEC=y\nCONFIG_CRASH_DUMP=y\nCONFIG_HIBERNATION=y\nCONFIG_PM_DEBUG=y\nCONFIG_PM_TRACE_RTC=y\nCONFIG_ACPI_DOCK=y\nCONFIG_ACPI_BGRT=y\nCONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y\nCONFIG_CPU_FREQ_GOV_ONDEMAND=y\nCONFIG_X86_ACPI_CPUFREQ=y\nCONFIG_EFI_VARS=y\nCONFIG_KPROBES=y\nCONFIG_JUMP_LABEL=y\nCONFIG_MODULES=y\nCONFIG_MODULE_UNLOAD=y\nCONFIG_MODULE_FORCE_UNLOAD=y\n# CONFIG_UNUSED_SYMBOLS is not set\nCONFIG_BINFMT_MISC=y\nCONFIG_NET=y\nCONFIG_PACKET=y\nCONFIG_UNIX=y\nCONFIG_XFRM_USER=y\nCONFIG_INET=y\nCONFIG_IP_MULTICAST=y\nCONFIG_IP_ADVANCED_ROUTER=y\nCONFIG_IP_MULTIPLE_TABLES=y\nCONFIG_IP_ROUTE_MULTIPATH=y\nCONFIG_IP_ROUTE_VERBOSE=y\nCONFIG_IP_PNP=y\nCONFIG_IP_PNP_DHCP=y\nCONFIG_IP_PNP_BOOTP=y\nCONFIG_IP_PNP_RARP=y\nCONFIG_IP_MROUTE=y\nCONFIG_IP_PIMSM_V1=y\nCONFIG_IP_PIMSM_V2=y\nCONFIG_SYN_COOKIES=y\n# CONFIG_INET_DIAG is not set\nCONFIG_TCP_CONG_ADVANCED=y\n# CONFIG_TCP_CONG_BIC is not set\n# CONFIG_TCP_CONG_WESTWOOD is not set\n# CONFIG_TCP_CONG_HTCP is not set\nCONFIG_TCP_MD5SIG=y\nCONFIG_INET6_AH=y\nCONFIG_INET6_ESP=y\nCONFIG_NETLABEL=y\nCONFIG_NETFILTER=y\n# CONFIG_NETFILTER_ADVANCED is not set\nCONFIG_NF_CONNTRACK=y\nCONFIG_NF_CONNTRACK_FTP=y\nCONFIG_NF_CONNTRACK_IRC=y\nCONFIG_NF_CONNTRACK_SIP=y\nCONFIG_NF_CT_NETLINK=y\nCONFIG_NF_NAT=y\nCONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y\nCONFIG_NETFILTER_XT_TARGET_NFLOG=y\nCONFIG_NETFILTER_XT_TARGET_SECMARK=y\nCONFIG_NETFILTER_XT_TARGET_TCPMSS=y\nCONFIG_NETFILTER_XT_MATCH_CONNTRACK=y\nCONFIG_NETFILTER_XT_MATCH_POLICY=y\nCONFIG_NETFILTER_XT_MATCH_STATE=y\nCONFIG_IP_NF_IPTABLES=y\nCONFIG_IP_NF_FILTER=y\nCONFIG_IP_NF_TARGET_REJECT=y\nCONFIG_IP_NF_TARGET_MASQUERADE=m\nCONFIG_IP_NF_MANGLE=y\nCONFIG_IP6_NF_IPTABLES=y\nCONFIG_IP6_NF_MATCH_IPV6HEADER=y\nCONFIG_IP6_NF_FILTER=y\nCONFIG_IP6_NF_TARGET_REJECT=y\nCONFIG_IP6_NF_MANGLE=y\nCONFIG_NET_SCHED=y\nCONFIG_NET_EMATCH=y\nCONFIG_NET_CLS_ACT=y\nCONFIG_CFG80211=y\nCONFIG_MAC80211=y\nCONFIG_MAC80211_LEDS=y\nCONFIG_RFKILL=y\nCONFIG_PCI=y\nCONFIG_PCIEPORTBUS=y\nCONFIG_PCI_MSI=y\nCONFIG_HOTPLUG_PCI=y\nCONFIG_PCCARD=y\nCONFIG_YENTA=y\nCONFIG_DEVTMPFS=y\nCONFIG_DEVTMPFS_MOUNT=y\nCONFIG_DEBUG_DEVRES=y\nCONFIG_CONNECTOR=y\nCONFIG_BLK_DEV_LOOP=y\nCONFIG_BLK_DEV_SD=y\nCONFIG_BLK_DEV_SR=y\nCONFIG_CHR_DEV_SG=y\nCONFIG_SCSI_CONSTANTS=y\nCONFIG_SCSI_SPI_ATTRS=y\n# CONFIG_SCSI_LOWLEVEL is not set\nCONFIG_ATA=y\nCONFIG_SATA_AHCI=y\nCONFIG_ATA_PIIX=y\nCONFIG_PATA_AMD=y\nCONFIG_PATA_OLDPIIX=y\nCONFIG_PATA_SCH=y\nCONFIG_PATA_MPIIX=y\nCONFIG_ATA_GENERIC=y\nCONFIG_MD=y\nCONFIG_BLK_DEV_MD=y\nCONFIG_BLK_DEV_DM=y\nCONFIG_DM_MIRROR=y\nCONFIG_DM_ZERO=y\nCONFIG_MACINTOSH_DRIVERS=y\nCONFIG_MAC_EMUMOUSEBTN=y\nCONFIG_NETDEVICES=y\nCONFIG_NETCONSOLE=y\nCONFIG_BNX2=y\nCONFIG_TIGON3=y\nCONFIG_NET_TULIP=y\nCONFIG_E100=y\nCONFIG_E1000=y\nCONFIG_E1000E=y\nCONFIG_SKY2=y\nCONFIG_NE2K_PCI=y\nCONFIG_FORCEDETH=y\nCONFIG_8139TOO=y\n# CONFIG_8139TOO_PIO is not set\nCONFIG_R8169=y\nCONFIG_INPUT_POLLDEV=y\nCONFIG_INPUT_EVDEV=y\nCONFIG_INPUT_JOYSTICK=y\nCONFIG_INPUT_TABLET=y\nCONFIG_INPUT_TOUCHSCREEN=y\nCONFIG_INPUT_MISC=y\n# CONFIG_LEGACY_PTYS is not set\nCONFIG_SERIAL_8250=y\nCONFIG_SERIAL_8250_CONSOLE=y\nCONFIG_SERIAL_8250_NR_UARTS=32\nCONFIG_SERIAL_8250_EXTENDED=y\nCONFIG_SERIAL_8250_MANY_PORTS=y\nCONFIG_SERIAL_8250_SHARE_IRQ=y\nCONFIG_SERIAL_8250_DETECT_IRQ=y\nCONFIG_SERIAL_8250_RSA=y\nCONFIG_SERIAL_NONSTANDARD=y\nCONFIG_HW_RANDOM=y\nCONFIG_NVRAM=y\nCONFIG_HPET=y\n# CONFIG_HPET_MMAP is not set\nCONFIG_I2C_I801=y\nCONFIG_WATCHDOG=y\nCONFIG_AGP=y\nCONFIG_AGP_AMD64=y\nCONFIG_AGP_INTEL=y\nCONFIG_DRM=y\nCONFIG_DRM_I915=y\nCONFIG_FB_MODE_HELPERS=y\nCONFIG_FB_TILEBLITTING=y\nCONFIG_FB_EFI=y\nCONFIG_VGACON_SOFT_SCROLLBACK=y\nCONFIG_LOGO=y\n# CONFIG_LOGO_LINUX_MONO is not set\n# CONFIG_LOGO_LINUX_VGA16 is not set\nCONFIG_SOUND=y\nCONFIG_SND=y\nCONFIG_SND_HRTIMER=y\nCONFIG_SND_SEQUENCER=y\nCONFIG_SND_SEQ_DUMMY=y\nCONFIG_SND_HDA_INTEL=y\nCONFIG_SND_HDA_HWDEP=y\nCONFIG_HIDRAW=y\nCONFIG_HID_GYRATION=y\nCONFIG_LOGITECH_FF=y\nCONFIG_HID_NTRIG=y\nCONFIG_HID_PANTHERLORD=y\nCONFIG_PANTHERLORD_FF=y\nCONFIG_HID_PETALYNX=y\nCONFIG_HID_SAMSUNG=y\nCONFIG_HID_SONY=y\nCONFIG_HID_SUNPLUS=y\nCONFIG_HID_TOPSEED=y\nCONFIG_HID_PID=y\nCONFIG_USB_HIDDEV=y\nCONFIG_USB=y\nCONFIG_USB_ANNOUNCE_NEW_DEVICES=y\nCONFIG_USB_MON=y\nCONFIG_USB_XHCI_HCD=y\nCONFIG_USB_EHCI_HCD=y\nCONFIG_USB_OHCI_HCD=y\nCONFIG_USB_UHCI_HCD=y\nCONFIG_USB_PRINTER=y\nCONFIG_USB_STORAGE=y\nCONFIG_RTC_CLASS=y\n# CONFIG_RTC_HCTOSYS is not set\nCONFIG_DMADEVICES=y\nCONFIG_EEEPC_LAPTOP=y\nCONFIG_EXT4_FS=y\nCONFIG_EXT4_FS_POSIX_ACL=y\nCONFIG_EXT4_FS_SECURITY=y\nCONFIG_QUOTA=y\nCONFIG_QUOTA_NETLINK_INTERFACE=y\n# CONFIG_PRINT_QUOTA_WARNING is not set\nCONFIG_QFMT_V2=y\nCONFIG_AUTOFS4_FS=y\nCONFIG_ISO9660_FS=y\nCONFIG_JOLIET=y\nCONFIG_ZISOFS=y\nCONFIG_MSDOS_FS=y\nCONFIG_VFAT_FS=y\nCONFIG_PROC_KCORE=y\nCONFIG_TMPFS_POSIX_ACL=y\nCONFIG_HUGETLBFS=y\nCONFIG_NFS_FS=y\nCONFIG_NFS_V3_ACL=y\nCONFIG_NFS_V4=y\nCONFIG_ROOT_NFS=y\nCONFIG_NLS_DEFAULT=\"utf8\"\nCONFIG_NLS_CODEPAGE_437=y\nCONFIG_NLS_ASCII=y\nCONFIG_NLS_ISO8859_1=y\nCONFIG_NLS_UTF8=y\nCONFIG_SECURITY=y\nCONFIG_SECURITY_NETWORK=y\nCONFIG_SECURITY_SELINUX=y\nCONFIG_SECURITY_SELINUX_BOOTPARAM=y\nCONFIG_SECURITY_SELINUX_DISABLE=y\nCONFIG_PRINTK_TIME=y\nCONFIG_MAGIC_SYSRQ=y\nCONFIG_DEBUG_KERNEL=y\nCONFIG_DEBUG_STACK_USAGE=y\nCONFIG_DEBUG_STACKOVERFLOW=y\n# CONFIG_SCHED_DEBUG is not set\nCONFIG_SCHEDSTATS=y\nCONFIG_BLK_DEV_IO_TRACE=y\nCONFIG_PROVIDE_OHCI1394_DMA_INIT=y\nCONFIG_EARLY_PRINTK_DBGP=y\nCONFIG_DEBUG_BOOT_PARAMS=y\n", "# CONFIG_LOCALVERSION_AUTO is not set\nCONFIG_SYSVIPC=y\nCONFIG_POSIX_MQUEUE=y\nCONFIG_AUDIT=y\nCONFIG_NO_HZ=y\nCONFIG_HIGH_RES_TIMERS=y\nCONFIG_PREEMPT_VOLUNTARY=y\nCONFIG_BSD_PROCESS_ACCT=y\nCONFIG_TASKSTATS=y\nCONFIG_TASK_DELAY_ACCT=y\nCONFIG_TASK_XACCT=y\nCONFIG_TASK_IO_ACCOUNTING=y\nCONFIG_LOG_BUF_SHIFT=18\nCONFIG_CGROUPS=y\nCONFIG_CGROUP_SCHED=y\nCONFIG_CGROUP_FREEZER=y\nCONFIG_CPUSETS=y\nCONFIG_CGROUP_CPUACCT=y\nCONFIG_BLK_DEV_INITRD=y\n# CONFIG_COMPAT_BRK is not set\nCONFIG_PROFILING=y\nCONFIG_SMP=y\nCONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y\nCONFIG_MICROCODE_AMD=y\nCONFIG_X86_MSR=y\nCONFIG_X86_CPUID=y\nCONFIG_NUMA=y\nCONFIG_X86_CHECK_BIOS_CORRUPTION=y\n# CONFIG_MTRR_SANITIZER is not set\nCONFIG_EFI=y\nCONFIG_EFI_STUB=y\nCONFIG_EFI_MIXED=y\nCONFIG_HZ_1000=y\nCONFIG_KEXEC=y\nCONFIG_CRASH_DUMP=y\nCONFIG_HIBERNATION=y\nCONFIG_PM_DEBUG=y\nCONFIG_PM_TRACE_RTC=y\nCONFIG_ACPI_DOCK=y\nCONFIG_ACPI_BGRT=y\nCONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y\nCONFIG_CPU_FREQ_GOV_ONDEMAND=y\nCONFIG_X86_ACPI_CPUFREQ=y\nCONFIG_IA32_EMULATION=y\nCONFIG_EFI_VARS=y\nCONFIG_KPROBES=y\nCONFIG_JUMP_LABEL=y\nCONFIG_MODULES=y\nCONFIG_MODULE_UNLOAD=y\nCONFIG_MODULE_FORCE_UNLOAD=y\n# CONFIG_UNUSED_SYMBOLS is not set\nCONFIG_BINFMT_MISC=y\nCONFIG_NET=y\nCONFIG_PACKET=y\nCONFIG_UNIX=y\nCONFIG_XFRM_USER=y\nCONFIG_INET=y\nCONFIG_IP_MULTICAST=y\nCONFIG_IP_ADVANCED_ROUTER=y\nCONFIG_IP_MULTIPLE_TABLES=y\nCONFIG_IP_ROUTE_MULTIPATH=y\nCONFIG_IP_ROUTE_VERBOSE=y\nCONFIG_IP_PNP=y\nCONFIG_IP_PNP_DHCP=y\nCONFIG_IP_PNP_BOOTP=y\nCONFIG_IP_PNP_RARP=y\nCONFIG_IP_MROUTE=y\nCONFIG_IP_PIMSM_V1=y\nCONFIG_IP_PIMSM_V2=y\nCONFIG_SYN_COOKIES=y\n# CONFIG_INET_DIAG is not set\nCONFIG_TCP_CONG_ADVANCED=y\n# CONFIG_TCP_CONG_BIC is not set\n# CONFIG_TCP_CONG_WESTWOOD is not set\n# CONFIG_TCP_CONG_HTCP is not set\nCONFIG_TCP_MD5SIG=y\nCONFIG_INET6_AH=y\nCONFIG_INET6_ESP=y\nCONFIG_NETLABEL=y\nCONFIG_NETFILTER=y\n# CONFIG_NETFILTER_ADVANCED is not set\nCONFIG_NF_CONNTRACK=y\nCONFIG_NF_CONNTRACK_FTP=y\nCONFIG_NF_CONNTRACK_IRC=y\nCONFIG_NF_CONNTRACK_SIP=y\nCONFIG_NF_CT_NETLINK=y\nCONFIG_NF_NAT=y\nCONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y\nCONFIG_NETFILTER_XT_TARGET_NFLOG=y\nCONFIG_NETFILTER_XT_TARGET_SECMARK=y\nCONFIG_NETFILTER_XT_TARGET_TCPMSS=y\nCONFIG_NETFILTER_XT_MATCH_CONNTRACK=y\nCONFIG_NETFILTER_XT_MATCH_POLICY=y\nCONFIG_NETFILTER_XT_MATCH_STATE=y\nCONFIG_IP_NF_IPTABLES=y\nCONFIG_IP_NF_FILTER=y\nCONFIG_IP_NF_TARGET_REJECT=y\nCONFIG_IP_NF_TARGET_MASQUERADE=m\nCONFIG_IP_NF_MANGLE=y\nCONFIG_IP6_NF_IPTABLES=y\nCONFIG_IP6_NF_MATCH_IPV6HEADER=y\nCONFIG_IP6_NF_FILTER=y\nCONFIG_IP6_NF_TARGET_REJECT=y\nCONFIG_IP6_NF_MANGLE=y\nCONFIG_NET_SCHED=y\nCONFIG_NET_EMATCH=y\nCONFIG_NET_CLS_ACT=y\nCONFIG_CFG80211=y\nCONFIG_MAC80211=y\nCONFIG_MAC80211_LEDS=y\nCONFIG_RFKILL=y\nCONFIG_PCI=y\nCONFIG_PCIEPORTBUS=y\nCONFIG_HOTPLUG_PCI=y\nCONFIG_PCCARD=y\nCONFIG_YENTA=y\nCONFIG_DEVTMPFS=y\nCONFIG_DEVTMPFS_MOUNT=y\nCONFIG_DEBUG_DEVRES=y\nCONFIG_CONNECTOR=y\nCONFIG_BLK_DEV_LOOP=y\nCONFIG_BLK_DEV_SD=y\nCONFIG_BLK_DEV_SR=y\nCONFIG_CHR_DEV_SG=y\nCONFIG_SCSI_CONSTANTS=y\nCONFIG_SCSI_SPI_ATTRS=y\n# CONFIG_SCSI_LOWLEVEL is not set\nCONFIG_ATA=y\nCONFIG_SATA_AHCI=y\nCONFIG_ATA_PIIX=y\nCONFIG_PATA_AMD=y\nCONFIG_PATA_OLDPIIX=y\nCONFIG_PATA_SCH=y\nCONFIG_MD=y\nCONFIG_BLK_DEV_MD=y\nCONFIG_BLK_DEV_DM=y\nCONFIG_DM_MIRROR=y\nCONFIG_DM_ZERO=y\nCONFIG_MACINTOSH_DRIVERS=y\nCONFIG_MAC_EMUMOUSEBTN=y\nCONFIG_NETDEVICES=y\nCONFIG_NETCONSOLE=y\nCONFIG_TIGON3=y\nCONFIG_NET_TULIP=y\nCONFIG_E100=y\nCONFIG_E1000=y\nCONFIG_E1000E=y\nCONFIG_SKY2=y\nCONFIG_FORCEDETH=y\nCONFIG_8139TOO=y\nCONFIG_R8169=y\nCONFIG_INPUT_POLLDEV=y\nCONFIG_INPUT_EVDEV=y\nCONFIG_INPUT_JOYSTICK=y\nCONFIG_INPUT_TABLET=y\nCONFIG_INPUT_TOUCHSCREEN=y\nCONFIG_INPUT_MISC=y\n# CONFIG_LEGACY_PTYS is not set\nCONFIG_SERIAL_8250=y\nCONFIG_SERIAL_8250_CONSOLE=y\nCONFIG_SERIAL_8250_NR_UARTS=32\nCONFIG_SERIAL_8250_EXTENDED=y\nCONFIG_SERIAL_8250_MANY_PORTS=y\nCONFIG_SERIAL_8250_SHARE_IRQ=y\nCONFIG_SERIAL_8250_DETECT_IRQ=y\nCONFIG_SERIAL_8250_RSA=y\nCONFIG_SERIAL_NONSTANDARD=y\nCONFIG_HW_RANDOM=y\n# CONFIG_HW_RANDOM_INTEL is not set\n# CONFIG_HW_RANDOM_AMD is not set\nCONFIG_NVRAM=y\nCONFIG_HPET=y\n# CONFIG_HPET_MMAP is not set\nCONFIG_I2C_I801=y\nCONFIG_WATCHDOG=y\nCONFIG_AGP=y\nCONFIG_AGP_AMD64=y\nCONFIG_AGP_INTEL=y\nCONFIG_DRM=y\nCONFIG_DRM_I915=y\nCONFIG_FB_MODE_HELPERS=y\nCONFIG_FB_TILEBLITTING=y\nCONFIG_FB_EFI=y\nCONFIG_VGACON_SOFT_SCROLLBACK=y\nCONFIG_LOGO=y\n# CONFIG_LOGO_LINUX_MONO is not set\n# CONFIG_LOGO_LINUX_VGA16 is not set\nCONFIG_SOUND=y\nCONFIG_SND=y\nCONFIG_SND_HRTIMER=y\nCONFIG_SND_SEQUENCER=y\nCONFIG_SND_SEQ_DUMMY=y\nCONFIG_SND_HDA_INTEL=y\nCONFIG_SND_HDA_HWDEP=y\nCONFIG_HIDRAW=y\nCONFIG_HID_GYRATION=y\nCONFIG_LOGITECH_FF=y\nCONFIG_HID_NTRIG=y\nCONFIG_HID_PANTHERLORD=y\nCONFIG_PANTHERLORD_FF=y\nCONFIG_HID_PETALYNX=y\nCONFIG_HID_SAMSUNG=y\nCONFIG_HID_SONY=y\nCONFIG_HID_SUNPLUS=y\nCONFIG_HID_TOPSEED=y\nCONFIG_HID_PID=y\nCONFIG_USB_HIDDEV=y\nCONFIG_USB=y\nCONFIG_USB_ANNOUNCE_NEW_DEVICES=y\nCONFIG_USB_MON=y\nCONFIG_USB_XHCI_HCD=y\nCONFIG_USB_EHCI_HCD=y\nCONFIG_USB_OHCI_HCD=y\nCONFIG_USB_UHCI_HCD=y\nCONFIG_USB_PRINTER=y\nCONFIG_USB_STORAGE=y\nCONFIG_RTC_CLASS=y\n# CONFIG_RTC_HCTOSYS is not set\nCONFIG_DMADEVICES=y\nCONFIG_EEEPC_LAPTOP=y\nCONFIG_AMD_IOMMU=y\nCONFIG_INTEL_IOMMU=y\n# CONFIG_INTEL_IOMMU_DEFAULT_ON is not set\nCONFIG_EXT4_FS=y\nCONFIG_EXT4_FS_POSIX_ACL=y\nCONFIG_EXT4_FS_SECURITY=y\nCONFIG_QUOTA=y\nCONFIG_QUOTA_NETLINK_INTERFACE=y\n# CONFIG_PRINT_QUOTA_WARNING is not set\nCONFIG_QFMT_V2=y\nCONFIG_AUTOFS4_FS=y\nCONFIG_ISO9660_FS=y\nCONFIG_JOLIET=y\nCONFIG_ZISOFS=y\nCONFIG_MSDOS_FS=y\nCONFIG_VFAT_FS=y\nCONFIG_PROC_KCORE=y\nCONFIG_TMPFS_POSIX_ACL=y\nCONFIG_HUGETLBFS=y\nCONFIG_NFS_FS=y\nCONFIG_NFS_V3_ACL=y\nCONFIG_NFS_V4=y\nCONFIG_ROOT_NFS=y\nCONFIG_NLS_DEFAULT=\"utf8\"\nCONFIG_NLS_CODEPAGE_437=y\nCONFIG_NLS_ASCII=y\nCONFIG_NLS_ISO8859_1=y\nCONFIG_NLS_UTF8=y\nCONFIG_SECURITY=y\nCONFIG_SECURITY_NETWORK=y\nCONFIG_SECURITY_SELINUX=y\nCONFIG_SECURITY_SELINUX_BOOTPARAM=y\nCONFIG_SECURITY_SELINUX_DISABLE=y\nCONFIG_PRINTK_TIME=y\nCONFIG_MAGIC_SYSRQ=y\nCONFIG_DEBUG_KERNEL=y\nCONFIG_DEBUG_STACK_USAGE=y\n# CONFIG_SCHED_DEBUG is not set\nCONFIG_SCHEDSTATS=y\nCONFIG_BLK_DEV_IO_TRACE=y\nCONFIG_PROVIDE_OHCI1394_DMA_INIT=y\nCONFIG_EARLY_PRINTK_DBGP=y\nCONFIG_DEBUG_BOOT_PARAMS=y\n", "# SPDX-License-Identifier: GPL-2.0-only\n#\n# Video configuration\n#\n\nmenu \"Console display driver support\"\n\nconfig VGA_CONSOLE\n\tbool \"VGA text console\" if EXPERT || !X86\n\tdepends on !4xx && !PPC_8xx && !SPARC && !M68K && !PARISC &&  !SUPERH && \\\n\t\t(!ARM || ARCH_FOOTBRIDGE || ARCH_INTEGRATOR || ARCH_NETWINDER) && \\\n\t\t!ARM64 && !ARC && !MICROBLAZE && !OPENRISC && !NDS32 && !S390\n\tdefault y\n\thelp\n\t  Saying Y here will allow you to use Linux in text mode through a\n\t  display that complies with the generic VGA standard. Virtually\n\t  everyone wants that.\n\n\t  The program SVGATextMode can be used to utilize SVGA video cards to\n\t  their full potential in text mode. Download it from\n\t  <ftp://ibiblio.org/pub/Linux/utils/console/>.\n\n\t  Say Y.\n\nconfig VGACON_SOFT_SCROLLBACK\n       bool \"Enable Scrollback Buffer in System RAM\"\n       depends on VGA_CONSOLE\n       default n\n       help\n\t The scrollback buffer of the standard VGA console is located in\n\t the VGA RAM.  The size of this RAM is fixed and is quite small.\n\t If you require a larger scrollback buffer, this can be placed in\n\t System RAM which is dynamically allocated during initialization.\n\t Placing the scrollback buffer in System RAM will slightly slow\n\t down the console.\n\n\t If you want this feature, say 'Y' here and enter the amount of\n\t RAM to allocate for this buffer.  If unsure, say 'N'.\n\nconfig VGACON_SOFT_SCROLLBACK_SIZE\n       int \"Scrollback Buffer Size (in KB)\"\n       depends on VGACON_SOFT_SCROLLBACK\n       range 1 1024\n       default \"64\"\n       help\n\t  Enter the amount of System RAM to allocate for scrollback\n\t  buffers of VGA consoles. Each 64KB will give you approximately\n\t  16 80x25 screenfuls of scrollback buffer.\n\nconfig VGACON_SOFT_SCROLLBACK_PERSISTENT_ENABLE_BY_DEFAULT\n\tbool \"Persistent Scrollback History for each console by default\"\n\tdepends on VGACON_SOFT_SCROLLBACK\n\tdefault n\n\thelp\n\t  Say Y here if the scrollback history should persist by default when\n\t  switching between consoles. Otherwise, the scrollback history will be\n\t  flushed each time the console is switched. This feature can also be\n\t  enabled using the boot command line parameter\n\t  'vgacon.scrollback_persistent=1'.\n\n\t  This feature might break your tool of choice to flush the scrollback\n\t  buffer, e.g. clear(1) will work fine but Debian's clear_console(1)\n\t  will be broken, which might cause security issues.\n\t  You can use the escape sequence \\e[3J instead if this feature is\n\t  activated.\n\n\t  Note that a buffer of VGACON_SOFT_SCROLLBACK_SIZE is taken for each\n\t  created tty device.\n\t  So if you use a RAM-constrained system, say N here.\n\nconfig MDA_CONSOLE\n\tdepends on !M68K && !PARISC && ISA\n\ttristate \"MDA text console (dual-headed)\"\n\thelp\n\t  Say Y here if you have an old MDA or monochrome Hercules graphics\n\t  adapter in your system acting as a second head ( = video card). You\n\t  will then be able to use two monitors with your Linux system. Do not\n\t  say Y here if your MDA card is the primary card in your system; the\n\t  normal VGA driver will handle it.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called mdacon.\n\n\t  If unsure, say N.\n\nconfig SGI_NEWPORT_CONSOLE\n\ttristate \"SGI Newport Console support\"\n\tdepends on SGI_IP22 && HAS_IOMEM\n\tselect FONT_SUPPORT\n\thelp\n\t  Say Y here if you want the console on the Newport aka XL graphics\n\t  card of your Indy.  Most people say Y here.\n\nconfig DUMMY_CONSOLE\n\tbool\n\tdefault y\n\nconfig DUMMY_CONSOLE_COLUMNS\n\tint \"Initial number of console screen columns\"\n\tdepends on DUMMY_CONSOLE && !ARM\n\tdefault 160 if PARISC\n\tdefault 80\n\thelp\n\t  On PA-RISC, the default value is 160, which should fit a 1280x1024\n\t  monitor.\n\t  Select 80 if you use a 640x480 resolution by default.\n\nconfig DUMMY_CONSOLE_ROWS\n\tint \"Initial number of console screen rows\"\n\tdepends on DUMMY_CONSOLE && !ARM\n\tdefault 64 if PARISC\n\tdefault 25\n\thelp\n\t  On PA-RISC, the default value is 64, which should fit a 1280x1024\n\t  monitor.\n\t  Select 25 if you use a 640x480 resolution by default.\n\nconfig FRAMEBUFFER_CONSOLE\n\tbool \"Framebuffer Console support\"\n\tdepends on FB && !UML\n\tselect VT_HW_CONSOLE_BINDING\n\tselect CRC32\n\tselect FONT_SUPPORT\n\thelp\n\t  Low-level framebuffer-based console driver.\n\nconfig FRAMEBUFFER_CONSOLE_DETECT_PRIMARY\n       bool \"Map the console to the primary display device\"\n       depends on FRAMEBUFFER_CONSOLE\n       default n\n\thelp\n\t If this option is selected, the framebuffer console will\n\t automatically select the primary display device (if the architecture\n\t supports this feature).  Otherwise, the framebuffer console will\n\t always select the first framebuffer driver that is loaded. The latter\n\t is the default behavior.\n\n\t You can always override the automatic selection of the primary device\n\t by using the fbcon=map: boot option.\n\n\t If unsure, select n.\n\nconfig FRAMEBUFFER_CONSOLE_ROTATION\n       bool \"Framebuffer Console Rotation\"\n       depends on FRAMEBUFFER_CONSOLE\n       help\n\t Enable display rotation for the framebuffer console.  This is done\n\t in software and may be significantly slower than a normally oriented\n\t display.  Note that the rotation is done at the console level only\n\t such that other users of the framebuffer will remain normally\n\t oriented.\n\nconfig FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER\n\tbool \"Framebuffer Console Deferred Takeover\"\n\tdepends on FB=y && FRAMEBUFFER_CONSOLE && DUMMY_CONSOLE\n\thelp\n\t  If enabled this defers the framebuffer console taking over the\n\t  console from the dummy console until the first text is displayed on\n\t  the console. This is useful in combination with the \"quiet\" kernel\n\t  commandline option to keep the framebuffer contents initially put up\n\t  by the firmware in place, rather then replacing the contents with a\n\t  black screen as soon as fbcon loads.\n\nconfig STI_CONSOLE\n\tbool \"STI text console\"\n\tdepends on PARISC && HAS_IOMEM\n\tselect FONT_SUPPORT\n\tdefault y\n\thelp\n\t  The STI console is the builtin display/keyboard on HP-PARISC\n\t  machines.  Say Y here to build support for it into your kernel.\n\t  The alternative is to use your primary serial port as a console.\n\nendmenu\n\n", "/*\n *  linux/drivers/video/vgacon.c -- Low level VGA based console driver\n *\n *\tCreated 28 Sep 1997 by Geert Uytterhoeven\n *\n *\tRewritten by Martin Mares <mj@ucw.cz>, July 1998\n *\n *  This file is based on the old console.c, vga.c and vesa_blank.c drivers.\n *\n *\tCopyright (C) 1991, 1992  Linus Torvalds\n *\t\t\t    1995  Jay Estabrook\n *\n *\tUser definable mapping table and font loading by Eugene G. Crosser,\n *\t<crosser@average.org>\n *\n *\tImproved loadable font/UTF-8 support by H. Peter Anvin\n *\tFeb-Sep 1995 <peter.anvin@linux.org>\n *\n *\tColour palette handling, by Simon Tatham\n *\t17-Jun-95 <sgt20@cam.ac.uk>\n *\n *\tif 512 char mode is already enabled don't re-enable it,\n *\tbecause it causes screen to flicker, by Mitja Horvat\n *\t5-May-96 <mitja.horvat@guest.arnes.si>\n *\n *\tUse 2 outw instead of 4 outb_p to reduce erroneous text\n *\tflashing on RHS of screen during heavy console scrolling .\n *\tOct 1996, Paul Gortmaker.\n *\n *\n *  This file is subject to the terms and conditions of the GNU General Public\n *  License.  See the file COPYING in the main directory of this archive for\n *  more details.\n */\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/console.h>\n#include <linux/string.h>\n#include <linux/kd.h>\n#include <linux/slab.h>\n#include <linux/vt_kern.h>\n#include <linux/sched.h>\n#include <linux/selection.h>\n#include <linux/spinlock.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/screen_info.h>\n#include <video/vga.h>\n#include <asm/io.h>\n\nstatic DEFINE_RAW_SPINLOCK(vga_lock);\nstatic int cursor_size_lastfrom;\nstatic int cursor_size_lastto;\nstatic u32 vgacon_xres;\nstatic u32 vgacon_yres;\nstatic struct vgastate vgastate;\n\n#define BLANK 0x0020\n\n#define VGA_FONTWIDTH       8   /* VGA does not support fontwidths != 8 */\n/*\n *  Interface used by the world\n */\n\nstatic const char *vgacon_startup(void);\nstatic void vgacon_init(struct vc_data *c, int init);\nstatic void vgacon_deinit(struct vc_data *c);\nstatic void vgacon_cursor(struct vc_data *c, int mode);\nstatic int vgacon_switch(struct vc_data *c);\nstatic int vgacon_blank(struct vc_data *c, int blank, int mode_switch);\nstatic void vgacon_scrolldelta(struct vc_data *c, int lines);\nstatic int vgacon_set_origin(struct vc_data *c);\nstatic void vgacon_save_screen(struct vc_data *c);\nstatic void vgacon_invert_region(struct vc_data *c, u16 * p, int count);\nstatic struct uni_pagedir *vgacon_uni_pagedir;\nstatic int vgacon_refcount;\n\n/* Description of the hardware situation */\nstatic bool\t\tvga_init_done;\nstatic unsigned long\tvga_vram_base\t\t__read_mostly;\t/* Base of video memory */\nstatic unsigned long\tvga_vram_end\t\t__read_mostly;\t/* End of video memory */\nstatic unsigned int\tvga_vram_size\t\t__read_mostly;\t/* Size of video memory */\nstatic u16\t\tvga_video_port_reg\t__read_mostly;\t/* Video register select port */\nstatic u16\t\tvga_video_port_val\t__read_mostly;\t/* Video register value port */\nstatic unsigned int\tvga_video_num_columns;\t\t\t/* Number of text columns */\nstatic unsigned int\tvga_video_num_lines;\t\t\t/* Number of text lines */\nstatic bool\t\tvga_can_do_color;\t\t\t/* Do we support colors? */\nstatic unsigned int\tvga_default_font_height __read_mostly;\t/* Height of default screen font */\nstatic unsigned char\tvga_video_type\t\t__read_mostly;\t/* Card type */\nstatic bool\t\tvga_font_is_default = true;\nstatic int\t\tvga_vesa_blanked;\nstatic bool \t\tvga_palette_blanked;\nstatic bool \t\tvga_is_gfx;\nstatic bool \t\tvga_512_chars;\nstatic int \t\tvga_video_font_height;\nstatic int \t\tvga_scan_lines\t\t__read_mostly;\nstatic unsigned int \tvga_rolled_over;\n\nstatic bool vgacon_text_mode_force;\nstatic bool vga_hardscroll_enabled;\nstatic bool vga_hardscroll_user_enable = true;\n\nbool vgacon_text_force(void)\n{\n\treturn vgacon_text_mode_force;\n}\nEXPORT_SYMBOL(vgacon_text_force);\n\nstatic int __init text_mode(char *str)\n{\n\tvgacon_text_mode_force = true;\n\n\tpr_warn(\"You have booted with nomodeset. This means your GPU drivers are DISABLED\\n\");\n\tpr_warn(\"Any video related functionality will be severely degraded, and you may not even be able to suspend the system properly\\n\");\n\tpr_warn(\"Unless you actually understand what nomodeset does, you should reboot without enabling it\\n\");\n\n\treturn 1;\n}\n\n/* force text mode - used by kernel modesetting */\n__setup(\"nomodeset\", text_mode);\n\nstatic int __init no_scroll(char *str)\n{\n\t/*\n\t * Disabling scrollback is required for the Braillex ib80-piezo\n\t * Braille reader made by F.H. Papenmeier (Germany).\n\t * Use the \"no-scroll\" bootflag.\n\t */\n\tvga_hardscroll_user_enable = vga_hardscroll_enabled = false;\n\treturn 1;\n}\n\n__setup(\"no-scroll\", no_scroll);\n\n/*\n * By replacing the four outb_p with two back to back outw, we can reduce\n * the window of opportunity to see text mislocated to the RHS of the\n * console during heavy scrolling activity. However there is the remote\n * possibility that some pre-dinosaur hardware won't like the back to back\n * I/O. Since the Xservers get away with it, we should be able to as well.\n */\nstatic inline void write_vga(unsigned char reg, unsigned int val)\n{\n\tunsigned int v1, v2;\n\tunsigned long flags;\n\n\t/*\n\t * ddprintk might set the console position from interrupt\n\t * handlers, thus the write has to be IRQ-atomic.\n\t */\n\traw_spin_lock_irqsave(&vga_lock, flags);\n\tv1 = reg + (val & 0xff00);\n\tv2 = reg + 1 + ((val << 8) & 0xff00);\n\toutw(v1, vga_video_port_reg);\n\toutw(v2, vga_video_port_reg);\n\traw_spin_unlock_irqrestore(&vga_lock, flags);\n}\n\nstatic inline void vga_set_mem_top(struct vc_data *c)\n{\n\twrite_vga(12, (c->vc_visible_origin - vga_vram_base) / 2);\n}\n\n#ifdef CONFIG_VGACON_SOFT_SCROLLBACK\n/* software scrollback */\nstruct vgacon_scrollback_info {\n\tvoid *data;\n\tint tail;\n\tint size;\n\tint rows;\n\tint cnt;\n\tint cur;\n\tint save;\n\tint restore;\n};\n\nstatic struct vgacon_scrollback_info *vgacon_scrollback_cur;\nstatic struct vgacon_scrollback_info vgacon_scrollbacks[MAX_NR_CONSOLES];\nstatic bool scrollback_persistent = \\\n\tIS_ENABLED(CONFIG_VGACON_SOFT_SCROLLBACK_PERSISTENT_ENABLE_BY_DEFAULT);\nmodule_param_named(scrollback_persistent, scrollback_persistent, bool, 0000);\nMODULE_PARM_DESC(scrollback_persistent, \"Enable persistent scrollback for all vga consoles\");\n\nstatic void vgacon_scrollback_reset(int vc_num, size_t reset_size)\n{\n\tstruct vgacon_scrollback_info *scrollback = &vgacon_scrollbacks[vc_num];\n\n\tif (scrollback->data && reset_size > 0)\n\t\tmemset(scrollback->data, 0, reset_size);\n\n\tscrollback->cnt  = 0;\n\tscrollback->tail = 0;\n\tscrollback->cur  = 0;\n}\n\nstatic void vgacon_scrollback_init(int vc_num)\n{\n\tint pitch = vga_video_num_columns * 2;\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tint rows = size / pitch;\n\tvoid *data;\n\n\tdata = kmalloc_array(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE, 1024,\n\t\t\t     GFP_NOWAIT);\n\n\tvgacon_scrollbacks[vc_num].data = data;\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\n\tvgacon_scrollback_cur->rows = rows - 1;\n\tvgacon_scrollback_cur->size = rows * pitch;\n\n\tvgacon_scrollback_reset(vc_num, size);\n}\n\nstatic void vgacon_scrollback_switch(int vc_num)\n{\n\tif (!scrollback_persistent)\n\t\tvc_num = 0;\n\n\tif (!vgacon_scrollbacks[vc_num].data) {\n\t\tvgacon_scrollback_init(vc_num);\n\t} else {\n\t\tif (scrollback_persistent) {\n\t\t\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\t\t} else {\n\t\t\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\n\t\t\tvgacon_scrollback_reset(vc_num, size);\n\t\t}\n\t}\n}\n\nstatic void vgacon_scrollback_startup(void)\n{\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[0];\n\tvgacon_scrollback_init(0);\n}\n\nstatic void vgacon_scrollback_update(struct vc_data *c, int t, int count)\n{\n\tvoid *p;\n\n\tif (!vgacon_scrollback_cur->data || !vgacon_scrollback_cur->size ||\n\t    c->vc_num != fg_console)\n\t\treturn;\n\n\tp = (void *) (c->vc_origin + t * c->vc_size_row);\n\n\twhile (count--) {\n\t\tif ((vgacon_scrollback_cur->tail + c->vc_size_row) >\n\t\t    vgacon_scrollback_cur->size)\n\t\t\tvgacon_scrollback_cur->tail = 0;\n\n\t\tscr_memcpyw(vgacon_scrollback_cur->data +\n\t\t\t    vgacon_scrollback_cur->tail,\n\t\t\t    p, c->vc_size_row);\n\n\t\tvgacon_scrollback_cur->cnt++;\n\t\tp += c->vc_size_row;\n\t\tvgacon_scrollback_cur->tail += c->vc_size_row;\n\n\t\tif (vgacon_scrollback_cur->tail >= vgacon_scrollback_cur->size)\n\t\t\tvgacon_scrollback_cur->tail = 0;\n\n\t\tif (vgacon_scrollback_cur->cnt > vgacon_scrollback_cur->rows)\n\t\t\tvgacon_scrollback_cur->cnt = vgacon_scrollback_cur->rows;\n\n\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n\t}\n}\n\nstatic void vgacon_restore_screen(struct vc_data *c)\n{\n\tc->vc_origin = c->vc_visible_origin;\n\tvgacon_scrollback_cur->save = 0;\n\n\tif (!vga_is_gfx && !vgacon_scrollback_cur->restore) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t    vga_vram_size : c->vc_screenbuf_size);\n\t\tvgacon_scrollback_cur->restore = 1;\n\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n\t}\n}\n\nstatic void vgacon_scrolldelta(struct vc_data *c, int lines)\n{\n\tint start, end, count, soff;\n\n\tif (!lines) {\n\t\tvgacon_restore_screen(c);\n\t\treturn;\n\t}\n\n\tif (!vgacon_scrollback_cur->data)\n\t\treturn;\n\n\tif (!vgacon_scrollback_cur->save) {\n\t\tvgacon_cursor(c, CM_ERASE);\n\t\tvgacon_save_screen(c);\n\t\tc->vc_origin = (unsigned long)c->vc_screenbuf;\n\t\tvgacon_scrollback_cur->save = 1;\n\t}\n\n\tvgacon_scrollback_cur->restore = 0;\n\tstart = vgacon_scrollback_cur->cur + lines;\n\tend = start + abs(lines);\n\n\tif (start < 0)\n\t\tstart = 0;\n\n\tif (start > vgacon_scrollback_cur->cnt)\n\t\tstart = vgacon_scrollback_cur->cnt;\n\n\tif (end < 0)\n\t\tend = 0;\n\n\tif (end > vgacon_scrollback_cur->cnt)\n\t\tend = vgacon_scrollback_cur->cnt;\n\n\tvgacon_scrollback_cur->cur = start;\n\tcount = end - start;\n\tsoff = vgacon_scrollback_cur->tail -\n\t\t((vgacon_scrollback_cur->cnt - end) * c->vc_size_row);\n\tsoff -= count * c->vc_size_row;\n\n\tif (soff < 0)\n\t\tsoff += vgacon_scrollback_cur->size;\n\n\tcount = vgacon_scrollback_cur->cnt - start;\n\n\tif (count > c->vc_rows)\n\t\tcount = c->vc_rows;\n\n\tif (count) {\n\t\tint copysize;\n\n\t\tint diff = c->vc_rows - count;\n\t\tvoid *d = (void *) c->vc_visible_origin;\n\t\tvoid *s = (void *) c->vc_screenbuf;\n\n\t\tcount *= c->vc_size_row;\n\t\t/* how much memory to end of buffer left? */\n\t\tcopysize = min(count, vgacon_scrollback_cur->size - soff);\n\t\tscr_memcpyw(d, vgacon_scrollback_cur->data + soff, copysize);\n\t\td += copysize;\n\t\tcount -= copysize;\n\n\t\tif (count) {\n\t\t\tscr_memcpyw(d, vgacon_scrollback_cur->data, count);\n\t\t\td += count;\n\t\t}\n\n\t\tif (diff)\n\t\t\tscr_memcpyw(d, s, diff * c->vc_size_row);\n\t} else\n\t\tvgacon_cursor(c, CM_MOVE);\n}\n\nstatic void vgacon_flush_scrollback(struct vc_data *c)\n{\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\n\tvgacon_scrollback_reset(c->vc_num, size);\n}\n#else\n#define vgacon_scrollback_startup(...) do { } while (0)\n#define vgacon_scrollback_init(...)    do { } while (0)\n#define vgacon_scrollback_update(...)  do { } while (0)\n#define vgacon_scrollback_switch(...)  do { } while (0)\n\nstatic void vgacon_restore_screen(struct vc_data *c)\n{\n\tif (c->vc_origin != c->vc_visible_origin)\n\t\tvgacon_scrolldelta(c, 0);\n}\n\nstatic void vgacon_scrolldelta(struct vc_data *c, int lines)\n{\n\tvc_scrolldelta_helper(c, lines, vga_rolled_over, (void *)vga_vram_base,\n\t\t\tvga_vram_size);\n\tvga_set_mem_top(c);\n}\n\nstatic void vgacon_flush_scrollback(struct vc_data *c)\n{\n}\n#endif /* CONFIG_VGACON_SOFT_SCROLLBACK */\n\nstatic const char *vgacon_startup(void)\n{\n\tconst char *display_desc = NULL;\n\tu16 saved1, saved2;\n\tvolatile u16 *p;\n\n\tif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||\n\t    screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {\n\t      no_vga:\n#ifdef CONFIG_DUMMY_CONSOLE\n\t\tconswitchp = &dummy_con;\n\t\treturn conswitchp->con_startup();\n#else\n\t\treturn NULL;\n#endif\n\t}\n\n\t/* boot_params.screen_info reasonably initialized? */\n\tif ((screen_info.orig_video_lines == 0) ||\n\t    (screen_info.orig_video_cols  == 0))\n\t\tgoto no_vga;\n\n\t/* VGA16 modes are not handled by VGACON */\n\tif ((screen_info.orig_video_mode == 0x0D) ||\t/* 320x200/4 */\n\t    (screen_info.orig_video_mode == 0x0E) ||\t/* 640x200/4 */\n\t    (screen_info.orig_video_mode == 0x10) ||\t/* 640x350/4 */\n\t    (screen_info.orig_video_mode == 0x12) ||\t/* 640x480/4 */\n\t    (screen_info.orig_video_mode == 0x6A))\t/* 800x600/4 (VESA) */\n\t\tgoto no_vga;\n\n\tvga_video_num_lines = screen_info.orig_video_lines;\n\tvga_video_num_columns = screen_info.orig_video_cols;\n\tvgastate.vgabase = NULL;\n\n\tif (screen_info.orig_video_mode == 7) {\n\t\t/* Monochrome display */\n\t\tvga_vram_base = 0xb0000;\n\t\tvga_video_port_reg = VGA_CRT_IM;\n\t\tvga_video_port_val = VGA_CRT_DM;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tstatic struct resource ega_console_resource =\n\t\t\t    { .name\t= \"ega\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_EGAM;\n\t\t\tvga_vram_size = 0x8000;\n\t\t\tdisplay_desc = \"EGA+\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &ega_console_resource);\n\t\t} else {\n\t\t\tstatic struct resource mda1_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BB };\n\t\t\tstatic struct resource mda2_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3BF,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_MDA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda1_console_resource);\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda2_console_resource);\n\t\t\tvga_video_font_height = 14;\n\t\t}\n\t} else {\n\t\t/* If not, it is color. */\n\t\tvga_can_do_color = true;\n\t\tvga_vram_base = 0xb8000;\n\t\tvga_video_port_reg = VGA_CRT_IC;\n\t\tvga_video_port_val = VGA_CRT_DC;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tint i;\n\n\t\t\tvga_vram_size = 0x8000;\n\n\t\t\tif (!screen_info.orig_video_isVGA) {\n\t\t\t\tstatic struct resource ega_console_resource =\n\t\t\t\t    { .name\t= \"ega\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_EGAC;\n\t\t\t\tdisplay_desc = \"EGA\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &ega_console_resource);\n\t\t\t} else {\n\t\t\t\tstatic struct resource vga_console_resource =\n\t\t\t\t    { .name\t= \"vga+\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_VGAC;\n\t\t\t\tdisplay_desc = \"VGA+\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &vga_console_resource);\n\n\t\t\t\t/*\n\t\t\t\t * Normalise the palette registers, to point\n\t\t\t\t * the 16 screen colours to the first 16\n\t\t\t\t * DAC entries.\n\t\t\t\t */\n\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tinb_p(VGA_IS1_RC);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t}\n\t\t\t\toutb_p(0x20, VGA_ATT_W);\n\n\t\t\t\t/*\n\t\t\t\t * Now set the DAC registers back to their\n\t\t\t\t * default values\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\toutb_p(color_table[i], VGA_PEL_IW);\n\t\t\t\t\toutb_p(default_red[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_grn[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_blu[i], VGA_PEL_D);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstatic struct resource cga_console_resource =\n\t\t\t    { .name\t= \"cga\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3D4,\n\t\t\t      .end\t= 0x3D5 };\n\t\t\tvga_video_type = VIDEO_TYPE_CGA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &cga_console_resource);\n\t\t\tvga_video_font_height = 8;\n\t\t}\n\t}\n\n\tvga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);\n\tvga_vram_end = vga_vram_base + vga_vram_size;\n\n\t/*\n\t *      Find out if there is a graphics card present.\n\t *      Are there smarter methods around?\n\t */\n\tp = (volatile u16 *) vga_vram_base;\n\tsaved1 = scr_readw(p);\n\tsaved2 = scr_readw(p + 1);\n\tscr_writew(0xAA55, p);\n\tscr_writew(0x55AA, p + 1);\n\tif (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(0x55AA, p);\n\tscr_writew(0xAA55, p + 1);\n\tif (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(saved1, p);\n\tscr_writew(saved2, p + 1);\n\n\tif (vga_video_type == VIDEO_TYPE_EGAC\n\t    || vga_video_type == VIDEO_TYPE_VGAC\n\t    || vga_video_type == VIDEO_TYPE_EGAM) {\n\t\tvga_hardscroll_enabled = vga_hardscroll_user_enable;\n\t\tvga_default_font_height = screen_info.orig_video_points;\n\t\tvga_video_font_height = screen_info.orig_video_points;\n\t\t/* This may be suboptimal but is a safe bet - go with it */\n\t\tvga_scan_lines =\n\t\t    vga_video_font_height * vga_video_num_lines;\n\t}\n\n\tvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\n\tvgacon_yres = vga_scan_lines;\n\n\tif (!vga_init_done) {\n\t\tvgacon_scrollback_startup();\n\t\tvga_init_done = true;\n\t}\n\n\treturn display_desc;\n}\n\nstatic void vgacon_init(struct vc_data *c, int init)\n{\n\tstruct uni_pagedir *p;\n\n\t/*\n\t * We cannot be loaded as a module, therefore init is always 1,\n\t * but vgacon_init can be called more than once, and init will\n\t * not be 1.\n\t */\n\tc->vc_can_do_color = vga_can_do_color;\n\n\t/* set dimensions manually if init != 0 since vc_resize() will fail */\n\tif (init) {\n\t\tc->vc_cols = vga_video_num_columns;\n\t\tc->vc_rows = vga_video_num_lines;\n\t} else\n\t\tvc_resize(c, vga_video_num_columns, vga_video_num_lines);\n\n\tc->vc_scan_lines = vga_scan_lines;\n\tc->vc_font.height = vga_video_font_height;\n\tc->vc_complement_mask = 0x7700;\n\tif (vga_512_chars)\n\t\tc->vc_hi_font_mask = 0x0800;\n\tp = *c->vc_uni_pagedir_loc;\n\tif (c->vc_uni_pagedir_loc != &vgacon_uni_pagedir) {\n\t\tcon_free_unimap(c);\n\t\tc->vc_uni_pagedir_loc = &vgacon_uni_pagedir;\n\t\tvgacon_refcount++;\n\t}\n\tif (!vgacon_uni_pagedir && p)\n\t\tcon_set_default_unimap(c);\n\n\t/* Only set the default if the user didn't deliberately override it */\n\tif (global_cursor_default == -1)\n\t\tglobal_cursor_default =\n\t\t\t!(screen_info.flags & VIDEO_FLAGS_NOCURSOR);\n}\n\nstatic void vgacon_deinit(struct vc_data *c)\n{\n\t/* When closing the active console, reset video origin */\n\tif (con_is_visible(c)) {\n\t\tc->vc_visible_origin = vga_vram_base;\n\t\tvga_set_mem_top(c);\n\t}\n\n\tif (!--vgacon_refcount)\n\t\tcon_free_unimap(c);\n\tc->vc_uni_pagedir_loc = &c->vc_uni_pagedir;\n\tcon_set_default_unimap(c);\n}\n\nstatic u8 vgacon_build_attr(struct vc_data *c, u8 color,\n\t\t\t    enum vc_intensity intensity,\n\t\t\t    bool blink, bool underline, bool reverse,\n\t\t\t    bool italic)\n{\n\tu8 attr = color;\n\n\tif (vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF0) | c->vc_itcolor;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf0) | c->vc_ulcolor;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | c->vc_halfcolor;\n\t}\n\tif (reverse)\n\t\tattr =\n\t\t    ((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) &\n\t\t\t\t       0x77);\n\tif (blink)\n\t\tattr ^= 0x80;\n\tif (intensity == VCI_BOLD)\n\t\tattr ^= 0x08;\n\tif (!vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF8) | 0x02;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf8) | 0x01;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | 0x08;\n\t}\n\treturn attr;\n}\n\nstatic void vgacon_invert_region(struct vc_data *c, u16 * p, int count)\n{\n\tconst bool col = vga_can_do_color;\n\n\twhile (count--) {\n\t\tu16 a = scr_readw(p);\n\t\tif (col)\n\t\t\ta = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) |\n\t\t\t    (((a) & 0x0700) << 4);\n\t\telse\n\t\t\ta ^= ((a & 0x0700) == 0x0100) ? 0x7000 : 0x7700;\n\t\tscr_writew(a, p++);\n\t}\n}\n\nstatic void vgacon_set_cursor_size(int xpos, int from, int to)\n{\n\tunsigned long flags;\n\tint curs, cure;\n\n\tif ((from == cursor_size_lastfrom) && (to == cursor_size_lastto))\n\t\treturn;\n\tcursor_size_lastfrom = from;\n\tcursor_size_lastto = to;\n\n\traw_spin_lock_irqsave(&vga_lock, flags);\n\tif (vga_video_type >= VIDEO_TYPE_VGAC) {\n\t\toutb_p(VGA_CRTC_CURSOR_START, vga_video_port_reg);\n\t\tcurs = inb_p(vga_video_port_val);\n\t\toutb_p(VGA_CRTC_CURSOR_END, vga_video_port_reg);\n\t\tcure = inb_p(vga_video_port_val);\n\t} else {\n\t\tcurs = 0;\n\t\tcure = 0;\n\t}\n\n\tcurs = (curs & 0xc0) | from;\n\tcure = (cure & 0xe0) | to;\n\n\toutb_p(VGA_CRTC_CURSOR_START, vga_video_port_reg);\n\toutb_p(curs, vga_video_port_val);\n\toutb_p(VGA_CRTC_CURSOR_END, vga_video_port_reg);\n\toutb_p(cure, vga_video_port_val);\n\traw_spin_unlock_irqrestore(&vga_lock, flags);\n}\n\nstatic void vgacon_cursor(struct vc_data *c, int mode)\n{\n\tif (c->vc_mode != KD_TEXT)\n\t\treturn;\n\n\tvgacon_restore_screen(c);\n\n\tswitch (mode) {\n\tcase CM_ERASE:\n\t\twrite_vga(14, (c->vc_pos - vga_vram_base) / 2);\n\t        if (vga_video_type >= VIDEO_TYPE_VGAC)\n\t\t\tvgacon_set_cursor_size(c->state.x, 31, 30);\n\t\telse\n\t\t\tvgacon_set_cursor_size(c->state.x, 31, 31);\n\t\tbreak;\n\n\tcase CM_MOVE:\n\tcase CM_DRAW:\n\t\twrite_vga(14, (c->vc_pos - vga_vram_base) / 2);\n\t\tswitch (CUR_SIZE(c->vc_cursor_type)) {\n\t\tcase CUR_UNDERLINE:\n\t\t\tvgacon_set_cursor_size(c->state.x,\n\t\t\t\t\t       c->vc_font.height -\n\t\t\t\t\t       (c->vc_font.height <\n\t\t\t\t\t\t10 ? 2 : 3),\n\t\t\t\t\t       c->vc_font.height -\n\t\t\t\t\t       (c->vc_font.height <\n\t\t\t\t\t\t10 ? 1 : 2));\n\t\t\tbreak;\n\t\tcase CUR_TWO_THIRDS:\n\t\t\tvgacon_set_cursor_size(c->state.x,\n\t\t\t\t\t       c->vc_font.height / 3,\n\t\t\t\t\t       c->vc_font.height -\n\t\t\t\t\t       (c->vc_font.height <\n\t\t\t\t\t\t10 ? 1 : 2));\n\t\t\tbreak;\n\t\tcase CUR_LOWER_THIRD:\n\t\t\tvgacon_set_cursor_size(c->state.x,\n\t\t\t\t\t       (c->vc_font.height * 2) / 3,\n\t\t\t\t\t       c->vc_font.height -\n\t\t\t\t\t       (c->vc_font.height <\n\t\t\t\t\t\t10 ? 1 : 2));\n\t\t\tbreak;\n\t\tcase CUR_LOWER_HALF:\n\t\t\tvgacon_set_cursor_size(c->state.x,\n\t\t\t\t\t       c->vc_font.height / 2,\n\t\t\t\t\t       c->vc_font.height -\n\t\t\t\t\t       (c->vc_font.height <\n\t\t\t\t\t\t10 ? 1 : 2));\n\t\t\tbreak;\n\t\tcase CUR_NONE:\n\t\t\tif (vga_video_type >= VIDEO_TYPE_VGAC)\n\t\t\t\tvgacon_set_cursor_size(c->state.x, 31, 30);\n\t\t\telse\n\t\t\t\tvgacon_set_cursor_size(c->state.x, 31, 31);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvgacon_set_cursor_size(c->state.x, 1,\n\t\t\t\t\t       c->vc_font.height);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int vgacon_doresize(struct vc_data *c,\n\t\tunsigned int width, unsigned int height)\n{\n\tunsigned long flags;\n\tunsigned int scanlines = height * c->vc_font.height;\n\tu8 scanlines_lo = 0, r7 = 0, vsync_end = 0, mode, max_scan;\n\n\traw_spin_lock_irqsave(&vga_lock, flags);\n\n\tvgacon_xres = width * VGA_FONTWIDTH;\n\tvgacon_yres = height * c->vc_font.height;\n\tif (vga_video_type >= VIDEO_TYPE_VGAC) {\n\t\toutb_p(VGA_CRTC_MAX_SCAN, vga_video_port_reg);\n\t\tmax_scan = inb_p(vga_video_port_val);\n\n\t\tif (max_scan & 0x80)\n\t\t\tscanlines <<= 1;\n\n\t\toutb_p(VGA_CRTC_MODE, vga_video_port_reg);\n\t\tmode = inb_p(vga_video_port_val);\n\n\t\tif (mode & 0x04)\n\t\t\tscanlines >>= 1;\n\n\t\tscanlines -= 1;\n\t\tscanlines_lo = scanlines & 0xff;\n\n\t\toutb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);\n\t\tr7 = inb_p(vga_video_port_val) & ~0x42;\n\n\t\tif (scanlines & 0x100)\n\t\t\tr7 |= 0x02;\n\t\tif (scanlines & 0x200)\n\t\t\tr7 |= 0x40;\n\n\t\t/* deprotect registers */\n\t\toutb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);\n\t\tvsync_end = inb_p(vga_video_port_val);\n\t\toutb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);\n\t\toutb_p(vsync_end & ~0x80, vga_video_port_val);\n\t}\n\n\toutb_p(VGA_CRTC_H_DISP, vga_video_port_reg);\n\toutb_p(width - 1, vga_video_port_val);\n\toutb_p(VGA_CRTC_OFFSET, vga_video_port_reg);\n\toutb_p(width >> 1, vga_video_port_val);\n\n\tif (vga_video_type >= VIDEO_TYPE_VGAC) {\n\t\toutb_p(VGA_CRTC_V_DISP_END, vga_video_port_reg);\n\t\toutb_p(scanlines_lo, vga_video_port_val);\n\t\toutb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);\n\t\toutb_p(r7,vga_video_port_val);\n\n\t\t/* reprotect registers */\n\t\toutb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);\n\t\toutb_p(vsync_end, vga_video_port_val);\n\t}\n\n\traw_spin_unlock_irqrestore(&vga_lock, flags);\n\treturn 0;\n}\n\nstatic int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\t/*\n\t * We need to save screen size here as it's the only way\n\t * we can spot the screen has been resized and we need to\n\t * set size of freshly allocated screens ourselves.\n\t */\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\n\t/* We can only copy out the size of the video buffer here,\n\t * otherwise we get into VGA BIOS */\n\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\n\tvgacon_scrollback_switch(c->vc_num);\n\treturn 0;\t\t/* Redrawing not needed */\n}\n\nstatic void vga_set_palette(struct vc_data *vc, const unsigned char *table)\n{\n\tint i, j;\n\n\tvga_w(vgastate.vgabase, VGA_PEL_MSK, 0xff);\n\tfor (i = j = 0; i < 16; i++) {\n\t\tvga_w(vgastate.vgabase, VGA_PEL_IW, table[i]);\n\t\tvga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);\n\t\tvga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);\n\t\tvga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);\n\t}\n}\n\nstatic void vgacon_set_palette(struct vc_data *vc, const unsigned char *table)\n{\n\tif (vga_video_type != VIDEO_TYPE_VGAC || vga_palette_blanked\n\t    || !con_is_visible(vc))\n\t\treturn;\n\tvga_set_palette(vc, table);\n}\n\n/* structure holding original VGA register settings */\nstatic struct {\n\tunsigned char SeqCtrlIndex;\t/* Sequencer Index reg.   */\n\tunsigned char CrtCtrlIndex;\t/* CRT-Contr. Index reg.  */\n\tunsigned char CrtMiscIO;\t/* Miscellaneous register */\n\tunsigned char HorizontalTotal;\t/* CRT-Controller:00h */\n\tunsigned char HorizDisplayEnd;\t/* CRT-Controller:01h */\n\tunsigned char StartHorizRetrace;\t/* CRT-Controller:04h */\n\tunsigned char EndHorizRetrace;\t/* CRT-Controller:05h */\n\tunsigned char Overflow;\t/* CRT-Controller:07h */\n\tunsigned char StartVertRetrace;\t/* CRT-Controller:10h */\n\tunsigned char EndVertRetrace;\t/* CRT-Controller:11h */\n\tunsigned char ModeControl;\t/* CRT-Controller:17h */\n\tunsigned char ClockingMode;\t/* Seq-Controller:01h */\n} vga_state;\n\nstatic void vga_vesa_blank(struct vgastate *state, int mode)\n{\n\t/* save original values of VGA controller registers */\n\tif (!vga_vesa_blanked) {\n\t\traw_spin_lock_irq(&vga_lock);\n\t\tvga_state.SeqCtrlIndex = vga_r(state->vgabase, VGA_SEQ_I);\n\t\tvga_state.CrtCtrlIndex = inb_p(vga_video_port_reg);\n\t\tvga_state.CrtMiscIO = vga_r(state->vgabase, VGA_MIS_R);\n\t\traw_spin_unlock_irq(&vga_lock);\n\n\t\toutb_p(0x00, vga_video_port_reg);\t/* HorizontalTotal */\n\t\tvga_state.HorizontalTotal = inb_p(vga_video_port_val);\n\t\toutb_p(0x01, vga_video_port_reg);\t/* HorizDisplayEnd */\n\t\tvga_state.HorizDisplayEnd = inb_p(vga_video_port_val);\n\t\toutb_p(0x04, vga_video_port_reg);\t/* StartHorizRetrace */\n\t\tvga_state.StartHorizRetrace = inb_p(vga_video_port_val);\n\t\toutb_p(0x05, vga_video_port_reg);\t/* EndHorizRetrace */\n\t\tvga_state.EndHorizRetrace = inb_p(vga_video_port_val);\n\t\toutb_p(0x07, vga_video_port_reg);\t/* Overflow */\n\t\tvga_state.Overflow = inb_p(vga_video_port_val);\n\t\toutb_p(0x10, vga_video_port_reg);\t/* StartVertRetrace */\n\t\tvga_state.StartVertRetrace = inb_p(vga_video_port_val);\n\t\toutb_p(0x11, vga_video_port_reg);\t/* EndVertRetrace */\n\t\tvga_state.EndVertRetrace = inb_p(vga_video_port_val);\n\t\toutb_p(0x17, vga_video_port_reg);\t/* ModeControl */\n\t\tvga_state.ModeControl = inb_p(vga_video_port_val);\n\t\tvga_state.ClockingMode = vga_rseq(state->vgabase, VGA_SEQ_CLOCK_MODE);\n\t}\n\n\t/* assure that video is enabled */\n\t/* \"0x20\" is VIDEO_ENABLE_bit in register 01 of sequencer */\n\traw_spin_lock_irq(&vga_lock);\n\tvga_wseq(state->vgabase, VGA_SEQ_CLOCK_MODE, vga_state.ClockingMode | 0x20);\n\n\t/* test for vertical retrace in process.... */\n\tif ((vga_state.CrtMiscIO & 0x80) == 0x80)\n\t\tvga_w(state->vgabase, VGA_MIS_W, vga_state.CrtMiscIO & 0xEF);\n\n\t/*\n\t * Set <End of vertical retrace> to minimum (0) and\n\t * <Start of vertical Retrace> to maximum (incl. overflow)\n\t * Result: turn off vertical sync (VSync) pulse.\n\t */\n\tif (mode & VESA_VSYNC_SUSPEND) {\n\t\toutb_p(0x10, vga_video_port_reg);\t/* StartVertRetrace */\n\t\toutb_p(0xff, vga_video_port_val);\t/* maximum value */\n\t\toutb_p(0x11, vga_video_port_reg);\t/* EndVertRetrace */\n\t\toutb_p(0x40, vga_video_port_val);\t/* minimum (bits 0..3)  */\n\t\toutb_p(0x07, vga_video_port_reg);\t/* Overflow */\n\t\toutb_p(vga_state.Overflow | 0x84, vga_video_port_val);\t/* bits 9,10 of vert. retrace */\n\t}\n\n\tif (mode & VESA_HSYNC_SUSPEND) {\n\t\t/*\n\t\t * Set <End of horizontal retrace> to minimum (0) and\n\t\t *  <Start of horizontal Retrace> to maximum\n\t\t * Result: turn off horizontal sync (HSync) pulse.\n\t\t */\n\t\toutb_p(0x04, vga_video_port_reg);\t/* StartHorizRetrace */\n\t\toutb_p(0xff, vga_video_port_val);\t/* maximum */\n\t\toutb_p(0x05, vga_video_port_reg);\t/* EndHorizRetrace */\n\t\toutb_p(0x00, vga_video_port_val);\t/* minimum (0) */\n\t}\n\n\t/* restore both index registers */\n\tvga_w(state->vgabase, VGA_SEQ_I, vga_state.SeqCtrlIndex);\n\toutb_p(vga_state.CrtCtrlIndex, vga_video_port_reg);\n\traw_spin_unlock_irq(&vga_lock);\n}\n\nstatic void vga_vesa_unblank(struct vgastate *state)\n{\n\t/* restore original values of VGA controller registers */\n\traw_spin_lock_irq(&vga_lock);\n\tvga_w(state->vgabase, VGA_MIS_W, vga_state.CrtMiscIO);\n\n\toutb_p(0x00, vga_video_port_reg);\t/* HorizontalTotal */\n\toutb_p(vga_state.HorizontalTotal, vga_video_port_val);\n\toutb_p(0x01, vga_video_port_reg);\t/* HorizDisplayEnd */\n\toutb_p(vga_state.HorizDisplayEnd, vga_video_port_val);\n\toutb_p(0x04, vga_video_port_reg);\t/* StartHorizRetrace */\n\toutb_p(vga_state.StartHorizRetrace, vga_video_port_val);\n\toutb_p(0x05, vga_video_port_reg);\t/* EndHorizRetrace */\n\toutb_p(vga_state.EndHorizRetrace, vga_video_port_val);\n\toutb_p(0x07, vga_video_port_reg);\t/* Overflow */\n\toutb_p(vga_state.Overflow, vga_video_port_val);\n\toutb_p(0x10, vga_video_port_reg);\t/* StartVertRetrace */\n\toutb_p(vga_state.StartVertRetrace, vga_video_port_val);\n\toutb_p(0x11, vga_video_port_reg);\t/* EndVertRetrace */\n\toutb_p(vga_state.EndVertRetrace, vga_video_port_val);\n\toutb_p(0x17, vga_video_port_reg);\t/* ModeControl */\n\toutb_p(vga_state.ModeControl, vga_video_port_val);\n\t/* ClockingMode */\n\tvga_wseq(state->vgabase, VGA_SEQ_CLOCK_MODE, vga_state.ClockingMode);\n\n\t/* restore index/control registers */\n\tvga_w(state->vgabase, VGA_SEQ_I, vga_state.SeqCtrlIndex);\n\toutb_p(vga_state.CrtCtrlIndex, vga_video_port_reg);\n\traw_spin_unlock_irq(&vga_lock);\n}\n\nstatic void vga_pal_blank(struct vgastate *state)\n{\n\tint i;\n\n\tvga_w(state->vgabase, VGA_PEL_MSK, 0xff);\n\tfor (i = 0; i < 16; i++) {\n\t\tvga_w(state->vgabase, VGA_PEL_IW, i);\n\t\tvga_w(state->vgabase, VGA_PEL_D, 0);\n\t\tvga_w(state->vgabase, VGA_PEL_D, 0);\n\t\tvga_w(state->vgabase, VGA_PEL_D, 0);\n\t}\n}\n\nstatic int vgacon_blank(struct vc_data *c, int blank, int mode_switch)\n{\n\tswitch (blank) {\n\tcase 0:\t\t/* Unblank */\n\t\tif (vga_vesa_blanked) {\n\t\t\tvga_vesa_unblank(&vgastate);\n\t\t\tvga_vesa_blanked = 0;\n\t\t}\n\t\tif (vga_palette_blanked) {\n\t\t\tvga_set_palette(c, color_table);\n\t\t\tvga_palette_blanked = false;\n\t\t\treturn 0;\n\t\t}\n\t\tvga_is_gfx = false;\n\t\t/* Tell console.c that it has to restore the screen itself */\n\t\treturn 1;\n\tcase 1:\t\t/* Normal blanking */\n\tcase -1:\t/* Obsolete */\n\t\tif (!mode_switch && vga_video_type == VIDEO_TYPE_VGAC) {\n\t\t\tvga_pal_blank(&vgastate);\n\t\t\tvga_palette_blanked = true;\n\t\t\treturn 0;\n\t\t}\n\t\tvgacon_set_origin(c);\n\t\tscr_memsetw((void *) vga_vram_base, BLANK,\n\t\t\t    c->vc_screenbuf_size);\n\t\tif (mode_switch)\n\t\t\tvga_is_gfx = true;\n\t\treturn 1;\n\tdefault:\t\t/* VESA blanking */\n\t\tif (vga_video_type == VIDEO_TYPE_VGAC) {\n\t\t\tvga_vesa_blank(&vgastate, blank - 1);\n\t\t\tvga_vesa_blanked = blank;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\n/*\n * PIO_FONT support.\n *\n * The font loading code goes back to the codepage package by\n * Joel Hoffman (joel@wam.umd.edu). (He reports that the original\n * reference is: \"From: p. 307 of _Programmer's Guide to PC & PS/2\n * Video Systems_ by Richard Wilton. 1987.  Microsoft Press\".)\n *\n * Change for certain monochrome monitors by Yury Shevchuck\n * (sizif@botik.yaroslavl.su).\n */\n\n#define colourmap 0xa0000\n/* Pauline Middelink <middelin@polyware.iaf.nl> reports that we\n   should use 0xA0000 for the bwmap as well.. */\n#define blackwmap 0xa0000\n#define cmapsz 8192\n\nstatic int vgacon_do_font_op(struct vgastate *state, char *arg, int set,\n\t\tbool ch512)\n{\n\tunsigned short video_port_status = vga_video_port_reg + 6;\n\tint font_select = 0x00, beg, i;\n\tchar *charmap;\n\tbool clear_attribs = false;\n\tif (vga_video_type != VIDEO_TYPE_EGAM) {\n\t\tcharmap = (char *) VGA_MAP_MEM(colourmap, 0);\n\t\tbeg = 0x0e;\n\t} else {\n\t\tcharmap = (char *) VGA_MAP_MEM(blackwmap, 0);\n\t\tbeg = 0x0a;\n\t}\n\n#ifdef BROKEN_GRAPHICS_PROGRAMS\n\t/*\n\t * All fonts are loaded in slot 0 (0:1 for 512 ch)\n\t */\n\n\tif (!arg)\n\t\treturn -EINVAL;\t/* Return to default font not supported */\n\n\tvga_font_is_default = false;\n\tfont_select = ch512 ? 0x04 : 0x00;\n#else\n\t/*\n\t * The default font is kept in slot 0 and is never touched.\n\t * A custom font is loaded in slot 2 (256 ch) or 2:3 (512 ch)\n\t */\n\n\tif (set) {\n\t\tvga_font_is_default = !arg;\n\t\tif (!arg)\n\t\t\tch512 = false;\t/* Default font is always 256 */\n\t\tfont_select = arg ? (ch512 ? 0x0e : 0x0a) : 0x00;\n\t}\n\n\tif (!vga_font_is_default)\n\t\tcharmap += 4 * cmapsz;\n#endif\n\n\traw_spin_lock_irq(&vga_lock);\n\t/* First, the Sequencer */\n\tvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x1);\n\t/* CPU writes only to map 2 */\n\tvga_wseq(state->vgabase, VGA_SEQ_PLANE_WRITE, 0x04);\t\n\t/* Sequential addressing */\n\tvga_wseq(state->vgabase, VGA_SEQ_MEMORY_MODE, 0x07);\t\n\t/* Clear synchronous reset */\n\tvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x03);\n\n\t/* Now, the graphics controller, select map 2 */\n\tvga_wgfx(state->vgabase, VGA_GFX_PLANE_READ, 0x02);\t\t\n\t/* disable odd-even addressing */\n\tvga_wgfx(state->vgabase, VGA_GFX_MODE, 0x00);\n\t/* map start at A000:0000 */\n\tvga_wgfx(state->vgabase, VGA_GFX_MISC, 0x00);\n\traw_spin_unlock_irq(&vga_lock);\n\n\tif (arg) {\n\t\tif (set)\n\t\t\tfor (i = 0; i < cmapsz; i++) {\n\t\t\t\tvga_writeb(arg[i], charmap + i);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\telse\n\t\t\tfor (i = 0; i < cmapsz; i++) {\n\t\t\t\targ[i] = vga_readb(charmap + i);\n\t\t\t\tcond_resched();\n\t\t\t}\n\n\t\t/*\n\t\t * In 512-character mode, the character map is not contiguous if\n\t\t * we want to remain EGA compatible -- which we do\n\t\t */\n\n\t\tif (ch512) {\n\t\t\tcharmap += 2 * cmapsz;\n\t\t\targ += cmapsz;\n\t\t\tif (set)\n\t\t\t\tfor (i = 0; i < cmapsz; i++) {\n\t\t\t\t\tvga_writeb(arg[i], charmap + i);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tfor (i = 0; i < cmapsz; i++) {\n\t\t\t\t\targ[i] = vga_readb(charmap + i);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t}\n\t}\n\n\traw_spin_lock_irq(&vga_lock);\n\t/* First, the sequencer, Synchronous reset */\n\tvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x01);\t\n\t/* CPU writes to maps 0 and 1 */\n\tvga_wseq(state->vgabase, VGA_SEQ_PLANE_WRITE, 0x03);\n\t/* odd-even addressing */\n\tvga_wseq(state->vgabase, VGA_SEQ_MEMORY_MODE, 0x03);\n\t/* Character Map Select */\n\tif (set)\n\t\tvga_wseq(state->vgabase, VGA_SEQ_CHARACTER_MAP, font_select);\n\t/* clear synchronous reset */\n\tvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x03);\n\n\t/* Now, the graphics controller, select map 0 for CPU */\n\tvga_wgfx(state->vgabase, VGA_GFX_PLANE_READ, 0x00);\n\t/* enable even-odd addressing */\n\tvga_wgfx(state->vgabase, VGA_GFX_MODE, 0x10);\n\t/* map starts at b800:0 or b000:0 */\n\tvga_wgfx(state->vgabase, VGA_GFX_MISC, beg);\n\n\t/* if 512 char mode is already enabled don't re-enable it. */\n\tif ((set) && (ch512 != vga_512_chars)) {\n\t\tvga_512_chars = ch512;\n\t\t/* 256-char: enable intensity bit\n\t\t   512-char: disable intensity bit */\n\t\tinb_p(video_port_status);\t/* clear address flip-flop */\n\t\t/* color plane enable register */\n\t\tvga_wattr(state->vgabase, VGA_ATC_PLANE_ENABLE, ch512 ? 0x07 : 0x0f);\n\t\t/* Wilton (1987) mentions the following; I don't know what\n\t\t   it means, but it works, and it appears necessary */\n\t\tinb_p(video_port_status);\n\t\tvga_wattr(state->vgabase, VGA_AR_ENABLE_DISPLAY, 0);\t\n\t\tclear_attribs = true;\n\t}\n\traw_spin_unlock_irq(&vga_lock);\n\n\tif (clear_attribs) {\n\t\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\t\tstruct vc_data *c = vc_cons[i].d;\n\t\t\tif (c && c->vc_sw == &vga_con) {\n\t\t\t\t/* force hi font mask to 0, so we always clear\n\t\t\t\t   the bit on either transition */\n\t\t\t\tc->vc_hi_font_mask = 0x00;\n\t\t\t\tclear_buffer_attributes(c);\n\t\t\t\tc->vc_hi_font_mask = ch512 ? 0x0800 : 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * Adjust the screen to fit a font of a certain height\n */\nstatic int vgacon_adjust_height(struct vc_data *vc, unsigned fontheight)\n{\n\tunsigned char ovr, vde, fsr;\n\tint rows, maxscan, i;\n\n\trows = vc->vc_scan_lines / fontheight;\t/* Number of video rows we end up with */\n\tmaxscan = rows * fontheight - 1;\t/* Scan lines to actually display-1 */\n\n\t/* Reprogram the CRTC for the new font size\n\t   Note: the attempt to read the overflow register will fail\n\t   on an EGA, but using 0xff for the previous value appears to\n\t   be OK for EGA text modes in the range 257-512 scan lines, so I\n\t   guess we don't need to worry about it.\n\n\t   The same applies for the spill bits in the font size and cursor\n\t   registers; they are write-only on EGA, but it appears that they\n\t   are all don't care bits on EGA, so I guess it doesn't matter. */\n\n\traw_spin_lock_irq(&vga_lock);\n\toutb_p(0x07, vga_video_port_reg);\t/* CRTC overflow register */\n\tovr = inb_p(vga_video_port_val);\n\toutb_p(0x09, vga_video_port_reg);\t/* Font size register */\n\tfsr = inb_p(vga_video_port_val);\n\traw_spin_unlock_irq(&vga_lock);\n\n\tvde = maxscan & 0xff;\t/* Vertical display end reg */\n\tovr = (ovr & 0xbd) +\t/* Overflow register */\n\t    ((maxscan & 0x100) >> 7) + ((maxscan & 0x200) >> 3);\n\tfsr = (fsr & 0xe0) + (fontheight - 1);\t/*  Font size register */\n\n\traw_spin_lock_irq(&vga_lock);\n\toutb_p(0x07, vga_video_port_reg);\t/* CRTC overflow register */\n\toutb_p(ovr, vga_video_port_val);\n\toutb_p(0x09, vga_video_port_reg);\t/* Font size */\n\toutb_p(fsr, vga_video_port_val);\n\toutb_p(0x12, vga_video_port_reg);\t/* Vertical display limit */\n\toutb_p(vde, vga_video_port_val);\n\traw_spin_unlock_irq(&vga_lock);\n\tvga_video_font_height = fontheight;\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\tstruct vc_data *c = vc_cons[i].d;\n\n\t\tif (c && c->vc_sw == &vga_con) {\n\t\t\tif (con_is_visible(c)) {\n\t\t\t        /* void size to cause regs to be rewritten */\n\t\t\t\tcursor_size_lastfrom = 0;\n\t\t\t\tcursor_size_lastto = 0;\n\t\t\t\tc->vc_sw->con_cursor(c, CM_DRAW);\n\t\t\t}\n\t\t\tc->vc_font.height = fontheight;\n\t\t\tvc_resize(c, 0, rows);\t/* Adjust console size */\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int vgacon_font_set(struct vc_data *c, struct console_font *font,\n\t\t\t   unsigned int flags)\n{\n\tunsigned charcount = font->charcount;\n\tint rc;\n\n\tif (vga_video_type < VIDEO_TYPE_EGAM)\n\t\treturn -EINVAL;\n\n\tif (font->width != VGA_FONTWIDTH ||\n\t    (charcount != 256 && charcount != 512))\n\t\treturn -EINVAL;\n\n\trc = vgacon_do_font_op(&vgastate, font->data, 1, charcount == 512);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!(flags & KD_FONT_FLAG_DONT_RECALC))\n\t\trc = vgacon_adjust_height(c, font->height);\n\treturn rc;\n}\n\nstatic int vgacon_font_get(struct vc_data *c, struct console_font *font)\n{\n\tif (vga_video_type < VIDEO_TYPE_EGAM)\n\t\treturn -EINVAL;\n\n\tfont->width = VGA_FONTWIDTH;\n\tfont->height = c->vc_font.height;\n\tfont->charcount = vga_512_chars ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\treturn vgacon_do_font_op(&vgastate, font->data, 0, vga_512_chars);\n}\n\nstatic int vgacon_resize(struct vc_data *c, unsigned int width,\n\t\t\t unsigned int height, unsigned int user)\n{\n\tif ((width << 1) * height > vga_vram_size)\n\t\treturn -EINVAL;\n\n\tif (width % 2 || width > screen_info.orig_video_cols ||\n\t    height > (screen_info.orig_video_lines * vga_default_font_height)/\n\t    c->vc_font.height)\n\t\t/* let svgatextmode tinker with video timings and\n\t\t   return success */\n\t\treturn (user) ? 0 : -EINVAL;\n\n\tif (con_is_visible(c) && !vga_is_gfx) /* who knows */\n\t\tvgacon_doresize(c, width, height);\n\treturn 0;\n}\n\nstatic int vgacon_set_origin(struct vc_data *c)\n{\n\tif (vga_is_gfx ||\t/* We don't play origin tricks in graphic modes */\n\t    (console_blanked && !vga_palette_blanked))\t/* Nor we write to blanked screens */\n\t\treturn 0;\n\tc->vc_origin = c->vc_visible_origin = vga_vram_base;\n\tvga_set_mem_top(c);\n\tvga_rolled_over = 0;\n\treturn 1;\n}\n\nstatic void vgacon_save_screen(struct vc_data *c)\n{\n\tstatic int vga_bootup_console = 0;\n\n\tif (!vga_bootup_console) {\n\t\t/* This is a gross hack, but here is the only place we can\n\t\t * set bootup console parameters without messing up generic\n\t\t * console initialization routines.\n\t\t */\n\t\tvga_bootup_console = 1;\n\t\tc->state.x = screen_info.orig_x;\n\t\tc->state.y = screen_info.orig_y;\n\t}\n\n\t/* We can't copy in more than the size of the video buffer,\n\t * or we'll be copying in VGA BIOS */\n\n\tif (!vga_is_gfx)\n\t\tscr_memcpyw((u16 *) c->vc_screenbuf, (u16 *) c->vc_origin,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ? vga_vram_size : c->vc_screenbuf_size);\n}\n\nstatic bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tunsigned long oldo;\n\tunsigned int delta;\n\n\tif (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)\n\t\treturn false;\n\n\tif (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)\n\t\treturn false;\n\n\tvgacon_restore_screen(c);\n\toldo = c->vc_origin;\n\tdelta = lines * c->vc_size_row;\n\tif (dir == SM_UP) {\n\t\tvgacon_scrollback_update(c, t, lines);\n\t\tif (c->vc_scr_end + delta >= vga_vram_end) {\n\t\t\tscr_memcpyw((u16 *) vga_vram_base,\n\t\t\t\t    (u16 *) (oldo + delta),\n\t\t\t\t    c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_base;\n\t\t\tvga_rolled_over = oldo - vga_vram_base;\n\t\t} else\n\t\t\tc->vc_origin += delta;\n\t\tscr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -\n\t\t\t\t     delta), c->vc_video_erase_char,\n\t\t\t    delta);\n\t} else {\n\t\tif (oldo - delta < vga_vram_base) {\n\t\t\tscr_memmovew((u16 *) (vga_vram_end -\n\t\t\t\t\t      c->vc_screenbuf_size +\n\t\t\t\t\t      delta), (u16 *) oldo,\n\t\t\t\t     c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_end - c->vc_screenbuf_size;\n\t\t\tvga_rolled_over = 0;\n\t\t} else\n\t\t\tc->vc_origin -= delta;\n\t\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\t\tscr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,\n\t\t\t    delta);\n\t}\n\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\tc->vc_visible_origin = c->vc_origin;\n\tvga_set_mem_top(c);\n\tc->vc_pos = (c->vc_pos - oldo) + c->vc_origin;\n\treturn true;\n}\n\n/*\n *  The console `switch' structure for the VGA based console\n */\n\nstatic void vgacon_clear(struct vc_data *vc, int sy, int sx, int height,\n\t\t\t int width) { }\nstatic void vgacon_putc(struct vc_data *vc, int c, int ypos, int xpos) { }\nstatic void vgacon_putcs(struct vc_data *vc, const unsigned short *s,\n\t\t\t int count, int ypos, int xpos) { }\n\nconst struct consw vga_con = {\n\t.owner = THIS_MODULE,\n\t.con_startup = vgacon_startup,\n\t.con_init = vgacon_init,\n\t.con_deinit = vgacon_deinit,\n\t.con_clear = vgacon_clear,\n\t.con_putc = vgacon_putc,\n\t.con_putcs = vgacon_putcs,\n\t.con_cursor = vgacon_cursor,\n\t.con_scroll = vgacon_scroll,\n\t.con_switch = vgacon_switch,\n\t.con_blank = vgacon_blank,\n\t.con_font_set = vgacon_font_set,\n\t.con_font_get = vgacon_font_get,\n\t.con_resize = vgacon_resize,\n\t.con_set_palette = vgacon_set_palette,\n\t.con_scrolldelta = vgacon_scrolldelta,\n\t.con_set_origin = vgacon_set_origin,\n\t.con_save_screen = vgacon_save_screen,\n\t.con_build_attr = vgacon_build_attr,\n\t.con_invert_region = vgacon_invert_region,\n\t.con_flush_scrollback = vgacon_flush_scrollback,\n};\nEXPORT_SYMBOL(vga_con);\n\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["CONFIG_PPC64=y\nCONFIG_ALTIVEC=y\nCONFIG_SMP=y\nCONFIG_NR_CPUS=2\nCONFIG_SYSVIPC=y\nCONFIG_NO_HZ=y\nCONFIG_HIGH_RES_TIMERS=y\nCONFIG_BLK_DEV_INITRD=y\nCONFIG_PROFILING=y\nCONFIG_OPROFILE=y\nCONFIG_MODULES=y\nCONFIG_MODULE_UNLOAD=y\n# CONFIG_BLK_DEV_BSG is not set\nCONFIG_PARTITION_ADVANCED=y\nCONFIG_MAC_PARTITION=y\n# CONFIG_PPC_POWERNV is not set\n# CONFIG_PPC_PSERIES is not set\n# CONFIG_PPC_PMAC is not set\nCONFIG_PPC_PASEMI=y\nCONFIG_PPC_PASEMI_IOMMU=y\nCONFIG_CPU_FREQ=y\nCONFIG_CPU_FREQ_GOV_POWERSAVE=y\nCONFIG_CPU_FREQ_GOV_USERSPACE=y\nCONFIG_CPU_FREQ_GOV_ONDEMAND=y\nCONFIG_HZ_1000=y\nCONFIG_PPC_64K_PAGES=y\n# CONFIG_SECCOMP is not set\nCONFIG_PCI_MSI=y\nCONFIG_PCCARD=y\nCONFIG_ELECTRA_CF=y\nCONFIG_NET=y\nCONFIG_PACKET=y\nCONFIG_UNIX=y\nCONFIG_XFRM_USER=y\nCONFIG_NET_KEY=y\nCONFIG_INET=y\nCONFIG_IP_MULTICAST=y\nCONFIG_IP_PNP=y\nCONFIG_IP_PNP_DHCP=y\nCONFIG_IP_PNP_BOOTP=y\nCONFIG_IP_PNP_RARP=y\nCONFIG_NET_IPIP=y\nCONFIG_SYN_COOKIES=y\nCONFIG_INET_AH=y\nCONFIG_INET_ESP=y\n# CONFIG_IPV6 is not set\nCONFIG_DEVTMPFS=y\nCONFIG_DEVTMPFS_MOUNT=y\nCONFIG_MTD=y\nCONFIG_MTD_BLOCK=y\nCONFIG_MTD_SLRAM=y\nCONFIG_MTD_PHRAM=y\nCONFIG_MTD_RAW_NAND=y\nCONFIG_MTD_NAND_PASEMI=y\nCONFIG_BLK_DEV_LOOP=y\nCONFIG_BLK_DEV_RAM=y\nCONFIG_BLK_DEV_RAM_SIZE=16384\nCONFIG_EEPROM_LEGACY=y\nCONFIG_BLK_DEV_SD=y\nCONFIG_CHR_DEV_ST=y\nCONFIG_BLK_DEV_SR=y\nCONFIG_CHR_DEV_SG=y\nCONFIG_CHR_DEV_SCH=y\nCONFIG_SCSI_CONSTANTS=y\nCONFIG_SCSI_LOGGING=y\nCONFIG_ATA=y\nCONFIG_SATA_SIL24=y\nCONFIG_SATA_MV=y\nCONFIG_PATA_PCMCIA=y\nCONFIG_PATA_PLATFORM=y\nCONFIG_PATA_OF_PLATFORM=y\nCONFIG_ATA_GENERIC=y\nCONFIG_MD=y\nCONFIG_BLK_DEV_MD=y\nCONFIG_MD_LINEAR=y\nCONFIG_MD_RAID0=y\nCONFIG_MD_RAID1=y\nCONFIG_MD_RAID10=y\nCONFIG_MD_RAID456=y\nCONFIG_BLK_DEV_DM=y\nCONFIG_DM_CRYPT=y\nCONFIG_NETDEVICES=y\nCONFIG_DUMMY=y\nCONFIG_TIGON3=y\nCONFIG_E1000=y\nCONFIG_PASEMI_MAC=y\nCONFIG_MARVELL_PHY=y\nCONFIG_INPUT_JOYDEV=y\nCONFIG_INPUT_EVDEV=y\n# CONFIG_KEYBOARD_ATKBD is not set\n# CONFIG_MOUSE_PS2 is not set\n# CONFIG_SERIO is not set\nCONFIG_LEGACY_PTY_COUNT=4\nCONFIG_SERIAL_8250=y\nCONFIG_SERIAL_8250_CONSOLE=y\nCONFIG_HW_RANDOM=y\nCONFIG_RAW_DRIVER=y\nCONFIG_I2C_CHARDEV=y\nCONFIG_I2C_PASEMI=y\nCONFIG_SENSORS_LM85=y\nCONFIG_SENSORS_LM90=y\nCONFIG_DRM=y\nCONFIG_DRM_RADEON=y\nCONFIG_FIRMWARE_EDID=y\nCONFIG_FB_TILEBLITTING=y\nCONFIG_FB_VGA16=y\nCONFIG_FB_NVIDIA=y\nCONFIG_FB_NVIDIA_I2C=y\nCONFIG_FB_RADEON=y\n# CONFIG_LCD_CLASS_DEVICE is not set\nCONFIG_LOGO=y\nCONFIG_SOUND=y\nCONFIG_SND=y\nCONFIG_SND_OSSEMUL=y\nCONFIG_SND_MIXER_OSS=y\nCONFIG_SND_PCM_OSS=y\nCONFIG_SND_SEQUENCER=y\nCONFIG_SND_SEQUENCER_OSS=y\nCONFIG_SND_USB_AUDIO=y\nCONFIG_SND_USB_USX2Y=y\nCONFIG_HID_DRAGONRISE=y\nCONFIG_HID_GYRATION=y\nCONFIG_HID_TWINHAN=y\nCONFIG_HID_NTRIG=y\nCONFIG_HID_PANTHERLORD=y\nCONFIG_HID_PETALYNX=y\nCONFIG_HID_SAMSUNG=y\nCONFIG_HID_SUNPLUS=y\nCONFIG_HID_GREENASIA=y\nCONFIG_HID_SMARTJOYPLUS=y\nCONFIG_HID_TOPSEED=y\nCONFIG_HID_THRUSTMASTER=y\nCONFIG_HID_ZEROPLUS=y\nCONFIG_USB=y\nCONFIG_USB_EHCI_HCD=y\nCONFIG_USB_OHCI_HCD=y\nCONFIG_USB_UHCI_HCD=y\nCONFIG_USB_SL811_HCD=y\nCONFIG_USB_STORAGE=y\nCONFIG_EDAC=y\nCONFIG_EDAC_PASEMI=y\nCONFIG_RTC_CLASS=y\nCONFIG_RTC_DRV_DS1307=y\nCONFIG_RAS=y\nCONFIG_EXT2_FS=y\nCONFIG_EXT2_FS_XATTR=y\nCONFIG_EXT2_FS_POSIX_ACL=y\nCONFIG_EXT4_FS=y\nCONFIG_AUTOFS4_FS=y\nCONFIG_ISO9660_FS=y\nCONFIG_UDF_FS=y\nCONFIG_MSDOS_FS=y\nCONFIG_VFAT_FS=y\nCONFIG_PROC_KCORE=y\nCONFIG_TMPFS=y\nCONFIG_HUGETLBFS=y\nCONFIG_CONFIGFS_FS=y\nCONFIG_JFFS2_FS=y\nCONFIG_NFS_FS=y\nCONFIG_ROOT_NFS=y\nCONFIG_NFSD=y\nCONFIG_NFSD_V4=y\nCONFIG_NLS_CODEPAGE_437=y\nCONFIG_NLS_ISO8859_1=y\nCONFIG_CRC_CCITT=y\nCONFIG_PRINTK_TIME=y\nCONFIG_MAGIC_SYSRQ=y\nCONFIG_DEBUG_KERNEL=y\nCONFIG_DETECT_HUNG_TASK=y\n# CONFIG_SCHED_DEBUG is not set\nCONFIG_XMON=y\nCONFIG_XMON_DEFAULT=y\nCONFIG_CRYPTO_MD4=y\nCONFIG_CRYPTO_SHA512=y\nCONFIG_CRYPTO_BLOWFISH=y\n", "CONFIG_FSL_EMB_PERFMON=y\n# CONFIG_LOCALVERSION_AUTO is not set\nCONFIG_SYSVIPC=y\nCONFIG_POSIX_MQUEUE=y\nCONFIG_AUDIT=y\nCONFIG_NO_HZ=y\nCONFIG_HIGH_RES_TIMERS=y\nCONFIG_BSD_PROCESS_ACCT=y\nCONFIG_TASKSTATS=y\nCONFIG_TASK_DELAY_ACCT=y\nCONFIG_TASK_XACCT=y\nCONFIG_TASK_IO_ACCOUNTING=y\nCONFIG_CGROUPS=y\nCONFIG_CGROUP_SCHED=y\nCONFIG_RT_GROUP_SCHED=y\nCONFIG_CGROUP_DEVICE=y\nCONFIG_CGROUP_CPUACCT=y\nCONFIG_USER_NS=y\nCONFIG_BLK_DEV_INITRD=y\n# CONFIG_COMPAT_BRK is not set\nCONFIG_PROFILING=y\nCONFIG_OPROFILE=m\nCONFIG_KPROBES=y\nCONFIG_MODULES=y\nCONFIG_MODULE_UNLOAD=y\nCONFIG_MODULE_SRCVERSION_ALL=y\nCONFIG_BLK_DEV_INTEGRITY=y\nCONFIG_PARTITION_ADVANCED=y\nCONFIG_OSF_PARTITION=y\nCONFIG_AMIGA_PARTITION=y\nCONFIG_BSD_DISKLABEL=y\nCONFIG_MINIX_SUBPARTITION=y\nCONFIG_SOLARIS_X86_PARTITION=y\nCONFIG_UNIXWARE_DISKLABEL=y\nCONFIG_SGI_PARTITION=y\nCONFIG_SUN_PARTITION=y\nCONFIG_KARMA_PARTITION=y\nCONFIG_PPC_MPC52xx=y\nCONFIG_PPC_EFIKA=y\nCONFIG_PPC_MPC5200_BUGFIX=y\nCONFIG_PPC_82xx=y\nCONFIG_MPC8272_ADS=y\nCONFIG_PQ2FADS=y\nCONFIG_EP8248E=y\nCONFIG_MGCOGE=y\nCONFIG_PPC_83xx=y\nCONFIG_MPC831x_RDB=y\nCONFIG_MPC832x_MDS=y\nCONFIG_MPC832x_RDB=y\nCONFIG_MPC834x_MDS=y\nCONFIG_MPC834x_ITX=y\nCONFIG_MPC836x_MDS=y\nCONFIG_MPC836x_RDK=y\nCONFIG_MPC837x_MDS=y\nCONFIG_MPC837x_RDB=y\nCONFIG_ASP834x=y\nCONFIG_PPC_86xx=y\nCONFIG_MPC8641_HPCN=y\nCONFIG_SBC8641D=y\nCONFIG_MPC8610_HPCD=y\nCONFIG_GEF_SBC610=y\nCONFIG_CPU_FREQ=y\nCONFIG_CPU_FREQ_STAT=y\nCONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y\nCONFIG_CPU_FREQ_GOV_PERFORMANCE=y\nCONFIG_CPU_FREQ_GOV_POWERSAVE=m\nCONFIG_CPU_FREQ_GOV_ONDEMAND=m\nCONFIG_CPU_FREQ_GOV_CONSERVATIVE=m\nCONFIG_CPU_FREQ_PMAC=y\nCONFIG_TAU=y\nCONFIG_TAU_AVERAGE=y\nCONFIG_QE_GPIO=y\nCONFIG_MCU_MPC8349EMITX=y\nCONFIG_HIGHMEM=y\nCONFIG_HZ_1000=y\nCONFIG_PREEMPT_VOLUNTARY=y\nCONFIG_BINFMT_MISC=y\nCONFIG_HIBERNATION=y\nCONFIG_PM_DEBUG=y\nCONFIG_ISA=y\nCONFIG_PCIEPORTBUS=y\nCONFIG_PCI_MSI=y\nCONFIG_PCCARD=y\nCONFIG_YENTA=y\nCONFIG_PD6729=m\nCONFIG_I82092=m\nCONFIG_I82365=m\nCONFIG_ADVANCED_OPTIONS=y\nCONFIG_NET=y\nCONFIG_PACKET=y\nCONFIG_UNIX=y\nCONFIG_XFRM_USER=y\nCONFIG_XFRM_SUB_POLICY=y\nCONFIG_XFRM_STATISTICS=y\nCONFIG_NET_KEY=m\nCONFIG_NET_KEY_MIGRATE=y\nCONFIG_INET=y\nCONFIG_IP_MULTICAST=y\nCONFIG_IP_ADVANCED_ROUTER=y\nCONFIG_IP_MULTIPLE_TABLES=y\nCONFIG_IP_ROUTE_MULTIPATH=y\nCONFIG_IP_ROUTE_VERBOSE=y\nCONFIG_NET_IPIP=m\nCONFIG_IP_MROUTE=y\nCONFIG_IP_PIMSM_V1=y\nCONFIG_IP_PIMSM_V2=y\nCONFIG_SYN_COOKIES=y\nCONFIG_INET_AH=m\nCONFIG_INET_ESP=m\nCONFIG_INET_IPCOMP=m\nCONFIG_INET_DIAG=m\nCONFIG_TCP_CONG_ADVANCED=y\nCONFIG_TCP_CONG_HSTCP=m\nCONFIG_TCP_CONG_HYBLA=m\nCONFIG_TCP_CONG_SCALABLE=m\nCONFIG_TCP_CONG_LP=m\nCONFIG_TCP_CONG_VENO=m\nCONFIG_TCP_CONG_YEAH=m\nCONFIG_TCP_CONG_ILLINOIS=m\nCONFIG_TCP_MD5SIG=y\nCONFIG_IPV6_ROUTER_PREF=y\nCONFIG_IPV6_ROUTE_INFO=y\nCONFIG_IPV6_OPTIMISTIC_DAD=y\nCONFIG_INET6_AH=m\nCONFIG_INET6_ESP=m\nCONFIG_INET6_IPCOMP=m\nCONFIG_IPV6_MIP6=m\nCONFIG_IPV6_TUNNEL=m\nCONFIG_IPV6_MULTIPLE_TABLES=y\nCONFIG_IPV6_SUBTREES=y\nCONFIG_IPV6_MROUTE=y\nCONFIG_IPV6_PIMSM_V2=y\nCONFIG_NETLABEL=y\nCONFIG_NETFILTER=y\nCONFIG_NF_CONNTRACK=m\nCONFIG_NF_CONNTRACK_SECMARK=y\nCONFIG_NF_CONNTRACK_EVENTS=y\nCONFIG_NF_CONNTRACK_AMANDA=m\nCONFIG_NF_CONNTRACK_FTP=m\nCONFIG_NF_CONNTRACK_H323=m\nCONFIG_NF_CONNTRACK_IRC=m\nCONFIG_NF_CONNTRACK_NETBIOS_NS=m\nCONFIG_NF_CONNTRACK_PPTP=m\nCONFIG_NF_CONNTRACK_SANE=m\nCONFIG_NF_CONNTRACK_SIP=m\nCONFIG_NF_CONNTRACK_TFTP=m\nCONFIG_NF_CT_NETLINK=m\nCONFIG_NETFILTER_XT_TARGET_CLASSIFY=m\nCONFIG_NETFILTER_XT_TARGET_CONNMARK=m\nCONFIG_NETFILTER_XT_TARGET_CONNSECMARK=m\nCONFIG_NETFILTER_XT_TARGET_DSCP=m\nCONFIG_NETFILTER_XT_TARGET_MARK=m\nCONFIG_NETFILTER_XT_TARGET_NFLOG=m\nCONFIG_NETFILTER_XT_TARGET_NFQUEUE=m\nCONFIG_NETFILTER_XT_TARGET_TPROXY=m\nCONFIG_NETFILTER_XT_TARGET_TRACE=m\nCONFIG_NETFILTER_XT_TARGET_SECMARK=m\nCONFIG_NETFILTER_XT_TARGET_TCPMSS=m\nCONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=m\nCONFIG_NETFILTER_XT_MATCH_COMMENT=m\nCONFIG_NETFILTER_XT_MATCH_CONNBYTES=m\nCONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m\nCONFIG_NETFILTER_XT_MATCH_CONNMARK=m\nCONFIG_NETFILTER_XT_MATCH_CONNTRACK=m\nCONFIG_NETFILTER_XT_MATCH_DSCP=m\nCONFIG_NETFILTER_XT_MATCH_ESP=m\nCONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m\nCONFIG_NETFILTER_XT_MATCH_HELPER=m\nCONFIG_NETFILTER_XT_MATCH_IPRANGE=m\nCONFIG_NETFILTER_XT_MATCH_LENGTH=m\nCONFIG_NETFILTER_XT_MATCH_LIMIT=m\nCONFIG_NETFILTER_XT_MATCH_MAC=m\nCONFIG_NETFILTER_XT_MATCH_MARK=m\nCONFIG_NETFILTER_XT_MATCH_MULTIPORT=m\nCONFIG_NETFILTER_XT_MATCH_OWNER=m\nCONFIG_NETFILTER_XT_MATCH_POLICY=m\nCONFIG_NETFILTER_XT_MATCH_PHYSDEV=m\nCONFIG_NETFILTER_XT_MATCH_PKTTYPE=m\nCONFIG_NETFILTER_XT_MATCH_QUOTA=m\nCONFIG_NETFILTER_XT_MATCH_RATEEST=m\nCONFIG_NETFILTER_XT_MATCH_REALM=m\nCONFIG_NETFILTER_XT_MATCH_RECENT=m\nCONFIG_NETFILTER_XT_MATCH_STATE=m\nCONFIG_NETFILTER_XT_MATCH_STATISTIC=m\nCONFIG_NETFILTER_XT_MATCH_STRING=m\nCONFIG_NETFILTER_XT_MATCH_TCPMSS=m\nCONFIG_NETFILTER_XT_MATCH_TIME=m\nCONFIG_NETFILTER_XT_MATCH_U32=m\nCONFIG_IP_NF_IPTABLES=m\nCONFIG_IP_NF_MATCH_AH=m\nCONFIG_IP_NF_MATCH_ECN=m\nCONFIG_IP_NF_MATCH_TTL=m\nCONFIG_IP_NF_FILTER=m\nCONFIG_IP_NF_TARGET_REJECT=m\nCONFIG_IP_NF_MANGLE=m\nCONFIG_IP_NF_TARGET_CLUSTERIP=m\nCONFIG_IP_NF_TARGET_ECN=m\nCONFIG_IP_NF_TARGET_TTL=m\nCONFIG_IP_NF_RAW=m\nCONFIG_IP_NF_SECURITY=m\nCONFIG_IP_NF_ARPTABLES=m\nCONFIG_IP_NF_ARPFILTER=m\nCONFIG_IP_NF_ARP_MANGLE=m\nCONFIG_IP6_NF_IPTABLES=m\nCONFIG_IP6_NF_MATCH_AH=m\nCONFIG_IP6_NF_MATCH_EUI64=m\nCONFIG_IP6_NF_MATCH_FRAG=m\nCONFIG_IP6_NF_MATCH_OPTS=m\nCONFIG_IP6_NF_MATCH_HL=m\nCONFIG_IP6_NF_MATCH_IPV6HEADER=m\nCONFIG_IP6_NF_MATCH_MH=m\nCONFIG_IP6_NF_MATCH_RT=m\nCONFIG_IP6_NF_TARGET_HL=m\nCONFIG_IP6_NF_FILTER=m\nCONFIG_IP6_NF_TARGET_REJECT=m\nCONFIG_IP6_NF_MANGLE=m\nCONFIG_IP6_NF_RAW=m\nCONFIG_IP6_NF_SECURITY=m\nCONFIG_BRIDGE_NF_EBTABLES=m\nCONFIG_BRIDGE_EBT_BROUTE=m\nCONFIG_BRIDGE_EBT_T_FILTER=m\nCONFIG_BRIDGE_EBT_T_NAT=m\nCONFIG_BRIDGE_EBT_802_3=m\nCONFIG_BRIDGE_EBT_AMONG=m\nCONFIG_BRIDGE_EBT_ARP=m\nCONFIG_BRIDGE_EBT_IP=m\nCONFIG_BRIDGE_EBT_IP6=m\nCONFIG_BRIDGE_EBT_LIMIT=m\nCONFIG_BRIDGE_EBT_MARK=m\nCONFIG_BRIDGE_EBT_PKTTYPE=m\nCONFIG_BRIDGE_EBT_STP=m\nCONFIG_BRIDGE_EBT_VLAN=m\nCONFIG_BRIDGE_EBT_ARPREPLY=m\nCONFIG_BRIDGE_EBT_DNAT=m\nCONFIG_BRIDGE_EBT_MARK_T=m\nCONFIG_BRIDGE_EBT_REDIRECT=m\nCONFIG_BRIDGE_EBT_SNAT=m\nCONFIG_BRIDGE_EBT_LOG=m\nCONFIG_BRIDGE_EBT_NFLOG=m\nCONFIG_IP_DCCP=m\nCONFIG_TIPC=m\nCONFIG_ATM=m\nCONFIG_ATM_CLIP=m\nCONFIG_ATM_LANE=m\nCONFIG_ATM_BR2684=m\nCONFIG_BRIDGE=m\nCONFIG_VLAN_8021Q=m\nCONFIG_DECNET=m\nCONFIG_DECNET_ROUTER=y\nCONFIG_ATALK=m\nCONFIG_DEV_APPLETALK=m\nCONFIG_IPDDP=m\nCONFIG_IPDDP_ENCAP=y\nCONFIG_NET_SCHED=y\nCONFIG_NET_SCH_CBQ=m\nCONFIG_NET_SCH_HTB=m\nCONFIG_NET_SCH_HFSC=m\nCONFIG_NET_SCH_ATM=m\nCONFIG_NET_SCH_PRIO=m\nCONFIG_NET_SCH_MULTIQ=m\nCONFIG_NET_SCH_RED=m\nCONFIG_NET_SCH_SFQ=m\nCONFIG_NET_SCH_TEQL=m\nCONFIG_NET_SCH_TBF=m\nCONFIG_NET_SCH_GRED=m\nCONFIG_NET_SCH_DSMARK=m\nCONFIG_NET_SCH_NETEM=m\nCONFIG_NET_SCH_INGRESS=m\nCONFIG_NET_CLS_BASIC=m\nCONFIG_NET_CLS_TCINDEX=m\nCONFIG_NET_CLS_ROUTE4=m\nCONFIG_NET_CLS_FW=m\nCONFIG_NET_CLS_U32=m\nCONFIG_CLS_U32_PERF=y\nCONFIG_CLS_U32_MARK=y\nCONFIG_NET_CLS_RSVP=m\nCONFIG_NET_CLS_RSVP6=m\nCONFIG_NET_CLS_FLOW=m\nCONFIG_NET_EMATCH=y\nCONFIG_NET_EMATCH_CMP=m\nCONFIG_NET_EMATCH_NBYTE=m\nCONFIG_NET_EMATCH_U32=m\nCONFIG_NET_EMATCH_META=m\nCONFIG_NET_EMATCH_TEXT=m\nCONFIG_NET_CLS_ACT=y\nCONFIG_NET_ACT_POLICE=m\nCONFIG_NET_ACT_GACT=m\nCONFIG_GACT_PROB=y\nCONFIG_NET_ACT_MIRRED=m\nCONFIG_NET_ACT_IPT=m\nCONFIG_NET_ACT_NAT=m\nCONFIG_NET_ACT_PEDIT=m\nCONFIG_NET_ACT_SIMP=m\nCONFIG_NET_ACT_SKBEDIT=m\nCONFIG_BT=m\nCONFIG_BT_RFCOMM=m\nCONFIG_BT_RFCOMM_TTY=y\nCONFIG_BT_BNEP=m\nCONFIG_BT_BNEP_MC_FILTER=y\nCONFIG_BT_BNEP_PROTO_FILTER=y\nCONFIG_BT_HIDP=m\nCONFIG_BT_HCIUART=m\nCONFIG_BT_HCIUART_BCSP=y\nCONFIG_BT_HCIBCM203X=m\nCONFIG_BT_HCIBPA10X=m\nCONFIG_BT_HCIBFUSB=m\nCONFIG_BT_HCIDTL1=m\nCONFIG_BT_HCIBT3C=m\nCONFIG_BT_HCIBLUECARD=m\nCONFIG_BT_HCIVHCI=m\nCONFIG_CFG80211=m\nCONFIG_MAC80211=m\nCONFIG_MAC80211_MESH=y\nCONFIG_MAC80211_LEDS=y\nCONFIG_MAC80211_DEBUGFS=y\nCONFIG_NET_9P=m\nCONFIG_NET_9P_VIRTIO=m\nCONFIG_DEBUG_DEVRES=y\nCONFIG_CONNECTOR=y\nCONFIG_PARPORT=m\nCONFIG_PARPORT_PC=m\nCONFIG_PARPORT_SERIAL=m\nCONFIG_PARPORT_1284=y\nCONFIG_PNP=y\nCONFIG_ISAPNP=y\nCONFIG_MAC_FLOPPY=m\nCONFIG_BLK_DEV_LOOP=m\nCONFIG_BLK_DEV_CRYPTOLOOP=m\nCONFIG_BLK_DEV_NBD=m\nCONFIG_BLK_DEV_RAM=y\nCONFIG_BLK_DEV_RAM_SIZE=16384\nCONFIG_CDROM_PKTCDVD=m\nCONFIG_VIRTIO_BLK=m\nCONFIG_ENCLOSURE_SERVICES=m\nCONFIG_SENSORS_TSL2550=m\nCONFIG_EEPROM_AT24=m\nCONFIG_EEPROM_LEGACY=m\nCONFIG_EEPROM_MAX6875=m\nCONFIG_EEPROM_93CX6=m\nCONFIG_RAID_ATTRS=m\nCONFIG_BLK_DEV_SD=y\nCONFIG_CHR_DEV_ST=m\nCONFIG_BLK_DEV_SR=m\nCONFIG_CHR_DEV_SG=y\nCONFIG_CHR_DEV_SCH=m\nCONFIG_SCSI_ENCLOSURE=m\nCONFIG_SCSI_CONSTANTS=y\nCONFIG_SCSI_LOGGING=y\nCONFIG_SCSI_SCAN_ASYNC=y\nCONFIG_SCSI_SPI_ATTRS=m\nCONFIG_SCSI_SRP_ATTRS=m\nCONFIG_SCSI_MESH=m\nCONFIG_SCSI_MAC53C94=m\nCONFIG_SCSI_LOWLEVEL_PCMCIA=y\nCONFIG_SCSI_DH=y\nCONFIG_SCSI_DH_RDAC=m\nCONFIG_SCSI_DH_HP_SW=m\nCONFIG_SCSI_DH_EMC=m\nCONFIG_ATA=y\n# CONFIG_SATA_PMP is not set\nCONFIG_SATA_FSL=m\nCONFIG_PDC_ADMA=m\nCONFIG_ATA_PIIX=m\nCONFIG_PATA_MACIO=y\nCONFIG_PATA_MPC52xx=m\nCONFIG_PATA_OPTIDMA=m\nCONFIG_PATA_SCH=m\nCONFIG_PATA_VIA=m\nCONFIG_PATA_PLATFORM=m\nCONFIG_PATA_OF_PLATFORM=m\nCONFIG_ATA_GENERIC=y\nCONFIG_MD=y\nCONFIG_BLK_DEV_MD=y\nCONFIG_MD_LINEAR=m\nCONFIG_MD_RAID0=m\nCONFIG_MD_RAID1=m\nCONFIG_MD_RAID10=m\nCONFIG_MD_RAID456=m\nCONFIG_MD_MULTIPATH=m\nCONFIG_MD_FAULTY=m\nCONFIG_BLK_DEV_DM=m\nCONFIG_DM_DEBUG=y\nCONFIG_DM_CRYPT=m\nCONFIG_DM_SNAPSHOT=m\nCONFIG_DM_MIRROR=m\nCONFIG_DM_ZERO=m\nCONFIG_DM_MULTIPATH=m\nCONFIG_DM_UEVENT=y\nCONFIG_FIREWIRE=m\nCONFIG_FIREWIRE_OHCI=m\nCONFIG_FIREWIRE_SBP2=m\nCONFIG_ADB=y\nCONFIG_ADB_CUDA=y\nCONFIG_ADB_PMU=y\nCONFIG_ADB_PMU_LED=y\nCONFIG_ADB_PMU_LED_DISK=y\nCONFIG_PMAC_APM_EMU=y\nCONFIG_PMAC_MEDIABAY=y\nCONFIG_PMAC_BACKLIGHT=y\nCONFIG_ADB_MACIO=y\nCONFIG_INPUT_ADBHID=y\nCONFIG_MAC_EMUMOUSEBTN=y\nCONFIG_THERM_WINDTUNNEL=m\nCONFIG_THERM_ADT746X=m\nCONFIG_WINDFARM=y\nCONFIG_PMAC_RACKMETER=m\nCONFIG_SENSORS_AMS=m\nCONFIG_NETDEVICES=y\nCONFIG_BONDING=m\nCONFIG_DUMMY=m\nCONFIG_EQUALIZER=m\nCONFIG_NET_FC=y\nCONFIG_IFB=m\nCONFIG_MACVLAN=m\nCONFIG_NETCONSOLE=m\nCONFIG_TUN=m\nCONFIG_VETH=m\nCONFIG_VIRTIO_NET=m\nCONFIG_ATM_TCP=m\nCONFIG_ATM_LANAI=m\nCONFIG_ATM_ENI=m\nCONFIG_ATM_NICSTAR=m\nCONFIG_ATM_IDT77252=m\nCONFIG_ATM_HE=m\nCONFIG_EL3=m\nCONFIG_PCMCIA_3C574=m\nCONFIG_PCMCIA_3C589=m\nCONFIG_VORTEX=m\nCONFIG_TYPHOON=m\nCONFIG_ADAPTEC_STARFIRE=m\nCONFIG_ACENIC=m\nCONFIG_AMD8111_ETH=m\nCONFIG_PCNET32=m\nCONFIG_PCMCIA_NMCLAN=m\nCONFIG_MACE=m\nCONFIG_BMAC=m\nCONFIG_ATL1=m\nCONFIG_B44=m\nCONFIG_BNX2=m\nCONFIG_TIGON3=m\nCONFIG_BNX2X=m\nCONFIG_CHELSIO_T1=m\nCONFIG_CHELSIO_T1_1G=y\nCONFIG_CHELSIO_T3=m\nCONFIG_NET_TULIP=y\nCONFIG_DE2104X=m\nCONFIG_TULIP=m\nCONFIG_TULIP_MMIO=y\nCONFIG_DE4X5=m\nCONFIG_WINBOND_840=m\nCONFIG_DM9102=m\nCONFIG_ULI526X=m\nCONFIG_PCMCIA_XIRCOM=m\nCONFIG_DL2K=m\nCONFIG_SUNDANCE=m\nCONFIG_S2IO=m\nCONFIG_FEC_MPC52xx=m\nCONFIG_GIANFAR=m\nCONFIG_PCMCIA_FMVJ18X=m\nCONFIG_E100=m\nCONFIG_E1000=m\nCONFIG_E1000E=m\nCONFIG_IGB=m\nCONFIG_IXGB=m\nCONFIG_IXGBE=m\nCONFIG_MV643XX_ETH=m\nCONFIG_SKGE=m\nCONFIG_SKY2=m\nCONFIG_MYRI10GE=m\nCONFIG_FEALNX=m\nCONFIG_NATSEMI=m\nCONFIG_NS83820=m\nCONFIG_PCMCIA_AXNET=m\nCONFIG_NE2000=m\nCONFIG_NE2K_PCI=m\nCONFIG_PCMCIA_PCNET=m\nCONFIG_ULTRA=m\nCONFIG_FORCEDETH=m\nCONFIG_HAMACHI=m\nCONFIG_YELLOWFIN=m\nCONFIG_QLA3XXX=m\nCONFIG_NETXEN_NIC=m\nCONFIG_8139CP=m\nCONFIG_8139TOO=m\n# CONFIG_8139TOO_PIO is not set\nCONFIG_8139TOO_8129=y\nCONFIG_R8169=m\nCONFIG_R6040=m\nCONFIG_SC92031=m\nCONFIG_SIS900=m\nCONFIG_SIS190=m\nCONFIG_SFC=m\nCONFIG_PCMCIA_SMC91C92=m\nCONFIG_EPIC100=m\nCONFIG_HAPPYMEAL=m\nCONFIG_SUNGEM=m\nCONFIG_CASSINI=m\nCONFIG_NIU=m\nCONFIG_TEHUTI=m\nCONFIG_TLAN=m\nCONFIG_VIA_RHINE=m\nCONFIG_VIA_RHINE_MMIO=y\nCONFIG_VIA_VELOCITY=m\nCONFIG_PCMCIA_XIRC2PS=m\nCONFIG_FDDI=y\nCONFIG_SKFP=m\nCONFIG_NET_SB1000=m\nCONFIG_BROADCOM_PHY=m\nCONFIG_CICADA_PHY=m\nCONFIG_DAVICOM_PHY=m\nCONFIG_ICPLUS_PHY=m\nCONFIG_LXT_PHY=m\nCONFIG_MARVELL_PHY=m\nCONFIG_QSEMI_PHY=m\nCONFIG_REALTEK_PHY=m\nCONFIG_SMSC_PHY=m\nCONFIG_VITESSE_PHY=m\nCONFIG_PLIP=m\nCONFIG_PPP_DEFLATE=m\nCONFIG_PPP_FILTER=y\nCONFIG_PPP_MPPE=m\nCONFIG_PPP_MULTILINK=y\nCONFIG_PPPOATM=m\nCONFIG_PPPOE=m\nCONFIG_PPP_ASYNC=m\nCONFIG_PPP_SYNC_TTY=m\nCONFIG_SLIP=m\nCONFIG_SLIP_COMPRESSED=y\nCONFIG_SLIP_SMART=y\nCONFIG_USB_CATC=m\nCONFIG_USB_KAWETH=m\nCONFIG_USB_PEGASUS=m\nCONFIG_USB_RTL8150=m\nCONFIG_USB_USBNET=m\nCONFIG_USB_NET_DM9601=m\nCONFIG_USB_NET_SMSC95XX=m\nCONFIG_USB_NET_GL620A=m\nCONFIG_USB_NET_PLUSB=m\nCONFIG_USB_NET_MCS7830=m\nCONFIG_USB_NET_RNDIS_HOST=m\nCONFIG_USB_ALI_M5632=y\nCONFIG_USB_AN2720=y\nCONFIG_USB_EPSON2888=y\nCONFIG_USB_KC2190=y\nCONFIG_INPUT_JOYDEV=m\nCONFIG_INPUT_EVDEV=y\nCONFIG_MOUSE_SERIAL=m\nCONFIG_MOUSE_APPLETOUCH=m\nCONFIG_MOUSE_VSXXXAA=m\nCONFIG_INPUT_JOYSTICK=y\nCONFIG_JOYSTICK_ANALOG=m\nCONFIG_JOYSTICK_A3D=m\nCONFIG_JOYSTICK_ADI=m\nCONFIG_JOYSTICK_COBRA=m\nCONFIG_JOYSTICK_GF2K=m\nCONFIG_JOYSTICK_GRIP=m\nCONFIG_JOYSTICK_GRIP_MP=m\nCONFIG_JOYSTICK_GUILLEMOT=m\nCONFIG_JOYSTICK_INTERACT=m\nCONFIG_JOYSTICK_SIDEWINDER=m\nCONFIG_JOYSTICK_TMDC=m\nCONFIG_JOYSTICK_IFORCE=m\nCONFIG_JOYSTICK_IFORCE_USB=y\nCONFIG_JOYSTICK_IFORCE_232=y\nCONFIG_JOYSTICK_WARRIOR=m\nCONFIG_JOYSTICK_MAGELLAN=m\nCONFIG_JOYSTICK_SPACEORB=m\nCONFIG_JOYSTICK_SPACEBALL=m\nCONFIG_JOYSTICK_STINGER=m\nCONFIG_JOYSTICK_TWIDJOY=m\nCONFIG_JOYSTICK_ZHENHUA=m\nCONFIG_JOYSTICK_DB9=m\nCONFIG_JOYSTICK_GAMECON=m\nCONFIG_JOYSTICK_TURBOGRAFX=m\nCONFIG_JOYSTICK_JOYDUMP=m\nCONFIG_JOYSTICK_XPAD=m\nCONFIG_JOYSTICK_XPAD_FF=y\nCONFIG_JOYSTICK_XPAD_LEDS=y\nCONFIG_INPUT_TABLET=y\nCONFIG_TABLET_USB_ACECAD=m\nCONFIG_TABLET_USB_AIPTEK=m\nCONFIG_TABLET_USB_GTCO=m\nCONFIG_TABLET_USB_KBTAB=m\nCONFIG_INPUT_MISC=y\nCONFIG_INPUT_PCSPKR=m\nCONFIG_INPUT_ATI_REMOTE2=m\nCONFIG_INPUT_KEYSPAN_REMOTE=m\nCONFIG_INPUT_POWERMATE=m\nCONFIG_INPUT_YEALINK=m\nCONFIG_INPUT_CM109=m\nCONFIG_INPUT_UINPUT=m\nCONFIG_SERIO_RAW=m\nCONFIG_GAMEPORT_NS558=m\nCONFIG_GAMEPORT_L4=m\nCONFIG_GAMEPORT_EMU10K1=m\nCONFIG_GAMEPORT_FM801=m\n# CONFIG_LEGACY_PTYS is not set\nCONFIG_SERIAL_NONSTANDARD=y\nCONFIG_ROCKETPORT=m\nCONFIG_CYCLADES=m\nCONFIG_SYNCLINK=m\nCONFIG_SYNCLINKMP=m\nCONFIG_SYNCLINK_GT=m\nCONFIG_NOZOMI=m\nCONFIG_N_HDLC=m\nCONFIG_SERIAL_8250=y\nCONFIG_SERIAL_8250_CONSOLE=y\nCONFIG_SERIAL_8250_CS=m\nCONFIG_SERIAL_8250_NR_UARTS=32\nCONFIG_SERIAL_8250_EXTENDED=y\nCONFIG_SERIAL_8250_MANY_PORTS=y\nCONFIG_SERIAL_8250_SHARE_IRQ=y\nCONFIG_SERIAL_8250_DETECT_IRQ=y\nCONFIG_SERIAL_8250_RSA=y\nCONFIG_SERIAL_OF_PLATFORM=y\nCONFIG_SERIAL_UARTLITE=m\nCONFIG_SERIAL_PMACZILOG=m\nCONFIG_SERIAL_MPC52xx=y\nCONFIG_SERIAL_MPC52xx_CONSOLE=y\nCONFIG_SERIAL_MPC52xx_CONSOLE_BAUD=115200\nCONFIG_SERIAL_JSM=m\nCONFIG_PRINTER=m\nCONFIG_LP_CONSOLE=y\nCONFIG_PPDEV=m\nCONFIG_HW_RANDOM=y\nCONFIG_HW_RANDOM_VIRTIO=m\nCONFIG_NVRAM=y\nCONFIG_DTLK=m\nCONFIG_R3964=m\nCONFIG_CARDMAN_4000=m\nCONFIG_CARDMAN_4040=m\nCONFIG_IPWIRELESS=m\nCONFIG_I2C_CHARDEV=m\nCONFIG_I2C_HYDRA=m\nCONFIG_I2C_MPC=m\nCONFIG_I2C_PCA_PLATFORM=m\nCONFIG_I2C_SIMTEC=m\nCONFIG_I2C_PARPORT=m\nCONFIG_I2C_TINY_USB=m\nCONFIG_I2C_PCA_ISA=m\nCONFIG_I2C_STUB=m\nCONFIG_GPIO_SYSFS=y\nCONFIG_GPIO_MPC8XXX=y\nCONFIG_W1=m\nCONFIG_W1_MASTER_DS2490=m\nCONFIG_W1_MASTER_DS2482=m\nCONFIG_W1_SLAVE_THERM=m\nCONFIG_W1_SLAVE_SMEM=m\nCONFIG_W1_SLAVE_DS2433=m\nCONFIG_W1_SLAVE_DS2433_CRC=y\nCONFIG_APM_POWER=m\nCONFIG_BATTERY_PMU=m\nCONFIG_HWMON=m\nCONFIG_SENSORS_AD7418=m\nCONFIG_SENSORS_ADM1021=m\nCONFIG_SENSORS_ADM1025=m\nCONFIG_SENSORS_ADM1026=m\nCONFIG_SENSORS_ADM1029=m\nCONFIG_SENSORS_ADM1031=m\nCONFIG_SENSORS_ADM9240=m\nCONFIG_SENSORS_ADT7470=m\nCONFIG_SENSORS_ATXP1=m\nCONFIG_SENSORS_DS1621=m\nCONFIG_SENSORS_F75375S=m\nCONFIG_SENSORS_GL518SM=m\nCONFIG_SENSORS_GL520SM=m\nCONFIG_SENSORS_MAX1619=m\nCONFIG_SENSORS_MAX6650=m\nCONFIG_SENSORS_LM63=m\nCONFIG_SENSORS_LM75=m\nCONFIG_SENSORS_LM77=m\nCONFIG_SENSORS_LM78=m\nCONFIG_SENSORS_LM80=m\nCONFIG_SENSORS_LM83=m\nCONFIG_SENSORS_LM85=m\nCONFIG_SENSORS_LM87=m\nCONFIG_SENSORS_LM90=m\nCONFIG_SENSORS_LM92=m\nCONFIG_SENSORS_LM93=m\nCONFIG_SENSORS_PCF8591=m\nCONFIG_SENSORS_SIS5595=m\nCONFIG_SENSORS_SMSC47M192=m\nCONFIG_SENSORS_ADS7828=m\nCONFIG_SENSORS_THMC50=m\nCONFIG_SENSORS_VIA686A=m\nCONFIG_SENSORS_VT8231=m\nCONFIG_SENSORS_W83781D=m\nCONFIG_SENSORS_W83791D=m\nCONFIG_SENSORS_W83792D=m\nCONFIG_SENSORS_W83793=m\nCONFIG_SENSORS_W83L785TS=m\nCONFIG_SENSORS_W83L786NG=m\nCONFIG_THERMAL=y\nCONFIG_WATCHDOG=y\nCONFIG_SOFT_WATCHDOG=m\nCONFIG_WATCHDOG_RTAS=m\nCONFIG_USBPCWATCHDOG=m\nCONFIG_SSB_PCMCIAHOST=y\nCONFIG_MFD_SM501=m\nCONFIG_MFD_SM501_GPIO=y\nCONFIG_AGP=y\nCONFIG_AGP_UNINORTH=y\nCONFIG_DRM=m\nCONFIG_DRM_RADEON=m\nCONFIG_DRM_LEGACY=y\nCONFIG_DRM_TDFX=m\nCONFIG_DRM_R128=m\nCONFIG_DRM_MGA=m\nCONFIG_DRM_SIS=m\nCONFIG_DRM_VIA=m\nCONFIG_DRM_SAVAGE=m\nCONFIG_FB=y\nCONFIG_FB_CIRRUS=m\nCONFIG_FB_OF=y\nCONFIG_FB_PLATINUM=y\nCONFIG_FB_VALKYRIE=y\nCONFIG_FB_CT65550=y\nCONFIG_FB_NVIDIA=y\nCONFIG_FB_NVIDIA_I2C=y\nCONFIG_FB_RIVA=m\nCONFIG_FB_MATROX=y\nCONFIG_FB_MATROX_MILLENIUM=y\nCONFIG_FB_MATROX_MYSTIQUE=y\nCONFIG_FB_MATROX_G=y\nCONFIG_FB_MATROX_I2C=m\nCONFIG_FB_MATROX_MAVEN=m\nCONFIG_FB_RADEON=y\nCONFIG_FB_ATY128=y\nCONFIG_FB_ATY=y\nCONFIG_FB_ATY_CT=y\nCONFIG_FB_ATY_GENERIC_LCD=y\nCONFIG_FB_ATY_GX=y\nCONFIG_FB_S3=m\nCONFIG_FB_SAVAGE=m\nCONFIG_FB_SAVAGE_I2C=y\nCONFIG_FB_SAVAGE_ACCEL=y\nCONFIG_FB_NEOMAGIC=m\nCONFIG_FB_KYRO=m\nCONFIG_FB_3DFX=m\nCONFIG_FB_3DFX_ACCEL=y\nCONFIG_FB_VOODOO1=m\nCONFIG_FB_TRIDENT=m\nCONFIG_FB_SM501=m\nCONFIG_FB_IBM_GXT4500=y\nCONFIG_LCD_PLATFORM=m\nCONFIG_FRAMEBUFFER_CONSOLE=y\nCONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y\nCONFIG_LOGO=y\n# CONFIG_LOGO_LINUX_MONO is not set\n# CONFIG_LOGO_LINUX_VGA16 is not set\nCONFIG_SOUND=m\nCONFIG_SND=m\nCONFIG_SND_OSSEMUL=y\nCONFIG_SND_MIXER_OSS=m\nCONFIG_SND_PCM_OSS=m\nCONFIG_SND_DYNAMIC_MINORS=y\n# CONFIG_SND_SUPPORT_OLD_API is not set\nCONFIG_SND_VERBOSE_PRINTK=y\nCONFIG_SND_DEBUG=y\nCONFIG_SND_DEBUG_VERBOSE=y\nCONFIG_SND_PCM_XRUN_DEBUG=y\nCONFIG_SND_SEQUENCER=m\nCONFIG_SND_SEQ_DUMMY=m\nCONFIG_SND_SEQUENCER_OSS=m\nCONFIG_SND_DUMMY=m\nCONFIG_SND_VIRMIDI=m\nCONFIG_SND_MTPAV=m\nCONFIG_SND_MTS64=m\nCONFIG_SND_SERIAL_U16550=m\nCONFIG_SND_MPU401=m\nCONFIG_SND_PORTMAN2X4=m\nCONFIG_SND_AC97_POWER_SAVE=y\nCONFIG_SND_AC97_POWER_SAVE_DEFAULT=5\nCONFIG_SND_AD1889=m\nCONFIG_SND_ALS300=m\nCONFIG_SND_ALS4000=m\nCONFIG_SND_ALI5451=m\nCONFIG_SND_ATIIXP=m\nCONFIG_SND_ATIIXP_MODEM=m\nCONFIG_SND_AU8810=m\nCONFIG_SND_AU8820=m\nCONFIG_SND_AU8830=m\nCONFIG_SND_AW2=m\nCONFIG_SND_AZT3328=m\nCONFIG_SND_BT87X=m\nCONFIG_SND_CA0106=m\nCONFIG_SND_CMIPCI=m\nCONFIG_SND_OXYGEN=m\nCONFIG_SND_CS4281=m\nCONFIG_SND_CS46XX=m\nCONFIG_SND_DARLA20=m\nCONFIG_SND_GINA20=m\nCONFIG_SND_LAYLA20=m\nCONFIG_SND_DARLA24=m\nCONFIG_SND_GINA24=m\nCONFIG_SND_LAYLA24=m\nCONFIG_SND_MONA=m\nCONFIG_SND_MIA=m\nCONFIG_SND_ECHO3G=m\nCONFIG_SND_INDIGO=m\nCONFIG_SND_INDIGOIO=m\nCONFIG_SND_INDIGODJ=m\nCONFIG_SND_EMU10K1=m\nCONFIG_SND_EMU10K1X=m\nCONFIG_SND_ENS1370=m\nCONFIG_SND_ENS1371=m\nCONFIG_SND_ES1938=m\nCONFIG_SND_ES1968=m\nCONFIG_SND_FM801=m\nCONFIG_SND_HDSP=m\nCONFIG_SND_HDSPM=m\nCONFIG_SND_ICE1712=m\nCONFIG_SND_ICE1724=m\nCONFIG_SND_KORG1212=m\nCONFIG_SND_MAESTRO3=m\nCONFIG_SND_MIXART=m\nCONFIG_SND_NM256=m\nCONFIG_SND_PCXHR=m\nCONFIG_SND_RIPTIDE=m\nCONFIG_SND_RME32=m\nCONFIG_SND_RME96=m\nCONFIG_SND_RME9652=m\nCONFIG_SND_SONICVIBES=m\nCONFIG_SND_TRIDENT=m\nCONFIG_SND_VIA82XX=m\nCONFIG_SND_VIA82XX_MODEM=m\nCONFIG_SND_VIRTUOSO=m\nCONFIG_SND_VX222=m\nCONFIG_SND_POWERMAC=m\nCONFIG_SND_AOA=m\nCONFIG_SND_AOA_FABRIC_LAYOUT=m\nCONFIG_SND_AOA_ONYX=m\nCONFIG_SND_AOA_TAS=m\nCONFIG_SND_AOA_TOONIE=m\nCONFIG_SND_USB_AUDIO=m\nCONFIG_SND_USB_USX2Y=m\nCONFIG_SND_USB_CAIAQ=m\nCONFIG_SND_USB_CAIAQ_INPUT=y\n# CONFIG_SND_PCMCIA is not set\nCONFIG_HIDRAW=y\nCONFIG_HID_GYRATION=y\nCONFIG_LOGITECH_FF=y\nCONFIG_LOGIRUMBLEPAD2_FF=y\nCONFIG_HID_PANTHERLORD=y\nCONFIG_PANTHERLORD_FF=y\nCONFIG_HID_PETALYNX=y\nCONFIG_HID_SAMSUNG=y\nCONFIG_HID_SONY=y\nCONFIG_HID_SUNPLUS=y\nCONFIG_HID_PID=y\nCONFIG_USB_HIDDEV=y\nCONFIG_USB=y\nCONFIG_USB_ANNOUNCE_NEW_DEVICES=y\nCONFIG_USB_MON=y\nCONFIG_USB_EHCI_HCD=m\nCONFIG_USB_EHCI_FSL=m\nCONFIG_USB_OHCI_HCD=m\nCONFIG_USB_OHCI_HCD_PPC_OF_BE=y\nCONFIG_USB_OHCI_HCD_PPC_OF_LE=y\nCONFIG_USB_UHCI_HCD=m\nCONFIG_USB_U132_HCD=m\nCONFIG_USB_SL811_HCD=m\nCONFIG_USB_ACM=m\nCONFIG_USB_PRINTER=m\nCONFIG_USB_WDM=m\nCONFIG_USB_STORAGE=m\nCONFIG_USB_STORAGE_DATAFAB=m\nCONFIG_USB_STORAGE_FREECOM=m\nCONFIG_USB_STORAGE_USBAT=m\nCONFIG_USB_STORAGE_SDDR09=m\nCONFIG_USB_STORAGE_SDDR55=m\nCONFIG_USB_STORAGE_JUMPSHOT=m\nCONFIG_USB_STORAGE_ALAUDA=m\nCONFIG_USB_STORAGE_ONETOUCH=m\nCONFIG_USB_STORAGE_KARMA=m\nCONFIG_USB_STORAGE_CYPRESS_ATACB=m\nCONFIG_USB_MDC800=m\nCONFIG_USB_MICROTEK=m\nCONFIG_USB_USS720=m\nCONFIG_USB_SERIAL=m\nCONFIG_USB_SERIAL_GENERIC=y\nCONFIG_USB_SERIAL_AIRCABLE=m\nCONFIG_USB_SERIAL_ARK3116=m\nCONFIG_USB_SERIAL_BELKIN=m\nCONFIG_USB_SERIAL_CH341=m\nCONFIG_USB_SERIAL_WHITEHEAT=m\nCONFIG_USB_SERIAL_DIGI_ACCELEPORT=m\nCONFIG_USB_SERIAL_CYPRESS_M8=m\nCONFIG_USB_SERIAL_EMPEG=m\nCONFIG_USB_SERIAL_FTDI_SIO=m\nCONFIG_USB_SERIAL_VISOR=m\nCONFIG_USB_SERIAL_IPAQ=m\nCONFIG_USB_SERIAL_IR=m\nCONFIG_USB_SERIAL_EDGEPORT=m\nCONFIG_USB_SERIAL_EDGEPORT_TI=m\nCONFIG_USB_SERIAL_IPW=m\nCONFIG_USB_SERIAL_IUU=m\nCONFIG_USB_SERIAL_KEYSPAN_PDA=m\nCONFIG_USB_SERIAL_KEYSPAN=m\nCONFIG_USB_SERIAL_KLSI=m\nCONFIG_USB_SERIAL_KOBIL_SCT=m\nCONFIG_USB_SERIAL_MCT_U232=m\nCONFIG_USB_SERIAL_MOS7720=m\nCONFIG_USB_SERIAL_MOS7840=m\nCONFIG_USB_SERIAL_NAVMAN=m\nCONFIG_USB_SERIAL_PL2303=m\nCONFIG_USB_SERIAL_OTI6858=m\nCONFIG_USB_SERIAL_SPCP8X5=m\nCONFIG_USB_SERIAL_SAFE=m\nCONFIG_USB_SERIAL_SAFE_PADDED=y\nCONFIG_USB_SERIAL_SIERRAWIRELESS=m\nCONFIG_USB_SERIAL_TI=m\nCONFIG_USB_SERIAL_CYBERJACK=m\nCONFIG_USB_SERIAL_XIRCOM=m\nCONFIG_USB_SERIAL_OPTION=m\nCONFIG_USB_SERIAL_OMNINET=m\nCONFIG_USB_SERIAL_DEBUG=m\nCONFIG_USB_EMI62=m\nCONFIG_USB_EMI26=m\nCONFIG_USB_ADUTUX=m\nCONFIG_USB_SEVSEG=m\nCONFIG_USB_LEGOTOWER=m\nCONFIG_USB_LCD=m\nCONFIG_USB_IDMOUSE=m\nCONFIG_USB_FTDI_ELAN=m\nCONFIG_USB_APPLEDISPLAY=m\nCONFIG_USB_SISUSBVGA=m\nCONFIG_USB_SISUSBVGA_CON=y\nCONFIG_USB_LD=m\nCONFIG_USB_TRANCEVIBRATOR=m\nCONFIG_USB_IOWARRIOR=m\nCONFIG_USB_ISIGHTFW=m\nCONFIG_USB_ATM=m\nCONFIG_USB_SPEEDTOUCH=m\nCONFIG_USB_CXACRU=m\nCONFIG_USB_UEAGLEATM=m\nCONFIG_USB_XUSBATM=m\nCONFIG_LEDS_TRIGGER_TIMER=m\nCONFIG_LEDS_TRIGGER_HEARTBEAT=m\nCONFIG_LEDS_TRIGGER_BACKLIGHT=m\nCONFIG_LEDS_TRIGGER_DEFAULT_ON=m\nCONFIG_ACCESSIBILITY=y\nCONFIG_A11Y_BRAILLE_CONSOLE=y\nCONFIG_EDAC=m\nCONFIG_RTC_CLASS=y\n# CONFIG_RTC_HCTOSYS is not set\nCONFIG_RTC_DRV_DS1307=m\nCONFIG_RTC_DRV_DS1374=m\nCONFIG_RTC_DRV_DS1672=m\nCONFIG_RTC_DRV_MAX6900=m\nCONFIG_RTC_DRV_RS5C372=m\nCONFIG_RTC_DRV_ISL1208=m\nCONFIG_RTC_DRV_X1205=m\nCONFIG_RTC_DRV_PCF8563=m\nCONFIG_RTC_DRV_PCF8583=m\nCONFIG_RTC_DRV_M41T80=m\nCONFIG_RTC_DRV_M41T80_WDT=y\nCONFIG_RTC_DRV_FM3130=m\nCONFIG_RTC_DRV_CMOS=y\nCONFIG_RTC_DRV_DS1511=m\nCONFIG_RTC_DRV_DS1553=m\nCONFIG_RTC_DRV_DS1742=m\nCONFIG_RTC_DRV_STK17TA8=m\nCONFIG_RTC_DRV_M48T35=m\nCONFIG_RTC_DRV_M48T59=m\nCONFIG_RTC_DRV_V3020=m\nCONFIG_DMADEVICES=y\nCONFIG_PPC_BESTCOMM=y\nCONFIG_AUXDISPLAY=y\nCONFIG_KS0108=m\nCONFIG_UIO=m\nCONFIG_UIO_CIF=m\nCONFIG_UIO_PDRV_GENIRQ=m\nCONFIG_VIRTIO_PCI=m\nCONFIG_VIRTIO_BALLOON=m\nCONFIG_QUICC_ENGINE=y\nCONFIG_EXT2_FS=m\nCONFIG_EXT2_FS_XATTR=y\nCONFIG_EXT2_FS_POSIX_ACL=y\nCONFIG_EXT2_FS_SECURITY=y\nCONFIG_EXT4_FS=y\nCONFIG_EXT4_FS_POSIX_ACL=y\nCONFIG_EXT4_FS_SECURITY=y\nCONFIG_JBD2_DEBUG=y\nCONFIG_REISERFS_FS=m\nCONFIG_REISERFS_PROC_INFO=y\nCONFIG_REISERFS_FS_XATTR=y\nCONFIG_REISERFS_FS_POSIX_ACL=y\nCONFIG_REISERFS_FS_SECURITY=y\nCONFIG_JFS_FS=m\nCONFIG_JFS_POSIX_ACL=y\nCONFIG_JFS_SECURITY=y\nCONFIG_XFS_FS=m\nCONFIG_XFS_QUOTA=y\nCONFIG_XFS_POSIX_ACL=y\nCONFIG_GFS2_FS=m\nCONFIG_FS_DAX=y\nCONFIG_QUOTA_NETLINK_INTERFACE=y\nCONFIG_AUTOFS4_FS=m\nCONFIG_FUSE_FS=m\nCONFIG_ISO9660_FS=y\nCONFIG_JOLIET=y\nCONFIG_ZISOFS=y\nCONFIG_UDF_FS=m\nCONFIG_MSDOS_FS=m\nCONFIG_VFAT_FS=m\nCONFIG_FAT_DEFAULT_IOCHARSET=\"ascii\"\nCONFIG_PROC_KCORE=y\nCONFIG_TMPFS=y\nCONFIG_TMPFS_POSIX_ACL=y\nCONFIG_AFFS_FS=m\nCONFIG_ECRYPT_FS=m\nCONFIG_HFS_FS=m\nCONFIG_HFSPLUS_FS=m\nCONFIG_BEFS_FS=m\nCONFIG_BFS_FS=m\nCONFIG_EFS_FS=m\nCONFIG_CRAMFS=m\nCONFIG_VXFS_FS=m\nCONFIG_MINIX_FS=m\nCONFIG_OMFS_FS=m\nCONFIG_QNX4FS_FS=m\nCONFIG_ROMFS_FS=m\nCONFIG_SYSV_FS=m\nCONFIG_UFS_FS=m\nCONFIG_NFS_FS=m\nCONFIG_NFS_V3_ACL=y\nCONFIG_NFS_V4=m\nCONFIG_NFSD=m\nCONFIG_NFSD_V3_ACL=y\nCONFIG_NFSD_V4=y\nCONFIG_CIFS=m\nCONFIG_CIFS_WEAK_PW_HASH=y\nCONFIG_CIFS_UPCALL=y\nCONFIG_CIFS_XATTR=y\nCONFIG_CIFS_POSIX=y\nCONFIG_CIFS_DFS_UPCALL=y\nCONFIG_CODA_FS=m\nCONFIG_9P_FS=m\nCONFIG_NLS_DEFAULT=\"utf8\"\nCONFIG_NLS_CODEPAGE_437=y\nCONFIG_NLS_CODEPAGE_737=m\nCONFIG_NLS_CODEPAGE_775=m\nCONFIG_NLS_CODEPAGE_850=m\nCONFIG_NLS_CODEPAGE_852=m\nCONFIG_NLS_CODEPAGE_855=m\nCONFIG_NLS_CODEPAGE_857=m\nCONFIG_NLS_CODEPAGE_860=m\nCONFIG_NLS_CODEPAGE_861=m\nCONFIG_NLS_CODEPAGE_862=m\nCONFIG_NLS_CODEPAGE_863=m\nCONFIG_NLS_CODEPAGE_864=m\nCONFIG_NLS_CODEPAGE_865=m\nCONFIG_NLS_CODEPAGE_866=m\nCONFIG_NLS_CODEPAGE_869=m\nCONFIG_NLS_CODEPAGE_936=m\nCONFIG_NLS_CODEPAGE_950=m\nCONFIG_NLS_CODEPAGE_932=m\nCONFIG_NLS_CODEPAGE_949=m\nCONFIG_NLS_CODEPAGE_874=m\nCONFIG_NLS_ISO8859_8=m\nCONFIG_NLS_CODEPAGE_1250=m\nCONFIG_NLS_CODEPAGE_1251=m\nCONFIG_NLS_ASCII=y\nCONFIG_NLS_ISO8859_1=m\nCONFIG_NLS_ISO8859_2=m\nCONFIG_NLS_ISO8859_3=m\nCONFIG_NLS_ISO8859_4=m\nCONFIG_NLS_ISO8859_5=m\nCONFIG_NLS_ISO8859_6=m\nCONFIG_NLS_ISO8859_7=m\nCONFIG_NLS_ISO8859_9=m\nCONFIG_NLS_ISO8859_13=m\nCONFIG_NLS_ISO8859_14=m\nCONFIG_NLS_ISO8859_15=m\nCONFIG_NLS_KOI8_R=m\nCONFIG_NLS_KOI8_U=m\nCONFIG_DEBUG_INFO=y\nCONFIG_UNUSED_SYMBOLS=y\nCONFIG_HEADERS_INSTALL=y\nCONFIG_MAGIC_SYSRQ=y\nCONFIG_DEBUG_KERNEL=y\nCONFIG_DEBUG_OBJECTS=y\nCONFIG_DEBUG_OBJECTS_FREE=y\nCONFIG_DEBUG_OBJECTS_TIMERS=y\nCONFIG_SLUB_DEBUG_ON=y\nCONFIG_DEBUG_STACK_USAGE=y\nCONFIG_DEBUG_VM=y\nCONFIG_DEBUG_HIGHMEM=y\nCONFIG_DEBUG_STACKOVERFLOW=y\nCONFIG_DEBUG_SHIRQ=y\nCONFIG_DEBUG_RT_MUTEXES=y\nCONFIG_DEBUG_SPINLOCK=y\nCONFIG_DEBUG_MUTEXES=y\nCONFIG_DEBUG_LIST=y\nCONFIG_DEBUG_SG=y\nCONFIG_FAULT_INJECTION=y\nCONFIG_FAILSLAB=y\nCONFIG_FAIL_PAGE_ALLOC=y\nCONFIG_FAIL_MAKE_REQUEST=y\nCONFIG_FAIL_IO_TIMEOUT=y\nCONFIG_FAULT_INJECTION_DEBUG_FS=y\nCONFIG_FAULT_INJECTION_STACKTRACE_FILTER=y\nCONFIG_SCHED_TRACER=y\nCONFIG_STACK_TRACER=y\nCONFIG_BLK_DEV_IO_TRACE=y\nCONFIG_XMON=y\nCONFIG_BOOTX_TEXT=y\nCONFIG_SECURITY=y\nCONFIG_SECURITY_NETWORK=y\nCONFIG_SECURITY_NETWORK_XFRM=y\nCONFIG_SECURITY_SELINUX=y\nCONFIG_SECURITY_SELINUX_BOOTPARAM=y\nCONFIG_SECURITY_SELINUX_DISABLE=y\nCONFIG_CRYPTO_TEST=m\nCONFIG_CRYPTO_CTS=m\nCONFIG_CRYPTO_LRW=m\nCONFIG_CRYPTO_PCBC=m\nCONFIG_CRYPTO_XTS=m\nCONFIG_CRYPTO_HMAC=y\nCONFIG_CRYPTO_XCBC=m\nCONFIG_CRYPTO_MICHAEL_MIC=m\nCONFIG_CRYPTO_RMD128=m\nCONFIG_CRYPTO_RMD160=m\nCONFIG_CRYPTO_RMD256=m\nCONFIG_CRYPTO_RMD320=m\nCONFIG_CRYPTO_SHA1=y\nCONFIG_CRYPTO_SHA512=m\nCONFIG_CRYPTO_TGR192=m\nCONFIG_CRYPTO_WP512=m\nCONFIG_CRYPTO_ANUBIS=m\nCONFIG_CRYPTO_BLOWFISH=m\nCONFIG_CRYPTO_CAMELLIA=m\nCONFIG_CRYPTO_CAST6=m\nCONFIG_CRYPTO_FCRYPT=m\nCONFIG_CRYPTO_KHAZAD=m\nCONFIG_CRYPTO_SALSA20=m\nCONFIG_CRYPTO_SEED=m\nCONFIG_CRYPTO_SERPENT=m\nCONFIG_CRYPTO_TEA=m\nCONFIG_CRYPTO_TWOFISH=m\nCONFIG_CRYPTO_LZO=m\nCONFIG_CRYPTO_DEV_HIFN_795X=m\nCONFIG_CRYPTO_DEV_HIFN_795X_RNG=y\nCONFIG_CRYPTO_DEV_TALITOS=m\nCONFIG_VIRTUALIZATION=y\n", "# CONFIG_LOCALVERSION_AUTO is not set\nCONFIG_SYSVIPC=y\nCONFIG_POSIX_MQUEUE=y\nCONFIG_AUDIT=y\nCONFIG_NO_HZ=y\nCONFIG_HIGH_RES_TIMERS=y\nCONFIG_PREEMPT_VOLUNTARY=y\nCONFIG_BSD_PROCESS_ACCT=y\nCONFIG_TASKSTATS=y\nCONFIG_TASK_DELAY_ACCT=y\nCONFIG_TASK_XACCT=y\nCONFIG_TASK_IO_ACCOUNTING=y\nCONFIG_LOG_BUF_SHIFT=18\nCONFIG_CGROUPS=y\nCONFIG_CGROUP_SCHED=y\nCONFIG_CGROUP_FREEZER=y\nCONFIG_CPUSETS=y\nCONFIG_CGROUP_CPUACCT=y\nCONFIG_BLK_DEV_INITRD=y\n# CONFIG_COMPAT_BRK is not set\nCONFIG_PROFILING=y\nCONFIG_SMP=y\nCONFIG_X86_GENERIC=y\nCONFIG_HPET_TIMER=y\nCONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y\nCONFIG_X86_REBOOTFIXUPS=y\nCONFIG_MICROCODE_AMD=y\nCONFIG_X86_MSR=y\nCONFIG_X86_CPUID=y\nCONFIG_HIGHPTE=y\nCONFIG_X86_CHECK_BIOS_CORRUPTION=y\n# CONFIG_MTRR_SANITIZER is not set\nCONFIG_EFI=y\nCONFIG_EFI_STUB=y\nCONFIG_HZ_1000=y\nCONFIG_KEXEC=y\nCONFIG_CRASH_DUMP=y\nCONFIG_HIBERNATION=y\nCONFIG_PM_DEBUG=y\nCONFIG_PM_TRACE_RTC=y\nCONFIG_ACPI_DOCK=y\nCONFIG_ACPI_BGRT=y\nCONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y\nCONFIG_CPU_FREQ_GOV_ONDEMAND=y\nCONFIG_X86_ACPI_CPUFREQ=y\nCONFIG_EFI_VARS=y\nCONFIG_KPROBES=y\nCONFIG_JUMP_LABEL=y\nCONFIG_MODULES=y\nCONFIG_MODULE_UNLOAD=y\nCONFIG_MODULE_FORCE_UNLOAD=y\n# CONFIG_UNUSED_SYMBOLS is not set\nCONFIG_BINFMT_MISC=y\nCONFIG_NET=y\nCONFIG_PACKET=y\nCONFIG_UNIX=y\nCONFIG_XFRM_USER=y\nCONFIG_INET=y\nCONFIG_IP_MULTICAST=y\nCONFIG_IP_ADVANCED_ROUTER=y\nCONFIG_IP_MULTIPLE_TABLES=y\nCONFIG_IP_ROUTE_MULTIPATH=y\nCONFIG_IP_ROUTE_VERBOSE=y\nCONFIG_IP_PNP=y\nCONFIG_IP_PNP_DHCP=y\nCONFIG_IP_PNP_BOOTP=y\nCONFIG_IP_PNP_RARP=y\nCONFIG_IP_MROUTE=y\nCONFIG_IP_PIMSM_V1=y\nCONFIG_IP_PIMSM_V2=y\nCONFIG_SYN_COOKIES=y\n# CONFIG_INET_DIAG is not set\nCONFIG_TCP_CONG_ADVANCED=y\n# CONFIG_TCP_CONG_BIC is not set\n# CONFIG_TCP_CONG_WESTWOOD is not set\n# CONFIG_TCP_CONG_HTCP is not set\nCONFIG_TCP_MD5SIG=y\nCONFIG_INET6_AH=y\nCONFIG_INET6_ESP=y\nCONFIG_NETLABEL=y\nCONFIG_NETFILTER=y\n# CONFIG_NETFILTER_ADVANCED is not set\nCONFIG_NF_CONNTRACK=y\nCONFIG_NF_CONNTRACK_FTP=y\nCONFIG_NF_CONNTRACK_IRC=y\nCONFIG_NF_CONNTRACK_SIP=y\nCONFIG_NF_CT_NETLINK=y\nCONFIG_NF_NAT=y\nCONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y\nCONFIG_NETFILTER_XT_TARGET_NFLOG=y\nCONFIG_NETFILTER_XT_TARGET_SECMARK=y\nCONFIG_NETFILTER_XT_TARGET_TCPMSS=y\nCONFIG_NETFILTER_XT_MATCH_CONNTRACK=y\nCONFIG_NETFILTER_XT_MATCH_POLICY=y\nCONFIG_NETFILTER_XT_MATCH_STATE=y\nCONFIG_IP_NF_IPTABLES=y\nCONFIG_IP_NF_FILTER=y\nCONFIG_IP_NF_TARGET_REJECT=y\nCONFIG_IP_NF_TARGET_MASQUERADE=m\nCONFIG_IP_NF_MANGLE=y\nCONFIG_IP6_NF_IPTABLES=y\nCONFIG_IP6_NF_MATCH_IPV6HEADER=y\nCONFIG_IP6_NF_FILTER=y\nCONFIG_IP6_NF_TARGET_REJECT=y\nCONFIG_IP6_NF_MANGLE=y\nCONFIG_NET_SCHED=y\nCONFIG_NET_EMATCH=y\nCONFIG_NET_CLS_ACT=y\nCONFIG_CFG80211=y\nCONFIG_MAC80211=y\nCONFIG_MAC80211_LEDS=y\nCONFIG_RFKILL=y\nCONFIG_PCI=y\nCONFIG_PCIEPORTBUS=y\nCONFIG_PCI_MSI=y\nCONFIG_HOTPLUG_PCI=y\nCONFIG_PCCARD=y\nCONFIG_YENTA=y\nCONFIG_DEVTMPFS=y\nCONFIG_DEVTMPFS_MOUNT=y\nCONFIG_DEBUG_DEVRES=y\nCONFIG_CONNECTOR=y\nCONFIG_BLK_DEV_LOOP=y\nCONFIG_BLK_DEV_SD=y\nCONFIG_BLK_DEV_SR=y\nCONFIG_CHR_DEV_SG=y\nCONFIG_SCSI_CONSTANTS=y\nCONFIG_SCSI_SPI_ATTRS=y\n# CONFIG_SCSI_LOWLEVEL is not set\nCONFIG_ATA=y\nCONFIG_SATA_AHCI=y\nCONFIG_ATA_PIIX=y\nCONFIG_PATA_AMD=y\nCONFIG_PATA_OLDPIIX=y\nCONFIG_PATA_SCH=y\nCONFIG_PATA_MPIIX=y\nCONFIG_ATA_GENERIC=y\nCONFIG_MD=y\nCONFIG_BLK_DEV_MD=y\nCONFIG_BLK_DEV_DM=y\nCONFIG_DM_MIRROR=y\nCONFIG_DM_ZERO=y\nCONFIG_MACINTOSH_DRIVERS=y\nCONFIG_MAC_EMUMOUSEBTN=y\nCONFIG_NETDEVICES=y\nCONFIG_NETCONSOLE=y\nCONFIG_BNX2=y\nCONFIG_TIGON3=y\nCONFIG_NET_TULIP=y\nCONFIG_E100=y\nCONFIG_E1000=y\nCONFIG_E1000E=y\nCONFIG_SKY2=y\nCONFIG_NE2K_PCI=y\nCONFIG_FORCEDETH=y\nCONFIG_8139TOO=y\n# CONFIG_8139TOO_PIO is not set\nCONFIG_R8169=y\nCONFIG_INPUT_POLLDEV=y\nCONFIG_INPUT_EVDEV=y\nCONFIG_INPUT_JOYSTICK=y\nCONFIG_INPUT_TABLET=y\nCONFIG_INPUT_TOUCHSCREEN=y\nCONFIG_INPUT_MISC=y\n# CONFIG_LEGACY_PTYS is not set\nCONFIG_SERIAL_8250=y\nCONFIG_SERIAL_8250_CONSOLE=y\nCONFIG_SERIAL_8250_NR_UARTS=32\nCONFIG_SERIAL_8250_EXTENDED=y\nCONFIG_SERIAL_8250_MANY_PORTS=y\nCONFIG_SERIAL_8250_SHARE_IRQ=y\nCONFIG_SERIAL_8250_DETECT_IRQ=y\nCONFIG_SERIAL_8250_RSA=y\nCONFIG_SERIAL_NONSTANDARD=y\nCONFIG_HW_RANDOM=y\nCONFIG_NVRAM=y\nCONFIG_HPET=y\n# CONFIG_HPET_MMAP is not set\nCONFIG_I2C_I801=y\nCONFIG_WATCHDOG=y\nCONFIG_AGP=y\nCONFIG_AGP_AMD64=y\nCONFIG_AGP_INTEL=y\nCONFIG_DRM=y\nCONFIG_DRM_I915=y\nCONFIG_FB_MODE_HELPERS=y\nCONFIG_FB_TILEBLITTING=y\nCONFIG_FB_EFI=y\nCONFIG_LOGO=y\n# CONFIG_LOGO_LINUX_MONO is not set\n# CONFIG_LOGO_LINUX_VGA16 is not set\nCONFIG_SOUND=y\nCONFIG_SND=y\nCONFIG_SND_HRTIMER=y\nCONFIG_SND_SEQUENCER=y\nCONFIG_SND_SEQ_DUMMY=y\nCONFIG_SND_HDA_INTEL=y\nCONFIG_SND_HDA_HWDEP=y\nCONFIG_HIDRAW=y\nCONFIG_HID_GYRATION=y\nCONFIG_LOGITECH_FF=y\nCONFIG_HID_NTRIG=y\nCONFIG_HID_PANTHERLORD=y\nCONFIG_PANTHERLORD_FF=y\nCONFIG_HID_PETALYNX=y\nCONFIG_HID_SAMSUNG=y\nCONFIG_HID_SONY=y\nCONFIG_HID_SUNPLUS=y\nCONFIG_HID_TOPSEED=y\nCONFIG_HID_PID=y\nCONFIG_USB_HIDDEV=y\nCONFIG_USB=y\nCONFIG_USB_ANNOUNCE_NEW_DEVICES=y\nCONFIG_USB_MON=y\nCONFIG_USB_XHCI_HCD=y\nCONFIG_USB_EHCI_HCD=y\nCONFIG_USB_OHCI_HCD=y\nCONFIG_USB_UHCI_HCD=y\nCONFIG_USB_PRINTER=y\nCONFIG_USB_STORAGE=y\nCONFIG_RTC_CLASS=y\n# CONFIG_RTC_HCTOSYS is not set\nCONFIG_DMADEVICES=y\nCONFIG_EEEPC_LAPTOP=y\nCONFIG_EXT4_FS=y\nCONFIG_EXT4_FS_POSIX_ACL=y\nCONFIG_EXT4_FS_SECURITY=y\nCONFIG_QUOTA=y\nCONFIG_QUOTA_NETLINK_INTERFACE=y\n# CONFIG_PRINT_QUOTA_WARNING is not set\nCONFIG_QFMT_V2=y\nCONFIG_AUTOFS4_FS=y\nCONFIG_ISO9660_FS=y\nCONFIG_JOLIET=y\nCONFIG_ZISOFS=y\nCONFIG_MSDOS_FS=y\nCONFIG_VFAT_FS=y\nCONFIG_PROC_KCORE=y\nCONFIG_TMPFS_POSIX_ACL=y\nCONFIG_HUGETLBFS=y\nCONFIG_NFS_FS=y\nCONFIG_NFS_V3_ACL=y\nCONFIG_NFS_V4=y\nCONFIG_ROOT_NFS=y\nCONFIG_NLS_DEFAULT=\"utf8\"\nCONFIG_NLS_CODEPAGE_437=y\nCONFIG_NLS_ASCII=y\nCONFIG_NLS_ISO8859_1=y\nCONFIG_NLS_UTF8=y\nCONFIG_SECURITY=y\nCONFIG_SECURITY_NETWORK=y\nCONFIG_SECURITY_SELINUX=y\nCONFIG_SECURITY_SELINUX_BOOTPARAM=y\nCONFIG_SECURITY_SELINUX_DISABLE=y\nCONFIG_PRINTK_TIME=y\nCONFIG_MAGIC_SYSRQ=y\nCONFIG_DEBUG_KERNEL=y\nCONFIG_DEBUG_STACK_USAGE=y\nCONFIG_DEBUG_STACKOVERFLOW=y\n# CONFIG_SCHED_DEBUG is not set\nCONFIG_SCHEDSTATS=y\nCONFIG_BLK_DEV_IO_TRACE=y\nCONFIG_PROVIDE_OHCI1394_DMA_INIT=y\nCONFIG_EARLY_PRINTK_DBGP=y\nCONFIG_DEBUG_BOOT_PARAMS=y\n", "# CONFIG_LOCALVERSION_AUTO is not set\nCONFIG_SYSVIPC=y\nCONFIG_POSIX_MQUEUE=y\nCONFIG_AUDIT=y\nCONFIG_NO_HZ=y\nCONFIG_HIGH_RES_TIMERS=y\nCONFIG_PREEMPT_VOLUNTARY=y\nCONFIG_BSD_PROCESS_ACCT=y\nCONFIG_TASKSTATS=y\nCONFIG_TASK_DELAY_ACCT=y\nCONFIG_TASK_XACCT=y\nCONFIG_TASK_IO_ACCOUNTING=y\nCONFIG_LOG_BUF_SHIFT=18\nCONFIG_CGROUPS=y\nCONFIG_CGROUP_SCHED=y\nCONFIG_CGROUP_FREEZER=y\nCONFIG_CPUSETS=y\nCONFIG_CGROUP_CPUACCT=y\nCONFIG_BLK_DEV_INITRD=y\n# CONFIG_COMPAT_BRK is not set\nCONFIG_PROFILING=y\nCONFIG_SMP=y\nCONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y\nCONFIG_MICROCODE_AMD=y\nCONFIG_X86_MSR=y\nCONFIG_X86_CPUID=y\nCONFIG_NUMA=y\nCONFIG_X86_CHECK_BIOS_CORRUPTION=y\n# CONFIG_MTRR_SANITIZER is not set\nCONFIG_EFI=y\nCONFIG_EFI_STUB=y\nCONFIG_EFI_MIXED=y\nCONFIG_HZ_1000=y\nCONFIG_KEXEC=y\nCONFIG_CRASH_DUMP=y\nCONFIG_HIBERNATION=y\nCONFIG_PM_DEBUG=y\nCONFIG_PM_TRACE_RTC=y\nCONFIG_ACPI_DOCK=y\nCONFIG_ACPI_BGRT=y\nCONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y\nCONFIG_CPU_FREQ_GOV_ONDEMAND=y\nCONFIG_X86_ACPI_CPUFREQ=y\nCONFIG_IA32_EMULATION=y\nCONFIG_EFI_VARS=y\nCONFIG_KPROBES=y\nCONFIG_JUMP_LABEL=y\nCONFIG_MODULES=y\nCONFIG_MODULE_UNLOAD=y\nCONFIG_MODULE_FORCE_UNLOAD=y\n# CONFIG_UNUSED_SYMBOLS is not set\nCONFIG_BINFMT_MISC=y\nCONFIG_NET=y\nCONFIG_PACKET=y\nCONFIG_UNIX=y\nCONFIG_XFRM_USER=y\nCONFIG_INET=y\nCONFIG_IP_MULTICAST=y\nCONFIG_IP_ADVANCED_ROUTER=y\nCONFIG_IP_MULTIPLE_TABLES=y\nCONFIG_IP_ROUTE_MULTIPATH=y\nCONFIG_IP_ROUTE_VERBOSE=y\nCONFIG_IP_PNP=y\nCONFIG_IP_PNP_DHCP=y\nCONFIG_IP_PNP_BOOTP=y\nCONFIG_IP_PNP_RARP=y\nCONFIG_IP_MROUTE=y\nCONFIG_IP_PIMSM_V1=y\nCONFIG_IP_PIMSM_V2=y\nCONFIG_SYN_COOKIES=y\n# CONFIG_INET_DIAG is not set\nCONFIG_TCP_CONG_ADVANCED=y\n# CONFIG_TCP_CONG_BIC is not set\n# CONFIG_TCP_CONG_WESTWOOD is not set\n# CONFIG_TCP_CONG_HTCP is not set\nCONFIG_TCP_MD5SIG=y\nCONFIG_INET6_AH=y\nCONFIG_INET6_ESP=y\nCONFIG_NETLABEL=y\nCONFIG_NETFILTER=y\n# CONFIG_NETFILTER_ADVANCED is not set\nCONFIG_NF_CONNTRACK=y\nCONFIG_NF_CONNTRACK_FTP=y\nCONFIG_NF_CONNTRACK_IRC=y\nCONFIG_NF_CONNTRACK_SIP=y\nCONFIG_NF_CT_NETLINK=y\nCONFIG_NF_NAT=y\nCONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y\nCONFIG_NETFILTER_XT_TARGET_NFLOG=y\nCONFIG_NETFILTER_XT_TARGET_SECMARK=y\nCONFIG_NETFILTER_XT_TARGET_TCPMSS=y\nCONFIG_NETFILTER_XT_MATCH_CONNTRACK=y\nCONFIG_NETFILTER_XT_MATCH_POLICY=y\nCONFIG_NETFILTER_XT_MATCH_STATE=y\nCONFIG_IP_NF_IPTABLES=y\nCONFIG_IP_NF_FILTER=y\nCONFIG_IP_NF_TARGET_REJECT=y\nCONFIG_IP_NF_TARGET_MASQUERADE=m\nCONFIG_IP_NF_MANGLE=y\nCONFIG_IP6_NF_IPTABLES=y\nCONFIG_IP6_NF_MATCH_IPV6HEADER=y\nCONFIG_IP6_NF_FILTER=y\nCONFIG_IP6_NF_TARGET_REJECT=y\nCONFIG_IP6_NF_MANGLE=y\nCONFIG_NET_SCHED=y\nCONFIG_NET_EMATCH=y\nCONFIG_NET_CLS_ACT=y\nCONFIG_CFG80211=y\nCONFIG_MAC80211=y\nCONFIG_MAC80211_LEDS=y\nCONFIG_RFKILL=y\nCONFIG_PCI=y\nCONFIG_PCIEPORTBUS=y\nCONFIG_HOTPLUG_PCI=y\nCONFIG_PCCARD=y\nCONFIG_YENTA=y\nCONFIG_DEVTMPFS=y\nCONFIG_DEVTMPFS_MOUNT=y\nCONFIG_DEBUG_DEVRES=y\nCONFIG_CONNECTOR=y\nCONFIG_BLK_DEV_LOOP=y\nCONFIG_BLK_DEV_SD=y\nCONFIG_BLK_DEV_SR=y\nCONFIG_CHR_DEV_SG=y\nCONFIG_SCSI_CONSTANTS=y\nCONFIG_SCSI_SPI_ATTRS=y\n# CONFIG_SCSI_LOWLEVEL is not set\nCONFIG_ATA=y\nCONFIG_SATA_AHCI=y\nCONFIG_ATA_PIIX=y\nCONFIG_PATA_AMD=y\nCONFIG_PATA_OLDPIIX=y\nCONFIG_PATA_SCH=y\nCONFIG_MD=y\nCONFIG_BLK_DEV_MD=y\nCONFIG_BLK_DEV_DM=y\nCONFIG_DM_MIRROR=y\nCONFIG_DM_ZERO=y\nCONFIG_MACINTOSH_DRIVERS=y\nCONFIG_MAC_EMUMOUSEBTN=y\nCONFIG_NETDEVICES=y\nCONFIG_NETCONSOLE=y\nCONFIG_TIGON3=y\nCONFIG_NET_TULIP=y\nCONFIG_E100=y\nCONFIG_E1000=y\nCONFIG_E1000E=y\nCONFIG_SKY2=y\nCONFIG_FORCEDETH=y\nCONFIG_8139TOO=y\nCONFIG_R8169=y\nCONFIG_INPUT_POLLDEV=y\nCONFIG_INPUT_EVDEV=y\nCONFIG_INPUT_JOYSTICK=y\nCONFIG_INPUT_TABLET=y\nCONFIG_INPUT_TOUCHSCREEN=y\nCONFIG_INPUT_MISC=y\n# CONFIG_LEGACY_PTYS is not set\nCONFIG_SERIAL_8250=y\nCONFIG_SERIAL_8250_CONSOLE=y\nCONFIG_SERIAL_8250_NR_UARTS=32\nCONFIG_SERIAL_8250_EXTENDED=y\nCONFIG_SERIAL_8250_MANY_PORTS=y\nCONFIG_SERIAL_8250_SHARE_IRQ=y\nCONFIG_SERIAL_8250_DETECT_IRQ=y\nCONFIG_SERIAL_8250_RSA=y\nCONFIG_SERIAL_NONSTANDARD=y\nCONFIG_HW_RANDOM=y\n# CONFIG_HW_RANDOM_INTEL is not set\n# CONFIG_HW_RANDOM_AMD is not set\nCONFIG_NVRAM=y\nCONFIG_HPET=y\n# CONFIG_HPET_MMAP is not set\nCONFIG_I2C_I801=y\nCONFIG_WATCHDOG=y\nCONFIG_AGP=y\nCONFIG_AGP_AMD64=y\nCONFIG_AGP_INTEL=y\nCONFIG_DRM=y\nCONFIG_DRM_I915=y\nCONFIG_FB_MODE_HELPERS=y\nCONFIG_FB_TILEBLITTING=y\nCONFIG_FB_EFI=y\nCONFIG_LOGO=y\n# CONFIG_LOGO_LINUX_MONO is not set\n# CONFIG_LOGO_LINUX_VGA16 is not set\nCONFIG_SOUND=y\nCONFIG_SND=y\nCONFIG_SND_HRTIMER=y\nCONFIG_SND_SEQUENCER=y\nCONFIG_SND_SEQ_DUMMY=y\nCONFIG_SND_HDA_INTEL=y\nCONFIG_SND_HDA_HWDEP=y\nCONFIG_HIDRAW=y\nCONFIG_HID_GYRATION=y\nCONFIG_LOGITECH_FF=y\nCONFIG_HID_NTRIG=y\nCONFIG_HID_PANTHERLORD=y\nCONFIG_PANTHERLORD_FF=y\nCONFIG_HID_PETALYNX=y\nCONFIG_HID_SAMSUNG=y\nCONFIG_HID_SONY=y\nCONFIG_HID_SUNPLUS=y\nCONFIG_HID_TOPSEED=y\nCONFIG_HID_PID=y\nCONFIG_USB_HIDDEV=y\nCONFIG_USB=y\nCONFIG_USB_ANNOUNCE_NEW_DEVICES=y\nCONFIG_USB_MON=y\nCONFIG_USB_XHCI_HCD=y\nCONFIG_USB_EHCI_HCD=y\nCONFIG_USB_OHCI_HCD=y\nCONFIG_USB_UHCI_HCD=y\nCONFIG_USB_PRINTER=y\nCONFIG_USB_STORAGE=y\nCONFIG_RTC_CLASS=y\n# CONFIG_RTC_HCTOSYS is not set\nCONFIG_DMADEVICES=y\nCONFIG_EEEPC_LAPTOP=y\nCONFIG_AMD_IOMMU=y\nCONFIG_INTEL_IOMMU=y\n# CONFIG_INTEL_IOMMU_DEFAULT_ON is not set\nCONFIG_EXT4_FS=y\nCONFIG_EXT4_FS_POSIX_ACL=y\nCONFIG_EXT4_FS_SECURITY=y\nCONFIG_QUOTA=y\nCONFIG_QUOTA_NETLINK_INTERFACE=y\n# CONFIG_PRINT_QUOTA_WARNING is not set\nCONFIG_QFMT_V2=y\nCONFIG_AUTOFS4_FS=y\nCONFIG_ISO9660_FS=y\nCONFIG_JOLIET=y\nCONFIG_ZISOFS=y\nCONFIG_MSDOS_FS=y\nCONFIG_VFAT_FS=y\nCONFIG_PROC_KCORE=y\nCONFIG_TMPFS_POSIX_ACL=y\nCONFIG_HUGETLBFS=y\nCONFIG_NFS_FS=y\nCONFIG_NFS_V3_ACL=y\nCONFIG_NFS_V4=y\nCONFIG_ROOT_NFS=y\nCONFIG_NLS_DEFAULT=\"utf8\"\nCONFIG_NLS_CODEPAGE_437=y\nCONFIG_NLS_ASCII=y\nCONFIG_NLS_ISO8859_1=y\nCONFIG_NLS_UTF8=y\nCONFIG_SECURITY=y\nCONFIG_SECURITY_NETWORK=y\nCONFIG_SECURITY_SELINUX=y\nCONFIG_SECURITY_SELINUX_BOOTPARAM=y\nCONFIG_SECURITY_SELINUX_DISABLE=y\nCONFIG_PRINTK_TIME=y\nCONFIG_MAGIC_SYSRQ=y\nCONFIG_DEBUG_KERNEL=y\nCONFIG_DEBUG_STACK_USAGE=y\n# CONFIG_SCHED_DEBUG is not set\nCONFIG_SCHEDSTATS=y\nCONFIG_BLK_DEV_IO_TRACE=y\nCONFIG_PROVIDE_OHCI1394_DMA_INIT=y\nCONFIG_EARLY_PRINTK_DBGP=y\nCONFIG_DEBUG_BOOT_PARAMS=y\n", "# SPDX-License-Identifier: GPL-2.0-only\n#\n# Video configuration\n#\n\nmenu \"Console display driver support\"\n\nconfig VGA_CONSOLE\n\tbool \"VGA text console\" if EXPERT || !X86\n\tdepends on !4xx && !PPC_8xx && !SPARC && !M68K && !PARISC &&  !SUPERH && \\\n\t\t(!ARM || ARCH_FOOTBRIDGE || ARCH_INTEGRATOR || ARCH_NETWINDER) && \\\n\t\t!ARM64 && !ARC && !MICROBLAZE && !OPENRISC && !NDS32 && !S390\n\tdefault y\n\thelp\n\t  Saying Y here will allow you to use Linux in text mode through a\n\t  display that complies with the generic VGA standard. Virtually\n\t  everyone wants that.\n\n\t  The program SVGATextMode can be used to utilize SVGA video cards to\n\t  their full potential in text mode. Download it from\n\t  <ftp://ibiblio.org/pub/Linux/utils/console/>.\n\n\t  Say Y.\n\nconfig MDA_CONSOLE\n\tdepends on !M68K && !PARISC && ISA\n\ttristate \"MDA text console (dual-headed)\"\n\thelp\n\t  Say Y here if you have an old MDA or monochrome Hercules graphics\n\t  adapter in your system acting as a second head ( = video card). You\n\t  will then be able to use two monitors with your Linux system. Do not\n\t  say Y here if your MDA card is the primary card in your system; the\n\t  normal VGA driver will handle it.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called mdacon.\n\n\t  If unsure, say N.\n\nconfig SGI_NEWPORT_CONSOLE\n\ttristate \"SGI Newport Console support\"\n\tdepends on SGI_IP22 && HAS_IOMEM\n\tselect FONT_SUPPORT\n\thelp\n\t  Say Y here if you want the console on the Newport aka XL graphics\n\t  card of your Indy.  Most people say Y here.\n\nconfig DUMMY_CONSOLE\n\tbool\n\tdefault y\n\nconfig DUMMY_CONSOLE_COLUMNS\n\tint \"Initial number of console screen columns\"\n\tdepends on DUMMY_CONSOLE && !ARM\n\tdefault 160 if PARISC\n\tdefault 80\n\thelp\n\t  On PA-RISC, the default value is 160, which should fit a 1280x1024\n\t  monitor.\n\t  Select 80 if you use a 640x480 resolution by default.\n\nconfig DUMMY_CONSOLE_ROWS\n\tint \"Initial number of console screen rows\"\n\tdepends on DUMMY_CONSOLE && !ARM\n\tdefault 64 if PARISC\n\tdefault 25\n\thelp\n\t  On PA-RISC, the default value is 64, which should fit a 1280x1024\n\t  monitor.\n\t  Select 25 if you use a 640x480 resolution by default.\n\nconfig FRAMEBUFFER_CONSOLE\n\tbool \"Framebuffer Console support\"\n\tdepends on FB && !UML\n\tselect VT_HW_CONSOLE_BINDING\n\tselect CRC32\n\tselect FONT_SUPPORT\n\thelp\n\t  Low-level framebuffer-based console driver.\n\nconfig FRAMEBUFFER_CONSOLE_DETECT_PRIMARY\n       bool \"Map the console to the primary display device\"\n       depends on FRAMEBUFFER_CONSOLE\n       default n\n\thelp\n\t If this option is selected, the framebuffer console will\n\t automatically select the primary display device (if the architecture\n\t supports this feature).  Otherwise, the framebuffer console will\n\t always select the first framebuffer driver that is loaded. The latter\n\t is the default behavior.\n\n\t You can always override the automatic selection of the primary device\n\t by using the fbcon=map: boot option.\n\n\t If unsure, select n.\n\nconfig FRAMEBUFFER_CONSOLE_ROTATION\n       bool \"Framebuffer Console Rotation\"\n       depends on FRAMEBUFFER_CONSOLE\n       help\n\t Enable display rotation for the framebuffer console.  This is done\n\t in software and may be significantly slower than a normally oriented\n\t display.  Note that the rotation is done at the console level only\n\t such that other users of the framebuffer will remain normally\n\t oriented.\n\nconfig FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER\n\tbool \"Framebuffer Console Deferred Takeover\"\n\tdepends on FB=y && FRAMEBUFFER_CONSOLE && DUMMY_CONSOLE\n\thelp\n\t  If enabled this defers the framebuffer console taking over the\n\t  console from the dummy console until the first text is displayed on\n\t  the console. This is useful in combination with the \"quiet\" kernel\n\t  commandline option to keep the framebuffer contents initially put up\n\t  by the firmware in place, rather then replacing the contents with a\n\t  black screen as soon as fbcon loads.\n\nconfig STI_CONSOLE\n\tbool \"STI text console\"\n\tdepends on PARISC && HAS_IOMEM\n\tselect FONT_SUPPORT\n\tdefault y\n\thelp\n\t  The STI console is the builtin display/keyboard on HP-PARISC\n\t  machines.  Say Y here to build support for it into your kernel.\n\t  The alternative is to use your primary serial port as a console.\n\nendmenu\n\n", "/*\n *  linux/drivers/video/vgacon.c -- Low level VGA based console driver\n *\n *\tCreated 28 Sep 1997 by Geert Uytterhoeven\n *\n *\tRewritten by Martin Mares <mj@ucw.cz>, July 1998\n *\n *  This file is based on the old console.c, vga.c and vesa_blank.c drivers.\n *\n *\tCopyright (C) 1991, 1992  Linus Torvalds\n *\t\t\t    1995  Jay Estabrook\n *\n *\tUser definable mapping table and font loading by Eugene G. Crosser,\n *\t<crosser@average.org>\n *\n *\tImproved loadable font/UTF-8 support by H. Peter Anvin\n *\tFeb-Sep 1995 <peter.anvin@linux.org>\n *\n *\tColour palette handling, by Simon Tatham\n *\t17-Jun-95 <sgt20@cam.ac.uk>\n *\n *\tif 512 char mode is already enabled don't re-enable it,\n *\tbecause it causes screen to flicker, by Mitja Horvat\n *\t5-May-96 <mitja.horvat@guest.arnes.si>\n *\n *\tUse 2 outw instead of 4 outb_p to reduce erroneous text\n *\tflashing on RHS of screen during heavy console scrolling .\n *\tOct 1996, Paul Gortmaker.\n *\n *\n *  This file is subject to the terms and conditions of the GNU General Public\n *  License.  See the file COPYING in the main directory of this archive for\n *  more details.\n */\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/console.h>\n#include <linux/string.h>\n#include <linux/kd.h>\n#include <linux/slab.h>\n#include <linux/vt_kern.h>\n#include <linux/sched.h>\n#include <linux/selection.h>\n#include <linux/spinlock.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/screen_info.h>\n#include <video/vga.h>\n#include <asm/io.h>\n\nstatic DEFINE_RAW_SPINLOCK(vga_lock);\nstatic int cursor_size_lastfrom;\nstatic int cursor_size_lastto;\nstatic u32 vgacon_xres;\nstatic u32 vgacon_yres;\nstatic struct vgastate vgastate;\n\n#define BLANK 0x0020\n\n#define VGA_FONTWIDTH       8   /* VGA does not support fontwidths != 8 */\n/*\n *  Interface used by the world\n */\n\nstatic const char *vgacon_startup(void);\nstatic void vgacon_init(struct vc_data *c, int init);\nstatic void vgacon_deinit(struct vc_data *c);\nstatic void vgacon_cursor(struct vc_data *c, int mode);\nstatic int vgacon_switch(struct vc_data *c);\nstatic int vgacon_blank(struct vc_data *c, int blank, int mode_switch);\nstatic void vgacon_scrolldelta(struct vc_data *c, int lines);\nstatic int vgacon_set_origin(struct vc_data *c);\nstatic void vgacon_save_screen(struct vc_data *c);\nstatic void vgacon_invert_region(struct vc_data *c, u16 * p, int count);\nstatic struct uni_pagedir *vgacon_uni_pagedir;\nstatic int vgacon_refcount;\n\n/* Description of the hardware situation */\nstatic bool\t\tvga_init_done;\nstatic unsigned long\tvga_vram_base\t\t__read_mostly;\t/* Base of video memory */\nstatic unsigned long\tvga_vram_end\t\t__read_mostly;\t/* End of video memory */\nstatic unsigned int\tvga_vram_size\t\t__read_mostly;\t/* Size of video memory */\nstatic u16\t\tvga_video_port_reg\t__read_mostly;\t/* Video register select port */\nstatic u16\t\tvga_video_port_val\t__read_mostly;\t/* Video register value port */\nstatic unsigned int\tvga_video_num_columns;\t\t\t/* Number of text columns */\nstatic unsigned int\tvga_video_num_lines;\t\t\t/* Number of text lines */\nstatic bool\t\tvga_can_do_color;\t\t\t/* Do we support colors? */\nstatic unsigned int\tvga_default_font_height __read_mostly;\t/* Height of default screen font */\nstatic unsigned char\tvga_video_type\t\t__read_mostly;\t/* Card type */\nstatic bool\t\tvga_font_is_default = true;\nstatic int\t\tvga_vesa_blanked;\nstatic bool \t\tvga_palette_blanked;\nstatic bool \t\tvga_is_gfx;\nstatic bool \t\tvga_512_chars;\nstatic int \t\tvga_video_font_height;\nstatic int \t\tvga_scan_lines\t\t__read_mostly;\nstatic unsigned int \tvga_rolled_over;\n\nstatic bool vgacon_text_mode_force;\nstatic bool vga_hardscroll_enabled;\nstatic bool vga_hardscroll_user_enable = true;\n\nbool vgacon_text_force(void)\n{\n\treturn vgacon_text_mode_force;\n}\nEXPORT_SYMBOL(vgacon_text_force);\n\nstatic int __init text_mode(char *str)\n{\n\tvgacon_text_mode_force = true;\n\n\tpr_warn(\"You have booted with nomodeset. This means your GPU drivers are DISABLED\\n\");\n\tpr_warn(\"Any video related functionality will be severely degraded, and you may not even be able to suspend the system properly\\n\");\n\tpr_warn(\"Unless you actually understand what nomodeset does, you should reboot without enabling it\\n\");\n\n\treturn 1;\n}\n\n/* force text mode - used by kernel modesetting */\n__setup(\"nomodeset\", text_mode);\n\nstatic int __init no_scroll(char *str)\n{\n\t/*\n\t * Disabling scrollback is required for the Braillex ib80-piezo\n\t * Braille reader made by F.H. Papenmeier (Germany).\n\t * Use the \"no-scroll\" bootflag.\n\t */\n\tvga_hardscroll_user_enable = vga_hardscroll_enabled = false;\n\treturn 1;\n}\n\n__setup(\"no-scroll\", no_scroll);\n\n/*\n * By replacing the four outb_p with two back to back outw, we can reduce\n * the window of opportunity to see text mislocated to the RHS of the\n * console during heavy scrolling activity. However there is the remote\n * possibility that some pre-dinosaur hardware won't like the back to back\n * I/O. Since the Xservers get away with it, we should be able to as well.\n */\nstatic inline void write_vga(unsigned char reg, unsigned int val)\n{\n\tunsigned int v1, v2;\n\tunsigned long flags;\n\n\t/*\n\t * ddprintk might set the console position from interrupt\n\t * handlers, thus the write has to be IRQ-atomic.\n\t */\n\traw_spin_lock_irqsave(&vga_lock, flags);\n\tv1 = reg + (val & 0xff00);\n\tv2 = reg + 1 + ((val << 8) & 0xff00);\n\toutw(v1, vga_video_port_reg);\n\toutw(v2, vga_video_port_reg);\n\traw_spin_unlock_irqrestore(&vga_lock, flags);\n}\n\nstatic inline void vga_set_mem_top(struct vc_data *c)\n{\n\twrite_vga(12, (c->vc_visible_origin - vga_vram_base) / 2);\n}\n\nstatic void vgacon_restore_screen(struct vc_data *c)\n{\n\tif (c->vc_origin != c->vc_visible_origin)\n\t\tvgacon_scrolldelta(c, 0);\n}\n\nstatic void vgacon_scrolldelta(struct vc_data *c, int lines)\n{\n\tvc_scrolldelta_helper(c, lines, vga_rolled_over, (void *)vga_vram_base,\n\t\t\tvga_vram_size);\n\tvga_set_mem_top(c);\n}\n\nstatic const char *vgacon_startup(void)\n{\n\tconst char *display_desc = NULL;\n\tu16 saved1, saved2;\n\tvolatile u16 *p;\n\n\tif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||\n\t    screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {\n\t      no_vga:\n#ifdef CONFIG_DUMMY_CONSOLE\n\t\tconswitchp = &dummy_con;\n\t\treturn conswitchp->con_startup();\n#else\n\t\treturn NULL;\n#endif\n\t}\n\n\t/* boot_params.screen_info reasonably initialized? */\n\tif ((screen_info.orig_video_lines == 0) ||\n\t    (screen_info.orig_video_cols  == 0))\n\t\tgoto no_vga;\n\n\t/* VGA16 modes are not handled by VGACON */\n\tif ((screen_info.orig_video_mode == 0x0D) ||\t/* 320x200/4 */\n\t    (screen_info.orig_video_mode == 0x0E) ||\t/* 640x200/4 */\n\t    (screen_info.orig_video_mode == 0x10) ||\t/* 640x350/4 */\n\t    (screen_info.orig_video_mode == 0x12) ||\t/* 640x480/4 */\n\t    (screen_info.orig_video_mode == 0x6A))\t/* 800x600/4 (VESA) */\n\t\tgoto no_vga;\n\n\tvga_video_num_lines = screen_info.orig_video_lines;\n\tvga_video_num_columns = screen_info.orig_video_cols;\n\tvgastate.vgabase = NULL;\n\n\tif (screen_info.orig_video_mode == 7) {\n\t\t/* Monochrome display */\n\t\tvga_vram_base = 0xb0000;\n\t\tvga_video_port_reg = VGA_CRT_IM;\n\t\tvga_video_port_val = VGA_CRT_DM;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tstatic struct resource ega_console_resource =\n\t\t\t    { .name\t= \"ega\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_EGAM;\n\t\t\tvga_vram_size = 0x8000;\n\t\t\tdisplay_desc = \"EGA+\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &ega_console_resource);\n\t\t} else {\n\t\t\tstatic struct resource mda1_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BB };\n\t\t\tstatic struct resource mda2_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3BF,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_MDA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda1_console_resource);\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda2_console_resource);\n\t\t\tvga_video_font_height = 14;\n\t\t}\n\t} else {\n\t\t/* If not, it is color. */\n\t\tvga_can_do_color = true;\n\t\tvga_vram_base = 0xb8000;\n\t\tvga_video_port_reg = VGA_CRT_IC;\n\t\tvga_video_port_val = VGA_CRT_DC;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tint i;\n\n\t\t\tvga_vram_size = 0x8000;\n\n\t\t\tif (!screen_info.orig_video_isVGA) {\n\t\t\t\tstatic struct resource ega_console_resource =\n\t\t\t\t    { .name\t= \"ega\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_EGAC;\n\t\t\t\tdisplay_desc = \"EGA\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &ega_console_resource);\n\t\t\t} else {\n\t\t\t\tstatic struct resource vga_console_resource =\n\t\t\t\t    { .name\t= \"vga+\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_VGAC;\n\t\t\t\tdisplay_desc = \"VGA+\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &vga_console_resource);\n\n\t\t\t\t/*\n\t\t\t\t * Normalise the palette registers, to point\n\t\t\t\t * the 16 screen colours to the first 16\n\t\t\t\t * DAC entries.\n\t\t\t\t */\n\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tinb_p(VGA_IS1_RC);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t}\n\t\t\t\toutb_p(0x20, VGA_ATT_W);\n\n\t\t\t\t/*\n\t\t\t\t * Now set the DAC registers back to their\n\t\t\t\t * default values\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\toutb_p(color_table[i], VGA_PEL_IW);\n\t\t\t\t\toutb_p(default_red[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_grn[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_blu[i], VGA_PEL_D);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstatic struct resource cga_console_resource =\n\t\t\t    { .name\t= \"cga\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3D4,\n\t\t\t      .end\t= 0x3D5 };\n\t\t\tvga_video_type = VIDEO_TYPE_CGA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &cga_console_resource);\n\t\t\tvga_video_font_height = 8;\n\t\t}\n\t}\n\n\tvga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);\n\tvga_vram_end = vga_vram_base + vga_vram_size;\n\n\t/*\n\t *      Find out if there is a graphics card present.\n\t *      Are there smarter methods around?\n\t */\n\tp = (volatile u16 *) vga_vram_base;\n\tsaved1 = scr_readw(p);\n\tsaved2 = scr_readw(p + 1);\n\tscr_writew(0xAA55, p);\n\tscr_writew(0x55AA, p + 1);\n\tif (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(0x55AA, p);\n\tscr_writew(0xAA55, p + 1);\n\tif (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(saved1, p);\n\tscr_writew(saved2, p + 1);\n\n\tif (vga_video_type == VIDEO_TYPE_EGAC\n\t    || vga_video_type == VIDEO_TYPE_VGAC\n\t    || vga_video_type == VIDEO_TYPE_EGAM) {\n\t\tvga_hardscroll_enabled = vga_hardscroll_user_enable;\n\t\tvga_default_font_height = screen_info.orig_video_points;\n\t\tvga_video_font_height = screen_info.orig_video_points;\n\t\t/* This may be suboptimal but is a safe bet - go with it */\n\t\tvga_scan_lines =\n\t\t    vga_video_font_height * vga_video_num_lines;\n\t}\n\n\tvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\n\tvgacon_yres = vga_scan_lines;\n\n\tvga_init_done = true;\n\n\treturn display_desc;\n}\n\nstatic void vgacon_init(struct vc_data *c, int init)\n{\n\tstruct uni_pagedir *p;\n\n\t/*\n\t * We cannot be loaded as a module, therefore init is always 1,\n\t * but vgacon_init can be called more than once, and init will\n\t * not be 1.\n\t */\n\tc->vc_can_do_color = vga_can_do_color;\n\n\t/* set dimensions manually if init != 0 since vc_resize() will fail */\n\tif (init) {\n\t\tc->vc_cols = vga_video_num_columns;\n\t\tc->vc_rows = vga_video_num_lines;\n\t} else\n\t\tvc_resize(c, vga_video_num_columns, vga_video_num_lines);\n\n\tc->vc_scan_lines = vga_scan_lines;\n\tc->vc_font.height = vga_video_font_height;\n\tc->vc_complement_mask = 0x7700;\n\tif (vga_512_chars)\n\t\tc->vc_hi_font_mask = 0x0800;\n\tp = *c->vc_uni_pagedir_loc;\n\tif (c->vc_uni_pagedir_loc != &vgacon_uni_pagedir) {\n\t\tcon_free_unimap(c);\n\t\tc->vc_uni_pagedir_loc = &vgacon_uni_pagedir;\n\t\tvgacon_refcount++;\n\t}\n\tif (!vgacon_uni_pagedir && p)\n\t\tcon_set_default_unimap(c);\n\n\t/* Only set the default if the user didn't deliberately override it */\n\tif (global_cursor_default == -1)\n\t\tglobal_cursor_default =\n\t\t\t!(screen_info.flags & VIDEO_FLAGS_NOCURSOR);\n}\n\nstatic void vgacon_deinit(struct vc_data *c)\n{\n\t/* When closing the active console, reset video origin */\n\tif (con_is_visible(c)) {\n\t\tc->vc_visible_origin = vga_vram_base;\n\t\tvga_set_mem_top(c);\n\t}\n\n\tif (!--vgacon_refcount)\n\t\tcon_free_unimap(c);\n\tc->vc_uni_pagedir_loc = &c->vc_uni_pagedir;\n\tcon_set_default_unimap(c);\n}\n\nstatic u8 vgacon_build_attr(struct vc_data *c, u8 color,\n\t\t\t    enum vc_intensity intensity,\n\t\t\t    bool blink, bool underline, bool reverse,\n\t\t\t    bool italic)\n{\n\tu8 attr = color;\n\n\tif (vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF0) | c->vc_itcolor;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf0) | c->vc_ulcolor;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | c->vc_halfcolor;\n\t}\n\tif (reverse)\n\t\tattr =\n\t\t    ((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) &\n\t\t\t\t       0x77);\n\tif (blink)\n\t\tattr ^= 0x80;\n\tif (intensity == VCI_BOLD)\n\t\tattr ^= 0x08;\n\tif (!vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF8) | 0x02;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf8) | 0x01;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | 0x08;\n\t}\n\treturn attr;\n}\n\nstatic void vgacon_invert_region(struct vc_data *c, u16 * p, int count)\n{\n\tconst bool col = vga_can_do_color;\n\n\twhile (count--) {\n\t\tu16 a = scr_readw(p);\n\t\tif (col)\n\t\t\ta = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) |\n\t\t\t    (((a) & 0x0700) << 4);\n\t\telse\n\t\t\ta ^= ((a & 0x0700) == 0x0100) ? 0x7000 : 0x7700;\n\t\tscr_writew(a, p++);\n\t}\n}\n\nstatic void vgacon_set_cursor_size(int xpos, int from, int to)\n{\n\tunsigned long flags;\n\tint curs, cure;\n\n\tif ((from == cursor_size_lastfrom) && (to == cursor_size_lastto))\n\t\treturn;\n\tcursor_size_lastfrom = from;\n\tcursor_size_lastto = to;\n\n\traw_spin_lock_irqsave(&vga_lock, flags);\n\tif (vga_video_type >= VIDEO_TYPE_VGAC) {\n\t\toutb_p(VGA_CRTC_CURSOR_START, vga_video_port_reg);\n\t\tcurs = inb_p(vga_video_port_val);\n\t\toutb_p(VGA_CRTC_CURSOR_END, vga_video_port_reg);\n\t\tcure = inb_p(vga_video_port_val);\n\t} else {\n\t\tcurs = 0;\n\t\tcure = 0;\n\t}\n\n\tcurs = (curs & 0xc0) | from;\n\tcure = (cure & 0xe0) | to;\n\n\toutb_p(VGA_CRTC_CURSOR_START, vga_video_port_reg);\n\toutb_p(curs, vga_video_port_val);\n\toutb_p(VGA_CRTC_CURSOR_END, vga_video_port_reg);\n\toutb_p(cure, vga_video_port_val);\n\traw_spin_unlock_irqrestore(&vga_lock, flags);\n}\n\nstatic void vgacon_cursor(struct vc_data *c, int mode)\n{\n\tif (c->vc_mode != KD_TEXT)\n\t\treturn;\n\n\tvgacon_restore_screen(c);\n\n\tswitch (mode) {\n\tcase CM_ERASE:\n\t\twrite_vga(14, (c->vc_pos - vga_vram_base) / 2);\n\t        if (vga_video_type >= VIDEO_TYPE_VGAC)\n\t\t\tvgacon_set_cursor_size(c->state.x, 31, 30);\n\t\telse\n\t\t\tvgacon_set_cursor_size(c->state.x, 31, 31);\n\t\tbreak;\n\n\tcase CM_MOVE:\n\tcase CM_DRAW:\n\t\twrite_vga(14, (c->vc_pos - vga_vram_base) / 2);\n\t\tswitch (CUR_SIZE(c->vc_cursor_type)) {\n\t\tcase CUR_UNDERLINE:\n\t\t\tvgacon_set_cursor_size(c->state.x,\n\t\t\t\t\t       c->vc_font.height -\n\t\t\t\t\t       (c->vc_font.height <\n\t\t\t\t\t\t10 ? 2 : 3),\n\t\t\t\t\t       c->vc_font.height -\n\t\t\t\t\t       (c->vc_font.height <\n\t\t\t\t\t\t10 ? 1 : 2));\n\t\t\tbreak;\n\t\tcase CUR_TWO_THIRDS:\n\t\t\tvgacon_set_cursor_size(c->state.x,\n\t\t\t\t\t       c->vc_font.height / 3,\n\t\t\t\t\t       c->vc_font.height -\n\t\t\t\t\t       (c->vc_font.height <\n\t\t\t\t\t\t10 ? 1 : 2));\n\t\t\tbreak;\n\t\tcase CUR_LOWER_THIRD:\n\t\t\tvgacon_set_cursor_size(c->state.x,\n\t\t\t\t\t       (c->vc_font.height * 2) / 3,\n\t\t\t\t\t       c->vc_font.height -\n\t\t\t\t\t       (c->vc_font.height <\n\t\t\t\t\t\t10 ? 1 : 2));\n\t\t\tbreak;\n\t\tcase CUR_LOWER_HALF:\n\t\t\tvgacon_set_cursor_size(c->state.x,\n\t\t\t\t\t       c->vc_font.height / 2,\n\t\t\t\t\t       c->vc_font.height -\n\t\t\t\t\t       (c->vc_font.height <\n\t\t\t\t\t\t10 ? 1 : 2));\n\t\t\tbreak;\n\t\tcase CUR_NONE:\n\t\t\tif (vga_video_type >= VIDEO_TYPE_VGAC)\n\t\t\t\tvgacon_set_cursor_size(c->state.x, 31, 30);\n\t\t\telse\n\t\t\t\tvgacon_set_cursor_size(c->state.x, 31, 31);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvgacon_set_cursor_size(c->state.x, 1,\n\t\t\t\t\t       c->vc_font.height);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int vgacon_doresize(struct vc_data *c,\n\t\tunsigned int width, unsigned int height)\n{\n\tunsigned long flags;\n\tunsigned int scanlines = height * c->vc_font.height;\n\tu8 scanlines_lo = 0, r7 = 0, vsync_end = 0, mode, max_scan;\n\n\traw_spin_lock_irqsave(&vga_lock, flags);\n\n\tvgacon_xres = width * VGA_FONTWIDTH;\n\tvgacon_yres = height * c->vc_font.height;\n\tif (vga_video_type >= VIDEO_TYPE_VGAC) {\n\t\toutb_p(VGA_CRTC_MAX_SCAN, vga_video_port_reg);\n\t\tmax_scan = inb_p(vga_video_port_val);\n\n\t\tif (max_scan & 0x80)\n\t\t\tscanlines <<= 1;\n\n\t\toutb_p(VGA_CRTC_MODE, vga_video_port_reg);\n\t\tmode = inb_p(vga_video_port_val);\n\n\t\tif (mode & 0x04)\n\t\t\tscanlines >>= 1;\n\n\t\tscanlines -= 1;\n\t\tscanlines_lo = scanlines & 0xff;\n\n\t\toutb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);\n\t\tr7 = inb_p(vga_video_port_val) & ~0x42;\n\n\t\tif (scanlines & 0x100)\n\t\t\tr7 |= 0x02;\n\t\tif (scanlines & 0x200)\n\t\t\tr7 |= 0x40;\n\n\t\t/* deprotect registers */\n\t\toutb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);\n\t\tvsync_end = inb_p(vga_video_port_val);\n\t\toutb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);\n\t\toutb_p(vsync_end & ~0x80, vga_video_port_val);\n\t}\n\n\toutb_p(VGA_CRTC_H_DISP, vga_video_port_reg);\n\toutb_p(width - 1, vga_video_port_val);\n\toutb_p(VGA_CRTC_OFFSET, vga_video_port_reg);\n\toutb_p(width >> 1, vga_video_port_val);\n\n\tif (vga_video_type >= VIDEO_TYPE_VGAC) {\n\t\toutb_p(VGA_CRTC_V_DISP_END, vga_video_port_reg);\n\t\toutb_p(scanlines_lo, vga_video_port_val);\n\t\toutb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);\n\t\toutb_p(r7,vga_video_port_val);\n\n\t\t/* reprotect registers */\n\t\toutb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);\n\t\toutb_p(vsync_end, vga_video_port_val);\n\t}\n\n\traw_spin_unlock_irqrestore(&vga_lock, flags);\n\treturn 0;\n}\n\nstatic int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\t/*\n\t * We need to save screen size here as it's the only way\n\t * we can spot the screen has been resized and we need to\n\t * set size of freshly allocated screens ourselves.\n\t */\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\n\t/* We can only copy out the size of the video buffer here,\n\t * otherwise we get into VGA BIOS */\n\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\n\treturn 0;\t\t/* Redrawing not needed */\n}\n\nstatic void vga_set_palette(struct vc_data *vc, const unsigned char *table)\n{\n\tint i, j;\n\n\tvga_w(vgastate.vgabase, VGA_PEL_MSK, 0xff);\n\tfor (i = j = 0; i < 16; i++) {\n\t\tvga_w(vgastate.vgabase, VGA_PEL_IW, table[i]);\n\t\tvga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);\n\t\tvga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);\n\t\tvga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);\n\t}\n}\n\nstatic void vgacon_set_palette(struct vc_data *vc, const unsigned char *table)\n{\n\tif (vga_video_type != VIDEO_TYPE_VGAC || vga_palette_blanked\n\t    || !con_is_visible(vc))\n\t\treturn;\n\tvga_set_palette(vc, table);\n}\n\n/* structure holding original VGA register settings */\nstatic struct {\n\tunsigned char SeqCtrlIndex;\t/* Sequencer Index reg.   */\n\tunsigned char CrtCtrlIndex;\t/* CRT-Contr. Index reg.  */\n\tunsigned char CrtMiscIO;\t/* Miscellaneous register */\n\tunsigned char HorizontalTotal;\t/* CRT-Controller:00h */\n\tunsigned char HorizDisplayEnd;\t/* CRT-Controller:01h */\n\tunsigned char StartHorizRetrace;\t/* CRT-Controller:04h */\n\tunsigned char EndHorizRetrace;\t/* CRT-Controller:05h */\n\tunsigned char Overflow;\t/* CRT-Controller:07h */\n\tunsigned char StartVertRetrace;\t/* CRT-Controller:10h */\n\tunsigned char EndVertRetrace;\t/* CRT-Controller:11h */\n\tunsigned char ModeControl;\t/* CRT-Controller:17h */\n\tunsigned char ClockingMode;\t/* Seq-Controller:01h */\n} vga_state;\n\nstatic void vga_vesa_blank(struct vgastate *state, int mode)\n{\n\t/* save original values of VGA controller registers */\n\tif (!vga_vesa_blanked) {\n\t\traw_spin_lock_irq(&vga_lock);\n\t\tvga_state.SeqCtrlIndex = vga_r(state->vgabase, VGA_SEQ_I);\n\t\tvga_state.CrtCtrlIndex = inb_p(vga_video_port_reg);\n\t\tvga_state.CrtMiscIO = vga_r(state->vgabase, VGA_MIS_R);\n\t\traw_spin_unlock_irq(&vga_lock);\n\n\t\toutb_p(0x00, vga_video_port_reg);\t/* HorizontalTotal */\n\t\tvga_state.HorizontalTotal = inb_p(vga_video_port_val);\n\t\toutb_p(0x01, vga_video_port_reg);\t/* HorizDisplayEnd */\n\t\tvga_state.HorizDisplayEnd = inb_p(vga_video_port_val);\n\t\toutb_p(0x04, vga_video_port_reg);\t/* StartHorizRetrace */\n\t\tvga_state.StartHorizRetrace = inb_p(vga_video_port_val);\n\t\toutb_p(0x05, vga_video_port_reg);\t/* EndHorizRetrace */\n\t\tvga_state.EndHorizRetrace = inb_p(vga_video_port_val);\n\t\toutb_p(0x07, vga_video_port_reg);\t/* Overflow */\n\t\tvga_state.Overflow = inb_p(vga_video_port_val);\n\t\toutb_p(0x10, vga_video_port_reg);\t/* StartVertRetrace */\n\t\tvga_state.StartVertRetrace = inb_p(vga_video_port_val);\n\t\toutb_p(0x11, vga_video_port_reg);\t/* EndVertRetrace */\n\t\tvga_state.EndVertRetrace = inb_p(vga_video_port_val);\n\t\toutb_p(0x17, vga_video_port_reg);\t/* ModeControl */\n\t\tvga_state.ModeControl = inb_p(vga_video_port_val);\n\t\tvga_state.ClockingMode = vga_rseq(state->vgabase, VGA_SEQ_CLOCK_MODE);\n\t}\n\n\t/* assure that video is enabled */\n\t/* \"0x20\" is VIDEO_ENABLE_bit in register 01 of sequencer */\n\traw_spin_lock_irq(&vga_lock);\n\tvga_wseq(state->vgabase, VGA_SEQ_CLOCK_MODE, vga_state.ClockingMode | 0x20);\n\n\t/* test for vertical retrace in process.... */\n\tif ((vga_state.CrtMiscIO & 0x80) == 0x80)\n\t\tvga_w(state->vgabase, VGA_MIS_W, vga_state.CrtMiscIO & 0xEF);\n\n\t/*\n\t * Set <End of vertical retrace> to minimum (0) and\n\t * <Start of vertical Retrace> to maximum (incl. overflow)\n\t * Result: turn off vertical sync (VSync) pulse.\n\t */\n\tif (mode & VESA_VSYNC_SUSPEND) {\n\t\toutb_p(0x10, vga_video_port_reg);\t/* StartVertRetrace */\n\t\toutb_p(0xff, vga_video_port_val);\t/* maximum value */\n\t\toutb_p(0x11, vga_video_port_reg);\t/* EndVertRetrace */\n\t\toutb_p(0x40, vga_video_port_val);\t/* minimum (bits 0..3)  */\n\t\toutb_p(0x07, vga_video_port_reg);\t/* Overflow */\n\t\toutb_p(vga_state.Overflow | 0x84, vga_video_port_val);\t/* bits 9,10 of vert. retrace */\n\t}\n\n\tif (mode & VESA_HSYNC_SUSPEND) {\n\t\t/*\n\t\t * Set <End of horizontal retrace> to minimum (0) and\n\t\t *  <Start of horizontal Retrace> to maximum\n\t\t * Result: turn off horizontal sync (HSync) pulse.\n\t\t */\n\t\toutb_p(0x04, vga_video_port_reg);\t/* StartHorizRetrace */\n\t\toutb_p(0xff, vga_video_port_val);\t/* maximum */\n\t\toutb_p(0x05, vga_video_port_reg);\t/* EndHorizRetrace */\n\t\toutb_p(0x00, vga_video_port_val);\t/* minimum (0) */\n\t}\n\n\t/* restore both index registers */\n\tvga_w(state->vgabase, VGA_SEQ_I, vga_state.SeqCtrlIndex);\n\toutb_p(vga_state.CrtCtrlIndex, vga_video_port_reg);\n\traw_spin_unlock_irq(&vga_lock);\n}\n\nstatic void vga_vesa_unblank(struct vgastate *state)\n{\n\t/* restore original values of VGA controller registers */\n\traw_spin_lock_irq(&vga_lock);\n\tvga_w(state->vgabase, VGA_MIS_W, vga_state.CrtMiscIO);\n\n\toutb_p(0x00, vga_video_port_reg);\t/* HorizontalTotal */\n\toutb_p(vga_state.HorizontalTotal, vga_video_port_val);\n\toutb_p(0x01, vga_video_port_reg);\t/* HorizDisplayEnd */\n\toutb_p(vga_state.HorizDisplayEnd, vga_video_port_val);\n\toutb_p(0x04, vga_video_port_reg);\t/* StartHorizRetrace */\n\toutb_p(vga_state.StartHorizRetrace, vga_video_port_val);\n\toutb_p(0x05, vga_video_port_reg);\t/* EndHorizRetrace */\n\toutb_p(vga_state.EndHorizRetrace, vga_video_port_val);\n\toutb_p(0x07, vga_video_port_reg);\t/* Overflow */\n\toutb_p(vga_state.Overflow, vga_video_port_val);\n\toutb_p(0x10, vga_video_port_reg);\t/* StartVertRetrace */\n\toutb_p(vga_state.StartVertRetrace, vga_video_port_val);\n\toutb_p(0x11, vga_video_port_reg);\t/* EndVertRetrace */\n\toutb_p(vga_state.EndVertRetrace, vga_video_port_val);\n\toutb_p(0x17, vga_video_port_reg);\t/* ModeControl */\n\toutb_p(vga_state.ModeControl, vga_video_port_val);\n\t/* ClockingMode */\n\tvga_wseq(state->vgabase, VGA_SEQ_CLOCK_MODE, vga_state.ClockingMode);\n\n\t/* restore index/control registers */\n\tvga_w(state->vgabase, VGA_SEQ_I, vga_state.SeqCtrlIndex);\n\toutb_p(vga_state.CrtCtrlIndex, vga_video_port_reg);\n\traw_spin_unlock_irq(&vga_lock);\n}\n\nstatic void vga_pal_blank(struct vgastate *state)\n{\n\tint i;\n\n\tvga_w(state->vgabase, VGA_PEL_MSK, 0xff);\n\tfor (i = 0; i < 16; i++) {\n\t\tvga_w(state->vgabase, VGA_PEL_IW, i);\n\t\tvga_w(state->vgabase, VGA_PEL_D, 0);\n\t\tvga_w(state->vgabase, VGA_PEL_D, 0);\n\t\tvga_w(state->vgabase, VGA_PEL_D, 0);\n\t}\n}\n\nstatic int vgacon_blank(struct vc_data *c, int blank, int mode_switch)\n{\n\tswitch (blank) {\n\tcase 0:\t\t/* Unblank */\n\t\tif (vga_vesa_blanked) {\n\t\t\tvga_vesa_unblank(&vgastate);\n\t\t\tvga_vesa_blanked = 0;\n\t\t}\n\t\tif (vga_palette_blanked) {\n\t\t\tvga_set_palette(c, color_table);\n\t\t\tvga_palette_blanked = false;\n\t\t\treturn 0;\n\t\t}\n\t\tvga_is_gfx = false;\n\t\t/* Tell console.c that it has to restore the screen itself */\n\t\treturn 1;\n\tcase 1:\t\t/* Normal blanking */\n\tcase -1:\t/* Obsolete */\n\t\tif (!mode_switch && vga_video_type == VIDEO_TYPE_VGAC) {\n\t\t\tvga_pal_blank(&vgastate);\n\t\t\tvga_palette_blanked = true;\n\t\t\treturn 0;\n\t\t}\n\t\tvgacon_set_origin(c);\n\t\tscr_memsetw((void *) vga_vram_base, BLANK,\n\t\t\t    c->vc_screenbuf_size);\n\t\tif (mode_switch)\n\t\t\tvga_is_gfx = true;\n\t\treturn 1;\n\tdefault:\t\t/* VESA blanking */\n\t\tif (vga_video_type == VIDEO_TYPE_VGAC) {\n\t\t\tvga_vesa_blank(&vgastate, blank - 1);\n\t\t\tvga_vesa_blanked = blank;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\n/*\n * PIO_FONT support.\n *\n * The font loading code goes back to the codepage package by\n * Joel Hoffman (joel@wam.umd.edu). (He reports that the original\n * reference is: \"From: p. 307 of _Programmer's Guide to PC & PS/2\n * Video Systems_ by Richard Wilton. 1987.  Microsoft Press\".)\n *\n * Change for certain monochrome monitors by Yury Shevchuck\n * (sizif@botik.yaroslavl.su).\n */\n\n#define colourmap 0xa0000\n/* Pauline Middelink <middelin@polyware.iaf.nl> reports that we\n   should use 0xA0000 for the bwmap as well.. */\n#define blackwmap 0xa0000\n#define cmapsz 8192\n\nstatic int vgacon_do_font_op(struct vgastate *state, char *arg, int set,\n\t\tbool ch512)\n{\n\tunsigned short video_port_status = vga_video_port_reg + 6;\n\tint font_select = 0x00, beg, i;\n\tchar *charmap;\n\tbool clear_attribs = false;\n\tif (vga_video_type != VIDEO_TYPE_EGAM) {\n\t\tcharmap = (char *) VGA_MAP_MEM(colourmap, 0);\n\t\tbeg = 0x0e;\n\t} else {\n\t\tcharmap = (char *) VGA_MAP_MEM(blackwmap, 0);\n\t\tbeg = 0x0a;\n\t}\n\n#ifdef BROKEN_GRAPHICS_PROGRAMS\n\t/*\n\t * All fonts are loaded in slot 0 (0:1 for 512 ch)\n\t */\n\n\tif (!arg)\n\t\treturn -EINVAL;\t/* Return to default font not supported */\n\n\tvga_font_is_default = false;\n\tfont_select = ch512 ? 0x04 : 0x00;\n#else\n\t/*\n\t * The default font is kept in slot 0 and is never touched.\n\t * A custom font is loaded in slot 2 (256 ch) or 2:3 (512 ch)\n\t */\n\n\tif (set) {\n\t\tvga_font_is_default = !arg;\n\t\tif (!arg)\n\t\t\tch512 = false;\t/* Default font is always 256 */\n\t\tfont_select = arg ? (ch512 ? 0x0e : 0x0a) : 0x00;\n\t}\n\n\tif (!vga_font_is_default)\n\t\tcharmap += 4 * cmapsz;\n#endif\n\n\traw_spin_lock_irq(&vga_lock);\n\t/* First, the Sequencer */\n\tvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x1);\n\t/* CPU writes only to map 2 */\n\tvga_wseq(state->vgabase, VGA_SEQ_PLANE_WRITE, 0x04);\t\n\t/* Sequential addressing */\n\tvga_wseq(state->vgabase, VGA_SEQ_MEMORY_MODE, 0x07);\t\n\t/* Clear synchronous reset */\n\tvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x03);\n\n\t/* Now, the graphics controller, select map 2 */\n\tvga_wgfx(state->vgabase, VGA_GFX_PLANE_READ, 0x02);\t\t\n\t/* disable odd-even addressing */\n\tvga_wgfx(state->vgabase, VGA_GFX_MODE, 0x00);\n\t/* map start at A000:0000 */\n\tvga_wgfx(state->vgabase, VGA_GFX_MISC, 0x00);\n\traw_spin_unlock_irq(&vga_lock);\n\n\tif (arg) {\n\t\tif (set)\n\t\t\tfor (i = 0; i < cmapsz; i++) {\n\t\t\t\tvga_writeb(arg[i], charmap + i);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\telse\n\t\t\tfor (i = 0; i < cmapsz; i++) {\n\t\t\t\targ[i] = vga_readb(charmap + i);\n\t\t\t\tcond_resched();\n\t\t\t}\n\n\t\t/*\n\t\t * In 512-character mode, the character map is not contiguous if\n\t\t * we want to remain EGA compatible -- which we do\n\t\t */\n\n\t\tif (ch512) {\n\t\t\tcharmap += 2 * cmapsz;\n\t\t\targ += cmapsz;\n\t\t\tif (set)\n\t\t\t\tfor (i = 0; i < cmapsz; i++) {\n\t\t\t\t\tvga_writeb(arg[i], charmap + i);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tfor (i = 0; i < cmapsz; i++) {\n\t\t\t\t\targ[i] = vga_readb(charmap + i);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t}\n\t}\n\n\traw_spin_lock_irq(&vga_lock);\n\t/* First, the sequencer, Synchronous reset */\n\tvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x01);\t\n\t/* CPU writes to maps 0 and 1 */\n\tvga_wseq(state->vgabase, VGA_SEQ_PLANE_WRITE, 0x03);\n\t/* odd-even addressing */\n\tvga_wseq(state->vgabase, VGA_SEQ_MEMORY_MODE, 0x03);\n\t/* Character Map Select */\n\tif (set)\n\t\tvga_wseq(state->vgabase, VGA_SEQ_CHARACTER_MAP, font_select);\n\t/* clear synchronous reset */\n\tvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x03);\n\n\t/* Now, the graphics controller, select map 0 for CPU */\n\tvga_wgfx(state->vgabase, VGA_GFX_PLANE_READ, 0x00);\n\t/* enable even-odd addressing */\n\tvga_wgfx(state->vgabase, VGA_GFX_MODE, 0x10);\n\t/* map starts at b800:0 or b000:0 */\n\tvga_wgfx(state->vgabase, VGA_GFX_MISC, beg);\n\n\t/* if 512 char mode is already enabled don't re-enable it. */\n\tif ((set) && (ch512 != vga_512_chars)) {\n\t\tvga_512_chars = ch512;\n\t\t/* 256-char: enable intensity bit\n\t\t   512-char: disable intensity bit */\n\t\tinb_p(video_port_status);\t/* clear address flip-flop */\n\t\t/* color plane enable register */\n\t\tvga_wattr(state->vgabase, VGA_ATC_PLANE_ENABLE, ch512 ? 0x07 : 0x0f);\n\t\t/* Wilton (1987) mentions the following; I don't know what\n\t\t   it means, but it works, and it appears necessary */\n\t\tinb_p(video_port_status);\n\t\tvga_wattr(state->vgabase, VGA_AR_ENABLE_DISPLAY, 0);\t\n\t\tclear_attribs = true;\n\t}\n\traw_spin_unlock_irq(&vga_lock);\n\n\tif (clear_attribs) {\n\t\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\t\tstruct vc_data *c = vc_cons[i].d;\n\t\t\tif (c && c->vc_sw == &vga_con) {\n\t\t\t\t/* force hi font mask to 0, so we always clear\n\t\t\t\t   the bit on either transition */\n\t\t\t\tc->vc_hi_font_mask = 0x00;\n\t\t\t\tclear_buffer_attributes(c);\n\t\t\t\tc->vc_hi_font_mask = ch512 ? 0x0800 : 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * Adjust the screen to fit a font of a certain height\n */\nstatic int vgacon_adjust_height(struct vc_data *vc, unsigned fontheight)\n{\n\tunsigned char ovr, vde, fsr;\n\tint rows, maxscan, i;\n\n\trows = vc->vc_scan_lines / fontheight;\t/* Number of video rows we end up with */\n\tmaxscan = rows * fontheight - 1;\t/* Scan lines to actually display-1 */\n\n\t/* Reprogram the CRTC for the new font size\n\t   Note: the attempt to read the overflow register will fail\n\t   on an EGA, but using 0xff for the previous value appears to\n\t   be OK for EGA text modes in the range 257-512 scan lines, so I\n\t   guess we don't need to worry about it.\n\n\t   The same applies for the spill bits in the font size and cursor\n\t   registers; they are write-only on EGA, but it appears that they\n\t   are all don't care bits on EGA, so I guess it doesn't matter. */\n\n\traw_spin_lock_irq(&vga_lock);\n\toutb_p(0x07, vga_video_port_reg);\t/* CRTC overflow register */\n\tovr = inb_p(vga_video_port_val);\n\toutb_p(0x09, vga_video_port_reg);\t/* Font size register */\n\tfsr = inb_p(vga_video_port_val);\n\traw_spin_unlock_irq(&vga_lock);\n\n\tvde = maxscan & 0xff;\t/* Vertical display end reg */\n\tovr = (ovr & 0xbd) +\t/* Overflow register */\n\t    ((maxscan & 0x100) >> 7) + ((maxscan & 0x200) >> 3);\n\tfsr = (fsr & 0xe0) + (fontheight - 1);\t/*  Font size register */\n\n\traw_spin_lock_irq(&vga_lock);\n\toutb_p(0x07, vga_video_port_reg);\t/* CRTC overflow register */\n\toutb_p(ovr, vga_video_port_val);\n\toutb_p(0x09, vga_video_port_reg);\t/* Font size */\n\toutb_p(fsr, vga_video_port_val);\n\toutb_p(0x12, vga_video_port_reg);\t/* Vertical display limit */\n\toutb_p(vde, vga_video_port_val);\n\traw_spin_unlock_irq(&vga_lock);\n\tvga_video_font_height = fontheight;\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\tstruct vc_data *c = vc_cons[i].d;\n\n\t\tif (c && c->vc_sw == &vga_con) {\n\t\t\tif (con_is_visible(c)) {\n\t\t\t        /* void size to cause regs to be rewritten */\n\t\t\t\tcursor_size_lastfrom = 0;\n\t\t\t\tcursor_size_lastto = 0;\n\t\t\t\tc->vc_sw->con_cursor(c, CM_DRAW);\n\t\t\t}\n\t\t\tc->vc_font.height = fontheight;\n\t\t\tvc_resize(c, 0, rows);\t/* Adjust console size */\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int vgacon_font_set(struct vc_data *c, struct console_font *font,\n\t\t\t   unsigned int flags)\n{\n\tunsigned charcount = font->charcount;\n\tint rc;\n\n\tif (vga_video_type < VIDEO_TYPE_EGAM)\n\t\treturn -EINVAL;\n\n\tif (font->width != VGA_FONTWIDTH ||\n\t    (charcount != 256 && charcount != 512))\n\t\treturn -EINVAL;\n\n\trc = vgacon_do_font_op(&vgastate, font->data, 1, charcount == 512);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!(flags & KD_FONT_FLAG_DONT_RECALC))\n\t\trc = vgacon_adjust_height(c, font->height);\n\treturn rc;\n}\n\nstatic int vgacon_font_get(struct vc_data *c, struct console_font *font)\n{\n\tif (vga_video_type < VIDEO_TYPE_EGAM)\n\t\treturn -EINVAL;\n\n\tfont->width = VGA_FONTWIDTH;\n\tfont->height = c->vc_font.height;\n\tfont->charcount = vga_512_chars ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\treturn vgacon_do_font_op(&vgastate, font->data, 0, vga_512_chars);\n}\n\nstatic int vgacon_resize(struct vc_data *c, unsigned int width,\n\t\t\t unsigned int height, unsigned int user)\n{\n\tif ((width << 1) * height > vga_vram_size)\n\t\treturn -EINVAL;\n\n\tif (width % 2 || width > screen_info.orig_video_cols ||\n\t    height > (screen_info.orig_video_lines * vga_default_font_height)/\n\t    c->vc_font.height)\n\t\t/* let svgatextmode tinker with video timings and\n\t\t   return success */\n\t\treturn (user) ? 0 : -EINVAL;\n\n\tif (con_is_visible(c) && !vga_is_gfx) /* who knows */\n\t\tvgacon_doresize(c, width, height);\n\treturn 0;\n}\n\nstatic int vgacon_set_origin(struct vc_data *c)\n{\n\tif (vga_is_gfx ||\t/* We don't play origin tricks in graphic modes */\n\t    (console_blanked && !vga_palette_blanked))\t/* Nor we write to blanked screens */\n\t\treturn 0;\n\tc->vc_origin = c->vc_visible_origin = vga_vram_base;\n\tvga_set_mem_top(c);\n\tvga_rolled_over = 0;\n\treturn 1;\n}\n\nstatic void vgacon_save_screen(struct vc_data *c)\n{\n\tstatic int vga_bootup_console = 0;\n\n\tif (!vga_bootup_console) {\n\t\t/* This is a gross hack, but here is the only place we can\n\t\t * set bootup console parameters without messing up generic\n\t\t * console initialization routines.\n\t\t */\n\t\tvga_bootup_console = 1;\n\t\tc->state.x = screen_info.orig_x;\n\t\tc->state.y = screen_info.orig_y;\n\t}\n\n\t/* We can't copy in more than the size of the video buffer,\n\t * or we'll be copying in VGA BIOS */\n\n\tif (!vga_is_gfx)\n\t\tscr_memcpyw((u16 *) c->vc_screenbuf, (u16 *) c->vc_origin,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ? vga_vram_size : c->vc_screenbuf_size);\n}\n\nstatic bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tunsigned long oldo;\n\tunsigned int delta;\n\n\tif (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)\n\t\treturn false;\n\n\tif (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)\n\t\treturn false;\n\n\tvgacon_restore_screen(c);\n\toldo = c->vc_origin;\n\tdelta = lines * c->vc_size_row;\n\tif (dir == SM_UP) {\n\t\tif (c->vc_scr_end + delta >= vga_vram_end) {\n\t\t\tscr_memcpyw((u16 *) vga_vram_base,\n\t\t\t\t    (u16 *) (oldo + delta),\n\t\t\t\t    c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_base;\n\t\t\tvga_rolled_over = oldo - vga_vram_base;\n\t\t} else\n\t\t\tc->vc_origin += delta;\n\t\tscr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -\n\t\t\t\t     delta), c->vc_video_erase_char,\n\t\t\t    delta);\n\t} else {\n\t\tif (oldo - delta < vga_vram_base) {\n\t\t\tscr_memmovew((u16 *) (vga_vram_end -\n\t\t\t\t\t      c->vc_screenbuf_size +\n\t\t\t\t\t      delta), (u16 *) oldo,\n\t\t\t\t     c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_end - c->vc_screenbuf_size;\n\t\t\tvga_rolled_over = 0;\n\t\t} else\n\t\t\tc->vc_origin -= delta;\n\t\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\t\tscr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,\n\t\t\t    delta);\n\t}\n\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\tc->vc_visible_origin = c->vc_origin;\n\tvga_set_mem_top(c);\n\tc->vc_pos = (c->vc_pos - oldo) + c->vc_origin;\n\treturn true;\n}\n\n/*\n *  The console `switch' structure for the VGA based console\n */\n\nstatic void vgacon_clear(struct vc_data *vc, int sy, int sx, int height,\n\t\t\t int width) { }\nstatic void vgacon_putc(struct vc_data *vc, int c, int ypos, int xpos) { }\nstatic void vgacon_putcs(struct vc_data *vc, const unsigned short *s,\n\t\t\t int count, int ypos, int xpos) { }\n\nconst struct consw vga_con = {\n\t.owner = THIS_MODULE,\n\t.con_startup = vgacon_startup,\n\t.con_init = vgacon_init,\n\t.con_deinit = vgacon_deinit,\n\t.con_clear = vgacon_clear,\n\t.con_putc = vgacon_putc,\n\t.con_putcs = vgacon_putcs,\n\t.con_cursor = vgacon_cursor,\n\t.con_scroll = vgacon_scroll,\n\t.con_switch = vgacon_switch,\n\t.con_blank = vgacon_blank,\n\t.con_font_set = vgacon_font_set,\n\t.con_font_get = vgacon_font_get,\n\t.con_resize = vgacon_resize,\n\t.con_set_palette = vgacon_set_palette,\n\t.con_scrolldelta = vgacon_scrolldelta,\n\t.con_set_origin = vgacon_set_origin,\n\t.con_save_screen = vgacon_save_screen,\n\t.con_build_attr = vgacon_build_attr,\n\t.con_invert_region = vgacon_invert_region,\n};\nEXPORT_SYMBOL(vga_con);\n\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["arch/powerpc/configs/pasemi_defconfig", "arch/powerpc/configs/ppc6xx_defconfig", "arch/x86/configs/i386_defconfig", "arch/x86/configs/x86_64_defconfig", "drivers/video/console/Kconfig", "drivers/video/console/vgacon.c"], "buggy_code_start_loc": [111, 746, 189, 184, 24, 168], "buggy_code_end_loc": [112, 747, 190, 185, 70, 1454], "fixing_code_start_loc": [110, 745, 188, 183, 23, 167], "fixing_code_end_loc": [110, 745, 188, 183, 23, 1234], "type": "CWE-125", "message": "The vgacon subsystem in the Linux kernel before 5.8.10 mishandles software scrollback. There is a vgacon_scrolldelta out-of-bounds read, aka CID-973c096f6a85.", "other": {"cve": {"id": "CVE-2020-28097", "sourceIdentifier": "cve@mitre.org", "published": "2021-06-24T12:15:07.780", "lastModified": "2022-04-06T16:46:32.560", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The vgacon subsystem in the Linux kernel before 5.8.10 mishandles software scrollback. There is a vgacon_scrolldelta out-of-bounds read, aka CID-973c096f6a85."}, {"lang": "es", "value": "El subsistema vgacon en el kernel de Linux versiones anteriores a 5.8.10, maneja inapropiadamente el desplazamiento de software. Se presenta una lectura fuera de l\u00edmites en la funci\u00f3n vgacon_scrolldelta, tambi\u00e9n se conoce como CID-973c096f6a85"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.8.10", "matchCriteriaId": "F1E86424-B406-4E36-9747-2D7E3471CC67"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.8.10", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=973c096f6a85e5b5f2a295126ba6928d9a6afd45", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/973c096f6a85e5b5f2a295126ba6928d9a6afd45", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://seclists.org/oss-sec/2020/q3/176", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210805-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/973c096f6a85e5b5f2a295126ba6928d9a6afd45"}}