{"buggy_code": ["# frozen_string_literal: true\n\nrequire 'current_user'\n\nclass ApplicationController < ActionController::Base\n  include CurrentUser\n  include CanonicalURL::ControllerExtensions\n  include JsonError\n  include GlobalPath\n  include Hijack\n  include ReadOnlyMixin\n  include VaryHeader\n\n  attr_reader :theme_id\n\n  serialization_scope :guardian\n\n  protect_from_forgery\n\n  # Default Rails 3.2 lets the request through with a blank session\n  #  we are being more pedantic here and nulling session / current_user\n  #  and then raising a CSRF exception\n  def handle_unverified_request\n    # NOTE: API key is secret, having it invalidates the need for a CSRF token\n    unless is_api? || is_user_api?\n      super\n      clear_current_user\n      render plain: \"[\\\"BAD CSRF\\\"]\", status: 403\n    end\n  end\n\n  before_action :rate_limit_crawlers\n  before_action :check_readonly_mode\n  before_action :handle_theme\n  before_action :set_current_user_for_logs\n  before_action :set_mp_snapshot_fields\n  before_action :clear_notifications\n  around_action :with_resolved_locale\n  before_action :set_mobile_view\n  before_action :block_if_readonly_mode\n  before_action :authorize_mini_profiler\n  before_action :redirect_to_login_if_required\n  before_action :block_if_requires_login\n  before_action :preload_json\n  before_action :check_xhr\n  after_action  :add_readonly_header\n  after_action  :perform_refresh_session\n  after_action  :dont_cache_page\n  after_action  :conditionally_allow_site_embedding\n  after_action  :ensure_vary_header\n  after_action  :add_noindex_header, if: -> { is_feed_request? || !SiteSetting.allow_index_in_robots_txt }\n  after_action  :add_noindex_header_to_non_canonical, if: -> { request.get? && !(request.format && request.format.json?) && !request.xhr? }\n\n  HONEYPOT_KEY ||= 'HONEYPOT_KEY'\n  CHALLENGE_KEY ||= 'CHALLENGE_KEY'\n\n  layout :set_layout\n\n  def has_escaped_fragment?\n    SiteSetting.enable_escaped_fragments? && params.key?(\"_escaped_fragment_\")\n  end\n\n  def show_browser_update?\n    @show_browser_update ||= CrawlerDetection.show_browser_update?(request.user_agent)\n  end\n  helper_method :show_browser_update?\n\n  def use_crawler_layout?\n    @use_crawler_layout ||=\n      request.user_agent &&\n      (request.media_type.blank? || request.media_type.include?('html')) &&\n      !['json', 'rss'].include?(params[:format]) &&\n      (has_escaped_fragment? || params.key?(\"print\") || show_browser_update? ||\n      CrawlerDetection.crawler?(request.user_agent, request.headers[\"HTTP_VIA\"])\n      )\n  end\n\n  def perform_refresh_session\n    refresh_session(current_user) unless @readonly_mode\n  end\n\n  def immutable_for(duration)\n    response.cache_control[:max_age] = duration.to_i\n    response.cache_control[:public] = true\n    response.cache_control[:extras] = [\"immutable\"]\n  end\n\n  def dont_cache_page\n    if !response.headers[\"Cache-Control\"] && response.cache_control.blank?\n      response.cache_control[:no_cache] = true\n      response.cache_control[:extras] = [\"no-store\"]\n    end\n    if SiteSetting.login_required\n      response.headers['Discourse-No-Onebox'] = '1'\n    end\n  end\n\n  def conditionally_allow_site_embedding\n    if SiteSetting.allow_embedding_site_in_an_iframe\n      response.headers.delete('X-Frame-Options')\n    end\n  end\n\n  def ember_cli_required?\n    Rails.env.development? && ENV['NO_EMBER_CLI'] != '1' && request.headers['X-Discourse-Ember-CLI'] != 'true'\n  end\n\n  def application_layout\n    ember_cli_required? ? \"ember_cli\" : \"application\"\n  end\n\n  def set_layout\n    case request.headers[\"Discourse-Render\"]\n    when \"desktop\"\n      return application_layout\n    when \"crawler\"\n      return \"crawler\"\n    end\n\n    use_crawler_layout? ? 'crawler' : application_layout\n  end\n\n  class RenderEmpty < StandardError; end\n  class PluginDisabled < StandardError; end\n\n  rescue_from RenderEmpty do\n    with_resolved_locale { render 'default/empty' }\n  end\n\n  rescue_from ArgumentError do |e|\n    if e.message == \"string contains null byte\"\n      raise Discourse::InvalidParameters, e.message\n    else\n      raise e\n    end\n  end\n\n  rescue_from PG::ReadOnlySqlTransaction do |e|\n    Discourse.received_postgres_readonly!\n    Rails.logger.error(\"#{e.class} #{e.message}: #{e.backtrace.join(\"\\n\")}\")\n    rescue_with_handler(Discourse::ReadOnly.new) || raise\n  end\n\n  rescue_from ActionController::ParameterMissing do |e|\n    render_json_error e.message, status: 400\n  end\n\n  rescue_from Discourse::SiteSettingMissing do |e|\n    render_json_error I18n.t('site_setting_missing', name: e.message), status: 500\n  end\n\n  rescue_from ActionController::RoutingError, PluginDisabled  do\n    rescue_discourse_actions(:not_found, 404)\n  end\n\n  # Handles requests for giant IDs that throw pg exceptions\n  rescue_from ActiveModel::RangeError do |e|\n    if e.message =~ /ActiveModel::Type::Integer/\n      rescue_discourse_actions(:not_found, 404)\n    else\n      raise e\n    end\n  end\n\n  rescue_from ActiveRecord::RecordInvalid do |e|\n    if request.format && request.format.json?\n      render_json_error e, type: :record_invalid, status: 422\n    else\n      raise e\n    end\n  end\n\n  rescue_from ActiveRecord::StatementInvalid do |e|\n    Discourse.reset_active_record_cache_if_needed(e)\n    raise e\n  end\n\n  # If they hit the rate limiter\n  rescue_from RateLimiter::LimitExceeded do |e|\n    retry_time_in_seconds = e&.available_in\n\n    response_headers = {\n      'Retry-After': retry_time_in_seconds.to_s\n    }\n\n    if e&.error_code\n      response_headers['Discourse-Rate-Limit-Error-Code'] = e.error_code\n    end\n\n    with_resolved_locale do\n      render_json_error(\n        e.description,\n        type: :rate_limit,\n        status: 429,\n        extras: { wait_seconds: retry_time_in_seconds, time_left: e&.time_left },\n        headers: response_headers\n      )\n    end\n  end\n\n  rescue_from Discourse::NotLoggedIn do |e|\n    if (request.format && request.format.json?) || request.xhr? || !request.get?\n      rescue_discourse_actions(:not_logged_in, 403, include_ember: true)\n    else\n      rescue_discourse_actions(:not_found, 404)\n    end\n  end\n\n  rescue_from Discourse::InvalidParameters do |e|\n    opts = {\n      custom_message: 'invalid_params',\n      custom_message_params: { message: e.message }\n    }\n\n    if (request.format && request.format.json?) || request.xhr? || !request.get?\n      rescue_discourse_actions(:invalid_parameters, 400, opts.merge(include_ember: true))\n    else\n      rescue_discourse_actions(:not_found, 400, opts)\n    end\n  end\n\n  rescue_from Discourse::NotFound do |e|\n    rescue_discourse_actions(\n      :not_found,\n      e.status,\n      check_permalinks: e.check_permalinks,\n      original_path: e.original_path,\n      custom_message: e.custom_message\n    )\n  end\n\n  rescue_from Discourse::InvalidAccess do |e|\n    if e.opts[:delete_cookie].present?\n      cookies.delete(e.opts[:delete_cookie])\n    end\n\n    rescue_discourse_actions(\n      :invalid_access,\n      403,\n      include_ember: true,\n      custom_message: e.custom_message,\n      custom_message_params: e.custom_message_params,\n      group: e.group\n    )\n  end\n\n  rescue_from Discourse::ReadOnly do\n    unless response_body\n      respond_to do |format|\n        format.json do\n          render_json_error I18n.t('read_only_mode_enabled'), type: :read_only, status: 503\n        end\n        format.html do\n          render status: 503, layout: 'no_ember', template: 'exceptions/read_only'\n        end\n      end\n    end\n  end\n\n  rescue_from SecondFactor::AuthManager::SecondFactorRequired do |e|\n    if request.xhr?\n      render json: {\n        second_factor_challenge_nonce: e.nonce\n      }, status: 403\n    else\n      redirect_to session_2fa_path(nonce: e.nonce)\n    end\n  end\n\n  rescue_from SecondFactor::BadChallenge do |e|\n    render json: { error: I18n.t(e.error_translation_key) }, status: e.status_code\n  end\n\n  def redirect_with_client_support(url, options = {})\n    if request.xhr?\n      response.headers['Discourse-Xhr-Redirect'] = 'true'\n      render plain: url\n    else\n      redirect_to url, options\n    end\n  end\n\n  def rescue_discourse_actions(type, status_code, opts = nil)\n    opts ||= {}\n    show_json_errors = (request.format && request.format.json?) ||\n                       (request.xhr?) ||\n                       ((params[:external_id] || '').ends_with? '.json')\n\n    if type == :not_found && opts[:check_permalinks]\n      url = opts[:original_path] || request.fullpath\n      permalink = Permalink.find_by_url(url)\n\n      # there are some cases where we have a permalink but no url\n      # cause category / topic was deleted\n      if permalink.present? && permalink.target_url\n        # permalink present, redirect to that URL\n        redirect_with_client_support permalink.target_url, status: :moved_permanently, allow_other_host: true\n        return\n      end\n    end\n\n    message = title = nil\n    with_resolved_locale(check_current_user: false) do\n      if opts[:custom_message]\n        title = message = I18n.t(opts[:custom_message], opts[:custom_message_params] || {})\n      else\n        message = I18n.t(type)\n        if status_code == 403\n          title = I18n.t(\"page_forbidden.title\")\n        else\n          title = I18n.t(\"page_not_found.title\")\n        end\n      end\n    end\n\n    error_page_opts = { title: title, status: status_code, group: opts[:group] }\n\n    if show_json_errors\n      opts = { type: type, status: status_code }\n\n      with_resolved_locale(check_current_user: false) do\n        # Include error in HTML format for topics#show.\n        if (request.params[:controller] == 'topics' && request.params[:action] == 'show') || (request.params[:controller] == 'categories' && request.params[:action] == 'find_by_slug')\n          opts[:extras] = {\n            title: I18n.t('page_not_found.page_title'),\n            html: build_not_found_page(error_page_opts),\n            group: error_page_opts[:group]\n          }\n        end\n      end\n\n      render_json_error message, opts\n    else\n      begin\n        # 404 pages won't have the session and theme_keys without these:\n        current_user\n        handle_theme\n      rescue Discourse::InvalidAccess\n        return render plain: message, status: status_code\n      end\n      with_resolved_locale do\n        error_page_opts[:layout] = opts[:include_ember] ? 'application' : 'no_ember'\n        render html: build_not_found_page(error_page_opts)\n      end\n    end\n  end\n\n  # If a controller requires a plugin, it will raise an exception if that plugin is\n  # disabled. This allows plugins to be disabled programmatically.\n  def self.requires_plugin(plugin_name)\n    before_action do\n      raise PluginDisabled.new if Discourse.disabled_plugin_names.include?(plugin_name)\n    end\n  end\n\n  def set_current_user_for_logs\n    if current_user\n      Logster.add_to_env(request.env, \"username\", current_user.username)\n      response.headers[\"X-Discourse-Username\"] = current_user.username\n    end\n    response.headers[\"X-Discourse-Route\"] = \"#{controller_name}/#{action_name}\"\n  end\n\n  def set_mp_snapshot_fields\n    if defined?(Rack::MiniProfiler)\n      Rack::MiniProfiler.add_snapshot_custom_field(\"Application version\", Discourse.git_version)\n      if Rack::MiniProfiler.snapshots_transporter?\n        Rack::MiniProfiler.add_snapshot_custom_field(\"Site\", Discourse.current_hostname)\n      end\n    end\n  end\n\n  def clear_notifications\n    if current_user && !@readonly_mode\n\n      cookie_notifications = cookies['cn']\n      notifications = request.headers['Discourse-Clear-Notifications']\n\n      if cookie_notifications\n        if notifications.present?\n          notifications += \",#{cookie_notifications}\"\n        else\n          notifications = cookie_notifications\n        end\n      end\n\n      if notifications.present?\n        notification_ids = notifications.split(\",\").map(&:to_i)\n        Notification.read(current_user, notification_ids)\n        current_user.reload\n        current_user.publish_notifications_state\n        cookie_args = {}\n        cookie_args[:path] = Discourse.base_path if Discourse.base_path.present?\n        cookies.delete('cn', cookie_args)\n      end\n    end\n  end\n\n  def with_resolved_locale(check_current_user: true)\n    if check_current_user && (user = current_user rescue nil)\n      locale = user.effective_locale\n    else\n      if SiteSetting.set_locale_from_accept_language_header\n        locale = locale_from_header\n      else\n        locale = SiteSetting.default_locale\n      end\n    end\n\n    if !I18n.locale_available?(locale)\n      locale = SiteSettings::DefaultsProvider::DEFAULT_LOCALE\n    end\n\n    I18n.ensure_all_loaded!\n    I18n.with_locale(locale) { yield }\n  end\n\n  def store_preloaded(key, json)\n    @preloaded ||= {}\n    # I dislike that there is a gsub as opposed to a gsub!\n    #  but we can not be mucking with user input, I wonder if there is a way\n    #  to inject this safety deeper in the library or even in AM serializer\n    @preloaded[key] = json.gsub(\"</\", \"<\\\\/\")\n  end\n\n  # If we are rendering HTML, preload the session data\n  def preload_json\n    # We don't preload JSON on xhr or JSON request\n    return if request.xhr? || request.format.json?\n\n    # if we are posting in makes no sense to preload\n    return if request.method != \"GET\"\n\n    # TODO should not be invoked on redirection so this should be further deferred\n    preload_anonymous_data\n\n    if current_user\n      current_user.sync_notification_channel_position\n      preload_current_user_data\n    end\n  end\n\n  def set_mobile_view\n    session[:mobile_view] = params[:mobile_view] if params.has_key?(:mobile_view)\n  end\n\n  NO_CUSTOM = \"no_custom\"\n  NO_PLUGINS = \"no_plugins\"\n  ONLY_OFFICIAL = \"only_official\"\n  SAFE_MODE = \"safe_mode\"\n\n  def resolve_safe_mode\n    return unless guardian.can_enable_safe_mode?\n\n    safe_mode = params[SAFE_MODE]\n    if safe_mode\n      request.env[NO_CUSTOM] = !!safe_mode.include?(NO_CUSTOM)\n      request.env[NO_PLUGINS] = !!safe_mode.include?(NO_PLUGINS)\n      request.env[ONLY_OFFICIAL] = !!safe_mode.include?(ONLY_OFFICIAL)\n    end\n  end\n\n  def handle_theme\n    return if request.format == \"js\"\n\n    resolve_safe_mode\n    return if request.env[NO_CUSTOM]\n\n    theme_id = nil\n\n    if (preview_theme_id = request[:preview_theme_id]&.to_i) &&\n      guardian.allow_themes?([preview_theme_id], include_preview: true)\n\n      theme_id = preview_theme_id\n    end\n\n    user_option = current_user&.user_option\n\n    if theme_id.blank?\n      ids, seq = cookies[:theme_ids]&.split(\"|\")\n      id = ids&.split(\",\")&.map(&:to_i)&.first\n      if id.present? && seq && seq.to_i == user_option&.theme_key_seq.to_i\n        theme_id = id if guardian.allow_themes?([id])\n      end\n    end\n\n    if theme_id.blank?\n      ids = user_option&.theme_ids || []\n      theme_id = ids.first if guardian.allow_themes?(ids)\n    end\n\n    if theme_id.blank? && SiteSetting.default_theme_id != -1 && guardian.allow_themes?([SiteSetting.default_theme_id])\n      theme_id = SiteSetting.default_theme_id\n    end\n\n    @theme_id = request.env[:resolved_theme_id] = theme_id\n  end\n\n  def guardian\n    # sometimes we log on a user in the middle of a request so we should throw\n    # away the cached guardian instance when we do that\n    if (@guardian&.user).blank? && current_user.present?\n      @guardian = Guardian.new(current_user, request)\n    end\n    @guardian ||= Guardian.new(current_user, request)\n  end\n\n  def current_homepage\n    current_user&.user_option&.homepage || SiteSetting.anonymous_homepage\n  end\n\n  def serialize_data(obj, serializer, opts = nil)\n    # If it's an array, apply the serializer as an each_serializer to the elements\n    serializer_opts = { scope: guardian }.merge!(opts || {})\n    if obj.respond_to?(:to_ary)\n      serializer_opts[:each_serializer] = serializer\n      ActiveModel::ArraySerializer.new(obj.to_ary, serializer_opts).as_json\n    else\n      serializer.new(obj, serializer_opts).as_json\n    end\n  end\n\n  # This is odd, but it seems that in Rails `render json: obj` is about\n  # 20% slower than calling MultiJSON.dump ourselves. I'm not sure why\n  # Rails doesn't call MultiJson.dump when you pass it json: obj but\n  # it seems we don't need whatever Rails is doing.\n  def render_serialized(obj, serializer, opts = nil)\n    render_json_dump(serialize_data(obj, serializer, opts), opts)\n  end\n\n  def render_json_dump(obj, opts = nil)\n    opts ||= {}\n    if opts[:rest_serializer]\n      obj['__rest_serializer'] = \"1\"\n      opts.each do |k, v|\n        obj[k] = v if k.to_s.start_with?(\"refresh_\")\n      end\n\n      obj['extras'] = opts[:extras] if opts[:extras]\n      obj['meta'] = opts[:meta] if opts[:meta]\n    end\n\n    render json: MultiJson.dump(obj), status: opts[:status] || 200\n  end\n\n  def can_cache_content?\n    current_user.blank? && cookies[:authentication_data].blank?\n  end\n\n  # Our custom cache method\n  def discourse_expires_in(time_length)\n    return unless can_cache_content?\n    Middleware::AnonymousCache.anon_cache(request.env, time_length)\n  end\n\n  def fetch_user_from_params(opts = nil, eager_load = [])\n    opts ||= {}\n    user = if params[:username]\n      username_lower = params[:username].downcase.chomp('.json')\n\n      if current_user && current_user.username_lower == username_lower\n        current_user\n      else\n        find_opts = { username_lower: username_lower }\n        find_opts[:active] = true unless opts[:include_inactive] || current_user.try(:staff?)\n        result = User\n        (result = result.includes(*eager_load)) if !eager_load.empty?\n        result.find_by(find_opts)\n      end\n    elsif params[:external_id]\n      external_id = params[:external_id].chomp('.json')\n      if provider_name = params[:external_provider]\n        raise Discourse::InvalidAccess unless guardian.is_admin? # external_id might be something sensitive\n        provider = Discourse.enabled_authenticators.find { |a| a.name == provider_name }\n        raise Discourse::NotFound if !provider&.is_managed? # Only managed authenticators use UserAssociatedAccount\n        UserAssociatedAccount.find_by(provider_name: provider_name, provider_uid: external_id)&.user\n      else\n        SingleSignOnRecord.find_by(external_id: external_id).try(:user)\n      end\n    end\n    raise Discourse::NotFound if user.blank?\n\n    guardian.ensure_can_see!(user)\n    user\n  end\n\n  def post_ids_including_replies\n    post_ids  = params[:post_ids].map(&:to_i)\n    post_ids |= PostReply.where(post_id: params[:reply_post_ids]).pluck(:reply_post_id) if params[:reply_post_ids]\n    post_ids\n  end\n\n  def no_cookies\n    # do your best to ensure response has no cookies\n    # longer term we may want to push this into middleware\n    headers.delete 'Set-Cookie'\n    request.session_options[:skip] = true\n  end\n\n  def secure_session\n    SecureSession.new(session[\"secure_session_id\"] ||= SecureRandom.hex)\n  end\n\n  def handle_permalink(path)\n    permalink = Permalink.find_by_url(path)\n    if permalink && permalink.target_url\n      redirect_to permalink.target_url, status: :moved_permanently\n    end\n  end\n\n  def rate_limit_second_factor!(user)\n    return if params[:second_factor_token].blank?\n\n    RateLimiter.new(nil, \"second-factor-min-#{request.remote_ip}\", 6, 1.minute).performed!\n\n    if user\n      RateLimiter.new(nil, \"second-factor-min-#{user.username}\", 6, 1.minute).performed!\n    end\n  end\n\n  private\n\n  def locale_from_header\n    HttpLanguageParser.parse(request.env[\"HTTP_ACCEPT_LANGUAGE\"])\n  end\n\n  def preload_anonymous_data\n    store_preloaded(\"site\", Site.json_for(guardian))\n    store_preloaded(\"siteSettings\", SiteSetting.client_settings_json)\n    store_preloaded(\"customHTML\", custom_html_json)\n    store_preloaded(\"banner\", banner_json)\n    store_preloaded(\"customEmoji\", custom_emoji)\n    store_preloaded(\"isReadOnly\", @readonly_mode.to_s)\n    store_preloaded(\"isStaffWritesOnly\", @staff_writes_only_mode.to_s)\n    store_preloaded(\"activatedThemes\", activated_themes_json)\n  end\n\n  def preload_current_user_data\n    store_preloaded(\"currentUser\", MultiJson.dump(CurrentUserSerializer.new(current_user, scope: guardian, root: false)))\n    report = TopicTrackingState.report(current_user)\n    serializer = ActiveModel::ArraySerializer.new(\n      report, each_serializer: TopicTrackingStateSerializer, scope: guardian\n    )\n    store_preloaded(\"topicTrackingStates\", MultiJson.dump(serializer))\n  end\n\n  def custom_html_json\n    target = view_context.mobile_view? ? :mobile : :desktop\n\n    data =\n      if @theme_id.present?\n        {\n         top: Theme.lookup_field(@theme_id, target, \"after_header\"),\n         footer: Theme.lookup_field(@theme_id, target, \"footer\")\n        }\n      else\n        {}\n      end\n\n    if DiscoursePluginRegistry.custom_html\n      data.merge! DiscoursePluginRegistry.custom_html\n    end\n\n    DiscoursePluginRegistry.html_builders.each do |name, _|\n      if name.start_with?(\"client:\")\n        data[name.sub(/^client:/, '')] = DiscoursePluginRegistry.build_html(name, self)\n      end\n    end\n\n    MultiJson.dump(data)\n  end\n\n  def self.banner_json_cache\n    @banner_json_cache ||= DistributedCache.new(\"banner_json\")\n  end\n\n  def banner_json\n    json = ApplicationController.banner_json_cache[\"json\"]\n\n    unless json\n      topic = Topic.where(archetype: Archetype.banner).first\n      banner = topic.present? ? topic.banner : {}\n      ApplicationController.banner_json_cache[\"json\"] = json = MultiJson.dump(banner)\n    end\n\n    json\n  end\n\n  def custom_emoji\n    serializer = ActiveModel::ArraySerializer.new(Emoji.custom, each_serializer: EmojiSerializer)\n    MultiJson.dump(serializer)\n  end\n\n  # Render action for a JSON error.\n  #\n  # obj       - a translated string, an ActiveRecord model, or an array of translated strings\n  # opts:\n  #   type    - a machine-readable description of the error\n  #   status  - HTTP status code to return\n  #   headers - extra headers for the response\n  def render_json_error(obj, opts = {})\n    opts = { status: opts } if opts.is_a?(Integer)\n    opts.fetch(:headers, {}).each { |name, value| headers[name.to_s] = value }\n\n    render(\n      json: MultiJson.dump(create_errors_json(obj, opts)),\n      status: opts[:status] || status_code(obj)\n    )\n  end\n\n  def status_code(obj)\n    return 403 if obj.try(:forbidden)\n    return 404 if obj.try(:not_found)\n    422\n  end\n\n  def success_json\n    { success: 'OK' }\n  end\n\n  def failed_json\n    { failed: 'FAILED' }\n  end\n\n  def json_result(obj, opts = {})\n    if yield(obj)\n      json = success_json\n\n      # If we were given a serializer, add the class to the json that comes back\n      if opts[:serializer].present?\n        json[obj.class.name.underscore] = opts[:serializer].new(obj, scope: guardian).serializable_hash\n      end\n\n      render json: MultiJson.dump(json)\n    else\n      error_obj = nil\n      if opts[:additional_errors]\n        error_target = opts[:additional_errors].find do |o|\n          target = obj.public_send(o)\n          target && target.errors.present?\n        end\n        error_obj = obj.public_send(error_target) if error_target\n      end\n      render_json_error(error_obj || obj)\n    end\n  end\n\n  def mini_profiler_enabled?\n    defined?(Rack::MiniProfiler) && (guardian.is_developer? || Rails.env.development?)\n  end\n\n  def authorize_mini_profiler\n    return unless mini_profiler_enabled?\n    Rack::MiniProfiler.authorize_request\n  end\n\n  def check_xhr\n    # bypass xhr check on PUT / POST / DELETE provided api key is there, otherwise calling api is annoying\n    return if !request.get? && (is_api? || is_user_api?)\n    raise ApplicationController::RenderEmpty.new unless ((request.format && request.format.json?) || request.xhr?)\n  end\n\n  def apply_cdn_headers\n    Discourse.apply_cdn_headers(response.headers) if Discourse.is_cdn_request?(request.env, request.method)\n  end\n\n  def self.requires_login(arg = {})\n    @requires_login_arg = arg\n  end\n\n  def self.requires_login_arg\n    @requires_login_arg\n  end\n\n  def block_if_requires_login\n    if arg = self.class.requires_login_arg\n      check =\n        if except = arg[:except]\n          !except.include?(action_name.to_sym)\n        elsif only = arg[:only]\n          only.include?(action_name.to_sym)\n        else\n          true\n        end\n      ensure_logged_in if check\n    end\n  end\n\n  def ensure_logged_in\n    raise Discourse::NotLoggedIn.new unless current_user.present?\n  end\n\n  def ensure_staff\n    raise Discourse::InvalidAccess.new unless current_user && current_user.staff?\n  end\n\n  def ensure_admin\n    raise Discourse::InvalidAccess.new unless current_user && current_user.admin?\n  end\n\n  def ensure_wizard_enabled\n    raise Discourse::InvalidAccess.new unless SiteSetting.wizard_enabled?\n  end\n\n  def destination_url\n    request.original_url unless request.original_url =~ /uploads/\n  end\n\n  def redirect_to_login\n    dont_cache_page\n\n    if SiteSetting.auth_immediately && SiteSetting.enable_discourse_connect?\n      # save original URL in a session so we can redirect after login\n      session[:destination_url] = destination_url\n      redirect_to path('/session/sso')\n    elsif SiteSetting.auth_immediately && !SiteSetting.enable_local_logins && Discourse.enabled_authenticators.length == 1 && !cookies[:authentication_data]\n      # Only one authentication provider, direct straight to it.\n      # If authentication_data is present, then we are halfway though registration. Don't redirect offsite\n      cookies[:destination_url] = destination_url\n      redirect_to path(\"/auth/#{Discourse.enabled_authenticators.first.name}\")\n    else\n      # save original URL in a cookie (javascript redirects after login in this case)\n      cookies[:destination_url] = destination_url\n      redirect_to path(\"/login\")\n    end\n  end\n\n  def redirect_to_login_if_required\n    return if request.format.json? && is_api?\n\n    # Used by clients authenticated via user API.\n    # Redirects to provided URL scheme if\n    # - request uses a valid public key and auth_redirect scheme\n    # - one_time_password scope is allowed\n    if !current_user &&\n      params.has_key?(:user_api_public_key) &&\n      params.has_key?(:auth_redirect)\n      begin\n        OpenSSL::PKey::RSA.new(params[:user_api_public_key])\n      rescue OpenSSL::PKey::RSAError\n        return render plain: I18n.t(\"user_api_key.invalid_public_key\")\n      end\n\n      if UserApiKey.invalid_auth_redirect?(params[:auth_redirect])\n        return render plain: I18n.t(\"user_api_key.invalid_auth_redirect\")\n      end\n\n      if UserApiKey.allowed_scopes.superset?(Set.new([\"one_time_password\"]))\n        redirect_to(\"#{params[:auth_redirect]}?otp=true\", allow_other_host: true)\n        return\n      end\n    end\n\n    if !current_user && SiteSetting.login_required?\n      flash.keep\n      if (request.format && request.format.json?) || request.xhr? || !request.get?\n        ensure_logged_in\n      else\n        redirect_to_login\n      end\n      return\n    end\n\n    return if !current_user\n    return if !should_enforce_2fa?\n\n    redirect_path = path(\"/u/#{current_user.encoded_username}/preferences/second-factor\")\n    if !request.fullpath.start_with?(redirect_path)\n      redirect_to path(redirect_path)\n      nil\n    end\n  end\n\n  def should_enforce_2fa?\n    disqualified_from_2fa_enforcement = request.format.json? || is_api? || current_user.anonymous?\n    enforcing_2fa = ((SiteSetting.enforce_second_factor == 'staff' && current_user.staff?) || SiteSetting.enforce_second_factor == 'all')\n    !disqualified_from_2fa_enforcement && enforcing_2fa && !current_user.has_any_second_factor_methods_enabled?\n  end\n\n  def build_not_found_page(opts = {})\n    if SiteSetting.bootstrap_error_pages?\n      preload_json\n      opts[:layout] = 'application' if opts[:layout] == 'no_ember'\n    end\n\n    @current_user = current_user rescue nil\n\n    if !SiteSetting.login_required? || @current_user\n      key = \"page_not_found_topics:#{I18n.locale}\"\n      @topics_partial = Discourse.cache.fetch(key, expires_in: 10.minutes) do\n        category_topic_ids = Category.pluck(:topic_id).compact\n        @top_viewed = TopicQuery.new(nil, except_topic_ids: category_topic_ids).list_top_for(\"monthly\").topics.first(10)\n        @recent = Topic.includes(:category).where.not(id: category_topic_ids).recent(10)\n        render_to_string partial: '/exceptions/not_found_topics', formats: [:html]\n      end.html_safe\n    end\n\n    @container_class = \"wrap not-found-container\"\n    @page_title = I18n.t(\"page_not_found.page_title\")\n    @title = opts[:title] || I18n.t(\"page_not_found.title\")\n    @group = opts[:group]\n    @hide_search = true if SiteSetting.login_required\n\n    params[:slug] = params[:slug].first if params[:slug].kind_of?(Array)\n    params[:id] = params[:id].first if params[:id].kind_of?(Array)\n    @slug = (params[:slug].presence || params[:id].presence || \"\").to_s.tr('-', ' ')\n\n    render_to_string status: opts[:status], layout: opts[:layout], formats: [:html], template: '/exceptions/not_found'\n  end\n\n  def is_asset_path\n    request.env['DISCOURSE_IS_ASSET_PATH'] = 1\n  end\n\n  def is_feed_request?\n    request.format.atom? || request.format.rss?\n  end\n\n  def add_noindex_header\n    if request.get? && !response.headers['X-Robots-Tag']\n      if SiteSetting.allow_index_in_robots_txt\n        response.headers['X-Robots-Tag'] = 'noindex'\n      else\n        response.headers['X-Robots-Tag'] = 'noindex, nofollow'\n      end\n    end\n  end\n\n  def add_noindex_header_to_non_canonical\n    canonical = (@canonical_url || @default_canonical)\n    if canonical.present? && canonical != request.url && !SiteSetting.allow_indexing_non_canonical_urls\n      response.headers['X-Robots-Tag'] ||= 'noindex'\n    end\n  end\n\n  protected\n\n  def honeypot_value\n    secure_session[HONEYPOT_KEY] ||= SecureRandom.hex\n  end\n\n  def challenge_value\n    secure_session[CHALLENGE_KEY] ||= SecureRandom.hex\n  end\n\n  def render_post_json(post, add_raw: true)\n    post_serializer = PostSerializer.new(post, scope: guardian, root: false)\n    post_serializer.add_raw = add_raw\n\n    counts = PostAction.counts_for([post], current_user)\n    if counts && counts = counts[post.id]\n      post_serializer.post_actions = counts\n    end\n    render_json_dump(post_serializer)\n  end\n\n  # returns an array of integers given a param key\n  # returns nil if key is not found\n  def param_to_integer_list(key, delimiter = ',')\n    case params[key]\n    when String\n      params[key].split(delimiter).map(&:to_i)\n    when Array\n      params[key].map(&:to_i)\n    end\n  end\n\n  def activated_themes_json\n    id = @theme_id\n    return \"{}\" if id.blank?\n    ids = Theme.transform_ids(id)\n    Theme.where(id: ids).pluck(:id, :name).to_h.to_json\n  end\n\n  def rate_limit_crawlers\n    return if current_user.present?\n    return if SiteSetting.slow_down_crawler_user_agents.blank?\n\n    user_agent = request.user_agent&.downcase\n    return if user_agent.blank?\n\n    SiteSetting.slow_down_crawler_user_agents.downcase.split(\"|\").each do |crawler|\n      if user_agent.include?(crawler)\n        key = \"#{crawler}_crawler_rate_limit\"\n        limiter = RateLimiter.new(\n          nil,\n          key,\n          1,\n          SiteSetting.slow_down_crawler_rate,\n          error_code: key\n        )\n        limiter.performed!\n        break\n      end\n    end\n  end\n\n  def run_second_factor!(action_class, action_data = nil)\n    action = action_class.new(guardian, request, action_data)\n    manager = SecondFactor::AuthManager.new(guardian, action)\n    yield(manager) if block_given?\n    result = manager.run!(request, params, secure_session)\n\n    if !result.no_second_factors_enabled? &&\n      !result.second_factor_auth_completed? &&\n      !result.second_factor_auth_skipped?\n      # should never happen, but I want to know if somehow it does! (osama)\n      raise \"2fa process ended up in a bad state!\"\n    end\n\n    result\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe ApplicationController do\n  describe '#redirect_to_login_if_required' do\n    let(:admin) { Fabricate(:admin) }\n\n    before do\n      admin  # to skip welcome wizard at home page `/`\n      SiteSetting.login_required = true\n    end\n\n    it \"should never cache a login redirect\" do\n      get \"/\"\n      expect(response.headers[\"Cache-Control\"]).to eq(\"no-cache, no-store\")\n    end\n\n    it \"should redirect to login normally\" do\n      get \"/\"\n      expect(response).to redirect_to(\"/login\")\n    end\n\n    it \"should redirect to SSO if enabled\" do\n      SiteSetting.discourse_connect_url = 'http://someurl.com'\n      SiteSetting.enable_discourse_connect = true\n      get \"/\"\n      expect(response).to redirect_to(\"/session/sso\")\n    end\n\n    it \"should redirect to authenticator if only one, and local logins disabled\" do\n      # Local logins and google enabled, direct to login UI\n      SiteSetting.enable_google_oauth2_logins = true\n      get \"/\"\n      expect(response).to redirect_to(\"/login\")\n\n      # Only google enabled, login immediately\n      SiteSetting.enable_local_logins = false\n      get \"/\"\n      expect(response).to redirect_to(\"/auth/google_oauth2\")\n\n      # Google and GitHub enabled, direct to login UI\n      SiteSetting.enable_github_logins = true\n      get \"/\"\n      expect(response).to redirect_to(\"/login\")\n    end\n\n    it \"should not redirect to SSO when auth_immediately is disabled\" do\n      SiteSetting.auth_immediately = false\n      SiteSetting.discourse_connect_url = 'http://someurl.com'\n      SiteSetting.enable_discourse_connect = true\n\n      get \"/\"\n      expect(response).to redirect_to(\"/login\")\n    end\n\n    it \"should not redirect to authenticator when auth_immediately is disabled\" do\n      SiteSetting.auth_immediately = false\n      SiteSetting.enable_google_oauth2_logins = true\n      SiteSetting.enable_local_logins = false\n\n      get \"/\"\n      expect(response).to redirect_to(\"/login\")\n    end\n\n    context \"with omniauth in test mode\" do\n      before do\n        OmniAuth.config.test_mode = true\n        OmniAuth.config.add_mock(:google_oauth2,\n          info: OmniAuth::AuthHash::InfoHash.new(\n            email: \"address@example.com\",\n          ),\n          extra: {\n            raw_info: OmniAuth::AuthHash.new(\n              email_verified: true,\n              email: \"address@example.com\",\n            )\n          }\n        )\n        Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:google_oauth2]\n      end\n\n      after do\n        Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:google_oauth2] = nil\n        OmniAuth.config.test_mode = false\n      end\n\n      it \"should not redirect to authenticator if registration in progress\" do\n        SiteSetting.enable_local_logins = false\n        SiteSetting.enable_google_oauth2_logins = true\n\n        get \"/\"\n        expect(response).to redirect_to(\"/auth/google_oauth2\")\n\n        expect(cookies[:authentication_data]).to eq(nil)\n\n        get \"/auth/google_oauth2/callback.json\"\n        expect(response).to redirect_to(\"/\")\n        expect(cookies[:authentication_data]).not_to eq(nil)\n\n        get \"/\"\n        expect(response).to redirect_to(\"/login\")\n      end\n    end\n\n    it 'contains authentication data when cookies exist' do\n      cookie_data = \"someauthenticationdata\"\n      cookies['authentication_data'] = cookie_data\n      get '/login'\n      expect(response.status).to eq(200)\n      expect(response.body).to include(\"data-authentication-data=\\\"#{cookie_data}\\\"\")\n      expect(response.headers[\"Set-Cookie\"]).to include(\"authentication_data=;\") # Delete cookie\n    end\n\n    it 'deletes authentication data cookie even if already authenticated' do\n      sign_in(Fabricate(:user))\n      cookies['authentication_data'] = \"someauthenticationdata\"\n      get '/'\n      expect(response.status).to eq(200)\n      expect(response.body).not_to include(\"data-authentication-data=\")\n      expect(response.headers[\"Set-Cookie\"]).to include(\"authentication_data=;\") # Delete cookie\n    end\n\n    it \"returns a 403 for json requests\" do\n      get '/latest'\n      expect(response.status).to eq(302)\n\n      get '/latest.json'\n      expect(response.status).to eq(403)\n    end\n  end\n\n  describe '#redirect_to_second_factor_if_required' do\n    let(:admin) { Fabricate(:admin) }\n    fab!(:user) { Fabricate(:user) }\n\n    before do\n      admin # to skip welcome wizard at home page `/`\n    end\n\n    it \"should redirect admins when enforce_second_factor is 'all'\" do\n      SiteSetting.enforce_second_factor = \"all\"\n      sign_in(admin)\n\n      get \"/\"\n      expect(response).to redirect_to(\"/u/#{admin.username}/preferences/second-factor\")\n    end\n\n    it \"should redirect users when enforce_second_factor is 'all'\" do\n      SiteSetting.enforce_second_factor = \"all\"\n      sign_in(user)\n\n      get \"/\"\n      expect(response).to redirect_to(\"/u/#{user.username}/preferences/second-factor\")\n    end\n\n    it \"should not redirect anonymous users when enforce_second_factor is 'all'\" do\n      SiteSetting.enforce_second_factor = \"all\"\n      SiteSetting.allow_anonymous_posting = true\n      sign_in(user)\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n\n      get \"/\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"should redirect admins when enforce_second_factor is 'staff'\" do\n      SiteSetting.enforce_second_factor = \"staff\"\n      sign_in(admin)\n\n      get \"/\"\n      expect(response).to redirect_to(\"/u/#{admin.username}/preferences/second-factor\")\n    end\n\n    it \"should not redirect users when enforce_second_factor is 'staff'\" do\n      SiteSetting.enforce_second_factor = \"staff\"\n      sign_in(user)\n\n      get \"/\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"should not redirect admins when turned off\" do\n      SiteSetting.enforce_second_factor = \"no\"\n      sign_in(admin)\n\n      get \"/\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"should not redirect users when turned off\" do\n      SiteSetting.enforce_second_factor = \"no\"\n      sign_in(user)\n\n      get \"/\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"correctly redirects for Unicode usernames\" do\n      SiteSetting.enforce_second_factor = \"all\"\n      SiteSetting.unicode_usernames = true\n      user = sign_in(Fabricate(:unicode_user))\n\n      get \"/\"\n      expect(response).to redirect_to(\"/u/#{user.encoded_username}/preferences/second-factor\")\n    end\n\n    context \"when enforcing second factor for staff\" do\n      before do\n        SiteSetting.enforce_second_factor = \"staff\"\n        sign_in(admin)\n      end\n\n      context \"when the staff member has not enabled TOTP or security keys\" do\n        it \"redirects the staff to the second factor preferences\" do\n          get \"/\"\n          expect(response).to redirect_to(\"/u/#{admin.username}/preferences/second-factor\")\n        end\n      end\n\n      context \"when the staff member has enabled TOTP\" do\n        before do\n          Fabricate(:user_second_factor_totp, user: admin)\n        end\n\n        it \"does not redirects the staff to set up 2FA\" do\n          get \"/\"\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context \"when the staff member has enabled security keys\" do\n        before do\n          Fabricate(:user_security_key_with_random_credential, user: admin)\n        end\n\n        it \"does not redirects the staff to set up 2FA\" do\n          get \"/\"\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n  end\n\n  describe 'invalid request params' do\n    before do\n      @old_logger = Rails.logger\n      @logs = StringIO.new\n      Rails.logger = Logger.new(@logs)\n    end\n\n    after do\n      Rails.logger = @old_logger\n    end\n\n    it 'should not raise a 500 (nor should it log a warning) for bad params' do\n      bad_str = (+\"d\\xDE\").force_encoding('utf-8')\n      expect(bad_str.valid_encoding?).to eq(false)\n\n      get \"/latest.json\", params: { test: bad_str }\n\n      expect(response.status).to eq(400)\n\n      log = @logs.string\n\n      if (log.include? 'exception app middleware')\n        # heisentest diagnostics\n        puts\n        puts \"EXTRA DIAGNOSTICS FOR INTERMITTENT TEST FAIL\"\n        puts log\n        puts \">> action_dispatch.exception\"\n        ex = request.env['action_dispatch.exception']\n        puts \">> exception class: #{ex.class} : #{ex}\"\n      end\n\n      expect(log).not_to include('exception app middleware')\n\n      expect(response.parsed_body).to eq(\n        \"status\" => 400,\n        \"error\" => \"Bad Request\"\n      )\n\n    end\n  end\n\n  describe 'missing required param' do\n    it 'should return a 400' do\n      get \"/search/query.json\", params: { trem: \"misspelled term\" }\n\n      expect(response.status).to eq(400)\n      expect(response.parsed_body[\"errors\"].first).to include(\"param is missing or the value is empty: term\")\n    end\n  end\n\n  describe 'build_not_found_page' do\n    describe 'topic not found' do\n\n      it 'should not redirect to permalink if topic/category does not exist' do\n        topic = create_post.topic\n        Permalink.create!(url: topic.relative_url, topic_id: topic.id + 1)\n        topic.trash!\n\n        SiteSetting.detailed_404 = false\n        get topic.relative_url\n        expect(response.status).to eq(404)\n\n        SiteSetting.detailed_404 = true\n        get topic.relative_url\n        expect(response.status).to eq(410)\n      end\n\n      it 'should return permalink for deleted topics' do\n        topic = create_post.topic\n        external_url = 'https://somewhere.over.rainbow'\n        Permalink.create!(url: topic.relative_url, external_url: external_url)\n        topic.trash!\n\n        get topic.relative_url\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(external_url)\n\n        get \"/t/#{topic.id}.json\"\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(external_url)\n\n        get \"/t/#{topic.id}.json\", xhr: true\n        expect(response.status).to eq(200)\n        expect(response.body).to eq(external_url)\n      end\n\n      it 'supports subfolder with permalinks' do\n        set_subfolder \"/forum\"\n\n        trashed_topic = create_post.topic\n        trashed_topic.trash!\n        new_topic = create_post.topic\n        permalink = Permalink.create!(url: trashed_topic.relative_url, topic_id: new_topic.id)\n\n        # no subfolder because router doesn't know about subfolder in this test\n        get \"/t/#{trashed_topic.slug}/#{trashed_topic.id}\"\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(\"/forum/t/#{new_topic.slug}/#{new_topic.id}\")\n\n        permalink.destroy\n        category = Fabricate(:category)\n        permalink = Permalink.create!(url: trashed_topic.relative_url, category_id: category.id)\n        get \"/t/#{trashed_topic.slug}/#{trashed_topic.id}\"\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(\"/forum/c/#{category.slug}/#{category.id}\")\n\n        permalink.destroy\n        permalink = Permalink.create!(url: trashed_topic.relative_url, post_id: new_topic.posts.last.id)\n        get \"/t/#{trashed_topic.slug}/#{trashed_topic.id}\"\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(\"/forum/t/#{new_topic.slug}/#{new_topic.id}/#{new_topic.posts.last.post_number}\")\n      end\n\n      it 'should return 404 and show Google search for an invalid topic route' do\n        get \"/t/nope-nope/99999999\"\n\n        expect(response.status).to eq(404)\n\n        response_body = response.body\n\n        expect(response_body).to include(I18n.t('page_not_found.search_button'))\n        expect(response_body).to have_tag(\"input\", with: { value: 'nope nope' })\n      end\n\n      it 'should not include Google search if login_required is enabled' do\n        SiteSetting.login_required = true\n        sign_in(Fabricate(:user))\n        get \"/t/nope-nope/99999999\"\n        expect(response.status).to eq(404)\n        expect(response.body).to_not include('google.com/search')\n      end\n\n      describe 'no logspam' do\n        before do\n          @orig_logger = Rails.logger\n          Rails.logger = @fake_logger = FakeLogger.new\n        end\n\n        after do\n          Rails.logger = @orig_logger\n        end\n\n        it 'should handle 404 to a css file' do\n          Discourse.cache.delete(\"page_not_found_topics:#{I18n.locale}\")\n\n          topic1 = Fabricate(:topic)\n          get '/stylesheets/mobile_1_4cd559272273fe6d3c7db620c617d596a5fdf240.css', headers: { 'HTTP_ACCEPT' => 'text/css,*/*,q=0.1' }\n          expect(response.status).to eq(404)\n          expect(response.body).to include(topic1.title)\n\n          topic2 = Fabricate(:topic)\n          get '/stylesheets/mobile_1_4cd559272273fe6d3c7db620c617d596a5fdf240.css', headers: { 'HTTP_ACCEPT' => 'text/css,*/*,q=0.1' }\n          expect(response.status).to eq(404)\n          expect(response.body).to include(topic1.title)\n          expect(response.body).to_not include(topic2.title)\n\n          expect(@fake_logger.fatals.length).to eq(0)\n          expect(@fake_logger.errors.length).to eq(0)\n          expect(@fake_logger.warnings.length).to eq(0)\n        end\n      end\n\n      it 'should cache results' do\n        Discourse.cache.delete(\"page_not_found_topics:#{I18n.locale}\")\n        Discourse.cache.delete(\"page_not_found_topics:fr\")\n\n        topic1 = Fabricate(:topic)\n        get '/t/nope-nope/99999999'\n        expect(response.status).to eq(404)\n        expect(response.body).to include(topic1.title)\n\n        topic2 = Fabricate(:topic)\n        get '/t/nope-nope/99999999'\n        expect(response.status).to eq(404)\n        expect(response.body).to include(topic1.title)\n        expect(response.body).to_not include(topic2.title)\n\n        # Different locale should have different cache\n        SiteSetting.default_locale = :fr\n        get '/t/nope-nope/99999999'\n        expect(response.status).to eq(404)\n        expect(response.body).to include(topic1.title)\n        expect(response.body).to include(topic2.title)\n      end\n    end\n  end\n\n  describe \"#handle_theme\" do\n    let!(:theme) { Fabricate(:theme, user_selectable: true) }\n    let!(:theme2) { Fabricate(:theme, user_selectable: true) }\n    let!(:non_selectable_theme) { Fabricate(:theme, user_selectable: false) }\n    fab!(:user) { Fabricate(:user) }\n    fab!(:admin) { Fabricate(:admin) }\n\n    before do\n      sign_in(user)\n    end\n\n    it \"selects the theme the user has selected\" do\n      user.user_option.update_columns(theme_ids: [theme.id])\n\n      get \"/\"\n      expect(response.status).to eq(200)\n      expect(controller.theme_id).to eq(theme.id)\n\n      theme.update_attribute(:user_selectable, false)\n\n      get \"/\"\n      expect(response.status).to eq(200)\n      expect(controller.theme_id).to eq(SiteSetting.default_theme_id)\n    end\n\n    it \"can be overridden with a cookie\" do\n      user.user_option.update_columns(theme_ids: [theme.id])\n\n      cookies['theme_ids'] = \"#{theme2.id}|#{user.user_option.theme_key_seq}\"\n\n      get \"/\"\n      expect(response.status).to eq(200)\n      expect(controller.theme_id).to eq(theme2.id)\n    end\n\n    it \"falls back to the default theme when the user has no cookies or preferences\" do\n      user.user_option.update_columns(theme_ids: [])\n      cookies[\"theme_ids\"] = nil\n      theme2.set_default!\n\n      get \"/\"\n      expect(response.status).to eq(200)\n      expect(controller.theme_id).to eq(theme2.id)\n    end\n\n    it \"can be overridden with preview_theme_id param\" do\n      sign_in(admin)\n      cookies['theme_ids'] = \"#{theme.id}|#{admin.user_option.theme_key_seq}\"\n\n      get \"/\", params: { preview_theme_id: theme2.id }\n      expect(response.status).to eq(200)\n      expect(controller.theme_id).to eq(theme2.id)\n\n      get \"/\", params: { preview_theme_id: non_selectable_theme.id }\n      expect(controller.theme_id).to eq(non_selectable_theme.id)\n    end\n\n    it \"does not allow non privileged user to preview themes\" do\n      sign_in(user)\n      get \"/\", params: { preview_theme_id: non_selectable_theme.id }\n      expect(controller.theme_id).to eq(SiteSetting.default_theme_id)\n    end\n\n    it \"cookie can fail back to user if out of sync\" do\n      user.user_option.update_columns(theme_ids: [theme.id])\n      cookies['theme_ids'] = \"#{theme2.id}|#{user.user_option.theme_key_seq - 1}\"\n\n      get \"/\"\n      expect(response.status).to eq(200)\n      expect(controller.theme_id).to eq(theme.id)\n    end\n  end\n\n  describe 'Custom hostname' do\n\n    it 'does not allow arbitrary host injection' do\n      get(\"/latest\",\n        headers: {\n          \"X-Forwarded-Host\" => \"test123.com\"\n        }\n      )\n\n      expect(response.body).not_to include(\"test123\")\n    end\n  end\n\n  describe 'allow_embedding_site_in_an_iframe' do\n\n    it \"should have the 'X-Frame-Options' header with value 'sameorigin'\" do\n      get(\"/latest\")\n      expect(response.headers['X-Frame-Options']).to eq(\"SAMEORIGIN\")\n    end\n\n    it \"should not include the 'X-Frame-Options' header\" do\n      SiteSetting.allow_embedding_site_in_an_iframe = true\n      get(\"/latest\")\n      expect(response.headers).not_to include('X-Frame-Options')\n    end\n  end\n\n  describe 'Delegated auth' do\n    let :public_key do\n      <<~TXT\n      -----BEGIN PUBLIC KEY-----\n      MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDh7BS7Ey8hfbNhlNAW/47pqT7w\n      IhBz3UyBYzin8JurEQ2pY9jWWlY8CH147KyIZf1fpcsi7ZNxGHeDhVsbtUKZxnFV\n      p16Op3CHLJnnJKKBMNdXMy0yDfCAHZtqxeBOTcCo1Vt/bHpIgiK5kmaekyXIaD0n\n      w0z/BYpOgZ8QwnI5ZwIDAQAB\n      -----END PUBLIC KEY-----\n      TXT\n    end\n\n    let :args do\n      {\n        auth_redirect: 'http://no-good.com',\n        user_api_public_key: \"not-a-valid-public-key\"\n      }\n    end\n\n    it 'disallows invalid public_key param' do\n      args[:auth_redirect] = \"discourse://auth_redirect\"\n      get \"/latest\", params: args\n\n      expect(response.body).to eq(I18n.t(\"user_api_key.invalid_public_key\"))\n    end\n\n    it 'does not allow invalid auth_redirect' do\n      args[:user_api_public_key] = public_key\n      get \"/latest\", params: args\n\n      expect(response.body).to eq(I18n.t(\"user_api_key.invalid_auth_redirect\"))\n    end\n\n    it 'does not redirect if one_time_password scope is disallowed' do\n      SiteSetting.allow_user_api_key_scopes = \"read|write\"\n      args[:user_api_public_key] = public_key\n      args[:auth_redirect] = \"discourse://auth_redirect\"\n\n      get \"/latest\", params: args\n\n      expect(response.status).to_not eq(302)\n      expect(response).to_not redirect_to(\"#{args[:auth_redirect]}?otp=true\")\n    end\n\n    it 'redirects correctly with valid params' do\n      SiteSetting.login_required = true\n      args[:user_api_public_key] = public_key\n      args[:auth_redirect] = \"discourse://auth_redirect\"\n\n      get \"/categories\", params: args\n\n      expect(response.status).to eq(302)\n      expect(response).to redirect_to(\"#{args[:auth_redirect]}?otp=true\")\n    end\n  end\n\n  describe 'Content Security Policy' do\n    it 'is enabled by SiteSettings' do\n      SiteSetting.content_security_policy = false\n      SiteSetting.content_security_policy_report_only = false\n\n      get '/'\n\n      expect(response.headers).to_not include('Content-Security-Policy')\n      expect(response.headers).to_not include('Content-Security-Policy-Report-Only')\n\n      SiteSetting.content_security_policy = true\n      SiteSetting.content_security_policy_report_only = true\n\n      get '/'\n\n      expect(response.headers).to include('Content-Security-Policy')\n      expect(response.headers).to include('Content-Security-Policy-Report-Only')\n    end\n\n    it 'can be customized with SiteSetting' do\n      SiteSetting.content_security_policy = true\n\n      get '/'\n      script_src = parse(response.headers['Content-Security-Policy'])['script-src']\n\n      expect(script_src).to_not include('example.com')\n\n      SiteSetting.content_security_policy_script_src = 'example.com'\n\n      get '/'\n      script_src = parse(response.headers['Content-Security-Policy'])['script-src']\n\n      expect(script_src).to include('example.com')\n    end\n\n    it 'does not set CSP when responding to non-HTML' do\n      SiteSetting.content_security_policy = true\n      SiteSetting.content_security_policy_report_only = true\n\n      get '/latest.json'\n\n      expect(response.headers).to_not include('Content-Security-Policy')\n      expect(response.headers).to_not include('Content-Security-Policy-Report-Only')\n    end\n\n    it 'when GTM is enabled it adds the same nonce to the policy and the GTM tag' do\n      SiteSetting.content_security_policy = true\n      SiteSetting.gtm_container_id = 'GTM-ABCDEF'\n\n      get '/latest'\n      nonce = ApplicationHelper.google_tag_manager_nonce\n      expect(response.headers).to include('Content-Security-Policy')\n\n      script_src = parse(response.headers['Content-Security-Policy'])['script-src']\n      expect(script_src.to_s).to include(nonce)\n      expect(response.body).to include(nonce)\n    end\n\n    def parse(csp_string)\n      csp_string.split(';').map do |policy|\n        directive, *sources = policy.split\n        [directive, sources]\n      end.to_h\n    end\n  end\n\n  it 'can respond to a request with */* accept header' do\n    get '/', headers: { HTTP_ACCEPT: '*/*' }\n    expect(response.status).to eq(200)\n    expect(response.body).to include('Discourse')\n  end\n\n  it 'has canonical tag' do\n    get '/', headers: { HTTP_ACCEPT: '*/*' }\n    expect(response.body).to have_tag(\"link\", with: { rel: \"canonical\", href: \"http://test.localhost/\" })\n    get '/?query_param=true', headers: { HTTP_ACCEPT: '*/*' }\n    expect(response.body).to have_tag(\"link\", with: { rel: \"canonical\", href: \"http://test.localhost/\" })\n    get '/latest?page=2&additional_param=true', headers: { HTTP_ACCEPT: '*/*' }\n    expect(response.body).to have_tag(\"link\", with: { rel: \"canonical\", href: \"http://test.localhost/latest?page=2\" })\n    get '/404', headers: { HTTP_ACCEPT: '*/*' }\n    expect(response.body).to have_tag(\"link\", with: { rel: \"canonical\", href: \"http://test.localhost/404\" })\n    topic = create_post.topic\n    get \"/t/#{topic.slug}/#{topic.id}\"\n    expect(response.body).to have_tag(\"link\", with: { rel: \"canonical\", href: \"http://test.localhost/t/#{topic.slug}/#{topic.id}\" })\n  end\n\n  it \"adds a noindex header if non-canonical indexing is disabled\" do\n    SiteSetting.allow_indexing_non_canonical_urls = false\n    get '/'\n    expect(response.headers['X-Robots-Tag']).to be_nil\n\n    get '/latest'\n    expect(response.headers['X-Robots-Tag']).to be_nil\n\n    get '/categories'\n    expect(response.headers['X-Robots-Tag']).to be_nil\n\n    topic = create_post.topic\n    get \"/t/#{topic.slug}/#{topic.id}\"\n    expect(response.headers['X-Robots-Tag']).to be_nil\n    post = create_post(topic_id: topic.id)\n    get \"/t/#{topic.slug}/#{topic.id}/2\"\n    expect(response.headers['X-Robots-Tag']).to eq('noindex')\n\n    20.times do\n      create_post(topic_id: topic.id)\n    end\n    get \"/t/#{topic.slug}/#{topic.id}/21\"\n    expect(response.headers['X-Robots-Tag']).to eq('noindex')\n    get \"/t/#{topic.slug}/#{topic.id}?page=2\"\n    expect(response.headers['X-Robots-Tag']).to be_nil\n  end\n\n  context \"default locale\" do\n    before do\n      SiteSetting.default_locale = :fr\n      sign_in(Fabricate(:user))\n    end\n\n    after do\n      I18n.reload!\n    end\n\n    context \"with rate limits\" do\n      before do\n        RateLimiter.clear_all!\n        RateLimiter.enable\n      end\n\n      it \"serves a LimitExceeded error in the preferred locale\" do\n        SiteSetting.max_likes_per_day = 1\n        post1 = Fabricate(:post)\n        post2 = Fabricate(:post)\n        override = TranslationOverride.create(\n          locale: \"fr\",\n          translation_key: \"rate_limiter.by_type.create_like\",\n          value: \"French LimitExceeded error message\"\n        )\n        I18n.reload!\n\n        post \"/post_actions.json\", params: {\n          id: post1.id, post_action_type_id: PostActionType.types[:like]\n        }\n        expect(response.status).to eq(200)\n\n        post \"/post_actions.json\", params: {\n          id: post2.id, post_action_type_id: PostActionType.types[:like]\n        }\n        expect(response.status).to eq(429)\n        expect(response.parsed_body[\"errors\"].first).to eq(override.value)\n      end\n    end\n\n    it \"serves an InvalidParameters error with the default locale\" do\n      override = TranslationOverride.create(\n        locale: \"fr\",\n        translation_key: \"invalid_params\",\n        value: \"French InvalidParameters error message\"\n      )\n      I18n.reload!\n\n      get \"/search.json\", params: { q: \"hello\\0hello\" }\n      expect(response.status).to eq(400)\n      expect(response.parsed_body[\"errors\"].first).to eq(override.value)\n    end\n  end\n\n  describe \"set_locale\" do\n    # Using /bootstrap.json because it returns a locale-dependent value\n    def headers(locale)\n      { HTTP_ACCEPT_LANGUAGE: locale }\n    end\n\n    context \"allow_user_locale disabled\" do\n      context \"accept-language header differs from default locale\" do\n        before do\n          SiteSetting.allow_user_locale = false\n          SiteSetting.default_locale = \"en\"\n        end\n\n        context \"with an anonymous user\" do\n          it \"uses the default locale\" do\n            get \"/bootstrap.json\", headers: headers(\"fr\")\n            expect(response.status).to eq(200)\n            expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"en.js\")\n          end\n        end\n\n        context \"with a logged in user\" do\n          it \"it uses the default locale\" do\n            user = Fabricate(:user, locale: :fr)\n            sign_in(user)\n\n            get \"/bootstrap.json\", headers: headers(\"fr\")\n            expect(response.status).to eq(200)\n            expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"en.js\")\n          end\n        end\n      end\n    end\n\n    context \"set_locale_from_accept_language_header enabled\" do\n      context \"accept-language header differs from default locale\" do\n        before do\n          SiteSetting.allow_user_locale = true\n          SiteSetting.set_locale_from_accept_language_header = true\n          SiteSetting.default_locale = \"en\"\n        end\n\n        context \"with an anonymous user\" do\n          it \"uses the locale from the headers\" do\n            get \"/bootstrap.json\", headers: headers(\"fr\")\n            expect(response.status).to eq(200)\n            expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"fr.js\")\n          end\n\n          it \"doesn't leak after requests\" do\n            get \"/bootstrap.json\", headers: headers(\"fr\")\n            expect(response.status).to eq(200)\n            expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"fr.js\")\n            expect(I18n.locale.to_s).to eq(SiteSettings::DefaultsProvider::DEFAULT_LOCALE)\n          end\n        end\n\n        context \"with a logged in user\" do\n          let(:user) { Fabricate(:user, locale: :fr) }\n\n          before do\n            sign_in(user)\n          end\n\n          it \"uses the user's preferred locale\" do\n            get \"/bootstrap.json\", headers: headers(\"fr\")\n            expect(response.status).to eq(200)\n            expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"fr.js\")\n          end\n\n          it \"serves a 404 page in the preferred locale\" do\n            get \"/missingroute\", headers: headers(\"fr\")\n            expect(response.status).to eq(404)\n            expected_title = I18n.t(\"page_not_found.title\", locale: :fr)\n            expect(response.body).to include(CGI.escapeHTML(expected_title))\n          end\n\n          it \"serves a RenderEmpty page in the preferred locale\" do\n            get \"/u/#{user.username}/preferences/interface\"\n            expect(response.status).to eq(200)\n            expect(response.body).to have_tag('script', with: { src: \"/assets/locales/fr.js\" })\n          end\n        end\n      end\n\n      context \"the preferred locale includes a region\" do\n        it \"returns the locale and region separated by an underscore\" do\n          SiteSetting.allow_user_locale = true\n          SiteSetting.set_locale_from_accept_language_header = true\n          SiteSetting.default_locale = \"en\"\n\n          get \"/bootstrap.json\", headers: headers(\"zh-CN\")\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"zh_CN.js\")\n        end\n      end\n\n      context 'accept-language header is not set' do\n        it 'uses the site default locale' do\n          SiteSetting.allow_user_locale = true\n          SiteSetting.default_locale = 'en'\n\n          get \"/bootstrap.json\", headers: headers(\"\")\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"en.js\")\n        end\n      end\n    end\n  end\n\n  describe 'vary header' do\n    it 'includes Vary:Accept on all requests where format is not explicit' do\n      # Rails default behaviour - include Vary:Accept when Accept is supplied\n      get \"/latest\", headers: { \"Accept\" => \"application/json\" }\n      expect(response.status).to eq(200)\n      expect(response.headers[\"Vary\"]).to eq(\"Accept\")\n\n      # Discourse additional behaviour (see lib/vary_header.rb)\n      # Include Vary:Accept even when Accept is not supplied\n      get \"/latest\"\n      expect(response.status).to eq(200)\n      expect(response.headers[\"Vary\"]).to eq(\"Accept\")\n\n      # Not needed, because the path 'format' parameter overrides the Accept header\n      get \"/latest.json\"\n      expect(response.status).to eq(200)\n      expect(response.headers[\"Vary\"]).to eq(nil)\n    end\n  end\n\n  describe \"Discourse-Rate-Limit-Error-Code header\" do\n    fab!(:admin) { Fabricate(:admin) }\n\n    before do\n      RateLimiter.clear_all!\n      RateLimiter.enable\n    end\n\n    it \"is included when API key is rate limited\" do\n      global_setting :max_admin_api_reqs_per_minute, 1\n      api_key = ApiKey.create!(user_id: admin.id).key\n      get \"/latest.json\", headers: {\n        \"Api-Key\": api_key,\n        \"Api-Username\": admin.username\n      }\n      expect(response.status).to eq(200)\n\n      get \"/latest.json\", headers: {\n        \"Api-Key\": api_key,\n        \"Api-Username\": admin.username\n      }\n      expect(response.status).to eq(429)\n      expect(response.headers[\"Discourse-Rate-Limit-Error-Code\"]).to eq(\"admin_api_key_rate_limit\")\n    end\n\n    it \"is included when user API key is rate limited\" do\n      global_setting :max_user_api_reqs_per_minute, 1\n      user_api_key = UserApiKey.create!(\n        user_id: admin.id,\n        client_id: \"\",\n        application_name: \"discourseapp\"\n      )\n      user_api_key.scopes = UserApiKeyScope.all_scopes.keys.map do |name|\n        UserApiKeyScope.create!(name: name, user_api_key_id: user_api_key.id)\n      end\n      user_api_key.save!\n\n      get \"/session/current.json\", headers: {\n        \"User-Api-Key\": user_api_key.key,\n      }\n      expect(response.status).to eq(200)\n\n      get \"/session/current.json\", headers: {\n        \"User-Api-Key\": user_api_key.key,\n      }\n      expect(response.status).to eq(429)\n      expect(\n        response.headers[\"Discourse-Rate-Limit-Error-Code\"]\n      ).to eq(\"user_api_key_limiter_60_secs\")\n\n      global_setting :max_user_api_reqs_per_minute, 100\n      global_setting :max_user_api_reqs_per_day, 1\n\n      get \"/session/current.json\", headers: {\n        \"User-Api-Key\": user_api_key.key,\n      }\n      expect(response.status).to eq(429)\n      expect(\n        response.headers[\"Discourse-Rate-Limit-Error-Code\"]\n      ).to eq(\"user_api_key_limiter_1_day\")\n    end\n  end\n\n  describe \"crawlers in slow_down_crawler_user_agents site setting\" do\n    before do\n      RateLimiter.enable\n      RateLimiter.clear_all!\n    end\n\n    it \"are rate limited\" do\n      SiteSetting.slow_down_crawler_rate = 128\n      SiteSetting.slow_down_crawler_user_agents = \"badcrawler|problematiccrawler\"\n      now = Time.zone.now\n      freeze_time now\n\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam badcrawler\"\n      }\n      expect(response.status).to eq(200)\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam badcrawler\"\n      }\n      expect(response.status).to eq(429)\n      expect(response.headers[\"Retry-After\"]).to eq(\"128\")\n\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam problematiccrawler\"\n      }\n      expect(response.status).to eq(200)\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam problematiccrawler\"\n      }\n      expect(response.status).to eq(429)\n      expect(response.headers[\"Retry-After\"]).to eq(\"128\")\n\n      freeze_time now + 100.seconds\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam badcrawler\"\n      }\n      expect(response.status).to eq(429)\n      expect(response.headers[\"Retry-After\"]).to eq(\"28\")\n\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam problematiccrawler\"\n      }\n      expect(response.status).to eq(429)\n      expect(response.headers[\"Retry-After\"]).to eq(\"28\")\n\n      freeze_time now + 150.seconds\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam badcrawler\"\n      }\n      expect(response.status).to eq(200)\n\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam problematiccrawler\"\n      }\n      expect(response.status).to eq(200)\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire 'current_user'\n\nclass ApplicationController < ActionController::Base\n  include CurrentUser\n  include CanonicalURL::ControllerExtensions\n  include JsonError\n  include GlobalPath\n  include Hijack\n  include ReadOnlyMixin\n  include VaryHeader\n\n  attr_reader :theme_id\n\n  serialization_scope :guardian\n\n  protect_from_forgery\n\n  # Default Rails 3.2 lets the request through with a blank session\n  #  we are being more pedantic here and nulling session / current_user\n  #  and then raising a CSRF exception\n  def handle_unverified_request\n    # NOTE: API key is secret, having it invalidates the need for a CSRF token\n    unless is_api? || is_user_api?\n      super\n      clear_current_user\n      render plain: \"[\\\"BAD CSRF\\\"]\", status: 403\n    end\n  end\n\n  before_action :rate_limit_crawlers\n  before_action :check_readonly_mode\n  before_action :handle_theme\n  before_action :set_current_user_for_logs\n  before_action :set_mp_snapshot_fields\n  before_action :clear_notifications\n  around_action :with_resolved_locale\n  before_action :set_mobile_view\n  before_action :block_if_readonly_mode\n  before_action :authorize_mini_profiler\n  before_action :redirect_to_login_if_required\n  before_action :block_if_requires_login\n  before_action :preload_json\n  before_action :check_xhr\n  after_action  :add_readonly_header\n  after_action  :perform_refresh_session\n  after_action  :dont_cache_page\n  after_action  :conditionally_allow_site_embedding\n  after_action  :ensure_vary_header\n  after_action  :add_noindex_header, if: -> { is_feed_request? || !SiteSetting.allow_index_in_robots_txt }\n  after_action  :add_noindex_header_to_non_canonical, if: -> { request.get? && !(request.format && request.format.json?) && !request.xhr? }\n\n  HONEYPOT_KEY ||= 'HONEYPOT_KEY'\n  CHALLENGE_KEY ||= 'CHALLENGE_KEY'\n\n  layout :set_layout\n\n  def has_escaped_fragment?\n    SiteSetting.enable_escaped_fragments? && params.key?(\"_escaped_fragment_\")\n  end\n\n  def show_browser_update?\n    @show_browser_update ||= CrawlerDetection.show_browser_update?(request.user_agent)\n  end\n  helper_method :show_browser_update?\n\n  def use_crawler_layout?\n    @use_crawler_layout ||=\n      request.user_agent &&\n      (request.media_type.blank? || request.media_type.include?('html')) &&\n      !['json', 'rss'].include?(params[:format]) &&\n      (has_escaped_fragment? || params.key?(\"print\") || show_browser_update? ||\n      CrawlerDetection.crawler?(request.user_agent, request.headers[\"HTTP_VIA\"])\n      )\n  end\n\n  def perform_refresh_session\n    refresh_session(current_user) unless @readonly_mode\n  end\n\n  def immutable_for(duration)\n    response.cache_control[:max_age] = duration.to_i\n    response.cache_control[:public] = true\n    response.cache_control[:extras] = [\"immutable\"]\n  end\n\n  def dont_cache_page\n    if !response.headers[\"Cache-Control\"] && response.cache_control.blank?\n      response.cache_control[:no_cache] = true\n      response.cache_control[:extras] = [\"no-store\"]\n    end\n    if SiteSetting.login_required\n      response.headers['Discourse-No-Onebox'] = '1'\n    end\n  end\n\n  def conditionally_allow_site_embedding\n    if SiteSetting.allow_embedding_site_in_an_iframe\n      response.headers.delete('X-Frame-Options')\n    end\n  end\n\n  def ember_cli_required?\n    Rails.env.development? && ENV['NO_EMBER_CLI'] != '1' && request.headers['X-Discourse-Ember-CLI'] != 'true'\n  end\n\n  def application_layout\n    ember_cli_required? ? \"ember_cli\" : \"application\"\n  end\n\n  def set_layout\n    case request.headers[\"Discourse-Render\"]\n    when \"desktop\"\n      return application_layout\n    when \"crawler\"\n      return \"crawler\"\n    end\n\n    use_crawler_layout? ? 'crawler' : application_layout\n  end\n\n  class RenderEmpty < StandardError; end\n  class PluginDisabled < StandardError; end\n\n  rescue_from RenderEmpty do\n    with_resolved_locale { render 'default/empty' }\n  end\n\n  rescue_from ArgumentError do |e|\n    if e.message == \"string contains null byte\"\n      raise Discourse::InvalidParameters, e.message\n    else\n      raise e\n    end\n  end\n\n  rescue_from PG::ReadOnlySqlTransaction do |e|\n    Discourse.received_postgres_readonly!\n    Rails.logger.error(\"#{e.class} #{e.message}: #{e.backtrace.join(\"\\n\")}\")\n    rescue_with_handler(Discourse::ReadOnly.new) || raise\n  end\n\n  rescue_from ActionController::ParameterMissing do |e|\n    render_json_error e.message, status: 400\n  end\n\n  rescue_from Discourse::SiteSettingMissing do |e|\n    render_json_error I18n.t('site_setting_missing', name: e.message), status: 500\n  end\n\n  rescue_from ActionController::RoutingError, PluginDisabled  do\n    rescue_discourse_actions(:not_found, 404)\n  end\n\n  # Handles requests for giant IDs that throw pg exceptions\n  rescue_from ActiveModel::RangeError do |e|\n    if e.message =~ /ActiveModel::Type::Integer/\n      rescue_discourse_actions(:not_found, 404)\n    else\n      raise e\n    end\n  end\n\n  rescue_from ActiveRecord::RecordInvalid do |e|\n    if request.format && request.format.json?\n      render_json_error e, type: :record_invalid, status: 422\n    else\n      raise e\n    end\n  end\n\n  rescue_from ActiveRecord::StatementInvalid do |e|\n    Discourse.reset_active_record_cache_if_needed(e)\n    raise e\n  end\n\n  # If they hit the rate limiter\n  rescue_from RateLimiter::LimitExceeded do |e|\n    retry_time_in_seconds = e&.available_in\n\n    response_headers = {\n      'Retry-After': retry_time_in_seconds.to_s\n    }\n\n    if e&.error_code\n      response_headers['Discourse-Rate-Limit-Error-Code'] = e.error_code\n    end\n\n    with_resolved_locale do\n      render_json_error(\n        e.description,\n        type: :rate_limit,\n        status: 429,\n        extras: { wait_seconds: retry_time_in_seconds, time_left: e&.time_left },\n        headers: response_headers\n      )\n    end\n  end\n\n  rescue_from Discourse::NotLoggedIn do |e|\n    if (request.format && request.format.json?) || request.xhr? || !request.get?\n      rescue_discourse_actions(:not_logged_in, 403, include_ember: true)\n    else\n      rescue_discourse_actions(:not_found, 404)\n    end\n  end\n\n  rescue_from Discourse::InvalidParameters do |e|\n    opts = {\n      custom_message: 'invalid_params',\n      custom_message_params: { message: e.message }\n    }\n\n    if (request.format && request.format.json?) || request.xhr? || !request.get?\n      rescue_discourse_actions(:invalid_parameters, 400, opts.merge(include_ember: true))\n    else\n      rescue_discourse_actions(:not_found, 400, opts)\n    end\n  end\n\n  rescue_from Discourse::NotFound do |e|\n    rescue_discourse_actions(\n      :not_found,\n      e.status,\n      check_permalinks: e.check_permalinks,\n      original_path: e.original_path,\n      custom_message: e.custom_message\n    )\n  end\n\n  rescue_from Discourse::InvalidAccess do |e|\n    if e.opts[:delete_cookie].present?\n      cookies.delete(e.opts[:delete_cookie])\n    end\n\n    rescue_discourse_actions(\n      :invalid_access,\n      403,\n      include_ember: true,\n      custom_message: e.custom_message,\n      custom_message_params: e.custom_message_params,\n      group: e.group\n    )\n  end\n\n  rescue_from Discourse::ReadOnly do\n    unless response_body\n      respond_to do |format|\n        format.json do\n          render_json_error I18n.t('read_only_mode_enabled'), type: :read_only, status: 503\n        end\n        format.html do\n          render status: 503, layout: 'no_ember', template: 'exceptions/read_only'\n        end\n      end\n    end\n  end\n\n  rescue_from SecondFactor::AuthManager::SecondFactorRequired do |e|\n    if request.xhr?\n      render json: {\n        second_factor_challenge_nonce: e.nonce\n      }, status: 403\n    else\n      redirect_to session_2fa_path(nonce: e.nonce)\n    end\n  end\n\n  rescue_from SecondFactor::BadChallenge do |e|\n    render json: { error: I18n.t(e.error_translation_key) }, status: e.status_code\n  end\n\n  def redirect_with_client_support(url, options = {})\n    if request.xhr?\n      response.headers['Discourse-Xhr-Redirect'] = 'true'\n      render plain: url\n    else\n      redirect_to url, options\n    end\n  end\n\n  def rescue_discourse_actions(type, status_code, opts = nil)\n    opts ||= {}\n    show_json_errors = (request.format && request.format.json?) ||\n                       (request.xhr?) ||\n                       ((params[:external_id] || '').ends_with? '.json')\n\n    if type == :not_found && opts[:check_permalinks]\n      url = opts[:original_path] || request.fullpath\n      permalink = Permalink.find_by_url(url)\n\n      # there are some cases where we have a permalink but no url\n      # cause category / topic was deleted\n      if permalink.present? && permalink.target_url\n        # permalink present, redirect to that URL\n        redirect_with_client_support permalink.target_url, status: :moved_permanently, allow_other_host: true\n        return\n      end\n    end\n\n    message = title = nil\n    with_resolved_locale(check_current_user: false) do\n      if opts[:custom_message]\n        title = message = I18n.t(opts[:custom_message], opts[:custom_message_params] || {})\n      else\n        message = I18n.t(type)\n        if status_code == 403\n          title = I18n.t(\"page_forbidden.title\")\n        else\n          title = I18n.t(\"page_not_found.title\")\n        end\n      end\n    end\n\n    error_page_opts = { title: title, status: status_code, group: opts[:group] }\n\n    if show_json_errors\n      opts = { type: type, status: status_code }\n\n      with_resolved_locale(check_current_user: false) do\n        # Include error in HTML format for topics#show.\n        if (request.params[:controller] == 'topics' && request.params[:action] == 'show') || (request.params[:controller] == 'categories' && request.params[:action] == 'find_by_slug')\n          opts[:extras] = {\n            title: I18n.t('page_not_found.page_title'),\n            html: build_not_found_page(error_page_opts),\n            group: error_page_opts[:group]\n          }\n        end\n      end\n\n      render_json_error message, opts\n    else\n      begin\n        # 404 pages won't have the session and theme_keys without these:\n        current_user\n        handle_theme\n      rescue Discourse::InvalidAccess\n        return render plain: message, status: status_code\n      end\n      with_resolved_locale do\n        error_page_opts[:layout] = opts[:include_ember] ? 'application' : 'no_ember'\n        render html: build_not_found_page(error_page_opts)\n      end\n    end\n  end\n\n  # If a controller requires a plugin, it will raise an exception if that plugin is\n  # disabled. This allows plugins to be disabled programmatically.\n  def self.requires_plugin(plugin_name)\n    before_action do\n      raise PluginDisabled.new if Discourse.disabled_plugin_names.include?(plugin_name)\n    end\n  end\n\n  def set_current_user_for_logs\n    if current_user\n      Logster.add_to_env(request.env, \"username\", current_user.username)\n      response.headers[\"X-Discourse-Username\"] = current_user.username\n    end\n    response.headers[\"X-Discourse-Route\"] = \"#{controller_name}/#{action_name}\"\n  end\n\n  def set_mp_snapshot_fields\n    if defined?(Rack::MiniProfiler)\n      Rack::MiniProfiler.add_snapshot_custom_field(\"Application version\", Discourse.git_version)\n      if Rack::MiniProfiler.snapshots_transporter?\n        Rack::MiniProfiler.add_snapshot_custom_field(\"Site\", Discourse.current_hostname)\n      end\n    end\n  end\n\n  def clear_notifications\n    if current_user && !@readonly_mode\n\n      cookie_notifications = cookies['cn']\n      notifications = request.headers['Discourse-Clear-Notifications']\n\n      if cookie_notifications\n        if notifications.present?\n          notifications += \",#{cookie_notifications}\"\n        else\n          notifications = cookie_notifications\n        end\n      end\n\n      if notifications.present?\n        notification_ids = notifications.split(\",\").map(&:to_i)\n        Notification.read(current_user, notification_ids)\n        current_user.reload\n        current_user.publish_notifications_state\n        cookie_args = {}\n        cookie_args[:path] = Discourse.base_path if Discourse.base_path.present?\n        cookies.delete('cn', cookie_args)\n      end\n    end\n  end\n\n  def with_resolved_locale(check_current_user: true)\n    if check_current_user && (user = current_user rescue nil)\n      locale = user.effective_locale\n    else\n      if SiteSetting.set_locale_from_accept_language_header\n        locale = locale_from_header\n      else\n        locale = SiteSetting.default_locale\n      end\n    end\n\n    if !I18n.locale_available?(locale)\n      locale = SiteSettings::DefaultsProvider::DEFAULT_LOCALE\n    end\n\n    I18n.ensure_all_loaded!\n    I18n.with_locale(locale) { yield }\n  end\n\n  def store_preloaded(key, json)\n    @preloaded ||= {}\n    # I dislike that there is a gsub as opposed to a gsub!\n    #  but we can not be mucking with user input, I wonder if there is a way\n    #  to inject this safety deeper in the library or even in AM serializer\n    @preloaded[key] = json.gsub(\"</\", \"<\\\\/\")\n  end\n\n  # If we are rendering HTML, preload the session data\n  def preload_json\n    # We don't preload JSON on xhr or JSON request\n    return if request.xhr? || request.format.json?\n\n    # if we are posting in makes no sense to preload\n    return if request.method != \"GET\"\n\n    # TODO should not be invoked on redirection so this should be further deferred\n    preload_anonymous_data\n\n    if current_user\n      current_user.sync_notification_channel_position\n      preload_current_user_data\n    end\n  end\n\n  def set_mobile_view\n    session[:mobile_view] = params[:mobile_view] if params.has_key?(:mobile_view)\n  end\n\n  NO_CUSTOM = \"no_custom\"\n  NO_PLUGINS = \"no_plugins\"\n  ONLY_OFFICIAL = \"only_official\"\n  SAFE_MODE = \"safe_mode\"\n\n  def resolve_safe_mode\n    return unless guardian.can_enable_safe_mode?\n\n    safe_mode = params[SAFE_MODE]\n    if safe_mode\n      request.env[NO_CUSTOM] = !!safe_mode.include?(NO_CUSTOM)\n      request.env[NO_PLUGINS] = !!safe_mode.include?(NO_PLUGINS)\n      request.env[ONLY_OFFICIAL] = !!safe_mode.include?(ONLY_OFFICIAL)\n    end\n  end\n\n  def handle_theme\n    return if request.format == \"js\"\n\n    resolve_safe_mode\n    return if request.env[NO_CUSTOM]\n\n    theme_id = nil\n\n    if (preview_theme_id = request[:preview_theme_id]&.to_i) &&\n      guardian.allow_themes?([preview_theme_id], include_preview: true)\n\n      theme_id = preview_theme_id\n    end\n\n    user_option = current_user&.user_option\n\n    if theme_id.blank?\n      ids, seq = cookies[:theme_ids]&.split(\"|\")\n      id = ids&.split(\",\")&.map(&:to_i)&.first\n      if id.present? && seq && seq.to_i == user_option&.theme_key_seq.to_i\n        theme_id = id if guardian.allow_themes?([id])\n      end\n    end\n\n    if theme_id.blank?\n      ids = user_option&.theme_ids || []\n      theme_id = ids.first if guardian.allow_themes?(ids)\n    end\n\n    if theme_id.blank? && SiteSetting.default_theme_id != -1 && guardian.allow_themes?([SiteSetting.default_theme_id])\n      theme_id = SiteSetting.default_theme_id\n    end\n\n    @theme_id = request.env[:resolved_theme_id] = theme_id\n  end\n\n  def guardian\n    # sometimes we log on a user in the middle of a request so we should throw\n    # away the cached guardian instance when we do that\n    if (@guardian&.user).blank? && current_user.present?\n      @guardian = Guardian.new(current_user, request)\n    end\n    @guardian ||= Guardian.new(current_user, request)\n  end\n\n  def current_homepage\n    current_user&.user_option&.homepage || SiteSetting.anonymous_homepage\n  end\n\n  def serialize_data(obj, serializer, opts = nil)\n    # If it's an array, apply the serializer as an each_serializer to the elements\n    serializer_opts = { scope: guardian }.merge!(opts || {})\n    if obj.respond_to?(:to_ary)\n      serializer_opts[:each_serializer] = serializer\n      ActiveModel::ArraySerializer.new(obj.to_ary, serializer_opts).as_json\n    else\n      serializer.new(obj, serializer_opts).as_json\n    end\n  end\n\n  # This is odd, but it seems that in Rails `render json: obj` is about\n  # 20% slower than calling MultiJSON.dump ourselves. I'm not sure why\n  # Rails doesn't call MultiJson.dump when you pass it json: obj but\n  # it seems we don't need whatever Rails is doing.\n  def render_serialized(obj, serializer, opts = nil)\n    render_json_dump(serialize_data(obj, serializer, opts), opts)\n  end\n\n  def render_json_dump(obj, opts = nil)\n    opts ||= {}\n    if opts[:rest_serializer]\n      obj['__rest_serializer'] = \"1\"\n      opts.each do |k, v|\n        obj[k] = v if k.to_s.start_with?(\"refresh_\")\n      end\n\n      obj['extras'] = opts[:extras] if opts[:extras]\n      obj['meta'] = opts[:meta] if opts[:meta]\n    end\n\n    render json: MultiJson.dump(obj), status: opts[:status] || 200\n  end\n\n  def can_cache_content?\n    current_user.blank? && cookies[:authentication_data].blank?\n  end\n\n  # Our custom cache method\n  def discourse_expires_in(time_length)\n    return unless can_cache_content?\n    Middleware::AnonymousCache.anon_cache(request.env, time_length)\n  end\n\n  def fetch_user_from_params(opts = nil, eager_load = [])\n    opts ||= {}\n    user = if params[:username]\n      username_lower = params[:username].downcase.chomp('.json')\n\n      if current_user && current_user.username_lower == username_lower\n        current_user\n      else\n        find_opts = { username_lower: username_lower }\n        find_opts[:active] = true unless opts[:include_inactive] || current_user.try(:staff?)\n        result = User\n        (result = result.includes(*eager_load)) if !eager_load.empty?\n        result.find_by(find_opts)\n      end\n    elsif params[:external_id]\n      external_id = params[:external_id].chomp('.json')\n      if provider_name = params[:external_provider]\n        raise Discourse::InvalidAccess unless guardian.is_admin? # external_id might be something sensitive\n        provider = Discourse.enabled_authenticators.find { |a| a.name == provider_name }\n        raise Discourse::NotFound if !provider&.is_managed? # Only managed authenticators use UserAssociatedAccount\n        UserAssociatedAccount.find_by(provider_name: provider_name, provider_uid: external_id)&.user\n      else\n        SingleSignOnRecord.find_by(external_id: external_id).try(:user)\n      end\n    end\n    raise Discourse::NotFound if user.blank?\n\n    guardian.ensure_can_see!(user)\n    user\n  end\n\n  def post_ids_including_replies\n    post_ids  = params[:post_ids].map(&:to_i)\n    post_ids |= PostReply.where(post_id: params[:reply_post_ids]).pluck(:reply_post_id) if params[:reply_post_ids]\n    post_ids\n  end\n\n  def no_cookies\n    # do your best to ensure response has no cookies\n    # longer term we may want to push this into middleware\n    headers.delete 'Set-Cookie'\n    request.session_options[:skip] = true\n  end\n\n  def secure_session\n    SecureSession.new(session[\"secure_session_id\"] ||= SecureRandom.hex)\n  end\n\n  def handle_permalink(path)\n    permalink = Permalink.find_by_url(path)\n    if permalink && permalink.target_url\n      redirect_to permalink.target_url, status: :moved_permanently\n    end\n  end\n\n  def rate_limit_second_factor!(user)\n    return if params[:second_factor_token].blank?\n\n    RateLimiter.new(nil, \"second-factor-min-#{request.remote_ip}\", 6, 1.minute).performed!\n\n    if user\n      RateLimiter.new(nil, \"second-factor-min-#{user.username}\", 6, 1.minute).performed!\n    end\n  end\n\n  private\n\n  def locale_from_header\n    HttpLanguageParser.parse(request.env[\"HTTP_ACCEPT_LANGUAGE\"])\n  end\n\n  def preload_anonymous_data\n    store_preloaded(\"site\", Site.json_for(guardian))\n    store_preloaded(\"siteSettings\", SiteSetting.client_settings_json)\n    store_preloaded(\"customHTML\", custom_html_json)\n    store_preloaded(\"banner\", banner_json)\n    store_preloaded(\"customEmoji\", custom_emoji)\n    store_preloaded(\"isReadOnly\", @readonly_mode.to_s)\n    store_preloaded(\"isStaffWritesOnly\", @staff_writes_only_mode.to_s)\n    store_preloaded(\"activatedThemes\", activated_themes_json)\n  end\n\n  def preload_current_user_data\n    store_preloaded(\"currentUser\", MultiJson.dump(CurrentUserSerializer.new(current_user, scope: guardian, root: false)))\n    report = TopicTrackingState.report(current_user)\n    serializer = ActiveModel::ArraySerializer.new(\n      report, each_serializer: TopicTrackingStateSerializer, scope: guardian\n    )\n    store_preloaded(\"topicTrackingStates\", MultiJson.dump(serializer))\n  end\n\n  def custom_html_json\n    target = view_context.mobile_view? ? :mobile : :desktop\n\n    data =\n      if @theme_id.present?\n        {\n         top: Theme.lookup_field(@theme_id, target, \"after_header\"),\n         footer: Theme.lookup_field(@theme_id, target, \"footer\")\n        }\n      else\n        {}\n      end\n\n    if DiscoursePluginRegistry.custom_html\n      data.merge! DiscoursePluginRegistry.custom_html\n    end\n\n    DiscoursePluginRegistry.html_builders.each do |name, _|\n      if name.start_with?(\"client:\")\n        data[name.sub(/^client:/, '')] = DiscoursePluginRegistry.build_html(name, self)\n      end\n    end\n\n    MultiJson.dump(data)\n  end\n\n  def self.banner_json_cache\n    @banner_json_cache ||= DistributedCache.new(\"banner_json\")\n  end\n\n  def banner_json\n    json = ApplicationController.banner_json_cache[\"json\"]\n    return \"{}\" if !current_user && SiteSetting.login_required?\n\n    unless json\n      topic = Topic.where(archetype: Archetype.banner).first\n      banner = topic.present? ? topic.banner : {}\n      ApplicationController.banner_json_cache[\"json\"] = json = MultiJson.dump(banner)\n    end\n\n    json\n  end\n\n  def custom_emoji\n    serializer = ActiveModel::ArraySerializer.new(Emoji.custom, each_serializer: EmojiSerializer)\n    MultiJson.dump(serializer)\n  end\n\n  # Render action for a JSON error.\n  #\n  # obj       - a translated string, an ActiveRecord model, or an array of translated strings\n  # opts:\n  #   type    - a machine-readable description of the error\n  #   status  - HTTP status code to return\n  #   headers - extra headers for the response\n  def render_json_error(obj, opts = {})\n    opts = { status: opts } if opts.is_a?(Integer)\n    opts.fetch(:headers, {}).each { |name, value| headers[name.to_s] = value }\n\n    render(\n      json: MultiJson.dump(create_errors_json(obj, opts)),\n      status: opts[:status] || status_code(obj)\n    )\n  end\n\n  def status_code(obj)\n    return 403 if obj.try(:forbidden)\n    return 404 if obj.try(:not_found)\n    422\n  end\n\n  def success_json\n    { success: 'OK' }\n  end\n\n  def failed_json\n    { failed: 'FAILED' }\n  end\n\n  def json_result(obj, opts = {})\n    if yield(obj)\n      json = success_json\n\n      # If we were given a serializer, add the class to the json that comes back\n      if opts[:serializer].present?\n        json[obj.class.name.underscore] = opts[:serializer].new(obj, scope: guardian).serializable_hash\n      end\n\n      render json: MultiJson.dump(json)\n    else\n      error_obj = nil\n      if opts[:additional_errors]\n        error_target = opts[:additional_errors].find do |o|\n          target = obj.public_send(o)\n          target && target.errors.present?\n        end\n        error_obj = obj.public_send(error_target) if error_target\n      end\n      render_json_error(error_obj || obj)\n    end\n  end\n\n  def mini_profiler_enabled?\n    defined?(Rack::MiniProfiler) && (guardian.is_developer? || Rails.env.development?)\n  end\n\n  def authorize_mini_profiler\n    return unless mini_profiler_enabled?\n    Rack::MiniProfiler.authorize_request\n  end\n\n  def check_xhr\n    # bypass xhr check on PUT / POST / DELETE provided api key is there, otherwise calling api is annoying\n    return if !request.get? && (is_api? || is_user_api?)\n    raise ApplicationController::RenderEmpty.new unless ((request.format && request.format.json?) || request.xhr?)\n  end\n\n  def apply_cdn_headers\n    Discourse.apply_cdn_headers(response.headers) if Discourse.is_cdn_request?(request.env, request.method)\n  end\n\n  def self.requires_login(arg = {})\n    @requires_login_arg = arg\n  end\n\n  def self.requires_login_arg\n    @requires_login_arg\n  end\n\n  def block_if_requires_login\n    if arg = self.class.requires_login_arg\n      check =\n        if except = arg[:except]\n          !except.include?(action_name.to_sym)\n        elsif only = arg[:only]\n          only.include?(action_name.to_sym)\n        else\n          true\n        end\n      ensure_logged_in if check\n    end\n  end\n\n  def ensure_logged_in\n    raise Discourse::NotLoggedIn.new unless current_user.present?\n  end\n\n  def ensure_staff\n    raise Discourse::InvalidAccess.new unless current_user && current_user.staff?\n  end\n\n  def ensure_admin\n    raise Discourse::InvalidAccess.new unless current_user && current_user.admin?\n  end\n\n  def ensure_wizard_enabled\n    raise Discourse::InvalidAccess.new unless SiteSetting.wizard_enabled?\n  end\n\n  def destination_url\n    request.original_url unless request.original_url =~ /uploads/\n  end\n\n  def redirect_to_login\n    dont_cache_page\n\n    if SiteSetting.auth_immediately && SiteSetting.enable_discourse_connect?\n      # save original URL in a session so we can redirect after login\n      session[:destination_url] = destination_url\n      redirect_to path('/session/sso')\n    elsif SiteSetting.auth_immediately && !SiteSetting.enable_local_logins && Discourse.enabled_authenticators.length == 1 && !cookies[:authentication_data]\n      # Only one authentication provider, direct straight to it.\n      # If authentication_data is present, then we are halfway though registration. Don't redirect offsite\n      cookies[:destination_url] = destination_url\n      redirect_to path(\"/auth/#{Discourse.enabled_authenticators.first.name}\")\n    else\n      # save original URL in a cookie (javascript redirects after login in this case)\n      cookies[:destination_url] = destination_url\n      redirect_to path(\"/login\")\n    end\n  end\n\n  def redirect_to_login_if_required\n    return if request.format.json? && is_api?\n\n    # Used by clients authenticated via user API.\n    # Redirects to provided URL scheme if\n    # - request uses a valid public key and auth_redirect scheme\n    # - one_time_password scope is allowed\n    if !current_user &&\n      params.has_key?(:user_api_public_key) &&\n      params.has_key?(:auth_redirect)\n      begin\n        OpenSSL::PKey::RSA.new(params[:user_api_public_key])\n      rescue OpenSSL::PKey::RSAError\n        return render plain: I18n.t(\"user_api_key.invalid_public_key\")\n      end\n\n      if UserApiKey.invalid_auth_redirect?(params[:auth_redirect])\n        return render plain: I18n.t(\"user_api_key.invalid_auth_redirect\")\n      end\n\n      if UserApiKey.allowed_scopes.superset?(Set.new([\"one_time_password\"]))\n        redirect_to(\"#{params[:auth_redirect]}?otp=true\", allow_other_host: true)\n        return\n      end\n    end\n\n    if !current_user && SiteSetting.login_required?\n      flash.keep\n      if (request.format && request.format.json?) || request.xhr? || !request.get?\n        ensure_logged_in\n      else\n        redirect_to_login\n      end\n      return\n    end\n\n    return if !current_user\n    return if !should_enforce_2fa?\n\n    redirect_path = path(\"/u/#{current_user.encoded_username}/preferences/second-factor\")\n    if !request.fullpath.start_with?(redirect_path)\n      redirect_to path(redirect_path)\n      nil\n    end\n  end\n\n  def should_enforce_2fa?\n    disqualified_from_2fa_enforcement = request.format.json? || is_api? || current_user.anonymous?\n    enforcing_2fa = ((SiteSetting.enforce_second_factor == 'staff' && current_user.staff?) || SiteSetting.enforce_second_factor == 'all')\n    !disqualified_from_2fa_enforcement && enforcing_2fa && !current_user.has_any_second_factor_methods_enabled?\n  end\n\n  def build_not_found_page(opts = {})\n    if SiteSetting.bootstrap_error_pages?\n      preload_json\n      opts[:layout] = 'application' if opts[:layout] == 'no_ember'\n    end\n\n    @current_user = current_user rescue nil\n\n    if !SiteSetting.login_required? || @current_user\n      key = \"page_not_found_topics:#{I18n.locale}\"\n      @topics_partial = Discourse.cache.fetch(key, expires_in: 10.minutes) do\n        category_topic_ids = Category.pluck(:topic_id).compact\n        @top_viewed = TopicQuery.new(nil, except_topic_ids: category_topic_ids).list_top_for(\"monthly\").topics.first(10)\n        @recent = Topic.includes(:category).where.not(id: category_topic_ids).recent(10)\n        render_to_string partial: '/exceptions/not_found_topics', formats: [:html]\n      end.html_safe\n    end\n\n    @container_class = \"wrap not-found-container\"\n    @page_title = I18n.t(\"page_not_found.page_title\")\n    @title = opts[:title] || I18n.t(\"page_not_found.title\")\n    @group = opts[:group]\n    @hide_search = true if SiteSetting.login_required\n\n    params[:slug] = params[:slug].first if params[:slug].kind_of?(Array)\n    params[:id] = params[:id].first if params[:id].kind_of?(Array)\n    @slug = (params[:slug].presence || params[:id].presence || \"\").to_s.tr('-', ' ')\n\n    render_to_string status: opts[:status], layout: opts[:layout], formats: [:html], template: '/exceptions/not_found'\n  end\n\n  def is_asset_path\n    request.env['DISCOURSE_IS_ASSET_PATH'] = 1\n  end\n\n  def is_feed_request?\n    request.format.atom? || request.format.rss?\n  end\n\n  def add_noindex_header\n    if request.get? && !response.headers['X-Robots-Tag']\n      if SiteSetting.allow_index_in_robots_txt\n        response.headers['X-Robots-Tag'] = 'noindex'\n      else\n        response.headers['X-Robots-Tag'] = 'noindex, nofollow'\n      end\n    end\n  end\n\n  def add_noindex_header_to_non_canonical\n    canonical = (@canonical_url || @default_canonical)\n    if canonical.present? && canonical != request.url && !SiteSetting.allow_indexing_non_canonical_urls\n      response.headers['X-Robots-Tag'] ||= 'noindex'\n    end\n  end\n\n  protected\n\n  def honeypot_value\n    secure_session[HONEYPOT_KEY] ||= SecureRandom.hex\n  end\n\n  def challenge_value\n    secure_session[CHALLENGE_KEY] ||= SecureRandom.hex\n  end\n\n  def render_post_json(post, add_raw: true)\n    post_serializer = PostSerializer.new(post, scope: guardian, root: false)\n    post_serializer.add_raw = add_raw\n\n    counts = PostAction.counts_for([post], current_user)\n    if counts && counts = counts[post.id]\n      post_serializer.post_actions = counts\n    end\n    render_json_dump(post_serializer)\n  end\n\n  # returns an array of integers given a param key\n  # returns nil if key is not found\n  def param_to_integer_list(key, delimiter = ',')\n    case params[key]\n    when String\n      params[key].split(delimiter).map(&:to_i)\n    when Array\n      params[key].map(&:to_i)\n    end\n  end\n\n  def activated_themes_json\n    id = @theme_id\n    return \"{}\" if id.blank?\n    ids = Theme.transform_ids(id)\n    Theme.where(id: ids).pluck(:id, :name).to_h.to_json\n  end\n\n  def rate_limit_crawlers\n    return if current_user.present?\n    return if SiteSetting.slow_down_crawler_user_agents.blank?\n\n    user_agent = request.user_agent&.downcase\n    return if user_agent.blank?\n\n    SiteSetting.slow_down_crawler_user_agents.downcase.split(\"|\").each do |crawler|\n      if user_agent.include?(crawler)\n        key = \"#{crawler}_crawler_rate_limit\"\n        limiter = RateLimiter.new(\n          nil,\n          key,\n          1,\n          SiteSetting.slow_down_crawler_rate,\n          error_code: key\n        )\n        limiter.performed!\n        break\n      end\n    end\n  end\n\n  def run_second_factor!(action_class, action_data = nil)\n    action = action_class.new(guardian, request, action_data)\n    manager = SecondFactor::AuthManager.new(guardian, action)\n    yield(manager) if block_given?\n    result = manager.run!(request, params, secure_session)\n\n    if !result.no_second_factors_enabled? &&\n      !result.second_factor_auth_completed? &&\n      !result.second_factor_auth_skipped?\n      # should never happen, but I want to know if somehow it does! (osama)\n      raise \"2fa process ended up in a bad state!\"\n    end\n\n    result\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe ApplicationController do\n  describe '#redirect_to_login_if_required' do\n    let(:admin) { Fabricate(:admin) }\n\n    before do\n      admin  # to skip welcome wizard at home page `/`\n      SiteSetting.login_required = true\n    end\n\n    it \"should never cache a login redirect\" do\n      get \"/\"\n      expect(response.headers[\"Cache-Control\"]).to eq(\"no-cache, no-store\")\n    end\n\n    it \"should redirect to login normally\" do\n      get \"/\"\n      expect(response).to redirect_to(\"/login\")\n    end\n\n    it \"should redirect to SSO if enabled\" do\n      SiteSetting.discourse_connect_url = 'http://someurl.com'\n      SiteSetting.enable_discourse_connect = true\n      get \"/\"\n      expect(response).to redirect_to(\"/session/sso\")\n    end\n\n    it \"should redirect to authenticator if only one, and local logins disabled\" do\n      # Local logins and google enabled, direct to login UI\n      SiteSetting.enable_google_oauth2_logins = true\n      get \"/\"\n      expect(response).to redirect_to(\"/login\")\n\n      # Only google enabled, login immediately\n      SiteSetting.enable_local_logins = false\n      get \"/\"\n      expect(response).to redirect_to(\"/auth/google_oauth2\")\n\n      # Google and GitHub enabled, direct to login UI\n      SiteSetting.enable_github_logins = true\n      get \"/\"\n      expect(response).to redirect_to(\"/login\")\n    end\n\n    it \"should not redirect to SSO when auth_immediately is disabled\" do\n      SiteSetting.auth_immediately = false\n      SiteSetting.discourse_connect_url = 'http://someurl.com'\n      SiteSetting.enable_discourse_connect = true\n\n      get \"/\"\n      expect(response).to redirect_to(\"/login\")\n    end\n\n    it \"should not redirect to authenticator when auth_immediately is disabled\" do\n      SiteSetting.auth_immediately = false\n      SiteSetting.enable_google_oauth2_logins = true\n      SiteSetting.enable_local_logins = false\n\n      get \"/\"\n      expect(response).to redirect_to(\"/login\")\n    end\n\n    context \"with omniauth in test mode\" do\n      before do\n        OmniAuth.config.test_mode = true\n        OmniAuth.config.add_mock(:google_oauth2,\n          info: OmniAuth::AuthHash::InfoHash.new(\n            email: \"address@example.com\",\n          ),\n          extra: {\n            raw_info: OmniAuth::AuthHash.new(\n              email_verified: true,\n              email: \"address@example.com\",\n            )\n          }\n        )\n        Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:google_oauth2]\n      end\n\n      after do\n        Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:google_oauth2] = nil\n        OmniAuth.config.test_mode = false\n      end\n\n      it \"should not redirect to authenticator if registration in progress\" do\n        SiteSetting.enable_local_logins = false\n        SiteSetting.enable_google_oauth2_logins = true\n\n        get \"/\"\n        expect(response).to redirect_to(\"/auth/google_oauth2\")\n\n        expect(cookies[:authentication_data]).to eq(nil)\n\n        get \"/auth/google_oauth2/callback.json\"\n        expect(response).to redirect_to(\"/\")\n        expect(cookies[:authentication_data]).not_to eq(nil)\n\n        get \"/\"\n        expect(response).to redirect_to(\"/login\")\n      end\n    end\n\n    it 'contains authentication data when cookies exist' do\n      cookie_data = \"someauthenticationdata\"\n      cookies['authentication_data'] = cookie_data\n      get '/login'\n      expect(response.status).to eq(200)\n      expect(response.body).to include(\"data-authentication-data=\\\"#{cookie_data}\\\"\")\n      expect(response.headers[\"Set-Cookie\"]).to include(\"authentication_data=;\") # Delete cookie\n    end\n\n    it 'deletes authentication data cookie even if already authenticated' do\n      sign_in(Fabricate(:user))\n      cookies['authentication_data'] = \"someauthenticationdata\"\n      get '/'\n      expect(response.status).to eq(200)\n      expect(response.body).not_to include(\"data-authentication-data=\")\n      expect(response.headers[\"Set-Cookie\"]).to include(\"authentication_data=;\") # Delete cookie\n    end\n\n    it \"returns a 403 for json requests\" do\n      get '/latest'\n      expect(response.status).to eq(302)\n\n      get '/latest.json'\n      expect(response.status).to eq(403)\n    end\n  end\n\n  describe '#redirect_to_second_factor_if_required' do\n    let(:admin) { Fabricate(:admin) }\n    fab!(:user) { Fabricate(:user) }\n\n    before do\n      admin # to skip welcome wizard at home page `/`\n    end\n\n    it \"should redirect admins when enforce_second_factor is 'all'\" do\n      SiteSetting.enforce_second_factor = \"all\"\n      sign_in(admin)\n\n      get \"/\"\n      expect(response).to redirect_to(\"/u/#{admin.username}/preferences/second-factor\")\n    end\n\n    it \"should redirect users when enforce_second_factor is 'all'\" do\n      SiteSetting.enforce_second_factor = \"all\"\n      sign_in(user)\n\n      get \"/\"\n      expect(response).to redirect_to(\"/u/#{user.username}/preferences/second-factor\")\n    end\n\n    it \"should not redirect anonymous users when enforce_second_factor is 'all'\" do\n      SiteSetting.enforce_second_factor = \"all\"\n      SiteSetting.allow_anonymous_posting = true\n      sign_in(user)\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n\n      get \"/\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"should redirect admins when enforce_second_factor is 'staff'\" do\n      SiteSetting.enforce_second_factor = \"staff\"\n      sign_in(admin)\n\n      get \"/\"\n      expect(response).to redirect_to(\"/u/#{admin.username}/preferences/second-factor\")\n    end\n\n    it \"should not redirect users when enforce_second_factor is 'staff'\" do\n      SiteSetting.enforce_second_factor = \"staff\"\n      sign_in(user)\n\n      get \"/\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"should not redirect admins when turned off\" do\n      SiteSetting.enforce_second_factor = \"no\"\n      sign_in(admin)\n\n      get \"/\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"should not redirect users when turned off\" do\n      SiteSetting.enforce_second_factor = \"no\"\n      sign_in(user)\n\n      get \"/\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"correctly redirects for Unicode usernames\" do\n      SiteSetting.enforce_second_factor = \"all\"\n      SiteSetting.unicode_usernames = true\n      user = sign_in(Fabricate(:unicode_user))\n\n      get \"/\"\n      expect(response).to redirect_to(\"/u/#{user.encoded_username}/preferences/second-factor\")\n    end\n\n    context \"when enforcing second factor for staff\" do\n      before do\n        SiteSetting.enforce_second_factor = \"staff\"\n        sign_in(admin)\n      end\n\n      context \"when the staff member has not enabled TOTP or security keys\" do\n        it \"redirects the staff to the second factor preferences\" do\n          get \"/\"\n          expect(response).to redirect_to(\"/u/#{admin.username}/preferences/second-factor\")\n        end\n      end\n\n      context \"when the staff member has enabled TOTP\" do\n        before do\n          Fabricate(:user_second_factor_totp, user: admin)\n        end\n\n        it \"does not redirects the staff to set up 2FA\" do\n          get \"/\"\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context \"when the staff member has enabled security keys\" do\n        before do\n          Fabricate(:user_security_key_with_random_credential, user: admin)\n        end\n\n        it \"does not redirects the staff to set up 2FA\" do\n          get \"/\"\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n  end\n\n  describe 'invalid request params' do\n    before do\n      @old_logger = Rails.logger\n      @logs = StringIO.new\n      Rails.logger = Logger.new(@logs)\n    end\n\n    after do\n      Rails.logger = @old_logger\n    end\n\n    it 'should not raise a 500 (nor should it log a warning) for bad params' do\n      bad_str = (+\"d\\xDE\").force_encoding('utf-8')\n      expect(bad_str.valid_encoding?).to eq(false)\n\n      get \"/latest.json\", params: { test: bad_str }\n\n      expect(response.status).to eq(400)\n\n      log = @logs.string\n\n      if (log.include? 'exception app middleware')\n        # heisentest diagnostics\n        puts\n        puts \"EXTRA DIAGNOSTICS FOR INTERMITTENT TEST FAIL\"\n        puts log\n        puts \">> action_dispatch.exception\"\n        ex = request.env['action_dispatch.exception']\n        puts \">> exception class: #{ex.class} : #{ex}\"\n      end\n\n      expect(log).not_to include('exception app middleware')\n\n      expect(response.parsed_body).to eq(\n        \"status\" => 400,\n        \"error\" => \"Bad Request\"\n      )\n\n    end\n  end\n\n  describe 'missing required param' do\n    it 'should return a 400' do\n      get \"/search/query.json\", params: { trem: \"misspelled term\" }\n\n      expect(response.status).to eq(400)\n      expect(response.parsed_body[\"errors\"].first).to include(\"param is missing or the value is empty: term\")\n    end\n  end\n\n  describe 'build_not_found_page' do\n    describe 'topic not found' do\n\n      it 'should not redirect to permalink if topic/category does not exist' do\n        topic = create_post.topic\n        Permalink.create!(url: topic.relative_url, topic_id: topic.id + 1)\n        topic.trash!\n\n        SiteSetting.detailed_404 = false\n        get topic.relative_url\n        expect(response.status).to eq(404)\n\n        SiteSetting.detailed_404 = true\n        get topic.relative_url\n        expect(response.status).to eq(410)\n      end\n\n      it 'should return permalink for deleted topics' do\n        topic = create_post.topic\n        external_url = 'https://somewhere.over.rainbow'\n        Permalink.create!(url: topic.relative_url, external_url: external_url)\n        topic.trash!\n\n        get topic.relative_url\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(external_url)\n\n        get \"/t/#{topic.id}.json\"\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(external_url)\n\n        get \"/t/#{topic.id}.json\", xhr: true\n        expect(response.status).to eq(200)\n        expect(response.body).to eq(external_url)\n      end\n\n      it 'supports subfolder with permalinks' do\n        set_subfolder \"/forum\"\n\n        trashed_topic = create_post.topic\n        trashed_topic.trash!\n        new_topic = create_post.topic\n        permalink = Permalink.create!(url: trashed_topic.relative_url, topic_id: new_topic.id)\n\n        # no subfolder because router doesn't know about subfolder in this test\n        get \"/t/#{trashed_topic.slug}/#{trashed_topic.id}\"\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(\"/forum/t/#{new_topic.slug}/#{new_topic.id}\")\n\n        permalink.destroy\n        category = Fabricate(:category)\n        permalink = Permalink.create!(url: trashed_topic.relative_url, category_id: category.id)\n        get \"/t/#{trashed_topic.slug}/#{trashed_topic.id}\"\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(\"/forum/c/#{category.slug}/#{category.id}\")\n\n        permalink.destroy\n        permalink = Permalink.create!(url: trashed_topic.relative_url, post_id: new_topic.posts.last.id)\n        get \"/t/#{trashed_topic.slug}/#{trashed_topic.id}\"\n        expect(response.status).to eq(301)\n        expect(response).to redirect_to(\"/forum/t/#{new_topic.slug}/#{new_topic.id}/#{new_topic.posts.last.post_number}\")\n      end\n\n      it 'should return 404 and show Google search for an invalid topic route' do\n        get \"/t/nope-nope/99999999\"\n\n        expect(response.status).to eq(404)\n\n        response_body = response.body\n\n        expect(response_body).to include(I18n.t('page_not_found.search_button'))\n        expect(response_body).to have_tag(\"input\", with: { value: 'nope nope' })\n      end\n\n      it 'should not include Google search if login_required is enabled' do\n        SiteSetting.login_required = true\n        sign_in(Fabricate(:user))\n        get \"/t/nope-nope/99999999\"\n        expect(response.status).to eq(404)\n        expect(response.body).to_not include('google.com/search')\n      end\n\n      describe 'no logspam' do\n        before do\n          @orig_logger = Rails.logger\n          Rails.logger = @fake_logger = FakeLogger.new\n        end\n\n        after do\n          Rails.logger = @orig_logger\n        end\n\n        it 'should handle 404 to a css file' do\n          Discourse.cache.delete(\"page_not_found_topics:#{I18n.locale}\")\n\n          topic1 = Fabricate(:topic)\n          get '/stylesheets/mobile_1_4cd559272273fe6d3c7db620c617d596a5fdf240.css', headers: { 'HTTP_ACCEPT' => 'text/css,*/*,q=0.1' }\n          expect(response.status).to eq(404)\n          expect(response.body).to include(topic1.title)\n\n          topic2 = Fabricate(:topic)\n          get '/stylesheets/mobile_1_4cd559272273fe6d3c7db620c617d596a5fdf240.css', headers: { 'HTTP_ACCEPT' => 'text/css,*/*,q=0.1' }\n          expect(response.status).to eq(404)\n          expect(response.body).to include(topic1.title)\n          expect(response.body).to_not include(topic2.title)\n\n          expect(@fake_logger.fatals.length).to eq(0)\n          expect(@fake_logger.errors.length).to eq(0)\n          expect(@fake_logger.warnings.length).to eq(0)\n        end\n      end\n\n      it 'should cache results' do\n        Discourse.cache.delete(\"page_not_found_topics:#{I18n.locale}\")\n        Discourse.cache.delete(\"page_not_found_topics:fr\")\n\n        topic1 = Fabricate(:topic)\n        get '/t/nope-nope/99999999'\n        expect(response.status).to eq(404)\n        expect(response.body).to include(topic1.title)\n\n        topic2 = Fabricate(:topic)\n        get '/t/nope-nope/99999999'\n        expect(response.status).to eq(404)\n        expect(response.body).to include(topic1.title)\n        expect(response.body).to_not include(topic2.title)\n\n        # Different locale should have different cache\n        SiteSetting.default_locale = :fr\n        get '/t/nope-nope/99999999'\n        expect(response.status).to eq(404)\n        expect(response.body).to include(topic1.title)\n        expect(response.body).to include(topic2.title)\n      end\n    end\n  end\n\n  describe \"#handle_theme\" do\n    let!(:theme) { Fabricate(:theme, user_selectable: true) }\n    let!(:theme2) { Fabricate(:theme, user_selectable: true) }\n    let!(:non_selectable_theme) { Fabricate(:theme, user_selectable: false) }\n    fab!(:user) { Fabricate(:user) }\n    fab!(:admin) { Fabricate(:admin) }\n\n    before do\n      sign_in(user)\n    end\n\n    it \"selects the theme the user has selected\" do\n      user.user_option.update_columns(theme_ids: [theme.id])\n\n      get \"/\"\n      expect(response.status).to eq(200)\n      expect(controller.theme_id).to eq(theme.id)\n\n      theme.update_attribute(:user_selectable, false)\n\n      get \"/\"\n      expect(response.status).to eq(200)\n      expect(controller.theme_id).to eq(SiteSetting.default_theme_id)\n    end\n\n    it \"can be overridden with a cookie\" do\n      user.user_option.update_columns(theme_ids: [theme.id])\n\n      cookies['theme_ids'] = \"#{theme2.id}|#{user.user_option.theme_key_seq}\"\n\n      get \"/\"\n      expect(response.status).to eq(200)\n      expect(controller.theme_id).to eq(theme2.id)\n    end\n\n    it \"falls back to the default theme when the user has no cookies or preferences\" do\n      user.user_option.update_columns(theme_ids: [])\n      cookies[\"theme_ids\"] = nil\n      theme2.set_default!\n\n      get \"/\"\n      expect(response.status).to eq(200)\n      expect(controller.theme_id).to eq(theme2.id)\n    end\n\n    it \"can be overridden with preview_theme_id param\" do\n      sign_in(admin)\n      cookies['theme_ids'] = \"#{theme.id}|#{admin.user_option.theme_key_seq}\"\n\n      get \"/\", params: { preview_theme_id: theme2.id }\n      expect(response.status).to eq(200)\n      expect(controller.theme_id).to eq(theme2.id)\n\n      get \"/\", params: { preview_theme_id: non_selectable_theme.id }\n      expect(controller.theme_id).to eq(non_selectable_theme.id)\n    end\n\n    it \"does not allow non privileged user to preview themes\" do\n      sign_in(user)\n      get \"/\", params: { preview_theme_id: non_selectable_theme.id }\n      expect(controller.theme_id).to eq(SiteSetting.default_theme_id)\n    end\n\n    it \"cookie can fail back to user if out of sync\" do\n      user.user_option.update_columns(theme_ids: [theme.id])\n      cookies['theme_ids'] = \"#{theme2.id}|#{user.user_option.theme_key_seq - 1}\"\n\n      get \"/\"\n      expect(response.status).to eq(200)\n      expect(controller.theme_id).to eq(theme.id)\n    end\n  end\n\n  describe 'Custom hostname' do\n\n    it 'does not allow arbitrary host injection' do\n      get(\"/latest\",\n        headers: {\n          \"X-Forwarded-Host\" => \"test123.com\"\n        }\n      )\n\n      expect(response.body).not_to include(\"test123\")\n    end\n  end\n\n  describe 'allow_embedding_site_in_an_iframe' do\n\n    it \"should have the 'X-Frame-Options' header with value 'sameorigin'\" do\n      get(\"/latest\")\n      expect(response.headers['X-Frame-Options']).to eq(\"SAMEORIGIN\")\n    end\n\n    it \"should not include the 'X-Frame-Options' header\" do\n      SiteSetting.allow_embedding_site_in_an_iframe = true\n      get(\"/latest\")\n      expect(response.headers).not_to include('X-Frame-Options')\n    end\n  end\n\n  describe 'Delegated auth' do\n    let :public_key do\n      <<~TXT\n      -----BEGIN PUBLIC KEY-----\n      MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDh7BS7Ey8hfbNhlNAW/47pqT7w\n      IhBz3UyBYzin8JurEQ2pY9jWWlY8CH147KyIZf1fpcsi7ZNxGHeDhVsbtUKZxnFV\n      p16Op3CHLJnnJKKBMNdXMy0yDfCAHZtqxeBOTcCo1Vt/bHpIgiK5kmaekyXIaD0n\n      w0z/BYpOgZ8QwnI5ZwIDAQAB\n      -----END PUBLIC KEY-----\n      TXT\n    end\n\n    let :args do\n      {\n        auth_redirect: 'http://no-good.com',\n        user_api_public_key: \"not-a-valid-public-key\"\n      }\n    end\n\n    it 'disallows invalid public_key param' do\n      args[:auth_redirect] = \"discourse://auth_redirect\"\n      get \"/latest\", params: args\n\n      expect(response.body).to eq(I18n.t(\"user_api_key.invalid_public_key\"))\n    end\n\n    it 'does not allow invalid auth_redirect' do\n      args[:user_api_public_key] = public_key\n      get \"/latest\", params: args\n\n      expect(response.body).to eq(I18n.t(\"user_api_key.invalid_auth_redirect\"))\n    end\n\n    it 'does not redirect if one_time_password scope is disallowed' do\n      SiteSetting.allow_user_api_key_scopes = \"read|write\"\n      args[:user_api_public_key] = public_key\n      args[:auth_redirect] = \"discourse://auth_redirect\"\n\n      get \"/latest\", params: args\n\n      expect(response.status).to_not eq(302)\n      expect(response).to_not redirect_to(\"#{args[:auth_redirect]}?otp=true\")\n    end\n\n    it 'redirects correctly with valid params' do\n      SiteSetting.login_required = true\n      args[:user_api_public_key] = public_key\n      args[:auth_redirect] = \"discourse://auth_redirect\"\n\n      get \"/categories\", params: args\n\n      expect(response.status).to eq(302)\n      expect(response).to redirect_to(\"#{args[:auth_redirect]}?otp=true\")\n    end\n  end\n\n  describe 'Content Security Policy' do\n    it 'is enabled by SiteSettings' do\n      SiteSetting.content_security_policy = false\n      SiteSetting.content_security_policy_report_only = false\n\n      get '/'\n\n      expect(response.headers).to_not include('Content-Security-Policy')\n      expect(response.headers).to_not include('Content-Security-Policy-Report-Only')\n\n      SiteSetting.content_security_policy = true\n      SiteSetting.content_security_policy_report_only = true\n\n      get '/'\n\n      expect(response.headers).to include('Content-Security-Policy')\n      expect(response.headers).to include('Content-Security-Policy-Report-Only')\n    end\n\n    it 'can be customized with SiteSetting' do\n      SiteSetting.content_security_policy = true\n\n      get '/'\n      script_src = parse(response.headers['Content-Security-Policy'])['script-src']\n\n      expect(script_src).to_not include('example.com')\n\n      SiteSetting.content_security_policy_script_src = 'example.com'\n\n      get '/'\n      script_src = parse(response.headers['Content-Security-Policy'])['script-src']\n\n      expect(script_src).to include('example.com')\n    end\n\n    it 'does not set CSP when responding to non-HTML' do\n      SiteSetting.content_security_policy = true\n      SiteSetting.content_security_policy_report_only = true\n\n      get '/latest.json'\n\n      expect(response.headers).to_not include('Content-Security-Policy')\n      expect(response.headers).to_not include('Content-Security-Policy-Report-Only')\n    end\n\n    it 'when GTM is enabled it adds the same nonce to the policy and the GTM tag' do\n      SiteSetting.content_security_policy = true\n      SiteSetting.gtm_container_id = 'GTM-ABCDEF'\n\n      get '/latest'\n      nonce = ApplicationHelper.google_tag_manager_nonce\n      expect(response.headers).to include('Content-Security-Policy')\n\n      script_src = parse(response.headers['Content-Security-Policy'])['script-src']\n      expect(script_src.to_s).to include(nonce)\n      expect(response.body).to include(nonce)\n    end\n\n    def parse(csp_string)\n      csp_string.split(';').map do |policy|\n        directive, *sources = policy.split\n        [directive, sources]\n      end.to_h\n    end\n  end\n\n  it 'can respond to a request with */* accept header' do\n    get '/', headers: { HTTP_ACCEPT: '*/*' }\n    expect(response.status).to eq(200)\n    expect(response.body).to include('Discourse')\n  end\n\n  it 'has canonical tag' do\n    get '/', headers: { HTTP_ACCEPT: '*/*' }\n    expect(response.body).to have_tag(\"link\", with: { rel: \"canonical\", href: \"http://test.localhost/\" })\n    get '/?query_param=true', headers: { HTTP_ACCEPT: '*/*' }\n    expect(response.body).to have_tag(\"link\", with: { rel: \"canonical\", href: \"http://test.localhost/\" })\n    get '/latest?page=2&additional_param=true', headers: { HTTP_ACCEPT: '*/*' }\n    expect(response.body).to have_tag(\"link\", with: { rel: \"canonical\", href: \"http://test.localhost/latest?page=2\" })\n    get '/404', headers: { HTTP_ACCEPT: '*/*' }\n    expect(response.body).to have_tag(\"link\", with: { rel: \"canonical\", href: \"http://test.localhost/404\" })\n    topic = create_post.topic\n    get \"/t/#{topic.slug}/#{topic.id}\"\n    expect(response.body).to have_tag(\"link\", with: { rel: \"canonical\", href: \"http://test.localhost/t/#{topic.slug}/#{topic.id}\" })\n  end\n\n  it \"adds a noindex header if non-canonical indexing is disabled\" do\n    SiteSetting.allow_indexing_non_canonical_urls = false\n    get '/'\n    expect(response.headers['X-Robots-Tag']).to be_nil\n\n    get '/latest'\n    expect(response.headers['X-Robots-Tag']).to be_nil\n\n    get '/categories'\n    expect(response.headers['X-Robots-Tag']).to be_nil\n\n    topic = create_post.topic\n    get \"/t/#{topic.slug}/#{topic.id}\"\n    expect(response.headers['X-Robots-Tag']).to be_nil\n    post = create_post(topic_id: topic.id)\n    get \"/t/#{topic.slug}/#{topic.id}/2\"\n    expect(response.headers['X-Robots-Tag']).to eq('noindex')\n\n    20.times do\n      create_post(topic_id: topic.id)\n    end\n    get \"/t/#{topic.slug}/#{topic.id}/21\"\n    expect(response.headers['X-Robots-Tag']).to eq('noindex')\n    get \"/t/#{topic.slug}/#{topic.id}?page=2\"\n    expect(response.headers['X-Robots-Tag']).to be_nil\n  end\n\n  context \"default locale\" do\n    before do\n      SiteSetting.default_locale = :fr\n      sign_in(Fabricate(:user))\n    end\n\n    after do\n      I18n.reload!\n    end\n\n    context \"with rate limits\" do\n      before do\n        RateLimiter.clear_all!\n        RateLimiter.enable\n      end\n\n      it \"serves a LimitExceeded error in the preferred locale\" do\n        SiteSetting.max_likes_per_day = 1\n        post1 = Fabricate(:post)\n        post2 = Fabricate(:post)\n        override = TranslationOverride.create(\n          locale: \"fr\",\n          translation_key: \"rate_limiter.by_type.create_like\",\n          value: \"French LimitExceeded error message\"\n        )\n        I18n.reload!\n\n        post \"/post_actions.json\", params: {\n          id: post1.id, post_action_type_id: PostActionType.types[:like]\n        }\n        expect(response.status).to eq(200)\n\n        post \"/post_actions.json\", params: {\n          id: post2.id, post_action_type_id: PostActionType.types[:like]\n        }\n        expect(response.status).to eq(429)\n        expect(response.parsed_body[\"errors\"].first).to eq(override.value)\n      end\n    end\n\n    it \"serves an InvalidParameters error with the default locale\" do\n      override = TranslationOverride.create(\n        locale: \"fr\",\n        translation_key: \"invalid_params\",\n        value: \"French InvalidParameters error message\"\n      )\n      I18n.reload!\n\n      get \"/search.json\", params: { q: \"hello\\0hello\" }\n      expect(response.status).to eq(400)\n      expect(response.parsed_body[\"errors\"].first).to eq(override.value)\n    end\n  end\n\n  describe \"set_locale\" do\n    # Using /bootstrap.json because it returns a locale-dependent value\n    def headers(locale)\n      { HTTP_ACCEPT_LANGUAGE: locale }\n    end\n\n    context \"allow_user_locale disabled\" do\n      context \"accept-language header differs from default locale\" do\n        before do\n          SiteSetting.allow_user_locale = false\n          SiteSetting.default_locale = \"en\"\n        end\n\n        context \"with an anonymous user\" do\n          it \"uses the default locale\" do\n            get \"/bootstrap.json\", headers: headers(\"fr\")\n            expect(response.status).to eq(200)\n            expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"en.js\")\n          end\n        end\n\n        context \"with a logged in user\" do\n          it \"it uses the default locale\" do\n            user = Fabricate(:user, locale: :fr)\n            sign_in(user)\n\n            get \"/bootstrap.json\", headers: headers(\"fr\")\n            expect(response.status).to eq(200)\n            expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"en.js\")\n          end\n        end\n      end\n    end\n\n    context \"set_locale_from_accept_language_header enabled\" do\n      context \"accept-language header differs from default locale\" do\n        before do\n          SiteSetting.allow_user_locale = true\n          SiteSetting.set_locale_from_accept_language_header = true\n          SiteSetting.default_locale = \"en\"\n        end\n\n        context \"with an anonymous user\" do\n          it \"uses the locale from the headers\" do\n            get \"/bootstrap.json\", headers: headers(\"fr\")\n            expect(response.status).to eq(200)\n            expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"fr.js\")\n          end\n\n          it \"doesn't leak after requests\" do\n            get \"/bootstrap.json\", headers: headers(\"fr\")\n            expect(response.status).to eq(200)\n            expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"fr.js\")\n            expect(I18n.locale.to_s).to eq(SiteSettings::DefaultsProvider::DEFAULT_LOCALE)\n          end\n        end\n\n        context \"with a logged in user\" do\n          let(:user) { Fabricate(:user, locale: :fr) }\n\n          before do\n            sign_in(user)\n          end\n\n          it \"uses the user's preferred locale\" do\n            get \"/bootstrap.json\", headers: headers(\"fr\")\n            expect(response.status).to eq(200)\n            expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"fr.js\")\n          end\n\n          it \"serves a 404 page in the preferred locale\" do\n            get \"/missingroute\", headers: headers(\"fr\")\n            expect(response.status).to eq(404)\n            expected_title = I18n.t(\"page_not_found.title\", locale: :fr)\n            expect(response.body).to include(CGI.escapeHTML(expected_title))\n          end\n\n          it \"serves a RenderEmpty page in the preferred locale\" do\n            get \"/u/#{user.username}/preferences/interface\"\n            expect(response.status).to eq(200)\n            expect(response.body).to have_tag('script', with: { src: \"/assets/locales/fr.js\" })\n          end\n        end\n      end\n\n      context \"the preferred locale includes a region\" do\n        it \"returns the locale and region separated by an underscore\" do\n          SiteSetting.allow_user_locale = true\n          SiteSetting.set_locale_from_accept_language_header = true\n          SiteSetting.default_locale = \"en\"\n\n          get \"/bootstrap.json\", headers: headers(\"zh-CN\")\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"zh_CN.js\")\n        end\n      end\n\n      context 'accept-language header is not set' do\n        it 'uses the site default locale' do\n          SiteSetting.allow_user_locale = true\n          SiteSetting.default_locale = 'en'\n\n          get \"/bootstrap.json\", headers: headers(\"\")\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['bootstrap']['locale_script']).to end_with(\"en.js\")\n        end\n      end\n    end\n  end\n\n  describe 'vary header' do\n    it 'includes Vary:Accept on all requests where format is not explicit' do\n      # Rails default behaviour - include Vary:Accept when Accept is supplied\n      get \"/latest\", headers: { \"Accept\" => \"application/json\" }\n      expect(response.status).to eq(200)\n      expect(response.headers[\"Vary\"]).to eq(\"Accept\")\n\n      # Discourse additional behaviour (see lib/vary_header.rb)\n      # Include Vary:Accept even when Accept is not supplied\n      get \"/latest\"\n      expect(response.status).to eq(200)\n      expect(response.headers[\"Vary\"]).to eq(\"Accept\")\n\n      # Not needed, because the path 'format' parameter overrides the Accept header\n      get \"/latest.json\"\n      expect(response.status).to eq(200)\n      expect(response.headers[\"Vary\"]).to eq(nil)\n    end\n  end\n\n  describe \"Discourse-Rate-Limit-Error-Code header\" do\n    fab!(:admin) { Fabricate(:admin) }\n\n    before do\n      RateLimiter.clear_all!\n      RateLimiter.enable\n    end\n\n    it \"is included when API key is rate limited\" do\n      global_setting :max_admin_api_reqs_per_minute, 1\n      api_key = ApiKey.create!(user_id: admin.id).key\n      get \"/latest.json\", headers: {\n        \"Api-Key\": api_key,\n        \"Api-Username\": admin.username\n      }\n      expect(response.status).to eq(200)\n\n      get \"/latest.json\", headers: {\n        \"Api-Key\": api_key,\n        \"Api-Username\": admin.username\n      }\n      expect(response.status).to eq(429)\n      expect(response.headers[\"Discourse-Rate-Limit-Error-Code\"]).to eq(\"admin_api_key_rate_limit\")\n    end\n\n    it \"is included when user API key is rate limited\" do\n      global_setting :max_user_api_reqs_per_minute, 1\n      user_api_key = UserApiKey.create!(\n        user_id: admin.id,\n        client_id: \"\",\n        application_name: \"discourseapp\"\n      )\n      user_api_key.scopes = UserApiKeyScope.all_scopes.keys.map do |name|\n        UserApiKeyScope.create!(name: name, user_api_key_id: user_api_key.id)\n      end\n      user_api_key.save!\n\n      get \"/session/current.json\", headers: {\n        \"User-Api-Key\": user_api_key.key,\n      }\n      expect(response.status).to eq(200)\n\n      get \"/session/current.json\", headers: {\n        \"User-Api-Key\": user_api_key.key,\n      }\n      expect(response.status).to eq(429)\n      expect(\n        response.headers[\"Discourse-Rate-Limit-Error-Code\"]\n      ).to eq(\"user_api_key_limiter_60_secs\")\n\n      global_setting :max_user_api_reqs_per_minute, 100\n      global_setting :max_user_api_reqs_per_day, 1\n\n      get \"/session/current.json\", headers: {\n        \"User-Api-Key\": user_api_key.key,\n      }\n      expect(response.status).to eq(429)\n      expect(\n        response.headers[\"Discourse-Rate-Limit-Error-Code\"]\n      ).to eq(\"user_api_key_limiter_1_day\")\n    end\n  end\n\n  describe \"crawlers in slow_down_crawler_user_agents site setting\" do\n    before do\n      RateLimiter.enable\n      RateLimiter.clear_all!\n    end\n\n    it \"are rate limited\" do\n      SiteSetting.slow_down_crawler_rate = 128\n      SiteSetting.slow_down_crawler_user_agents = \"badcrawler|problematiccrawler\"\n      now = Time.zone.now\n      freeze_time now\n\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam badcrawler\"\n      }\n      expect(response.status).to eq(200)\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam badcrawler\"\n      }\n      expect(response.status).to eq(429)\n      expect(response.headers[\"Retry-After\"]).to eq(\"128\")\n\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam problematiccrawler\"\n      }\n      expect(response.status).to eq(200)\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam problematiccrawler\"\n      }\n      expect(response.status).to eq(429)\n      expect(response.headers[\"Retry-After\"]).to eq(\"128\")\n\n      freeze_time now + 100.seconds\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam badcrawler\"\n      }\n      expect(response.status).to eq(429)\n      expect(response.headers[\"Retry-After\"]).to eq(\"28\")\n\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam problematiccrawler\"\n      }\n      expect(response.status).to eq(429)\n      expect(response.headers[\"Retry-After\"]).to eq(\"28\")\n\n      freeze_time now + 150.seconds\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam badcrawler\"\n      }\n      expect(response.status).to eq(200)\n\n      get \"/\", headers: {\n        \"HTTP_USER_AGENT\" => \"iam problematiccrawler\"\n      }\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe \"#banner_json\" do\n    let(:admin) { Fabricate(:admin) }\n    let(:user) { Fabricate(:user) }\n    fab!(:banner_topic) { Fabricate(:banner_topic) }\n    fab!(:p1) { Fabricate(:post, topic: banner_topic, raw: \"A banner topic\") }\n\n    before do\n      admin # to skip welcome wizard at home page `/`\n    end\n\n    context \"login_required\" do\n      before do\n        SiteSetting.login_required = true\n      end\n      it \"does not include banner info for anonymous users\" do\n        get \"/login\"\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n          expect(json['banner']).to eq(\"{}\")\n        end\n      end\n\n      it \"includes banner info for logged-in users\" do\n        sign_in(user)\n        get \"/\"\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n          expect(JSON.parse(json['banner'])[\"html\"]).to eq(\"<p>A banner topic</p>\")\n        end\n      end\n    end\n\n    context \"login not required\" do\n      before do\n        SiteSetting.login_required = false\n      end\n      it \"does include banner info for anonymous users\" do\n        get \"/login\"\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n          expect(JSON.parse(json['banner'])[\"html\"]).to eq(\"<p>A banner topic</p>\")\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["app/controllers/application_controller.rb", "spec/requests/application_controller_spec.rb"], "buggy_code_start_loc": [678, 1004], "buggy_code_end_loc": [678, 1004], "fixing_code_start_loc": [679, 1005], "fixing_code_end_loc": [680, 1054], "type": "NVD-CWE-noinfo", "message": "Discourse is an open-source discussion platform. Prior to version 2.8.4 in the `stable` branch and version `2.9.0.beta5` in the `beta` and `tests-passed` branches, banner topic data is exposed on login-required sites. This issue is patched in version 2.8.4 in the `stable` branch and version `2.9.0.beta5` in the `beta` and `tests-passed` branches of Discourse. As a workaround, one may disable banners.", "other": {"cve": {"id": "CVE-2022-31060", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-14T21:15:16.317", "lastModified": "2022-06-27T17:20:14.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open-source discussion platform. Prior to version 2.8.4 in the `stable` branch and version `2.9.0.beta5` in the `beta` and `tests-passed` branches, banner topic data is exposed on login-required sites. This issue is patched in version 2.8.4 in the `stable` branch and version `2.9.0.beta5` in the `beta` and `tests-passed` branches of Discourse. As a workaround, one may disable banners."}, {"lang": "es", "value": "Discourse es una plataforma de discusi\u00f3n de c\u00f3digo abierto. En versiones anteriores a 2.8.4 en la rama \"stable\" y la versi\u00f3n \"2.9.0.beta5\" en las ramas \"beta\" y \"tests-passed\", los datos de los temas de los banners est\u00e1n expuestos en los sitios que requieren inicio de sesi\u00f3n. Este problema ha sido corregido en versi\u00f3n 2.8.4 de la rama \"stable\" y en la versi\u00f3n \"2.9.0.beta5\" de las ramas \"beta\" y \"tests-passed\" de Discourse. Como mitigaci\u00f3n, pueden deshabllitarse los banners"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.4", "matchCriteriaId": "33A8F935-CC56-40AD-ADA9-C13AB1B1371A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "B3803EF9-A296-42B7-887F-93C5E68E94C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "8BA3D313-3C11-43E2-A47D-CBB532D1B6F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "6F42673E-65F3-4807-9484-20CB747420FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "0B91D023-FCE5-4866-AD8B-BBB675763104"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/ae6a9079436fb9b20fd051d25fb6d8027f0ec59a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/pull/17071", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-5f4f-35fx-gqhq", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/ae6a9079436fb9b20fd051d25fb6d8027f0ec59a"}}