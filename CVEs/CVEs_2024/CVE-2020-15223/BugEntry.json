{"buggy_code": ["linters:\n  enable:\n    - gosec\n  disable:\n    - ineffassign\n    - deadcode\n    - unused\n    - structcheck\n    - errcheck\n    - gosimple\n    - bodyclose\n    - staticcheck\n\nrun:\n  skip-files:\n    - \".+_test.go\"\n    - \".+_test_.+.go\"\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc (f *Fosite) WriteAccessError(rw http.ResponseWriter, _ AccessRequester, err error) {\n\tf.writeJsonError(rw, err)\n}\n\nfunc (f *Fosite) writeJsonError(rw http.ResponseWriter, err error) {\n\trw.Header().Set(\"Content-Type\", \"application/json;charset=UTF-8\")\n\trw.Header().Set(\"Cache-Control\", \"no-store\")\n\trw.Header().Set(\"Pragma\", \"no-cache\")\n\n\trfcerr := ErrorToRFC6749Error(err)\n\tif !f.SendDebugMessagesToClients {\n\t\trfcerr = rfcerr.Sanitize()\n\t}\n\n\tjs, err := json.Marshal(rfcerr)\n\tif err != nil {\n\t\tif f.SendDebugMessagesToClients {\n\t\t\terrorMessage := EscapeJSONString(err.Error())\n\t\t\thttp.Error(rw, fmt.Sprintf(`{\"error\":\"server_error\",\"error_description\":\"%s\"}`, errorMessage), http.StatusInternalServerError)\n\t\t} else {\n\t\t\thttp.Error(rw, `{\"error\":\"server_error\"}`, http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t}\n\n\trw.WriteHeader(rfcerr.Code)\n\trw.Write(js)\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\nfunc (f *Fosite) WriteAccessResponse(rw http.ResponseWriter, requester AccessRequester, responder AccessResponder) {\n\trw.Header().Set(\"Cache-Control\", \"no-store\")\n\trw.Header().Set(\"Pragma\", \"no-cache\")\n\n\tjs, err := json.Marshal(responder.ToMap())\n\tif err != nil {\n\t\thttp.Error(rw, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\trw.Header().Set(\"Content-Type\", \"application/json;charset=UTF-8\")\n\n\trw.WriteHeader(http.StatusOK)\n\trw.Write(js)\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/pkg/errors\"\n)\n\nfunc (f *Fosite) WriteAuthorizeError(rw http.ResponseWriter, ar AuthorizeRequester, err error) {\n\trw.Header().Set(\"Cache-Control\", \"no-store\")\n\trw.Header().Set(\"Pragma\", \"no-cache\")\n\n\trfcerr := ErrorToRFC6749Error(err)\n\tif !f.SendDebugMessagesToClients {\n\t\trfcerr = rfcerr.Sanitize()\n\t}\n\n\tif !ar.IsRedirectURIValid() {\n\t\trw.Header().Set(\"Content-Type\", \"application/json;charset=UTF-8\")\n\n\t\tjs, err := json.Marshal(rfcerr)\n\t\tif err != nil {\n\t\t\tif f.SendDebugMessagesToClients {\n\t\t\t\terrorMessage := EscapeJSONString(err.Error())\n\t\t\t\thttp.Error(rw, fmt.Sprintf(`{\"error\":\"server_error\",\"error_description\":\"%s\"}`, errorMessage), http.StatusInternalServerError)\n\t\t\t} else {\n\t\t\t\thttp.Error(rw, `{\"error\":\"server_error\"}`, http.StatusInternalServerError)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\trw.WriteHeader(rfcerr.Code)\n\t\trw.Write(js)\n\t\treturn\n\t}\n\n\tredirectURI := ar.GetRedirectURI()\n\n\t// The endpoint URI MUST NOT include a fragment component.\n\tredirectURI.Fragment = \"\"\n\n\tquery := rfcerr.ToValues()\n\tquery.Add(\"state\", ar.GetState())\n\n\tvar redirectURIString string\n\tif !(len(ar.GetResponseTypes()) == 0 || ar.GetResponseTypes().ExactOne(\"code\")) && !errors.Is(err, ErrUnsupportedResponseType) {\n\t\tredirectURIString = redirectURI.String() + \"#\" + query.Encode()\n\t} else {\n\t\tfor key, values := range redirectURI.Query() {\n\t\t\tfor _, value := range values {\n\t\t\t\tquery.Add(key, value)\n\t\t\t}\n\t\t}\n\t\tredirectURI.RawQuery = query.Encode()\n\t\tredirectURIString = redirectURI.String()\n\t}\n\n\trw.Header().Add(\"Location\", redirectURIString)\n\trw.WriteHeader(http.StatusFound)\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/pkg/errors\"\n)\n\nvar (\n\t// ErrInvalidatedAuthorizeCode is an error indicating that an authorization code has been\n\t// used previously.\n\tErrInvalidatedAuthorizeCode = errors.New(\"Authorization code has ben invalidated\")\n\t// ErrSerializationFailure is an error indicating that the transactional capable storage could not guarantee\n\t// consistency of Update & Delete operations on the same rows between multiple sessions.\n\tErrSerializationFailure = errors.New(\"The request could not be completed due to concurrent access\")\n\tErrUnknownRequest       = &RFC6749Error{\n\t\tName:        errUnknownErrorName,\n\t\tDescription: \"The handler is not responsible for this request\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRequestForbidden = &RFC6749Error{\n\t\tName:        errRequestForbidden,\n\t\tDescription: \"The request is not allowed\",\n\t\tHint:        \"You are not allowed to perform this action.\",\n\t\tCode:        http.StatusForbidden,\n\t}\n\tErrInvalidRequest = &RFC6749Error{\n\t\tName:        errInvalidRequestName,\n\t\tDescription: \"The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed\",\n\t\tHint:        \"Make sure that the various parameters are correct, be aware of case sensitivity and trim your parameters. Make sure that the client you are using has exactly whitelisted the redirect_uri you specified.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrUnauthorizedClient = &RFC6749Error{\n\t\tName:        errUnauthorizedClientName,\n\t\tDescription: \"The client is not authorized to request a token using this method\",\n\t\tHint:        \"Make sure that client id and secret are correctly specified and that the client exists.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrAccessDenied = &RFC6749Error{\n\t\tName:        errAccessDeniedName,\n\t\tDescription: \"The resource owner or authorization server denied the request\",\n\t\tHint:        \"Make sure that the request you are making is valid. Maybe the credential or request parameters you are using are limited in scope or otherwise restricted.\",\n\t\tCode:        http.StatusForbidden,\n\t}\n\tErrUnsupportedResponseType = &RFC6749Error{\n\t\tName:        errUnsupportedResponseTypeName,\n\t\tDescription: \"The authorization server does not support obtaining a token using this method\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidScope = &RFC6749Error{\n\t\tName:        errInvalidScopeName,\n\t\tDescription: \"The requested scope is invalid, unknown, or malformed\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrServerError = &RFC6749Error{\n\t\tName:        errServerErrorName,\n\t\tDescription: \"The authorization server encountered an unexpected condition that prevented it from fulfilling the request\",\n\t\tCode:        http.StatusInternalServerError,\n\t}\n\tErrTemporarilyUnavailable = &RFC6749Error{\n\t\tName:        errTemporarilyUnavailableName,\n\t\tDescription: \"The authorization server is currently unable to handle the request due to a temporary overloading or maintenance of the server\",\n\t\tCode:        http.StatusServiceUnavailable,\n\t}\n\tErrUnsupportedGrantType = &RFC6749Error{\n\t\tName:        errUnsupportedGrantTypeName,\n\t\tDescription: \"The authorization grant type is not supported by the authorization server\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidGrant = &RFC6749Error{\n\t\tName:        errInvalidGrantName,\n\t\tDescription: \"The provided authorization grant (e.g., authorization code, resource owner credentials) or refresh token is invalid, expired, revoked, does not match the redirection URI used in the authorization request, or was issued to another client\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidClient = &RFC6749Error{\n\t\tName:        errInvalidClientName,\n\t\tDescription: \"Client authentication failed (e.g., unknown client, no client authentication included, or unsupported authentication method)\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrInvalidState = &RFC6749Error{\n\t\tName:        errInvalidStateName,\n\t\tDescription: \"The state is missing or does not have enough characters and is therefore considered too weak\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrMisconfiguration = &RFC6749Error{\n\t\tName:        errMisconfigurationName,\n\t\tDescription: \"The request failed because of an internal error that is probably caused by misconfiguration\",\n\t\tCode:        http.StatusInternalServerError,\n\t}\n\tErrInsufficientEntropy = &RFC6749Error{\n\t\tName:        errInsufficientEntropyName,\n\t\tDescription: \"The request used a security parameter (e.g., anti-replay, anti-csrf) with insufficient entropy\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrNotFound = &RFC6749Error{\n\t\tName:        errNotFoundName,\n\t\tDescription: \"Could not find the requested resource(s)\",\n\t\tCode:        http.StatusNotFound,\n\t}\n\tErrRequestUnauthorized = &RFC6749Error{\n\t\tName:        errRequestUnauthorizedName,\n\t\tDescription: \"The request could not be authorized\",\n\t\tHint:        \"Check that you provided valid credentials in the right format.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrTokenSignatureMismatch = &RFC6749Error{\n\t\tName:        errTokenSignatureMismatchName,\n\t\tDescription: \"Token signature mismatch\",\n\t\tHint:        \"Check that you provided  a valid token in the right format.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidTokenFormat = &RFC6749Error{\n\t\tName:        errInvalidTokenFormatName,\n\t\tDescription: \"Invalid token format\",\n\t\tHint:        \"Check that you provided a valid token in the right format.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrTokenExpired = &RFC6749Error{\n\t\tName:        errTokenExpiredName,\n\t\tDescription: \"Token expired\",\n\t\tHint:        \"The token expired.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrScopeNotGranted = &RFC6749Error{\n\t\tName:        errScopeNotGrantedName,\n\t\tDescription: \"The token was not granted the requested scope\",\n\t\tHint:        \"The resource owner did not grant the requested scope.\",\n\t\tCode:        http.StatusForbidden,\n\t}\n\tErrTokenClaim = &RFC6749Error{\n\t\tName:        errTokenClaimName,\n\t\tDescription: \"The token failed validation due to a claim mismatch\",\n\t\tHint:        \"One or more token claims failed validation.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrInactiveToken = &RFC6749Error{\n\t\tName:        errTokenInactiveName,\n\t\tDescription: \"Token is inactive because it is malformed, expired or otherwise invalid\",\n\t\tHint:        \"Token validation failed.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrRevocationClientMismatch = &RFC6749Error{\n\t\tName:        errRevocationClientMismatchName,\n\t\tDescription: \"Token was not issued to the client making the revocation request\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrLoginRequired = &RFC6749Error{\n\t\tName:        errLoginRequired,\n\t\tDescription: \"The Authorization Server requires End-User authentication\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInteractionRequired = &RFC6749Error{\n\t\tDescription: \"The Authorization Server requires End-User interaction of some form to proceed\",\n\t\tName:        errInteractionRequired,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrConsentRequired = &RFC6749Error{\n\t\tDescription: \"The Authorization Server requires End-User consent\",\n\t\tName:        errConsentRequired,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRequestNotSupported = &RFC6749Error{\n\t\tDescription: \"The OP does not support use of the request parameter\",\n\t\tName:        errRequestNotSupportedName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRequestURINotSupported = &RFC6749Error{\n\t\tDescription: \"The OP does not support use of the request_uri parameter\",\n\t\tName:        errRequestURINotSupportedName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRegistrationNotSupported = &RFC6749Error{\n\t\tDescription: \"The OP does not support use of the registration parameter\",\n\t\tName:        errRegistrationNotSupportedName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidRequestURI = &RFC6749Error{\n\t\tDescription: \"The request_uri in the Authorization Request returns an error or contains invalid data. \",\n\t\tName:        errInvalidRequestURI,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidRequestObject = &RFC6749Error{\n\t\tDescription: \"The request parameter contains an invalid Request Object. \",\n\t\tName:        errInvalidRequestObject,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrJTIKnown = &RFC6749Error{\n\t\tDescription: \"The jti was already used.\",\n\t\tName:        errJTIKnownName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n)\n\nconst (\n\terrInvalidRequestURI           = \"invalid_request_uri\"\n\terrInvalidRequestObject        = \"invalid_request_object\"\n\terrConsentRequired             = \"consent_required\"\n\terrInteractionRequired         = \"interaction_required\"\n\terrLoginRequired               = \"login_required\"\n\terrRequestUnauthorizedName     = \"request_unauthorized\"\n\terrRequestForbidden            = \"request_forbidden\"\n\terrInvalidRequestName          = \"invalid_request\"\n\terrUnauthorizedClientName      = \"unauthorized_client\"\n\terrAccessDeniedName            = \"access_denied\"\n\terrUnsupportedResponseTypeName = \"unsupported_response_type\"\n\terrInvalidScopeName            = \"invalid_scope\"\n\terrServerErrorName             = \"server_error\"\n\terrTemporarilyUnavailableName  = \"temporarily_unavailable\"\n\terrUnsupportedGrantTypeName    = \"unsupported_grant_type\"\n\terrInvalidGrantName            = \"invalid_grant\"\n\terrInvalidClientName           = \"invalid_client\"\n\terrNotFoundName                = \"not_found\"\n\terrInvalidStateName            = \"invalid_state\"\n\terrMisconfigurationName        = \"misconfiguration\"\n\terrInsufficientEntropyName     = \"insufficient_entropy\"\n\terrInvalidTokenFormatName      = \"invalid_token\"\n\terrTokenSignatureMismatchName  = \"token_signature_mismatch\"\n\terrTokenExpiredName            = \"token_expired\"\n\terrScopeNotGrantedName         = \"scope_not_granted\"\n\terrTokenClaimName              = \"token_claim\"\n\terrTokenInactiveName           = \"token_inactive\"\n\t// errAuthorizationCodeInactiveName = \"authorization_code_inactive\"\n\terrUnknownErrorName             = \"error\"\n\terrRevocationClientMismatchName = \"revocation_client_mismatch\"\n\terrRequestNotSupportedName      = \"request_not_supported\"\n\terrRequestURINotSupportedName   = \"request_uri_not_supported\"\n\terrRegistrationNotSupportedName = \"registration_not_supported\"\n\terrJTIKnownName                 = \"jti_known\"\n)\n\nfunc ErrorToRFC6749Error(err error) *RFC6749Error {\n\tvar e *RFC6749Error\n\tif errors.As(err, &e) {\n\t\treturn e\n\t}\n\treturn &RFC6749Error{\n\t\tName:        errUnknownErrorName,\n\t\tDescription: \"The error is unrecognizable.\",\n\t\tDebug:       err.Error(),\n\t\tCode:        http.StatusInternalServerError,\n\t\tcause:       err,\n\t}\n}\n\ntype RFC6749Error struct {\n\tName        string\n\tDescription string\n\tHint        string\n\tCode        int\n\tDebug       string\n\tcause       error\n}\n\nfunc (e *RFC6749Error) Status() string {\n\treturn http.StatusText(e.Code)\n}\n\nfunc (e *RFC6749Error) Error() string {\n\treturn e.Name\n}\n\nfunc (e *RFC6749Error) RequestID() string {\n\treturn \"\"\n}\n\nfunc (e *RFC6749Error) Reason() string {\n\treturn e.Hint\n}\n\nfunc (e *RFC6749Error) StatusCode() int {\n\treturn e.Code\n}\n\nfunc (e *RFC6749Error) Cause() error {\n\treturn e.cause\n}\n\nfunc (e *RFC6749Error) Unwrap() error {\n\treturn e.cause\n}\n\nfunc (e *RFC6749Error) WithHintf(hint string, args ...interface{}) *RFC6749Error {\n\treturn e.WithHint(fmt.Sprintf(hint, args...))\n}\n\nfunc (e *RFC6749Error) WithHint(hint string) *RFC6749Error {\n\terr := *e\n\terr.Hint = hint\n\treturn &err\n}\n\nfunc (e *RFC6749Error) WithDebug(debug string) *RFC6749Error {\n\terr := *e\n\terr.Debug = debug\n\treturn &err\n}\n\nfunc (e *RFC6749Error) WithDebugf(debug string, args ...interface{}) *RFC6749Error {\n\treturn e.WithDebug(fmt.Sprintf(debug, args...))\n}\n\nfunc (e *RFC6749Error) WithDescription(description string) *RFC6749Error {\n\terr := *e\n\terr.Description = description\n\treturn &err\n}\n\nfunc (e *RFC6749Error) WithCause(cause error) *RFC6749Error {\n\terr := *e\n\terr.cause = cause\n\treturn &err\n}\n\nfunc (e *RFC6749Error) Sanitize() *RFC6749Error {\n\terr := *e\n\terr.Debug = \"\"\n\treturn &err\n}\n\n// GetDescription returns a more description description, combined with hint and debug (when available).\nfunc (e *RFC6749Error) GetDescription() string {\n\tdescription := e.Description\n\tif e.Hint != \"\" {\n\t\tdescription += \"\\n\\n\" + e.Hint\n\t}\n\tif e.Debug != \"\" {\n\t\tdescription += \"\\n\\n\" + e.Debug\n\t}\n\treturn description\n}\n\n// Is returns true if the target error is equal to the current error. Used by errors.Is.\nfunc (e *RFC6749Error) Is(target error) bool {\n\treturn e.Error() == target.Error()\n}\n\n// RFC6749ErrorJson is a helper struct for JSON encoding/decoding of RFC6749Error.\ntype RFC6749ErrorJson struct {\n\tName        string `json:\"error\"`\n\tVerbose     string `json:\"error_verbose\"`\n\tDescription string `json:\"error_description\"`\n\tHint        string `json:\"error_hint,omitempty\"`\n\tCode        int    `json:\"status_code,omitempty\"`\n\tDebug       string `json:\"error_debug,omitempty\"`\n}\n\nfunc (e *RFC6749Error) UnmarshalJSON(b []byte) error {\n\tvar data RFC6749ErrorJson\n\n\tif err := json.Unmarshal(b, &data); err != nil {\n\t\treturn err\n\t}\n\n\te.Name = data.Name\n\te.Description = data.Verbose\n\te.Hint = data.Hint\n\te.Code = data.Code\n\te.Debug = data.Debug\n\n\treturn nil\n}\n\nfunc (e RFC6749Error) MarshalJSON() ([]byte, error) {\n\tdata := RFC6749ErrorJson{\n\t\tName:        e.Name,\n\t\tVerbose:     e.Description,\n\t\tDescription: e.GetDescription(),\n\t\tHint:        e.Hint,\n\t\tCode:        e.Code,\n\t\tDebug:       e.Debug,\n\t}\n\treturn json.Marshal(data)\n}\n\nfunc (e *RFC6749Error) ToValues() url.Values {\n\tvalues := url.Values{}\n\tvalues.Add(\"error\", e.Name)\n\tvalues.Add(\"error_description\", e.GetDescription())\n\tif e.Hint != \"\" {\n\t\tvalues.Add(\"error_hint\", e.Hint)\n\t}\n\tif e.Debug != \"\" {\n\t\tvalues.Add(\"error_debug\", e.Debug)\n\t}\n\treturn values\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"testing\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAddDebug(t *testing.T) {\n\terr := ErrRevocationClientMismatch.WithDebug(\"debug\")\n\tassert.NotEqual(t, err, ErrRevocationClientMismatch)\n\tassert.Empty(t, ErrRevocationClientMismatch.Debug)\n\tassert.NotEmpty(t, err.Debug)\n}\n\nfunc TestIs(t *testing.T) {\n\tassert.True(t, errors.Is(ErrUnknownRequest, ErrUnknownRequest))\n\tassert.True(t, errors.Is(ErrUnknownRequest, &RFC6749Error{\n\t\tName: errUnknownErrorName,\n\t}))\n\tassert.True(t, errors.Is(&RFC6749Error{\n\t\tName: errUnknownErrorName,\n\t}, ErrUnknownRequest))\n}\n", "// +build tools\n\npackage fosite\n\nimport (\n\t_ \"github.com/gorilla/websocket\"\n\t_ \"github.com/mattn/goveralls\"\n\t_ \"github.com/ory/go-acc\"\n)\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage oauth2\n\nimport (\n\t\"context\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/ory/fosite\"\n)\n\ntype TokenRevocationHandler struct {\n\tTokenRevocationStorage TokenRevocationStorage\n\tRefreshTokenStrategy   RefreshTokenStrategy\n\tAccessTokenStrategy    AccessTokenStrategy\n}\n\n// RevokeToken implements https://tools.ietf.org/html/rfc7009#section-2.1\n// The token type hint indicates which token type check should be performed first.\nfunc (r *TokenRevocationHandler) RevokeToken(ctx context.Context, token string, tokenType fosite.TokenType, client fosite.Client) error {\n\tdiscoveryFuncs := []func() (request fosite.Requester, err error){\n\t\tfunc() (request fosite.Requester, err error) {\n\t\t\t// Refresh token\n\t\t\tsignature := r.RefreshTokenStrategy.RefreshTokenSignature(token)\n\t\t\treturn r.TokenRevocationStorage.GetRefreshTokenSession(ctx, signature, nil)\n\t\t},\n\t\tfunc() (request fosite.Requester, err error) {\n\t\t\t// Access token\n\t\t\tsignature := r.AccessTokenStrategy.AccessTokenSignature(token)\n\t\t\treturn r.TokenRevocationStorage.GetAccessTokenSession(ctx, signature, nil)\n\t\t},\n\t}\n\n\t// Token type hinting\n\tif tokenType == fosite.AccessToken {\n\t\tdiscoveryFuncs[0], discoveryFuncs[1] = discoveryFuncs[1], discoveryFuncs[0]\n\t}\n\n\tvar ar fosite.Requester\n\tvar err error\n\tif ar, err = discoveryFuncs[0](); err != nil {\n\t\tar, err = discoveryFuncs[1]()\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif ar.GetClient().GetID() != client.GetID() {\n\t\treturn errors.WithStack(fosite.ErrRevocationClientMismatch)\n\t}\n\n\trequestID := ar.GetID()\n\tr.TokenRevocationStorage.RevokeRefreshToken(ctx, requestID)\n\tr.TokenRevocationStorage.RevokeAccessToken(ctx, requestID)\n\n\treturn nil\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage oauth2\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/golang/mock/gomock\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/ory/fosite\"\n\t\"github.com/ory/fosite/internal\"\n)\n\nfunc TestRevokeToken(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tstore := internal.NewMockTokenRevocationStorage(ctrl)\n\tatStrat := internal.NewMockAccessTokenStrategy(ctrl)\n\trtStrat := internal.NewMockRefreshTokenStrategy(ctrl)\n\tar := internal.NewMockAccessRequester(ctrl)\n\tdefer ctrl.Finish()\n\n\th := TokenRevocationHandler{\n\t\tTokenRevocationStorage: store,\n\t\tRefreshTokenStrategy:   rtStrat,\n\t\tAccessTokenStrategy:    atStrat,\n\t}\n\n\tvar token string\n\tvar tokenType fosite.TokenType\n\n\tfor k, c := range []struct {\n\t\tdescription string\n\t\tmock        func()\n\t\texpectErr   error\n\t\tclient      fosite.Client\n\t}{\n\t\t{\n\t\t\tdescription: \"should fail - token was issued to another client\",\n\t\t\texpectErr:   fosite.ErrRevocationClientMismatch,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.RefreshToken\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"foo\"})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should pass - refresh token discovery first; refresh token found\",\n\t\t\texpectErr:   nil,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.RefreshToken\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n\t\t\t\tar.EXPECT().GetID()\n\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"bar\"})\n\t\t\t\tstore.EXPECT().RevokeRefreshToken(gomock.Any(), gomock.Any())\n\t\t\t\tstore.EXPECT().RevokeAccessToken(gomock.Any(), gomock.Any())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should pass - access token discovery first; access token found\",\n\t\t\texpectErr:   nil,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.AccessToken\n\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n\t\t\t\tar.EXPECT().GetID()\n\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"bar\"})\n\t\t\t\tstore.EXPECT().RevokeRefreshToken(gomock.Any(), gomock.Any())\n\t\t\t\tstore.EXPECT().RevokeAccessToken(gomock.Any(), gomock.Any())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should pass - refresh token discovery first; refresh token not found\",\n\t\t\texpectErr:   nil,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.AccessToken\n\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n\t\t\t\tar.EXPECT().GetID()\n\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"bar\"})\n\t\t\t\tstore.EXPECT().RevokeRefreshToken(gomock.Any(), gomock.Any())\n\t\t\t\tstore.EXPECT().RevokeAccessToken(gomock.Any(), gomock.Any())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should pass - access token discovery first; access token not found\",\n\t\t\texpectErr:   nil,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.RefreshToken\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\n\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n\t\t\t\tar.EXPECT().GetID()\n\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"bar\"})\n\t\t\t\tstore.EXPECT().RevokeRefreshToken(gomock.Any(), gomock.Any())\n\t\t\t\tstore.EXPECT().RevokeAccessToken(gomock.Any(), gomock.Any())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should fail - refresh token discovery first; both tokens not found\",\n\t\t\texpectErr:   fosite.ErrNotFound,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.RefreshToken\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\n\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should fail - access token discovery first; both tokens not found\",\n\t\t\texpectErr:   fosite.ErrNotFound,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.AccessToken\n\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\t\t\t},\n\t\t},\n\t} {\n\t\tt.Run(fmt.Sprintf(\"case=%d\", k), func(t *testing.T) {\n\t\t\tc.mock()\n\t\t\terr := h.RevokeToken(nil, token, tokenType, c.client)\n\n\t\t\tif c.expectErr != nil {\n\t\t\t\trequire.EqualError(t, err, c.expectErr.Error())\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage openid\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\n\t\"github.com/ory/fosite\"\n)\n\ntype IDTokenHandleHelper struct {\n\tIDTokenStrategy OpenIDConnectTokenStrategy\n}\n\nfunc (i *IDTokenHandleHelper) GetAccessTokenHash(ctx context.Context, requester fosite.AccessRequester, responder fosite.AccessResponder) string {\n\ttoken := responder.GetAccessToken()\n\n\tbuffer := bytes.NewBufferString(token)\n\thash := sha256.New()\n\thash.Write(buffer.Bytes())\n\thashBuf := bytes.NewBuffer(hash.Sum([]byte{}))\n\tlen := hashBuf.Len()\n\n\treturn base64.RawURLEncoding.EncodeToString(hashBuf.Bytes()[:len/2])\n}\n\nfunc (i *IDTokenHandleHelper) generateIDToken(ctx context.Context, fosr fosite.Requester) (token string, err error) {\n\ttoken, err = i.IDTokenStrategy.GenerateIDToken(ctx, fosr)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn token, nil\n}\n\nfunc (i *IDTokenHandleHelper) IssueImplicitIDToken(ctx context.Context, ar fosite.Requester, resp fosite.AuthorizeResponder) error {\n\ttoken, err := i.generateIDToken(ctx, ar)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp.AddFragment(\"id_token\", token)\n\treturn nil\n}\n\nfunc (i *IDTokenHandleHelper) IssueExplicitIDToken(ctx context.Context, ar fosite.Requester, resp fosite.AccessResponder) error {\n\ttoken, err := i.generateIDToken(ctx, ar)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp.SetExtra(\"id_token\", token)\n\treturn nil\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/pkg/errors\"\n)\n\n// NewRevocationRequest handles incoming token revocation requests and\n// validates various parameters as specified in:\n// https://tools.ietf.org/html/rfc7009#section-2.1\n//\n// The authorization server first validates the client credentials (in\n// case of a confidential client) and then verifies whether the token\n// was issued to the client making the revocation request.  If this\n// validation fails, the request is refused and the client is informed\n// of the error by the authorization server as described below.\n//\n// In the next step, the authorization server invalidates the token.\n// The invalidation takes place immediately, and the token cannot be\n// used again after the revocation.\n//\n// * https://tools.ietf.org/html/rfc7009#section-2.2\n// An invalid token type hint value is ignored by the authorization\n// server and does not influence the revocation response.\nfunc (f *Fosite) NewRevocationRequest(ctx context.Context, r *http.Request) error {\n\tif r.Method != \"POST\" {\n\t\treturn errors.WithStack(ErrInvalidRequest.WithHintf(\"HTTP method is \\\"%s\\\", expected \\\"POST\\\".\", r.Method))\n\t} else if err := r.ParseMultipartForm(1 << 20); err != nil && err != http.ErrNotMultipart {\n\t\treturn errors.WithStack(ErrInvalidRequest.WithHint(\"Unable to parse HTTP body, make sure to send a properly formatted form request body.\").WithCause(err).WithDebug(err.Error()))\n\t} else if len(r.PostForm) == 0 {\n\t\treturn errors.WithStack(ErrInvalidRequest.WithHint(\"The POST body can not be empty.\"))\n\t}\n\n\tclient, err := f.AuthenticateClient(ctx, r, r.PostForm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttoken := r.PostForm.Get(\"token\")\n\ttokenTypeHint := TokenType(r.PostForm.Get(\"token_type_hint\"))\n\n\tvar found = false\n\tfor _, loader := range f.RevocationHandlers {\n\t\tif err := loader.RevokeToken(ctx, token, tokenTypeHint, client); err == nil {\n\t\t\tfound = true\n\t\t} else if errors.Is(err, ErrUnknownRequest) {\n\t\t\t// do nothing\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif !found {\n\t\treturn errors.WithStack(ErrInvalidRequest)\n\t}\n\n\treturn nil\n}\n\n// WriteRevocationResponse writes a token revocation response as specified in:\n// https://tools.ietf.org/html/rfc7009#section-2.2\n//\n// The authorization server responds with HTTP status code 200 if the\n// token has been revoked successfully or if the client submitted an\n// invalid token.\n//\n// Note: invalid tokens do not cause an error response since the client\n// cannot handle such an error in a reasonable way.  Moreover, the\n// purpose of the revocation request, invalidating the particular token,\n// is already achieved.\nfunc (f *Fosite) WriteRevocationResponse(rw http.ResponseWriter, err error) {\n\trw.Header().Set(\"Cache-Control\", \"no-store\")\n\trw.Header().Set(\"Pragma\", \"no-cache\")\n\n\tif err == nil {\n\t\trw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\n\tif errors.Is(err, ErrInvalidRequest) {\n\t\trw.Header().Set(\"Content-Type\", \"application/json;charset=UTF-8\")\n\n\t\tjs, err := json.Marshal(ErrInvalidRequest)\n\t\tif err != nil {\n\t\t\thttp.Error(rw, fmt.Sprintf(`{\"error\": \"%s\"}`, err.Error()), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\trw.WriteHeader(ErrInvalidRequest.Code)\n\t\trw.Write(js)\n\t} else if errors.Is(err, ErrInvalidClient) {\n\t\trw.Header().Set(\"Content-Type\", \"application/json;charset=UTF-8\")\n\n\t\tjs, err := json.Marshal(ErrInvalidClient)\n\t\tif err != nil {\n\t\t\thttp.Error(rw, fmt.Sprintf(`{\"error\": \"%s\"}`, err.Error()), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\trw.WriteHeader(ErrInvalidClient.Code)\n\t\trw.Write(js)\n\t} else {\n\t\t// 200 OK\n\t\trw.WriteHeader(http.StatusOK)\n\t}\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\n// Package hmac is the default implementation for generating and validating challenges. It uses HMAC-SHA256 to\n// generate and validate challenges.\n\npackage hmac\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha512\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/ory/fosite\"\n)\n\n// HMACStrategy is responsible for generating and validating challenges.\ntype HMACStrategy struct {\n\tTokenEntropy         int\n\tGlobalSecret         []byte\n\tRotatedGlobalSecrets [][]byte\n\tsync.Mutex\n}\n\nconst (\n\t// key should be at least 256 bit long, making it\n\tminimumEntropy = 32\n\n\t// the secrets (client and global) should each have at least 16 characters making it harder to guess them\n\tminimumSecretLength = 32\n)\n\nvar b64 = base64.URLEncoding.WithPadding(base64.NoPadding)\n\n// Generate generates a token and a matching signature or returns an error.\n// This method implements rfc6819 Section 5.1.4.2.2: Use High Entropy for Secrets.\nfunc (c *HMACStrategy) Generate() (string, string, error) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tif len(c.GlobalSecret) < minimumSecretLength {\n\t\treturn \"\", \"\", errors.Errorf(\"secret for signing HMAC-SHA256 is expected to be 32 byte long, got %d byte\", len(c.GlobalSecret))\n\t}\n\n\tvar signingKey [32]byte\n\tcopy(signingKey[:], c.GlobalSecret)\n\n\tif c.TokenEntropy < minimumEntropy {\n\t\tc.TokenEntropy = minimumEntropy\n\t}\n\n\t// When creating secrets not intended for usage by human users (e.g.,\n\t// client secrets or token handles), the authorization server should\n\t// include a reasonable level of entropy in order to mitigate the risk\n\t// of guessing attacks.  The token value should be >=128 bits long and\n\t// constructed from a cryptographically strong random or pseudo-random\n\t// number sequence (see [RFC4086] for best current practice) generated\n\t// by the authorization server.\n\ttokenKey, err := RandomBytes(c.TokenEntropy)\n\tif err != nil {\n\t\treturn \"\", \"\", errors.WithStack(err)\n\t}\n\n\tsignature := generateHMAC(tokenKey, &signingKey)\n\n\tencodedSignature := b64.EncodeToString(signature)\n\tencodedToken := fmt.Sprintf(\"%s.%s\", b64.EncodeToString(tokenKey), encodedSignature)\n\treturn encodedToken, encodedSignature, nil\n}\n\n// Validate validates a token and returns its signature or an error if the token is not valid.\nfunc (c *HMACStrategy) Validate(token string) (err error) {\n\tvar keys [][]byte\n\n\tif len(c.GlobalSecret) > 0 {\n\t\tkeys = append(keys, c.GlobalSecret)\n\t}\n\n\tif len(c.RotatedGlobalSecrets) > 0 {\n\t\tkeys = append(keys, c.RotatedGlobalSecrets...)\n\t}\n\n\tfor _, key := range keys {\n\t\tif err = c.validate(key, token); err == nil {\n\t\t\treturn nil\n\t\t} else if errors.Is(err, fosite.ErrTokenSignatureMismatch) {\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err == nil {\n\t\treturn errors.New(\"a secret for signing HMAC-SHA256 is expected to be defined, but none were\")\n\t}\n\n\treturn err\n}\n\nfunc (c *HMACStrategy) validate(secret []byte, token string) error {\n\tif len(secret) < minimumSecretLength {\n\t\treturn errors.Errorf(\"secret for signing HMAC-SHA256 is expected to be 32 byte long, got %d byte\", len(secret))\n\t}\n\n\tvar signingKey [32]byte\n\tcopy(signingKey[:], secret)\n\n\tsplit := strings.Split(token, \".\")\n\tif len(split) != 2 {\n\t\treturn errors.WithStack(fosite.ErrInvalidTokenFormat)\n\t}\n\n\ttokenKey := split[0]\n\ttokenSignature := split[1]\n\tif tokenKey == \"\" || tokenSignature == \"\" {\n\t\treturn errors.WithStack(fosite.ErrInvalidTokenFormat)\n\t}\n\n\tdecodedTokenSignature, err := b64.DecodeString(tokenSignature)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tdecodedTokenKey, err := b64.DecodeString(tokenKey)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\texpectedMAC := generateHMAC(decodedTokenKey, &signingKey)\n\tif !hmac.Equal(expectedMAC, decodedTokenSignature) {\n\t\t// Hash is invalid\n\t\treturn errors.WithStack(fosite.ErrTokenSignatureMismatch)\n\t}\n\n\treturn nil\n}\n\nfunc (c *HMACStrategy) Signature(token string) string {\n\tsplit := strings.Split(token, \".\")\n\n\tif len(split) != 2 {\n\t\treturn \"\"\n\t}\n\n\treturn split[1]\n}\n\nfunc generateHMAC(data []byte, key *[32]byte) []byte {\n\th := hmac.New(sha512.New512_256, key[:])\n\th.Write(data)\n\treturn h.Sum(nil)\n}\n"], "fixing_code": ["linters:\n  enable:\n    - gosec\n  disable:\n    - ineffassign\n    - deadcode\n    - unused\n    - structcheck\n    - gosimple\n    - bodyclose\n    - staticcheck\n\nrun:\n  skip-files:\n    - \".+_test.go\"\n    - \".+_test_.+.go\"\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc (f *Fosite) WriteAccessError(rw http.ResponseWriter, _ AccessRequester, err error) {\n\tf.writeJsonError(rw, err)\n}\n\nfunc (f *Fosite) writeJsonError(rw http.ResponseWriter, err error) {\n\trw.Header().Set(\"Content-Type\", \"application/json;charset=UTF-8\")\n\trw.Header().Set(\"Cache-Control\", \"no-store\")\n\trw.Header().Set(\"Pragma\", \"no-cache\")\n\n\trfcerr := ErrorToRFC6749Error(err)\n\tif !f.SendDebugMessagesToClients {\n\t\trfcerr = rfcerr.Sanitize()\n\t}\n\n\tjs, err := json.Marshal(rfcerr)\n\tif err != nil {\n\t\tif f.SendDebugMessagesToClients {\n\t\t\terrorMessage := EscapeJSONString(err.Error())\n\t\t\thttp.Error(rw, fmt.Sprintf(`{\"error\":\"server_error\",\"error_description\":\"%s\"}`, errorMessage), http.StatusInternalServerError)\n\t\t} else {\n\t\t\thttp.Error(rw, `{\"error\":\"server_error\"}`, http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t}\n\n\trw.WriteHeader(rfcerr.Code)\n\t// ignoring the error because the connection is broken when it happens\n\t_, _ = rw.Write(js)\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\nfunc (f *Fosite) WriteAccessResponse(rw http.ResponseWriter, requester AccessRequester, responder AccessResponder) {\n\trw.Header().Set(\"Cache-Control\", \"no-store\")\n\trw.Header().Set(\"Pragma\", \"no-cache\")\n\n\tjs, err := json.Marshal(responder.ToMap())\n\tif err != nil {\n\t\thttp.Error(rw, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\trw.Header().Set(\"Content-Type\", \"application/json;charset=UTF-8\")\n\n\trw.WriteHeader(http.StatusOK)\n\t_, _ = rw.Write(js)\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/pkg/errors\"\n)\n\nfunc (f *Fosite) WriteAuthorizeError(rw http.ResponseWriter, ar AuthorizeRequester, err error) {\n\trw.Header().Set(\"Cache-Control\", \"no-store\")\n\trw.Header().Set(\"Pragma\", \"no-cache\")\n\n\trfcerr := ErrorToRFC6749Error(err)\n\tif !f.SendDebugMessagesToClients {\n\t\trfcerr = rfcerr.Sanitize()\n\t}\n\n\tif !ar.IsRedirectURIValid() {\n\t\trw.Header().Set(\"Content-Type\", \"application/json;charset=UTF-8\")\n\n\t\tjs, err := json.Marshal(rfcerr)\n\t\tif err != nil {\n\t\t\tif f.SendDebugMessagesToClients {\n\t\t\t\terrorMessage := EscapeJSONString(err.Error())\n\t\t\t\thttp.Error(rw, fmt.Sprintf(`{\"error\":\"server_error\",\"error_description\":\"%s\"}`, errorMessage), http.StatusInternalServerError)\n\t\t\t} else {\n\t\t\t\thttp.Error(rw, `{\"error\":\"server_error\"}`, http.StatusInternalServerError)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\trw.WriteHeader(rfcerr.Code)\n\t\t_, _ = rw.Write(js)\n\t\treturn\n\t}\n\n\tredirectURI := ar.GetRedirectURI()\n\n\t// The endpoint URI MUST NOT include a fragment component.\n\tredirectURI.Fragment = \"\"\n\n\tquery := rfcerr.ToValues()\n\tquery.Add(\"state\", ar.GetState())\n\n\tvar redirectURIString string\n\tif !(len(ar.GetResponseTypes()) == 0 || ar.GetResponseTypes().ExactOne(\"code\")) && !errors.Is(err, ErrUnsupportedResponseType) {\n\t\tredirectURIString = redirectURI.String() + \"#\" + query.Encode()\n\t} else {\n\t\tfor key, values := range redirectURI.Query() {\n\t\t\tfor _, value := range values {\n\t\t\t\tquery.Add(key, value)\n\t\t\t}\n\t\t}\n\t\tredirectURI.RawQuery = query.Encode()\n\t\tredirectURIString = redirectURI.String()\n\t}\n\n\trw.Header().Add(\"Location\", redirectURIString)\n\trw.WriteHeader(http.StatusFound)\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/pkg/errors\"\n)\n\nvar (\n\t// ErrInvalidatedAuthorizeCode is an error indicating that an authorization code has been\n\t// used previously.\n\tErrInvalidatedAuthorizeCode = errors.New(\"Authorization code has ben invalidated\")\n\t// ErrSerializationFailure is an error indicating that the transactional capable storage could not guarantee\n\t// consistency of Update & Delete operations on the same rows between multiple sessions.\n\tErrSerializationFailure = errors.New(\"The request could not be completed due to concurrent access\")\n\tErrUnknownRequest       = &RFC6749Error{\n\t\tName:        errUnknownErrorName,\n\t\tDescription: \"The handler is not responsible for this request\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRequestForbidden = &RFC6749Error{\n\t\tName:        errRequestForbidden,\n\t\tDescription: \"The request is not allowed\",\n\t\tHint:        \"You are not allowed to perform this action.\",\n\t\tCode:        http.StatusForbidden,\n\t}\n\tErrInvalidRequest = &RFC6749Error{\n\t\tName:        errInvalidRequestName,\n\t\tDescription: \"The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed\",\n\t\tHint:        \"Make sure that the various parameters are correct, be aware of case sensitivity and trim your parameters. Make sure that the client you are using has exactly whitelisted the redirect_uri you specified.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrUnauthorizedClient = &RFC6749Error{\n\t\tName:        errUnauthorizedClientName,\n\t\tDescription: \"The client is not authorized to request a token using this method\",\n\t\tHint:        \"Make sure that client id and secret are correctly specified and that the client exists.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrAccessDenied = &RFC6749Error{\n\t\tName:        errAccessDeniedName,\n\t\tDescription: \"The resource owner or authorization server denied the request\",\n\t\tHint:        \"Make sure that the request you are making is valid. Maybe the credential or request parameters you are using are limited in scope or otherwise restricted.\",\n\t\tCode:        http.StatusForbidden,\n\t}\n\tErrUnsupportedResponseType = &RFC6749Error{\n\t\tName:        errUnsupportedResponseTypeName,\n\t\tDescription: \"The authorization server does not support obtaining a token using this method\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidScope = &RFC6749Error{\n\t\tName:        errInvalidScopeName,\n\t\tDescription: \"The requested scope is invalid, unknown, or malformed\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrServerError = &RFC6749Error{\n\t\tName:        errServerErrorName,\n\t\tDescription: \"The authorization server encountered an unexpected condition that prevented it from fulfilling the request\",\n\t\tCode:        http.StatusInternalServerError,\n\t}\n\tErrTemporarilyUnavailable = &RFC6749Error{\n\t\tName:        errTemporarilyUnavailableName,\n\t\tDescription: \"The authorization server is currently unable to handle the request due to a temporary overloading or maintenance of the server\",\n\t\tCode:        http.StatusServiceUnavailable,\n\t}\n\tErrUnsupportedGrantType = &RFC6749Error{\n\t\tName:        errUnsupportedGrantTypeName,\n\t\tDescription: \"The authorization grant type is not supported by the authorization server\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidGrant = &RFC6749Error{\n\t\tName:        errInvalidGrantName,\n\t\tDescription: \"The provided authorization grant (e.g., authorization code, resource owner credentials) or refresh token is invalid, expired, revoked, does not match the redirection URI used in the authorization request, or was issued to another client\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidClient = &RFC6749Error{\n\t\tName:        errInvalidClientName,\n\t\tDescription: \"Client authentication failed (e.g., unknown client, no client authentication included, or unsupported authentication method)\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrInvalidState = &RFC6749Error{\n\t\tName:        errInvalidStateName,\n\t\tDescription: \"The state is missing or does not have enough characters and is therefore considered too weak\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrMisconfiguration = &RFC6749Error{\n\t\tName:        errMisconfigurationName,\n\t\tDescription: \"The request failed because of an internal error that is probably caused by misconfiguration\",\n\t\tCode:        http.StatusInternalServerError,\n\t}\n\tErrInsufficientEntropy = &RFC6749Error{\n\t\tName:        errInsufficientEntropyName,\n\t\tDescription: \"The request used a security parameter (e.g., anti-replay, anti-csrf) with insufficient entropy\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrNotFound = &RFC6749Error{\n\t\tName:        errNotFoundName,\n\t\tDescription: \"Could not find the requested resource(s)\",\n\t\tCode:        http.StatusNotFound,\n\t}\n\tErrRequestUnauthorized = &RFC6749Error{\n\t\tName:        errRequestUnauthorizedName,\n\t\tDescription: \"The request could not be authorized\",\n\t\tHint:        \"Check that you provided valid credentials in the right format.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrTokenSignatureMismatch = &RFC6749Error{\n\t\tName:        errTokenSignatureMismatchName,\n\t\tDescription: \"Token signature mismatch\",\n\t\tHint:        \"Check that you provided  a valid token in the right format.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidTokenFormat = &RFC6749Error{\n\t\tName:        errInvalidTokenFormatName,\n\t\tDescription: \"Invalid token format\",\n\t\tHint:        \"Check that you provided a valid token in the right format.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrTokenExpired = &RFC6749Error{\n\t\tName:        errTokenExpiredName,\n\t\tDescription: \"Token expired\",\n\t\tHint:        \"The token expired.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrScopeNotGranted = &RFC6749Error{\n\t\tName:        errScopeNotGrantedName,\n\t\tDescription: \"The token was not granted the requested scope\",\n\t\tHint:        \"The resource owner did not grant the requested scope.\",\n\t\tCode:        http.StatusForbidden,\n\t}\n\tErrTokenClaim = &RFC6749Error{\n\t\tName:        errTokenClaimName,\n\t\tDescription: \"The token failed validation due to a claim mismatch\",\n\t\tHint:        \"One or more token claims failed validation.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrInactiveToken = &RFC6749Error{\n\t\tName:        errTokenInactiveName,\n\t\tDescription: \"Token is inactive because it is malformed, expired or otherwise invalid\",\n\t\tHint:        \"Token validation failed.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrLoginRequired = &RFC6749Error{\n\t\tName:        errLoginRequired,\n\t\tDescription: \"The Authorization Server requires End-User authentication\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInteractionRequired = &RFC6749Error{\n\t\tDescription: \"The Authorization Server requires End-User interaction of some form to proceed\",\n\t\tName:        errInteractionRequired,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrConsentRequired = &RFC6749Error{\n\t\tDescription: \"The Authorization Server requires End-User consent\",\n\t\tName:        errConsentRequired,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRequestNotSupported = &RFC6749Error{\n\t\tDescription: \"The OP does not support use of the request parameter\",\n\t\tName:        errRequestNotSupportedName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRequestURINotSupported = &RFC6749Error{\n\t\tDescription: \"The OP does not support use of the request_uri parameter\",\n\t\tName:        errRequestURINotSupportedName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRegistrationNotSupported = &RFC6749Error{\n\t\tDescription: \"The OP does not support use of the registration parameter\",\n\t\tName:        errRegistrationNotSupportedName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidRequestURI = &RFC6749Error{\n\t\tDescription: \"The request_uri in the Authorization Request returns an error or contains invalid data. \",\n\t\tName:        errInvalidRequestURI,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidRequestObject = &RFC6749Error{\n\t\tDescription: \"The request parameter contains an invalid Request Object. \",\n\t\tName:        errInvalidRequestObject,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrJTIKnown = &RFC6749Error{\n\t\tDescription: \"The jti was already used.\",\n\t\tName:        errJTIKnownName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n)\n\nconst (\n\terrInvalidRequestURI           = \"invalid_request_uri\"\n\terrInvalidRequestObject        = \"invalid_request_object\"\n\terrConsentRequired             = \"consent_required\"\n\terrInteractionRequired         = \"interaction_required\"\n\terrLoginRequired               = \"login_required\"\n\terrRequestUnauthorizedName     = \"request_unauthorized\"\n\terrRequestForbidden            = \"request_forbidden\"\n\terrInvalidRequestName          = \"invalid_request\"\n\terrUnauthorizedClientName      = \"unauthorized_client\"\n\terrAccessDeniedName            = \"access_denied\"\n\terrUnsupportedResponseTypeName = \"unsupported_response_type\"\n\terrInvalidScopeName            = \"invalid_scope\"\n\terrServerErrorName             = \"server_error\"\n\terrTemporarilyUnavailableName  = \"temporarily_unavailable\"\n\terrUnsupportedGrantTypeName    = \"unsupported_grant_type\"\n\terrInvalidGrantName            = \"invalid_grant\"\n\terrInvalidClientName           = \"invalid_client\"\n\terrNotFoundName                = \"not_found\"\n\terrInvalidStateName            = \"invalid_state\"\n\terrMisconfigurationName        = \"misconfiguration\"\n\terrInsufficientEntropyName     = \"insufficient_entropy\"\n\terrInvalidTokenFormatName      = \"invalid_token\"\n\terrTokenSignatureMismatchName  = \"token_signature_mismatch\"\n\terrTokenExpiredName            = \"token_expired\"\n\terrScopeNotGrantedName         = \"scope_not_granted\"\n\terrTokenClaimName              = \"token_claim\"\n\terrTokenInactiveName           = \"token_inactive\"\n\t// errAuthorizationCodeInactiveName = \"authorization_code_inactive\"\n\terrUnknownErrorName             = \"error\"\n\terrRevocationClientMismatchName = \"revocation_client_mismatch\"\n\terrRequestNotSupportedName      = \"request_not_supported\"\n\terrRequestURINotSupportedName   = \"request_uri_not_supported\"\n\terrRegistrationNotSupportedName = \"registration_not_supported\"\n\terrJTIKnownName                 = \"jti_known\"\n)\n\nfunc ErrorToRFC6749Error(err error) *RFC6749Error {\n\tvar e *RFC6749Error\n\tif errors.As(err, &e) {\n\t\treturn e\n\t}\n\treturn &RFC6749Error{\n\t\tName:        errUnknownErrorName,\n\t\tDescription: \"The error is unrecognizable.\",\n\t\tDebug:       err.Error(),\n\t\tCode:        http.StatusInternalServerError,\n\t\tcause:       err,\n\t}\n}\n\ntype RFC6749Error struct {\n\tName        string\n\tDescription string\n\tHint        string\n\tCode        int\n\tDebug       string\n\tcause       error\n}\n\nfunc (e *RFC6749Error) Status() string {\n\treturn http.StatusText(e.Code)\n}\n\nfunc (e *RFC6749Error) Error() string {\n\treturn e.Name\n}\n\nfunc (e *RFC6749Error) RequestID() string {\n\treturn \"\"\n}\n\nfunc (e *RFC6749Error) Reason() string {\n\treturn e.Hint\n}\n\nfunc (e *RFC6749Error) StatusCode() int {\n\treturn e.Code\n}\n\nfunc (e *RFC6749Error) Cause() error {\n\treturn e.cause\n}\n\nfunc (e *RFC6749Error) Unwrap() error {\n\treturn e.cause\n}\n\nfunc (e *RFC6749Error) WithHintf(hint string, args ...interface{}) *RFC6749Error {\n\treturn e.WithHint(fmt.Sprintf(hint, args...))\n}\n\nfunc (e *RFC6749Error) WithHint(hint string) *RFC6749Error {\n\terr := *e\n\terr.Hint = hint\n\treturn &err\n}\n\nfunc (e *RFC6749Error) WithDebug(debug string) *RFC6749Error {\n\terr := *e\n\terr.Debug = debug\n\treturn &err\n}\n\nfunc (e *RFC6749Error) WithDebugf(debug string, args ...interface{}) *RFC6749Error {\n\treturn e.WithDebug(fmt.Sprintf(debug, args...))\n}\n\nfunc (e *RFC6749Error) WithDescription(description string) *RFC6749Error {\n\terr := *e\n\terr.Description = description\n\treturn &err\n}\n\nfunc (e *RFC6749Error) WithCause(cause error) *RFC6749Error {\n\terr := *e\n\terr.cause = cause\n\treturn &err\n}\n\nfunc (e *RFC6749Error) Sanitize() *RFC6749Error {\n\terr := *e\n\terr.Debug = \"\"\n\treturn &err\n}\n\n// GetDescription returns a more description description, combined with hint and debug (when available).\nfunc (e *RFC6749Error) GetDescription() string {\n\tdescription := e.Description\n\tif e.Hint != \"\" {\n\t\tdescription += \"\\n\\n\" + e.Hint\n\t}\n\tif e.Debug != \"\" {\n\t\tdescription += \"\\n\\n\" + e.Debug\n\t}\n\treturn description\n}\n\n// Is returns true if the target error is equal to the current error. Used by errors.Is.\nfunc (e *RFC6749Error) Is(target error) bool {\n\treturn e.Error() == target.Error()\n}\n\n// RFC6749ErrorJson is a helper struct for JSON encoding/decoding of RFC6749Error.\ntype RFC6749ErrorJson struct {\n\tName        string `json:\"error\"`\n\tVerbose     string `json:\"error_verbose\"`\n\tDescription string `json:\"error_description\"`\n\tHint        string `json:\"error_hint,omitempty\"`\n\tCode        int    `json:\"status_code,omitempty\"`\n\tDebug       string `json:\"error_debug,omitempty\"`\n}\n\nfunc (e *RFC6749Error) UnmarshalJSON(b []byte) error {\n\tvar data RFC6749ErrorJson\n\n\tif err := json.Unmarshal(b, &data); err != nil {\n\t\treturn err\n\t}\n\n\te.Name = data.Name\n\te.Description = data.Verbose\n\te.Hint = data.Hint\n\te.Code = data.Code\n\te.Debug = data.Debug\n\n\treturn nil\n}\n\nfunc (e RFC6749Error) MarshalJSON() ([]byte, error) {\n\tdata := RFC6749ErrorJson{\n\t\tName:        e.Name,\n\t\tVerbose:     e.Description,\n\t\tDescription: e.GetDescription(),\n\t\tHint:        e.Hint,\n\t\tCode:        e.Code,\n\t\tDebug:       e.Debug,\n\t}\n\treturn json.Marshal(data)\n}\n\nfunc (e *RFC6749Error) ToValues() url.Values {\n\tvalues := url.Values{}\n\tvalues.Add(\"error\", e.Name)\n\tvalues.Add(\"error_description\", e.GetDescription())\n\tif e.Hint != \"\" {\n\t\tvalues.Add(\"error_hint\", e.Hint)\n\t}\n\tif e.Debug != \"\" {\n\t\tvalues.Add(\"error_debug\", e.Debug)\n\t}\n\treturn values\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"testing\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIs(t *testing.T) {\n\tassert.True(t, errors.Is(ErrUnknownRequest, ErrUnknownRequest))\n\tassert.True(t, errors.Is(ErrUnknownRequest, &RFC6749Error{\n\t\tName: errUnknownErrorName,\n\t}))\n\tassert.True(t, errors.Is(&RFC6749Error{\n\t\tName: errUnknownErrorName,\n\t}, ErrUnknownRequest))\n}\n", "// +build tools\n\npackage fosite\n\nimport (\n\t_ \"github.com/gorilla/websocket\"\n\t_ \"github.com/mattn/goveralls\"\n\n\t_ \"github.com/ory/go-acc\"\n)\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage oauth2\n\nimport (\n\t\"context\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/ory/fosite\"\n)\n\ntype TokenRevocationHandler struct {\n\tTokenRevocationStorage TokenRevocationStorage\n\tRefreshTokenStrategy   RefreshTokenStrategy\n\tAccessTokenStrategy    AccessTokenStrategy\n}\n\n// RevokeToken implements https://tools.ietf.org/html/rfc7009#section-2.1\n// The token type hint indicates which token type check should be performed first.\nfunc (r *TokenRevocationHandler) RevokeToken(ctx context.Context, token string, tokenType fosite.TokenType, client fosite.Client) error {\n\tdiscoveryFuncs := []func() (request fosite.Requester, err error){\n\t\tfunc() (request fosite.Requester, err error) {\n\t\t\t// Refresh token\n\t\t\tsignature := r.RefreshTokenStrategy.RefreshTokenSignature(token)\n\t\t\treturn r.TokenRevocationStorage.GetRefreshTokenSession(ctx, signature, nil)\n\t\t},\n\t\tfunc() (request fosite.Requester, err error) {\n\t\t\t// Access token\n\t\t\tsignature := r.AccessTokenStrategy.AccessTokenSignature(token)\n\t\t\treturn r.TokenRevocationStorage.GetAccessTokenSession(ctx, signature, nil)\n\t\t},\n\t}\n\n\t// Token type hinting\n\tif tokenType == fosite.AccessToken {\n\t\tdiscoveryFuncs[0], discoveryFuncs[1] = discoveryFuncs[1], discoveryFuncs[0]\n\t}\n\n\tvar ar fosite.Requester\n\tvar err1, err2 error\n\tif ar, err1 = discoveryFuncs[0](); err1 != nil {\n\t\tar, err2 = discoveryFuncs[1]()\n\t}\n\t// err2 can only be not nil if first err1 was not nil\n\tif err2 != nil {\n\t\treturn storeErrorsToRevocationError(err1, err2)\n\t}\n\n\tif ar.GetClient().GetID() != client.GetID() {\n\t\treturn errors.WithStack(fosite.ErrUnauthorizedClient)\n\t}\n\n\trequestID := ar.GetID()\n\terr1 = r.TokenRevocationStorage.RevokeRefreshToken(ctx, requestID)\n\terr2 = r.TokenRevocationStorage.RevokeAccessToken(ctx, requestID)\n\n\treturn storeErrorsToRevocationError(err1, err2)\n}\n\nfunc storeErrorsToRevocationError(err1, err2 error) error {\n\t// both errors are 404 or nil <=> the token is revoked\n\tif (errors.Is(err1, fosite.ErrNotFound) || err1 == nil) && (errors.Is(err2, fosite.ErrNotFound) || err2 == nil) {\n\t\treturn nil\n\t}\n\n\t// there was an unexpected error => the token may still exist and the client should retry later\n\treturn errors.WithStack(fosite.ErrTemporarilyUnavailable)\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage oauth2\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/golang/mock/gomock\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/ory/fosite\"\n\t\"github.com/ory/fosite/internal\"\n)\n\nfunc TestRevokeToken(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tstore := internal.NewMockTokenRevocationStorage(ctrl)\n\tatStrat := internal.NewMockAccessTokenStrategy(ctrl)\n\trtStrat := internal.NewMockRefreshTokenStrategy(ctrl)\n\tar := internal.NewMockAccessRequester(ctrl)\n\tdefer ctrl.Finish()\n\n\th := TokenRevocationHandler{\n\t\tTokenRevocationStorage: store,\n\t\tRefreshTokenStrategy:   rtStrat,\n\t\tAccessTokenStrategy:    atStrat,\n\t}\n\n\tvar token string\n\tvar tokenType fosite.TokenType\n\n\tfor k, c := range []struct {\n\t\tdescription string\n\t\tmock        func()\n\t\texpectErr   error\n\t\tclient      fosite.Client\n\t}{\n\t\t{\n\t\t\tdescription: \"should fail - token was issued to another client\",\n\t\t\texpectErr:   fosite.ErrUnauthorizedClient,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.RefreshToken\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"foo\"})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should pass - refresh token discovery first; refresh token found\",\n\t\t\texpectErr:   nil,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.RefreshToken\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n\t\t\t\tar.EXPECT().GetID()\n\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"bar\"})\n\t\t\t\tstore.EXPECT().RevokeRefreshToken(gomock.Any(), gomock.Any())\n\t\t\t\tstore.EXPECT().RevokeAccessToken(gomock.Any(), gomock.Any())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should pass - access token discovery first; access token found\",\n\t\t\texpectErr:   nil,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.AccessToken\n\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n\t\t\t\tar.EXPECT().GetID()\n\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"bar\"})\n\t\t\t\tstore.EXPECT().RevokeRefreshToken(gomock.Any(), gomock.Any())\n\t\t\t\tstore.EXPECT().RevokeAccessToken(gomock.Any(), gomock.Any())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should pass - refresh token discovery first; refresh token not found\",\n\t\t\texpectErr:   nil,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.AccessToken\n\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n\t\t\t\tar.EXPECT().GetID()\n\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"bar\"})\n\t\t\t\tstore.EXPECT().RevokeRefreshToken(gomock.Any(), gomock.Any())\n\t\t\t\tstore.EXPECT().RevokeAccessToken(gomock.Any(), gomock.Any())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should pass - access token discovery first; access token not found\",\n\t\t\texpectErr:   nil,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.RefreshToken\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\n\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n\t\t\t\tar.EXPECT().GetID()\n\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"bar\"})\n\t\t\t\tstore.EXPECT().RevokeRefreshToken(gomock.Any(), gomock.Any())\n\t\t\t\tstore.EXPECT().RevokeAccessToken(gomock.Any(), gomock.Any())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should pass - refresh token discovery first; both tokens not found\",\n\t\t\texpectErr:   nil,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.RefreshToken\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\n\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should pass - access token discovery first; both tokens not found\",\n\t\t\texpectErr:   nil,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.AccessToken\n\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should fail - store error for access token get\",\n\t\t\texpectErr:   fosite.ErrTemporarilyUnavailable,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.AccessToken\n\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fmt.Errorf(\"random error\"))\n\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should fail - store error for refresh token get\",\n\t\t\texpectErr:   fosite.ErrTemporarilyUnavailable,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.RefreshToken\n\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fosite.ErrNotFound)\n\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, fmt.Errorf(\"random error\"))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should fail - store error for access token revoke\",\n\t\t\texpectErr:   fosite.ErrTemporarilyUnavailable,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.AccessToken\n\t\t\t\tatStrat.EXPECT().AccessTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetAccessTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n\n\t\t\t\tar.EXPECT().GetID()\n\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"bar\"})\n\t\t\t\tstore.EXPECT().RevokeRefreshToken(gomock.Any(), gomock.Any()).Return(fosite.ErrNotFound)\n\t\t\t\tstore.EXPECT().RevokeAccessToken(gomock.Any(), gomock.Any()).Return(fmt.Errorf(\"random error\"))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"should fail - store error for refresh token revoke\",\n\t\t\texpectErr:   fosite.ErrTemporarilyUnavailable,\n\t\t\tclient:      &fosite.DefaultClient{ID: \"bar\"},\n\t\t\tmock: func() {\n\t\t\t\ttoken = \"foo\"\n\t\t\t\ttokenType = fosite.RefreshToken\n\t\t\t\trtStrat.EXPECT().RefreshTokenSignature(token)\n\t\t\t\tstore.EXPECT().GetRefreshTokenSession(gomock.Any(), gomock.Any(), gomock.Any()).Return(ar, nil)\n\n\t\t\t\tar.EXPECT().GetID()\n\t\t\t\tar.EXPECT().GetClient().Return(&fosite.DefaultClient{ID: \"bar\"})\n\t\t\t\tstore.EXPECT().RevokeRefreshToken(gomock.Any(), gomock.Any()).Return(fmt.Errorf(\"random error\"))\n\t\t\t\tstore.EXPECT().RevokeAccessToken(gomock.Any(), gomock.Any()).Return(fosite.ErrNotFound)\n\t\t\t},\n\t\t},\n\t} {\n\t\tt.Run(fmt.Sprintf(\"case=%d/description=%s\", k, c.description), func(t *testing.T) {\n\t\t\tc.mock()\n\t\t\terr := h.RevokeToken(nil, token, tokenType, c.client)\n\n\t\t\tif c.expectErr != nil {\n\t\t\t\trequire.EqualError(t, err, c.expectErr.Error())\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage openid\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\n\t\"github.com/ory/fosite\"\n)\n\ntype IDTokenHandleHelper struct {\n\tIDTokenStrategy OpenIDConnectTokenStrategy\n}\n\nfunc (i *IDTokenHandleHelper) GetAccessTokenHash(ctx context.Context, requester fosite.AccessRequester, responder fosite.AccessResponder) string {\n\ttoken := responder.GetAccessToken()\n\n\tbuffer := bytes.NewBufferString(token)\n\thash := sha256.New()\n\t// sha256.digest.Write() always returns nil for err, the panic should never happen\n\t_, err := hash.Write(buffer.Bytes())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\thashBuf := bytes.NewBuffer(hash.Sum([]byte{}))\n\tlen := hashBuf.Len()\n\n\treturn base64.RawURLEncoding.EncodeToString(hashBuf.Bytes()[:len/2])\n}\n\nfunc (i *IDTokenHandleHelper) generateIDToken(ctx context.Context, fosr fosite.Requester) (token string, err error) {\n\ttoken, err = i.IDTokenStrategy.GenerateIDToken(ctx, fosr)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn token, nil\n}\n\nfunc (i *IDTokenHandleHelper) IssueImplicitIDToken(ctx context.Context, ar fosite.Requester, resp fosite.AuthorizeResponder) error {\n\ttoken, err := i.generateIDToken(ctx, ar)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp.AddFragment(\"id_token\", token)\n\treturn nil\n}\n\nfunc (i *IDTokenHandleHelper) IssueExplicitIDToken(ctx context.Context, ar fosite.Requester, resp fosite.AccessResponder) error {\n\ttoken, err := i.generateIDToken(ctx, ar)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp.SetExtra(\"id_token\", token)\n\treturn nil\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/pkg/errors\"\n)\n\n// NewRevocationRequest handles incoming token revocation requests and\n// validates various parameters as specified in:\n// https://tools.ietf.org/html/rfc7009#section-2.1\n//\n// The authorization server first validates the client credentials (in\n// case of a confidential client) and then verifies whether the token\n// was issued to the client making the revocation request.  If this\n// validation fails, the request is refused and the client is informed\n// of the error by the authorization server as described below.\n//\n// In the next step, the authorization server invalidates the token.\n// The invalidation takes place immediately, and the token cannot be\n// used again after the revocation.\n//\n// * https://tools.ietf.org/html/rfc7009#section-2.2\n// An invalid token type hint value is ignored by the authorization\n// server and does not influence the revocation response.\nfunc (f *Fosite) NewRevocationRequest(ctx context.Context, r *http.Request) error {\n\tif r.Method != \"POST\" {\n\t\treturn errors.WithStack(ErrInvalidRequest.WithHintf(\"HTTP method is \\\"%s\\\", expected \\\"POST\\\".\", r.Method))\n\t} else if err := r.ParseMultipartForm(1 << 20); err != nil && err != http.ErrNotMultipart {\n\t\treturn errors.WithStack(ErrInvalidRequest.WithHint(\"Unable to parse HTTP body, make sure to send a properly formatted form request body.\").WithCause(err).WithDebug(err.Error()))\n\t} else if len(r.PostForm) == 0 {\n\t\treturn errors.WithStack(ErrInvalidRequest.WithHint(\"The POST body can not be empty.\"))\n\t}\n\n\tclient, err := f.AuthenticateClient(ctx, r, r.PostForm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttoken := r.PostForm.Get(\"token\")\n\ttokenTypeHint := TokenType(r.PostForm.Get(\"token_type_hint\"))\n\n\tvar found = false\n\tfor _, loader := range f.RevocationHandlers {\n\t\tif err := loader.RevokeToken(ctx, token, tokenTypeHint, client); err == nil {\n\t\t\tfound = true\n\t\t} else if errors.Is(err, ErrUnknownRequest) {\n\t\t\t// do nothing\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif !found {\n\t\treturn errors.WithStack(ErrInvalidRequest)\n\t}\n\n\treturn nil\n}\n\n// WriteRevocationResponse writes a token revocation response as specified in:\n// https://tools.ietf.org/html/rfc7009#section-2.2\n//\n// The authorization server responds with HTTP status code 200 if the\n// token has been revoked successfully or if the client submitted an\n// invalid token.\n//\n// Note: invalid tokens do not cause an error response since the client\n// cannot handle such an error in a reasonable way.  Moreover, the\n// purpose of the revocation request, invalidating the particular token,\n// is already achieved.\nfunc (f *Fosite) WriteRevocationResponse(rw http.ResponseWriter, err error) {\n\trw.Header().Set(\"Cache-Control\", \"no-store\")\n\trw.Header().Set(\"Pragma\", \"no-cache\")\n\n\tif err == nil {\n\t\trw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\n\tif errors.Is(err, ErrInvalidRequest) {\n\t\trw.Header().Set(\"Content-Type\", \"application/json;charset=UTF-8\")\n\n\t\tjs, err := json.Marshal(ErrInvalidRequest)\n\t\tif err != nil {\n\t\t\thttp.Error(rw, fmt.Sprintf(`{\"error\": \"%s\"}`, err.Error()), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\trw.WriteHeader(ErrInvalidRequest.Code)\n\t\t_, _ = rw.Write(js)\n\t} else if errors.Is(err, ErrInvalidClient) {\n\t\trw.Header().Set(\"Content-Type\", \"application/json;charset=UTF-8\")\n\n\t\tjs, err := json.Marshal(ErrInvalidClient)\n\t\tif err != nil {\n\t\t\thttp.Error(rw, fmt.Sprintf(`{\"error\": \"%s\"}`, err.Error()), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\trw.WriteHeader(ErrInvalidClient.Code)\n\t\t_, _ = rw.Write(js)\n\t} else {\n\t\t// 200 OK\n\t\trw.WriteHeader(http.StatusOK)\n\t}\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\n// Package hmac is the default implementation for generating and validating challenges. It uses HMAC-SHA256 to\n// generate and validate challenges.\n\npackage hmac\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha512\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/ory/fosite\"\n)\n\n// HMACStrategy is responsible for generating and validating challenges.\ntype HMACStrategy struct {\n\tTokenEntropy         int\n\tGlobalSecret         []byte\n\tRotatedGlobalSecrets [][]byte\n\tsync.Mutex\n}\n\nconst (\n\t// key should be at least 256 bit long, making it\n\tminimumEntropy = 32\n\n\t// the secrets (client and global) should each have at least 16 characters making it harder to guess them\n\tminimumSecretLength = 32\n)\n\nvar b64 = base64.URLEncoding.WithPadding(base64.NoPadding)\n\n// Generate generates a token and a matching signature or returns an error.\n// This method implements rfc6819 Section 5.1.4.2.2: Use High Entropy for Secrets.\nfunc (c *HMACStrategy) Generate() (string, string, error) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tif len(c.GlobalSecret) < minimumSecretLength {\n\t\treturn \"\", \"\", errors.Errorf(\"secret for signing HMAC-SHA256 is expected to be 32 byte long, got %d byte\", len(c.GlobalSecret))\n\t}\n\n\tvar signingKey [32]byte\n\tcopy(signingKey[:], c.GlobalSecret)\n\n\tif c.TokenEntropy < minimumEntropy {\n\t\tc.TokenEntropy = minimumEntropy\n\t}\n\n\t// When creating secrets not intended for usage by human users (e.g.,\n\t// client secrets or token handles), the authorization server should\n\t// include a reasonable level of entropy in order to mitigate the risk\n\t// of guessing attacks.  The token value should be >=128 bits long and\n\t// constructed from a cryptographically strong random or pseudo-random\n\t// number sequence (see [RFC4086] for best current practice) generated\n\t// by the authorization server.\n\ttokenKey, err := RandomBytes(c.TokenEntropy)\n\tif err != nil {\n\t\treturn \"\", \"\", errors.WithStack(err)\n\t}\n\n\tsignature := generateHMAC(tokenKey, &signingKey)\n\n\tencodedSignature := b64.EncodeToString(signature)\n\tencodedToken := fmt.Sprintf(\"%s.%s\", b64.EncodeToString(tokenKey), encodedSignature)\n\treturn encodedToken, encodedSignature, nil\n}\n\n// Validate validates a token and returns its signature or an error if the token is not valid.\nfunc (c *HMACStrategy) Validate(token string) (err error) {\n\tvar keys [][]byte\n\n\tif len(c.GlobalSecret) > 0 {\n\t\tkeys = append(keys, c.GlobalSecret)\n\t}\n\n\tif len(c.RotatedGlobalSecrets) > 0 {\n\t\tkeys = append(keys, c.RotatedGlobalSecrets...)\n\t}\n\n\tfor _, key := range keys {\n\t\tif err = c.validate(key, token); err == nil {\n\t\t\treturn nil\n\t\t} else if errors.Is(err, fosite.ErrTokenSignatureMismatch) {\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err == nil {\n\t\treturn errors.New(\"a secret for signing HMAC-SHA256 is expected to be defined, but none were\")\n\t}\n\n\treturn err\n}\n\nfunc (c *HMACStrategy) validate(secret []byte, token string) error {\n\tif len(secret) < minimumSecretLength {\n\t\treturn errors.Errorf(\"secret for signing HMAC-SHA256 is expected to be 32 byte long, got %d byte\", len(secret))\n\t}\n\n\tvar signingKey [32]byte\n\tcopy(signingKey[:], secret)\n\n\tsplit := strings.Split(token, \".\")\n\tif len(split) != 2 {\n\t\treturn errors.WithStack(fosite.ErrInvalidTokenFormat)\n\t}\n\n\ttokenKey := split[0]\n\ttokenSignature := split[1]\n\tif tokenKey == \"\" || tokenSignature == \"\" {\n\t\treturn errors.WithStack(fosite.ErrInvalidTokenFormat)\n\t}\n\n\tdecodedTokenSignature, err := b64.DecodeString(tokenSignature)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tdecodedTokenKey, err := b64.DecodeString(tokenKey)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\texpectedMAC := generateHMAC(decodedTokenKey, &signingKey)\n\tif !hmac.Equal(expectedMAC, decodedTokenSignature) {\n\t\t// Hash is invalid\n\t\treturn errors.WithStack(fosite.ErrTokenSignatureMismatch)\n\t}\n\n\treturn nil\n}\n\nfunc (c *HMACStrategy) Signature(token string) string {\n\tsplit := strings.Split(token, \".\")\n\n\tif len(split) != 2 {\n\t\treturn \"\"\n\t}\n\n\treturn split[1]\n}\n\nfunc generateHMAC(data []byte, key *[32]byte) []byte {\n\th := hmac.New(sha512.New512_256, key[:])\n\t// sha512.digest.Write() always returns nil for err, the panic should never happen\n\t_, err := h.Write(data)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn h.Sum(nil)\n}\n"], "filenames": [".golangci.yml", "access_error.go", "access_write.go", "authorize_error.go", "errors.go", "errors_test.go", "go_mod_indirect_pins.go", "handler/oauth2/revocation.go", "handler/oauth2/revocation_test.go", "handler/openid/helper.go", "revoke_handler.go", "token/hmac/hmacsha.go"], "buggy_code_start_loc": [9, 56, 42, 56, 165, 31, 7, 60, 60, 42, 115, 172], "buggy_code_end_loc": [10, 57, 43, 57, 170, 38, 7, 77, 166, 43, 127, 173], "fixing_code_start_loc": [8, 56, 42, 56, 164, 30, 8, 60, 60, 42, 115, 172], "fixing_code_end_loc": [8, 58, 43, 57, 164, 30, 9, 89, 226, 47, 127, 177], "type": "CWE-754", "message": "In ORY Fosite (the security first OAuth2 & OpenID Connect framework for Go) before version 0.34.0, the `TokenRevocationHandler` ignores errors coming from the storage. This can lead to unexpected 200 status codes indicating successful revocation while the token is still valid. Whether an attacker can use this for her advantage depends on the ability to trigger errors in the store. This is fixed in version 0.34.0", "other": {"cve": {"id": "CVE-2020-15223", "sourceIdentifier": "security-advisories@github.com", "published": "2020-09-24T17:15:13.210", "lastModified": "2022-10-21T18:09:36.827", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In ORY Fosite (the security first OAuth2 & OpenID Connect framework for Go) before version 0.34.0, the `TokenRevocationHandler` ignores errors coming from the storage. This can lead to unexpected 200 status codes indicating successful revocation while the token is still valid. Whether an attacker can use this for her advantage depends on the ability to trigger errors in the store. This is fixed in version 0.34.0"}, {"lang": "es", "value": "En ORY Fosite (el primer framework de seguridad OAuth2 &amp; OpenID Connect para Go) anterior a la versi\u00f3n 0.34.0, el \"TokenRevocationHandler\" ignora los errores provenientes del almacenamiento.&#xa0;Esto puede conllevar a 200 c\u00f3digos de estado no previstos que indican una revocaci\u00f3n exitosa mientras el token a\u00fan es v\u00e1lido.&#xa0;Si un atacante puede usar esto para su favor depende de la capacidad de desencadenar errores en la tienda.&#xa0;Esto se corrigi\u00f3 en la versi\u00f3n 0.34.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.8}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-754"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ory:fosite:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.34.0", "matchCriteriaId": "80E07C30-E0A1-456A-B3E8-A0015EB05A66"}]}]}], "references": [{"url": "https://github.com/ory/fosite/commit/03dd55813f5521985f7dd64277b7ba0cf1441319", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ory/fosite/security/advisories/GHSA-7mqr-2v3q-v2wm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://tools.ietf.org/html/rfc7009#section-2.2.1", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ory/fosite/commit/03dd55813f5521985f7dd64277b7ba0cf1441319"}}