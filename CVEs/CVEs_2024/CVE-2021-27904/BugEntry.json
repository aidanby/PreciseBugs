{"buggy_code": ["<?php\nApp::uses('AppModel', 'Model');\n\nclass SharingGroupServer extends AppModel\n{\n    public $actsAs = array('Containable');\n\n    public $belongsTo = array(\n        'SharingGroup' => array(\n            'className' => 'SharingGroup',\n            'foreignKey' => 'sharing_group_id'\n        ),\n        'Server' => array(\n                'className' => 'Server',\n                'foreignKey' => 'server_id',\n                //'conditions' => array('SharingGroupElement.organisation_uuid' => 'Organisation.uuid')\n        )\n    );\n\n    public function beforeValidate($options = array())\n    {\n        parent::beforeValidate();\n    }\n\n\n    public function updateServersForSG($id, $new_servers, $old_servers, $roaming, $user)\n    {\n        $log = ClassRegistry::init('Log');\n        // Check first if we need to handle the servers at all, or if we should just delete all servers from the SG (depending on the checkbox in the \"MISP instances\" tab).\n        if (!$roaming) {\n            foreach ($new_servers as $server) {\n                $SgS = array(\n                        'sharing_group_id' => $id,\n                        'server_id' => $server['id'],\n                        'all_orgs' => $server['all_orgs']\n                );\n                $server_name = 'server (' . $server['id'] . ')';\n                if ($server['id'] == 0) {\n                    $server_name = 'the local server';\n                }\n\n                $found = false;\n                // If there is a match between a new server and an old server, keep the server in $found and unset it in the old server array.\n                foreach ($old_servers as $k => $old_server) {\n                    if ($old_server['server_id'] == $server['id']) {\n                        $found = $old_servers[$k];\n                        unset($old_servers[$k]);\n                        break;\n                    }\n                }\n\n                // If we have not found the server previously, create a new sharing group server object.\n                // Otherwise, if we have found it check whether the extended field has been altered, if not just continue without saving\n                if (!$found) {\n                    $this->create();\n                    $isChange = false;\n                } else {\n                    if ($found['all_orgs'] == $SgS['all_orgs']) {\n                        continue;\n                    }\n                    $isChange = true;\n                    $SgS['id'] = $found['id'];\n                }\n                $this->save($SgS);\n                if ($this->save($SgS)) {\n                    $log->create();\n                    if ($isChange) {\n                        $log->createLogEntry($user, 'edit', 'SharingGroupServer', $this->id, 'Sharing group (' . $id . '): Modified access rights for users on ' . $server_name . '.', ($server['all_orgs'] ? 'All organisations on server ' . $server['id'] . ' are now part of the sharing group.' : 'Organisations on ' . $server_name . ' are now not part of the sharing group unless they are present in the list of organisations.'));\n                    } else {\n                        $log->createLogEntry($user, 'add', 'SharingGroupServer', $this->id, 'Sharing group (' . $id . '): Added server (' . $server['id'] . ').', ucfirst($server_name) . ' added to Sharing group.' . ($server['all_orgs'] ? ' Sharing group visible to all organisations on the server.' : ''));\n                    }\n                }\n            }\n            // We are left with some \"old orgs\" that are not in the new list. This means that they can be safely deleted.\n            foreach ($old_servers as $old_server) {\n                if ($this->SharingGroup->SharingGroupServer->delete($old_server['id'])) {\n                    $log->create();\n                    $log->createLogEntry($user, 'delete', 'SharingGroupServer', $old_server['id'], 'Sharing group (' . $id . '): Removed server(' . $old_server['server_id'] . ').', 'Server (' . $old_server['server_id'] . ') removed from Sharing group.');\n                }\n            }\n        } else {\n            $this->deleteAll(array('sharing_group_id' => $id), false);\n        }\n    }\n\n    // returns all sharing group IDs that have the local server (server_id = 0) as a server object with all orgs turned to 1\n    // This basically lists all SGs that allow everyone on the instance to see events tagged with it\n    public function fetchAllAuthorised()\n    {\n        $sgs = $this->find('column', array(\n            'conditions' => array('all_orgs' => 1, 'server_id' => 0),\n            'fields' => array('SharingGroupServer.sharing_group_id'),\n        ));\n        return $sgs;\n    }\n\n    // pass a sharing group ID, returns true if it has an attached server object with \"all_orgs\" ticked\n    public function checkIfAuthorised($id)\n    {\n        $sg = $this->find('first', array(\n                'conditions' => array('sharing_group_id' => $id, 'all_orgs' => 1),\n                'recursive' => -1,\n                'fields' => array('id'),\n        ));\n        if (!empty($sg)) {\n            return true;\n        }\n        return false;\n    }\n}\n"], "fixing_code": ["<?php\nApp::uses('AppModel', 'Model');\n\nclass SharingGroupServer extends AppModel\n{\n    public $actsAs = array('Containable');\n\n    public $belongsTo = array(\n        'SharingGroup' => array(\n            'className' => 'SharingGroup',\n            'foreignKey' => 'sharing_group_id'\n        ),\n        'Server' => array(\n                'className' => 'Server',\n                'foreignKey' => 'server_id',\n                //'conditions' => array('SharingGroupElement.organisation_uuid' => 'Organisation.uuid')\n        )\n    );\n\n    public function beforeValidate($options = array())\n    {\n        parent::beforeValidate();\n    }\n\n\n    public function updateServersForSG($id, $new_servers, $old_servers, $roaming, $user)\n    {\n        $log = ClassRegistry::init('Log');\n        // Check first if we need to handle the servers at all, or if we should just delete all servers from the SG (depending on the checkbox in the \"MISP instances\" tab).\n        if (!$roaming) {\n            foreach ($new_servers as $server) {\n                $SgS = array(\n                        'sharing_group_id' => $id,\n                        'server_id' => $server['id'],\n                        'all_orgs' => $server['all_orgs']\n                );\n                $server_name = 'server (' . $server['id'] . ')';\n                if ($server['id'] == 0) {\n                    $server_name = 'the local server';\n                }\n\n                $found = false;\n                // If there is a match between a new server and an old server, keep the server in $found and unset it in the old server array.\n                foreach ($old_servers as $k => $old_server) {\n                    if ($old_server['server_id'] == $server['id']) {\n                        $found = $old_servers[$k];\n                        unset($old_servers[$k]);\n                        break;\n                    }\n                }\n\n                // If we have not found the server previously, create a new sharing group server object.\n                // Otherwise, if we have found it check whether the extended field has been altered, if not just continue without saving\n                if (!$found) {\n                    $this->create();\n                    $isChange = false;\n                } else {\n                    if ($found['all_orgs'] == $SgS['all_orgs']) {\n                        continue;\n                    }\n                    $isChange = true;\n                    $SgS['id'] = $found['id'];\n                }\n                $this->save($SgS);\n                if ($this->save($SgS)) {\n                    $log->create();\n                    if ($isChange) {\n                        $log->createLogEntry($user, 'edit', 'SharingGroupServer', $this->id, 'Sharing group (' . $id . '): Modified access rights for users on ' . $server_name . '.', ($server['all_orgs'] ? 'All organisations on server ' . $server['id'] . ' are now part of the sharing group.' : 'Organisations on ' . $server_name . ' are now not part of the sharing group unless they are present in the list of organisations.'));\n                    } else {\n                        $log->createLogEntry($user, 'add', 'SharingGroupServer', $this->id, 'Sharing group (' . $id . '): Added server (' . $server['id'] . ').', ucfirst($server_name) . ' added to Sharing group.' . ($server['all_orgs'] ? ' Sharing group visible to all organisations on the server.' : ''));\n                    }\n                }\n            }\n            // We are left with some \"old orgs\" that are not in the new list. This means that they can be safely deleted.\n            foreach ($old_servers as $old_server) {\n                if ($this->SharingGroup->SharingGroupServer->delete($old_server['id'])) {\n                    $log->create();\n                    $log->createLogEntry($user, 'delete', 'SharingGroupServer', $old_server['id'], 'Sharing group (' . $id . '): Removed server(' . $old_server['server_id'] . ').', 'Server (' . $old_server['server_id'] . ') removed from Sharing group.');\n                }\n            }\n        } else {\n            $this->deleteAll(array('sharing_group_id' => $id), false);\n        }\n    }\n\n    // returns all sharing group IDs that have the local server (server_id = 0) as a server object with all orgs turned to 1\n    // This basically lists all SGs that allow everyone on the instance to see events tagged with it\n    public function fetchAllAuthorised()\n    {\n        $sgs = $this->find('column', array(\n            'conditions' => array('all_orgs' => 1, 'server_id' => 0),\n            'fields' => array('SharingGroupServer.sharing_group_id'),\n        ));\n        return $sgs;\n    }\n\n    // pass a sharing group ID, returns true if it has an attached server object with \"all_orgs\" ticked\n    public function checkIfAuthorised($id)\n    {\n        $sg = $this->find('first', array(\n                'conditions' => array('sharing_group_id' => $id, 'all_orgs' => 1, 'server_id' => 0),\n                'recursive' => -1,\n                'fields' => array('id'),\n        ));\n        if (!empty($sg)) {\n            return true;\n        }\n        return false;\n    }\n}\n"], "filenames": ["app/Model/SharingGroupServer.php"], "buggy_code_start_loc": [101], "buggy_code_end_loc": [102], "fixing_code_start_loc": [101], "fixing_code_end_loc": [102], "type": "NVD-CWE-noinfo", "message": "An issue was discovered in app/Model/SharingGroupServer.php in MISP 2.4.139. In the implementation of Sharing Groups, the \"all org\" flag sometimes provided view access to unintended actors.", "other": {"cve": {"id": "CVE-2021-27904", "sourceIdentifier": "cve@mitre.org", "published": "2021-03-02T07:15:12.760", "lastModified": "2021-03-08T17:27:03.737", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in app/Model/SharingGroupServer.php in MISP 2.4.139. In the implementation of Sharing Groups, the \"all org\" flag sometimes provided view access to unintended actors."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el archivo app/Model/SharingGroupServer.php en MISP versi\u00f3n 2.4.139.&#xa0;En la implementaci\u00f3n de Sharing Groups, el flag \"all org\" algunas veces proporcionaba acceso de visualizaci\u00f3n a actores no deseados"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:misp:misp:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.4.139", "matchCriteriaId": "D2C49507-C086-4DDC-9361-1A6A2DE9753C"}]}]}], "references": [{"url": "https://github.com/MISP/MISP/commit/ca13fee271ad126832c88896776f3050a6c06e64", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/MISP/MISP/commit/ca13fee271ad126832c88896776f3050a6c06e64"}}