{"buggy_code": ["/*\n * Luminary Micro Stellaris Ethernet Controller\n *\n * Copyright (c) 2007 CodeSourcery.\n * Written by Paul Brook\n *\n * This code is licensed under the GPL.\n */\n#include \"hw/sysbus.h\"\n#include \"net/net.h\"\n#include <zlib.h>\n\n//#define DEBUG_STELLARIS_ENET 1\n\n#ifdef DEBUG_STELLARIS_ENET\n#define DPRINTF(fmt, ...) \\\ndo { printf(\"stellaris_enet: \" fmt , ## __VA_ARGS__); } while (0)\n#define BADF(fmt, ...) \\\ndo { fprintf(stderr, \"stellaris_enet: error: \" fmt , ## __VA_ARGS__); exit(1);} while (0)\n#else\n#define DPRINTF(fmt, ...) do {} while(0)\n#define BADF(fmt, ...) \\\ndo { fprintf(stderr, \"stellaris_enet: error: \" fmt , ## __VA_ARGS__);} while (0)\n#endif\n\n#define SE_INT_RX       0x01\n#define SE_INT_TXER     0x02\n#define SE_INT_TXEMP    0x04\n#define SE_INT_FOV      0x08\n#define SE_INT_RXER     0x10\n#define SE_INT_MD       0x20\n#define SE_INT_PHY      0x40\n\n#define SE_RCTL_RXEN    0x01\n#define SE_RCTL_AMUL    0x02\n#define SE_RCTL_PRMS    0x04\n#define SE_RCTL_BADCRC  0x08\n#define SE_RCTL_RSTFIFO 0x10\n\n#define SE_TCTL_TXEN    0x01\n#define SE_TCTL_PADEN   0x02\n#define SE_TCTL_CRC     0x04\n#define SE_TCTL_DUPLEX  0x08\n\n#define TYPE_STELLARIS_ENET \"stellaris_enet\"\n#define STELLARIS_ENET(obj) \\\n    OBJECT_CHECK(stellaris_enet_state, (obj), TYPE_STELLARIS_ENET)\n\ntypedef struct {\n    SysBusDevice parent_obj;\n\n    uint32_t ris;\n    uint32_t im;\n    uint32_t rctl;\n    uint32_t tctl;\n    uint32_t thr;\n    uint32_t mctl;\n    uint32_t mdv;\n    uint32_t mtxd;\n    uint32_t mrxd;\n    uint32_t np;\n    int tx_fifo_len;\n    uint8_t tx_fifo[2048];\n    /* Real hardware has a 2k fifo, which works out to be at most 31 packets.\n       We implement a full 31 packet fifo.  */\n    struct {\n        uint8_t data[2048];\n        int len;\n    } rx[31];\n    int rx_fifo_offset;\n    int next_packet;\n    NICState *nic;\n    NICConf conf;\n    qemu_irq irq;\n    MemoryRegion mmio;\n} stellaris_enet_state;\n\nstatic void stellaris_enet_update(stellaris_enet_state *s)\n{\n    qemu_set_irq(s->irq, (s->ris & s->im) != 0);\n}\n\n/* Return the data length of the packet currently being assembled\n * in the TX fifo.\n */\nstatic inline int stellaris_txpacket_datalen(stellaris_enet_state *s)\n{\n    return s->tx_fifo[0] | (s->tx_fifo[1] << 8);\n}\n\n/* Return true if the packet currently in the TX FIFO is complete,\n* ie the FIFO holds enough bytes for the data length, ethernet header,\n* payload and optionally CRC.\n*/\nstatic inline bool stellaris_txpacket_complete(stellaris_enet_state *s)\n{\n    int framelen = stellaris_txpacket_datalen(s);\n    framelen += 16;\n    if (!(s->tctl & SE_TCTL_CRC)) {\n        framelen += 4;\n    }\n    /* Cover the corner case of a 2032 byte payload with auto-CRC disabled:\n     * this requires more bytes than will fit in the FIFO. It's not totally\n     * clear how the h/w handles this, but if using threshold-based TX\n     * it will definitely try to transmit something.\n     */\n    framelen = MIN(framelen, ARRAY_SIZE(s->tx_fifo));\n    return s->tx_fifo_len >= framelen;\n}\n\n/* Return true if the TX FIFO threshold is enabled and the FIFO\n * has filled enough to reach it.\n */\nstatic inline bool stellaris_tx_thr_reached(stellaris_enet_state *s)\n{\n    return (s->thr < 0x3f &&\n            (s->tx_fifo_len >= 4 * (s->thr * 8 + 1)));\n}\n\n/* Send the packet currently in the TX FIFO */\nstatic void stellaris_enet_send(stellaris_enet_state *s)\n{\n    int framelen = stellaris_txpacket_datalen(s);\n\n    /* Ethernet header is in the FIFO but not in the datacount.\n     * We don't implement explicit CRC, so just ignore any\n     * CRC value in the FIFO.\n     */\n    framelen += 14;\n    if ((s->tctl & SE_TCTL_PADEN) && framelen < 60) {\n        memset(&s->tx_fifo[framelen + 2], 0, 60 - framelen);\n        framelen = 60;\n    }\n    /* This MIN will have no effect unless the FIFO data is corrupt\n     * (eg bad data from an incoming migration); otherwise the check\n     * on the datalen at the start of writing the data into the FIFO\n     * will have caught this. Silently write a corrupt half-packet,\n     * which is what the hardware does in FIFO underrun situations.\n     */\n    framelen = MIN(framelen, ARRAY_SIZE(s->tx_fifo) - 2);\n    qemu_send_packet(qemu_get_queue(s->nic), s->tx_fifo + 2, framelen);\n    s->tx_fifo_len = 0;\n    s->ris |= SE_INT_TXEMP;\n    stellaris_enet_update(s);\n    DPRINTF(\"Done TX\\n\");\n}\n\n/* TODO: Implement MAC address filtering.  */\nstatic ssize_t stellaris_enet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n    int n;\n    uint8_t *p;\n    uint32_t crc;\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n        return -1;\n    if (s->np >= 31) {\n        DPRINTF(\"Packet dropped\\n\");\n        return -1;\n    }\n\n    DPRINTF(\"Received packet len=%zu\\n\", size);\n    n = s->next_packet + s->np;\n    if (n >= 31)\n        n -= 31;\n    s->np++;\n\n    s->rx[n].len = size + 6;\n    p = s->rx[n].data;\n    *(p++) = (size + 6);\n    *(p++) = (size + 6) >> 8;\n    memcpy (p, buf, size);\n    p += size;\n    crc = crc32(~0, buf, size);\n    *(p++) = crc;\n    *(p++) = crc >> 8;\n    *(p++) = crc >> 16;\n    *(p++) = crc >> 24;\n    /* Clear the remaining bytes in the last word.  */\n    if ((size & 3) != 2) {\n        memset(p, 0, (6 - size) & 3);\n    }\n\n    s->ris |= SE_INT_RX;\n    stellaris_enet_update(s);\n\n    return size;\n}\n\nstatic int stellaris_enet_can_receive(NetClientState *nc)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n        return 1;\n\n    return (s->np < 31);\n}\n\nstatic uint64_t stellaris_enet_read(void *opaque, hwaddr offset,\n                                    unsigned size)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    uint32_t val;\n\n    switch (offset) {\n    case 0x00: /* RIS */\n        DPRINTF(\"IRQ status %02x\\n\", s->ris);\n        return s->ris;\n    case 0x04: /* IM */\n        return s->im;\n    case 0x08: /* RCTL */\n        return s->rctl;\n    case 0x0c: /* TCTL */\n        return s->tctl;\n    case 0x10: /* DATA */\n    {\n        uint8_t *rx_fifo;\n\n        if (s->np == 0) {\n            BADF(\"RX underflow\\n\");\n            return 0;\n        }\n\n        rx_fifo = s->rx[s->next_packet].data + s->rx_fifo_offset;\n\n        val = rx_fifo[0] | (rx_fifo[1] << 8) | (rx_fifo[2] << 16)\n              | (rx_fifo[3] << 24);\n        s->rx_fifo_offset += 4;\n        if (s->rx_fifo_offset >= s->rx[s->next_packet].len) {\n            s->rx_fifo_offset = 0;\n            s->next_packet++;\n            if (s->next_packet >= 31)\n                s->next_packet = 0;\n            s->np--;\n            DPRINTF(\"RX done np=%d\\n\", s->np);\n        }\n        return val;\n    }\n    case 0x14: /* IA0 */\n        return s->conf.macaddr.a[0] | (s->conf.macaddr.a[1] << 8)\n            | (s->conf.macaddr.a[2] << 16)\n            | ((uint32_t)s->conf.macaddr.a[3] << 24);\n    case 0x18: /* IA1 */\n        return s->conf.macaddr.a[4] | (s->conf.macaddr.a[5] << 8);\n    case 0x1c: /* THR */\n        return s->thr;\n    case 0x20: /* MCTL */\n        return s->mctl;\n    case 0x24: /* MDV */\n        return s->mdv;\n    case 0x28: /* MADD */\n        return 0;\n    case 0x2c: /* MTXD */\n        return s->mtxd;\n    case 0x30: /* MRXD */\n        return s->mrxd;\n    case 0x34: /* NP */\n        return s->np;\n    case 0x38: /* TR */\n        return 0;\n    case 0x3c: /* Undocuented: Timestamp? */\n        return 0;\n    default:\n        hw_error(\"stellaris_enet_read: Bad offset %x\\n\", (int)offset);\n        return 0;\n    }\n}\n\nstatic void stellaris_enet_write(void *opaque, hwaddr offset,\n                                 uint64_t value, unsigned size)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n    switch (offset) {\n    case 0x00: /* IACK */\n        s->ris &= ~value;\n        DPRINTF(\"IRQ ack %02\" PRIx64 \"/%02x\\n\", value, s->ris);\n        stellaris_enet_update(s);\n        /* Clearing TXER also resets the TX fifo.  */\n        if (value & SE_INT_TXER) {\n            s->tx_fifo_len = 0;\n        }\n        break;\n    case 0x04: /* IM */\n        DPRINTF(\"IRQ mask %02\" PRIx64 \"/%02x\\n\", value, s->ris);\n        s->im = value;\n        stellaris_enet_update(s);\n        break;\n    case 0x08: /* RCTL */\n        s->rctl = value;\n        if (value & SE_RCTL_RSTFIFO) {\n            s->np = 0;\n            s->rx_fifo_offset = 0;\n            stellaris_enet_update(s);\n        }\n        break;\n    case 0x0c: /* TCTL */\n        s->tctl = value;\n        break;\n    case 0x10: /* DATA */\n        if (s->tx_fifo_len == 0) {\n            /* The first word is special, it contains the data length */\n            int framelen = value & 0xffff;\n            if (framelen > 2032) {\n                DPRINTF(\"TX frame too long (%d)\\n\", framelen);\n                s->ris |= SE_INT_TXER;\n                stellaris_enet_update(s);\n                break;\n            }\n        }\n\n        if (s->tx_fifo_len + 4 <= ARRAY_SIZE(s->tx_fifo)) {\n            s->tx_fifo[s->tx_fifo_len++] = value;\n            s->tx_fifo[s->tx_fifo_len++] = value >> 8;\n            s->tx_fifo[s->tx_fifo_len++] = value >> 16;\n            s->tx_fifo[s->tx_fifo_len++] = value >> 24;\n        }\n\n        if (stellaris_tx_thr_reached(s) && stellaris_txpacket_complete(s)) {\n            stellaris_enet_send(s);\n        }\n        break;\n    case 0x14: /* IA0 */\n        s->conf.macaddr.a[0] = value;\n        s->conf.macaddr.a[1] = value >> 8;\n        s->conf.macaddr.a[2] = value >> 16;\n        s->conf.macaddr.a[3] = value >> 24;\n        break;\n    case 0x18: /* IA1 */\n        s->conf.macaddr.a[4] = value;\n        s->conf.macaddr.a[5] = value >> 8;\n        break;\n    case 0x1c: /* THR */\n        s->thr = value;\n        break;\n    case 0x20: /* MCTL */\n        s->mctl = value;\n        break;\n    case 0x24: /* MDV */\n        s->mdv = value;\n        break;\n    case 0x28: /* MADD */\n        /* ignored.  */\n        break;\n    case 0x2c: /* MTXD */\n        s->mtxd = value & 0xff;\n        break;\n    case 0x38: /* TR */\n        if (value & 1) {\n            stellaris_enet_send(s);\n        }\n        break;\n    case 0x30: /* MRXD */\n    case 0x34: /* NP */\n        /* Ignored.  */\n    case 0x3c: /* Undocuented: Timestamp? */\n        /* Ignored.  */\n        break;\n    default:\n        hw_error(\"stellaris_enet_write: Bad offset %x\\n\", (int)offset);\n    }\n}\n\nstatic const MemoryRegionOps stellaris_enet_ops = {\n    .read = stellaris_enet_read,\n    .write = stellaris_enet_write,\n    .endianness = DEVICE_NATIVE_ENDIAN,\n};\n\nstatic void stellaris_enet_reset(stellaris_enet_state *s)\n{\n    s->mdv = 0x80;\n    s->rctl = SE_RCTL_BADCRC;\n    s->im = SE_INT_PHY | SE_INT_MD | SE_INT_RXER | SE_INT_FOV | SE_INT_TXEMP\n            | SE_INT_TXER | SE_INT_RX;\n    s->thr = 0x3f;\n    s->tx_fifo_len = 0;\n}\n\nstatic void stellaris_enet_save(QEMUFile *f, void *opaque)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n\n    qemu_put_be32(f, s->ris);\n    qemu_put_be32(f, s->im);\n    qemu_put_be32(f, s->rctl);\n    qemu_put_be32(f, s->tctl);\n    qemu_put_be32(f, s->thr);\n    qemu_put_be32(f, s->mctl);\n    qemu_put_be32(f, s->mdv);\n    qemu_put_be32(f, s->mtxd);\n    qemu_put_be32(f, s->mrxd);\n    qemu_put_be32(f, s->np);\n    qemu_put_be32(f, s->tx_fifo_len);\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        qemu_put_be32(f, s->rx[i].len);\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n    }\n    qemu_put_be32(f, s->next_packet);\n    qemu_put_be32(f, s->rx_fifo_offset);\n}\n\nstatic int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n\n    if (version_id != 1)\n        return -EINVAL;\n\n    s->ris = qemu_get_be32(f);\n    s->im = qemu_get_be32(f);\n    s->rctl = qemu_get_be32(f);\n    s->tctl = qemu_get_be32(f);\n    s->thr = qemu_get_be32(f);\n    s->mctl = qemu_get_be32(f);\n    s->mdv = qemu_get_be32(f);\n    s->mtxd = qemu_get_be32(f);\n    s->mrxd = qemu_get_be32(f);\n    s->np = qemu_get_be32(f);\n    s->tx_fifo_len = qemu_get_be32(f);\n    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        s->rx[i].len = qemu_get_be32(f);\n        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n    }\n    s->next_packet = qemu_get_be32(f);\n    s->rx_fifo_offset = qemu_get_be32(f);\n\n    return 0;\n}\n\nstatic void stellaris_enet_cleanup(NetClientState *nc)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n\n    s->nic = NULL;\n}\n\nstatic NetClientInfo net_stellaris_enet_info = {\n    .type = NET_CLIENT_OPTIONS_KIND_NIC,\n    .size = sizeof(NICState),\n    .can_receive = stellaris_enet_can_receive,\n    .receive = stellaris_enet_receive,\n    .cleanup = stellaris_enet_cleanup,\n};\n\nstatic int stellaris_enet_init(SysBusDevice *sbd)\n{\n    DeviceState *dev = DEVICE(sbd);\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,\n                          \"stellaris_enet\", 0x1000);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_irq(sbd, &s->irq);\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n\n    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n\n    stellaris_enet_reset(s);\n    register_savevm(dev, \"stellaris_enet\", -1, 1,\n                    stellaris_enet_save, stellaris_enet_load, s);\n    return 0;\n}\n\nstatic void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n\n    unregister_savevm(DEVICE(s), \"stellaris_enet\", s);\n\n    memory_region_destroy(&s->mmio);\n}\n\nstatic Property stellaris_enet_properties[] = {\n    DEFINE_NIC_PROPERTIES(stellaris_enet_state, conf),\n    DEFINE_PROP_END_OF_LIST(),\n};\n\nstatic void stellaris_enet_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n    k->init = stellaris_enet_init;\n    dc->unrealize = stellaris_enet_unrealize;\n    dc->props = stellaris_enet_properties;\n}\n\nstatic const TypeInfo stellaris_enet_info = {\n    .name          = TYPE_STELLARIS_ENET,\n    .parent        = TYPE_SYS_BUS_DEVICE,\n    .instance_size = sizeof(stellaris_enet_state),\n    .class_init    = stellaris_enet_class_init,\n};\n\nstatic void stellaris_enet_register_types(void)\n{\n    type_register_static(&stellaris_enet_info);\n}\n\ntype_init(stellaris_enet_register_types)\n"], "fixing_code": ["/*\n * Luminary Micro Stellaris Ethernet Controller\n *\n * Copyright (c) 2007 CodeSourcery.\n * Written by Paul Brook\n *\n * This code is licensed under the GPL.\n */\n#include \"hw/sysbus.h\"\n#include \"net/net.h\"\n#include <zlib.h>\n\n//#define DEBUG_STELLARIS_ENET 1\n\n#ifdef DEBUG_STELLARIS_ENET\n#define DPRINTF(fmt, ...) \\\ndo { printf(\"stellaris_enet: \" fmt , ## __VA_ARGS__); } while (0)\n#define BADF(fmt, ...) \\\ndo { fprintf(stderr, \"stellaris_enet: error: \" fmt , ## __VA_ARGS__); exit(1);} while (0)\n#else\n#define DPRINTF(fmt, ...) do {} while(0)\n#define BADF(fmt, ...) \\\ndo { fprintf(stderr, \"stellaris_enet: error: \" fmt , ## __VA_ARGS__);} while (0)\n#endif\n\n#define SE_INT_RX       0x01\n#define SE_INT_TXER     0x02\n#define SE_INT_TXEMP    0x04\n#define SE_INT_FOV      0x08\n#define SE_INT_RXER     0x10\n#define SE_INT_MD       0x20\n#define SE_INT_PHY      0x40\n\n#define SE_RCTL_RXEN    0x01\n#define SE_RCTL_AMUL    0x02\n#define SE_RCTL_PRMS    0x04\n#define SE_RCTL_BADCRC  0x08\n#define SE_RCTL_RSTFIFO 0x10\n\n#define SE_TCTL_TXEN    0x01\n#define SE_TCTL_PADEN   0x02\n#define SE_TCTL_CRC     0x04\n#define SE_TCTL_DUPLEX  0x08\n\n#define TYPE_STELLARIS_ENET \"stellaris_enet\"\n#define STELLARIS_ENET(obj) \\\n    OBJECT_CHECK(stellaris_enet_state, (obj), TYPE_STELLARIS_ENET)\n\ntypedef struct {\n    uint8_t data[2048];\n    uint32_t len;\n} StellarisEnetRxFrame;\n\ntypedef struct {\n    SysBusDevice parent_obj;\n\n    uint32_t ris;\n    uint32_t im;\n    uint32_t rctl;\n    uint32_t tctl;\n    uint32_t thr;\n    uint32_t mctl;\n    uint32_t mdv;\n    uint32_t mtxd;\n    uint32_t mrxd;\n    uint32_t np;\n    uint32_t tx_fifo_len;\n    uint8_t tx_fifo[2048];\n    /* Real hardware has a 2k fifo, which works out to be at most 31 packets.\n       We implement a full 31 packet fifo.  */\n    StellarisEnetRxFrame rx[31];\n    uint32_t rx_fifo_offset;\n    uint32_t next_packet;\n    NICState *nic;\n    NICConf conf;\n    qemu_irq irq;\n    MemoryRegion mmio;\n} stellaris_enet_state;\n\nstatic const VMStateDescription vmstate_rx_frame = {\n    .name = \"stellaris_enet/rx_frame\",\n    .version_id = 1,\n    .minimum_version_id = 1,\n    .fields = (VMStateField[]) {\n        VMSTATE_UINT8_ARRAY(data, StellarisEnetRxFrame, 2048),\n        VMSTATE_UINT32(len, StellarisEnetRxFrame),\n        VMSTATE_END_OF_LIST()\n    }\n};\n\nstatic int stellaris_enet_post_load(void *opaque, int version_id)\n{\n    stellaris_enet_state *s = opaque;\n    int i;\n\n    /* Sanitize inbound state. Note that next_packet is an index but\n     * np is a size; hence their valid upper bounds differ.\n     */\n    if (s->next_packet >= ARRAY_SIZE(s->rx)) {\n        return -1;\n    }\n\n    if (s->np > ARRAY_SIZE(s->rx)) {\n        return -1;\n    }\n\n    for (i = 0; i < ARRAY_SIZE(s->rx); i++) {\n        if (s->rx[i].len > ARRAY_SIZE(s->rx[i].data)) {\n            return -1;\n        }\n    }\n\n    if (s->rx_fifo_offset > ARRAY_SIZE(s->rx[0].data) - 4) {\n        return -1;\n    }\n\n    if (s->tx_fifo_len > ARRAY_SIZE(s->tx_fifo)) {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic const VMStateDescription vmstate_stellaris_enet = {\n    .name = \"stellaris_enet\",\n    .version_id = 2,\n    .minimum_version_id = 2,\n    .post_load = stellaris_enet_post_load,\n    .fields = (VMStateField[]) {\n        VMSTATE_UINT32(ris, stellaris_enet_state),\n        VMSTATE_UINT32(im, stellaris_enet_state),\n        VMSTATE_UINT32(rctl, stellaris_enet_state),\n        VMSTATE_UINT32(tctl, stellaris_enet_state),\n        VMSTATE_UINT32(thr, stellaris_enet_state),\n        VMSTATE_UINT32(mctl, stellaris_enet_state),\n        VMSTATE_UINT32(mdv, stellaris_enet_state),\n        VMSTATE_UINT32(mtxd, stellaris_enet_state),\n        VMSTATE_UINT32(mrxd, stellaris_enet_state),\n        VMSTATE_UINT32(np, stellaris_enet_state),\n        VMSTATE_UINT32(tx_fifo_len, stellaris_enet_state),\n        VMSTATE_UINT8_ARRAY(tx_fifo, stellaris_enet_state, 2048),\n        VMSTATE_STRUCT_ARRAY(rx, stellaris_enet_state, 31, 1,\n                             vmstate_rx_frame, StellarisEnetRxFrame),\n        VMSTATE_UINT32(rx_fifo_offset, stellaris_enet_state),\n        VMSTATE_UINT32(next_packet, stellaris_enet_state),\n        VMSTATE_END_OF_LIST()\n    }\n};\n\nstatic void stellaris_enet_update(stellaris_enet_state *s)\n{\n    qemu_set_irq(s->irq, (s->ris & s->im) != 0);\n}\n\n/* Return the data length of the packet currently being assembled\n * in the TX fifo.\n */\nstatic inline int stellaris_txpacket_datalen(stellaris_enet_state *s)\n{\n    return s->tx_fifo[0] | (s->tx_fifo[1] << 8);\n}\n\n/* Return true if the packet currently in the TX FIFO is complete,\n* ie the FIFO holds enough bytes for the data length, ethernet header,\n* payload and optionally CRC.\n*/\nstatic inline bool stellaris_txpacket_complete(stellaris_enet_state *s)\n{\n    int framelen = stellaris_txpacket_datalen(s);\n    framelen += 16;\n    if (!(s->tctl & SE_TCTL_CRC)) {\n        framelen += 4;\n    }\n    /* Cover the corner case of a 2032 byte payload with auto-CRC disabled:\n     * this requires more bytes than will fit in the FIFO. It's not totally\n     * clear how the h/w handles this, but if using threshold-based TX\n     * it will definitely try to transmit something.\n     */\n    framelen = MIN(framelen, ARRAY_SIZE(s->tx_fifo));\n    return s->tx_fifo_len >= framelen;\n}\n\n/* Return true if the TX FIFO threshold is enabled and the FIFO\n * has filled enough to reach it.\n */\nstatic inline bool stellaris_tx_thr_reached(stellaris_enet_state *s)\n{\n    return (s->thr < 0x3f &&\n            (s->tx_fifo_len >= 4 * (s->thr * 8 + 1)));\n}\n\n/* Send the packet currently in the TX FIFO */\nstatic void stellaris_enet_send(stellaris_enet_state *s)\n{\n    int framelen = stellaris_txpacket_datalen(s);\n\n    /* Ethernet header is in the FIFO but not in the datacount.\n     * We don't implement explicit CRC, so just ignore any\n     * CRC value in the FIFO.\n     */\n    framelen += 14;\n    if ((s->tctl & SE_TCTL_PADEN) && framelen < 60) {\n        memset(&s->tx_fifo[framelen + 2], 0, 60 - framelen);\n        framelen = 60;\n    }\n    /* This MIN will have no effect unless the FIFO data is corrupt\n     * (eg bad data from an incoming migration); otherwise the check\n     * on the datalen at the start of writing the data into the FIFO\n     * will have caught this. Silently write a corrupt half-packet,\n     * which is what the hardware does in FIFO underrun situations.\n     */\n    framelen = MIN(framelen, ARRAY_SIZE(s->tx_fifo) - 2);\n    qemu_send_packet(qemu_get_queue(s->nic), s->tx_fifo + 2, framelen);\n    s->tx_fifo_len = 0;\n    s->ris |= SE_INT_TXEMP;\n    stellaris_enet_update(s);\n    DPRINTF(\"Done TX\\n\");\n}\n\n/* TODO: Implement MAC address filtering.  */\nstatic ssize_t stellaris_enet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n    int n;\n    uint8_t *p;\n    uint32_t crc;\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n        return -1;\n    if (s->np >= 31) {\n        DPRINTF(\"Packet dropped\\n\");\n        return -1;\n    }\n\n    DPRINTF(\"Received packet len=%zu\\n\", size);\n    n = s->next_packet + s->np;\n    if (n >= 31)\n        n -= 31;\n    s->np++;\n\n    s->rx[n].len = size + 6;\n    p = s->rx[n].data;\n    *(p++) = (size + 6);\n    *(p++) = (size + 6) >> 8;\n    memcpy (p, buf, size);\n    p += size;\n    crc = crc32(~0, buf, size);\n    *(p++) = crc;\n    *(p++) = crc >> 8;\n    *(p++) = crc >> 16;\n    *(p++) = crc >> 24;\n    /* Clear the remaining bytes in the last word.  */\n    if ((size & 3) != 2) {\n        memset(p, 0, (6 - size) & 3);\n    }\n\n    s->ris |= SE_INT_RX;\n    stellaris_enet_update(s);\n\n    return size;\n}\n\nstatic int stellaris_enet_can_receive(NetClientState *nc)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n        return 1;\n\n    return (s->np < 31);\n}\n\nstatic uint64_t stellaris_enet_read(void *opaque, hwaddr offset,\n                                    unsigned size)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    uint32_t val;\n\n    switch (offset) {\n    case 0x00: /* RIS */\n        DPRINTF(\"IRQ status %02x\\n\", s->ris);\n        return s->ris;\n    case 0x04: /* IM */\n        return s->im;\n    case 0x08: /* RCTL */\n        return s->rctl;\n    case 0x0c: /* TCTL */\n        return s->tctl;\n    case 0x10: /* DATA */\n    {\n        uint8_t *rx_fifo;\n\n        if (s->np == 0) {\n            BADF(\"RX underflow\\n\");\n            return 0;\n        }\n\n        rx_fifo = s->rx[s->next_packet].data + s->rx_fifo_offset;\n\n        val = rx_fifo[0] | (rx_fifo[1] << 8) | (rx_fifo[2] << 16)\n              | (rx_fifo[3] << 24);\n        s->rx_fifo_offset += 4;\n        if (s->rx_fifo_offset >= s->rx[s->next_packet].len) {\n            s->rx_fifo_offset = 0;\n            s->next_packet++;\n            if (s->next_packet >= 31)\n                s->next_packet = 0;\n            s->np--;\n            DPRINTF(\"RX done np=%d\\n\", s->np);\n        }\n        return val;\n    }\n    case 0x14: /* IA0 */\n        return s->conf.macaddr.a[0] | (s->conf.macaddr.a[1] << 8)\n            | (s->conf.macaddr.a[2] << 16)\n            | ((uint32_t)s->conf.macaddr.a[3] << 24);\n    case 0x18: /* IA1 */\n        return s->conf.macaddr.a[4] | (s->conf.macaddr.a[5] << 8);\n    case 0x1c: /* THR */\n        return s->thr;\n    case 0x20: /* MCTL */\n        return s->mctl;\n    case 0x24: /* MDV */\n        return s->mdv;\n    case 0x28: /* MADD */\n        return 0;\n    case 0x2c: /* MTXD */\n        return s->mtxd;\n    case 0x30: /* MRXD */\n        return s->mrxd;\n    case 0x34: /* NP */\n        return s->np;\n    case 0x38: /* TR */\n        return 0;\n    case 0x3c: /* Undocuented: Timestamp? */\n        return 0;\n    default:\n        hw_error(\"stellaris_enet_read: Bad offset %x\\n\", (int)offset);\n        return 0;\n    }\n}\n\nstatic void stellaris_enet_write(void *opaque, hwaddr offset,\n                                 uint64_t value, unsigned size)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n    switch (offset) {\n    case 0x00: /* IACK */\n        s->ris &= ~value;\n        DPRINTF(\"IRQ ack %02\" PRIx64 \"/%02x\\n\", value, s->ris);\n        stellaris_enet_update(s);\n        /* Clearing TXER also resets the TX fifo.  */\n        if (value & SE_INT_TXER) {\n            s->tx_fifo_len = 0;\n        }\n        break;\n    case 0x04: /* IM */\n        DPRINTF(\"IRQ mask %02\" PRIx64 \"/%02x\\n\", value, s->ris);\n        s->im = value;\n        stellaris_enet_update(s);\n        break;\n    case 0x08: /* RCTL */\n        s->rctl = value;\n        if (value & SE_RCTL_RSTFIFO) {\n            s->np = 0;\n            s->rx_fifo_offset = 0;\n            stellaris_enet_update(s);\n        }\n        break;\n    case 0x0c: /* TCTL */\n        s->tctl = value;\n        break;\n    case 0x10: /* DATA */\n        if (s->tx_fifo_len == 0) {\n            /* The first word is special, it contains the data length */\n            int framelen = value & 0xffff;\n            if (framelen > 2032) {\n                DPRINTF(\"TX frame too long (%d)\\n\", framelen);\n                s->ris |= SE_INT_TXER;\n                stellaris_enet_update(s);\n                break;\n            }\n        }\n\n        if (s->tx_fifo_len + 4 <= ARRAY_SIZE(s->tx_fifo)) {\n            s->tx_fifo[s->tx_fifo_len++] = value;\n            s->tx_fifo[s->tx_fifo_len++] = value >> 8;\n            s->tx_fifo[s->tx_fifo_len++] = value >> 16;\n            s->tx_fifo[s->tx_fifo_len++] = value >> 24;\n        }\n\n        if (stellaris_tx_thr_reached(s) && stellaris_txpacket_complete(s)) {\n            stellaris_enet_send(s);\n        }\n        break;\n    case 0x14: /* IA0 */\n        s->conf.macaddr.a[0] = value;\n        s->conf.macaddr.a[1] = value >> 8;\n        s->conf.macaddr.a[2] = value >> 16;\n        s->conf.macaddr.a[3] = value >> 24;\n        break;\n    case 0x18: /* IA1 */\n        s->conf.macaddr.a[4] = value;\n        s->conf.macaddr.a[5] = value >> 8;\n        break;\n    case 0x1c: /* THR */\n        s->thr = value;\n        break;\n    case 0x20: /* MCTL */\n        s->mctl = value;\n        break;\n    case 0x24: /* MDV */\n        s->mdv = value;\n        break;\n    case 0x28: /* MADD */\n        /* ignored.  */\n        break;\n    case 0x2c: /* MTXD */\n        s->mtxd = value & 0xff;\n        break;\n    case 0x38: /* TR */\n        if (value & 1) {\n            stellaris_enet_send(s);\n        }\n        break;\n    case 0x30: /* MRXD */\n    case 0x34: /* NP */\n        /* Ignored.  */\n    case 0x3c: /* Undocuented: Timestamp? */\n        /* Ignored.  */\n        break;\n    default:\n        hw_error(\"stellaris_enet_write: Bad offset %x\\n\", (int)offset);\n    }\n}\n\nstatic const MemoryRegionOps stellaris_enet_ops = {\n    .read = stellaris_enet_read,\n    .write = stellaris_enet_write,\n    .endianness = DEVICE_NATIVE_ENDIAN,\n};\n\nstatic void stellaris_enet_reset(stellaris_enet_state *s)\n{\n    s->mdv = 0x80;\n    s->rctl = SE_RCTL_BADCRC;\n    s->im = SE_INT_PHY | SE_INT_MD | SE_INT_RXER | SE_INT_FOV | SE_INT_TXEMP\n            | SE_INT_TXER | SE_INT_RX;\n    s->thr = 0x3f;\n    s->tx_fifo_len = 0;\n}\n\nstatic void stellaris_enet_cleanup(NetClientState *nc)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n\n    s->nic = NULL;\n}\n\nstatic NetClientInfo net_stellaris_enet_info = {\n    .type = NET_CLIENT_OPTIONS_KIND_NIC,\n    .size = sizeof(NICState),\n    .can_receive = stellaris_enet_can_receive,\n    .receive = stellaris_enet_receive,\n    .cleanup = stellaris_enet_cleanup,\n};\n\nstatic int stellaris_enet_init(SysBusDevice *sbd)\n{\n    DeviceState *dev = DEVICE(sbd);\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,\n                          \"stellaris_enet\", 0x1000);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_irq(sbd, &s->irq);\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n\n    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n\n    stellaris_enet_reset(s);\n    return 0;\n}\n\nstatic void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n\n    memory_region_destroy(&s->mmio);\n}\n\nstatic Property stellaris_enet_properties[] = {\n    DEFINE_NIC_PROPERTIES(stellaris_enet_state, conf),\n    DEFINE_PROP_END_OF_LIST(),\n};\n\nstatic void stellaris_enet_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n    k->init = stellaris_enet_init;\n    dc->unrealize = stellaris_enet_unrealize;\n    dc->props = stellaris_enet_properties;\n    dc->vmsd = &vmstate_stellaris_enet;\n}\n\nstatic const TypeInfo stellaris_enet_info = {\n    .name          = TYPE_STELLARIS_ENET,\n    .parent        = TYPE_SYS_BUS_DEVICE,\n    .instance_size = sizeof(stellaris_enet_state),\n    .class_init    = stellaris_enet_class_init,\n};\n\nstatic void stellaris_enet_register_types(void)\n{\n    type_register_static(&stellaris_enet_info);\n}\n\ntype_init(stellaris_enet_register_types)\n"], "filenames": ["hw/net/stellaris_enet.c"], "buggy_code_start_loc": [49], "buggy_code_end_loc": [496], "fixing_code_start_loc": [50], "fixing_code_end_loc": [509], "type": "CWE-119", "message": "Qemu 1.1.2+dfsg to 2.1+dfsg suffers from a buffer overrun which could potentially result in arbitrary code execution on the host with the privileges of the QEMU process.", "other": {"cve": {"id": "CVE-2013-4532", "sourceIdentifier": "secalert@redhat.com", "published": "2020-01-02T16:15:11.560", "lastModified": "2020-01-15T19:39:33.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Qemu 1.1.2+dfsg to 2.1+dfsg suffers from a buffer overrun which could potentially result in arbitrary code execution on the host with the privileges of the QEMU process."}, {"lang": "es", "value": "Qemu versi\u00f3n 1.1.2+dfsg hasta 2.1+dfsg sufre un desbordamiento de b\u00fafer que podr\u00eda resultar en una ejecuci\u00f3n de c\u00f3digo arbitrario en el host con los privilegios del proceso QEMU."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qemu:qemu:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.1.2\\+dfsg", "versionEndIncluding": "2.1\\+dfsg", "matchCriteriaId": "7E09AF7A-970C-4941-8107-36FB859D5D15"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:lts:*:*:*", "matchCriteriaId": "5D37DF0F-F863-45AC-853A-3E04F9FEC7CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://www.ubuntu.com/usn/USN-2342-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/security/cve/cve-2013-4532", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=739589", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2013-4532", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=CVE-2013-4532", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/qemu/qemu/commit/2e1198672759eda6e122ff38fcf6df06f27e0fe2", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2013-4532", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/qemu/qemu/commit/2e1198672759eda6e122ff38fcf6df06f27e0fe2"}}