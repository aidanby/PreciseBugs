{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport org.xwiki.component.annotation.Role;\nimport org.xwiki.contrib.rights.SecurityRuleDiff;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.user.UserReference;\n\n/**\n * Component responsible to handle the rights synchronization between change requests and modified documents, and to\n * perform different rights checks for change request.\n *\n * @version $Id$\n * @since 0.7\n */\n@Unstable\n@Role\npublic interface ChangeRequestRightsManager\n{\n    /**\n     * Copy all rights coming from the original change request to the target one, except view rights rules.\n     *\n     * @param originalChangeRequest the change request from which to get the rights to copy.\n     * @param targetChangeRequest the change request where to copy the rights.\n     * @throws ChangeRequestException in case of problems when reading or writing the rights.\n     */\n    void copyAllButViewRights(ChangeRequest originalChangeRequest, ChangeRequest targetChangeRequest)\n        throws ChangeRequestException;\n\n    /**\n     * Determine if view access is still consistent if a new change related to the given document reference is added\n     * to the given change request. The consistency here means that there's no rules that are contradictory between\n     * the documents included in the change request, and the new document.\n     *\n     * @param changeRequest the change request where the new filechange should be added.\n     * @param newChange the change to be added.\n     * @return {@code true} if the given document reference can be added to the change request without creating right\n     *          inconsistency.\n     * @throws ChangeRequestException in case of problem to access the rights.\n     */\n    boolean isViewAccessConsistent(ChangeRequest changeRequest, DocumentReference newChange)\n        throws ChangeRequestException;\n\n    /**\n     * Determine if the view right is still consistent in the change request for the given list of user references.\n     * The consistency here consists only in defining if each user or group has independently same allow or deny access\n     * of each document of the change request. This method should be called whenever a right is updated in a document.\n     *\n     * @param changeRequest the change request for which to check the consistency.\n     * @param subjectReferences the users or groups for which to check the consistency of rights.\n     * @return {@code true} if the view right is consistent across all document of the change request for each given\n     *          user independently.\n     * @throws ChangeRequestException in case of problem to access the rights.\n     */\n    boolean isViewAccessStillConsistent(ChangeRequest changeRequest, Set<DocumentReference> subjectReferences)\n        throws ChangeRequestException;\n\n    /**\n     * Copy the view right rules coming from the given document reference to the change request.\n     * Note that all inherited rules are copied too.\n     *\n     * @param changeRequest the change request in which to copy rights.\n     * @param newChange the reference from which to get rights to copy.\n     * @throws ChangeRequestException in case of problem for accessing or copying rights.\n     */\n    void copyViewRights(ChangeRequest changeRequest, EntityReference newChange) throws ChangeRequestException;\n\n    /**\n     * Apply the provided right changes to the change request.\n     *\n     * @param changeRequest the change request on which to apply the right changes.\n     * @param ruleDiffList a list of diff changes of rights.\n     * @throws ChangeRequestException in case of problem when applying the changes.\n     */\n    void applyChanges(ChangeRequest changeRequest, List<SecurityRuleDiff> ruleDiffList) throws ChangeRequestException;\n\n    /**\n     * Check if the given user is authorized to merge the given change request.\n     *\n     * @param userReference the user for which to check the authorizations\n     * @param changeRequest the change request to check\n     * @return {@code true} if the user has the appropriate rights to perform the merge.\n     * @throws ChangeRequestException in case of problem when checking if the user is an approver.\n     */\n    boolean isAuthorizedToMerge(UserReference userReference, ChangeRequest changeRequest) throws ChangeRequestException;\n\n    /**\n     * Check if the given user is authorized to review the given change request.\n     *\n     * @param userReference the user for which to check authorizations.\n     * @param changeRequest the change request to review.\n     * @return {@code true} if the user is not one of the change request author and it authorized to review it.\n     * @throws ChangeRequestException in case of problem when checking if a user is an approver.\n     */\n    boolean isAuthorizedToReview(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException;\n\n    /**\n     * Check if the given user is authorized to perform a review on behalf of the original approver, on the given change\n     * request.\n     * This should only returns {@code true} if the delegate approver mechanism is enabled, the original approver is an\n     * explicit approver and the given user is a delegate approver of them.\n     *\n     * @param userReference the user for which to check the authorization\n     * @param changeRequest the change request for which to check the authorization\n     * @param originalApprover the user on behalf of whom the authorization might be given\n     * @return {@code true} if the delegate mechanism is enabled and the given user  is not an author, and is a delegate\n     *          of the original approver who is also an approver of the given change request.\n     * @throws ChangeRequestException in case of problem to resolve the delegate approvers.\n     * @since 0.13\n     */\n    @Unstable\n    boolean isAuthorizedToReviewOnBehalf(UserReference userReference, ChangeRequest changeRequest,\n        UserReference originalApprover) throws ChangeRequestException;\n\n    /**\n     * Check if the given user is authorized to perform a review as a delegate of one of the approver of the given\n     * change request.\n     * This should only returns {@code true} if the delegate mechanism is enabled, the change request has explicit\n     * approvers, and  the given user is a delegate of at least one of them. Moreover, this cannot return {@code true}\n     * if the given user is an author of the change request.\n     *\n     * @param userReference the user for which to check the authorization\n     * @param changeRequest the change request for which to check the authorization\n     * @return {@code true} if the delegate mechanism is enabled, the change request has explicit\n     *         approvers, the given user is not an author of the change request, and is a delegate of at least one of\n     *         the approvers.\n     * @throws ChangeRequestException in case of problem to resolve the delegate approvers.\n     * @since 0.13\n     */\n    @Unstable\n    boolean isAuthorizedToReviewAsDelegate(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException;\n\n    /**\n     * Check if an user is authorized to comment a change request. This method should always check first if the user\n     * is authorized to review (see {@link #isAuthorizedToReview(UserReference, ChangeRequest)}) and allow to comment if\n     * that's the case. Then it should fallback on checking if the user has comment right.\n     *\n     * @param userReference the user for which to check rights.\n     * @param changeRequest the change request for which to check if the user can comment.\n     * @return {@code true} if the user is authorized to post a comment.\n     * @throws ChangeRequestException in case of problem when checking if a user is an approver.\n     */\n    boolean isAuthorizedToComment(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException;\n\n    /**\n     * Define if the given user is authorized to edit the given change request. An edition can be either changing the\n     * status, modifying the description, or even rebasing the change request.\n     * Only change request that are opened can be edited, and only authors or administrators of the change\n     * request document are authorized to do it.\n     * @param userReference the user for which to check rights.\n     * @param changeRequest the change request to check if it can be edited.\n     * @return {@code true} if the given user can edit the change request, {@code false otherwise}.\n     */\n    boolean isAuthorizedToEdit(UserReference userReference, ChangeRequest changeRequest);\n\n    /**\n     * Define if the given user is authorized to re-open a closed change request. This method basically performs the\n     * same checks as {@link #isAuthorizedToEdit(UserReference, ChangeRequest)} except that it always returns false for\n     * merged change requests.\n     * @param userReference the user for which to check rights.\n     * @param changeRequest the change request to check if it can be re-opened.\n     * @return {@code true} if the given user can re-open the change request, {@code false otherwise}.\n     */\n    boolean isAuthorizedToOpen(UserReference userReference, ChangeRequest changeRequest);\n\n    /**\n     * Check if the given user is authorized to perform a split of the change request.\n     * Users that are authors of the change request, and admins are authorized to split a change request.\n     *\n     * @param userReference the user for which to check rights\n     * @param changeRequest the change request that is requested to be split\n     * @return {@code true} if the given user is an author or an admin\n     */\n    default boolean isAuthorizedToSplit(UserReference userReference, ChangeRequest changeRequest)\n    {\n        return false;\n    }\n}\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--\n  ~ See the NOTICE file distributed with this work for additional\n  ~ information regarding copyright ownership.\n  ~\n  ~ This is free software; you can redistribute it and/or modify it\n  ~ under the terms of the GNU Lesser General Public License as\n  ~ published by the Free Software Foundation; either version 2.1 of\n  ~ the License, or (at your option) any later version.\n  ~\n  ~ This software is distributed in the hope that it will be useful,\n  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of\n  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  ~ Lesser General Public License for more details.\n  ~\n  ~ You should have received a copy of the GNU Lesser General Public\n  ~ License along with this software; if not, write to the Free\n  ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n  ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n  -->\n\n<!DOCTYPE suppressions PUBLIC\n    \"-//Puppy Crawl//DTD Suppressions 1.0//EN\"\n    \"http://www.puppycrawl.com/dtds/suppressions_1_0.dtd\">\n\n<suppressions>\n  <!-- The complexity metrics are not respected on EditChangeRequestResourceHandler for now. Note that in the future\n  this handler should be mostly an inheritance of an EditResourceHandler that will belocated in xwiki-platform and most\n  of the code put in the current class will be put in commons for the various actions. For now we keep it like that\n  since it avoids extending an old XWikiAction. -->\n  <suppress checks=\"NPathComplexity\" files=\"EditChangeRequestResourceHandler.java\"/>\n  <suppress checks=\"CyclomaticComplexity\" files=\"EditChangeRequestResourceHandler.java\"/>\n\n  <suppress checks=\"ClassFanOutComplexity\" files=\"CreateInChangeRequestResourceHandler.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"TemplateProviderSupportChecker.java\"/>\n\n  <suppress checks=\"ClassFanOutComplexity\" files=\"ChangeRequestEventsConverter.java\"/>\n\n  <!-- False positive introduced by multi strings used for queries -->\n  <suppress checks=\"MultipleStringLiterals\" files=\"DefaultChangeRequestStorageManager.java\"/>\n\n  <!-- FIXME: this should be improved in the future -->\n  <suppress checks=\"ClassFanOutComplexity\" files=\"DefaultFileChangeStorageManager.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"DefaultChangeRequestManager.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"DefaultChangeRequestRightsManager.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"DefaultChangeRequestMergeManager.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"DefaultChangeRequestStorageManager.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"AddChangesChangeRequestHandler.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"CreateChangeRequestHandler.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"AbstractChangeRequestActionHandler.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"XWikiDocumentDelegateApproverManager.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"ChangeRequestScriptService.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"ChangeRequestResourceHandler.java\"/>\n  <suppress checks=\"CyclomaticComplexity\" files=\"RightsUpdatedListener.java\"/>\n</suppressions>\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\n\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.contrib.changerequest.ApproversManager;\nimport org.xwiki.contrib.changerequest.ChangeRequest;\nimport org.xwiki.contrib.changerequest.ChangeRequestConfiguration;\nimport org.xwiki.contrib.changerequest.ChangeRequestException;\nimport org.xwiki.contrib.changerequest.ChangeRequestRightsManager;\nimport org.xwiki.contrib.changerequest.ChangeRequestStatus;\nimport org.xwiki.contrib.changerequest.DelegateApproverManager;\nimport org.xwiki.contrib.changerequest.FileChange;\nimport org.xwiki.contrib.changerequest.rights.ChangeRequestApproveRight;\nimport org.xwiki.contrib.rights.RightsReader;\nimport org.xwiki.contrib.rights.RightsWriter;\nimport org.xwiki.contrib.rights.SecurityRuleAbacus;\nimport org.xwiki.contrib.rights.SecurityRuleDiff;\nimport org.xwiki.contrib.rights.WritableSecurityRule;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.security.authorization.AuthorizationException;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ReadableSecurityRule;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.security.authorization.RightSet;\nimport org.xwiki.security.authorization.RuleState;\nimport org.xwiki.user.GuestUserReference;\nimport org.xwiki.user.UserReference;\n\nimport com.xpn.xwiki.XWikiException;\n\n/**\n * Component in charge of performing right synchronization operations.\n *\n * @version $Id$\n * @since 0.7\n */\n@Component\n@Singleton\npublic class DefaultChangeRequestRightsManager implements ChangeRequestRightsManager\n{\n    @Inject\n    private DocumentReferenceResolver<ChangeRequest> changeRequestDocumentReferenceResolver;\n\n    @Inject\n    private AuthorizationManager authorizationManager;\n\n    @Inject\n    private RightsWriter rightsWriter;\n\n    @Inject\n    private SecurityRuleAbacus ruleAbacus;\n\n    @Inject\n    private RightsReader rightsReader;\n\n    @Inject\n    private ApproversManager<ChangeRequest> changeRequestApproversManager;\n\n    @Inject\n    private DelegateApproverManager<ChangeRequest> changeRequestDelegateApproverManager;\n\n    @Inject\n    private UserReferenceConverter userReferenceConverter;\n\n    @Inject\n    private ChangeRequestConfiguration configuration;\n\n    @Override\n    public void copyAllButViewRights(ChangeRequest originalChangeRequest, ChangeRequest targetChangeRequest)\n        throws ChangeRequestException\n    {\n        DocumentReference originalDocReference =\n            this.changeRequestDocumentReferenceResolver.resolve(originalChangeRequest);\n        DocumentReference targetDocReference =\n            this.changeRequestDocumentReferenceResolver.resolve(targetChangeRequest);\n\n        try {\n            List<ReadableSecurityRule> actualRules =\n                this.rightsReader.getRules(originalDocReference.getLastSpaceReference(), false);\n            List<ReadableSecurityRule> writableSecurityRules = new ArrayList<>();\n\n            for (ReadableSecurityRule actualRule : actualRules) {\n                if (actualRule.match(Right.VIEW)) {\n                    WritableSecurityRule rule = this.rightsWriter.createRule(actualRule);\n                    RightSet rights = rule.getRights();\n                    rights.remove(Right.VIEW);\n                    if (!rights.isEmpty()) {\n                        rule.setRights(rights);\n                        writableSecurityRules.add(rule);\n                    }\n                } else {\n                    writableSecurityRules.add(actualRule);\n                }\n            }\n            this.rightsWriter.saveRules(writableSecurityRules, targetDocReference.getLastSpaceReference());\n        } catch (AuthorizationException | XWikiException e) {\n            throw new ChangeRequestException(\n                String.format(\"Error while trying to retrieve or save rights between [%s] and [%s]\",\n                    originalDocReference, targetDocReference), e);\n        }\n    }\n\n    @Override\n    public boolean isViewAccessConsistent(ChangeRequest changeRequest, DocumentReference newChange)\n        throws ChangeRequestException\n    {\n        Set<DocumentReference> documentReferences = new HashSet<>(changeRequest.getModifiedDocuments());\n        documentReferences.add(newChange);\n\n        Set<DocumentReference> subjects = new HashSet<>();\n        for (DocumentReference documentReference : documentReferences) {\n            try {\n                List<ReadableSecurityRule> actualRules = this.rightsReader.getActualRules(documentReference);\n                List<ReadableSecurityRule> normalizedRules = this.ruleAbacus.normalizeRulesBySubject(actualRules);\n                for (ReadableSecurityRule normalizedRule : normalizedRules) {\n                    if (normalizedRule.match(Right.VIEW)) {\n                        subjects.addAll(normalizedRule.getGroups());\n                        subjects.addAll(normalizedRule.getUsers());\n                    }\n                }\n            } catch (AuthorizationException e) {\n                throw new ChangeRequestException(\n                    String.format(\"Error while trying to access rights for [%s]\", documentReference), e);\n            }\n        }\n\n        return this.isViewAccessConsistent(documentReferences, subjects);\n    }\n\n    @Override\n    public boolean isViewAccessStillConsistent(ChangeRequest changeRequest,\n        Set<DocumentReference> subjectReferences) throws ChangeRequestException\n    {\n        return this.isViewAccessConsistent(changeRequest.getModifiedDocuments(), subjectReferences);\n    }\n\n    private boolean isViewAccessConsistent(Set<DocumentReference> documentReferences,\n        Set<DocumentReference> subjectReferences)\n    {\n        for (DocumentReference subject : subjectReferences) {\n            Boolean hasAccess = null;\n            for (DocumentReference modifiedDocument : documentReferences) {\n                boolean currentHasAccess =\n                    this.authorizationManager.hasAccess(Right.VIEW, subject, modifiedDocument);\n\n                if (hasAccess == null) {\n                    hasAccess = currentHasAccess;\n                } else if (hasAccess != currentHasAccess) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void copyViewRights(ChangeRequest changeRequest, EntityReference newChange)\n        throws ChangeRequestException\n    {\n        DocumentReference changeRequestDocReference =\n            this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n        SpaceReference changeRequestSpaceReference = changeRequestDocReference.getLastSpaceReference();\n\n        try {\n            List<ReadableSecurityRule> actualRules =\n                this.rightsReader.getRules(changeRequestSpaceReference, false);\n            List<ReadableSecurityRule> rules = new ArrayList<>(this.rightsWriter.createRules(actualRules));\n            List<ReadableSecurityRule> documentRules =\n                new ArrayList<>(this.rightsReader.getActualRules(newChange));\n            List<ReadableSecurityRule> wikiRules =\n                this.rightsReader.getActualRules(newChange.extractReference(EntityType.WIKI));\n\n            // we filter out the wiki reference rules\n            documentRules.removeAll(wikiRules);\n            for (ReadableSecurityRule actualRule : documentRules) {\n                if (actualRule.match(Right.VIEW)) {\n                    WritableSecurityRule rule = this.rightsWriter.createRule(actualRule);\n                    rule.setRights(Collections.singletonList(Right.VIEW));\n                    rules.add(rule);\n                }\n            }\n\n            this.rightsWriter.saveRules(rules, changeRequestSpaceReference);\n        } catch (AuthorizationException | XWikiException e) {\n            throw new ChangeRequestException(\n                String.format(\"Error while copying rights from [%s] for change request [%s]\", changeRequest, newChange),\n                e);\n        }\n    }\n\n    /**\n     * Helper class for computing efficiently the change to perform in {@link #applyChanges(ChangeRequest, List)}.\n     */\n    private static final class SecurityRuleAction\n    {\n        private final boolean add;\n        private final RuleState state;\n        private final boolean isGroup;\n\n        /**\n         * Default constructor.\n         *\n         * @param add {@code true} if it concerns a rule added, else it's a rule deleted.\n         * @param state the rule state\n         * @param isGroup {@code true} if the associated key in the map where those actions are used is a reference to\n         *                a group, else it's a reference to a user.\n         */\n        SecurityRuleAction(boolean add, RuleState state, boolean isGroup)\n        {\n            this.add = add;\n            this.state = state;\n            this.isGroup = isGroup;\n        }\n    }\n\n    /**\n     * Create the {@link SecurityRuleAction} corresponding to the given rule and the given add flag, and put it in the\n     * given map.\n     *\n     * @param rule the rule for which to create the {@link SecurityRuleAction}.\n     * @param add to set the flag in the created action.\n     * @param map where to put the created action.\n     */\n    private void creationActionRule(ReadableSecurityRule rule, boolean add,\n        Map<DocumentReference, List<SecurityRuleAction>> map)\n    {\n        SecurityRuleAction action;\n        DocumentReference key;\n        if (this.isAboutUser(rule)) {\n            key = rule.getUsers().get(0);\n            action = new SecurityRuleAction(add, rule.getState(), false);\n        } else {\n            key = rule.getGroups().get(0);\n            action = new SecurityRuleAction(add, rule.getState(), true);\n        }\n        if (!map.containsKey(key)) {\n            map.put(key, new ArrayList<>());\n        }\n        map.get(key).add(action);\n    }\n\n    /**\n     * Check if the given rule is about a user or a group.\n     *\n     * @param rule the rule to check.\n     * @return {@code true} if the rule is about a user, {@code false} if it's about a group.\n     */\n    private boolean isAboutUser(ReadableSecurityRule rule)\n    {\n        return rule.getUsers() != null && !rule.getUsers().isEmpty();\n    }\n\n    /**\n     * Clone the given rule and apply the changes required by the action before adding it back in the list of rules to\n     * write.\n     *\n     * @param securityRuleAction the change to be performed on the rule.\n     * @param normalizedRule the original rule to be updated.\n     * @param updatedRules the list of rules to write after the changes.\n     */\n    private void updateRule(SecurityRuleAction securityRuleAction, ReadableSecurityRule normalizedRule,\n        List<ReadableSecurityRule> updatedRules)\n    {\n        // We ensure first that we won't have twice the rule to write\n        updatedRules.remove(normalizedRule);\n        RightSet rightSet = normalizedRule.getRights();\n        WritableSecurityRule writerRule = this.rightsWriter.createRule(normalizedRule);\n\n        // if the rule has been added then we need to add a view Right to the rule we found,\n        // else we need to remove it.\n        if (securityRuleAction.add) {\n            rightSet.add(Right.VIEW);\n        } else {\n            rightSet.remove(Right.VIEW);\n        }\n\n        // if the rule was only about view right and it has been removed, we already discarded it first,\n        // so we don't need to do anything\n        if (!rightSet.isEmpty()) {\n            writerRule.setRights(rightSet);\n            updatedRules.add(writerRule);\n        }\n    }\n\n    /**\n     * Create a new security rule based on an action, when there was no matching rules.\n     *\n     * @param action the action for which to create a new security rule.\n     * @param reference the reference of the user or group to use.\n     * @param updatedRules the list of rules to write.\n     */\n    private void createRule(SecurityRuleAction action, DocumentReference reference,\n        List<ReadableSecurityRule> updatedRules)\n    {\n        // if the action was about deleting a rule, we just ignore it: we did not find a rule concerning it previously\n        // there's nothing more to do now.\n        if (action.add) {\n            WritableSecurityRule rule = this.rightsWriter.createRule();\n            if (action.isGroup) {\n                rule.setGroups(Collections.singletonList(reference));\n            } else {\n                rule.setUsers(Collections.singletonList(reference));\n            }\n            rule.setRights(Collections.singletonList(Right.VIEW));\n            rule.setState(action.state);\n            updatedRules.add(rule);\n        }\n    }\n\n    /**\n     * Performs the given actions on the change request rights to update them.\n     *\n     * @param changeRequest the change request on which to perform changes.\n     * @param actionsToPerform the rights update to perform that have been previously computed.\n     * @param ruleDiffList the original diff list used for logging purpose.\n     * @throws ChangeRequestException in case of problem for writing rights.\n     */\n    private void applyActions(ChangeRequest changeRequest,\n        Map<DocumentReference, List<SecurityRuleAction>> actionsToPerform, List<SecurityRuleDiff> ruleDiffList)\n        throws ChangeRequestException\n    {\n        DocumentReference changeRequestDocReference =\n            this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n        SpaceReference changeRequestSpaceReference = changeRequestDocReference.getLastSpaceReference();\n\n        try {\n            // first we get the rules that concerns the change request\n            List<ReadableSecurityRule> actualRules =\n                this.rightsReader.getRules(changeRequestSpaceReference, false);\n\n            // then we normalize them to allow using properly the map of actions\n            List<ReadableSecurityRule> normalizedRules = this.ruleAbacus.normalizeRulesBySubject(actualRules);\n\n            // we create a copy of the list to allow modifying it when iterating on the original\n            List<ReadableSecurityRule> updatedRules = new ArrayList<>(normalizedRules);\n\n            for (ReadableSecurityRule normalizedRule : normalizedRules) {\n                // the rule applies on the given target\n                DocumentReference target = (this.isAboutUser(normalizedRule))\n                    ? normalizedRule.getUsers().get(0) : normalizedRule.getGroups().get(0);\n\n                // we check if there's one or several actions to perform\n                if (actionsToPerform.containsKey(target)) {\n\n                    // we create a copy of the list to allow removing the actions while iterating\n                    List<SecurityRuleAction> securityRuleActions = actionsToPerform.get(target);\n\n                    for (SecurityRuleAction securityRuleAction : new ArrayList<>(securityRuleActions)) {\n\n                        // we only update the rule if the state is the same than in the action\n                        // we're doing this because we're not supposed to change the state of the rule:\n                        // we only create or remove rules. A change of a state will create two actions, one for removing\n                        // and one for creating.\n                        // This strategy is tightly linked to the way normalizing rules work right now, see the javadoc\n                        // of SecurityRuleAbacus.\n                        if (normalizedRule.getState() == securityRuleAction.state) {\n                            this.updateRule(securityRuleAction, normalizedRule, updatedRules);\n\n                            // we remove the action once applied\n                            securityRuleActions.remove(securityRuleAction);\n                        }\n                    }\n\n                    // if there's no more action, we remove the entry\n                    if (securityRuleActions.isEmpty()) {\n                        actionsToPerform.remove(target);\n                    }\n                }\n            }\n\n            // We might still have actions to apply if there was no previous rules concerning the targets:\n            // here we apply only the action for adding rules.\n            for (Map.Entry<DocumentReference, List<SecurityRuleAction>> entry : actionsToPerform.entrySet()) {\n                DocumentReference reference = entry.getKey();\n\n                for (SecurityRuleAction action : entry.getValue()) {\n                    this.createRule(action, reference, updatedRules);\n                }\n            }\n\n            // finally we write all rules\n            this.rightsWriter.saveRules(updatedRules, changeRequestSpaceReference);\n        } catch (AuthorizationException | XWikiException e) {\n            throw new ChangeRequestException(String.format(\"Error while applying rights changes for change request \"\n                + \"[%s] with diff [%s]\", changeRequest, ruleDiffList),\n                e);\n        }\n    }\n\n    private Map<DocumentReference, List<SecurityRuleAction>> computeActionsMap(List<SecurityRuleDiff> ruleDiffList)\n    {\n        Map<DocumentReference, List<SecurityRuleAction>> actionsToPerform = new HashMap<>();\n\n        for (SecurityRuleDiff securityRuleDiff : ruleDiffList) {\n            ReadableSecurityRule currentRule = securityRuleDiff.getCurrentRule();\n            ReadableSecurityRule previousRule = securityRuleDiff.getPreviousRule();\n            switch (securityRuleDiff.getChangeType()) {\n                case RULE_ADDED:\n                    if (currentRule.match(Right.VIEW)) {\n                        this.creationActionRule(currentRule, true, actionsToPerform);\n                    }\n                    break;\n\n                case RULE_DELETED:\n                    if (previousRule.match(Right.VIEW)) {\n                        this.creationActionRule(previousRule, false, actionsToPerform);\n                    }\n                    break;\n\n                default:\n                case RULE_UPDATED:\n                    if (previousRule.match(Right.VIEW)) {\n                        this.creationActionRule(previousRule, false, actionsToPerform);\n                    }\n                    if (currentRule.match(Right.VIEW)) {\n                        this.creationActionRule(currentRule, true, actionsToPerform);\n                    }\n                    break;\n            }\n        }\n        return actionsToPerform;\n    }\n\n    @Override\n    public void applyChanges(ChangeRequest changeRequest, List<SecurityRuleDiff> ruleDiffList)\n        throws ChangeRequestException\n    {\n        // This methods works in two main steps:\n        //   1. we compute a list of actions to perform on rights, indexed by the reference of the group or user\n        //      targeted by the right rule. This data structure is chosen because of the way rules are normalized\n        //      with the SecurityRuleAbacus.\n        //   2. we apply the map of actions on the change request rights.\n\n        Map<DocumentReference, List<SecurityRuleAction>> actionsToPerform =\n            this.computeActionsMap(ruleDiffList);\n\n        if (!actionsToPerform.isEmpty()) {\n            this.applyActions(changeRequest, actionsToPerform, ruleDiffList);\n        }\n    }\n\n    @Override\n    public boolean isAuthorizedToMerge(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException\n    {\n        boolean result = true;\n\n        // The merger user is taken from the configuration if a merger user is defined, and this is the user\n        // who should be checked for the proper edit/delete rights.\n        // Now the approval right should only be checked on the current user reference.\n        UserReference mergerUserReference = userReference;\n        UserReference mergeUserReference = this.configuration.getMergeUser();\n        if (mergeUserReference != GuestUserReference.INSTANCE) {\n            mergerUserReference = mergeUserReference;\n        }\n        DocumentReference mergeUserDocReference = this.userReferenceConverter.convert(mergerUserReference);\n        DocumentReference currentUserDocReference = this.userReferenceConverter.convert(userReference);\n\n        // This method is only checking if the user is an approver, so even with the fallback it's possible that\n        // an admin user has approval right, but is not an approver of this specific change request, because a\n        // list of approver is defined in it. So we cannot forbid merging a change request for people who are not\n        // explicitely approvers.\n        // Instead, we check in each file if the approval right is granted in case the user is not approver:\n        // users who have proper write authorization, and proper approval right should be able to merge if they're not\n        // explicitely approvers of the given change request.\n        // This choice is mainly to avoid blocking a change request, in case approvers do not have write access\n        // which can be quite common.\n        boolean isApprover = this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)\n            || this.changeRequestDelegateApproverManager.isDelegateApproverOf(userReference, changeRequest);\n\n        for (FileChange lastFileChange : changeRequest.getLastFileChanges()) {\n            Right rightToBeChecked;\n            switch (lastFileChange.getType()) {\n                case DELETION:\n                    rightToBeChecked = Right.DELETE;\n                    break;\n\n                case EDITION:\n                case CREATION:\n                default:\n                    rightToBeChecked = Right.EDIT;\n                    break;\n            }\n            DocumentReference targetEntity = lastFileChange.getTargetEntity();\n            // We check the write right on the merge user, and the approval right on the current user.\n            boolean hasWriteRight = this.authorizationManager\n                .hasAccess(rightToBeChecked, mergeUserDocReference, targetEntity);\n            boolean hasApprovalRight = this.authorizationManager\n                .hasAccess(ChangeRequestApproveRight.getRight(), currentUserDocReference, targetEntity);\n\n            if (!(hasWriteRight && (isApprover || hasApprovalRight))) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    @Override\n    public boolean isAuthorizedToReview(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException\n    {\n        boolean result = false;\n        if (!this.configuration.preventAuthorToReview() || !(changeRequest.getAuthors().contains(userReference))) {\n            result = this.changeRequestApproversManager.isApprover(userReference, changeRequest, false);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isAuthorizedToReviewOnBehalf(UserReference userReference, ChangeRequest changeRequest,\n        UserReference originalApprover) throws ChangeRequestException\n    {\n        boolean result = false;\n        if (!this.configuration.preventAuthorToReview() || !(changeRequest.getAuthors().contains(userReference))) {\n            result = this.changeRequestDelegateApproverManager\n                .isDelegateApproverOf(userReference, changeRequest, originalApprover);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isAuthorizedToReviewAsDelegate(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException\n    {\n        boolean result = false;\n        if (!this.configuration.preventAuthorToReview() || !(changeRequest.getAuthors().contains(userReference))) {\n            result = this.changeRequestDelegateApproverManager.isDelegateApproverOf(userReference, changeRequest);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isAuthorizedToComment(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException\n    {\n        DocumentReference userDocReference = this.userReferenceConverter.convert(userReference);\n        DocumentReference changeRequestDoc = this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n        boolean hasAdminRight = this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc);\n        boolean hasCommentRight =\n            this.authorizationManager.hasAccess(Right.COMMENT, userDocReference, changeRequestDoc);\n        return hasAdminRight || this.isAuthorizedToReview(userReference, changeRequest) || hasCommentRight;\n    }\n\n    private boolean isAuthorizedToEdit(UserReference userReference, ChangeRequest changeRequest,\n        boolean checkForOpening)\n    {\n        boolean result = false;\n        ChangeRequestStatus status = changeRequest.getStatus();\n        if (status != ChangeRequestStatus.MERGED && (status.isOpen() || checkForOpening)) {\n            // if change request was created by guest, then anybody should be able to edit it.\n            if (changeRequest.getAuthors().contains(GuestUserReference.INSTANCE)\n                || changeRequest.getAuthors().contains(userReference)) {\n                result = true;\n            } else {\n                DocumentReference userDocReference = this.userReferenceConverter.convert(userReference);\n                DocumentReference changeRequestDoc = this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n                result = this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc);\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isAuthorizedToEdit(UserReference userReference, ChangeRequest changeRequest)\n    {\n        return this.isAuthorizedToEdit(userReference, changeRequest, false);\n    }\n\n    @Override\n    public boolean isAuthorizedToOpen(UserReference userReference, ChangeRequest changeRequest)\n    {\n        return this.isAuthorizedToEdit(userReference, changeRequest, true);\n    }\n\n    @Override\n    public boolean isAuthorizedToSplit(UserReference userReference, ChangeRequest changeRequest)\n    {\n        boolean result = changeRequest.getAuthors().contains(userReference);\n        if (!result) {\n            DocumentReference userDocReference = this.userReferenceConverter.convert(userReference);\n            DocumentReference crReference = this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n            result = this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, crReference);\n        }\n        return result;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest.internal.handlers;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.xwiki.container.Container;\nimport org.xwiki.contrib.changerequest.ApproversManager;\nimport org.xwiki.contrib.changerequest.ChangeRequest;\nimport org.xwiki.contrib.changerequest.ChangeRequestConfiguration;\nimport org.xwiki.contrib.changerequest.ChangeRequestException;\nimport org.xwiki.contrib.changerequest.ChangeRequestManager;\nimport org.xwiki.contrib.changerequest.ChangeRequestReference;\nimport org.xwiki.contrib.changerequest.ChangeRequestRightsManager;\nimport org.xwiki.contrib.changerequest.FileChange;\nimport org.xwiki.contrib.changerequest.internal.FileChangeVersionManager;\nimport org.xwiki.contrib.changerequest.storage.ChangeRequestStorageManager;\nimport org.xwiki.contrib.changerequest.storage.FileChangeStorageManager;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.wysiwyg.converter.RequestParameterConverter;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.web.EditForm;\nimport com.xpn.xwiki.web.XWikiResponse;\n\n/**\n * Abstract implementation of {@link ChangeRequestActionHandler} which provides some utility methods.\n *\n * @version $Id$\n * @since 0.3\n */\npublic abstract class AbstractChangeRequestActionHandler implements ChangeRequestActionHandler\n{\n    static final String PREVIOUS_VERSION_PARAMETER = \"previousVersion\";\n    static final String FROM_CHANGE_REQUEST_PARAMETER = \"fromchangerequest\";\n    private static final String ASYNC_PARAMETER = \"async\";\n\n    @Inject\n    protected Provider<XWikiContext> contextProvider;\n\n    @Inject\n    protected DocumentReferenceResolver<ChangeRequest> changeRequestDocumentReferenceResolver;\n\n    @Inject\n    protected ChangeRequestStorageManager storageManager;\n\n    @Inject\n    protected ObservationManager observationManager;\n\n    @Inject\n    @Named(\"current\")\n    protected DocumentReferenceResolver<String> documentReferenceResolver;\n\n    @Inject\n    protected FileChangeStorageManager fileChangeStorageManager;\n\n    @Inject\n    protected Container container;\n\n    @Inject\n    protected FileChangeVersionManager fileChangeVersionManager;\n\n    @Inject\n    protected ChangeRequestRightsManager changeRequestRightsManager;\n\n    @Inject\n    protected ChangeRequestManager changeRequestManager;\n\n    @Inject\n    private RequestParameterConverter requestParameterConverter;\n\n    @Inject\n    private ContextualAuthorizationManager contextualAuthorizationManager;\n\n    @Inject\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    @Inject\n    private UserReferenceResolver<CurrentUserReference> currentUserReferenceResolver;\n\n    @Inject\n    private ApproversManager<FileChange> fileChangeApproversManager;\n\n    @Inject\n    private ApproversManager<ChangeRequest> changeRequestApproversManager;\n\n    @Inject\n    private ChangeRequestConfiguration configuration;\n\n    @Inject\n    private ContextualLocalizationManager contextualLocalizationManager;\n\n    protected HttpServletRequest prepareRequest() throws ChangeRequestException\n    {\n        XWikiContext context = this.contextProvider.get();\n        HttpServletRequest request = context.getRequest();\n        try {\n            return (HttpServletRequest) this.requestParameterConverter.convert(request, context.getResponse()).get();\n        } catch (IOException e) {\n            throw new ChangeRequestException(\"Error while converting request\", e);\n        }\n    }\n\n    protected EditForm prepareForm(HttpServletRequest request)\n    {\n        EditForm editForm = new EditForm();\n        editForm.setRequest(request);\n        editForm.readRequest();\n        return editForm;\n    }\n\n    protected void redirectToChangeRequest(ChangeRequest changeRequest) throws IOException\n    {\n        this.redirectToChangeRequest(changeRequest, \"view\");\n    }\n\n    protected void redirectToChangeRequest(ChangeRequest changeRequest, String action) throws IOException\n    {\n        XWikiContext context = this.contextProvider.get();\n        DocumentReference changeRequestDocumentReference =\n            this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n        String url = context.getWiki().getURL(changeRequestDocumentReference, action, context);\n        context.getResponse().sendRedirect(url);\n    }\n\n    protected ChangeRequest loadChangeRequest(ChangeRequestReference reference)\n        throws ChangeRequestException, IOException\n    {\n        Optional<ChangeRequest> changeRequestOptional = this.storageManager.load(reference.getId());\n        if (changeRequestOptional.isPresent()) {\n            return changeRequestOptional.get();\n        } else {\n            XWikiContext context = this.contextProvider.get();\n            context.getResponse().sendError(404, String.format(\"Cannot find change request with id [%s]\",\n                    reference.getId()));\n        }\n        return null;\n    }\n\n    protected boolean isFromChangeRequest(HttpServletRequest request)\n    {\n        return StringUtils.equals(request.getParameter(FROM_CHANGE_REQUEST_PARAMETER), \"1\");\n    }\n\n    protected String getPreviousVersion(HttpServletRequest request)\n    {\n        String previousVersionParameter = request.getParameter(PREVIOUS_VERSION_PARAMETER);\n        if (isFromChangeRequest(request)) {\n            return this.fileChangeVersionManager.getFileChangeVersion(previousVersionParameter);\n        } else {\n            return previousVersionParameter;\n        }\n    }\n\n    protected XWikiDocument prepareDocument(HttpServletRequest request, EditForm editForm, ChangeRequest changeRequest)\n        throws ChangeRequestException\n    {\n        XWikiContext context = this.contextProvider.get();\n        String serializedDocReference = request.getParameter(\"docReference\");\n        DocumentReference documentReference = this.documentReferenceResolver.resolve(serializedDocReference);\n\n        XWikiDocument modifiedDocument = null;\n        try {\n            if (isFromChangeRequest(request) && changeRequest != null) {\n                List<FileChange> fileChangeList = this.fileChangeStorageManager.load(changeRequest, documentReference);\n                String previousVersion = getPreviousVersion(request);\n                FileChange fileChange = null;\n                for (FileChange change : fileChangeList) {\n                    if (change.getVersion().equals(previousVersion)) {\n                        fileChange = change;\n                        break;\n                    }\n                }\n                if (fileChange != null) {\n                    modifiedDocument = (XWikiDocument) fileChange.getModifiedDocument();\n                } else {\n                    throw new ChangeRequestException(\n                        String.format(\"Cannot find file change with version [%s]\", previousVersion));\n                }\n            } else {\n                modifiedDocument = context.getWiki().getDocument(documentReference, context);\n            }\n            // cloning the document to ensure we don't impact the document in cache.\n            modifiedDocument = modifiedDocument.clone();\n\n            // Read info from the template if there's one.\n            if (!StringUtils.isBlank(editForm.getTemplate())) {\n                DocumentReference templateRef =\n                    this.currentMixedDocumentReferenceResolver.resolve(editForm.getTemplate());\n\n                // Check that the template can be read by current user.\n                if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, templateRef)) {\n                    modifiedDocument.readFromTemplate(templateRef, context);\n                }\n            }\n\n            modifiedDocument.readFromForm(editForm, context);\n            if (modifiedDocument.getDefaultLocale() == Locale.ROOT) {\n                modifiedDocument.setDefaultLocale(context.getWiki().getLocalePreference(context));\n            }\n            return modifiedDocument;\n        } catch (XWikiException e) {\n            throw new ChangeRequestException(\n                String.format(\"Cannot read document [%s]\", serializedDocReference), e);\n        }\n    }\n\n    protected void responseSuccess(ChangeRequest changeRequest) throws IOException\n    {\n        XWikiContext context = this.contextProvider.get();\n        if (this.isAsync(context.getRequest())) {\n            Map<String, String> json = new HashMap<>();\n            json.put(\"changeRequestId\", changeRequest.getId());\n            DocumentReference changeRequestRef = this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n            json.put(\"changeRequestUrl\", context.getWiki().getURL(changeRequestRef, context));\n            this.answerJSON(HttpServletResponse.SC_OK, json);\n        } else {\n            this.redirectToChangeRequest(changeRequest);\n        }\n    }\n\n    protected boolean isAsync(HttpServletRequest request)\n    {\n        return \"1\".equals(request.getParameter(ASYNC_PARAMETER));\n    }\n\n    /**\n     * Answer to a request with a JSON content.\n     * Note: this method was partially copied from {@link com.xpn.xwiki.web.XWikiAction}.\n     *\n     * @param status the status code to send back.\n     * @param answer the content of the JSON answer.\n     * @throws IOException in case of error during the serialization of the JSON.\n     */\n    protected void answerJSON(int status, Map<String, String> answer) throws IOException\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        XWikiContext context = contextProvider.get();\n        XWikiResponse response = context.getResponse();\n        String jsonAnswerAsString = mapper.writeValueAsString(answer);\n        String encoding = context.getWiki().getEncoding();\n        response.setContentType(\"application/json\");\n        // Set the content length to the number of bytes, not the\n        // string length, so as to handle multi-byte encodings\n        response.setContentLength(jsonAnswerAsString.getBytes(encoding).length);\n        response.setStatus(status);\n        response.setCharacterEncoding(encoding);\n        response.getWriter().print(jsonAnswerAsString);\n        context.setResponseSent(true);\n    }\n\n    protected UserReference getCurrentUser()\n    {\n        return this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n    }\n\n    protected void copyApprovers(FileChange fileChange) throws ChangeRequestException\n    {\n        ChangeRequest changeRequest = fileChange.getChangeRequest();\n\n        // Existing approvers of the change request.\n        Set<UserReference> usersCRApprovers =\n            new LinkedHashSet<>(this.changeRequestApproversManager.getAllApprovers(changeRequest, false));\n        Set<DocumentReference> groupsCRApprovers =\n            new LinkedHashSet<>(this.changeRequestApproversManager.getGroupsApprovers(changeRequest));\n\n        usersCRApprovers.addAll(this.fileChangeApproversManager.getAllApprovers(fileChange, false));\n        groupsCRApprovers.addAll(this.fileChangeApproversManager.getGroupsApprovers(fileChange));\n\n        // If the authored are prevented to review, we ensure to remove it from the list of users approvers.\n        if (this.configuration.preventAuthorToReview()) {\n            usersCRApprovers.remove(fileChange.getAuthor());\n        }\n\n        if (!groupsCRApprovers.isEmpty()) {\n            this.changeRequestApproversManager.setGroupsApprovers(groupsCRApprovers, changeRequest);\n        }\n        if (!usersCRApprovers.isEmpty()) {\n            this.changeRequestApproversManager.setUsersApprovers(usersCRApprovers, changeRequest);\n        }\n    }\n\n    protected void reportError(int statusCode, String localizationKey, Object... parameters) throws IOException\n    {\n        this.answerJSON(statusCode, Collections.singletonMap(\"changeRequestError\",\n            this.contextualLocalizationManager.getTranslationPlain(localizationKey, parameters)));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest.script;\n\nimport java.util.List;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.contrib.changerequest.ChangeRequest;\nimport org.xwiki.contrib.changerequest.ChangeRequestException;\nimport org.xwiki.contrib.changerequest.ChangeRequestRightsManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.script.service.ScriptService;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\n\n/**\n * Script service dedicated to perform authorization check for change request.\n *\n * @version $Id$\n * @since 0.11\n */\n\n@Component\n@Named(\"changerequest.authorization\")\n@Singleton\n@Unstable\npublic class ChangeRequestAuthorizationScriptService implements ScriptService\n{\n    @Inject\n    private ChangeRequestRightsManager changeRequestRightsManager;\n\n    @Inject\n    private AuthorizationManager authorizationManager;\n\n    @Inject\n    private UserReferenceResolver<CurrentUserReference> currentUserReferenceResolver;\n\n    /**\n     * Check if the current user can edit the change request.\n     *\n     * @param changeRequest the change request for which to check the authors.\n     * @return {@code true} if the current user is one of the author of the given change request and the change request\n     *          is not merged or closed yet.\n     * @since 0.7\n     */\n    public boolean isAuthorizedToEdit(ChangeRequest changeRequest)\n    {\n        UserReference currentUser = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToEdit(currentUser, changeRequest);\n    }\n\n    /**\n     * Check if the current user can comment a change request.\n     * @param changeRequest the change request for which to check if it can be commented.\n     * @return {@code true} if the current user is authorized to comment the change request.\n     * @throws ChangeRequestException in case of problem to check the authorization.\n     * @see ChangeRequestRightsManager#isAuthorizedToComment(UserReference, ChangeRequest)\n     * @since 0.11\n     */\n    public boolean isAuthorizedToComment(ChangeRequest changeRequest) throws ChangeRequestException\n    {\n        UserReference currentUser = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToComment(currentUser, changeRequest);\n    }\n\n    /**\n     * Check if the current user is authorized to merge the given changed request.\n     *\n     * @param changeRequest the change request to be checked for merging authorization.\n     * @return {@code true} if the current user has proper rights to merge the given change request.\n     * @throws ChangeRequestException in case of problem when checking the role of the user.\n     * @since 0.3\n     */\n    @Unstable\n    public boolean isAuthorizedToMerge(ChangeRequest changeRequest) throws ChangeRequestException\n    {\n        UserReference currentUser = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToMerge(currentUser, changeRequest);\n    }\n\n    /**\n     * Check if the current user can edit the change request.\n     *\n     * @param changeRequest the change request for which to check the authors.\n     * @return {@code true} if the current user is one of the author of the given change request and the change request\n     *          is not merged yet.\n     * @since 0.9\n     */\n    public boolean isAuthorizedToOpen(ChangeRequest changeRequest)\n    {\n        UserReference currentUser = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToOpen(currentUser, changeRequest);\n    }\n\n    /**\n     * Check if the current user is authorized to review the given change request.\n     *\n     * @param changeRequest the change request about to be reviewed.\n     * @return {@code true} if the change request can be reviewed by current user.\n     * @throws ChangeRequestException in case of problem when checking if an user is an approver.\n     */\n    public boolean isAuthorizedToReview(ChangeRequest changeRequest) throws ChangeRequestException\n    {\n        UserReference currentUserReference = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToReview(currentUserReference, changeRequest);\n    }\n\n    /**\n     * Check if the current user is authorized to perform a review on behalf of the original approver, on the given\n     * change request.\n     * This should only returns {@code true} if the delegate approver mechanism is enabled, the original approver is an\n     * explicit approver and the current user is a delegate approver of them.\n     *\n     * @param changeRequest the change request for which to check the authorization\n     * @param originalApprover the user on behalf of whom the authorization might be given\n     * @return {@code true} if the delegate mechanism is enabled and the current user  is not an author, and is a\n     *         delegate of the original approver who is also an approver of the given change request.\n     * @throws ChangeRequestException in case of problem to resolve the delegate approvers.\n     * @since 0.13\n     */\n    @Unstable\n    public boolean isAuthorizedToReviewOnBehalf(ChangeRequest changeRequest, UserReference originalApprover)\n        throws ChangeRequestException\n    {\n        UserReference currentUserReference = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager\n            .isAuthorizedToReviewOnBehalf(currentUserReference, changeRequest, originalApprover);\n    }\n\n    /**\n     * Check if the current user is authorized to perform a review as a delegate of one of the approver of the given\n     * change request.\n     * This should only returns {@code true} if the delegate mechanism is enabled, the change request has explicit\n     * approvers, and  the current user is a delegate of at least one of them. Moreover, this cannot return {@code true}\n     * if the given user is an author of the change request.\n     *\n     * @param changeRequest the change request for which to check the authorization\n     * @return {@code true} if the delegate mechanism is enabled, the change request has explicit\n     *         approvers, the current user is not an author of the change request, and is a delegate of at least one of\n     *         the approvers.\n     * @throws ChangeRequestException in case of problem to resolve the delegate approvers.\n     * @since 0.13\n     */\n    public boolean isAuthorizedToReviewAsDelegate(ChangeRequest changeRequest)\n        throws ChangeRequestException\n    {\n        UserReference currentUserReference = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToReviewAsDelegate(currentUserReference, changeRequest);\n    }\n\n    /**\n     * Check if the given user is authorized to perform a review as a delegate of one of the approver of the given\n     * change request.\n     * This should only returns {@code true} if the delegate mechanism is enabled, the change request has explicit\n     * approvers, and  the current user is a delegate of at least one of them. Moreover, this cannot return {@code true}\n     * if the given user is an author of the change request.\n     *\n     * @param changeRequest the change request for which to check the authorization\n     * @param userReference the user for which to check if they can review\n     * @return {@code true} if the delegate mechanism is enabled, the change request has explicit\n     *         approvers, the user is not an author of the change request, and is a delegate of at least one of\n     *         the approvers.\n     * @throws ChangeRequestException in case of problem to resolve the delegate approvers.\n     * @since 0.14\n     */\n    public boolean isAuthorizedToReviewAsDelegate(ChangeRequest changeRequest, UserReference userReference)\n        throws ChangeRequestException\n    {\n        return this.changeRequestRightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest);\n    }\n\n    /**\n     * Check if the given user is authorized to review the given change request.\n     *\n     * @param changeRequest the change request about to be reviewed.\n     * @param userReference the user for which to check if they can review\n     * @return {@code true} if the change request can be reviewed by the given user.\n     * @throws ChangeRequestException in case of problem when checking if an user is an approver.\n     * @since 0.9\n     */\n    @Unstable\n    public boolean isAuthorizedToReview(ChangeRequest changeRequest, UserReference userReference)\n        throws ChangeRequestException\n    {\n        return this.changeRequestRightsManager.isAuthorizedToReview(userReference, changeRequest);\n    }\n\n    /**\n     * Check if the list of users have view rights to the concerned document: this is a necessary condition for users\n     * to be approvers.\n     *\n     * @param concernedDoc the doc for which to assign approvers\n     * @param userReferenceList the proposed approvers for which to test rights\n     * @return {@code true} if all proposed users have view rights to the concerned doc\n     * @since 1.1\n     */\n    @Unstable\n    public boolean haveApproversViewRights(DocumentReference concernedDoc, List<DocumentReference> userReferenceList)\n    {\n        boolean result = true;\n        if (userReferenceList != null) {\n            for (DocumentReference userDoc : userReferenceList) {\n                result &= this.authorizationManager.hasAccess(Right.VIEW, userDoc, concernedDoc);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Check if the current user is authorized to split the change request.\n     *\n     * @param changeRequest the change request to split\n     * @return {@code true} if the current user is authorized to perform a split\n     */\n    public boolean isAuthorizedToSplit(ChangeRequest changeRequest)\n    {\n        UserReference currentUserReference = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToSplit(currentUserReference, changeRequest);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest.internal;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport javax.inject.Inject;\n\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.contrib.changerequest.ApproversManager;\nimport org.xwiki.contrib.changerequest.ChangeRequest;\nimport org.xwiki.contrib.changerequest.ChangeRequestConfiguration;\nimport org.xwiki.contrib.changerequest.ChangeRequestException;\nimport org.xwiki.contrib.changerequest.ChangeRequestStatus;\nimport org.xwiki.contrib.changerequest.DelegateApproverManager;\nimport org.xwiki.contrib.changerequest.FileChange;\nimport org.xwiki.contrib.changerequest.internal.approvers.ChangeRequestApproversManager;\nimport org.xwiki.contrib.rights.RightsReader;\nimport org.xwiki.contrib.rights.RightsWriter;\nimport org.xwiki.contrib.rights.SecurityRuleAbacus;\nimport org.xwiki.contrib.rights.SecurityRuleDiff;\nimport org.xwiki.contrib.rights.WritableSecurityRule;\nimport org.xwiki.contrib.rights.internal.WritableSecurityRuleImpl;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.security.authorization.AuthorizationException;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ReadableSecurityRule;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.security.authorization.RightSet;\nimport org.xwiki.security.authorization.RuleState;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.user.GuestUserReference;\nimport org.xwiki.user.UserReference;\n\nimport com.xpn.xwiki.XWikiException;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoInteractions;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link DefaultChangeRequestRightsManager}.\n *\n * @version $Id$\n * @since 0.7\n */\n@ComponentTest\nclass DefaultChangeRequestRightsManagerTest\n{\n    @InjectMockComponents\n    private DefaultChangeRequestRightsManager rightsManager;\n\n    @MockComponent\n    private DocumentReferenceResolver<ChangeRequest> changeRequestDocumentReferenceResolver;\n\n    @MockComponent\n    private AuthorizationManager authorizationManager;\n\n    @MockComponent\n    private RightsWriter rightsWriter;\n\n    @MockComponent\n    private SecurityRuleAbacus ruleAbacus;\n\n    @MockComponent\n    private RightsReader rightsReader;\n\n    @MockComponent\n    private UserReferenceConverter userReferenceConverter;\n\n    @MockComponent\n    private ChangeRequestConfiguration configuration;\n\n    @MockComponent\n    private ApproversManager<ChangeRequest> changeRequestApproversManager;\n\n    @MockComponent\n    private DelegateApproverManager<ChangeRequest> changeRequestDelegateApproverManager;\n\n    @Test\n    void copyAllButViewRights() throws AuthorizationException, ChangeRequestException, XWikiException\n    {\n        ChangeRequest sourceChangeRequest = mock(ChangeRequest.class);\n        ChangeRequest targetChangeRequest = mock(ChangeRequest.class);\n\n        DocumentReference sourceDocReference = mock(DocumentReference.class);\n        DocumentReference targetDocReference = mock(DocumentReference.class);\n\n        when(this.changeRequestDocumentReferenceResolver.resolve(sourceChangeRequest)).thenReturn(sourceDocReference);\n        when(this.changeRequestDocumentReferenceResolver.resolve(targetChangeRequest)).thenReturn(targetDocReference);\n\n        SpaceReference sourceSpaceReference = mock(SpaceReference.class);\n        when(sourceDocReference.getLastSpaceReference()).thenReturn(sourceSpaceReference);\n\n        SpaceReference targetSpaceReference = mock(SpaceReference.class);\n        when(targetDocReference.getLastSpaceReference()).thenReturn(targetSpaceReference);\n\n        ReadableSecurityRule rule1 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule rule2 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule rule3 = mock(ReadableSecurityRule.class);\n\n        when(this.rightsReader.getRules(sourceSpaceReference, false))\n            .thenReturn(Arrays.asList(rule1, rule2, rule3));\n\n        when(rule1.match(Right.VIEW)).thenReturn(true);\n        when(rule2.match(Right.VIEW)).thenReturn(false);\n        when(rule3.match(Right.VIEW)).thenReturn(true);\n\n        WritableSecurityRule rule1bis = mock(WritableSecurityRule.class);\n        WritableSecurityRule rule3bis = mock(WritableSecurityRule.class);\n\n        when(this.rightsWriter.createRule(rule1)).thenReturn(rule1bis);\n        when(this.rightsWriter.createRule(rule3)).thenReturn(rule3bis);\n\n        when(rule1bis.getRights()).thenReturn(new RightSet(Right.VIEW));\n        when(rule3bis.getRights()).thenReturn(new RightSet(Right.VIEW, Right.EDIT));\n\n        this.rightsManager.copyAllButViewRights(sourceChangeRequest, targetChangeRequest);\n        verify(rule3bis).setRights(new RightSet(Right.EDIT));\n        verify(this.rightsWriter).saveRules(Arrays.asList(rule2, rule3bis), targetSpaceReference);\n    }\n\n    @Test\n    void isViewAccessConsistent() throws AuthorizationException, ChangeRequestException\n    {\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n        DocumentReference newChangeReference = mock(DocumentReference.class);\n\n        DocumentReference docRef1 = mock(DocumentReference.class);\n        DocumentReference docRef2 = mock(DocumentReference.class);\n\n        when(changeRequest.getModifiedDocuments()).thenReturn(Stream.of(docRef1, docRef2).collect(Collectors.toSet()));\n\n        List<ReadableSecurityRule> rulesDoc1 = mock(List.class);\n        List<ReadableSecurityRule> rulesDoc2 = mock(List.class);\n        List<ReadableSecurityRule> rulesNewChange = mock(List.class);\n\n        when(this.rightsReader.getActualRules(docRef1)).thenReturn(rulesDoc1);\n        ReadableSecurityRule doc1rule1 = mock(ReadableSecurityRule.class);\n        when(doc1rule1.match(Right.VIEW)).thenReturn(false);\n\n        when(this.ruleAbacus.normalizeRulesBySubject(rulesDoc1)).thenReturn(Collections.singletonList(doc1rule1));\n\n        when(this.rightsReader.getActualRules(docRef2)).thenReturn(rulesDoc2);\n        ReadableSecurityRule doc2rule1 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule doc2rule2 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule doc2rule3 = mock(ReadableSecurityRule.class);\n\n        when(doc2rule1.match(Right.VIEW)).thenReturn(true);\n        when(doc2rule2.match(Right.VIEW)).thenReturn(false);\n        when(doc2rule3.match(Right.VIEW)).thenReturn(true);\n\n        DocumentReference groupARef = mock(DocumentReference.class);\n        DocumentReference groupBRef = mock(DocumentReference.class);\n        when(doc2rule1.getGroups()).thenReturn(Arrays.asList(groupARef, groupBRef));\n\n        DocumentReference userFooRef = mock(DocumentReference.class);\n        when(doc2rule3.getUsers()).thenReturn(Collections.singletonList(userFooRef));\n\n        when(this.ruleAbacus.normalizeRulesBySubject(rulesDoc2))\n            .thenReturn(Arrays.asList(doc2rule1, doc2rule2, doc2rule3));\n\n        when(this.rightsReader.getActualRules(newChangeReference)).thenReturn(rulesNewChange);\n\n        ReadableSecurityRule newChangeRule1 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule newChangeRule2 = mock(ReadableSecurityRule.class);\n\n        when(newChangeRule1.match(Right.VIEW)).thenReturn(true);\n        when(newChangeRule2.match(Right.VIEW)).thenReturn(true);\n\n        DocumentReference userBarRef = mock(DocumentReference.class);\n        when(newChangeRule1.getUsers()).thenReturn(Arrays.asList(userFooRef, userBarRef));\n        when(newChangeRule2.getGroups()).thenReturn(Collections.singletonList(groupBRef));\n\n        when(this.ruleAbacus.normalizeRulesBySubject(rulesNewChange))\n            .thenReturn(Arrays.asList(newChangeRule1, newChangeRule2));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, groupARef, docRef1)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, groupARef, docRef2)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, groupARef, newChangeReference)).thenReturn(true);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, groupBRef, docRef1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, groupBRef, docRef2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, groupBRef, newChangeReference)).thenReturn(false);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, userFooRef, docRef1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, userFooRef, docRef2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, userFooRef, newChangeReference)).thenReturn(false);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, userBarRef, docRef1)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, userBarRef, docRef2)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, userBarRef, newChangeReference)).thenReturn(true);\n\n        assertTrue(this.rightsManager.isViewAccessConsistent(changeRequest, newChangeReference));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, userBarRef, docRef2)).thenReturn(false);\n\n        assertFalse(this.rightsManager.isViewAccessConsistent(changeRequest, newChangeReference));\n    }\n\n    @Test\n    void isViewAccessStillConsistent() throws ChangeRequestException\n    {\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        DocumentReference doc1 = mock(DocumentReference.class);\n        DocumentReference doc2 = mock(DocumentReference.class);\n        DocumentReference doc3 = mock(DocumentReference.class);\n\n        when(changeRequest.getModifiedDocuments()).thenReturn(Stream.of(doc1, doc2, doc3).collect(Collectors.toSet()));\n\n        DocumentReference user1 = mock(DocumentReference.class);\n        DocumentReference user2 = mock(DocumentReference.class);\n        DocumentReference user3 = mock(DocumentReference.class);\n        Set<DocumentReference> userSet = Stream.of(user1, user2, user3).collect(Collectors.toSet());\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc1)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc2)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc3)).thenReturn(true);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc1)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc2)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc3)).thenReturn(true);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc1)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc2)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc3)).thenReturn(true);\n\n        assertTrue(this.rightsManager.isViewAccessStillConsistent(changeRequest, userSet));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc1)).thenReturn(false);\n        assertFalse(this.rightsManager.isViewAccessStillConsistent(changeRequest, userSet));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc3)).thenReturn(false);\n        assertTrue(this.rightsManager.isViewAccessStillConsistent(changeRequest, userSet));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc2)).thenReturn(false);\n        assertFalse(this.rightsManager.isViewAccessStillConsistent(changeRequest, userSet));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc3)).thenReturn(false);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc3)).thenReturn(false);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc3)).thenReturn(false);\n\n        assertTrue(this.rightsManager.isViewAccessStillConsistent(changeRequest, userSet));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc3)).thenReturn(true);\n        assertFalse(this.rightsManager.isViewAccessStillConsistent(changeRequest, userSet));\n    }\n\n    @Test\n    void copyViewRights() throws AuthorizationException, ChangeRequestException, XWikiException\n    {\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n        DocumentReference changeRequestDocReference = mock(DocumentReference.class);\n        SpaceReference changeRequestSpaceReference = mock(SpaceReference.class);\n\n        DocumentReference newChange = mock(DocumentReference.class);\n        WikiReference wikiReference = new WikiReference(\"foo\");\n        when(newChange.getWikiReference()).thenReturn(wikiReference);\n\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDocReference);\n        when(changeRequestDocReference.getLastSpaceReference()).thenReturn(changeRequestSpaceReference);\n\n        WritableSecurityRule crRule1 = mock(WritableSecurityRule.class);\n        WritableSecurityRule crRule2 = mock(WritableSecurityRule.class);\n        WritableSecurityRule crRule3 = mock(WritableSecurityRule.class);\n\n        List<ReadableSecurityRule> crRules = mock(List.class);\n        when(this.rightsReader.getRules(changeRequestSpaceReference, false))\n            .thenReturn(crRules);\n        when(this.rightsWriter.createRules(crRules)).thenReturn(Arrays.asList(crRule1, crRule2, crRule3));\n\n        ReadableSecurityRule newChangeRule1 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule newChangeRule2 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule newChangeRule3 = mock(ReadableSecurityRule.class);\n\n        when(this.rightsReader.getActualRules(newChange))\n            .thenReturn(Arrays.asList(newChangeRule1, newChangeRule2, newChangeRule3));\n\n        ReadableSecurityRule wikiRule1 = mock(ReadableSecurityRule.class);\n        when(this.rightsReader.getActualRules(wikiReference)).thenReturn(Arrays.asList(wikiRule1, newChangeRule2));\n\n        when(newChangeRule1.match(Right.VIEW)).thenReturn(false);\n        when(newChangeRule3.match(Right.VIEW)).thenReturn(true);\n\n        WritableSecurityRule rule3bis = mock(WritableSecurityRule.class);\n        when(this.rightsWriter.createRule(newChangeRule3)).thenReturn(rule3bis);\n\n        this.rightsManager.copyViewRights(changeRequest, newChange);\n        verify(rule3bis).setRights(Collections.singletonList(Right.VIEW));\n        verify(this.rightsWriter).saveRules(Arrays.asList(crRule1, crRule2, crRule3, rule3bis),\n            changeRequestSpaceReference);\n    }\n\n    @Test\n    void applyChanges() throws AuthorizationException, ChangeRequestException, XWikiException\n    {\n        // Scenario:\n        // Change request containing following rights:\n        //   - Allow view,edit,script on XWiki.AdminGroup\n        //   - Deny view,edit on XWiki.Foo\n        //   - Deny edit on XWiki.Bar\n        //   - Allow view on XWiki.AllGroup\n        //\n        // Diff contains following changes:\n        //   - Update to remove allow view on XWiki.AdminGroup\n        //   - Update Deny view on XWiki.Foo (2 rules: one to remove Deny view, one to add Allow view)\n        //   - Update deny edit to allow edit on XWiki.bar (2 rules: one to remove Deny edit, one to add Allow edit)\n        //   - Add allow view on XWiki.Buz\n        //   - Remove Allow view on XWiki.AllGroup\n        //\n        // Expected rights after applying:\n        //   - Allow edit,script on XWiki.AdminGroup\n        //   - Deny edit on XWiki.Foo\n        //   - Allow view on XWiki.Foo\n        //   - Deny edit on XWiki.Bar\n        //   - Allow view on XWiki.Buz\n\n        DocumentReference adminGroupRef = new DocumentReference(\"xwiki\", \"XWiki\", \"AdminGroup\");\n        DocumentReference allGroupRef = new DocumentReference(\"xwiki\", \"XWiki\", \"AllGroup\");\n\n        DocumentReference fooUserRef = new DocumentReference(\"xwiki\", \"XWiki\", \"Foo\");\n        DocumentReference barUserRef = new DocumentReference(\"xwiki\", \"XWiki\", \"Bar\");\n        DocumentReference buzUserRef = new DocumentReference(\"xwiki\", \"XWiki\", \"Buz\");\n\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        // diff1: Update to remove allow view on XWiki.AdminGroup\n        SecurityRuleDiff diff1 = mock(SecurityRuleDiff.class);\n\n        when(diff1.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_UPDATED);\n        ReadableSecurityRule previousRule = mock(ReadableSecurityRule.class);\n        when(diff1.getPreviousRule()).thenReturn(previousRule);\n        when(previousRule.getGroups()).thenReturn(Collections.singletonList(adminGroupRef));\n        when(previousRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW, Right.EDIT, Right.SCRIPT)));\n        when(previousRule.getState()).thenReturn(RuleState.ALLOW);\n        when(previousRule.match(Right.VIEW)).thenReturn(true);\n\n        ReadableSecurityRule currentRule = mock(ReadableSecurityRule.class);\n        when(diff1.getCurrentRule()).thenReturn(currentRule);\n        when(currentRule.getGroups()).thenReturn(Collections.singletonList(adminGroupRef));\n        when(currentRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.EDIT, Right.SCRIPT)));\n        when(currentRule.getState()).thenReturn(RuleState.ALLOW);\n        when(currentRule.match(Right.VIEW)).thenReturn(false);\n\n        // diff2: Update Deny view on XWiki.Foo (2 rules: one to remove Deny view, one to add Allow view)\n        SecurityRuleDiff diff2_1 = mock(SecurityRuleDiff.class);\n\n        when(diff2_1.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_UPDATED);\n        previousRule = mock(ReadableSecurityRule.class);\n        when(diff2_1.getPreviousRule()).thenReturn(previousRule);\n        when(previousRule.getUsers()).thenReturn(Collections.singletonList(fooUserRef));\n        when(previousRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW, Right.EDIT)));\n        when(previousRule.getState()).thenReturn(RuleState.DENY);\n        when(previousRule.match(Right.VIEW)).thenReturn(true);\n\n        currentRule = mock(ReadableSecurityRule.class);\n        when(diff2_1.getCurrentRule()).thenReturn(currentRule);\n        when(currentRule.getUsers()).thenReturn(Collections.singletonList(fooUserRef));\n        when(currentRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.EDIT)));\n        when(currentRule.getState()).thenReturn(RuleState.DENY);\n        when(currentRule.match(Right.VIEW)).thenReturn(false);\n\n        SecurityRuleDiff diff2_2 = mock(SecurityRuleDiff.class);\n\n        when(diff2_2.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_ADDED);\n        currentRule = mock(ReadableSecurityRule.class);\n        when(diff2_2.getCurrentRule()).thenReturn(currentRule);\n        when(currentRule.getUsers()).thenReturn(Collections.singletonList(fooUserRef));\n        when(currentRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW)));\n        when(currentRule.getState()).thenReturn(RuleState.ALLOW);\n        when(currentRule.match(Right.VIEW)).thenReturn(true);\n\n        // diff3: Update deny edit to allow edit on XWiki.bar (2 rules: one to remove Deny edit, one to add Allow edit)\n\n        SecurityRuleDiff diff3_1 = mock(SecurityRuleDiff.class);\n\n        when(diff3_1.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_DELETED);\n        previousRule = mock(ReadableSecurityRule.class);\n        when(diff3_1.getPreviousRule()).thenReturn(previousRule);\n        when(previousRule.getUsers()).thenReturn(Collections.singletonList(barUserRef));\n        when(previousRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.EDIT)));\n        when(previousRule.getState()).thenReturn(RuleState.DENY);\n        when(previousRule.match(Right.VIEW)).thenReturn(false);\n\n        SecurityRuleDiff diff3_2 = mock(SecurityRuleDiff.class);\n\n        when(diff3_2.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_ADDED);\n        currentRule = mock(ReadableSecurityRule.class);\n        when(diff3_2.getCurrentRule()).thenReturn(currentRule);\n        when(currentRule.getUsers()).thenReturn(Collections.singletonList(barUserRef));\n        when(currentRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.EDIT)));\n        when(currentRule.getState()).thenReturn(RuleState.ALLOW);\n        when(currentRule.match(Right.VIEW)).thenReturn(false);\n\n        // diff4: Add allow view on XWiki.Buz\n\n        SecurityRuleDiff diff4 = mock(SecurityRuleDiff.class);\n\n        when(diff4.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_ADDED);\n        currentRule = mock(ReadableSecurityRule.class);\n        when(diff4.getCurrentRule()).thenReturn(currentRule);\n        when(currentRule.getUsers()).thenReturn(Collections.singletonList(buzUserRef));\n        when(currentRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW)));\n        when(currentRule.getState()).thenReturn(RuleState.ALLOW);\n        when(currentRule.match(Right.VIEW)).thenReturn(true);\n\n        // diff5: Remove Allow view on XWiki.AllGroup\n        SecurityRuleDiff diff5 = mock(SecurityRuleDiff.class);\n\n        when(diff5.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_DELETED);\n        previousRule = mock(ReadableSecurityRule.class);\n        when(diff5.getPreviousRule()).thenReturn(previousRule);\n        when(previousRule.getGroups()).thenReturn(Collections.singletonList(allGroupRef));\n        when(previousRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW)));\n        when(previousRule.getState()).thenReturn(RuleState.ALLOW);\n        when(previousRule.match(Right.VIEW)).thenReturn(true);\n\n        DocumentReference changeRequestDocRef = mock(DocumentReference.class);\n        SpaceReference changeRequestSpaceRef = mock(SpaceReference.class);\n        when(changeRequestDocRef.getLastSpaceReference()).thenReturn(changeRequestSpaceRef);\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDocRef);\n\n        List rules = mock(List.class);\n        when(this.rightsReader.getRules(changeRequestSpaceRef, false)).thenReturn(rules);\n\n        List<ReadableSecurityRule> normalizedRules = new ArrayList<>();\n\n        // rule1: Allow view,edit,script on XWiki.AdminGroup\n        ReadableSecurityRule rule1 = mock(ReadableSecurityRule.class);\n        when(rule1.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW, Right.EDIT, Right.SCRIPT)));\n        when(rule1.getState()).thenReturn(RuleState.ALLOW);\n        when(rule1.getGroups()).thenReturn(Arrays.asList(adminGroupRef));\n        normalizedRules.add(rule1);\n\n        // rule2: Deny view,edit on XWiki.Foo\n        ReadableSecurityRule rule2 = mock(ReadableSecurityRule.class);\n        when(rule2.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW, Right.EDIT)));\n        when(rule2.getState()).thenReturn(RuleState.DENY);\n        when(rule2.getUsers()).thenReturn(Arrays.asList(fooUserRef));\n        normalizedRules.add(rule2);\n\n        // rule3: Deny edit on XWiki.Bar\n        ReadableSecurityRule rule3 = mock(ReadableSecurityRule.class);\n        when(rule3.getRights()).thenReturn(new RightSet(Arrays.asList(Right.EDIT)));\n        when(rule3.getState()).thenReturn(RuleState.DENY);\n        when(rule3.getUsers()).thenReturn(Arrays.asList(barUserRef));\n        normalizedRules.add(rule3);\n\n        // rule4: Allow view on XWiki.AllGroup\n        ReadableSecurityRule rule4 = mock(ReadableSecurityRule.class);\n        when(rule4.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW)));\n        when(rule4.getState()).thenReturn(RuleState.ALLOW);\n        when(rule4.getGroups()).thenReturn(Arrays.asList(allGroupRef));\n        normalizedRules.add(rule4);\n\n        when(this.ruleAbacus.normalizeRulesBySubject(rules)).thenReturn(normalizedRules);\n        when(this.rightsWriter.createRule(any())).thenAnswer(invocationOnMock -> {\n            ReadableSecurityRule readableSecurityRule = invocationOnMock.getArgument(0);\n            return new WritableSecurityRuleImpl(\n                readableSecurityRule.getGroups(),\n                readableSecurityRule.getUsers(),\n                readableSecurityRule.getRights(),\n                readableSecurityRule.getState());\n        });\n        when(this.rightsWriter.createRule()).thenAnswer(invocationOnMock -> new WritableSecurityRuleImpl());\n\n        // expected1: Allow edit,script on XWiki.AdminGroup\n        WritableSecurityRule expected1 = new WritableSecurityRuleImpl(\n            Collections.singletonList(adminGroupRef),\n            Collections.emptyList(),\n            new RightSet(Arrays.asList(Right.EDIT, Right.SCRIPT)),\n            RuleState.ALLOW\n        );\n\n        // expected2: Deny edit on XWiki.Foo\n        WritableSecurityRule expected2 = new WritableSecurityRuleImpl(\n            Collections.emptyList(),\n            Collections.singletonList(fooUserRef),\n            new RightSet(Arrays.asList(Right.EDIT)),\n            RuleState.DENY\n        );\n\n        // expected3: Allow view on XWiki.Foo\n        WritableSecurityRule expected3 = new WritableSecurityRuleImpl(\n            Collections.emptyList(),\n            Collections.singletonList(fooUserRef),\n            new RightSet(Arrays.asList(Right.VIEW)),\n            RuleState.ALLOW\n        );\n\n        // expected4: Deny edit on XWiki.Bar\n        // this one should not be created but that should be still rule3\n\n        // expected5: Allow view on XWiki.Buz\n        WritableSecurityRule expected5 = new WritableSecurityRuleImpl(\n            Collections.emptyList(),\n            Collections.singletonList(buzUserRef),\n            new RightSet(Arrays.asList(Right.VIEW)),\n            RuleState.ALLOW\n        );\n\n        doAnswer(invocationOnMock -> {\n            List<ReadableSecurityRule> updatedRules = invocationOnMock.getArgument(0);\n            assertTrue(updatedRules.contains(expected1),\n                String.format(\"rule [%s] seems missing from [%s]\", expected1, updatedRules));\n            assertTrue(updatedRules.contains(expected2),\n                String.format(\"rule [%s] seems missing from [%s]\", expected2, updatedRules));\n            assertTrue(updatedRules.contains(expected3),\n                String.format(\"rule [%s] seems missing from [%s]\", expected3, updatedRules));\n            assertTrue(updatedRules.contains(rule3),\n                String.format(\"rule [%s] seems missing from [%s]\", rule3, updatedRules));\n            assertTrue(updatedRules.contains(expected5),\n                String.format(\"rule [%s] seems missing from [%s]\", expected5, updatedRules));\n            return null;\n        }).when(this.rightsWriter).saveRules(any(), eq(changeRequestSpaceRef));\n        this.rightsManager.applyChanges(changeRequest, Arrays.asList(\n            diff1,\n            diff2_1, diff2_2,\n            diff3_1, diff3_2,\n            diff4,\n            diff5));\n        verify(this.rightsWriter).saveRules(any(), eq(changeRequestSpaceRef));\n    }\n\n    @Test\n    void isAuthorizedToMergeWithoutMergeUser() throws ChangeRequestException\n    {\n        UserReference userReference = mock(UserReference.class);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        DocumentReference userDocReference = mock(DocumentReference.class);\n        when(this.userReferenceConverter.convert(userReference)).thenReturn(userDocReference);\n        when(this.configuration.getMergeUser()).thenReturn(GuestUserReference.INSTANCE);\n\n        FileChange fileChange1 = mock(FileChange.class);\n        FileChange fileChange2 = mock(FileChange.class);\n        when(fileChange1.getType()).thenReturn(FileChange.FileChangeType.EDITION);\n        when(fileChange2.getType()).thenReturn(FileChange.FileChangeType.DELETION);\n\n        DocumentReference reference1 = mock(DocumentReference.class);\n        DocumentReference reference2 = mock(DocumentReference.class);\n        when(fileChange1.getTargetEntity()).thenReturn(reference1);\n        when(fileChange2.getTargetEntity()).thenReturn(reference2);\n\n        when(changeRequest.getLastFileChanges()).thenReturn(Arrays.asList(fileChange1, fileChange2));\n\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.EDIT, userDocReference, reference1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.DELETE, userDocReference, reference2)).thenReturn(false);\n\n        assertFalse(this.rightsManager.isAuthorizedToMerge(userReference, changeRequest));\n\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToMerge(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.EDIT, userDocReference, reference1)).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToMerge(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.EDIT, userDocReference, reference2)).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToMerge(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.DELETE, userDocReference, reference2)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToMerge(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.EDIT, userDocReference, reference2)).thenReturn(false);\n        assertTrue(this.rightsManager.isAuthorizedToMerge(userReference, changeRequest));\n    }\n\n    @Test\n    void isAuthorizedToMergeWithMergeUser() throws ChangeRequestException\n    {\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        UserReference currentUserReference = mock(UserReference.class);\n        DocumentReference currentUserDocReference = mock(DocumentReference.class);\n        when(this.userReferenceConverter.convert(currentUserReference)).thenReturn(currentUserDocReference);\n\n        UserReference mergeUserReference = mock(UserReference.class);\n        DocumentReference mergeUserDocReference = mock(DocumentReference.class);\n        when(this.userReferenceConverter.convert(mergeUserReference)).thenReturn(mergeUserDocReference);\n        when(this.configuration.getMergeUser()).thenReturn(mergeUserReference);\n\n        FileChange fileChange1 = mock(FileChange.class);\n        FileChange fileChange2 = mock(FileChange.class);\n        when(fileChange1.getType()).thenReturn(FileChange.FileChangeType.EDITION);\n        when(fileChange2.getType()).thenReturn(FileChange.FileChangeType.DELETION);\n\n        DocumentReference reference1 = mock(DocumentReference.class);\n        DocumentReference reference2 = mock(DocumentReference.class);\n        when(fileChange1.getTargetEntity()).thenReturn(reference1);\n        when(fileChange2.getTargetEntity()).thenReturn(reference2);\n\n        when(changeRequest.getLastFileChanges()).thenReturn(Arrays.asList(fileChange1, fileChange2));\n\n        when(this.changeRequestApproversManager.isApprover(currentUserReference, changeRequest, false))\n            .thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.EDIT, mergeUserDocReference, reference1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.DELETE, mergeUserDocReference, reference2)).thenReturn(false);\n\n        assertFalse(this.rightsManager.isAuthorizedToMerge(currentUserReference, changeRequest));\n\n        when(this.changeRequestApproversManager.isApprover(currentUserReference, changeRequest, false))\n            .thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToMerge(currentUserReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.EDIT, mergeUserDocReference, reference1)).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToMerge(currentUserReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.EDIT, mergeUserDocReference, reference2)).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToMerge(currentUserReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.DELETE, mergeUserDocReference, reference2)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToMerge(currentUserReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.EDIT, mergeUserDocReference, reference2)).thenReturn(false);\n        assertTrue(this.rightsManager.isAuthorizedToMerge(currentUserReference, changeRequest));\n\n        verify(this.authorizationManager, never())\n            .hasAccess(eq(Right.EDIT), eq(currentUserDocReference), any(DocumentReference.class));\n    }\n\n    @Test\n    void isAuthorizedToEdit()\n    {\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n        UserReference userReference = mock(UserReference.class);\n\n        when(changeRequest.getStatus()).thenReturn(ChangeRequestStatus.MERGED);\n        when(changeRequest.getAuthors())\n            .thenReturn(new HashSet<>(Arrays.asList(userReference, mock(UserReference.class))));\n        assertFalse(this.rightsManager.isAuthorizedToEdit(userReference, changeRequest));\n\n        when(changeRequest.getStatus()).thenReturn(ChangeRequestStatus.DRAFT);\n        assertTrue(this.rightsManager.isAuthorizedToEdit(userReference, changeRequest));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(mock(UserReference.class)));\n        assertFalse(this.rightsManager.isAuthorizedToEdit(userReference, changeRequest));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(GuestUserReference.INSTANCE));\n        assertTrue(this.rightsManager.isAuthorizedToEdit(userReference, changeRequest));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(mock(UserReference.class)));\n        DocumentReference userDocReference = mock(DocumentReference.class);\n        DocumentReference changeRequestDoc = mock(DocumentReference.class);\n\n        when(this.userReferenceConverter.convert(userReference)).thenReturn(userDocReference);\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDoc);\n        when(this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToEdit(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToEdit(userReference, changeRequest));\n    }\n\n    @Test\n    void isAuthorizedToOpen()\n    {\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n        UserReference userReference = mock(UserReference.class);\n\n        when(changeRequest.getStatus()).thenReturn(ChangeRequestStatus.MERGED);\n        when(changeRequest.getAuthors())\n            .thenReturn(new HashSet<>(Arrays.asList(userReference, mock(UserReference.class))));\n        assertFalse(this.rightsManager.isAuthorizedToOpen(userReference, changeRequest));\n\n        when(changeRequest.getStatus()).thenReturn(ChangeRequestStatus.CLOSED);\n        assertTrue(this.rightsManager.isAuthorizedToOpen(userReference, changeRequest));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(mock(UserReference.class)));\n        DocumentReference userDocReference = mock(DocumentReference.class);\n        DocumentReference changeRequestDoc = mock(DocumentReference.class);\n\n        when(this.userReferenceConverter.convert(userReference)).thenReturn(userDocReference);\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDoc);\n        when(this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToOpen(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToOpen(userReference, changeRequest));\n    }\n\n    @Test\n    void isAuthorizedToReview() throws ChangeRequestException\n    {\n        UserReference userReference = mock(UserReference.class);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        when(changeRequest.getAuthors()).thenReturn(new HashSet<>(List.of(userReference, mock(UserReference.class))));\n        when(configuration.preventAuthorToReview()).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n        verifyNoInteractions(this.changeRequestApproversManager);\n\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(mock(UserReference.class)));\n        when(configuration.preventAuthorToReview()).thenReturn(true);\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n    }\n\n    @Test\n    void isAuthorizedToReviewOnBehalf() throws ChangeRequestException\n    {\n        UserReference userReference = mock(UserReference.class);\n        UserReference originalApprover = mock(UserReference.class);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        when(changeRequest.getAuthors()).thenReturn(new HashSet<>(List.of(userReference, mock(UserReference.class))));\n        when(configuration.preventAuthorToReview()).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n        verifyNoInteractions(this.changeRequestDelegateApproverManager);\n\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest, originalApprover)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest, originalApprover)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(mock(UserReference.class)));\n        when(configuration.preventAuthorToReview()).thenReturn(true);\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest, originalApprover)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest, originalApprover)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest, originalApprover)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest, originalApprover)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n    }\n\n    @Test\n    void isAuthorizedToReviewAsDelegate() throws ChangeRequestException\n    {\n        UserReference userReference = mock(UserReference.class);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        when(changeRequest.getAuthors()).thenReturn(new HashSet<>(List.of(userReference, mock(UserReference.class))));\n        when(configuration.preventAuthorToReview()).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n        verifyNoInteractions(this.changeRequestDelegateApproverManager);\n\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(mock(UserReference.class)));\n        when(configuration.preventAuthorToReview()).thenReturn(true);\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n    }\n\n    @Test\n    void isAuthorizedToComment() throws ChangeRequestException\n    {\n        UserReference userReference = mock(UserReference.class);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        DocumentReference userDocReference = mock(DocumentReference.class);\n        DocumentReference changeRequestDoc = mock(DocumentReference.class);\n        when(this.userReferenceConverter.convert(userReference)).thenReturn(userDocReference);\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDoc);\n        when(this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToComment(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.COMMENT, userDocReference, changeRequestDoc)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToComment(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.COMMENT, userDocReference, changeRequestDoc)).thenReturn(false);\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToComment(userReference, changeRequest));\n\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToComment(userReference, changeRequest));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest.internal.handlers;\n\nimport java.util.Date;\nimport java.util.Optional;\n\nimport javax.inject.Named;\nimport javax.inject.Provider;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.contrib.changerequest.ApproversManager;\nimport org.xwiki.contrib.changerequest.ChangeRequest;\nimport org.xwiki.contrib.changerequest.ChangeRequestManager;\nimport org.xwiki.contrib.changerequest.ChangeRequestMergeManager;\nimport org.xwiki.contrib.changerequest.ChangeRequestReference;\nimport org.xwiki.contrib.changerequest.ChangeRequestRightsManager;\nimport org.xwiki.contrib.changerequest.FileChange;\nimport org.xwiki.contrib.changerequest.events.ChangeRequestFileChangeAddedEvent;\nimport org.xwiki.contrib.changerequest.internal.FileChangeVersionManager;\nimport org.xwiki.contrib.changerequest.storage.ChangeRequestStorageManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.store.merge.MergeDocumentResult;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.wysiwyg.converter.RequestParameterConverter;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.web.EditForm;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiResponse;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link AddChangesChangeRequestHandler}.\n *\n * @version $Id$\n * @since 0.5\n */\n@ComponentTest\nclass AddChangesChangeRequestHandlerTest\n{\n    @InjectMockComponents\n    private AddChangesChangeRequestHandler handler;\n\n    @MockComponent\n    private ChangeRequestManager changeRequestManager;\n\n    @MockComponent\n    private UserReferenceResolver<CurrentUserReference> userReferenceResolver;\n\n    @MockComponent\n    private FileChangeVersionManager fileChangeVersionManager;\n\n    @MockComponent\n    private ApproversManager<FileChange> fileChangeApproversManager;\n\n    @MockComponent\n    private ApproversManager<ChangeRequest> changeRequestApproversManager;\n\n    @MockComponent\n    protected Provider<XWikiContext> contextProvider;\n\n    @MockComponent\n    protected DocumentReferenceResolver<ChangeRequest> changeRequestDocumentReferenceResolver;\n\n    @MockComponent\n    protected ChangeRequestStorageManager storageManager;\n\n    @MockComponent\n    protected ObservationManager observationManager;\n\n    @MockComponent\n    @Named(\"current\")\n    protected DocumentReferenceResolver<String> documentReferenceResolver;\n\n    @MockComponent\n    private RequestParameterConverter requestParameterConverter;\n\n    @MockComponent\n    private ChangeRequestRightsManager changeRequestRightsManager;\n\n    @MockComponent\n    private ChangeRequestMergeManager changeRequestMergeManager;\n\n    private XWikiContext context;\n    private XWiki wiki;\n    private XWikiVersioningStoreInterface versioningStore;\n\n    @BeforeEach\n    void setup()\n    {\n        this.context = mock(XWikiContext.class);\n        when(contextProvider.get()).thenReturn(context);\n\n        this.wiki = mock(XWiki.class);\n        when(this.context.getWiki()).thenReturn(this.wiki);\n\n        this.versioningStore = mock(XWikiVersioningStoreInterface.class);\n        when(this.wiki.getVersioningStore()).thenReturn(this.versioningStore);\n    }\n\n    @Test\n    void handleFileChangeNotExisting() throws Exception\n    {\n\n        XWikiRequest request = mock(XWikiRequest.class);\n        when(context.getRequest()).thenReturn(request);\n        XWikiResponse response = mock(XWikiResponse.class);\n        when(context.getResponse()).thenReturn(response);\n        when(this.requestParameterConverter.convert(request, response)).thenReturn(Optional.of(request));\n        String docReference = \"XWiki.Doc.Reference\";\n        when(request.getParameter(\"docReference\")).thenReturn(docReference);\n        DocumentReference documentReference = mock(DocumentReference.class);\n        when(this.documentReferenceResolver.resolve(docReference)).thenReturn(documentReference);\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(wiki.getDocument(documentReference, context)).thenReturn(document);\n        when(document.clone()).thenReturn(document);\n        when(document.getDocumentReferenceWithLocale()).thenReturn(documentReference);\n        ChangeRequestReference changeRequestReference = mock(ChangeRequestReference.class);\n        String changeRequestId = \"some id\";\n        when(changeRequestReference.getId()).thenReturn(changeRequestId);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n        when(this.storageManager.load(changeRequestId)).thenReturn(Optional.of(changeRequest));\n        when(changeRequest.getId()).thenReturn(changeRequestId);\n        UserReference userReference = mock(UserReference.class);\n        when(this.userReferenceResolver.resolve(CurrentUserReference.INSTANCE)).thenReturn(userReference);\n        when(changeRequest.getLatestFileChangeFor(documentReference)).thenReturn(Optional.empty());\n        when(request.getParameter(AddChangesChangeRequestHandler.PREVIOUS_VERSION_PARAMETER)).thenReturn(\"2.1\");\n        XWikiDocumentArchive documentArchive = mock(XWikiDocumentArchive.class);\n        when(versioningStore.getXWikiDocumentArchive(document, context)).thenReturn(documentArchive);\n        XWikiDocument previousVersionDoc = mock(XWikiDocument.class);\n        when(documentArchive.loadDocument(new Version(\"2.1\"), context)).thenReturn(previousVersionDoc);\n        when(previousVersionDoc.getDate()).thenReturn(new Date(4100));\n        when(this.fileChangeVersionManager.getNextFileChangeVersion(\"2.1\", false)).thenReturn(\"filechange-3.1\");\n        FileChange expectedFileChange = new FileChange(changeRequest)\n            .setAuthor(userReference)\n            .setTargetEntity(documentReference)\n            .setPreviousVersion(\"2.1\")\n            .setPreviousPublishedVersion(\"2.1\", new Date(4100))\n            .setVersion(\"filechange-3.1\")\n            .setModifiedDocument(document);\n        when(changeRequest.addFileChange(any())).then(invocationOnMock -> {\n            FileChange fileChange = invocationOnMock.getArgument(0);\n            expectedFileChange.setCreationDate(fileChange.getCreationDate());\n            return null;\n        });\n        when(this.changeRequestRightsManager.isViewAccessConsistent(changeRequest, documentReference)).thenReturn(true);\n        DocumentReference changeRequestDocReference = mock(DocumentReference.class);\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDocReference);\n        String url = \"some url\";\n        when(wiki.getURL(changeRequestDocReference, \"view\", context)).thenReturn(url);\n\n        this.handler.handle(changeRequestReference);\n        verify(this.requestParameterConverter).convert(request, response);\n        verify(document).clone();\n        verify(document).readFromForm(any(EditForm.class), eq(context));\n        verify(changeRequest).addFileChange(expectedFileChange);\n        verify(this.storageManager).save(changeRequest);\n        verify(this.changeRequestApproversManager).getAllApprovers(changeRequest, false);\n        verify(this.fileChangeApproversManager).getAllApprovers(expectedFileChange, false);\n        verify(this.changeRequestApproversManager).getGroupsApprovers(changeRequest);\n        verify(this.fileChangeApproversManager).getGroupsApprovers(expectedFileChange);\n        verify(this.observationManager)\n            .notify(any(ChangeRequestFileChangeAddedEvent.class), eq(changeRequestId), eq(expectedFileChange));\n        verify(response).sendRedirect(url);\n    }\n\n    @Test\n    void handleFileChangeExistingNoConflict() throws Exception\n    {\n        XWikiRequest request = mock(XWikiRequest.class);\n        when(context.getRequest()).thenReturn(request);\n        XWikiResponse response = mock(XWikiResponse.class);\n        when(context.getResponse()).thenReturn(response);\n        when(this.requestParameterConverter.convert(request, response)).thenReturn(Optional.of(request));\n        String docReference = \"XWiki.Doc.Reference\";\n        when(request.getParameter(\"docReference\")).thenReturn(docReference);\n        DocumentReference documentReference = mock(DocumentReference.class);\n        when(this.documentReferenceResolver.resolve(docReference)).thenReturn(documentReference);\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(wiki.getDocument(documentReference, context)).thenReturn(document);\n        when(document.clone()).thenReturn(document);\n        when(document.getDocumentReferenceWithLocale()).thenReturn(documentReference);\n        ChangeRequestReference changeRequestReference = mock(ChangeRequestReference.class);\n        String changeRequestId = \"some id\";\n        when(changeRequestReference.getId()).thenReturn(changeRequestId);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n        when(this.storageManager.load(changeRequestId)).thenReturn(Optional.of(changeRequest));\n        when(changeRequest.getId()).thenReturn(changeRequestId);\n        UserReference userReference = mock(UserReference.class);\n        when(this.userReferenceResolver.resolve(CurrentUserReference.INSTANCE)).thenReturn(userReference);\n        when(request.getParameter(AddChangesChangeRequestHandler.PREVIOUS_VERSION_PARAMETER)).thenReturn(\"2.1\");\n\n        XWikiDocumentArchive documentArchive = mock(XWikiDocumentArchive.class);\n        when(versioningStore.getXWikiDocumentArchive(document, context)).thenReturn(documentArchive);\n        XWikiDocument previousVersionDoc = mock(XWikiDocument.class);\n        when(documentArchive.loadDocument(new Version(\"2.1\"), context)).thenReturn(previousVersionDoc);\n        when(previousVersionDoc.getDate()).thenReturn(new Date(478));\n\n        FileChange existingFileChange = mock(FileChange.class);\n        when(changeRequest.getLatestFileChangeFor(documentReference)).thenReturn(Optional.of(existingFileChange));\n        when(existingFileChange.getPreviousPublishedVersion()).thenReturn(\"1.1\");\n        when(existingFileChange.getPreviousPublishedVersionDate()).thenReturn(new Date(58));\n        MergeDocumentResult mergeDocumentResult = mock(MergeDocumentResult.class);\n        when(this.changeRequestMergeManager.mergeDocumentChanges(document, \"2.1\", changeRequest))\n            .thenReturn(Optional.of(mergeDocumentResult));\n        when(this.fileChangeVersionManager.getNextFileChangeVersion(\"2.1\", true)).thenReturn(\"filechange-2.2\");\n        when(mergeDocumentResult.hasConflicts()).thenReturn(false);\n        XWikiDocument mergedDocument = mock(XWikiDocument.class);\n        when(mergeDocumentResult.getMergeResult()).thenReturn(mergedDocument);\n        FileChange expectedFileChange = new FileChange(changeRequest)\n            .setAuthor(userReference)\n            .setTargetEntity(documentReference)\n            .setPreviousVersion(\"2.1\")\n            .setPreviousPublishedVersion(\"1.1\", new Date(58))\n            .setVersion(\"filechange-2.2\")\n            .setModifiedDocument(mergedDocument);\n\n        when(changeRequest.addFileChange(any())).then(invocationOnMock -> {\n            FileChange fileChange = invocationOnMock.getArgument(0);\n            expectedFileChange.setCreationDate(fileChange.getCreationDate());\n            return null;\n        });\n        DocumentReference changeRequestDocReference = mock(DocumentReference.class);\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDocReference);\n        String url = \"some url\";\n        when(wiki.getURL(changeRequestDocReference, \"view\", context)).thenReturn(url);\n\n        this.handler.handle(changeRequestReference);\n\n        verify(this.requestParameterConverter).convert(request, response);\n        verify(document).clone();\n        verify(document).readFromForm(any(EditForm.class), eq(context));\n        verify(changeRequest).addFileChange(expectedFileChange);\n        verify(this.storageManager).save(changeRequest);\n        verify(this.changeRequestApproversManager).getAllApprovers(changeRequest, false);\n        verify(this.fileChangeApproversManager).getAllApprovers(expectedFileChange, false);\n        verify(this.changeRequestApproversManager).getGroupsApprovers(changeRequest);\n        verify(this.fileChangeApproversManager).getGroupsApprovers(expectedFileChange);\n        verify(this.observationManager)\n            .notify(any(ChangeRequestFileChangeAddedEvent.class), eq(changeRequestId), eq(expectedFileChange));\n        verify(response).sendRedirect(url);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest.internal.handlers;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Optional;\n\nimport javax.inject.Named;\nimport javax.inject.Provider;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.contrib.changerequest.ChangeRequest;\nimport org.xwiki.contrib.changerequest.ChangeRequestStatus;\nimport org.xwiki.contrib.changerequest.FileChange;\nimport org.xwiki.contrib.changerequest.events.ChangeRequestCreatedEvent;\nimport org.xwiki.contrib.changerequest.storage.ChangeRequestStorageManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.wysiwyg.converter.RequestParameterConverter;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiResponse;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link CreateChangeRequestHandler}.\n *\n * @version $Id$\n * @since 0.3\n */\n@ComponentTest\nclass CreateChangeRequestHandlerTest\n{\n    @InjectMockComponents\n    private CreateChangeRequestHandler handler;\n\n    @MockComponent\n    protected Provider<XWikiContext> contextProvider;\n\n    @MockComponent\n    protected DocumentReferenceResolver<ChangeRequest> changeRequestDocumentReferenceResolver;\n\n    @MockComponent\n    protected ChangeRequestStorageManager storageManager;\n\n    @MockComponent\n    protected ObservationManager observationManager;\n\n    @MockComponent\n    @Named(\"current\")\n    private DocumentReferenceResolver<String> documentReferenceResolver;\n\n    @MockComponent\n    private RequestParameterConverter requestParameterConverter;\n\n    @MockComponent\n    private UserReferenceResolver<CurrentUserReference> userReferenceResolver;\n\n    private XWikiContext context;\n    private XWikiRequest httpServletRequest;\n    private XWikiResponse httpServletResponse;\n    private XWiki xWiki;\n    private XWikiVersioningStoreInterface versioningStore;\n\n    @BeforeEach\n    void setup()\n    {\n        this.context = mock(XWikiContext.class);\n        when(contextProvider.get()).thenReturn(context);\n\n        this.xWiki = mock(XWiki.class);\n        when(this.context.getWiki()).thenReturn(this.xWiki);\n\n        this.versioningStore = mock(XWikiVersioningStoreInterface.class);\n        when(this.xWiki.getVersioningStore()).thenReturn(this.versioningStore);\n    }\n\n    @Test\n    void handle() throws Exception\n    {\n        this.httpServletRequest = mock(XWikiRequest.class);\n        when(this.context.getRequest()).thenReturn(this.httpServletRequest);\n        this.httpServletResponse = mock(XWikiResponse.class);\n        when(this.context.getResponse()).thenReturn(this.httpServletResponse);\n\n        when(this.requestParameterConverter.convert(this.httpServletRequest, this.httpServletResponse))\n            .thenReturn(Optional.of(this.httpServletRequest));\n        String serializedReference = \"XWiki.SomeReference\";\n        when(this.httpServletRequest.getParameter(\"docReference\")).thenReturn(serializedReference);\n        DocumentReference documentReference = mock(DocumentReference.class);\n        when(this.documentReferenceResolver.resolve(serializedReference)).thenReturn(documentReference);\n        XWikiDocument modifiedDocument = mock(XWikiDocument.class);\n        when(this.xWiki.getDocument(documentReference, this.context)).thenReturn(modifiedDocument);\n        when(modifiedDocument.clone()).thenReturn(modifiedDocument);\n        DocumentReference documentReferenceWithLocale = mock(DocumentReference.class);\n        when(modifiedDocument.getDocumentReferenceWithLocale()).thenReturn(documentReferenceWithLocale);\n\n        String title = \"some title\";\n        String description = \"some description\";\n        when(this.httpServletRequest.getParameter(\"crTitle\")).thenReturn(title);\n        when(this.httpServletRequest.getParameter(\"crDescription\")).thenReturn(description);\n\n        UserReference userReference = mock(UserReference.class);\n        when(this.userReferenceResolver.resolve(CurrentUserReference.INSTANCE)).thenReturn(userReference);\n        String previousVersion = \"3.2\";\n        when(this.httpServletRequest.getParameter(\"previousVersion\")).thenReturn(previousVersion);\n        XWikiDocumentArchive documentArchive = mock(XWikiDocumentArchive.class);\n        when(versioningStore.getXWikiDocumentArchive(modifiedDocument, context)).thenReturn(documentArchive);\n        XWikiDocument previousVersionDoc = mock(XWikiDocument.class);\n        when(documentArchive.loadDocument(new Version(\"3.2\"), context)).thenReturn(previousVersionDoc);\n        when(previousVersionDoc.getDate()).thenReturn(new Date(458));\n\n        ChangeRequest expectedChangeRequest = new ChangeRequest();\n        FileChange expectedFileChange = new FileChange(expectedChangeRequest);\n        expectedFileChange\n            .setAuthor(userReference)\n            .setTargetEntity(documentReferenceWithLocale)\n            .setPreviousVersion(previousVersion)\n            .setPreviousPublishedVersion(previousVersion, new Date(458))\n            .setModifiedDocument(modifiedDocument);\n\n        String crId = \"myCrID\";\n        expectedChangeRequest\n            .setId(crId)\n            .setTitle(title)\n            .setDescription(description)\n            .setCreator(userReference)\n            .addFileChange(expectedFileChange)\n            .setStatus(ChangeRequestStatus.READY_FOR_REVIEW);\n\n        doAnswer(invocationOnMock -> {\n            ChangeRequest changeRequest = invocationOnMock.getArgument(0);\n            List<FileChange> allFileChanges = changeRequest.getLastFileChanges();\n            assertEquals(1, allFileChanges.size());\n            // ensure to have the exact same date in file change\n            Date creationDate = allFileChanges.get(0).getCreationDate();\n            expectedFileChange.setCreationDate(creationDate);\n            expectedChangeRequest.setCreationDate(changeRequest.getCreationDate());\n            changeRequest.setId(crId);\n            return null;\n        }).when(this.storageManager).save(any());\n\n        DocumentReference crDocReference = mock(DocumentReference.class);\n        when(this.changeRequestDocumentReferenceResolver.resolve(expectedChangeRequest)).thenReturn(crDocReference);\n        String expectedURL = \"/mycr\";\n        when(this.xWiki.getURL(crDocReference, \"view\", this.context)).thenReturn(expectedURL);\n\n        this.handler.handle(null);\n        verify(this.storageManager).save(expectedChangeRequest);\n        verify(this.observationManager)\n            .notify(any(ChangeRequestCreatedEvent.class), eq(crId), eq(expectedChangeRequest));\n        verify(this.httpServletResponse).sendRedirect(expectedURL);\n    }\n\n}\n", "<?xml version=\"1.1\" encoding=\"UTF-8\"?>\n\n<!--\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n-->\n\n<xwikidoc version=\"1.5\" reference=\"ChangeRequest.Code.EditPageUIX\" locale=\"\">\n  <web>ChangeRequest.Code</web>\n  <name>EditPageUIX</name>\n  <language/>\n  <defaultLanguage/>\n  <translation>0</translation>\n  <creator>xwiki:XWiki.Admin</creator>\n  <parent>WebHome</parent>\n  <author>xwiki:XWiki.Admin</author>\n  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>\n  <version>1.1</version>\n  <title>EditPageUIX</title>\n  <comment/>\n  <minorEdit>false</minorEdit>\n  <syntaxId>xwiki/2.1</syntaxId>\n  <hidden>true</hidden>\n  <content/>\n  <object>\n    <name>ChangeRequest.Code.EditPageUIX</name>\n    <number>0</number>\n    <className>XWiki.JavaScriptExtension</className>\n    <guid>d4457cb8-ac6d-48e2-9032-e76da4df56bb</guid>\n    <class>\n      <name>XWiki.JavaScriptExtension</name>\n      <customClass/>\n      <customMapping/>\n      <defaultViewSheet/>\n      <defaultEditSheet/>\n      <defaultWeb/>\n      <nameField/>\n      <validationScript/>\n      <cache>\n        <cache>0</cache>\n        <defaultValue>long</defaultValue>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>cache</name>\n        <number>5</number>\n        <prettyName>Caching policy</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>long|short|default|forbid</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </cache>\n      <code>\n        <contenttype>PureText</contenttype>\n        <disabled>0</disabled>\n        <editor>PureText</editor>\n        <name>code</name>\n        <number>2</number>\n        <prettyName>Code</prettyName>\n        <rows>20</rows>\n        <size>50</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </code>\n      <name>\n        <disabled>0</disabled>\n        <name>name</name>\n        <number>1</number>\n        <prettyName>Name</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </name>\n      <parse>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType>yesno</displayType>\n        <name>parse</name>\n        <number>4</number>\n        <prettyName>Parse content</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </parse>\n      <use>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>use</name>\n        <number>3</number>\n        <prettyName>Use this extension</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>currentPage|onDemand|always</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </use>\n    </class>\n    <property>\n      <cache>long</cache>\n    </property>\n    <property>\n      <code>require(['jquery', 'xwiki-meta'], function ($, xm) {\n  var createConfig = JSON.parse($('#changerequest-create-config').text());\n  \n  var submitCreate = function () {\n    var form = $('form#create');\n    form.attr('action', createConfig.createURL);\n    form.submit();\n  };\n  \n  var initialize = function () {\n    if ($('#create_changerequest').length == 0) {\n      var button = $(\"&lt;input&gt;\", {\n        'type': 'button',\n        'class': 'btn btn-info',\n        'name': 'create_changerequest',\n        'id': 'create_changerequest',\n        'value': createConfig.createAsCRButtonTranslation\n      });\n      \n      $('form#create .buttonwrapper').first().prepend(button);\n      button.on('click', submitCreate);\n    }\n  }\n  \n  initialize();\n})</code>\n    </property>\n    <property>\n      <name>Create as change request button injection</name>\n    </property>\n    <property>\n      <parse>0</parse>\n    </property>\n    <property>\n      <use>onDemand</use>\n    </property>\n  </object>\n  <object>\n    <name>ChangeRequest.Code.EditPageUIX</name>\n    <number>0</number>\n    <className>XWiki.UIExtensionClass</className>\n    <guid>8c1b0aea-f935-457b-8ed3-e34c207969ba</guid>\n    <class>\n      <name>XWiki.UIExtensionClass</name>\n      <customClass/>\n      <customMapping/>\n      <defaultViewSheet/>\n      <defaultEditSheet/>\n      <defaultWeb/>\n      <nameField/>\n      <validationScript/>\n      <async_cached>\n        <defaultValue>0</defaultValue>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType/>\n        <name>async_cached</name>\n        <number>3</number>\n        <prettyName>Cached</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </async_cached>\n      <async_context>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>1</multiSelect>\n        <name>async_context</name>\n        <number>4</number>\n        <prettyName>Context elements</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator>, </separator>\n        <separators>|, </separators>\n        <size>5</size>\n        <unmodifiable>0</unmodifiable>\n        <values>action=Action|doc.reference=Document|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.parameters=Request parameters|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </async_context>\n      <async_enabled>\n        <defaultValue>0</defaultValue>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType/>\n        <name>async_enabled</name>\n        <number>2</number>\n        <prettyName>Asynchronous rendering</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </async_enabled>\n      <content>\n        <disabled>0</disabled>\n        <editor>Text</editor>\n        <name>content</name>\n        <number>1</number>\n        <prettyName>Executed Content</prettyName>\n        <rows>25</rows>\n        <size>120</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </content>\n      <extensionPointId>\n        <disabled>0</disabled>\n        <name>extensionPointId</name>\n        <number>5</number>\n        <prettyName>Extension Point ID</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </extensionPointId>\n      <name>\n        <disabled>0</disabled>\n        <name>name</name>\n        <number>6</number>\n        <prettyName>Extension ID</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </name>\n      <parameters>\n        <contenttype>PureText</contenttype>\n        <disabled>0</disabled>\n        <editor>PureText</editor>\n        <name>parameters</name>\n        <number>7</number>\n        <prettyName>Extension Parameters</prettyName>\n        <rows>10</rows>\n        <size>40</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </parameters>\n      <scope>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>scope</name>\n        <number>8</number>\n        <prettyName>Extension Scope</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>wiki=Current Wiki|user=Current User|global=Global</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </scope>\n    </class>\n    <property>\n      <async_cached>1</async_cached>\n    </property>\n    <property>\n      <async_context>\n        <value>doc.reference</value>\n        <value>user</value>\n        <value>wiki</value>\n      </async_context>\n    </property>\n    <property>\n      <async_enabled>1</async_enabled>\n    </property>\n    <property>\n      <content>{{velocity}}\n{{html clean='false'}}\n#template(\"xwikivars.vm\")\n#set ($crEditName = \"changerequest\")\n#set ($hasCREdit = $services.security.authorization.isRightRegistered($crEditName) &amp;&amp; $services.security.authorization.hasAccess($crEditName, $tdoc))\n#set ($hasEdit = $services.security.authorization.hasAccess('edit', $tdoc))\n#set ($hasCreateButton = ($hasCreateSpace || $hasCreatePage))\n#set ($editURL = $doc.getURL('editcr'))\n#set ($createURL = $doc.getURL('createcr'))\n#if (!$isReadOnly &amp;&amp; $hasCREdit)\n#if (!$hasEdit)\n&lt;div class=\"btn-group\" id=\"crEdit\"&gt;\n  &lt;a href=\"$editURL\" role=\"button\" title=\"$services.localization.render('changerequest.edit.button.title')\" class=\"btn btn-default\"&gt;\n    $services.icon.renderHTML('pencil') $services.localization.render('changerequest.edit.button.value')\n  &lt;/a&gt;\n&lt;/div&gt;\n#end\n#if (!$hasCreateButton)\n&lt;div class=\"btn-group\" id=\"crCreate\"&gt;\n  &lt;a href=\"$createURL\" role=\"button\" title=\"$services.localization.render('changerequest.create.button.title')\" class=\"btn btn-default\"&gt;\n    $services.icon.renderHTML('add') $services.localization.render('changerequest.create.button.value')\n  &lt;/a&gt;\n&lt;/div&gt;\n#end\n#end\n{{/html}}\n{{/velocity}}</content>\n    </property>\n    <property>\n      <extensionPointId>org.xwiki.plaftorm.menu.content</extensionPointId>\n    </property>\n    <property>\n      <name>org.xwiki.contrib.changerequest.menu.edit</name>\n    </property>\n    <property>\n      <parameters>order=10000</parameters>\n    </property>\n    <property>\n      <scope>wiki</scope>\n    </property>\n  </object>\n  <object>\n    <name>ChangeRequest.Code.EditPageUIX</name>\n    <number>1</number>\n    <className>XWiki.UIExtensionClass</className>\n    <guid>e5f4ba05-dd8f-405d-8e8c-d5b329ad7bab</guid>\n    <class>\n      <name>XWiki.UIExtensionClass</name>\n      <customClass/>\n      <customMapping/>\n      <defaultViewSheet/>\n      <defaultEditSheet/>\n      <defaultWeb/>\n      <nameField/>\n      <validationScript/>\n      <async_cached>\n        <defaultValue>0</defaultValue>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType/>\n        <name>async_cached</name>\n        <number>3</number>\n        <prettyName>Cached</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </async_cached>\n      <async_context>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>1</multiSelect>\n        <name>async_context</name>\n        <number>4</number>\n        <prettyName>Context elements</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator>, </separator>\n        <separators>|, </separators>\n        <size>5</size>\n        <unmodifiable>0</unmodifiable>\n        <values>action=Action|doc.reference=Document|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.parameters=Request parameters|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </async_context>\n      <async_enabled>\n        <defaultValue>0</defaultValue>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType/>\n        <name>async_enabled</name>\n        <number>2</number>\n        <prettyName>Asynchronous rendering</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </async_enabled>\n      <content>\n        <disabled>0</disabled>\n        <editor>Text</editor>\n        <name>content</name>\n        <number>1</number>\n        <prettyName>Executed Content</prettyName>\n        <rows>25</rows>\n        <size>120</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </content>\n      <extensionPointId>\n        <disabled>0</disabled>\n        <name>extensionPointId</name>\n        <number>5</number>\n        <prettyName>Extension Point ID</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </extensionPointId>\n      <name>\n        <disabled>0</disabled>\n        <name>name</name>\n        <number>6</number>\n        <prettyName>Extension ID</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </name>\n      <parameters>\n        <contenttype>PureText</contenttype>\n        <disabled>0</disabled>\n        <editor>PureText</editor>\n        <name>parameters</name>\n        <number>7</number>\n        <prettyName>Extension Parameters</prettyName>\n        <rows>10</rows>\n        <size>40</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </parameters>\n      <scope>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>scope</name>\n        <number>8</number>\n        <prettyName>Extension Scope</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>wiki=Current Wiki|user=Current User|global=Global</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </scope>\n    </class>\n    <property>\n      <async_cached>0</async_cached>\n    </property>\n    <property>\n      <async_context/>\n    </property>\n    <property>\n      <async_enabled>0</async_enabled>\n    </property>\n    <property>\n      <content>{{velocity}}\n#set ($crEditName = \"changerequest\")\n#set ($hasCREdit = $services.security.authorization.isRightRegistered($crEditName) &amp;&amp; $services.security.authorization.hasAccess($crEditName, $tdoc))\n#set ($isCreateAction = $xcontext.action == 'create')\n\n#if ($hasCREdit &amp;&amp; $isCreateAction)\n  #set ($createURL = $tdoc.getURL('createcr'))\n  #set ($changeRequestCreateConfig = {\n    'createURL': $createURL,\n    'createAsCRButtonTranslation': $services.localization.render('changerequest.createascr.button')\n  })\n  \n  {{html clean=\"false\"}}\n  &lt;script id=\"changerequest-create-config\" type=\"application/json\"&gt;$jsontool.serialize($changeRequestCreateConfig).replace('&lt;', '\\u003C')&lt;/script&gt;\n  #set ($discard = $xwiki.jsx.use('ChangeRequest.Code.EditPageUIX'))\n  {{/html}}\n  \n#end\n{{/velocity}}</content>\n    </property>\n    <property>\n      <extensionPointId>org.xwiki.platform.template.header.after</extensionPointId>\n    </property>\n    <property>\n      <name>org.xwiki.contrib.changerequest.ui.header.after.create.extension</name>\n    </property>\n    <property>\n      <parameters>order=0</parameters>\n    </property>\n    <property>\n      <scope>wiki</scope>\n    </property>\n  </object>\n</xwikidoc>\n", "<?xml version=\"1.1\" encoding=\"UTF-8\"?>\n\n<!--\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n-->\n\n<xwikidoc version=\"1.5\" reference=\"ChangeRequest.Code.SaveButtonsUIX\" locale=\"\">\n  <web>ChangeRequest.Code</web>\n  <name>SaveButtonsUIX</name>\n  <language/>\n  <defaultLanguage/>\n  <translation>0</translation>\n  <creator>xwiki:XWiki.Admin</creator>\n  <parent>Main.WebHome</parent>\n  <author>xwiki:XWiki.Admin</author>\n  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>\n  <version>1.1</version>\n  <title>SaveButtonsUIX</title>\n  <comment/>\n  <minorEdit>false</minorEdit>\n  <syntaxId>xwiki/2.1</syntaxId>\n  <hidden>true</hidden>\n  <content>{{velocity}}\n#if ($request.get('checktemplate') == 1)\n  #set ($isTemplateSupported = $services.changerequest.isTemplateSupported($request.get('template')))\n  #jsonResponse({\n    'isSupported': $isTemplateSupported\n  })\n#end\n{{/velocity}}</content>\n  <object>\n    <name>ChangeRequest.Code.SaveButtonsUIX</name>\n    <number>0</number>\n    <className>XWiki.JavaScriptExtension</className>\n    <guid>35af08ef-adff-45fa-9b7a-4462347574e4</guid>\n    <class>\n      <name>XWiki.JavaScriptExtension</name>\n      <customClass/>\n      <customMapping/>\n      <defaultViewSheet/>\n      <defaultEditSheet/>\n      <defaultWeb/>\n      <nameField/>\n      <validationScript/>\n      <cache>\n        <cache>0</cache>\n        <defaultValue>long</defaultValue>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>cache</name>\n        <number>5</number>\n        <prettyName>Caching policy</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>long|short|default|forbid</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </cache>\n      <code>\n        <contenttype>PureText</contenttype>\n        <disabled>0</disabled>\n        <editor>PureText</editor>\n        <name>code</name>\n        <number>2</number>\n        <prettyName>Code</prettyName>\n        <rows>20</rows>\n        <size>50</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </code>\n      <name>\n        <disabled>0</disabled>\n        <name>name</name>\n        <number>1</number>\n        <prettyName>Name</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </name>\n      <parse>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType>yesno</displayType>\n        <name>parse</name>\n        <number>4</number>\n        <prettyName>Parse content</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </parse>\n      <use>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>use</name>\n        <number>3</number>\n        <prettyName>Use this extension</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>currentPage|onDemand|always</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </use>\n    </class>\n    <property>\n      <cache>long</cache>\n    </property>\n    <property>\n      <code>require(['jquery', 'xwiki-meta', 'SaveChangeRequestModal'], function ($, xm, SaveChangeRequestModal) {\n  var saveConfig = JSON.parse($('#changerequest-save-config').text());\n  \n  var handleCancel = function (event) {\n    event.preventDefault();\n    $(document).trigger('xwiki:actions:cancel');\n    var urlParams = new URLSearchParams(window.location.search);\n    var editExistingCR = urlParams.has('changerequest');\n    if (editExistingCR) {\n      document.location.href = saveConfig.changeRequestURL;\n    } else {\n      currentDocUrl = new XWiki.Document(xm.documentReference).getURL();\n      document.location.href = currentDocUrl;\n    }\n  };\n  \n  var attachButtons = function () {\n    if ($('#save_changerequest').length == 0) {\n      var button = $(\"&lt;input&gt;\", {\n        'type': 'button',\n        'class': 'btn btn-info',\n        'name': 'save_changerequest',\n        'id': 'save_changerequest',\n        'value': saveConfig.saveButtonTranslation\n      });\n      \n      var buttonAdded = false;\n      var inplaceEditing;\n      if ($('.bottombuttons').length &gt; 0) {\n        $('.bottombuttons .buttons').prepend(button);\n        buttonAdded = true;\n        inplaceEditing = false;\n      } else if ($('.inplace-editing-buttons').length &gt; 0) {\n        button.data('inplaceediting', true);\n        $('.inplace-editing-buttons .buttons').prepend(button);\n        buttonAdded = true;\n        inplaceEditing = true;\n      }\n    }\n    if (buttonAdded) {\n      var saveChangeRequestModal = new SaveChangeRequestModal('changerequest-save-config');\n      var urlParams = new URLSearchParams(window.location.search);\n      var editExistingCR = urlParams.get('changerequest');\n      button.on('click', function(event) {\n        if (editExistingCR) {\n          saveChangeRequestModal.saveChangeRequest(event, editExistingCR);\n        } else {\n          saveChangeRequestModal.openModal();\n        }\n      });\n      $(document).on('xwiki:document:saveFailed', function(event, data) {\n        var errorMessage = data.response.responseJSON.changeRequestError;\n        if (errorMessage) {\n          saveChangeRequestModal.openModal();\n          $(document).on('xwiki:dom:updated', function (event, data) {\n            if (data.elements.length &gt; 0 &amp;&amp; $(data.elements)[0].id === 'changeRequestModal') {\n              $('#otherError').removeClass('hidden');\n              $('#otherError').find('.details').text(errorMessage);\n            }\n          });\n        }\n      });\n      \n      var hasEditRight = saveConfig.hasEditRight;\n      // hide minor edit and autosave capabilities\n      if (!hasEditRight || editExistingCR) {\n        $('.meta-minorEdit').remove();\n        $('#autosaveControl').remove();\n        $('input[name=action_save]').parent().remove();\n        $('input[name=action_cancel]').off('click');\n        $('input[name=action_cancel]').on('click', handleCancel);\n      }\n    }\n  };\n  \n  var initialize = function() {\n    var urlParams = new URLSearchParams(window.location.search);\n    if (urlParams.has('template')) {\n      var saveButtonUIXDoc = new XWiki.Document(new XWiki.DocumentReference('xwiki', ['ChangeRequest', 'Code'], 'SaveButtonsUIX'));\n      // check template\n      $.get(saveButtonUIXDoc.getURL('get'), {\n        'checktemplate': 1,\n        'outputSyntax': 'plain',\n        'template': urlParams.get('template')\n      }).done(function (data) {\n        if (data.isSupported === true) {\n          attachButtons();\n        } else {\n          console.info(\"Template [{}] not supported by change request.\", urlParams.get('template'));\n        }\n      }).fail(function (data) {\n        console.error(\"Error when checking if template [{}] is supported by change request.\", urlParams.get('template'));\n        console.debug(data);\n      });\n    } else {\n      attachButtons();\n    }\n  }\n\n  $(document).on('xwiki:dom:updated', initialize);\n  initialize();\n});</code>\n    </property>\n    <property>\n      <name>SaveButtonsUIX</name>\n    </property>\n    <property>\n      <parse>0</parse>\n    </property>\n    <property>\n      <use>onDemand</use>\n    </property>\n  </object>\n  <object>\n    <name>ChangeRequest.Code.SaveButtonsUIX</name>\n    <number>0</number>\n    <className>XWiki.UIExtensionClass</className>\n    <guid>76f49e6a-8dc3-42ca-97a8-2c3ef834a7fa</guid>\n    <class>\n      <name>XWiki.UIExtensionClass</name>\n      <customClass/>\n      <customMapping/>\n      <defaultViewSheet/>\n      <defaultEditSheet/>\n      <defaultWeb/>\n      <nameField/>\n      <validationScript/>\n      <async_cached>\n        <defaultValue>0</defaultValue>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType/>\n        <name>async_cached</name>\n        <number>3</number>\n        <prettyName>Cached</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </async_cached>\n      <async_context>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>1</multiSelect>\n        <name>async_context</name>\n        <number>4</number>\n        <prettyName>Context elements</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator>, </separator>\n        <separators>|, </separators>\n        <size>5</size>\n        <unmodifiable>0</unmodifiable>\n        <values>action=Action|doc.reference=Document|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.cookies|request.parameters=Request parameters|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </async_context>\n      <async_enabled>\n        <defaultValue>0</defaultValue>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType/>\n        <name>async_enabled</name>\n        <number>2</number>\n        <prettyName>Asynchronous rendering</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </async_enabled>\n      <content>\n        <disabled>0</disabled>\n        <editor>Text</editor>\n        <name>content</name>\n        <number>1</number>\n        <prettyName>Executed Content</prettyName>\n        <rows>25</rows>\n        <size>120</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </content>\n      <extensionPointId>\n        <disabled>0</disabled>\n        <name>extensionPointId</name>\n        <number>5</number>\n        <prettyName>Extension Point ID</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </extensionPointId>\n      <name>\n        <disabled>0</disabled>\n        <name>name</name>\n        <number>6</number>\n        <prettyName>Extension ID</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </name>\n      <parameters>\n        <contenttype>PureText</contenttype>\n        <disabled>0</disabled>\n        <editor>PureText</editor>\n        <name>parameters</name>\n        <number>7</number>\n        <prettyName>Extension Parameters</prettyName>\n        <rows>10</rows>\n        <size>40</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </parameters>\n      <scope>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>scope</name>\n        <number>8</number>\n        <prettyName>Extension Scope</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>wiki=Current Wiki|user=Current User|global=Global</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </scope>\n    </class>\n    <property>\n      <async_cached>0</async_cached>\n    </property>\n    <property>\n      <async_context/>\n    </property>\n    <property>\n      <async_enabled>0</async_enabled>\n    </property>\n    <property>\n      <content>{{velocity}}\n#set ($crEditName = \"changerequest\")\n#set ($hasCREdit = $services.security.authorization.isRightRegistered($crEditName) &amp;&amp; $services.security.authorization.hasAccess($crEditName, $tdoc))\n## we need to also inject this in view action, because of the inplace editing mode.\n#set ($isEditOrViewAction = ($xcontext.action == 'edit' || $xcontext.action == 'view'))\n#if ($hasCREdit &amp;&amp; $isEditOrViewAction)\n  #set ($hasEditRight = $services.security.authorization.hasAccess('edit', $doc))\n  #set ($createURL = $services.changerequest.getChangeRequestURL('create', ''))\n  #set ($addChangesURL = $services.changerequest.getChangeRequestURL('addchanges', '__CR__'))\n  #set ($isInplaceEditing = ($xcontext.action == 'view'))\n  #set ($changeRequestSaveConfig = {\n    'hasEditRight': $hasEditRight,\n    'createURL': $createURL,\n    'addChangesURL': $addChangesURL,\n    'saveButtonTranslation': $services.localization.render('changerequest.editor.button.save'),\n    'isCreation': $doc.isNew(),\n    'isInplaceEditing': $isInplaceEditing\n  })\n  #if ($request.get('changerequest'))\n    #set ($changeRequestOpt = $services.changerequest.getChangeRequest($request.get('changerequest')))\n    #if ($changeRequestOpt.isPresent())\n      #set ($changeRequestDocReference = $services.changerequest.getChangeRequestDocumentReference($changeRequestOpt.get()))\n      #set ($discard = $changeRequestSaveConfig.put('changeRequestURL', $xwiki.getDocument($changeRequestDocReference).getURL()))\n    #end\n  #end\n  \n  {{html clean=\"false\"}}\n  &lt;script id=\"changerequest-save-config\" type=\"application/json\"&gt;$jsontool.serialize($changeRequestSaveConfig).replace('&lt;', '\\u003C')&lt;/script&gt;\n  #set ($discard = $xwiki.linkx.use($services.webjars.url('selectize.js', 'css/selectize.bootstrap3.css'),\n  {'type': 'text/css', 'rel': 'stylesheet'}))\n  #set ($discard = $xwiki.ssfx.use('uicomponents/suggest/xwiki.selectize.css', true))\n  #set ($discard = $xwiki.jsfx.use('uicomponents/suggest/xwiki.selectize.js', true))\n  #set ($discard = $xwiki.jsx.use('ChangeRequest.Code.SaveChangeRequestModal'))\n  #set ($discard = $xwiki.jsx.use('ChangeRequest.Code.SaveButtonsUIX'))\n  {{/html}}\n  \n#end\n{{/velocity}}</content>\n    </property>\n    <property>\n      <extensionPointId>org.xwiki.platform.template.header.after</extensionPointId>\n    </property>\n    <property>\n      <name>org.xwiki.contrib.changerequest.ui.header.after.editor.extension</name>\n    </property>\n    <property>\n      <parameters>order=0</parameters>\n    </property>\n    <property>\n      <scope>wiki</scope>\n    </property>\n  </object>\n</xwikidoc>\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport org.xwiki.component.annotation.Role;\nimport org.xwiki.contrib.rights.SecurityRuleDiff;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.user.UserReference;\n\n/**\n * Component responsible to handle the rights synchronization between change requests and modified documents, and to\n * perform different rights checks for change request.\n *\n * @version $Id$\n * @since 0.7\n */\n@Unstable\n@Role\npublic interface ChangeRequestRightsManager\n{\n    /**\n     * Copy all rights coming from the original change request to the target one, except view rights rules.\n     *\n     * @param originalChangeRequest the change request from which to get the rights to copy.\n     * @param targetChangeRequest the change request where to copy the rights.\n     * @throws ChangeRequestException in case of problems when reading or writing the rights.\n     */\n    void copyAllButViewRights(ChangeRequest originalChangeRequest, ChangeRequest targetChangeRequest)\n        throws ChangeRequestException;\n\n    /**\n     * Determine if view access is still consistent if a new change related to the given document reference is added\n     * to the given change request. The consistency here means that there's no rules that are contradictory between\n     * the documents included in the change request, and the new document.\n     *\n     * @param changeRequest the change request where the new filechange should be added.\n     * @param newChange the change to be added.\n     * @return {@code true} if the given document reference can be added to the change request without creating right\n     *          inconsistency.\n     * @throws ChangeRequestException in case of problem to access the rights.\n     */\n    boolean isViewAccessConsistent(ChangeRequest changeRequest, DocumentReference newChange)\n        throws ChangeRequestException;\n\n    /**\n     * Determine if the view right is still consistent in the change request for the given list of user references.\n     * The consistency here consists only in defining if each user or group has independently same allow or deny access\n     * of each document of the change request. This method should be called whenever a right is updated in a document.\n     *\n     * @param changeRequest the change request for which to check the consistency.\n     * @param subjectReferences the users or groups for which to check the consistency of rights.\n     * @return {@code true} if the view right is consistent across all document of the change request for each given\n     *          user independently.\n     * @throws ChangeRequestException in case of problem to access the rights.\n     */\n    boolean isViewAccessStillConsistent(ChangeRequest changeRequest, Set<DocumentReference> subjectReferences)\n        throws ChangeRequestException;\n\n    /**\n     * Copy the view right rules coming from the given document reference to the change request.\n     * Note that all inherited rules are copied too.\n     *\n     * @param changeRequest the change request in which to copy rights.\n     * @param newChange the reference from which to get rights to copy.\n     * @throws ChangeRequestException in case of problem for accessing or copying rights.\n     */\n    void copyViewRights(ChangeRequest changeRequest, EntityReference newChange) throws ChangeRequestException;\n\n    /**\n     * Apply the provided right changes to the change request.\n     *\n     * @param changeRequest the change request on which to apply the right changes.\n     * @param ruleDiffList a list of diff changes of rights.\n     * @throws ChangeRequestException in case of problem when applying the changes.\n     */\n    void applyChanges(ChangeRequest changeRequest, List<SecurityRuleDiff> ruleDiffList) throws ChangeRequestException;\n\n    /**\n     * Check if the given user is authorized to merge the given change request.\n     *\n     * @param userReference the user for which to check the authorizations\n     * @param changeRequest the change request to check\n     * @return {@code true} if the user has the appropriate rights to perform the merge.\n     * @throws ChangeRequestException in case of problem when checking if the user is an approver.\n     */\n    boolean isAuthorizedToMerge(UserReference userReference, ChangeRequest changeRequest) throws ChangeRequestException;\n\n    /**\n     * Check if the given user is authorized to review the given change request.\n     *\n     * @param userReference the user for which to check authorizations.\n     * @param changeRequest the change request to review.\n     * @return {@code true} if the user is not one of the change request author and it authorized to review it.\n     * @throws ChangeRequestException in case of problem when checking if a user is an approver.\n     */\n    boolean isAuthorizedToReview(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException;\n\n    /**\n     * Check if the given user is authorized to perform a review on behalf of the original approver, on the given change\n     * request.\n     * This should only returns {@code true} if the delegate approver mechanism is enabled, the original approver is an\n     * explicit approver and the given user is a delegate approver of them.\n     *\n     * @param userReference the user for which to check the authorization\n     * @param changeRequest the change request for which to check the authorization\n     * @param originalApprover the user on behalf of whom the authorization might be given\n     * @return {@code true} if the delegate mechanism is enabled and the given user  is not an author, and is a delegate\n     *          of the original approver who is also an approver of the given change request.\n     * @throws ChangeRequestException in case of problem to resolve the delegate approvers.\n     * @since 0.13\n     */\n    @Unstable\n    boolean isAuthorizedToReviewOnBehalf(UserReference userReference, ChangeRequest changeRequest,\n        UserReference originalApprover) throws ChangeRequestException;\n\n    /**\n     * Check if the given user is authorized to perform a review as a delegate of one of the approver of the given\n     * change request.\n     * This should only returns {@code true} if the delegate mechanism is enabled, the change request has explicit\n     * approvers, and  the given user is a delegate of at least one of them. Moreover, this cannot return {@code true}\n     * if the given user is an author of the change request.\n     *\n     * @param userReference the user for which to check the authorization\n     * @param changeRequest the change request for which to check the authorization\n     * @return {@code true} if the delegate mechanism is enabled, the change request has explicit\n     *         approvers, the given user is not an author of the change request, and is a delegate of at least one of\n     *         the approvers.\n     * @throws ChangeRequestException in case of problem to resolve the delegate approvers.\n     * @since 0.13\n     */\n    @Unstable\n    boolean isAuthorizedToReviewAsDelegate(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException;\n\n    /**\n     * Check if an user is authorized to comment a change request. This method should always check first if the user\n     * is authorized to review (see {@link #isAuthorizedToReview(UserReference, ChangeRequest)}) and allow to comment if\n     * that's the case. Then it should fallback on checking if the user has comment right.\n     *\n     * @param userReference the user for which to check rights.\n     * @param changeRequest the change request for which to check if the user can comment.\n     * @return {@code true} if the user is authorized to post a comment.\n     * @throws ChangeRequestException in case of problem when checking if a user is an approver.\n     */\n    boolean isAuthorizedToComment(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException;\n\n    /**\n     * Define if the given user is authorized to edit the given change request. An edition can be either changing the\n     * status, modifying the description, or even rebasing the change request.\n     * Only change request that are opened can be edited, and only authors or administrators of the change\n     * request document are authorized to do it.\n     * @param userReference the user for which to check rights.\n     * @param changeRequest the change request to check if it can be edited.\n     * @return {@code true} if the given user can edit the change request, {@code false otherwise}.\n     */\n    boolean isAuthorizedToEdit(UserReference userReference, ChangeRequest changeRequest);\n\n    /**\n     * Define if the given user is authorized to re-open a closed change request. This method basically performs the\n     * same checks as {@link #isAuthorizedToEdit(UserReference, ChangeRequest)} except that it always returns false for\n     * merged change requests.\n     * @param userReference the user for which to check rights.\n     * @param changeRequest the change request to check if it can be re-opened.\n     * @return {@code true} if the given user can re-open the change request, {@code false otherwise}.\n     */\n    boolean isAuthorizedToOpen(UserReference userReference, ChangeRequest changeRequest);\n\n    /**\n     * Check if the given user is authorized to perform a split of the change request.\n     * Users that are authors of the change request, and admins are authorized to split a change request.\n     *\n     * @param userReference the user for which to check rights\n     * @param changeRequest the change request that is requested to be split\n     * @return {@code true} if the given user is an author or an admin\n     */\n    default boolean isAuthorizedToSplit(UserReference userReference, ChangeRequest changeRequest)\n    {\n        return false;\n    }\n\n    /**\n     * Check if the given user is allowed to use change request to edit the given document reference.\n     * @param userReference the user for whom to perform the check\n     * @param documentReference the reference for which to check authorization\n     * @return {@code true} if the given user is allowed to perform the edition with change request\n     * @throws ChangeRequestException in case of problem when performing the check\n     * @since 1.10\n     */\n    default boolean isEditWithChangeRequestAllowed(UserReference userReference, DocumentReference documentReference)\n        throws ChangeRequestException\n    {\n        return false;\n    }\n\n    /**\n     * Check if the given user is allowed to use change request to create a document having the given reference for\n     * parent.\n     * @param userReference the user for whom to perform the check\n     * @param parentSpaceReference the parent space where the new document would be created\n     * @return {@code true} if the given user is allowed to create a document with change request at the given place\n     * @throws ChangeRequestException in case of problem when performing the check\n     * @since 1.10\n     */\n    default boolean isCreateWithChangeRequestAllowed(UserReference userReference,\n        DocumentReference parentSpaceReference) throws ChangeRequestException\n    {\n        return false;\n    }\n}\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--\n  ~ See the NOTICE file distributed with this work for additional\n  ~ information regarding copyright ownership.\n  ~\n  ~ This is free software; you can redistribute it and/or modify it\n  ~ under the terms of the GNU Lesser General Public License as\n  ~ published by the Free Software Foundation; either version 2.1 of\n  ~ the License, or (at your option) any later version.\n  ~\n  ~ This software is distributed in the hope that it will be useful,\n  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of\n  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  ~ Lesser General Public License for more details.\n  ~\n  ~ You should have received a copy of the GNU Lesser General Public\n  ~ License along with this software; if not, write to the Free\n  ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n  ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n  -->\n\n<!DOCTYPE suppressions PUBLIC\n    \"-//Puppy Crawl//DTD Suppressions 1.0//EN\"\n    \"http://www.puppycrawl.com/dtds/suppressions_1_0.dtd\">\n\n<suppressions>\n  <!-- The complexity metrics are not respected on EditChangeRequestResourceHandler for now. Note that in the future\n  this handler should be mostly an inheritance of an EditResourceHandler that will belocated in xwiki-platform and most\n  of the code put in the current class will be put in commons for the various actions. For now we keep it like that\n  since it avoids extending an old XWikiAction. -->\n  <suppress checks=\"NPathComplexity\" files=\"EditChangeRequestResourceHandler.java\"/>\n  <suppress checks=\"CyclomaticComplexity\" files=\"EditChangeRequestResourceHandler.java\"/>\n\n  <suppress checks=\"ClassFanOutComplexity\" files=\"CreateInChangeRequestResourceHandler.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"TemplateProviderSupportChecker.java\"/>\n\n  <suppress checks=\"ClassFanOutComplexity\" files=\"ChangeRequestEventsConverter.java\"/>\n\n  <!-- False positive introduced by multi strings used for queries -->\n  <suppress checks=\"MultipleStringLiterals\" files=\"DefaultChangeRequestStorageManager.java\"/>\n\n  <!-- FIXME: this should be improved in the future -->\n  <suppress checks=\"ClassFanOutComplexity\" files=\"DefaultFileChangeStorageManager.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"DefaultChangeRequestManager.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"DefaultChangeRequestRightsManager.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"DefaultChangeRequestMergeManager.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"DefaultChangeRequestStorageManager.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"AddChangesChangeRequestHandler.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"CreateChangeRequestHandler.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"AbstractChangeRequestActionHandler.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"XWikiDocumentDelegateApproverManager.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"ChangeRequestScriptService.java\"/>\n  <suppress checks=\"ClassFanOutComplexity\" files=\"ChangeRequestResourceHandler.java\"/>\n  <suppress checks=\"CyclomaticComplexity\" files=\"RightsUpdatedListener.java\"/>\n  <suppress checks=\"CyclomaticComplexity\" files=\"AbstractChangeRequestActionHandler.java\"/>\n</suppressions>\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.contrib.changerequest.ApproversManager;\nimport org.xwiki.contrib.changerequest.ChangeRequest;\nimport org.xwiki.contrib.changerequest.ChangeRequestConfiguration;\nimport org.xwiki.contrib.changerequest.ChangeRequestException;\nimport org.xwiki.contrib.changerequest.ChangeRequestRightsManager;\nimport org.xwiki.contrib.changerequest.ChangeRequestStatus;\nimport org.xwiki.contrib.changerequest.DelegateApproverManager;\nimport org.xwiki.contrib.changerequest.FileChange;\nimport org.xwiki.contrib.changerequest.rights.ChangeRequestApproveRight;\nimport org.xwiki.contrib.changerequest.rights.ChangeRequestRight;\nimport org.xwiki.contrib.rights.RightsReader;\nimport org.xwiki.contrib.rights.RightsWriter;\nimport org.xwiki.contrib.rights.SecurityRuleAbacus;\nimport org.xwiki.contrib.rights.SecurityRuleDiff;\nimport org.xwiki.contrib.rights.WritableSecurityRule;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.security.authorization.AuthorizationException;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ReadableSecurityRule;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.security.authorization.RightSet;\nimport org.xwiki.security.authorization.RuleState;\nimport org.xwiki.user.GuestUserReference;\nimport org.xwiki.user.UserReference;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.PasswordClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\n\n/**\n * Component in charge of performing right synchronization operations.\n *\n * @version $Id$\n * @since 0.7\n */\n@Component\n@Singleton\npublic class DefaultChangeRequestRightsManager implements ChangeRequestRightsManager\n{\n    @Inject\n    private DocumentReferenceResolver<ChangeRequest> changeRequestDocumentReferenceResolver;\n\n    @Inject\n    private AuthorizationManager authorizationManager;\n\n    @Inject\n    private RightsWriter rightsWriter;\n\n    @Inject\n    private SecurityRuleAbacus ruleAbacus;\n\n    @Inject\n    private RightsReader rightsReader;\n\n    @Inject\n    private ApproversManager<ChangeRequest> changeRequestApproversManager;\n\n    @Inject\n    private DelegateApproverManager<ChangeRequest> changeRequestDelegateApproverManager;\n\n    @Inject\n    private UserReferenceConverter userReferenceConverter;\n\n    @Inject\n    private ChangeRequestConfiguration configuration;\n\n    @Inject\n    private Provider<XWikiContext> contextProvider;\n\n    @Override\n    public void copyAllButViewRights(ChangeRequest originalChangeRequest, ChangeRequest targetChangeRequest)\n        throws ChangeRequestException\n    {\n        DocumentReference originalDocReference =\n            this.changeRequestDocumentReferenceResolver.resolve(originalChangeRequest);\n        DocumentReference targetDocReference =\n            this.changeRequestDocumentReferenceResolver.resolve(targetChangeRequest);\n\n        try {\n            List<ReadableSecurityRule> actualRules =\n                this.rightsReader.getRules(originalDocReference.getLastSpaceReference(), false);\n            List<ReadableSecurityRule> writableSecurityRules = new ArrayList<>();\n\n            for (ReadableSecurityRule actualRule : actualRules) {\n                if (actualRule.match(Right.VIEW)) {\n                    WritableSecurityRule rule = this.rightsWriter.createRule(actualRule);\n                    RightSet rights = rule.getRights();\n                    rights.remove(Right.VIEW);\n                    if (!rights.isEmpty()) {\n                        rule.setRights(rights);\n                        writableSecurityRules.add(rule);\n                    }\n                } else {\n                    writableSecurityRules.add(actualRule);\n                }\n            }\n            this.rightsWriter.saveRules(writableSecurityRules, targetDocReference.getLastSpaceReference());\n        } catch (AuthorizationException | XWikiException e) {\n            throw new ChangeRequestException(\n                String.format(\"Error while trying to retrieve or save rights between [%s] and [%s]\",\n                    originalDocReference, targetDocReference), e);\n        }\n    }\n\n    @Override\n    public boolean isViewAccessConsistent(ChangeRequest changeRequest, DocumentReference newChange)\n        throws ChangeRequestException\n    {\n        Set<DocumentReference> documentReferences = new HashSet<>(changeRequest.getModifiedDocuments());\n        documentReferences.add(newChange);\n\n        Set<DocumentReference> subjects = new HashSet<>();\n        for (DocumentReference documentReference : documentReferences) {\n            try {\n                List<ReadableSecurityRule> actualRules = this.rightsReader.getActualRules(documentReference);\n                List<ReadableSecurityRule> normalizedRules = this.ruleAbacus.normalizeRulesBySubject(actualRules);\n                for (ReadableSecurityRule normalizedRule : normalizedRules) {\n                    if (normalizedRule.match(Right.VIEW)) {\n                        subjects.addAll(normalizedRule.getGroups());\n                        subjects.addAll(normalizedRule.getUsers());\n                    }\n                }\n            } catch (AuthorizationException e) {\n                throw new ChangeRequestException(\n                    String.format(\"Error while trying to access rights for [%s]\", documentReference), e);\n            }\n        }\n\n        return this.isViewAccessConsistent(documentReferences, subjects);\n    }\n\n    @Override\n    public boolean isViewAccessStillConsistent(ChangeRequest changeRequest,\n        Set<DocumentReference> subjectReferences) throws ChangeRequestException\n    {\n        return this.isViewAccessConsistent(changeRequest.getModifiedDocuments(), subjectReferences);\n    }\n\n    private boolean isViewAccessConsistent(Set<DocumentReference> documentReferences,\n        Set<DocumentReference> subjectReferences)\n    {\n        for (DocumentReference subject : subjectReferences) {\n            Boolean hasAccess = null;\n            for (DocumentReference modifiedDocument : documentReferences) {\n                boolean currentHasAccess =\n                    this.authorizationManager.hasAccess(Right.VIEW, subject, modifiedDocument);\n\n                if (hasAccess == null) {\n                    hasAccess = currentHasAccess;\n                } else if (hasAccess != currentHasAccess) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void copyViewRights(ChangeRequest changeRequest, EntityReference newChange)\n        throws ChangeRequestException\n    {\n        DocumentReference changeRequestDocReference =\n            this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n        SpaceReference changeRequestSpaceReference = changeRequestDocReference.getLastSpaceReference();\n\n        try {\n            List<ReadableSecurityRule> actualRules =\n                this.rightsReader.getRules(changeRequestSpaceReference, false);\n            List<ReadableSecurityRule> rules = new ArrayList<>(this.rightsWriter.createRules(actualRules));\n            List<ReadableSecurityRule> documentRules =\n                new ArrayList<>(this.rightsReader.getActualRules(newChange));\n            List<ReadableSecurityRule> wikiRules =\n                this.rightsReader.getActualRules(newChange.extractReference(EntityType.WIKI));\n\n            // we filter out the wiki reference rules\n            documentRules.removeAll(wikiRules);\n            for (ReadableSecurityRule actualRule : documentRules) {\n                if (actualRule.match(Right.VIEW)) {\n                    WritableSecurityRule rule = this.rightsWriter.createRule(actualRule);\n                    rule.setRights(Collections.singletonList(Right.VIEW));\n                    rules.add(rule);\n                }\n            }\n\n            this.rightsWriter.saveRules(rules, changeRequestSpaceReference);\n        } catch (AuthorizationException | XWikiException e) {\n            throw new ChangeRequestException(\n                String.format(\"Error while copying rights from [%s] for change request [%s]\", changeRequest, newChange),\n                e);\n        }\n    }\n\n    /**\n     * Helper class for computing efficiently the change to perform in {@link #applyChanges(ChangeRequest, List)}.\n     */\n    private static final class SecurityRuleAction\n    {\n        private final boolean add;\n        private final RuleState state;\n        private final boolean isGroup;\n\n        /**\n         * Default constructor.\n         *\n         * @param add {@code true} if it concerns a rule added, else it's a rule deleted.\n         * @param state the rule state\n         * @param isGroup {@code true} if the associated key in the map where those actions are used is a reference to\n         *                a group, else it's a reference to a user.\n         */\n        SecurityRuleAction(boolean add, RuleState state, boolean isGroup)\n        {\n            this.add = add;\n            this.state = state;\n            this.isGroup = isGroup;\n        }\n    }\n\n    /**\n     * Create the {@link SecurityRuleAction} corresponding to the given rule and the given add flag, and put it in the\n     * given map.\n     *\n     * @param rule the rule for which to create the {@link SecurityRuleAction}.\n     * @param add to set the flag in the created action.\n     * @param map where to put the created action.\n     */\n    private void creationActionRule(ReadableSecurityRule rule, boolean add,\n        Map<DocumentReference, List<SecurityRuleAction>> map)\n    {\n        SecurityRuleAction action;\n        DocumentReference key;\n        if (this.isAboutUser(rule)) {\n            key = rule.getUsers().get(0);\n            action = new SecurityRuleAction(add, rule.getState(), false);\n        } else {\n            key = rule.getGroups().get(0);\n            action = new SecurityRuleAction(add, rule.getState(), true);\n        }\n        if (!map.containsKey(key)) {\n            map.put(key, new ArrayList<>());\n        }\n        map.get(key).add(action);\n    }\n\n    /**\n     * Check if the given rule is about a user or a group.\n     *\n     * @param rule the rule to check.\n     * @return {@code true} if the rule is about a user, {@code false} if it's about a group.\n     */\n    private boolean isAboutUser(ReadableSecurityRule rule)\n    {\n        return rule.getUsers() != null && !rule.getUsers().isEmpty();\n    }\n\n    /**\n     * Clone the given rule and apply the changes required by the action before adding it back in the list of rules to\n     * write.\n     *\n     * @param securityRuleAction the change to be performed on the rule.\n     * @param normalizedRule the original rule to be updated.\n     * @param updatedRules the list of rules to write after the changes.\n     */\n    private void updateRule(SecurityRuleAction securityRuleAction, ReadableSecurityRule normalizedRule,\n        List<ReadableSecurityRule> updatedRules)\n    {\n        // We ensure first that we won't have twice the rule to write\n        updatedRules.remove(normalizedRule);\n        RightSet rightSet = normalizedRule.getRights();\n        WritableSecurityRule writerRule = this.rightsWriter.createRule(normalizedRule);\n\n        // if the rule has been added then we need to add a view Right to the rule we found,\n        // else we need to remove it.\n        if (securityRuleAction.add) {\n            rightSet.add(Right.VIEW);\n        } else {\n            rightSet.remove(Right.VIEW);\n        }\n\n        // if the rule was only about view right and it has been removed, we already discarded it first,\n        // so we don't need to do anything\n        if (!rightSet.isEmpty()) {\n            writerRule.setRights(rightSet);\n            updatedRules.add(writerRule);\n        }\n    }\n\n    /**\n     * Create a new security rule based on an action, when there was no matching rules.\n     *\n     * @param action the action for which to create a new security rule.\n     * @param reference the reference of the user or group to use.\n     * @param updatedRules the list of rules to write.\n     */\n    private void createRule(SecurityRuleAction action, DocumentReference reference,\n        List<ReadableSecurityRule> updatedRules)\n    {\n        // if the action was about deleting a rule, we just ignore it: we did not find a rule concerning it previously\n        // there's nothing more to do now.\n        if (action.add) {\n            WritableSecurityRule rule = this.rightsWriter.createRule();\n            if (action.isGroup) {\n                rule.setGroups(Collections.singletonList(reference));\n            } else {\n                rule.setUsers(Collections.singletonList(reference));\n            }\n            rule.setRights(Collections.singletonList(Right.VIEW));\n            rule.setState(action.state);\n            updatedRules.add(rule);\n        }\n    }\n\n    /**\n     * Performs the given actions on the change request rights to update them.\n     *\n     * @param changeRequest the change request on which to perform changes.\n     * @param actionsToPerform the rights update to perform that have been previously computed.\n     * @param ruleDiffList the original diff list used for logging purpose.\n     * @throws ChangeRequestException in case of problem for writing rights.\n     */\n    private void applyActions(ChangeRequest changeRequest,\n        Map<DocumentReference, List<SecurityRuleAction>> actionsToPerform, List<SecurityRuleDiff> ruleDiffList)\n        throws ChangeRequestException\n    {\n        DocumentReference changeRequestDocReference =\n            this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n        SpaceReference changeRequestSpaceReference = changeRequestDocReference.getLastSpaceReference();\n\n        try {\n            // first we get the rules that concerns the change request\n            List<ReadableSecurityRule> actualRules =\n                this.rightsReader.getRules(changeRequestSpaceReference, false);\n\n            // then we normalize them to allow using properly the map of actions\n            List<ReadableSecurityRule> normalizedRules = this.ruleAbacus.normalizeRulesBySubject(actualRules);\n\n            // we create a copy of the list to allow modifying it when iterating on the original\n            List<ReadableSecurityRule> updatedRules = new ArrayList<>(normalizedRules);\n\n            for (ReadableSecurityRule normalizedRule : normalizedRules) {\n                // the rule applies on the given target\n                DocumentReference target = (this.isAboutUser(normalizedRule))\n                    ? normalizedRule.getUsers().get(0) : normalizedRule.getGroups().get(0);\n\n                // we check if there's one or several actions to perform\n                if (actionsToPerform.containsKey(target)) {\n\n                    // we create a copy of the list to allow removing the actions while iterating\n                    List<SecurityRuleAction> securityRuleActions = actionsToPerform.get(target);\n\n                    for (SecurityRuleAction securityRuleAction : new ArrayList<>(securityRuleActions)) {\n\n                        // we only update the rule if the state is the same than in the action\n                        // we're doing this because we're not supposed to change the state of the rule:\n                        // we only create or remove rules. A change of a state will create two actions, one for removing\n                        // and one for creating.\n                        // This strategy is tightly linked to the way normalizing rules work right now, see the javadoc\n                        // of SecurityRuleAbacus.\n                        if (normalizedRule.getState() == securityRuleAction.state) {\n                            this.updateRule(securityRuleAction, normalizedRule, updatedRules);\n\n                            // we remove the action once applied\n                            securityRuleActions.remove(securityRuleAction);\n                        }\n                    }\n\n                    // if there's no more action, we remove the entry\n                    if (securityRuleActions.isEmpty()) {\n                        actionsToPerform.remove(target);\n                    }\n                }\n            }\n\n            // We might still have actions to apply if there was no previous rules concerning the targets:\n            // here we apply only the action for adding rules.\n            for (Map.Entry<DocumentReference, List<SecurityRuleAction>> entry : actionsToPerform.entrySet()) {\n                DocumentReference reference = entry.getKey();\n\n                for (SecurityRuleAction action : entry.getValue()) {\n                    this.createRule(action, reference, updatedRules);\n                }\n            }\n\n            // finally we write all rules\n            this.rightsWriter.saveRules(updatedRules, changeRequestSpaceReference);\n        } catch (AuthorizationException | XWikiException e) {\n            throw new ChangeRequestException(String.format(\"Error while applying rights changes for change request \"\n                + \"[%s] with diff [%s]\", changeRequest, ruleDiffList),\n                e);\n        }\n    }\n\n    private Map<DocumentReference, List<SecurityRuleAction>> computeActionsMap(List<SecurityRuleDiff> ruleDiffList)\n    {\n        Map<DocumentReference, List<SecurityRuleAction>> actionsToPerform = new HashMap<>();\n\n        for (SecurityRuleDiff securityRuleDiff : ruleDiffList) {\n            ReadableSecurityRule currentRule = securityRuleDiff.getCurrentRule();\n            ReadableSecurityRule previousRule = securityRuleDiff.getPreviousRule();\n            switch (securityRuleDiff.getChangeType()) {\n                case RULE_ADDED:\n                    if (currentRule.match(Right.VIEW)) {\n                        this.creationActionRule(currentRule, true, actionsToPerform);\n                    }\n                    break;\n\n                case RULE_DELETED:\n                    if (previousRule.match(Right.VIEW)) {\n                        this.creationActionRule(previousRule, false, actionsToPerform);\n                    }\n                    break;\n\n                default:\n                case RULE_UPDATED:\n                    if (previousRule.match(Right.VIEW)) {\n                        this.creationActionRule(previousRule, false, actionsToPerform);\n                    }\n                    if (currentRule.match(Right.VIEW)) {\n                        this.creationActionRule(currentRule, true, actionsToPerform);\n                    }\n                    break;\n            }\n        }\n        return actionsToPerform;\n    }\n\n    @Override\n    public void applyChanges(ChangeRequest changeRequest, List<SecurityRuleDiff> ruleDiffList)\n        throws ChangeRequestException\n    {\n        // This methods works in two main steps:\n        //   1. we compute a list of actions to perform on rights, indexed by the reference of the group or user\n        //      targeted by the right rule. This data structure is chosen because of the way rules are normalized\n        //      with the SecurityRuleAbacus.\n        //   2. we apply the map of actions on the change request rights.\n\n        Map<DocumentReference, List<SecurityRuleAction>> actionsToPerform =\n            this.computeActionsMap(ruleDiffList);\n\n        if (!actionsToPerform.isEmpty()) {\n            this.applyActions(changeRequest, actionsToPerform, ruleDiffList);\n        }\n    }\n\n    @Override\n    public boolean isAuthorizedToMerge(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException\n    {\n        boolean result = true;\n\n        // The merger user is taken from the configuration if a merger user is defined, and this is the user\n        // who should be checked for the proper edit/delete rights.\n        // Now the approval right should only be checked on the current user reference.\n        UserReference mergerUserReference = userReference;\n        UserReference mergeUserReference = this.configuration.getMergeUser();\n        if (mergeUserReference != GuestUserReference.INSTANCE) {\n            mergerUserReference = mergeUserReference;\n        }\n        DocumentReference mergeUserDocReference = this.userReferenceConverter.convert(mergerUserReference);\n        DocumentReference currentUserDocReference = this.userReferenceConverter.convert(userReference);\n\n        // This method is only checking if the user is an approver, so even with the fallback it's possible that\n        // an admin user has approval right, but is not an approver of this specific change request, because a\n        // list of approver is defined in it. So we cannot forbid merging a change request for people who are not\n        // explicitely approvers.\n        // Instead, we check in each file if the approval right is granted in case the user is not approver:\n        // users who have proper write authorization, and proper approval right should be able to merge if they're not\n        // explicitely approvers of the given change request.\n        // This choice is mainly to avoid blocking a change request, in case approvers do not have write access\n        // which can be quite common.\n        boolean isApprover = this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)\n            || this.changeRequestDelegateApproverManager.isDelegateApproverOf(userReference, changeRequest);\n\n        for (FileChange lastFileChange : changeRequest.getLastFileChanges()) {\n            Right rightToBeChecked;\n            switch (lastFileChange.getType()) {\n                case DELETION:\n                    rightToBeChecked = Right.DELETE;\n                    break;\n\n                case EDITION:\n                case CREATION:\n                default:\n                    rightToBeChecked = Right.EDIT;\n                    break;\n            }\n            DocumentReference targetEntity = lastFileChange.getTargetEntity();\n            // We check the write right on the merge user, and the approval right on the current user.\n            boolean hasWriteRight = this.authorizationManager\n                .hasAccess(rightToBeChecked, mergeUserDocReference, targetEntity);\n            boolean hasApprovalRight = this.authorizationManager\n                .hasAccess(ChangeRequestApproveRight.getRight(), currentUserDocReference, targetEntity);\n\n            if (!(hasWriteRight && (isApprover || hasApprovalRight))) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    @Override\n    public boolean isAuthorizedToReview(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException\n    {\n        boolean result = false;\n        if (!this.configuration.preventAuthorToReview() || !(changeRequest.getAuthors().contains(userReference))) {\n            result = this.changeRequestApproversManager.isApprover(userReference, changeRequest, false);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isAuthorizedToReviewOnBehalf(UserReference userReference, ChangeRequest changeRequest,\n        UserReference originalApprover) throws ChangeRequestException\n    {\n        boolean result = false;\n        if (!this.configuration.preventAuthorToReview() || !(changeRequest.getAuthors().contains(userReference))) {\n            result = this.changeRequestDelegateApproverManager\n                .isDelegateApproverOf(userReference, changeRequest, originalApprover);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isAuthorizedToReviewAsDelegate(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException\n    {\n        boolean result = false;\n        if (!this.configuration.preventAuthorToReview() || !(changeRequest.getAuthors().contains(userReference))) {\n            result = this.changeRequestDelegateApproverManager.isDelegateApproverOf(userReference, changeRequest);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isAuthorizedToComment(UserReference userReference, ChangeRequest changeRequest)\n        throws ChangeRequestException\n    {\n        DocumentReference userDocReference = this.userReferenceConverter.convert(userReference);\n        DocumentReference changeRequestDoc = this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n        boolean hasAdminRight = this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc);\n        boolean hasCommentRight =\n            this.authorizationManager.hasAccess(Right.COMMENT, userDocReference, changeRequestDoc);\n        return hasAdminRight || this.isAuthorizedToReview(userReference, changeRequest) || hasCommentRight;\n    }\n\n    private boolean isAuthorizedToEdit(UserReference userReference, ChangeRequest changeRequest,\n        boolean checkForOpening)\n    {\n        boolean result = false;\n        ChangeRequestStatus status = changeRequest.getStatus();\n        if (status != ChangeRequestStatus.MERGED && (status.isOpen() || checkForOpening)) {\n            // if change request was created by guest, then anybody should be able to edit it.\n            if (changeRequest.getAuthors().contains(GuestUserReference.INSTANCE)\n                || changeRequest.getAuthors().contains(userReference)) {\n                result = true;\n            } else {\n                DocumentReference userDocReference = this.userReferenceConverter.convert(userReference);\n                DocumentReference changeRequestDoc = this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n                result = this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc);\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isAuthorizedToEdit(UserReference userReference, ChangeRequest changeRequest)\n    {\n        return this.isAuthorizedToEdit(userReference, changeRequest, false);\n    }\n\n    @Override\n    public boolean isAuthorizedToOpen(UserReference userReference, ChangeRequest changeRequest)\n    {\n        return this.isAuthorizedToEdit(userReference, changeRequest, true);\n    }\n\n    @Override\n    public boolean isAuthorizedToSplit(UserReference userReference, ChangeRequest changeRequest)\n    {\n        boolean result = changeRequest.getAuthors().contains(userReference);\n        if (!result) {\n            DocumentReference userDocReference = this.userReferenceConverter.convert(userReference);\n            DocumentReference crReference = this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n            result = this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, crReference);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isEditWithChangeRequestAllowed(UserReference userReference, DocumentReference documentReference)\n        throws ChangeRequestException\n    {\n        DocumentReference userDocReference = this.userReferenceConverter.convert(userReference);\n        boolean hasCREdit = this.authorizationManager.hasAccess(ChangeRequestRight.getRight(), userDocReference,\n            documentReference);\n        boolean result = false;\n        // if the user doesn't have CR edit right, then it's already solved.\n        if (hasCREdit) {\n            XWikiContext context = this.contextProvider.get();\n            try {\n                XWikiDocument document = context.getWiki().getDocument(documentReference, context);\n                // if it's a new document, we don't care\n                if (document.isNew()) {\n                    result = true;\n                } else {\n                    Map<DocumentReference, List<BaseObject>> objects = document.getXObjects();\n                    boolean foundOneObjectWithPassword = false;\n                    for (Map.Entry<DocumentReference, List<BaseObject>> objectsEntry : objects.entrySet()) {\n                        Optional<BaseObject> baseObjectOpt =\n                            objectsEntry.getValue().stream().filter(Objects::nonNull).findFirst();\n                        if (baseObjectOpt.isPresent() && this.isObjectContainingPassword(baseObjectOpt.get())) {\n                            foundOneObjectWithPassword = true;\n                            break;\n                        }\n                    }\n                    if (!foundOneObjectWithPassword) {\n                        result = true;\n                    }\n                }\n            } catch (XWikiException e) {\n                throw new ChangeRequestException(String.format(\"Cannot load document [%s] to check if CR right should \"\n                    + \"be granted for user [%s]\", documentReference, userDocReference), e);\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isCreateWithChangeRequestAllowed(UserReference userReference, DocumentReference parentSpaceReference)\n        throws ChangeRequestException\n    {\n        DocumentReference userDocReference = this.userReferenceConverter.convert(userReference);\n        return this.authorizationManager.hasAccess(ChangeRequestRight.getRight(), userDocReference,\n            parentSpaceReference);\n    }\n\n    private boolean isObjectContainingPassword(BaseObject baseObject)\n    {\n        XWikiContext context = contextProvider.get();\n        Collection<PropertyClass> propertyClassCollection = baseObject.getXClass(context).getFieldList();\n        for (PropertyClass propertyClass : propertyClassCollection) {\n            if (propertyClass instanceof PasswordClass) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest.internal.handlers;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.xwiki.container.Container;\nimport org.xwiki.contrib.changerequest.ApproversManager;\nimport org.xwiki.contrib.changerequest.ChangeRequest;\nimport org.xwiki.contrib.changerequest.ChangeRequestConfiguration;\nimport org.xwiki.contrib.changerequest.ChangeRequestException;\nimport org.xwiki.contrib.changerequest.ChangeRequestManager;\nimport org.xwiki.contrib.changerequest.ChangeRequestReference;\nimport org.xwiki.contrib.changerequest.ChangeRequestRightsManager;\nimport org.xwiki.contrib.changerequest.FileChange;\nimport org.xwiki.contrib.changerequest.internal.FileChangeVersionManager;\nimport org.xwiki.contrib.changerequest.storage.ChangeRequestStorageManager;\nimport org.xwiki.contrib.changerequest.storage.FileChangeStorageManager;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.wysiwyg.converter.RequestParameterConverter;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.web.EditForm;\nimport com.xpn.xwiki.web.XWikiResponse;\n\n/**\n * Abstract implementation of {@link ChangeRequestActionHandler} which provides some utility methods.\n *\n * @version $Id$\n * @since 0.3\n */\npublic abstract class AbstractChangeRequestActionHandler implements ChangeRequestActionHandler\n{\n    static final String PREVIOUS_VERSION_PARAMETER = \"previousVersion\";\n    static final String FROM_CHANGE_REQUEST_PARAMETER = \"fromchangerequest\";\n    private static final String ASYNC_PARAMETER = \"async\";\n\n    @Inject\n    protected Provider<XWikiContext> contextProvider;\n\n    @Inject\n    protected DocumentReferenceResolver<ChangeRequest> changeRequestDocumentReferenceResolver;\n\n    @Inject\n    protected ChangeRequestStorageManager storageManager;\n\n    @Inject\n    protected ObservationManager observationManager;\n\n    @Inject\n    @Named(\"current\")\n    protected DocumentReferenceResolver<String> documentReferenceResolver;\n\n    @Inject\n    protected FileChangeStorageManager fileChangeStorageManager;\n\n    @Inject\n    protected Container container;\n\n    @Inject\n    protected FileChangeVersionManager fileChangeVersionManager;\n\n    @Inject\n    protected ChangeRequestRightsManager changeRequestRightsManager;\n\n    @Inject\n    protected ChangeRequestManager changeRequestManager;\n\n    @Inject\n    private RequestParameterConverter requestParameterConverter;\n\n    @Inject\n    private ContextualAuthorizationManager contextualAuthorizationManager;\n\n    @Inject\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    @Inject\n    private UserReferenceResolver<CurrentUserReference> currentUserReferenceResolver;\n\n    @Inject\n    private ApproversManager<FileChange> fileChangeApproversManager;\n\n    @Inject\n    private ApproversManager<ChangeRequest> changeRequestApproversManager;\n\n    @Inject\n    private ChangeRequestConfiguration configuration;\n\n    @Inject\n    private ContextualLocalizationManager contextualLocalizationManager;\n\n    protected HttpServletRequest prepareRequest() throws ChangeRequestException\n    {\n        XWikiContext context = this.contextProvider.get();\n        HttpServletRequest request = context.getRequest();\n        try {\n            return (HttpServletRequest) this.requestParameterConverter.convert(request, context.getResponse()).get();\n        } catch (IOException e) {\n            throw new ChangeRequestException(\"Error while converting request\", e);\n        }\n    }\n\n    protected EditForm prepareForm(HttpServletRequest request)\n    {\n        EditForm editForm = new EditForm();\n        editForm.setRequest(request);\n        editForm.readRequest();\n        return editForm;\n    }\n\n    protected void redirectToChangeRequest(ChangeRequest changeRequest) throws IOException\n    {\n        this.redirectToChangeRequest(changeRequest, \"view\");\n    }\n\n    protected void redirectToChangeRequest(ChangeRequest changeRequest, String action) throws IOException\n    {\n        XWikiContext context = this.contextProvider.get();\n        DocumentReference changeRequestDocumentReference =\n            this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n        String url = context.getWiki().getURL(changeRequestDocumentReference, action, context);\n        context.getResponse().sendRedirect(url);\n    }\n\n    protected ChangeRequest loadChangeRequest(ChangeRequestReference reference)\n        throws ChangeRequestException, IOException\n    {\n        Optional<ChangeRequest> changeRequestOptional = this.storageManager.load(reference.getId());\n        if (changeRequestOptional.isPresent()) {\n            return changeRequestOptional.get();\n        } else {\n            XWikiContext context = this.contextProvider.get();\n            context.getResponse().sendError(404, String.format(\"Cannot find change request with id [%s]\",\n                    reference.getId()));\n        }\n        return null;\n    }\n\n    protected boolean isFromChangeRequest(HttpServletRequest request)\n    {\n        return StringUtils.equals(request.getParameter(FROM_CHANGE_REQUEST_PARAMETER), \"1\");\n    }\n\n    protected String getPreviousVersion(HttpServletRequest request)\n    {\n        String previousVersionParameter = request.getParameter(PREVIOUS_VERSION_PARAMETER);\n        if (isFromChangeRequest(request)) {\n            return this.fileChangeVersionManager.getFileChangeVersion(previousVersionParameter);\n        } else {\n            return previousVersionParameter;\n        }\n    }\n\n    protected XWikiDocument prepareDocument(HttpServletRequest request, EditForm editForm, ChangeRequest changeRequest)\n        throws ChangeRequestException\n    {\n        XWikiContext context = this.contextProvider.get();\n        String serializedDocReference = request.getParameter(\"docReference\");\n        DocumentReference documentReference = this.documentReferenceResolver.resolve(serializedDocReference);\n        UserReference currentUserReference = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        if (!this.changeRequestRightsManager.isEditWithChangeRequestAllowed(currentUserReference, documentReference)) {\n            throw new ChangeRequestException(\n                String.format(\"User [%s] is not allowed to edit the document [%s] through a change request.\",\n                    currentUserReference, documentReference));\n        }\n\n        XWikiDocument modifiedDocument = null;\n        try {\n            if (isFromChangeRequest(request) && changeRequest != null) {\n                List<FileChange> fileChangeList = this.fileChangeStorageManager.load(changeRequest, documentReference);\n                String previousVersion = getPreviousVersion(request);\n                FileChange fileChange = null;\n                for (FileChange change : fileChangeList) {\n                    if (change.getVersion().equals(previousVersion)) {\n                        fileChange = change;\n                        break;\n                    }\n                }\n                if (fileChange != null) {\n                    modifiedDocument = (XWikiDocument) fileChange.getModifiedDocument();\n                } else {\n                    throw new ChangeRequestException(\n                        String.format(\"Cannot find file change with version [%s]\", previousVersion));\n                }\n            } else {\n                modifiedDocument = context.getWiki().getDocument(documentReference, context);\n            }\n            // cloning the document to ensure we don't impact the document in cache.\n            modifiedDocument = modifiedDocument.clone();\n\n            // Read info from the template if there's one.\n            if (!StringUtils.isBlank(editForm.getTemplate())) {\n                DocumentReference templateRef =\n                    this.currentMixedDocumentReferenceResolver.resolve(editForm.getTemplate());\n\n                // Check that the template can be read by current user.\n                if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, templateRef)) {\n                    modifiedDocument.readFromTemplate(templateRef, context);\n                }\n            }\n\n            modifiedDocument.readFromForm(editForm, context);\n            if (modifiedDocument.getDefaultLocale() == Locale.ROOT) {\n                modifiedDocument.setDefaultLocale(context.getWiki().getLocalePreference(context));\n            }\n            return modifiedDocument;\n        } catch (XWikiException e) {\n            throw new ChangeRequestException(\n                String.format(\"Cannot read document [%s]\", serializedDocReference), e);\n        }\n    }\n\n    protected void responseSuccess(ChangeRequest changeRequest) throws IOException\n    {\n        XWikiContext context = this.contextProvider.get();\n        if (this.isAsync(context.getRequest())) {\n            Map<String, String> json = new HashMap<>();\n            json.put(\"changeRequestId\", changeRequest.getId());\n            DocumentReference changeRequestRef = this.changeRequestDocumentReferenceResolver.resolve(changeRequest);\n            json.put(\"changeRequestUrl\", context.getWiki().getURL(changeRequestRef, context));\n            this.answerJSON(HttpServletResponse.SC_OK, json);\n        } else {\n            this.redirectToChangeRequest(changeRequest);\n        }\n    }\n\n    protected boolean isAsync(HttpServletRequest request)\n    {\n        return \"1\".equals(request.getParameter(ASYNC_PARAMETER));\n    }\n\n    /**\n     * Answer to a request with a JSON content.\n     * Note: this method was partially copied from {@link com.xpn.xwiki.web.XWikiAction}.\n     *\n     * @param status the status code to send back.\n     * @param answer the content of the JSON answer.\n     * @throws IOException in case of error during the serialization of the JSON.\n     */\n    protected void answerJSON(int status, Map<String, String> answer) throws IOException\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        XWikiContext context = contextProvider.get();\n        XWikiResponse response = context.getResponse();\n        String jsonAnswerAsString = mapper.writeValueAsString(answer);\n        String encoding = context.getWiki().getEncoding();\n        response.setContentType(\"application/json\");\n        // Set the content length to the number of bytes, not the\n        // string length, so as to handle multi-byte encodings\n        response.setContentLength(jsonAnswerAsString.getBytes(encoding).length);\n        response.setStatus(status);\n        response.setCharacterEncoding(encoding);\n        response.getWriter().print(jsonAnswerAsString);\n        context.setResponseSent(true);\n    }\n\n    protected UserReference getCurrentUser()\n    {\n        return this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n    }\n\n    protected void copyApprovers(FileChange fileChange) throws ChangeRequestException\n    {\n        ChangeRequest changeRequest = fileChange.getChangeRequest();\n\n        // Existing approvers of the change request.\n        Set<UserReference> usersCRApprovers =\n            new LinkedHashSet<>(this.changeRequestApproversManager.getAllApprovers(changeRequest, false));\n        Set<DocumentReference> groupsCRApprovers =\n            new LinkedHashSet<>(this.changeRequestApproversManager.getGroupsApprovers(changeRequest));\n\n        usersCRApprovers.addAll(this.fileChangeApproversManager.getAllApprovers(fileChange, false));\n        groupsCRApprovers.addAll(this.fileChangeApproversManager.getGroupsApprovers(fileChange));\n\n        // If the authored are prevented to review, we ensure to remove it from the list of users approvers.\n        if (this.configuration.preventAuthorToReview()) {\n            usersCRApprovers.remove(fileChange.getAuthor());\n        }\n\n        if (!groupsCRApprovers.isEmpty()) {\n            this.changeRequestApproversManager.setGroupsApprovers(groupsCRApprovers, changeRequest);\n        }\n        if (!usersCRApprovers.isEmpty()) {\n            this.changeRequestApproversManager.setUsersApprovers(usersCRApprovers, changeRequest);\n        }\n    }\n\n    protected void reportError(int statusCode, String localizationKey, Object... parameters) throws IOException\n    {\n        this.answerJSON(statusCode, Collections.singletonMap(\"changeRequestError\",\n            this.contextualLocalizationManager.getTranslationPlain(localizationKey, parameters)));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest.script;\n\nimport java.util.List;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.contrib.changerequest.ChangeRequest;\nimport org.xwiki.contrib.changerequest.ChangeRequestException;\nimport org.xwiki.contrib.changerequest.ChangeRequestRightsManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.script.service.ScriptService;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\n\n/**\n * Script service dedicated to perform authorization check for change request.\n *\n * @version $Id$\n * @since 0.11\n */\n\n@Component\n@Named(\"changerequest.authorization\")\n@Singleton\n@Unstable\npublic class ChangeRequestAuthorizationScriptService implements ScriptService\n{\n    @Inject\n    private ChangeRequestRightsManager changeRequestRightsManager;\n\n    @Inject\n    private AuthorizationManager authorizationManager;\n\n    @Inject\n    private UserReferenceResolver<CurrentUserReference> currentUserReferenceResolver;\n\n    /**\n     * Check if the current user can edit the change request.\n     *\n     * @param changeRequest the change request for which to check the authors.\n     * @return {@code true} if the current user is one of the author of the given change request and the change request\n     *          is not merged or closed yet.\n     * @since 0.7\n     */\n    public boolean isAuthorizedToEdit(ChangeRequest changeRequest)\n    {\n        UserReference currentUser = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToEdit(currentUser, changeRequest);\n    }\n\n    /**\n     * Check if the current user can comment a change request.\n     * @param changeRequest the change request for which to check if it can be commented.\n     * @return {@code true} if the current user is authorized to comment the change request.\n     * @throws ChangeRequestException in case of problem to check the authorization.\n     * @see ChangeRequestRightsManager#isAuthorizedToComment(UserReference, ChangeRequest)\n     * @since 0.11\n     */\n    public boolean isAuthorizedToComment(ChangeRequest changeRequest) throws ChangeRequestException\n    {\n        UserReference currentUser = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToComment(currentUser, changeRequest);\n    }\n\n    /**\n     * Check if the current user is authorized to merge the given changed request.\n     *\n     * @param changeRequest the change request to be checked for merging authorization.\n     * @return {@code true} if the current user has proper rights to merge the given change request.\n     * @throws ChangeRequestException in case of problem when checking the role of the user.\n     * @since 0.3\n     */\n    @Unstable\n    public boolean isAuthorizedToMerge(ChangeRequest changeRequest) throws ChangeRequestException\n    {\n        UserReference currentUser = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToMerge(currentUser, changeRequest);\n    }\n\n    /**\n     * Check if the current user can edit the change request.\n     *\n     * @param changeRequest the change request for which to check the authors.\n     * @return {@code true} if the current user is one of the author of the given change request and the change request\n     *          is not merged yet.\n     * @since 0.9\n     */\n    public boolean isAuthorizedToOpen(ChangeRequest changeRequest)\n    {\n        UserReference currentUser = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToOpen(currentUser, changeRequest);\n    }\n\n    /**\n     * Check if the current user is authorized to review the given change request.\n     *\n     * @param changeRequest the change request about to be reviewed.\n     * @return {@code true} if the change request can be reviewed by current user.\n     * @throws ChangeRequestException in case of problem when checking if an user is an approver.\n     */\n    public boolean isAuthorizedToReview(ChangeRequest changeRequest) throws ChangeRequestException\n    {\n        UserReference currentUserReference = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToReview(currentUserReference, changeRequest);\n    }\n\n    /**\n     * Check if the current user is authorized to perform a review on behalf of the original approver, on the given\n     * change request.\n     * This should only returns {@code true} if the delegate approver mechanism is enabled, the original approver is an\n     * explicit approver and the current user is a delegate approver of them.\n     *\n     * @param changeRequest the change request for which to check the authorization\n     * @param originalApprover the user on behalf of whom the authorization might be given\n     * @return {@code true} if the delegate mechanism is enabled and the current user  is not an author, and is a\n     *         delegate of the original approver who is also an approver of the given change request.\n     * @throws ChangeRequestException in case of problem to resolve the delegate approvers.\n     * @since 0.13\n     */\n    @Unstable\n    public boolean isAuthorizedToReviewOnBehalf(ChangeRequest changeRequest, UserReference originalApprover)\n        throws ChangeRequestException\n    {\n        UserReference currentUserReference = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager\n            .isAuthorizedToReviewOnBehalf(currentUserReference, changeRequest, originalApprover);\n    }\n\n    /**\n     * Check if the current user is authorized to perform a review as a delegate of one of the approver of the given\n     * change request.\n     * This should only returns {@code true} if the delegate mechanism is enabled, the change request has explicit\n     * approvers, and  the current user is a delegate of at least one of them. Moreover, this cannot return {@code true}\n     * if the given user is an author of the change request.\n     *\n     * @param changeRequest the change request for which to check the authorization\n     * @return {@code true} if the delegate mechanism is enabled, the change request has explicit\n     *         approvers, the current user is not an author of the change request, and is a delegate of at least one of\n     *         the approvers.\n     * @throws ChangeRequestException in case of problem to resolve the delegate approvers.\n     * @since 0.13\n     */\n    public boolean isAuthorizedToReviewAsDelegate(ChangeRequest changeRequest)\n        throws ChangeRequestException\n    {\n        UserReference currentUserReference = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToReviewAsDelegate(currentUserReference, changeRequest);\n    }\n\n    /**\n     * Check if the given user is authorized to perform a review as a delegate of one of the approver of the given\n     * change request.\n     * This should only returns {@code true} if the delegate mechanism is enabled, the change request has explicit\n     * approvers, and  the current user is a delegate of at least one of them. Moreover, this cannot return {@code true}\n     * if the given user is an author of the change request.\n     *\n     * @param changeRequest the change request for which to check the authorization\n     * @param userReference the user for which to check if they can review\n     * @return {@code true} if the delegate mechanism is enabled, the change request has explicit\n     *         approvers, the user is not an author of the change request, and is a delegate of at least one of\n     *         the approvers.\n     * @throws ChangeRequestException in case of problem to resolve the delegate approvers.\n     * @since 0.14\n     */\n    public boolean isAuthorizedToReviewAsDelegate(ChangeRequest changeRequest, UserReference userReference)\n        throws ChangeRequestException\n    {\n        return this.changeRequestRightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest);\n    }\n\n    /**\n     * Check if the given user is authorized to review the given change request.\n     *\n     * @param changeRequest the change request about to be reviewed.\n     * @param userReference the user for which to check if they can review\n     * @return {@code true} if the change request can be reviewed by the given user.\n     * @throws ChangeRequestException in case of problem when checking if an user is an approver.\n     * @since 0.9\n     */\n    @Unstable\n    public boolean isAuthorizedToReview(ChangeRequest changeRequest, UserReference userReference)\n        throws ChangeRequestException\n    {\n        return this.changeRequestRightsManager.isAuthorizedToReview(userReference, changeRequest);\n    }\n\n    /**\n     * Check if the list of users have view rights to the concerned document: this is a necessary condition for users\n     * to be approvers.\n     *\n     * @param concernedDoc the doc for which to assign approvers\n     * @param userReferenceList the proposed approvers for which to test rights\n     * @return {@code true} if all proposed users have view rights to the concerned doc\n     * @since 1.1\n     */\n    @Unstable\n    public boolean haveApproversViewRights(DocumentReference concernedDoc, List<DocumentReference> userReferenceList)\n    {\n        boolean result = true;\n        if (userReferenceList != null) {\n            for (DocumentReference userDoc : userReferenceList) {\n                result &= this.authorizationManager.hasAccess(Right.VIEW, userDoc, concernedDoc);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Check if the current user is authorized to split the change request.\n     *\n     * @param changeRequest the change request to split\n     * @return {@code true} if the current user is authorized to perform a split\n     */\n    public boolean isAuthorizedToSplit(ChangeRequest changeRequest)\n    {\n        UserReference currentUserReference = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isAuthorizedToSplit(currentUserReference, changeRequest);\n    }\n\n    /**\n     * Check if the current user is allowed to use change request to edit the given document reference.\n     * @param documentReference the reference for which to check authorization\n     * @return {@code true} if current user is allowed to perform the edition with change request\n     * @throws ChangeRequestException in case of problem when performing the checks\n     * @since 1.10\n     */\n    public boolean isEditWithChangeRequestAllowed(DocumentReference documentReference) throws ChangeRequestException\n    {\n        UserReference currentUserReference = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isEditWithChangeRequestAllowed(currentUserReference, documentReference);\n    }\n\n    /**\n     * Check if the current user is allowed to use change request to create a document having the given reference for\n     * parent.\n     * @param parentSpaceReference the parent space where the new document would be created\n     * @return {@code true} if current user is allowed to create a document with change request at the given place\n     * @throws ChangeRequestException in case of problem when performing the checks\n     * @since 1.10\n     */\n    public boolean isCreateWithChangeRequestAllowed(DocumentReference parentSpaceReference)\n        throws ChangeRequestException\n    {\n        UserReference currentUserReference = this.currentUserReferenceResolver.resolve(CurrentUserReference.INSTANCE);\n        return this.changeRequestRightsManager.isCreateWithChangeRequestAllowed(currentUserReference,\n            parentSpaceReference);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest.internal;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport javax.inject.Inject;\nimport javax.inject.Provider;\n\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.contrib.changerequest.ApproversManager;\nimport org.xwiki.contrib.changerequest.ChangeRequest;\nimport org.xwiki.contrib.changerequest.ChangeRequestConfiguration;\nimport org.xwiki.contrib.changerequest.ChangeRequestException;\nimport org.xwiki.contrib.changerequest.ChangeRequestStatus;\nimport org.xwiki.contrib.changerequest.DelegateApproverManager;\nimport org.xwiki.contrib.changerequest.FileChange;\nimport org.xwiki.contrib.changerequest.internal.approvers.ChangeRequestApproversManager;\nimport org.xwiki.contrib.changerequest.rights.ChangeRequestRight;\nimport org.xwiki.contrib.rights.RightsReader;\nimport org.xwiki.contrib.rights.RightsWriter;\nimport org.xwiki.contrib.rights.SecurityRuleAbacus;\nimport org.xwiki.contrib.rights.SecurityRuleDiff;\nimport org.xwiki.contrib.rights.WritableSecurityRule;\nimport org.xwiki.contrib.rights.internal.WritableSecurityRuleImpl;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.security.authorization.AuthorizationException;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ReadableSecurityRule;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.security.authorization.RightSet;\nimport org.xwiki.security.authorization.RuleState;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.user.GuestUserReference;\nimport org.xwiki.user.UserReference;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PasswordClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoInteractions;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link DefaultChangeRequestRightsManager}.\n *\n * @version $Id$\n * @since 0.7\n */\n@ComponentTest\nclass DefaultChangeRequestRightsManagerTest\n{\n    @InjectMockComponents\n    private DefaultChangeRequestRightsManager rightsManager;\n\n    @MockComponent\n    private DocumentReferenceResolver<ChangeRequest> changeRequestDocumentReferenceResolver;\n\n    @MockComponent\n    private AuthorizationManager authorizationManager;\n\n    @MockComponent\n    private RightsWriter rightsWriter;\n\n    @MockComponent\n    private SecurityRuleAbacus ruleAbacus;\n\n    @MockComponent\n    private RightsReader rightsReader;\n\n    @MockComponent\n    private UserReferenceConverter userReferenceConverter;\n\n    @MockComponent\n    private ChangeRequestConfiguration configuration;\n\n    @MockComponent\n    private ApproversManager<ChangeRequest> changeRequestApproversManager;\n\n    @MockComponent\n    private DelegateApproverManager<ChangeRequest> changeRequestDelegateApproverManager;\n\n    @MockComponent\n    private Provider<XWikiContext> contextProvider;\n\n    @Test\n    void copyAllButViewRights() throws AuthorizationException, ChangeRequestException, XWikiException\n    {\n        ChangeRequest sourceChangeRequest = mock(ChangeRequest.class);\n        ChangeRequest targetChangeRequest = mock(ChangeRequest.class);\n\n        DocumentReference sourceDocReference = mock(DocumentReference.class);\n        DocumentReference targetDocReference = mock(DocumentReference.class);\n\n        when(this.changeRequestDocumentReferenceResolver.resolve(sourceChangeRequest)).thenReturn(sourceDocReference);\n        when(this.changeRequestDocumentReferenceResolver.resolve(targetChangeRequest)).thenReturn(targetDocReference);\n\n        SpaceReference sourceSpaceReference = mock(SpaceReference.class);\n        when(sourceDocReference.getLastSpaceReference()).thenReturn(sourceSpaceReference);\n\n        SpaceReference targetSpaceReference = mock(SpaceReference.class);\n        when(targetDocReference.getLastSpaceReference()).thenReturn(targetSpaceReference);\n\n        ReadableSecurityRule rule1 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule rule2 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule rule3 = mock(ReadableSecurityRule.class);\n\n        when(this.rightsReader.getRules(sourceSpaceReference, false))\n            .thenReturn(Arrays.asList(rule1, rule2, rule3));\n\n        when(rule1.match(Right.VIEW)).thenReturn(true);\n        when(rule2.match(Right.VIEW)).thenReturn(false);\n        when(rule3.match(Right.VIEW)).thenReturn(true);\n\n        WritableSecurityRule rule1bis = mock(WritableSecurityRule.class);\n        WritableSecurityRule rule3bis = mock(WritableSecurityRule.class);\n\n        when(this.rightsWriter.createRule(rule1)).thenReturn(rule1bis);\n        when(this.rightsWriter.createRule(rule3)).thenReturn(rule3bis);\n\n        when(rule1bis.getRights()).thenReturn(new RightSet(Right.VIEW));\n        when(rule3bis.getRights()).thenReturn(new RightSet(Right.VIEW, Right.EDIT));\n\n        this.rightsManager.copyAllButViewRights(sourceChangeRequest, targetChangeRequest);\n        verify(rule3bis).setRights(new RightSet(Right.EDIT));\n        verify(this.rightsWriter).saveRules(Arrays.asList(rule2, rule3bis), targetSpaceReference);\n    }\n\n    @Test\n    void isViewAccessConsistent() throws AuthorizationException, ChangeRequestException\n    {\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n        DocumentReference newChangeReference = mock(DocumentReference.class);\n\n        DocumentReference docRef1 = mock(DocumentReference.class);\n        DocumentReference docRef2 = mock(DocumentReference.class);\n\n        when(changeRequest.getModifiedDocuments()).thenReturn(Stream.of(docRef1, docRef2).collect(Collectors.toSet()));\n\n        List<ReadableSecurityRule> rulesDoc1 = mock(List.class);\n        List<ReadableSecurityRule> rulesDoc2 = mock(List.class);\n        List<ReadableSecurityRule> rulesNewChange = mock(List.class);\n\n        when(this.rightsReader.getActualRules(docRef1)).thenReturn(rulesDoc1);\n        ReadableSecurityRule doc1rule1 = mock(ReadableSecurityRule.class);\n        when(doc1rule1.match(Right.VIEW)).thenReturn(false);\n\n        when(this.ruleAbacus.normalizeRulesBySubject(rulesDoc1)).thenReturn(Collections.singletonList(doc1rule1));\n\n        when(this.rightsReader.getActualRules(docRef2)).thenReturn(rulesDoc2);\n        ReadableSecurityRule doc2rule1 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule doc2rule2 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule doc2rule3 = mock(ReadableSecurityRule.class);\n\n        when(doc2rule1.match(Right.VIEW)).thenReturn(true);\n        when(doc2rule2.match(Right.VIEW)).thenReturn(false);\n        when(doc2rule3.match(Right.VIEW)).thenReturn(true);\n\n        DocumentReference groupARef = mock(DocumentReference.class);\n        DocumentReference groupBRef = mock(DocumentReference.class);\n        when(doc2rule1.getGroups()).thenReturn(Arrays.asList(groupARef, groupBRef));\n\n        DocumentReference userFooRef = mock(DocumentReference.class);\n        when(doc2rule3.getUsers()).thenReturn(Collections.singletonList(userFooRef));\n\n        when(this.ruleAbacus.normalizeRulesBySubject(rulesDoc2))\n            .thenReturn(Arrays.asList(doc2rule1, doc2rule2, doc2rule3));\n\n        when(this.rightsReader.getActualRules(newChangeReference)).thenReturn(rulesNewChange);\n\n        ReadableSecurityRule newChangeRule1 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule newChangeRule2 = mock(ReadableSecurityRule.class);\n\n        when(newChangeRule1.match(Right.VIEW)).thenReturn(true);\n        when(newChangeRule2.match(Right.VIEW)).thenReturn(true);\n\n        DocumentReference userBarRef = mock(DocumentReference.class);\n        when(newChangeRule1.getUsers()).thenReturn(Arrays.asList(userFooRef, userBarRef));\n        when(newChangeRule2.getGroups()).thenReturn(Collections.singletonList(groupBRef));\n\n        when(this.ruleAbacus.normalizeRulesBySubject(rulesNewChange))\n            .thenReturn(Arrays.asList(newChangeRule1, newChangeRule2));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, groupARef, docRef1)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, groupARef, docRef2)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, groupARef, newChangeReference)).thenReturn(true);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, groupBRef, docRef1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, groupBRef, docRef2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, groupBRef, newChangeReference)).thenReturn(false);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, userFooRef, docRef1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, userFooRef, docRef2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, userFooRef, newChangeReference)).thenReturn(false);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, userBarRef, docRef1)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, userBarRef, docRef2)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, userBarRef, newChangeReference)).thenReturn(true);\n\n        assertTrue(this.rightsManager.isViewAccessConsistent(changeRequest, newChangeReference));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, userBarRef, docRef2)).thenReturn(false);\n\n        assertFalse(this.rightsManager.isViewAccessConsistent(changeRequest, newChangeReference));\n    }\n\n    @Test\n    void isViewAccessStillConsistent() throws ChangeRequestException\n    {\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        DocumentReference doc1 = mock(DocumentReference.class);\n        DocumentReference doc2 = mock(DocumentReference.class);\n        DocumentReference doc3 = mock(DocumentReference.class);\n\n        when(changeRequest.getModifiedDocuments()).thenReturn(Stream.of(doc1, doc2, doc3).collect(Collectors.toSet()));\n\n        DocumentReference user1 = mock(DocumentReference.class);\n        DocumentReference user2 = mock(DocumentReference.class);\n        DocumentReference user3 = mock(DocumentReference.class);\n        Set<DocumentReference> userSet = Stream.of(user1, user2, user3).collect(Collectors.toSet());\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc1)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc2)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc3)).thenReturn(true);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc1)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc2)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc3)).thenReturn(true);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc1)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc2)).thenReturn(true);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc3)).thenReturn(true);\n\n        assertTrue(this.rightsManager.isViewAccessStillConsistent(changeRequest, userSet));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc1)).thenReturn(false);\n        assertFalse(this.rightsManager.isViewAccessStillConsistent(changeRequest, userSet));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc3)).thenReturn(false);\n        assertTrue(this.rightsManager.isViewAccessStillConsistent(changeRequest, userSet));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc2)).thenReturn(false);\n        assertFalse(this.rightsManager.isViewAccessStillConsistent(changeRequest, userSet));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user1, doc3)).thenReturn(false);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user2, doc3)).thenReturn(false);\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc2)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc3)).thenReturn(false);\n\n        assertTrue(this.rightsManager.isViewAccessStillConsistent(changeRequest, userSet));\n\n        when(this.authorizationManager.hasAccess(Right.VIEW, user3, doc3)).thenReturn(true);\n        assertFalse(this.rightsManager.isViewAccessStillConsistent(changeRequest, userSet));\n    }\n\n    @Test\n    void copyViewRights() throws AuthorizationException, ChangeRequestException, XWikiException\n    {\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n        DocumentReference changeRequestDocReference = mock(DocumentReference.class);\n        SpaceReference changeRequestSpaceReference = mock(SpaceReference.class);\n\n        DocumentReference newChange = mock(DocumentReference.class);\n        WikiReference wikiReference = new WikiReference(\"foo\");\n        when(newChange.getWikiReference()).thenReturn(wikiReference);\n\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDocReference);\n        when(changeRequestDocReference.getLastSpaceReference()).thenReturn(changeRequestSpaceReference);\n\n        WritableSecurityRule crRule1 = mock(WritableSecurityRule.class);\n        WritableSecurityRule crRule2 = mock(WritableSecurityRule.class);\n        WritableSecurityRule crRule3 = mock(WritableSecurityRule.class);\n\n        List<ReadableSecurityRule> crRules = mock(List.class);\n        when(this.rightsReader.getRules(changeRequestSpaceReference, false))\n            .thenReturn(crRules);\n        when(this.rightsWriter.createRules(crRules)).thenReturn(Arrays.asList(crRule1, crRule2, crRule3));\n\n        ReadableSecurityRule newChangeRule1 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule newChangeRule2 = mock(ReadableSecurityRule.class);\n        ReadableSecurityRule newChangeRule3 = mock(ReadableSecurityRule.class);\n\n        when(this.rightsReader.getActualRules(newChange))\n            .thenReturn(Arrays.asList(newChangeRule1, newChangeRule2, newChangeRule3));\n\n        ReadableSecurityRule wikiRule1 = mock(ReadableSecurityRule.class);\n        when(this.rightsReader.getActualRules(wikiReference)).thenReturn(Arrays.asList(wikiRule1, newChangeRule2));\n\n        when(newChangeRule1.match(Right.VIEW)).thenReturn(false);\n        when(newChangeRule3.match(Right.VIEW)).thenReturn(true);\n\n        WritableSecurityRule rule3bis = mock(WritableSecurityRule.class);\n        when(this.rightsWriter.createRule(newChangeRule3)).thenReturn(rule3bis);\n\n        this.rightsManager.copyViewRights(changeRequest, newChange);\n        verify(rule3bis).setRights(Collections.singletonList(Right.VIEW));\n        verify(this.rightsWriter).saveRules(Arrays.asList(crRule1, crRule2, crRule3, rule3bis),\n            changeRequestSpaceReference);\n    }\n\n    @Test\n    void applyChanges() throws AuthorizationException, ChangeRequestException, XWikiException\n    {\n        // Scenario:\n        // Change request containing following rights:\n        //   - Allow view,edit,script on XWiki.AdminGroup\n        //   - Deny view,edit on XWiki.Foo\n        //   - Deny edit on XWiki.Bar\n        //   - Allow view on XWiki.AllGroup\n        //\n        // Diff contains following changes:\n        //   - Update to remove allow view on XWiki.AdminGroup\n        //   - Update Deny view on XWiki.Foo (2 rules: one to remove Deny view, one to add Allow view)\n        //   - Update deny edit to allow edit on XWiki.bar (2 rules: one to remove Deny edit, one to add Allow edit)\n        //   - Add allow view on XWiki.Buz\n        //   - Remove Allow view on XWiki.AllGroup\n        //\n        // Expected rights after applying:\n        //   - Allow edit,script on XWiki.AdminGroup\n        //   - Deny edit on XWiki.Foo\n        //   - Allow view on XWiki.Foo\n        //   - Deny edit on XWiki.Bar\n        //   - Allow view on XWiki.Buz\n\n        DocumentReference adminGroupRef = new DocumentReference(\"xwiki\", \"XWiki\", \"AdminGroup\");\n        DocumentReference allGroupRef = new DocumentReference(\"xwiki\", \"XWiki\", \"AllGroup\");\n\n        DocumentReference fooUserRef = new DocumentReference(\"xwiki\", \"XWiki\", \"Foo\");\n        DocumentReference barUserRef = new DocumentReference(\"xwiki\", \"XWiki\", \"Bar\");\n        DocumentReference buzUserRef = new DocumentReference(\"xwiki\", \"XWiki\", \"Buz\");\n\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        // diff1: Update to remove allow view on XWiki.AdminGroup\n        SecurityRuleDiff diff1 = mock(SecurityRuleDiff.class);\n\n        when(diff1.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_UPDATED);\n        ReadableSecurityRule previousRule = mock(ReadableSecurityRule.class);\n        when(diff1.getPreviousRule()).thenReturn(previousRule);\n        when(previousRule.getGroups()).thenReturn(Collections.singletonList(adminGroupRef));\n        when(previousRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW, Right.EDIT, Right.SCRIPT)));\n        when(previousRule.getState()).thenReturn(RuleState.ALLOW);\n        when(previousRule.match(Right.VIEW)).thenReturn(true);\n\n        ReadableSecurityRule currentRule = mock(ReadableSecurityRule.class);\n        when(diff1.getCurrentRule()).thenReturn(currentRule);\n        when(currentRule.getGroups()).thenReturn(Collections.singletonList(adminGroupRef));\n        when(currentRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.EDIT, Right.SCRIPT)));\n        when(currentRule.getState()).thenReturn(RuleState.ALLOW);\n        when(currentRule.match(Right.VIEW)).thenReturn(false);\n\n        // diff2: Update Deny view on XWiki.Foo (2 rules: one to remove Deny view, one to add Allow view)\n        SecurityRuleDiff diff2_1 = mock(SecurityRuleDiff.class);\n\n        when(diff2_1.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_UPDATED);\n        previousRule = mock(ReadableSecurityRule.class);\n        when(diff2_1.getPreviousRule()).thenReturn(previousRule);\n        when(previousRule.getUsers()).thenReturn(Collections.singletonList(fooUserRef));\n        when(previousRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW, Right.EDIT)));\n        when(previousRule.getState()).thenReturn(RuleState.DENY);\n        when(previousRule.match(Right.VIEW)).thenReturn(true);\n\n        currentRule = mock(ReadableSecurityRule.class);\n        when(diff2_1.getCurrentRule()).thenReturn(currentRule);\n        when(currentRule.getUsers()).thenReturn(Collections.singletonList(fooUserRef));\n        when(currentRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.EDIT)));\n        when(currentRule.getState()).thenReturn(RuleState.DENY);\n        when(currentRule.match(Right.VIEW)).thenReturn(false);\n\n        SecurityRuleDiff diff2_2 = mock(SecurityRuleDiff.class);\n\n        when(diff2_2.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_ADDED);\n        currentRule = mock(ReadableSecurityRule.class);\n        when(diff2_2.getCurrentRule()).thenReturn(currentRule);\n        when(currentRule.getUsers()).thenReturn(Collections.singletonList(fooUserRef));\n        when(currentRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW)));\n        when(currentRule.getState()).thenReturn(RuleState.ALLOW);\n        when(currentRule.match(Right.VIEW)).thenReturn(true);\n\n        // diff3: Update deny edit to allow edit on XWiki.bar (2 rules: one to remove Deny edit, one to add Allow edit)\n\n        SecurityRuleDiff diff3_1 = mock(SecurityRuleDiff.class);\n\n        when(diff3_1.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_DELETED);\n        previousRule = mock(ReadableSecurityRule.class);\n        when(diff3_1.getPreviousRule()).thenReturn(previousRule);\n        when(previousRule.getUsers()).thenReturn(Collections.singletonList(barUserRef));\n        when(previousRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.EDIT)));\n        when(previousRule.getState()).thenReturn(RuleState.DENY);\n        when(previousRule.match(Right.VIEW)).thenReturn(false);\n\n        SecurityRuleDiff diff3_2 = mock(SecurityRuleDiff.class);\n\n        when(diff3_2.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_ADDED);\n        currentRule = mock(ReadableSecurityRule.class);\n        when(diff3_2.getCurrentRule()).thenReturn(currentRule);\n        when(currentRule.getUsers()).thenReturn(Collections.singletonList(barUserRef));\n        when(currentRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.EDIT)));\n        when(currentRule.getState()).thenReturn(RuleState.ALLOW);\n        when(currentRule.match(Right.VIEW)).thenReturn(false);\n\n        // diff4: Add allow view on XWiki.Buz\n\n        SecurityRuleDiff diff4 = mock(SecurityRuleDiff.class);\n\n        when(diff4.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_ADDED);\n        currentRule = mock(ReadableSecurityRule.class);\n        when(diff4.getCurrentRule()).thenReturn(currentRule);\n        when(currentRule.getUsers()).thenReturn(Collections.singletonList(buzUserRef));\n        when(currentRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW)));\n        when(currentRule.getState()).thenReturn(RuleState.ALLOW);\n        when(currentRule.match(Right.VIEW)).thenReturn(true);\n\n        // diff5: Remove Allow view on XWiki.AllGroup\n        SecurityRuleDiff diff5 = mock(SecurityRuleDiff.class);\n\n        when(diff5.getChangeType()).thenReturn(SecurityRuleDiff.ChangeType.RULE_DELETED);\n        previousRule = mock(ReadableSecurityRule.class);\n        when(diff5.getPreviousRule()).thenReturn(previousRule);\n        when(previousRule.getGroups()).thenReturn(Collections.singletonList(allGroupRef));\n        when(previousRule.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW)));\n        when(previousRule.getState()).thenReturn(RuleState.ALLOW);\n        when(previousRule.match(Right.VIEW)).thenReturn(true);\n\n        DocumentReference changeRequestDocRef = mock(DocumentReference.class);\n        SpaceReference changeRequestSpaceRef = mock(SpaceReference.class);\n        when(changeRequestDocRef.getLastSpaceReference()).thenReturn(changeRequestSpaceRef);\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDocRef);\n\n        List rules = mock(List.class);\n        when(this.rightsReader.getRules(changeRequestSpaceRef, false)).thenReturn(rules);\n\n        List<ReadableSecurityRule> normalizedRules = new ArrayList<>();\n\n        // rule1: Allow view,edit,script on XWiki.AdminGroup\n        ReadableSecurityRule rule1 = mock(ReadableSecurityRule.class);\n        when(rule1.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW, Right.EDIT, Right.SCRIPT)));\n        when(rule1.getState()).thenReturn(RuleState.ALLOW);\n        when(rule1.getGroups()).thenReturn(Arrays.asList(adminGroupRef));\n        normalizedRules.add(rule1);\n\n        // rule2: Deny view,edit on XWiki.Foo\n        ReadableSecurityRule rule2 = mock(ReadableSecurityRule.class);\n        when(rule2.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW, Right.EDIT)));\n        when(rule2.getState()).thenReturn(RuleState.DENY);\n        when(rule2.getUsers()).thenReturn(Arrays.asList(fooUserRef));\n        normalizedRules.add(rule2);\n\n        // rule3: Deny edit on XWiki.Bar\n        ReadableSecurityRule rule3 = mock(ReadableSecurityRule.class);\n        when(rule3.getRights()).thenReturn(new RightSet(Arrays.asList(Right.EDIT)));\n        when(rule3.getState()).thenReturn(RuleState.DENY);\n        when(rule3.getUsers()).thenReturn(Arrays.asList(barUserRef));\n        normalizedRules.add(rule3);\n\n        // rule4: Allow view on XWiki.AllGroup\n        ReadableSecurityRule rule4 = mock(ReadableSecurityRule.class);\n        when(rule4.getRights()).thenReturn(new RightSet(Arrays.asList(Right.VIEW)));\n        when(rule4.getState()).thenReturn(RuleState.ALLOW);\n        when(rule4.getGroups()).thenReturn(Arrays.asList(allGroupRef));\n        normalizedRules.add(rule4);\n\n        when(this.ruleAbacus.normalizeRulesBySubject(rules)).thenReturn(normalizedRules);\n        when(this.rightsWriter.createRule(any())).thenAnswer(invocationOnMock -> {\n            ReadableSecurityRule readableSecurityRule = invocationOnMock.getArgument(0);\n            return new WritableSecurityRuleImpl(\n                readableSecurityRule.getGroups(),\n                readableSecurityRule.getUsers(),\n                readableSecurityRule.getRights(),\n                readableSecurityRule.getState());\n        });\n        when(this.rightsWriter.createRule()).thenAnswer(invocationOnMock -> new WritableSecurityRuleImpl());\n\n        // expected1: Allow edit,script on XWiki.AdminGroup\n        WritableSecurityRule expected1 = new WritableSecurityRuleImpl(\n            Collections.singletonList(adminGroupRef),\n            Collections.emptyList(),\n            new RightSet(Arrays.asList(Right.EDIT, Right.SCRIPT)),\n            RuleState.ALLOW\n        );\n\n        // expected2: Deny edit on XWiki.Foo\n        WritableSecurityRule expected2 = new WritableSecurityRuleImpl(\n            Collections.emptyList(),\n            Collections.singletonList(fooUserRef),\n            new RightSet(Arrays.asList(Right.EDIT)),\n            RuleState.DENY\n        );\n\n        // expected3: Allow view on XWiki.Foo\n        WritableSecurityRule expected3 = new WritableSecurityRuleImpl(\n            Collections.emptyList(),\n            Collections.singletonList(fooUserRef),\n            new RightSet(Arrays.asList(Right.VIEW)),\n            RuleState.ALLOW\n        );\n\n        // expected4: Deny edit on XWiki.Bar\n        // this one should not be created but that should be still rule3\n\n        // expected5: Allow view on XWiki.Buz\n        WritableSecurityRule expected5 = new WritableSecurityRuleImpl(\n            Collections.emptyList(),\n            Collections.singletonList(buzUserRef),\n            new RightSet(Arrays.asList(Right.VIEW)),\n            RuleState.ALLOW\n        );\n\n        doAnswer(invocationOnMock -> {\n            List<ReadableSecurityRule> updatedRules = invocationOnMock.getArgument(0);\n            assertTrue(updatedRules.contains(expected1),\n                String.format(\"rule [%s] seems missing from [%s]\", expected1, updatedRules));\n            assertTrue(updatedRules.contains(expected2),\n                String.format(\"rule [%s] seems missing from [%s]\", expected2, updatedRules));\n            assertTrue(updatedRules.contains(expected3),\n                String.format(\"rule [%s] seems missing from [%s]\", expected3, updatedRules));\n            assertTrue(updatedRules.contains(rule3),\n                String.format(\"rule [%s] seems missing from [%s]\", rule3, updatedRules));\n            assertTrue(updatedRules.contains(expected5),\n                String.format(\"rule [%s] seems missing from [%s]\", expected5, updatedRules));\n            return null;\n        }).when(this.rightsWriter).saveRules(any(), eq(changeRequestSpaceRef));\n        this.rightsManager.applyChanges(changeRequest, Arrays.asList(\n            diff1,\n            diff2_1, diff2_2,\n            diff3_1, diff3_2,\n            diff4,\n            diff5));\n        verify(this.rightsWriter).saveRules(any(), eq(changeRequestSpaceRef));\n    }\n\n    @Test\n    void isAuthorizedToMergeWithoutMergeUser() throws ChangeRequestException\n    {\n        UserReference userReference = mock(UserReference.class);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        DocumentReference userDocReference = mock(DocumentReference.class);\n        when(this.userReferenceConverter.convert(userReference)).thenReturn(userDocReference);\n        when(this.configuration.getMergeUser()).thenReturn(GuestUserReference.INSTANCE);\n\n        FileChange fileChange1 = mock(FileChange.class);\n        FileChange fileChange2 = mock(FileChange.class);\n        when(fileChange1.getType()).thenReturn(FileChange.FileChangeType.EDITION);\n        when(fileChange2.getType()).thenReturn(FileChange.FileChangeType.DELETION);\n\n        DocumentReference reference1 = mock(DocumentReference.class);\n        DocumentReference reference2 = mock(DocumentReference.class);\n        when(fileChange1.getTargetEntity()).thenReturn(reference1);\n        when(fileChange2.getTargetEntity()).thenReturn(reference2);\n\n        when(changeRequest.getLastFileChanges()).thenReturn(Arrays.asList(fileChange1, fileChange2));\n\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.EDIT, userDocReference, reference1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.DELETE, userDocReference, reference2)).thenReturn(false);\n\n        assertFalse(this.rightsManager.isAuthorizedToMerge(userReference, changeRequest));\n\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToMerge(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.EDIT, userDocReference, reference1)).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToMerge(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.EDIT, userDocReference, reference2)).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToMerge(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.DELETE, userDocReference, reference2)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToMerge(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.EDIT, userDocReference, reference2)).thenReturn(false);\n        assertTrue(this.rightsManager.isAuthorizedToMerge(userReference, changeRequest));\n    }\n\n    @Test\n    void isAuthorizedToMergeWithMergeUser() throws ChangeRequestException\n    {\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        UserReference currentUserReference = mock(UserReference.class);\n        DocumentReference currentUserDocReference = mock(DocumentReference.class);\n        when(this.userReferenceConverter.convert(currentUserReference)).thenReturn(currentUserDocReference);\n\n        UserReference mergeUserReference = mock(UserReference.class);\n        DocumentReference mergeUserDocReference = mock(DocumentReference.class);\n        when(this.userReferenceConverter.convert(mergeUserReference)).thenReturn(mergeUserDocReference);\n        when(this.configuration.getMergeUser()).thenReturn(mergeUserReference);\n\n        FileChange fileChange1 = mock(FileChange.class);\n        FileChange fileChange2 = mock(FileChange.class);\n        when(fileChange1.getType()).thenReturn(FileChange.FileChangeType.EDITION);\n        when(fileChange2.getType()).thenReturn(FileChange.FileChangeType.DELETION);\n\n        DocumentReference reference1 = mock(DocumentReference.class);\n        DocumentReference reference2 = mock(DocumentReference.class);\n        when(fileChange1.getTargetEntity()).thenReturn(reference1);\n        when(fileChange2.getTargetEntity()).thenReturn(reference2);\n\n        when(changeRequest.getLastFileChanges()).thenReturn(Arrays.asList(fileChange1, fileChange2));\n\n        when(this.changeRequestApproversManager.isApprover(currentUserReference, changeRequest, false))\n            .thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.EDIT, mergeUserDocReference, reference1)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.DELETE, mergeUserDocReference, reference2)).thenReturn(false);\n\n        assertFalse(this.rightsManager.isAuthorizedToMerge(currentUserReference, changeRequest));\n\n        when(this.changeRequestApproversManager.isApprover(currentUserReference, changeRequest, false))\n            .thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToMerge(currentUserReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.EDIT, mergeUserDocReference, reference1)).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToMerge(currentUserReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.EDIT, mergeUserDocReference, reference2)).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToMerge(currentUserReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.DELETE, mergeUserDocReference, reference2)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToMerge(currentUserReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.EDIT, mergeUserDocReference, reference2)).thenReturn(false);\n        assertTrue(this.rightsManager.isAuthorizedToMerge(currentUserReference, changeRequest));\n\n        verify(this.authorizationManager, never())\n            .hasAccess(eq(Right.EDIT), eq(currentUserDocReference), any(DocumentReference.class));\n    }\n\n    @Test\n    void isAuthorizedToEdit()\n    {\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n        UserReference userReference = mock(UserReference.class);\n\n        when(changeRequest.getStatus()).thenReturn(ChangeRequestStatus.MERGED);\n        when(changeRequest.getAuthors())\n            .thenReturn(new HashSet<>(Arrays.asList(userReference, mock(UserReference.class))));\n        assertFalse(this.rightsManager.isAuthorizedToEdit(userReference, changeRequest));\n\n        when(changeRequest.getStatus()).thenReturn(ChangeRequestStatus.DRAFT);\n        assertTrue(this.rightsManager.isAuthorizedToEdit(userReference, changeRequest));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(mock(UserReference.class)));\n        assertFalse(this.rightsManager.isAuthorizedToEdit(userReference, changeRequest));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(GuestUserReference.INSTANCE));\n        assertTrue(this.rightsManager.isAuthorizedToEdit(userReference, changeRequest));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(mock(UserReference.class)));\n        DocumentReference userDocReference = mock(DocumentReference.class);\n        DocumentReference changeRequestDoc = mock(DocumentReference.class);\n\n        when(this.userReferenceConverter.convert(userReference)).thenReturn(userDocReference);\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDoc);\n        when(this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToEdit(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToEdit(userReference, changeRequest));\n    }\n\n    @Test\n    void isAuthorizedToOpen()\n    {\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n        UserReference userReference = mock(UserReference.class);\n\n        when(changeRequest.getStatus()).thenReturn(ChangeRequestStatus.MERGED);\n        when(changeRequest.getAuthors())\n            .thenReturn(new HashSet<>(Arrays.asList(userReference, mock(UserReference.class))));\n        assertFalse(this.rightsManager.isAuthorizedToOpen(userReference, changeRequest));\n\n        when(changeRequest.getStatus()).thenReturn(ChangeRequestStatus.CLOSED);\n        assertTrue(this.rightsManager.isAuthorizedToOpen(userReference, changeRequest));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(mock(UserReference.class)));\n        DocumentReference userDocReference = mock(DocumentReference.class);\n        DocumentReference changeRequestDoc = mock(DocumentReference.class);\n\n        when(this.userReferenceConverter.convert(userReference)).thenReturn(userDocReference);\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDoc);\n        when(this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToOpen(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToOpen(userReference, changeRequest));\n    }\n\n    @Test\n    void isAuthorizedToReview() throws ChangeRequestException\n    {\n        UserReference userReference = mock(UserReference.class);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        when(changeRequest.getAuthors()).thenReturn(new HashSet<>(List.of(userReference, mock(UserReference.class))));\n        when(configuration.preventAuthorToReview()).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n        verifyNoInteractions(this.changeRequestApproversManager);\n\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(mock(UserReference.class)));\n        when(configuration.preventAuthorToReview()).thenReturn(true);\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReview(userReference, changeRequest));\n    }\n\n    @Test\n    void isAuthorizedToReviewOnBehalf() throws ChangeRequestException\n    {\n        UserReference userReference = mock(UserReference.class);\n        UserReference originalApprover = mock(UserReference.class);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        when(changeRequest.getAuthors()).thenReturn(new HashSet<>(List.of(userReference, mock(UserReference.class))));\n        when(configuration.preventAuthorToReview()).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n        verifyNoInteractions(this.changeRequestDelegateApproverManager);\n\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest, originalApprover)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest, originalApprover)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(mock(UserReference.class)));\n        when(configuration.preventAuthorToReview()).thenReturn(true);\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest, originalApprover)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest, originalApprover)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest, originalApprover)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest, originalApprover)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReviewOnBehalf(userReference, changeRequest, originalApprover));\n    }\n\n    @Test\n    void isAuthorizedToReviewAsDelegate() throws ChangeRequestException\n    {\n        UserReference userReference = mock(UserReference.class);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        when(changeRequest.getAuthors()).thenReturn(new HashSet<>(List.of(userReference, mock(UserReference.class))));\n        when(configuration.preventAuthorToReview()).thenReturn(true);\n        assertFalse(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n        verifyNoInteractions(this.changeRequestDelegateApproverManager);\n\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n\n        when(changeRequest.getAuthors()).thenReturn(Collections.singleton(mock(UserReference.class)));\n        when(configuration.preventAuthorToReview()).thenReturn(true);\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n\n        when(this.changeRequestDelegateApproverManager\n            .isDelegateApproverOf(userReference, changeRequest)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToReviewAsDelegate(userReference, changeRequest));\n    }\n\n    @Test\n    void isAuthorizedToComment() throws ChangeRequestException\n    {\n        UserReference userReference = mock(UserReference.class);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n\n        DocumentReference userDocReference = mock(DocumentReference.class);\n        DocumentReference changeRequestDoc = mock(DocumentReference.class);\n        when(this.userReferenceConverter.convert(userReference)).thenReturn(userDocReference);\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDoc);\n        when(this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToComment(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, changeRequestDoc)).thenReturn(false);\n        when(this.authorizationManager.hasAccess(Right.COMMENT, userDocReference, changeRequestDoc)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToComment(userReference, changeRequest));\n\n        when(this.authorizationManager.hasAccess(Right.COMMENT, userDocReference, changeRequestDoc)).thenReturn(false);\n        when(configuration.preventAuthorToReview()).thenReturn(false);\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(true);\n        assertTrue(this.rightsManager.isAuthorizedToComment(userReference, changeRequest));\n\n        when(this.changeRequestApproversManager.isApprover(userReference, changeRequest, false)).thenReturn(false);\n        assertFalse(this.rightsManager.isAuthorizedToComment(userReference, changeRequest));\n    }\n\n    @Test\n    void isCreateWithChangeRequestAllowed() throws ChangeRequestException\n    {\n        Right crRight = ChangeRequestRight.getRight();\n        UserReference userReference = mock(UserReference.class);\n        DocumentReference userDocReference = mock(DocumentReference.class);\n        DocumentReference parentSpaceReference = mock(DocumentReference.class);\n\n        when(this.userReferenceConverter.convert(userReference)).thenReturn(userDocReference);\n        when(this.authorizationManager.hasAccess(crRight, userDocReference, parentSpaceReference)).thenReturn(true);\n        assertTrue(this.rightsManager.isCreateWithChangeRequestAllowed(userReference, parentSpaceReference));\n\n        verify(this.authorizationManager).hasAccess(crRight, userDocReference, parentSpaceReference);\n    }\n\n    @Test\n    void isEditWithChangeRequestAllowed() throws ChangeRequestException, XWikiException\n    {\n        Right crRight = ChangeRequestRight.getRight();\n        UserReference userReference = mock(UserReference.class);\n        DocumentReference userDocReference = mock(DocumentReference.class);\n        DocumentReference documentReference = mock(DocumentReference.class);\n        XWikiDocument document = mock(XWikiDocument.class);\n        XWiki wiki = mock(XWiki.class);\n        XWikiContext context = mock(XWikiContext.class);\n\n        when(this.userReferenceConverter.convert(userReference)).thenReturn(userDocReference);\n        when(this.contextProvider.get()).thenReturn(context);\n        when(context.getWiki()).thenReturn(wiki);\n        when(wiki.getDocument(documentReference, context)).thenReturn(document);\n        when(this.authorizationManager.hasAccess(crRight, userDocReference, documentReference)).thenReturn(false);\n\n        assertFalse(this.rightsManager.isEditWithChangeRequestAllowed(userReference, documentReference));\n\n        verify(this.authorizationManager).hasAccess(crRight, userDocReference, documentReference);\n        verifyNoInteractions(document);\n\n        when(this.authorizationManager.hasAccess(crRight, userDocReference, documentReference)).thenReturn(true);\n        when(document.isNew()).thenReturn(true);\n        assertTrue(this.rightsManager.isEditWithChangeRequestAllowed(userReference, documentReference));\n\n        verify(this.authorizationManager, times(2)).hasAccess(crRight, userDocReference, documentReference);\n\n        when(document.isNew()).thenReturn(false);\n\n        DocumentReference objReference1 = mock(DocumentReference.class);\n        DocumentReference objReference2 = mock(DocumentReference.class);\n\n        BaseObject baseObject1 = mock(BaseObject.class);\n        BaseObject baseObject2 = mock(BaseObject.class);\n        BaseObject baseObject3 = mock(BaseObject.class);\n\n        List<BaseObject> baseObjectList1 = Arrays.asList(null, baseObject1);\n        List<BaseObject> baseObjectList2 = Arrays.asList(null, baseObject2, baseObject3);\n\n        Map<DocumentReference, List<BaseObject>> objectMap = new LinkedHashMap<>();\n        objectMap.put(objReference1, baseObjectList1);\n        objectMap.put(objReference2, baseObjectList2);\n\n        when(document.getXObjects()).thenReturn(objectMap);\n        BaseClass class1 = mock(BaseClass.class);\n        List<PropertyClass> propertyClasses = List.of(mock(PropertyClass.class), mock(PropertyClass.class),\n            mock(PasswordClass.class));\n        when(class1.getFieldList()).thenReturn(propertyClasses);\n        when(baseObject1.getXClass(context)).thenReturn(class1);\n\n        assertFalse(this.rightsManager.isEditWithChangeRequestAllowed(userReference, documentReference));\n        verify(baseObject1).getXClass(context);\n        verifyNoInteractions(baseObject2);\n        verifyNoInteractions(baseObject3);\n\n        when(class1.getFieldList()).thenReturn(List.of(mock(PropertyClass.class)));\n        BaseClass class2 = mock(BaseClass.class);\n        when(class2.getFieldList()).thenReturn(List.of(mock(PasswordClass.class)));\n        when(baseObject2.getXClass(context)).thenReturn(class2);\n\n        assertFalse(this.rightsManager.isEditWithChangeRequestAllowed(userReference, documentReference));\n        verify(baseObject1, times(2)).getXClass(context);\n        verify(baseObject2).getXClass(context);\n        verifyNoInteractions(baseObject3);\n\n        when(class2.getFieldList()).thenReturn(List.of());\n        assertTrue(this.rightsManager.isEditWithChangeRequestAllowed(userReference, documentReference));\n        verify(baseObject1, times(3)).getXClass(context);\n        verify(baseObject2, times(2)).getXClass(context);\n        verifyNoInteractions(baseObject3);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest.internal.handlers;\n\nimport java.util.Date;\nimport java.util.Optional;\n\nimport javax.inject.Named;\nimport javax.inject.Provider;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.contrib.changerequest.ApproversManager;\nimport org.xwiki.contrib.changerequest.ChangeRequest;\nimport org.xwiki.contrib.changerequest.ChangeRequestException;\nimport org.xwiki.contrib.changerequest.ChangeRequestManager;\nimport org.xwiki.contrib.changerequest.ChangeRequestMergeManager;\nimport org.xwiki.contrib.changerequest.ChangeRequestReference;\nimport org.xwiki.contrib.changerequest.ChangeRequestRightsManager;\nimport org.xwiki.contrib.changerequest.FileChange;\nimport org.xwiki.contrib.changerequest.events.ChangeRequestFileChangeAddedEvent;\nimport org.xwiki.contrib.changerequest.internal.FileChangeVersionManager;\nimport org.xwiki.contrib.changerequest.storage.ChangeRequestStorageManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.store.merge.MergeDocumentResult;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.wysiwyg.converter.RequestParameterConverter;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.web.EditForm;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiResponse;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link AddChangesChangeRequestHandler}.\n *\n * @version $Id$\n * @since 0.5\n */\n@ComponentTest\nclass AddChangesChangeRequestHandlerTest\n{\n    @InjectMockComponents\n    private AddChangesChangeRequestHandler handler;\n\n    @MockComponent\n    private ChangeRequestManager changeRequestManager;\n\n    @MockComponent\n    private UserReferenceResolver<CurrentUserReference> userReferenceResolver;\n\n    @MockComponent\n    private FileChangeVersionManager fileChangeVersionManager;\n\n    @MockComponent\n    private ApproversManager<FileChange> fileChangeApproversManager;\n\n    @MockComponent\n    private ApproversManager<ChangeRequest> changeRequestApproversManager;\n\n    @MockComponent\n    protected Provider<XWikiContext> contextProvider;\n\n    @MockComponent\n    protected DocumentReferenceResolver<ChangeRequest> changeRequestDocumentReferenceResolver;\n\n    @MockComponent\n    protected ChangeRequestStorageManager storageManager;\n\n    @MockComponent\n    protected ObservationManager observationManager;\n\n    @MockComponent\n    @Named(\"current\")\n    protected DocumentReferenceResolver<String> documentReferenceResolver;\n\n    @MockComponent\n    private RequestParameterConverter requestParameterConverter;\n\n    @MockComponent\n    private ChangeRequestRightsManager changeRequestRightsManager;\n\n    @MockComponent\n    private ChangeRequestMergeManager changeRequestMergeManager;\n\n    private XWikiContext context;\n    private XWiki wiki;\n    private XWikiVersioningStoreInterface versioningStore;\n\n    @BeforeEach\n    void setup()\n    {\n        this.context = mock(XWikiContext.class);\n        when(contextProvider.get()).thenReturn(context);\n\n        this.wiki = mock(XWiki.class);\n        when(this.context.getWiki()).thenReturn(this.wiki);\n\n        this.versioningStore = mock(XWikiVersioningStoreInterface.class);\n        when(this.wiki.getVersioningStore()).thenReturn(this.versioningStore);\n    }\n\n    @Test\n    void handleFileChangeNotExisting() throws Exception\n    {\n\n        XWikiRequest request = mock(XWikiRequest.class);\n        when(context.getRequest()).thenReturn(request);\n        XWikiResponse response = mock(XWikiResponse.class);\n        when(context.getResponse()).thenReturn(response);\n        when(this.requestParameterConverter.convert(request, response)).thenReturn(Optional.of(request));\n        String docReference = \"XWiki.Doc.Reference\";\n        when(request.getParameter(\"docReference\")).thenReturn(docReference);\n        DocumentReference documentReference = mock(DocumentReference.class);\n        when(this.documentReferenceResolver.resolve(docReference)).thenReturn(documentReference);\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(wiki.getDocument(documentReference, context)).thenReturn(document);\n        when(document.clone()).thenReturn(document);\n        when(document.getDocumentReferenceWithLocale()).thenReturn(documentReference);\n        ChangeRequestReference changeRequestReference = mock(ChangeRequestReference.class);\n        String changeRequestId = \"some id\";\n        when(changeRequestReference.getId()).thenReturn(changeRequestId);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n        when(this.storageManager.load(changeRequestId)).thenReturn(Optional.of(changeRequest));\n        when(changeRequest.getId()).thenReturn(changeRequestId);\n        UserReference userReference = mock(UserReference.class);\n        when(this.userReferenceResolver.resolve(CurrentUserReference.INSTANCE)).thenReturn(userReference);\n        when(changeRequest.getLatestFileChangeFor(documentReference)).thenReturn(Optional.empty());\n        when(request.getParameter(AddChangesChangeRequestHandler.PREVIOUS_VERSION_PARAMETER)).thenReturn(\"2.1\");\n        XWikiDocumentArchive documentArchive = mock(XWikiDocumentArchive.class);\n        when(versioningStore.getXWikiDocumentArchive(document, context)).thenReturn(documentArchive);\n        XWikiDocument previousVersionDoc = mock(XWikiDocument.class);\n        when(documentArchive.loadDocument(new Version(\"2.1\"), context)).thenReturn(previousVersionDoc);\n        when(previousVersionDoc.getDate()).thenReturn(new Date(4100));\n        when(this.fileChangeVersionManager.getNextFileChangeVersion(\"2.1\", false)).thenReturn(\"filechange-3.1\");\n        FileChange expectedFileChange = new FileChange(changeRequest)\n            .setAuthor(userReference)\n            .setTargetEntity(documentReference)\n            .setPreviousVersion(\"2.1\")\n            .setPreviousPublishedVersion(\"2.1\", new Date(4100))\n            .setVersion(\"filechange-3.1\")\n            .setModifiedDocument(document);\n        when(changeRequest.addFileChange(any())).then(invocationOnMock -> {\n            FileChange fileChange = invocationOnMock.getArgument(0);\n            expectedFileChange.setCreationDate(fileChange.getCreationDate());\n            return null;\n        });\n        when(this.changeRequestRightsManager.isViewAccessConsistent(changeRequest, documentReference)).thenReturn(true);\n        DocumentReference changeRequestDocReference = mock(DocumentReference.class);\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDocReference);\n        String url = \"some url\";\n        when(wiki.getURL(changeRequestDocReference, \"view\", context)).thenReturn(url);\n\n        when(this.changeRequestRightsManager.isEditWithChangeRequestAllowed(userReference, documentReference))\n            .thenReturn(true);\n        this.handler.handle(changeRequestReference);\n        verify(this.requestParameterConverter).convert(request, response);\n        verify(document).clone();\n        verify(document).readFromForm(any(EditForm.class), eq(context));\n        verify(changeRequest).addFileChange(expectedFileChange);\n        verify(this.storageManager).save(changeRequest);\n        verify(this.changeRequestApproversManager).getAllApprovers(changeRequest, false);\n        verify(this.fileChangeApproversManager).getAllApprovers(expectedFileChange, false);\n        verify(this.changeRequestApproversManager).getGroupsApprovers(changeRequest);\n        verify(this.fileChangeApproversManager).getGroupsApprovers(expectedFileChange);\n        verify(this.observationManager)\n            .notify(any(ChangeRequestFileChangeAddedEvent.class), eq(changeRequestId), eq(expectedFileChange));\n        verify(response).sendRedirect(url);\n    }\n\n    @Test\n    void handleFileChangeExistingNoConflict() throws Exception\n    {\n        XWikiRequest request = mock(XWikiRequest.class);\n        when(context.getRequest()).thenReturn(request);\n        XWikiResponse response = mock(XWikiResponse.class);\n        when(context.getResponse()).thenReturn(response);\n        when(this.requestParameterConverter.convert(request, response)).thenReturn(Optional.of(request));\n        String docReference = \"XWiki.Doc.Reference\";\n        when(request.getParameter(\"docReference\")).thenReturn(docReference);\n        DocumentReference documentReference = mock(DocumentReference.class, \"editedDoc\");\n        when(this.documentReferenceResolver.resolve(docReference)).thenReturn(documentReference);\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(wiki.getDocument(documentReference, context)).thenReturn(document);\n        when(document.clone()).thenReturn(document);\n        when(document.getDocumentReferenceWithLocale()).thenReturn(documentReference);\n        ChangeRequestReference changeRequestReference = mock(ChangeRequestReference.class);\n        String changeRequestId = \"some id\";\n        when(changeRequestReference.getId()).thenReturn(changeRequestId);\n        ChangeRequest changeRequest = mock(ChangeRequest.class);\n        when(this.storageManager.load(changeRequestId)).thenReturn(Optional.of(changeRequest));\n        when(changeRequest.getId()).thenReturn(changeRequestId);\n        UserReference userReference = mock(UserReference.class, \"currentUser\");\n        when(this.userReferenceResolver.resolve(CurrentUserReference.INSTANCE)).thenReturn(userReference);\n        when(request.getParameter(AddChangesChangeRequestHandler.PREVIOUS_VERSION_PARAMETER)).thenReturn(\"2.1\");\n\n        XWikiDocumentArchive documentArchive = mock(XWikiDocumentArchive.class);\n        when(versioningStore.getXWikiDocumentArchive(document, context)).thenReturn(documentArchive);\n        XWikiDocument previousVersionDoc = mock(XWikiDocument.class);\n        when(documentArchive.loadDocument(new Version(\"2.1\"), context)).thenReturn(previousVersionDoc);\n        when(previousVersionDoc.getDate()).thenReturn(new Date(478));\n\n        FileChange existingFileChange = mock(FileChange.class);\n        when(changeRequest.getLatestFileChangeFor(documentReference)).thenReturn(Optional.of(existingFileChange));\n        when(existingFileChange.getPreviousPublishedVersion()).thenReturn(\"1.1\");\n        when(existingFileChange.getPreviousPublishedVersionDate()).thenReturn(new Date(58));\n        MergeDocumentResult mergeDocumentResult = mock(MergeDocumentResult.class);\n        when(this.changeRequestMergeManager.mergeDocumentChanges(document, \"2.1\", changeRequest))\n            .thenReturn(Optional.of(mergeDocumentResult));\n        when(this.fileChangeVersionManager.getNextFileChangeVersion(\"2.1\", true)).thenReturn(\"filechange-2.2\");\n        when(mergeDocumentResult.hasConflicts()).thenReturn(false);\n        XWikiDocument mergedDocument = mock(XWikiDocument.class);\n        when(mergeDocumentResult.getMergeResult()).thenReturn(mergedDocument);\n        FileChange expectedFileChange = new FileChange(changeRequest)\n            .setAuthor(userReference)\n            .setTargetEntity(documentReference)\n            .setPreviousVersion(\"2.1\")\n            .setPreviousPublishedVersion(\"1.1\", new Date(58))\n            .setVersion(\"filechange-2.2\")\n            .setModifiedDocument(mergedDocument);\n\n        when(changeRequest.addFileChange(any())).then(invocationOnMock -> {\n            FileChange fileChange = invocationOnMock.getArgument(0);\n            expectedFileChange.setCreationDate(fileChange.getCreationDate());\n            return null;\n        });\n        DocumentReference changeRequestDocReference = mock(DocumentReference.class);\n        when(this.changeRequestDocumentReferenceResolver.resolve(changeRequest)).thenReturn(changeRequestDocReference);\n        String url = \"some url\";\n        when(wiki.getURL(changeRequestDocReference, \"view\", context)).thenReturn(url);\n\n        when(this.changeRequestRightsManager.isEditWithChangeRequestAllowed(userReference, documentReference))\n            .thenReturn(false);\n        ChangeRequestException changeRequestException =\n            assertThrows(ChangeRequestException.class, () -> this.handler.handle(changeRequestReference));\n        assertEquals(\"User [currentUser] is not allowed to edit the document [editedDoc] through a change request.\",\n            changeRequestException.getMessage());\n\n        when(this.changeRequestRightsManager.isEditWithChangeRequestAllowed(userReference, documentReference))\n            .thenReturn(true);\n        this.handler.handle(changeRequestReference);\n\n        verify(this.requestParameterConverter, times(2)).convert(request, response);\n        verify(document).clone();\n        verify(document).readFromForm(any(EditForm.class), eq(context));\n        verify(changeRequest).addFileChange(expectedFileChange);\n        verify(this.storageManager).save(changeRequest);\n        verify(this.changeRequestApproversManager).getAllApprovers(changeRequest, false);\n        verify(this.fileChangeApproversManager).getAllApprovers(expectedFileChange, false);\n        verify(this.changeRequestApproversManager).getGroupsApprovers(changeRequest);\n        verify(this.fileChangeApproversManager).getGroupsApprovers(expectedFileChange);\n        verify(this.observationManager)\n            .notify(any(ChangeRequestFileChangeAddedEvent.class), eq(changeRequestId), eq(expectedFileChange));\n        verify(response).sendRedirect(url);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.contrib.changerequest.internal.handlers;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Optional;\n\nimport javax.inject.Named;\nimport javax.inject.Provider;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.contrib.changerequest.ChangeRequest;\nimport org.xwiki.contrib.changerequest.ChangeRequestException;\nimport org.xwiki.contrib.changerequest.ChangeRequestRightsManager;\nimport org.xwiki.contrib.changerequest.ChangeRequestStatus;\nimport org.xwiki.contrib.changerequest.FileChange;\nimport org.xwiki.contrib.changerequest.events.ChangeRequestCreatedEvent;\nimport org.xwiki.contrib.changerequest.storage.ChangeRequestStorageManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.wysiwyg.converter.RequestParameterConverter;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiResponse;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link CreateChangeRequestHandler}.\n *\n * @version $Id$\n * @since 0.3\n */\n@ComponentTest\nclass CreateChangeRequestHandlerTest\n{\n    @InjectMockComponents\n    private CreateChangeRequestHandler handler;\n\n    @MockComponent\n    protected Provider<XWikiContext> contextProvider;\n\n    @MockComponent\n    protected DocumentReferenceResolver<ChangeRequest> changeRequestDocumentReferenceResolver;\n\n    @MockComponent\n    protected ChangeRequestStorageManager storageManager;\n\n    @MockComponent\n    protected ObservationManager observationManager;\n\n    @MockComponent\n    @Named(\"current\")\n    private DocumentReferenceResolver<String> documentReferenceResolver;\n\n    @MockComponent\n    private RequestParameterConverter requestParameterConverter;\n\n    @MockComponent\n    private UserReferenceResolver<CurrentUserReference> userReferenceResolver;\n\n    @MockComponent\n    private ChangeRequestRightsManager changeRequestRightsManager;\n\n    private XWikiContext context;\n    private XWikiRequest httpServletRequest;\n    private XWikiResponse httpServletResponse;\n    private XWiki xWiki;\n    private XWikiVersioningStoreInterface versioningStore;\n\n    @BeforeEach\n    void setup()\n    {\n        this.context = mock(XWikiContext.class);\n        when(contextProvider.get()).thenReturn(context);\n\n        this.xWiki = mock(XWiki.class);\n        when(this.context.getWiki()).thenReturn(this.xWiki);\n\n        this.versioningStore = mock(XWikiVersioningStoreInterface.class);\n        when(this.xWiki.getVersioningStore()).thenReturn(this.versioningStore);\n    }\n\n    @Test\n    void handle() throws Exception\n    {\n        this.httpServletRequest = mock(XWikiRequest.class);\n        when(this.context.getRequest()).thenReturn(this.httpServletRequest);\n        this.httpServletResponse = mock(XWikiResponse.class);\n        when(this.context.getResponse()).thenReturn(this.httpServletResponse);\n\n        when(this.requestParameterConverter.convert(this.httpServletRequest, this.httpServletResponse))\n            .thenReturn(Optional.of(this.httpServletRequest));\n        String serializedReference = \"XWiki.SomeReference\";\n        when(this.httpServletRequest.getParameter(\"docReference\")).thenReturn(serializedReference);\n        DocumentReference documentReference = mock(DocumentReference.class, \"editedDoc\");\n        when(this.documentReferenceResolver.resolve(serializedReference)).thenReturn(documentReference);\n        XWikiDocument modifiedDocument = mock(XWikiDocument.class);\n        when(this.xWiki.getDocument(documentReference, this.context)).thenReturn(modifiedDocument);\n        when(modifiedDocument.clone()).thenReturn(modifiedDocument);\n        DocumentReference documentReferenceWithLocale = mock(DocumentReference.class);\n        when(modifiedDocument.getDocumentReferenceWithLocale()).thenReturn(documentReferenceWithLocale);\n\n        String title = \"some title\";\n        String description = \"some description\";\n        when(this.httpServletRequest.getParameter(\"crTitle\")).thenReturn(title);\n        when(this.httpServletRequest.getParameter(\"crDescription\")).thenReturn(description);\n\n        UserReference userReference = mock(UserReference.class, \"currentUser\");\n        when(this.userReferenceResolver.resolve(CurrentUserReference.INSTANCE)).thenReturn(userReference);\n        String previousVersion = \"3.2\";\n        when(this.httpServletRequest.getParameter(\"previousVersion\")).thenReturn(previousVersion);\n        XWikiDocumentArchive documentArchive = mock(XWikiDocumentArchive.class);\n        when(versioningStore.getXWikiDocumentArchive(modifiedDocument, context)).thenReturn(documentArchive);\n        XWikiDocument previousVersionDoc = mock(XWikiDocument.class);\n        when(documentArchive.loadDocument(new Version(\"3.2\"), context)).thenReturn(previousVersionDoc);\n        when(previousVersionDoc.getDate()).thenReturn(new Date(458));\n\n        ChangeRequest expectedChangeRequest = new ChangeRequest();\n        FileChange expectedFileChange = new FileChange(expectedChangeRequest);\n        expectedFileChange\n            .setAuthor(userReference)\n            .setTargetEntity(documentReferenceWithLocale)\n            .setPreviousVersion(previousVersion)\n            .setPreviousPublishedVersion(previousVersion, new Date(458))\n            .setModifiedDocument(modifiedDocument);\n\n        String crId = \"myCrID\";\n        expectedChangeRequest\n            .setId(crId)\n            .setTitle(title)\n            .setDescription(description)\n            .setCreator(userReference)\n            .addFileChange(expectedFileChange)\n            .setStatus(ChangeRequestStatus.READY_FOR_REVIEW);\n\n        doAnswer(invocationOnMock -> {\n            ChangeRequest changeRequest = invocationOnMock.getArgument(0);\n            List<FileChange> allFileChanges = changeRequest.getLastFileChanges();\n            assertEquals(1, allFileChanges.size());\n            // ensure to have the exact same date in file change\n            Date creationDate = allFileChanges.get(0).getCreationDate();\n            expectedFileChange.setCreationDate(creationDate);\n            expectedChangeRequest.setCreationDate(changeRequest.getCreationDate());\n            changeRequest.setId(crId);\n            return null;\n        }).when(this.storageManager).save(any());\n\n        DocumentReference crDocReference = mock(DocumentReference.class);\n        when(this.changeRequestDocumentReferenceResolver.resolve(expectedChangeRequest)).thenReturn(crDocReference);\n        String expectedURL = \"/mycr\";\n        when(this.xWiki.getURL(crDocReference, \"view\", this.context)).thenReturn(expectedURL);\n\n        when(this.changeRequestRightsManager.isEditWithChangeRequestAllowed(userReference, documentReference))\n            .thenReturn(false);\n        when(this.changeRequestRightsManager.isEditWithChangeRequestAllowed(userReference, documentReference))\n            .thenReturn(false);\n        ChangeRequestException changeRequestException =\n            assertThrows(ChangeRequestException.class, () -> this.handler.handle(null));\n        assertEquals(\"User [currentUser] is not allowed to edit the document [editedDoc] through a change request.\",\n            changeRequestException.getMessage());\n\n        when(this.changeRequestRightsManager.isEditWithChangeRequestAllowed(userReference, documentReference))\n            .thenReturn(true);\n        this.handler.handle(null);\n\n        verify(this.storageManager).save(expectedChangeRequest);\n        verify(this.observationManager)\n            .notify(any(ChangeRequestCreatedEvent.class), eq(crId), eq(expectedChangeRequest));\n        verify(this.httpServletResponse).sendRedirect(expectedURL);\n    }\n\n}\n", "<?xml version=\"1.1\" encoding=\"UTF-8\"?>\n\n<!--\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n-->\n\n<xwikidoc version=\"1.5\" reference=\"ChangeRequest.Code.EditPageUIX\" locale=\"\">\n  <web>ChangeRequest.Code</web>\n  <name>EditPageUIX</name>\n  <language/>\n  <defaultLanguage/>\n  <translation>0</translation>\n  <creator>xwiki:XWiki.Admin</creator>\n  <parent>WebHome</parent>\n  <author>xwiki:XWiki.Admin</author>\n  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>\n  <version>1.1</version>\n  <title>EditPageUIX</title>\n  <comment/>\n  <minorEdit>false</minorEdit>\n  <syntaxId>xwiki/2.1</syntaxId>\n  <hidden>true</hidden>\n  <content/>\n  <object>\n    <name>ChangeRequest.Code.EditPageUIX</name>\n    <number>0</number>\n    <className>XWiki.JavaScriptExtension</className>\n    <guid>d4457cb8-ac6d-48e2-9032-e76da4df56bb</guid>\n    <class>\n      <name>XWiki.JavaScriptExtension</name>\n      <customClass/>\n      <customMapping/>\n      <defaultViewSheet/>\n      <defaultEditSheet/>\n      <defaultWeb/>\n      <nameField/>\n      <validationScript/>\n      <cache>\n        <cache>0</cache>\n        <defaultValue>long</defaultValue>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>cache</name>\n        <number>5</number>\n        <prettyName>Caching policy</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>long|short|default|forbid</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </cache>\n      <code>\n        <contenttype>PureText</contenttype>\n        <disabled>0</disabled>\n        <editor>PureText</editor>\n        <name>code</name>\n        <number>2</number>\n        <prettyName>Code</prettyName>\n        <rows>20</rows>\n        <size>50</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </code>\n      <name>\n        <disabled>0</disabled>\n        <name>name</name>\n        <number>1</number>\n        <prettyName>Name</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </name>\n      <parse>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType>yesno</displayType>\n        <name>parse</name>\n        <number>4</number>\n        <prettyName>Parse content</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </parse>\n      <use>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>use</name>\n        <number>3</number>\n        <prettyName>Use this extension</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>currentPage|onDemand|always</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </use>\n    </class>\n    <property>\n      <cache>long</cache>\n    </property>\n    <property>\n      <code>require(['jquery', 'xwiki-meta'], function ($, xm) {\n  var createConfig = JSON.parse($('#changerequest-create-config').text());\n  \n  var submitCreate = function () {\n    var form = $('form#create');\n    form.attr('action', createConfig.createURL);\n    form.submit();\n  };\n  \n  var initialize = function () {\n    if ($('#create_changerequest').length == 0) {\n      var button = $(\"&lt;input&gt;\", {\n        'type': 'button',\n        'class': 'btn btn-info',\n        'name': 'create_changerequest',\n        'id': 'create_changerequest',\n        'value': createConfig.createAsCRButtonTranslation\n      });\n      \n      $('form#create .buttonwrapper').first().prepend(button);\n      button.on('click', submitCreate);\n    }\n  }\n  \n  initialize();\n})</code>\n    </property>\n    <property>\n      <name>Create as change request button injection</name>\n    </property>\n    <property>\n      <parse>0</parse>\n    </property>\n    <property>\n      <use>onDemand</use>\n    </property>\n  </object>\n  <object>\n    <name>ChangeRequest.Code.EditPageUIX</name>\n    <number>0</number>\n    <className>XWiki.UIExtensionClass</className>\n    <guid>8c1b0aea-f935-457b-8ed3-e34c207969ba</guid>\n    <class>\n      <name>XWiki.UIExtensionClass</name>\n      <customClass/>\n      <customMapping/>\n      <defaultViewSheet/>\n      <defaultEditSheet/>\n      <defaultWeb/>\n      <nameField/>\n      <validationScript/>\n      <async_cached>\n        <defaultValue>0</defaultValue>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType/>\n        <name>async_cached</name>\n        <number>3</number>\n        <prettyName>Cached</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </async_cached>\n      <async_context>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>1</multiSelect>\n        <name>async_context</name>\n        <number>4</number>\n        <prettyName>Context elements</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator>, </separator>\n        <separators>|, </separators>\n        <size>5</size>\n        <unmodifiable>0</unmodifiable>\n        <values>action=Action|doc.reference=Document|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.parameters=Request parameters|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </async_context>\n      <async_enabled>\n        <defaultValue>0</defaultValue>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType/>\n        <name>async_enabled</name>\n        <number>2</number>\n        <prettyName>Asynchronous rendering</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </async_enabled>\n      <content>\n        <disabled>0</disabled>\n        <editor>Text</editor>\n        <name>content</name>\n        <number>1</number>\n        <prettyName>Executed Content</prettyName>\n        <rows>25</rows>\n        <size>120</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </content>\n      <extensionPointId>\n        <disabled>0</disabled>\n        <name>extensionPointId</name>\n        <number>5</number>\n        <prettyName>Extension Point ID</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </extensionPointId>\n      <name>\n        <disabled>0</disabled>\n        <name>name</name>\n        <number>6</number>\n        <prettyName>Extension ID</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </name>\n      <parameters>\n        <contenttype>PureText</contenttype>\n        <disabled>0</disabled>\n        <editor>PureText</editor>\n        <name>parameters</name>\n        <number>7</number>\n        <prettyName>Extension Parameters</prettyName>\n        <rows>10</rows>\n        <size>40</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </parameters>\n      <scope>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>scope</name>\n        <number>8</number>\n        <prettyName>Extension Scope</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>wiki=Current Wiki|user=Current User|global=Global</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </scope>\n    </class>\n    <property>\n      <async_cached>1</async_cached>\n    </property>\n    <property>\n      <async_context>\n        <value>doc.reference</value>\n        <value>user</value>\n        <value>wiki</value>\n      </async_context>\n    </property>\n    <property>\n      <async_enabled>1</async_enabled>\n    </property>\n    <property>\n      <content>{{velocity}}\n{{html clean='false'}}\n#template(\"xwikivars.vm\")\n#set ($crEditName = \"changerequest\")\n#set ($hasCREdit = $services.changerequest.authorization.isEditWithChangeRequestAllowed($doc.getDocumentReference()))\n#set ($hasCRCreate = $services.changerequest.authorization.isCreateWithChangeRequestAllowed($doc.getDocumentReference()))\n#set ($hasEdit = $services.security.authorization.hasAccess('edit', $tdoc))\n#set ($hasCreateButton = ($hasCreateSpace || $hasCreatePage))\n#set ($editURL = $doc.getURL('editcr'))\n#set ($createURL = $doc.getURL('createcr'))\n#if (!$isReadOnly &amp;&amp; $hasCREdit)\n#if (!$hasEdit)\n&lt;div class=\"btn-group\" id=\"crEdit\"&gt;\n  &lt;a href=\"$editURL\" role=\"button\" title=\"$services.localization.render('changerequest.edit.button.title')\" class=\"btn btn-default\"&gt;\n    $services.icon.renderHTML('pencil') $services.localization.render('changerequest.edit.button.value')\n  &lt;/a&gt;\n&lt;/div&gt;\n#end\n#end\n#if (!$isReadOnly &amp;&amp; $hasCRCreate)\n#if (!$hasCreateButton)\n&lt;div class=\"btn-group\" id=\"crCreate\"&gt;\n  &lt;a href=\"$createURL\" role=\"button\" title=\"$services.localization.render('changerequest.create.button.title')\" class=\"btn btn-default\"&gt;\n    $services.icon.renderHTML('add') $services.localization.render('changerequest.create.button.value')\n  &lt;/a&gt;\n&lt;/div&gt;\n#end\n#end\n{{/html}}\n{{/velocity}}</content>\n    </property>\n    <property>\n      <extensionPointId>org.xwiki.plaftorm.menu.content</extensionPointId>\n    </property>\n    <property>\n      <name>org.xwiki.contrib.changerequest.menu.edit</name>\n    </property>\n    <property>\n      <parameters>order=10000</parameters>\n    </property>\n    <property>\n      <scope>wiki</scope>\n    </property>\n  </object>\n  <object>\n    <name>ChangeRequest.Code.EditPageUIX</name>\n    <number>1</number>\n    <className>XWiki.UIExtensionClass</className>\n    <guid>e5f4ba05-dd8f-405d-8e8c-d5b329ad7bab</guid>\n    <class>\n      <name>XWiki.UIExtensionClass</name>\n      <customClass/>\n      <customMapping/>\n      <defaultViewSheet/>\n      <defaultEditSheet/>\n      <defaultWeb/>\n      <nameField/>\n      <validationScript/>\n      <async_cached>\n        <defaultValue>0</defaultValue>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType/>\n        <name>async_cached</name>\n        <number>3</number>\n        <prettyName>Cached</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </async_cached>\n      <async_context>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>1</multiSelect>\n        <name>async_context</name>\n        <number>4</number>\n        <prettyName>Context elements</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator>, </separator>\n        <separators>|, </separators>\n        <size>5</size>\n        <unmodifiable>0</unmodifiable>\n        <values>action=Action|doc.reference=Document|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.parameters=Request parameters|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </async_context>\n      <async_enabled>\n        <defaultValue>0</defaultValue>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType/>\n        <name>async_enabled</name>\n        <number>2</number>\n        <prettyName>Asynchronous rendering</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </async_enabled>\n      <content>\n        <disabled>0</disabled>\n        <editor>Text</editor>\n        <name>content</name>\n        <number>1</number>\n        <prettyName>Executed Content</prettyName>\n        <rows>25</rows>\n        <size>120</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </content>\n      <extensionPointId>\n        <disabled>0</disabled>\n        <name>extensionPointId</name>\n        <number>5</number>\n        <prettyName>Extension Point ID</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </extensionPointId>\n      <name>\n        <disabled>0</disabled>\n        <name>name</name>\n        <number>6</number>\n        <prettyName>Extension ID</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </name>\n      <parameters>\n        <contenttype>PureText</contenttype>\n        <disabled>0</disabled>\n        <editor>PureText</editor>\n        <name>parameters</name>\n        <number>7</number>\n        <prettyName>Extension Parameters</prettyName>\n        <rows>10</rows>\n        <size>40</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </parameters>\n      <scope>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>scope</name>\n        <number>8</number>\n        <prettyName>Extension Scope</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>wiki=Current Wiki|user=Current User|global=Global</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </scope>\n    </class>\n    <property>\n      <async_cached>0</async_cached>\n    </property>\n    <property>\n      <async_context/>\n    </property>\n    <property>\n      <async_enabled>0</async_enabled>\n    </property>\n    <property>\n      <content>{{velocity}}\n#set ($crEditName = \"changerequest\")\n#set ($hasCREdit = $services.security.authorization.isRightRegistered($crEditName) &amp;&amp; $services.security.authorization.hasAccess($crEditName, $tdoc))\n#set ($isCreateAction = $xcontext.action == 'create')\n\n#if ($hasCREdit &amp;&amp; $isCreateAction)\n  #set ($createURL = $tdoc.getURL('createcr'))\n  #set ($changeRequestCreateConfig = {\n    'createURL': $createURL,\n    'createAsCRButtonTranslation': $services.localization.render('changerequest.createascr.button')\n  })\n  \n  {{html clean=\"false\"}}\n  &lt;script id=\"changerequest-create-config\" type=\"application/json\"&gt;$jsontool.serialize($changeRequestCreateConfig).replace('&lt;', '\\u003C')&lt;/script&gt;\n  #set ($discard = $xwiki.jsx.use('ChangeRequest.Code.EditPageUIX'))\n  {{/html}}\n  \n#end\n{{/velocity}}</content>\n    </property>\n    <property>\n      <extensionPointId>org.xwiki.platform.template.header.after</extensionPointId>\n    </property>\n    <property>\n      <name>org.xwiki.contrib.changerequest.ui.header.after.create.extension</name>\n    </property>\n    <property>\n      <parameters>order=0</parameters>\n    </property>\n    <property>\n      <scope>wiki</scope>\n    </property>\n  </object>\n</xwikidoc>\n", "<?xml version=\"1.1\" encoding=\"UTF-8\"?>\n\n<!--\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n-->\n\n<xwikidoc version=\"1.5\" reference=\"ChangeRequest.Code.SaveButtonsUIX\" locale=\"\">\n  <web>ChangeRequest.Code</web>\n  <name>SaveButtonsUIX</name>\n  <language/>\n  <defaultLanguage/>\n  <translation>0</translation>\n  <creator>xwiki:XWiki.Admin</creator>\n  <parent>Main.WebHome</parent>\n  <author>xwiki:XWiki.Admin</author>\n  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>\n  <version>1.1</version>\n  <title>SaveButtonsUIX</title>\n  <comment/>\n  <minorEdit>false</minorEdit>\n  <syntaxId>xwiki/2.1</syntaxId>\n  <hidden>true</hidden>\n  <content>{{velocity}}\n#if ($request.get('checktemplate') == 1)\n  #set ($isTemplateSupported = $services.changerequest.isTemplateSupported($request.get('template')))\n  #jsonResponse({\n    'isSupported': $isTemplateSupported\n  })\n#end\n{{/velocity}}</content>\n  <object>\n    <name>ChangeRequest.Code.SaveButtonsUIX</name>\n    <number>0</number>\n    <className>XWiki.JavaScriptExtension</className>\n    <guid>35af08ef-adff-45fa-9b7a-4462347574e4</guid>\n    <class>\n      <name>XWiki.JavaScriptExtension</name>\n      <customClass/>\n      <customMapping/>\n      <defaultViewSheet/>\n      <defaultEditSheet/>\n      <defaultWeb/>\n      <nameField/>\n      <validationScript/>\n      <cache>\n        <cache>0</cache>\n        <defaultValue>long</defaultValue>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>cache</name>\n        <number>5</number>\n        <prettyName>Caching policy</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>long|short|default|forbid</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </cache>\n      <code>\n        <contenttype>PureText</contenttype>\n        <disabled>0</disabled>\n        <editor>PureText</editor>\n        <name>code</name>\n        <number>2</number>\n        <prettyName>Code</prettyName>\n        <rows>20</rows>\n        <size>50</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </code>\n      <name>\n        <disabled>0</disabled>\n        <name>name</name>\n        <number>1</number>\n        <prettyName>Name</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </name>\n      <parse>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType>yesno</displayType>\n        <name>parse</name>\n        <number>4</number>\n        <prettyName>Parse content</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </parse>\n      <use>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>use</name>\n        <number>3</number>\n        <prettyName>Use this extension</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>currentPage|onDemand|always</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </use>\n    </class>\n    <property>\n      <cache>long</cache>\n    </property>\n    <property>\n      <code>require(['jquery', 'xwiki-meta', 'SaveChangeRequestModal'], function ($, xm, SaveChangeRequestModal) {\n  var saveConfig = JSON.parse($('#changerequest-save-config').text());\n  \n  var handleCancel = function (event) {\n    event.preventDefault();\n    $(document).trigger('xwiki:actions:cancel');\n    var urlParams = new URLSearchParams(window.location.search);\n    var editExistingCR = urlParams.has('changerequest');\n    if (editExistingCR) {\n      document.location.href = saveConfig.changeRequestURL;\n    } else {\n      currentDocUrl = new XWiki.Document(xm.documentReference).getURL();\n      document.location.href = currentDocUrl;\n    }\n  };\n  \n  var attachButtons = function () {\n    if ($('#save_changerequest').length == 0) {\n      var button = $(\"&lt;input&gt;\", {\n        'type': 'button',\n        'class': 'btn btn-info',\n        'name': 'save_changerequest',\n        'id': 'save_changerequest',\n        'value': saveConfig.saveButtonTranslation\n      });\n      \n      var buttonAdded = false;\n      var inplaceEditing;\n      if ($('.bottombuttons').length &gt; 0) {\n        $('.bottombuttons .buttons').prepend(button);\n        buttonAdded = true;\n        inplaceEditing = false;\n      } else if ($('.inplace-editing-buttons').length &gt; 0) {\n        button.data('inplaceediting', true);\n        $('.inplace-editing-buttons .buttons').prepend(button);\n        buttonAdded = true;\n        inplaceEditing = true;\n      }\n    }\n    if (buttonAdded) {\n      var saveChangeRequestModal = new SaveChangeRequestModal('changerequest-save-config');\n      var urlParams = new URLSearchParams(window.location.search);\n      var editExistingCR = urlParams.get('changerequest');\n      button.on('click', function(event) {\n        if (editExistingCR) {\n          saveChangeRequestModal.saveChangeRequest(event, editExistingCR);\n        } else {\n          saveChangeRequestModal.openModal();\n        }\n      });\n      $(document).on('xwiki:document:saveFailed', function(event, data) {\n        var errorMessage = data.response.responseJSON.changeRequestError;\n        if (errorMessage) {\n          saveChangeRequestModal.openModal();\n          $(document).on('xwiki:dom:updated', function (event, data) {\n            if (data.elements.length &gt; 0 &amp;&amp; $(data.elements)[0].id === 'changeRequestModal') {\n              $('#otherError').removeClass('hidden');\n              $('#otherError').find('.details').text(errorMessage);\n            }\n          });\n        }\n      });\n      \n      var hasEditRight = saveConfig.hasEditRight;\n      // hide minor edit and autosave capabilities\n      if (!hasEditRight || editExistingCR) {\n        $('.meta-minorEdit').remove();\n        $('#autosaveControl').remove();\n        $('input[name=action_save]').parent().remove();\n        $('input[name=action_cancel]').off('click');\n        $('input[name=action_cancel]').on('click', handleCancel);\n      }\n    }\n  };\n  \n  var initialize = function() {\n    var urlParams = new URLSearchParams(window.location.search);\n    if (urlParams.has('template')) {\n      var saveButtonUIXDoc = new XWiki.Document(new XWiki.DocumentReference('xwiki', ['ChangeRequest', 'Code'], 'SaveButtonsUIX'));\n      // check template\n      $.get(saveButtonUIXDoc.getURL('get'), {\n        'checktemplate': 1,\n        'outputSyntax': 'plain',\n        'template': urlParams.get('template')\n      }).done(function (data) {\n        if (data.isSupported === true) {\n          attachButtons();\n        } else {\n          console.info(\"Template [{}] not supported by change request.\", urlParams.get('template'));\n        }\n      }).fail(function (data) {\n        console.error(\"Error when checking if template [{}] is supported by change request.\", urlParams.get('template'));\n        console.debug(data);\n      });\n    } else {\n      attachButtons();\n    }\n  }\n\n  $(document).on('xwiki:dom:updated', initialize);\n  initialize();\n});</code>\n    </property>\n    <property>\n      <name>SaveButtonsUIX</name>\n    </property>\n    <property>\n      <parse>0</parse>\n    </property>\n    <property>\n      <use>onDemand</use>\n    </property>\n  </object>\n  <object>\n    <name>ChangeRequest.Code.SaveButtonsUIX</name>\n    <number>0</number>\n    <className>XWiki.UIExtensionClass</className>\n    <guid>76f49e6a-8dc3-42ca-97a8-2c3ef834a7fa</guid>\n    <class>\n      <name>XWiki.UIExtensionClass</name>\n      <customClass/>\n      <customMapping/>\n      <defaultViewSheet/>\n      <defaultEditSheet/>\n      <defaultWeb/>\n      <nameField/>\n      <validationScript/>\n      <async_cached>\n        <defaultValue>0</defaultValue>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType/>\n        <name>async_cached</name>\n        <number>3</number>\n        <prettyName>Cached</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </async_cached>\n      <async_context>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>1</multiSelect>\n        <name>async_context</name>\n        <number>4</number>\n        <prettyName>Context elements</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator>, </separator>\n        <separators>|, </separators>\n        <size>5</size>\n        <unmodifiable>0</unmodifiable>\n        <values>action=Action|doc.reference=Document|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.cookies|request.parameters=Request parameters|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </async_context>\n      <async_enabled>\n        <defaultValue>0</defaultValue>\n        <disabled>0</disabled>\n        <displayFormType>select</displayFormType>\n        <displayType/>\n        <name>async_enabled</name>\n        <number>2</number>\n        <prettyName>Asynchronous rendering</prettyName>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>\n      </async_enabled>\n      <content>\n        <disabled>0</disabled>\n        <editor>Text</editor>\n        <name>content</name>\n        <number>1</number>\n        <prettyName>Executed Content</prettyName>\n        <rows>25</rows>\n        <size>120</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </content>\n      <extensionPointId>\n        <disabled>0</disabled>\n        <name>extensionPointId</name>\n        <number>5</number>\n        <prettyName>Extension Point ID</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </extensionPointId>\n      <name>\n        <disabled>0</disabled>\n        <name>name</name>\n        <number>6</number>\n        <prettyName>Extension ID</prettyName>\n        <size>30</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>\n      </name>\n      <parameters>\n        <contenttype>PureText</contenttype>\n        <disabled>0</disabled>\n        <editor>PureText</editor>\n        <name>parameters</name>\n        <number>7</number>\n        <prettyName>Extension Parameters</prettyName>\n        <rows>10</rows>\n        <size>40</size>\n        <unmodifiable>0</unmodifiable>\n        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>\n      </parameters>\n      <scope>\n        <cache>0</cache>\n        <disabled>0</disabled>\n        <displayType>select</displayType>\n        <freeText>forbidden</freeText>\n        <largeStorage>0</largeStorage>\n        <multiSelect>0</multiSelect>\n        <name>scope</name>\n        <number>8</number>\n        <prettyName>Extension Scope</prettyName>\n        <relationalStorage>0</relationalStorage>\n        <separator> </separator>\n        <separators>|, </separators>\n        <size>1</size>\n        <unmodifiable>0</unmodifiable>\n        <values>wiki=Current Wiki|user=Current User|global=Global</values>\n        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>\n      </scope>\n    </class>\n    <property>\n      <async_cached>0</async_cached>\n    </property>\n    <property>\n      <async_context/>\n    </property>\n    <property>\n      <async_enabled>0</async_enabled>\n    </property>\n    <property>\n      <content>{{velocity}}\n#set ($crEditName = \"changerequest\")\n#set ($hasCREdit = $services.changerequest.authorization.isEditWithChangeRequestAllowed($doc.getDocumentReference()))\n## we need to also inject this in view action, because of the inplace editing mode.\n#set ($isEditOrViewAction = ($xcontext.action == 'edit' || $xcontext.action == 'view'))\n#if ($hasCREdit &amp;&amp; $isEditOrViewAction)\n  #set ($hasEditRight = $services.security.authorization.hasAccess('edit', $doc))\n  #set ($createURL = $services.changerequest.getChangeRequestURL('create', ''))\n  #set ($addChangesURL = $services.changerequest.getChangeRequestURL('addchanges', '__CR__'))\n  #set ($isInplaceEditing = ($xcontext.action == 'view'))\n  #set ($changeRequestSaveConfig = {\n    'hasEditRight': $hasEditRight,\n    'createURL': $createURL,\n    'addChangesURL': $addChangesURL,\n    'saveButtonTranslation': $services.localization.render('changerequest.editor.button.save'),\n    'isCreation': $doc.isNew(),\n    'isInplaceEditing': $isInplaceEditing\n  })\n  #if ($request.get('changerequest'))\n    #set ($changeRequestOpt = $services.changerequest.getChangeRequest($request.get('changerequest')))\n    #if ($changeRequestOpt.isPresent())\n      #set ($changeRequestDocReference = $services.changerequest.getChangeRequestDocumentReference($changeRequestOpt.get()))\n      #set ($discard = $changeRequestSaveConfig.put('changeRequestURL', $xwiki.getDocument($changeRequestDocReference).getURL()))\n    #end\n  #end\n  \n  {{html clean=\"false\"}}\n  &lt;script id=\"changerequest-save-config\" type=\"application/json\"&gt;$jsontool.serialize($changeRequestSaveConfig).replace('&lt;', '\\u003C')&lt;/script&gt;\n  #set ($discard = $xwiki.linkx.use($services.webjars.url('selectize.js', 'css/selectize.bootstrap3.css'),\n  {'type': 'text/css', 'rel': 'stylesheet'}))\n  #set ($discard = $xwiki.ssfx.use('uicomponents/suggest/xwiki.selectize.css', true))\n  #set ($discard = $xwiki.jsfx.use('uicomponents/suggest/xwiki.selectize.js', true))\n  #set ($discard = $xwiki.jsx.use('ChangeRequest.Code.SaveChangeRequestModal'))\n  #set ($discard = $xwiki.jsx.use('ChangeRequest.Code.SaveButtonsUIX'))\n  {{/html}}\n  \n#end\n{{/velocity}}</content>\n    </property>\n    <property>\n      <extensionPointId>org.xwiki.platform.template.header.after</extensionPointId>\n    </property>\n    <property>\n      <name>org.xwiki.contrib.changerequest.ui.header.after.editor.extension</name>\n    </property>\n    <property>\n      <parameters>order=0</parameters>\n    </property>\n    <property>\n      <scope>wiki</scope>\n    </property>\n  </object>\n</xwikidoc>\n"], "filenames": ["application-changerequest-api/src/main/java/org/xwiki/contrib/changerequest/ChangeRequestRightsManager.java", "application-changerequest-default/src/checkstyle/checkstyle-suppressions.xml", "application-changerequest-default/src/main/java/org/xwiki/contrib/changerequest/internal/DefaultChangeRequestRightsManager.java", "application-changerequest-default/src/main/java/org/xwiki/contrib/changerequest/internal/handlers/AbstractChangeRequestActionHandler.java", "application-changerequest-default/src/main/java/org/xwiki/contrib/changerequest/script/ChangeRequestAuthorizationScriptService.java", "application-changerequest-default/src/test/java/org/xwiki/contrib/changerequest/internal/DefaultChangeRequestRightsManagerTest.java", "application-changerequest-default/src/test/java/org/xwiki/contrib/changerequest/internal/handlers/AddChangesChangeRequestHandlerTest.java", "application-changerequest-default/src/test/java/org/xwiki/contrib/changerequest/internal/handlers/CreateChangeRequestHandlerTest.java", "application-changerequest-ui/src/main/resources/ChangeRequest/Code/EditPageUIX.xml", "application-changerequest-ui/src/main/resources/ChangeRequest/Code/SaveButtonsUIX.xml"], "buggy_code_start_loc": [203, 55, 22, 204, 244, 25, 32, 32, 296, 373], "buggy_code_end_loc": [203, 55, 620, 204, 244, 869, 267, 187, 308, 374], "fixing_code_start_loc": [204, 56, 23, 205, 245, 26, 33, 33, 296, 373], "fixing_code_end_loc": [233, 57, 694, 211, 274, 973, 282, 206, 312, 374], "type": "CWE-522", "message": "XWiki Change Request is an XWiki application allowing to request changes on a wiki without publishing directly the changes. Change request allows to edit any page by default, and the changes are then exported in an XML file that anyone can download. So it's possible for an attacker to obtain password hash of users by performing an edit on the user profiles and then downloading the XML file that has been created. This is also true for any document that might contain password field and that a user can view.\nThis vulnerability impacts all version of Change Request, but the impact depends on the rights that has been set on the wiki since it requires for the user to have the Change request right (allowed by default) and view rights on the page to target. This issue cannot be easily exploited in an automated way. The patch consists in denying to users the right of editing pages that contains a password field with change request. It means that already existing change request for those pages won't be removed by the patch, administrators needs to take care of it. The patch is provided in Change Request 1.10, administrators should upgrade immediately. It's possible to workaround the vulnerability by denying manually the Change request right on some spaces, such as XWiki space which will include any user profile by default.", "other": {"cve": {"id": "CVE-2023-49280", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-04T23:15:26.767", "lastModified": "2023-12-08T15:54:43.680", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Change Request is an XWiki application allowing to request changes on a wiki without publishing directly the changes. Change request allows to edit any page by default, and the changes are then exported in an XML file that anyone can download. So it's possible for an attacker to obtain password hash of users by performing an edit on the user profiles and then downloading the XML file that has been created. This is also true for any document that might contain password field and that a user can view.\nThis vulnerability impacts all version of Change Request, but the impact depends on the rights that has been set on the wiki since it requires for the user to have the Change request right (allowed by default) and view rights on the page to target. This issue cannot be easily exploited in an automated way. The patch consists in denying to users the right of editing pages that contains a password field with change request. It means that already existing change request for those pages won't be removed by the patch, administrators needs to take care of it. The patch is provided in Change Request 1.10, administrators should upgrade immediately. It's possible to workaround the vulnerability by denying manually the Change request right on some spaces, such as XWiki space which will include any user profile by default."}, {"lang": "es", "value": "XWiki Change Request es una aplicaci\u00f3n XWiki que permite solicitar cambios en una wiki sin publicar directamente los cambios. Change Request permite editar cualquier p\u00e1gina de forma predeterminada y luego los cambios se exportan en un archivo XML que cualquiera puede descargar. Por lo tanto, es posible que un atacante obtenga el hash de contrase\u00f1a de los usuarios realizando una edici\u00f3n en los perfiles de usuario y luego descargando el archivo XML que se ha creado. Esto tambi\u00e9n se aplica a cualquier documento que pueda contener un campo de contrase\u00f1a y que un usuario pueda ver. Esta vulnerabilidad afecta a todas las versiones de Change Request, pero el impacto depende de los derechos que se hayan establecido en el wiki, ya que requiere que el usuario tenga el derecho de Change Request (permitido de forma predeterminada) y derechos de visualizaci\u00f3n en la p\u00e1gina de destino. Este problema no se puede explotar f\u00e1cilmente de forma automatizada. El parche consiste en negar a los usuarios el derecho de editar p\u00e1ginas que contengan un campo de contrase\u00f1a con Change Request. Significa que el parche no eliminar\u00e1 las solicitudes de cambio ya existentes para esas p\u00e1ginas, los administradores deben encargarse de ello. El parche se proporciona en la Change Request 1.10; los administradores deben actualizarlo de inmediato. Es posible solucionar la vulnerabilidad denegando manualmente Change Request en algunos espacios, como el espacio XWiki, que incluir\u00e1 cualquier perfil de usuario de forma predeterminada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-522"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:change_request:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.1", "versionEndExcluding": "1.10", "matchCriteriaId": "92D41902-A45C-4463-B881-AE2EEF7F8CF6"}]}]}], "references": [{"url": "https://github.com/xwiki-contrib/application-changerequest/commit/ff0f5368ea04f0e4aa7b33821c707dc68a8c5ca8", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xwiki-contrib/application-changerequest/security/advisories/GHSA-2fr7-cc7p-p45q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://jira.xwiki.org/browse/CRAPP-302", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki-contrib/application-changerequest/commit/ff0f5368ea04f0e4aa7b33821c707dc68a8c5ca8"}}