{"buggy_code": ["require ('hazardous')  // makes this module work when it's unpacked from the app.asar package when the app is packed with electron-build\n// it overloads path.join to change asar.app to asar.app.unpacked\nconst path = require('path')\nconst { exec, execSync } = require('child_process')\nconst JSON5 = require('json5')\n\n// The paths are defined here so that hazardous can work it's magic on the paths\nconst macFocusWindow = path.join(__dirname, 'mac', 'setWindowFocus.applescript')\n\nconst sendTextToWindowWithId = path.join(__dirname, 'linux', 'sendTextToWindowWithId.sh')\nconst macFocusAndSendKeys = path.join(__dirname, 'mac', 'focusAndSendKeysAndEnter.applescript')\nconst winSendKeysToWindowName = path.join(__dirname, 'windows', 'sendKeys.bat')\n\nconst linuxGetWindowList = path.join(__dirname, 'linux', 'getWindowList.sh')\nconst macGetWindowList = path.join(__dirname, 'mac', 'getWindowList.applescript')\nconst winGetWindowList = path.join(__dirname, 'windows', 'listOpenWindows.bat')\n\n/**\n * Focuses the first window of the process with the PID given\n * @param {integer} id PID to use to find the application window\n * @param {function} callback callback, get error and message as parameters\n */\nconst focusWindow = (id, callback) => {\n  const emptyCallBack = () => {}\n  callback = callback || emptyCallBack\n  if ( process.platform === 'darwin' ) {\n    exec(`osascript \"${macFocusWindow}\" ${id}`, (error, stdout, stderr) => {\n      if (error) {\n        callback(error, null)\n        return\n      }\n      if (stderr) {\n        callback(stderr, null)\n        return\n      }\n      callback(null, stdout)\n    })\n  } else if ( process.platform === 'win32' ) {\n    // TODO: add windows support\n    callback('Windows isn\\'t supported yet', null)\n  } else if ( process.platform === 'linux' ) {\n    // TODO: add Linux support\n    callback('Linux isn\\'t supported yet', null)\n  } else {\n    callback('Platform not suported', null)\n  }\n  \n}\n\n/**\n * Focuses the first window of the PID given, then sends the cahracters in the keys string to the focused window by emulating the keyboard. \n * Optionally, can focus back to the original application.\n * Optionally has a callback that gets (error, message) parameters for the error message (if any) and any output of the script\n * @param {integer} id PID of the pcoess to focus, or on linux and windows this would be the windowID\n * @param {string} keys string to send to the window\n * @param {*} [param2] optional parameters:\n *  - resetFocus: (default false) if set to true, will reset the focus to the original focus after sending the keys\n *  - pressEnterOnceDone: (default true) if set to true, will press enter once the keys have been sent\n * @returns {Promise} output of the script\n */\nconst sendKeys = (id, keys, {resetFocus = false, pressEnterOnceDone = true} = {}) => {\n  let execPromise = new Promise((resolve, reject) => {\n    keys = keys.replace('\"', '\\\\\"')\n\n    if ( process.platform === 'darwin' ) {\n      exec(`osascript \"${macFocusAndSendKeys}\" ${id} \"${keys}\" ${resetFocus} ${pressEnterOnceDone}`, (error, stdout, stderr) => {\n        if (error) reject(error)\n        if (stderr) reject(stderr)\n        resolve(stdout)\n      })\n\n    } else if ( process.platform === 'win32' ) {\n      // TODO: add option to reset focus on windows\n      const windowTitle = id\n      if (pressEnterOnceDone) {\n        keys = keys + '~'\n      }\n\n      exec(`${winSendKeysToWindowName} \"${windowTitle}\" \"${keys}\"`, (error, stdout, stderr) => {\n        if (error) reject(error)\n        if (stderr) reject(stderr)\n        resolve(stdout)\n      })\n      \n    } else if ( process.platform === 'linux' ) {\n      // TODO: add option to reset focus on linux\n      // TODO: add option to not press enter once keys have been sent\n      const windowID = id // although the function calls it pid, iin this case it's a windowID\n      exec(`${sendTextToWindowWithId} ${windowID} \"${keys}\"`, (error, stdout, stderr) => {\n        if (error) reject(error)\n        if (stderr) reject(stderr)\n        resolve(stdout)\n      })\n\n    } else {\n      reject('Platform not suported')\n    }\n  })\n\n  return execPromise\n}\n\n/**\n * Gets the list of open windows and returns it as an array of window objects.\n * On Linux each object has a id, user and title attributes\n * - id is the window id (linux)\n * - user is the user that owns the process running the window (linux)\n * - title is the title of the window\n * \n * On mac, the object will contain\n * - processName is the name of the process owning the windows\n * - id identifier of the process\n * - windows[] and array of strings for the title of each window this process owns\n * \n * In all cases, the ID can be used in sendKeys()\n * @return {Promise} array of window list Object\n */\nconst getWindowList = () => {\n  return new Promise((resolve, reject) => {\n\n    // Linux\n    if (process.platform === 'linux') {\n      exec(linuxGetWindowList, (error, stdout, stderr) => {\n        if (error) reject(error)\n        if (stderr) reject(stderr)\n        windowStrings = stdout.split('\\n')\n        windowList = []\n  \n        windowStrings.forEach((windowString) => {\n          let windowTitle = windowString.split(' ').slice(4).join(' ')\n          windowObject = {id: windowString.split(' ')[0], user: windowString.split(' ')[3], title: windowTitle}\n          windowList.push(windowObject)\n        })\n        resolve(windowList)\n      })\n\n    // MacOS\n    } else if (process.platform === 'darwin'){\n      exec(`osascript '${macGetWindowList}'`, (error, stdout, stderr) => {\n        if (error) {\n          reject(error)\n        }\n        if (stderr) {\n          // in this case, the script outputs to stderr for some reason\n          // so any stderr isn't an error\n          // We check if the first character is \"{\", if it isn't\n          // then it's an error message\n          if (stderr.charAt(0) !== '{') {\n            reject(stderr)\n          } else {\n            let winList = JSON5.parse(stderr).data\n            resolve(winList)\n          }\n\n        } else {\n          let winList = JSON5.parse(stdout).data\n          resolve(winList)\n        }\n      })\n\n    // Windows\n    } else if (process.platform === 'win32') {\n\n      exec(`${winGetWindowList}`, (error, stdout, stderr) => {\n        if (error) {\n          reject(error)\n        }\n        if (stderr) {\n          reject(stderr)\n\n        } else {\n          // sort the output into an array and remove unecessary output\n          let winList = stdout.split('\\r\\n').slice(2)\n          winList = winList.filter(window => {\n            if (window === '' || window === ' ') {\n              return false\n            } else {\n              return true\n            }\n          })\n\n          // remove extra whitespace\n          winList = winList.map(win => {\n            return win.trim()\n          })\n\n          resolve(winList)\n        }\n      })\n\n    // Other\n    } else {\n      reject('platform not supported yet')\n    }\n  })\n}\n\nmodule.exports = {\n  focusWindow: focusWindow,\n  sendKeys: sendKeys,\n  getWindowList: getWindowList,\n}", "{\n  \"name\": \"window-control\",\n  \"version\": \"1.4.4\",\n  \"lockfileVersion\": 1,\n  \"requires\": true,\n  \"dependencies\": {\n    \"callsite\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/callsite/-/callsite-1.0.0.tgz\",\n      \"integrity\": \"sha1-KAOY5dZkvXQDi28JBRU+borxvCA=\"\n    },\n    \"hazardous\": {\n      \"version\": \"0.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/hazardous/-/hazardous-0.3.0.tgz\",\n      \"integrity\": \"sha512-VLSlBMoLTnfScKBJTycufZ2OHLO06eS3Q0mxNdHJ+egd1QLqeLitxDeGeUuoIgOqSPer+uqZCxiv43a1EVmwdg==\",\n      \"requires\": {\n        \"callsite\": \"^1.0.0\"\n      }\n    },\n    \"json5\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/json5/-/json5-2.1.1.tgz\",\n      \"integrity\": \"sha512-l+3HXD0GEI3huGq1njuqtzYK8OYJyXMkOLtQ53pjWh89tvWS2h6l+1zMkYWqlb57+SiQodKZyvMEFb2X+KrFhQ==\",\n      \"requires\": {\n        \"minimist\": \"^1.2.0\"\n      }\n    },\n    \"minimist\": {\n      \"version\": \"1.2.6\",\n      \"resolved\": \"https://registry.npmjs.org/minimist/-/minimist-1.2.6.tgz\",\n      \"integrity\": \"sha512-Jsjnk4bw3YJqYzbdyBiNsPWHPfO++UGG749Cxs6peCu5Xg4nrena6OVxOYxrQTqww0Jmwt+Ref8rggumkTLz9Q==\"\n    }\n  }\n}\n", "{\n  \"name\": \"window-control\",\n  \"version\": \"1.4.4\",\n  \"description\": \"Tools to manage window focus on mac, windows and linux\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\"\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/uranium78/window-control.git\"\n  },\n  \"keywords\": [\n    \"window\",\n    \"focus\",\n    \"control\",\n    \"tools\"\n  ],\n  \"author\": \"Bruno Robert\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/uranium78/window-control/issues\"\n  },\n  \"homepage\": \"https://github.com/uranium78/window-control#readme\",\n  \"dependencies\": {\n    \"hazardous\": \"^0.3.0\",\n    \"json5\": \"^2.1.1\"\n  }\n}\n"], "fixing_code": ["require ('hazardous')  // makes this module work when it's unpacked from the app.asar package when the app is packed with electron-build\n// it overloads path.join to change asar.app to asar.app.unpacked\nconst path = require('path')\nconst { exec, execSync } = require('child_process')\nconst JSON5 = require('json5')\n\n// The paths are defined here so that hazardous can work it's magic on the paths\nconst macFocusWindow = path.join(__dirname, 'mac', 'setWindowFocus.applescript')\n\nconst sendTextToWindowWithId = path.join(__dirname, 'linux', 'sendTextToWindowWithId.sh')\nconst macFocusAndSendKeys = path.join(__dirname, 'mac', 'focusAndSendKeysAndEnter.applescript')\nconst winSendKeysToWindowName = path.join(__dirname, 'windows', 'sendKeys.bat')\n\nconst linuxGetWindowList = path.join(__dirname, 'linux', 'getWindowList.sh')\nconst macGetWindowList = path.join(__dirname, 'mac', 'getWindowList.applescript')\nconst winGetWindowList = path.join(__dirname, 'windows', 'listOpenWindows.bat')\n\nconst sanitiseUserInput = (input) => {\n  let newInput = (' ' + input).slice(1)\n  newInput = newInput.replaceAll(\"'\", \"\");\n  return newInput\n}\n\n/**\n * Focuses the first window of the process with the PID given\n * @param {integer} id PID to use to find the application window\n * @param {function} callback callback, get error and message as parameters\n */\nconst focusWindow = (id, callback) => {\n  const emptyCallBack = () => {}\n  callback = callback || emptyCallBack\n  if ( process.platform === 'darwin' ) {\n    exec(`osascript \"${macFocusWindow}\" ${id}`, (error, stdout, stderr) => {\n      if (error) {\n        callback(error, null)\n        return\n      }\n      if (stderr) {\n        callback(stderr, null)\n        return\n      }\n      callback(null, stdout)\n    })\n  } else if ( process.platform === 'win32' ) {\n    // TODO: add windows support\n    callback('Windows isn\\'t supported yet', null)\n  } else if ( process.platform === 'linux' ) {\n    // TODO: add Linux support\n    callback('Linux isn\\'t supported yet', null)\n  } else {\n    callback('Platform not suported', null)\n  }\n  \n}\n\n/**\n * Focuses the first window of the PID given, then sends the cahracters in the keys string to the focused window by emulating the keyboard. \n * Optionally, can focus back to the original application.\n * Optionally has a callback that gets (error, message) parameters for the error message (if any) and any output of the script\n * @param {integer} id PID of the pcoess to focus, or on linux and windows this would be the windowID\n * @param {string} keys string to send to the window\n * @param {*} [param2] optional parameters:\n *  - resetFocus: (default false) if set to true, will reset the focus to the original focus after sending the keys\n *  - pressEnterOnceDone: (default true) if set to true, will press enter once the keys have been sent\n * @returns {Promise} output of the script\n */\nconst sendKeys = (id, keys, {resetFocus = false, pressEnterOnceDone = true} = {}) => {\n  let execPromise = new Promise((resolve, reject) => {\n    keys = keys.replace('\"', '\\\\\"')\n\n    if ( process.platform === 'darwin' ) {\n      exec(`osascript \"${macFocusAndSendKeys}\" '${sanitiseUserInput(id)}' '${sanitiseUserInput(keys)}' ${resetFocus} ${pressEnterOnceDone}`, (error, stdout, stderr) => {\n        if (error) reject(error)\n        if (stderr) reject(stderr)\n        resolve(stdout)\n      })\n\n    } else if ( process.platform === 'win32' ) {\n      // TODO: add option to reset focus on windows\n      const windowTitle = id\n      if (pressEnterOnceDone) {\n        keys = keys + '~'\n      }\n\n      exec(`${winSendKeysToWindowName} '${sanitiseUserInput(windowTitle)}' '${sanitiseUserInput(keys)}'`, (error, stdout, stderr) => {\n        if (error) reject(error)\n        if (stderr) reject(stderr)\n        resolve(stdout)\n      })\n      \n    } else if ( process.platform === 'linux' ) {\n      // TODO: add option to reset focus on linux\n      // TODO: add option to not press enter once keys have been sent\n      const windowID = id // although the function calls it pid, iin this case it's a windowID\n      exec(`${sendTextToWindowWithId} '${sanitiseUserInput(windowID)}' '${sanitiseUserInput(keys)}'`, (error, stdout, stderr) => {\n        if (error) reject(error)\n        if (stderr) reject(stderr)\n        resolve(stdout)\n      })\n\n    } else {\n      reject('Platform not suported')\n    }\n  })\n\n  return execPromise\n}\n\n/**\n * Gets the list of open windows and returns it as an array of window objects.\n * On Linux each object has a id, user and title attributes\n * - id is the window id (linux)\n * - user is the user that owns the process running the window (linux)\n * - title is the title of the window\n * \n * On mac, the object will contain\n * - processName is the name of the process owning the windows\n * - id identifier of the process\n * - windows[] and array of strings for the title of each window this process owns\n * \n * In all cases, the ID can be used in sendKeys()\n * @return {Promise} array of window list Object\n */\nconst getWindowList = () => {\n  return new Promise((resolve, reject) => {\n\n    // Linux\n    if (process.platform === 'linux') {\n      exec(linuxGetWindowList, (error, stdout, stderr) => {\n        if (error) reject(error)\n        if (stderr) reject(stderr)\n        windowStrings = stdout.split('\\n')\n        windowList = []\n  \n        windowStrings.forEach((windowString) => {\n          let windowTitle = windowString.split(' ').slice(4).join(' ')\n          windowObject = {id: windowString.split(' ')[0], user: windowString.split(' ')[3], title: windowTitle}\n          windowList.push(windowObject)\n        })\n        resolve(windowList)\n      })\n\n    // MacOS\n    } else if (process.platform === 'darwin'){\n      exec(`osascript '${macGetWindowList}'`, (error, stdout, stderr) => {\n        if (error) {\n          reject(error)\n        }\n        if (stderr) {\n          // in this case, the script outputs to stderr for some reason\n          // so any stderr isn't an error\n          // We check if the first character is \"{\", if it isn't\n          // then it's an error message\n          if (stderr.charAt(0) !== '{') {\n            reject(stderr)\n          } else {\n            let winList = JSON5.parse(stderr).data\n            resolve(winList)\n          }\n\n        } else {\n          let winList = JSON5.parse(stdout).data\n          resolve(winList)\n        }\n      })\n\n    // Windows\n    } else if (process.platform === 'win32') {\n\n      exec(`${winGetWindowList}`, (error, stdout, stderr) => {\n        if (error) {\n          reject(error)\n        }\n        if (stderr) {\n          reject(stderr)\n\n        } else {\n          // sort the output into an array and remove unecessary output\n          let winList = stdout.split('\\r\\n').slice(2)\n          winList = winList.filter(window => {\n            if (window === '' || window === ' ') {\n              return false\n            } else {\n              return true\n            }\n          })\n\n          // remove extra whitespace\n          winList = winList.map(win => {\n            return win.trim()\n          })\n\n          resolve(winList)\n        }\n      })\n\n    // Other\n    } else {\n      reject('platform not supported yet')\n    }\n  })\n}\n\nmodule.exports = {\n  focusWindow: focusWindow,\n  sendKeys: sendKeys,\n  getWindowList: getWindowList,\n}\n", "{\n  \"name\": \"window-control\",\n  \"version\": \"1.4.5\",\n  \"lockfileVersion\": 2,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"window-control\",\n      \"version\": \"1.4.5\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"hazardous\": \"^0.3.0\",\n        \"json5\": \"^2.1.1\"\n      }\n    },\n    \"node_modules/callsite\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/callsite/-/callsite-1.0.0.tgz\",\n      \"integrity\": \"sha1-KAOY5dZkvXQDi28JBRU+borxvCA=\",\n      \"engines\": {\n        \"node\": \"*\"\n      }\n    },\n    \"node_modules/hazardous\": {\n      \"version\": \"0.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/hazardous/-/hazardous-0.3.0.tgz\",\n      \"integrity\": \"sha512-VLSlBMoLTnfScKBJTycufZ2OHLO06eS3Q0mxNdHJ+egd1QLqeLitxDeGeUuoIgOqSPer+uqZCxiv43a1EVmwdg==\",\n      \"dependencies\": {\n        \"callsite\": \"^1.0.0\"\n      }\n    },\n    \"node_modules/json5\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/json5/-/json5-2.1.1.tgz\",\n      \"integrity\": \"sha512-l+3HXD0GEI3huGq1njuqtzYK8OYJyXMkOLtQ53pjWh89tvWS2h6l+1zMkYWqlb57+SiQodKZyvMEFb2X+KrFhQ==\",\n      \"dependencies\": {\n        \"minimist\": \"^1.2.0\"\n      },\n      \"bin\": {\n        \"json5\": \"lib/cli.js\"\n      },\n      \"engines\": {\n        \"node\": \">=6\"\n      }\n    },\n    \"node_modules/minimist\": {\n      \"version\": \"1.2.6\",\n      \"resolved\": \"https://registry.npmjs.org/minimist/-/minimist-1.2.6.tgz\",\n      \"integrity\": \"sha512-Jsjnk4bw3YJqYzbdyBiNsPWHPfO++UGG749Cxs6peCu5Xg4nrena6OVxOYxrQTqww0Jmwt+Ref8rggumkTLz9Q==\"\n    }\n  },\n  \"dependencies\": {\n    \"callsite\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/callsite/-/callsite-1.0.0.tgz\",\n      \"integrity\": \"sha1-KAOY5dZkvXQDi28JBRU+borxvCA=\"\n    },\n    \"hazardous\": {\n      \"version\": \"0.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/hazardous/-/hazardous-0.3.0.tgz\",\n      \"integrity\": \"sha512-VLSlBMoLTnfScKBJTycufZ2OHLO06eS3Q0mxNdHJ+egd1QLqeLitxDeGeUuoIgOqSPer+uqZCxiv43a1EVmwdg==\",\n      \"requires\": {\n        \"callsite\": \"^1.0.0\"\n      }\n    },\n    \"json5\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/json5/-/json5-2.1.1.tgz\",\n      \"integrity\": \"sha512-l+3HXD0GEI3huGq1njuqtzYK8OYJyXMkOLtQ53pjWh89tvWS2h6l+1zMkYWqlb57+SiQodKZyvMEFb2X+KrFhQ==\",\n      \"requires\": {\n        \"minimist\": \"^1.2.0\"\n      }\n    },\n    \"minimist\": {\n      \"version\": \"1.2.6\",\n      \"resolved\": \"https://registry.npmjs.org/minimist/-/minimist-1.2.6.tgz\",\n      \"integrity\": \"sha512-Jsjnk4bw3YJqYzbdyBiNsPWHPfO++UGG749Cxs6peCu5Xg4nrena6OVxOYxrQTqww0Jmwt+Ref8rggumkTLz9Q==\"\n    }\n  }\n}\n", "{\n  \"name\": \"window-control\",\n  \"version\": \"1.4.5\",\n  \"description\": \"Tools to manage window focus on mac, windows and linux\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\"\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/uranium78/window-control.git\"\n  },\n  \"keywords\": [\n    \"window\",\n    \"focus\",\n    \"control\",\n    \"tools\"\n  ],\n  \"author\": \"Bruno Robert\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/uranium78/window-control/issues\"\n  },\n  \"homepage\": \"https://github.com/uranium78/window-control#readme\",\n  \"dependencies\": {\n    \"hazardous\": \"^0.3.0\",\n    \"json5\": \"^2.1.1\"\n  }\n}\n"], "filenames": ["index.js", "package-lock.json", "package.json"], "buggy_code_start_loc": [16, 3, 3], "buggy_code_end_loc": [203, 5, 4], "fixing_code_start_loc": [17, 3, 3], "fixing_code_end_loc": [209, 52, 4], "type": "CWE-77", "message": "Versions of the package window-control before 1.4.5 are vulnerable to Command Injection via the sendKeys function, due to improper input sanitization.", "other": {"cve": {"id": "CVE-2022-25926", "sourceIdentifier": "report@snyk.io", "published": "2023-01-04T18:15:09.027", "lastModified": "2023-01-10T20:35:25.813", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Versions of the package window-control before 1.4.5 are vulnerable to Command Injection via the sendKeys function, due to improper input sanitization."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.4, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:window-control_project:window-control:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.4.5", "matchCriteriaId": "4C6918AD-F808-4C4D-8B40-9DFAD6A1E975"}]}]}], "references": [{"url": "https://github.com/bruno-robert/window-control/commit/075c854534a749d887655a906759f5a7eee95173", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bruno-robert/window-control/releases/tag/v1.4.5", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-WINDOWCONTROL-3186345", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bruno-robert/window-control/commit/075c854534a749d887655a906759f5a7eee95173"}}