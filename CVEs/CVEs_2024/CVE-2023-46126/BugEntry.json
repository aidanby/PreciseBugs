{"buggy_code": ["from __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, List, Optional\n\nfrom pydantic import Extra, Field, root_validator, validator\n\nfrom fides.api.models.privacy_experience import BannerEnabled, ComponentType\nfrom fides.api.models.privacy_notice import PrivacyNoticeRegion\nfrom fides.api.schemas.base_class import FidesSchema\nfrom fides.api.schemas.privacy_notice import PrivacyNoticeResponseWithUserPreferences\nfrom fides.api.schemas.tcf import TCMobileData\nfrom fides.api.util.endpoint_utils import human_friendly_list\nfrom fides.api.util.tcf.tcf_experience_contents import TCFExperienceContents\n\n\nclass ExperienceConfigSchema(FidesSchema):\n    \"\"\"\n    Base for ExperienceConfig API objects.  Here all fields are optional since\n    Pydantic allows subclasses to be more strict but not less strict\n\n    Note component is intentionally not included in the base class. This can be specified when creating an ExperienceConfig\n    but cannot be updated later.\n    \"\"\"\n\n    accept_button_label: Optional[str] = Field(\n        description=\"Overlay 'Accept button displayed on the Banner and Privacy Preferences' or Privacy Center 'Confirmation button label'\"\n    )\n    acknowledge_button_label: Optional[str] = Field(\n        description=\"Overlay 'Acknowledge button label for notice only banner'\"\n    )\n    banner_enabled: Optional[BannerEnabled] = Field(description=\"Overlay 'Banner'\")\n    description: Optional[str] = Field(\n        description=\"Overlay 'Banner Description' or Privacy Center 'Description'\"\n    )\n    disabled: Optional[bool] = Field(\n        default=False, description=\"Whether the given ExperienceConfig is disabled\"\n    )\n    is_default: Optional[bool] = Field(\n        default=False,\n        description=\"Whether the given ExperienceConfig is a global default\",\n    )\n    privacy_policy_link_label: Optional[str] = Field(\n        description=\"Overlay and Privacy Center 'Privacy policy link label'\"\n    )\n    privacy_policy_url: Optional[str] = Field(\n        description=\"Overlay and Privacy Center 'Privacy policy URl'\"\n    )\n    privacy_preferences_link_label: Optional[str] = Field(\n        description=\"Overlay 'Privacy preferences link label'\"\n    )\n    regions: Optional[List[PrivacyNoticeRegion]] = Field(\n        description=\"Regions using this ExperienceConfig\"\n    )\n    reject_button_label: Optional[str] = Field(\n        description=\"Overlay 'Reject button displayed on the Banner and 'Privacy Preferences' of Privacy Center 'Reject button label'\"\n    )\n    save_button_label: Optional[str] = Field(\n        description=\"Overlay 'Privacy preferences 'Save' button label\"\n    )\n    title: Optional[str] = Field(\n        description=\"Overlay 'Banner title' or Privacy Center 'title'\"\n    )\n\n    @validator(\"regions\")\n    @classmethod\n    def validate_regions(\n        cls, regions: List[PrivacyNoticeRegion]\n    ) -> List[PrivacyNoticeRegion]:\n        \"\"\"Assert regions aren't duplicated.\"\"\"\n        if regions and len(regions) != len(set(regions)):\n            raise ValueError(\"Duplicate regions found.\")\n        return regions\n\n\nclass ExperienceConfigCreate(ExperienceConfigSchema):\n    \"\"\"\n    An API representation to create ExperienceConfig.\n    This model doesn't include an `id` so that it can be used for creation.\n    It also establishes some fields _required_ for creation\n    \"\"\"\n\n    accept_button_label: str\n    component: ComponentType\n    description: str\n    reject_button_label: str\n    save_button_label: str\n    title: str\n\n    @root_validator\n    def validate_attributes(cls, values: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate minimum set of required fields exist given the type of component\"\"\"\n        component: Optional[ComponentType] = values.get(\"component\")\n\n        if component == ComponentType.overlay:\n            # Overlays have a few additional required fields beyond the privacy center\n            required_overlay_fields = [\n                \"acknowledge_button_label\",\n                \"banner_enabled\",\n                \"privacy_preferences_link_label\",\n            ]\n            for field in required_overlay_fields:\n                if not values.get(field):\n                    raise ValueError(\n                        f\"The following additional fields are required when defining an overlay: {human_friendly_list(required_overlay_fields)}.\"\n                    )\n\n        return values\n\n\nclass ExperienceConfigUpdate(ExperienceConfigSchema):\n    \"\"\"\n    Updating ExperienceConfig. Note that component cannot be updated once its created\n    \"\"\"\n\n    class Config:\n        \"\"\"Forbid extra values - specifically we don't want component to be updated here.\"\"\"\n\n        extra = Extra.forbid\n\n\nclass ExperienceConfigCreateWithId(ExperienceConfigCreate):\n    \"\"\"Schema for creating out-of-the-box experience configs\"\"\"\n\n    id: str\n\n\nclass ExperienceConfigSchemaWithId(ExperienceConfigSchema):\n    \"\"\"\n    An API representation of a ExperienceConfig that includes an `id` field.\n\n    Also includes the experience config history id and version\n    \"\"\"\n\n    id: str\n    component: ComponentType\n    experience_config_history_id: str\n    version: float\n\n\nclass ExperienceConfigResponse(ExperienceConfigSchemaWithId):\n    \"\"\"\n    An API representation of ExperienceConfig used for response payloads\n    \"\"\"\n\n    created_at: datetime\n    updated_at: datetime\n    regions: List[PrivacyNoticeRegion]  # Property\n\n\nclass ExperienceConfigCreateOrUpdateResponse(FidesSchema):\n    \"\"\"Schema with the created/updated experience config with regions that succeeded or failed\"\"\"\n\n    experience_config: ExperienceConfigResponse\n    linked_regions: List[PrivacyNoticeRegion]\n    unlinked_regions: List[PrivacyNoticeRegion]\n\n\nclass PrivacyExperience(FidesSchema):\n    \"\"\"\n    Base for PrivacyExperience API objects.  Here all fields are optional since\n    Pydantic allows subclasses to be more strict but not less strict\n    \"\"\"\n\n    region: PrivacyNoticeRegion\n    component: Optional[ComponentType]\n    experience_config: Optional[ExperienceConfigSchemaWithId]\n\n    class Config:\n        \"\"\"Populate models with the raw value of enum fields, rather than the enum itself\"\"\"\n\n        use_enum_values = True\n        orm_mode = True\n        extra = Extra.forbid\n\n\nclass PrivacyExperienceWithId(PrivacyExperience):\n    \"\"\"\n    An API representation of a PrivacyExperience that includes an `id` field.\n    Used to help model API responses and update payloads\n    \"\"\"\n\n    id: str\n\n\nclass ExperienceMeta(FidesSchema):\n    \"\"\"Supplements experience with developer-friendly meta information\"\"\"\n\n    version_hash: Optional[str] = Field(\n        description=\"A hashed value that can be compared to previously-fetched \"\n        \"hash values to determine if the Experience has meaningfully changed\"\n    )\n    accept_all_fides_string: Optional[str] = Field(\n        description=\"The fides string (TC String + AC String) corresponding to a user opting in to all \"\n        \"available options\"\n    )\n    accept_all_fides_mobile_data: Optional[TCMobileData] = None\n    reject_all_fides_string: Optional[str] = Field(\n        description=\"The fides string (TC String + AC String) corresponding to a user opting out of all \"\n        \"available options\"\n    )\n    reject_all_fides_mobile_data: Optional[TCMobileData] = None\n\n\nclass PrivacyExperienceResponse(TCFExperienceContents, PrivacyExperienceWithId):\n    \"\"\"\n    An API representation of a PrivacyExperience used for response payloads\n    \"\"\"\n\n    created_at: datetime\n    updated_at: datetime\n    show_banner: Optional[bool] = Field(\n        description=\"Whether the experience should show a banner\",\n    )\n    privacy_notices: Optional[List[PrivacyNoticeResponseWithUserPreferences]] = Field(\n        description=\"The Privacy Notices associated with this experience, if applicable\"\n    )\n    experience_config: Optional[ExperienceConfigResponse] = Field(\n        description=\"The Experience copy or language\"\n    )\n    gvl: Optional[Dict] = None\n    meta: Optional[ExperienceMeta] = None\n", "import logging\nimport uuid\nfrom copy import deepcopy\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Dict, Generator, List, Optional\nfrom unittest import mock\nfrom uuid import uuid4\n\nimport pydash\nimport pytest\nimport yaml\nfrom faker import Faker\nfrom fideslang.models import Dataset\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.orm.exc import ObjectDeletedError, StaleDataError\nfrom toml import load as load_toml\n\nfrom fides.api.common_exceptions import SystemManagerException\nfrom fides.api.models.application_config import ApplicationConfig\nfrom fides.api.models.audit_log import AuditLog, AuditLogAction\nfrom fides.api.models.client import ClientDetail\nfrom fides.api.models.connectionconfig import (\n    AccessLevel,\n    ConnectionConfig,\n    ConnectionType,\n)\nfrom fides.api.models.datasetconfig import DatasetConfig\nfrom fides.api.models.fides_user import FidesUser\nfrom fides.api.models.fides_user_permissions import FidesUserPermissions\nfrom fides.api.models.messaging import MessagingConfig\nfrom fides.api.models.policy import (\n    ActionType,\n    Policy,\n    PolicyPostWebhook,\n    PolicyPreWebhook,\n    Rule,\n    RuleTarget,\n)\nfrom fides.api.models.privacy_experience import (\n    ComponentType,\n    PrivacyExperience,\n    PrivacyExperienceConfig,\n)\nfrom fides.api.models.privacy_notice import (\n    ConsentMechanism,\n    EnforcementLevel,\n    PrivacyNotice,\n    PrivacyNoticeRegion,\n)\nfrom fides.api.models.privacy_preference import (\n    PrivacyPreferenceHistory,\n    ServedNoticeHistory,\n)\nfrom fides.api.models.privacy_request import (\n    Consent,\n    ConsentRequest,\n    PrivacyRequest,\n    PrivacyRequestStatus,\n    ProvidedIdentity,\n)\nfrom fides.api.models.registration import UserRegistration\nfrom fides.api.models.sql_models import DataCategory as DataCategoryDbModel\nfrom fides.api.models.sql_models import Dataset as CtlDataset\nfrom fides.api.models.sql_models import PrivacyDeclaration, System\nfrom fides.api.models.storage import (\n    ResponseFormat,\n    StorageConfig,\n    _create_local_default_storage,\n    default_storage_config_name,\n)\nfrom fides.api.oauth.roles import APPROVER, VIEWER\nfrom fides.api.schemas.messaging.messaging import (\n    MessagingServiceDetails,\n    MessagingServiceSecrets,\n    MessagingServiceType,\n)\nfrom fides.api.schemas.redis_cache import CustomPrivacyRequestField, Identity\nfrom fides.api.schemas.storage.storage import (\n    FileNaming,\n    S3AuthMethod,\n    StorageDetails,\n    StorageSecrets,\n    StorageType,\n)\nfrom fides.api.service.connectors.fides.fides_client import FidesClient\nfrom fides.api.service.masking.strategy.masking_strategy_hmac import HmacMaskingStrategy\nfrom fides.api.service.masking.strategy.masking_strategy_nullify import (\n    NullMaskingStrategy,\n)\nfrom fides.api.service.masking.strategy.masking_strategy_string_rewrite import (\n    StringRewriteMaskingStrategy,\n)\nfrom fides.api.util.data_category import DataCategory\nfrom fides.config import CONFIG\nfrom fides.config.helpers import load_file\n\nlogging.getLogger(\"faker\").setLevel(logging.ERROR)\n# disable verbose faker logging\nfaker = Faker()\nintegration_config = load_toml(\"tests/ops/integration_test_config.toml\")\n\n\n# Unified list of connections to integration dbs specified from fides.api-integration.toml\n\nintegration_secrets = {\n    \"postgres_example\": {\n        \"host\": pydash.get(integration_config, \"postgres_example.server\"),\n        \"port\": pydash.get(integration_config, \"postgres_example.port\"),\n        \"dbname\": pydash.get(integration_config, \"postgres_example.db\"),\n        \"username\": pydash.get(integration_config, \"postgres_example.user\"),\n        \"password\": pydash.get(integration_config, \"postgres_example.password\"),\n    },\n    \"mongo_example\": {\n        \"host\": pydash.get(integration_config, \"mongodb_example.server\"),\n        \"defaultauthdb\": pydash.get(integration_config, \"mongodb_example.db\"),\n        \"username\": pydash.get(integration_config, \"mongodb_example.user\"),\n        \"password\": pydash.get(integration_config, \"mongodb_example.password\"),\n    },\n    \"mysql_example\": {\n        \"host\": pydash.get(integration_config, \"mysql_example.server\"),\n        \"port\": pydash.get(integration_config, \"mysql_example.port\"),\n        \"dbname\": pydash.get(integration_config, \"mysql_example.db\"),\n        \"username\": pydash.get(integration_config, \"mysql_example.user\"),\n        \"password\": pydash.get(integration_config, \"mysql_example.password\"),\n    },\n    \"mssql_example\": {\n        \"host\": pydash.get(integration_config, \"mssql_example.server\"),\n        \"port\": pydash.get(integration_config, \"mssql_example.port\"),\n        \"dbname\": pydash.get(integration_config, \"mssql_example.db\"),\n        \"username\": pydash.get(integration_config, \"mssql_example.user\"),\n        \"password\": pydash.get(integration_config, \"mssql_example.password\"),\n    },\n    \"mariadb_example\": {\n        \"host\": pydash.get(integration_config, \"mariadb_example.server\"),\n        \"port\": pydash.get(integration_config, \"mariadb_example.port\"),\n        \"dbname\": pydash.get(integration_config, \"mariadb_example.db\"),\n        \"username\": pydash.get(integration_config, \"mariadb_example.user\"),\n        \"password\": pydash.get(integration_config, \"mariadb_example.password\"),\n    },\n    \"timescale_example\": {\n        \"host\": pydash.get(integration_config, \"timescale_example.server\"),\n        \"port\": pydash.get(integration_config, \"timescale_example.port\"),\n        \"dbname\": pydash.get(integration_config, \"timescale_example.db\"),\n        \"username\": pydash.get(integration_config, \"timescale_example.user\"),\n        \"password\": pydash.get(integration_config, \"timescale_example.password\"),\n    },\n    \"fides_example\": {\n        \"uri\": pydash.get(integration_config, \"fides_example.uri\"),\n        \"username\": pydash.get(integration_config, \"fides_example.username\"),\n        \"password\": pydash.get(integration_config, \"fides_example.password\"),\n        \"polling_timeout\": pydash.get(\n            integration_config, \"fides_example.polling_timeout\"\n        ),\n    },\n    \"dynamodb_example\": {\n        \"region\": pydash.get(integration_config, \"dynamodb_example.region\"),\n        \"aws_access_key_id\": pydash.get(\n            integration_config, \"dynamodb_example.aws_access_key_id\"\n        ),\n        \"aws_secret_access_key\": pydash.get(\n            integration_config, \"dynamodb_example.aws_secret_access_key\"\n        ),\n    },\n}\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef mock_upload_logic() -> Generator:\n    with mock.patch(\n        \"fides.api.service.storage.storage_uploader_service.upload_to_s3\"\n    ) as _fixture:\n        yield _fixture\n\n\n@pytest.fixture(scope=\"function\")\ndef custom_data_category(db: Session) -> Generator:\n    category = DataCategoryDbModel.create(\n        db=db,\n        data={\n            \"name\": \"Example Custom Data Category\",\n            \"description\": \"A custom data category for testing\",\n            \"fides_key\": \"test_custom_data_category\",\n        },\n    )\n    yield category\n    category.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef storage_config(db: Session) -> Generator:\n    name = str(uuid4())\n    storage_config = StorageConfig.create(\n        db=db,\n        data={\n            \"name\": name,\n            \"type\": StorageType.s3,\n            \"details\": {\n                StorageDetails.AUTH_METHOD.value: S3AuthMethod.SECRET_KEYS.value,\n                StorageDetails.NAMING.value: FileNaming.request_id.value,\n                StorageDetails.BUCKET.value: \"test_bucket\",\n            },\n            \"key\": \"my_test_config\",\n            \"format\": ResponseFormat.json,\n        },\n    )\n    storage_config.set_secrets(\n        db=db,\n        storage_secrets={\n            StorageSecrets.AWS_ACCESS_KEY_ID.value: \"1234\",\n            StorageSecrets.AWS_SECRET_ACCESS_KEY.value: \"5678\",\n        },\n    )\n    yield storage_config\n    storage_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef storage_config_local(db: Session) -> Generator:\n    name = str(uuid4())\n    storage_config = StorageConfig.create(\n        db=db,\n        data={\n            \"name\": name,\n            \"type\": StorageType.local,\n            \"details\": {\n                StorageDetails.NAMING.value: FileNaming.request_id.value,\n            },\n            \"key\": \"my_test_config_local\",\n            \"format\": ResponseFormat.json,\n        },\n    )\n    yield storage_config\n    storage_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef storage_config_default(db: Session) -> Generator:\n    \"\"\"\n    Create and yield a default storage config, as defined by its\n    `is_default` flag being set to `True`. This is an s3 storage config.\n    \"\"\"\n    sc = StorageConfig.create(\n        db=db,\n        data={\n            \"name\": default_storage_config_name(StorageType.s3.value),\n            \"type\": StorageType.s3,\n            \"is_default\": True,\n            \"details\": {\n                StorageDetails.NAMING.value: FileNaming.request_id.value,\n                StorageDetails.AUTH_METHOD.value: S3AuthMethod.AUTOMATIC.value,\n                StorageDetails.BUCKET.value: \"test_bucket\",\n            },\n            \"format\": ResponseFormat.json,\n        },\n    )\n    yield sc\n\n\n@pytest.fixture(scope=\"function\")\ndef storage_config_default_s3_secret_keys(db: Session) -> Generator:\n    \"\"\"\n    Create and yield a default storage config, as defined by its\n    `is_default` flag being set to `True`. This is an s3 storage config.\n    \"\"\"\n    sc = StorageConfig.create(\n        db=db,\n        data={\n            \"name\": default_storage_config_name(StorageType.s3.value),\n            \"type\": StorageType.s3,\n            \"is_default\": True,\n            \"details\": {\n                StorageDetails.NAMING.value: FileNaming.request_id.value,\n                StorageDetails.AUTH_METHOD.value: S3AuthMethod.SECRET_KEYS.value,\n                StorageDetails.BUCKET.value: \"test_bucket\",\n            },\n            \"secrets\": {\n                StorageSecrets.AWS_ACCESS_KEY_ID.value: \"access_key_id\",\n                StorageSecrets.AWS_SECRET_ACCESS_KEY.value: \"secret_access_key\",\n            },\n            \"format\": ResponseFormat.json,\n        },\n    )\n    yield sc\n\n\n@pytest.fixture(scope=\"function\")\ndef storage_config_default_local(db: Session) -> Generator:\n    \"\"\"\n    Create and yield the default local storage config.\n    \"\"\"\n    sc = _create_local_default_storage(db)\n    yield sc\n\n\n@pytest.fixture(scope=\"function\")\ndef set_active_storage_s3(db) -> None:\n    ApplicationConfig.create_or_update(\n        db,\n        data={\n            \"api_set\": {\n                \"storage\": {\"active_default_storage_type\": StorageType.s3.value}\n            }\n        },\n    )\n\n\n@pytest.fixture(scope=\"function\")\ndef messaging_config(db: Session) -> Generator:\n    name = str(uuid4())\n    messaging_config = MessagingConfig.create(\n        db=db,\n        data={\n            \"name\": name,\n            \"key\": \"my_mailgun_messaging_config\",\n            \"service_type\": MessagingServiceType.mailgun.value,\n            \"details\": {\n                MessagingServiceDetails.API_VERSION.value: \"v3\",\n                MessagingServiceDetails.DOMAIN.value: \"some.domain\",\n                MessagingServiceDetails.IS_EU_DOMAIN.value: False,\n            },\n        },\n    )\n    messaging_config.set_secrets(\n        db=db,\n        messaging_secrets={\n            MessagingServiceSecrets.MAILGUN_API_KEY.value: \"12984r70298r\"\n        },\n    )\n    yield messaging_config\n    messaging_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef messaging_config_twilio_email(db: Session) -> Generator:\n    name = str(uuid4())\n    messaging_config = MessagingConfig.create(\n        db=db,\n        data={\n            \"name\": name,\n            \"key\": \"my_twilio_email_config\",\n            \"service_type\": MessagingServiceType.twilio_email.value,\n        },\n    )\n    messaging_config.set_secrets(\n        db=db,\n        messaging_secrets={\n            MessagingServiceSecrets.TWILIO_API_KEY.value: \"123489ctynpiqurwfh\"\n        },\n    )\n    yield messaging_config\n    messaging_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef messaging_config_twilio_sms(db: Session) -> Generator:\n    name = str(uuid4())\n    messaging_config = MessagingConfig.create(\n        db=db,\n        data={\n            \"name\": name,\n            \"key\": \"my_twilio_sms_config\",\n            \"service_type\": MessagingServiceType.twilio_text.value,\n        },\n    )\n    messaging_config.set_secrets(\n        db=db,\n        messaging_secrets={\n            MessagingServiceSecrets.TWILIO_ACCOUNT_SID.value: \"23rwrfwxwef\",\n            MessagingServiceSecrets.TWILIO_AUTH_TOKEN.value: \"23984y29384y598432\",\n            MessagingServiceSecrets.TWILIO_MESSAGING_SERVICE_SID.value: \"2ieurnoqw\",\n        },\n    )\n    yield messaging_config\n    messaging_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef messaging_config_mailchimp_transactional(db: Session) -> Generator:\n    messaging_config = MessagingConfig.create(\n        db=db,\n        data={\n            \"name\": str(uuid4()),\n            \"key\": \"my_mailchimp_transactional_messaging_config\",\n            \"service_type\": MessagingServiceType.mailchimp_transactional,\n            \"details\": {\n                MessagingServiceDetails.DOMAIN.value: \"some.domain\",\n                MessagingServiceDetails.EMAIL_FROM.value: \"test@example.com\",\n            },\n        },\n    )\n    messaging_config.set_secrets(\n        db=db,\n        messaging_secrets={\n            MessagingServiceSecrets.MAILCHIMP_TRANSACTIONAL_API_KEY.value: \"12984r70298r\"\n        },\n    )\n    yield messaging_config\n    messaging_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef https_connection_config(db: Session) -> Generator:\n    name = str(uuid4())\n    connection_config = ConnectionConfig.create(\n        db=db,\n        data={\n            \"name\": name,\n            \"key\": \"my_webhook_config\",\n            \"connection_type\": ConnectionType.https,\n            \"access\": AccessLevel.read,\n            \"secrets\": {\n                \"url\": \"http://example.com\",\n                \"authorization\": \"test_authorization\",\n            },\n        },\n    )\n    yield connection_config\n    connection_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef policy_pre_execution_webhooks(\n    db: Session, https_connection_config, policy\n) -> Generator:\n    pre_webhook = PolicyPreWebhook.create(\n        db=db,\n        data={\n            \"connection_config_id\": https_connection_config.id,\n            \"policy_id\": policy.id,\n            \"direction\": \"one_way\",\n            \"name\": str(uuid4()),\n            \"key\": \"pre_execution_one_way_webhook\",\n            \"order\": 0,\n        },\n    )\n    pre_webhook_two = PolicyPreWebhook.create(\n        db=db,\n        data={\n            \"connection_config_id\": https_connection_config.id,\n            \"policy_id\": policy.id,\n            \"direction\": \"two_way\",\n            \"name\": str(uuid4()),\n            \"key\": \"pre_execution_two_way_webhook\",\n            \"order\": 1,\n        },\n    )\n    db.commit()\n    yield [pre_webhook, pre_webhook_two]\n    try:\n        pre_webhook.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        pre_webhook_two.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef policy_post_execution_webhooks(\n    db: Session, https_connection_config, policy\n) -> Generator:\n    post_webhook = PolicyPostWebhook.create(\n        db=db,\n        data={\n            \"connection_config_id\": https_connection_config.id,\n            \"policy_id\": policy.id,\n            \"direction\": \"one_way\",\n            \"name\": str(uuid4()),\n            \"key\": \"cache_busting_webhook\",\n            \"order\": 0,\n        },\n    )\n    post_webhook_two = PolicyPostWebhook.create(\n        db=db,\n        data={\n            \"connection_config_id\": https_connection_config.id,\n            \"policy_id\": policy.id,\n            \"direction\": \"one_way\",\n            \"name\": str(uuid4()),\n            \"key\": \"cleanup_webhook\",\n            \"order\": 1,\n        },\n    )\n    db.commit()\n    yield [post_webhook, post_webhook_two]\n    try:\n        post_webhook.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        post_webhook_two.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef access_and_erasure_policy(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    access_and_erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example access and erasure policy\",\n            \"key\": \"example_access_erasure_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n    access_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.access.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Access Request Rule\",\n            \"policy_id\": access_and_erasure_policy.id,\n            \"storage_destination_id\": storage_config.id,\n        },\n    )\n    access_rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user\").value,\n            \"rule_id\": access_rule.id,\n        },\n    )\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Erasure Rule\",\n            \"policy_id\": access_and_erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": \"null_rewrite\",\n                \"configuration\": {},\n            },\n        },\n    )\n\n    erasure_rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n    yield access_and_erasure_policy\n    try:\n        access_rule_target.delete(db)\n        erasure_rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_rule.delete(db)\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_and_erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy(\n    db: Session,\n    oauth_client: ClientDetail,\n) -> Generator:\n    erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example erasure policy\",\n            \"key\": \"example_erasure_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Erasure Rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": \"null_rewrite\",\n                \"configuration\": {},\n            },\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n    yield erasure_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy_aes(\n    db: Session,\n    oauth_client: ClientDetail,\n) -> Generator:\n    erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example erasure policy aes\",\n            \"key\": \"example_erasure_policy_aes\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Erasure Rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": \"aes_encrypt\",\n                \"configuration\": {},\n            },\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n    yield erasure_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy_string_rewrite_long(\n    db: Session,\n    oauth_client: ClientDetail,\n) -> Generator:\n    erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example erasure policy string rewrite\",\n            \"key\": \"example_erasure_policy_string_rewrite\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Erasure Rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": StringRewriteMaskingStrategy.name,\n                \"configuration\": {\n                    \"rewrite_value\": \"some rewrite value that is very long and goes on and on\"\n                },\n            },\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n    yield erasure_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy_two_rules(\n    db: Session, oauth_client: ClientDetail, erasure_policy: Policy\n) -> Generator:\n    second_erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Second Erasure Rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": NullMaskingStrategy.name,\n                \"configuration\": {},\n            },\n        },\n    )\n\n    # TODO set masking strategy in Rule.create() call above, once more masking strategies beyond NULL_REWRITE are supported.\n    second_erasure_rule.masking_strategy = {\n        \"strategy\": StringRewriteMaskingStrategy.name,\n        \"configuration\": {\"rewrite_value\": \"*****\"},\n    }\n\n    second_rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.contact.email\").value,\n            \"rule_id\": second_erasure_rule.id,\n        },\n    )\n    yield erasure_policy\n    try:\n        second_rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        second_erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef empty_policy(\n    db: Session,\n    oauth_client: ClientDetail,\n) -> Generator:\n    policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example empty policy\",\n            \"key\": \"example_empty_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n    yield policy\n    try:\n        policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef policy(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    access_request_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example access request policy\",\n            \"key\": \"example_access_request_policy\",\n            \"client_id\": oauth_client.id,\n            \"execution_timeframe\": 7,\n        },\n    )\n\n    access_request_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.access.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Access Request Rule\",\n            \"policy_id\": access_request_policy.id,\n            \"storage_destination_id\": storage_config.id,\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user\").value,\n            \"rule_id\": access_request_rule.id,\n        },\n    )\n    yield access_request_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_request_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_request_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef consent_policy(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    \"\"\"Consent policies only need a ConsentRule attached - no RuleTargets necessary\"\"\"\n    consent_request_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example consent request policy\",\n            \"key\": \"example_consent_request_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    consent_request_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.consent.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Consent Request Rule\",\n            \"policy_id\": consent_request_policy.id,\n        },\n    )\n\n    yield consent_request_policy\n    try:\n        consent_request_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        consent_request_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef policy_local_storage(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config_local: StorageConfig,\n) -> Generator:\n    \"\"\"\n    A basic example policy fixture that uses a local storage config\n    in cases where end-to-end request execution must actually succeed\n    \"\"\"\n    access_request_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example access request policy\",\n            \"key\": \"example_access_request_policy\",\n            \"client_id\": oauth_client.id,\n            \"execution_timeframe\": 7,\n        },\n    )\n\n    access_request_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.access.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Access Request Rule\",\n            \"policy_id\": access_request_policy.id,\n            \"storage_destination_id\": storage_config_local.id,\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user\").value,\n            \"rule_id\": access_request_rule.id,\n        },\n    )\n    yield access_request_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_request_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_request_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef policy_drp_action(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    access_request_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example access request policy drp\",\n            \"key\": \"example_access_request_policy_drp\",\n            \"drp_action\": \"access\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    access_request_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.access.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Access Request Rule DRP\",\n            \"policy_id\": access_request_policy.id,\n            \"storage_destination_id\": storage_config.id,\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user\").value,\n            \"rule_id\": access_request_rule.id,\n        },\n    )\n    yield access_request_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_request_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_request_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef policy_drp_action_erasure(db: Session, oauth_client: ClientDetail) -> Generator:\n    erasure_request_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example erasure request policy drp\",\n            \"key\": \"example_erasure_request_policy_drp\",\n            \"drp_action\": \"deletion\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_request_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Erasure Request Rule DRP\",\n            \"policy_id\": erasure_request_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": StringRewriteMaskingStrategy.name,\n                \"configuration\": {\"rewrite_value\": \"MASKED\"},\n            },\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user\").value,\n            \"rule_id\": erasure_request_rule.id,\n        },\n    )\n    yield erasure_request_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_request_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_request_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy_string_rewrite(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"string rewrite policy\",\n            \"key\": \"string_rewrite_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"string rewrite erasure rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": StringRewriteMaskingStrategy.name,\n                \"configuration\": {\"rewrite_value\": \"MASKED\"},\n            },\n        },\n    )\n\n    erasure_rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n\n    yield erasure_policy\n    try:\n        erasure_rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy_string_rewrite_name_and_email(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"string rewrite policy\",\n            \"key\": \"string_rewrite_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"string rewrite erasure rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": StringRewriteMaskingStrategy.name,\n                \"configuration\": {\"rewrite_value\": \"MASKED\"},\n            },\n        },\n    )\n\n    erasure_rule_target_name = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n\n    erasure_rule_target_email = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.contact.email\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n\n    yield erasure_policy\n    try:\n        erasure_rule_target_name.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule_target_email.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy_hmac(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"hmac policy\",\n            \"key\": \"hmac_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"hmac erasure rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": HmacMaskingStrategy.name,\n                \"configuration\": {},\n            },\n        },\n    )\n\n    erasure_rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n\n    yield erasure_policy\n    try:\n        erasure_rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_requests(db: Session, policy: Policy) -> Generator:\n    privacy_requests = []\n    for count in range(3):\n        privacy_requests.append(\n            PrivacyRequest.create(\n                db=db,\n                data={\n                    \"external_id\": f\"ext-{str(uuid4())}\",\n                    \"started_processing_at\": datetime.utcnow(),\n                    \"requested_at\": datetime.utcnow() - timedelta(days=1),\n                    \"status\": PrivacyRequestStatus.in_processing,\n                    \"origin\": f\"https://example.com/{count}/\",\n                    \"policy_id\": policy.id,\n                    \"client_id\": policy.client_id,\n                },\n            )\n        )\n    yield privacy_requests\n    for pr in privacy_requests:\n        pr.delete(db)\n\n\ndef _create_privacy_request_for_policy(\n    db: Session,\n    policy: Policy,\n    status: PrivacyRequestStatus = PrivacyRequestStatus.in_processing,\n    email_identity: Optional[str] = \"test@example.com\",\n) -> PrivacyRequest:\n    data = {\n        \"external_id\": f\"ext-{str(uuid4())}\",\n        \"requested_at\": datetime(\n            2018,\n            12,\n            31,\n            hour=2,\n            minute=30,\n            second=23,\n            microsecond=916482,\n            tzinfo=timezone.utc,\n        ),\n        \"status\": status,\n        \"origin\": f\"https://example.com/\",\n        \"policy_id\": policy.id,\n        \"client_id\": policy.client_id,\n    }\n    if status != PrivacyRequestStatus.pending:\n        data[\"started_processing_at\"] = datetime(\n            2019,\n            1,\n            1,\n            hour=1,\n            minute=45,\n            second=55,\n            microsecond=393185,\n            tzinfo=timezone.utc,\n        )\n    pr = PrivacyRequest.create(\n        db=db,\n        data=data,\n    )\n    identity_kwargs = {\"email\": email_identity}\n    pr.cache_identity(identity_kwargs)\n    pr.persist_identity(\n        db=db,\n        identity=Identity(\n            email=email_identity,\n            phone_number=\"+12345678910\",\n        ),\n    )\n    return pr\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request(db: Session, policy: Policy) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        policy,\n    )\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_with_erasure_policy(\n    db: Session, erasure_policy: Policy\n) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        erasure_policy,\n    )\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_with_consent_policy(\n    db: Session, consent_policy: Policy\n) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        consent_policy,\n    )\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_with_custom_fields(db: Session, policy: Policy) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        policy,\n    )\n    privacy_request.persist_custom_privacy_request_fields(\n        db=db,\n        custom_privacy_request_fields={\n            \"first_name\": CustomPrivacyRequestField(label=\"First name\", value=\"John\"),\n            \"last_name\": CustomPrivacyRequestField(label=\"Last name\", value=\"Doe\"),\n        },\n    )\n    privacy_request.save(db)\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_requires_input(db: Session, policy: Policy) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        policy,\n    )\n    privacy_request.status = PrivacyRequestStatus.requires_input\n    privacy_request.save(db)\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_awaiting_consent_email_send(\n    db: Session, consent_policy: Policy\n) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        consent_policy,\n    )\n    privacy_request.status = PrivacyRequestStatus.awaiting_email_send\n    privacy_request.save(db)\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_awaiting_erasure_email_send(\n    db: Session, erasure_policy: Policy\n) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        erasure_policy,\n    )\n    privacy_request.status = PrivacyRequestStatus.awaiting_email_send\n    privacy_request.save(db)\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef audit_log(db: Session, privacy_request) -> PrivacyRequest:\n    audit_log = AuditLog.create(\n        db=db,\n        data={\n            \"user_id\": \"system\",\n            \"privacy_request_id\": privacy_request.id,\n            \"action\": AuditLogAction.approved,\n            \"message\": \"\",\n        },\n    )\n    yield audit_log\n    audit_log.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_status_pending(db: Session, policy: Policy) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        policy,\n        PrivacyRequestStatus.pending,\n    )\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_status_canceled(db: Session, policy: Policy) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        policy,\n        PrivacyRequestStatus.canceled,\n    )\n    privacy_request.started_processing_at = None\n    privacy_request.save(db)\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_with_drp_action(\n    db: Session, policy_drp_action: Policy\n) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        policy_drp_action,\n    )\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef succeeded_privacy_request(cache, db: Session, policy: Policy) -> PrivacyRequest:\n    pr = PrivacyRequest.create(\n        db=db,\n        data={\n            \"external_id\": f\"ext-{str(uuid4())}\",\n            \"started_processing_at\": datetime(2021, 10, 1),\n            \"finished_processing_at\": datetime(2021, 10, 3),\n            \"requested_at\": datetime(2021, 10, 1),\n            \"status\": PrivacyRequestStatus.complete,\n            \"origin\": f\"https://example.com/\",\n            \"policy_id\": policy.id,\n            \"client_id\": policy.client_id,\n        },\n    )\n    identity_kwargs = {\"email\": \"email@example.com\"}\n    pr.cache_identity(identity_kwargs)\n    pr.persist_identity(\n        db=db,\n        identity=Identity(**identity_kwargs),\n    )\n    yield pr\n    pr.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef failed_privacy_request(db: Session, policy: Policy) -> PrivacyRequest:\n    pr = PrivacyRequest.create(\n        db=db,\n        data={\n            \"external_id\": f\"ext-{str(uuid4())}\",\n            \"started_processing_at\": datetime(2021, 1, 1),\n            \"finished_processing_at\": datetime(2021, 1, 2),\n            \"requested_at\": datetime(2020, 12, 31),\n            \"status\": PrivacyRequestStatus.error,\n            \"origin\": f\"https://example.com/\",\n            \"policy_id\": policy.id,\n            \"client_id\": policy.client_id,\n        },\n    )\n    yield pr\n    pr.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice\",\n            \"notice_key\": \"example_privacy_notice\",\n            \"description\": \"user&#x27;s description &lt;script /&gt;\",\n            \"regions\": [\n                PrivacyNoticeRegion.us_ca,\n                PrivacyNoticeRegion.us_co,\n            ],\n            \"consent_mechanism\": ConsentMechanism.opt_in,\n            \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n            \"enforcement_level\": EnforcementLevel.system_wide,\n            \"displayed_in_privacy_center\": True,\n            \"displayed_in_overlay\": True,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history(\n    db: Session, privacy_notice, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"acknowledge_mode\": False,\n            \"serving_component\": \"overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"privacy_notice_history_id\": privacy_notice.privacy_notice_history_id,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history_for_tcf_purpose(\n    db: Session, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"acknowledge_mode\": False,\n            \"serving_component\": \"tcf_overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"purpose_consent\": 8,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history_for_vendor_legitimate_interests(\n    db: Session, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"serving_component\": \"tcf_overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"vendor_legitimate_interests\": \"gvl.42\",\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history_for_tcf_feature(\n    db: Session, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"acknowledge_mode\": False,\n            \"serving_component\": \"tcf_overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"feature\": 2,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history_for_tcf_special_purpose(\n    db: Session, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"acknowledge_mode\": False,\n            \"serving_component\": \"tcf_overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"special_purpose\": 1,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice_us_ca_provide(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice us_ca provide\",\n            \"notice_key\": \"example_privacy_notice_us_ca_provide\",\n            # no description or origin on this privacy notice to help\n            # cover edge cases due to column nullability\n            \"regions\": [PrivacyNoticeRegion.us_ca],\n            \"consent_mechanism\": ConsentMechanism.opt_in,\n            \"data_uses\": [\"essential\"],\n            \"enforcement_level\": EnforcementLevel.system_wide,\n            \"displayed_in_overlay\": True,\n            \"displayed_in_privacy_center\": False,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_us_ca_provide(\n    db: Session, privacy_notice_us_ca_provide\n) -> Generator:\n    provided_identity_data = {\n        \"privacy_request_id\": None,\n        \"field_name\": \"email\",\n        \"hashed_value\": ProvidedIdentity.hash_value(\"test2@email.com\"),\n        \"encrypted_value\": {\"value\": \"test2@email.com\"},\n    }\n    provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n    pref_1 = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"preference\": \"opt_in\",\n            \"provided_identity_id\": provided_identity.id,\n            \"privacy_notice_history_id\": privacy_notice_us_ca_provide.privacy_notice_history_id,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n    provided_identity.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history_us_provide_for_fides_user(\n    db: Session, privacy_notice_us_ca_provide, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"acknowledge_mode\": False,\n            \"serving_component\": \"overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"privacy_notice_history_id\": privacy_notice_us_ca_provide.privacy_notice_history_id,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_us_ca_provide_for_fides_user(\n    db: Session, privacy_notice_us_ca_provide, fides_user_provided_identity\n) -> Generator:\n    pref_1 = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"preference\": \"opt_in\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"privacy_notice_history_id\": privacy_notice_us_ca_provide.privacy_notice_history_id,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history_us_ca_provide_for_fides_user(\n    db: Session, privacy_notice_us_ca_provide, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"acknowledge_mode\": False,\n            \"serving_component\": \"overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"privacy_notice_history_id\": privacy_notice_us_ca_provide.privacy_notice_history_id,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice_us_co_third_party_sharing(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice us_co third_party_sharing\",\n            \"notice_key\": \"example_privacy_notice_us_co_third_party_sharing\",\n            \"description\": \"a sample privacy notice configuration\",\n            \"regions\": [PrivacyNoticeRegion.us_co],\n            \"consent_mechanism\": ConsentMechanism.opt_in,\n            \"data_uses\": [\"third_party_sharing\"],\n            \"enforcement_level\": EnforcementLevel.system_wide,\n            \"displayed_in_overlay\": True,\n            \"displayed_in_privacy_center\": True,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice_us_co_provide_service_operations(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice us_co provide.service.operations\",\n            \"notice_key\": \"example_privacy_notice_us_co_provide.service.operations\",\n            \"description\": \"a sample privacy notice configuration\",\n            \"regions\": [PrivacyNoticeRegion.us_co],\n            \"consent_mechanism\": ConsentMechanism.opt_in,\n            \"data_uses\": [\"essential.service.operations\"],\n            \"enforcement_level\": EnforcementLevel.system_wide,\n            \"displayed_in_privacy_center\": False,\n            \"displayed_in_overlay\": True,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_experience_france_tcf_overlay(\n    db: Session, experience_config_tcf_overlay\n) -> Generator:\n    privacy_experience = PrivacyExperience.create(\n        db=db,\n        data={\n            \"component\": ComponentType.tcf_overlay,\n            \"region\": PrivacyNoticeRegion.fr,\n            \"experience_config_id\": experience_config_tcf_overlay.id,\n        },\n    )\n\n    yield privacy_experience\n    privacy_experience.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_experience_france_overlay(\n    db: Session, experience_config_overlay\n) -> Generator:\n    privacy_experience = PrivacyExperience.create(\n        db=db,\n        data={\n            \"component\": ComponentType.overlay,\n            \"region\": PrivacyNoticeRegion.fr,\n            \"experience_config_id\": experience_config_overlay.id,\n        },\n    )\n\n    yield privacy_experience\n    privacy_experience.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice_fr_provide_service_frontend_only(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice us_co provide.service.operations\",\n            \"notice_key\": \"example_privacy_notice_us_co_provide.service.operations\",\n            \"description\": \"a sample privacy notice configuration\",\n            \"regions\": [PrivacyNoticeRegion.fr],\n            \"consent_mechanism\": ConsentMechanism.opt_in,\n            \"data_uses\": [\"essential.service\"],\n            \"enforcement_level\": EnforcementLevel.frontend,\n            \"displayed_in_overlay\": True,\n            \"displayed_in_privacy_center\": False,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice_eu_cy_provide_service_frontend_only(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice eu_cy provide.service.operations\",\n            \"notice_key\": \"example_privacy_notice_eu_cy_provide.service.operations\",\n            \"description\": \"a sample privacy notice configuration\",\n            \"regions\": [PrivacyNoticeRegion.cy],\n            \"consent_mechanism\": ConsentMechanism.opt_out,\n            \"data_uses\": [\"essential.service\"],\n            \"enforcement_level\": EnforcementLevel.frontend,\n            \"displayed_in_overlay\": False,\n            \"displayed_in_privacy_center\": True,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_fr_provide_service_frontend_only(\n    db: Session, privacy_notice_fr_provide_service_frontend_only\n) -> Generator:\n    provided_identity_data = {\n        \"privacy_request_id\": None,\n        \"field_name\": \"email\",\n        \"hashed_value\": ProvidedIdentity.hash_value(\"test2@email.com\"),\n        \"encrypted_value\": {\"value\": \"test2@email.com\"},\n    }\n    provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n    pref_1 = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"preference\": \"opt_in\",\n            \"provided_identity_id\": provided_identity.id,\n            \"privacy_notice_history_id\": privacy_notice_fr_provide_service_frontend_only.privacy_notice_history_id,\n            \"user_geography\": \"fr_idg\",\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n    provided_identity.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef ctl_dataset(db: Session, example_datasets):\n    ds = Dataset(\n        fides_key=\"postgres_example_subscriptions_dataset\",\n        organization_fides_key=\"default_organization\",\n        name=\"Postgres Example Subscribers Dataset\",\n        description=\"Example Postgres dataset created in test fixtures\",\n        data_qualifier=\"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n        retention=\"No retention or erasure policy\",\n        collections=[\n            {\n                \"name\": \"subscriptions\",\n                \"fields\": [\n                    {\n                        \"name\": \"id\",\n                        \"data_categories\": [\"system.operations\"],\n                    },\n                    {\n                        \"name\": \"email\",\n                        \"data_categories\": [\"user.contact.email\"],\n                        \"fidesops_meta\": {\n                            \"identity\": \"email\",\n                        },\n                    },\n                ],\n            },\n        ],\n    )\n    dataset = CtlDataset(**ds.dict())\n    db.add(dataset)\n    db.commit()\n    yield dataset\n    dataset.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef unlinked_dataset(db: Session):\n    ds = Dataset(\n        fides_key=\"unlinked_dataset\",\n        organization_fides_key=\"default_organization\",\n        name=\"Unlinked Dataset\",\n        description=\"Example dataset created in test fixtures\",\n        data_qualifier=\"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n        retention=\"No retention or erasure policy\",\n        collections=[\n            {\n                \"name\": \"subscriptions\",\n                \"fields\": [\n                    {\n                        \"name\": \"id\",\n                        \"data_categories\": [\"system.operations\"],\n                    },\n                    {\n                        \"name\": \"email\",\n                        \"data_categories\": [\"user.contact.email\"],\n                        \"fidesops_meta\": {\n                            \"identity\": \"email\",\n                        },\n                    },\n                ],\n            },\n        ],\n    )\n    dataset = CtlDataset(**ds.dict())\n    db.add(dataset)\n    db.commit()\n    yield dataset\n    dataset.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef linked_dataset(db: Session, connection_config: ConnectionConfig) -> Generator:\n    ds = Dataset(\n        fides_key=\"linked_dataset\",\n        organization_fides_key=\"default_organization\",\n        name=\"Linked Dataset\",\n        description=\"Example dataset created in test fixtures\",\n        data_qualifier=\"aggregated.anonymized.linked_pseudonymized.pseudonymized.identified\",\n        retention=\"No retention or erasure policy\",\n        collections=[\n            {\n                \"name\": \"subscriptions\",\n                \"fields\": [\n                    {\n                        \"name\": \"id\",\n                        \"data_categories\": [\"system.operations\"],\n                    },\n                    {\n                        \"name\": \"email\",\n                        \"data_categories\": [\"user.contact.email\"],\n                        \"fidesops_meta\": {\n                            \"identity\": \"email\",\n                        },\n                    },\n                ],\n            },\n        ],\n    )\n    dataset = CtlDataset(**ds.dict())\n    db.add(dataset)\n    db.commit()\n    dataset_config = DatasetConfig.create(\n        db=db,\n        data={\n            \"connection_config_id\": connection_config.id,\n            \"fides_key\": \"postgres_example_subscriptions_dataset\",\n            \"ctl_dataset_id\": dataset.id,\n        },\n    )\n\n    yield dataset\n    dataset_config.delete(db)\n    dataset.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef dataset_config(\n    connection_config: ConnectionConfig,\n    ctl_dataset,\n    db: Session,\n) -> Generator:\n    dataset_config = DatasetConfig.create(\n        db=db,\n        data={\n            \"connection_config_id\": connection_config.id,\n            \"fides_key\": \"postgres_example_subscriptions_dataset\",\n            \"ctl_dataset_id\": ctl_dataset.id,\n        },\n    )\n    yield dataset_config\n    dataset_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef dataset_config_preview(\n    connection_config: ConnectionConfig, db: Session, ctl_dataset\n) -> Generator:\n    ctl_dataset.fides_key = \"postgres\"\n    db.add(ctl_dataset)\n    db.commit()\n    dataset_config = DatasetConfig.create(\n        db=db,\n        data={\n            \"connection_config_id\": connection_config.id,\n            \"fides_key\": \"postgres\",\n            \"ctl_dataset_id\": ctl_dataset.id,\n        },\n    )\n    yield dataset_config\n    dataset_config.delete(db)\n\n\ndef load_dataset(filename: str) -> Dict:\n    yaml_file = load_file([filename])\n    with open(yaml_file, \"r\") as file:\n        return yaml.safe_load(file).get(\"dataset\", [])\n\n\ndef load_dataset_as_string(filename: str) -> str:\n    yaml_file = load_file([filename])\n    with open(yaml_file, \"r\") as file:\n        return file.read()\n\n\n@pytest.fixture\ndef example_datasets() -> List[Dict]:\n    example_datasets = []\n    example_filenames = [\n        \"data/dataset/postgres_example_test_dataset.yml\",\n        \"data/dataset/mongo_example_test_dataset.yml\",\n        \"data/dataset/snowflake_example_test_dataset.yml\",\n        \"data/dataset/redshift_example_test_dataset.yml\",\n        \"data/dataset/mssql_example_test_dataset.yml\",\n        \"data/dataset/mysql_example_test_dataset.yml\",\n        \"data/dataset/mariadb_example_test_dataset.yml\",\n        \"data/dataset/bigquery_example_test_dataset.yml\",\n        \"data/dataset/manual_dataset.yml\",\n        \"data/dataset/email_dataset.yml\",\n        \"data/dataset/remote_fides_example_test_dataset.yml\",\n        \"data/dataset/dynamodb_example_test_dataset.yml\",\n    ]\n    for filename in example_filenames:\n        example_datasets += load_dataset(filename)\n    return example_datasets\n\n\n@pytest.fixture\ndef example_yaml_datasets() -> str:\n    example_filename = \"data/dataset/example_test_datasets.yml\"\n    return load_dataset_as_string(example_filename)\n\n\n@pytest.fixture\ndef example_yaml_dataset() -> str:\n    example_filename = \"data/dataset/postgres_example_test_dataset.yml\"\n    return load_dataset_as_string(example_filename)\n\n\n@pytest.fixture\ndef example_invalid_yaml_dataset() -> str:\n    example_filename = \"data/dataset/example_test_dataset.invalid\"\n    return load_dataset_as_string(example_filename)\n\n\n@pytest.fixture(scope=\"function\")\ndef sample_data():\n    return {\n        \"_id\": 12345,\n        \"thread\": [\n            {\n                \"comment\": \"com_0001\",\n                \"message\": \"hello, testing in-flight chat feature\",\n                \"chat_name\": \"John\",\n                \"messages\": {},\n            },\n            {\n                \"comment\": \"com_0002\",\n                \"message\": \"yep, got your message, looks like it works\",\n                \"chat_name\": \"Jane\",\n            },\n            {\"comment\": \"com_0002\", \"message\": \"hello!\", \"chat_name\": \"Jeanne\"},\n        ],\n        \"snacks\": [\"pizza\", \"chips\"],\n        \"seats\": {\"first_choice\": \"A2\", \"second_choice\": \"B3\"},\n        \"upgrades\": {\n            \"magazines\": [\"Time\", \"People\"],\n            \"books\": [\"Once upon a Time\", \"SICP\"],\n            \"earplugs\": True,\n        },\n        \"other_flights\": [\n            {\"DFW\": [\"11 AM\", \"12 PM\"], \"CHO\": [\"12 PM\", \"1 PM\"]},\n            {\"DFW\": [\"2 AM\", \"12 PM\"], \"CHO\": [\"2 PM\", \"1 PM\"]},\n            {\"DFW\": [\"3 AM\", \"2 AM\"], \"CHO\": [\"2 PM\", \"1:30 PM\"]},\n        ],\n        \"months\": {\n            \"july\": [\n                {\n                    \"activities\": [\"swimming\", \"hiking\"],\n                    \"crops\": [\"watermelon\", \"cheese\", \"grapes\"],\n                },\n                {\"activities\": [\"tubing\"], \"crops\": [\"corn\"]},\n            ],\n            \"march\": [\n                {\n                    \"activities\": [\"skiing\", \"bobsledding\"],\n                    \"crops\": [\"swiss chard\", \"swiss chard\"],\n                },\n                {\"activities\": [\"hiking\"], \"crops\": [\"spinach\"]},\n            ],\n        },\n        \"hello\": [1, 2, 3, 4, 2],\n        \"weights\": [[1, 2], [3, 4]],\n        \"toppings\": [[[\"pepperoni\", \"salami\"], [\"pepperoni\", \"cheese\", \"cheese\"]]],\n        \"A\": {\"C\": [{\"M\": [\"p\", \"n\", \"n\"]}]},\n        \"C\": [[\"A\", \"B\", \"C\", \"B\"], [\"G\", \"H\", \"B\", \"B\"]],  # Double lists\n        \"D\": [\n            [[\"A\", \"B\", \"C\", \"B\"], [\"G\", \"H\", \"B\", \"B\"]],\n            [[\"A\", \"B\", \"C\", \"B\"], [\"G\", \"H\", \"B\", \"B\"]],\n        ],  # Triple lists\n        \"E\": [[[\"B\"], [[\"A\", \"B\", \"C\", \"B\"], [\"G\", \"H\", \"B\", \"B\"]]]],  # Irregular lists\n        \"F\": [\n            \"a\",\n            [\"1\", \"a\", [[\"z\", \"a\", \"a\"]]],\n        ],  # Lists elems are different types, not officially supported\n    }\n\n\n@pytest.fixture(scope=\"function\")\ndef application_user(\n    db,\n    oauth_client,\n) -> FidesUser:\n    unique_username = f\"user-{uuid4()}\"\n    user = FidesUser.create(\n        db=db,\n        data={\n            \"username\": unique_username,\n            \"password\": \"test_password\",\n            \"first_name\": \"Test\",\n            \"last_name\": \"User\",\n        },\n    )\n    oauth_client.user_id = user.id\n    oauth_client.save(db=db)\n    yield user\n    user.delete(db=db)\n\n\n@pytest.fixture(scope=\"function\")\ndef short_redis_cache_expiration():\n    original_value: int = CONFIG.redis.default_ttl_seconds\n    CONFIG.redis.default_ttl_seconds = (\n        1  # Set redis cache to expire very quickly for testing purposes\n    )\n    yield CONFIG\n    CONFIG.redis.default_ttl_seconds = original_value\n\n\n@pytest.fixture(scope=\"function\")\ndef user_registration_opt_out(db: Session) -> UserRegistration:\n    \"\"\"Adds a UserRegistration record with `opt_in` as False.\"\"\"\n    return create_user_registration(db, opt_in=False)\n\n\n@pytest.fixture(scope=\"function\")\ndef user_registration_opt_in(db: Session) -> UserRegistration:\n    \"\"\"Adds a UserRegistration record with `opt_in` as True.\"\"\"\n    return create_user_registration(db, opt_in=True)\n\n\ndef create_user_registration(db: Session, opt_in: bool = False) -> UserRegistration:\n    \"\"\"Adds a UserRegistration record.\"\"\"\n    return UserRegistration.create(\n        db=db,\n        data={\n            \"user_email\": \"user@example.com\",\n            \"user_organization\": \"Example Org.\",\n            \"analytics_id\": \"example-analytics-id\",\n            \"opt_in\": opt_in,\n        },\n    )\n\n\n@pytest.fixture(scope=\"function\")\ndef test_fides_client(\n    fides_connector_example_secrets: Dict[str, str], api_client\n) -> FidesClient:\n    return FidesClient(\n        fides_connector_example_secrets[\"uri\"],\n        fides_connector_example_secrets[\"username\"],\n        fides_connector_example_secrets[\"password\"],\n        fides_connector_example_secrets[\"polling_timeout\"],\n    )\n\n\n@pytest.fixture(scope=\"function\")\ndef authenticated_fides_client(\n    test_fides_client: FidesClient,\n) -> FidesClient:\n    test_fides_client.login()\n    return test_fides_client\n\n\n@pytest.fixture(scope=\"function\")\ndef system_manager(db: Session, system) -> System:\n    user = FidesUser.create(\n        db=db,\n        data={\n            \"username\": \"test_system_manager_user\",\n            \"password\": \"TESTdcnG@wzJeu0&%3Qe2fGo7\",\n        },\n    )\n    client = ClientDetail(\n        hashed_secret=\"thisisatest\",\n        salt=\"thisisstillatest\",\n        scopes=[],\n        roles=[VIEWER],\n        user_id=user.id,\n        systems=[system.id],\n    )\n\n    FidesUserPermissions.create(db=db, data={\"user_id\": user.id, \"roles\": [VIEWER]})\n\n    db.add(client)\n    db.commit()\n    db.refresh(client)\n\n    user.set_as_system_manager(db, system)\n    yield user\n    try:\n        user.remove_as_system_manager(db, system)\n    except (SystemManagerException, StaleDataError):\n        pass\n    user.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef empty_provided_identity(db):\n    provided_identity = ProvidedIdentity.create(db, data={\"field_name\": \"email\"})\n    yield provided_identity\n    provided_identity.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef provided_identity_value():\n    return \"test@email.com\"\n\n\n@pytest.fixture(scope=\"function\")\ndef provided_identity_and_consent_request(\n    db,\n    provided_identity_value,\n):\n    provided_identity_data = {\n        \"privacy_request_id\": None,\n        \"field_name\": \"email\",\n        \"hashed_value\": ProvidedIdentity.hash_value(provided_identity_value),\n        \"encrypted_value\": {\"value\": provided_identity_value},\n    }\n    provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n    consent_request_data = {\n        \"provided_identity_id\": provided_identity.id,\n    }\n    consent_request = ConsentRequest.create(db, data=consent_request_data)\n\n    yield provided_identity, consent_request\n    provided_identity.delete(db=db)\n    consent_request.delete(db=db)\n\n\n@pytest.fixture(scope=\"function\")\ndef fides_user_provided_identity(db):\n    provided_identity_data = {\n        \"privacy_request_id\": None,\n        \"field_name\": \"fides_user_device_id\",\n        \"hashed_value\": ProvidedIdentity.hash_value(\n            \"051b219f-20e4-45df-82f7-5eb68a00889f\"\n        ),\n        \"encrypted_value\": {\"value\": \"051b219f-20e4-45df-82f7-5eb68a00889f\"},\n    }\n    provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n    yield provided_identity\n    provided_identity.delete(db=db)\n\n\n@pytest.fixture(scope=\"function\")\ndef fides_user_provided_identity_and_consent_request(db, fides_user_provided_identity):\n    consent_request_data = {\n        \"provided_identity_id\": fides_user_provided_identity.id,\n    }\n    consent_request = ConsentRequest.create(db, data=consent_request_data)\n\n    yield fides_user_provided_identity, consent_request\n    fides_user_provided_identity.delete(db=db)\n    consent_request.delete(db=db)\n\n\n@pytest.fixture(scope=\"function\")\ndef executable_consent_request(\n    db,\n    provided_identity_and_consent_request,\n    consent_policy,\n):\n    provided_identity = provided_identity_and_consent_request[0]\n    consent_request = provided_identity_and_consent_request[1]\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        consent_policy,\n    )\n    consent_request.privacy_request_id = privacy_request.id\n    consent_request.save(db)\n    provided_identity.privacy_request_id = privacy_request.id\n    provided_identity.save(db)\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history(\n    db,\n    provided_identity_and_consent_request,\n    privacy_notice,\n    privacy_experience_privacy_center,\n    served_notice_history,\n):\n    provided_identity, consent_request = provided_identity_and_consent_request\n    privacy_notice_history = privacy_notice.histories[0]\n\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"method\": \"button\",\n            \"privacy_experience_config_history_id\": privacy_experience_privacy_center.experience_config.experience_config_history_id,\n            \"privacy_experience_id\": privacy_experience_privacy_center.id,\n            \"preference\": \"opt_out\",\n            \"privacy_notice_history_id\": privacy_notice_history.id,\n            \"provided_identity_id\": provided_identity.id,\n            \"request_origin\": \"privacy_center\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"us_ca\",\n            \"url_recorded\": \"example.com/privacy_center\",\n            \"served_notice_history_id\": served_notice_history.id,\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_tcf_purpose_consent(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n    served_notice_history_for_tcf_purpose,\n):\n    \"\"\"Fixture that saves a privacy preference against a TCF purpose directly\"\"\"\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"fides_user_device\": \"051b219f-20e4-45df-82f7-5eb68a00889f\",\n            \"method\": \"button\",\n            \"purpose_consent\": 8,\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_out\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"fr_idg\",\n            \"url_recorded\": \"example.com/\",\n            \"served_notice_history_id\": served_notice_history_for_tcf_purpose.id,\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_tcf_purpose_legitimate_interests(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n):\n    \"\"\"Fixture that saves a privacy preference against a TCF purpose directly\"\"\"\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"fides_user_device\": \"051b219f-20e4-45df-82f7-5eb68a00889f\",\n            \"method\": \"button\",\n            \"purpose_legitimate_interests\": 8,\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_in\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_vendor(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n):\n    \"\"\"Fixture that saves a privacy preference against a TCF vendor directly\"\"\"\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"method\": \"button\",\n            \"vendor_consent\": \"gvl.42\",\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_out\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"fr_idg\",\n            \"url_recorded\": \"example.com/\",\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_vendor_legitimate_interests(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n    served_notice_history_for_vendor_legitimate_interests,\n):\n    \"\"\"Fixture that saves a privacy preference against a TCF vendor directly\"\"\"\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"method\": \"button\",\n            \"vendor_legitimate_interests\": \"gvl.42\",\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_out\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"fr_idg\",\n            \"url_recorded\": \"example.com/\",\n            \"served_notice_history_id\": served_notice_history_for_vendor_legitimate_interests.id,\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_system(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n    system,\n):\n    \"\"\"Fixture that saves a privacy preference against a system fides key directly\"\"\"\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"method\": \"button\",\n            \"system_consent\": system.id,\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_in\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"fr_idg\",\n            \"url_recorded\": \"example.com/\",\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_tcf_feature(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n    served_notice_history_for_tcf_feature,\n):\n    \"\"\"Fixture that saves a privacy preference against a TCF feature directly\"\"\"\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"fides_user_device\": \"051b219f-20e4-45df-82f7-5eb68a00889f\",\n            \"method\": \"button\",\n            \"feature\": 2,\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_in\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"fr_idg\",\n            \"url_recorded\": \"example.com/\",\n            \"served_notice_history_id\": served_notice_history_for_tcf_feature.id,\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_tcf_special_purpose(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n):\n    \"\"\"Fixture that saves a privacy preference against a TCF special purpose directly\"\"\"\n    (\n        provided_identity,\n        _,\n    ) = provided_identity_and_consent_request\n\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"method\": \"button\",\n            \"special_purpose\": 1,\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_in\",\n            \"provided_identity_id\": provided_identity.id,\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"fr_idg\",\n            \"url_recorded\": \"example.com/\",\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef anonymous_consent_records(\n    db,\n    fides_user_provided_identity_and_consent_request,\n):\n    (\n        provided_identity,\n        consent_request,\n    ) = fides_user_provided_identity_and_consent_request\n    consent_request.cache_identity_verification_code(\"abcdefg\")\n\n    consent_data = [\n        {\n            \"data_use\": \"email\",\n            \"data_use_description\": None,\n            \"opt_in\": True,\n        },\n        {\n            \"data_use\": \"location\",\n            \"data_use_description\": \"Location data\",\n            \"opt_in\": False,\n        },\n    ]\n\n    records = []\n    for data in deepcopy(consent_data):\n        data[\"provided_identity_id\"] = provided_identity.id\n        records.append(Consent.create(db, data=data))\n\n    yield records\n\n    for record in records:\n        record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef consent_records(\n    db,\n    provided_identity_and_consent_request,\n):\n    provided_identity, consent_request = provided_identity_and_consent_request\n    consent_request.cache_identity_verification_code(\"abcdefg\")\n\n    consent_data = [\n        {\n            \"data_use\": \"email\",\n            \"data_use_description\": None,\n            \"opt_in\": True,\n        },\n        {\n            \"data_use\": \"location\",\n            \"data_use_description\": \"Location data\",\n            \"opt_in\": False,\n        },\n    ]\n\n    records = []\n    for data in deepcopy(consent_data):\n        data[\"provided_identity_id\"] = provided_identity.id\n        records.append(Consent.create(db, data=data))\n\n    yield records\n\n    for record in records:\n        record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef experience_config_privacy_center(db: Session) -> Generator:\n    exp = PrivacyExperienceConfig.create(\n        db=db,\n        data={\n            \"accept_button_label\": \"Accept all\",\n            \"description\": \"user&#x27;s description &lt;script /&gt;\",\n            \"component\": \"privacy_center\",\n            \"reject_button_label\": \"Reject all\",\n            \"save_button_label\": \"Save\",\n            \"title\": \"Control your privacy\",\n            \"disabled\": True,\n        },\n    )\n    yield exp\n    for history in exp.histories:\n        history.delete(db)\n    exp.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_experience_privacy_center(\n    db: Session, experience_config_privacy_center\n) -> Generator:\n    privacy_experience = PrivacyExperience.create(\n        db=db,\n        data={\n            \"component\": ComponentType.privacy_center,\n            \"region\": PrivacyNoticeRegion.us_co,\n            \"experience_config_id\": experience_config_privacy_center.id,\n        },\n    )\n\n    yield privacy_experience\n    privacy_experience.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef experience_config_overlay(db: Session) -> Generator:\n    config = PrivacyExperienceConfig.create(\n        db=db,\n        data={\n            \"accept_button_label\": \"Accept all\",\n            \"acknowledge_button_label\": \"Confirm\",\n            \"banner_enabled\": \"enabled_where_required\",\n            \"component\": \"overlay\",\n            \"description\": \"On this page you can opt in and out of these data uses cases\",\n            \"disabled\": False,\n            \"privacy_preferences_link_label\": \"Manage preferences\",\n            \"privacy_policy_link_label\": \"View our company&#x27;s privacy policy\",\n            \"privacy_policy_url\": \"example.com/privacy\",\n            \"reject_button_label\": \"Reject all\",\n            \"save_button_label\": \"Save\",\n            \"title\": \"Manage your consent\",\n        },\n    )\n\n    yield config\n    for history in config.histories:\n        history.delete(db)\n    config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef experience_config_tcf_overlay(db: Session) -> Generator:\n    config = PrivacyExperienceConfig.create(\n        db=db,\n        data={\n            \"accept_button_label\": \"Accept all\",\n            \"acknowledge_button_label\": \"Confirm\",\n            \"banner_enabled\": \"enabled_where_required\",\n            \"component\": \"tcf_overlay\",\n            \"description\": \"On this page you can opt in and out of these data uses cases\",\n            \"disabled\": False,\n            \"privacy_preferences_link_label\": \"Manage preferences\",\n            \"privacy_policy_link_label\": \"View our company&#x27;s privacy policy\",\n            \"privacy_policy_url\": \"example.com/privacy\",\n            \"reject_button_label\": \"Reject all\",\n            \"save_button_label\": \"Save\",\n            \"title\": \"Manage your consent\",\n        },\n    )\n\n    yield config\n    for history in config.histories:\n        history.delete(db)\n    config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_experience_overlay(db: Session, experience_config_overlay) -> Generator:\n    privacy_experience = PrivacyExperience.create(\n        db=db,\n        data={\n            \"component\": ComponentType.overlay,\n            \"region\": PrivacyNoticeRegion.us_ca,\n            \"experience_config_id\": experience_config_overlay.id,\n        },\n    )\n\n    yield privacy_experience\n    privacy_experience.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_experience_privacy_center_france(\n    db: Session, experience_config_privacy_center\n) -> Generator:\n    privacy_experience = PrivacyExperience.create(\n        db=db,\n        data={\n            \"component\": ComponentType.privacy_center,\n            \"region\": PrivacyNoticeRegion.fr,\n            \"experience_config_id\": experience_config_privacy_center.id,\n        },\n    )\n\n    yield privacy_experience\n    privacy_experience.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice_france(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice\",\n            \"notice_key\": \"example_privacy_notice\",\n            \"description\": \"user description\",\n            \"regions\": [\n                PrivacyNoticeRegion.fr,\n            ],\n            \"consent_mechanism\": ConsentMechanism.opt_in,\n            \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n            \"enforcement_level\": EnforcementLevel.system_wide,\n            \"displayed_in_privacy_center\": True,\n            \"displayed_in_overlay\": False,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef allow_custom_privacy_request_field_collection_enabled():\n    original_value = CONFIG.execution.allow_custom_privacy_request_field_collection\n    CONFIG.execution.allow_custom_privacy_request_field_collection = True\n    yield\n    CONFIG.notifications.send_request_review_notification = original_value\n\n\n@pytest.fixture(scope=\"function\")\ndef system_with_no_uses(db: Session) -> System:\n    system = System.create(\n        db=db,\n        data={\n            \"fides_key\": f\"system_fides_key\",\n            \"name\": f\"system-{uuid4()}\",\n            \"description\": \"tcf_relevant_system\",\n            \"organization_fides_key\": \"default_organization\",\n            \"system_type\": \"Service\",\n            \"data_responsibility_title\": \"Processor\",\n            \"data_protection_impact_assessment\": {\n                \"is_required\": False,\n                \"progress\": None,\n                \"link\": None,\n            },\n        },\n    )\n    return system\n\n\n@pytest.fixture(scope=\"function\")\ndef tcf_system(db: Session) -> System:\n    system = System.create(\n        db=db,\n        data={\n            \"fides_key\": f\"tcf-system_key-f{uuid4()}\",\n            \"vendor_id\": \"gvl.42\",\n            \"name\": f\"TCF System Test\",\n            \"description\": \"My TCF System Description\",\n            \"organization_fides_key\": \"default_organization\",\n            \"system_type\": \"Service\",\n            \"data_responsibility_title\": \"Processor\",\n            \"data_protection_impact_assessment\": {\n                \"is_required\": False,\n                \"progress\": None,\n                \"link\": None,\n            },\n        },\n    )\n\n    PrivacyDeclaration.create(\n        db=db,\n        data={\n            \"name\": \"Collect data for content performance\",\n            \"system_id\": system.id,\n            \"data_categories\": [\"user.device.cookie_id\"],\n            \"data_use\": \"analytics.reporting.content_performance\",\n            \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n            \"data_subjects\": [\"customer\"],\n            \"dataset_references\": None,\n            \"legal_basis_for_processing\": \"Consent\",\n            \"egress\": None,\n            \"ingress\": None,\n        },\n    )\n\n    PrivacyDeclaration.create(\n        db=db,\n        data={\n            \"name\": \"Ensure security, prevent and detect fraud\",\n            \"system_id\": system.id,\n            \"data_categories\": [\"user\"],\n            \"data_use\": \"essential.fraud_detection\",\n            \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n            \"data_subjects\": [\"customer\"],\n            \"dataset_references\": None,\n            \"legal_basis_for_processing\": \"Legitimate interests\",\n            \"egress\": None,\n            \"ingress\": None,\n        },\n    )\n\n    db.refresh(system)\n    return system\n\n\n@pytest.fixture(scope=\"function\")\ndef ac_system(db: Session) -> System:\n    \"\"\"Test AC System - will be fleshed out further later\"\"\"\n    system = System.create(\n        db=db,\n        data={\n            \"fides_key\": f\"ac_system{uuid.uuid4()}\",\n            \"vendor_id\": \"gacp.8\",\n            \"name\": f\"Test AC System\",\n            \"organization_fides_key\": \"default_organization\",\n            \"system_type\": \"Service\",\n        },\n    )\n\n    PrivacyDeclaration.create(\n        db=db,\n        data={\n            \"system_id\": system.id,\n            \"data_use\": \"functional.storage\",\n            \"legal_basis_for_processing\": \"Consent\",\n            \"features\": [\n                \"Match and combine data from other data sources\",  # Feature 1\n                \"Link different devices\",  # Feature 2\n            ],\n        },\n    )\n    return system\n\n\n# Detailed systems with attributes for TC string testing\n# Please don't update them!\n\n\n@pytest.fixture(scope=\"function\")\ndef captify_technologies_system(db: Session) -> System:\n    \"\"\"Add system that only has purposes with Consent legal basis\"\"\"\n    system = System.create(\n        db=db,\n        data={\n            \"fides_key\": f\"captify_{uuid.uuid4()}\",\n            \"vendor_id\": \"gvl.2\",\n            \"name\": f\"Captify\",\n            \"description\": \"Captify is a search intelligence platform that helps brands and advertisers leverage search insights to improve their ad targeting and relevance.\",\n            \"organization_fides_key\": \"default_organization\",\n            \"system_type\": \"Service\",\n            \"uses_profiling\": False,\n            \"legal_basis_for_transfers\": [\"SCCs\"],\n        },\n    )\n\n    for data_use in [\n        \"functional.storage\",  # Purpose 1\n        \"marketing.advertising.negative_targeting\",  # Purpose 2\n        \"marketing.advertising.frequency_capping\",  # Purpose 2\n        \"marketing.advertising.first_party.contextual\",  # Purpose 2\n        \"marketing.advertising.profiling\",  # Purpose 3\n        \"marketing.advertising.first_party.targeted\",  # Purpose 4\n        \"marketing.advertising.third_party.targeted\",  # Purpose 4\n        \"analytics.reporting.ad_performance\",  # Purpose 7\n        \"analytics.reporting.campaign_insights\",  # Purpose 9\n        \"functional.service.improve\",  # Purpose 10\n        \"essential.fraud_detection\",  # Special Purpose 1\n        \"essential.service.security\"  # Special Purpose 1\n        \"marketing.advertising.serving\",  # Special Purpose 2\n    ]:\n        # Includes Feature 2, Special Feature 2\n        PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"system_id\": system.id,\n                \"data_use\": data_use,\n                \"legal_basis_for_processing\": \"Consent\",\n                \"features\": [\n                    \"Link different devices\",\n                    \"Actively scan device characteristics for identification\",\n                ],\n            },\n        )\n\n    db.refresh(system)\n    return system\n\n\n@pytest.fixture(scope=\"function\")\ndef emerse_system(db: Session) -> System:\n    \"\"\"This system has purposes that are both consent and legitimate interest legal basis\"\"\"\n    system = System.create(\n        db=db,\n        data={\n            \"fides_key\": f\"emerse{uuid.uuid4()}\",\n            \"vendor_id\": \"gvl.8\",\n            \"name\": f\"Emerse\",\n            \"description\": \"Emerse Sverige AB is a provider of programmatic advertising solutions, offering advertisers and publishers tools to manage and optimize their digital ad campaigns.\",\n            \"organization_fides_key\": \"default_organization\",\n            \"system_type\": \"Service\",\n        },\n    )\n\n    # Add Consent-related Purposes\n    for data_use in [\n        \"functional.storage\",  # Purpose 1\n        \"marketing.advertising.profiling\",  # Purpose 3\n        \"marketing.advertising.third_party.targeted\",  # Purpose 4\n        \"marketing.advertising.first_party.targeted\",  # Purpose 4\n    ]:\n        # Includes Feature 2, Special Feature 2\n        PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"system_id\": system.id,\n                \"data_use\": data_use,\n                \"legal_basis_for_processing\": \"Consent\",\n                \"features\": [\n                    \"Match and combine data from other data sources\",  # Feature 1\n                    \"Link different devices\",  # Feature 2\n                ],\n            },\n        )\n\n    # Add Legitimate Interest-related Purposes\n    for data_use in [\n        \"marketing.advertising.negative_targeting\",  # Purpose 2\n        \"marketing.advertising.first_party.contextual\",  # Purpose 2\n        \"marketing.advertising.frequency_capping\",  # Purpose 2\n        \"analytics.reporting.ad_performance\",  # Purpose 7\n        \"analytics.reporting.content_performance\",  # Purpose 8\n        \"analytics.reporting.campaign_insights\",  # Purpose 9\n        \"essential.fraud_detection\",  # Special Purpose 1\n        \"essential.service.security\",  # Special Purpose 1\n        \"marketing.advertising.serving\",  # Special Purpose 2\n    ]:\n        # Includes Feature 2, Special Feature 2\n        PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"system_id\": system.id,\n                \"data_use\": data_use,\n                \"legal_basis_for_processing\": \"Legitimate interests\",\n                \"features\": [\n                    \"Match and combine data from other data sources\",  # Feature 1\n                    \"Link different devices\",  # Feature 2\n                ],\n            },\n        )\n\n    db.refresh(system)\n    return system\n\n\n@pytest.fixture(scope=\"function\")\ndef skimbit_system(db):\n    \"\"\"Add system that only has purposes with LI legal basis\"\"\"\n    system = System.create(\n        db=db,\n        data={\n            \"fides_key\": f\"skimbit{uuid.uuid4()}\",\n            \"vendor_id\": \"gvl.46\",\n            \"name\": f\"Skimbit (Skimlinks, Taboola)\",\n            \"description\": \"Skimbit, a Taboola company, specializes in data-driven advertising and provides tools for brands and advertisers to analyze customer behavior and deliver targeted and personalized ads.\",\n            \"organization_fides_key\": \"default_organization\",\n            \"system_type\": \"Service\",\n        },\n    )\n\n    # Add Legitimate Interest-related Purposes\n    for data_use in [\n        \"analytics.reporting.ad_performance\",  # Purpose 7\n        \"analytics.reporting.content_performance\",  # Purpose 8\n        \"functional.service.improve\",  # Purpose 10\n        \"essential.service.security\"  # Special Purpose 1\n        \"essential.fraud_detection\",  # Special Purpose 1\n        \"marketing.advertising.serving\",  # Special Purpose 2\n    ]:\n        # Includes Feature 3\n        PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"system_id\": system.id,\n                \"data_use\": data_use,\n                \"legal_basis_for_processing\": \"Legitimate interests\",\n                \"features\": [\n                    \"Identify devices based on information transmitted automatically\"\n                ],\n            },\n        )\n    return system\n", "from __future__ import annotations\n\nimport pytest\nfrom starlette.status import HTTP_200_OK, HTTP_201_CREATED, HTTP_403_FORBIDDEN\nfrom starlette.testclient import TestClient\n\nfrom fides.api.api.v1.endpoints.privacy_experience_config_endpoints import (\n    get_experience_config_or_error,\n)\nfrom fides.api.models.privacy_experience import (\n    BannerEnabled,\n    ComponentType,\n    PrivacyExperience,\n    PrivacyExperienceConfig,\n    PrivacyExperienceConfigHistory,\n)\nfrom fides.api.models.privacy_notice import PrivacyNoticeRegion\nfrom fides.common.api import scope_registry as scopes\nfrom fides.common.api.v1.urn_registry import EXPERIENCE_CONFIG, V1_URL_PREFIX\n\n\nclass TestGetExperienceConfigList:\n    @pytest.fixture(scope=\"function\")\n    def url(self) -> str:\n        return V1_URL_PREFIX + EXPERIENCE_CONFIG\n\n    def test_get_experience_config_unauthenticated(self, url, api_client):\n        resp = api_client.get(url)\n        assert resp.status_code == 401\n\n    def test_get_experience_config_wrong_scope(\n        self, url, api_client: TestClient, generate_auth_header\n    ):\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_NOTICE_READ])\n        resp = api_client.get(\n            url,\n            headers=auth_header,\n        )\n        assert resp.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"role,expected_status\",\n        [\n            (\"owner\", HTTP_200_OK),\n            (\"contributor\", HTTP_200_OK),\n            (\"viewer_and_approver\", HTTP_200_OK),\n            (\"viewer\", HTTP_200_OK),\n            (\"approver\", HTTP_403_FORBIDDEN),\n        ],\n    )\n    def test_get_experience_config_with_roles(\n        self,\n        role,\n        expected_status,\n        api_client: TestClient,\n        url,\n        generate_role_header,\n    ) -> None:\n        auth_header = generate_role_header(roles=[role])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == expected_status\n\n    @pytest.mark.usefixtures(\n        \"privacy_experience_privacy_center\", \"privacy_experience_overlay\"\n    )\n    def test_get_experience_config_list(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_privacy_center,\n        experience_config_overlay,\n    ) -> None:\n        unescape_header = {\"Unescape-Safestr\": \"true\"}\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(url, headers={**auth_header, **unescape_header})\n        assert response.status_code == 200\n        resp = response.json()\n        assert (\n            resp[\"total\"] == 5\n        )  # Three default configs loaded on startup plus two here\n        assert resp[\"page\"] == 1\n        assert resp[\"size\"] == 50\n        data = resp[\"items\"]\n        assert len(data) == 5\n\n        first_config = data[0]\n        assert first_config[\"id\"] == experience_config_overlay.id\n        assert first_config[\"component\"] == \"overlay\"\n        assert first_config[\"banner_enabled\"] == \"enabled_where_required\"\n        assert first_config[\"disabled\"] is False\n        assert first_config[\"regions\"] == [\"us_ca\"]\n        assert first_config[\"version\"] == 1.0\n        assert first_config[\"created_at\"] is not None\n        assert first_config[\"updated_at\"] is not None\n        assert (\n            first_config[\"experience_config_history_id\"]\n            == experience_config_overlay.experience_config_history_id\n        )\n\n        second_config = data[1]\n        assert second_config[\"id\"] == experience_config_privacy_center.id\n        assert (\n            second_config[\"description\"] == \"user's description <script />\"\n        )  # Unescaped due to header\n        assert second_config[\"component\"] == \"privacy_center\"\n        assert second_config[\"banner_enabled\"] is None\n        assert second_config[\"disabled\"] is True\n        assert second_config[\"regions\"] == [\"us_co\"]\n        assert second_config[\"created_at\"] is not None\n        assert second_config[\"updated_at\"] is not None\n        assert second_config[\"version\"] == 1.0\n        assert (\n            second_config[\"experience_config_history_id\"]\n            == experience_config_privacy_center.experience_config_history_id\n        )\n\n        third_config = data[2]\n        assert third_config[\"id\"] == \"a4974670-abad-471f-9084-2cb-tcf-over\"\n        assert third_config[\"is_default\"] is True\n        assert third_config[\"component\"] == \"tcf_overlay\"\n        assert third_config[\"regions\"] == []\n        assert third_config[\"version\"] == 1.0\n        assert third_config[\"created_at\"] is not None\n        assert third_config[\"updated_at\"] is not None\n\n        fourth_config = data[3]\n        assert fourth_config[\"id\"] == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n        assert fourth_config[\"is_default\"] is True\n        assert fourth_config[\"component\"] == \"privacy_center\"\n        assert fourth_config[\"regions\"] == []\n        assert fourth_config[\"version\"] == 1.0\n        assert fourth_config[\"created_at\"] is not None\n        assert fourth_config[\"updated_at\"] is not None\n\n        fifth_config = data[4]\n        assert fifth_config[\"id\"] == \"pri-7ae3-f06b-4096-970f-0bbbdef-over\"\n        assert fifth_config[\"is_default\"] is True\n        assert fifth_config[\"disabled\"] is False\n        assert fifth_config[\"regions\"] == []\n        assert fifth_config[\"component\"] == \"overlay\"\n\n    @pytest.mark.usefixtures(\n        \"privacy_experience_privacy_center\",\n        \"privacy_experience_overlay\",\n        \"experience_config_overlay\",\n    )\n    def test_get_experience_config_list_no_unescape_header(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_privacy_center,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        resp = response.json()[\"items\"]\n\n        second_config = resp[1]\n        assert second_config[\"id\"] == experience_config_privacy_center.id\n        assert (\n            second_config[\"description\"] == \"user&#x27;s description &lt;script /&gt;\"\n        )  # Still escaped\n\n    @pytest.mark.usefixtures(\n        \"privacy_experience_overlay\",\n        \"privacy_experience_privacy_center\",\n        \"experience_config_privacy_center\",\n    )\n    def test_get_experience_config_show_disabled_false_filter(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_overlay,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(\n            url + \"?show_disabled=False\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()\n        assert resp[\"total\"] == 4\n        assert resp[\"page\"] == 1\n        assert resp[\"size\"] == 50\n        data = resp[\"items\"]\n        assert len(data) == 4\n\n        config = data[0]\n        assert config[\"id\"] == experience_config_overlay.id\n        assert config[\"component\"] == \"overlay\"\n        assert config[\"disabled\"] is False\n        assert config[\"regions\"] == [\"us_ca\"]\n        assert config[\"version\"] == 1.0\n        assert config[\"created_at\"] is not None\n        assert config[\"updated_at\"] is not None\n        assert (\n            config[\"experience_config_history_id\"]\n            == experience_config_overlay.experience_config_history_id\n        )\n\n        second_config = data[1]\n        assert second_config[\"id\"] == \"a4974670-abad-471f-9084-2cb-tcf-over\"\n        assert second_config[\"is_default\"] is True\n        assert second_config[\"component\"] == \"tcf_overlay\"\n        assert second_config[\"disabled\"] is False\n        assert second_config[\"version\"] == 1.0\n        assert second_config[\"created_at\"] is not None\n        assert second_config[\"updated_at\"] is not None\n\n        third_config = data[2]\n        assert third_config[\"id\"] == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n        assert third_config[\"is_default\"] is True\n        assert third_config[\"component\"] == \"privacy_center\"\n        assert third_config[\"disabled\"] is False\n        assert third_config[\"version\"] == 1.0\n        assert third_config[\"created_at\"] is not None\n        assert third_config[\"updated_at\"] is not None\n\n        fourth_config = data[3]\n        assert fourth_config[\"id\"] == \"pri-7ae3-f06b-4096-970f-0bbbdef-over\"\n        assert fourth_config[\"is_default\"] is True\n        assert fourth_config[\"disabled\"] is False\n        assert fourth_config[\"regions\"] == []\n        assert fourth_config[\"component\"] == \"overlay\"\n\n    @pytest.mark.usefixtures(\n        \"privacy_experience_overlay\",\n        \"experience_config_privacy_center\",\n    )\n    def test_get_experience_config_region_filter(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_overlay,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(\n            url + \"?region=us_ca\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()\n        assert resp[\"total\"] == 1\n        assert resp[\"page\"] == 1\n        assert resp[\"size\"] == 50\n        data = resp[\"items\"]\n        assert len(data) == 1\n\n        first_config = data[0]\n        assert first_config[\"id\"] == experience_config_overlay.id\n        assert first_config[\"regions\"] == [\"us_ca\"]\n        assert first_config[\"version\"] == 1.0\n        assert first_config[\"created_at\"] is not None\n        assert first_config[\"updated_at\"] is not None\n        assert (\n            first_config[\"experience_config_history_id\"]\n            == experience_config_overlay.experience_config_history_id\n        )\n\n    def test_get_experience_config_component_filter(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_overlay,\n        experience_config_privacy_center,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(\n            url + \"?component=overlay\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()\n        assert resp[\"total\"] == 2\n        assert resp[\"page\"] == 1\n        assert resp[\"size\"] == 50\n        data = resp[\"items\"]\n        assert len(data) == 2\n\n        assert data[0][\"id\"] == experience_config_overlay.id\n        assert data[1][\"id\"] == \"pri-7ae3-f06b-4096-970f-0bbbdef-over\"\n\n        response = api_client.get(\n            url + \"?component=privacy_center\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()\n        assert resp[\"total\"] == 2\n        assert resp[\"page\"] == 1\n        assert resp[\"size\"] == 50\n        data = resp[\"items\"]\n        assert len(data) == 2\n\n        assert data[0][\"id\"] == experience_config_privacy_center.id\n        assert data[1][\"id\"] == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n\n\nclass TestCreateExperienceConfig:\n    @pytest.fixture(scope=\"function\")\n    def url(self) -> str:\n        return V1_URL_PREFIX + EXPERIENCE_CONFIG\n\n    @pytest.fixture(scope=\"function\")\n    def overlay_experience_request_body(self) -> dict:\n        return {\n            \"acknowledge_button_label\": \"Confirm\",\n            \"banner_enabled\": \"enabled_where_required\",\n            \"component\": \"overlay\",\n            \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n            \"accept_button_label\": \"Accept all\",\n            \"disabled\": False,\n            \"privacy_preferences_link_label\": \"Manage preferences\",\n            \"privacy_policy_link_label\": \"View our privacy policy\",\n            \"privacy_policy_url\": \"example.com/privacy\",\n            \"reject_button_label\": \"Reject all\",\n            \"regions\": [],\n            \"save_button_label\": \"Save\",\n            \"title\": \"Control your privacy\",\n        }\n\n    def test_create_experience_config_unauthenticated(self, url, api_client):\n        resp = api_client.post(url)\n        assert resp.status_code == 401\n\n    def test_create_experience_config_wrong_scope(\n        self, url, api_client: TestClient, generate_auth_header\n    ):\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        resp = api_client.post(\n            url,\n            headers=auth_header,\n        )\n        assert resp.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"role,expected_status\",\n        [\n            (\"owner\", HTTP_201_CREATED),\n            (\"contributor\", HTTP_201_CREATED),\n            (\"viewer_and_approver\", HTTP_403_FORBIDDEN),\n            (\"viewer\", HTTP_403_FORBIDDEN),\n            (\"approver\", HTTP_403_FORBIDDEN),\n        ],\n    )\n    def test_create_experience_config_with_roles(\n        self,\n        role,\n        expected_status,\n        api_client: TestClient,\n        url,\n        generate_role_header,\n        overlay_experience_request_body,\n    ) -> None:\n        auth_header = generate_role_header(roles=[role])\n        response = api_client.post(\n            url, json=overlay_experience_request_body, headers=auth_header\n        )\n        assert response.status_code == expected_status\n\n    def test_create_overlay_config_missing_details(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Accept\",\n                \"description\": \"We care about your privacy\",\n                \"component\": \"overlay\",\n                \"regions\": [\"it\"],\n                \"reject_button_label\": \"Reject\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Manage your privacy\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"The following additional fields are required when defining an overlay: acknowledge_button_label, banner_enabled, and privacy_preferences_link_label.\"\n        )\n\n    def test_create_privacy_center_config_missing_details(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Accept\",\n                \"description\": \"We care about your privacy\",\n                \"component\": \"privacy_center\",\n                \"regions\": [\"it\"],\n                \"save_button_label\": \"Save\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert response.json()[\"detail\"][0][\"msg\"] == \"field required\"\n\n    def test_create_experience_duplicate_regions(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Accept all\",\n                \"description\": \"We care about your privacy\",\n                \"component\": \"privacy_center\",\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n                \"regions\": [\"it\", \"it\"],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert response.json()[\"detail\"][0][\"msg\"] == \"Duplicate regions found.\"\n\n    def test_create_another_default_experience_config(\n        self, api_client: TestClient, url, generate_auth_header, db\n    ) -> None:\n        \"\"\"We have defaults loaded in at startup so don't allow other defaults to be created here\"\"\"\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Yes\",\n                \"banner_enabled\": \"always_disabled\",\n                \"component\": \"privacy_center\",\n                \"description\": \"We take your privacy seriously\",\n                \"is_default\": True,\n                \"privacy_policy_link_label\": \"Manage your privacy\",\n                \"privacy_policy_url\": \"example.com/privacy\",\n                \"reject_button_label\": \"No\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Manage your privacy\",\n            },\n            headers=auth_header,\n        )\n\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"]\n            == \"Cannot set as the default. Only one default privacy_center config can be in the system.\"\n        )\n\n    def test_create_experience_config_with_no_regions(\n        self, api_client: TestClient, url, generate_auth_header, db\n    ) -> None:\n        \"\"\"Experience config can be defined without any regions specified. This is handy for defining default experiences\n\n        No privacy experiences are affected here.  But ExperienceConfig and ExperienceConfigHistory records are created.\n        \"\"\"\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Yes\",\n                \"banner_enabled\": \"always_disabled\",\n                \"component\": \"privacy_center\",\n                \"description\": \"We take your company's privacy seriously\",\n                \"privacy_policy_link_label\": \"Manage your privacy\",\n                \"privacy_policy_url\": \"example.com/privacy\",\n                \"reject_button_label\": \"No\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Manage your privacy\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 201\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"accept_button_label\"] == \"Yes\"\n        assert resp[\"banner_enabled\"] == \"always_disabled\"\n        assert resp[\"component\"] == \"privacy_center\"\n        assert (\n            resp[\"description\"] == \"We take your company's privacy seriously\"\n        )  # Returned in the response, unescaped, for display\n        assert resp[\"privacy_policy_link_label\"] == \"Manage your privacy\"\n        assert resp[\"privacy_policy_url\"] == \"example.com/privacy\"\n        assert resp[\"regions\"] == []\n        assert resp[\"reject_button_label\"] == \"No\"\n        assert resp[\"save_button_label\"] == \"Save\"\n        assert resp[\"title\"] == \"Manage your privacy\"\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"version\"] == 1.0\n\n        experience_config = get_experience_config_or_error(db, resp[\"id\"])\n        assert experience_config.component == ComponentType.privacy_center\n        assert experience_config.privacy_policy_link_label == \"Manage your privacy\"\n        assert experience_config.experiences.all() == []\n        assert experience_config.histories.count() == 1\n        assert (\n            experience_config.description\n            == \"We take your company&#x27;s privacy seriously\"\n        )  # Saved in the db escaped\n        history = experience_config.histories[0]\n        assert history.version == 1.0\n        assert history.component == ComponentType.privacy_center\n        assert history.privacy_policy_link_label == \"Manage your privacy\"\n        assert history.experience_config_id == experience_config.id\n\n        assert response.json()[\"linked_regions\"] == []\n        assert response.json()[\"unlinked_regions\"] == []\n\n        history.delete(db)\n        experience_config.delete(db)\n\n    def test_create_experience_config_with_empty_regions(\n        self, api_client: TestClient, url, generate_auth_header, db\n    ) -> None:\n        \"\"\"Experience config can be defined without any regions specified. This is handy for defining default experiences\n\n        No privacy experiences are affected here.  But ExperienceConfig and ExperienceConfigHistory records are created.\n        \"\"\"\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Yes\",\n                \"banner_enabled\": \"always_disabled\",\n                \"component\": \"privacy_center\",\n                \"description\": \"We take your privacy seriously\",\n                \"privacy_policy_link_label\": \"Manage your privacy\",\n                \"privacy_policy_url\": \"example.com/privacy\",\n                \"regions\": [],\n                \"reject_button_label\": \"No\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Manage your privacy\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 201\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"accept_button_label\"] == \"Yes\"\n        assert resp[\"banner_enabled\"] == \"always_disabled\"\n        assert resp[\"component\"] == \"privacy_center\"\n        assert resp[\"description\"] == \"We take your privacy seriously\"\n        assert resp[\"privacy_policy_link_label\"] == \"Manage your privacy\"\n        assert resp[\"privacy_policy_url\"] == \"example.com/privacy\"\n        assert resp[\"regions\"] == []\n        assert resp[\"reject_button_label\"] == \"No\"\n        assert resp[\"save_button_label\"] == \"Save\"\n        assert resp[\"title\"] == \"Manage your privacy\"\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"version\"] == 1.0\n\n        experience_config = get_experience_config_or_error(db, resp[\"id\"])\n        assert experience_config.component == ComponentType.privacy_center\n        assert experience_config.privacy_policy_link_label == \"Manage your privacy\"\n        assert experience_config.experiences.all() == []\n        assert experience_config.histories.count() == 1\n        history = experience_config.histories[0]\n        assert history.version == 1.0\n        assert history.component == ComponentType.privacy_center\n        assert history.privacy_policy_link_label == \"Manage your privacy\"\n        assert history.experience_config_id == experience_config.id\n\n        assert response.json()[\"linked_regions\"] == []\n        assert response.json()[\"unlinked_regions\"] == []\n\n        history.delete(db)\n        experience_config.delete(db)\n\n    def test_create_experience_config_no_existing_experiences(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n    ) -> None:\n        \"\"\"\n        Specifying a NY region to be used with the new ExperienceConfig will\n        cause a NY PrivacyExperience to be created behind the scenes if one doesn't exist.\n        \"\"\"\n\n        assert (\n            PrivacyExperience.get_experience_by_region_and_component(\n                db, PrivacyNoticeRegion.us_ny, ComponentType.overlay\n            )\n            is None\n        )\n\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Accept all\",\n                \"acknowledge_button_label\": \"Confirm\",\n                \"banner_enabled\": \"enabled_where_required\",\n                \"component\": \"overlay\",\n                \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n                \"privacy_preferences_link_label\": \"Control your privacy\",\n                \"privacy_policy_link_label\": \"Control your privacy\",\n                \"privacy_policy_url\": \"example.com/privacy\",\n                \"regions\": [\"us_ny\"],\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 201\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"accept_button_label\"] == \"Accept all\"\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"created_at\"] is not None\n        assert (\n            resp[\"description\"]\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert resp[\"privacy_preferences_link_label\"] == \"Control your privacy\"\n        assert resp[\"privacy_policy_link_label\"] == \"Control your privacy\"\n        assert resp[\"privacy_policy_url\"] == \"example.com/privacy\"\n        assert resp[\"regions\"] == [\"us_ny\"]\n        assert resp[\"reject_button_label\"] == \"Reject all\"\n        assert resp[\"save_button_label\"] == \"Save\"\n        assert resp[\"title\"] == \"Control your privacy\"\n        assert resp[\"version\"] == 1.0\n        assert resp[\"updated_at\"] is not None\n\n        # Created Experience Config\n        experience_config = get_experience_config_or_error(db, resp[\"id\"])\n        assert experience_config.accept_button_label == \"Accept all\"\n        assert experience_config.acknowledge_button_label == \"Confirm\"\n        assert experience_config.banner_enabled == BannerEnabled.enabled_where_required\n        assert experience_config.component == ComponentType.overlay\n        assert (\n            experience_config.description\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert (\n            experience_config.privacy_preferences_link_label == \"Control your privacy\"\n        )\n        assert experience_config.privacy_policy_link_label == \"Control your privacy\"\n        assert experience_config.privacy_policy_url == \"example.com/privacy\"\n        assert experience_config.regions == [PrivacyNoticeRegion.us_ny]\n        assert experience_config.reject_button_label == \"Reject all\"\n        assert experience_config.save_button_label == \"Save\"\n        assert experience_config.title == \"Control your privacy\"\n\n        assert experience_config.created_at is not None\n        assert experience_config.updated_at is not None\n        assert experience_config.histories.count() == 1\n\n        # Created Experience Config History\n        experience_config_history = experience_config.histories[0]\n        assert experience_config_history.version == 1.0\n\n        assert experience_config_history.accept_button_label == \"Accept all\"\n        assert experience_config_history.acknowledge_button_label == \"Confirm\"\n        assert (\n            experience_config_history.banner_enabled\n            == BannerEnabled.enabled_where_required\n        )\n        assert experience_config_history.component == ComponentType.overlay\n        assert (\n            experience_config_history.description\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert (\n            experience_config_history.privacy_preferences_link_label\n            == \"Control your privacy\"\n        )\n        assert (\n            experience_config_history.privacy_policy_link_label\n            == \"Control your privacy\"\n        )\n        assert experience_config_history.privacy_policy_url == \"example.com/privacy\"\n        assert experience_config_history.reject_button_label == \"Reject all\"\n        assert experience_config_history.save_button_label == \"Save\"\n        assert experience_config_history.title == \"Control your privacy\"\n\n        assert experience_config_history.created_at is not None\n        assert experience_config_history.updated_at is not None\n        assert experience_config_history.experience_config_id == experience_config.id\n\n        # Created Privacy Experience\n        assert experience_config.experiences.count() == 1\n        experience = experience_config.experiences[0]\n        assert experience.region == PrivacyNoticeRegion.us_ny\n        assert experience.component == ComponentType.overlay\n        assert experience.experience_config_id == experience_config.id\n\n        experience.delete(db)\n        experience_config_history.delete(db)\n        experience_config.delete(db)\n\n        assert response.json()[\"linked_regions\"] == [\"us_ny\"]\n        assert response.json()[\"unlinked_regions\"] == []\n\n    def test_create_experience_config_existing_experiences(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n    ) -> None:\n        \"\"\"\n        Specifying a TX region to be used with the new ExperienceConfig can\n        cause an existing TX PrivacyExperience to be linked to the current ExperienceConfig\n        \"\"\"\n\n        privacy_experience = PrivacyExperience.create(\n            db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": PrivacyNoticeRegion.us_tx,\n            },\n        )\n\n        assert privacy_experience.experience_config_id is None\n\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Accept all\",\n                \"acknowledge_button_label\": \"Confirm\",\n                \"banner_enabled\": \"enabled_where_required\",\n                \"component\": \"overlay\",\n                \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n                \"privacy_preferences_link_label\": \"Control your privacy\",\n                \"privacy_policy_link_label\": \"Control your privacy\",\n                \"privacy_policy_url\": \"example.com/privacy\",\n                \"regions\": [\"us_tx\"],\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 201\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"accept_button_label\"] == \"Accept all\"\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"created_at\"] is not None\n        assert (\n            resp[\"description\"]\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert resp[\"privacy_preferences_link_label\"] == \"Control your privacy\"\n        assert resp[\"privacy_policy_link_label\"] == \"Control your privacy\"\n        assert resp[\"privacy_policy_url\"] == \"example.com/privacy\"\n        assert resp[\"regions\"] == [\"us_tx\"]\n        assert resp[\"reject_button_label\"] == \"Reject all\"\n        assert resp[\"save_button_label\"] == \"Save\"\n        assert resp[\"title\"] == \"Control your privacy\"\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"version\"] == 1.0\n\n        # Created Experience Config\n        experience_config = get_experience_config_or_error(db, resp[\"id\"])\n        assert experience_config.histories.count() == 1\n\n        # Created Experience Config History\n        experience_config_history = experience_config.histories[0]\n        assert experience_config_history.version == 1.0\n        assert experience_config_history.component == ComponentType.overlay\n        assert (\n            experience_config_history.banner_enabled\n            == BannerEnabled.enabled_where_required\n        )\n        assert experience_config_history.experience_config_id == experience_config.id\n\n        # Updated Privacy Experience - TX Privacy Experience automatically linked\n        assert experience_config.experiences.count() == 1\n        experience = experience_config.experiences[0]\n        db.refresh(experience)\n        assert (\n            experience == privacy_experience\n        )  # Linked experience is the same Texas experience from above\n        assert experience.region == PrivacyNoticeRegion.us_tx\n        assert experience.component == ComponentType.overlay\n        assert experience.experience_config_id == experience_config.id\n\n        assert response.json()[\"linked_regions\"] == [\"us_tx\"]\n        assert response.json()[\"unlinked_regions\"] == []\n\n        experience.delete(db)\n        experience_config_history.delete(db)\n        experience_config.delete(db)\n\n\nclass TestGetExperienceConfigDetail:\n    @pytest.fixture(scope=\"function\")\n    def url(self, experience_config_overlay) -> str:\n        return V1_URL_PREFIX + EXPERIENCE_CONFIG + f\"/{experience_config_overlay.id}\"\n\n    def test_get_experience_config_detail_unauthenticated(self, url, api_client):\n        resp = api_client.get(url)\n        assert resp.status_code == 401\n\n    def test_get_experience_config_detail_wrong_scope(\n        self, url, api_client: TestClient, generate_auth_header\n    ):\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_NOTICE_READ])\n        resp = api_client.get(\n            url,\n            headers=auth_header,\n        )\n        assert resp.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"role,expected_status\",\n        [\n            (\"owner\", HTTP_200_OK),\n            (\"contributor\", HTTP_200_OK),\n            (\"viewer_and_approver\", HTTP_200_OK),\n            (\"viewer\", HTTP_200_OK),\n            (\"approver\", HTTP_403_FORBIDDEN),\n        ],\n    )\n    def test_get_experience_config_detail_with_roles(\n        self,\n        role,\n        expected_status,\n        api_client: TestClient,\n        url,\n        generate_role_header,\n    ) -> None:\n        auth_header = generate_role_header(roles=[role])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == expected_status\n\n    def test_get_bad_experience_config_detail(\n        self,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        url = V1_URL_PREFIX + EXPERIENCE_CONFIG + \"/bad_id\"\n\n        response = api_client.get(\n            url,\n            headers=auth_header,\n        )\n        assert response.status_code == 404\n        assert (\n            response.json()[\"detail\"]\n            == \"No Privacy Experience Config found for id 'bad_id'.\"\n        )\n\n    @pytest.mark.usefixtures(\n        \"privacy_experience_overlay\",\n    )\n    def test_get_experience_config_detail(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_overlay,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(\n            url,\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()\n\n        assert resp[\"id\"] == experience_config_overlay.id\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"disabled\"] is False\n        assert resp[\"regions\"] == [\"us_ca\"]\n        assert resp[\"version\"] == 1.0\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert (\n            resp[\"experience_config_history_id\"]\n            == experience_config_overlay.experience_config_history_id\n        )\n        assert resp[\"title\"] == \"Manage your consent\"\n        assert (\n            resp[\"privacy_policy_link_label\"]\n            == \"View our company&#x27;s privacy policy\"\n        )  # Escaped without request header\n\n    @pytest.mark.usefixtures(\n        \"privacy_experience_overlay\",\n    )\n    def test_get_experience_config_detail_with_unescape_header(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_overlay,\n    ) -> None:\n        unescape_header = {\"Unescape-Safestr\": \"true\"}\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(url, headers={**auth_header, **unescape_header})\n        assert response.status_code == 200\n        resp = response.json()\n\n        assert resp[\"id\"] == experience_config_overlay.id\n        assert resp[\"component\"] == \"overlay\"\n        assert (\n            resp[\"privacy_policy_link_label\"] == \"View our company's privacy policy\"\n        )  # Unescaped with request header\n\n\nclass TestUpdateExperienceConfig:\n    @pytest.fixture(scope=\"function\")\n    def url(self, overlay_experience_config) -> str:\n        return V1_URL_PREFIX + EXPERIENCE_CONFIG + f\"/{overlay_experience_config.id}\"\n\n    @pytest.fixture(scope=\"function\")\n    def overlay_experience_config(self, db) -> PrivacyExperienceConfig:\n        exp = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"accept_button_label\": \"Accept all\",\n                \"acknowledge_button_label\": \"Confirm\",\n                \"banner_enabled\": \"enabled_where_required\",\n                \"component\": \"overlay\",\n                \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n                \"disabled\": False,\n                \"privacy_preferences_link_label\": \"Manage preferences\",\n                \"privacy_policy_link_label\": \"View our privacy policy\",\n                \"privacy_policy_url\": \"example.com/privacy\",\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n        yield exp\n        for history in exp.histories:\n            history.delete(db)\n        exp.delete(db)\n\n    def test_update_experience_config_unauthenticated(self, url, api_client):\n        resp = api_client.patch(url, json={\"disabled\": True})\n        assert resp.status_code == 401\n\n    def test_update_experience_config_wrong_scope(\n        self, url, api_client: TestClient, generate_auth_header\n    ):\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        resp = api_client.patch(\n            url,\n            headers=auth_header,\n        )\n        assert resp.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"role,expected_status\",\n        [\n            (\"owner\", HTTP_200_OK),\n            (\"contributor\", HTTP_200_OK),\n            (\"viewer_and_approver\", HTTP_403_FORBIDDEN),\n            (\"viewer\", HTTP_403_FORBIDDEN),\n            (\"approver\", HTTP_403_FORBIDDEN),\n        ],\n    )\n    def test_update_experience_config_with_roles(\n        self,\n        role,\n        expected_status,\n        api_client: TestClient,\n        url,\n        generate_role_header,\n    ) -> None:\n        auth_header = generate_role_header(roles=[role])\n        response = api_client.patch(\n            url, json={\"disabled\": True, \"regions\": []}, headers=auth_header\n        )\n        assert response.status_code == expected_status\n\n    def test_update_experience_config_duplicate_regions(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        \"\"\"Failing if duplicate regions in request to avoid unexpected behavior\"\"\"\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\n                \"title\": \"We care about your privacy\",\n                \"regions\": [\"us_ca\", \"us_ca\"],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert response.json()[\"detail\"][0][\"msg\"] == \"Duplicate regions found.\"\n\n    def test_update_bad_experience_config(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        \"\"\"Nonexistent experience config id\"\"\"\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            V1_URL_PREFIX + EXPERIENCE_CONFIG + \"/bad_experience_id\",\n            json={\n                \"title\": \"We care about your privacy\",\n                \"regions\": [\"us_ca\"],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 404\n        assert (\n            response.json()[\"detail\"]\n            == \"No Privacy Experience Config found for id 'bad_experience_id'.\"\n        )\n\n    def test_update_overlay_experience_config_missing_details(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\"title\": None},\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert response.json()[\"detail\"][0][\"msg\"] == \"none is not an allowed value\"\n\n    def test_update_overlay_experience_config_missing_overlay_specific_fields(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n\n        response = api_client.patch(\n            url,\n            json={\n                \"privacy_preferences_link_label\": \"\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"The following additional fields are required when defining an overlay: acknowledge_button_label, banner_enabled, and privacy_preferences_link_label.\"\n        )\n\n    def test_update_as_default(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        overlay_experience_config,\n    ):\n        \"\"\"We already have a default overlay added to the system on startup, so we don't\n        want to update this separate overlay to be a default\"\"\"\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\n                \"is_default\": True,\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"]\n            == \"Cannot set as the default. Only one default overlay config can be in the system.\"\n        )\n\n    def test_update_experience_config_with_fields_that_should_be_escaped(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        overlay_experience_config,\n        db,\n    ) -> None:\n        \"\"\"Failing if duplicate regions in request to avoid unexpected behavior\"\"\"\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\n                \"title\": \"We care about you and your family's privacy\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert (\n            response.json()[\"experience_config\"][\"title\"]\n            == \"We care about you and your family's privacy\"\n        )  # Unescaped in response\n        db.refresh(overlay_experience_config)\n        assert (\n            overlay_experience_config.title\n            == \"We care about you and your family&#x27;s privacy\"\n        )  # But stored escaped\n\n    def test_attempt_to_update_component_type(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        \"\"\"Component type can't be edited once created\"\"\"\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n\n        response = api_client.patch(\n            url,\n            json={\n                \"component\": \"privacy_center\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert response.json()[\"detail\"][0][\"msg\"] == \"extra fields not permitted\"\n\n    def test_update_experience_config_while_ignoring_regions(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n        experience_config_overlay,\n        privacy_experience_overlay,\n    ) -> None:\n        \"\"\"We need to currently support editing experience configs without the regions.  If \"regions\" is None,\n        I don't edit regions at all. If \"regions\" are an empty list, they are all removed.\n        \"\"\"\n        assert experience_config_overlay.disabled is False\n        assert experience_config_overlay.regions == [PrivacyNoticeRegion.us_ca]\n\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            V1_URL_PREFIX + EXPERIENCE_CONFIG + f\"/{experience_config_overlay.id}\",\n            json={\n                \"disabled\": True,\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"disabled\"] is True\n        assert resp[\"regions\"] == [\"us_ca\"]  # Main thing, regions weren't touched!\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"disabled\"] is True\n        assert resp[\"version\"] == 2.0\n\n        experience_config = get_experience_config_or_error(db, resp[\"id\"])\n        assert experience_config.experiences.all() == [privacy_experience_overlay]\n        assert experience_config.histories.count() == 2\n        history = experience_config.histories.order_by(\n            PrivacyExperienceConfigHistory.created_at\n        )[0]\n        assert history.version == 1.0\n        assert history.component == ComponentType.overlay\n        assert history.banner_enabled == BannerEnabled.enabled_where_required\n        assert history.experience_config_id == experience_config.id\n        assert history.disabled is False\n\n        history = experience_config.histories.order_by(\n            PrivacyExperienceConfigHistory.created_at\n        )[1]\n        assert history.version == 2.0\n        assert history.disabled is True\n\n        assert response.json()[\"linked_regions\"] == []\n        assert response.json()[\"unlinked_regions\"] == []\n\n        privacy_experience_overlay.delete(db)\n\n        for history in experience_config.histories:\n            history.delete(db)\n        experience_config.delete(db)\n\n    def test_update_experience_config_with_no_regions(\n        self, api_client: TestClient, url, generate_auth_header, db\n    ) -> None:\n        \"\"\"Test scenario where experience config has no regions and we make updates without any regions being\n        involved.  Specifically disabling the ExperienceConfig\n        \"\"\"\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\n                \"disabled\": True,\n                \"regions\": [],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"title\"] == \"Control your privacy\"\n        assert (\n            resp[\"description\"]\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert resp[\"accept_button_label\"] == \"Accept all\"\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"reject_button_label\"] == \"Reject all\"\n        assert resp[\"regions\"] == []\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"disabled\"] is True\n        assert resp[\"version\"] == 2.0\n\n        experience_config = get_experience_config_or_error(db, resp[\"id\"])\n        assert experience_config.experiences.all() == []\n        assert experience_config.histories.count() == 2\n        history = experience_config.histories.order_by(\n            PrivacyExperienceConfigHistory.created_at\n        )[0]\n        assert history.version == 1.0\n        assert history.component == ComponentType.overlay\n        assert history.banner_enabled == BannerEnabled.enabled_where_required\n        assert history.experience_config_id == experience_config.id\n        assert history.disabled is False\n\n        history = experience_config.histories.order_by(\n            PrivacyExperienceConfigHistory.created_at\n        )[1]\n        assert history.version == 2.0\n        assert history.disabled is True\n\n        assert response.json()[\"linked_regions\"] == []\n        assert response.json()[\"unlinked_regions\"] == []\n\n        for history in experience_config.histories:\n            history.delete(db)\n        experience_config.delete(db)\n\n    def test_update_experience_config_no_existing_experiences(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n        overlay_experience_config,\n    ) -> None:\n        \"\"\"\n        This action is updating an existing ExperienceConfig to add NY.  NY does not have a PrivacyExperience\n        yet, so one will be created for it.\n        \"\"\"\n\n        assert (\n            PrivacyExperience.get_experience_by_region_and_component(\n                db, PrivacyNoticeRegion.us_ny, ComponentType.overlay\n            )\n            is None\n        )\n\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\"regions\": [\"us_ny\"]},\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"title\"] == \"Control your privacy\"\n        assert (\n            resp[\"description\"]\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert resp[\"accept_button_label\"] == \"Accept all\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"reject_button_label\"] == \"Reject all\"\n        assert resp[\"regions\"] == [\"us_ny\"]\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"version\"] == 1.0\n\n        # ExperienceConfig specifically wasn't updated, as this change is only changing which regions link here as FK\n        db.refresh(overlay_experience_config)\n        assert overlay_experience_config.id == resp[\"id\"]\n        assert overlay_experience_config.histories.count() == 1\n\n        # Existing Experience Config History\n        experience_config_history = overlay_experience_config.histories[0]\n        assert experience_config_history.version == 1.0\n        assert experience_config_history.component == ComponentType.overlay\n        assert (\n            experience_config_history.experience_config_id\n            == overlay_experience_config.id\n        )\n\n        # Created Privacy Experience\n        assert overlay_experience_config.experiences.count() == 1\n        experience = overlay_experience_config.experiences[0]\n        assert experience.region == PrivacyNoticeRegion.us_ny\n        assert experience.component == ComponentType.overlay\n        assert experience.experience_config_id == overlay_experience_config.id\n\n        experience.delete(db)\n\n        assert response.json()[\"linked_regions\"] == [\"us_ny\"]\n        assert response.json()[\"unlinked_regions\"] == []\n\n    def test_update_experience_config_regions_to_overlap_on_existing_experiences(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n        overlay_experience_config,\n    ) -> None:\n        \"\"\"\n        Existing ExperienceConfig is updated to add TX.  A Texas Privacy Experience already exists.\n\n        This should cause the existing Texas PrivacyExperience to be given a FK to the existing ExperienceConfig record\n        \"\"\"\n\n        privacy_experience = PrivacyExperience.create(\n            db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": PrivacyNoticeRegion.us_tx,\n            },\n        )\n\n        assert privacy_experience.experience_config_id is None\n\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\n                \"regions\": [\"us_tx\"],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"title\"] == \"Control your privacy\"\n        assert (\n            resp[\"description\"]\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert resp[\"accept_button_label\"] == \"Accept all\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"reject_button_label\"] == \"Reject all\"\n        assert resp[\"regions\"] == [\"us_tx\"]\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert (\n            resp[\"version\"] == 1.0\n        ), \"Version not bumped because config didn't change on ExperienceConfig\"\n\n        db.refresh(overlay_experience_config)\n        # Existing Experience Config History - no new version needed to be created\n        assert overlay_experience_config.histories.count() == 1\n        experience_config_history = overlay_experience_config.histories[0]\n        assert experience_config_history.version == 1.0\n        assert experience_config_history.component == ComponentType.overlay\n        assert (\n            experience_config_history.banner_enabled\n            == BannerEnabled.enabled_where_required\n        )\n        assert (\n            experience_config_history.experience_config_id\n            == overlay_experience_config.id\n        )\n\n        # Updated Privacy Experience - TX Privacy Experience automatically linked\n        assert overlay_experience_config.experiences.count() == 1\n        experience = overlay_experience_config.experiences[0]\n        db.refresh(experience)\n        assert (\n            experience == privacy_experience\n        )  # Linked experience is the same Texas experience from above\n        assert experience.region == PrivacyNoticeRegion.us_tx\n        assert experience.component == ComponentType.overlay\n        assert experience.experience_config_id == overlay_experience_config.id\n\n        assert response.json()[\"linked_regions\"] == [\"us_tx\"]\n        assert response.json()[\"unlinked_regions\"] == []\n\n        experience.delete(db)\n\n    def test_update_experience_config_experience_also_updated(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n        overlay_experience_config,\n    ) -> None:\n        \"\"\"\n        Verify that if the ExperienceConfig is updated, some of those updates are passed onto the PrivacyExperience record.\n\n        Existing ExperienceConfig is updated to add TX.  A Texas Privacy Experience already exists.\n        We are updating the existing ExperienceConfig simultaneously. So the TX PrivacyExperience will\n        be linked to the ExperienceConfig and also have select attributes from ExperienceConfig propagated back\n        \"\"\"\n\n        privacy_experience = PrivacyExperience.create(\n            db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": PrivacyNoticeRegion.us_tx,\n            },\n        )\n\n        assert privacy_experience.experience_config_id is None\n\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\"regions\": [\"us_tx\"], \"disabled\": True},\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"title\"] == \"Control your privacy\"\n        assert (\n            resp[\"description\"]\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert resp[\"accept_button_label\"] == \"Accept all\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"reject_button_label\"] == \"Reject all\"\n        assert resp[\"regions\"] == [\"us_tx\"]\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"disabled\"] is True\n        assert (\n            resp[\"version\"] == 2.0\n        ), \"Version bumped because we've disabled ExperienceConfig\"\n\n        db.refresh(overlay_experience_config)\n        # ExperienceConfig was disabled - this is a change, so another historical record is created\n        assert overlay_experience_config.histories.count() == 2\n        experience_config_history = overlay_experience_config.histories.order_by(\n            PrivacyExperienceConfigHistory.created_at\n        )[1]\n        assert experience_config_history.version == 2.0\n        assert experience_config_history.disabled\n        assert experience_config_history.component == ComponentType.overlay\n        assert (\n            experience_config_history.banner_enabled\n            == BannerEnabled.enabled_where_required\n        )\n        assert (\n            experience_config_history.experience_config_id\n            == overlay_experience_config.id\n        )\n\n        # Updated Privacy Experience - TX Privacy Experience automatically linked\n        assert overlay_experience_config.experiences.count() == 1\n        experience = overlay_experience_config.experiences[0]\n        db.refresh(experience)\n        assert (\n            experience == privacy_experience\n        )  # Linked experience is the same Texas experience from above\n        assert experience.region == PrivacyNoticeRegion.us_tx\n        assert experience.component == ComponentType.overlay\n        assert experience.experience_config_id == overlay_experience_config.id\n\n        assert response.json()[\"linked_regions\"] == [\"us_tx\"]\n        assert response.json()[\"unlinked_regions\"] == []\n\n        experience.delete(db)\n\n    def test_update_experience_config_to_remove_region(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n        overlay_experience_config,\n    ) -> None:\n        \"\"\"\n        Update the ExperienceConfig to remove a region. Verify this unlinks the region.\n        \"\"\"\n\n        privacy_experience = PrivacyExperience.create(\n            db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": PrivacyNoticeRegion.us_tx,\n                \"experience_config_id\": overlay_experience_config.id,\n            },\n        )\n\n        assert privacy_experience.experience_config_id == overlay_experience_config.id\n\n        db.refresh(overlay_experience_config)\n        assert overlay_experience_config.experiences.all() == [privacy_experience]\n\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\n                \"regions\": [],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()[\"experience_config\"]\n\n        assert (\n            resp[\"version\"] == 1.0\n        ), \"Version not bumped because config didn't change, only region removed\"\n        assert resp[\"regions\"] == []  # Main thing, regions were removed\n        assert response.json()[\"linked_regions\"] == []\n        assert response.json()[\"unlinked_regions\"] == [\"us_tx\"]\n\n        db.refresh(overlay_experience_config)\n        # ExperienceConfig was disabled - this is a change, so another historical record is created\n        assert overlay_experience_config.histories.count() == 1\n        experience_config_history = overlay_experience_config.histories[0]\n        assert experience_config_history.version == 1.0\n        assert experience_config_history.component == ComponentType.overlay\n        assert (\n            experience_config_history.experience_config_id\n            == overlay_experience_config.id\n        )\n\n        # Updated Privacy Experience - TX Privacy Experience automatically *unlinked*\n        assert overlay_experience_config.experiences.count() == 0\n        db.refresh(privacy_experience)\n\n        assert (\n            privacy_experience.experience_config_id\n            == \"pri-7ae3-f06b-4096-970f-0bbbdef-over\"\n        )  # Default overlay experience config linked instead\n\n        privacy_experience.delete(db)\n\n    @pytest.mark.usefixtures(\"privacy_experience_france_tcf_overlay\")\n    def test_add_regions_to_tcf_overlay(\n        self,\n        api_client: TestClient,\n        generate_auth_header,\n        experience_config_tcf_overlay,\n        db,\n    ) -> None:\n        \"\"\"Verify that regions can technically be added to the tcf overlay.\n\n        This is a contrived example, but tests that this workflow doesn't break for the new tcf overlay\n        \"\"\"\n        fr_experience = PrivacyExperience.get_experience_by_region_and_component(\n            db=db, region=\"fr\", component=ComponentType.tcf_overlay\n        )\n        assert fr_experience\n\n        ca_experience = PrivacyExperience.get_experience_by_region_and_component(\n            db=db, region=\"us_ca\", component=ComponentType.tcf_overlay\n        )\n        assert not ca_experience\n\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        url = V1_URL_PREFIX + EXPERIENCE_CONFIG + f\"/{experience_config_tcf_overlay.id}\"\n        response = api_client.patch(\n            url,\n            json={\n                \"regions\": [\"us_ca\", \"fr\"],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"experience_config\"][\"regions\"] == [\"fr\", \"us_ca\"]\n        assert response.json()[\"linked_regions\"] == [\"us_ca\"]\n\n        fr_experience = PrivacyExperience.get_experience_by_region_and_component(\n            db=db, region=\"fr\", component=ComponentType.tcf_overlay\n        )\n        assert fr_experience\n\n        ca_experience = PrivacyExperience.get_experience_by_region_and_component(\n            db=db, region=\"us_ca\", component=ComponentType.tcf_overlay\n        )\n        assert ca_experience\n", "from datetime import timedelta\nfrom unittest import mock\nfrom unittest.mock import MagicMock, patch\n\nimport pytest\nfrom sqlalchemy.orm import Session\nfrom starlette.status import HTTP_200_OK, HTTP_403_FORBIDDEN\nfrom starlette.testclient import TestClient\n\nfrom fides.api.models.privacy_preference import (\n    CURRENT_TCF_VERSION,\n    ConsentMethod,\n    CurrentPrivacyPreference,\n    PrivacyPreferenceHistory,\n    RequestOrigin,\n    UserConsentPreference,\n)\nfrom fides.api.models.privacy_request import (\n    ConsentRequest,\n    ExecutionLogStatus,\n    PrivacyRequestStatus,\n    ProvidedIdentity,\n)\nfrom fides.api.schemas.privacy_notice import PrivacyNoticeHistorySchema\nfrom fides.api.util.tcf.tcf_experience_contents import ConsentRecordType\nfrom fides.common.api.scope_registry import (\n    CONSENT_READ,\n    CURRENT_PRIVACY_PREFERENCE_READ,\n    PRIVACY_PREFERENCE_HISTORY_READ,\n)\nfrom fides.common.api.v1.urn_registry import (\n    CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY,\n    CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID,\n    CURRENT_PRIVACY_PREFERENCES_REPORT,\n    HISTORICAL_PRIVACY_PREFERENCES_REPORT,\n    PRIVACY_PREFERENCES,\n    V1_URL_PREFIX,\n)\nfrom fides.config import CONFIG\n\n\nclass TestSavePrivacyPreferencesPrivacyCenter:\n    @pytest.fixture(scope=\"function\")\n    def verification_code(self) -> str:\n        return \"abcd\"\n\n    @pytest.fixture(scope=\"function\")\n    def request_body(\n        self, privacy_notice, verification_code, consent_policy, served_notice_history\n    ):\n        return {\n            \"browser_identity\": {\"ga_client_id\": \"test\"},\n            \"code\": verification_code,\n            \"preferences\": [\n                {\n                    \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                    \"preference\": \"opt_out\",\n                    \"served_notice_history_id\": served_notice_history.id,\n                }\n            ],\n            \"policy_key\": consent_policy.key,\n            \"user_geography\": \"us_ca\",\n        }\n\n    @pytest.fixture(scope=\"function\")\n    def tcf_request_body(self, privacy_notice, verification_code, consent_policy):\n        return {\n            \"browser_identity\": {\"ga_client_id\": \"test\"},\n            \"code\": verification_code,\n            \"feature_preferences\": [\n                {\n                    \"id\": 1,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"policy_key\": consent_policy.key,\n            \"user_geography\": \"fr\",\n        }\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_save_privacy_preferences_no_consent_request_id(\n        self, api_client, request_body\n    ):\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id='non_existent_consent_id')}\",\n            json=request_body,\n        )\n        assert response.status_code == 404\n        assert \"not found\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_save_privacy_preferences_no_consent_code(\n        self, provided_identity_and_consent_request, api_client, privacy_notice\n    ):\n        _, consent_request = provided_identity_and_consent_request\n\n        data = {\n            \"browser_identity\": {\"ga_client_id\": \"test_ga_client_id\"},\n            \"code\": \"12345\",\n            \"preferences\": [\n                {\n                    \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"user_geography\": \"us_ca\",\n        }\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=data,\n        )\n        assert response.status_code == 400\n        assert \"code expired\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_set_privacy_preferences_invalid_code(\n        self,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        request_body,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"code\"] = \"non_matching_code\"\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 403\n        assert \"Incorrect identification\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\", \"automatically_approved\", \"system\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.privacy_preference_endpoints.anonymize_ip_address\"\n    )\n    def test_verify_then_set_privacy_preferences(\n        self,\n        mock_anonymize,\n        run_privacy_request_mock,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        db: Session,\n        request_body,\n        privacy_notice,\n    ):\n        \"\"\"Verify code, save, and then return privacy preferences\n        Privacy request also queued because a notice has system wide enforcement\n        \"\"\"\n        masked_ip = \"12.214.31.0\"  # Mocking because hostname for FastAPI TestClient is \"testclient\"\n        mock_anonymize.return_value = masked_ip\n\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        # Assert no existing privacy preferences exist for this identity\n        assert response.json() == {\n            \"items\": [],\n            \"total\": 0,\n            \"page\": 1,\n            \"pages\": 0,\n            \"size\": 50,\n        }\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"preferences\"]) == 1\n        assert response.json()[\"fides_mobile_data\"] is None\n\n        response_json = response.json()[\"preferences\"][0]\n        created_privacy_preference_history_id = response_json[\n            \"privacy_preference_history_id\"\n        ]\n        privacy_preference_history = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id == created_privacy_preference_history_id\n            )\n            .first()\n        )\n        assert response_json[\"preference\"] == \"opt_out\"\n\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n        db.refresh(consent_request)\n        assert consent_request.privacy_request_id\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        response_json = response.json()[\"items\"][0]\n        assert response_json[\"id\"] is not None\n        assert response_json[\"preference\"] == \"opt_out\"\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n\n        assert privacy_preference_history.privacy_request_id is not None\n        assert run_privacy_request_mock.called\n\n        privacy_preference_history.delete(db=db)\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\", \"automatically_approved\", \"system\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.privacy_preference_endpoints.anonymize_ip_address\"\n    )\n    def test_verify_then_set_privacy_preferences_but_no_privacy_request_created(\n        self,\n        mock_anonymize,\n        run_privacy_request_mock,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        db: Session,\n        privacy_notice_fr_provide_service_frontend_only,\n        privacy_experience_france_overlay,\n        consent_policy,\n    ):\n        \"\"\"Verify code, save, and then return privacy preferences\n        Privacy request not queued because no notice has system wide enforcement\n        \"\"\"\n        masked_ip = \"12.214.31.0\"  # Mocking because hostname for FastAPI TestClient is \"testclient\"\n        mock_anonymize.return_value = masked_ip\n\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        # Assert no existing privacy preferences exist for this identity\n        assert response.json() == {\n            \"items\": [],\n            \"total\": 0,\n            \"page\": 1,\n            \"pages\": 0,\n            \"size\": 50,\n        }\n\n        request_body = {\n            \"browser_identity\": {\"ga_client_id\": \"test\"},\n            \"code\": verification_code,\n            \"preferences\": [\n                {\n                    \"privacy_notice_history_id\": privacy_notice_fr_provide_service_frontend_only.histories[\n                        0\n                    ].id,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"policy_key\": consent_policy.key,\n            \"user_geography\": \"fr_idg\",\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"method\": \"button\",\n        }\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"preferences\"]) == 1\n        assert response.json()[\"fides_mobile_data\"] is None\n\n        response_json = response.json()[\"preferences\"][0]\n        created_privacy_preference_history_id = response_json[\n            \"privacy_preference_history_id\"\n        ]\n        privacy_preference_history = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id == created_privacy_preference_history_id\n            )\n            .first()\n        )\n        assert response_json[\"preference\"] == \"opt_out\"\n\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(\n                privacy_notice_fr_provide_service_frontend_only.histories[0]\n            ).dict()\n        )\n        db.refresh(consent_request)\n        # No privacy request created here\n        assert not consent_request.privacy_request_id\n\n        # Privacy request not created or queued\n        assert privacy_preference_history.privacy_request_id is None\n        assert not run_privacy_request_mock.called\n\n        assert privacy_preference_history.user_geography == \"fr_idg\"\n\n        privacy_preference_history.delete(db=db)\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_not_required\", \"automatically_approved\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.privacy_preference_endpoints.anonymize_ip_address\"\n    )\n    def test_set_privacy_preferences_privacy_center_fides_user_device_id_only(\n        self,\n        mock_anonymize,\n        run_privacy_request_mock,\n        fides_user_provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        db: Session,\n        request_body,\n        privacy_notice,\n    ):\n        \"\"\"Test the workflow where consent preferences were saved in the privacy center against\n        a fides user device id only - no email or phone number.  This ProvidedIdentity needs to be\n        saved as the PrivacyPreferenceHistory.fides_user_device_provided_identity_id record.\n\n        Also asserts these same preferences can be retrieved via the consent request verify endpoint\n        \"\"\"\n        masked_ip = \"12.214.31.0\"\n        mock_anonymize.return_value = masked_ip\n\n        (\n            fides_user_provided_identity,\n            consent_request,\n        ) = fides_user_provided_identity_and_consent_request\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"preferences\"]) == 1\n        assert response.json()[\"fides_mobile_data\"] is None\n\n        response_json = response.json()[\"preferences\"][0]\n        created_privacy_preference_history_id = response_json[\n            \"privacy_preference_history_id\"\n        ]\n        privacy_preference_history = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id == created_privacy_preference_history_id\n            )\n            .first()\n        )\n        assert privacy_preference_history.email is None\n        assert (\n            privacy_preference_history.fides_user_device\n            == fides_user_provided_identity.encrypted_value[\"value\"]\n        )\n        assert privacy_preference_history.provided_identity is None\n        assert (\n            privacy_preference_history.fides_user_device_provided_identity\n            == fides_user_provided_identity,\n            \"Assert fides user device provided identity \",\n        )\n        assert privacy_preference_history.phone_number is None\n        assert privacy_preference_history.preference == UserConsentPreference.opt_out\n\n        assert response_json[\"preference\"] == \"opt_out\"\n\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n        db.refresh(consent_request)\n        assert consent_request.privacy_request_id\n\n        # Assert preferences can be retrieved under fides user device id only\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        response_json = response.json()[\"items\"][0]\n        assert response_json[\"id\"] is not None\n        assert response_json[\"preference\"] == \"opt_out\"\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n\n        # Test no experience specified, so no request origin\n        assert privacy_preference_history.request_origin is None\n        assert privacy_preference_history.user_agent == \"testclient\"\n        assert privacy_preference_history.privacy_experience_config_history_id is None\n        assert privacy_preference_history.privacy_experience_id is None\n        assert mock_anonymize.call_args.args[0] == \"testclient\"\n        assert privacy_preference_history.anonymized_ip_address == masked_ip\n        assert privacy_preference_history.url_recorded is None\n\n        # Fetch current privacy preference\n        current_preference = CurrentPrivacyPreference.get(\n            db, object_id=response_json[\"id\"]\n        )\n        assert current_preference.preference == UserConsentPreference.opt_out\n        assert (\n            current_preference.privacy_notice_history_id\n            == privacy_notice.histories[0].id\n        )\n\n        privacy_preference_history.delete(db=db)\n        assert run_privacy_request_mock.called\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_set_privacy_preferences_invalid_code_respects_attempt_count(\n        self,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        request_body,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"code\"] = \"987632\"  # Bad code\n\n        for _ in range(0, CONFIG.security.identity_verification_attempt_limit):\n            response = api_client.patch(\n                f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n                json=request_body,\n            )\n            assert response.status_code == 403\n            assert \"Incorrect identification\" in response.json()[\"detail\"]\n\n        assert (\n            consent_request._get_cached_verification_code_attempt_count()\n            == CONFIG.security.identity_verification_attempt_limit\n        )\n\n        request_body[\"code\"] = verification_code\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 403\n        assert (\n            response.json()[\"detail\"] == f\"Attempt limit hit for '{consent_request.id}'\"\n        )\n        assert consent_request.get_cached_verification_code() is None\n        assert consent_request._get_cached_verification_code_attempt_count() == 0\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    def test_set_privacy_preferences_no_email_provided(\n        self,\n        mock_verify_identity: MagicMock,\n        db,\n        api_client,\n        verification_code,\n        request_body,\n    ):\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": None,\n            \"encrypted_value\": None,\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n        consent_request_data = {\n            \"provided_identity_id\": provided_identity.id,\n        }\n        consent_request = ConsentRequest.create(db, data=consent_request_data)\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n\n        assert response.status_code == 404\n        assert mock_verify_identity.called\n        assert \"missing\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_set_privacy_preferences_no_privacy_preferences_present(\n        self,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        request_body,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"preferences\"] = None\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 422\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_set_privacy_preferences_invalid_privacy_notice_history_id(\n        self,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        request_body,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"preferences\"][0][\"privacy_notice_history_id\"] = \"bad_id\"\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert (\n            response.status_code == 400\n        ), \"Gets picked up by the duplicate privacy notice check\"\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_set_duplicate_preferences_for_the_same_notice_in_one_request(\n        self,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        request_body,\n        privacy_notice,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"preferences\"].append(\n            {\n                \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                \"preference\": \"opt_in\",\n            }\n        )\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert (\n            response.status_code == 400\n        ), \"Gets picked up by the duplicate privacy notice check\"\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_save_preferences_invalid_served_notice_history_id(\n        self,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        request_body,\n        privacy_notice,\n        served_notice_history_us_ca_provide_for_fides_user,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"preferences\"][0][\n            \"served_notice_history_id\"\n        ] = served_notice_history_us_ca_provide_for_fides_user.id\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"]\n            == f\"The ServedNoticeHistory record '{served_notice_history_us_ca_provide_for_fides_user.id}' did not serve the privacy notice history '{privacy_notice.histories[0].id}'.\"\n        )\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n        \"automatically_approved\",\n        \"consent_policy\",\n        \"system\",\n    )\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_set_privacy_preferences(\n        self,\n        mock_run_privacy_request: MagicMock,\n        mock_verify_identity: MagicMock,\n        provided_identity_and_consent_request,\n        db,\n        api_client,\n        verification_code,\n        request_body,\n        privacy_notice,\n        privacy_notice_us_ca_provide,\n        served_notice_history,\n    ):\n        provided_identity, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"preferences\"].append(\n            {\n                \"privacy_notice_history_id\": privacy_notice_us_ca_provide.histories[\n                    0\n                ].id,\n                \"preference\": \"opt_in\",\n            }\n        )\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n\n        assert response.status_code == 200\n        assert len(response.json()[\"preferences\"]) == 2\n        assert response.json()[\"fides_mobile_data\"] is None\n\n        response_json = response.json()[\"preferences\"]\n\n        first_privacy_preference_history_created = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id\n                == response_json[0][\"privacy_preference_history_id\"]\n            )\n            .first()\n        )\n        assert response_json[0][\"preference\"] == \"opt_out\"\n\n        assert (\n            response_json[0][\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n\n        second_privacy_preference_history_created = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id\n                == response_json[1][\"privacy_preference_history_id\"]\n            )\n            .first()\n        )\n        assert response_json[1][\"preference\"] == \"opt_in\"\n        assert (\n            response_json[1][\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(\n                privacy_notice_us_ca_provide.histories[0]\n            ).dict()\n        )\n        assert verification_code in mock_verify_identity.call_args_list[0].args\n\n        db.refresh(first_privacy_preference_history_created)\n        db.refresh(second_privacy_preference_history_created)\n\n        assert (\n            first_privacy_preference_history_created.served_notice_history_id\n            == served_notice_history.id\n        )\n        assert (\n            second_privacy_preference_history_created.served_notice_history_id is None\n        )\n\n        assert first_privacy_preference_history_created.privacy_request_id is not None\n        assert second_privacy_preference_history_created.privacy_request_id is not None\n\n        identity = (\n            first_privacy_preference_history_created.privacy_request.get_persisted_identity()\n        )\n        assert identity.email == \"test@email.com\", (\n            \"Identity pulled from Privacy Request Provided Identity and used to \"\n            \"create a Privacy Request provided identity \"\n        )\n        assert identity.phone_number is None\n        assert identity.ga_client_id == \"test\", (\n            \"Browser identity pulled from Privacy Request Provided Identity and persisted \"\n            \"to a Privacy Request provided identity\"\n        )\n\n        privacy_request = first_privacy_preference_history_created.privacy_request\n        assert privacy_request.status == PrivacyRequestStatus.pending\n        assert privacy_request.privacy_preferences == [\n            first_privacy_preference_history_created,\n            second_privacy_preference_history_created,\n        ], \"Same privacy request created to propagate both preferences\"\n\n        db.refresh(consent_request)\n        assert (\n            consent_request.privacy_request_id == privacy_request.id\n        ), \"Privacy request id also saved on Consent request for record keeping\"\n        assert mock_run_privacy_request.called\n\n        current_privacy_preference_one = (\n            first_privacy_preference_history_created.current_privacy_preference\n        )\n        current_privacy_preference_two = (\n            second_privacy_preference_history_created.current_privacy_preference\n        )\n        assert (\n            current_privacy_preference_one.preference == UserConsentPreference.opt_out\n        ), \"History preferences saved to latest preferences\"\n        assert (\n            current_privacy_preference_two.preference == UserConsentPreference.opt_in\n        ), \"History preferences saved to latest preferences\"\n\n        first_privacy_preference_history_created.delete(db)\n        second_privacy_preference_history_created.delete(db)\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n        \"automatically_approved\",\n        \"consent_policy\",\n        \"system\",\n        \"enable_tcf\",\n    )\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_set_privacy_preferences_tcf(\n        self,\n        mock_run_privacy_request: MagicMock,\n        mock_verify_identity: MagicMock,\n        provided_identity_and_consent_request,\n        db,\n        api_client,\n        verification_code,\n        tcf_request_body,\n    ):\n        provided_identity, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=tcf_request_body,\n        )\n\n        assert response.status_code == 200\n        assert response.json()[\"fides_mobile_data\"] is None\n        assert len(response.json()[\"preferences\"]) == 0\n        assert len(response.json()[\"feature_preferences\"]) == 1\n\n        response_json = response.json()[\"feature_preferences\"]\n\n        first_privacy_preference_history_created = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id\n                == response_json[0][\"privacy_preference_history_id\"]\n            )\n            .first()\n        )\n        assert response_json[0][\"preference\"] == \"opt_out\"\n        assert response_json[0][\"feature\"] == 1\n\n        assert first_privacy_preference_history_created.feature == 1\n        assert (\n            first_privacy_preference_history_created.preference\n            == UserConsentPreference.opt_out\n        )\n        assert (\n            first_privacy_preference_history_created.consent_record_type\n            == ConsentRecordType.feature\n        )\n\n        current_preference = (\n            first_privacy_preference_history_created.current_privacy_preference\n        )\n\n        assert current_preference.feature == 1\n        assert current_preference.preference == UserConsentPreference.opt_out\n\n        assert verification_code in mock_verify_identity.call_args_list[0].args\n\n        current_preference.delete(db)\n        first_privacy_preference_history_created.delete(db)\n\n        assert not mock_run_privacy_request.called\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\", \"automatically_approved\"\n    )\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_set_privacy_preferences_bad_policy_key(\n        self,\n        mock_run_privacy_request: MagicMock,\n        mock_verify_identity: MagicMock,\n        provided_identity_and_consent_request,\n        db,\n        api_client,\n        verification_code,\n        request_body,\n        privacy_notice,\n    ):\n        \"\"\"Even though privacy request creation fails, privacy preferences are still saved\"\"\"\n        provided_identity, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"policy_key\"] = \"bad_policy_key\"\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n\n        assert response.status_code == 400\n        assert (\n            response.json()[\"detail\"] == \"Policy with key bad_policy_key does not exist\"\n        )\n\n        privacy_preference_history_created = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.privacy_notice_history_id\n                == privacy_notice.privacy_notice_history_id\n            )\n            .first()\n        )\n        assert (\n            privacy_preference_history_created.preference\n            == UserConsentPreference.opt_out\n        )\n\n        assert verification_code in mock_verify_identity.call_args_list[0].args\n        assert privacy_preference_history_created.privacy_request_id is None\n        db.refresh(consent_request)\n        assert consent_request.privacy_request_id is None\n        assert not mock_run_privacy_request.called\n\n        current_privacy_preference_one = (\n            privacy_preference_history_created.current_privacy_preference\n        )\n\n        assert (\n            current_privacy_preference_one.preference == UserConsentPreference.opt_out\n        ), \"Historical preferences upserted to latest consent preferences\"\n\n        privacy_preference_history_created.delete(db)\n\n    @pytest.mark.usefixtures(\"automatically_approved\", \"system\")\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_set_privacy_preferences_without_verification_required(\n        self,\n        run_privacy_request_mock,\n        mock_verify_identity: MagicMock,\n        provided_identity_and_consent_request,\n        db,\n        api_client,\n        privacy_notice,\n        request_body,\n        verification_code,\n    ):\n        provided_identity, consent_request = provided_identity_and_consent_request\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"preferences\"]) == 1\n\n        response_json = response.json()[\"preferences\"][0]\n        created_privacy_preference_history_id = response_json[\n            \"privacy_preference_history_id\"\n        ]\n        privacy_preference_history = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id == created_privacy_preference_history_id\n            )\n            .first()\n        )\n        assert response_json[\"preference\"] == \"opt_out\"\n\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n\n        db.refresh(consent_request)\n        assert consent_request.privacy_request_id\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        response_json = response.json()[\"items\"][0]\n        assert response_json[\"id\"] is not None\n        assert response_json[\"preference\"] == \"opt_out\"\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n\n        privacy_preference_history.delete(db=db)\n        assert not mock_verify_identity.called\n        assert run_privacy_request_mock.called\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\", \"automatically_approved\", \"system\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_verify_then_set_privacy_preferences_with_additional_fides_user_device_id(\n        self,\n        run_privacy_request_mock,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        db: Session,\n        request_body,\n        privacy_notice,\n    ):\n        \"\"\"Verify code and then return privacy preferences\n\n        Besides having a verified identity, we also have the fides_user_device_id from the browser\n        \"\"\"\n        test_device_id = \"2da1690a-65b6-447b-879b-d33089c04ba5\"\n        request_body[\"browser_identity\"][\"fides_user_device_id\"] = test_device_id\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        # Assert no existing privacy preferences exist for this identity\n        assert response.json() == {\n            \"items\": [],\n            \"total\": 0,\n            \"page\": 1,\n            \"pages\": 0,\n            \"size\": 50,\n        }\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"preferences\"]) == 1\n        assert response.json()[\"fides_mobile_data\"] is None\n\n        response_json = response.json()[\"preferences\"][0]\n        created_privacy_preference_history_id = response_json[\n            \"privacy_preference_history_id\"\n        ]\n        privacy_preference_history = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id == created_privacy_preference_history_id\n            )\n            .first()\n        )\n        assert response_json[\"preference\"] == \"opt_out\"\n\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n        db.refresh(consent_request)\n        assert consent_request.privacy_request_id\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        response_json = response.json()[\"items\"][0]\n        assert response_json[\"id\"] is not None\n        assert response_json[\"preference\"] == \"opt_out\"\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n        assert privacy_preference_history.fides_user_device == test_device_id\n        assert (\n            privacy_preference_history.hashed_fides_user_device\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n        assert (\n            privacy_preference_history.fides_user_device_provided_identity_id\n            is not None\n        )\n        fides_user_device_provided_identity = (\n            privacy_preference_history.fides_user_device_provided_identity\n        )\n        assert (\n            fides_user_device_provided_identity\n            != privacy_preference_history.provided_identity\n        )\n        assert (\n            fides_user_device_provided_identity.encrypted_value[\"value\"]\n            == test_device_id\n        )\n        assert (\n            fides_user_device_provided_identity.hashed_value\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n\n        privacy_preference_history.delete(db=db)\n        assert run_privacy_request_mock.called\n\n\nclass TestPrivacyPreferenceVerify:\n    @pytest.fixture(scope=\"function\")\n    def verification_code(self) -> str:\n        return \"abcd\"\n\n    def test_consent_verify_no_consent_request_id(\n        self,\n        api_client,\n    ):\n        data = {\"code\": \"12345\"}\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id='non_existent_consent_id')}\",\n            json=data,\n        )\n        assert response.status_code == 404\n        assert \"not found\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_consent_verify_no_consent_code(\n        self, provided_identity_and_consent_request, api_client\n    ):\n        data = {\"code\": \"12345\"}\n\n        _, consent_request = provided_identity_and_consent_request\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json=data,\n        )\n        assert response.status_code == 400\n        assert \"code expired\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_consent_verify_invalid_code(\n        self, provided_identity_and_consent_request, api_client\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(\"abcd\")\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": \"1234\"},\n        )\n        assert response.status_code == 403\n        assert \"Incorrect identification\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    def test_consent_verify_no_email_provided(\n        self,\n        mock_verify_identity: MagicMock,\n        db,\n        api_client,\n        verification_code,\n    ):\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": None,\n            \"encrypted_value\": None,\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n        consent_request_data = {\n            \"provided_identity_id\": provided_identity.id,\n        }\n        consent_request = ConsentRequest.create(db, data=consent_request_data)\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n\n        assert response.status_code == 404\n        assert verification_code in mock_verify_identity.call_args_list[0].args\n        assert \"missing\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    def test_consent_verify_no_privacy_preferences_present(\n        self,\n        mock_verify_identity: MagicMock,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert verification_code in mock_verify_identity.call_args_list[0].args\n        assert response.json() == {\n            \"items\": [],\n            \"total\": 0,\n            \"page\": 1,\n            \"pages\": 0,\n            \"size\": 50,\n        }\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_consent_verify_consent_preferences(\n        self,\n        provided_identity_and_consent_request,\n        db,\n        api_client,\n        verification_code,\n        privacy_preference_history,\n    ):\n        provided_identity, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n\n        # Getting current preferences returns the latest CurrentPrivacyPreferences, not the PrivacyPreferenceHistory records\n        current_preference_record = (\n            privacy_preference_history.current_privacy_preference\n        )\n        data = response.json()[\"items\"][0]\n        assert data[\"id\"] == current_preference_record.id\n        assert (\n            data[\"preference\"]\n            == \"opt_out\"\n            == privacy_preference_history.preference.value\n        )\n        assert (\n            data[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(\n                privacy_preference_history.privacy_notice_history\n            ).dict()\n        )\n        db.refresh(consent_request)\n        assert consent_request.identity_verified_at is not None\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n        \"privacy_preference_history_for_tcf_special_purpose\",\n    )\n    def test_consent_verify_tcf_consent_preferences_tcf_disabled(\n        self, provided_identity_and_consent_request, api_client, verification_code\n    ):\n        provided_identity, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 0\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n        \"enable_tcf\",\n    )\n    def test_consent_verify_tcf_consent_preferences(\n        self,\n        provided_identity_and_consent_request,\n        db,\n        api_client,\n        verification_code,\n        privacy_preference_history_for_tcf_special_purpose,\n    ):\n        provided_identity, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n\n        current_preference_record = (\n            privacy_preference_history_for_tcf_special_purpose.current_privacy_preference\n        )\n        data = response.json()[\"items\"][0]\n        assert data[\"id\"] == current_preference_record.id\n        assert (\n            data[\"preference\"]\n            == \"opt_in\"\n            == privacy_preference_history_for_tcf_special_purpose.preference.value\n        )\n        assert data[\"special_purpose\"] == 1\n        db.refresh(consent_request)\n        assert consent_request.identity_verified_at is not None\n\n\nclass TestSavePrivacyPreferencesForFidesDeviceId:\n    @pytest.fixture(scope=\"function\")\n    def url(self) -> str:\n        return V1_URL_PREFIX + PRIVACY_PREFERENCES\n\n    @pytest.fixture(scope=\"function\")\n    def request_body(\n        self,\n        privacy_notice,\n        consent_policy,\n        privacy_experience_overlay,\n        served_notice_history,\n    ):\n        return {\n            \"browser_identity\": {\n                \"ga_client_id\": \"test\",\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"preferences\": [\n                {\n                    \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                    \"preference\": \"opt_out\",\n                    \"served_notice_history_id\": served_notice_history.id,\n                }\n            ],\n            \"policy_key\": consent_policy.key,\n            \"user_geography\": \"us_ca\",\n            \"privacy_experience_id\": privacy_experience_overlay.id,\n            \"method\": \"button\",\n        }\n\n    @pytest.fixture(scope=\"function\")\n    def tcf_request_body(\n        self,\n        privacy_notice,\n        consent_policy,\n        privacy_experience_france_tcf_overlay,\n        served_notice_history_for_tcf_purpose,\n        system,\n    ):\n        return {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"purpose_consent_preferences\": [\n                {\n                    \"id\": 8,\n                    \"preference\": \"opt_out\",\n                    \"served_notice_history_id\": served_notice_history_for_tcf_purpose.id,\n                }\n            ],\n            \"vendor_consent_preferences\": [\n                {\n                    \"id\": \"amplitude\",\n                    \"preference\": \"opt_in\",\n                }\n            ],\n            \"feature_preferences\": [{\"id\": 1, \"preference\": \"opt_out\"}],\n            \"special_feature_preferences\": [{\"id\": 2, \"preference\": \"opt_in\"}],\n            \"system_legitimate_interests_preferences\": [\n                {\"id\": system.id, \"preference\": \"opt_out\"}\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n\n    @pytest.mark.usefixtures(\n        \"privacy_notice\",\n    )\n    def test_no_fides_user_device_id_supplied(self, api_client, url, request_body):\n        del request_body[\"browser_identity\"][\"fides_user_device_id\"]\n        response = api_client.patch(\n            url, json=request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 422\n\n    @pytest.mark.usefixtures(\n        \"privacy_notice\",\n    )\n    def test_bad_fides_user_device_id_supplied(self, api_client, url, request_body):\n        request_body[\"browser_identity\"][\n            \"fides_user_device_id\"\n        ] = \"bad_fides_user_device_id\"\n        response = api_client.patch(\n            url, json=request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"badly formed hexadecimal UUID string\"\n        )\n\n    @pytest.mark.usefixtures(\n        \"privacy_notice\",\n    )\n    def test_save_privacy_preferences_with_bad_notice(\n        self, api_client, url, request_body\n    ):\n        request_body[\"preferences\"][0][\"privacy_notice_history_id\"] = \"bad_history\"\n        response = api_client.patch(\n            url, json=request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 400\n\n    @pytest.mark.usefixtures(\n        \"privacy_notice\",\n    )\n    def test_save_privacy_preferences_with_invalid_served_notice_history(\n        self,\n        api_client,\n        url,\n        request_body,\n        served_notice_history_us_ca_provide_for_fides_user,\n    ):\n        request_body[\"preferences\"][0][\n            \"served_notice_history_id\"\n        ] = served_notice_history_us_ca_provide_for_fides_user.id\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 422\n\n    @pytest.mark.usefixtures(\n        \"privacy_notice\",\n    )\n    def test_save_privacy_preferences_with_served_notice_history_not_found(\n        self, api_client, url, request_body\n    ):\n        request_body[\"preferences\"][0][\n            \"served_notice_history_id\"\n        ] = \"bad_served_notice_history_id\"\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 404\n\n    def test_save_privacy_preferences_bad_experience_id(\n        self,\n        api_client,\n        url,\n        request_body,\n    ):\n        \"\"\"Privacy experiences need to be valid when setting preferences\"\"\"\n        request_body[\"privacy_experience_id\"] = \"bad_id\"\n        response = api_client.patch(\n            url, json=request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 404\n        assert response.json()[\"detail\"] == f\"Privacy Experience 'bad_id' not found.\"\n\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.privacy_preference_endpoints.anonymize_ip_address\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_save_privacy_preferences_with_respect_to_fides_user_device_id(\n        self,\n        run_privacy_request_mock,\n        mock_anonymize,\n        db,\n        api_client,\n        url,\n        request_body,\n        privacy_notice,\n        privacy_experience_overlay,\n        served_notice_history,\n    ):\n        \"\"\"Assert CurrentPrivacyPreference records were updated and PrivacyPreferenceHistory records were created\n        for recordkeeping with respect to the fides user device id in the request\n        \"\"\"\n        test_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n        masked_ip = \"12.214.31.0\"\n        mock_anonymize.return_value = masked_ip\n        response = api_client.patch(\n            url, json=request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 200\n        assert response.json()[\"fides_mobile_data\"] is None\n        response_json = response.json()[\"preferences\"][0]\n        assert response_json[\"preference\"] == \"opt_out\"\n        assert (\n            response_json[\"privacy_notice_history\"][\"id\"]\n            == privacy_notice.histories[0].id\n        )\n\n        privacy_preference_history_id = response_json[\"privacy_preference_history_id\"]\n\n        # Fetch current privacy preference that was updated\n        current_preference = CurrentPrivacyPreference.get(\n            db, object_id=response_json[\"id\"]\n        )\n        # Get corresponding historical preference that was just created\n        privacy_preference_history = current_preference.privacy_preference_history\n        assert privacy_preference_history.id == privacy_preference_history_id\n\n        fides_user_device_provided_identity = (\n            privacy_preference_history.fides_user_device_provided_identity\n        )\n        # Same fides user device identity added to both the historical and current record\n        assert (\n            current_preference.fides_user_device_provided_identity\n            == fides_user_device_provided_identity\n        )\n        assert (\n            fides_user_device_provided_identity.hashed_value\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n        assert (\n            fides_user_device_provided_identity.encrypted_value[\"value\"]\n            == test_device_id\n        )\n        # Values also cached on the historical record for reporting\n        assert (\n            privacy_preference_history.hashed_fides_user_device\n            == ProvidedIdentity.hash_value(test_device_id)\n        )  # Cached here for reporting\n        assert (\n            privacy_preference_history.fides_user_device == test_device_id\n        )  # Cached here for reporting\n\n        # Test items that are pulled from request headers or client\n        assert (\n            privacy_preference_history.request_origin == RequestOrigin.overlay\n        )  # Retrieved from privacy experience history\n        assert (\n            privacy_preference_history.user_agent == \"testclient\"\n        )  # Retrieved from request headers\n        assert (\n            privacy_preference_history.privacy_experience_config_history_id\n            == privacy_experience_overlay.experience_config.experience_config_history_id\n        )\n        assert (\n            privacy_preference_history.privacy_experience_id\n            == privacy_experience_overlay.id\n        )\n        assert privacy_preference_history.anonymized_ip_address == masked_ip\n        assert privacy_preference_history.url_recorded is None\n        assert privacy_preference_history.method == ConsentMethod.button\n        assert (\n            privacy_preference_history.served_notice_history_id\n            == served_notice_history.id\n        )\n\n        # Privacy request created and queued because a privacy notice has system wide enforcement\n        assert privacy_preference_history.privacy_request_id is not None\n        assert run_privacy_request_mock.called\n\n        current_preference.delete(db)\n        privacy_preference_history.delete(db)\n\n    def test_invalid_tcf_purpose_in_request_body(\n        self,\n        api_client,\n        url,\n        privacy_experience_france_tcf_overlay,\n    ):\n        request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"purpose_consent_preferences\": [\n                {\n                    \"id\": 1000,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"Cannot save preferences against invalid purpose id: '1000'\"\n        )\n\n    def test_invalid_tcf_special_purpose_in_request_body(\n        self,\n        api_client,\n        url,\n        privacy_experience_france_tcf_overlay,\n    ):\n        request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"special_purpose_preferences\": [\n                {\n                    \"id\": 3,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"Cannot save preferences against invalid special purpose id: '3'\"\n        )\n\n    def test_invalid_tcf_feature_in_request_body(\n        self,\n        api_client,\n        url,\n        privacy_experience_france_tcf_overlay,\n    ):\n        request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"feature_preferences\": [\n                {\n                    \"id\": 4,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"Cannot save preferences against invalid feature id: '4'\"\n        )\n\n    def test_invalid_tcf_special_feature_in_request_body(\n        self,\n        api_client,\n        url,\n        privacy_experience_france_tcf_overlay,\n    ):\n        request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"special_feature_preferences\": [\n                {\n                    \"id\": 3,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"Cannot save preferences against invalid special feature id: '3'\"\n        )\n\n    @pytest.mark.usefixtures(\n        \"enable_tcf\",\n    )\n    def test_invalid_system_in_request_body(\n        self, api_client, url, db, privacy_experience_france_tcf_overlay\n    ):\n        request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"system_consent_preferences\": [\n                {\n                    \"id\": \"bad_system\",\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 400\n        assert (\n            response.json()[\"detail\"]\n            == \"Can't save consent against invalid system id 'bad_system'.\"\n        )\n\n    def test_duplicate_tcf_preferences_in_request_body(\n        self,\n        api_client,\n        url,\n        privacy_experience_france_tcf_overlay,\n    ):\n        request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"special_purpose_preferences\": [\n                {\n                    \"id\": 2,\n                    \"preference\": \"opt_out\",\n                },\n                {\n                    \"id\": 2,\n                    \"preference\": \"opt_in\",\n                },\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"Duplicate preferences saved against TCF component: 'special_purpose_preferences'\"\n        )\n\n    @pytest.mark.usefixtures(\n        \"enable_tcf\",\n    )\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.privacy_preference_endpoints.anonymize_ip_address\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_save_tcf_privacy_preferences(\n        self,\n        run_privacy_request_mock,\n        mock_anonymize,\n        db,\n        api_client,\n        url,\n        tcf_request_body,\n        privacy_experience_france_tcf_overlay,\n        served_notice_history_for_tcf_purpose,\n        experience_config_tcf_overlay,\n        system,\n    ):\n        \"\"\"Assert CurrentPrivacyPreference records were updated and PrivacyPreferenceHistory records were created\n        for recordkeeping with respect to the fides user device id in the request\n        \"\"\"\n        test_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n        masked_ip = \"12.214.31.0\"\n        mock_anonymize.return_value = masked_ip\n        response = api_client.patch(\n            url, json=tcf_request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"purpose_consent_preferences\"]) == 1\n        assert len(response.json()[\"preferences\"]) == 0\n        assert len(response.json()[\"purpose_legitimate_interests_preferences\"]) == 0\n        assert len(response.json()[\"special_purpose_preferences\"]) == 0\n        assert len(response.json()[\"vendor_consent_preferences\"]) == 1\n        assert len(response.json()[\"feature_preferences\"]) == 1\n        assert len(response.json()[\"special_feature_preferences\"]) == 1\n        assert len(response.json()[\"system_consent_preferences\"]) == 0\n        assert len(response.json()[\"system_legitimate_interests_preferences\"]) == 1\n        assert response.json()[\"fides_mobile_data\"] is None\n\n        purpose_response = response.json()[\"purpose_consent_preferences\"][0]\n        assert purpose_response[\"preference\"] == \"opt_out\"\n        assert purpose_response[\"purpose_consent\"] == 8\n        purpose_privacy_preference_history_id = purpose_response[\n            \"privacy_preference_history_id\"\n        ]\n        current_purpose_preference = CurrentPrivacyPreference.get(\n            db, object_id=purpose_response[\"id\"]\n        )\n        # Assert details saved with respect to data use\n        purpose_privacy_preference_history = (\n            current_purpose_preference.privacy_preference_history\n        )\n        assert (\n            purpose_privacy_preference_history.id\n            == purpose_privacy_preference_history_id\n        )\n        assert purpose_privacy_preference_history.vendor_consent is None\n        assert purpose_privacy_preference_history.vendor_legitimate_interests is None\n\n        assert purpose_privacy_preference_history.privacy_notice_history_id is None\n        assert purpose_privacy_preference_history.feature is None\n        fides_user_device_provided_identity = (\n            purpose_privacy_preference_history.fides_user_device_provided_identity\n        )\n        assert (\n            current_purpose_preference.fides_user_device_provided_identity\n            == fides_user_device_provided_identity\n        )\n        assert (\n            fides_user_device_provided_identity.hashed_value\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n        assert (\n            fides_user_device_provided_identity.encrypted_value[\"value\"]\n            == test_device_id\n        )\n        assert (\n            purpose_privacy_preference_history.hashed_fides_user_device\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n        assert purpose_privacy_preference_history.fides_user_device == test_device_id\n        assert (\n            purpose_privacy_preference_history.purpose_consent\n            == purpose_response[\"purpose_consent\"]\n        )\n        assert purpose_privacy_preference_history.purpose_legitimate_interests is None\n\n        assert (\n            purpose_privacy_preference_history.request_origin\n            == RequestOrigin.tcf_overlay\n        )\n        assert purpose_privacy_preference_history.user_agent == \"testclient\"\n        assert (\n            purpose_privacy_preference_history.privacy_experience_config_history_id\n            == experience_config_tcf_overlay.experience_config_history_id\n        )\n        assert (\n            purpose_privacy_preference_history.privacy_experience_id\n            == privacy_experience_france_tcf_overlay.id\n        )\n        assert purpose_privacy_preference_history.anonymized_ip_address == masked_ip\n        assert purpose_privacy_preference_history.url_recorded is None\n        assert (\n            purpose_privacy_preference_history.served_notice_history_id\n            == served_notice_history_for_tcf_purpose.id\n        )\n\n        # Assert details saved w.r.t vendor\n\n        vendor_consent_response = response.json()[\"vendor_consent_preferences\"][0]\n        assert vendor_consent_response[\"preference\"] == \"opt_in\"\n        assert vendor_consent_response[\"vendor_consent\"] == \"amplitude\"\n\n        current_vendor_preference = CurrentPrivacyPreference.get(\n            db, object_id=vendor_consent_response[\"id\"]\n        )\n        vendor_privacy_preference_history = (\n            current_vendor_preference.privacy_preference_history\n        )\n        assert vendor_privacy_preference_history.purpose_consent is None\n        assert vendor_privacy_preference_history.privacy_notice_history_id is None\n        assert vendor_privacy_preference_history.feature is None\n\n        fides_user_device_provided_identity = (\n            vendor_privacy_preference_history.fides_user_device_provided_identity\n        )\n        assert (\n            current_purpose_preference.fides_user_device_provided_identity\n            == fides_user_device_provided_identity\n        )\n        assert (\n            fides_user_device_provided_identity.hashed_value\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n        assert (\n            fides_user_device_provided_identity.encrypted_value[\"value\"]\n            == test_device_id\n        )\n        assert (\n            vendor_privacy_preference_history.hashed_fides_user_device\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n        assert vendor_privacy_preference_history.fides_user_device == test_device_id\n        assert (\n            vendor_privacy_preference_history.vendor_consent\n            == vendor_consent_response[\"vendor_consent\"]\n        )\n\n        assert (\n            vendor_privacy_preference_history.request_origin\n            == RequestOrigin.tcf_overlay\n        )\n        assert vendor_privacy_preference_history.user_agent == \"testclient\"\n        assert (\n            vendor_privacy_preference_history.privacy_experience_config_history_id\n            == experience_config_tcf_overlay.experience_config_history_id\n        )\n        assert (\n            vendor_privacy_preference_history.privacy_experience_id\n            == privacy_experience_france_tcf_overlay.id\n        )\n        assert vendor_privacy_preference_history.anonymized_ip_address == masked_ip\n        assert vendor_privacy_preference_history.url_recorded is None\n        assert vendor_privacy_preference_history.served_notice_history_id is None\n\n        # Privacy request not created for TCF\n        assert purpose_privacy_preference_history.privacy_request_id is None\n        assert vendor_privacy_preference_history.privacy_request_id is None\n        assert not run_privacy_request_mock.called\n\n        # Assert feature portion of the response\n        feature_response = response.json()[\"feature_preferences\"][0]\n        assert feature_response[\"preference\"] == \"opt_out\"\n        assert feature_response[\"feature\"] == 1\n        assert feature_response[\"special_feature\"] is None\n        current_feature_preference = CurrentPrivacyPreference.get(\n            db, object_id=feature_response[\"id\"]\n        )\n        feature_privacy_preference_history = (\n            current_feature_preference.privacy_preference_history\n        )\n        assert current_feature_preference.feature == 1\n        assert feature_privacy_preference_history.feature == 1\n\n        # Assert special feature portion of the response\n        special_feature_response = response.json()[\"special_feature_preferences\"][0]\n        assert special_feature_response[\"preference\"] == \"opt_in\"\n        assert special_feature_response[\"special_feature\"] == 2\n        assert special_feature_response[\"feature\"] is None\n        current_special_feature_preference = CurrentPrivacyPreference.get(\n            db, object_id=special_feature_response[\"id\"]\n        )\n        special_feature_privacy_preference_history = (\n            current_special_feature_preference.privacy_preference_history\n        )\n        assert current_special_feature_preference.special_feature == 2\n        assert special_feature_privacy_preference_history.special_feature == 2\n\n        # Assert system portion of the response\n        system_response = response.json()[\"system_legitimate_interests_preferences\"][0]\n        assert system_response[\"preference\"] == \"opt_out\"\n        assert system_response[\"system_legitimate_interests\"] == system.id\n        current_system_preference = CurrentPrivacyPreference.get(\n            db, object_id=system_response[\"id\"]\n        )\n        system_privacy_preference_history = (\n            current_system_preference.privacy_preference_history\n        )\n        assert current_system_preference.system_legitimate_interests == system.id\n        assert (\n            system_privacy_preference_history.system_legitimate_interests == system.id\n        )\n\n        current_system_preference.delete(db)\n        system_privacy_preference_history.delete(db)\n        current_special_feature_preference.delete(db)\n        special_feature_privacy_preference_history.delete(db)\n        current_feature_preference.delete(db)\n        feature_privacy_preference_history.delete(db)\n        current_purpose_preference.delete(db)\n        purpose_privacy_preference_history.delete(db)\n        current_vendor_preference.delete(db)\n        vendor_privacy_preference_history.delete(db)\n\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.privacy_preference_endpoints.anonymize_ip_address\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_save_privacy_preferences_for_fides_user_device_id_no_notice_has_system_wide_enforcement(\n        self,\n        run_privacy_request_mock,\n        mock_anonymize,\n        db,\n        api_client,\n        url,\n        consent_policy,\n        privacy_notice_fr_provide_service_frontend_only,\n        privacy_experience_france_overlay,\n    ):\n        \"\"\"PrivacyPreferences and CurrentPrivacyPreferences saved for the given fides user device id\n        but no privacy request created to propagate preferences, because all privacy notices\n        have frontend only enforcement\n        \"\"\"\n        masked_ip = \"12.214.31.0\"\n        mock_anonymize.return_value = masked_ip\n\n        request_body = {\n            \"browser_identity\": {\n                \"ga_client_id\": \"test\",\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"preferences\": [\n                {\n                    \"privacy_notice_history_id\": privacy_notice_fr_provide_service_frontend_only.histories[\n                        0\n                    ].id,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"policy_key\": consent_policy.key,\n            \"user_geography\": \"us_ca\",\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"method\": \"button\",\n        }\n\n        response = api_client.patch(\n            url, json=request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 200\n        response_json = response.json()[\"preferences\"][0]\n        assert response_json[\"preference\"] == \"opt_out\"\n        assert (\n            response_json[\"privacy_notice_history\"][\"id\"]\n            == privacy_notice_fr_provide_service_frontend_only.histories[0].id\n        )\n\n        # Fetch current privacy preference that was updated\n        current_preference = CurrentPrivacyPreference.get(\n            db, object_id=response_json[\"id\"]\n        )\n        # Get corresponding historical preference that was just created\n        privacy_preference_history = current_preference.privacy_preference_history\n\n        assert (\n            privacy_preference_history.privacy_request_id is None\n        )  # Privacy request not created\n        assert not run_privacy_request_mock.called  # Privacy Request is not queued\n\n        current_preference.delete(db)\n        privacy_preference_history.delete(db)\n\n\nclass TestHistoricalPreferences:\n    @pytest.fixture(scope=\"function\")\n    def url(self) -> str:\n        return V1_URL_PREFIX + HISTORICAL_PRIVACY_PREFERENCES_REPORT\n\n    def test_get_historical_preferences_not_authenticated(\n        self, api_client: TestClient, url\n    ) -> None:\n        response = api_client.get(url, headers={})\n        assert 401 == response.status_code\n\n    def test_get_historical_preferences_incorrect_scope(\n        self, api_client: TestClient, url, generate_auth_header\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[CONSENT_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert 403 == response.status_code\n\n    @pytest.mark.parametrize(\n        \"role,expected_status\",\n        [\n            (\"owner\", HTTP_200_OK),\n            (\"contributor\", HTTP_200_OK),\n            (\"viewer_and_approver\", HTTP_403_FORBIDDEN),\n            (\"viewer\", HTTP_403_FORBIDDEN),\n            (\"approver\", HTTP_403_FORBIDDEN),\n        ],\n    )\n    def test_get_historical_preferences_roles(\n        self, role, expected_status, api_client: TestClient, url, generate_role_header\n    ) -> None:\n        auth_header = generate_role_header(roles=[role])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == expected_status\n\n    def test_get_historical_preferences(\n        self,\n        db,\n        api_client: TestClient,\n        url,\n        user,\n        generate_auth_header,\n        privacy_preference_history,\n        privacy_request_with_consent_policy,\n        served_notice_history,\n        system,\n        privacy_experience_privacy_center,\n    ) -> None:\n        privacy_preference_history.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.relevant_systems = privacy_preference_history.privacy_notice_history.calculate_relevant_systems(\n            db\n        )\n        privacy_preference_history.save(db)\n\n        privacy_preference_history.update_secondary_user_ids(\n            db, {\"ljt_readerID\": \"preference_history_test\"}\n        )\n        privacy_preference_history.cache_system_status(\n            db, system=system.fides_key, status=ExecutionLogStatus.complete\n        )\n\n        privacy_request_with_consent_policy.reviewed_by = user.id\n        privacy_request_with_consent_policy.save(db)\n\n        auth_header = generate_auth_header(scopes=[PRIVACY_PREFERENCE_HISTORY_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        assert response.json()[\"total\"] == 1\n        assert response.json()[\"page\"] == 1\n        assert response.json()[\"pages\"] == 1\n        assert response.json()[\"size\"] == 50\n\n        response_body = response.json()[\"items\"][0]\n\n        assert response_body[\"id\"] == privacy_preference_history.id\n        assert (\n            response_body[\"privacy_request_id\"]\n            == privacy_request_with_consent_policy.id\n        )\n        assert response_body[\"email\"] == \"test@email.com\"\n        assert response_body[\"phone_number\"] is None\n        assert response_body[\"fides_user_device_id\"] is None\n        assert response_body[\"secondary_user_ids\"] == {\n            \"ljt_readerID\": \"preference_history_test\"\n        }\n        assert response_body[\"request_timestamp\"] is not None\n        assert response_body[\"request_origin\"] == \"privacy_center\"\n        assert response_body[\"request_status\"] == \"in_processing\"\n        assert response_body[\"request_type\"] == \"consent\"\n        assert response_body[\"approver_id\"] == \"test_fidesops_user\"\n        assert (\n            response_body[\"privacy_notice_history_id\"]\n            == privacy_preference_history.privacy_notice_history_id\n        )\n        assert response_body[\"privacy_notice_history_id\"] is not None\n        assert response_body[\"preference\"] == \"opt_out\"\n        assert response_body[\"tcf_version\"] is None\n        assert response_body[\"user_geography\"] == \"us_ca\"\n        assert response_body[\"relevant_systems\"] == [system.fides_key]\n        assert response_body[\"affected_system_status\"] == {system.fides_key: \"complete\"}\n        assert response_body[\"url_recorded\"] == \"example.com/privacy_center\"\n        assert (\n            response_body[\"user_agent\"]\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert response_body[\"method\"] == \"button\"\n        assert response_body[\"truncated_ip_address\"] == \"92.158.1.0\"\n        assert (\n            response_body[\"experience_config_history_id\"]\n            == privacy_experience_privacy_center.experience_config.experience_config_history_id\n        )\n        assert (\n            response_body[\"privacy_experience_id\"]\n            == privacy_experience_privacy_center.id\n        )\n        assert response_body[\"served_notice_history_id\"] == served_notice_history.id\n\n    def test_get_historical_preferences_tcf(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history_for_tcf_purpose_consent,\n        served_notice_history_for_tcf_purpose,\n        privacy_experience_france_overlay,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[PRIVACY_PREFERENCE_HISTORY_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        assert response.json()[\"total\"] == 1\n        assert response.json()[\"page\"] == 1\n        assert response.json()[\"size\"] == 50\n\n        response_body = response.json()[\"items\"][0]\n\n        assert (\n            response_body[\"id\"] == privacy_preference_history_for_tcf_purpose_consent.id\n        )\n        assert response_body[\"privacy_request_id\"] is None\n        assert response_body[\"email\"] == \"test@email.com\"\n        assert response_body[\"phone_number\"] is None\n        assert (\n            response_body[\"fides_user_device_id\"]\n            == \"051b219f-20e4-45df-82f7-5eb68a00889f\"\n        )\n        assert response_body[\"purpose_consent\"] == 8\n        assert response_body[\"purpose_legitimate_interests\"] is None\n        assert response_body[\"special_purpose\"] is None\n        assert response_body[\"vendor_consent\"] is None\n        assert response_body[\"vendor_legitimate_interests\"] is None\n        assert response_body[\"system_consent\"] is None\n        assert response_body[\"system_legitimate_interests\"] is None\n        assert response_body[\"feature\"] is None\n        assert response_body[\"special_feature\"] is None\n        assert response_body[\"tcf_version\"] == CURRENT_TCF_VERSION\n\n        assert response_body[\"request_timestamp\"] is not None\n        assert response_body[\"request_origin\"] == \"tcf_overlay\"\n        assert response_body[\"request_status\"] is None\n        assert response_body[\"request_type\"] == \"consent\"\n        assert response_body[\"approver_id\"] is None\n        assert response_body[\"privacy_notice_history_id\"] is None\n        assert response_body[\"preference\"] == \"opt_out\"\n        assert response_body[\"user_geography\"] == \"fr_idg\"\n        assert response_body[\"relevant_systems\"] == []\n        assert response_body[\"affected_system_status\"] == {}\n        assert response_body[\"url_recorded\"] == \"example.com/\"\n        assert (\n            response_body[\"user_agent\"]\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert response_body[\"method\"] == \"button\"\n        assert response_body[\"truncated_ip_address\"] == \"92.158.1.0\"\n        assert response_body[\"experience_config_history_id\"] is None\n        assert (\n            response_body[\"privacy_experience_id\"]\n            == privacy_experience_france_overlay.id\n        )\n        assert (\n            response_body[\"served_notice_history_id\"]\n            == served_notice_history_for_tcf_purpose.id\n        )\n\n    def test_get_historical_preferences_saved_for_system(\n        self,\n        generate_auth_header,\n        api_client,\n        url,\n        privacy_preference_history_for_system,\n    ):\n        auth_header = generate_auth_header(scopes=[PRIVACY_PREFERENCE_HISTORY_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        assert (\n            response.json()[\"items\"][0][\"system_consent\"]\n            == privacy_preference_history_for_system.system_consent\n        )\n        assert (\n            response.json()[\"items\"][0][\"preference\"]\n            == privacy_preference_history_for_system.preference.value\n        )\n\n    def test_get_historical_preferences_user_geography_unsupported(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ) -> None:\n        \"\"\"Just verifying it's fine if the user geography is not an official privacy notice region\"\"\"\n\n        auth_header = generate_auth_header(scopes=[PRIVACY_PREFERENCE_HISTORY_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        assert response.json()[\"total\"] == 1\n        assert response.json()[\"page\"] == 1\n        assert response.json()[\"pages\"] == 1\n        assert response.json()[\"size\"] == 50\n\n        response_body = response.json()[\"items\"][0]\n\n        assert (\n            response_body[\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.id\n        )\n        assert response_body[\"user_geography\"] == \"fr_idg\"\n\n    def test_get_historical_preferences_ordering(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history,\n        privacy_preference_history_us_ca_provide,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[PRIVACY_PREFERENCE_HISTORY_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 3\n        assert response.json()[\"total\"] == 3\n        assert response.json()[\"page\"] == 1\n        assert response.json()[\"pages\"] == 1\n        assert response.json()[\"size\"] == 50\n\n        response_body = response.json()[\"items\"]\n\n        # Records ordered most recently created first\n        assert (\n            response_body[0][\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.id\n        )\n        assert response_body[1][\"id\"] == privacy_preference_history_us_ca_provide.id\n        assert response_body[2][\"id\"] == privacy_preference_history.id\n\n    def test_get_historical_preferences_date_filtering(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history,\n        privacy_preference_history_us_ca_provide,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[PRIVACY_PREFERENCE_HISTORY_READ])\n\n        # Filter for everything created before the first preference\n        response = api_client.get(\n            url\n            + f\"?request_timestamp_lt={privacy_preference_history.created_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"items\"] == []\n\n        # Filter for everything created before the last preference plus an hour\n        response = api_client.get(\n            url\n            + f\"?request_timestamp_lt={(privacy_preference_history_fr_provide_service_frontend_only.created_at + timedelta(hours=1)).strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"total\"] == 3\n\n        assert (\n            response.json()[\"items\"][0][\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.id\n        )\n        assert (\n            response.json()[\"items\"][1][\"id\"]\n            == privacy_preference_history_us_ca_provide.id\n        )\n        assert response.json()[\"items\"][2][\"id\"] == privacy_preference_history.id\n\n        # Filter for everything created after the first preference\n        response = api_client.get(\n            url\n            + f\"?request_timestamp_gt={privacy_preference_history.created_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"total\"] == 2\n        assert (\n            response.json()[\"items\"][0][\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.id\n        )\n        assert (\n            response.json()[\"items\"][1][\"id\"]\n            == privacy_preference_history_us_ca_provide.id\n        )\n\n        # Invalid filter\n        response = api_client.get(\n            url\n            + f\"?request_timestamp_lt={privacy_preference_history.created_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}&request_timestamp_gt={privacy_preference_history_fr_provide_service_frontend_only.created_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 400\n        assert \"Value specified for request_timestamp_lt\" in response.json()[\"detail\"]\n        assert \"must be after request_timestamp_gt\" in response.json()[\"detail\"]\n\n\nclass TestCurrentPrivacyPreferences:\n    @pytest.fixture(scope=\"function\")\n    def url(self) -> str:\n        return V1_URL_PREFIX + CURRENT_PRIVACY_PREFERENCES_REPORT\n\n    def test_get_current_preferences_not_authenticated(\n        self, api_client: TestClient, url\n    ) -> None:\n        response = api_client.get(url, headers={})\n        assert 401 == response.status_code\n\n    def test_get_current_preferences_incorrect_scope(\n        self, api_client: TestClient, url, generate_auth_header\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[CONSENT_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert 403 == response.status_code\n\n    def test_get_current_preferences_report_with_tcf(\n        self,\n        generate_auth_header,\n        privacy_preference_history_for_tcf_purpose_consent,\n        api_client,\n        url,\n    ):\n        auth_header = generate_auth_header(scopes=[CURRENT_PRIVACY_PREFERENCE_READ])\n\n        response = api_client.get(url, headers=auth_header)\n\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        data = response.json()[\"items\"][0]\n        assert (\n            data[\"preference\"]\n            == privacy_preference_history_for_tcf_purpose_consent.preference.value\n        )\n        assert data[\"purpose_consent\"] == 8\n        assert (\n            data[\"id\"]\n            == privacy_preference_history_for_tcf_purpose_consent.current_privacy_preference.id\n        )\n\n    @pytest.mark.parametrize(\n        \"role,expected_status\",\n        [\n            (\"owner\", HTTP_200_OK),\n            (\"contributor\", HTTP_200_OK),\n            (\"viewer_and_approver\", HTTP_403_FORBIDDEN),\n            (\"viewer\", HTTP_403_FORBIDDEN),\n            (\"approver\", HTTP_403_FORBIDDEN),\n        ],\n    )\n    def test_get_current_preferences_roles(\n        self, role, expected_status, api_client: TestClient, url, generate_role_header\n    ) -> None:\n        auth_header = generate_role_header(roles=[role])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == expected_status\n\n    def test_get_current_preferences(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history,\n    ) -> None:\n        current_preference = privacy_preference_history.current_privacy_preference\n\n        auth_header = generate_auth_header(scopes=[CURRENT_PRIVACY_PREFERENCE_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        assert response.json()[\"total\"] == 1\n        assert response.json()[\"page\"] == 1\n        assert response.json()[\"pages\"] == 1\n        assert response.json()[\"size\"] == 50\n\n        response_body = response.json()[\"items\"][0]\n\n        assert response_body[\"id\"] == current_preference.id\n        assert response_body[\"preference\"] == current_preference.preference.value\n        assert (\n            response_body[\"privacy_notice_history_id\"]\n            == current_preference.privacy_notice_history.id\n        )\n        assert (\n            response_body[\"provided_identity_id\"]\n            == privacy_preference_history.provided_identity.id\n        )\n        assert response_body[\"created_at\"] is not None\n\n    def test_get_current_preference_ordering(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history,\n        privacy_preference_history_us_ca_provide,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[CURRENT_PRIVACY_PREFERENCE_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 3\n        assert response.json()[\"total\"] == 3\n        assert response.json()[\"page\"] == 1\n        assert response.json()[\"pages\"] == 1\n        assert response.json()[\"size\"] == 50\n\n        response_body = response.json()[\"items\"]\n\n        # Records ordered most recently created first\n        assert (\n            response_body[0][\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.current_privacy_preference.id\n        )\n        assert (\n            response_body[1][\"id\"]\n            == privacy_preference_history_us_ca_provide.current_privacy_preference.id\n        )\n        assert (\n            response_body[2][\"id\"]\n            == privacy_preference_history.current_privacy_preference.id\n        )\n\n    def test_get_current_preferences_date_filtering(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history,\n        privacy_preference_history_us_ca_provide,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[CURRENT_PRIVACY_PREFERENCE_READ])\n\n        # Filter for everything updated before the first preference\n        response = api_client.get(\n            url\n            + f\"?updated_lt={privacy_preference_history.current_privacy_preference.updated_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"items\"] == []\n\n        # Filter for everything updated before the last preference plus an hour\n        response = api_client.get(\n            url\n            + f\"?updated_lt={(privacy_preference_history_fr_provide_service_frontend_only.current_privacy_preference.updated_at + timedelta(hours=1)).strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"total\"] == 3\n\n        assert (\n            response.json()[\"items\"][0][\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.current_privacy_preference.id\n        )\n        assert (\n            response.json()[\"items\"][1][\"id\"]\n            == privacy_preference_history_us_ca_provide.current_privacy_preference.id\n        )\n        assert (\n            response.json()[\"items\"][2][\"id\"]\n            == privacy_preference_history.current_privacy_preference.id\n        )\n\n        # Filter for everything updated after the first preference\n        response = api_client.get(\n            url\n            + f\"?updated_gt={privacy_preference_history.current_privacy_preference.updated_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"total\"] == 2\n        assert (\n            response.json()[\"items\"][0][\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.current_privacy_preference.id\n        )\n        assert (\n            response.json()[\"items\"][1][\"id\"]\n            == privacy_preference_history_us_ca_provide.current_privacy_preference.id\n        )\n\n        # Invalid filter\n        response = api_client.get(\n            url\n            + f\"?updated_lt={privacy_preference_history.current_privacy_preference.updated_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}&updated_gt={privacy_preference_history_fr_provide_service_frontend_only.current_privacy_preference.created_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 400\n        assert \"Value specified for updated_lt\" in response.json()[\"detail\"]\n        assert \"must be after updated_gt\" in response.json()[\"detail\"]\n\n\nclass TestSavePrivacyPreferencesTCStringOnly:\n    @pytest.fixture(scope=\"function\")\n    def url(self) -> str:\n        return V1_URL_PREFIX + PRIVACY_PREFERENCES\n\n    @pytest.mark.usefixtures(\"enable_tcf\")\n    def test_save_privacy_preferences_tc_string_section_overlaps_request_body_section(\n        self, api_client, url\n    ):\n        tc_string: str = \"CPzEX8APzEX8AAMABBENAUEEAPLAAAAAAAAAABEAAAAA.IABE\"\n        fides_user_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n\n        minimal_request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": fides_user_device_id,\n            },\n            \"fides_string\": tc_string,\n            \"purpose_consent_preferences\": [{\"id\": 1, \"preference\": \"opt_out\"}],\n        }\n        response = api_client.patch(\n            url, json=minimal_request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"Cannot supply value for 'purpose_consent_preferences' and 'fides_string' simultaneously when saving privacy preferences.\"\n        )\n\n    def test_save_privacy_preferences_bad_tc_string(self, api_client, url):\n        tc_string: str = \"bad_string\"\n        fides_user_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n\n        minimal_request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": fides_user_device_id,\n            },\n            \"fides_string\": tc_string,\n        }\n        response = api_client.patch(\n            url, json=minimal_request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 400\n        assert response.json()[\"detail\"] == \"Invalid base64-encoded TC string\"\n\n    @pytest.mark.usefixtures(\"enable_tcf\")\n    def test_save_privacy_preferences_with_tc_string_when_datamap_empty(\n        self, api_client, url\n    ):\n        tc_string: str = \"CPzEX8APzEX8AAMABBENAUEEAPLAAAAAAAAAABEAAAAA.IABE\"\n        fides_user_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n\n        minimal_request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": fides_user_device_id,\n            },\n            \"fides_string\": tc_string,\n        }\n        response = api_client.patch(\n            url, json=minimal_request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 200\n        response_body = response.json()[\"preferences\"]\n\n        # Nothing in the datamap so we didn't save anything here.\n        assert len(response_body) == 0\n\n    def test_save_privacy_preferences_when_tcf_disabled(self, api_client, url):\n        tc_string: str = \"CPzEX8APzEX8AAMABBENAUEEAPLAAAAAAAAAABEAAAAA.IABE\"\n        fides_user_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n\n        minimal_request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": fides_user_device_id,\n            },\n            \"fides_string\": tc_string,\n        }\n        response = api_client.patch(\n            url, json=minimal_request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 200\n        response_body = response.json()[\"preferences\"]\n\n        # Nothing saved because TCF is disabled\n        assert len(response_body) == 0\n\n    @pytest.mark.usefixtures(\n        \"skimbit_system\", \"emerse_system\", \"captify_technologies_system\", \"enable_tcf\"\n    )\n    def test_save_privacy_preferences_with_tc_string(self, api_client, url, db):\n        tc_string: str = \"CPzEX8APzEX8AAMABBENAUEEAPLAAAAAAAAAABEAAAAA.IABE\"\n        fides_user_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n\n        minimal_request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": fides_user_device_id,\n            },\n            \"fides_string\": tc_string,\n        }\n        response = api_client.patch(\n            url, json=minimal_request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 200\n        response_body = response.json()\n\n        assert len(response_body[\"preferences\"]) == 0\n        assert len(response_body[\"purpose_consent_preferences\"]) == 7\n        assert len(response_body[\"purpose_legitimate_interests_preferences\"]) == 5\n        assert len(response_body[\"special_purpose_preferences\"]) == 0\n        assert len(response_body[\"vendor_consent_preferences\"]) == 2\n        assert len(response_body[\"vendor_legitimate_interests_preferences\"]) == 2\n        assert len(response_body[\"feature_preferences\"]) == 0\n        assert len(response_body[\"special_feature_preferences\"]) == 1\n        assert len(response_body[\"system_consent_preferences\"]) == 0\n        assert len(response_body[\"system_legitimate_interests_preferences\"]) == 0\n\n        first_purpose_consent_record = response_body[\"purpose_consent_preferences\"][0]\n        assert first_purpose_consent_record[\"purpose_consent\"] == 1\n        assert first_purpose_consent_record[\"preference\"] == \"opt_in\"\n        saved_current_privacy_preference_record = db.query(\n            CurrentPrivacyPreference\n        ).get(first_purpose_consent_record[\"id\"])\n        assert saved_current_privacy_preference_record.purpose_consent == 1\n        assert (\n            saved_current_privacy_preference_record.preference\n            == UserConsentPreference.opt_in\n        )\n\n        privacy_preference_history_record = db.query(PrivacyPreferenceHistory).get(\n            first_purpose_consent_record[\"privacy_preference_history_id\"]\n        )\n        assert (\n            privacy_preference_history_record.current_privacy_preference\n            == saved_current_privacy_preference_record\n        )\n\n        assert (\n            privacy_preference_history_record.fides_user_device == fides_user_device_id\n        )\n        assert (\n            privacy_preference_history_record.fides_user_device_provided_identity\n            is not None\n        )\n        assert (\n            privacy_preference_history_record.fides_user_device_provided_identity\n            == saved_current_privacy_preference_record.fides_user_device_provided_identity\n        )\n\n        assert (\n            privacy_preference_history_record.privacy_experience_id is None\n        )  # Not required in request body\n        assert (\n            privacy_preference_history_record.privacy_experience_config_history_id\n            is None\n        )\n\n        # There were no purpose legitimate interests in the string, but purpose 2 was disclosed\n        # to the user in the experience.  We opt out here.\n        first_purpose_li_record = response_body[\n            \"purpose_legitimate_interests_preferences\"\n        ][0]\n        assert first_purpose_li_record[\"purpose_legitimate_interests\"] == 2\n        assert first_purpose_li_record[\"preference\"] == \"opt_out\"\n        saved_current_privacy_preference_record = db.query(\n            CurrentPrivacyPreference\n        ).get(first_purpose_li_record[\"id\"])\n        assert saved_current_privacy_preference_record.purpose_legitimate_interests == 2\n        assert (\n            saved_current_privacy_preference_record.preference\n            == UserConsentPreference.opt_out\n        )\n\n        # Vendor 2 was in the vendor consents section\n        first_vendor_consent_record = response_body[\"vendor_consent_preferences\"][0]\n        assert first_vendor_consent_record[\"vendor_consent\"] == \"gvl.2\"\n        assert first_vendor_consent_record[\"preference\"] == \"opt_in\"\n        saved_current_privacy_preference_record = db.query(\n            CurrentPrivacyPreference\n        ).get(first_vendor_consent_record[\"id\"])\n        assert saved_current_privacy_preference_record.vendor_consent == \"gvl.2\"\n        assert (\n            saved_current_privacy_preference_record.preference\n            == UserConsentPreference.opt_in\n        )\n\n        # Vendor 8 was not opted in in the vendor consents section, but was disclosed to the\n        # customer in the vendor consents section, so we opt out.\n        second_vendor_consent_record = response_body[\"vendor_consent_preferences\"][1]\n        assert second_vendor_consent_record[\"vendor_consent\"] == \"gvl.8\"\n        assert second_vendor_consent_record[\"preference\"] == \"opt_out\"\n        saved_current_privacy_preference_record = db.query(\n            CurrentPrivacyPreference\n        ).get(second_vendor_consent_record[\"id\"])\n        assert saved_current_privacy_preference_record.vendor_consent == \"gvl.8\"\n        assert (\n            saved_current_privacy_preference_record.preference\n            == UserConsentPreference.opt_out\n        )\n\n        special_feature_record = response_body[\"special_feature_preferences\"][0]\n        assert special_feature_record[\"special_feature\"] == 2\n        assert special_feature_record[\"preference\"] == \"opt_in\"\n        saved_current_privacy_preference_record = db.query(\n            CurrentPrivacyPreference\n        ).get(special_feature_record[\"id\"])\n        assert saved_current_privacy_preference_record.special_feature == 2\n        assert (\n            saved_current_privacy_preference_record.preference\n            == UserConsentPreference.opt_in\n        )\n\n        mobile_data = response.json()[\"fides_mobile_data\"]\n        assert mobile_data == {\n            \"IABTCF_CmpSdkID\": 12,\n            \"IABTCF_CmpSdkVersion\": 1,\n            \"IABTCF_PolicyVersion\": 4,\n            \"IABTCF_gdprApplies\": 1,\n            \"IABTCF_PublisherCC\": \"AA\",\n            \"IABTCF_PurposeOneTreatment\": 0,\n            \"IABTCF_UseNonStandardTexts\": 0,\n            \"IABTCF_TCString\": \"CPzEX8APzEX8AAMABBENAUEEAPLAAAAAAAAAABEAAAAA.IABE\",\n            \"IABTCF_VendorConsents\": \"01\",\n            \"IABTCF_VendorLegitimateInterests\": \"\",\n            \"IABTCF_PurposeConsents\": \"111100101100000000000000\",\n            \"IABTCF_PurposeLegitimateInterests\": \"000000000000000000000000\",\n            \"IABTCF_SpecialFeaturesOptIns\": \"010000000000\",\n            \"IABTCF_PublisherConsent\": None,\n            \"IABTCF_PublisherLegitimateInterests\": None,\n            \"IABTCF_PublisherCustomPurposesConsents\": None,\n            \"IABTCF_PublisherCustomPurposesLegitimateInterests\": None,\n            \"IABTCF_AddtlConsent\": None,\n        }\n", "import pytest\nfrom fideslang.gvl import MAPPED_PURPOSES, MAPPED_SPECIAL_PURPOSES\nfrom sqlalchemy.exc import IntegrityError\n\nfrom fides.api.api.deps import get_api_session\nfrom fides.api.models.privacy_experience import (\n    BannerEnabled,\n    ComponentType,\n    PrivacyExperience,\n    PrivacyExperienceConfig,\n    PrivacyExperienceConfigHistory,\n    cache_saved_and_served_on_consent_record,\n    upsert_privacy_experiences_after_config_update,\n    upsert_privacy_experiences_after_notice_update,\n)\nfrom fides.api.models.privacy_notice import (\n    ConsentMechanism,\n    EnforcementLevel,\n    PrivacyNotice,\n    PrivacyNoticeRegion,\n    UserConsentPreference,\n)\nfrom fides.api.models.privacy_preference import ConsentRecordType\nfrom fides.api.schemas.tcf import (\n    TCFFeatureRecord,\n    TCFPurposeConsentRecord,\n    TCFPurposeLegitimateInterestsRecord,\n    TCFSpecialPurposeRecord,\n    TCFVendorConsentRecord,\n    TCFVendorLegitimateInterestsRecord,\n    TCFVendorRelationships,\n)\n\n\nclass TestExperienceConfig:\n    def test_create_privacy_experience_config(self, db):\n        \"\"\"Assert PrivacyExperienceConfig and its historical record are created\n        Note that the PrivacyExperienceConfig doesn't have regions specifically linked to it here.\n        \"\"\"\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"accept_button_label\": \"Accept all\",\n                \"acknowledge_button_label\": \"OK\",\n                \"banner_enabled\": \"enabled_where_required\",\n                \"component\": \"overlay\",\n                \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n                \"privacy_preferences_link_label\": \"Manage preferences\",\n                \"privacy_policy_link_label\": \"View our privacy policy\",\n                \"privacy_policy_url\": \"example.com/privacy\",\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n\n        assert config.accept_button_label == \"Accept all\"\n        assert config.acknowledge_button_label == \"OK\"\n        assert config.banner_enabled == BannerEnabled.enabled_where_required\n        assert config.component == ComponentType.overlay\n        assert (\n            config.description\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert config.disabled is False\n        assert config.is_default is False\n        assert config.privacy_preferences_link_label == \"Manage preferences\"\n        assert config.privacy_policy_link_label == \"View our privacy policy\"\n        assert config.privacy_policy_url == \"example.com/privacy\"\n        assert config.reject_button_label == \"Reject all\"\n        assert config.save_button_label == \"Save\"\n        assert config.title == \"Control your privacy\"\n\n        assert config.version == 1.0\n        assert config.histories.count() == 1\n        assert config.experiences.count() == 0\n        assert config.regions == []\n\n        history = config.histories[0]\n        assert config.experience_config_history_id == history.id\n\n        assert history.accept_button_label == \"Accept all\"\n        assert history.acknowledge_button_label == \"OK\"\n        assert history.banner_enabled == BannerEnabled.enabled_where_required\n        assert history.component == ComponentType.overlay\n        assert (\n            history.description\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert history.disabled is False\n        assert history.is_default is False\n        assert history.privacy_preferences_link_label == \"Manage preferences\"\n        assert history.privacy_policy_link_label == \"View our privacy policy\"\n        assert history.privacy_policy_url == \"example.com/privacy\"\n        assert history.reject_button_label == \"Reject all\"\n        assert history.save_button_label == \"Save\"\n        assert history.title == \"Control your privacy\"\n        assert history.version == 1.0\n\n        history.delete(db)\n        config.delete(db=db)\n\n    def test_update_privacy_experience_config(self, db):\n        \"\"\"Assert if PrivacyExperienceConfig is updated, its version is bumped and a new historical record is created\"\"\"\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"accept_button_label\": \"Accept all\",\n                \"acknowledge_button_label\": \"OK\",\n                \"banner_enabled\": \"enabled_where_required\",\n                \"component\": \"overlay\",\n                \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n                \"privacy_preferences_link_label\": \"Manage preferences\",\n                \"privacy_policy_link_label\": \"View our privacy policy\",\n                \"privacy_policy_url\": \"example.com/privacy\",\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n        config_created_at = config.created_at\n        config_updated_at = config.updated_at\n\n        config.update(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n            },\n        )\n        db.refresh(config)\n\n        assert config.component == ComponentType.privacy_center\n        assert config.version == 2.0\n        assert config.id is not None\n        assert config.created_at == config_created_at\n        assert config.updated_at > config_updated_at\n\n        assert config.histories.count() == 2\n        history = config.histories.order_by(PrivacyExperienceConfigHistory.created_at)[\n            1\n        ]\n        assert history.component == ComponentType.privacy_center\n        assert config.experience_config_history_id == history.id\n\n        old_history = config.histories.order_by(\n            PrivacyExperienceConfigHistory.created_at\n        )[0]\n        assert old_history.version == 1.0\n        assert old_history.component == ComponentType.overlay\n\n        old_history.delete(db)\n        history.delete(db)\n\n\nclass TestPrivacyExperience:\n    def test_get_experiences_by_region(self, db):\n        \"\"\"Test PrivacyExperience.get_experiences_by_region method\"\"\"\n        (\n            queried_overlay_exp,\n            queried_pc_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_tx\n        )\n        assert queried_overlay_exp is None\n        assert queried_pc_exp is None\n\n        overlay_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"overlay\",\n                \"region\": \"us_tx\",\n            },\n        )\n\n        (\n            queried_overlay_exp,\n            queried_pc_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_tx\n        )\n        assert queried_overlay_exp == overlay_exp\n        assert queried_pc_exp is None\n\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"us_tx\",\n            },\n        )\n\n        (\n            queried_overlay_exp,\n            queried_pc_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_tx\n        )\n        assert queried_overlay_exp == overlay_exp\n        assert queried_pc_exp == pc_exp\n\n        overlay_exp.delete(db)\n        pc_exp.delete(db)\n\n    def test_get_experience_by_component_and_region(self, db):\n        \"\"\"Test PrivacyExperience.get_experience_by_region_and_component method\"\"\"\n        assert (\n            PrivacyExperience.get_experience_by_region_and_component(\n                db, PrivacyNoticeRegion.at, ComponentType.overlay\n            )\n            is None\n        )\n\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"at\",\n            },\n        )\n\n        assert (\n            PrivacyExperience.get_experience_by_region_and_component(\n                db, PrivacyNoticeRegion.at, ComponentType.overlay\n            )\n            is None\n        )\n        assert (\n            PrivacyExperience.get_experience_by_region_and_component(\n                db, PrivacyNoticeRegion.at, ComponentType.privacy_center\n            )\n            == pc_exp\n        )\n\n        db.delete(pc_exp)\n\n    def test_unlink_privacy_experience_config(\n        self, db, experience_config_privacy_center\n    ):\n        \"\"\"\n        Test Experience.unlink_experience_config unlinks the experience\n        \"\"\"\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"at\",\n                \"experience_config_id\": experience_config_privacy_center.id,\n            },\n        )\n        created_at = pc_exp.created_at\n        updated_at = pc_exp.updated_at\n\n        assert pc_exp.experience_config == experience_config_privacy_center\n        pc_exp.unlink_experience_config(db)\n        db.refresh(pc_exp)\n\n        assert pc_exp.experience_config_id is None\n        assert pc_exp.created_at == created_at\n        assert pc_exp.updated_at > updated_at\n\n        pc_exp.delete(db)\n\n    def test_link_default_experience_config(self, db, experience_config_privacy_center):\n        \"\"\"\n        Test Experience.link_default_experience_config points the experience towards the default config\n        \"\"\"\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"at\",\n                \"experience_config_id\": experience_config_privacy_center.id,\n            },\n        )\n        created_at = pc_exp.created_at\n        updated_at = pc_exp.updated_at\n\n        assert pc_exp.experience_config == experience_config_privacy_center\n        pc_exp.link_default_experience_config(db)\n        db.refresh(pc_exp)\n\n        assert pc_exp.experience_config_id is not None\n        assert pc_exp.experience_config_id == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n        assert pc_exp.created_at == created_at\n        assert pc_exp.updated_at > updated_at\n\n        pc_exp.delete(db)\n\n    def test_create_privacy_experience(self, db):\n        \"\"\"Assert PrivacyExperience is created as expected\"\"\"\n        exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"overlay\",\n                \"region\": \"us_tx\",\n            },\n        )\n\n        assert exp.component == ComponentType.overlay\n        assert exp.region == PrivacyNoticeRegion.us_tx\n        assert exp.experience_config_id is None\n\n        exp.delete(db=db)\n\n    def test_update_privacy_experience(self, db, experience_config_overlay):\n        \"\"\"Assert PrivacyExperience is updated as expected\"\"\"\n        exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"overlay\",\n                \"region\": \"us_ca\",\n            },\n        )\n        exp_created_at = exp.created_at\n        exp_updated_at = exp.updated_at\n        assert exp.experience_config is None\n\n        exp.update(\n            db=db,\n            data={\n                \"experience_config_id\": experience_config_overlay.id,\n            },\n        )\n        db.refresh(exp)\n\n        assert exp.component == ComponentType.overlay\n        assert exp.region == PrivacyNoticeRegion.us_ca\n        assert exp.experience_config == experience_config_overlay\n        assert exp.id is not None\n        assert exp.created_at == exp_created_at\n        assert exp.updated_at > exp_updated_at\n\n        exp.delete(db)\n\n    def test_get_related_privacy_notices(self, db, system):\n        \"\"\"Test PrivacyExperience.get_related_privacy_notices that are embedded in PrivacyExperience request\"\"\"\n        privacy_experience = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": \"it\",\n            },\n        )\n\n        # No privacy notices exist\n        assert privacy_experience.get_related_privacy_notices(db) == []\n\n        privacy_notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"Test privacy notice\",\n                \"notice_key\": \"test_privacy_notice\",\n                \"description\": \"a test sample privacy notice configuration\",\n                \"regions\": [PrivacyNoticeRegion.fr, PrivacyNoticeRegion.it],\n                \"consent_mechanism\": ConsentMechanism.opt_in,\n                \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_overlay\": False,\n                \"displayed_in_api\": True,\n                \"displayed_in_privacy_center\": True,\n            },\n        )\n\n        # Privacy Notice has a matching region, but is not displayed in overlay\n        assert privacy_experience.get_related_privacy_notices(db) == []\n\n        privacy_notice.displayed_in_overlay = True\n        privacy_notice.save(db)\n\n        # Privacy Notice both has a matching region and is displayed in overlay\n        assert privacy_experience.get_related_privacy_notices(db) == [privacy_notice]\n\n        privacy_notice.regions = [\"us_ca\"]\n        privacy_notice.save(db)\n        # While privacy notice is displayed in the overlay, it doesn't have a matching region\n        assert privacy_experience.get_related_privacy_notices(db) == []\n\n        privacy_notice.regions = [\"it\"]\n        privacy_notice.save(db)\n        privacy_notice.disabled = True\n        privacy_notice.save(db)\n\n        assert privacy_experience.get_related_privacy_notices(db) == [privacy_notice]\n        # Disabled show by default but if show_disable is False, they're unlinked.\n        assert (\n            privacy_experience.get_related_privacy_notices(db, show_disabled=False)\n            == []\n        )\n\n        # Privacy notice is applicable to a system - they share a data use\n        assert privacy_experience.get_related_privacy_notices(\n            db, systems_applicable=True\n        ) == [privacy_notice]\n\n        system.privacy_declarations[0].delete(db)\n        db.refresh(system)\n\n        # Privacy notice is no longer applicable to any systems\n        assert (\n            privacy_experience.get_related_privacy_notices(db, systems_applicable=True)\n            == []\n        )\n\n        privacy_notice.histories[0].delete(db)\n        privacy_notice.delete(db)\n\n    def test_get_related_privacy_notices_for_a_tcf_overlay(\n        self, db, privacy_experience_france_tcf_overlay\n    ):\n        \"\"\"Just returns an empty list; Privacy Notices are not relevant here\"\"\"\n        assert (\n            privacy_experience_france_tcf_overlay.get_related_privacy_notices(db) == []\n        )\n\n    def test_get_should_show_banner(self, db):\n        \"\"\"Test PrivacyExperience.get_should_show_banner that is calculated at runtime\"\"\"\n        privacy_experience = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": ComponentType.privacy_center,\n                \"region\": \"it\",\n            },\n        )\n\n        # This is a privacy center component so whether we should show the banner is not relevant here\n        assert privacy_experience.get_should_show_banner(db) is False\n\n        privacy_experience.component = ComponentType.overlay\n        privacy_experience.save(db)\n\n        # This is an overlay component but there are no relevant notices here either\n        assert privacy_experience.get_should_show_banner(db) is False\n\n        privacy_notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"Test privacy notice\",\n                \"notice_key\": \"test_privacy_notice\",\n                \"description\": \"a test sample privacy notice configuration\",\n                \"regions\": [PrivacyNoticeRegion.fr, PrivacyNoticeRegion.it],\n                \"consent_mechanism\": ConsentMechanism.opt_out,\n                \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_overlay\": False,\n                \"displayed_in_api\": True,\n                \"displayed_in_privacy_center\": True,\n            },\n        )\n\n        # Privacy Notice has a matching region, but is not displayed in overlay, so it's\n        # not relevant here\n        assert privacy_experience.get_should_show_banner(db) is False\n\n        privacy_notice.displayed_in_overlay = True\n        privacy_notice.save(db)\n\n        # Privacy Notice both has a matching region and is displayed in overlay and is opt_out, so not required\n        assert privacy_experience.get_should_show_banner(db) is False\n\n        privacy_notice.consent_mechanism = ConsentMechanism.opt_in\n        privacy_notice.save(db)\n\n        # Relevant privacy notice is opt in, so it should be delivered in a banner\n        assert privacy_experience.get_should_show_banner(db) is True\n\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"accept_button_label\": \"Accept all\",\n                \"acknowledge_button_label\": \"OK\",\n                \"banner_enabled\": \"always_enabled\",\n                \"component\": \"overlay\",\n                \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n                \"privacy_preferences_link_label\": \"Manage preferences\",\n                \"privacy_policy_link_label\": \"View our privacy policy\",\n                \"privacy_policy_url\": \"example.com/privacy\",\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n\n        # Link experience config\n        privacy_experience.experience_config_id = config.id\n        privacy_experience.save(db)\n\n        # Remove notices\n        privacy_notice.histories[0].delete(db)\n        privacy_notice.delete(db)\n\n        # Banner delivery required because experience config says that banner is always enabled\n        assert privacy_experience.get_should_show_banner(db) is True\n\n        config.banner_enabled = BannerEnabled.always_disabled\n        config.save(db)\n\n        # Banner delivery not required because config says that banner should be always disabled\n        assert privacy_experience.get_should_show_banner(db) is False\n\n    def test_get_should_show_banner_for_a_tcf_overlay(\n        self, privacy_experience_france_tcf_overlay, db\n    ):\n        \"\"\"Currently, this returns true if the experience is a TCF Overlay type\"\"\"\n        assert privacy_experience_france_tcf_overlay.get_should_show_banner(db) is True\n\n    @pytest.mark.usefixtures(\"privacy_preference_history_us_ca_provide\")\n    def test_get_related_notices_no_privacy_preference_for_fides_user_device_id(\n        self,\n        db,\n        privacy_notice_us_ca_provide,\n        fides_user_provided_identity,\n    ):\n        \"\"\"Test fides_user_provided_identity argument for get_related_privacy_notices when the\n        user does not have saved preferences.\n\n        By default, we still return the notices, we just don't surface current or outdated preferences for the\n        user because none exist.\n        \"\"\"\n        privacy_experience = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": \"us_ca\",\n            },\n        )\n\n        notices = privacy_experience.get_related_privacy_notices(db)\n        assert notices == [privacy_notice_us_ca_provide]\n        # No preference here, because no user passed in.\n        assert notices[0].default_preference == UserConsentPreference.opt_out\n        assert notices[0].current_preference is None\n        assert notices[0].outdated_preference is None\n\n        notices = privacy_experience.get_related_privacy_notices(\n            db, fides_user_provided_identity=fides_user_provided_identity\n        )\n        assert notices == [privacy_notice_us_ca_provide]\n        # User has no preferences saved for this notice\n        assert notices[0].default_preference == UserConsentPreference.opt_out\n        assert notices[0].current_preference is None\n        assert notices[0].outdated_preference is None\n\n    def test_get_related_privacy_notices_with_fides_user_device_id_preferences(\n        self,\n        db,\n        privacy_notice_us_ca_provide,\n        privacy_preference_history_us_ca_provide_for_fides_user,\n        fides_user_provided_identity,\n    ):\n        \"\"\"Test fides user device id argument to Experience.get_related_privacy_notices adds the user's\n        preferences if they exist.  If the user's preferences correspond to an older version, that\n        will go under \"outdated\" preference.\n        \"\"\"\n        privacy_experience = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": \"us_ca\",\n            },\n        )\n\n        notices = privacy_experience.get_related_privacy_notices(db)\n        assert notices == [privacy_notice_us_ca_provide]\n        # No preference here, because no user passed in.\n        assert notices[0].current_preference is None\n        assert notices[0].outdated_preference is None\n\n        current_saved_preference = (\n            privacy_preference_history_us_ca_provide_for_fides_user.current_privacy_preference\n        )\n        assert current_saved_preference.preference == UserConsentPreference.opt_in\n\n        # Current preference returned for given user\n        notices = privacy_experience.get_related_privacy_notices(\n            db, fides_user_provided_identity=fides_user_provided_identity\n        )\n        assert notices == [privacy_notice_us_ca_provide]\n        assert notices[0].default_preference == UserConsentPreference.opt_out\n        assert notices[0].current_preference == UserConsentPreference.opt_in\n        assert notices[0].outdated_preference is None\n\n        # Update privacy notice\n        privacy_notice_us_ca_provide.update(\n            db=db,\n            data={\n                \"data_uses\": [\"functional\"],\n                \"enforcement_level\": EnforcementLevel.frontend,\n            },\n        )\n\n        # Current preference for the given user is now None, and opt in preference is the \"outdated\" preference because it\n        # corresponds to a preference for an older version\n        refreshed_notices = privacy_experience.get_related_privacy_notices(\n            db, fides_user_provided_identity=fides_user_provided_identity\n        )\n\n        assert refreshed_notices == [privacy_notice_us_ca_provide]\n        assert refreshed_notices[0].default_preference == UserConsentPreference.opt_out\n        assert refreshed_notices[0].current_preference is None\n        assert refreshed_notices[0].outdated_preference == UserConsentPreference.opt_in\n\n        privacy_experience.delete(db)\n\n        another_session = get_api_session()\n        requeried = privacy_experience.get_related_privacy_notices(another_session)\n        # Assert current/outdated preferences are None when requeried in another session w/ no device id\n        assert requeried[0].default_preference == UserConsentPreference.opt_out\n        assert requeried[0].current_preference is None\n        assert requeried[0].outdated_preference is None\n        another_session.close()\n\n    def test_create_multiple_experiences_of_same_component_type(self, db):\n        \"\"\"We can only have one experience per component type per region\"\"\"\n        exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"overlay\",\n                \"region\": \"us_tx\",\n            },\n        )\n\n        with pytest.raises(IntegrityError):\n            PrivacyExperience.create(\n                db=db,\n                data={\n                    \"component\": \"overlay\",\n                    \"region\": \"us_tx\",\n                },\n            )\n\n        exp.delete(db)\n\n    def test_update_multiple_experiences_of_same_component_type(self, db):\n        \"\"\"We can only have one experience per component type per region. Unique constraint prevents\n        Experience updates from getting in a bad state\"\"\"\n        exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"overlay\",\n                \"region\": \"us_tx\",\n            },\n        )\n\n        exp_2 = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"us_tx\",\n            },\n        )\n\n        with pytest.raises(IntegrityError):\n            exp_2.update(\n                db=db,\n                data={\n                    \"component\": \"overlay\",\n                    \"region\": \"us_tx\",\n                },\n            )\n\n        exp_2.delete(db)\n        exp.delete(db)\n\n\nclass TestUpsertPrivacyExperiencesOnNoticeChange:\n    def test_privacy_center_experience_needed(self, db):\n        \"\"\"\n        Notice that needs to be displayed in the PrivacyCenter is created and no Privacy Center Experience\n        exists.  Assert that a privacy center PrivacyExperience is created.\n        \"\"\"\n        notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"example privacy notice\",\n                \"notice_key\": \"example_privacy_notice\",\n                \"regions\": [\n                    PrivacyNoticeRegion.us_ca,\n                ],\n                \"consent_mechanism\": ConsentMechanism.opt_out,\n                \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_privacy_center\": True,\n                \"displayed_in_overlay\": False,\n                \"displayed_in_api\": False,\n            },\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n        assert overlay_experience is None\n        assert privacy_center_experience is None\n\n        added_exp = upsert_privacy_experiences_after_notice_update(\n            db, [PrivacyNoticeRegion.us_ca]\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n\n        assert overlay_experience is None  # Only privacy center experience was created\n        assert privacy_center_experience is not None\n        assert added_exp == [privacy_center_experience]\n\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ca\n        # Experience automatically linked to default privacy center config\n        assert (\n            privacy_center_experience.experience_config_id\n            == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n        )\n        assert privacy_center_experience.get_related_privacy_notices(db) == [notice]\n\n        privacy_center_experience.delete(db)\n\n        notice.histories[0].delete(db)\n        notice.delete(db)\n\n    def test_privacy_center_experience_already_exists(self, db):\n        \"\"\"\n        Notice that needs to be displayed in the PrivacyCenter is created and Privacy Center Experience\n        already exists.  No action needed.\n        \"\"\"\n        notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"example privacy notice\",\n                \"notice_key\": \"example_privacy_notice\",\n                \"regions\": [\n                    PrivacyNoticeRegion.us_ca,\n                ],\n                \"consent_mechanism\": ConsentMechanism.opt_out,\n                \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_privacy_center\": True,\n                \"displayed_in_overlay\": False,\n                \"displayed_in_api\": False,\n            },\n        )\n\n        exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"region\": PrivacyNoticeRegion.us_ca,\n                \"component\": ComponentType.privacy_center,\n            },\n        )\n        exp_created_at = exp.created_at\n        exp_updated_at = exp.updated_at\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n\n        added_exp = upsert_privacy_experiences_after_notice_update(\n            db, [PrivacyNoticeRegion.us_ca]\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n        assert added_exp == []\n\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ca\n        assert privacy_center_experience.experience_config_id is None\n        assert privacy_center_experience.created_at == exp_created_at\n        assert privacy_center_experience.updated_at == exp_updated_at\n\n        assert privacy_center_experience.get_related_privacy_notices(db) == [notice]\n\n        privacy_center_experience.delete(db)\n\n        notice.histories[0].delete(db)\n        notice.delete(db)\n\n    def test_overlay_experience_needed(self, db):\n        \"\"\"Test Notice created that needs to be displayed in an overlay but none exists. Assert one is created\"\"\"\n        notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"example privacy notice\",\n                \"notice_key\": \"example_privacy_notice\",\n                \"regions\": [\n                    PrivacyNoticeRegion.it,\n                ],\n                \"consent_mechanism\": ConsentMechanism.opt_in,\n                \"data_uses\": [\"marketing.advertising\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_privacy_center\": False,\n                \"displayed_in_overlay\": True,\n                \"displayed_in_api\": False,\n            },\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.it\n        )\n        assert overlay_experience is None\n        assert privacy_center_experience is None\n\n        added_exp = upsert_privacy_experiences_after_notice_update(\n            db, [PrivacyNoticeRegion.it]\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.it\n        )\n\n        assert overlay_experience is not None\n        assert privacy_center_experience is None\n        assert added_exp == [overlay_experience]\n\n        assert overlay_experience.component == ComponentType.overlay\n        assert overlay_experience.region == PrivacyNoticeRegion.it\n        assert (\n            overlay_experience.experience_config_id\n            == \"pri-7ae3-f06b-4096-970f-0bbbdef-over\"\n        )\n\n        assert overlay_experience.get_related_privacy_notices(db) == [notice]\n\n        overlay_experience.delete(db)\n\n        notice.histories[0].delete(db)\n        notice.delete(db)\n\n    def test_overlay_experience_exists(self, db):\n        \"\"\"\n        Test Notice created that needs to be displayed in an overlay and experience already exists.\n        No action needed.\n        \"\"\"\n        notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"example privacy notice\",\n                \"notice_key\": \"example_privacy_notice\",\n                \"regions\": [\n                    PrivacyNoticeRegion.us_ca,\n                ],\n                \"consent_mechanism\": ConsentMechanism.opt_out,\n                \"data_uses\": [\"marketing.advertising\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_privacy_center\": False,\n                \"displayed_in_overlay\": True,\n                \"displayed_in_api\": False,\n            },\n        )\n\n        exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"region\": PrivacyNoticeRegion.us_ca,\n                \"component\": ComponentType.overlay,\n            },\n        )\n        exp_created_at = exp.created_at\n        exp_updated_at = exp.updated_at\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n\n        assert overlay_experience is not None\n        assert privacy_center_experience is None\n\n        added_exp = upsert_privacy_experiences_after_notice_update(\n            db, [PrivacyNoticeRegion.us_ca]\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n        db.refresh(overlay_experience)\n\n        assert overlay_experience is not None\n        assert privacy_center_experience is None\n        assert added_exp == []\n\n        assert overlay_experience.component == ComponentType.overlay\n        assert overlay_experience.region == PrivacyNoticeRegion.us_ca\n        assert overlay_experience.experience_config_id is None\n        assert overlay_experience.created_at == exp_created_at\n        assert overlay_experience.updated_at == exp_updated_at\n\n        assert overlay_experience.get_related_privacy_notices(db) == [notice]\n\n        overlay_experience.delete(db)\n\n        notice.histories[0].delete(db)\n        notice.delete(db)\n\n    def test_both_privacy_center_and_overlay_experience_needed(self, db):\n        \"\"\"Assert multiple types of experiences can be created simultaneously\"\"\"\n        notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"example privacy notice\",\n                \"notice_key\": \"example_privacy_notice\",\n                \"regions\": [\n                    PrivacyNoticeRegion.us_ca,\n                ],\n                \"consent_mechanism\": ConsentMechanism.opt_out,\n                \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_privacy_center\": True,\n                \"displayed_in_overlay\": True,\n                \"displayed_in_api\": False,\n            },\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n        assert overlay_experience is None\n        assert privacy_center_experience is None\n\n        added_exp = upsert_privacy_experiences_after_notice_update(\n            db, [PrivacyNoticeRegion.us_ca]\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n\n        assert overlay_experience is not None\n        assert privacy_center_experience is not None\n        assert {exp.id for exp in added_exp} == {\n            overlay_experience.id,\n            privacy_center_experience.id,\n        }\n\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ca\n        assert (\n            privacy_center_experience.experience_config_id\n            == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n        )\n\n        assert overlay_experience.component == ComponentType.overlay\n        assert overlay_experience.region == PrivacyNoticeRegion.us_ca\n        assert (\n            overlay_experience.experience_config_id\n            == \"pri-7ae3-f06b-4096-970f-0bbbdef-over\"\n        )\n\n        assert privacy_center_experience.get_related_privacy_notices(db) == [notice]\n        assert overlay_experience.get_related_privacy_notices(db) == [notice]\n\n        overlay_experience.delete(db)\n        privacy_center_experience.delete(db)\n\n        notice.histories[0].delete(db)\n        notice.delete(db)\n\n\nclass TestUpsertPrivacyExperiencesOnConfigChange:\n    def test_experience_config_created_no_matching_experience_exists(self, db):\n        \"\"\"Test a privacy center ExperienceConfig is created and we attempt to link AK.\n        No PrivacyExperience exists yet so we create one - we do this regardless of whether notices exist.\n        It's okay to have an experience without notices.\n        \"\"\"\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"banner_enabled\": \"always_disabled\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n        assert overlay_experience is None\n        assert privacy_center_experience is None\n\n        linked, unlinked = upsert_privacy_experiences_after_config_update(\n            db, config, regions=[PrivacyNoticeRegion.us_ak]\n        )\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n        assert linked == [PrivacyNoticeRegion.us_ak]\n        assert unlinked == []\n\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ak\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.experience_config_id == config.id\n\n        privacy_center_experience.delete(db)\n        config.histories[0].delete(db)\n        config.delete(db)\n\n    def test_experience_config_created_matching_unlinked_experience_exists(self, db):\n        \"\"\"Test ExperienceConfig created and we attempt to link AK to that ExperienceConfig.\n        A PrivacyExperience exists for AK, but needs to be linked to this ExperienceConfig.\n        \"\"\"\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"banner_enabled\": \"always_disabled\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"us_ak\",\n            },\n        )\n        assert pc_exp.experience_config_id is None\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n        assert overlay_experience is None\n        assert privacy_center_experience == pc_exp\n\n        linked, unlinked = upsert_privacy_experiences_after_config_update(\n            db, config, regions=[PrivacyNoticeRegion.us_ak]\n        )\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n        assert linked == [PrivacyNoticeRegion.us_ak]\n        assert unlinked == []\n\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ak\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.experience_config_id == config.id\n\n        privacy_center_experience.delete(db)\n        config.histories[0].delete(db)\n        config.delete(db)\n\n    def test_experience_config_updated_matching_experience_already_linked(self, db):\n        \"\"\"Privacy Center Experience Config updated, and we attempt to add AK to this,\n        but it is already linked, so no action needed\"\"\"\n\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"banner_enabled\": \"always_disabled\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"us_ak\",\n                \"experience_config_id\": config.id,\n            },\n        )\n        assert pc_exp.experience_config_id == config.id\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience == pc_exp\n\n        linked, unlinked = upsert_privacy_experiences_after_config_update(\n            db, config, regions=[PrivacyNoticeRegion.us_ak]\n        )\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n        db.refresh(privacy_center_experience)\n\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n        assert linked == []\n        assert unlinked == []\n\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ak\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.experience_config_id == config.id\n\n        privacy_center_experience.delete(db)\n        config.histories[0].delete(db)\n        config.delete(db)\n\n    def test_experience_config_unlinks_region(self, db):\n        \"\"\"Privacy Center Experience Config updated, and we attempt to remove the\n        regions. Any affected experiences have the default linked instead\"\"\"\n\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"banner_enabled\": \"always_disabled\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"us_ak\",\n                \"experience_config_id\": config.id,\n            },\n        )\n        assert pc_exp.experience_config_id == config.id\n        assert config.experiences.count() == 1\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience == pc_exp\n\n        linked, unlinked = upsert_privacy_experiences_after_config_update(\n            db, config, regions=[]  # Empty region list will remove regions\n        )\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n        assert linked == []\n        assert unlinked == [PrivacyNoticeRegion.us_ak]\n        db.refresh(config)\n        assert config.experiences.count() == 0\n\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ak\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert (\n            privacy_center_experience.experience_config_id\n            == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n        )\n\n        privacy_center_experience.delete(db)\n        config.histories[0].delete(db)\n        config.delete(db)\n\n    def test_experience_config_unlinks_region_from_default_config(self, db):\n        \"\"\"Default Privacy Center Experience Config updated, and we attempt to remove the\n        regions. Affected experiences have no config because there's nothing to which we can automatically link.\n        \"\"\"\n        default_privacy_center_config = PrivacyExperienceConfig.get_default_config(\n            db, ComponentType.privacy_center\n        )\n\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"us_ak\",\n                \"experience_config_id\": default_privacy_center_config.id,\n            },\n        )\n        assert pc_exp.experience_config_id == default_privacy_center_config.id\n        assert default_privacy_center_config.experiences.count() == 1\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience == pc_exp\n\n        linked, unlinked = upsert_privacy_experiences_after_config_update(\n            db,\n            default_privacy_center_config,\n            regions=[],  # Empty region list will remove regions\n        )\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n        assert linked == []\n        assert unlinked == [PrivacyNoticeRegion.us_ak]\n        db.refresh(default_privacy_center_config)\n        assert default_privacy_center_config.experiences.count() == 0\n\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ak\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.experience_config_id is None\n\n        privacy_center_experience.delete(db)\n\n\nclass TestCacheSavedAndServedOnConsentRecord:\n    @pytest.fixture\n    def tcf_purpose_consent_record(self):\n        return TCFPurposeConsentRecord(**MAPPED_PURPOSES[8].dict())\n\n    @pytest.fixture\n    def tcf_purpose_legitimate_interests_record(self):\n        return TCFPurposeLegitimateInterestsRecord(**MAPPED_PURPOSES[8].dict())\n\n    @pytest.mark.usefixtures(\n        \"served_notice_history_us_provide_for_fides_user\",\n        \"privacy_preference_history_us_ca_provide_for_fides_user\",\n    )\n    def test_cache_saved_and_served_for_privacy_notice_history(\n        self,\n        db,\n        fides_user_provided_identity,\n        privacy_notice_us_ca_provide,\n    ):\n        assert (\n            privacy_notice_us_ca_provide.default_preference\n            == UserConsentPreference.opt_out\n        )\n        assert privacy_notice_us_ca_provide.current_preference is None\n        assert privacy_notice_us_ca_provide.outdated_preference is None\n        assert privacy_notice_us_ca_provide.current_served is None\n        assert privacy_notice_us_ca_provide.outdated_served is None\n\n        cache_saved_and_served_on_consent_record(\n            db=db,\n            consent_record=privacy_notice_us_ca_provide,\n            fides_user_provided_identity=fides_user_provided_identity,\n            record_type=ConsentRecordType.privacy_notice_id,\n        )\n\n        assert (\n            privacy_notice_us_ca_provide.default_preference\n            == UserConsentPreference.opt_out\n        )\n        assert (\n            privacy_notice_us_ca_provide.current_preference\n            == UserConsentPreference.opt_in\n        )\n        assert privacy_notice_us_ca_provide.outdated_preference is None\n        assert privacy_notice_us_ca_provide.current_served is True\n        assert privacy_notice_us_ca_provide.outdated_served is None\n\n    def test_record_for_tcf_purpose_exists_for_older_version(\n        self,\n        db,\n        tcf_purpose_consent_record,\n        fides_user_provided_identity,\n        privacy_preference_history_for_tcf_purpose_consent,\n        served_notice_history_for_tcf_purpose,\n    ):\n        privacy_preference_history_for_tcf_purpose_consent.current_privacy_preference.tcf_version = (\n            \"1.0\"\n        )\n        privacy_preference_history_for_tcf_purpose_consent.current_privacy_preference.save(\n            db\n        )\n\n        served_notice_history_for_tcf_purpose.last_served_record.tcf_version = \"1.0\"\n        served_notice_history_for_tcf_purpose.last_served_record.save(db)\n\n        cache_saved_and_served_on_consent_record(\n            db,\n            tcf_purpose_consent_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.purpose_consent,\n        )\n\n        assert (\n            tcf_purpose_consent_record.default_preference\n            == UserConsentPreference.opt_out\n        )\n        assert tcf_purpose_consent_record.current_preference is None\n        assert (\n            tcf_purpose_consent_record.outdated_preference\n            == UserConsentPreference.opt_out\n        )\n        assert tcf_purpose_consent_record.current_served is None\n        assert tcf_purpose_consent_record.outdated_served is True\n\n    @pytest.mark.usefixtures(\n        \"privacy_preference_history_for_tcf_purpose_consent\",\n        \"served_notice_history_for_tcf_purpose\",\n    )\n    def test_record_for_tcf_purpose_exists_for_current_version(\n        self, db, tcf_purpose_consent_record, fides_user_provided_identity\n    ):\n        cache_saved_and_served_on_consent_record(\n            db,\n            tcf_purpose_consent_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.purpose_consent,\n        )\n\n        assert (\n            tcf_purpose_consent_record.default_preference\n            == UserConsentPreference.opt_out\n        )\n        assert (\n            tcf_purpose_consent_record.current_preference\n            == UserConsentPreference.opt_out\n        )\n        assert tcf_purpose_consent_record.outdated_preference is None\n        assert tcf_purpose_consent_record.current_served is True\n        assert tcf_purpose_consent_record.outdated_served is None\n\n    def test_no_record_for_tcf_purpose_exists(\n        self, db, tcf_purpose_consent_record, fides_user_provided_identity\n    ):\n        cache_saved_and_served_on_consent_record(\n            db,\n            tcf_purpose_consent_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.purpose_consent,\n        )\n        assert (\n            tcf_purpose_consent_record.default_preference\n            == UserConsentPreference.opt_out\n        )\n        assert tcf_purpose_consent_record.current_preference is None\n        assert tcf_purpose_consent_record.outdated_preference is None\n        assert tcf_purpose_consent_record.current_served is None\n        assert tcf_purpose_consent_record.outdated_served is None\n\n    def test_tcf_purpose_legitimate_interests_record(\n        self,\n        db,\n        tcf_purpose_legitimate_interests_record,\n        fides_user_provided_identity,\n        privacy_preference_history_for_tcf_purpose_legitimate_interests,\n    ):\n        cache_saved_and_served_on_consent_record(\n            db,\n            tcf_purpose_legitimate_interests_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.purpose_legitimate_interests,\n        )\n        assert (\n            tcf_purpose_legitimate_interests_record.default_preference\n            == UserConsentPreference.opt_in\n        )\n        assert (\n            tcf_purpose_legitimate_interests_record.current_preference\n            == UserConsentPreference.opt_in\n        )\n        assert tcf_purpose_legitimate_interests_record.outdated_preference is None\n        assert tcf_purpose_legitimate_interests_record.current_served is None\n        assert tcf_purpose_legitimate_interests_record.outdated_served is None\n\n    @pytest.mark.usefixtures(\n        \"privacy_preference_history_for_tcf_special_purpose\",\n        \"served_notice_history_for_tcf_special_purpose\",\n    )\n    def test_cache_saved_and_served_for_special_purpose(\n        self,\n        db,\n        fides_user_provided_identity,\n    ):\n        special_purpose_record = TCFPurposeConsentRecord(\n            **MAPPED_SPECIAL_PURPOSES[1].dict()\n        )\n        cache_saved_and_served_on_consent_record(\n            db,\n            special_purpose_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.special_purpose,\n        )\n\n        assert (\n            special_purpose_record.default_preference == UserConsentPreference.opt_out\n        )\n        assert special_purpose_record.current_preference == UserConsentPreference.opt_in\n        assert special_purpose_record.outdated_preference is None\n        assert special_purpose_record.current_served is True\n        assert special_purpose_record.outdated_served is None\n\n    @pytest.mark.usefixtures(\"privacy_preference_history_for_vendor\")\n    def test_cache_saved_and_served_for_vendor_consent(\n        self, db, fides_user_provided_identity\n    ):\n        vendor_record = TCFVendorConsentRecord(\n            id=\"gvl.42\", name=\"test\", description=\"test\", has_vendor_id=False\n        )\n        cache_saved_and_served_on_consent_record(\n            db,\n            vendor_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.vendor_consent,\n        )\n\n        assert vendor_record.default_preference == UserConsentPreference.opt_out\n        assert vendor_record.current_preference == UserConsentPreference.opt_out\n        assert vendor_record.outdated_preference is None\n        assert vendor_record.current_served is None\n        assert vendor_record.outdated_served is None\n\n    @pytest.mark.usefixtures(\n        \"privacy_preference_history_for_vendor_legitimate_interests\"\n    )\n    def test_cache_saved_and_served_for_vendor_legitimate_interests(\n        self, db, fides_user_provided_identity\n    ):\n        vendor_record = TCFVendorLegitimateInterestsRecord(\n            id=\"gvl.42\", name=\"test\", description=\"test\", has_vendor_id=True\n        )\n        cache_saved_and_served_on_consent_record(\n            db,\n            vendor_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.vendor_legitimate_interests,\n        )\n\n        assert vendor_record.default_preference == UserConsentPreference.opt_in\n        assert vendor_record.current_preference == UserConsentPreference.opt_out\n        assert vendor_record.outdated_preference is None\n        assert vendor_record.current_served is True\n        assert vendor_record.outdated_served is None\n\n    @pytest.mark.usefixtures(\"privacy_preference_history_for_system\")\n    def test_cache_saved_and_served_for_system_consent(\n        self, db, fides_user_provided_identity, system\n    ):\n        system_record = TCFVendorConsentRecord(id=system.id, has_vendor_id=True)\n        cache_saved_and_served_on_consent_record(\n            db,\n            system_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.system_consent,\n        )\n\n        assert system_record.default_preference == UserConsentPreference.opt_out\n        assert system_record.current_preference == UserConsentPreference.opt_in\n        assert system_record.outdated_preference is None\n        assert system_record.current_served is None\n        assert system_record.outdated_served is None\n\n    def test_cache_saved_and_served_for_vendor_relationships(\n        self, db, fides_user_provided_identity, system\n    ):\n        \"\"\"This is more just aggregating additional info - no consent is saved here\"\"\"\n        system_record = TCFVendorRelationships(\n            id=system.id, name=\"test\", description=\"test\", has_vendor_id=False\n        )\n        cache_saved_and_served_on_consent_record(\n            db,\n            system_record,\n            fides_user_provided_identity,\n            record_type=None,\n        )\n\n        assert not getattr(system_record, \"default_preference\", None)\n\n    def test_cache_saved_and_served_for_tcf_special_purpose(\n        self, db, fides_user_provided_identity\n    ):\n        sp_record = TCFSpecialPurposeRecord(\n            id=2,\n            name=\"Special Purpose 2\",\n            illustrations=[\"test illustrations\"],\n            data_uses=[\"test\"],\n            description=\"desc\",\n        )\n        cache_saved_and_served_on_consent_record(\n            db,\n            sp_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.special_purpose,\n        )\n\n        assert sp_record.default_preference == UserConsentPreference.acknowledge\n        assert sp_record.current_preference is None\n        assert sp_record.outdated_preference is None\n        assert sp_record.current_served is None\n        assert sp_record.outdated_served is None\n\n    @pytest.mark.usefixtures(\"privacy_preference_history_for_tcf_feature\")\n    def test_cache_saved_and_served_for_tcf_feature(\n        self, db, fides_user_provided_identity\n    ):\n        feature_record = TCFFeatureRecord(\n            id=2,\n            name=\"Link different devices\",\n            description=\"Different devices can be determined as belonging to you or your household in support of one or more of purposes.\",\n        )\n        cache_saved_and_served_on_consent_record(\n            db,\n            feature_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.feature,\n        )\n\n        assert feature_record.default_preference == UserConsentPreference.acknowledge\n        assert feature_record.current_preference == UserConsentPreference.opt_in\n        assert feature_record.outdated_preference is None\n        assert feature_record.current_served is True\n        assert feature_record.outdated_served is None\n", "import pytest\nfrom sqlalchemy.exc import InvalidRequestError\n\nfrom fides.api.api.v1.endpoints.privacy_preference_endpoints import (\n    anonymize_ip_address,\n    extract_identity_from_provided_identity,\n)\nfrom fides.api.common_exceptions import (\n    ConsentHistorySaveError,\n    IdentityNotFoundException,\n    PrivacyNoticeHistoryNotFound,\n    SystemNotFound,\n)\nfrom fides.api.models.privacy_preference import (\n    CURRENT_TCF_VERSION,\n    ConsentRecordType,\n    CurrentPrivacyPreference,\n    LastServedNotice,\n    PrivacyPreferenceHistory,\n    RequestOrigin,\n    ServedNoticeHistory,\n    ServingComponent,\n    TCFComponentType,\n    UserConsentPreference,\n    _validate_before_saving_consent_history,\n)\nfrom fides.api.models.privacy_request import (\n    ExecutionLogStatus,\n    ProvidedIdentity,\n    ProvidedIdentityType,\n)\nfrom fides.api.models.sql_models import PrivacyDeclaration\n\n\nclass TestPrivacyPreferenceHistory:\n    def test_create_privacy_preference_min_fields(self, db, privacy_notice):\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\"test@email.com\"),\n            \"encrypted_value\": {\"value\": \"test@email.com\"},\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n        pref = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": \"opt_in\",\n                \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                \"provided_identity_id\": provided_identity.id,\n            },\n            check_name=False,\n        )\n\n        assert pref.preference == UserConsentPreference.opt_in\n        assert pref.privacy_notice_history == privacy_notice.histories[0]\n        assert pref.privacy_notice_id == privacy_notice.id\n\n        pref.delete(db=db)\n\n    def test_create_privacy_preference_no_privacy_notice_history(self, db):\n        with pytest.raises(PrivacyNoticeHistoryNotFound):\n            PrivacyPreferenceHistory.create(\n                db=db,\n                data={\n                    \"preference\": \"opt_in\",\n                    \"privacy_notice_history_id\": \"nonexistent_notice\",\n                },\n                check_name=False,\n            )\n\n    def test_create_privacy_preference_history_without_identity(\n        self, db, privacy_notice\n    ):\n        with pytest.raises(IdentityNotFoundException):\n            PrivacyPreferenceHistory.create(\n                db=db,\n                data={\n                    \"preference\": \"opt_in\",\n                    \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                },\n                check_name=False,\n            )\n\n    def test_create_privacy_preference_for_notice(\n        self, db, privacy_notice, system, privacy_request\n    ):\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\"test@email.com\"),\n            \"encrypted_value\": {\"value\": \"test@email.com\"},\n        }\n        fides_user_provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"fides_user_device_id\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\n                \"test_fides_user_device_id_1234567\"\n            ),\n            \"encrypted_value\": {\"value\": \"test_fides_user_device_id_1234567\"},\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n        fides_user_provided_identity = ProvidedIdentity.create(\n            db, data=fides_user_provided_identity_data\n        )\n\n        privacy_notice_history = privacy_notice.histories[0]\n\n        email, hashed_email = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.email\n        )\n        phone_number, hashed_phone_number = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.phone_number\n        )\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": email,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": hashed_email,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": hashed_phone_number,\n                \"phone_number\": phone_number,\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": provided_identity.id,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n        assert preference_history_record.affected_system_status == {}\n        assert preference_history_record.email == \"test@email.com\"\n        assert (\n            preference_history_record.hashed_email\n            == provided_identity.hashed_value\n            is not None\n        )\n        assert (\n            preference_history_record.fides_user_device\n            == fides_user_device_id\n            is not None\n        )\n        assert (\n            preference_history_record.hashed_fides_user_device\n            == hashed_device_id\n            is not None\n        )\n        assert (\n            preference_history_record.fides_user_device_provided_identity\n            == fides_user_provided_identity\n        )\n\n        assert preference_history_record.email == \"test@email.com\"\n        assert (\n            preference_history_record.hashed_email\n            == provided_identity.hashed_value\n            is not None\n        )\n\n        assert preference_history_record.phone_number is None\n        assert preference_history_record.hashed_phone_number is None\n        assert preference_history_record.preference == UserConsentPreference.opt_out\n        assert (\n            preference_history_record.privacy_notice_history == privacy_notice_history\n        )\n        assert preference_history_record.privacy_notice_id == privacy_notice.id\n        assert (\n            preference_history_record.privacy_request is None\n        )  # Hasn't been added yet\n        assert preference_history_record.provided_identity == provided_identity\n        assert preference_history_record.relevant_systems == [system.fides_key]\n        assert preference_history_record.tcf_version is None  # Not relevant here\n        assert preference_history_record.feature is None\n        assert preference_history_record.special_feature is None\n        assert preference_history_record.vendor_consent is None\n        assert preference_history_record.special_purpose is None\n        assert preference_history_record.purpose_consent is None\n        assert preference_history_record.request_origin == RequestOrigin.privacy_center\n        assert preference_history_record.secondary_user_ids == {\"ga_client_id\": \"test\"}\n        assert (\n            preference_history_record.user_agent\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert preference_history_record.user_geography == \"us_ca\"\n        assert preference_history_record.url_recorded == \"example.com/privacy_center\"\n\n        # Assert PrivacyRequest.privacy_preferences relationship\n        assert privacy_request.privacy_preferences == []\n\n        preference_history_record.privacy_request_id = privacy_request.id\n        preference_history_record.save(db)\n        assert preference_history_record.privacy_request == privacy_request\n        assert privacy_request.privacy_preferences == [preference_history_record]\n\n        # Assert CurrentPrivacyPreference record upserted\n        current_privacy_preference = (\n            preference_history_record.current_privacy_preference\n        )\n        current_privacy_preference_id = current_privacy_preference.id\n        assert current_privacy_preference.preference == UserConsentPreference.opt_out\n        assert (\n            current_privacy_preference.privacy_notice_history == privacy_notice_history\n        )\n        assert current_privacy_preference.tcf_version is None\n        assert current_privacy_preference.feature is None\n        assert current_privacy_preference.special_feature is None\n        assert current_privacy_preference.vendor_consent is None\n        assert current_privacy_preference.special_purpose is None\n        assert current_privacy_preference.purpose_consent is None\n\n        # Save preferences again with an \"opt in\" preference for this privacy notice\n        next_preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": provided_identity.encrypted_value[\"value\"]\n                if provided_identity.field_name == ProvidedIdentityType.email\n                else None,\n                \"phone_number\": provided_identity.encrypted_value[\"value\"]\n                if provided_identity.field_name == ProvidedIdentityType.phone_number\n                else None,\n                \"preference\": \"opt_in\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": provided_identity.id,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        assert next_preference_history_record.preference == UserConsentPreference.opt_in\n        assert (\n            next_preference_history_record.privacy_notice_history\n            == privacy_notice_history\n        )\n\n        # Assert CurrentPrivacyPreference record upserted\n        db.refresh(current_privacy_preference)\n        assert current_privacy_preference.preference == UserConsentPreference.opt_in\n        assert (\n            current_privacy_preference.privacy_notice_history == privacy_notice_history\n        )\n        assert (\n            next_preference_history_record.current_privacy_preference\n            == current_privacy_preference\n        )\n        assert current_privacy_preference.id == current_privacy_preference_id\n\n        db.refresh(preference_history_record)\n        assert (\n            next_preference_history_record.current_privacy_preference\n            == current_privacy_preference\n        )\n        assert preference_history_record.current_privacy_preference is None\n\n        preference_history_record.delete(db)\n        next_preference_history_record.delete(db)\n\n    def test_create_privacy_preference_for_multiple_preference_types(\n        self, db, system, fides_user_provided_identity\n    ):\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        with pytest.raises(ConsentHistorySaveError):\n            PrivacyPreferenceHistory.create(\n                db=db,\n                data={\n                    \"purpose_consent\": 8,\n                    \"vendor_consent\": \"amplitude\",\n                    \"fides_user_device\": fides_user_device_id,\n                    \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                    \"hashed_fides_user_device\": hashed_device_id,\n                    \"preference\": \"opt_out\",\n                    \"request_origin\": \"tcf_overlay\",\n                },\n                check_name=False,\n            )\n\n    def test_create_privacy_preference_for_purpose(\n        self, db, system, tcf_system, fides_user_provided_identity\n    ):\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"purpose_consent\": 8,\n                \"email\": None,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": None,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": None,\n                \"provided_identity_id\": None,\n                \"request_origin\": \"tcf_overlay\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n                \"url_recorded\": \"example.com\",\n            },\n            check_name=False,\n        )\n        assert preference_history_record.affected_system_status == {}\n        assert preference_history_record.email is None\n        assert preference_history_record.hashed_email is None\n        assert (\n            preference_history_record.fides_user_device\n            == fides_user_device_id\n            is not None\n        )\n        assert (\n            preference_history_record.hashed_fides_user_device\n            == hashed_device_id\n            is not None\n        )\n        assert (\n            preference_history_record.fides_user_device_provided_identity\n            == fides_user_provided_identity\n        )\n        assert preference_history_record.purpose_consent == 8\n        assert preference_history_record.purpose_legitimate_interests is None\n        assert preference_history_record.feature is None\n        assert preference_history_record.special_feature is None\n        assert preference_history_record.vendor_consent is None\n        assert preference_history_record.vendor_legitimate_interests is None\n        assert preference_history_record.system_consent is None\n        assert preference_history_record.system_legitimate_interests is None\n        assert preference_history_record.special_purpose is None\n        assert preference_history_record.tcf_version == CURRENT_TCF_VERSION\n        assert preference_history_record.privacy_notice_id is None\n\n        assert preference_history_record.phone_number is None\n        assert preference_history_record.hashed_phone_number is None\n        assert preference_history_record.preference == UserConsentPreference.opt_out\n        assert preference_history_record.privacy_notice_history is None\n        assert preference_history_record.privacy_request is None\n        assert preference_history_record.provided_identity is None\n        assert preference_history_record.relevant_systems == [tcf_system.fides_key]\n        assert preference_history_record.request_origin == RequestOrigin.tcf_overlay\n        assert preference_history_record.secondary_user_ids == {\"ga_client_id\": \"test\"}\n        assert (\n            preference_history_record.user_agent\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert preference_history_record.user_geography == \"fr\"\n        assert preference_history_record.url_recorded == \"example.com\"\n\n        # Assert CurrentPrivacyPreference record upserted\n        current_privacy_preference = (\n            preference_history_record.current_privacy_preference\n        )\n        current_privacy_preference_id = current_privacy_preference.id\n        assert current_privacy_preference.preference == UserConsentPreference.opt_out\n        assert current_privacy_preference.privacy_notice_history is None\n        assert current_privacy_preference.purpose_consent == 8\n        assert current_privacy_preference.purpose_legitimate_interests is None\n        assert current_privacy_preference.feature is None\n        assert current_privacy_preference.special_feature is None\n        assert current_privacy_preference.vendor_consent is None\n        assert current_privacy_preference.vendor_legitimate_interests is None\n        assert current_privacy_preference.special_purpose is None\n        assert current_privacy_preference.tcf_version == CURRENT_TCF_VERSION\n\n        # Save preferences again with an \"opt in\" preference for this purpose\n        next_preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": \"opt_in\",\n                \"purpose_consent\": 8,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"request_origin\": \"tcf_overlay\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n            },\n            check_name=False,\n        )\n\n        assert next_preference_history_record.preference == UserConsentPreference.opt_in\n        assert next_preference_history_record.privacy_notice_history is None\n        assert next_preference_history_record.purpose_consent == 8\n\n        # Assert CurrentPrivacyPreference record upserted\n        db.refresh(current_privacy_preference)\n        assert current_privacy_preference.preference == UserConsentPreference.opt_in\n        assert current_privacy_preference.privacy_notice_history is None\n        assert current_privacy_preference.purpose_consent == 8\n        assert (\n            next_preference_history_record.current_privacy_preference\n            == current_privacy_preference\n        )\n        assert current_privacy_preference.id == current_privacy_preference_id\n\n        db.refresh(preference_history_record)\n        assert (\n            next_preference_history_record.current_privacy_preference\n            == current_privacy_preference\n        )\n        assert preference_history_record.current_privacy_preference is None\n\n        preference_history_record.delete(db)\n        next_preference_history_record.delete(db)\n\n        # Save preferences again with an \"opt in\" preference for a special purpose\n\n        special_purpose_preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": \"opt_in\",\n                \"special_purpose\": 1,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"request_origin\": \"tcf_overlay\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n            },\n            check_name=False,\n        )\n\n        assert special_purpose_preference_history_record.special_purpose == 1\n        assert special_purpose_preference_history_record.relevant_systems == [\n            tcf_system.fides_key\n        ]\n        assert special_purpose_preference_history_record.purpose_consent is None\n        assert special_purpose_preference_history_record.feature is None\n        assert special_purpose_preference_history_record.special_feature is None\n        assert (\n            special_purpose_preference_history_record.tcf_version == CURRENT_TCF_VERSION\n        )\n        assert (\n            special_purpose_preference_history_record.privacy_notice_history_id is None\n        )\n        assert special_purpose_preference_history_record.privacy_notice_id is None\n        current_special_purpose_preference = (\n            special_purpose_preference_history_record.current_privacy_preference\n        )\n\n        assert current_special_purpose_preference.special_purpose == 1\n        assert current_special_purpose_preference.purpose_consent is None\n        assert current_special_purpose_preference.feature is None\n        assert current_special_purpose_preference.special_feature is None\n        assert current_special_purpose_preference.privacy_notice_history_id is None\n        assert current_special_purpose_preference.tcf_version == CURRENT_TCF_VERSION\n\n        current_special_purpose_preference.delete(db)\n        special_purpose_preference_history_record.delete(db)\n\n    def test_create_privacy_preference_for_vendor(\n        self, db, fides_user_provided_identity\n    ):\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"vendor_consent\": \"gvl.42\",\n                \"email\": None,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": None,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": None,\n                \"provided_identity_id\": None,\n                \"request_origin\": \"tcf_overlay\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n                \"url_recorded\": \"example.com\",\n            },\n            check_name=False,\n        )\n        assert preference_history_record.affected_system_status == {}\n        assert preference_history_record.email is None\n        assert preference_history_record.hashed_email is None\n        assert (\n            preference_history_record.fides_user_device\n            == fides_user_device_id\n            is not None\n        )\n        assert (\n            preference_history_record.hashed_fides_user_device\n            == hashed_device_id\n            is not None\n        )\n        assert (\n            preference_history_record.fides_user_device_provided_identity\n            == fides_user_provided_identity\n        )\n        assert preference_history_record.vendor_consent == \"gvl.42\"\n        assert preference_history_record.vendor_legitimate_interests is None\n        assert preference_history_record.purpose_consent is None\n        assert preference_history_record.purpose_legitimate_interests is None\n        assert preference_history_record.special_purpose is None\n        assert preference_history_record.feature is None\n        assert preference_history_record.special_feature is None\n        assert preference_history_record.tcf_version == CURRENT_TCF_VERSION\n        assert preference_history_record.privacy_notice_id is None\n        assert preference_history_record.phone_number is None\n        assert preference_history_record.hashed_phone_number is None\n        assert preference_history_record.preference == UserConsentPreference.opt_out\n        assert preference_history_record.privacy_notice_history is None\n        assert preference_history_record.privacy_request is None\n        assert preference_history_record.provided_identity is None\n        assert preference_history_record.relevant_systems == []\n        assert preference_history_record.request_origin == RequestOrigin.tcf_overlay\n        assert preference_history_record.secondary_user_ids == {\"ga_client_id\": \"test\"}\n        assert (\n            preference_history_record.user_agent\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert preference_history_record.user_geography == \"fr\"\n        assert preference_history_record.url_recorded == \"example.com\"\n\n        # Assert CurrentPrivacyPreference record upserted\n        current_privacy_preference = (\n            preference_history_record.current_privacy_preference\n        )\n        current_privacy_preference_id = current_privacy_preference.id\n        assert current_privacy_preference.preference == UserConsentPreference.opt_out\n        assert current_privacy_preference.privacy_notice_history is None\n        assert current_privacy_preference.vendor_consent == \"gvl.42\"\n        assert current_privacy_preference.tcf_version == CURRENT_TCF_VERSION\n\n        # Save preferences again with an \"opt in\" preference for this privacy notice\n        next_preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": \"opt_in\",\n                \"vendor_consent\": \"gvl.42\",\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"request_origin\": \"tcf_overlay\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n            },\n            check_name=False,\n        )\n\n        assert next_preference_history_record.preference == UserConsentPreference.opt_in\n        assert next_preference_history_record.privacy_notice_history is None\n        assert next_preference_history_record.vendor_consent == \"gvl.42\"\n\n        # Assert CurrentPrivacyPreference record upserted\n        db.refresh(current_privacy_preference)\n        assert current_privacy_preference.preference == UserConsentPreference.opt_in\n        assert current_privacy_preference.privacy_notice_history is None\n        assert current_privacy_preference.vendor_consent == \"gvl.42\"\n        assert current_privacy_preference.vendor_legitimate_interests is None\n        assert current_privacy_preference.purpose_consent is None\n        assert current_privacy_preference.purpose_legitimate_interests is None\n        assert current_privacy_preference.special_purpose is None\n        assert current_privacy_preference.feature is None\n        assert current_privacy_preference.special_feature is None\n        assert current_privacy_preference.tcf_version == CURRENT_TCF_VERSION\n        assert (\n            next_preference_history_record.current_privacy_preference\n            == current_privacy_preference\n        )\n        assert current_privacy_preference.id == current_privacy_preference_id\n\n        db.refresh(preference_history_record)\n        assert (\n            next_preference_history_record.current_privacy_preference\n            == current_privacy_preference\n        )\n        assert preference_history_record.current_privacy_preference is None\n\n        preference_history_record.delete(db)\n        next_preference_history_record.delete(db)\n\n    def test_create_history_and_upsert_current_preferences(\n        self,\n        db,\n        privacy_notice,\n    ):\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\"test@email.com\"),\n            \"encrypted_value\": {\"value\": \"test@email.com\"},\n        }\n        fides_user_provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"fides_user_device_id\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\n                \"test_fides_user_device_id_1234567\"\n            ),\n            \"encrypted_value\": {\"value\": \"test_fides_user_device_id_1234567\"},\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n        fides_user_provided_identity = ProvidedIdentity.create(\n            db, data=fides_user_provided_identity_data\n        )\n\n        privacy_notice_history = privacy_notice.histories[0]\n\n        email, hashed_email = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.email\n        )\n        phone_number, hashed_phone_number = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.phone_number\n        )\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        (\n            preference_history_record,\n            current_record,\n        ) = PrivacyPreferenceHistory.create_history_and_upsert_current_preference(\n            db=db,\n            data={\n                \"email\": email,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": hashed_email,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": hashed_phone_number,\n                \"phone_number\": phone_number,\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": provided_identity.id,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        assert current_record == preference_history_record.current_privacy_preference\n\n    def test_cache_system_status(self, privacy_preference_history, db):\n        assert privacy_preference_history.affected_system_status == {}\n\n        privacy_preference_history.cache_system_status(\n            db, \"test_system_key\", ExecutionLogStatus.pending\n        )\n        assert privacy_preference_history.affected_system_status == {\n            \"test_system_key\": ExecutionLogStatus.pending.value\n        }\n\n        privacy_preference_history.cache_system_status(\n            db, \"test_system_key\", ExecutionLogStatus.complete\n        )\n        assert privacy_preference_history.affected_system_status == {\n            \"test_system_key\": ExecutionLogStatus.complete.value\n        }\n\n    def test_update_secondary_user_ids(self, privacy_preference_history, db):\n        assert privacy_preference_history.secondary_user_ids is None\n\n        privacy_preference_history.update_secondary_user_ids(\n            db, {\"email\": \"test@example.com\"}\n        )\n        assert privacy_preference_history.secondary_user_ids == {\n            \"email\": \"test@example.com\"\n        }\n\n        privacy_preference_history.update_secondary_user_ids(\n            db, {\"ljt_readerID\": \"customer-123\"}\n        )\n        assert privacy_preference_history.secondary_user_ids == {\n            \"email\": \"test@example.com\",\n            \"ljt_readerID\": \"customer-123\",\n        }\n\n        privacy_preference_history.update_secondary_user_ids(\n            db, {\"email\": \"hello@example.com\"}\n        )\n        assert privacy_preference_history.secondary_user_ids == {\n            \"email\": \"hello@example.com\",\n            \"ljt_readerID\": \"customer-123\",\n        }\n\n    def test_consolidate_current_privacy_preferences(self, db, privacy_notice):\n        \"\"\"We might have privacy preferences saved just under a fides user device id in an overlay,\n        and then later, have privacy preferences saved both under an email and that same fides user device id\n\n        We should consider these preferences as being for the same individual, and consolidate\n        them for our \"current privacy preferences\"\n        \"\"\"\n\n        # Let's first just save a privacy preference under a fides user device id\n        fides_user_provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"fides_user_device_id\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\n                \"test_fides_user_device_id_1234567\"\n            ),\n            \"encrypted_value\": {\"value\": \"test_fides_user_device_id_1234567\"},\n        }\n        fides_user_provided_identity = ProvidedIdentity.create(\n            db, data=fides_user_provided_identity_data\n        )\n\n        privacy_notice_history = privacy_notice.histories[0]\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        preference_history_record_for_device = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": None,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": None,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": None,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        # Assert a CurrentPrivacyPreference record was created when the PrivacyPreferenceHistory was created\n        fides_user_device_current_preference = (\n            preference_history_record_for_device.current_privacy_preference\n        )\n        assert fides_user_device_current_preference.created_at is not None\n        assert fides_user_device_current_preference.updated_at is not None\n        assert (\n            fides_user_device_current_preference.preference\n            == UserConsentPreference.opt_out\n        )\n        assert fides_user_device_current_preference.provided_identity_id is None\n        assert (\n            fides_user_device_current_preference.fides_user_device_provided_identity_id\n            == fides_user_provided_identity.id\n        )\n        assert (\n            fides_user_device_current_preference.privacy_notice_id == privacy_notice.id\n        )\n        assert (\n            fides_user_device_current_preference.privacy_notice_history_id\n            == privacy_notice_history.id\n        )\n        assert (\n            fides_user_device_current_preference.privacy_preference_history_id\n            == preference_history_record_for_device.id\n        )\n\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\"test@email.com\"),\n            \"encrypted_value\": {\"value\": \"test@email.com\"},\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n        email, hashed_email = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.email\n        )\n\n        preference_history_record_for_email = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": email,\n                \"fides_user_device\": None,\n                \"fides_user_device_provided_identity_id\": None,\n                \"hashed_email\": hashed_email,\n                \"hashed_fides_user_device\": None,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_in\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": provided_identity.id,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        # Assert a new CurrentPrivacyPreference record was created when the PrivacyPreferenceHistory was created with email\n        email_current_preference = (\n            preference_history_record_for_email.current_privacy_preference\n        )\n        assert email_current_preference.created_at is not None\n        assert email_current_preference.updated_at is not None\n        assert email_current_preference.preference == UserConsentPreference.opt_in\n        assert email_current_preference.provided_identity_id == provided_identity.id\n        assert email_current_preference.fides_user_device_provided_identity_id is None\n        assert email_current_preference.privacy_notice_id == privacy_notice.id\n        assert (\n            email_current_preference.privacy_notice_history_id\n            == privacy_notice_history.id\n        )\n        assert (\n            email_current_preference.privacy_preference_history_id\n            == preference_history_record_for_email.id\n        )\n\n        # Now user saves a preference from the privacy center with verified email that also has their device id\n        preference_history_saved_with_both_email_and_device_id = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": email,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": hashed_email,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_in\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": provided_identity.id,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        # Assert existing CurrentPrivacyPreference record was updated when the PrivacyPreferenceHistory was created\n        # and consolidated preferences for the email and the user device. The preferences for device only was deleted\n        current_preference = (\n            preference_history_saved_with_both_email_and_device_id.current_privacy_preference\n        )\n        assert current_preference.created_at is not None\n        assert current_preference.updated_at is not None\n        assert current_preference.preference == UserConsentPreference.opt_in\n        assert current_preference.provided_identity_id == provided_identity.id\n        assert (\n            current_preference.fides_user_device_provided_identity_id\n            == fides_user_provided_identity.id\n        )\n        assert current_preference.privacy_notice_id == privacy_notice.id\n        assert current_preference.privacy_notice_history_id == privacy_notice_history.id\n        assert (\n            current_preference.privacy_preference_history_id\n            == preference_history_saved_with_both_email_and_device_id.id\n        )\n\n        assert (\n            current_preference\n            == email_current_preference\n            != fides_user_device_current_preference\n        )\n        with pytest.raises(InvalidRequestError):\n            # Can't refresh because this preference has been deleted, and consolidated with the other\n            db.refresh(fides_user_device_current_preference)\n\n    def test_consolidate_current_tcf_privacy_preferences(\n        self, db, fides_user_provided_identity\n    ):\n        \"\"\"\n        Consolidate TCF Privacy preferences saved for the same individual\n        \"\"\"\n\n        # Let's first just save a tcf privacy preference under a fides user device id\n\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        preference_history_record_for_device = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": None,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"preference\": \"opt_in\",\n                \"request_origin\": \"tcf_overlay\",\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n                \"special_purpose\": 1,\n            },\n            check_name=False,\n        )\n\n        # Assert a CurrentPrivacyPreference record was created when the PrivacyPreferenceHistory was created\n        fides_user_device_current_preference = (\n            preference_history_record_for_device.current_privacy_preference\n        )\n        assert fides_user_device_current_preference.created_at is not None\n        assert fides_user_device_current_preference.updated_at is not None\n        assert (\n            fides_user_device_current_preference.preference\n            == UserConsentPreference.opt_in\n        )\n        assert fides_user_device_current_preference.provided_identity_id is None\n        assert (\n            fides_user_device_current_preference.fides_user_device_provided_identity_id\n            == fides_user_provided_identity.id\n        )\n        assert fides_user_device_current_preference.privacy_notice_id is None\n        assert fides_user_device_current_preference.special_purpose == 1\n        assert fides_user_device_current_preference.privacy_notice_history_id is None\n        assert (\n            fides_user_device_current_preference.privacy_preference_history_id\n            == preference_history_record_for_device.id\n        )\n\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\"test@email.com\"),\n            \"encrypted_value\": {\"value\": \"test@email.com\"},\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n        email, hashed_email = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.email\n        )\n\n        preference_history_record_for_email = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": email,\n                \"hashed_email\": hashed_email,\n                \"preference\": \"opt_in\",\n                \"provided_identity_id\": provided_identity.id,\n                \"special_purpose\": 1,\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_geography\": \"fr\",\n                \"url_recorded\": \"example.com/\",\n            },\n            check_name=False,\n        )\n\n        # Assert a new CurrentPrivacyPreference record was created when the PrivacyPreferenceHistory was created with email\n        email_current_preference = (\n            preference_history_record_for_email.current_privacy_preference\n        )\n        assert email_current_preference.created_at is not None\n        assert email_current_preference.updated_at is not None\n        assert email_current_preference.preference == UserConsentPreference.opt_in\n        assert email_current_preference.provided_identity_id == provided_identity.id\n        assert email_current_preference.fides_user_device_provided_identity_id is None\n        assert email_current_preference.privacy_notice_id is None\n        assert email_current_preference.special_purpose == 1\n        assert email_current_preference.privacy_notice_history_id is None\n        assert (\n            email_current_preference.privacy_preference_history_id\n            == preference_history_record_for_email.id\n        )\n\n        # Now user saves a preference from the tcf overlay with verified email that also has their device id\n        preference_history_saved_with_both_email_and_device_id = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": email,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": hashed_email,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"preference\": \"opt_in\",\n                \"provided_identity_id\": provided_identity.id,\n                \"special_purpose\": 1,\n                \"request_origin\": \"tcf_overlay\",\n                \"user_geography\": \"fr\",\n            },\n            check_name=False,\n        )\n\n        # Assert existing CurrentPrivacyPreference record was updated when the PrivacyPreferenceHistory was created\n        # and consolidated preferences for the email and the user device. The preferences for device only was deleted\n        current_preference = (\n            preference_history_saved_with_both_email_and_device_id.current_privacy_preference\n        )\n        assert current_preference.created_at is not None\n        assert current_preference.updated_at is not None\n        assert current_preference.preference == UserConsentPreference.opt_in\n        assert current_preference.provided_identity_id == provided_identity.id\n        assert (\n            current_preference.fides_user_device_provided_identity_id\n            == fides_user_provided_identity.id\n        )\n        assert current_preference.special_purpose == 1\n        assert current_preference.privacy_notice_id is None\n        assert current_preference.privacy_notice_history_id is None\n        assert (\n            current_preference.privacy_preference_history_id\n            == preference_history_saved_with_both_email_and_device_id.id\n        )\n\n        assert (\n            current_preference\n            == email_current_preference\n            != fides_user_device_current_preference\n        )\n        with pytest.raises(InvalidRequestError):\n            # Can't refresh because this preference has been deleted, and consolidated with the other\n            db.refresh(fides_user_device_current_preference)\n\n        current_preference.delete(db)\n        preference_history_saved_with_both_email_and_device_id.delete(db)\n        preference_history_record_for_device.delete(db)\n\n    def test_update_current_privacy_preferences_fides_id_only(\n        self, db, privacy_notice, fides_user_provided_identity\n    ):\n        \"\"\"Assert that if we save privacy preferences for a fides user device id and current preferences\n        already exists, the current preference is updated correctly.\"\n        \"\"\"\n\n        privacy_notice_history = privacy_notice.histories[0]\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        preference_history_record_for_device = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": None,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": None,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": None,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        # Assert a CurrentPrivacyPreference record was created when the PrivacyPreferenceHistory was created\n        fides_user_device_current_preference = (\n            preference_history_record_for_device.current_privacy_preference\n        )\n        assert (\n            fides_user_device_current_preference.preference\n            == UserConsentPreference.opt_out\n        )\n        created_at = fides_user_device_current_preference.created_at\n        updated_at = fides_user_device_current_preference.updated_at\n\n        # Save a preference but change the preference from opt out to opt in\n        new_preference_history_record_for_device = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": None,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": None,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_in\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": None,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        # Assert a new CurrentPrivacyPreference record was created when the PrivacyPreferenceHistory was created with email\n        db.refresh(fides_user_device_current_preference)\n        assert (\n            fides_user_device_current_preference.preference\n            == UserConsentPreference.opt_in\n        )\n        assert fides_user_device_current_preference.created_at == created_at\n        assert fides_user_device_current_preference.updated_at > updated_at\n\n        new_preference_history_record_for_device.delete(db)\n        preference_history_record_for_device.delete(db)\n\n    def test_consent_record_type_property(\n        self,\n        privacy_preference_history_for_vendor,\n        privacy_preference_history_for_tcf_special_purpose,\n        privacy_preference_history_us_ca_provide,\n        privacy_preference_history_for_tcf_purpose_consent,\n    ):\n        assert (\n            privacy_preference_history_us_ca_provide.consent_record_type\n            == ConsentRecordType.privacy_notice_id\n        )\n\n        assert (\n            privacy_preference_history_for_vendor.consent_record_type\n            == ConsentRecordType.vendor_consent\n        )\n\n        assert (\n            privacy_preference_history_for_tcf_special_purpose.consent_record_type\n            == ConsentRecordType.special_purpose\n        )\n\n        assert (\n            privacy_preference_history_for_tcf_purpose_consent.consent_record_type\n            == ConsentRecordType.purpose_consent\n        )\n\n    def test_validate_before_saving_consent_history_helper(\n        self, db, fides_user_provided_identity, privacy_notice, system\n    ):\n        with pytest.raises(IdentityNotFoundException):\n            _validate_before_saving_consent_history(db, {})\n\n        with pytest.raises(PrivacyNoticeHistoryNotFound):\n            _validate_before_saving_consent_history(\n                db, {\"privacy_notice_history_id\": \"bad\"}\n            )\n\n        with pytest.raises(ConsentHistorySaveError):\n            # We need to save against one consent record type, not 2\n            _validate_before_saving_consent_history(\n                db,\n                {\n                    \"special_purpose\": 1,\n                    \"purpose_consent\": 1,\n                    \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                },\n            )\n\n        with pytest.raises(ConsentHistorySaveError):\n            # We need to save against one consent record type, not 0\n            _validate_before_saving_consent_history(\n                db,\n                {\n                    \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id\n                },\n            )\n\n        with pytest.raises(SystemNotFound):\n            # Attempted to save preferences against system that doesn't exist\n            _validate_before_saving_consent_history(\n                db,\n                {\n                    \"system_consent\": \"bad system\",\n                    \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                },\n            )\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"purpose_consent\": 1,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history is None\n        assert tcf_key == ConsentRecordType.purpose_consent.value\n        assert tcf_val == 1\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"special_purpose\": 2,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history is None\n        assert tcf_key == ConsentRecordType.special_purpose.value\n        assert tcf_val == 2\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"vendor_consent\": \"amplitude\",\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history is None\n        assert tcf_key == ConsentRecordType.vendor_consent.value\n        assert tcf_val == \"amplitude\"\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"feature\": 3,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history is None\n        assert tcf_key == ConsentRecordType.feature.value\n        assert tcf_val == 3\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"special_feature\": 4,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history is None\n        assert tcf_key == ConsentRecordType.special_feature.value\n        assert tcf_val == 4\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history == privacy_notice.histories[0]\n        assert tcf_key is None\n        assert tcf_val is None\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"system_consent\": system.id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history is None\n        assert tcf_key == ConsentRecordType.system_consent.value\n        assert tcf_val == system.id\n\n\nclass TestDeterminePrivacyPreferenceHistoryRelevantSystems:\n    def test_determine_relevant_systems_for_notice(\n        self, db, privacy_notice, system_with_no_uses\n    ):\n        # Add data use that is not relevant for notice\n        pd_1 = PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"analytics\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"dataset_references\": None,\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db, privacy_notice_history=privacy_notice.histories[0]\n            )\n            == []\n        )\n\n        # Update data use to be relevant for notice\n        pd_1.data_use = privacy_notice.data_uses[0]\n        pd_1.save(db)\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db, privacy_notice_history=privacy_notice.histories[0]\n        ) == [system_with_no_uses.fides_key]\n\n        pd_1.delete(db)\n\n    def test_determine_relevant_systems_for_tcf_consent_purpose(\n        self, db, system_with_no_uses\n    ):\n        # Add data use to system that corresponds to purpose 3.  Also has consent legal basis, which is important.\n        pd_1 = PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"marketing.advertising.profiling\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"dataset_references\": None,\n                \"legal_basis_for_processing\": \"Consent\",\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db, tcf_field=TCFComponentType.purpose_consent.value, tcf_value=2\n            )\n            == []\n        )\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db, tcf_field=TCFComponentType.purpose_consent.value, tcf_value=3\n        ) == [system_with_no_uses.fides_key]\n\n        pd_1.delete(db)\n\n    def test_determine_relevant_systems_for_tcf_legitimate_interests_purpose(\n        self, db, system_with_no_uses\n    ):\n        # Add data use to system that corresponds to purpose 3.  Also has LI legal basis, which is important.\n        pd_1 = PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"marketing.advertising.profiling\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"dataset_references\": None,\n                \"legal_basis_for_processing\": \"Legitimate interests\",\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n\n        # This system is not relevant for purpose consent\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db, tcf_field=TCFComponentType.purpose_consent.value, tcf_value=3\n            )\n            == []\n        )\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db,\n            tcf_field=TCFComponentType.purpose_legitimate_interests.value,\n            tcf_value=3,\n        ) == [system_with_no_uses.fides_key]\n\n        pd_1.delete(db)\n\n    def test_determine_relevant_systems_for_tcf_special_purpose(\n        self, db, system_with_no_uses\n    ):\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db, tcf_field=TCFComponentType.special_purpose.value, tcf_value=2\n            )\n            == []\n        )\n\n        # Add relevant data use for special purpose 2 to system\n        pd_1 = PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"marketing.advertising.serving\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"legal_basis_for_processing\": \"Consent\",\n                \"dataset_references\": None,\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db, tcf_field=TCFComponentType.special_purpose.value, tcf_value=2\n        ) == [system_with_no_uses.fides_key]\n\n        pd_1.delete(db)\n\n    def test_determine_relevant_systems_for_tcf_consent_vendor(\n        self, db, system_with_no_uses\n    ):\n        system_with_no_uses.vendor_id = \"amplitude\"\n        system_with_no_uses.save(db)\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db,\n                tcf_field=TCFComponentType.vendor_consent.value,\n                tcf_value=\"amplitude\",\n            )\n            == []\n        )\n\n        # Vendor needs to have a relevant data use, and a specific consent legal basis to make the vendor relevant\n        PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"marketing.advertising.serving\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"legal_basis_for_processing\": \"Consent\",\n                \"dataset_references\": None,\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db, tcf_field=TCFComponentType.vendor_consent.value, tcf_value=\"amplitude\"\n        ) == [system_with_no_uses.fides_key]\n\n    def test_determine_relevant_systems_for_tcf_legitimate_interests_vendor(\n        self, db, system_with_no_uses\n    ):\n        system_with_no_uses.vendor_id = \"amplitude\"\n        system_with_no_uses.save(db)\n\n        # Vendor needs to have a relevant data use, and a specific consent legal basis to make the vendor relevant\n        PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"marketing.advertising.serving\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"legal_basis_for_processing\": \"Legitimate interests\",\n                \"dataset_references\": None,\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n\n        # Vendor not relevant for vendor consent\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db,\n                tcf_field=TCFComponentType.vendor_consent.value,\n                tcf_value=\"amplitude\",\n            )\n            == []\n        )\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db,\n            tcf_field=TCFComponentType.vendor_legitimate_interests.value,\n            tcf_value=\"amplitude\",\n        ) == [system_with_no_uses.fides_key]\n\n    def test_determine_relevant_systems_for_tcf_feature(self, db, system):\n        # Add feature that we don't have a preference for\n        decl = system.privacy_declarations[0]\n        decl.features = [\"Link different devices\"]\n        decl.save(db)\n\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db, tcf_field=TCFComponentType.feature.value, tcf_value=1\n            )\n            == []\n        )\n\n        decl.features = [\"Match and combine data from other data sources\"]\n        decl.data_use = \"marketing.advertising.serving\"\n        decl.legal_basis_for_processing = \"Consent\"\n        decl.save(db)\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db, tcf_field=TCFComponentType.feature.value, tcf_value=1\n        ) == [system.fides_key]\n\n    def test_determine_relevant_systems_for_tcf_special_feature(self, db, system):\n        # Add special feature that we're not saving preference for\n        decl = system.privacy_declarations[0]\n        decl.features = [\"Actively scan device characteristics for identification\"]\n        decl.data_use = \"marketing.advertising.serving\"\n        decl.legal_basis_for_processing = \"Consent\"\n        decl.save(db)\n\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db, tcf_field=TCFComponentType.feature.value, tcf_value=1\n            )\n            == []\n        )\n\n        decl.features = [\"Use precise geolocation data\"]\n        decl.save(db)\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db, tcf_field=TCFComponentType.special_feature.value, tcf_value=1\n        ) == [system.fides_key]\n\n    def test_determine_relevant_systems_for_tcf_system(self, db, system_with_no_uses):\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db,\n                tcf_field=TCFComponentType.system_consent.value,\n                tcf_value=\"non_matching_system_id\",\n            )\n            == []\n        )\n\n        pd = PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"marketing.advertising.serving\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"dataset_references\": None,\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db,\n                tcf_field=TCFComponentType.system_consent.value,\n                tcf_value=\"non_matching_system_id\",\n            )\n            == []\n        )\n\n        pd.legal_basis_for_processing = \"Consent\"\n        pd.save(db)\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db,\n            tcf_field=TCFComponentType.system_consent.value,\n            tcf_value=system_with_no_uses.id,\n        ) == [system_with_no_uses.fides_key]\n\n\nclass TestCurrentPrivacyPreference:\n    def test_get_preference_by_notice_and_fides_user_device(\n        self,\n        db,\n        empty_provided_identity,\n        privacy_preference_history_us_ca_provide_for_fides_user,\n        privacy_notice,\n        privacy_notice_us_ca_provide,\n        fides_user_provided_identity,\n    ):\n        pref = CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n            db=db,\n            fides_user_provided_identity=fides_user_provided_identity,\n            preference_type=ConsentRecordType.privacy_notice_id,\n            preference_value=privacy_notice_us_ca_provide.id,\n        )\n        assert (\n            pref\n            == privacy_preference_history_us_ca_provide_for_fides_user.current_privacy_preference\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=empty_provided_identity,\n                preference_type=ConsentRecordType.privacy_notice_id,\n                preference_value=privacy_notice.id,\n            )\n            is None\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                preference_type=ConsentRecordType.privacy_notice_id,\n                preference_value=privacy_notice.id,\n            )\n            is None\n        )\n\n    def test_get_preference_by_purpose_and_fides_user_device(\n        self,\n        db,\n        empty_provided_identity,\n        privacy_preference_history_for_tcf_purpose_consent,\n        fides_user_provided_identity,\n    ):\n        pref = CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n            db=db,\n            fides_user_provided_identity=fides_user_provided_identity,\n            preference_type=ConsentRecordType.purpose_consent,\n            preference_value=8,\n        )\n        assert (\n            pref\n            == privacy_preference_history_for_tcf_purpose_consent.current_privacy_preference\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=empty_provided_identity,\n                preference_type=ConsentRecordType.purpose_consent,\n                preference_value=8,\n            )\n            is None\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                preference_type=ConsentRecordType.purpose_consent,\n                preference_value=500,\n            )\n            is None\n        )\n\n    def test_get_preference_by_feature_and_fides_user_device(\n        self,\n        db,\n        empty_provided_identity,\n        privacy_preference_history_for_tcf_feature,\n        fides_user_provided_identity,\n    ):\n        pref = CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n            db=db,\n            fides_user_provided_identity=fides_user_provided_identity,\n            preference_type=ConsentRecordType.feature,\n            preference_value=2,\n        )\n        assert (\n            pref\n            == privacy_preference_history_for_tcf_feature.current_privacy_preference\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=empty_provided_identity,\n                preference_type=ConsentRecordType.feature,\n                preference_value=2,\n            )\n            is None\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                preference_type=ConsentRecordType.feature,\n                preference_value=500,\n            )\n            is None\n        )\n\n    def test_get_preference_by_system_and_fides_user_device(\n        self,\n        db,\n        empty_provided_identity,\n        privacy_preference_history_for_system,\n        fides_user_provided_identity,\n        system,\n    ):\n        pref = CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n            db=db,\n            fides_user_provided_identity=fides_user_provided_identity,\n            preference_type=ConsentRecordType.system_consent,\n            preference_value=system.id,\n        )\n        assert pref == privacy_preference_history_for_system.current_privacy_preference\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=empty_provided_identity,\n                preference_type=ConsentRecordType.system_consent,\n                preference_value=system.id,\n            )\n            is None\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                preference_type=ConsentRecordType.system_consent,\n                preference_value=\"another system\",\n            )\n            is None\n        )\n\n\nclass TestAnonymizeIpAddress:\n    def test_anonymize_ip_address_empty_string(self):\n        assert anonymize_ip_address(\"\") is None\n\n    def test_anonymize_ip_address_none(self):\n        assert anonymize_ip_address(None) is None\n\n    def test_anonymize_bad_ip_address(self):\n        assert anonymize_ip_address(\"bad_address\") is None\n\n    def test_anonymize_ip_address_list(self):\n        assert anonymize_ip_address(\"[]\") is None\n\n    def test_anonymize_ipv4(self):\n        assert anonymize_ip_address(\"12.214.31.144\") == \"12.214.31.0\"\n\n    def test_anonymize_ipv6(self):\n        assert (\n            anonymize_ip_address(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")\n            == \"2001:0db8:85a3:0000:0000:0000:0000:0000\"\n        )\n\n\nclass TestServedNoticeHistory:\n    def test_create_served_notice_history_for_multiple_consent_attributes(\n        self, db, fides_user_provided_identity, privacy_experience_france_tcf_overlay\n    ):\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        with pytest.raises(ConsentHistorySaveError):\n            ServedNoticeHistory.create(\n                db=db,\n                data={\n                    \"anonymized_ip_address\": \"12.214.31.0\",\n                    \"fides_user_device\": fides_user_device_id,\n                    \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                    \"hashed_fides_user_device\": hashed_device_id,\n                    \"request_origin\": \"tcf_overlay\",\n                    \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                    \"user_geography\": \"fr\",\n                    \"url_recorded\": \"example.com/\",\n                    \"acknowledge_mode\": False,\n                    \"serving_component\": ServingComponent.tcf_overlay,\n                    \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n                    \"purpose_consent\": 1,\n                    \"special_purpose\": 2,\n                },\n                check_name=False,\n            )\n\n    def test_create_served_notice_history_for_notice(\n        self,\n        db,\n        privacy_notice,\n        privacy_experience_privacy_center,\n        experience_config_privacy_center,\n    ):\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\"ethyca@email.com\"),\n            \"encrypted_value\": {\"value\": \"ethyca@email.com\"},\n        }\n        fides_user_provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"fides_user_device_id\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\n                \"test_fides_user_device_id_abcdefg\"\n            ),\n            \"encrypted_value\": {\"value\": \"test_fides_user_device_id_abcdefg\"},\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n        fides_user_provided_identity = ProvidedIdentity.create(\n            db, data=fides_user_provided_identity_data\n        )\n\n        privacy_notice_history = privacy_notice.histories[0]\n\n        email, hashed_email = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.email\n        )\n        phone_number, hashed_phone_number = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.phone_number\n        )\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        served_notice_history_record = ServedNoticeHistory.create(\n            db=db,\n            data={\n                \"anonymized_ip_address\": \"12.214.31.0\",\n                \"email\": email,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": hashed_email,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": hashed_phone_number,\n                \"phone_number\": phone_number,\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": provided_identity.id,\n                \"request_origin\": \"privacy_center\",\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_co\",\n                \"url_recorded\": \"example.com/privacy_center\",\n                \"acknowledge_mode\": False,\n                \"serving_component\": ServingComponent.privacy_center,\n                \"privacy_experience_id\": privacy_experience_privacy_center.id,\n                \"privacy_experience_config_history_id\": experience_config_privacy_center.histories[\n                    0\n                ].id,\n            },\n            check_name=False,\n        )\n        assert served_notice_history_record.email == \"ethyca@email.com\"\n        assert (\n            served_notice_history_record.hashed_email\n            == provided_identity.hashed_value\n            is not None\n        )\n        assert (\n            served_notice_history_record.fides_user_device\n            == fides_user_device_id\n            is not None\n        )\n        assert (\n            served_notice_history_record.hashed_fides_user_device\n            == hashed_device_id\n            is not None\n        )\n        assert (\n            served_notice_history_record.fides_user_device_provided_identity\n            == fides_user_provided_identity\n        )\n\n        assert served_notice_history_record.phone_number is None\n        assert served_notice_history_record.hashed_phone_number is None\n        assert (\n            served_notice_history_record.privacy_notice_history\n            == privacy_notice_history\n        )\n        assert served_notice_history_record.privacy_notice_id == privacy_notice.id\n        assert served_notice_history_record.provided_identity == provided_identity\n        assert (\n            served_notice_history_record.request_origin == RequestOrigin.privacy_center\n        )\n        assert (\n            served_notice_history_record.user_agent\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert served_notice_history_record.user_geography == \"us_co\"\n        assert served_notice_history_record.url_recorded == \"example.com/privacy_center\"\n\n        # Assert ServedNoticeHistory record upserted\n        last_served_notice = served_notice_history_record.last_served_record\n        assert last_served_notice.privacy_notice_history == privacy_notice_history\n        assert last_served_notice.privacy_notice_id == privacy_notice.id\n        assert last_served_notice.provided_identity_id == provided_identity.id\n        assert (\n            last_served_notice.fides_user_device_provided_identity_id\n            == fides_user_provided_identity.id\n        )\n        assert (\n            last_served_notice.served_notice_history_id\n            == served_notice_history_record.id\n        )\n\n        served_notice_history_record.delete(db)\n        last_served_notice.delete(db)\n\n    def test_create_served_notice_history_for_tcf_purpose(\n        self, db, fides_user_provided_identity, privacy_experience_france_tcf_overlay\n    ):\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        served_notice_history_record = ServedNoticeHistory.create(\n            db=db,\n            data={\n                \"anonymized_ip_address\": \"12.214.31.0\",\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"request_origin\": \"tcf_overlay\",\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n                \"url_recorded\": \"example.com/\",\n                \"acknowledge_mode\": False,\n                \"serving_component\": ServingComponent.tcf_overlay,\n                \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n                \"purpose_consent\": 1,\n            },\n            check_name=False,\n        )\n        assert served_notice_history_record.email is None\n        assert served_notice_history_record.hashed_email is None\n        assert (\n            served_notice_history_record.fides_user_device\n            == fides_user_device_id\n            is not None\n        )\n        assert (\n            served_notice_history_record.hashed_fides_user_device\n            == hashed_device_id\n            is not None\n        )\n        assert (\n            served_notice_history_record.fides_user_device_provided_identity\n            == fides_user_provided_identity\n        )\n\n        assert served_notice_history_record.phone_number is None\n        assert served_notice_history_record.hashed_phone_number is None\n        assert served_notice_history_record.privacy_notice_history is None\n        assert served_notice_history_record.provided_identity is None\n        assert served_notice_history_record.request_origin == RequestOrigin.tcf_overlay\n        assert (\n            served_notice_history_record.user_agent\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert served_notice_history_record.user_geography == \"fr\"\n        assert served_notice_history_record.url_recorded == \"example.com/\"\n        assert served_notice_history_record.purpose_consent == 1\n        assert served_notice_history_record.special_purpose is None\n        assert served_notice_history_record.feature is None\n        assert served_notice_history_record.special_feature is None\n        assert served_notice_history_record.vendor_consent is None\n        assert (\n            served_notice_history_record.consent_record_type\n            == ConsentRecordType.purpose_consent\n        )\n\n        # Assert ServedNoticeHistory record upserted\n        last_served_notice = served_notice_history_record.last_served_record\n        assert last_served_notice.privacy_notice_history is None\n        assert last_served_notice.privacy_notice_id is None\n        assert last_served_notice.purpose_consent == 1\n        assert last_served_notice.special_purpose is None\n        assert last_served_notice.feature is None\n        assert last_served_notice.special_feature is None\n        assert last_served_notice.vendor_consent is None\n        assert last_served_notice.provided_identity_id is None\n        assert (\n            last_served_notice.fides_user_device_provided_identity_id\n            == fides_user_provided_identity.id\n        )\n        assert (\n            last_served_notice.served_notice_history_id\n            == served_notice_history_record.id\n        )\n\n        served_notice_history_record.delete(db)\n        last_served_notice.delete(db)\n\n    def test_consent_record_type_property(\n        self,\n        served_notice_history,\n        served_notice_history_for_tcf_purpose,\n        served_notice_history_for_tcf_special_purpose,\n    ):\n        assert (\n            served_notice_history_for_tcf_special_purpose.consent_record_type\n            == ConsentRecordType.special_purpose\n        )\n\n        assert (\n            served_notice_history.consent_record_type\n            == ConsentRecordType.privacy_notice_id\n        )\n\n        assert (\n            served_notice_history_for_tcf_purpose.consent_record_type\n            == ConsentRecordType.purpose_consent\n        )\n\n\nclass TestLastServedNotice:\n    def test_served_latest_version_of_notice(\n        self,\n        db,\n        served_notice_history_us_ca_provide_for_fides_user,\n        privacy_notice_us_ca_provide,\n    ):\n        last_served = (\n            served_notice_history_us_ca_provide_for_fides_user.last_served_record\n        )\n        assert last_served.record_matches_current_version is True\n\n        privacy_notice_us_ca_provide.update(db, data={\"description\": \"new_description\"})\n        assert privacy_notice_us_ca_provide.version == 2.0\n        assert privacy_notice_us_ca_provide.description == \"new_description\"\n\n        assert last_served.record_matches_current_version is False\n\n    def test_served_latest_tcf_version(\n        self,\n        db,\n        served_notice_history_for_tcf_purpose,\n    ):\n        last_served = served_notice_history_for_tcf_purpose.last_served_record\n        assert last_served.record_matches_current_version is True\n\n        # Just for demonstration\n        last_served.update(db, data={\"tcf_version\": \"1.0\"})\n        assert last_served.record_matches_current_version is False\n\n    def test_get_last_served_for_notice_and_fides_user_device(\n        self,\n        db,\n        fides_user_provided_identity,\n        served_notice_history_us_ca_provide_for_fides_user,\n        privacy_notice_us_ca_provide,\n        empty_provided_identity,\n        privacy_notice,\n    ):\n        retrieved_record = (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                record_type=ConsentRecordType.privacy_notice_id,\n                preference_value=privacy_notice_us_ca_provide.id,\n            )\n        )\n        assert (\n            retrieved_record\n            == served_notice_history_us_ca_provide_for_fides_user.last_served_record\n        )\n\n        assert (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=empty_provided_identity,\n                record_type=ConsentRecordType.privacy_notice_id,\n                preference_value=privacy_notice_us_ca_provide.id,\n            )\n            is None\n        )\n        assert (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                record_type=ConsentRecordType.privacy_notice_id,\n                preference_value=privacy_notice.id,\n            )\n            is None\n        )\n\n    def test_get_last_served_for_purpose_and_fides_user_device(\n        self,\n        db,\n        fides_user_provided_identity,\n        empty_provided_identity,\n        served_notice_history_for_tcf_purpose,\n    ):\n        retrieved_record = (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                record_type=ConsentRecordType.purpose_consent,\n                preference_value=8,\n            )\n        )\n        assert (\n            retrieved_record == served_notice_history_for_tcf_purpose.last_served_record\n        )\n\n        assert (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=empty_provided_identity,\n                record_type=ConsentRecordType.purpose_consent,\n                preference_value=8,\n            )\n            is None\n        )\n        assert (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                record_type=ConsentRecordType.purpose_consent,\n                preference_value=200,\n            )\n            is None\n        )\n\n    def test_get_last_served_for_feature_and_fides_user_device(\n        self,\n        db,\n        fides_user_provided_identity,\n        empty_provided_identity,\n        served_notice_history_for_tcf_feature,\n    ):\n        retrieved_record = (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                record_type=ConsentRecordType.feature,\n                preference_value=2,\n            )\n        )\n        assert (\n            retrieved_record == served_notice_history_for_tcf_feature.last_served_record\n        )\n\n        assert (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=empty_provided_identity,\n                record_type=ConsentRecordType.feature,\n                preference_value=2,\n            )\n            is None\n        )\n        assert (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                record_type=ConsentRecordType.feature,\n                preference_value=200,\n            )\n            is None\n        )\n", "from __future__ import annotations\n\nfrom html import unescape\n\nimport pytest\nfrom fastapi import HTTPException\nfrom fideslang import DataUse\nfrom sqlalchemy.orm.attributes import flag_modified\nfrom starlette.exceptions import HTTPException\n\nfrom fides.api.app_setup import DEFAULT_PRIVACY_NOTICES_PATH\nfrom fides.api.models.privacy_experience import (\n    BannerEnabled,\n    ComponentType,\n    PrivacyExperience,\n)\nfrom fides.api.models.privacy_notice import (\n    ConsentMechanism,\n    EnforcementLevel,\n    PrivacyNoticeRegion,\n    PrivacyNoticeTemplate,\n)\nfrom fides.api.models.privacy_preference import PrivacyPreferenceHistory\nfrom fides.api.models.sql_models import DataUse as sql_DataUse\nfrom fides.api.schemas.privacy_notice import PrivacyNoticeCreation, PrivacyNoticeWithId\nfrom fides.api.util.consent_util import (\n    EEA_COUNTRIES,\n    add_complete_system_status_for_consent_reporting,\n    add_errored_system_status_for_consent_reporting,\n    cache_initial_status_and_identities_for_consent_reporting,\n    create_default_experience_config,\n    create_privacy_notices_util,\n    create_tcf_experiences_on_startup,\n    get_fides_user_device_id_provided_identity,\n    load_default_notices_on_startup,\n    should_opt_in_to_service,\n    upsert_privacy_notice_templates_util,\n    validate_notice_data_uses,\n)\n\n\nclass TestShouldOptIntoService:\n    @pytest.mark.parametrize(\n        \"preference, should_opt_in\",\n        [(\"opt_in\", True), (\"opt_out\", False), (\"acknowledge\", None)],\n    )\n    def test_matching_data_use(\n        self,\n        preference,\n        should_opt_in,\n        db,\n        system,\n        privacy_request_with_consent_policy,\n        privacy_notice,\n        fides_user_provided_identity,\n    ):\n        \"\"\"\n        Privacy Notice Enforcement Level = \"system_wide\"\n        Privacy Notice Data Use = \"marketing.advertising\"\n        System Data Use = \"marketing.advertising\"\n        \"\"\"\n        pref = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": preference,\n                \"privacy_notice_history_id\": privacy_notice.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref.privacy_request_id = privacy_request_with_consent_policy.id\n        pref.save(db)\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference == should_opt_in\n\n        pref.delete(db)\n\n    @pytest.mark.parametrize(\n        \"preference, should_opt_in\",\n        [(\"opt_in\", True), (\"opt_out\", False), (\"acknowledge\", None)],\n    )\n    def test_notice_use_is_parent_of_system_use(\n        self,\n        preference,\n        should_opt_in,\n        db,\n        system,\n        privacy_notice_us_ca_provide,\n        privacy_request_with_consent_policy,\n        fides_user_provided_identity,\n    ):\n        \"\"\"\n        Privacy Notice Enforcement Level = \"system_wide\"\n        Privacy Notice Data Use = \"essential\"\n        System Data Use = \"essential.service.operations\"\n        \"\"\"\n        privacy_declarations = system.privacy_declarations\n        system.privacy_declarations[0].update(\n            db=db, data={\"data_use\": \"essential.service.operations\"}\n        )\n\n        system.privacy_declarations = privacy_declarations\n        flag_modified(system, \"privacy_declarations\")\n        system.save(db)\n\n        pref = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": preference,\n                \"privacy_notice_history_id\": privacy_notice_us_ca_provide.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref.privacy_request_id = privacy_request_with_consent_policy.id\n        pref.save(db)\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference == should_opt_in\n        pref.delete(db)\n\n    @pytest.mark.parametrize(\n        \"preference, should_opt_in\",\n        [(\"opt_in\", None), (\"opt_out\", None), (\"acknowledge\", None)],\n    )\n    def test_notice_use_is_child_of_system_use(\n        self,\n        preference,\n        should_opt_in,\n        db,\n        system,\n        privacy_notice_us_co_provide_service_operations,\n        privacy_request_with_consent_policy,\n        fides_user_provided_identity,\n    ):\n        \"\"\"\n        Privacy Notice Enforcement Level = \"system_wide\"\n        Privacy Notice Data Use = \"essential.service.operations\"\n        System Data Use = \"essential\"\n        \"\"\"\n        privacy_declarations = system.privacy_declarations\n        system.privacy_declarations[0].update(db=db, data={\"data_use\": \"essential\"})\n        system.privacy_declarations = privacy_declarations\n        flag_modified(system, \"privacy_declarations\")\n        system.save(db)\n\n        pref = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": preference,\n                \"privacy_notice_history_id\": privacy_notice_us_co_provide_service_operations.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref.privacy_request_id = privacy_request_with_consent_policy.id\n        pref.save(db)\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference == should_opt_in\n        pref.delete(db)\n\n    @pytest.mark.parametrize(\n        \"preference, should_opt_in\",\n        [(\"opt_in\", None), (\"opt_out\", None), (\"acknowledge\", None)],\n    )\n    def test_enforcement_frontend_only(\n        self,\n        preference,\n        should_opt_in,\n        db,\n        system,\n        privacy_request_with_consent_policy,\n        privacy_notice_fr_provide_service_frontend_only,\n        fides_user_provided_identity,\n    ):\n        \"\"\"\n        Privacy Notice Enforcement Level = \"frontend\"\n        Privacy Notice Data Use = \"essential.service\" but not checked\n        System Data Use = \"marketing.advertising\"\n        \"\"\"\n        pref = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": preference,\n                \"privacy_notice_history_id\": privacy_notice_fr_provide_service_frontend_only.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref.privacy_request_id = privacy_request_with_consent_policy.id\n        pref.save(db)\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference == should_opt_in\n        pref.delete(db)\n\n    @pytest.mark.parametrize(\n        \"preference, should_opt_in\",\n        [(\"opt_in\", True), (\"opt_out\", False), (\"acknowledge\", None)],\n    )\n    def test_no_system_means_no_data_use_check(\n        self,\n        preference,\n        should_opt_in,\n        db,\n        privacy_notice_us_co_provide_service_operations,\n        privacy_request_with_consent_policy,\n        fides_user_provided_identity,\n    ):\n        \"\"\"\n        Privacy Notice Enforcement Level = \"system_wide\"\n        Privacy Notice Data Use = \"essential.service.operations\"\n        \"\"\"\n\n        pref = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": preference,\n                \"privacy_notice_history_id\": privacy_notice_us_co_provide_service_operations.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref.privacy_request_id = privacy_request_with_consent_policy.id\n        pref.save(db)\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            None, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference == should_opt_in\n        pref.delete(db)\n\n    def test_conflict_preferences_opt_out_wins(\n        self,\n        db,\n        privacy_request_with_consent_policy,\n        privacy_notice,\n        privacy_notice_us_ca_provide,\n        fides_user_provided_identity,\n    ):\n        \"\"\"\n        Privacy Notice Enforcement Level = \"system_wide\"\n        Privacy Notice Data Use = \"marketing.advertising\" but not checked w/ no system\n        other Privacy Notice Data Use = \"essential\" but not checked w/ no system\n        \"\"\"\n        pref_1 = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": \"opt_in\",\n                \"privacy_notice_history_id\": privacy_notice.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref_2 = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": privacy_notice_us_ca_provide.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref_1.privacy_request_id = privacy_request_with_consent_policy.id\n        pref_1.save(db)\n        pref_2.privacy_request_id = privacy_request_with_consent_policy.id\n        pref_2.save(db)\n\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            None, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference is False\n        assert filtered_preferences == [pref_2]\n        pref_1.delete(db)\n        pref_2.delete(db)\n\n    def test_old_workflow_preferences_saved_with_respect_to_data_use(\n        self,\n        system,\n        privacy_request_with_consent_policy,\n    ):\n        \"\"\"\n        Test old workflow where executable preferences were cached on PrivacyRequest.consent_preferences\n        \"\"\"\n        privacy_request_with_consent_policy.consent_preferences = [\n            {\"data_use\": \"marketing.advertising\", \"opt_in\": False}\n        ]\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference is False\n        assert filtered_preferences == []\n\n        privacy_request_with_consent_policy.consent_preferences = [\n            {\"data_use\": \"marketing.advertising\", \"opt_in\": True}\n        ]\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference is True\n        assert filtered_preferences == []\n\n        privacy_request_with_consent_policy.consent_preferences = [\n            {\"data_use\": \"marketing.advertising\", \"opt_in\": True},\n            {\"data_use\": \"functional\", \"opt_in\": False},\n        ]\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference is False\n        assert filtered_preferences == []\n\n\nclass TestCacheSystemStatusesForConsentReporting:\n    def test_cache_initial_status_and_identities_for_consent_reporting(\n        self,\n        db,\n        privacy_request_with_consent_policy,\n        connection_config,\n        privacy_preference_history,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ):\n        privacy_preference_history.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.save(db)\n\n        privacy_preference_history_fr_provide_service_frontend_only.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.save(db)\n\n        cache_initial_status_and_identities_for_consent_reporting(\n            db,\n            privacy_request_with_consent_policy,\n            connection_config,\n            relevant_preferences=[\n                privacy_preference_history_fr_provide_service_frontend_only\n            ],\n            relevant_user_identities={\"email\": \"customer-1@example.com\"},\n        )\n\n        db.refresh(privacy_preference_history)\n        db.refresh(privacy_preference_history_fr_provide_service_frontend_only)\n\n        # Relevant systems\n        assert (\n            privacy_preference_history_fr_provide_service_frontend_only.affected_system_status\n            == {connection_config.name: \"pending\"}\n        )\n        assert (\n            privacy_preference_history_fr_provide_service_frontend_only.secondary_user_ids\n            == {\"email\": \"customer-1@example.com\"}\n        )\n\n        # non-relevant systems\n        assert privacy_preference_history.affected_system_status == {\n            connection_config.name: \"skipped\"\n        }\n        assert privacy_preference_history.secondary_user_ids is None\n\n    def test_add_complete_system_status_for_consent_reporting(\n        self,\n        db,\n        privacy_request_with_consent_policy,\n        connection_config,\n        privacy_preference_history,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ):\n        privacy_preference_history.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.save(db)\n\n        privacy_preference_history_fr_provide_service_frontend_only.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.save(db)\n\n        cache_initial_status_and_identities_for_consent_reporting(\n            db,\n            privacy_request_with_consent_policy,\n            connection_config,\n            relevant_preferences=[\n                privacy_preference_history_fr_provide_service_frontend_only\n            ],\n            relevant_user_identities={\"email\": \"customer-1@example.com\"},\n        )\n\n        add_complete_system_status_for_consent_reporting(\n            db, privacy_request_with_consent_policy, connection_config\n        )\n\n        db.refresh(privacy_preference_history)\n        db.refresh(privacy_preference_history_fr_provide_service_frontend_only)\n\n        # Relevant systems\n        assert (\n            privacy_preference_history_fr_provide_service_frontend_only.affected_system_status\n            == {connection_config.name: \"complete\"}\n        )\n        assert (\n            privacy_preference_history_fr_provide_service_frontend_only.secondary_user_ids\n            == {\"email\": \"customer-1@example.com\"}\n        )\n\n        # non-relevant systems\n        assert privacy_preference_history.affected_system_status == {\n            connection_config.name: \"skipped\"\n        }\n        assert privacy_preference_history.secondary_user_ids is None\n\n    def test_add_error_system_status_for_consent_reporting(\n        self,\n        db,\n        privacy_request_with_consent_policy,\n        connection_config,\n        privacy_preference_history,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ):\n        privacy_preference_history.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.save(db)\n\n        privacy_preference_history_fr_provide_service_frontend_only.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.save(db)\n\n        cache_initial_status_and_identities_for_consent_reporting(\n            db,\n            privacy_request_with_consent_policy,\n            connection_config,\n            relevant_preferences=[\n                privacy_preference_history_fr_provide_service_frontend_only\n            ],\n            relevant_user_identities={\"email\": \"customer-1@example.com\"},\n        )\n\n        add_errored_system_status_for_consent_reporting(\n            db, privacy_request_with_consent_policy, connection_config\n        )\n\n        db.refresh(privacy_preference_history)\n        db.refresh(privacy_preference_history_fr_provide_service_frontend_only)\n\n        # Relevant systems\n        assert (\n            privacy_preference_history_fr_provide_service_frontend_only.affected_system_status\n            == {connection_config.name: \"error\"}\n        )\n        assert (\n            privacy_preference_history_fr_provide_service_frontend_only.secondary_user_ids\n            == {\"email\": \"customer-1@example.com\"}\n        )\n\n        # non-relevant systems\n        assert privacy_preference_history.affected_system_status == {\n            connection_config.name: \"skipped\"\n        }\n        assert privacy_preference_history.secondary_user_ids is None\n\n\nclass TestGetFidesUserProvidedIdentity:\n    def test_no_identifier_supplied(self, db):\n        provided_identity = get_fides_user_device_id_provided_identity(db, None)\n        assert provided_identity is None\n\n    def test_no_provided_identifier_exists(self, db):\n        provided_identity = get_fides_user_device_id_provided_identity(\n            db, \"fides_user_device_id\"\n        )\n        assert provided_identity is None\n\n    def test_get_fides_user_device_id_provided_identity(\n        self, db, fides_user_provided_identity\n    ):\n        provided_identity = get_fides_user_device_id_provided_identity(\n            db, \"051b219f-20e4-45df-82f7-5eb68a00889f\"\n        )\n        assert provided_identity == fides_user_provided_identity\n\n\nclass TestCreatePrivacyNoticeUtils:\n    def test_create_privacy_notices_util(self, db, load_default_data_uses):\n        schema = PrivacyNoticeCreation(\n            name=\"Test Notice\",\n            notice_key=\"test_notice\",\n            description=\"test description\",\n            internal_description=\"internal description\",\n            regions=[\"it\"],\n            consent_mechanism=\"opt_out\",\n            data_uses=[\"train_ai_system\"],\n            enforcement_level=EnforcementLevel.not_applicable,\n            displayed_in_privacy_center=True,\n        )\n\n        privacy_notices, affected_regions = create_privacy_notices_util(db, [schema])\n        assert affected_regions == {PrivacyNoticeRegion.it}\n\n        assert len(privacy_notices) == 1\n        notice = privacy_notices[0]\n        assert notice.name == \"Test Notice\"\n        assert notice.notice_key == \"test_notice\"\n        assert notice.description == \"test description\"\n        assert notice.internal_description == \"internal description\"\n        assert notice.regions == [PrivacyNoticeRegion.it]\n        assert notice.consent_mechanism == ConsentMechanism.opt_out\n        assert notice.enforcement_level == EnforcementLevel.not_applicable\n        assert notice.disabled is False\n        assert notice.has_gpc_flag is False\n        assert notice.displayed_in_privacy_center is True\n        assert notice.displayed_in_overlay is False\n        assert notice.displayed_in_api is False\n\n        assert notice.privacy_notice_history_id is not None\n        history = notice.histories[0]\n        assert history.id == notice.privacy_notice_history_id\n        assert history.name == \"Test Notice\"\n        assert history.notice_key == \"test_notice\"\n        assert history.description == \"test description\"\n        assert history.internal_description == \"internal description\"\n        assert history.regions == [PrivacyNoticeRegion.it]\n        assert history.consent_mechanism == ConsentMechanism.opt_out\n        assert history.enforcement_level == EnforcementLevel.not_applicable\n        assert history.disabled is False\n        assert history.has_gpc_flag is False\n        assert history.displayed_in_privacy_center is True\n        assert history.displayed_in_overlay is False\n        assert history.displayed_in_api is False\n\n        db.delete(notice.histories[0])\n        db.delete(notice)\n\n\nclass TestLoadDefaultNotices:\n    def test_load_default_notices(self, db, load_default_data_uses):\n        # Load notice from a file that only has one template (A) defined.\n        # This should create one template (A), one notice (A), and one notice history (A)\n        (\n            overlay_exp,\n            privacy_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n        assert overlay_exp is None\n        assert privacy_exp is None\n\n        new_templates, new_privacy_notices = load_default_notices_on_startup(\n            db, \"tests/fixtures/test_privacy_notice.yml\"\n        )\n        assert len(new_privacy_notices) == 1\n        notice = new_privacy_notices[0]\n        assert notice.name == \"Test Privacy Notice\"\n        assert notice.notice_key == \"test_privacy_notice\"\n        assert notice.description == \"This website uses cookies.\"\n        assert (\n            unescape(notice.internal_description)\n            == \"This is a contrived template for testing.  This field's for internal testing!\"\n        )\n        assert (\n            notice.internal_description\n            == \"This is a contrived template for testing.  This field&#x27;s for internal testing!\"\n        )  # Stored escaped\n        assert notice.regions == [PrivacyNoticeRegion.us_ak]\n        assert notice.consent_mechanism == ConsentMechanism.opt_in\n        assert notice.enforcement_level == EnforcementLevel.system_wide\n        assert notice.disabled is False\n        assert notice.has_gpc_flag is True\n        assert notice.displayed_in_privacy_center is False\n        assert notice.displayed_in_overlay is True\n        assert notice.displayed_in_api is False\n        assert notice.version == 1.0\n        (\n            overlay_exp,\n            privacy_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n        assert overlay_exp is not None\n        assert privacy_exp is None\n\n        assert notice.privacy_notice_history_id is not None\n        history = notice.histories[0]\n        assert history.name == \"Test Privacy Notice\"\n        assert history.notice_key == \"test_privacy_notice\"\n        assert history.description == \"This website uses cookies.\"\n        assert (\n            unescape(history.internal_description)\n            == \"This is a contrived template for testing.  This field's for internal testing!\"\n        )\n        assert history.regions == [PrivacyNoticeRegion.us_ak]\n        assert history.consent_mechanism == ConsentMechanism.opt_in\n        assert history.enforcement_level == EnforcementLevel.system_wide\n        assert history.disabled is False\n        assert history.has_gpc_flag is True\n        assert history.displayed_in_privacy_center is False\n        assert history.displayed_in_overlay is True\n        assert history.displayed_in_api is False\n        assert history.version == 1.0\n        assert history.origin == new_templates[0].id\n\n        assert len(new_templates) == 1\n        assert new_templates[0].id == notice.origin\n        template_id = notice.origin\n        template = db.query(PrivacyNoticeTemplate).get(template_id)\n        assert template.name == \"Test Privacy Notice\"\n        assert template.description == \"This website uses cookies.\"\n        assert (\n            unescape(template.internal_description)\n            == \"This is a contrived template for testing.  This field's for internal testing!\"\n        )\n        assert template.regions == [PrivacyNoticeRegion.us_ak]\n        assert template.consent_mechanism == ConsentMechanism.opt_in\n        assert template.enforcement_level == EnforcementLevel.system_wide\n        assert template.disabled is False\n        assert template.has_gpc_flag is True\n        assert template.displayed_in_privacy_center is False\n        assert template.displayed_in_overlay is True\n        assert template.displayed_in_api is False\n        assert (\n            template.id == \"pri-5bd5cee7-8c8c-4da7-9a5c-7617a7d4dbb2\"\n        ), \"Id hardoded in template\"\n\n        # Load two notices from new file.\n        # One notice is an update of the previous template (A), the other is brand new (B).\n        # This should update the existing template (A), create a separate new template (B),\n        # and then create a new notice (B) and notice history (B) from just the new template (B).\n        # Leave the existing notice (A) and notice history (A) untouched.\n        (\n            overlay_exp,\n            privacy_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_al\n        )\n        assert overlay_exp is None\n        assert privacy_exp is None\n\n        new_templates, new_privacy_notices = load_default_notices_on_startup(\n            db, \"tests/fixtures/test_privacy_notice_update.yml\"\n        )\n        assert len(new_templates) == 1\n        # New template (B) created\n        new_template = new_templates[0]\n        assert new_template.name == \"Other Privacy Notice\"\n        assert (\n            new_template.description == \"This website uses a large amount of cookies.\"\n        )\n        assert (\n            new_template.internal_description\n            == \"This is another template added for testing\"\n        )\n        assert new_template.regions == [PrivacyNoticeRegion.us_al]\n        assert new_template.consent_mechanism == ConsentMechanism.opt_out\n        assert new_template.enforcement_level == EnforcementLevel.frontend\n        assert new_template.disabled is True\n        assert new_template.has_gpc_flag is False\n        assert new_template.displayed_in_privacy_center is True\n        assert new_template.displayed_in_overlay is False\n        assert new_template.displayed_in_api is False\n        assert new_template.id != template.id\n        assert new_template.id == \"pri-685486d9-f532-4951-bb1a-b15fea586ff8\"\n\n        # Updated template A, consent mechanism and internal description were updated\n        db.refresh(template)\n        assert template.name == \"Test Privacy Notice\"\n        assert template.description == \"This website uses cookies.\"\n        assert (\n            template.internal_description\n            == \"This is an existing template that we are updating to make the default opt_out instead.\"\n        )\n        assert template.regions == [PrivacyNoticeRegion.us_ak]\n        assert template.consent_mechanism == ConsentMechanism.opt_out  # Updated value\n        assert template.enforcement_level == EnforcementLevel.system_wide\n        assert template.disabled is False\n        assert template.has_gpc_flag is True\n        assert template.displayed_in_privacy_center is False\n        assert template.displayed_in_overlay is True\n        assert template.displayed_in_api is False\n\n        # Newly created privacy notice (B)\n        assert len(new_privacy_notices) == 1\n        new_privacy_notice = new_privacy_notices[0]\n        assert new_privacy_notice.name == \"Other Privacy Notice\"\n        assert (\n            new_privacy_notice.description\n            == \"This website uses a large amount of cookies.\"\n        )\n        assert (\n            new_privacy_notice.internal_description\n            == \"This is another template added for testing\"\n        )\n        assert new_privacy_notice.regions == [PrivacyNoticeRegion.us_al]\n        assert new_privacy_notice.consent_mechanism == ConsentMechanism.opt_out\n        assert new_privacy_notice.enforcement_level == EnforcementLevel.frontend\n        assert new_privacy_notice.disabled is True\n        assert new_privacy_notice.has_gpc_flag is False\n        assert new_privacy_notice.displayed_in_privacy_center is True\n        assert new_privacy_notice.displayed_in_overlay is False\n        assert new_privacy_notice.displayed_in_api is False\n        assert new_privacy_notice.version == 1.0\n        assert new_privacy_notice.id != notice.id\n\n        (\n            overlay_exp,\n            privacy_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_al\n        )\n        assert overlay_exp is None\n        assert privacy_exp is not None\n\n        # Newly created privacy notice history (B)\n        assert new_privacy_notice.privacy_notice_history_id is not None\n        new_history = new_privacy_notice.histories[0]\n        assert new_history.name == \"Other Privacy Notice\"\n        assert new_history.description == \"This website uses a large amount of cookies.\"\n        assert (\n            new_history.internal_description\n            == \"This is another template added for testing\"\n        )\n        assert new_history.regions == [PrivacyNoticeRegion.us_al]\n        assert new_history.consent_mechanism == ConsentMechanism.opt_out\n        assert new_history.enforcement_level == EnforcementLevel.frontend\n        assert new_history.disabled is True\n        assert new_history.has_gpc_flag is False\n        assert new_history.displayed_in_privacy_center is True\n        assert new_history.displayed_in_overlay is False\n        assert new_history.displayed_in_api is False\n        assert new_history.version == 1.0\n        assert new_history.id != notice.id\n        assert new_history.version == 1.0\n\n        # Existing notice A - assert this wasn't updated.\n        db.refresh(notice)\n        assert notice.name == \"Test Privacy Notice\"\n        assert notice.description == \"This website uses cookies.\"\n        assert (\n            unescape(notice.internal_description)\n            == \"This is a contrived template for testing.  This field's for internal testing!\"\n        )\n        assert notice.regions == [PrivacyNoticeRegion.us_ak]\n        assert notice.consent_mechanism == ConsentMechanism.opt_in\n        assert notice.enforcement_level == EnforcementLevel.system_wide\n        assert notice.disabled is False\n        assert notice.has_gpc_flag is True\n        assert notice.displayed_in_privacy_center is False\n        assert notice.displayed_in_overlay is True\n        assert notice.displayed_in_api is False\n        assert notice.version == 1.0\n        assert notice.histories.count() == 1\n\n        db.refresh(history)\n        # Existing history B - assert this wasn't updated.\n        assert history.name == \"Test Privacy Notice\"\n        assert history.description == \"This website uses cookies.\"\n        assert (\n            unescape(history.internal_description)\n            == \"This is a contrived template for testing.  This field's for internal testing!\"\n        )\n        assert history.regions == [PrivacyNoticeRegion.us_ak]\n        assert history.consent_mechanism == ConsentMechanism.opt_in\n        assert history.enforcement_level == EnforcementLevel.system_wide\n        assert history.disabled is False\n        assert history.has_gpc_flag is True\n        assert history.displayed_in_privacy_center is False\n        assert history.displayed_in_overlay is True\n        assert history.displayed_in_api is False\n        assert history.version == 1.0\n        assert history.id != new_history.id\n\n        with pytest.raises(HTTPException):\n            load_default_notices_on_startup(\n                db, \"tests/fixtures/test_bad_privacy_notices_update.yml\"\n            )\n\n        new_history.delete(db)\n        history.delete(db)\n\n        new_privacy_notice.delete(db)\n        notice.delete(db)\n\n        new_template.delete(db)\n        template.delete(db)\n\n    def test_load_actual_default_notices(self, db):\n        \"\"\"Sanity check, makings sure that default privacy notices don't load with errors\"\"\"\n        new_templates, new_privacy_notices = load_default_notices_on_startup(\n            db, DEFAULT_PRIVACY_NOTICES_PATH\n        )\n        assert len(new_templates) >= 1\n        assert len(new_privacy_notices) >= 1\n\n\nclass TestUpsertPrivacyNoticeTemplates:\n    def test_ensure_unique_ids(self, db, load_default_data_uses):\n        \"\"\"Can help make sure we don't actually try to upload templates with duplicate\n        ids due to copy/pasting\n        \"\"\"\n        with pytest.raises(HTTPException) as exc:\n            upsert_privacy_notice_templates_util(\n                db,\n                [\n                    PrivacyNoticeWithId(\n                        id=\"test_id_1\",\n                        name=\"A\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_in,\n                        data_uses=[\"essential\"],\n                        enforcement_level=EnforcementLevel.system_wide,\n                        displayed_in_overlay=True,\n                    ),\n                    PrivacyNoticeWithId(\n                        id=\"test_id_1\",\n                        name=\"A\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_out,\n                        data_uses=[\"essential\"],\n                        enforcement_level=EnforcementLevel.frontend,\n                        displayed_in_overlay=True,\n                    ),\n                ],\n            )\n        assert exc._excinfo[1].status_code == 422\n        assert (\n            exc._excinfo[1].detail\n            == \"More than one provided PrivacyNotice with ID test_id_1.\"\n        )\n\n    def test_overlapping_data_uses(self, db, load_default_data_uses):\n        \"\"\"Can't have overlaps on incoming templates, and we also check these for disabled templates\"\"\"\n        with pytest.raises(HTTPException) as exc:\n            upsert_privacy_notice_templates_util(\n                db,\n                [\n                    PrivacyNoticeWithId(\n                        id=\"test_id_1\",\n                        notice_key=\"a\",\n                        name=\"A\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_in,\n                        data_uses=[\"essential\"],\n                        enforcement_level=EnforcementLevel.system_wide,\n                        displayed_in_overlay=True,\n                    ),\n                    PrivacyNoticeWithId(\n                        id=\"test_id_2\",\n                        notice_key=\"b\",\n                        name=\"B\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_in,\n                        data_uses=[\"essential.service\"],\n                        enforcement_level=EnforcementLevel.frontend,\n                        disabled=True,\n                        displayed_in_overlay=True,\n                    ),\n                ],\n            )\n        assert exc._excinfo[1].status_code == 422\n        assert (\n            exc._excinfo[1].detail\n            == \"Privacy Notice 'A' has already assigned data use 'essential' to region 'it'\"\n        )\n\n    def test_overlapping_notice_keys(self, db, load_default_data_uses):\n        \"\"\"Can't have overlapping notice keys on incoming templates, and we also check these for disabled templates\"\"\"\n        with pytest.raises(HTTPException) as exc:\n            upsert_privacy_notice_templates_util(\n                db,\n                [\n                    PrivacyNoticeWithId(\n                        id=\"test_id_1\",\n                        notice_key=\"a\",\n                        name=\"A\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_in,\n                        data_uses=[\"essential\"],\n                        enforcement_level=EnforcementLevel.system_wide,\n                        displayed_in_overlay=True,\n                    ),\n                    PrivacyNoticeWithId(\n                        id=\"test_id_2\",\n                        notice_key=\"a\",\n                        name=\"B\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_in,\n                        data_uses=[\"marketing\"],\n                        enforcement_level=EnforcementLevel.frontend,\n                        disabled=True,\n                        displayed_in_overlay=True,\n                    ),\n                ],\n            )\n        assert exc._excinfo[1].status_code == 422\n        assert (\n            exc._excinfo[1].detail\n            == \"Privacy Notice 'A' has already assigned notice key 'a' to region 'it'\"\n        )\n\n    def test_bad_data_uses(self, db, load_default_data_uses):\n        \"\"\"Test data uses must exist\"\"\"\n        with pytest.raises(HTTPException) as exc:\n            upsert_privacy_notice_templates_util(\n                db,\n                [\n                    PrivacyNoticeWithId(\n                        id=\"test_id_1\",\n                        name=\"A\",\n                        notice_key=\"a\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_in,\n                        data_uses=[\"bad use\"],\n                        enforcement_level=EnforcementLevel.system_wide,\n                        displayed_in_overlay=True,\n                    )\n                ],\n            )\n        assert exc._excinfo[1].status_code == 422\n        assert exc._excinfo[1].detail == \"Unknown data_use 'bad use'\"\n\n    def test_create_two_templates_then_update_second(self, db, load_default_data_uses):\n        \"\"\"Test create two brand new templates\"\"\"\n        templates = upsert_privacy_notice_templates_util(\n            db,\n            [\n                PrivacyNoticeWithId(\n                    id=\"test_id_1\",\n                    notice_key=\"a\",\n                    name=\"A\",\n                    regions=[\"it\"],\n                    consent_mechanism=ConsentMechanism.opt_in,\n                    data_uses=[\"essential\"],\n                    enforcement_level=EnforcementLevel.system_wide,\n                    displayed_in_overlay=True,\n                ),\n                PrivacyNoticeWithId(\n                    id=\"test_id_2\",\n                    notice_key=\"b\",\n                    name=\"B\",\n                    regions=[\"it\"],\n                    consent_mechanism=ConsentMechanism.opt_in,\n                    data_uses=[\"functional\"],\n                    enforcement_level=EnforcementLevel.frontend,\n                    disabled=True,\n                    displayed_in_overlay=True,\n                ),\n            ],\n        )\n        assert len(templates) == 2\n        first_template = templates[0]\n        first_template_updated_at = first_template.updated_at\n        second_template = templates[1]\n        second_template_updated_at = second_template.updated_at\n\n        assert first_template.id == \"test_id_1\"\n        assert first_template.name == \"A\"\n        assert first_template.regions == [PrivacyNoticeRegion.it]\n        assert first_template.consent_mechanism == ConsentMechanism.opt_in\n        assert first_template.data_uses == [\"essential\"]\n        assert first_template.enforcement_level == EnforcementLevel.system_wide\n\n        assert second_template.id == \"test_id_2\"\n        assert second_template.name == \"B\"\n        assert second_template.regions == [PrivacyNoticeRegion.it]\n        assert second_template.consent_mechanism == ConsentMechanism.opt_in\n        assert second_template.data_uses == [\"functional\"]\n        assert second_template.enforcement_level == EnforcementLevel.frontend\n        assert second_template.disabled\n\n        templates = upsert_privacy_notice_templates_util(\n            db,\n            [\n                PrivacyNoticeWithId(\n                    id=\"test_id_2\",\n                    notice_key=\"b\",\n                    name=\"B\",\n                    regions=[\"it\"],\n                    consent_mechanism=ConsentMechanism.opt_out,\n                    data_uses=[\"marketing.advertising\"],\n                    enforcement_level=EnforcementLevel.frontend,\n                    disabled=True,\n                    displayed_in_overlay=True,\n                ),\n                PrivacyNoticeWithId(\n                    id=\"test_id_3\",\n                    notice_key=\"c\",\n                    name=\"C\",\n                    regions=[\"it\"],\n                    consent_mechanism=ConsentMechanism.opt_out,\n                    data_uses=[\"functional\"],\n                    enforcement_level=EnforcementLevel.system_wide,\n                    disabled=False,\n                    displayed_in_overlay=True,\n                ),\n            ],\n        )\n\n        second_template_updated = templates[0]\n        third_template = templates[1]\n\n        db.refresh(first_template)\n        db.refresh(second_template)\n        assert first_template.updated_at == first_template_updated_at\n        assert second_template.updated_at > second_template_updated_at\n        assert second_template_updated.id == second_template.id\n\n        # First template didn't change\n        assert first_template.id == \"test_id_1\"\n        assert first_template.name == \"A\"\n        assert first_template.regions == [PrivacyNoticeRegion.it]\n        assert first_template.consent_mechanism == ConsentMechanism.opt_in\n        assert first_template.data_uses == [\"essential\"]\n        assert first_template.enforcement_level == EnforcementLevel.system_wide\n\n        # Second template updated data use and consent mechanism\n        assert second_template.id == \"test_id_2\"\n        assert second_template.name == \"B\"\n        assert second_template.regions == [PrivacyNoticeRegion.it]\n        assert second_template.consent_mechanism == ConsentMechanism.opt_out\n        assert second_template.data_uses == [\"marketing.advertising\"]\n        assert second_template.enforcement_level == EnforcementLevel.frontend\n        assert second_template.disabled\n\n        # Third template is new\n        assert third_template.id == \"test_id_3\"\n        assert third_template.name == \"C\"\n        assert third_template.regions == [PrivacyNoticeRegion.it]\n        assert third_template.consent_mechanism == ConsentMechanism.opt_out\n        assert third_template.data_uses == [\"functional\"]\n        assert third_template.enforcement_level == EnforcementLevel.system_wide\n        assert not third_template.disabled\n\n\nclass TestUpsertDefaultExperienceConfig:\n    @pytest.fixture(scope=\"function\")\n    def default_overlay_config_data(self, db):\n        return {\n            \"accept_button_label\": \"A\",\n            \"acknowledge_button_label\": \"B\",\n            \"banner_enabled\": BannerEnabled.enabled_where_required,\n            \"component\": ComponentType.overlay,\n            \"description\": \"C\",\n            \"disabled\": False,\n            \"is_default\": True,\n            \"id\": \"test_id\",\n            \"privacy_preferences_link_label\": \"D\",\n            \"privacy_policy_link_label\": \"E's label\",\n            \"privacy_policy_url\": \"F\",\n            \"reject_button_label\": \"G\",\n            \"save_button_label\": \"H\",\n            \"title\": \"I\",\n        }\n\n    def test_create_default_experience_config(self, db, default_overlay_config_data):\n        experience_config = create_default_experience_config(\n            db, default_overlay_config_data\n        )\n\n        assert experience_config.accept_button_label == \"A\"\n        assert experience_config.acknowledge_button_label == \"B\"\n        assert experience_config.banner_enabled == BannerEnabled.enabled_where_required\n        assert experience_config.component == ComponentType.overlay\n        assert experience_config.created_at is not None\n        assert experience_config.description == \"C\"\n        assert not experience_config.disabled\n        assert experience_config.is_default is True\n        assert experience_config.id == \"test_id\"\n        assert experience_config.privacy_preferences_link_label == \"D\"\n        assert (\n            experience_config.privacy_policy_link_label == \"E&#x27;s label\"\n        )  # Escaped\n        assert experience_config.privacy_policy_url == \"F\"\n        assert experience_config.regions == []\n        assert experience_config.reject_button_label == \"G\"\n        assert experience_config.save_button_label == \"H\"\n        assert experience_config.title == \"I\"\n        assert experience_config.updated_at is not None\n        assert experience_config.version == 1.0\n\n        # Asserting history created appropriately\n        assert experience_config.experience_config_history_id is not None\n        assert experience_config.experience_config_history_id != \"test_id\"\n        assert experience_config.histories.count() == 1\n        history = experience_config.histories[0]\n\n        assert history.accept_button_label == \"A\"\n        assert history.acknowledge_button_label == \"B\"\n        assert history.banner_enabled == BannerEnabled.enabled_where_required\n        assert history.component == ComponentType.overlay\n        assert history.created_at is not None\n        assert history.description == \"C\"\n        assert not history.disabled\n        assert history.experience_config_id == experience_config.id\n        assert history.is_default is True\n        assert history.id != \"test_id\"\n        assert history.privacy_preferences_link_label == \"D\"\n        assert history.privacy_policy_link_label == \"E&#x27;s label\"\n        assert history.privacy_policy_url == \"F\"\n        assert history.reject_button_label == \"G\"\n        assert history.save_button_label == \"H\"\n        assert history.title == \"I\"\n        assert history.updated_at is not None\n        assert history.version == 1.0\n\n        db.delete(history)\n        db.delete(experience_config)\n\n    def test_create_default_experience_config_config_already_exists_no_change(\n        self, db, default_overlay_config_data\n    ):\n        \"\"\"Experience config is not changed in any way\"\"\"\n        experience_config = create_default_experience_config(\n            db, default_overlay_config_data\n        )\n        assert experience_config is not None\n\n        resp = create_default_experience_config(db, default_overlay_config_data)\n        assert resp is None\n\n        db.refresh(experience_config)\n\n        # Nothing changed so we don't want to update the version\n        assert experience_config.version == 1.0\n        assert experience_config.histories.count() == 1\n\n        db.delete(experience_config.histories[0])\n        db.delete(experience_config)\n\n    def test_default_experience_config_data_has_changed(\n        self, db, default_overlay_config_data\n    ):\n        \"\"\"Even though data has changed, we don't update existing experience config\"\"\"\n        experience_config = create_default_experience_config(\n            db, default_overlay_config_data\n        )\n        assert experience_config is not None\n\n        default_overlay_config_data[\"privacy_policy_url\"] = \"example.com/privacy_policy\"\n\n        resp = create_default_experience_config(db, default_overlay_config_data)\n        assert resp is None\n\n        db.refresh(experience_config)\n\n        # Data has changed but we didn't update existing config\n        assert experience_config.version == 1.0\n        assert experience_config.privacy_policy_url != \"example.com/privacy_policy\"\n        assert experience_config.histories.count() == 1\n\n        assert experience_config.experience_config_history_id is not None\n        assert experience_config.experience_config_history_id != \"test_id\"\n        history = experience_config.histories[0]\n\n        assert history.version == 1.0\n        assert experience_config.privacy_policy_url != \"example.com/privacy_policy\"\n\n        history.delete(db)\n        experience_config.delete(db)\n\n    def test_trying_to_use_this_function_to_create_non_default_configs(\n        self, db, default_overlay_config_data\n    ):\n        default_overlay_config_data[\"is_default\"] = False\n\n        with pytest.raises(Exception):\n            create_default_experience_config(db, default_overlay_config_data)\n\n    def test_create_default_experience_config_validation_error(\n        self, db, default_overlay_config_data\n    ):\n        default_overlay_config_data[\n            \"banner_enabled\"\n        ] = None  # Marking required field as None\n\n        with pytest.raises(ValueError) as exc:\n            create_default_experience_config(db, default_overlay_config_data)\n\n        assert (\n            str(exc.value.args[0][0].exc)\n            == \"The following additional fields are required when defining an overlay: acknowledge_button_label, banner_enabled, and privacy_preferences_link_label.\"\n        )\n\n\nclass TestValidateDataUses:\n    @pytest.fixture(scope=\"function\")\n    def privacy_notice_request(self):\n        return PrivacyNoticeCreation(\n            name=\"sample privacy notice\",\n            notice_key=\"sample_privacy_notice\",\n            regions=[PrivacyNoticeRegion.us_ca],\n            consent_mechanism=ConsentMechanism.opt_in,\n            data_uses=[\"placeholder\"],\n            enforcement_level=EnforcementLevel.system_wide,\n            displayed_in_overlay=True,\n        )\n\n    @pytest.fixture(scope=\"function\")\n    def custom_data_use(self, db):\n        return sql_DataUse.create(\n            db=db,\n            data=DataUse(\n                fides_key=\"new_data_use\",\n                organization_fides_key=\"default_organization\",\n                name=\"New data use\",\n                description=\"A test data use\",\n                parent_key=None,\n            ).dict(),\n        )\n\n    @pytest.mark.usefixtures(\"load_default_data_uses\")\n    def test_validate_data_uses_invalid(\n        self, db, privacy_notice_request: PrivacyNoticeCreation\n    ):\n        privacy_notice_request.data_uses = [\"invalid_data_use\"]\n        with pytest.raises(HTTPException):\n            validate_notice_data_uses([privacy_notice_request], db)\n\n        privacy_notice_request.data_uses = [\"marketing.advertising\", \"invalid_data_use\"]\n        with pytest.raises(HTTPException):\n            validate_notice_data_uses([privacy_notice_request], db)\n\n        privacy_notice_request.data_uses = [\n            \"marketing.advertising\",\n            \"marketing.advertising.invalid_data_use\",\n        ]\n        with pytest.raises(HTTPException):\n            validate_notice_data_uses([privacy_notice_request], db)\n\n    @pytest.mark.usefixtures(\"load_default_data_uses\")\n    def test_validate_data_uses_default_taxonomy(\n        self, db, privacy_notice_request: PrivacyNoticeCreation\n    ):\n        privacy_notice_request.data_uses = [\"marketing.advertising\"]\n        validate_notice_data_uses([privacy_notice_request], db)\n        privacy_notice_request.data_uses = [\"marketing.advertising\", \"essential\"]\n        validate_notice_data_uses([privacy_notice_request], db)\n        privacy_notice_request.data_uses = [\n            \"marketing.advertising\",\n            \"essential\",\n            \"essential.service\",\n        ]\n        validate_notice_data_uses([privacy_notice_request], db)\n\n    @pytest.mark.usefixtures(\"load_default_data_uses\")\n    def test_validate_data_uses_custom_uses(\n        self,\n        db,\n        privacy_notice_request: PrivacyNoticeCreation,\n        custom_data_use: sql_DataUse,\n    ):\n        \"\"\"\n        Ensure custom data uses added to the DB are considered valid\n        \"\"\"\n\n        privacy_notice_request.data_uses = [custom_data_use.fides_key]\n        validate_notice_data_uses([privacy_notice_request], db)\n        privacy_notice_request.data_uses = [\n            \"marketing.advertising\",\n            custom_data_use.fides_key,\n        ]\n        validate_notice_data_uses([privacy_notice_request], db)\n\n\nclass TestLoadTCFExperiences:\n    def test_create_tcf_experiences_on_startup(self, db):\n        \"\"\"Sanity check on creating TCF experiences\"\"\"\n        experiences_created = create_tcf_experiences_on_startup(db)\n        assert len(experiences_created) == len(EEA_COUNTRIES)\n        be_exp = experiences_created[0]\n        assert be_exp.component == ComponentType.tcf_overlay\n        assert be_exp.region == PrivacyNoticeRegion.be\n        experience_config = be_exp.experience_config\n        assert experience_config.is_default\n        assert experience_config.component == ComponentType.tcf_overlay\n"], "fixing_code": ["from __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict, List, Optional\n\nfrom pydantic import Extra, Field, HttpUrl, root_validator, validator\n\nfrom fides.api.models.privacy_experience import BannerEnabled, ComponentType\nfrom fides.api.models.privacy_notice import PrivacyNoticeRegion\nfrom fides.api.schemas.base_class import FidesSchema\nfrom fides.api.schemas.privacy_notice import PrivacyNoticeResponseWithUserPreferences\nfrom fides.api.schemas.tcf import TCMobileData\nfrom fides.api.util.endpoint_utils import human_friendly_list\nfrom fides.api.util.tcf.tcf_experience_contents import TCFExperienceContents\n\n\nclass ExperienceConfigSchema(FidesSchema):\n    \"\"\"\n    Base for ExperienceConfig API objects.  Here all fields are optional since\n    Pydantic allows subclasses to be more strict but not less strict\n\n    Note component is intentionally not included in the base class. This can be specified when creating an ExperienceConfig\n    but cannot be updated later.\n    \"\"\"\n\n    accept_button_label: Optional[str] = Field(\n        description=\"Overlay 'Accept button displayed on the Banner and Privacy Preferences' or Privacy Center 'Confirmation button label'\"\n    )\n    acknowledge_button_label: Optional[str] = Field(\n        description=\"Overlay 'Acknowledge button label for notice only banner'\"\n    )\n    banner_enabled: Optional[BannerEnabled] = Field(description=\"Overlay 'Banner'\")\n    description: Optional[str] = Field(\n        description=\"Overlay 'Banner Description' or Privacy Center 'Description'\"\n    )\n    disabled: Optional[bool] = Field(\n        default=False, description=\"Whether the given ExperienceConfig is disabled\"\n    )\n    is_default: Optional[bool] = Field(\n        default=False,\n        description=\"Whether the given ExperienceConfig is a global default\",\n    )\n    privacy_policy_link_label: Optional[str] = Field(\n        description=\"Overlay and Privacy Center 'Privacy policy link label'\"\n    )\n    privacy_policy_url: Optional[HttpUrl] = Field(\n        default=None, description=\"Overlay and Privacy Center 'Privacy policy URL\"\n    )\n    privacy_preferences_link_label: Optional[str] = Field(\n        description=\"Overlay 'Privacy preferences link label'\"\n    )\n    regions: Optional[List[PrivacyNoticeRegion]] = Field(\n        description=\"Regions using this ExperienceConfig\"\n    )\n    reject_button_label: Optional[str] = Field(\n        description=\"Overlay 'Reject button displayed on the Banner and 'Privacy Preferences' of Privacy Center 'Reject button label'\"\n    )\n    save_button_label: Optional[str] = Field(\n        description=\"Overlay 'Privacy preferences 'Save' button label\"\n    )\n    title: Optional[str] = Field(\n        description=\"Overlay 'Banner title' or Privacy Center 'title'\"\n    )\n\n    @validator(\"regions\")\n    @classmethod\n    def validate_regions(\n        cls, regions: List[PrivacyNoticeRegion]\n    ) -> List[PrivacyNoticeRegion]:\n        \"\"\"Assert regions aren't duplicated.\"\"\"\n        if regions and len(regions) != len(set(regions)):\n            raise ValueError(\"Duplicate regions found.\")\n        return regions\n\n\nclass ExperienceConfigCreate(ExperienceConfigSchema):\n    \"\"\"\n    An API representation to create ExperienceConfig.\n    This model doesn't include an `id` so that it can be used for creation.\n    It also establishes some fields _required_ for creation\n    \"\"\"\n\n    accept_button_label: str\n    component: ComponentType\n    description: str\n    reject_button_label: str\n    save_button_label: str\n    title: str\n\n    @root_validator\n    def validate_attributes(cls, values: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate minimum set of required fields exist given the type of component\"\"\"\n        component: Optional[ComponentType] = values.get(\"component\")\n\n        if component == ComponentType.overlay:\n            # Overlays have a few additional required fields beyond the privacy center\n            required_overlay_fields = [\n                \"acknowledge_button_label\",\n                \"banner_enabled\",\n                \"privacy_preferences_link_label\",\n            ]\n            for field in required_overlay_fields:\n                if not values.get(field):\n                    raise ValueError(\n                        f\"The following additional fields are required when defining an overlay: {human_friendly_list(required_overlay_fields)}.\"\n                    )\n\n        return values\n\n\nclass ExperienceConfigUpdate(ExperienceConfigSchema):\n    \"\"\"\n    Updating ExperienceConfig. Note that component cannot be updated once its created\n    \"\"\"\n\n    class Config:\n        \"\"\"Forbid extra values - specifically we don't want component to be updated here.\"\"\"\n\n        extra = Extra.forbid\n\n\nclass ExperienceConfigCreateWithId(ExperienceConfigCreate):\n    \"\"\"Schema for creating out-of-the-box experience configs\"\"\"\n\n    id: str\n\n\nclass ExperienceConfigSchemaWithId(ExperienceConfigSchema):\n    \"\"\"\n    An API representation of a ExperienceConfig that includes an `id` field.\n\n    Also includes the experience config history id and version\n    \"\"\"\n\n    id: str\n    component: ComponentType\n    experience_config_history_id: str\n    version: float\n\n\nclass ExperienceConfigResponse(ExperienceConfigSchemaWithId):\n    \"\"\"\n    An API representation of ExperienceConfig used for response payloads\n    \"\"\"\n\n    created_at: datetime\n    updated_at: datetime\n    regions: List[PrivacyNoticeRegion]  # Property\n\n\nclass ExperienceConfigCreateOrUpdateResponse(FidesSchema):\n    \"\"\"Schema with the created/updated experience config with regions that succeeded or failed\"\"\"\n\n    experience_config: ExperienceConfigResponse\n    linked_regions: List[PrivacyNoticeRegion]\n    unlinked_regions: List[PrivacyNoticeRegion]\n\n\nclass PrivacyExperience(FidesSchema):\n    \"\"\"\n    Base for PrivacyExperience API objects.  Here all fields are optional since\n    Pydantic allows subclasses to be more strict but not less strict\n    \"\"\"\n\n    region: PrivacyNoticeRegion\n    component: Optional[ComponentType]\n    experience_config: Optional[ExperienceConfigSchemaWithId]\n\n    class Config:\n        \"\"\"Populate models with the raw value of enum fields, rather than the enum itself\"\"\"\n\n        use_enum_values = True\n        orm_mode = True\n        extra = Extra.forbid\n\n\nclass PrivacyExperienceWithId(PrivacyExperience):\n    \"\"\"\n    An API representation of a PrivacyExperience that includes an `id` field.\n    Used to help model API responses and update payloads\n    \"\"\"\n\n    id: str\n\n\nclass ExperienceMeta(FidesSchema):\n    \"\"\"Supplements experience with developer-friendly meta information\"\"\"\n\n    version_hash: Optional[str] = Field(\n        description=\"A hashed value that can be compared to previously-fetched \"\n        \"hash values to determine if the Experience has meaningfully changed\"\n    )\n    accept_all_fides_string: Optional[str] = Field(\n        description=\"The fides string (TC String + AC String) corresponding to a user opting in to all \"\n        \"available options\"\n    )\n    accept_all_fides_mobile_data: Optional[TCMobileData] = None\n    reject_all_fides_string: Optional[str] = Field(\n        description=\"The fides string (TC String + AC String) corresponding to a user opting out of all \"\n        \"available options\"\n    )\n    reject_all_fides_mobile_data: Optional[TCMobileData] = None\n\n\nclass PrivacyExperienceResponse(TCFExperienceContents, PrivacyExperienceWithId):\n    \"\"\"\n    An API representation of a PrivacyExperience used for response payloads\n    \"\"\"\n\n    created_at: datetime\n    updated_at: datetime\n    show_banner: Optional[bool] = Field(\n        description=\"Whether the experience should show a banner\",\n    )\n    privacy_notices: Optional[List[PrivacyNoticeResponseWithUserPreferences]] = Field(\n        description=\"The Privacy Notices associated with this experience, if applicable\"\n    )\n    experience_config: Optional[ExperienceConfigResponse] = Field(\n        description=\"The Experience copy or language\"\n    )\n    gvl: Optional[Dict] = None\n    meta: Optional[ExperienceMeta] = None\n", "import logging\nimport uuid\nfrom copy import deepcopy\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Dict, Generator, List, Optional\nfrom unittest import mock\nfrom uuid import uuid4\n\nimport pydash\nimport pytest\nimport yaml\nfrom faker import Faker\nfrom fideslang.models import Dataset\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.orm.exc import ObjectDeletedError, StaleDataError\nfrom toml import load as load_toml\n\nfrom fides.api.common_exceptions import SystemManagerException\nfrom fides.api.models.application_config import ApplicationConfig\nfrom fides.api.models.audit_log import AuditLog, AuditLogAction\nfrom fides.api.models.client import ClientDetail\nfrom fides.api.models.connectionconfig import (\n    AccessLevel,\n    ConnectionConfig,\n    ConnectionType,\n)\nfrom fides.api.models.datasetconfig import DatasetConfig\nfrom fides.api.models.fides_user import FidesUser\nfrom fides.api.models.fides_user_permissions import FidesUserPermissions\nfrom fides.api.models.messaging import MessagingConfig\nfrom fides.api.models.policy import (\n    ActionType,\n    Policy,\n    PolicyPostWebhook,\n    PolicyPreWebhook,\n    Rule,\n    RuleTarget,\n)\nfrom fides.api.models.privacy_experience import (\n    ComponentType,\n    PrivacyExperience,\n    PrivacyExperienceConfig,\n)\nfrom fides.api.models.privacy_notice import (\n    ConsentMechanism,\n    EnforcementLevel,\n    PrivacyNotice,\n    PrivacyNoticeRegion,\n)\nfrom fides.api.models.privacy_preference import (\n    PrivacyPreferenceHistory,\n    ServedNoticeHistory,\n)\nfrom fides.api.models.privacy_request import (\n    Consent,\n    ConsentRequest,\n    PrivacyRequest,\n    PrivacyRequestStatus,\n    ProvidedIdentity,\n)\nfrom fides.api.models.registration import UserRegistration\nfrom fides.api.models.sql_models import DataCategory as DataCategoryDbModel\nfrom fides.api.models.sql_models import Dataset as CtlDataset\nfrom fides.api.models.sql_models import PrivacyDeclaration, System\nfrom fides.api.models.storage import (\n    ResponseFormat,\n    StorageConfig,\n    _create_local_default_storage,\n    default_storage_config_name,\n)\nfrom fides.api.oauth.roles import APPROVER, VIEWER\nfrom fides.api.schemas.messaging.messaging import (\n    MessagingServiceDetails,\n    MessagingServiceSecrets,\n    MessagingServiceType,\n)\nfrom fides.api.schemas.redis_cache import CustomPrivacyRequestField, Identity\nfrom fides.api.schemas.storage.storage import (\n    FileNaming,\n    S3AuthMethod,\n    StorageDetails,\n    StorageSecrets,\n    StorageType,\n)\nfrom fides.api.service.connectors.fides.fides_client import FidesClient\nfrom fides.api.service.masking.strategy.masking_strategy_hmac import HmacMaskingStrategy\nfrom fides.api.service.masking.strategy.masking_strategy_nullify import (\n    NullMaskingStrategy,\n)\nfrom fides.api.service.masking.strategy.masking_strategy_string_rewrite import (\n    StringRewriteMaskingStrategy,\n)\nfrom fides.api.util.data_category import DataCategory\nfrom fides.config import CONFIG\nfrom fides.config.helpers import load_file\n\nlogging.getLogger(\"faker\").setLevel(logging.ERROR)\n# disable verbose faker logging\nfaker = Faker()\nintegration_config = load_toml(\"tests/ops/integration_test_config.toml\")\n\n\n# Unified list of connections to integration dbs specified from fides.api-integration.toml\n\nintegration_secrets = {\n    \"postgres_example\": {\n        \"host\": pydash.get(integration_config, \"postgres_example.server\"),\n        \"port\": pydash.get(integration_config, \"postgres_example.port\"),\n        \"dbname\": pydash.get(integration_config, \"postgres_example.db\"),\n        \"username\": pydash.get(integration_config, \"postgres_example.user\"),\n        \"password\": pydash.get(integration_config, \"postgres_example.password\"),\n    },\n    \"mongo_example\": {\n        \"host\": pydash.get(integration_config, \"mongodb_example.server\"),\n        \"defaultauthdb\": pydash.get(integration_config, \"mongodb_example.db\"),\n        \"username\": pydash.get(integration_config, \"mongodb_example.user\"),\n        \"password\": pydash.get(integration_config, \"mongodb_example.password\"),\n    },\n    \"mysql_example\": {\n        \"host\": pydash.get(integration_config, \"mysql_example.server\"),\n        \"port\": pydash.get(integration_config, \"mysql_example.port\"),\n        \"dbname\": pydash.get(integration_config, \"mysql_example.db\"),\n        \"username\": pydash.get(integration_config, \"mysql_example.user\"),\n        \"password\": pydash.get(integration_config, \"mysql_example.password\"),\n    },\n    \"mssql_example\": {\n        \"host\": pydash.get(integration_config, \"mssql_example.server\"),\n        \"port\": pydash.get(integration_config, \"mssql_example.port\"),\n        \"dbname\": pydash.get(integration_config, \"mssql_example.db\"),\n        \"username\": pydash.get(integration_config, \"mssql_example.user\"),\n        \"password\": pydash.get(integration_config, \"mssql_example.password\"),\n    },\n    \"mariadb_example\": {\n        \"host\": pydash.get(integration_config, \"mariadb_example.server\"),\n        \"port\": pydash.get(integration_config, \"mariadb_example.port\"),\n        \"dbname\": pydash.get(integration_config, \"mariadb_example.db\"),\n        \"username\": pydash.get(integration_config, \"mariadb_example.user\"),\n        \"password\": pydash.get(integration_config, \"mariadb_example.password\"),\n    },\n    \"timescale_example\": {\n        \"host\": pydash.get(integration_config, \"timescale_example.server\"),\n        \"port\": pydash.get(integration_config, \"timescale_example.port\"),\n        \"dbname\": pydash.get(integration_config, \"timescale_example.db\"),\n        \"username\": pydash.get(integration_config, \"timescale_example.user\"),\n        \"password\": pydash.get(integration_config, \"timescale_example.password\"),\n    },\n    \"fides_example\": {\n        \"uri\": pydash.get(integration_config, \"fides_example.uri\"),\n        \"username\": pydash.get(integration_config, \"fides_example.username\"),\n        \"password\": pydash.get(integration_config, \"fides_example.password\"),\n        \"polling_timeout\": pydash.get(\n            integration_config, \"fides_example.polling_timeout\"\n        ),\n    },\n    \"dynamodb_example\": {\n        \"region\": pydash.get(integration_config, \"dynamodb_example.region\"),\n        \"aws_access_key_id\": pydash.get(\n            integration_config, \"dynamodb_example.aws_access_key_id\"\n        ),\n        \"aws_secret_access_key\": pydash.get(\n            integration_config, \"dynamodb_example.aws_secret_access_key\"\n        ),\n    },\n}\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef mock_upload_logic() -> Generator:\n    with mock.patch(\n        \"fides.api.service.storage.storage_uploader_service.upload_to_s3\"\n    ) as _fixture:\n        yield _fixture\n\n\n@pytest.fixture(scope=\"function\")\ndef custom_data_category(db: Session) -> Generator:\n    category = DataCategoryDbModel.create(\n        db=db,\n        data={\n            \"name\": \"Example Custom Data Category\",\n            \"description\": \"A custom data category for testing\",\n            \"fides_key\": \"test_custom_data_category\",\n        },\n    )\n    yield category\n    category.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef storage_config(db: Session) -> Generator:\n    name = str(uuid4())\n    storage_config = StorageConfig.create(\n        db=db,\n        data={\n            \"name\": name,\n            \"type\": StorageType.s3,\n            \"details\": {\n                StorageDetails.AUTH_METHOD.value: S3AuthMethod.SECRET_KEYS.value,\n                StorageDetails.NAMING.value: FileNaming.request_id.value,\n                StorageDetails.BUCKET.value: \"test_bucket\",\n            },\n            \"key\": \"my_test_config\",\n            \"format\": ResponseFormat.json,\n        },\n    )\n    storage_config.set_secrets(\n        db=db,\n        storage_secrets={\n            StorageSecrets.AWS_ACCESS_KEY_ID.value: \"1234\",\n            StorageSecrets.AWS_SECRET_ACCESS_KEY.value: \"5678\",\n        },\n    )\n    yield storage_config\n    storage_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef storage_config_local(db: Session) -> Generator:\n    name = str(uuid4())\n    storage_config = StorageConfig.create(\n        db=db,\n        data={\n            \"name\": name,\n            \"type\": StorageType.local,\n            \"details\": {\n                StorageDetails.NAMING.value: FileNaming.request_id.value,\n            },\n            \"key\": \"my_test_config_local\",\n            \"format\": ResponseFormat.json,\n        },\n    )\n    yield storage_config\n    storage_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef storage_config_default(db: Session) -> Generator:\n    \"\"\"\n    Create and yield a default storage config, as defined by its\n    `is_default` flag being set to `True`. This is an s3 storage config.\n    \"\"\"\n    sc = StorageConfig.create(\n        db=db,\n        data={\n            \"name\": default_storage_config_name(StorageType.s3.value),\n            \"type\": StorageType.s3,\n            \"is_default\": True,\n            \"details\": {\n                StorageDetails.NAMING.value: FileNaming.request_id.value,\n                StorageDetails.AUTH_METHOD.value: S3AuthMethod.AUTOMATIC.value,\n                StorageDetails.BUCKET.value: \"test_bucket\",\n            },\n            \"format\": ResponseFormat.json,\n        },\n    )\n    yield sc\n\n\n@pytest.fixture(scope=\"function\")\ndef storage_config_default_s3_secret_keys(db: Session) -> Generator:\n    \"\"\"\n    Create and yield a default storage config, as defined by its\n    `is_default` flag being set to `True`. This is an s3 storage config.\n    \"\"\"\n    sc = StorageConfig.create(\n        db=db,\n        data={\n            \"name\": default_storage_config_name(StorageType.s3.value),\n            \"type\": StorageType.s3,\n            \"is_default\": True,\n            \"details\": {\n                StorageDetails.NAMING.value: FileNaming.request_id.value,\n                StorageDetails.AUTH_METHOD.value: S3AuthMethod.SECRET_KEYS.value,\n                StorageDetails.BUCKET.value: \"test_bucket\",\n            },\n            \"secrets\": {\n                StorageSecrets.AWS_ACCESS_KEY_ID.value: \"access_key_id\",\n                StorageSecrets.AWS_SECRET_ACCESS_KEY.value: \"secret_access_key\",\n            },\n            \"format\": ResponseFormat.json,\n        },\n    )\n    yield sc\n\n\n@pytest.fixture(scope=\"function\")\ndef storage_config_default_local(db: Session) -> Generator:\n    \"\"\"\n    Create and yield the default local storage config.\n    \"\"\"\n    sc = _create_local_default_storage(db)\n    yield sc\n\n\n@pytest.fixture(scope=\"function\")\ndef set_active_storage_s3(db) -> None:\n    ApplicationConfig.create_or_update(\n        db,\n        data={\n            \"api_set\": {\n                \"storage\": {\"active_default_storage_type\": StorageType.s3.value}\n            }\n        },\n    )\n\n\n@pytest.fixture(scope=\"function\")\ndef messaging_config(db: Session) -> Generator:\n    name = str(uuid4())\n    messaging_config = MessagingConfig.create(\n        db=db,\n        data={\n            \"name\": name,\n            \"key\": \"my_mailgun_messaging_config\",\n            \"service_type\": MessagingServiceType.mailgun.value,\n            \"details\": {\n                MessagingServiceDetails.API_VERSION.value: \"v3\",\n                MessagingServiceDetails.DOMAIN.value: \"some.domain\",\n                MessagingServiceDetails.IS_EU_DOMAIN.value: False,\n            },\n        },\n    )\n    messaging_config.set_secrets(\n        db=db,\n        messaging_secrets={\n            MessagingServiceSecrets.MAILGUN_API_KEY.value: \"12984r70298r\"\n        },\n    )\n    yield messaging_config\n    messaging_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef messaging_config_twilio_email(db: Session) -> Generator:\n    name = str(uuid4())\n    messaging_config = MessagingConfig.create(\n        db=db,\n        data={\n            \"name\": name,\n            \"key\": \"my_twilio_email_config\",\n            \"service_type\": MessagingServiceType.twilio_email.value,\n        },\n    )\n    messaging_config.set_secrets(\n        db=db,\n        messaging_secrets={\n            MessagingServiceSecrets.TWILIO_API_KEY.value: \"123489ctynpiqurwfh\"\n        },\n    )\n    yield messaging_config\n    messaging_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef messaging_config_twilio_sms(db: Session) -> Generator:\n    name = str(uuid4())\n    messaging_config = MessagingConfig.create(\n        db=db,\n        data={\n            \"name\": name,\n            \"key\": \"my_twilio_sms_config\",\n            \"service_type\": MessagingServiceType.twilio_text.value,\n        },\n    )\n    messaging_config.set_secrets(\n        db=db,\n        messaging_secrets={\n            MessagingServiceSecrets.TWILIO_ACCOUNT_SID.value: \"23rwrfwxwef\",\n            MessagingServiceSecrets.TWILIO_AUTH_TOKEN.value: \"23984y29384y598432\",\n            MessagingServiceSecrets.TWILIO_MESSAGING_SERVICE_SID.value: \"2ieurnoqw\",\n        },\n    )\n    yield messaging_config\n    messaging_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef messaging_config_mailchimp_transactional(db: Session) -> Generator:\n    messaging_config = MessagingConfig.create(\n        db=db,\n        data={\n            \"name\": str(uuid4()),\n            \"key\": \"my_mailchimp_transactional_messaging_config\",\n            \"service_type\": MessagingServiceType.mailchimp_transactional,\n            \"details\": {\n                MessagingServiceDetails.DOMAIN.value: \"some.domain\",\n                MessagingServiceDetails.EMAIL_FROM.value: \"test@example.com\",\n            },\n        },\n    )\n    messaging_config.set_secrets(\n        db=db,\n        messaging_secrets={\n            MessagingServiceSecrets.MAILCHIMP_TRANSACTIONAL_API_KEY.value: \"12984r70298r\"\n        },\n    )\n    yield messaging_config\n    messaging_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef https_connection_config(db: Session) -> Generator:\n    name = str(uuid4())\n    connection_config = ConnectionConfig.create(\n        db=db,\n        data={\n            \"name\": name,\n            \"key\": \"my_webhook_config\",\n            \"connection_type\": ConnectionType.https,\n            \"access\": AccessLevel.read,\n            \"secrets\": {\n                \"url\": \"http://example.com\",\n                \"authorization\": \"test_authorization\",\n            },\n        },\n    )\n    yield connection_config\n    connection_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef policy_pre_execution_webhooks(\n    db: Session, https_connection_config, policy\n) -> Generator:\n    pre_webhook = PolicyPreWebhook.create(\n        db=db,\n        data={\n            \"connection_config_id\": https_connection_config.id,\n            \"policy_id\": policy.id,\n            \"direction\": \"one_way\",\n            \"name\": str(uuid4()),\n            \"key\": \"pre_execution_one_way_webhook\",\n            \"order\": 0,\n        },\n    )\n    pre_webhook_two = PolicyPreWebhook.create(\n        db=db,\n        data={\n            \"connection_config_id\": https_connection_config.id,\n            \"policy_id\": policy.id,\n            \"direction\": \"two_way\",\n            \"name\": str(uuid4()),\n            \"key\": \"pre_execution_two_way_webhook\",\n            \"order\": 1,\n        },\n    )\n    db.commit()\n    yield [pre_webhook, pre_webhook_two]\n    try:\n        pre_webhook.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        pre_webhook_two.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef policy_post_execution_webhooks(\n    db: Session, https_connection_config, policy\n) -> Generator:\n    post_webhook = PolicyPostWebhook.create(\n        db=db,\n        data={\n            \"connection_config_id\": https_connection_config.id,\n            \"policy_id\": policy.id,\n            \"direction\": \"one_way\",\n            \"name\": str(uuid4()),\n            \"key\": \"cache_busting_webhook\",\n            \"order\": 0,\n        },\n    )\n    post_webhook_two = PolicyPostWebhook.create(\n        db=db,\n        data={\n            \"connection_config_id\": https_connection_config.id,\n            \"policy_id\": policy.id,\n            \"direction\": \"one_way\",\n            \"name\": str(uuid4()),\n            \"key\": \"cleanup_webhook\",\n            \"order\": 1,\n        },\n    )\n    db.commit()\n    yield [post_webhook, post_webhook_two]\n    try:\n        post_webhook.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        post_webhook_two.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef access_and_erasure_policy(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    access_and_erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example access and erasure policy\",\n            \"key\": \"example_access_erasure_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n    access_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.access.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Access Request Rule\",\n            \"policy_id\": access_and_erasure_policy.id,\n            \"storage_destination_id\": storage_config.id,\n        },\n    )\n    access_rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user\").value,\n            \"rule_id\": access_rule.id,\n        },\n    )\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Erasure Rule\",\n            \"policy_id\": access_and_erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": \"null_rewrite\",\n                \"configuration\": {},\n            },\n        },\n    )\n\n    erasure_rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n    yield access_and_erasure_policy\n    try:\n        access_rule_target.delete(db)\n        erasure_rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_rule.delete(db)\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_and_erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy(\n    db: Session,\n    oauth_client: ClientDetail,\n) -> Generator:\n    erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example erasure policy\",\n            \"key\": \"example_erasure_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Erasure Rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": \"null_rewrite\",\n                \"configuration\": {},\n            },\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n    yield erasure_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy_aes(\n    db: Session,\n    oauth_client: ClientDetail,\n) -> Generator:\n    erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example erasure policy aes\",\n            \"key\": \"example_erasure_policy_aes\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Erasure Rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": \"aes_encrypt\",\n                \"configuration\": {},\n            },\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n    yield erasure_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy_string_rewrite_long(\n    db: Session,\n    oauth_client: ClientDetail,\n) -> Generator:\n    erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example erasure policy string rewrite\",\n            \"key\": \"example_erasure_policy_string_rewrite\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Erasure Rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": StringRewriteMaskingStrategy.name,\n                \"configuration\": {\n                    \"rewrite_value\": \"some rewrite value that is very long and goes on and on\"\n                },\n            },\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n    yield erasure_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy_two_rules(\n    db: Session, oauth_client: ClientDetail, erasure_policy: Policy\n) -> Generator:\n    second_erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Second Erasure Rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": NullMaskingStrategy.name,\n                \"configuration\": {},\n            },\n        },\n    )\n\n    # TODO set masking strategy in Rule.create() call above, once more masking strategies beyond NULL_REWRITE are supported.\n    second_erasure_rule.masking_strategy = {\n        \"strategy\": StringRewriteMaskingStrategy.name,\n        \"configuration\": {\"rewrite_value\": \"*****\"},\n    }\n\n    second_rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.contact.email\").value,\n            \"rule_id\": second_erasure_rule.id,\n        },\n    )\n    yield erasure_policy\n    try:\n        second_rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        second_erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef empty_policy(\n    db: Session,\n    oauth_client: ClientDetail,\n) -> Generator:\n    policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example empty policy\",\n            \"key\": \"example_empty_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n    yield policy\n    try:\n        policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef policy(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    access_request_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example access request policy\",\n            \"key\": \"example_access_request_policy\",\n            \"client_id\": oauth_client.id,\n            \"execution_timeframe\": 7,\n        },\n    )\n\n    access_request_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.access.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Access Request Rule\",\n            \"policy_id\": access_request_policy.id,\n            \"storage_destination_id\": storage_config.id,\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user\").value,\n            \"rule_id\": access_request_rule.id,\n        },\n    )\n    yield access_request_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_request_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_request_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef consent_policy(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    \"\"\"Consent policies only need a ConsentRule attached - no RuleTargets necessary\"\"\"\n    consent_request_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example consent request policy\",\n            \"key\": \"example_consent_request_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    consent_request_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.consent.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Consent Request Rule\",\n            \"policy_id\": consent_request_policy.id,\n        },\n    )\n\n    yield consent_request_policy\n    try:\n        consent_request_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        consent_request_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef policy_local_storage(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config_local: StorageConfig,\n) -> Generator:\n    \"\"\"\n    A basic example policy fixture that uses a local storage config\n    in cases where end-to-end request execution must actually succeed\n    \"\"\"\n    access_request_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example access request policy\",\n            \"key\": \"example_access_request_policy\",\n            \"client_id\": oauth_client.id,\n            \"execution_timeframe\": 7,\n        },\n    )\n\n    access_request_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.access.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Access Request Rule\",\n            \"policy_id\": access_request_policy.id,\n            \"storage_destination_id\": storage_config_local.id,\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user\").value,\n            \"rule_id\": access_request_rule.id,\n        },\n    )\n    yield access_request_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_request_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_request_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef policy_drp_action(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    access_request_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example access request policy drp\",\n            \"key\": \"example_access_request_policy_drp\",\n            \"drp_action\": \"access\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    access_request_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.access.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Access Request Rule DRP\",\n            \"policy_id\": access_request_policy.id,\n            \"storage_destination_id\": storage_config.id,\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user\").value,\n            \"rule_id\": access_request_rule.id,\n        },\n    )\n    yield access_request_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_request_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        access_request_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef policy_drp_action_erasure(db: Session, oauth_client: ClientDetail) -> Generator:\n    erasure_request_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"example erasure request policy drp\",\n            \"key\": \"example_erasure_request_policy_drp\",\n            \"drp_action\": \"deletion\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_request_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"Erasure Request Rule DRP\",\n            \"policy_id\": erasure_request_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": StringRewriteMaskingStrategy.name,\n                \"configuration\": {\"rewrite_value\": \"MASKED\"},\n            },\n        },\n    )\n\n    rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user\").value,\n            \"rule_id\": erasure_request_rule.id,\n        },\n    )\n    yield erasure_request_policy\n    try:\n        rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_request_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_request_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy_string_rewrite(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"string rewrite policy\",\n            \"key\": \"string_rewrite_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"string rewrite erasure rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": StringRewriteMaskingStrategy.name,\n                \"configuration\": {\"rewrite_value\": \"MASKED\"},\n            },\n        },\n    )\n\n    erasure_rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n\n    yield erasure_policy\n    try:\n        erasure_rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy_string_rewrite_name_and_email(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"string rewrite policy\",\n            \"key\": \"string_rewrite_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"string rewrite erasure rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": StringRewriteMaskingStrategy.name,\n                \"configuration\": {\"rewrite_value\": \"MASKED\"},\n            },\n        },\n    )\n\n    erasure_rule_target_name = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n\n    erasure_rule_target_email = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.contact.email\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n\n    yield erasure_policy\n    try:\n        erasure_rule_target_name.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule_target_email.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef erasure_policy_hmac(\n    db: Session,\n    oauth_client: ClientDetail,\n    storage_config: StorageConfig,\n) -> Generator:\n    erasure_policy = Policy.create(\n        db=db,\n        data={\n            \"name\": \"hmac policy\",\n            \"key\": \"hmac_policy\",\n            \"client_id\": oauth_client.id,\n        },\n    )\n\n    erasure_rule = Rule.create(\n        db=db,\n        data={\n            \"action_type\": ActionType.erasure.value,\n            \"client_id\": oauth_client.id,\n            \"name\": \"hmac erasure rule\",\n            \"policy_id\": erasure_policy.id,\n            \"masking_strategy\": {\n                \"strategy\": HmacMaskingStrategy.name,\n                \"configuration\": {},\n            },\n        },\n    )\n\n    erasure_rule_target = RuleTarget.create(\n        db=db,\n        data={\n            \"client_id\": oauth_client.id,\n            \"data_category\": DataCategory(\"user.name\").value,\n            \"rule_id\": erasure_rule.id,\n        },\n    )\n\n    yield erasure_policy\n    try:\n        erasure_rule_target.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_rule.delete(db)\n    except ObjectDeletedError:\n        pass\n    try:\n        erasure_policy.delete(db)\n    except ObjectDeletedError:\n        pass\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_requests(db: Session, policy: Policy) -> Generator:\n    privacy_requests = []\n    for count in range(3):\n        privacy_requests.append(\n            PrivacyRequest.create(\n                db=db,\n                data={\n                    \"external_id\": f\"ext-{str(uuid4())}\",\n                    \"started_processing_at\": datetime.utcnow(),\n                    \"requested_at\": datetime.utcnow() - timedelta(days=1),\n                    \"status\": PrivacyRequestStatus.in_processing,\n                    \"origin\": f\"https://example.com/{count}/\",\n                    \"policy_id\": policy.id,\n                    \"client_id\": policy.client_id,\n                },\n            )\n        )\n    yield privacy_requests\n    for pr in privacy_requests:\n        pr.delete(db)\n\n\ndef _create_privacy_request_for_policy(\n    db: Session,\n    policy: Policy,\n    status: PrivacyRequestStatus = PrivacyRequestStatus.in_processing,\n    email_identity: Optional[str] = \"test@example.com\",\n) -> PrivacyRequest:\n    data = {\n        \"external_id\": f\"ext-{str(uuid4())}\",\n        \"requested_at\": datetime(\n            2018,\n            12,\n            31,\n            hour=2,\n            minute=30,\n            second=23,\n            microsecond=916482,\n            tzinfo=timezone.utc,\n        ),\n        \"status\": status,\n        \"origin\": f\"https://example.com/\",\n        \"policy_id\": policy.id,\n        \"client_id\": policy.client_id,\n    }\n    if status != PrivacyRequestStatus.pending:\n        data[\"started_processing_at\"] = datetime(\n            2019,\n            1,\n            1,\n            hour=1,\n            minute=45,\n            second=55,\n            microsecond=393185,\n            tzinfo=timezone.utc,\n        )\n    pr = PrivacyRequest.create(\n        db=db,\n        data=data,\n    )\n    identity_kwargs = {\"email\": email_identity}\n    pr.cache_identity(identity_kwargs)\n    pr.persist_identity(\n        db=db,\n        identity=Identity(\n            email=email_identity,\n            phone_number=\"+12345678910\",\n        ),\n    )\n    return pr\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request(db: Session, policy: Policy) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        policy,\n    )\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_with_erasure_policy(\n    db: Session, erasure_policy: Policy\n) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        erasure_policy,\n    )\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_with_consent_policy(\n    db: Session, consent_policy: Policy\n) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        consent_policy,\n    )\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_with_custom_fields(db: Session, policy: Policy) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        policy,\n    )\n    privacy_request.persist_custom_privacy_request_fields(\n        db=db,\n        custom_privacy_request_fields={\n            \"first_name\": CustomPrivacyRequestField(label=\"First name\", value=\"John\"),\n            \"last_name\": CustomPrivacyRequestField(label=\"Last name\", value=\"Doe\"),\n        },\n    )\n    privacy_request.save(db)\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_requires_input(db: Session, policy: Policy) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        policy,\n    )\n    privacy_request.status = PrivacyRequestStatus.requires_input\n    privacy_request.save(db)\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_awaiting_consent_email_send(\n    db: Session, consent_policy: Policy\n) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        consent_policy,\n    )\n    privacy_request.status = PrivacyRequestStatus.awaiting_email_send\n    privacy_request.save(db)\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_awaiting_erasure_email_send(\n    db: Session, erasure_policy: Policy\n) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        erasure_policy,\n    )\n    privacy_request.status = PrivacyRequestStatus.awaiting_email_send\n    privacy_request.save(db)\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef audit_log(db: Session, privacy_request) -> PrivacyRequest:\n    audit_log = AuditLog.create(\n        db=db,\n        data={\n            \"user_id\": \"system\",\n            \"privacy_request_id\": privacy_request.id,\n            \"action\": AuditLogAction.approved,\n            \"message\": \"\",\n        },\n    )\n    yield audit_log\n    audit_log.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_status_pending(db: Session, policy: Policy) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        policy,\n        PrivacyRequestStatus.pending,\n    )\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_status_canceled(db: Session, policy: Policy) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        policy,\n        PrivacyRequestStatus.canceled,\n    )\n    privacy_request.started_processing_at = None\n    privacy_request.save(db)\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_request_with_drp_action(\n    db: Session, policy_drp_action: Policy\n) -> PrivacyRequest:\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        policy_drp_action,\n    )\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef succeeded_privacy_request(cache, db: Session, policy: Policy) -> PrivacyRequest:\n    pr = PrivacyRequest.create(\n        db=db,\n        data={\n            \"external_id\": f\"ext-{str(uuid4())}\",\n            \"started_processing_at\": datetime(2021, 10, 1),\n            \"finished_processing_at\": datetime(2021, 10, 3),\n            \"requested_at\": datetime(2021, 10, 1),\n            \"status\": PrivacyRequestStatus.complete,\n            \"origin\": f\"https://example.com/\",\n            \"policy_id\": policy.id,\n            \"client_id\": policy.client_id,\n        },\n    )\n    identity_kwargs = {\"email\": \"email@example.com\"}\n    pr.cache_identity(identity_kwargs)\n    pr.persist_identity(\n        db=db,\n        identity=Identity(**identity_kwargs),\n    )\n    yield pr\n    pr.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef failed_privacy_request(db: Session, policy: Policy) -> PrivacyRequest:\n    pr = PrivacyRequest.create(\n        db=db,\n        data={\n            \"external_id\": f\"ext-{str(uuid4())}\",\n            \"started_processing_at\": datetime(2021, 1, 1),\n            \"finished_processing_at\": datetime(2021, 1, 2),\n            \"requested_at\": datetime(2020, 12, 31),\n            \"status\": PrivacyRequestStatus.error,\n            \"origin\": f\"https://example.com/\",\n            \"policy_id\": policy.id,\n            \"client_id\": policy.client_id,\n        },\n    )\n    yield pr\n    pr.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice\",\n            \"notice_key\": \"example_privacy_notice\",\n            \"description\": \"user&#x27;s description &lt;script /&gt;\",\n            \"regions\": [\n                PrivacyNoticeRegion.us_ca,\n                PrivacyNoticeRegion.us_co,\n            ],\n            \"consent_mechanism\": ConsentMechanism.opt_in,\n            \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n            \"enforcement_level\": EnforcementLevel.system_wide,\n            \"displayed_in_privacy_center\": True,\n            \"displayed_in_overlay\": True,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history(\n    db: Session, privacy_notice, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"acknowledge_mode\": False,\n            \"serving_component\": \"overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"privacy_notice_history_id\": privacy_notice.privacy_notice_history_id,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history_for_tcf_purpose(\n    db: Session, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"acknowledge_mode\": False,\n            \"serving_component\": \"tcf_overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"purpose_consent\": 8,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history_for_vendor_legitimate_interests(\n    db: Session, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"serving_component\": \"tcf_overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"vendor_legitimate_interests\": \"gvl.42\",\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history_for_tcf_feature(\n    db: Session, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"acknowledge_mode\": False,\n            \"serving_component\": \"tcf_overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"feature\": 2,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history_for_tcf_special_purpose(\n    db: Session, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"acknowledge_mode\": False,\n            \"serving_component\": \"tcf_overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"special_purpose\": 1,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice_us_ca_provide(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice us_ca provide\",\n            \"notice_key\": \"example_privacy_notice_us_ca_provide\",\n            # no description or origin on this privacy notice to help\n            # cover edge cases due to column nullability\n            \"regions\": [PrivacyNoticeRegion.us_ca],\n            \"consent_mechanism\": ConsentMechanism.opt_in,\n            \"data_uses\": [\"essential\"],\n            \"enforcement_level\": EnforcementLevel.system_wide,\n            \"displayed_in_overlay\": True,\n            \"displayed_in_privacy_center\": False,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_us_ca_provide(\n    db: Session, privacy_notice_us_ca_provide\n) -> Generator:\n    provided_identity_data = {\n        \"privacy_request_id\": None,\n        \"field_name\": \"email\",\n        \"hashed_value\": ProvidedIdentity.hash_value(\"test2@email.com\"),\n        \"encrypted_value\": {\"value\": \"test2@email.com\"},\n    }\n    provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n    pref_1 = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"preference\": \"opt_in\",\n            \"provided_identity_id\": provided_identity.id,\n            \"privacy_notice_history_id\": privacy_notice_us_ca_provide.privacy_notice_history_id,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n    provided_identity.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history_us_provide_for_fides_user(\n    db: Session, privacy_notice_us_ca_provide, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"acknowledge_mode\": False,\n            \"serving_component\": \"overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"privacy_notice_history_id\": privacy_notice_us_ca_provide.privacy_notice_history_id,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_us_ca_provide_for_fides_user(\n    db: Session, privacy_notice_us_ca_provide, fides_user_provided_identity\n) -> Generator:\n    pref_1 = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"preference\": \"opt_in\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"privacy_notice_history_id\": privacy_notice_us_ca_provide.privacy_notice_history_id,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef served_notice_history_us_ca_provide_for_fides_user(\n    db: Session, privacy_notice_us_ca_provide, fides_user_provided_identity\n) -> Generator:\n    pref_1 = ServedNoticeHistory.create(\n        db=db,\n        data={\n            \"acknowledge_mode\": False,\n            \"serving_component\": \"overlay\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"privacy_notice_history_id\": privacy_notice_us_ca_provide.privacy_notice_history_id,\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice_us_co_third_party_sharing(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice us_co third_party_sharing\",\n            \"notice_key\": \"example_privacy_notice_us_co_third_party_sharing\",\n            \"description\": \"a sample privacy notice configuration\",\n            \"regions\": [PrivacyNoticeRegion.us_co],\n            \"consent_mechanism\": ConsentMechanism.opt_in,\n            \"data_uses\": [\"third_party_sharing\"],\n            \"enforcement_level\": EnforcementLevel.system_wide,\n            \"displayed_in_overlay\": True,\n            \"displayed_in_privacy_center\": True,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice_us_co_provide_service_operations(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice us_co provide.service.operations\",\n            \"notice_key\": \"example_privacy_notice_us_co_provide.service.operations\",\n            \"description\": \"a sample privacy notice configuration\",\n            \"regions\": [PrivacyNoticeRegion.us_co],\n            \"consent_mechanism\": ConsentMechanism.opt_in,\n            \"data_uses\": [\"essential.service.operations\"],\n            \"enforcement_level\": EnforcementLevel.system_wide,\n            \"displayed_in_privacy_center\": False,\n            \"displayed_in_overlay\": True,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_experience_france_tcf_overlay(\n    db: Session, experience_config_tcf_overlay\n) -> Generator:\n    privacy_experience = PrivacyExperience.create(\n        db=db,\n        data={\n            \"component\": ComponentType.tcf_overlay,\n            \"region\": PrivacyNoticeRegion.fr,\n            \"experience_config_id\": experience_config_tcf_overlay.id,\n        },\n    )\n\n    yield privacy_experience\n    privacy_experience.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_experience_france_overlay(\n    db: Session, experience_config_overlay\n) -> Generator:\n    privacy_experience = PrivacyExperience.create(\n        db=db,\n        data={\n            \"component\": ComponentType.overlay,\n            \"region\": PrivacyNoticeRegion.fr,\n            \"experience_config_id\": experience_config_overlay.id,\n        },\n    )\n\n    yield privacy_experience\n    privacy_experience.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice_fr_provide_service_frontend_only(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice us_co provide.service.operations\",\n            \"notice_key\": \"example_privacy_notice_us_co_provide.service.operations\",\n            \"description\": \"a sample privacy notice configuration\",\n            \"regions\": [PrivacyNoticeRegion.fr],\n            \"consent_mechanism\": ConsentMechanism.opt_in,\n            \"data_uses\": [\"essential.service\"],\n            \"enforcement_level\": EnforcementLevel.frontend,\n            \"displayed_in_overlay\": True,\n            \"displayed_in_privacy_center\": False,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice_eu_cy_provide_service_frontend_only(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice eu_cy provide.service.operations\",\n            \"notice_key\": \"example_privacy_notice_eu_cy_provide.service.operations\",\n            \"description\": \"a sample privacy notice configuration\",\n            \"regions\": [PrivacyNoticeRegion.cy],\n            \"consent_mechanism\": ConsentMechanism.opt_out,\n            \"data_uses\": [\"essential.service\"],\n            \"enforcement_level\": EnforcementLevel.frontend,\n            \"displayed_in_overlay\": False,\n            \"displayed_in_privacy_center\": True,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_fr_provide_service_frontend_only(\n    db: Session, privacy_notice_fr_provide_service_frontend_only\n) -> Generator:\n    provided_identity_data = {\n        \"privacy_request_id\": None,\n        \"field_name\": \"email\",\n        \"hashed_value\": ProvidedIdentity.hash_value(\"test2@email.com\"),\n        \"encrypted_value\": {\"value\": \"test2@email.com\"},\n    }\n    provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n    pref_1 = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"preference\": \"opt_in\",\n            \"provided_identity_id\": provided_identity.id,\n            \"privacy_notice_history_id\": privacy_notice_fr_provide_service_frontend_only.privacy_notice_history_id,\n            \"user_geography\": \"fr_idg\",\n        },\n        check_name=False,\n    )\n    yield pref_1\n    pref_1.delete(db)\n    provided_identity.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef ctl_dataset(db: Session, example_datasets):\n    ds = Dataset(\n        fides_key=\"postgres_example_subscriptions_dataset\",\n        organization_fides_key=\"default_organization\",\n        name=\"Postgres Example Subscribers Dataset\",\n        description=\"Example Postgres dataset created in test fixtures\",\n        data_qualifier=\"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n        retention=\"No retention or erasure policy\",\n        collections=[\n            {\n                \"name\": \"subscriptions\",\n                \"fields\": [\n                    {\n                        \"name\": \"id\",\n                        \"data_categories\": [\"system.operations\"],\n                    },\n                    {\n                        \"name\": \"email\",\n                        \"data_categories\": [\"user.contact.email\"],\n                        \"fidesops_meta\": {\n                            \"identity\": \"email\",\n                        },\n                    },\n                ],\n            },\n        ],\n    )\n    dataset = CtlDataset(**ds.dict())\n    db.add(dataset)\n    db.commit()\n    yield dataset\n    dataset.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef unlinked_dataset(db: Session):\n    ds = Dataset(\n        fides_key=\"unlinked_dataset\",\n        organization_fides_key=\"default_organization\",\n        name=\"Unlinked Dataset\",\n        description=\"Example dataset created in test fixtures\",\n        data_qualifier=\"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n        retention=\"No retention or erasure policy\",\n        collections=[\n            {\n                \"name\": \"subscriptions\",\n                \"fields\": [\n                    {\n                        \"name\": \"id\",\n                        \"data_categories\": [\"system.operations\"],\n                    },\n                    {\n                        \"name\": \"email\",\n                        \"data_categories\": [\"user.contact.email\"],\n                        \"fidesops_meta\": {\n                            \"identity\": \"email\",\n                        },\n                    },\n                ],\n            },\n        ],\n    )\n    dataset = CtlDataset(**ds.dict())\n    db.add(dataset)\n    db.commit()\n    yield dataset\n    dataset.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef linked_dataset(db: Session, connection_config: ConnectionConfig) -> Generator:\n    ds = Dataset(\n        fides_key=\"linked_dataset\",\n        organization_fides_key=\"default_organization\",\n        name=\"Linked Dataset\",\n        description=\"Example dataset created in test fixtures\",\n        data_qualifier=\"aggregated.anonymized.linked_pseudonymized.pseudonymized.identified\",\n        retention=\"No retention or erasure policy\",\n        collections=[\n            {\n                \"name\": \"subscriptions\",\n                \"fields\": [\n                    {\n                        \"name\": \"id\",\n                        \"data_categories\": [\"system.operations\"],\n                    },\n                    {\n                        \"name\": \"email\",\n                        \"data_categories\": [\"user.contact.email\"],\n                        \"fidesops_meta\": {\n                            \"identity\": \"email\",\n                        },\n                    },\n                ],\n            },\n        ],\n    )\n    dataset = CtlDataset(**ds.dict())\n    db.add(dataset)\n    db.commit()\n    dataset_config = DatasetConfig.create(\n        db=db,\n        data={\n            \"connection_config_id\": connection_config.id,\n            \"fides_key\": \"postgres_example_subscriptions_dataset\",\n            \"ctl_dataset_id\": dataset.id,\n        },\n    )\n\n    yield dataset\n    dataset_config.delete(db)\n    dataset.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef dataset_config(\n    connection_config: ConnectionConfig,\n    ctl_dataset,\n    db: Session,\n) -> Generator:\n    dataset_config = DatasetConfig.create(\n        db=db,\n        data={\n            \"connection_config_id\": connection_config.id,\n            \"fides_key\": \"postgres_example_subscriptions_dataset\",\n            \"ctl_dataset_id\": ctl_dataset.id,\n        },\n    )\n    yield dataset_config\n    dataset_config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef dataset_config_preview(\n    connection_config: ConnectionConfig, db: Session, ctl_dataset\n) -> Generator:\n    ctl_dataset.fides_key = \"postgres\"\n    db.add(ctl_dataset)\n    db.commit()\n    dataset_config = DatasetConfig.create(\n        db=db,\n        data={\n            \"connection_config_id\": connection_config.id,\n            \"fides_key\": \"postgres\",\n            \"ctl_dataset_id\": ctl_dataset.id,\n        },\n    )\n    yield dataset_config\n    dataset_config.delete(db)\n\n\ndef load_dataset(filename: str) -> Dict:\n    yaml_file = load_file([filename])\n    with open(yaml_file, \"r\") as file:\n        return yaml.safe_load(file).get(\"dataset\", [])\n\n\ndef load_dataset_as_string(filename: str) -> str:\n    yaml_file = load_file([filename])\n    with open(yaml_file, \"r\") as file:\n        return file.read()\n\n\n@pytest.fixture\ndef example_datasets() -> List[Dict]:\n    example_datasets = []\n    example_filenames = [\n        \"data/dataset/postgres_example_test_dataset.yml\",\n        \"data/dataset/mongo_example_test_dataset.yml\",\n        \"data/dataset/snowflake_example_test_dataset.yml\",\n        \"data/dataset/redshift_example_test_dataset.yml\",\n        \"data/dataset/mssql_example_test_dataset.yml\",\n        \"data/dataset/mysql_example_test_dataset.yml\",\n        \"data/dataset/mariadb_example_test_dataset.yml\",\n        \"data/dataset/bigquery_example_test_dataset.yml\",\n        \"data/dataset/manual_dataset.yml\",\n        \"data/dataset/email_dataset.yml\",\n        \"data/dataset/remote_fides_example_test_dataset.yml\",\n        \"data/dataset/dynamodb_example_test_dataset.yml\",\n    ]\n    for filename in example_filenames:\n        example_datasets += load_dataset(filename)\n    return example_datasets\n\n\n@pytest.fixture\ndef example_yaml_datasets() -> str:\n    example_filename = \"data/dataset/example_test_datasets.yml\"\n    return load_dataset_as_string(example_filename)\n\n\n@pytest.fixture\ndef example_yaml_dataset() -> str:\n    example_filename = \"data/dataset/postgres_example_test_dataset.yml\"\n    return load_dataset_as_string(example_filename)\n\n\n@pytest.fixture\ndef example_invalid_yaml_dataset() -> str:\n    example_filename = \"data/dataset/example_test_dataset.invalid\"\n    return load_dataset_as_string(example_filename)\n\n\n@pytest.fixture(scope=\"function\")\ndef sample_data():\n    return {\n        \"_id\": 12345,\n        \"thread\": [\n            {\n                \"comment\": \"com_0001\",\n                \"message\": \"hello, testing in-flight chat feature\",\n                \"chat_name\": \"John\",\n                \"messages\": {},\n            },\n            {\n                \"comment\": \"com_0002\",\n                \"message\": \"yep, got your message, looks like it works\",\n                \"chat_name\": \"Jane\",\n            },\n            {\"comment\": \"com_0002\", \"message\": \"hello!\", \"chat_name\": \"Jeanne\"},\n        ],\n        \"snacks\": [\"pizza\", \"chips\"],\n        \"seats\": {\"first_choice\": \"A2\", \"second_choice\": \"B3\"},\n        \"upgrades\": {\n            \"magazines\": [\"Time\", \"People\"],\n            \"books\": [\"Once upon a Time\", \"SICP\"],\n            \"earplugs\": True,\n        },\n        \"other_flights\": [\n            {\"DFW\": [\"11 AM\", \"12 PM\"], \"CHO\": [\"12 PM\", \"1 PM\"]},\n            {\"DFW\": [\"2 AM\", \"12 PM\"], \"CHO\": [\"2 PM\", \"1 PM\"]},\n            {\"DFW\": [\"3 AM\", \"2 AM\"], \"CHO\": [\"2 PM\", \"1:30 PM\"]},\n        ],\n        \"months\": {\n            \"july\": [\n                {\n                    \"activities\": [\"swimming\", \"hiking\"],\n                    \"crops\": [\"watermelon\", \"cheese\", \"grapes\"],\n                },\n                {\"activities\": [\"tubing\"], \"crops\": [\"corn\"]},\n            ],\n            \"march\": [\n                {\n                    \"activities\": [\"skiing\", \"bobsledding\"],\n                    \"crops\": [\"swiss chard\", \"swiss chard\"],\n                },\n                {\"activities\": [\"hiking\"], \"crops\": [\"spinach\"]},\n            ],\n        },\n        \"hello\": [1, 2, 3, 4, 2],\n        \"weights\": [[1, 2], [3, 4]],\n        \"toppings\": [[[\"pepperoni\", \"salami\"], [\"pepperoni\", \"cheese\", \"cheese\"]]],\n        \"A\": {\"C\": [{\"M\": [\"p\", \"n\", \"n\"]}]},\n        \"C\": [[\"A\", \"B\", \"C\", \"B\"], [\"G\", \"H\", \"B\", \"B\"]],  # Double lists\n        \"D\": [\n            [[\"A\", \"B\", \"C\", \"B\"], [\"G\", \"H\", \"B\", \"B\"]],\n            [[\"A\", \"B\", \"C\", \"B\"], [\"G\", \"H\", \"B\", \"B\"]],\n        ],  # Triple lists\n        \"E\": [[[\"B\"], [[\"A\", \"B\", \"C\", \"B\"], [\"G\", \"H\", \"B\", \"B\"]]]],  # Irregular lists\n        \"F\": [\n            \"a\",\n            [\"1\", \"a\", [[\"z\", \"a\", \"a\"]]],\n        ],  # Lists elems are different types, not officially supported\n    }\n\n\n@pytest.fixture(scope=\"function\")\ndef application_user(\n    db,\n    oauth_client,\n) -> FidesUser:\n    unique_username = f\"user-{uuid4()}\"\n    user = FidesUser.create(\n        db=db,\n        data={\n            \"username\": unique_username,\n            \"password\": \"test_password\",\n            \"first_name\": \"Test\",\n            \"last_name\": \"User\",\n        },\n    )\n    oauth_client.user_id = user.id\n    oauth_client.save(db=db)\n    yield user\n    user.delete(db=db)\n\n\n@pytest.fixture(scope=\"function\")\ndef short_redis_cache_expiration():\n    original_value: int = CONFIG.redis.default_ttl_seconds\n    CONFIG.redis.default_ttl_seconds = (\n        1  # Set redis cache to expire very quickly for testing purposes\n    )\n    yield CONFIG\n    CONFIG.redis.default_ttl_seconds = original_value\n\n\n@pytest.fixture(scope=\"function\")\ndef user_registration_opt_out(db: Session) -> UserRegistration:\n    \"\"\"Adds a UserRegistration record with `opt_in` as False.\"\"\"\n    return create_user_registration(db, opt_in=False)\n\n\n@pytest.fixture(scope=\"function\")\ndef user_registration_opt_in(db: Session) -> UserRegistration:\n    \"\"\"Adds a UserRegistration record with `opt_in` as True.\"\"\"\n    return create_user_registration(db, opt_in=True)\n\n\ndef create_user_registration(db: Session, opt_in: bool = False) -> UserRegistration:\n    \"\"\"Adds a UserRegistration record.\"\"\"\n    return UserRegistration.create(\n        db=db,\n        data={\n            \"user_email\": \"user@example.com\",\n            \"user_organization\": \"Example Org.\",\n            \"analytics_id\": \"example-analytics-id\",\n            \"opt_in\": opt_in,\n        },\n    )\n\n\n@pytest.fixture(scope=\"function\")\ndef test_fides_client(\n    fides_connector_example_secrets: Dict[str, str], api_client\n) -> FidesClient:\n    return FidesClient(\n        fides_connector_example_secrets[\"uri\"],\n        fides_connector_example_secrets[\"username\"],\n        fides_connector_example_secrets[\"password\"],\n        fides_connector_example_secrets[\"polling_timeout\"],\n    )\n\n\n@pytest.fixture(scope=\"function\")\ndef authenticated_fides_client(\n    test_fides_client: FidesClient,\n) -> FidesClient:\n    test_fides_client.login()\n    return test_fides_client\n\n\n@pytest.fixture(scope=\"function\")\ndef system_manager(db: Session, system) -> System:\n    user = FidesUser.create(\n        db=db,\n        data={\n            \"username\": \"test_system_manager_user\",\n            \"password\": \"TESTdcnG@wzJeu0&%3Qe2fGo7\",\n        },\n    )\n    client = ClientDetail(\n        hashed_secret=\"thisisatest\",\n        salt=\"thisisstillatest\",\n        scopes=[],\n        roles=[VIEWER],\n        user_id=user.id,\n        systems=[system.id],\n    )\n\n    FidesUserPermissions.create(db=db, data={\"user_id\": user.id, \"roles\": [VIEWER]})\n\n    db.add(client)\n    db.commit()\n    db.refresh(client)\n\n    user.set_as_system_manager(db, system)\n    yield user\n    try:\n        user.remove_as_system_manager(db, system)\n    except (SystemManagerException, StaleDataError):\n        pass\n    user.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef empty_provided_identity(db):\n    provided_identity = ProvidedIdentity.create(db, data={\"field_name\": \"email\"})\n    yield provided_identity\n    provided_identity.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef provided_identity_value():\n    return \"test@email.com\"\n\n\n@pytest.fixture(scope=\"function\")\ndef provided_identity_and_consent_request(\n    db,\n    provided_identity_value,\n):\n    provided_identity_data = {\n        \"privacy_request_id\": None,\n        \"field_name\": \"email\",\n        \"hashed_value\": ProvidedIdentity.hash_value(provided_identity_value),\n        \"encrypted_value\": {\"value\": provided_identity_value},\n    }\n    provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n    consent_request_data = {\n        \"provided_identity_id\": provided_identity.id,\n    }\n    consent_request = ConsentRequest.create(db, data=consent_request_data)\n\n    yield provided_identity, consent_request\n    provided_identity.delete(db=db)\n    consent_request.delete(db=db)\n\n\n@pytest.fixture(scope=\"function\")\ndef fides_user_provided_identity(db):\n    provided_identity_data = {\n        \"privacy_request_id\": None,\n        \"field_name\": \"fides_user_device_id\",\n        \"hashed_value\": ProvidedIdentity.hash_value(\n            \"051b219f-20e4-45df-82f7-5eb68a00889f\"\n        ),\n        \"encrypted_value\": {\"value\": \"051b219f-20e4-45df-82f7-5eb68a00889f\"},\n    }\n    provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n    yield provided_identity\n    provided_identity.delete(db=db)\n\n\n@pytest.fixture(scope=\"function\")\ndef fides_user_provided_identity_and_consent_request(db, fides_user_provided_identity):\n    consent_request_data = {\n        \"provided_identity_id\": fides_user_provided_identity.id,\n    }\n    consent_request = ConsentRequest.create(db, data=consent_request_data)\n\n    yield fides_user_provided_identity, consent_request\n    fides_user_provided_identity.delete(db=db)\n    consent_request.delete(db=db)\n\n\n@pytest.fixture(scope=\"function\")\ndef executable_consent_request(\n    db,\n    provided_identity_and_consent_request,\n    consent_policy,\n):\n    provided_identity = provided_identity_and_consent_request[0]\n    consent_request = provided_identity_and_consent_request[1]\n    privacy_request = _create_privacy_request_for_policy(\n        db,\n        consent_policy,\n    )\n    consent_request.privacy_request_id = privacy_request.id\n    consent_request.save(db)\n    provided_identity.privacy_request_id = privacy_request.id\n    provided_identity.save(db)\n    yield privacy_request\n    privacy_request.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history(\n    db,\n    provided_identity_and_consent_request,\n    privacy_notice,\n    privacy_experience_privacy_center,\n    served_notice_history,\n):\n    provided_identity, consent_request = provided_identity_and_consent_request\n    privacy_notice_history = privacy_notice.histories[0]\n\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"method\": \"button\",\n            \"privacy_experience_config_history_id\": privacy_experience_privacy_center.experience_config.experience_config_history_id,\n            \"privacy_experience_id\": privacy_experience_privacy_center.id,\n            \"preference\": \"opt_out\",\n            \"privacy_notice_history_id\": privacy_notice_history.id,\n            \"provided_identity_id\": provided_identity.id,\n            \"request_origin\": \"privacy_center\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"us_ca\",\n            \"url_recorded\": \"https://example.com/privacy_center\",\n            \"served_notice_history_id\": served_notice_history.id,\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_tcf_purpose_consent(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n    served_notice_history_for_tcf_purpose,\n):\n    \"\"\"Fixture that saves a privacy preference against a TCF purpose directly\"\"\"\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"fides_user_device\": \"051b219f-20e4-45df-82f7-5eb68a00889f\",\n            \"method\": \"button\",\n            \"purpose_consent\": 8,\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_out\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"fr_idg\",\n            \"url_recorded\": \"example.com/\",\n            \"served_notice_history_id\": served_notice_history_for_tcf_purpose.id,\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_tcf_purpose_legitimate_interests(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n):\n    \"\"\"Fixture that saves a privacy preference against a TCF purpose directly\"\"\"\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"fides_user_device\": \"051b219f-20e4-45df-82f7-5eb68a00889f\",\n            \"method\": \"button\",\n            \"purpose_legitimate_interests\": 8,\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_in\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_vendor(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n):\n    \"\"\"Fixture that saves a privacy preference against a TCF vendor directly\"\"\"\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"method\": \"button\",\n            \"vendor_consent\": \"gvl.42\",\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_out\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"fr_idg\",\n            \"url_recorded\": \"example.com/\",\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_vendor_legitimate_interests(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n    served_notice_history_for_vendor_legitimate_interests,\n):\n    \"\"\"Fixture that saves a privacy preference against a TCF vendor directly\"\"\"\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"method\": \"button\",\n            \"vendor_legitimate_interests\": \"gvl.42\",\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_out\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"fr_idg\",\n            \"url_recorded\": \"example.com/\",\n            \"served_notice_history_id\": served_notice_history_for_vendor_legitimate_interests.id,\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_system(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n    system,\n):\n    \"\"\"Fixture that saves a privacy preference against a system fides key directly\"\"\"\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"method\": \"button\",\n            \"system_consent\": system.id,\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_in\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"fr_idg\",\n            \"url_recorded\": \"example.com/\",\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_tcf_feature(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n    served_notice_history_for_tcf_feature,\n):\n    \"\"\"Fixture that saves a privacy preference against a TCF feature directly\"\"\"\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"fides_user_device\": \"051b219f-20e4-45df-82f7-5eb68a00889f\",\n            \"method\": \"button\",\n            \"feature\": 2,\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_in\",\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"fr_idg\",\n            \"url_recorded\": \"example.com/\",\n            \"served_notice_history_id\": served_notice_history_for_tcf_feature.id,\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_preference_history_for_tcf_special_purpose(\n    db,\n    provided_identity_and_consent_request,\n    privacy_experience_france_overlay,\n    fides_user_provided_identity,\n):\n    \"\"\"Fixture that saves a privacy preference against a TCF special purpose directly\"\"\"\n    (\n        provided_identity,\n        _,\n    ) = provided_identity_and_consent_request\n\n    preference_history_record = PrivacyPreferenceHistory.create(\n        db=db,\n        data={\n            \"anonymized_ip_address\": \"92.158.1.0\",\n            \"email\": \"test@email.com\",\n            \"method\": \"button\",\n            \"special_purpose\": 1,\n            \"privacy_experience_config_history_id\": None,\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"preference\": \"opt_in\",\n            \"provided_identity_id\": provided_identity.id,\n            \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            \"request_origin\": \"tcf_overlay\",\n            \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n            \"user_geography\": \"fr_idg\",\n            \"url_recorded\": \"example.com/\",\n        },\n        check_name=False,\n    )\n    yield preference_history_record\n    preference_history_record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef anonymous_consent_records(\n    db,\n    fides_user_provided_identity_and_consent_request,\n):\n    (\n        provided_identity,\n        consent_request,\n    ) = fides_user_provided_identity_and_consent_request\n    consent_request.cache_identity_verification_code(\"abcdefg\")\n\n    consent_data = [\n        {\n            \"data_use\": \"email\",\n            \"data_use_description\": None,\n            \"opt_in\": True,\n        },\n        {\n            \"data_use\": \"location\",\n            \"data_use_description\": \"Location data\",\n            \"opt_in\": False,\n        },\n    ]\n\n    records = []\n    for data in deepcopy(consent_data):\n        data[\"provided_identity_id\"] = provided_identity.id\n        records.append(Consent.create(db, data=data))\n\n    yield records\n\n    for record in records:\n        record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef consent_records(\n    db,\n    provided_identity_and_consent_request,\n):\n    provided_identity, consent_request = provided_identity_and_consent_request\n    consent_request.cache_identity_verification_code(\"abcdefg\")\n\n    consent_data = [\n        {\n            \"data_use\": \"email\",\n            \"data_use_description\": None,\n            \"opt_in\": True,\n        },\n        {\n            \"data_use\": \"location\",\n            \"data_use_description\": \"Location data\",\n            \"opt_in\": False,\n        },\n    ]\n\n    records = []\n    for data in deepcopy(consent_data):\n        data[\"provided_identity_id\"] = provided_identity.id\n        records.append(Consent.create(db, data=data))\n\n    yield records\n\n    for record in records:\n        record.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef experience_config_privacy_center(db: Session) -> Generator:\n    exp = PrivacyExperienceConfig.create(\n        db=db,\n        data={\n            \"accept_button_label\": \"Accept all\",\n            \"description\": \"user&#x27;s description &lt;script /&gt;\",\n            \"component\": \"privacy_center\",\n            \"reject_button_label\": \"Reject all\",\n            \"save_button_label\": \"Save\",\n            \"title\": \"Control your privacy\",\n            \"disabled\": True,\n        },\n    )\n    yield exp\n    for history in exp.histories:\n        history.delete(db)\n    exp.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_experience_privacy_center(\n    db: Session, experience_config_privacy_center\n) -> Generator:\n    privacy_experience = PrivacyExperience.create(\n        db=db,\n        data={\n            \"component\": ComponentType.privacy_center,\n            \"region\": PrivacyNoticeRegion.us_co,\n            \"experience_config_id\": experience_config_privacy_center.id,\n        },\n    )\n\n    yield privacy_experience\n    privacy_experience.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef experience_config_overlay(db: Session) -> Generator:\n    config = PrivacyExperienceConfig.create(\n        db=db,\n        data={\n            \"accept_button_label\": \"Accept all\",\n            \"acknowledge_button_label\": \"Confirm\",\n            \"banner_enabled\": \"enabled_where_required\",\n            \"component\": \"overlay\",\n            \"description\": \"On this page you can opt in and out of these data uses cases\",\n            \"disabled\": False,\n            \"privacy_preferences_link_label\": \"Manage preferences\",\n            \"privacy_policy_link_label\": \"View our company&#x27;s privacy policy\",\n            \"privacy_policy_url\": \"https://example.com/privacy\",\n            \"reject_button_label\": \"Reject all\",\n            \"save_button_label\": \"Save\",\n            \"title\": \"Manage your consent\",\n        },\n    )\n\n    yield config\n    for history in config.histories:\n        history.delete(db)\n    config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef experience_config_tcf_overlay(db: Session) -> Generator:\n    config = PrivacyExperienceConfig.create(\n        db=db,\n        data={\n            \"accept_button_label\": \"Accept all\",\n            \"acknowledge_button_label\": \"Confirm\",\n            \"banner_enabled\": \"enabled_where_required\",\n            \"component\": \"tcf_overlay\",\n            \"description\": \"On this page you can opt in and out of these data uses cases\",\n            \"disabled\": False,\n            \"privacy_preferences_link_label\": \"Manage preferences\",\n            \"privacy_policy_link_label\": \"View our company&#x27;s privacy policy\",\n            \"privacy_policy_url\": \"https://example.com/privacy\",\n            \"reject_button_label\": \"Reject all\",\n            \"save_button_label\": \"Save\",\n            \"title\": \"Manage your consent\",\n        },\n    )\n\n    yield config\n    for history in config.histories:\n        history.delete(db)\n    config.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_experience_overlay(db: Session, experience_config_overlay) -> Generator:\n    privacy_experience = PrivacyExperience.create(\n        db=db,\n        data={\n            \"component\": ComponentType.overlay,\n            \"region\": PrivacyNoticeRegion.us_ca,\n            \"experience_config_id\": experience_config_overlay.id,\n        },\n    )\n\n    yield privacy_experience\n    privacy_experience.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_experience_privacy_center_france(\n    db: Session, experience_config_privacy_center\n) -> Generator:\n    privacy_experience = PrivacyExperience.create(\n        db=db,\n        data={\n            \"component\": ComponentType.privacy_center,\n            \"region\": PrivacyNoticeRegion.fr,\n            \"experience_config_id\": experience_config_privacy_center.id,\n        },\n    )\n\n    yield privacy_experience\n    privacy_experience.delete(db)\n\n\n@pytest.fixture(scope=\"function\")\ndef privacy_notice_france(db: Session) -> Generator:\n    privacy_notice = PrivacyNotice.create(\n        db=db,\n        data={\n            \"name\": \"example privacy notice\",\n            \"notice_key\": \"example_privacy_notice\",\n            \"description\": \"user description\",\n            \"regions\": [\n                PrivacyNoticeRegion.fr,\n            ],\n            \"consent_mechanism\": ConsentMechanism.opt_in,\n            \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n            \"enforcement_level\": EnforcementLevel.system_wide,\n            \"displayed_in_privacy_center\": True,\n            \"displayed_in_overlay\": False,\n            \"displayed_in_api\": False,\n        },\n    )\n\n    yield privacy_notice\n\n\n@pytest.fixture(scope=\"function\")\ndef allow_custom_privacy_request_field_collection_enabled():\n    original_value = CONFIG.execution.allow_custom_privacy_request_field_collection\n    CONFIG.execution.allow_custom_privacy_request_field_collection = True\n    yield\n    CONFIG.notifications.send_request_review_notification = original_value\n\n\n@pytest.fixture(scope=\"function\")\ndef system_with_no_uses(db: Session) -> System:\n    system = System.create(\n        db=db,\n        data={\n            \"fides_key\": f\"system_fides_key\",\n            \"name\": f\"system-{uuid4()}\",\n            \"description\": \"tcf_relevant_system\",\n            \"organization_fides_key\": \"default_organization\",\n            \"system_type\": \"Service\",\n            \"data_responsibility_title\": \"Processor\",\n            \"data_protection_impact_assessment\": {\n                \"is_required\": False,\n                \"progress\": None,\n                \"link\": None,\n            },\n        },\n    )\n    return system\n\n\n@pytest.fixture(scope=\"function\")\ndef tcf_system(db: Session) -> System:\n    system = System.create(\n        db=db,\n        data={\n            \"fides_key\": f\"tcf-system_key-f{uuid4()}\",\n            \"vendor_id\": \"gvl.42\",\n            \"name\": f\"TCF System Test\",\n            \"description\": \"My TCF System Description\",\n            \"organization_fides_key\": \"default_organization\",\n            \"system_type\": \"Service\",\n            \"data_responsibility_title\": \"Processor\",\n            \"data_protection_impact_assessment\": {\n                \"is_required\": False,\n                \"progress\": None,\n                \"link\": None,\n            },\n        },\n    )\n\n    PrivacyDeclaration.create(\n        db=db,\n        data={\n            \"name\": \"Collect data for content performance\",\n            \"system_id\": system.id,\n            \"data_categories\": [\"user.device.cookie_id\"],\n            \"data_use\": \"analytics.reporting.content_performance\",\n            \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n            \"data_subjects\": [\"customer\"],\n            \"dataset_references\": None,\n            \"legal_basis_for_processing\": \"Consent\",\n            \"egress\": None,\n            \"ingress\": None,\n        },\n    )\n\n    PrivacyDeclaration.create(\n        db=db,\n        data={\n            \"name\": \"Ensure security, prevent and detect fraud\",\n            \"system_id\": system.id,\n            \"data_categories\": [\"user\"],\n            \"data_use\": \"essential.fraud_detection\",\n            \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n            \"data_subjects\": [\"customer\"],\n            \"dataset_references\": None,\n            \"legal_basis_for_processing\": \"Legitimate interests\",\n            \"egress\": None,\n            \"ingress\": None,\n        },\n    )\n\n    db.refresh(system)\n    return system\n\n\n@pytest.fixture(scope=\"function\")\ndef ac_system(db: Session) -> System:\n    \"\"\"Test AC System - will be fleshed out further later\"\"\"\n    system = System.create(\n        db=db,\n        data={\n            \"fides_key\": f\"ac_system{uuid.uuid4()}\",\n            \"vendor_id\": \"gacp.8\",\n            \"name\": f\"Test AC System\",\n            \"organization_fides_key\": \"default_organization\",\n            \"system_type\": \"Service\",\n        },\n    )\n\n    PrivacyDeclaration.create(\n        db=db,\n        data={\n            \"system_id\": system.id,\n            \"data_use\": \"functional.storage\",\n            \"legal_basis_for_processing\": \"Consent\",\n            \"features\": [\n                \"Match and combine data from other data sources\",  # Feature 1\n                \"Link different devices\",  # Feature 2\n            ],\n        },\n    )\n    return system\n\n\n# Detailed systems with attributes for TC string testing\n# Please don't update them!\n\n\n@pytest.fixture(scope=\"function\")\ndef captify_technologies_system(db: Session) -> System:\n    \"\"\"Add system that only has purposes with Consent legal basis\"\"\"\n    system = System.create(\n        db=db,\n        data={\n            \"fides_key\": f\"captify_{uuid.uuid4()}\",\n            \"vendor_id\": \"gvl.2\",\n            \"name\": f\"Captify\",\n            \"description\": \"Captify is a search intelligence platform that helps brands and advertisers leverage search insights to improve their ad targeting and relevance.\",\n            \"organization_fides_key\": \"default_organization\",\n            \"system_type\": \"Service\",\n            \"uses_profiling\": False,\n            \"legal_basis_for_transfers\": [\"SCCs\"],\n        },\n    )\n\n    for data_use in [\n        \"functional.storage\",  # Purpose 1\n        \"marketing.advertising.negative_targeting\",  # Purpose 2\n        \"marketing.advertising.frequency_capping\",  # Purpose 2\n        \"marketing.advertising.first_party.contextual\",  # Purpose 2\n        \"marketing.advertising.profiling\",  # Purpose 3\n        \"marketing.advertising.first_party.targeted\",  # Purpose 4\n        \"marketing.advertising.third_party.targeted\",  # Purpose 4\n        \"analytics.reporting.ad_performance\",  # Purpose 7\n        \"analytics.reporting.campaign_insights\",  # Purpose 9\n        \"functional.service.improve\",  # Purpose 10\n        \"essential.fraud_detection\",  # Special Purpose 1\n        \"essential.service.security\"  # Special Purpose 1\n        \"marketing.advertising.serving\",  # Special Purpose 2\n    ]:\n        # Includes Feature 2, Special Feature 2\n        PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"system_id\": system.id,\n                \"data_use\": data_use,\n                \"legal_basis_for_processing\": \"Consent\",\n                \"features\": [\n                    \"Link different devices\",\n                    \"Actively scan device characteristics for identification\",\n                ],\n            },\n        )\n\n    db.refresh(system)\n    return system\n\n\n@pytest.fixture(scope=\"function\")\ndef emerse_system(db: Session) -> System:\n    \"\"\"This system has purposes that are both consent and legitimate interest legal basis\"\"\"\n    system = System.create(\n        db=db,\n        data={\n            \"fides_key\": f\"emerse{uuid.uuid4()}\",\n            \"vendor_id\": \"gvl.8\",\n            \"name\": f\"Emerse\",\n            \"description\": \"Emerse Sverige AB is a provider of programmatic advertising solutions, offering advertisers and publishers tools to manage and optimize their digital ad campaigns.\",\n            \"organization_fides_key\": \"default_organization\",\n            \"system_type\": \"Service\",\n        },\n    )\n\n    # Add Consent-related Purposes\n    for data_use in [\n        \"functional.storage\",  # Purpose 1\n        \"marketing.advertising.profiling\",  # Purpose 3\n        \"marketing.advertising.third_party.targeted\",  # Purpose 4\n        \"marketing.advertising.first_party.targeted\",  # Purpose 4\n    ]:\n        # Includes Feature 2, Special Feature 2\n        PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"system_id\": system.id,\n                \"data_use\": data_use,\n                \"legal_basis_for_processing\": \"Consent\",\n                \"features\": [\n                    \"Match and combine data from other data sources\",  # Feature 1\n                    \"Link different devices\",  # Feature 2\n                ],\n            },\n        )\n\n    # Add Legitimate Interest-related Purposes\n    for data_use in [\n        \"marketing.advertising.negative_targeting\",  # Purpose 2\n        \"marketing.advertising.first_party.contextual\",  # Purpose 2\n        \"marketing.advertising.frequency_capping\",  # Purpose 2\n        \"analytics.reporting.ad_performance\",  # Purpose 7\n        \"analytics.reporting.content_performance\",  # Purpose 8\n        \"analytics.reporting.campaign_insights\",  # Purpose 9\n        \"essential.fraud_detection\",  # Special Purpose 1\n        \"essential.service.security\",  # Special Purpose 1\n        \"marketing.advertising.serving\",  # Special Purpose 2\n    ]:\n        # Includes Feature 2, Special Feature 2\n        PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"system_id\": system.id,\n                \"data_use\": data_use,\n                \"legal_basis_for_processing\": \"Legitimate interests\",\n                \"features\": [\n                    \"Match and combine data from other data sources\",  # Feature 1\n                    \"Link different devices\",  # Feature 2\n                ],\n            },\n        )\n\n    db.refresh(system)\n    return system\n\n\n@pytest.fixture(scope=\"function\")\ndef skimbit_system(db):\n    \"\"\"Add system that only has purposes with LI legal basis\"\"\"\n    system = System.create(\n        db=db,\n        data={\n            \"fides_key\": f\"skimbit{uuid.uuid4()}\",\n            \"vendor_id\": \"gvl.46\",\n            \"name\": f\"Skimbit (Skimlinks, Taboola)\",\n            \"description\": \"Skimbit, a Taboola company, specializes in data-driven advertising and provides tools for brands and advertisers to analyze customer behavior and deliver targeted and personalized ads.\",\n            \"organization_fides_key\": \"default_organization\",\n            \"system_type\": \"Service\",\n        },\n    )\n\n    # Add Legitimate Interest-related Purposes\n    for data_use in [\n        \"analytics.reporting.ad_performance\",  # Purpose 7\n        \"analytics.reporting.content_performance\",  # Purpose 8\n        \"functional.service.improve\",  # Purpose 10\n        \"essential.service.security\"  # Special Purpose 1\n        \"essential.fraud_detection\",  # Special Purpose 1\n        \"marketing.advertising.serving\",  # Special Purpose 2\n    ]:\n        # Includes Feature 3\n        PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"system_id\": system.id,\n                \"data_use\": data_use,\n                \"legal_basis_for_processing\": \"Legitimate interests\",\n                \"features\": [\n                    \"Identify devices based on information transmitted automatically\"\n                ],\n            },\n        )\n    return system\n", "from __future__ import annotations\n\nimport pytest\nfrom starlette.status import HTTP_200_OK, HTTP_201_CREATED, HTTP_403_FORBIDDEN\nfrom starlette.testclient import TestClient\n\nfrom fides.api.api.v1.endpoints.privacy_experience_config_endpoints import (\n    get_experience_config_or_error,\n)\nfrom fides.api.models.privacy_experience import (\n    BannerEnabled,\n    ComponentType,\n    PrivacyExperience,\n    PrivacyExperienceConfig,\n    PrivacyExperienceConfigHistory,\n)\nfrom fides.api.models.privacy_notice import PrivacyNoticeRegion\nfrom fides.common.api import scope_registry as scopes\nfrom fides.common.api.v1.urn_registry import EXPERIENCE_CONFIG, V1_URL_PREFIX\n\n\nclass TestGetExperienceConfigList:\n    @pytest.fixture(scope=\"function\")\n    def url(self) -> str:\n        return V1_URL_PREFIX + EXPERIENCE_CONFIG\n\n    def test_get_experience_config_unauthenticated(self, url, api_client):\n        resp = api_client.get(url)\n        assert resp.status_code == 401\n\n    def test_get_experience_config_wrong_scope(\n        self, url, api_client: TestClient, generate_auth_header\n    ):\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_NOTICE_READ])\n        resp = api_client.get(\n            url,\n            headers=auth_header,\n        )\n        assert resp.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"role,expected_status\",\n        [\n            (\"owner\", HTTP_200_OK),\n            (\"contributor\", HTTP_200_OK),\n            (\"viewer_and_approver\", HTTP_200_OK),\n            (\"viewer\", HTTP_200_OK),\n            (\"approver\", HTTP_403_FORBIDDEN),\n        ],\n    )\n    def test_get_experience_config_with_roles(\n        self,\n        role,\n        expected_status,\n        api_client: TestClient,\n        url,\n        generate_role_header,\n    ) -> None:\n        auth_header = generate_role_header(roles=[role])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == expected_status\n\n    @pytest.mark.usefixtures(\n        \"privacy_experience_privacy_center\", \"privacy_experience_overlay\"\n    )\n    def test_get_experience_config_list(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_privacy_center,\n        experience_config_overlay,\n    ) -> None:\n        unescape_header = {\"Unescape-Safestr\": \"true\"}\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(url, headers={**auth_header, **unescape_header})\n        assert response.status_code == 200\n        resp = response.json()\n        assert (\n            resp[\"total\"] == 5\n        )  # Three default configs loaded on startup plus two here\n        assert resp[\"page\"] == 1\n        assert resp[\"size\"] == 50\n        data = resp[\"items\"]\n        assert len(data) == 5\n\n        first_config = data[0]\n        assert first_config[\"id\"] == experience_config_overlay.id\n        assert first_config[\"component\"] == \"overlay\"\n        assert first_config[\"banner_enabled\"] == \"enabled_where_required\"\n        assert first_config[\"disabled\"] is False\n        assert first_config[\"regions\"] == [\"us_ca\"]\n        assert first_config[\"version\"] == 1.0\n        assert first_config[\"created_at\"] is not None\n        assert first_config[\"updated_at\"] is not None\n        assert (\n            first_config[\"experience_config_history_id\"]\n            == experience_config_overlay.experience_config_history_id\n        )\n\n        second_config = data[1]\n        assert second_config[\"id\"] == experience_config_privacy_center.id\n        assert (\n            second_config[\"description\"] == \"user's description <script />\"\n        )  # Unescaped due to header\n        assert second_config[\"component\"] == \"privacy_center\"\n        assert second_config[\"banner_enabled\"] is None\n        assert second_config[\"disabled\"] is True\n        assert second_config[\"regions\"] == [\"us_co\"]\n        assert second_config[\"created_at\"] is not None\n        assert second_config[\"updated_at\"] is not None\n        assert second_config[\"version\"] == 1.0\n        assert (\n            second_config[\"experience_config_history_id\"]\n            == experience_config_privacy_center.experience_config_history_id\n        )\n\n        third_config = data[2]\n        assert third_config[\"id\"] == \"a4974670-abad-471f-9084-2cb-tcf-over\"\n        assert third_config[\"is_default\"] is True\n        assert third_config[\"component\"] == \"tcf_overlay\"\n        assert third_config[\"regions\"] == []\n        assert third_config[\"version\"] == 1.0\n        assert third_config[\"created_at\"] is not None\n        assert third_config[\"updated_at\"] is not None\n\n        fourth_config = data[3]\n        assert fourth_config[\"id\"] == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n        assert fourth_config[\"is_default\"] is True\n        assert fourth_config[\"component\"] == \"privacy_center\"\n        assert fourth_config[\"regions\"] == []\n        assert fourth_config[\"version\"] == 1.0\n        assert fourth_config[\"created_at\"] is not None\n        assert fourth_config[\"updated_at\"] is not None\n\n        fifth_config = data[4]\n        assert fifth_config[\"id\"] == \"pri-7ae3-f06b-4096-970f-0bbbdef-over\"\n        assert fifth_config[\"is_default\"] is True\n        assert fifth_config[\"disabled\"] is False\n        assert fifth_config[\"regions\"] == []\n        assert fifth_config[\"component\"] == \"overlay\"\n\n    @pytest.mark.usefixtures(\n        \"privacy_experience_privacy_center\",\n        \"privacy_experience_overlay\",\n        \"experience_config_overlay\",\n    )\n    def test_get_experience_config_list_no_unescape_header(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_privacy_center,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        resp = response.json()[\"items\"]\n\n        second_config = resp[1]\n        assert second_config[\"id\"] == experience_config_privacy_center.id\n        assert (\n            second_config[\"description\"] == \"user&#x27;s description &lt;script /&gt;\"\n        )  # Still escaped\n\n    @pytest.mark.usefixtures(\n        \"privacy_experience_overlay\",\n        \"privacy_experience_privacy_center\",\n        \"experience_config_privacy_center\",\n    )\n    def test_get_experience_config_show_disabled_false_filter(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_overlay,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(\n            url + \"?show_disabled=False\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()\n        assert resp[\"total\"] == 4\n        assert resp[\"page\"] == 1\n        assert resp[\"size\"] == 50\n        data = resp[\"items\"]\n        assert len(data) == 4\n\n        config = data[0]\n        assert config[\"id\"] == experience_config_overlay.id\n        assert config[\"component\"] == \"overlay\"\n        assert config[\"disabled\"] is False\n        assert config[\"regions\"] == [\"us_ca\"]\n        assert config[\"version\"] == 1.0\n        assert config[\"created_at\"] is not None\n        assert config[\"updated_at\"] is not None\n        assert (\n            config[\"experience_config_history_id\"]\n            == experience_config_overlay.experience_config_history_id\n        )\n\n        second_config = data[1]\n        assert second_config[\"id\"] == \"a4974670-abad-471f-9084-2cb-tcf-over\"\n        assert second_config[\"is_default\"] is True\n        assert second_config[\"component\"] == \"tcf_overlay\"\n        assert second_config[\"disabled\"] is False\n        assert second_config[\"version\"] == 1.0\n        assert second_config[\"created_at\"] is not None\n        assert second_config[\"updated_at\"] is not None\n\n        third_config = data[2]\n        assert third_config[\"id\"] == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n        assert third_config[\"is_default\"] is True\n        assert third_config[\"component\"] == \"privacy_center\"\n        assert third_config[\"disabled\"] is False\n        assert third_config[\"version\"] == 1.0\n        assert third_config[\"created_at\"] is not None\n        assert third_config[\"updated_at\"] is not None\n\n        fourth_config = data[3]\n        assert fourth_config[\"id\"] == \"pri-7ae3-f06b-4096-970f-0bbbdef-over\"\n        assert fourth_config[\"is_default\"] is True\n        assert fourth_config[\"disabled\"] is False\n        assert fourth_config[\"regions\"] == []\n        assert fourth_config[\"component\"] == \"overlay\"\n\n    @pytest.mark.usefixtures(\n        \"privacy_experience_overlay\",\n        \"experience_config_privacy_center\",\n    )\n    def test_get_experience_config_region_filter(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_overlay,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(\n            url + \"?region=us_ca\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()\n        assert resp[\"total\"] == 1\n        assert resp[\"page\"] == 1\n        assert resp[\"size\"] == 50\n        data = resp[\"items\"]\n        assert len(data) == 1\n\n        first_config = data[0]\n        assert first_config[\"id\"] == experience_config_overlay.id\n        assert first_config[\"regions\"] == [\"us_ca\"]\n        assert first_config[\"version\"] == 1.0\n        assert first_config[\"created_at\"] is not None\n        assert first_config[\"updated_at\"] is not None\n        assert (\n            first_config[\"experience_config_history_id\"]\n            == experience_config_overlay.experience_config_history_id\n        )\n\n    def test_get_experience_config_component_filter(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_overlay,\n        experience_config_privacy_center,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(\n            url + \"?component=overlay\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()\n        assert resp[\"total\"] == 2\n        assert resp[\"page\"] == 1\n        assert resp[\"size\"] == 50\n        data = resp[\"items\"]\n        assert len(data) == 2\n\n        assert data[0][\"id\"] == experience_config_overlay.id\n        assert data[1][\"id\"] == \"pri-7ae3-f06b-4096-970f-0bbbdef-over\"\n\n        response = api_client.get(\n            url + \"?component=privacy_center\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()\n        assert resp[\"total\"] == 2\n        assert resp[\"page\"] == 1\n        assert resp[\"size\"] == 50\n        data = resp[\"items\"]\n        assert len(data) == 2\n\n        assert data[0][\"id\"] == experience_config_privacy_center.id\n        assert data[1][\"id\"] == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n\n\nclass TestCreateExperienceConfig:\n    @pytest.fixture(scope=\"function\")\n    def url(self) -> str:\n        return V1_URL_PREFIX + EXPERIENCE_CONFIG\n\n    @pytest.fixture(scope=\"function\")\n    def overlay_experience_request_body(self) -> dict:\n        return {\n            \"acknowledge_button_label\": \"Confirm\",\n            \"banner_enabled\": \"enabled_where_required\",\n            \"component\": \"overlay\",\n            \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n            \"accept_button_label\": \"Accept all\",\n            \"disabled\": False,\n            \"privacy_preferences_link_label\": \"Manage preferences\",\n            \"privacy_policy_link_label\": \"View our privacy policy\",\n            \"privacy_policy_url\": \"http://example.com/privacy\",\n            \"reject_button_label\": \"Reject all\",\n            \"regions\": [],\n            \"save_button_label\": \"Save\",\n            \"title\": \"Control your privacy\",\n        }\n\n    def test_create_experience_config_unauthenticated(self, url, api_client):\n        resp = api_client.post(url)\n        assert resp.status_code == 401\n\n    def test_create_experience_config_wrong_scope(\n        self, url, api_client: TestClient, generate_auth_header\n    ):\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        resp = api_client.post(\n            url,\n            headers=auth_header,\n        )\n        assert resp.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"role,expected_status\",\n        [\n            (\"owner\", HTTP_201_CREATED),\n            (\"contributor\", HTTP_201_CREATED),\n            (\"viewer_and_approver\", HTTP_403_FORBIDDEN),\n            (\"viewer\", HTTP_403_FORBIDDEN),\n            (\"approver\", HTTP_403_FORBIDDEN),\n        ],\n    )\n    def test_create_experience_config_with_roles(\n        self,\n        role,\n        expected_status,\n        api_client: TestClient,\n        url,\n        generate_role_header,\n        overlay_experience_request_body,\n    ) -> None:\n        auth_header = generate_role_header(roles=[role])\n        response = api_client.post(\n            url, json=overlay_experience_request_body, headers=auth_header\n        )\n        assert response.status_code == expected_status\n\n    def test_create_overlay_config_missing_details(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Accept\",\n                \"description\": \"We care about your privacy\",\n                \"component\": \"overlay\",\n                \"regions\": [\"it\"],\n                \"reject_button_label\": \"Reject\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Manage your privacy\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"The following additional fields are required when defining an overlay: acknowledge_button_label, banner_enabled, and privacy_preferences_link_label.\"\n        )\n\n    def test_create_privacy_center_config_missing_details(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Accept\",\n                \"description\": \"We care about your privacy\",\n                \"component\": \"privacy_center\",\n                \"regions\": [\"it\"],\n                \"save_button_label\": \"Save\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert response.json()[\"detail\"][0][\"msg\"] == \"field required\"\n\n    def test_create_experience_duplicate_regions(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Accept all\",\n                \"description\": \"We care about your privacy\",\n                \"component\": \"privacy_center\",\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n                \"regions\": [\"it\", \"it\"],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert response.json()[\"detail\"][0][\"msg\"] == \"Duplicate regions found.\"\n\n    def test_create_another_default_experience_config(\n        self, api_client: TestClient, url, generate_auth_header, db\n    ) -> None:\n        \"\"\"We have defaults loaded in at startup so don't allow other defaults to be created here\"\"\"\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Yes\",\n                \"banner_enabled\": \"always_disabled\",\n                \"component\": \"privacy_center\",\n                \"description\": \"We take your privacy seriously\",\n                \"is_default\": True,\n                \"privacy_policy_link_label\": \"Manage your privacy\",\n                \"privacy_policy_url\": \"http://example.com/privacy\",\n                \"reject_button_label\": \"No\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Manage your privacy\",\n            },\n            headers=auth_header,\n        )\n\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"]\n            == \"Cannot set as the default. Only one default privacy_center config can be in the system.\"\n        )\n\n    @pytest.mark.parametrize(\n        \"invalid_url\",\n        [\n            \"thisisnotaurl\",\n            \"javascript:alert('XSS: domain scope: '+document.domain)\",\n        ],\n    )\n    def test_create_experience_config_with_invalid_policy_url(\n        self, api_client: TestClient, url, generate_auth_header, db, invalid_url\n    ) -> None:\n        \"\"\"\n        Verify that an invalid Privacy Policy URL returns a 422.\n        \"\"\"\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Yes\",\n                \"banner_enabled\": \"always_disabled\",\n                \"component\": \"privacy_center\",\n                \"description\": \"We take your company's privacy seriously\",\n                \"privacy_policy_link_label\": \"Manage your privacy\",\n                \"privacy_policy_url\": invalid_url,\n                \"reject_button_label\": \"No\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Manage your privacy\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n\n    def test_create_experience_config_with_no_regions(\n        self, api_client: TestClient, url, generate_auth_header, db\n    ) -> None:\n        \"\"\"Experience config can be defined without any regions specified. This is handy for defining default experiences\n\n        No privacy experiences are affected here.  But ExperienceConfig and ExperienceConfigHistory records are created.\n        \"\"\"\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Yes\",\n                \"banner_enabled\": \"always_disabled\",\n                \"component\": \"privacy_center\",\n                \"description\": \"We take your company's privacy seriously\",\n                \"privacy_policy_link_label\": \"Manage your privacy\",\n                \"privacy_policy_url\": \"http://example.com/privacy\",\n                \"reject_button_label\": \"No\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Manage your privacy\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 201\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"accept_button_label\"] == \"Yes\"\n        assert resp[\"banner_enabled\"] == \"always_disabled\"\n        assert resp[\"component\"] == \"privacy_center\"\n        assert (\n            resp[\"description\"] == \"We take your company's privacy seriously\"\n        )  # Returned in the response, unescaped, for display\n        assert resp[\"privacy_policy_link_label\"] == \"Manage your privacy\"\n        assert resp[\"privacy_policy_url\"] == \"http://example.com/privacy\"\n        assert resp[\"regions\"] == []\n        assert resp[\"reject_button_label\"] == \"No\"\n        assert resp[\"save_button_label\"] == \"Save\"\n        assert resp[\"title\"] == \"Manage your privacy\"\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"version\"] == 1.0\n\n        experience_config = get_experience_config_or_error(db, resp[\"id\"])\n        assert experience_config.component == ComponentType.privacy_center\n        assert experience_config.privacy_policy_link_label == \"Manage your privacy\"\n        assert experience_config.experiences.all() == []\n        assert experience_config.histories.count() == 1\n        assert (\n            experience_config.description\n            == \"We take your company&#x27;s privacy seriously\"\n        )  # Saved in the db escaped\n        history = experience_config.histories[0]\n        assert history.version == 1.0\n        assert history.component == ComponentType.privacy_center\n        assert history.privacy_policy_link_label == \"Manage your privacy\"\n        assert history.experience_config_id == experience_config.id\n\n        assert response.json()[\"linked_regions\"] == []\n        assert response.json()[\"unlinked_regions\"] == []\n\n        history.delete(db)\n        experience_config.delete(db)\n\n    def test_create_experience_config_with_empty_regions(\n        self, api_client: TestClient, url, generate_auth_header, db\n    ) -> None:\n        \"\"\"Experience config can be defined without any regions specified. This is handy for defining default experiences\n\n        No privacy experiences are affected here.  But ExperienceConfig and ExperienceConfigHistory records are created.\n        \"\"\"\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Yes\",\n                \"banner_enabled\": \"always_disabled\",\n                \"component\": \"privacy_center\",\n                \"description\": \"We take your privacy seriously\",\n                \"privacy_policy_link_label\": \"Manage your privacy\",\n                \"privacy_policy_url\": \"http://example.com/privacy\",\n                \"regions\": [],\n                \"reject_button_label\": \"No\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Manage your privacy\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 201\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"accept_button_label\"] == \"Yes\"\n        assert resp[\"banner_enabled\"] == \"always_disabled\"\n        assert resp[\"component\"] == \"privacy_center\"\n        assert resp[\"description\"] == \"We take your privacy seriously\"\n        assert resp[\"privacy_policy_link_label\"] == \"Manage your privacy\"\n        assert resp[\"privacy_policy_url\"] == \"http://example.com/privacy\"\n        assert resp[\"regions\"] == []\n        assert resp[\"reject_button_label\"] == \"No\"\n        assert resp[\"save_button_label\"] == \"Save\"\n        assert resp[\"title\"] == \"Manage your privacy\"\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"version\"] == 1.0\n\n        experience_config = get_experience_config_or_error(db, resp[\"id\"])\n        assert experience_config.component == ComponentType.privacy_center\n        assert experience_config.privacy_policy_link_label == \"Manage your privacy\"\n        assert experience_config.experiences.all() == []\n        assert experience_config.histories.count() == 1\n        history = experience_config.histories[0]\n        assert history.version == 1.0\n        assert history.component == ComponentType.privacy_center\n        assert history.privacy_policy_link_label == \"Manage your privacy\"\n        assert history.experience_config_id == experience_config.id\n\n        assert response.json()[\"linked_regions\"] == []\n        assert response.json()[\"unlinked_regions\"] == []\n\n        history.delete(db)\n        experience_config.delete(db)\n\n    def test_create_experience_config_no_existing_experiences(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n    ) -> None:\n        \"\"\"\n        Specifying a NY region to be used with the new ExperienceConfig will\n        cause a NY PrivacyExperience to be created behind the scenes if one doesn't exist.\n        \"\"\"\n\n        assert (\n            PrivacyExperience.get_experience_by_region_and_component(\n                db, PrivacyNoticeRegion.us_ny, ComponentType.overlay\n            )\n            is None\n        )\n\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Accept all\",\n                \"acknowledge_button_label\": \"Confirm\",\n                \"banner_enabled\": \"enabled_where_required\",\n                \"component\": \"overlay\",\n                \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n                \"privacy_preferences_link_label\": \"Control your privacy\",\n                \"privacy_policy_link_label\": \"Control your privacy\",\n                \"privacy_policy_url\": \"http://example.com/privacy\",\n                \"regions\": [\"us_ny\"],\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 201\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"accept_button_label\"] == \"Accept all\"\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"created_at\"] is not None\n        assert (\n            resp[\"description\"]\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert resp[\"privacy_preferences_link_label\"] == \"Control your privacy\"\n        assert resp[\"privacy_policy_link_label\"] == \"Control your privacy\"\n        assert resp[\"privacy_policy_url\"] == \"http://example.com/privacy\"\n        assert resp[\"regions\"] == [\"us_ny\"]\n        assert resp[\"reject_button_label\"] == \"Reject all\"\n        assert resp[\"save_button_label\"] == \"Save\"\n        assert resp[\"title\"] == \"Control your privacy\"\n        assert resp[\"version\"] == 1.0\n        assert resp[\"updated_at\"] is not None\n\n        # Created Experience Config\n        experience_config = get_experience_config_or_error(db, resp[\"id\"])\n        assert experience_config.accept_button_label == \"Accept all\"\n        assert experience_config.acknowledge_button_label == \"Confirm\"\n        assert experience_config.banner_enabled == BannerEnabled.enabled_where_required\n        assert experience_config.component == ComponentType.overlay\n        assert (\n            experience_config.description\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert (\n            experience_config.privacy_preferences_link_label == \"Control your privacy\"\n        )\n        assert experience_config.privacy_policy_link_label == \"Control your privacy\"\n        assert experience_config.privacy_policy_url == \"http://example.com/privacy\"\n        assert experience_config.regions == [PrivacyNoticeRegion.us_ny]\n        assert experience_config.reject_button_label == \"Reject all\"\n        assert experience_config.save_button_label == \"Save\"\n        assert experience_config.title == \"Control your privacy\"\n\n        assert experience_config.created_at is not None\n        assert experience_config.updated_at is not None\n        assert experience_config.histories.count() == 1\n\n        # Created Experience Config History\n        experience_config_history = experience_config.histories[0]\n        assert experience_config_history.version == 1.0\n\n        assert experience_config_history.accept_button_label == \"Accept all\"\n        assert experience_config_history.acknowledge_button_label == \"Confirm\"\n        assert (\n            experience_config_history.banner_enabled\n            == BannerEnabled.enabled_where_required\n        )\n        assert experience_config_history.component == ComponentType.overlay\n        assert (\n            experience_config_history.description\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert (\n            experience_config_history.privacy_preferences_link_label\n            == \"Control your privacy\"\n        )\n        assert (\n            experience_config_history.privacy_policy_link_label\n            == \"Control your privacy\"\n        )\n        assert (\n            experience_config_history.privacy_policy_url == \"http://example.com/privacy\"\n        )\n        assert experience_config_history.reject_button_label == \"Reject all\"\n        assert experience_config_history.save_button_label == \"Save\"\n        assert experience_config_history.title == \"Control your privacy\"\n\n        assert experience_config_history.created_at is not None\n        assert experience_config_history.updated_at is not None\n        assert experience_config_history.experience_config_id == experience_config.id\n\n        # Created Privacy Experience\n        assert experience_config.experiences.count() == 1\n        experience = experience_config.experiences[0]\n        assert experience.region == PrivacyNoticeRegion.us_ny\n        assert experience.component == ComponentType.overlay\n        assert experience.experience_config_id == experience_config.id\n\n        experience.delete(db)\n        experience_config_history.delete(db)\n        experience_config.delete(db)\n\n        assert response.json()[\"linked_regions\"] == [\"us_ny\"]\n        assert response.json()[\"unlinked_regions\"] == []\n\n    def test_create_experience_config_existing_experiences(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n    ) -> None:\n        \"\"\"\n        Specifying a TX region to be used with the new ExperienceConfig can\n        cause an existing TX PrivacyExperience to be linked to the current ExperienceConfig\n        \"\"\"\n\n        privacy_experience = PrivacyExperience.create(\n            db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": PrivacyNoticeRegion.us_tx,\n            },\n        )\n\n        assert privacy_experience.experience_config_id is None\n\n        auth_header = generate_auth_header(\n            scopes=[scopes.PRIVACY_EXPERIENCE_CREATE, scopes.PRIVACY_EXPERIENCE_UPDATE]\n        )\n        response = api_client.post(\n            url,\n            json={\n                \"accept_button_label\": \"Accept all\",\n                \"acknowledge_button_label\": \"Confirm\",\n                \"banner_enabled\": \"enabled_where_required\",\n                \"component\": \"overlay\",\n                \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n                \"privacy_preferences_link_label\": \"Control your privacy\",\n                \"privacy_policy_link_label\": \"Control your privacy\",\n                \"privacy_policy_url\": \"http://example.com/privacy\",\n                \"regions\": [\"us_tx\"],\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 201\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"accept_button_label\"] == \"Accept all\"\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"created_at\"] is not None\n        assert (\n            resp[\"description\"]\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert resp[\"privacy_preferences_link_label\"] == \"Control your privacy\"\n        assert resp[\"privacy_policy_link_label\"] == \"Control your privacy\"\n        assert resp[\"privacy_policy_url\"] == \"http://example.com/privacy\"\n        assert resp[\"regions\"] == [\"us_tx\"]\n        assert resp[\"reject_button_label\"] == \"Reject all\"\n        assert resp[\"save_button_label\"] == \"Save\"\n        assert resp[\"title\"] == \"Control your privacy\"\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"version\"] == 1.0\n\n        # Created Experience Config\n        experience_config = get_experience_config_or_error(db, resp[\"id\"])\n        assert experience_config.histories.count() == 1\n\n        # Created Experience Config History\n        experience_config_history = experience_config.histories[0]\n        assert experience_config_history.version == 1.0\n        assert experience_config_history.component == ComponentType.overlay\n        assert (\n            experience_config_history.banner_enabled\n            == BannerEnabled.enabled_where_required\n        )\n        assert experience_config_history.experience_config_id == experience_config.id\n\n        # Updated Privacy Experience - TX Privacy Experience automatically linked\n        assert experience_config.experiences.count() == 1\n        experience = experience_config.experiences[0]\n        db.refresh(experience)\n        assert (\n            experience == privacy_experience\n        )  # Linked experience is the same Texas experience from above\n        assert experience.region == PrivacyNoticeRegion.us_tx\n        assert experience.component == ComponentType.overlay\n        assert experience.experience_config_id == experience_config.id\n\n        assert response.json()[\"linked_regions\"] == [\"us_tx\"]\n        assert response.json()[\"unlinked_regions\"] == []\n\n        experience.delete(db)\n        experience_config_history.delete(db)\n        experience_config.delete(db)\n\n\nclass TestGetExperienceConfigDetail:\n    @pytest.fixture(scope=\"function\")\n    def url(self, experience_config_overlay) -> str:\n        return V1_URL_PREFIX + EXPERIENCE_CONFIG + f\"/{experience_config_overlay.id}\"\n\n    def test_get_experience_config_detail_unauthenticated(self, url, api_client):\n        resp = api_client.get(url)\n        assert resp.status_code == 401\n\n    def test_get_experience_config_detail_wrong_scope(\n        self, url, api_client: TestClient, generate_auth_header\n    ):\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_NOTICE_READ])\n        resp = api_client.get(\n            url,\n            headers=auth_header,\n        )\n        assert resp.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"role,expected_status\",\n        [\n            (\"owner\", HTTP_200_OK),\n            (\"contributor\", HTTP_200_OK),\n            (\"viewer_and_approver\", HTTP_200_OK),\n            (\"viewer\", HTTP_200_OK),\n            (\"approver\", HTTP_403_FORBIDDEN),\n        ],\n    )\n    def test_get_experience_config_detail_with_roles(\n        self,\n        role,\n        expected_status,\n        api_client: TestClient,\n        url,\n        generate_role_header,\n    ) -> None:\n        auth_header = generate_role_header(roles=[role])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == expected_status\n\n    def test_get_bad_experience_config_detail(\n        self,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        url = V1_URL_PREFIX + EXPERIENCE_CONFIG + \"/bad_id\"\n\n        response = api_client.get(\n            url,\n            headers=auth_header,\n        )\n        assert response.status_code == 404\n        assert (\n            response.json()[\"detail\"]\n            == \"No Privacy Experience Config found for id 'bad_id'.\"\n        )\n\n    @pytest.mark.usefixtures(\n        \"privacy_experience_overlay\",\n    )\n    def test_get_experience_config_detail(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_overlay,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(\n            url,\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()\n\n        assert resp[\"id\"] == experience_config_overlay.id\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"disabled\"] is False\n        assert resp[\"regions\"] == [\"us_ca\"]\n        assert resp[\"version\"] == 1.0\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert (\n            resp[\"experience_config_history_id\"]\n            == experience_config_overlay.experience_config_history_id\n        )\n        assert resp[\"title\"] == \"Manage your consent\"\n        assert (\n            resp[\"privacy_policy_link_label\"]\n            == \"View our company&#x27;s privacy policy\"\n        )  # Escaped without request header\n\n    @pytest.mark.usefixtures(\n        \"privacy_experience_overlay\",\n    )\n    def test_get_experience_config_detail_with_unescape_header(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        experience_config_overlay,\n    ) -> None:\n        unescape_header = {\"Unescape-Safestr\": \"true\"}\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        response = api_client.get(url, headers={**auth_header, **unescape_header})\n        assert response.status_code == 200\n        resp = response.json()\n\n        assert resp[\"id\"] == experience_config_overlay.id\n        assert resp[\"component\"] == \"overlay\"\n        assert (\n            resp[\"privacy_policy_link_label\"] == \"View our company's privacy policy\"\n        )  # Unescaped with request header\n\n\nclass TestUpdateExperienceConfig:\n    @pytest.fixture(scope=\"function\")\n    def url(self, overlay_experience_config) -> str:\n        return V1_URL_PREFIX + EXPERIENCE_CONFIG + f\"/{overlay_experience_config.id}\"\n\n    @pytest.fixture(scope=\"function\")\n    def overlay_experience_config(self, db) -> PrivacyExperienceConfig:\n        exp = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"accept_button_label\": \"Accept all\",\n                \"acknowledge_button_label\": \"Confirm\",\n                \"banner_enabled\": \"enabled_where_required\",\n                \"component\": \"overlay\",\n                \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n                \"disabled\": False,\n                \"privacy_preferences_link_label\": \"Manage preferences\",\n                \"privacy_policy_link_label\": \"View our privacy policy\",\n                \"privacy_policy_url\": \"http://example.com/privacy\",\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n        yield exp\n        for history in exp.histories:\n            history.delete(db)\n        exp.delete(db)\n\n    def test_update_experience_config_unauthenticated(self, url, api_client):\n        resp = api_client.patch(url, json={\"disabled\": True})\n        assert resp.status_code == 401\n\n    def test_update_experience_config_wrong_scope(\n        self, url, api_client: TestClient, generate_auth_header\n    ):\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_READ])\n        resp = api_client.patch(\n            url,\n            headers=auth_header,\n        )\n        assert resp.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"role,expected_status\",\n        [\n            (\"owner\", HTTP_200_OK),\n            (\"contributor\", HTTP_200_OK),\n            (\"viewer_and_approver\", HTTP_403_FORBIDDEN),\n            (\"viewer\", HTTP_403_FORBIDDEN),\n            (\"approver\", HTTP_403_FORBIDDEN),\n        ],\n    )\n    def test_update_experience_config_with_roles(\n        self,\n        role,\n        expected_status,\n        api_client: TestClient,\n        url,\n        generate_role_header,\n    ) -> None:\n        auth_header = generate_role_header(roles=[role])\n        response = api_client.patch(\n            url, json={\"disabled\": True, \"regions\": []}, headers=auth_header\n        )\n        assert response.status_code == expected_status\n\n    def test_update_experience_config_duplicate_regions(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        \"\"\"Failing if duplicate regions in request to avoid unexpected behavior\"\"\"\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\n                \"title\": \"We care about your privacy\",\n                \"regions\": [\"us_ca\", \"us_ca\"],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert response.json()[\"detail\"][0][\"msg\"] == \"Duplicate regions found.\"\n\n    def test_update_bad_experience_config(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        \"\"\"Nonexistent experience config id\"\"\"\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            V1_URL_PREFIX + EXPERIENCE_CONFIG + \"/bad_experience_id\",\n            json={\n                \"title\": \"We care about your privacy\",\n                \"regions\": [\"us_ca\"],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 404\n        assert (\n            response.json()[\"detail\"]\n            == \"No Privacy Experience Config found for id 'bad_experience_id'.\"\n        )\n\n    def test_update_overlay_experience_config_missing_details(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\"title\": None},\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert response.json()[\"detail\"][0][\"msg\"] == \"none is not an allowed value\"\n\n    def test_update_overlay_experience_config_missing_overlay_specific_fields(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n\n        response = api_client.patch(\n            url,\n            json={\n                \"privacy_preferences_link_label\": \"\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"The following additional fields are required when defining an overlay: acknowledge_button_label, banner_enabled, and privacy_preferences_link_label.\"\n        )\n\n    def test_update_as_default(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        overlay_experience_config,\n    ):\n        \"\"\"We already have a default overlay added to the system on startup, so we don't\n        want to update this separate overlay to be a default\"\"\"\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\n                \"is_default\": True,\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"]\n            == \"Cannot set as the default. Only one default overlay config can be in the system.\"\n        )\n\n    def test_update_experience_config_with_fields_that_should_be_escaped(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        overlay_experience_config,\n        db,\n    ) -> None:\n        \"\"\"Failing if duplicate regions in request to avoid unexpected behavior\"\"\"\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\n                \"title\": \"We care about you and your family's privacy\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert (\n            response.json()[\"experience_config\"][\"title\"]\n            == \"We care about you and your family's privacy\"\n        )  # Unescaped in response\n        db.refresh(overlay_experience_config)\n        assert (\n            overlay_experience_config.title\n            == \"We care about you and your family&#x27;s privacy\"\n        )  # But stored escaped\n\n    def test_attempt_to_update_component_type(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n    ) -> None:\n        \"\"\"Component type can't be edited once created\"\"\"\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n\n        response = api_client.patch(\n            url,\n            json={\n                \"component\": \"privacy_center\",\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 422\n        assert response.json()[\"detail\"][0][\"msg\"] == \"extra fields not permitted\"\n\n    def test_update_experience_config_while_ignoring_regions(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n        experience_config_overlay,\n        privacy_experience_overlay,\n    ) -> None:\n        \"\"\"We need to currently support editing experience configs without the regions.  If \"regions\" is None,\n        I don't edit regions at all. If \"regions\" are an empty list, they are all removed.\n        \"\"\"\n        assert experience_config_overlay.disabled is False\n        assert experience_config_overlay.regions == [PrivacyNoticeRegion.us_ca]\n\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            V1_URL_PREFIX + EXPERIENCE_CONFIG + f\"/{experience_config_overlay.id}\",\n            json={\n                \"disabled\": True,\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"disabled\"] is True\n        assert resp[\"regions\"] == [\"us_ca\"]  # Main thing, regions weren't touched!\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"disabled\"] is True\n        assert resp[\"version\"] == 2.0\n\n        experience_config = get_experience_config_or_error(db, resp[\"id\"])\n        assert experience_config.experiences.all() == [privacy_experience_overlay]\n        assert experience_config.histories.count() == 2\n        history = experience_config.histories.order_by(\n            PrivacyExperienceConfigHistory.created_at\n        )[0]\n        assert history.version == 1.0\n        assert history.component == ComponentType.overlay\n        assert history.banner_enabled == BannerEnabled.enabled_where_required\n        assert history.experience_config_id == experience_config.id\n        assert history.disabled is False\n\n        history = experience_config.histories.order_by(\n            PrivacyExperienceConfigHistory.created_at\n        )[1]\n        assert history.version == 2.0\n        assert history.disabled is True\n\n        assert response.json()[\"linked_regions\"] == []\n        assert response.json()[\"unlinked_regions\"] == []\n\n        privacy_experience_overlay.delete(db)\n\n        for history in experience_config.histories:\n            history.delete(db)\n        experience_config.delete(db)\n\n    def test_update_experience_config_with_no_regions(\n        self, api_client: TestClient, url, generate_auth_header, db\n    ) -> None:\n        \"\"\"Test scenario where experience config has no regions and we make updates without any regions being\n        involved.  Specifically disabling the ExperienceConfig\n        \"\"\"\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\n                \"disabled\": True,\n                \"regions\": [],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"title\"] == \"Control your privacy\"\n        assert (\n            resp[\"description\"]\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert resp[\"accept_button_label\"] == \"Accept all\"\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"reject_button_label\"] == \"Reject all\"\n        assert resp[\"regions\"] == []\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"disabled\"] is True\n        assert resp[\"version\"] == 2.0\n\n        experience_config = get_experience_config_or_error(db, resp[\"id\"])\n        assert experience_config.experiences.all() == []\n        assert experience_config.histories.count() == 2\n        history = experience_config.histories.order_by(\n            PrivacyExperienceConfigHistory.created_at\n        )[0]\n        assert history.version == 1.0\n        assert history.component == ComponentType.overlay\n        assert history.banner_enabled == BannerEnabled.enabled_where_required\n        assert history.experience_config_id == experience_config.id\n        assert history.disabled is False\n\n        history = experience_config.histories.order_by(\n            PrivacyExperienceConfigHistory.created_at\n        )[1]\n        assert history.version == 2.0\n        assert history.disabled is True\n\n        assert response.json()[\"linked_regions\"] == []\n        assert response.json()[\"unlinked_regions\"] == []\n\n        for history in experience_config.histories:\n            history.delete(db)\n        experience_config.delete(db)\n\n    def test_update_experience_config_no_existing_experiences(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n        overlay_experience_config,\n    ) -> None:\n        \"\"\"\n        This action is updating an existing ExperienceConfig to add NY.  NY does not have a PrivacyExperience\n        yet, so one will be created for it.\n        \"\"\"\n\n        assert (\n            PrivacyExperience.get_experience_by_region_and_component(\n                db, PrivacyNoticeRegion.us_ny, ComponentType.overlay\n            )\n            is None\n        )\n\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\"regions\": [\"us_ny\"]},\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"title\"] == \"Control your privacy\"\n        assert (\n            resp[\"description\"]\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert resp[\"accept_button_label\"] == \"Accept all\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"reject_button_label\"] == \"Reject all\"\n        assert resp[\"regions\"] == [\"us_ny\"]\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"version\"] == 1.0\n\n        # ExperienceConfig specifically wasn't updated, as this change is only changing which regions link here as FK\n        db.refresh(overlay_experience_config)\n        assert overlay_experience_config.id == resp[\"id\"]\n        assert overlay_experience_config.histories.count() == 1\n\n        # Existing Experience Config History\n        experience_config_history = overlay_experience_config.histories[0]\n        assert experience_config_history.version == 1.0\n        assert experience_config_history.component == ComponentType.overlay\n        assert (\n            experience_config_history.experience_config_id\n            == overlay_experience_config.id\n        )\n\n        # Created Privacy Experience\n        assert overlay_experience_config.experiences.count() == 1\n        experience = overlay_experience_config.experiences[0]\n        assert experience.region == PrivacyNoticeRegion.us_ny\n        assert experience.component == ComponentType.overlay\n        assert experience.experience_config_id == overlay_experience_config.id\n\n        experience.delete(db)\n\n        assert response.json()[\"linked_regions\"] == [\"us_ny\"]\n        assert response.json()[\"unlinked_regions\"] == []\n\n    def test_update_experience_config_regions_to_overlap_on_existing_experiences(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n        overlay_experience_config,\n    ) -> None:\n        \"\"\"\n        Existing ExperienceConfig is updated to add TX.  A Texas Privacy Experience already exists.\n\n        This should cause the existing Texas PrivacyExperience to be given a FK to the existing ExperienceConfig record\n        \"\"\"\n\n        privacy_experience = PrivacyExperience.create(\n            db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": PrivacyNoticeRegion.us_tx,\n            },\n        )\n\n        assert privacy_experience.experience_config_id is None\n\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\n                \"regions\": [\"us_tx\"],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"title\"] == \"Control your privacy\"\n        assert (\n            resp[\"description\"]\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert resp[\"accept_button_label\"] == \"Accept all\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"reject_button_label\"] == \"Reject all\"\n        assert resp[\"regions\"] == [\"us_tx\"]\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert (\n            resp[\"version\"] == 1.0\n        ), \"Version not bumped because config didn't change on ExperienceConfig\"\n\n        db.refresh(overlay_experience_config)\n        # Existing Experience Config History - no new version needed to be created\n        assert overlay_experience_config.histories.count() == 1\n        experience_config_history = overlay_experience_config.histories[0]\n        assert experience_config_history.version == 1.0\n        assert experience_config_history.component == ComponentType.overlay\n        assert (\n            experience_config_history.banner_enabled\n            == BannerEnabled.enabled_where_required\n        )\n        assert (\n            experience_config_history.experience_config_id\n            == overlay_experience_config.id\n        )\n\n        # Updated Privacy Experience - TX Privacy Experience automatically linked\n        assert overlay_experience_config.experiences.count() == 1\n        experience = overlay_experience_config.experiences[0]\n        db.refresh(experience)\n        assert (\n            experience == privacy_experience\n        )  # Linked experience is the same Texas experience from above\n        assert experience.region == PrivacyNoticeRegion.us_tx\n        assert experience.component == ComponentType.overlay\n        assert experience.experience_config_id == overlay_experience_config.id\n\n        assert response.json()[\"linked_regions\"] == [\"us_tx\"]\n        assert response.json()[\"unlinked_regions\"] == []\n\n        experience.delete(db)\n\n    def test_update_experience_config_experience_also_updated(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n        overlay_experience_config,\n    ) -> None:\n        \"\"\"\n        Verify that if the ExperienceConfig is updated, some of those updates are passed onto the PrivacyExperience record.\n\n        Existing ExperienceConfig is updated to add TX.  A Texas Privacy Experience already exists.\n        We are updating the existing ExperienceConfig simultaneously. So the TX PrivacyExperience will\n        be linked to the ExperienceConfig and also have select attributes from ExperienceConfig propagated back\n        \"\"\"\n\n        privacy_experience = PrivacyExperience.create(\n            db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": PrivacyNoticeRegion.us_tx,\n            },\n        )\n\n        assert privacy_experience.experience_config_id is None\n\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\"regions\": [\"us_tx\"], \"disabled\": True},\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()[\"experience_config\"]\n        assert resp[\"acknowledge_button_label\"] == \"Confirm\"\n        assert resp[\"component\"] == \"overlay\"\n        assert resp[\"title\"] == \"Control your privacy\"\n        assert (\n            resp[\"description\"]\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert resp[\"accept_button_label\"] == \"Accept all\"\n        assert resp[\"banner_enabled\"] == \"enabled_where_required\"\n        assert resp[\"reject_button_label\"] == \"Reject all\"\n        assert resp[\"regions\"] == [\"us_tx\"]\n        assert resp[\"created_at\"] is not None\n        assert resp[\"updated_at\"] is not None\n        assert resp[\"disabled\"] is True\n        assert (\n            resp[\"version\"] == 2.0\n        ), \"Version bumped because we've disabled ExperienceConfig\"\n\n        db.refresh(overlay_experience_config)\n        # ExperienceConfig was disabled - this is a change, so another historical record is created\n        assert overlay_experience_config.histories.count() == 2\n        experience_config_history = overlay_experience_config.histories.order_by(\n            PrivacyExperienceConfigHistory.created_at\n        )[1]\n        assert experience_config_history.version == 2.0\n        assert experience_config_history.disabled\n        assert experience_config_history.component == ComponentType.overlay\n        assert (\n            experience_config_history.banner_enabled\n            == BannerEnabled.enabled_where_required\n        )\n        assert (\n            experience_config_history.experience_config_id\n            == overlay_experience_config.id\n        )\n\n        # Updated Privacy Experience - TX Privacy Experience automatically linked\n        assert overlay_experience_config.experiences.count() == 1\n        experience = overlay_experience_config.experiences[0]\n        db.refresh(experience)\n        assert (\n            experience == privacy_experience\n        )  # Linked experience is the same Texas experience from above\n        assert experience.region == PrivacyNoticeRegion.us_tx\n        assert experience.component == ComponentType.overlay\n        assert experience.experience_config_id == overlay_experience_config.id\n\n        assert response.json()[\"linked_regions\"] == [\"us_tx\"]\n        assert response.json()[\"unlinked_regions\"] == []\n\n        experience.delete(db)\n\n    def test_update_experience_config_to_remove_region(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        db,\n        overlay_experience_config,\n    ) -> None:\n        \"\"\"\n        Update the ExperienceConfig to remove a region. Verify this unlinks the region.\n        \"\"\"\n\n        privacy_experience = PrivacyExperience.create(\n            db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": PrivacyNoticeRegion.us_tx,\n                \"experience_config_id\": overlay_experience_config.id,\n            },\n        )\n\n        assert privacy_experience.experience_config_id == overlay_experience_config.id\n\n        db.refresh(overlay_experience_config)\n        assert overlay_experience_config.experiences.all() == [privacy_experience]\n\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        response = api_client.patch(\n            url,\n            json={\n                \"regions\": [],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        resp = response.json()[\"experience_config\"]\n\n        assert (\n            resp[\"version\"] == 1.0\n        ), \"Version not bumped because config didn't change, only region removed\"\n        assert resp[\"regions\"] == []  # Main thing, regions were removed\n        assert response.json()[\"linked_regions\"] == []\n        assert response.json()[\"unlinked_regions\"] == [\"us_tx\"]\n\n        db.refresh(overlay_experience_config)\n        # ExperienceConfig was disabled - this is a change, so another historical record is created\n        assert overlay_experience_config.histories.count() == 1\n        experience_config_history = overlay_experience_config.histories[0]\n        assert experience_config_history.version == 1.0\n        assert experience_config_history.component == ComponentType.overlay\n        assert (\n            experience_config_history.experience_config_id\n            == overlay_experience_config.id\n        )\n\n        # Updated Privacy Experience - TX Privacy Experience automatically *unlinked*\n        assert overlay_experience_config.experiences.count() == 0\n        db.refresh(privacy_experience)\n\n        assert (\n            privacy_experience.experience_config_id\n            == \"pri-7ae3-f06b-4096-970f-0bbbdef-over\"\n        )  # Default overlay experience config linked instead\n\n        privacy_experience.delete(db)\n\n    @pytest.mark.usefixtures(\"privacy_experience_france_tcf_overlay\")\n    def test_add_regions_to_tcf_overlay(\n        self,\n        api_client: TestClient,\n        generate_auth_header,\n        experience_config_tcf_overlay,\n        db,\n    ) -> None:\n        \"\"\"Verify that regions can technically be added to the tcf overlay.\n\n        This is a contrived example, but tests that this workflow doesn't break for the new tcf overlay\n        \"\"\"\n        fr_experience = PrivacyExperience.get_experience_by_region_and_component(\n            db=db, region=\"fr\", component=ComponentType.tcf_overlay\n        )\n        assert fr_experience\n\n        ca_experience = PrivacyExperience.get_experience_by_region_and_component(\n            db=db, region=\"us_ca\", component=ComponentType.tcf_overlay\n        )\n        assert not ca_experience\n\n        auth_header = generate_auth_header(scopes=[scopes.PRIVACY_EXPERIENCE_UPDATE])\n        url = V1_URL_PREFIX + EXPERIENCE_CONFIG + f\"/{experience_config_tcf_overlay.id}\"\n        response = api_client.patch(\n            url,\n            json={\n                \"regions\": [\"us_ca\", \"fr\"],\n            },\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"experience_config\"][\"regions\"] == [\"fr\", \"us_ca\"]\n        assert response.json()[\"linked_regions\"] == [\"us_ca\"]\n\n        fr_experience = PrivacyExperience.get_experience_by_region_and_component(\n            db=db, region=\"fr\", component=ComponentType.tcf_overlay\n        )\n        assert fr_experience\n\n        ca_experience = PrivacyExperience.get_experience_by_region_and_component(\n            db=db, region=\"us_ca\", component=ComponentType.tcf_overlay\n        )\n        assert ca_experience\n", "from datetime import timedelta\nfrom unittest import mock\nfrom unittest.mock import MagicMock, patch\n\nimport pytest\nfrom sqlalchemy.orm import Session\nfrom starlette.status import HTTP_200_OK, HTTP_403_FORBIDDEN\nfrom starlette.testclient import TestClient\n\nfrom fides.api.models.privacy_preference import (\n    CURRENT_TCF_VERSION,\n    ConsentMethod,\n    CurrentPrivacyPreference,\n    PrivacyPreferenceHistory,\n    RequestOrigin,\n    UserConsentPreference,\n)\nfrom fides.api.models.privacy_request import (\n    ConsentRequest,\n    ExecutionLogStatus,\n    PrivacyRequestStatus,\n    ProvidedIdentity,\n)\nfrom fides.api.schemas.privacy_notice import PrivacyNoticeHistorySchema\nfrom fides.api.util.tcf.tcf_experience_contents import ConsentRecordType\nfrom fides.common.api.scope_registry import (\n    CONSENT_READ,\n    CURRENT_PRIVACY_PREFERENCE_READ,\n    PRIVACY_PREFERENCE_HISTORY_READ,\n)\nfrom fides.common.api.v1.urn_registry import (\n    CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY,\n    CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID,\n    CURRENT_PRIVACY_PREFERENCES_REPORT,\n    HISTORICAL_PRIVACY_PREFERENCES_REPORT,\n    PRIVACY_PREFERENCES,\n    V1_URL_PREFIX,\n)\nfrom fides.config import CONFIG\n\n\nclass TestSavePrivacyPreferencesPrivacyCenter:\n    @pytest.fixture(scope=\"function\")\n    def verification_code(self) -> str:\n        return \"abcd\"\n\n    @pytest.fixture(scope=\"function\")\n    def request_body(\n        self, privacy_notice, verification_code, consent_policy, served_notice_history\n    ):\n        return {\n            \"browser_identity\": {\"ga_client_id\": \"test\"},\n            \"code\": verification_code,\n            \"preferences\": [\n                {\n                    \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                    \"preference\": \"opt_out\",\n                    \"served_notice_history_id\": served_notice_history.id,\n                }\n            ],\n            \"policy_key\": consent_policy.key,\n            \"user_geography\": \"us_ca\",\n        }\n\n    @pytest.fixture(scope=\"function\")\n    def tcf_request_body(self, privacy_notice, verification_code, consent_policy):\n        return {\n            \"browser_identity\": {\"ga_client_id\": \"test\"},\n            \"code\": verification_code,\n            \"feature_preferences\": [\n                {\n                    \"id\": 1,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"policy_key\": consent_policy.key,\n            \"user_geography\": \"fr\",\n        }\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_save_privacy_preferences_no_consent_request_id(\n        self, api_client, request_body\n    ):\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id='non_existent_consent_id')}\",\n            json=request_body,\n        )\n        assert response.status_code == 404\n        assert \"not found\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_save_privacy_preferences_no_consent_code(\n        self, provided_identity_and_consent_request, api_client, privacy_notice\n    ):\n        _, consent_request = provided_identity_and_consent_request\n\n        data = {\n            \"browser_identity\": {\"ga_client_id\": \"test_ga_client_id\"},\n            \"code\": \"12345\",\n            \"preferences\": [\n                {\n                    \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"user_geography\": \"us_ca\",\n        }\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=data,\n        )\n        assert response.status_code == 400\n        assert \"code expired\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_set_privacy_preferences_invalid_code(\n        self,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        request_body,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"code\"] = \"non_matching_code\"\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 403\n        assert \"Incorrect identification\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\", \"automatically_approved\", \"system\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.privacy_preference_endpoints.anonymize_ip_address\"\n    )\n    def test_verify_then_set_privacy_preferences(\n        self,\n        mock_anonymize,\n        run_privacy_request_mock,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        db: Session,\n        request_body,\n        privacy_notice,\n    ):\n        \"\"\"Verify code, save, and then return privacy preferences\n        Privacy request also queued because a notice has system wide enforcement\n        \"\"\"\n        masked_ip = \"12.214.31.0\"  # Mocking because hostname for FastAPI TestClient is \"testclient\"\n        mock_anonymize.return_value = masked_ip\n\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        # Assert no existing privacy preferences exist for this identity\n        assert response.json() == {\n            \"items\": [],\n            \"total\": 0,\n            \"page\": 1,\n            \"pages\": 0,\n            \"size\": 50,\n        }\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"preferences\"]) == 1\n        assert response.json()[\"fides_mobile_data\"] is None\n\n        response_json = response.json()[\"preferences\"][0]\n        created_privacy_preference_history_id = response_json[\n            \"privacy_preference_history_id\"\n        ]\n        privacy_preference_history = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id == created_privacy_preference_history_id\n            )\n            .first()\n        )\n        assert response_json[\"preference\"] == \"opt_out\"\n\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n        db.refresh(consent_request)\n        assert consent_request.privacy_request_id\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        response_json = response.json()[\"items\"][0]\n        assert response_json[\"id\"] is not None\n        assert response_json[\"preference\"] == \"opt_out\"\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n\n        assert privacy_preference_history.privacy_request_id is not None\n        assert run_privacy_request_mock.called\n\n        privacy_preference_history.delete(db=db)\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\", \"automatically_approved\", \"system\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.privacy_preference_endpoints.anonymize_ip_address\"\n    )\n    def test_verify_then_set_privacy_preferences_but_no_privacy_request_created(\n        self,\n        mock_anonymize,\n        run_privacy_request_mock,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        db: Session,\n        privacy_notice_fr_provide_service_frontend_only,\n        privacy_experience_france_overlay,\n        consent_policy,\n    ):\n        \"\"\"Verify code, save, and then return privacy preferences\n        Privacy request not queued because no notice has system wide enforcement\n        \"\"\"\n        masked_ip = \"12.214.31.0\"  # Mocking because hostname for FastAPI TestClient is \"testclient\"\n        mock_anonymize.return_value = masked_ip\n\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        # Assert no existing privacy preferences exist for this identity\n        assert response.json() == {\n            \"items\": [],\n            \"total\": 0,\n            \"page\": 1,\n            \"pages\": 0,\n            \"size\": 50,\n        }\n\n        request_body = {\n            \"browser_identity\": {\"ga_client_id\": \"test\"},\n            \"code\": verification_code,\n            \"preferences\": [\n                {\n                    \"privacy_notice_history_id\": privacy_notice_fr_provide_service_frontend_only.histories[\n                        0\n                    ].id,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"policy_key\": consent_policy.key,\n            \"user_geography\": \"fr_idg\",\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"method\": \"button\",\n        }\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"preferences\"]) == 1\n        assert response.json()[\"fides_mobile_data\"] is None\n\n        response_json = response.json()[\"preferences\"][0]\n        created_privacy_preference_history_id = response_json[\n            \"privacy_preference_history_id\"\n        ]\n        privacy_preference_history = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id == created_privacy_preference_history_id\n            )\n            .first()\n        )\n        assert response_json[\"preference\"] == \"opt_out\"\n\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(\n                privacy_notice_fr_provide_service_frontend_only.histories[0]\n            ).dict()\n        )\n        db.refresh(consent_request)\n        # No privacy request created here\n        assert not consent_request.privacy_request_id\n\n        # Privacy request not created or queued\n        assert privacy_preference_history.privacy_request_id is None\n        assert not run_privacy_request_mock.called\n\n        assert privacy_preference_history.user_geography == \"fr_idg\"\n\n        privacy_preference_history.delete(db=db)\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_not_required\", \"automatically_approved\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.privacy_preference_endpoints.anonymize_ip_address\"\n    )\n    def test_set_privacy_preferences_privacy_center_fides_user_device_id_only(\n        self,\n        mock_anonymize,\n        run_privacy_request_mock,\n        fides_user_provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        db: Session,\n        request_body,\n        privacy_notice,\n    ):\n        \"\"\"Test the workflow where consent preferences were saved in the privacy center against\n        a fides user device id only - no email or phone number.  This ProvidedIdentity needs to be\n        saved as the PrivacyPreferenceHistory.fides_user_device_provided_identity_id record.\n\n        Also asserts these same preferences can be retrieved via the consent request verify endpoint\n        \"\"\"\n        masked_ip = \"12.214.31.0\"\n        mock_anonymize.return_value = masked_ip\n\n        (\n            fides_user_provided_identity,\n            consent_request,\n        ) = fides_user_provided_identity_and_consent_request\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"preferences\"]) == 1\n        assert response.json()[\"fides_mobile_data\"] is None\n\n        response_json = response.json()[\"preferences\"][0]\n        created_privacy_preference_history_id = response_json[\n            \"privacy_preference_history_id\"\n        ]\n        privacy_preference_history = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id == created_privacy_preference_history_id\n            )\n            .first()\n        )\n        assert privacy_preference_history.email is None\n        assert (\n            privacy_preference_history.fides_user_device\n            == fides_user_provided_identity.encrypted_value[\"value\"]\n        )\n        assert privacy_preference_history.provided_identity is None\n        assert (\n            privacy_preference_history.fides_user_device_provided_identity\n            == fides_user_provided_identity,\n            \"Assert fides user device provided identity \",\n        )\n        assert privacy_preference_history.phone_number is None\n        assert privacy_preference_history.preference == UserConsentPreference.opt_out\n\n        assert response_json[\"preference\"] == \"opt_out\"\n\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n        db.refresh(consent_request)\n        assert consent_request.privacy_request_id\n\n        # Assert preferences can be retrieved under fides user device id only\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        response_json = response.json()[\"items\"][0]\n        assert response_json[\"id\"] is not None\n        assert response_json[\"preference\"] == \"opt_out\"\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n\n        # Test no experience specified, so no request origin\n        assert privacy_preference_history.request_origin is None\n        assert privacy_preference_history.user_agent == \"testclient\"\n        assert privacy_preference_history.privacy_experience_config_history_id is None\n        assert privacy_preference_history.privacy_experience_id is None\n        assert mock_anonymize.call_args.args[0] == \"testclient\"\n        assert privacy_preference_history.anonymized_ip_address == masked_ip\n        assert privacy_preference_history.url_recorded is None\n\n        # Fetch current privacy preference\n        current_preference = CurrentPrivacyPreference.get(\n            db, object_id=response_json[\"id\"]\n        )\n        assert current_preference.preference == UserConsentPreference.opt_out\n        assert (\n            current_preference.privacy_notice_history_id\n            == privacy_notice.histories[0].id\n        )\n\n        privacy_preference_history.delete(db=db)\n        assert run_privacy_request_mock.called\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_set_privacy_preferences_invalid_code_respects_attempt_count(\n        self,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        request_body,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"code\"] = \"987632\"  # Bad code\n\n        for _ in range(0, CONFIG.security.identity_verification_attempt_limit):\n            response = api_client.patch(\n                f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n                json=request_body,\n            )\n            assert response.status_code == 403\n            assert \"Incorrect identification\" in response.json()[\"detail\"]\n\n        assert (\n            consent_request._get_cached_verification_code_attempt_count()\n            == CONFIG.security.identity_verification_attempt_limit\n        )\n\n        request_body[\"code\"] = verification_code\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 403\n        assert (\n            response.json()[\"detail\"] == f\"Attempt limit hit for '{consent_request.id}'\"\n        )\n        assert consent_request.get_cached_verification_code() is None\n        assert consent_request._get_cached_verification_code_attempt_count() == 0\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    def test_set_privacy_preferences_no_email_provided(\n        self,\n        mock_verify_identity: MagicMock,\n        db,\n        api_client,\n        verification_code,\n        request_body,\n    ):\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": None,\n            \"encrypted_value\": None,\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n        consent_request_data = {\n            \"provided_identity_id\": provided_identity.id,\n        }\n        consent_request = ConsentRequest.create(db, data=consent_request_data)\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n\n        assert response.status_code == 404\n        assert mock_verify_identity.called\n        assert \"missing\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_set_privacy_preferences_no_privacy_preferences_present(\n        self,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        request_body,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"preferences\"] = None\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 422\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_set_privacy_preferences_invalid_privacy_notice_history_id(\n        self,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        request_body,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"preferences\"][0][\"privacy_notice_history_id\"] = \"bad_id\"\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert (\n            response.status_code == 400\n        ), \"Gets picked up by the duplicate privacy notice check\"\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_set_duplicate_preferences_for_the_same_notice_in_one_request(\n        self,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        request_body,\n        privacy_notice,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"preferences\"].append(\n            {\n                \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                \"preference\": \"opt_in\",\n            }\n        )\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert (\n            response.status_code == 400\n        ), \"Gets picked up by the duplicate privacy notice check\"\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_save_preferences_invalid_served_notice_history_id(\n        self,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        request_body,\n        privacy_notice,\n        served_notice_history_us_ca_provide_for_fides_user,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"preferences\"][0][\n            \"served_notice_history_id\"\n        ] = served_notice_history_us_ca_provide_for_fides_user.id\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"]\n            == f\"The ServedNoticeHistory record '{served_notice_history_us_ca_provide_for_fides_user.id}' did not serve the privacy notice history '{privacy_notice.histories[0].id}'.\"\n        )\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n        \"automatically_approved\",\n        \"consent_policy\",\n        \"system\",\n    )\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_set_privacy_preferences(\n        self,\n        mock_run_privacy_request: MagicMock,\n        mock_verify_identity: MagicMock,\n        provided_identity_and_consent_request,\n        db,\n        api_client,\n        verification_code,\n        request_body,\n        privacy_notice,\n        privacy_notice_us_ca_provide,\n        served_notice_history,\n    ):\n        provided_identity, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"preferences\"].append(\n            {\n                \"privacy_notice_history_id\": privacy_notice_us_ca_provide.histories[\n                    0\n                ].id,\n                \"preference\": \"opt_in\",\n            }\n        )\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n\n        assert response.status_code == 200\n        assert len(response.json()[\"preferences\"]) == 2\n        assert response.json()[\"fides_mobile_data\"] is None\n\n        response_json = response.json()[\"preferences\"]\n\n        first_privacy_preference_history_created = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id\n                == response_json[0][\"privacy_preference_history_id\"]\n            )\n            .first()\n        )\n        assert response_json[0][\"preference\"] == \"opt_out\"\n\n        assert (\n            response_json[0][\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n\n        second_privacy_preference_history_created = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id\n                == response_json[1][\"privacy_preference_history_id\"]\n            )\n            .first()\n        )\n        assert response_json[1][\"preference\"] == \"opt_in\"\n        assert (\n            response_json[1][\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(\n                privacy_notice_us_ca_provide.histories[0]\n            ).dict()\n        )\n        assert verification_code in mock_verify_identity.call_args_list[0].args\n\n        db.refresh(first_privacy_preference_history_created)\n        db.refresh(second_privacy_preference_history_created)\n\n        assert (\n            first_privacy_preference_history_created.served_notice_history_id\n            == served_notice_history.id\n        )\n        assert (\n            second_privacy_preference_history_created.served_notice_history_id is None\n        )\n\n        assert first_privacy_preference_history_created.privacy_request_id is not None\n        assert second_privacy_preference_history_created.privacy_request_id is not None\n\n        identity = (\n            first_privacy_preference_history_created.privacy_request.get_persisted_identity()\n        )\n        assert identity.email == \"test@email.com\", (\n            \"Identity pulled from Privacy Request Provided Identity and used to \"\n            \"create a Privacy Request provided identity \"\n        )\n        assert identity.phone_number is None\n        assert identity.ga_client_id == \"test\", (\n            \"Browser identity pulled from Privacy Request Provided Identity and persisted \"\n            \"to a Privacy Request provided identity\"\n        )\n\n        privacy_request = first_privacy_preference_history_created.privacy_request\n        assert privacy_request.status == PrivacyRequestStatus.pending\n        assert privacy_request.privacy_preferences == [\n            first_privacy_preference_history_created,\n            second_privacy_preference_history_created,\n        ], \"Same privacy request created to propagate both preferences\"\n\n        db.refresh(consent_request)\n        assert (\n            consent_request.privacy_request_id == privacy_request.id\n        ), \"Privacy request id also saved on Consent request for record keeping\"\n        assert mock_run_privacy_request.called\n\n        current_privacy_preference_one = (\n            first_privacy_preference_history_created.current_privacy_preference\n        )\n        current_privacy_preference_two = (\n            second_privacy_preference_history_created.current_privacy_preference\n        )\n        assert (\n            current_privacy_preference_one.preference == UserConsentPreference.opt_out\n        ), \"History preferences saved to latest preferences\"\n        assert (\n            current_privacy_preference_two.preference == UserConsentPreference.opt_in\n        ), \"History preferences saved to latest preferences\"\n\n        first_privacy_preference_history_created.delete(db)\n        second_privacy_preference_history_created.delete(db)\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n        \"automatically_approved\",\n        \"consent_policy\",\n        \"system\",\n        \"enable_tcf\",\n    )\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_set_privacy_preferences_tcf(\n        self,\n        mock_run_privacy_request: MagicMock,\n        mock_verify_identity: MagicMock,\n        provided_identity_and_consent_request,\n        db,\n        api_client,\n        verification_code,\n        tcf_request_body,\n    ):\n        provided_identity, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=tcf_request_body,\n        )\n\n        assert response.status_code == 200\n        assert response.json()[\"fides_mobile_data\"] is None\n        assert len(response.json()[\"preferences\"]) == 0\n        assert len(response.json()[\"feature_preferences\"]) == 1\n\n        response_json = response.json()[\"feature_preferences\"]\n\n        first_privacy_preference_history_created = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id\n                == response_json[0][\"privacy_preference_history_id\"]\n            )\n            .first()\n        )\n        assert response_json[0][\"preference\"] == \"opt_out\"\n        assert response_json[0][\"feature\"] == 1\n\n        assert first_privacy_preference_history_created.feature == 1\n        assert (\n            first_privacy_preference_history_created.preference\n            == UserConsentPreference.opt_out\n        )\n        assert (\n            first_privacy_preference_history_created.consent_record_type\n            == ConsentRecordType.feature\n        )\n\n        current_preference = (\n            first_privacy_preference_history_created.current_privacy_preference\n        )\n\n        assert current_preference.feature == 1\n        assert current_preference.preference == UserConsentPreference.opt_out\n\n        assert verification_code in mock_verify_identity.call_args_list[0].args\n\n        current_preference.delete(db)\n        first_privacy_preference_history_created.delete(db)\n\n        assert not mock_run_privacy_request.called\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\", \"automatically_approved\"\n    )\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_set_privacy_preferences_bad_policy_key(\n        self,\n        mock_run_privacy_request: MagicMock,\n        mock_verify_identity: MagicMock,\n        provided_identity_and_consent_request,\n        db,\n        api_client,\n        verification_code,\n        request_body,\n        privacy_notice,\n    ):\n        \"\"\"Even though privacy request creation fails, privacy preferences are still saved\"\"\"\n        provided_identity, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        request_body[\"policy_key\"] = \"bad_policy_key\"\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n\n        assert response.status_code == 400\n        assert (\n            response.json()[\"detail\"] == \"Policy with key bad_policy_key does not exist\"\n        )\n\n        privacy_preference_history_created = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.privacy_notice_history_id\n                == privacy_notice.privacy_notice_history_id\n            )\n            .first()\n        )\n        assert (\n            privacy_preference_history_created.preference\n            == UserConsentPreference.opt_out\n        )\n\n        assert verification_code in mock_verify_identity.call_args_list[0].args\n        assert privacy_preference_history_created.privacy_request_id is None\n        db.refresh(consent_request)\n        assert consent_request.privacy_request_id is None\n        assert not mock_run_privacy_request.called\n\n        current_privacy_preference_one = (\n            privacy_preference_history_created.current_privacy_preference\n        )\n\n        assert (\n            current_privacy_preference_one.preference == UserConsentPreference.opt_out\n        ), \"Historical preferences upserted to latest consent preferences\"\n\n        privacy_preference_history_created.delete(db)\n\n    @pytest.mark.usefixtures(\"automatically_approved\", \"system\")\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_set_privacy_preferences_without_verification_required(\n        self,\n        run_privacy_request_mock,\n        mock_verify_identity: MagicMock,\n        provided_identity_and_consent_request,\n        db,\n        api_client,\n        privacy_notice,\n        request_body,\n        verification_code,\n    ):\n        provided_identity, consent_request = provided_identity_and_consent_request\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"preferences\"]) == 1\n\n        response_json = response.json()[\"preferences\"][0]\n        created_privacy_preference_history_id = response_json[\n            \"privacy_preference_history_id\"\n        ]\n        privacy_preference_history = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id == created_privacy_preference_history_id\n            )\n            .first()\n        )\n        assert response_json[\"preference\"] == \"opt_out\"\n\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n\n        db.refresh(consent_request)\n        assert consent_request.privacy_request_id\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        response_json = response.json()[\"items\"][0]\n        assert response_json[\"id\"] is not None\n        assert response_json[\"preference\"] == \"opt_out\"\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n\n        privacy_preference_history.delete(db=db)\n        assert not mock_verify_identity.called\n        assert run_privacy_request_mock.called\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\", \"automatically_approved\", \"system\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_verify_then_set_privacy_preferences_with_additional_fides_user_device_id(\n        self,\n        run_privacy_request_mock,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n        db: Session,\n        request_body,\n        privacy_notice,\n    ):\n        \"\"\"Verify code and then return privacy preferences\n\n        Besides having a verified identity, we also have the fides_user_device_id from the browser\n        \"\"\"\n        test_device_id = \"2da1690a-65b6-447b-879b-d33089c04ba5\"\n        request_body[\"browser_identity\"][\"fides_user_device_id\"] = test_device_id\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        # Assert no existing privacy preferences exist for this identity\n        assert response.json() == {\n            \"items\": [],\n            \"total\": 0,\n            \"page\": 1,\n            \"pages\": 0,\n            \"size\": 50,\n        }\n\n        response = api_client.patch(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_WITH_ID.format(consent_request_id=consent_request.id)}\",\n            json=request_body,\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"preferences\"]) == 1\n        assert response.json()[\"fides_mobile_data\"] is None\n\n        response_json = response.json()[\"preferences\"][0]\n        created_privacy_preference_history_id = response_json[\n            \"privacy_preference_history_id\"\n        ]\n        privacy_preference_history = (\n            db.query(PrivacyPreferenceHistory)\n            .filter(\n                PrivacyPreferenceHistory.id == created_privacy_preference_history_id\n            )\n            .first()\n        )\n        assert response_json[\"preference\"] == \"opt_out\"\n\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n        db.refresh(consent_request)\n        assert consent_request.privacy_request_id\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        response_json = response.json()[\"items\"][0]\n        assert response_json[\"id\"] is not None\n        assert response_json[\"preference\"] == \"opt_out\"\n        assert (\n            response_json[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(privacy_notice.histories[0]).dict()\n        )\n        assert privacy_preference_history.fides_user_device == test_device_id\n        assert (\n            privacy_preference_history.hashed_fides_user_device\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n        assert (\n            privacy_preference_history.fides_user_device_provided_identity_id\n            is not None\n        )\n        fides_user_device_provided_identity = (\n            privacy_preference_history.fides_user_device_provided_identity\n        )\n        assert (\n            fides_user_device_provided_identity\n            != privacy_preference_history.provided_identity\n        )\n        assert (\n            fides_user_device_provided_identity.encrypted_value[\"value\"]\n            == test_device_id\n        )\n        assert (\n            fides_user_device_provided_identity.hashed_value\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n\n        privacy_preference_history.delete(db=db)\n        assert run_privacy_request_mock.called\n\n\nclass TestPrivacyPreferenceVerify:\n    @pytest.fixture(scope=\"function\")\n    def verification_code(self) -> str:\n        return \"abcd\"\n\n    def test_consent_verify_no_consent_request_id(\n        self,\n        api_client,\n    ):\n        data = {\"code\": \"12345\"}\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id='non_existent_consent_id')}\",\n            json=data,\n        )\n        assert response.status_code == 404\n        assert \"not found\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_consent_verify_no_consent_code(\n        self, provided_identity_and_consent_request, api_client\n    ):\n        data = {\"code\": \"12345\"}\n\n        _, consent_request = provided_identity_and_consent_request\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json=data,\n        )\n        assert response.status_code == 400\n        assert \"code expired\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_consent_verify_invalid_code(\n        self, provided_identity_and_consent_request, api_client\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(\"abcd\")\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": \"1234\"},\n        )\n        assert response.status_code == 403\n        assert \"Incorrect identification\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    def test_consent_verify_no_email_provided(\n        self,\n        mock_verify_identity: MagicMock,\n        db,\n        api_client,\n        verification_code,\n    ):\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": None,\n            \"encrypted_value\": None,\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n        consent_request_data = {\n            \"provided_identity_id\": provided_identity.id,\n        }\n        consent_request = ConsentRequest.create(db, data=consent_request_data)\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n\n        assert response.status_code == 404\n        assert verification_code in mock_verify_identity.call_args_list[0].args\n        assert \"missing\" in response.json()[\"detail\"]\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    @patch(\"fides.api.models.privacy_request.ConsentRequest.verify_identity\")\n    def test_consent_verify_no_privacy_preferences_present(\n        self,\n        mock_verify_identity: MagicMock,\n        provided_identity_and_consent_request,\n        api_client,\n        verification_code,\n    ):\n        _, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert verification_code in mock_verify_identity.call_args_list[0].args\n        assert response.json() == {\n            \"items\": [],\n            \"total\": 0,\n            \"page\": 1,\n            \"pages\": 0,\n            \"size\": 50,\n        }\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n    )\n    def test_consent_verify_consent_preferences(\n        self,\n        provided_identity_and_consent_request,\n        db,\n        api_client,\n        verification_code,\n        privacy_preference_history,\n    ):\n        provided_identity, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n\n        # Getting current preferences returns the latest CurrentPrivacyPreferences, not the PrivacyPreferenceHistory records\n        current_preference_record = (\n            privacy_preference_history.current_privacy_preference\n        )\n        data = response.json()[\"items\"][0]\n        assert data[\"id\"] == current_preference_record.id\n        assert (\n            data[\"preference\"]\n            == \"opt_out\"\n            == privacy_preference_history.preference.value\n        )\n        assert (\n            data[\"privacy_notice_history\"]\n            == PrivacyNoticeHistorySchema.from_orm(\n                privacy_preference_history.privacy_notice_history\n            ).dict()\n        )\n        db.refresh(consent_request)\n        assert consent_request.identity_verified_at is not None\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n        \"privacy_preference_history_for_tcf_special_purpose\",\n    )\n    def test_consent_verify_tcf_consent_preferences_tcf_disabled(\n        self, provided_identity_and_consent_request, api_client, verification_code\n    ):\n        provided_identity, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 0\n\n    @pytest.mark.usefixtures(\n        \"subject_identity_verification_required\",\n        \"enable_tcf\",\n    )\n    def test_consent_verify_tcf_consent_preferences(\n        self,\n        provided_identity_and_consent_request,\n        db,\n        api_client,\n        verification_code,\n        privacy_preference_history_for_tcf_special_purpose,\n    ):\n        provided_identity, consent_request = provided_identity_and_consent_request\n        consent_request.cache_identity_verification_code(verification_code)\n\n        response = api_client.post(\n            f\"{V1_URL_PREFIX}{CONSENT_REQUEST_PRIVACY_PREFERENCES_VERIFY.format(consent_request_id=consent_request.id)}\",\n            json={\"code\": verification_code},\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n\n        current_preference_record = (\n            privacy_preference_history_for_tcf_special_purpose.current_privacy_preference\n        )\n        data = response.json()[\"items\"][0]\n        assert data[\"id\"] == current_preference_record.id\n        assert (\n            data[\"preference\"]\n            == \"opt_in\"\n            == privacy_preference_history_for_tcf_special_purpose.preference.value\n        )\n        assert data[\"special_purpose\"] == 1\n        db.refresh(consent_request)\n        assert consent_request.identity_verified_at is not None\n\n\nclass TestSavePrivacyPreferencesForFidesDeviceId:\n    @pytest.fixture(scope=\"function\")\n    def url(self) -> str:\n        return V1_URL_PREFIX + PRIVACY_PREFERENCES\n\n    @pytest.fixture(scope=\"function\")\n    def request_body(\n        self,\n        privacy_notice,\n        consent_policy,\n        privacy_experience_overlay,\n        served_notice_history,\n    ):\n        return {\n            \"browser_identity\": {\n                \"ga_client_id\": \"test\",\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"preferences\": [\n                {\n                    \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                    \"preference\": \"opt_out\",\n                    \"served_notice_history_id\": served_notice_history.id,\n                }\n            ],\n            \"policy_key\": consent_policy.key,\n            \"user_geography\": \"us_ca\",\n            \"privacy_experience_id\": privacy_experience_overlay.id,\n            \"method\": \"button\",\n        }\n\n    @pytest.fixture(scope=\"function\")\n    def tcf_request_body(\n        self,\n        privacy_notice,\n        consent_policy,\n        privacy_experience_france_tcf_overlay,\n        served_notice_history_for_tcf_purpose,\n        system,\n    ):\n        return {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"purpose_consent_preferences\": [\n                {\n                    \"id\": 8,\n                    \"preference\": \"opt_out\",\n                    \"served_notice_history_id\": served_notice_history_for_tcf_purpose.id,\n                }\n            ],\n            \"vendor_consent_preferences\": [\n                {\n                    \"id\": \"amplitude\",\n                    \"preference\": \"opt_in\",\n                }\n            ],\n            \"feature_preferences\": [{\"id\": 1, \"preference\": \"opt_out\"}],\n            \"special_feature_preferences\": [{\"id\": 2, \"preference\": \"opt_in\"}],\n            \"system_legitimate_interests_preferences\": [\n                {\"id\": system.id, \"preference\": \"opt_out\"}\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n\n    @pytest.mark.usefixtures(\n        \"privacy_notice\",\n    )\n    def test_no_fides_user_device_id_supplied(self, api_client, url, request_body):\n        del request_body[\"browser_identity\"][\"fides_user_device_id\"]\n        response = api_client.patch(\n            url, json=request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 422\n\n    @pytest.mark.usefixtures(\n        \"privacy_notice\",\n    )\n    def test_bad_fides_user_device_id_supplied(self, api_client, url, request_body):\n        request_body[\"browser_identity\"][\n            \"fides_user_device_id\"\n        ] = \"bad_fides_user_device_id\"\n        response = api_client.patch(\n            url, json=request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"badly formed hexadecimal UUID string\"\n        )\n\n    @pytest.mark.usefixtures(\n        \"privacy_notice\",\n    )\n    def test_save_privacy_preferences_with_bad_notice(\n        self, api_client, url, request_body\n    ):\n        request_body[\"preferences\"][0][\"privacy_notice_history_id\"] = \"bad_history\"\n        response = api_client.patch(\n            url, json=request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 400\n\n    @pytest.mark.usefixtures(\n        \"privacy_notice\",\n    )\n    def test_save_privacy_preferences_with_invalid_served_notice_history(\n        self,\n        api_client,\n        url,\n        request_body,\n        served_notice_history_us_ca_provide_for_fides_user,\n    ):\n        request_body[\"preferences\"][0][\n            \"served_notice_history_id\"\n        ] = served_notice_history_us_ca_provide_for_fides_user.id\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 422\n\n    @pytest.mark.usefixtures(\n        \"privacy_notice\",\n    )\n    def test_save_privacy_preferences_with_served_notice_history_not_found(\n        self, api_client, url, request_body\n    ):\n        request_body[\"preferences\"][0][\n            \"served_notice_history_id\"\n        ] = \"bad_served_notice_history_id\"\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 404\n\n    def test_save_privacy_preferences_bad_experience_id(\n        self,\n        api_client,\n        url,\n        request_body,\n    ):\n        \"\"\"Privacy experiences need to be valid when setting preferences\"\"\"\n        request_body[\"privacy_experience_id\"] = \"bad_id\"\n        response = api_client.patch(\n            url, json=request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 404\n        assert response.json()[\"detail\"] == f\"Privacy Experience 'bad_id' not found.\"\n\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.privacy_preference_endpoints.anonymize_ip_address\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_save_privacy_preferences_with_respect_to_fides_user_device_id(\n        self,\n        run_privacy_request_mock,\n        mock_anonymize,\n        db,\n        api_client,\n        url,\n        request_body,\n        privacy_notice,\n        privacy_experience_overlay,\n        served_notice_history,\n    ):\n        \"\"\"Assert CurrentPrivacyPreference records were updated and PrivacyPreferenceHistory records were created\n        for recordkeeping with respect to the fides user device id in the request\n        \"\"\"\n        test_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n        masked_ip = \"12.214.31.0\"\n        mock_anonymize.return_value = masked_ip\n        response = api_client.patch(\n            url, json=request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 200\n        assert response.json()[\"fides_mobile_data\"] is None\n        response_json = response.json()[\"preferences\"][0]\n        assert response_json[\"preference\"] == \"opt_out\"\n        assert (\n            response_json[\"privacy_notice_history\"][\"id\"]\n            == privacy_notice.histories[0].id\n        )\n\n        privacy_preference_history_id = response_json[\"privacy_preference_history_id\"]\n\n        # Fetch current privacy preference that was updated\n        current_preference = CurrentPrivacyPreference.get(\n            db, object_id=response_json[\"id\"]\n        )\n        # Get corresponding historical preference that was just created\n        privacy_preference_history = current_preference.privacy_preference_history\n        assert privacy_preference_history.id == privacy_preference_history_id\n\n        fides_user_device_provided_identity = (\n            privacy_preference_history.fides_user_device_provided_identity\n        )\n        # Same fides user device identity added to both the historical and current record\n        assert (\n            current_preference.fides_user_device_provided_identity\n            == fides_user_device_provided_identity\n        )\n        assert (\n            fides_user_device_provided_identity.hashed_value\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n        assert (\n            fides_user_device_provided_identity.encrypted_value[\"value\"]\n            == test_device_id\n        )\n        # Values also cached on the historical record for reporting\n        assert (\n            privacy_preference_history.hashed_fides_user_device\n            == ProvidedIdentity.hash_value(test_device_id)\n        )  # Cached here for reporting\n        assert (\n            privacy_preference_history.fides_user_device == test_device_id\n        )  # Cached here for reporting\n\n        # Test items that are pulled from request headers or client\n        assert (\n            privacy_preference_history.request_origin == RequestOrigin.overlay\n        )  # Retrieved from privacy experience history\n        assert (\n            privacy_preference_history.user_agent == \"testclient\"\n        )  # Retrieved from request headers\n        assert (\n            privacy_preference_history.privacy_experience_config_history_id\n            == privacy_experience_overlay.experience_config.experience_config_history_id\n        )\n        assert (\n            privacy_preference_history.privacy_experience_id\n            == privacy_experience_overlay.id\n        )\n        assert privacy_preference_history.anonymized_ip_address == masked_ip\n        assert privacy_preference_history.url_recorded is None\n        assert privacy_preference_history.method == ConsentMethod.button\n        assert (\n            privacy_preference_history.served_notice_history_id\n            == served_notice_history.id\n        )\n\n        # Privacy request created and queued because a privacy notice has system wide enforcement\n        assert privacy_preference_history.privacy_request_id is not None\n        assert run_privacy_request_mock.called\n\n        current_preference.delete(db)\n        privacy_preference_history.delete(db)\n\n    def test_invalid_tcf_purpose_in_request_body(\n        self,\n        api_client,\n        url,\n        privacy_experience_france_tcf_overlay,\n    ):\n        request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"purpose_consent_preferences\": [\n                {\n                    \"id\": 1000,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"Cannot save preferences against invalid purpose id: '1000'\"\n        )\n\n    def test_invalid_tcf_special_purpose_in_request_body(\n        self,\n        api_client,\n        url,\n        privacy_experience_france_tcf_overlay,\n    ):\n        request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"special_purpose_preferences\": [\n                {\n                    \"id\": 3,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"Cannot save preferences against invalid special purpose id: '3'\"\n        )\n\n    def test_invalid_tcf_feature_in_request_body(\n        self,\n        api_client,\n        url,\n        privacy_experience_france_tcf_overlay,\n    ):\n        request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"feature_preferences\": [\n                {\n                    \"id\": 4,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"Cannot save preferences against invalid feature id: '4'\"\n        )\n\n    def test_invalid_tcf_special_feature_in_request_body(\n        self,\n        api_client,\n        url,\n        privacy_experience_france_tcf_overlay,\n    ):\n        request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"special_feature_preferences\": [\n                {\n                    \"id\": 3,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"Cannot save preferences against invalid special feature id: '3'\"\n        )\n\n    @pytest.mark.usefixtures(\n        \"enable_tcf\",\n    )\n    def test_invalid_system_in_request_body(\n        self, api_client, url, db, privacy_experience_france_tcf_overlay\n    ):\n        request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"system_consent_preferences\": [\n                {\n                    \"id\": \"bad_system\",\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 400\n        assert (\n            response.json()[\"detail\"]\n            == \"Can't save consent against invalid system id 'bad_system'.\"\n        )\n\n    def test_duplicate_tcf_preferences_in_request_body(\n        self,\n        api_client,\n        url,\n        privacy_experience_france_tcf_overlay,\n    ):\n        request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"special_purpose_preferences\": [\n                {\n                    \"id\": 2,\n                    \"preference\": \"opt_out\",\n                },\n                {\n                    \"id\": 2,\n                    \"preference\": \"opt_in\",\n                },\n            ],\n            \"user_geography\": \"fr\",\n            \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n        }\n        response = api_client.patch(url, json=request_body)\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"Duplicate preferences saved against TCF component: 'special_purpose_preferences'\"\n        )\n\n    @pytest.mark.usefixtures(\n        \"enable_tcf\",\n    )\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.privacy_preference_endpoints.anonymize_ip_address\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_save_tcf_privacy_preferences(\n        self,\n        run_privacy_request_mock,\n        mock_anonymize,\n        db,\n        api_client,\n        url,\n        tcf_request_body,\n        privacy_experience_france_tcf_overlay,\n        served_notice_history_for_tcf_purpose,\n        experience_config_tcf_overlay,\n        system,\n    ):\n        \"\"\"Assert CurrentPrivacyPreference records were updated and PrivacyPreferenceHistory records were created\n        for recordkeeping with respect to the fides user device id in the request\n        \"\"\"\n        test_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n        masked_ip = \"12.214.31.0\"\n        mock_anonymize.return_value = masked_ip\n        response = api_client.patch(\n            url, json=tcf_request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 200\n        assert len(response.json()[\"purpose_consent_preferences\"]) == 1\n        assert len(response.json()[\"preferences\"]) == 0\n        assert len(response.json()[\"purpose_legitimate_interests_preferences\"]) == 0\n        assert len(response.json()[\"special_purpose_preferences\"]) == 0\n        assert len(response.json()[\"vendor_consent_preferences\"]) == 1\n        assert len(response.json()[\"feature_preferences\"]) == 1\n        assert len(response.json()[\"special_feature_preferences\"]) == 1\n        assert len(response.json()[\"system_consent_preferences\"]) == 0\n        assert len(response.json()[\"system_legitimate_interests_preferences\"]) == 1\n        assert response.json()[\"fides_mobile_data\"] is None\n\n        purpose_response = response.json()[\"purpose_consent_preferences\"][0]\n        assert purpose_response[\"preference\"] == \"opt_out\"\n        assert purpose_response[\"purpose_consent\"] == 8\n        purpose_privacy_preference_history_id = purpose_response[\n            \"privacy_preference_history_id\"\n        ]\n        current_purpose_preference = CurrentPrivacyPreference.get(\n            db, object_id=purpose_response[\"id\"]\n        )\n        # Assert details saved with respect to data use\n        purpose_privacy_preference_history = (\n            current_purpose_preference.privacy_preference_history\n        )\n        assert (\n            purpose_privacy_preference_history.id\n            == purpose_privacy_preference_history_id\n        )\n        assert purpose_privacy_preference_history.vendor_consent is None\n        assert purpose_privacy_preference_history.vendor_legitimate_interests is None\n\n        assert purpose_privacy_preference_history.privacy_notice_history_id is None\n        assert purpose_privacy_preference_history.feature is None\n        fides_user_device_provided_identity = (\n            purpose_privacy_preference_history.fides_user_device_provided_identity\n        )\n        assert (\n            current_purpose_preference.fides_user_device_provided_identity\n            == fides_user_device_provided_identity\n        )\n        assert (\n            fides_user_device_provided_identity.hashed_value\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n        assert (\n            fides_user_device_provided_identity.encrypted_value[\"value\"]\n            == test_device_id\n        )\n        assert (\n            purpose_privacy_preference_history.hashed_fides_user_device\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n        assert purpose_privacy_preference_history.fides_user_device == test_device_id\n        assert (\n            purpose_privacy_preference_history.purpose_consent\n            == purpose_response[\"purpose_consent\"]\n        )\n        assert purpose_privacy_preference_history.purpose_legitimate_interests is None\n\n        assert (\n            purpose_privacy_preference_history.request_origin\n            == RequestOrigin.tcf_overlay\n        )\n        assert purpose_privacy_preference_history.user_agent == \"testclient\"\n        assert (\n            purpose_privacy_preference_history.privacy_experience_config_history_id\n            == experience_config_tcf_overlay.experience_config_history_id\n        )\n        assert (\n            purpose_privacy_preference_history.privacy_experience_id\n            == privacy_experience_france_tcf_overlay.id\n        )\n        assert purpose_privacy_preference_history.anonymized_ip_address == masked_ip\n        assert purpose_privacy_preference_history.url_recorded is None\n        assert (\n            purpose_privacy_preference_history.served_notice_history_id\n            == served_notice_history_for_tcf_purpose.id\n        )\n\n        # Assert details saved w.r.t vendor\n\n        vendor_consent_response = response.json()[\"vendor_consent_preferences\"][0]\n        assert vendor_consent_response[\"preference\"] == \"opt_in\"\n        assert vendor_consent_response[\"vendor_consent\"] == \"amplitude\"\n\n        current_vendor_preference = CurrentPrivacyPreference.get(\n            db, object_id=vendor_consent_response[\"id\"]\n        )\n        vendor_privacy_preference_history = (\n            current_vendor_preference.privacy_preference_history\n        )\n        assert vendor_privacy_preference_history.purpose_consent is None\n        assert vendor_privacy_preference_history.privacy_notice_history_id is None\n        assert vendor_privacy_preference_history.feature is None\n\n        fides_user_device_provided_identity = (\n            vendor_privacy_preference_history.fides_user_device_provided_identity\n        )\n        assert (\n            current_purpose_preference.fides_user_device_provided_identity\n            == fides_user_device_provided_identity\n        )\n        assert (\n            fides_user_device_provided_identity.hashed_value\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n        assert (\n            fides_user_device_provided_identity.encrypted_value[\"value\"]\n            == test_device_id\n        )\n        assert (\n            vendor_privacy_preference_history.hashed_fides_user_device\n            == ProvidedIdentity.hash_value(test_device_id)\n        )\n        assert vendor_privacy_preference_history.fides_user_device == test_device_id\n        assert (\n            vendor_privacy_preference_history.vendor_consent\n            == vendor_consent_response[\"vendor_consent\"]\n        )\n\n        assert (\n            vendor_privacy_preference_history.request_origin\n            == RequestOrigin.tcf_overlay\n        )\n        assert vendor_privacy_preference_history.user_agent == \"testclient\"\n        assert (\n            vendor_privacy_preference_history.privacy_experience_config_history_id\n            == experience_config_tcf_overlay.experience_config_history_id\n        )\n        assert (\n            vendor_privacy_preference_history.privacy_experience_id\n            == privacy_experience_france_tcf_overlay.id\n        )\n        assert vendor_privacy_preference_history.anonymized_ip_address == masked_ip\n        assert vendor_privacy_preference_history.url_recorded is None\n        assert vendor_privacy_preference_history.served_notice_history_id is None\n\n        # Privacy request not created for TCF\n        assert purpose_privacy_preference_history.privacy_request_id is None\n        assert vendor_privacy_preference_history.privacy_request_id is None\n        assert not run_privacy_request_mock.called\n\n        # Assert feature portion of the response\n        feature_response = response.json()[\"feature_preferences\"][0]\n        assert feature_response[\"preference\"] == \"opt_out\"\n        assert feature_response[\"feature\"] == 1\n        assert feature_response[\"special_feature\"] is None\n        current_feature_preference = CurrentPrivacyPreference.get(\n            db, object_id=feature_response[\"id\"]\n        )\n        feature_privacy_preference_history = (\n            current_feature_preference.privacy_preference_history\n        )\n        assert current_feature_preference.feature == 1\n        assert feature_privacy_preference_history.feature == 1\n\n        # Assert special feature portion of the response\n        special_feature_response = response.json()[\"special_feature_preferences\"][0]\n        assert special_feature_response[\"preference\"] == \"opt_in\"\n        assert special_feature_response[\"special_feature\"] == 2\n        assert special_feature_response[\"feature\"] is None\n        current_special_feature_preference = CurrentPrivacyPreference.get(\n            db, object_id=special_feature_response[\"id\"]\n        )\n        special_feature_privacy_preference_history = (\n            current_special_feature_preference.privacy_preference_history\n        )\n        assert current_special_feature_preference.special_feature == 2\n        assert special_feature_privacy_preference_history.special_feature == 2\n\n        # Assert system portion of the response\n        system_response = response.json()[\"system_legitimate_interests_preferences\"][0]\n        assert system_response[\"preference\"] == \"opt_out\"\n        assert system_response[\"system_legitimate_interests\"] == system.id\n        current_system_preference = CurrentPrivacyPreference.get(\n            db, object_id=system_response[\"id\"]\n        )\n        system_privacy_preference_history = (\n            current_system_preference.privacy_preference_history\n        )\n        assert current_system_preference.system_legitimate_interests == system.id\n        assert (\n            system_privacy_preference_history.system_legitimate_interests == system.id\n        )\n\n        current_system_preference.delete(db)\n        system_privacy_preference_history.delete(db)\n        current_special_feature_preference.delete(db)\n        special_feature_privacy_preference_history.delete(db)\n        current_feature_preference.delete(db)\n        feature_privacy_preference_history.delete(db)\n        current_purpose_preference.delete(db)\n        purpose_privacy_preference_history.delete(db)\n        current_vendor_preference.delete(db)\n        vendor_privacy_preference_history.delete(db)\n\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.privacy_preference_endpoints.anonymize_ip_address\"\n    )\n    @mock.patch(\n        \"fides.api.service.privacy_request.request_runner_service.run_privacy_request.delay\"\n    )\n    def test_save_privacy_preferences_for_fides_user_device_id_no_notice_has_system_wide_enforcement(\n        self,\n        run_privacy_request_mock,\n        mock_anonymize,\n        db,\n        api_client,\n        url,\n        consent_policy,\n        privacy_notice_fr_provide_service_frontend_only,\n        privacy_experience_france_overlay,\n    ):\n        \"\"\"PrivacyPreferences and CurrentPrivacyPreferences saved for the given fides user device id\n        but no privacy request created to propagate preferences, because all privacy notices\n        have frontend only enforcement\n        \"\"\"\n        masked_ip = \"12.214.31.0\"\n        mock_anonymize.return_value = masked_ip\n\n        request_body = {\n            \"browser_identity\": {\n                \"ga_client_id\": \"test\",\n                \"fides_user_device_id\": \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\",\n            },\n            \"preferences\": [\n                {\n                    \"privacy_notice_history_id\": privacy_notice_fr_provide_service_frontend_only.histories[\n                        0\n                    ].id,\n                    \"preference\": \"opt_out\",\n                }\n            ],\n            \"policy_key\": consent_policy.key,\n            \"user_geography\": \"us_ca\",\n            \"privacy_experience_id\": privacy_experience_france_overlay.id,\n            \"method\": \"button\",\n        }\n\n        response = api_client.patch(\n            url, json=request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 200\n        response_json = response.json()[\"preferences\"][0]\n        assert response_json[\"preference\"] == \"opt_out\"\n        assert (\n            response_json[\"privacy_notice_history\"][\"id\"]\n            == privacy_notice_fr_provide_service_frontend_only.histories[0].id\n        )\n\n        # Fetch current privacy preference that was updated\n        current_preference = CurrentPrivacyPreference.get(\n            db, object_id=response_json[\"id\"]\n        )\n        # Get corresponding historical preference that was just created\n        privacy_preference_history = current_preference.privacy_preference_history\n\n        assert (\n            privacy_preference_history.privacy_request_id is None\n        )  # Privacy request not created\n        assert not run_privacy_request_mock.called  # Privacy Request is not queued\n\n        current_preference.delete(db)\n        privacy_preference_history.delete(db)\n\n\nclass TestHistoricalPreferences:\n    @pytest.fixture(scope=\"function\")\n    def url(self) -> str:\n        return V1_URL_PREFIX + HISTORICAL_PRIVACY_PREFERENCES_REPORT\n\n    def test_get_historical_preferences_not_authenticated(\n        self, api_client: TestClient, url\n    ) -> None:\n        response = api_client.get(url, headers={})\n        assert 401 == response.status_code\n\n    def test_get_historical_preferences_incorrect_scope(\n        self, api_client: TestClient, url, generate_auth_header\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[CONSENT_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert 403 == response.status_code\n\n    @pytest.mark.parametrize(\n        \"role,expected_status\",\n        [\n            (\"owner\", HTTP_200_OK),\n            (\"contributor\", HTTP_200_OK),\n            (\"viewer_and_approver\", HTTP_403_FORBIDDEN),\n            (\"viewer\", HTTP_403_FORBIDDEN),\n            (\"approver\", HTTP_403_FORBIDDEN),\n        ],\n    )\n    def test_get_historical_preferences_roles(\n        self, role, expected_status, api_client: TestClient, url, generate_role_header\n    ) -> None:\n        auth_header = generate_role_header(roles=[role])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == expected_status\n\n    def test_get_historical_preferences(\n        self,\n        db,\n        api_client: TestClient,\n        url,\n        user,\n        generate_auth_header,\n        privacy_preference_history,\n        privacy_request_with_consent_policy,\n        served_notice_history,\n        system,\n        privacy_experience_privacy_center,\n    ) -> None:\n        privacy_preference_history.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.relevant_systems = privacy_preference_history.privacy_notice_history.calculate_relevant_systems(\n            db\n        )\n        privacy_preference_history.save(db)\n\n        privacy_preference_history.update_secondary_user_ids(\n            db, {\"ljt_readerID\": \"preference_history_test\"}\n        )\n        privacy_preference_history.cache_system_status(\n            db, system=system.fides_key, status=ExecutionLogStatus.complete\n        )\n\n        privacy_request_with_consent_policy.reviewed_by = user.id\n        privacy_request_with_consent_policy.save(db)\n\n        auth_header = generate_auth_header(scopes=[PRIVACY_PREFERENCE_HISTORY_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        assert response.json()[\"total\"] == 1\n        assert response.json()[\"page\"] == 1\n        assert response.json()[\"pages\"] == 1\n        assert response.json()[\"size\"] == 50\n\n        response_body = response.json()[\"items\"][0]\n\n        assert response_body[\"id\"] == privacy_preference_history.id\n        assert (\n            response_body[\"privacy_request_id\"]\n            == privacy_request_with_consent_policy.id\n        )\n        assert response_body[\"email\"] == \"test@email.com\"\n        assert response_body[\"phone_number\"] is None\n        assert response_body[\"fides_user_device_id\"] is None\n        assert response_body[\"secondary_user_ids\"] == {\n            \"ljt_readerID\": \"preference_history_test\"\n        }\n        assert response_body[\"request_timestamp\"] is not None\n        assert response_body[\"request_origin\"] == \"privacy_center\"\n        assert response_body[\"request_status\"] == \"in_processing\"\n        assert response_body[\"request_type\"] == \"consent\"\n        assert response_body[\"approver_id\"] == \"test_fidesops_user\"\n        assert (\n            response_body[\"privacy_notice_history_id\"]\n            == privacy_preference_history.privacy_notice_history_id\n        )\n        assert response_body[\"privacy_notice_history_id\"] is not None\n        assert response_body[\"preference\"] == \"opt_out\"\n        assert response_body[\"tcf_version\"] is None\n        assert response_body[\"user_geography\"] == \"us_ca\"\n        assert response_body[\"relevant_systems\"] == [system.fides_key]\n        assert response_body[\"affected_system_status\"] == {system.fides_key: \"complete\"}\n        assert response_body[\"url_recorded\"] == \"https://example.com/privacy_center\"\n        assert (\n            response_body[\"user_agent\"]\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert response_body[\"method\"] == \"button\"\n        assert response_body[\"truncated_ip_address\"] == \"92.158.1.0\"\n        assert (\n            response_body[\"experience_config_history_id\"]\n            == privacy_experience_privacy_center.experience_config.experience_config_history_id\n        )\n        assert (\n            response_body[\"privacy_experience_id\"]\n            == privacy_experience_privacy_center.id\n        )\n        assert response_body[\"served_notice_history_id\"] == served_notice_history.id\n\n    def test_get_historical_preferences_tcf(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history_for_tcf_purpose_consent,\n        served_notice_history_for_tcf_purpose,\n        privacy_experience_france_overlay,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[PRIVACY_PREFERENCE_HISTORY_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        assert response.json()[\"total\"] == 1\n        assert response.json()[\"page\"] == 1\n        assert response.json()[\"size\"] == 50\n\n        response_body = response.json()[\"items\"][0]\n\n        assert (\n            response_body[\"id\"] == privacy_preference_history_for_tcf_purpose_consent.id\n        )\n        assert response_body[\"privacy_request_id\"] is None\n        assert response_body[\"email\"] == \"test@email.com\"\n        assert response_body[\"phone_number\"] is None\n        assert (\n            response_body[\"fides_user_device_id\"]\n            == \"051b219f-20e4-45df-82f7-5eb68a00889f\"\n        )\n        assert response_body[\"purpose_consent\"] == 8\n        assert response_body[\"purpose_legitimate_interests\"] is None\n        assert response_body[\"special_purpose\"] is None\n        assert response_body[\"vendor_consent\"] is None\n        assert response_body[\"vendor_legitimate_interests\"] is None\n        assert response_body[\"system_consent\"] is None\n        assert response_body[\"system_legitimate_interests\"] is None\n        assert response_body[\"feature\"] is None\n        assert response_body[\"special_feature\"] is None\n        assert response_body[\"tcf_version\"] == CURRENT_TCF_VERSION\n\n        assert response_body[\"request_timestamp\"] is not None\n        assert response_body[\"request_origin\"] == \"tcf_overlay\"\n        assert response_body[\"request_status\"] is None\n        assert response_body[\"request_type\"] == \"consent\"\n        assert response_body[\"approver_id\"] is None\n        assert response_body[\"privacy_notice_history_id\"] is None\n        assert response_body[\"preference\"] == \"opt_out\"\n        assert response_body[\"user_geography\"] == \"fr_idg\"\n        assert response_body[\"relevant_systems\"] == []\n        assert response_body[\"affected_system_status\"] == {}\n        assert response_body[\"url_recorded\"] == \"example.com/\"\n        assert (\n            response_body[\"user_agent\"]\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert response_body[\"method\"] == \"button\"\n        assert response_body[\"truncated_ip_address\"] == \"92.158.1.0\"\n        assert response_body[\"experience_config_history_id\"] is None\n        assert (\n            response_body[\"privacy_experience_id\"]\n            == privacy_experience_france_overlay.id\n        )\n        assert (\n            response_body[\"served_notice_history_id\"]\n            == served_notice_history_for_tcf_purpose.id\n        )\n\n    def test_get_historical_preferences_saved_for_system(\n        self,\n        generate_auth_header,\n        api_client,\n        url,\n        privacy_preference_history_for_system,\n    ):\n        auth_header = generate_auth_header(scopes=[PRIVACY_PREFERENCE_HISTORY_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        assert (\n            response.json()[\"items\"][0][\"system_consent\"]\n            == privacy_preference_history_for_system.system_consent\n        )\n        assert (\n            response.json()[\"items\"][0][\"preference\"]\n            == privacy_preference_history_for_system.preference.value\n        )\n\n    def test_get_historical_preferences_user_geography_unsupported(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ) -> None:\n        \"\"\"Just verifying it's fine if the user geography is not an official privacy notice region\"\"\"\n\n        auth_header = generate_auth_header(scopes=[PRIVACY_PREFERENCE_HISTORY_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        assert response.json()[\"total\"] == 1\n        assert response.json()[\"page\"] == 1\n        assert response.json()[\"pages\"] == 1\n        assert response.json()[\"size\"] == 50\n\n        response_body = response.json()[\"items\"][0]\n\n        assert (\n            response_body[\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.id\n        )\n        assert response_body[\"user_geography\"] == \"fr_idg\"\n\n    def test_get_historical_preferences_ordering(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history,\n        privacy_preference_history_us_ca_provide,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[PRIVACY_PREFERENCE_HISTORY_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 3\n        assert response.json()[\"total\"] == 3\n        assert response.json()[\"page\"] == 1\n        assert response.json()[\"pages\"] == 1\n        assert response.json()[\"size\"] == 50\n\n        response_body = response.json()[\"items\"]\n\n        # Records ordered most recently created first\n        assert (\n            response_body[0][\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.id\n        )\n        assert response_body[1][\"id\"] == privacy_preference_history_us_ca_provide.id\n        assert response_body[2][\"id\"] == privacy_preference_history.id\n\n    def test_get_historical_preferences_date_filtering(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history,\n        privacy_preference_history_us_ca_provide,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[PRIVACY_PREFERENCE_HISTORY_READ])\n\n        # Filter for everything created before the first preference\n        response = api_client.get(\n            url\n            + f\"?request_timestamp_lt={privacy_preference_history.created_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"items\"] == []\n\n        # Filter for everything created before the last preference plus an hour\n        response = api_client.get(\n            url\n            + f\"?request_timestamp_lt={(privacy_preference_history_fr_provide_service_frontend_only.created_at + timedelta(hours=1)).strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"total\"] == 3\n\n        assert (\n            response.json()[\"items\"][0][\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.id\n        )\n        assert (\n            response.json()[\"items\"][1][\"id\"]\n            == privacy_preference_history_us_ca_provide.id\n        )\n        assert response.json()[\"items\"][2][\"id\"] == privacy_preference_history.id\n\n        # Filter for everything created after the first preference\n        response = api_client.get(\n            url\n            + f\"?request_timestamp_gt={privacy_preference_history.created_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"total\"] == 2\n        assert (\n            response.json()[\"items\"][0][\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.id\n        )\n        assert (\n            response.json()[\"items\"][1][\"id\"]\n            == privacy_preference_history_us_ca_provide.id\n        )\n\n        # Invalid filter\n        response = api_client.get(\n            url\n            + f\"?request_timestamp_lt={privacy_preference_history.created_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}&request_timestamp_gt={privacy_preference_history_fr_provide_service_frontend_only.created_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 400\n        assert \"Value specified for request_timestamp_lt\" in response.json()[\"detail\"]\n        assert \"must be after request_timestamp_gt\" in response.json()[\"detail\"]\n\n\nclass TestCurrentPrivacyPreferences:\n    @pytest.fixture(scope=\"function\")\n    def url(self) -> str:\n        return V1_URL_PREFIX + CURRENT_PRIVACY_PREFERENCES_REPORT\n\n    def test_get_current_preferences_not_authenticated(\n        self, api_client: TestClient, url\n    ) -> None:\n        response = api_client.get(url, headers={})\n        assert 401 == response.status_code\n\n    def test_get_current_preferences_incorrect_scope(\n        self, api_client: TestClient, url, generate_auth_header\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[CONSENT_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert 403 == response.status_code\n\n    def test_get_current_preferences_report_with_tcf(\n        self,\n        generate_auth_header,\n        privacy_preference_history_for_tcf_purpose_consent,\n        api_client,\n        url,\n    ):\n        auth_header = generate_auth_header(scopes=[CURRENT_PRIVACY_PREFERENCE_READ])\n\n        response = api_client.get(url, headers=auth_header)\n\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        data = response.json()[\"items\"][0]\n        assert (\n            data[\"preference\"]\n            == privacy_preference_history_for_tcf_purpose_consent.preference.value\n        )\n        assert data[\"purpose_consent\"] == 8\n        assert (\n            data[\"id\"]\n            == privacy_preference_history_for_tcf_purpose_consent.current_privacy_preference.id\n        )\n\n    @pytest.mark.parametrize(\n        \"role,expected_status\",\n        [\n            (\"owner\", HTTP_200_OK),\n            (\"contributor\", HTTP_200_OK),\n            (\"viewer_and_approver\", HTTP_403_FORBIDDEN),\n            (\"viewer\", HTTP_403_FORBIDDEN),\n            (\"approver\", HTTP_403_FORBIDDEN),\n        ],\n    )\n    def test_get_current_preferences_roles(\n        self, role, expected_status, api_client: TestClient, url, generate_role_header\n    ) -> None:\n        auth_header = generate_role_header(roles=[role])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == expected_status\n\n    def test_get_current_preferences(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history,\n    ) -> None:\n        current_preference = privacy_preference_history.current_privacy_preference\n\n        auth_header = generate_auth_header(scopes=[CURRENT_PRIVACY_PREFERENCE_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 1\n        assert response.json()[\"total\"] == 1\n        assert response.json()[\"page\"] == 1\n        assert response.json()[\"pages\"] == 1\n        assert response.json()[\"size\"] == 50\n\n        response_body = response.json()[\"items\"][0]\n\n        assert response_body[\"id\"] == current_preference.id\n        assert response_body[\"preference\"] == current_preference.preference.value\n        assert (\n            response_body[\"privacy_notice_history_id\"]\n            == current_preference.privacy_notice_history.id\n        )\n        assert (\n            response_body[\"provided_identity_id\"]\n            == privacy_preference_history.provided_identity.id\n        )\n        assert response_body[\"created_at\"] is not None\n\n    def test_get_current_preference_ordering(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history,\n        privacy_preference_history_us_ca_provide,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[CURRENT_PRIVACY_PREFERENCE_READ])\n        response = api_client.get(url, headers=auth_header)\n        assert response.status_code == 200\n        assert len(response.json()[\"items\"]) == 3\n        assert response.json()[\"total\"] == 3\n        assert response.json()[\"page\"] == 1\n        assert response.json()[\"pages\"] == 1\n        assert response.json()[\"size\"] == 50\n\n        response_body = response.json()[\"items\"]\n\n        # Records ordered most recently created first\n        assert (\n            response_body[0][\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.current_privacy_preference.id\n        )\n        assert (\n            response_body[1][\"id\"]\n            == privacy_preference_history_us_ca_provide.current_privacy_preference.id\n        )\n        assert (\n            response_body[2][\"id\"]\n            == privacy_preference_history.current_privacy_preference.id\n        )\n\n    def test_get_current_preferences_date_filtering(\n        self,\n        api_client: TestClient,\n        url,\n        generate_auth_header,\n        privacy_preference_history,\n        privacy_preference_history_us_ca_provide,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[CURRENT_PRIVACY_PREFERENCE_READ])\n\n        # Filter for everything updated before the first preference\n        response = api_client.get(\n            url\n            + f\"?updated_lt={privacy_preference_history.current_privacy_preference.updated_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"items\"] == []\n\n        # Filter for everything updated before the last preference plus an hour\n        response = api_client.get(\n            url\n            + f\"?updated_lt={(privacy_preference_history_fr_provide_service_frontend_only.current_privacy_preference.updated_at + timedelta(hours=1)).strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"total\"] == 3\n\n        assert (\n            response.json()[\"items\"][0][\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.current_privacy_preference.id\n        )\n        assert (\n            response.json()[\"items\"][1][\"id\"]\n            == privacy_preference_history_us_ca_provide.current_privacy_preference.id\n        )\n        assert (\n            response.json()[\"items\"][2][\"id\"]\n            == privacy_preference_history.current_privacy_preference.id\n        )\n\n        # Filter for everything updated after the first preference\n        response = api_client.get(\n            url\n            + f\"?updated_gt={privacy_preference_history.current_privacy_preference.updated_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 200\n        assert response.json()[\"total\"] == 2\n        assert (\n            response.json()[\"items\"][0][\"id\"]\n            == privacy_preference_history_fr_provide_service_frontend_only.current_privacy_preference.id\n        )\n        assert (\n            response.json()[\"items\"][1][\"id\"]\n            == privacy_preference_history_us_ca_provide.current_privacy_preference.id\n        )\n\n        # Invalid filter\n        response = api_client.get(\n            url\n            + f\"?updated_lt={privacy_preference_history.current_privacy_preference.updated_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}&updated_gt={privacy_preference_history_fr_provide_service_frontend_only.current_privacy_preference.created_at.strftime('%Y-%m-%dT%H:%M:%S.%f')}\",\n            headers=auth_header,\n        )\n        assert response.status_code == 400\n        assert \"Value specified for updated_lt\" in response.json()[\"detail\"]\n        assert \"must be after updated_gt\" in response.json()[\"detail\"]\n\n\nclass TestSavePrivacyPreferencesTCStringOnly:\n    @pytest.fixture(scope=\"function\")\n    def url(self) -> str:\n        return V1_URL_PREFIX + PRIVACY_PREFERENCES\n\n    @pytest.mark.usefixtures(\"enable_tcf\")\n    def test_save_privacy_preferences_tc_string_section_overlaps_request_body_section(\n        self, api_client, url\n    ):\n        tc_string: str = \"CPzEX8APzEX8AAMABBENAUEEAPLAAAAAAAAAABEAAAAA.IABE\"\n        fides_user_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n\n        minimal_request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": fides_user_device_id,\n            },\n            \"fides_string\": tc_string,\n            \"purpose_consent_preferences\": [{\"id\": 1, \"preference\": \"opt_out\"}],\n        }\n        response = api_client.patch(\n            url, json=minimal_request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 422\n        assert (\n            response.json()[\"detail\"][0][\"msg\"]\n            == \"Cannot supply value for 'purpose_consent_preferences' and 'fides_string' simultaneously when saving privacy preferences.\"\n        )\n\n    def test_save_privacy_preferences_bad_tc_string(self, api_client, url):\n        tc_string: str = \"bad_string\"\n        fides_user_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n\n        minimal_request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": fides_user_device_id,\n            },\n            \"fides_string\": tc_string,\n        }\n        response = api_client.patch(\n            url, json=minimal_request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 400\n        assert response.json()[\"detail\"] == \"Invalid base64-encoded TC string\"\n\n    @pytest.mark.usefixtures(\"enable_tcf\")\n    def test_save_privacy_preferences_with_tc_string_when_datamap_empty(\n        self, api_client, url\n    ):\n        tc_string: str = \"CPzEX8APzEX8AAMABBENAUEEAPLAAAAAAAAAABEAAAAA.IABE\"\n        fides_user_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n\n        minimal_request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": fides_user_device_id,\n            },\n            \"fides_string\": tc_string,\n        }\n        response = api_client.patch(\n            url, json=minimal_request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 200\n        response_body = response.json()[\"preferences\"]\n\n        # Nothing in the datamap so we didn't save anything here.\n        assert len(response_body) == 0\n\n    def test_save_privacy_preferences_when_tcf_disabled(self, api_client, url):\n        tc_string: str = \"CPzEX8APzEX8AAMABBENAUEEAPLAAAAAAAAAABEAAAAA.IABE\"\n        fides_user_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n\n        minimal_request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": fides_user_device_id,\n            },\n            \"fides_string\": tc_string,\n        }\n        response = api_client.patch(\n            url, json=minimal_request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 200\n        response_body = response.json()[\"preferences\"]\n\n        # Nothing saved because TCF is disabled\n        assert len(response_body) == 0\n\n    @pytest.mark.usefixtures(\n        \"skimbit_system\", \"emerse_system\", \"captify_technologies_system\", \"enable_tcf\"\n    )\n    def test_save_privacy_preferences_with_tc_string(self, api_client, url, db):\n        tc_string: str = \"CPzEX8APzEX8AAMABBENAUEEAPLAAAAAAAAAABEAAAAA.IABE\"\n        fides_user_device_id = \"e4e573ba-d806-4e54-bdd8-3d2ff11d4f11\"\n\n        minimal_request_body = {\n            \"browser_identity\": {\n                \"fides_user_device_id\": fides_user_device_id,\n            },\n            \"fides_string\": tc_string,\n        }\n        response = api_client.patch(\n            url, json=minimal_request_body, headers={\"Origin\": \"http://localhost:8080\"}\n        )\n        assert response.status_code == 200\n        response_body = response.json()\n\n        assert len(response_body[\"preferences\"]) == 0\n        assert len(response_body[\"purpose_consent_preferences\"]) == 7\n        assert len(response_body[\"purpose_legitimate_interests_preferences\"]) == 5\n        assert len(response_body[\"special_purpose_preferences\"]) == 0\n        assert len(response_body[\"vendor_consent_preferences\"]) == 2\n        assert len(response_body[\"vendor_legitimate_interests_preferences\"]) == 2\n        assert len(response_body[\"feature_preferences\"]) == 0\n        assert len(response_body[\"special_feature_preferences\"]) == 1\n        assert len(response_body[\"system_consent_preferences\"]) == 0\n        assert len(response_body[\"system_legitimate_interests_preferences\"]) == 0\n\n        first_purpose_consent_record = response_body[\"purpose_consent_preferences\"][0]\n        assert first_purpose_consent_record[\"purpose_consent\"] == 1\n        assert first_purpose_consent_record[\"preference\"] == \"opt_in\"\n        saved_current_privacy_preference_record = db.query(\n            CurrentPrivacyPreference\n        ).get(first_purpose_consent_record[\"id\"])\n        assert saved_current_privacy_preference_record.purpose_consent == 1\n        assert (\n            saved_current_privacy_preference_record.preference\n            == UserConsentPreference.opt_in\n        )\n\n        privacy_preference_history_record = db.query(PrivacyPreferenceHistory).get(\n            first_purpose_consent_record[\"privacy_preference_history_id\"]\n        )\n        assert (\n            privacy_preference_history_record.current_privacy_preference\n            == saved_current_privacy_preference_record\n        )\n\n        assert (\n            privacy_preference_history_record.fides_user_device == fides_user_device_id\n        )\n        assert (\n            privacy_preference_history_record.fides_user_device_provided_identity\n            is not None\n        )\n        assert (\n            privacy_preference_history_record.fides_user_device_provided_identity\n            == saved_current_privacy_preference_record.fides_user_device_provided_identity\n        )\n\n        assert (\n            privacy_preference_history_record.privacy_experience_id is None\n        )  # Not required in request body\n        assert (\n            privacy_preference_history_record.privacy_experience_config_history_id\n            is None\n        )\n\n        # There were no purpose legitimate interests in the string, but purpose 2 was disclosed\n        # to the user in the experience.  We opt out here.\n        first_purpose_li_record = response_body[\n            \"purpose_legitimate_interests_preferences\"\n        ][0]\n        assert first_purpose_li_record[\"purpose_legitimate_interests\"] == 2\n        assert first_purpose_li_record[\"preference\"] == \"opt_out\"\n        saved_current_privacy_preference_record = db.query(\n            CurrentPrivacyPreference\n        ).get(first_purpose_li_record[\"id\"])\n        assert saved_current_privacy_preference_record.purpose_legitimate_interests == 2\n        assert (\n            saved_current_privacy_preference_record.preference\n            == UserConsentPreference.opt_out\n        )\n\n        # Vendor 2 was in the vendor consents section\n        first_vendor_consent_record = response_body[\"vendor_consent_preferences\"][0]\n        assert first_vendor_consent_record[\"vendor_consent\"] == \"gvl.2\"\n        assert first_vendor_consent_record[\"preference\"] == \"opt_in\"\n        saved_current_privacy_preference_record = db.query(\n            CurrentPrivacyPreference\n        ).get(first_vendor_consent_record[\"id\"])\n        assert saved_current_privacy_preference_record.vendor_consent == \"gvl.2\"\n        assert (\n            saved_current_privacy_preference_record.preference\n            == UserConsentPreference.opt_in\n        )\n\n        # Vendor 8 was not opted in in the vendor consents section, but was disclosed to the\n        # customer in the vendor consents section, so we opt out.\n        second_vendor_consent_record = response_body[\"vendor_consent_preferences\"][1]\n        assert second_vendor_consent_record[\"vendor_consent\"] == \"gvl.8\"\n        assert second_vendor_consent_record[\"preference\"] == \"opt_out\"\n        saved_current_privacy_preference_record = db.query(\n            CurrentPrivacyPreference\n        ).get(second_vendor_consent_record[\"id\"])\n        assert saved_current_privacy_preference_record.vendor_consent == \"gvl.8\"\n        assert (\n            saved_current_privacy_preference_record.preference\n            == UserConsentPreference.opt_out\n        )\n\n        special_feature_record = response_body[\"special_feature_preferences\"][0]\n        assert special_feature_record[\"special_feature\"] == 2\n        assert special_feature_record[\"preference\"] == \"opt_in\"\n        saved_current_privacy_preference_record = db.query(\n            CurrentPrivacyPreference\n        ).get(special_feature_record[\"id\"])\n        assert saved_current_privacy_preference_record.special_feature == 2\n        assert (\n            saved_current_privacy_preference_record.preference\n            == UserConsentPreference.opt_in\n        )\n\n        mobile_data = response.json()[\"fides_mobile_data\"]\n        assert mobile_data == {\n            \"IABTCF_CmpSdkID\": 12,\n            \"IABTCF_CmpSdkVersion\": 1,\n            \"IABTCF_PolicyVersion\": 4,\n            \"IABTCF_gdprApplies\": 1,\n            \"IABTCF_PublisherCC\": \"AA\",\n            \"IABTCF_PurposeOneTreatment\": 0,\n            \"IABTCF_UseNonStandardTexts\": 0,\n            \"IABTCF_TCString\": \"CPzEX8APzEX8AAMABBENAUEEAPLAAAAAAAAAABEAAAAA.IABE\",\n            \"IABTCF_VendorConsents\": \"01\",\n            \"IABTCF_VendorLegitimateInterests\": \"\",\n            \"IABTCF_PurposeConsents\": \"111100101100000000000000\",\n            \"IABTCF_PurposeLegitimateInterests\": \"000000000000000000000000\",\n            \"IABTCF_SpecialFeaturesOptIns\": \"010000000000\",\n            \"IABTCF_PublisherConsent\": None,\n            \"IABTCF_PublisherLegitimateInterests\": None,\n            \"IABTCF_PublisherCustomPurposesConsents\": None,\n            \"IABTCF_PublisherCustomPurposesLegitimateInterests\": None,\n            \"IABTCF_AddtlConsent\": None,\n        }\n", "import pytest\nfrom fideslang.gvl import MAPPED_PURPOSES, MAPPED_SPECIAL_PURPOSES\nfrom sqlalchemy.exc import IntegrityError\n\nfrom fides.api.api.deps import get_api_session\nfrom fides.api.models.privacy_experience import (\n    BannerEnabled,\n    ComponentType,\n    PrivacyExperience,\n    PrivacyExperienceConfig,\n    PrivacyExperienceConfigHistory,\n    cache_saved_and_served_on_consent_record,\n    upsert_privacy_experiences_after_config_update,\n    upsert_privacy_experiences_after_notice_update,\n)\nfrom fides.api.models.privacy_notice import (\n    ConsentMechanism,\n    EnforcementLevel,\n    PrivacyNotice,\n    PrivacyNoticeRegion,\n    UserConsentPreference,\n)\nfrom fides.api.models.privacy_preference import ConsentRecordType\nfrom fides.api.schemas.tcf import (\n    TCFFeatureRecord,\n    TCFPurposeConsentRecord,\n    TCFPurposeLegitimateInterestsRecord,\n    TCFSpecialPurposeRecord,\n    TCFVendorConsentRecord,\n    TCFVendorLegitimateInterestsRecord,\n    TCFVendorRelationships,\n)\n\n\nclass TestExperienceConfig:\n    def test_create_privacy_experience_config(self, db):\n        \"\"\"Assert PrivacyExperienceConfig and its historical record are created\n        Note that the PrivacyExperienceConfig doesn't have regions specifically linked to it here.\n        \"\"\"\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"accept_button_label\": \"Accept all\",\n                \"acknowledge_button_label\": \"OK\",\n                \"banner_enabled\": \"enabled_where_required\",\n                \"component\": \"overlay\",\n                \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n                \"privacy_preferences_link_label\": \"Manage preferences\",\n                \"privacy_policy_link_label\": \"View our privacy policy\",\n                \"privacy_policy_url\": \"http://example.com/privacy\",\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n\n        assert config.accept_button_label == \"Accept all\"\n        assert config.acknowledge_button_label == \"OK\"\n        assert config.banner_enabled == BannerEnabled.enabled_where_required\n        assert config.component == ComponentType.overlay\n        assert (\n            config.description\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert config.disabled is False\n        assert config.is_default is False\n        assert config.privacy_preferences_link_label == \"Manage preferences\"\n        assert config.privacy_policy_link_label == \"View our privacy policy\"\n        assert config.privacy_policy_url == \"http://example.com/privacy\"\n        assert config.reject_button_label == \"Reject all\"\n        assert config.save_button_label == \"Save\"\n        assert config.title == \"Control your privacy\"\n\n        assert config.version == 1.0\n        assert config.histories.count() == 1\n        assert config.experiences.count() == 0\n        assert config.regions == []\n\n        history = config.histories[0]\n        assert config.experience_config_history_id == history.id\n\n        assert history.accept_button_label == \"Accept all\"\n        assert history.acknowledge_button_label == \"OK\"\n        assert history.banner_enabled == BannerEnabled.enabled_where_required\n        assert history.component == ComponentType.overlay\n        assert (\n            history.description\n            == \"We care about your privacy. Opt in and opt out of the data use cases below.\"\n        )\n        assert history.disabled is False\n        assert history.is_default is False\n        assert history.privacy_preferences_link_label == \"Manage preferences\"\n        assert history.privacy_policy_link_label == \"View our privacy policy\"\n        assert history.privacy_policy_url == \"http://example.com/privacy\"\n        assert history.reject_button_label == \"Reject all\"\n        assert history.save_button_label == \"Save\"\n        assert history.title == \"Control your privacy\"\n        assert history.version == 1.0\n\n        history.delete(db)\n        config.delete(db=db)\n\n    def test_update_privacy_experience_config(self, db):\n        \"\"\"Assert if PrivacyExperienceConfig is updated, its version is bumped and a new historical record is created\"\"\"\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"accept_button_label\": \"Accept all\",\n                \"acknowledge_button_label\": \"OK\",\n                \"banner_enabled\": \"enabled_where_required\",\n                \"component\": \"overlay\",\n                \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n                \"privacy_preferences_link_label\": \"Manage preferences\",\n                \"privacy_policy_link_label\": \"View our privacy policy\",\n                \"privacy_policy_url\": \"http://example.com/privacy\",\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n        config_created_at = config.created_at\n        config_updated_at = config.updated_at\n\n        config.update(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n            },\n        )\n        db.refresh(config)\n\n        assert config.component == ComponentType.privacy_center\n        assert config.version == 2.0\n        assert config.id is not None\n        assert config.created_at == config_created_at\n        assert config.updated_at > config_updated_at\n\n        assert config.histories.count() == 2\n        history = config.histories.order_by(PrivacyExperienceConfigHistory.created_at)[\n            1\n        ]\n        assert history.component == ComponentType.privacy_center\n        assert config.experience_config_history_id == history.id\n\n        old_history = config.histories.order_by(\n            PrivacyExperienceConfigHistory.created_at\n        )[0]\n        assert old_history.version == 1.0\n        assert old_history.component == ComponentType.overlay\n\n        old_history.delete(db)\n        history.delete(db)\n\n\nclass TestPrivacyExperience:\n    def test_get_experiences_by_region(self, db):\n        \"\"\"Test PrivacyExperience.get_experiences_by_region method\"\"\"\n        (\n            queried_overlay_exp,\n            queried_pc_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_tx\n        )\n        assert queried_overlay_exp is None\n        assert queried_pc_exp is None\n\n        overlay_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"overlay\",\n                \"region\": \"us_tx\",\n            },\n        )\n\n        (\n            queried_overlay_exp,\n            queried_pc_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_tx\n        )\n        assert queried_overlay_exp == overlay_exp\n        assert queried_pc_exp is None\n\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"us_tx\",\n            },\n        )\n\n        (\n            queried_overlay_exp,\n            queried_pc_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_tx\n        )\n        assert queried_overlay_exp == overlay_exp\n        assert queried_pc_exp == pc_exp\n\n        overlay_exp.delete(db)\n        pc_exp.delete(db)\n\n    def test_get_experience_by_component_and_region(self, db):\n        \"\"\"Test PrivacyExperience.get_experience_by_region_and_component method\"\"\"\n        assert (\n            PrivacyExperience.get_experience_by_region_and_component(\n                db, PrivacyNoticeRegion.at, ComponentType.overlay\n            )\n            is None\n        )\n\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"at\",\n            },\n        )\n\n        assert (\n            PrivacyExperience.get_experience_by_region_and_component(\n                db, PrivacyNoticeRegion.at, ComponentType.overlay\n            )\n            is None\n        )\n        assert (\n            PrivacyExperience.get_experience_by_region_and_component(\n                db, PrivacyNoticeRegion.at, ComponentType.privacy_center\n            )\n            == pc_exp\n        )\n\n        db.delete(pc_exp)\n\n    def test_unlink_privacy_experience_config(\n        self, db, experience_config_privacy_center\n    ):\n        \"\"\"\n        Test Experience.unlink_experience_config unlinks the experience\n        \"\"\"\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"at\",\n                \"experience_config_id\": experience_config_privacy_center.id,\n            },\n        )\n        created_at = pc_exp.created_at\n        updated_at = pc_exp.updated_at\n\n        assert pc_exp.experience_config == experience_config_privacy_center\n        pc_exp.unlink_experience_config(db)\n        db.refresh(pc_exp)\n\n        assert pc_exp.experience_config_id is None\n        assert pc_exp.created_at == created_at\n        assert pc_exp.updated_at > updated_at\n\n        pc_exp.delete(db)\n\n    def test_link_default_experience_config(self, db, experience_config_privacy_center):\n        \"\"\"\n        Test Experience.link_default_experience_config points the experience towards the default config\n        \"\"\"\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"at\",\n                \"experience_config_id\": experience_config_privacy_center.id,\n            },\n        )\n        created_at = pc_exp.created_at\n        updated_at = pc_exp.updated_at\n\n        assert pc_exp.experience_config == experience_config_privacy_center\n        pc_exp.link_default_experience_config(db)\n        db.refresh(pc_exp)\n\n        assert pc_exp.experience_config_id is not None\n        assert pc_exp.experience_config_id == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n        assert pc_exp.created_at == created_at\n        assert pc_exp.updated_at > updated_at\n\n        pc_exp.delete(db)\n\n    def test_create_privacy_experience(self, db):\n        \"\"\"Assert PrivacyExperience is created as expected\"\"\"\n        exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"overlay\",\n                \"region\": \"us_tx\",\n            },\n        )\n\n        assert exp.component == ComponentType.overlay\n        assert exp.region == PrivacyNoticeRegion.us_tx\n        assert exp.experience_config_id is None\n\n        exp.delete(db=db)\n\n    def test_update_privacy_experience(self, db, experience_config_overlay):\n        \"\"\"Assert PrivacyExperience is updated as expected\"\"\"\n        exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"overlay\",\n                \"region\": \"us_ca\",\n            },\n        )\n        exp_created_at = exp.created_at\n        exp_updated_at = exp.updated_at\n        assert exp.experience_config is None\n\n        exp.update(\n            db=db,\n            data={\n                \"experience_config_id\": experience_config_overlay.id,\n            },\n        )\n        db.refresh(exp)\n\n        assert exp.component == ComponentType.overlay\n        assert exp.region == PrivacyNoticeRegion.us_ca\n        assert exp.experience_config == experience_config_overlay\n        assert exp.id is not None\n        assert exp.created_at == exp_created_at\n        assert exp.updated_at > exp_updated_at\n\n        exp.delete(db)\n\n    def test_get_related_privacy_notices(self, db, system):\n        \"\"\"Test PrivacyExperience.get_related_privacy_notices that are embedded in PrivacyExperience request\"\"\"\n        privacy_experience = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": \"it\",\n            },\n        )\n\n        # No privacy notices exist\n        assert privacy_experience.get_related_privacy_notices(db) == []\n\n        privacy_notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"Test privacy notice\",\n                \"notice_key\": \"test_privacy_notice\",\n                \"description\": \"a test sample privacy notice configuration\",\n                \"regions\": [PrivacyNoticeRegion.fr, PrivacyNoticeRegion.it],\n                \"consent_mechanism\": ConsentMechanism.opt_in,\n                \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_overlay\": False,\n                \"displayed_in_api\": True,\n                \"displayed_in_privacy_center\": True,\n            },\n        )\n\n        # Privacy Notice has a matching region, but is not displayed in overlay\n        assert privacy_experience.get_related_privacy_notices(db) == []\n\n        privacy_notice.displayed_in_overlay = True\n        privacy_notice.save(db)\n\n        # Privacy Notice both has a matching region and is displayed in overlay\n        assert privacy_experience.get_related_privacy_notices(db) == [privacy_notice]\n\n        privacy_notice.regions = [\"us_ca\"]\n        privacy_notice.save(db)\n        # While privacy notice is displayed in the overlay, it doesn't have a matching region\n        assert privacy_experience.get_related_privacy_notices(db) == []\n\n        privacy_notice.regions = [\"it\"]\n        privacy_notice.save(db)\n        privacy_notice.disabled = True\n        privacy_notice.save(db)\n\n        assert privacy_experience.get_related_privacy_notices(db) == [privacy_notice]\n        # Disabled show by default but if show_disable is False, they're unlinked.\n        assert (\n            privacy_experience.get_related_privacy_notices(db, show_disabled=False)\n            == []\n        )\n\n        # Privacy notice is applicable to a system - they share a data use\n        assert privacy_experience.get_related_privacy_notices(\n            db, systems_applicable=True\n        ) == [privacy_notice]\n\n        system.privacy_declarations[0].delete(db)\n        db.refresh(system)\n\n        # Privacy notice is no longer applicable to any systems\n        assert (\n            privacy_experience.get_related_privacy_notices(db, systems_applicable=True)\n            == []\n        )\n\n        privacy_notice.histories[0].delete(db)\n        privacy_notice.delete(db)\n\n    def test_get_related_privacy_notices_for_a_tcf_overlay(\n        self, db, privacy_experience_france_tcf_overlay\n    ):\n        \"\"\"Just returns an empty list; Privacy Notices are not relevant here\"\"\"\n        assert (\n            privacy_experience_france_tcf_overlay.get_related_privacy_notices(db) == []\n        )\n\n    def test_get_should_show_banner(self, db):\n        \"\"\"Test PrivacyExperience.get_should_show_banner that is calculated at runtime\"\"\"\n        privacy_experience = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": ComponentType.privacy_center,\n                \"region\": \"it\",\n            },\n        )\n\n        # This is a privacy center component so whether we should show the banner is not relevant here\n        assert privacy_experience.get_should_show_banner(db) is False\n\n        privacy_experience.component = ComponentType.overlay\n        privacy_experience.save(db)\n\n        # This is an overlay component but there are no relevant notices here either\n        assert privacy_experience.get_should_show_banner(db) is False\n\n        privacy_notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"Test privacy notice\",\n                \"notice_key\": \"test_privacy_notice\",\n                \"description\": \"a test sample privacy notice configuration\",\n                \"regions\": [PrivacyNoticeRegion.fr, PrivacyNoticeRegion.it],\n                \"consent_mechanism\": ConsentMechanism.opt_out,\n                \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_overlay\": False,\n                \"displayed_in_api\": True,\n                \"displayed_in_privacy_center\": True,\n            },\n        )\n\n        # Privacy Notice has a matching region, but is not displayed in overlay, so it's\n        # not relevant here\n        assert privacy_experience.get_should_show_banner(db) is False\n\n        privacy_notice.displayed_in_overlay = True\n        privacy_notice.save(db)\n\n        # Privacy Notice both has a matching region and is displayed in overlay and is opt_out, so not required\n        assert privacy_experience.get_should_show_banner(db) is False\n\n        privacy_notice.consent_mechanism = ConsentMechanism.opt_in\n        privacy_notice.save(db)\n\n        # Relevant privacy notice is opt in, so it should be delivered in a banner\n        assert privacy_experience.get_should_show_banner(db) is True\n\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"accept_button_label\": \"Accept all\",\n                \"acknowledge_button_label\": \"OK\",\n                \"banner_enabled\": \"always_enabled\",\n                \"component\": \"overlay\",\n                \"description\": \"We care about your privacy. Opt in and opt out of the data use cases below.\",\n                \"privacy_preferences_link_label\": \"Manage preferences\",\n                \"privacy_policy_link_label\": \"View our privacy policy\",\n                \"privacy_policy_url\": \"http://example.com/privacy\",\n                \"reject_button_label\": \"Reject all\",\n                \"save_button_label\": \"Save\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n\n        # Link experience config\n        privacy_experience.experience_config_id = config.id\n        privacy_experience.save(db)\n\n        # Remove notices\n        privacy_notice.histories[0].delete(db)\n        privacy_notice.delete(db)\n\n        # Banner delivery required because experience config says that banner is always enabled\n        assert privacy_experience.get_should_show_banner(db) is True\n\n        config.banner_enabled = BannerEnabled.always_disabled\n        config.save(db)\n\n        # Banner delivery not required because config says that banner should be always disabled\n        assert privacy_experience.get_should_show_banner(db) is False\n\n    def test_get_should_show_banner_for_a_tcf_overlay(\n        self, privacy_experience_france_tcf_overlay, db\n    ):\n        \"\"\"Currently, this returns true if the experience is a TCF Overlay type\"\"\"\n        assert privacy_experience_france_tcf_overlay.get_should_show_banner(db) is True\n\n    @pytest.mark.usefixtures(\"privacy_preference_history_us_ca_provide\")\n    def test_get_related_notices_no_privacy_preference_for_fides_user_device_id(\n        self,\n        db,\n        privacy_notice_us_ca_provide,\n        fides_user_provided_identity,\n    ):\n        \"\"\"Test fides_user_provided_identity argument for get_related_privacy_notices when the\n        user does not have saved preferences.\n\n        By default, we still return the notices, we just don't surface current or outdated preferences for the\n        user because none exist.\n        \"\"\"\n        privacy_experience = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": \"us_ca\",\n            },\n        )\n\n        notices = privacy_experience.get_related_privacy_notices(db)\n        assert notices == [privacy_notice_us_ca_provide]\n        # No preference here, because no user passed in.\n        assert notices[0].default_preference == UserConsentPreference.opt_out\n        assert notices[0].current_preference is None\n        assert notices[0].outdated_preference is None\n\n        notices = privacy_experience.get_related_privacy_notices(\n            db, fides_user_provided_identity=fides_user_provided_identity\n        )\n        assert notices == [privacy_notice_us_ca_provide]\n        # User has no preferences saved for this notice\n        assert notices[0].default_preference == UserConsentPreference.opt_out\n        assert notices[0].current_preference is None\n        assert notices[0].outdated_preference is None\n\n    def test_get_related_privacy_notices_with_fides_user_device_id_preferences(\n        self,\n        db,\n        privacy_notice_us_ca_provide,\n        privacy_preference_history_us_ca_provide_for_fides_user,\n        fides_user_provided_identity,\n    ):\n        \"\"\"Test fides user device id argument to Experience.get_related_privacy_notices adds the user's\n        preferences if they exist.  If the user's preferences correspond to an older version, that\n        will go under \"outdated\" preference.\n        \"\"\"\n        privacy_experience = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": ComponentType.overlay,\n                \"region\": \"us_ca\",\n            },\n        )\n\n        notices = privacy_experience.get_related_privacy_notices(db)\n        assert notices == [privacy_notice_us_ca_provide]\n        # No preference here, because no user passed in.\n        assert notices[0].current_preference is None\n        assert notices[0].outdated_preference is None\n\n        current_saved_preference = (\n            privacy_preference_history_us_ca_provide_for_fides_user.current_privacy_preference\n        )\n        assert current_saved_preference.preference == UserConsentPreference.opt_in\n\n        # Current preference returned for given user\n        notices = privacy_experience.get_related_privacy_notices(\n            db, fides_user_provided_identity=fides_user_provided_identity\n        )\n        assert notices == [privacy_notice_us_ca_provide]\n        assert notices[0].default_preference == UserConsentPreference.opt_out\n        assert notices[0].current_preference == UserConsentPreference.opt_in\n        assert notices[0].outdated_preference is None\n\n        # Update privacy notice\n        privacy_notice_us_ca_provide.update(\n            db=db,\n            data={\n                \"data_uses\": [\"functional\"],\n                \"enforcement_level\": EnforcementLevel.frontend,\n            },\n        )\n\n        # Current preference for the given user is now None, and opt in preference is the \"outdated\" preference because it\n        # corresponds to a preference for an older version\n        refreshed_notices = privacy_experience.get_related_privacy_notices(\n            db, fides_user_provided_identity=fides_user_provided_identity\n        )\n\n        assert refreshed_notices == [privacy_notice_us_ca_provide]\n        assert refreshed_notices[0].default_preference == UserConsentPreference.opt_out\n        assert refreshed_notices[0].current_preference is None\n        assert refreshed_notices[0].outdated_preference == UserConsentPreference.opt_in\n\n        privacy_experience.delete(db)\n\n        another_session = get_api_session()\n        requeried = privacy_experience.get_related_privacy_notices(another_session)\n        # Assert current/outdated preferences are None when requeried in another session w/ no device id\n        assert requeried[0].default_preference == UserConsentPreference.opt_out\n        assert requeried[0].current_preference is None\n        assert requeried[0].outdated_preference is None\n        another_session.close()\n\n    def test_create_multiple_experiences_of_same_component_type(self, db):\n        \"\"\"We can only have one experience per component type per region\"\"\"\n        exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"overlay\",\n                \"region\": \"us_tx\",\n            },\n        )\n\n        with pytest.raises(IntegrityError):\n            PrivacyExperience.create(\n                db=db,\n                data={\n                    \"component\": \"overlay\",\n                    \"region\": \"us_tx\",\n                },\n            )\n\n        exp.delete(db)\n\n    def test_update_multiple_experiences_of_same_component_type(self, db):\n        \"\"\"We can only have one experience per component type per region. Unique constraint prevents\n        Experience updates from getting in a bad state\"\"\"\n        exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"overlay\",\n                \"region\": \"us_tx\",\n            },\n        )\n\n        exp_2 = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"us_tx\",\n            },\n        )\n\n        with pytest.raises(IntegrityError):\n            exp_2.update(\n                db=db,\n                data={\n                    \"component\": \"overlay\",\n                    \"region\": \"us_tx\",\n                },\n            )\n\n        exp_2.delete(db)\n        exp.delete(db)\n\n\nclass TestUpsertPrivacyExperiencesOnNoticeChange:\n    def test_privacy_center_experience_needed(self, db):\n        \"\"\"\n        Notice that needs to be displayed in the PrivacyCenter is created and no Privacy Center Experience\n        exists.  Assert that a privacy center PrivacyExperience is created.\n        \"\"\"\n        notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"example privacy notice\",\n                \"notice_key\": \"example_privacy_notice\",\n                \"regions\": [\n                    PrivacyNoticeRegion.us_ca,\n                ],\n                \"consent_mechanism\": ConsentMechanism.opt_out,\n                \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_privacy_center\": True,\n                \"displayed_in_overlay\": False,\n                \"displayed_in_api\": False,\n            },\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n        assert overlay_experience is None\n        assert privacy_center_experience is None\n\n        added_exp = upsert_privacy_experiences_after_notice_update(\n            db, [PrivacyNoticeRegion.us_ca]\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n\n        assert overlay_experience is None  # Only privacy center experience was created\n        assert privacy_center_experience is not None\n        assert added_exp == [privacy_center_experience]\n\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ca\n        # Experience automatically linked to default privacy center config\n        assert (\n            privacy_center_experience.experience_config_id\n            == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n        )\n        assert privacy_center_experience.get_related_privacy_notices(db) == [notice]\n\n        privacy_center_experience.delete(db)\n\n        notice.histories[0].delete(db)\n        notice.delete(db)\n\n    def test_privacy_center_experience_already_exists(self, db):\n        \"\"\"\n        Notice that needs to be displayed in the PrivacyCenter is created and Privacy Center Experience\n        already exists.  No action needed.\n        \"\"\"\n        notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"example privacy notice\",\n                \"notice_key\": \"example_privacy_notice\",\n                \"regions\": [\n                    PrivacyNoticeRegion.us_ca,\n                ],\n                \"consent_mechanism\": ConsentMechanism.opt_out,\n                \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_privacy_center\": True,\n                \"displayed_in_overlay\": False,\n                \"displayed_in_api\": False,\n            },\n        )\n\n        exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"region\": PrivacyNoticeRegion.us_ca,\n                \"component\": ComponentType.privacy_center,\n            },\n        )\n        exp_created_at = exp.created_at\n        exp_updated_at = exp.updated_at\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n\n        added_exp = upsert_privacy_experiences_after_notice_update(\n            db, [PrivacyNoticeRegion.us_ca]\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n        assert added_exp == []\n\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ca\n        assert privacy_center_experience.experience_config_id is None\n        assert privacy_center_experience.created_at == exp_created_at\n        assert privacy_center_experience.updated_at == exp_updated_at\n\n        assert privacy_center_experience.get_related_privacy_notices(db) == [notice]\n\n        privacy_center_experience.delete(db)\n\n        notice.histories[0].delete(db)\n        notice.delete(db)\n\n    def test_overlay_experience_needed(self, db):\n        \"\"\"Test Notice created that needs to be displayed in an overlay but none exists. Assert one is created\"\"\"\n        notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"example privacy notice\",\n                \"notice_key\": \"example_privacy_notice\",\n                \"regions\": [\n                    PrivacyNoticeRegion.it,\n                ],\n                \"consent_mechanism\": ConsentMechanism.opt_in,\n                \"data_uses\": [\"marketing.advertising\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_privacy_center\": False,\n                \"displayed_in_overlay\": True,\n                \"displayed_in_api\": False,\n            },\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.it\n        )\n        assert overlay_experience is None\n        assert privacy_center_experience is None\n\n        added_exp = upsert_privacy_experiences_after_notice_update(\n            db, [PrivacyNoticeRegion.it]\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.it\n        )\n\n        assert overlay_experience is not None\n        assert privacy_center_experience is None\n        assert added_exp == [overlay_experience]\n\n        assert overlay_experience.component == ComponentType.overlay\n        assert overlay_experience.region == PrivacyNoticeRegion.it\n        assert (\n            overlay_experience.experience_config_id\n            == \"pri-7ae3-f06b-4096-970f-0bbbdef-over\"\n        )\n\n        assert overlay_experience.get_related_privacy_notices(db) == [notice]\n\n        overlay_experience.delete(db)\n\n        notice.histories[0].delete(db)\n        notice.delete(db)\n\n    def test_overlay_experience_exists(self, db):\n        \"\"\"\n        Test Notice created that needs to be displayed in an overlay and experience already exists.\n        No action needed.\n        \"\"\"\n        notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"example privacy notice\",\n                \"notice_key\": \"example_privacy_notice\",\n                \"regions\": [\n                    PrivacyNoticeRegion.us_ca,\n                ],\n                \"consent_mechanism\": ConsentMechanism.opt_out,\n                \"data_uses\": [\"marketing.advertising\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_privacy_center\": False,\n                \"displayed_in_overlay\": True,\n                \"displayed_in_api\": False,\n            },\n        )\n\n        exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"region\": PrivacyNoticeRegion.us_ca,\n                \"component\": ComponentType.overlay,\n            },\n        )\n        exp_created_at = exp.created_at\n        exp_updated_at = exp.updated_at\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n\n        assert overlay_experience is not None\n        assert privacy_center_experience is None\n\n        added_exp = upsert_privacy_experiences_after_notice_update(\n            db, [PrivacyNoticeRegion.us_ca]\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n        db.refresh(overlay_experience)\n\n        assert overlay_experience is not None\n        assert privacy_center_experience is None\n        assert added_exp == []\n\n        assert overlay_experience.component == ComponentType.overlay\n        assert overlay_experience.region == PrivacyNoticeRegion.us_ca\n        assert overlay_experience.experience_config_id is None\n        assert overlay_experience.created_at == exp_created_at\n        assert overlay_experience.updated_at == exp_updated_at\n\n        assert overlay_experience.get_related_privacy_notices(db) == [notice]\n\n        overlay_experience.delete(db)\n\n        notice.histories[0].delete(db)\n        notice.delete(db)\n\n    def test_both_privacy_center_and_overlay_experience_needed(self, db):\n        \"\"\"Assert multiple types of experiences can be created simultaneously\"\"\"\n        notice = PrivacyNotice.create(\n            db=db,\n            data={\n                \"name\": \"example privacy notice\",\n                \"notice_key\": \"example_privacy_notice\",\n                \"regions\": [\n                    PrivacyNoticeRegion.us_ca,\n                ],\n                \"consent_mechanism\": ConsentMechanism.opt_out,\n                \"data_uses\": [\"marketing.advertising\", \"third_party_sharing\"],\n                \"enforcement_level\": EnforcementLevel.system_wide,\n                \"displayed_in_privacy_center\": True,\n                \"displayed_in_overlay\": True,\n                \"displayed_in_api\": False,\n            },\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n        assert overlay_experience is None\n        assert privacy_center_experience is None\n\n        added_exp = upsert_privacy_experiences_after_notice_update(\n            db, [PrivacyNoticeRegion.us_ca]\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ca\n        )\n\n        assert overlay_experience is not None\n        assert privacy_center_experience is not None\n        assert {exp.id for exp in added_exp} == {\n            overlay_experience.id,\n            privacy_center_experience.id,\n        }\n\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ca\n        assert (\n            privacy_center_experience.experience_config_id\n            == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n        )\n\n        assert overlay_experience.component == ComponentType.overlay\n        assert overlay_experience.region == PrivacyNoticeRegion.us_ca\n        assert (\n            overlay_experience.experience_config_id\n            == \"pri-7ae3-f06b-4096-970f-0bbbdef-over\"\n        )\n\n        assert privacy_center_experience.get_related_privacy_notices(db) == [notice]\n        assert overlay_experience.get_related_privacy_notices(db) == [notice]\n\n        overlay_experience.delete(db)\n        privacy_center_experience.delete(db)\n\n        notice.histories[0].delete(db)\n        notice.delete(db)\n\n\nclass TestUpsertPrivacyExperiencesOnConfigChange:\n    def test_experience_config_created_no_matching_experience_exists(self, db):\n        \"\"\"Test a privacy center ExperienceConfig is created and we attempt to link AK.\n        No PrivacyExperience exists yet so we create one - we do this regardless of whether notices exist.\n        It's okay to have an experience without notices.\n        \"\"\"\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"banner_enabled\": \"always_disabled\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n        assert overlay_experience is None\n        assert privacy_center_experience is None\n\n        linked, unlinked = upsert_privacy_experiences_after_config_update(\n            db, config, regions=[PrivacyNoticeRegion.us_ak]\n        )\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n        assert linked == [PrivacyNoticeRegion.us_ak]\n        assert unlinked == []\n\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ak\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.experience_config_id == config.id\n\n        privacy_center_experience.delete(db)\n        config.histories[0].delete(db)\n        config.delete(db)\n\n    def test_experience_config_created_matching_unlinked_experience_exists(self, db):\n        \"\"\"Test ExperienceConfig created and we attempt to link AK to that ExperienceConfig.\n        A PrivacyExperience exists for AK, but needs to be linked to this ExperienceConfig.\n        \"\"\"\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"banner_enabled\": \"always_disabled\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"us_ak\",\n            },\n        )\n        assert pc_exp.experience_config_id is None\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n        assert overlay_experience is None\n        assert privacy_center_experience == pc_exp\n\n        linked, unlinked = upsert_privacy_experiences_after_config_update(\n            db, config, regions=[PrivacyNoticeRegion.us_ak]\n        )\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n        assert linked == [PrivacyNoticeRegion.us_ak]\n        assert unlinked == []\n\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ak\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.experience_config_id == config.id\n\n        privacy_center_experience.delete(db)\n        config.histories[0].delete(db)\n        config.delete(db)\n\n    def test_experience_config_updated_matching_experience_already_linked(self, db):\n        \"\"\"Privacy Center Experience Config updated, and we attempt to add AK to this,\n        but it is already linked, so no action needed\"\"\"\n\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"banner_enabled\": \"always_disabled\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"us_ak\",\n                \"experience_config_id\": config.id,\n            },\n        )\n        assert pc_exp.experience_config_id == config.id\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience == pc_exp\n\n        linked, unlinked = upsert_privacy_experiences_after_config_update(\n            db, config, regions=[PrivacyNoticeRegion.us_ak]\n        )\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n        db.refresh(privacy_center_experience)\n\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n        assert linked == []\n        assert unlinked == []\n\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ak\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.experience_config_id == config.id\n\n        privacy_center_experience.delete(db)\n        config.histories[0].delete(db)\n        config.delete(db)\n\n    def test_experience_config_unlinks_region(self, db):\n        \"\"\"Privacy Center Experience Config updated, and we attempt to remove the\n        regions. Any affected experiences have the default linked instead\"\"\"\n\n        config = PrivacyExperienceConfig.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"banner_enabled\": \"always_disabled\",\n                \"title\": \"Control your privacy\",\n            },\n        )\n\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"us_ak\",\n                \"experience_config_id\": config.id,\n            },\n        )\n        assert pc_exp.experience_config_id == config.id\n        assert config.experiences.count() == 1\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience == pc_exp\n\n        linked, unlinked = upsert_privacy_experiences_after_config_update(\n            db, config, regions=[]  # Empty region list will remove regions\n        )\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n        assert linked == []\n        assert unlinked == [PrivacyNoticeRegion.us_ak]\n        db.refresh(config)\n        assert config.experiences.count() == 0\n\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ak\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert (\n            privacy_center_experience.experience_config_id\n            == \"pri-097a-d00d-40b6-a08f-f8e50def-pri\"\n        )\n\n        privacy_center_experience.delete(db)\n        config.histories[0].delete(db)\n        config.delete(db)\n\n    def test_experience_config_unlinks_region_from_default_config(self, db):\n        \"\"\"Default Privacy Center Experience Config updated, and we attempt to remove the\n        regions. Affected experiences have no config because there's nothing to which we can automatically link.\n        \"\"\"\n        default_privacy_center_config = PrivacyExperienceConfig.get_default_config(\n            db, ComponentType.privacy_center\n        )\n\n        pc_exp = PrivacyExperience.create(\n            db=db,\n            data={\n                \"component\": \"privacy_center\",\n                \"region\": \"us_ak\",\n                \"experience_config_id\": default_privacy_center_config.id,\n            },\n        )\n        assert pc_exp.experience_config_id == default_privacy_center_config.id\n        assert default_privacy_center_config.experiences.count() == 1\n\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience == pc_exp\n\n        linked, unlinked = upsert_privacy_experiences_after_config_update(\n            db,\n            default_privacy_center_config,\n            regions=[],  # Empty region list will remove regions\n        )\n        (\n            overlay_experience,\n            privacy_center_experience,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n\n        assert overlay_experience is None\n        assert privacy_center_experience is not None\n        assert linked == []\n        assert unlinked == [PrivacyNoticeRegion.us_ak]\n        db.refresh(default_privacy_center_config)\n        assert default_privacy_center_config.experiences.count() == 0\n\n        assert privacy_center_experience.region == PrivacyNoticeRegion.us_ak\n        assert privacy_center_experience.component == ComponentType.privacy_center\n        assert privacy_center_experience.experience_config_id is None\n\n        privacy_center_experience.delete(db)\n\n\nclass TestCacheSavedAndServedOnConsentRecord:\n    @pytest.fixture\n    def tcf_purpose_consent_record(self):\n        return TCFPurposeConsentRecord(**MAPPED_PURPOSES[8].dict())\n\n    @pytest.fixture\n    def tcf_purpose_legitimate_interests_record(self):\n        return TCFPurposeLegitimateInterestsRecord(**MAPPED_PURPOSES[8].dict())\n\n    @pytest.mark.usefixtures(\n        \"served_notice_history_us_provide_for_fides_user\",\n        \"privacy_preference_history_us_ca_provide_for_fides_user\",\n    )\n    def test_cache_saved_and_served_for_privacy_notice_history(\n        self,\n        db,\n        fides_user_provided_identity,\n        privacy_notice_us_ca_provide,\n    ):\n        assert (\n            privacy_notice_us_ca_provide.default_preference\n            == UserConsentPreference.opt_out\n        )\n        assert privacy_notice_us_ca_provide.current_preference is None\n        assert privacy_notice_us_ca_provide.outdated_preference is None\n        assert privacy_notice_us_ca_provide.current_served is None\n        assert privacy_notice_us_ca_provide.outdated_served is None\n\n        cache_saved_and_served_on_consent_record(\n            db=db,\n            consent_record=privacy_notice_us_ca_provide,\n            fides_user_provided_identity=fides_user_provided_identity,\n            record_type=ConsentRecordType.privacy_notice_id,\n        )\n\n        assert (\n            privacy_notice_us_ca_provide.default_preference\n            == UserConsentPreference.opt_out\n        )\n        assert (\n            privacy_notice_us_ca_provide.current_preference\n            == UserConsentPreference.opt_in\n        )\n        assert privacy_notice_us_ca_provide.outdated_preference is None\n        assert privacy_notice_us_ca_provide.current_served is True\n        assert privacy_notice_us_ca_provide.outdated_served is None\n\n    def test_record_for_tcf_purpose_exists_for_older_version(\n        self,\n        db,\n        tcf_purpose_consent_record,\n        fides_user_provided_identity,\n        privacy_preference_history_for_tcf_purpose_consent,\n        served_notice_history_for_tcf_purpose,\n    ):\n        privacy_preference_history_for_tcf_purpose_consent.current_privacy_preference.tcf_version = (\n            \"1.0\"\n        )\n        privacy_preference_history_for_tcf_purpose_consent.current_privacy_preference.save(\n            db\n        )\n\n        served_notice_history_for_tcf_purpose.last_served_record.tcf_version = \"1.0\"\n        served_notice_history_for_tcf_purpose.last_served_record.save(db)\n\n        cache_saved_and_served_on_consent_record(\n            db,\n            tcf_purpose_consent_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.purpose_consent,\n        )\n\n        assert (\n            tcf_purpose_consent_record.default_preference\n            == UserConsentPreference.opt_out\n        )\n        assert tcf_purpose_consent_record.current_preference is None\n        assert (\n            tcf_purpose_consent_record.outdated_preference\n            == UserConsentPreference.opt_out\n        )\n        assert tcf_purpose_consent_record.current_served is None\n        assert tcf_purpose_consent_record.outdated_served is True\n\n    @pytest.mark.usefixtures(\n        \"privacy_preference_history_for_tcf_purpose_consent\",\n        \"served_notice_history_for_tcf_purpose\",\n    )\n    def test_record_for_tcf_purpose_exists_for_current_version(\n        self, db, tcf_purpose_consent_record, fides_user_provided_identity\n    ):\n        cache_saved_and_served_on_consent_record(\n            db,\n            tcf_purpose_consent_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.purpose_consent,\n        )\n\n        assert (\n            tcf_purpose_consent_record.default_preference\n            == UserConsentPreference.opt_out\n        )\n        assert (\n            tcf_purpose_consent_record.current_preference\n            == UserConsentPreference.opt_out\n        )\n        assert tcf_purpose_consent_record.outdated_preference is None\n        assert tcf_purpose_consent_record.current_served is True\n        assert tcf_purpose_consent_record.outdated_served is None\n\n    def test_no_record_for_tcf_purpose_exists(\n        self, db, tcf_purpose_consent_record, fides_user_provided_identity\n    ):\n        cache_saved_and_served_on_consent_record(\n            db,\n            tcf_purpose_consent_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.purpose_consent,\n        )\n        assert (\n            tcf_purpose_consent_record.default_preference\n            == UserConsentPreference.opt_out\n        )\n        assert tcf_purpose_consent_record.current_preference is None\n        assert tcf_purpose_consent_record.outdated_preference is None\n        assert tcf_purpose_consent_record.current_served is None\n        assert tcf_purpose_consent_record.outdated_served is None\n\n    def test_tcf_purpose_legitimate_interests_record(\n        self,\n        db,\n        tcf_purpose_legitimate_interests_record,\n        fides_user_provided_identity,\n        privacy_preference_history_for_tcf_purpose_legitimate_interests,\n    ):\n        cache_saved_and_served_on_consent_record(\n            db,\n            tcf_purpose_legitimate_interests_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.purpose_legitimate_interests,\n        )\n        assert (\n            tcf_purpose_legitimate_interests_record.default_preference\n            == UserConsentPreference.opt_in\n        )\n        assert (\n            tcf_purpose_legitimate_interests_record.current_preference\n            == UserConsentPreference.opt_in\n        )\n        assert tcf_purpose_legitimate_interests_record.outdated_preference is None\n        assert tcf_purpose_legitimate_interests_record.current_served is None\n        assert tcf_purpose_legitimate_interests_record.outdated_served is None\n\n    @pytest.mark.usefixtures(\n        \"privacy_preference_history_for_tcf_special_purpose\",\n        \"served_notice_history_for_tcf_special_purpose\",\n    )\n    def test_cache_saved_and_served_for_special_purpose(\n        self,\n        db,\n        fides_user_provided_identity,\n    ):\n        special_purpose_record = TCFPurposeConsentRecord(\n            **MAPPED_SPECIAL_PURPOSES[1].dict()\n        )\n        cache_saved_and_served_on_consent_record(\n            db,\n            special_purpose_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.special_purpose,\n        )\n\n        assert (\n            special_purpose_record.default_preference == UserConsentPreference.opt_out\n        )\n        assert special_purpose_record.current_preference == UserConsentPreference.opt_in\n        assert special_purpose_record.outdated_preference is None\n        assert special_purpose_record.current_served is True\n        assert special_purpose_record.outdated_served is None\n\n    @pytest.mark.usefixtures(\"privacy_preference_history_for_vendor\")\n    def test_cache_saved_and_served_for_vendor_consent(\n        self, db, fides_user_provided_identity\n    ):\n        vendor_record = TCFVendorConsentRecord(\n            id=\"gvl.42\", name=\"test\", description=\"test\", has_vendor_id=False\n        )\n        cache_saved_and_served_on_consent_record(\n            db,\n            vendor_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.vendor_consent,\n        )\n\n        assert vendor_record.default_preference == UserConsentPreference.opt_out\n        assert vendor_record.current_preference == UserConsentPreference.opt_out\n        assert vendor_record.outdated_preference is None\n        assert vendor_record.current_served is None\n        assert vendor_record.outdated_served is None\n\n    @pytest.mark.usefixtures(\n        \"privacy_preference_history_for_vendor_legitimate_interests\"\n    )\n    def test_cache_saved_and_served_for_vendor_legitimate_interests(\n        self, db, fides_user_provided_identity\n    ):\n        vendor_record = TCFVendorLegitimateInterestsRecord(\n            id=\"gvl.42\", name=\"test\", description=\"test\", has_vendor_id=True\n        )\n        cache_saved_and_served_on_consent_record(\n            db,\n            vendor_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.vendor_legitimate_interests,\n        )\n\n        assert vendor_record.default_preference == UserConsentPreference.opt_in\n        assert vendor_record.current_preference == UserConsentPreference.opt_out\n        assert vendor_record.outdated_preference is None\n        assert vendor_record.current_served is True\n        assert vendor_record.outdated_served is None\n\n    @pytest.mark.usefixtures(\"privacy_preference_history_for_system\")\n    def test_cache_saved_and_served_for_system_consent(\n        self, db, fides_user_provided_identity, system\n    ):\n        system_record = TCFVendorConsentRecord(id=system.id, has_vendor_id=True)\n        cache_saved_and_served_on_consent_record(\n            db,\n            system_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.system_consent,\n        )\n\n        assert system_record.default_preference == UserConsentPreference.opt_out\n        assert system_record.current_preference == UserConsentPreference.opt_in\n        assert system_record.outdated_preference is None\n        assert system_record.current_served is None\n        assert system_record.outdated_served is None\n\n    def test_cache_saved_and_served_for_vendor_relationships(\n        self, db, fides_user_provided_identity, system\n    ):\n        \"\"\"This is more just aggregating additional info - no consent is saved here\"\"\"\n        system_record = TCFVendorRelationships(\n            id=system.id, name=\"test\", description=\"test\", has_vendor_id=False\n        )\n        cache_saved_and_served_on_consent_record(\n            db,\n            system_record,\n            fides_user_provided_identity,\n            record_type=None,\n        )\n\n        assert not getattr(system_record, \"default_preference\", None)\n\n    def test_cache_saved_and_served_for_tcf_special_purpose(\n        self, db, fides_user_provided_identity\n    ):\n        sp_record = TCFSpecialPurposeRecord(\n            id=2,\n            name=\"Special Purpose 2\",\n            illustrations=[\"test illustrations\"],\n            data_uses=[\"test\"],\n            description=\"desc\",\n        )\n        cache_saved_and_served_on_consent_record(\n            db,\n            sp_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.special_purpose,\n        )\n\n        assert sp_record.default_preference == UserConsentPreference.acknowledge\n        assert sp_record.current_preference is None\n        assert sp_record.outdated_preference is None\n        assert sp_record.current_served is None\n        assert sp_record.outdated_served is None\n\n    @pytest.mark.usefixtures(\"privacy_preference_history_for_tcf_feature\")\n    def test_cache_saved_and_served_for_tcf_feature(\n        self, db, fides_user_provided_identity\n    ):\n        feature_record = TCFFeatureRecord(\n            id=2,\n            name=\"Link different devices\",\n            description=\"Different devices can be determined as belonging to you or your household in support of one or more of purposes.\",\n        )\n        cache_saved_and_served_on_consent_record(\n            db,\n            feature_record,\n            fides_user_provided_identity,\n            record_type=ConsentRecordType.feature,\n        )\n\n        assert feature_record.default_preference == UserConsentPreference.acknowledge\n        assert feature_record.current_preference == UserConsentPreference.opt_in\n        assert feature_record.outdated_preference is None\n        assert feature_record.current_served is True\n        assert feature_record.outdated_served is None\n", "import pytest\nfrom sqlalchemy.exc import InvalidRequestError\n\nfrom fides.api.api.v1.endpoints.privacy_preference_endpoints import (\n    anonymize_ip_address,\n    extract_identity_from_provided_identity,\n)\nfrom fides.api.common_exceptions import (\n    ConsentHistorySaveError,\n    IdentityNotFoundException,\n    PrivacyNoticeHistoryNotFound,\n    SystemNotFound,\n)\nfrom fides.api.models.privacy_preference import (\n    CURRENT_TCF_VERSION,\n    ConsentRecordType,\n    CurrentPrivacyPreference,\n    LastServedNotice,\n    PrivacyPreferenceHistory,\n    RequestOrigin,\n    ServedNoticeHistory,\n    ServingComponent,\n    TCFComponentType,\n    UserConsentPreference,\n    _validate_before_saving_consent_history,\n)\nfrom fides.api.models.privacy_request import (\n    ExecutionLogStatus,\n    ProvidedIdentity,\n    ProvidedIdentityType,\n)\nfrom fides.api.models.sql_models import PrivacyDeclaration\n\n\nclass TestPrivacyPreferenceHistory:\n    def test_create_privacy_preference_min_fields(self, db, privacy_notice):\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\"test@email.com\"),\n            \"encrypted_value\": {\"value\": \"test@email.com\"},\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n\n        pref = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": \"opt_in\",\n                \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                \"provided_identity_id\": provided_identity.id,\n            },\n            check_name=False,\n        )\n\n        assert pref.preference == UserConsentPreference.opt_in\n        assert pref.privacy_notice_history == privacy_notice.histories[0]\n        assert pref.privacy_notice_id == privacy_notice.id\n\n        pref.delete(db=db)\n\n    def test_create_privacy_preference_no_privacy_notice_history(self, db):\n        with pytest.raises(PrivacyNoticeHistoryNotFound):\n            PrivacyPreferenceHistory.create(\n                db=db,\n                data={\n                    \"preference\": \"opt_in\",\n                    \"privacy_notice_history_id\": \"nonexistent_notice\",\n                },\n                check_name=False,\n            )\n\n    def test_create_privacy_preference_history_without_identity(\n        self, db, privacy_notice\n    ):\n        with pytest.raises(IdentityNotFoundException):\n            PrivacyPreferenceHistory.create(\n                db=db,\n                data={\n                    \"preference\": \"opt_in\",\n                    \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                },\n                check_name=False,\n            )\n\n    def test_create_privacy_preference_for_notice(\n        self, db, privacy_notice, system, privacy_request\n    ):\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\"test@email.com\"),\n            \"encrypted_value\": {\"value\": \"test@email.com\"},\n        }\n        fides_user_provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"fides_user_device_id\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\n                \"test_fides_user_device_id_1234567\"\n            ),\n            \"encrypted_value\": {\"value\": \"test_fides_user_device_id_1234567\"},\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n        fides_user_provided_identity = ProvidedIdentity.create(\n            db, data=fides_user_provided_identity_data\n        )\n\n        privacy_notice_history = privacy_notice.histories[0]\n\n        email, hashed_email = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.email\n        )\n        phone_number, hashed_phone_number = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.phone_number\n        )\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": email,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": hashed_email,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": hashed_phone_number,\n                \"phone_number\": phone_number,\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": provided_identity.id,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"https://example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n        assert preference_history_record.affected_system_status == {}\n        assert preference_history_record.email == \"test@email.com\"\n        assert (\n            preference_history_record.hashed_email\n            == provided_identity.hashed_value\n            is not None\n        )\n        assert (\n            preference_history_record.fides_user_device\n            == fides_user_device_id\n            is not None\n        )\n        assert (\n            preference_history_record.hashed_fides_user_device\n            == hashed_device_id\n            is not None\n        )\n        assert (\n            preference_history_record.fides_user_device_provided_identity\n            == fides_user_provided_identity\n        )\n\n        assert preference_history_record.email == \"test@email.com\"\n        assert (\n            preference_history_record.hashed_email\n            == provided_identity.hashed_value\n            is not None\n        )\n\n        assert preference_history_record.phone_number is None\n        assert preference_history_record.hashed_phone_number is None\n        assert preference_history_record.preference == UserConsentPreference.opt_out\n        assert (\n            preference_history_record.privacy_notice_history == privacy_notice_history\n        )\n        assert preference_history_record.privacy_notice_id == privacy_notice.id\n        assert (\n            preference_history_record.privacy_request is None\n        )  # Hasn't been added yet\n        assert preference_history_record.provided_identity == provided_identity\n        assert preference_history_record.relevant_systems == [system.fides_key]\n        assert preference_history_record.tcf_version is None  # Not relevant here\n        assert preference_history_record.feature is None\n        assert preference_history_record.special_feature is None\n        assert preference_history_record.vendor_consent is None\n        assert preference_history_record.special_purpose is None\n        assert preference_history_record.purpose_consent is None\n        assert preference_history_record.request_origin == RequestOrigin.privacy_center\n        assert preference_history_record.secondary_user_ids == {\"ga_client_id\": \"test\"}\n        assert (\n            preference_history_record.user_agent\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert preference_history_record.user_geography == \"us_ca\"\n        assert (\n            preference_history_record.url_recorded\n            == \"http://example.com/privacy_center\"\n        )\n\n        # Assert PrivacyRequest.privacy_preferences relationship\n        assert privacy_request.privacy_preferences == []\n\n        preference_history_record.privacy_request_id = privacy_request.id\n        preference_history_record.save(db)\n        assert preference_history_record.privacy_request == privacy_request\n        assert privacy_request.privacy_preferences == [preference_history_record]\n\n        # Assert CurrentPrivacyPreference record upserted\n        current_privacy_preference = (\n            preference_history_record.current_privacy_preference\n        )\n        current_privacy_preference_id = current_privacy_preference.id\n        assert current_privacy_preference.preference == UserConsentPreference.opt_out\n        assert (\n            current_privacy_preference.privacy_notice_history == privacy_notice_history\n        )\n        assert current_privacy_preference.tcf_version is None\n        assert current_privacy_preference.feature is None\n        assert current_privacy_preference.special_feature is None\n        assert current_privacy_preference.vendor_consent is None\n        assert current_privacy_preference.special_purpose is None\n        assert current_privacy_preference.purpose_consent is None\n\n        # Save preferences again with an \"opt in\" preference for this privacy notice\n        next_preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": provided_identity.encrypted_value[\"value\"]\n                if provided_identity.field_name == ProvidedIdentityType.email\n                else None,\n                \"phone_number\": provided_identity.encrypted_value[\"value\"]\n                if provided_identity.field_name == ProvidedIdentityType.phone_number\n                else None,\n                \"preference\": \"opt_in\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": provided_identity.id,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"http://example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        assert next_preference_history_record.preference == UserConsentPreference.opt_in\n        assert (\n            next_preference_history_record.privacy_notice_history\n            == privacy_notice_history\n        )\n\n        # Assert CurrentPrivacyPreference record upserted\n        db.refresh(current_privacy_preference)\n        assert current_privacy_preference.preference == UserConsentPreference.opt_in\n        assert (\n            current_privacy_preference.privacy_notice_history == privacy_notice_history\n        )\n        assert (\n            next_preference_history_record.current_privacy_preference\n            == current_privacy_preference\n        )\n        assert current_privacy_preference.id == current_privacy_preference_id\n\n        db.refresh(preference_history_record)\n        assert (\n            next_preference_history_record.current_privacy_preference\n            == current_privacy_preference\n        )\n        assert preference_history_record.current_privacy_preference is None\n\n        preference_history_record.delete(db)\n        next_preference_history_record.delete(db)\n\n    def test_create_privacy_preference_for_multiple_preference_types(\n        self, db, system, fides_user_provided_identity\n    ):\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        with pytest.raises(ConsentHistorySaveError):\n            PrivacyPreferenceHistory.create(\n                db=db,\n                data={\n                    \"purpose_consent\": 8,\n                    \"vendor_consent\": \"amplitude\",\n                    \"fides_user_device\": fides_user_device_id,\n                    \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                    \"hashed_fides_user_device\": hashed_device_id,\n                    \"preference\": \"opt_out\",\n                    \"request_origin\": \"tcf_overlay\",\n                },\n                check_name=False,\n            )\n\n    def test_create_privacy_preference_for_purpose(\n        self, db, system, tcf_system, fides_user_provided_identity\n    ):\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"purpose_consent\": 8,\n                \"email\": None,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": None,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": None,\n                \"provided_identity_id\": None,\n                \"request_origin\": \"tcf_overlay\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n                \"url_recorded\": \"example.com\",\n            },\n            check_name=False,\n        )\n        assert preference_history_record.affected_system_status == {}\n        assert preference_history_record.email is None\n        assert preference_history_record.hashed_email is None\n        assert (\n            preference_history_record.fides_user_device\n            == fides_user_device_id\n            is not None\n        )\n        assert (\n            preference_history_record.hashed_fides_user_device\n            == hashed_device_id\n            is not None\n        )\n        assert (\n            preference_history_record.fides_user_device_provided_identity\n            == fides_user_provided_identity\n        )\n        assert preference_history_record.purpose_consent == 8\n        assert preference_history_record.purpose_legitimate_interests is None\n        assert preference_history_record.feature is None\n        assert preference_history_record.special_feature is None\n        assert preference_history_record.vendor_consent is None\n        assert preference_history_record.vendor_legitimate_interests is None\n        assert preference_history_record.system_consent is None\n        assert preference_history_record.system_legitimate_interests is None\n        assert preference_history_record.special_purpose is None\n        assert preference_history_record.tcf_version == CURRENT_TCF_VERSION\n        assert preference_history_record.privacy_notice_id is None\n\n        assert preference_history_record.phone_number is None\n        assert preference_history_record.hashed_phone_number is None\n        assert preference_history_record.preference == UserConsentPreference.opt_out\n        assert preference_history_record.privacy_notice_history is None\n        assert preference_history_record.privacy_request is None\n        assert preference_history_record.provided_identity is None\n        assert preference_history_record.relevant_systems == [tcf_system.fides_key]\n        assert preference_history_record.request_origin == RequestOrigin.tcf_overlay\n        assert preference_history_record.secondary_user_ids == {\"ga_client_id\": \"test\"}\n        assert (\n            preference_history_record.user_agent\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert preference_history_record.user_geography == \"fr\"\n        assert preference_history_record.url_recorded == \"example.com\"\n\n        # Assert CurrentPrivacyPreference record upserted\n        current_privacy_preference = (\n            preference_history_record.current_privacy_preference\n        )\n        current_privacy_preference_id = current_privacy_preference.id\n        assert current_privacy_preference.preference == UserConsentPreference.opt_out\n        assert current_privacy_preference.privacy_notice_history is None\n        assert current_privacy_preference.purpose_consent == 8\n        assert current_privacy_preference.purpose_legitimate_interests is None\n        assert current_privacy_preference.feature is None\n        assert current_privacy_preference.special_feature is None\n        assert current_privacy_preference.vendor_consent is None\n        assert current_privacy_preference.vendor_legitimate_interests is None\n        assert current_privacy_preference.special_purpose is None\n        assert current_privacy_preference.tcf_version == CURRENT_TCF_VERSION\n\n        # Save preferences again with an \"opt in\" preference for this purpose\n        next_preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": \"opt_in\",\n                \"purpose_consent\": 8,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"request_origin\": \"tcf_overlay\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n            },\n            check_name=False,\n        )\n\n        assert next_preference_history_record.preference == UserConsentPreference.opt_in\n        assert next_preference_history_record.privacy_notice_history is None\n        assert next_preference_history_record.purpose_consent == 8\n\n        # Assert CurrentPrivacyPreference record upserted\n        db.refresh(current_privacy_preference)\n        assert current_privacy_preference.preference == UserConsentPreference.opt_in\n        assert current_privacy_preference.privacy_notice_history is None\n        assert current_privacy_preference.purpose_consent == 8\n        assert (\n            next_preference_history_record.current_privacy_preference\n            == current_privacy_preference\n        )\n        assert current_privacy_preference.id == current_privacy_preference_id\n\n        db.refresh(preference_history_record)\n        assert (\n            next_preference_history_record.current_privacy_preference\n            == current_privacy_preference\n        )\n        assert preference_history_record.current_privacy_preference is None\n\n        preference_history_record.delete(db)\n        next_preference_history_record.delete(db)\n\n        # Save preferences again with an \"opt in\" preference for a special purpose\n\n        special_purpose_preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": \"opt_in\",\n                \"special_purpose\": 1,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"request_origin\": \"tcf_overlay\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n            },\n            check_name=False,\n        )\n\n        assert special_purpose_preference_history_record.special_purpose == 1\n        assert special_purpose_preference_history_record.relevant_systems == [\n            tcf_system.fides_key\n        ]\n        assert special_purpose_preference_history_record.purpose_consent is None\n        assert special_purpose_preference_history_record.feature is None\n        assert special_purpose_preference_history_record.special_feature is None\n        assert (\n            special_purpose_preference_history_record.tcf_version == CURRENT_TCF_VERSION\n        )\n        assert (\n            special_purpose_preference_history_record.privacy_notice_history_id is None\n        )\n        assert special_purpose_preference_history_record.privacy_notice_id is None\n        current_special_purpose_preference = (\n            special_purpose_preference_history_record.current_privacy_preference\n        )\n\n        assert current_special_purpose_preference.special_purpose == 1\n        assert current_special_purpose_preference.purpose_consent is None\n        assert current_special_purpose_preference.feature is None\n        assert current_special_purpose_preference.special_feature is None\n        assert current_special_purpose_preference.privacy_notice_history_id is None\n        assert current_special_purpose_preference.tcf_version == CURRENT_TCF_VERSION\n\n        current_special_purpose_preference.delete(db)\n        special_purpose_preference_history_record.delete(db)\n\n    def test_create_privacy_preference_for_vendor(\n        self, db, fides_user_provided_identity\n    ):\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"vendor_consent\": \"gvl.42\",\n                \"email\": None,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": None,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": None,\n                \"provided_identity_id\": None,\n                \"request_origin\": \"tcf_overlay\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n                \"url_recorded\": \"example.com\",\n            },\n            check_name=False,\n        )\n        assert preference_history_record.affected_system_status == {}\n        assert preference_history_record.email is None\n        assert preference_history_record.hashed_email is None\n        assert (\n            preference_history_record.fides_user_device\n            == fides_user_device_id\n            is not None\n        )\n        assert (\n            preference_history_record.hashed_fides_user_device\n            == hashed_device_id\n            is not None\n        )\n        assert (\n            preference_history_record.fides_user_device_provided_identity\n            == fides_user_provided_identity\n        )\n        assert preference_history_record.vendor_consent == \"gvl.42\"\n        assert preference_history_record.vendor_legitimate_interests is None\n        assert preference_history_record.purpose_consent is None\n        assert preference_history_record.purpose_legitimate_interests is None\n        assert preference_history_record.special_purpose is None\n        assert preference_history_record.feature is None\n        assert preference_history_record.special_feature is None\n        assert preference_history_record.tcf_version == CURRENT_TCF_VERSION\n        assert preference_history_record.privacy_notice_id is None\n        assert preference_history_record.phone_number is None\n        assert preference_history_record.hashed_phone_number is None\n        assert preference_history_record.preference == UserConsentPreference.opt_out\n        assert preference_history_record.privacy_notice_history is None\n        assert preference_history_record.privacy_request is None\n        assert preference_history_record.provided_identity is None\n        assert preference_history_record.relevant_systems == []\n        assert preference_history_record.request_origin == RequestOrigin.tcf_overlay\n        assert preference_history_record.secondary_user_ids == {\"ga_client_id\": \"test\"}\n        assert (\n            preference_history_record.user_agent\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert preference_history_record.user_geography == \"fr\"\n        assert preference_history_record.url_recorded == \"example.com\"\n\n        # Assert CurrentPrivacyPreference record upserted\n        current_privacy_preference = (\n            preference_history_record.current_privacy_preference\n        )\n        current_privacy_preference_id = current_privacy_preference.id\n        assert current_privacy_preference.preference == UserConsentPreference.opt_out\n        assert current_privacy_preference.privacy_notice_history is None\n        assert current_privacy_preference.vendor_consent == \"gvl.42\"\n        assert current_privacy_preference.tcf_version == CURRENT_TCF_VERSION\n\n        # Save preferences again with an \"opt in\" preference for this privacy notice\n        next_preference_history_record = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": \"opt_in\",\n                \"vendor_consent\": \"gvl.42\",\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"request_origin\": \"tcf_overlay\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n            },\n            check_name=False,\n        )\n\n        assert next_preference_history_record.preference == UserConsentPreference.opt_in\n        assert next_preference_history_record.privacy_notice_history is None\n        assert next_preference_history_record.vendor_consent == \"gvl.42\"\n\n        # Assert CurrentPrivacyPreference record upserted\n        db.refresh(current_privacy_preference)\n        assert current_privacy_preference.preference == UserConsentPreference.opt_in\n        assert current_privacy_preference.privacy_notice_history is None\n        assert current_privacy_preference.vendor_consent == \"gvl.42\"\n        assert current_privacy_preference.vendor_legitimate_interests is None\n        assert current_privacy_preference.purpose_consent is None\n        assert current_privacy_preference.purpose_legitimate_interests is None\n        assert current_privacy_preference.special_purpose is None\n        assert current_privacy_preference.feature is None\n        assert current_privacy_preference.special_feature is None\n        assert current_privacy_preference.tcf_version == CURRENT_TCF_VERSION\n        assert (\n            next_preference_history_record.current_privacy_preference\n            == current_privacy_preference\n        )\n        assert current_privacy_preference.id == current_privacy_preference_id\n\n        db.refresh(preference_history_record)\n        assert (\n            next_preference_history_record.current_privacy_preference\n            == current_privacy_preference\n        )\n        assert preference_history_record.current_privacy_preference is None\n\n        preference_history_record.delete(db)\n        next_preference_history_record.delete(db)\n\n    def test_create_history_and_upsert_current_preferences(\n        self,\n        db,\n        privacy_notice,\n    ):\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\"test@email.com\"),\n            \"encrypted_value\": {\"value\": \"test@email.com\"},\n        }\n        fides_user_provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"fides_user_device_id\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\n                \"test_fides_user_device_id_1234567\"\n            ),\n            \"encrypted_value\": {\"value\": \"test_fides_user_device_id_1234567\"},\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n        fides_user_provided_identity = ProvidedIdentity.create(\n            db, data=fides_user_provided_identity_data\n        )\n\n        privacy_notice_history = privacy_notice.histories[0]\n\n        email, hashed_email = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.email\n        )\n        phone_number, hashed_phone_number = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.phone_number\n        )\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        (\n            preference_history_record,\n            current_record,\n        ) = PrivacyPreferenceHistory.create_history_and_upsert_current_preference(\n            db=db,\n            data={\n                \"email\": email,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": hashed_email,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": hashed_phone_number,\n                \"phone_number\": phone_number,\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": provided_identity.id,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"http://example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        assert current_record == preference_history_record.current_privacy_preference\n\n    def test_cache_system_status(self, privacy_preference_history, db):\n        assert privacy_preference_history.affected_system_status == {}\n\n        privacy_preference_history.cache_system_status(\n            db, \"test_system_key\", ExecutionLogStatus.pending\n        )\n        assert privacy_preference_history.affected_system_status == {\n            \"test_system_key\": ExecutionLogStatus.pending.value\n        }\n\n        privacy_preference_history.cache_system_status(\n            db, \"test_system_key\", ExecutionLogStatus.complete\n        )\n        assert privacy_preference_history.affected_system_status == {\n            \"test_system_key\": ExecutionLogStatus.complete.value\n        }\n\n    def test_update_secondary_user_ids(self, privacy_preference_history, db):\n        assert privacy_preference_history.secondary_user_ids is None\n\n        privacy_preference_history.update_secondary_user_ids(\n            db, {\"email\": \"test@example.com\"}\n        )\n        assert privacy_preference_history.secondary_user_ids == {\n            \"email\": \"test@example.com\"\n        }\n\n        privacy_preference_history.update_secondary_user_ids(\n            db, {\"ljt_readerID\": \"customer-123\"}\n        )\n        assert privacy_preference_history.secondary_user_ids == {\n            \"email\": \"test@example.com\",\n            \"ljt_readerID\": \"customer-123\",\n        }\n\n        privacy_preference_history.update_secondary_user_ids(\n            db, {\"email\": \"hello@example.com\"}\n        )\n        assert privacy_preference_history.secondary_user_ids == {\n            \"email\": \"hello@example.com\",\n            \"ljt_readerID\": \"customer-123\",\n        }\n\n    def test_consolidate_current_privacy_preferences(self, db, privacy_notice):\n        \"\"\"We might have privacy preferences saved just under a fides user device id in an overlay,\n        and then later, have privacy preferences saved both under an email and that same fides user device id\n\n        We should consider these preferences as being for the same individual, and consolidate\n        them for our \"current privacy preferences\"\n        \"\"\"\n\n        # Let's first just save a privacy preference under a fides user device id\n        fides_user_provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"fides_user_device_id\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\n                \"test_fides_user_device_id_1234567\"\n            ),\n            \"encrypted_value\": {\"value\": \"test_fides_user_device_id_1234567\"},\n        }\n        fides_user_provided_identity = ProvidedIdentity.create(\n            db, data=fides_user_provided_identity_data\n        )\n\n        privacy_notice_history = privacy_notice.histories[0]\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        preference_history_record_for_device = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": None,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": None,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": None,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"http://example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        # Assert a CurrentPrivacyPreference record was created when the PrivacyPreferenceHistory was created\n        fides_user_device_current_preference = (\n            preference_history_record_for_device.current_privacy_preference\n        )\n        assert fides_user_device_current_preference.created_at is not None\n        assert fides_user_device_current_preference.updated_at is not None\n        assert (\n            fides_user_device_current_preference.preference\n            == UserConsentPreference.opt_out\n        )\n        assert fides_user_device_current_preference.provided_identity_id is None\n        assert (\n            fides_user_device_current_preference.fides_user_device_provided_identity_id\n            == fides_user_provided_identity.id\n        )\n        assert (\n            fides_user_device_current_preference.privacy_notice_id == privacy_notice.id\n        )\n        assert (\n            fides_user_device_current_preference.privacy_notice_history_id\n            == privacy_notice_history.id\n        )\n        assert (\n            fides_user_device_current_preference.privacy_preference_history_id\n            == preference_history_record_for_device.id\n        )\n\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\"test@email.com\"),\n            \"encrypted_value\": {\"value\": \"test@email.com\"},\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n        email, hashed_email = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.email\n        )\n\n        preference_history_record_for_email = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": email,\n                \"fides_user_device\": None,\n                \"fides_user_device_provided_identity_id\": None,\n                \"hashed_email\": hashed_email,\n                \"hashed_fides_user_device\": None,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_in\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": provided_identity.id,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"http://example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        # Assert a new CurrentPrivacyPreference record was created when the PrivacyPreferenceHistory was created with email\n        email_current_preference = (\n            preference_history_record_for_email.current_privacy_preference\n        )\n        assert email_current_preference.created_at is not None\n        assert email_current_preference.updated_at is not None\n        assert email_current_preference.preference == UserConsentPreference.opt_in\n        assert email_current_preference.provided_identity_id == provided_identity.id\n        assert email_current_preference.fides_user_device_provided_identity_id is None\n        assert email_current_preference.privacy_notice_id == privacy_notice.id\n        assert (\n            email_current_preference.privacy_notice_history_id\n            == privacy_notice_history.id\n        )\n        assert (\n            email_current_preference.privacy_preference_history_id\n            == preference_history_record_for_email.id\n        )\n\n        # Now user saves a preference from the privacy center with verified email that also has their device id\n        preference_history_saved_with_both_email_and_device_id = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": email,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": hashed_email,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_in\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": provided_identity.id,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"http://example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        # Assert existing CurrentPrivacyPreference record was updated when the PrivacyPreferenceHistory was created\n        # and consolidated preferences for the email and the user device. The preferences for device only was deleted\n        current_preference = (\n            preference_history_saved_with_both_email_and_device_id.current_privacy_preference\n        )\n        assert current_preference.created_at is not None\n        assert current_preference.updated_at is not None\n        assert current_preference.preference == UserConsentPreference.opt_in\n        assert current_preference.provided_identity_id == provided_identity.id\n        assert (\n            current_preference.fides_user_device_provided_identity_id\n            == fides_user_provided_identity.id\n        )\n        assert current_preference.privacy_notice_id == privacy_notice.id\n        assert current_preference.privacy_notice_history_id == privacy_notice_history.id\n        assert (\n            current_preference.privacy_preference_history_id\n            == preference_history_saved_with_both_email_and_device_id.id\n        )\n\n        assert (\n            current_preference\n            == email_current_preference\n            != fides_user_device_current_preference\n        )\n        with pytest.raises(InvalidRequestError):\n            # Can't refresh because this preference has been deleted, and consolidated with the other\n            db.refresh(fides_user_device_current_preference)\n\n    def test_consolidate_current_tcf_privacy_preferences(\n        self, db, fides_user_provided_identity\n    ):\n        \"\"\"\n        Consolidate TCF Privacy preferences saved for the same individual\n        \"\"\"\n\n        # Let's first just save a tcf privacy preference under a fides user device id\n\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        preference_history_record_for_device = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": None,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"preference\": \"opt_in\",\n                \"request_origin\": \"tcf_overlay\",\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n                \"special_purpose\": 1,\n            },\n            check_name=False,\n        )\n\n        # Assert a CurrentPrivacyPreference record was created when the PrivacyPreferenceHistory was created\n        fides_user_device_current_preference = (\n            preference_history_record_for_device.current_privacy_preference\n        )\n        assert fides_user_device_current_preference.created_at is not None\n        assert fides_user_device_current_preference.updated_at is not None\n        assert (\n            fides_user_device_current_preference.preference\n            == UserConsentPreference.opt_in\n        )\n        assert fides_user_device_current_preference.provided_identity_id is None\n        assert (\n            fides_user_device_current_preference.fides_user_device_provided_identity_id\n            == fides_user_provided_identity.id\n        )\n        assert fides_user_device_current_preference.privacy_notice_id is None\n        assert fides_user_device_current_preference.special_purpose == 1\n        assert fides_user_device_current_preference.privacy_notice_history_id is None\n        assert (\n            fides_user_device_current_preference.privacy_preference_history_id\n            == preference_history_record_for_device.id\n        )\n\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\"test@email.com\"),\n            \"encrypted_value\": {\"value\": \"test@email.com\"},\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n        email, hashed_email = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.email\n        )\n\n        preference_history_record_for_email = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": email,\n                \"hashed_email\": hashed_email,\n                \"preference\": \"opt_in\",\n                \"provided_identity_id\": provided_identity.id,\n                \"special_purpose\": 1,\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_geography\": \"fr\",\n                \"url_recorded\": \"example.com/\",\n            },\n            check_name=False,\n        )\n\n        # Assert a new CurrentPrivacyPreference record was created when the PrivacyPreferenceHistory was created with email\n        email_current_preference = (\n            preference_history_record_for_email.current_privacy_preference\n        )\n        assert email_current_preference.created_at is not None\n        assert email_current_preference.updated_at is not None\n        assert email_current_preference.preference == UserConsentPreference.opt_in\n        assert email_current_preference.provided_identity_id == provided_identity.id\n        assert email_current_preference.fides_user_device_provided_identity_id is None\n        assert email_current_preference.privacy_notice_id is None\n        assert email_current_preference.special_purpose == 1\n        assert email_current_preference.privacy_notice_history_id is None\n        assert (\n            email_current_preference.privacy_preference_history_id\n            == preference_history_record_for_email.id\n        )\n\n        # Now user saves a preference from the tcf overlay with verified email that also has their device id\n        preference_history_saved_with_both_email_and_device_id = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": email,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": hashed_email,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"preference\": \"opt_in\",\n                \"provided_identity_id\": provided_identity.id,\n                \"special_purpose\": 1,\n                \"request_origin\": \"tcf_overlay\",\n                \"user_geography\": \"fr\",\n            },\n            check_name=False,\n        )\n\n        # Assert existing CurrentPrivacyPreference record was updated when the PrivacyPreferenceHistory was created\n        # and consolidated preferences for the email and the user device. The preferences for device only was deleted\n        current_preference = (\n            preference_history_saved_with_both_email_and_device_id.current_privacy_preference\n        )\n        assert current_preference.created_at is not None\n        assert current_preference.updated_at is not None\n        assert current_preference.preference == UserConsentPreference.opt_in\n        assert current_preference.provided_identity_id == provided_identity.id\n        assert (\n            current_preference.fides_user_device_provided_identity_id\n            == fides_user_provided_identity.id\n        )\n        assert current_preference.special_purpose == 1\n        assert current_preference.privacy_notice_id is None\n        assert current_preference.privacy_notice_history_id is None\n        assert (\n            current_preference.privacy_preference_history_id\n            == preference_history_saved_with_both_email_and_device_id.id\n        )\n\n        assert (\n            current_preference\n            == email_current_preference\n            != fides_user_device_current_preference\n        )\n        with pytest.raises(InvalidRequestError):\n            # Can't refresh because this preference has been deleted, and consolidated with the other\n            db.refresh(fides_user_device_current_preference)\n\n        current_preference.delete(db)\n        preference_history_saved_with_both_email_and_device_id.delete(db)\n        preference_history_record_for_device.delete(db)\n\n    def test_update_current_privacy_preferences_fides_id_only(\n        self, db, privacy_notice, fides_user_provided_identity\n    ):\n        \"\"\"Assert that if we save privacy preferences for a fides user device id and current preferences\n        already exists, the current preference is updated correctly.\"\n        \"\"\"\n\n        privacy_notice_history = privacy_notice.histories[0]\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        preference_history_record_for_device = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": None,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": None,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": None,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"http://example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        # Assert a CurrentPrivacyPreference record was created when the PrivacyPreferenceHistory was created\n        fides_user_device_current_preference = (\n            preference_history_record_for_device.current_privacy_preference\n        )\n        assert (\n            fides_user_device_current_preference.preference\n            == UserConsentPreference.opt_out\n        )\n        created_at = fides_user_device_current_preference.created_at\n        updated_at = fides_user_device_current_preference.updated_at\n\n        # Save a preference but change the preference from opt out to opt in\n        new_preference_history_record_for_device = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"email\": None,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": None,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": None,\n                \"phone_number\": None,\n                \"preference\": \"opt_in\",\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": None,\n                \"request_origin\": \"privacy_center\",\n                \"secondary_user_ids\": {\"ga_client_id\": \"test\"},\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_ca\",\n                \"url_recorded\": \"http://example.com/privacy_center\",\n            },\n            check_name=False,\n        )\n\n        # Assert a new CurrentPrivacyPreference record was created when the PrivacyPreferenceHistory was created with email\n        db.refresh(fides_user_device_current_preference)\n        assert (\n            fides_user_device_current_preference.preference\n            == UserConsentPreference.opt_in\n        )\n        assert fides_user_device_current_preference.created_at == created_at\n        assert fides_user_device_current_preference.updated_at > updated_at\n\n        new_preference_history_record_for_device.delete(db)\n        preference_history_record_for_device.delete(db)\n\n    def test_consent_record_type_property(\n        self,\n        privacy_preference_history_for_vendor,\n        privacy_preference_history_for_tcf_special_purpose,\n        privacy_preference_history_us_ca_provide,\n        privacy_preference_history_for_tcf_purpose_consent,\n    ):\n        assert (\n            privacy_preference_history_us_ca_provide.consent_record_type\n            == ConsentRecordType.privacy_notice_id\n        )\n\n        assert (\n            privacy_preference_history_for_vendor.consent_record_type\n            == ConsentRecordType.vendor_consent\n        )\n\n        assert (\n            privacy_preference_history_for_tcf_special_purpose.consent_record_type\n            == ConsentRecordType.special_purpose\n        )\n\n        assert (\n            privacy_preference_history_for_tcf_purpose_consent.consent_record_type\n            == ConsentRecordType.purpose_consent\n        )\n\n    def test_validate_before_saving_consent_history_helper(\n        self, db, fides_user_provided_identity, privacy_notice, system\n    ):\n        with pytest.raises(IdentityNotFoundException):\n            _validate_before_saving_consent_history(db, {})\n\n        with pytest.raises(PrivacyNoticeHistoryNotFound):\n            _validate_before_saving_consent_history(\n                db, {\"privacy_notice_history_id\": \"bad\"}\n            )\n\n        with pytest.raises(ConsentHistorySaveError):\n            # We need to save against one consent record type, not 2\n            _validate_before_saving_consent_history(\n                db,\n                {\n                    \"special_purpose\": 1,\n                    \"purpose_consent\": 1,\n                    \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                },\n            )\n\n        with pytest.raises(ConsentHistorySaveError):\n            # We need to save against one consent record type, not 0\n            _validate_before_saving_consent_history(\n                db,\n                {\n                    \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id\n                },\n            )\n\n        with pytest.raises(SystemNotFound):\n            # Attempted to save preferences against system that doesn't exist\n            _validate_before_saving_consent_history(\n                db,\n                {\n                    \"system_consent\": \"bad system\",\n                    \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                },\n            )\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"purpose_consent\": 1,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history is None\n        assert tcf_key == ConsentRecordType.purpose_consent.value\n        assert tcf_val == 1\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"special_purpose\": 2,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history is None\n        assert tcf_key == ConsentRecordType.special_purpose.value\n        assert tcf_val == 2\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"vendor_consent\": \"amplitude\",\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history is None\n        assert tcf_key == ConsentRecordType.vendor_consent.value\n        assert tcf_val == \"amplitude\"\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"feature\": 3,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history is None\n        assert tcf_key == ConsentRecordType.feature.value\n        assert tcf_val == 3\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"special_feature\": 4,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history is None\n        assert tcf_key == ConsentRecordType.special_feature.value\n        assert tcf_val == 4\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"privacy_notice_history_id\": privacy_notice.histories[0].id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history == privacy_notice.histories[0]\n        assert tcf_key is None\n        assert tcf_val is None\n\n        (\n            privacy_notice_history,\n            tcf_key,\n            tcf_val,\n        ) = _validate_before_saving_consent_history(\n            db,\n            {\n                \"system_consent\": system.id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n        )\n        assert privacy_notice_history is None\n        assert tcf_key == ConsentRecordType.system_consent.value\n        assert tcf_val == system.id\n\n\nclass TestDeterminePrivacyPreferenceHistoryRelevantSystems:\n    def test_determine_relevant_systems_for_notice(\n        self, db, privacy_notice, system_with_no_uses\n    ):\n        # Add data use that is not relevant for notice\n        pd_1 = PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"analytics\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"dataset_references\": None,\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db, privacy_notice_history=privacy_notice.histories[0]\n            )\n            == []\n        )\n\n        # Update data use to be relevant for notice\n        pd_1.data_use = privacy_notice.data_uses[0]\n        pd_1.save(db)\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db, privacy_notice_history=privacy_notice.histories[0]\n        ) == [system_with_no_uses.fides_key]\n\n        pd_1.delete(db)\n\n    def test_determine_relevant_systems_for_tcf_consent_purpose(\n        self, db, system_with_no_uses\n    ):\n        # Add data use to system that corresponds to purpose 3.  Also has consent legal basis, which is important.\n        pd_1 = PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"marketing.advertising.profiling\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"dataset_references\": None,\n                \"legal_basis_for_processing\": \"Consent\",\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db, tcf_field=TCFComponentType.purpose_consent.value, tcf_value=2\n            )\n            == []\n        )\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db, tcf_field=TCFComponentType.purpose_consent.value, tcf_value=3\n        ) == [system_with_no_uses.fides_key]\n\n        pd_1.delete(db)\n\n    def test_determine_relevant_systems_for_tcf_legitimate_interests_purpose(\n        self, db, system_with_no_uses\n    ):\n        # Add data use to system that corresponds to purpose 3.  Also has LI legal basis, which is important.\n        pd_1 = PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"marketing.advertising.profiling\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"dataset_references\": None,\n                \"legal_basis_for_processing\": \"Legitimate interests\",\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n\n        # This system is not relevant for purpose consent\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db, tcf_field=TCFComponentType.purpose_consent.value, tcf_value=3\n            )\n            == []\n        )\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db,\n            tcf_field=TCFComponentType.purpose_legitimate_interests.value,\n            tcf_value=3,\n        ) == [system_with_no_uses.fides_key]\n\n        pd_1.delete(db)\n\n    def test_determine_relevant_systems_for_tcf_special_purpose(\n        self, db, system_with_no_uses\n    ):\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db, tcf_field=TCFComponentType.special_purpose.value, tcf_value=2\n            )\n            == []\n        )\n\n        # Add relevant data use for special purpose 2 to system\n        pd_1 = PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"marketing.advertising.serving\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"legal_basis_for_processing\": \"Consent\",\n                \"dataset_references\": None,\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db, tcf_field=TCFComponentType.special_purpose.value, tcf_value=2\n        ) == [system_with_no_uses.fides_key]\n\n        pd_1.delete(db)\n\n    def test_determine_relevant_systems_for_tcf_consent_vendor(\n        self, db, system_with_no_uses\n    ):\n        system_with_no_uses.vendor_id = \"amplitude\"\n        system_with_no_uses.save(db)\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db,\n                tcf_field=TCFComponentType.vendor_consent.value,\n                tcf_value=\"amplitude\",\n            )\n            == []\n        )\n\n        # Vendor needs to have a relevant data use, and a specific consent legal basis to make the vendor relevant\n        PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"marketing.advertising.serving\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"legal_basis_for_processing\": \"Consent\",\n                \"dataset_references\": None,\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db, tcf_field=TCFComponentType.vendor_consent.value, tcf_value=\"amplitude\"\n        ) == [system_with_no_uses.fides_key]\n\n    def test_determine_relevant_systems_for_tcf_legitimate_interests_vendor(\n        self, db, system_with_no_uses\n    ):\n        system_with_no_uses.vendor_id = \"amplitude\"\n        system_with_no_uses.save(db)\n\n        # Vendor needs to have a relevant data use, and a specific consent legal basis to make the vendor relevant\n        PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"marketing.advertising.serving\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"legal_basis_for_processing\": \"Legitimate interests\",\n                \"dataset_references\": None,\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n\n        # Vendor not relevant for vendor consent\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db,\n                tcf_field=TCFComponentType.vendor_consent.value,\n                tcf_value=\"amplitude\",\n            )\n            == []\n        )\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db,\n            tcf_field=TCFComponentType.vendor_legitimate_interests.value,\n            tcf_value=\"amplitude\",\n        ) == [system_with_no_uses.fides_key]\n\n    def test_determine_relevant_systems_for_tcf_feature(self, db, system):\n        # Add feature that we don't have a preference for\n        decl = system.privacy_declarations[0]\n        decl.features = [\"Link different devices\"]\n        decl.save(db)\n\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db, tcf_field=TCFComponentType.feature.value, tcf_value=1\n            )\n            == []\n        )\n\n        decl.features = [\"Match and combine data from other data sources\"]\n        decl.data_use = \"marketing.advertising.serving\"\n        decl.legal_basis_for_processing = \"Consent\"\n        decl.save(db)\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db, tcf_field=TCFComponentType.feature.value, tcf_value=1\n        ) == [system.fides_key]\n\n    def test_determine_relevant_systems_for_tcf_special_feature(self, db, system):\n        # Add special feature that we're not saving preference for\n        decl = system.privacy_declarations[0]\n        decl.features = [\"Actively scan device characteristics for identification\"]\n        decl.data_use = \"marketing.advertising.serving\"\n        decl.legal_basis_for_processing = \"Consent\"\n        decl.save(db)\n\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db, tcf_field=TCFComponentType.feature.value, tcf_value=1\n            )\n            == []\n        )\n\n        decl.features = [\"Use precise geolocation data\"]\n        decl.save(db)\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db, tcf_field=TCFComponentType.special_feature.value, tcf_value=1\n        ) == [system.fides_key]\n\n    def test_determine_relevant_systems_for_tcf_system(self, db, system_with_no_uses):\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db,\n                tcf_field=TCFComponentType.system_consent.value,\n                tcf_value=\"non_matching_system_id\",\n            )\n            == []\n        )\n\n        pd = PrivacyDeclaration.create(\n            db=db,\n            data={\n                \"name\": \"Collect data for content performance\",\n                \"system_id\": system_with_no_uses.id,\n                \"data_categories\": [\"user.device.cookie_id\"],\n                \"data_use\": \"marketing.advertising.serving\",\n                \"data_qualifier\": \"aggregated.anonymized.unlinked_pseudonymized.pseudonymized.identified\",\n                \"data_subjects\": [\"customer\"],\n                \"dataset_references\": None,\n                \"egress\": None,\n                \"ingress\": None,\n            },\n        )\n\n        assert (\n            PrivacyPreferenceHistory.determine_relevant_systems(\n                db,\n                tcf_field=TCFComponentType.system_consent.value,\n                tcf_value=\"non_matching_system_id\",\n            )\n            == []\n        )\n\n        pd.legal_basis_for_processing = \"Consent\"\n        pd.save(db)\n\n        assert PrivacyPreferenceHistory.determine_relevant_systems(\n            db,\n            tcf_field=TCFComponentType.system_consent.value,\n            tcf_value=system_with_no_uses.id,\n        ) == [system_with_no_uses.fides_key]\n\n\nclass TestCurrentPrivacyPreference:\n    def test_get_preference_by_notice_and_fides_user_device(\n        self,\n        db,\n        empty_provided_identity,\n        privacy_preference_history_us_ca_provide_for_fides_user,\n        privacy_notice,\n        privacy_notice_us_ca_provide,\n        fides_user_provided_identity,\n    ):\n        pref = CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n            db=db,\n            fides_user_provided_identity=fides_user_provided_identity,\n            preference_type=ConsentRecordType.privacy_notice_id,\n            preference_value=privacy_notice_us_ca_provide.id,\n        )\n        assert (\n            pref\n            == privacy_preference_history_us_ca_provide_for_fides_user.current_privacy_preference\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=empty_provided_identity,\n                preference_type=ConsentRecordType.privacy_notice_id,\n                preference_value=privacy_notice.id,\n            )\n            is None\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                preference_type=ConsentRecordType.privacy_notice_id,\n                preference_value=privacy_notice.id,\n            )\n            is None\n        )\n\n    def test_get_preference_by_purpose_and_fides_user_device(\n        self,\n        db,\n        empty_provided_identity,\n        privacy_preference_history_for_tcf_purpose_consent,\n        fides_user_provided_identity,\n    ):\n        pref = CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n            db=db,\n            fides_user_provided_identity=fides_user_provided_identity,\n            preference_type=ConsentRecordType.purpose_consent,\n            preference_value=8,\n        )\n        assert (\n            pref\n            == privacy_preference_history_for_tcf_purpose_consent.current_privacy_preference\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=empty_provided_identity,\n                preference_type=ConsentRecordType.purpose_consent,\n                preference_value=8,\n            )\n            is None\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                preference_type=ConsentRecordType.purpose_consent,\n                preference_value=500,\n            )\n            is None\n        )\n\n    def test_get_preference_by_feature_and_fides_user_device(\n        self,\n        db,\n        empty_provided_identity,\n        privacy_preference_history_for_tcf_feature,\n        fides_user_provided_identity,\n    ):\n        pref = CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n            db=db,\n            fides_user_provided_identity=fides_user_provided_identity,\n            preference_type=ConsentRecordType.feature,\n            preference_value=2,\n        )\n        assert (\n            pref\n            == privacy_preference_history_for_tcf_feature.current_privacy_preference\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=empty_provided_identity,\n                preference_type=ConsentRecordType.feature,\n                preference_value=2,\n            )\n            is None\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                preference_type=ConsentRecordType.feature,\n                preference_value=500,\n            )\n            is None\n        )\n\n    def test_get_preference_by_system_and_fides_user_device(\n        self,\n        db,\n        empty_provided_identity,\n        privacy_preference_history_for_system,\n        fides_user_provided_identity,\n        system,\n    ):\n        pref = CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n            db=db,\n            fides_user_provided_identity=fides_user_provided_identity,\n            preference_type=ConsentRecordType.system_consent,\n            preference_value=system.id,\n        )\n        assert pref == privacy_preference_history_for_system.current_privacy_preference\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=empty_provided_identity,\n                preference_type=ConsentRecordType.system_consent,\n                preference_value=system.id,\n            )\n            is None\n        )\n\n        assert (\n            CurrentPrivacyPreference.get_preference_by_type_and_fides_user_device(\n                db=db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                preference_type=ConsentRecordType.system_consent,\n                preference_value=\"another system\",\n            )\n            is None\n        )\n\n\nclass TestAnonymizeIpAddress:\n    def test_anonymize_ip_address_empty_string(self):\n        assert anonymize_ip_address(\"\") is None\n\n    def test_anonymize_ip_address_none(self):\n        assert anonymize_ip_address(None) is None\n\n    def test_anonymize_bad_ip_address(self):\n        assert anonymize_ip_address(\"bad_address\") is None\n\n    def test_anonymize_ip_address_list(self):\n        assert anonymize_ip_address(\"[]\") is None\n\n    def test_anonymize_ipv4(self):\n        assert anonymize_ip_address(\"12.214.31.144\") == \"12.214.31.0\"\n\n    def test_anonymize_ipv6(self):\n        assert (\n            anonymize_ip_address(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")\n            == \"2001:0db8:85a3:0000:0000:0000:0000:0000\"\n        )\n\n\nclass TestServedNoticeHistory:\n    def test_create_served_notice_history_for_multiple_consent_attributes(\n        self, db, fides_user_provided_identity, privacy_experience_france_tcf_overlay\n    ):\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        with pytest.raises(ConsentHistorySaveError):\n            ServedNoticeHistory.create(\n                db=db,\n                data={\n                    \"anonymized_ip_address\": \"12.214.31.0\",\n                    \"fides_user_device\": fides_user_device_id,\n                    \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                    \"hashed_fides_user_device\": hashed_device_id,\n                    \"request_origin\": \"tcf_overlay\",\n                    \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                    \"user_geography\": \"fr\",\n                    \"url_recorded\": \"example.com/\",\n                    \"acknowledge_mode\": False,\n                    \"serving_component\": ServingComponent.tcf_overlay,\n                    \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n                    \"purpose_consent\": 1,\n                    \"special_purpose\": 2,\n                },\n                check_name=False,\n            )\n\n    def test_create_served_notice_history_for_notice(\n        self,\n        db,\n        privacy_notice,\n        privacy_experience_privacy_center,\n        experience_config_privacy_center,\n    ):\n        provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"email\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\"ethyca@email.com\"),\n            \"encrypted_value\": {\"value\": \"ethyca@email.com\"},\n        }\n        fides_user_provided_identity_data = {\n            \"privacy_request_id\": None,\n            \"field_name\": \"fides_user_device_id\",\n            \"hashed_value\": ProvidedIdentity.hash_value(\n                \"test_fides_user_device_id_abcdefg\"\n            ),\n            \"encrypted_value\": {\"value\": \"test_fides_user_device_id_abcdefg\"},\n        }\n        provided_identity = ProvidedIdentity.create(db, data=provided_identity_data)\n        fides_user_provided_identity = ProvidedIdentity.create(\n            db, data=fides_user_provided_identity_data\n        )\n\n        privacy_notice_history = privacy_notice.histories[0]\n\n        email, hashed_email = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.email\n        )\n        phone_number, hashed_phone_number = extract_identity_from_provided_identity(\n            provided_identity, ProvidedIdentityType.phone_number\n        )\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        served_notice_history_record = ServedNoticeHistory.create(\n            db=db,\n            data={\n                \"anonymized_ip_address\": \"12.214.31.0\",\n                \"email\": email,\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_email\": hashed_email,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"hashed_phone_number\": hashed_phone_number,\n                \"phone_number\": phone_number,\n                \"privacy_notice_history_id\": privacy_notice_history.id,\n                \"provided_identity_id\": provided_identity.id,\n                \"request_origin\": \"privacy_center\",\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"us_co\",\n                \"url_recorded\": \"http://example.com/privacy_center\",\n                \"acknowledge_mode\": False,\n                \"serving_component\": ServingComponent.privacy_center,\n                \"privacy_experience_id\": privacy_experience_privacy_center.id,\n                \"privacy_experience_config_history_id\": experience_config_privacy_center.histories[\n                    0\n                ].id,\n            },\n            check_name=False,\n        )\n        assert served_notice_history_record.email == \"ethyca@email.com\"\n        assert (\n            served_notice_history_record.hashed_email\n            == provided_identity.hashed_value\n            is not None\n        )\n        assert (\n            served_notice_history_record.fides_user_device\n            == fides_user_device_id\n            is not None\n        )\n        assert (\n            served_notice_history_record.hashed_fides_user_device\n            == hashed_device_id\n            is not None\n        )\n        assert (\n            served_notice_history_record.fides_user_device_provided_identity\n            == fides_user_provided_identity\n        )\n\n        assert served_notice_history_record.phone_number is None\n        assert served_notice_history_record.hashed_phone_number is None\n        assert (\n            served_notice_history_record.privacy_notice_history\n            == privacy_notice_history\n        )\n        assert served_notice_history_record.privacy_notice_id == privacy_notice.id\n        assert served_notice_history_record.provided_identity == provided_identity\n        assert (\n            served_notice_history_record.request_origin == RequestOrigin.privacy_center\n        )\n        assert (\n            served_notice_history_record.user_agent\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert served_notice_history_record.user_geography == \"us_co\"\n        assert (\n            served_notice_history_record.url_recorded\n            == \"http://example.com/privacy_center\"\n        )\n\n        # Assert ServedNoticeHistory record upserted\n        last_served_notice = served_notice_history_record.last_served_record\n        assert last_served_notice.privacy_notice_history == privacy_notice_history\n        assert last_served_notice.privacy_notice_id == privacy_notice.id\n        assert last_served_notice.provided_identity_id == provided_identity.id\n        assert (\n            last_served_notice.fides_user_device_provided_identity_id\n            == fides_user_provided_identity.id\n        )\n        assert (\n            last_served_notice.served_notice_history_id\n            == served_notice_history_record.id\n        )\n\n        served_notice_history_record.delete(db)\n        last_served_notice.delete(db)\n\n    def test_create_served_notice_history_for_tcf_purpose(\n        self, db, fides_user_provided_identity, privacy_experience_france_tcf_overlay\n    ):\n        (\n            fides_user_device_id,\n            hashed_device_id,\n        ) = extract_identity_from_provided_identity(\n            fides_user_provided_identity, ProvidedIdentityType.fides_user_device_id\n        )\n\n        served_notice_history_record = ServedNoticeHistory.create(\n            db=db,\n            data={\n                \"anonymized_ip_address\": \"12.214.31.0\",\n                \"fides_user_device\": fides_user_device_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n                \"hashed_fides_user_device\": hashed_device_id,\n                \"request_origin\": \"tcf_overlay\",\n                \"user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\",\n                \"user_geography\": \"fr\",\n                \"url_recorded\": \"example.com/\",\n                \"acknowledge_mode\": False,\n                \"serving_component\": ServingComponent.tcf_overlay,\n                \"privacy_experience_id\": privacy_experience_france_tcf_overlay.id,\n                \"purpose_consent\": 1,\n            },\n            check_name=False,\n        )\n        assert served_notice_history_record.email is None\n        assert served_notice_history_record.hashed_email is None\n        assert (\n            served_notice_history_record.fides_user_device\n            == fides_user_device_id\n            is not None\n        )\n        assert (\n            served_notice_history_record.hashed_fides_user_device\n            == hashed_device_id\n            is not None\n        )\n        assert (\n            served_notice_history_record.fides_user_device_provided_identity\n            == fides_user_provided_identity\n        )\n\n        assert served_notice_history_record.phone_number is None\n        assert served_notice_history_record.hashed_phone_number is None\n        assert served_notice_history_record.privacy_notice_history is None\n        assert served_notice_history_record.provided_identity is None\n        assert served_notice_history_record.request_origin == RequestOrigin.tcf_overlay\n        assert (\n            served_notice_history_record.user_agent\n            == \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/324.42 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/425.24\"\n        )\n        assert served_notice_history_record.user_geography == \"fr\"\n        assert served_notice_history_record.url_recorded == \"example.com/\"\n        assert served_notice_history_record.purpose_consent == 1\n        assert served_notice_history_record.special_purpose is None\n        assert served_notice_history_record.feature is None\n        assert served_notice_history_record.special_feature is None\n        assert served_notice_history_record.vendor_consent is None\n        assert (\n            served_notice_history_record.consent_record_type\n            == ConsentRecordType.purpose_consent\n        )\n\n        # Assert ServedNoticeHistory record upserted\n        last_served_notice = served_notice_history_record.last_served_record\n        assert last_served_notice.privacy_notice_history is None\n        assert last_served_notice.privacy_notice_id is None\n        assert last_served_notice.purpose_consent == 1\n        assert last_served_notice.special_purpose is None\n        assert last_served_notice.feature is None\n        assert last_served_notice.special_feature is None\n        assert last_served_notice.vendor_consent is None\n        assert last_served_notice.provided_identity_id is None\n        assert (\n            last_served_notice.fides_user_device_provided_identity_id\n            == fides_user_provided_identity.id\n        )\n        assert (\n            last_served_notice.served_notice_history_id\n            == served_notice_history_record.id\n        )\n\n        served_notice_history_record.delete(db)\n        last_served_notice.delete(db)\n\n    def test_consent_record_type_property(\n        self,\n        served_notice_history,\n        served_notice_history_for_tcf_purpose,\n        served_notice_history_for_tcf_special_purpose,\n    ):\n        assert (\n            served_notice_history_for_tcf_special_purpose.consent_record_type\n            == ConsentRecordType.special_purpose\n        )\n\n        assert (\n            served_notice_history.consent_record_type\n            == ConsentRecordType.privacy_notice_id\n        )\n\n        assert (\n            served_notice_history_for_tcf_purpose.consent_record_type\n            == ConsentRecordType.purpose_consent\n        )\n\n\nclass TestLastServedNotice:\n    def test_served_latest_version_of_notice(\n        self,\n        db,\n        served_notice_history_us_ca_provide_for_fides_user,\n        privacy_notice_us_ca_provide,\n    ):\n        last_served = (\n            served_notice_history_us_ca_provide_for_fides_user.last_served_record\n        )\n        assert last_served.record_matches_current_version is True\n\n        privacy_notice_us_ca_provide.update(db, data={\"description\": \"new_description\"})\n        assert privacy_notice_us_ca_provide.version == 2.0\n        assert privacy_notice_us_ca_provide.description == \"new_description\"\n\n        assert last_served.record_matches_current_version is False\n\n    def test_served_latest_tcf_version(\n        self,\n        db,\n        served_notice_history_for_tcf_purpose,\n    ):\n        last_served = served_notice_history_for_tcf_purpose.last_served_record\n        assert last_served.record_matches_current_version is True\n\n        # Just for demonstration\n        last_served.update(db, data={\"tcf_version\": \"1.0\"})\n        assert last_served.record_matches_current_version is False\n\n    def test_get_last_served_for_notice_and_fides_user_device(\n        self,\n        db,\n        fides_user_provided_identity,\n        served_notice_history_us_ca_provide_for_fides_user,\n        privacy_notice_us_ca_provide,\n        empty_provided_identity,\n        privacy_notice,\n    ):\n        retrieved_record = (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                record_type=ConsentRecordType.privacy_notice_id,\n                preference_value=privacy_notice_us_ca_provide.id,\n            )\n        )\n        assert (\n            retrieved_record\n            == served_notice_history_us_ca_provide_for_fides_user.last_served_record\n        )\n\n        assert (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=empty_provided_identity,\n                record_type=ConsentRecordType.privacy_notice_id,\n                preference_value=privacy_notice_us_ca_provide.id,\n            )\n            is None\n        )\n        assert (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                record_type=ConsentRecordType.privacy_notice_id,\n                preference_value=privacy_notice.id,\n            )\n            is None\n        )\n\n    def test_get_last_served_for_purpose_and_fides_user_device(\n        self,\n        db,\n        fides_user_provided_identity,\n        empty_provided_identity,\n        served_notice_history_for_tcf_purpose,\n    ):\n        retrieved_record = (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                record_type=ConsentRecordType.purpose_consent,\n                preference_value=8,\n            )\n        )\n        assert (\n            retrieved_record == served_notice_history_for_tcf_purpose.last_served_record\n        )\n\n        assert (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=empty_provided_identity,\n                record_type=ConsentRecordType.purpose_consent,\n                preference_value=8,\n            )\n            is None\n        )\n        assert (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                record_type=ConsentRecordType.purpose_consent,\n                preference_value=200,\n            )\n            is None\n        )\n\n    def test_get_last_served_for_feature_and_fides_user_device(\n        self,\n        db,\n        fides_user_provided_identity,\n        empty_provided_identity,\n        served_notice_history_for_tcf_feature,\n    ):\n        retrieved_record = (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                record_type=ConsentRecordType.feature,\n                preference_value=2,\n            )\n        )\n        assert (\n            retrieved_record == served_notice_history_for_tcf_feature.last_served_record\n        )\n\n        assert (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=empty_provided_identity,\n                record_type=ConsentRecordType.feature,\n                preference_value=2,\n            )\n            is None\n        )\n        assert (\n            LastServedNotice.get_last_served_for_record_type_and_fides_user_device(\n                db,\n                fides_user_provided_identity=fides_user_provided_identity,\n                record_type=ConsentRecordType.feature,\n                preference_value=200,\n            )\n            is None\n        )\n", "\"\"\"Test consent utils\"\"\"\nfrom __future__ import annotations\n\nfrom html import unescape\n\nimport pytest\nfrom fastapi import HTTPException\nfrom fideslang import DataUse\nfrom sqlalchemy.orm.attributes import flag_modified\nfrom starlette.exceptions import HTTPException\n\nfrom fides.api.app_setup import DEFAULT_PRIVACY_NOTICES_PATH\nfrom fides.api.models.privacy_experience import (\n    BannerEnabled,\n    ComponentType,\n    PrivacyExperience,\n)\nfrom fides.api.models.privacy_notice import (\n    ConsentMechanism,\n    EnforcementLevel,\n    PrivacyNoticeRegion,\n    PrivacyNoticeTemplate,\n)\nfrom fides.api.models.privacy_preference import PrivacyPreferenceHistory\nfrom fides.api.models.sql_models import DataUse as sql_DataUse\nfrom fides.api.schemas.privacy_notice import PrivacyNoticeCreation, PrivacyNoticeWithId\nfrom fides.api.util.consent_util import (\n    EEA_COUNTRIES,\n    add_complete_system_status_for_consent_reporting,\n    add_errored_system_status_for_consent_reporting,\n    cache_initial_status_and_identities_for_consent_reporting,\n    create_default_experience_config,\n    create_privacy_notices_util,\n    create_tcf_experiences_on_startup,\n    get_fides_user_device_id_provided_identity,\n    load_default_notices_on_startup,\n    should_opt_in_to_service,\n    upsert_privacy_notice_templates_util,\n    validate_notice_data_uses,\n)\n\n\nclass TestShouldOptIntoService:\n    @pytest.mark.parametrize(\n        \"preference, should_opt_in\",\n        [(\"opt_in\", True), (\"opt_out\", False), (\"acknowledge\", None)],\n    )\n    def test_matching_data_use(\n        self,\n        preference,\n        should_opt_in,\n        db,\n        system,\n        privacy_request_with_consent_policy,\n        privacy_notice,\n        fides_user_provided_identity,\n    ):\n        \"\"\"\n        Privacy Notice Enforcement Level = \"system_wide\"\n        Privacy Notice Data Use = \"marketing.advertising\"\n        System Data Use = \"marketing.advertising\"\n        \"\"\"\n        pref = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": preference,\n                \"privacy_notice_history_id\": privacy_notice.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref.privacy_request_id = privacy_request_with_consent_policy.id\n        pref.save(db)\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference == should_opt_in\n\n        pref.delete(db)\n\n    @pytest.mark.parametrize(\n        \"preference, should_opt_in\",\n        [(\"opt_in\", True), (\"opt_out\", False), (\"acknowledge\", None)],\n    )\n    def test_notice_use_is_parent_of_system_use(\n        self,\n        preference,\n        should_opt_in,\n        db,\n        system,\n        privacy_notice_us_ca_provide,\n        privacy_request_with_consent_policy,\n        fides_user_provided_identity,\n    ):\n        \"\"\"\n        Privacy Notice Enforcement Level = \"system_wide\"\n        Privacy Notice Data Use = \"essential\"\n        System Data Use = \"essential.service.operations\"\n        \"\"\"\n        privacy_declarations = system.privacy_declarations\n        system.privacy_declarations[0].update(\n            db=db, data={\"data_use\": \"essential.service.operations\"}\n        )\n\n        system.privacy_declarations = privacy_declarations\n        flag_modified(system, \"privacy_declarations\")\n        system.save(db)\n\n        pref = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": preference,\n                \"privacy_notice_history_id\": privacy_notice_us_ca_provide.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref.privacy_request_id = privacy_request_with_consent_policy.id\n        pref.save(db)\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference == should_opt_in\n        pref.delete(db)\n\n    @pytest.mark.parametrize(\n        \"preference, should_opt_in\",\n        [(\"opt_in\", None), (\"opt_out\", None), (\"acknowledge\", None)],\n    )\n    def test_notice_use_is_child_of_system_use(\n        self,\n        preference,\n        should_opt_in,\n        db,\n        system,\n        privacy_notice_us_co_provide_service_operations,\n        privacy_request_with_consent_policy,\n        fides_user_provided_identity,\n    ):\n        \"\"\"\n        Privacy Notice Enforcement Level = \"system_wide\"\n        Privacy Notice Data Use = \"essential.service.operations\"\n        System Data Use = \"essential\"\n        \"\"\"\n        privacy_declarations = system.privacy_declarations\n        system.privacy_declarations[0].update(db=db, data={\"data_use\": \"essential\"})\n        system.privacy_declarations = privacy_declarations\n        flag_modified(system, \"privacy_declarations\")\n        system.save(db)\n\n        pref = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": preference,\n                \"privacy_notice_history_id\": privacy_notice_us_co_provide_service_operations.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref.privacy_request_id = privacy_request_with_consent_policy.id\n        pref.save(db)\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference == should_opt_in\n        pref.delete(db)\n\n    @pytest.mark.parametrize(\n        \"preference, should_opt_in\",\n        [(\"opt_in\", None), (\"opt_out\", None), (\"acknowledge\", None)],\n    )\n    def test_enforcement_frontend_only(\n        self,\n        preference,\n        should_opt_in,\n        db,\n        system,\n        privacy_request_with_consent_policy,\n        privacy_notice_fr_provide_service_frontend_only,\n        fides_user_provided_identity,\n    ):\n        \"\"\"\n        Privacy Notice Enforcement Level = \"frontend\"\n        Privacy Notice Data Use = \"essential.service\" but not checked\n        System Data Use = \"marketing.advertising\"\n        \"\"\"\n        pref = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": preference,\n                \"privacy_notice_history_id\": privacy_notice_fr_provide_service_frontend_only.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref.privacy_request_id = privacy_request_with_consent_policy.id\n        pref.save(db)\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference == should_opt_in\n        pref.delete(db)\n\n    @pytest.mark.parametrize(\n        \"preference, should_opt_in\",\n        [(\"opt_in\", True), (\"opt_out\", False), (\"acknowledge\", None)],\n    )\n    def test_no_system_means_no_data_use_check(\n        self,\n        preference,\n        should_opt_in,\n        db,\n        privacy_notice_us_co_provide_service_operations,\n        privacy_request_with_consent_policy,\n        fides_user_provided_identity,\n    ):\n        \"\"\"\n        Privacy Notice Enforcement Level = \"system_wide\"\n        Privacy Notice Data Use = \"essential.service.operations\"\n        \"\"\"\n\n        pref = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": preference,\n                \"privacy_notice_history_id\": privacy_notice_us_co_provide_service_operations.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref.privacy_request_id = privacy_request_with_consent_policy.id\n        pref.save(db)\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            None, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference == should_opt_in\n        pref.delete(db)\n\n    def test_conflict_preferences_opt_out_wins(\n        self,\n        db,\n        privacy_request_with_consent_policy,\n        privacy_notice,\n        privacy_notice_us_ca_provide,\n        fides_user_provided_identity,\n    ):\n        \"\"\"\n        Privacy Notice Enforcement Level = \"system_wide\"\n        Privacy Notice Data Use = \"marketing.advertising\" but not checked w/ no system\n        other Privacy Notice Data Use = \"essential\" but not checked w/ no system\n        \"\"\"\n        pref_1 = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": \"opt_in\",\n                \"privacy_notice_history_id\": privacy_notice.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref_2 = PrivacyPreferenceHistory.create(\n            db=db,\n            data={\n                \"preference\": \"opt_out\",\n                \"privacy_notice_history_id\": privacy_notice_us_ca_provide.privacy_notice_history_id,\n                \"fides_user_device_provided_identity_id\": fides_user_provided_identity.id,\n            },\n            check_name=False,\n        )\n        pref_1.privacy_request_id = privacy_request_with_consent_policy.id\n        pref_1.save(db)\n        pref_2.privacy_request_id = privacy_request_with_consent_policy.id\n        pref_2.save(db)\n\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            None, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference is False\n        assert filtered_preferences == [pref_2]\n        pref_1.delete(db)\n        pref_2.delete(db)\n\n    def test_old_workflow_preferences_saved_with_respect_to_data_use(\n        self,\n        system,\n        privacy_request_with_consent_policy,\n    ):\n        \"\"\"\n        Test old workflow where executable preferences were cached on PrivacyRequest.consent_preferences\n        \"\"\"\n        privacy_request_with_consent_policy.consent_preferences = [\n            {\"data_use\": \"marketing.advertising\", \"opt_in\": False}\n        ]\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference is False\n        assert filtered_preferences == []\n\n        privacy_request_with_consent_policy.consent_preferences = [\n            {\"data_use\": \"marketing.advertising\", \"opt_in\": True}\n        ]\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference is True\n        assert filtered_preferences == []\n\n        privacy_request_with_consent_policy.consent_preferences = [\n            {\"data_use\": \"marketing.advertising\", \"opt_in\": True},\n            {\"data_use\": \"functional\", \"opt_in\": False},\n        ]\n        collapsed_opt_in_preference, filtered_preferences = should_opt_in_to_service(\n            system, privacy_request_with_consent_policy\n        )\n        assert collapsed_opt_in_preference is False\n        assert filtered_preferences == []\n\n\nclass TestCacheSystemStatusesForConsentReporting:\n    def test_cache_initial_status_and_identities_for_consent_reporting(\n        self,\n        db,\n        privacy_request_with_consent_policy,\n        connection_config,\n        privacy_preference_history,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ):\n        privacy_preference_history.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.save(db)\n\n        privacy_preference_history_fr_provide_service_frontend_only.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.save(db)\n\n        cache_initial_status_and_identities_for_consent_reporting(\n            db,\n            privacy_request_with_consent_policy,\n            connection_config,\n            relevant_preferences=[\n                privacy_preference_history_fr_provide_service_frontend_only\n            ],\n            relevant_user_identities={\"email\": \"customer-1@example.com\"},\n        )\n\n        db.refresh(privacy_preference_history)\n        db.refresh(privacy_preference_history_fr_provide_service_frontend_only)\n\n        # Relevant systems\n        assert (\n            privacy_preference_history_fr_provide_service_frontend_only.affected_system_status\n            == {connection_config.name: \"pending\"}\n        )\n        assert (\n            privacy_preference_history_fr_provide_service_frontend_only.secondary_user_ids\n            == {\"email\": \"customer-1@example.com\"}\n        )\n\n        # non-relevant systems\n        assert privacy_preference_history.affected_system_status == {\n            connection_config.name: \"skipped\"\n        }\n        assert privacy_preference_history.secondary_user_ids is None\n\n    def test_add_complete_system_status_for_consent_reporting(\n        self,\n        db,\n        privacy_request_with_consent_policy,\n        connection_config,\n        privacy_preference_history,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ):\n        privacy_preference_history.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.save(db)\n\n        privacy_preference_history_fr_provide_service_frontend_only.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.save(db)\n\n        cache_initial_status_and_identities_for_consent_reporting(\n            db,\n            privacy_request_with_consent_policy,\n            connection_config,\n            relevant_preferences=[\n                privacy_preference_history_fr_provide_service_frontend_only\n            ],\n            relevant_user_identities={\"email\": \"customer-1@example.com\"},\n        )\n\n        add_complete_system_status_for_consent_reporting(\n            db, privacy_request_with_consent_policy, connection_config\n        )\n\n        db.refresh(privacy_preference_history)\n        db.refresh(privacy_preference_history_fr_provide_service_frontend_only)\n\n        # Relevant systems\n        assert (\n            privacy_preference_history_fr_provide_service_frontend_only.affected_system_status\n            == {connection_config.name: \"complete\"}\n        )\n        assert (\n            privacy_preference_history_fr_provide_service_frontend_only.secondary_user_ids\n            == {\"email\": \"customer-1@example.com\"}\n        )\n\n        # non-relevant systems\n        assert privacy_preference_history.affected_system_status == {\n            connection_config.name: \"skipped\"\n        }\n        assert privacy_preference_history.secondary_user_ids is None\n\n    def test_add_error_system_status_for_consent_reporting(\n        self,\n        db,\n        privacy_request_with_consent_policy,\n        connection_config,\n        privacy_preference_history,\n        privacy_preference_history_fr_provide_service_frontend_only,\n    ):\n        privacy_preference_history.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.save(db)\n\n        privacy_preference_history_fr_provide_service_frontend_only.privacy_request_id = (\n            privacy_request_with_consent_policy.id\n        )\n        privacy_preference_history.save(db)\n\n        cache_initial_status_and_identities_for_consent_reporting(\n            db,\n            privacy_request_with_consent_policy,\n            connection_config,\n            relevant_preferences=[\n                privacy_preference_history_fr_provide_service_frontend_only\n            ],\n            relevant_user_identities={\"email\": \"customer-1@example.com\"},\n        )\n\n        add_errored_system_status_for_consent_reporting(\n            db, privacy_request_with_consent_policy, connection_config\n        )\n\n        db.refresh(privacy_preference_history)\n        db.refresh(privacy_preference_history_fr_provide_service_frontend_only)\n\n        # Relevant systems\n        assert (\n            privacy_preference_history_fr_provide_service_frontend_only.affected_system_status\n            == {connection_config.name: \"error\"}\n        )\n        assert (\n            privacy_preference_history_fr_provide_service_frontend_only.secondary_user_ids\n            == {\"email\": \"customer-1@example.com\"}\n        )\n\n        # non-relevant systems\n        assert privacy_preference_history.affected_system_status == {\n            connection_config.name: \"skipped\"\n        }\n        assert privacy_preference_history.secondary_user_ids is None\n\n\nclass TestGetFidesUserProvidedIdentity:\n    def test_no_identifier_supplied(self, db):\n        provided_identity = get_fides_user_device_id_provided_identity(db, None)\n        assert provided_identity is None\n\n    def test_no_provided_identifier_exists(self, db):\n        provided_identity = get_fides_user_device_id_provided_identity(\n            db, \"fides_user_device_id\"\n        )\n        assert provided_identity is None\n\n    def test_get_fides_user_device_id_provided_identity(\n        self, db, fides_user_provided_identity\n    ):\n        provided_identity = get_fides_user_device_id_provided_identity(\n            db, \"051b219f-20e4-45df-82f7-5eb68a00889f\"\n        )\n        assert provided_identity == fides_user_provided_identity\n\n\nclass TestCreatePrivacyNoticeUtils:\n    def test_create_privacy_notices_util(self, db, load_default_data_uses):\n        schema = PrivacyNoticeCreation(\n            name=\"Test Notice\",\n            notice_key=\"test_notice\",\n            description=\"test description\",\n            internal_description=\"internal description\",\n            regions=[\"it\"],\n            consent_mechanism=\"opt_out\",\n            data_uses=[\"train_ai_system\"],\n            enforcement_level=EnforcementLevel.not_applicable,\n            displayed_in_privacy_center=True,\n        )\n\n        privacy_notices, affected_regions = create_privacy_notices_util(db, [schema])\n        assert affected_regions == {PrivacyNoticeRegion.it}\n\n        assert len(privacy_notices) == 1\n        notice = privacy_notices[0]\n        assert notice.name == \"Test Notice\"\n        assert notice.notice_key == \"test_notice\"\n        assert notice.description == \"test description\"\n        assert notice.internal_description == \"internal description\"\n        assert notice.regions == [PrivacyNoticeRegion.it]\n        assert notice.consent_mechanism == ConsentMechanism.opt_out\n        assert notice.enforcement_level == EnforcementLevel.not_applicable\n        assert notice.disabled is False\n        assert notice.has_gpc_flag is False\n        assert notice.displayed_in_privacy_center is True\n        assert notice.displayed_in_overlay is False\n        assert notice.displayed_in_api is False\n\n        assert notice.privacy_notice_history_id is not None\n        history = notice.histories[0]\n        assert history.id == notice.privacy_notice_history_id\n        assert history.name == \"Test Notice\"\n        assert history.notice_key == \"test_notice\"\n        assert history.description == \"test description\"\n        assert history.internal_description == \"internal description\"\n        assert history.regions == [PrivacyNoticeRegion.it]\n        assert history.consent_mechanism == ConsentMechanism.opt_out\n        assert history.enforcement_level == EnforcementLevel.not_applicable\n        assert history.disabled is False\n        assert history.has_gpc_flag is False\n        assert history.displayed_in_privacy_center is True\n        assert history.displayed_in_overlay is False\n        assert history.displayed_in_api is False\n\n        db.delete(notice.histories[0])\n        db.delete(notice)\n\n\nclass TestLoadDefaultNotices:\n    def test_load_default_notices(self, db, load_default_data_uses):\n        # Load notice from a file that only has one template (A) defined.\n        # This should create one template (A), one notice (A), and one notice history (A)\n        (\n            overlay_exp,\n            privacy_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n        assert overlay_exp is None\n        assert privacy_exp is None\n\n        new_templates, new_privacy_notices = load_default_notices_on_startup(\n            db, \"tests/fixtures/test_privacy_notice.yml\"\n        )\n        assert len(new_privacy_notices) == 1\n        notice = new_privacy_notices[0]\n        assert notice.name == \"Test Privacy Notice\"\n        assert notice.notice_key == \"test_privacy_notice\"\n        assert notice.description == \"This website uses cookies.\"\n        assert (\n            unescape(notice.internal_description)\n            == \"This is a contrived template for testing.  This field's for internal testing!\"\n        )\n        assert (\n            notice.internal_description\n            == \"This is a contrived template for testing.  This field&#x27;s for internal testing!\"\n        )  # Stored escaped\n        assert notice.regions == [PrivacyNoticeRegion.us_ak]\n        assert notice.consent_mechanism == ConsentMechanism.opt_in\n        assert notice.enforcement_level == EnforcementLevel.system_wide\n        assert notice.disabled is False\n        assert notice.has_gpc_flag is True\n        assert notice.displayed_in_privacy_center is False\n        assert notice.displayed_in_overlay is True\n        assert notice.displayed_in_api is False\n        assert notice.version == 1.0\n        (\n            overlay_exp,\n            privacy_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_ak\n        )\n        assert overlay_exp is not None\n        assert privacy_exp is None\n\n        assert notice.privacy_notice_history_id is not None\n        history = notice.histories[0]\n        assert history.name == \"Test Privacy Notice\"\n        assert history.notice_key == \"test_privacy_notice\"\n        assert history.description == \"This website uses cookies.\"\n        assert (\n            unescape(history.internal_description)\n            == \"This is a contrived template for testing.  This field's for internal testing!\"\n        )\n        assert history.regions == [PrivacyNoticeRegion.us_ak]\n        assert history.consent_mechanism == ConsentMechanism.opt_in\n        assert history.enforcement_level == EnforcementLevel.system_wide\n        assert history.disabled is False\n        assert history.has_gpc_flag is True\n        assert history.displayed_in_privacy_center is False\n        assert history.displayed_in_overlay is True\n        assert history.displayed_in_api is False\n        assert history.version == 1.0\n        assert history.origin == new_templates[0].id\n\n        assert len(new_templates) == 1\n        assert new_templates[0].id == notice.origin\n        template_id = notice.origin\n        template = db.query(PrivacyNoticeTemplate).get(template_id)\n        assert template.name == \"Test Privacy Notice\"\n        assert template.description == \"This website uses cookies.\"\n        assert (\n            unescape(template.internal_description)\n            == \"This is a contrived template for testing.  This field's for internal testing!\"\n        )\n        assert template.regions == [PrivacyNoticeRegion.us_ak]\n        assert template.consent_mechanism == ConsentMechanism.opt_in\n        assert template.enforcement_level == EnforcementLevel.system_wide\n        assert template.disabled is False\n        assert template.has_gpc_flag is True\n        assert template.displayed_in_privacy_center is False\n        assert template.displayed_in_overlay is True\n        assert template.displayed_in_api is False\n        assert (\n            template.id == \"pri-5bd5cee7-8c8c-4da7-9a5c-7617a7d4dbb2\"\n        ), \"Id hardoded in template\"\n\n        # Load two notices from new file.\n        # One notice is an update of the previous template (A), the other is brand new (B).\n        # This should update the existing template (A), create a separate new template (B),\n        # and then create a new notice (B) and notice history (B) from just the new template (B).\n        # Leave the existing notice (A) and notice history (A) untouched.\n        (\n            overlay_exp,\n            privacy_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_al\n        )\n        assert overlay_exp is None\n        assert privacy_exp is None\n\n        new_templates, new_privacy_notices = load_default_notices_on_startup(\n            db, \"tests/fixtures/test_privacy_notice_update.yml\"\n        )\n        assert len(new_templates) == 1\n        # New template (B) created\n        new_template = new_templates[0]\n        assert new_template.name == \"Other Privacy Notice\"\n        assert (\n            new_template.description == \"This website uses a large amount of cookies.\"\n        )\n        assert (\n            new_template.internal_description\n            == \"This is another template added for testing\"\n        )\n        assert new_template.regions == [PrivacyNoticeRegion.us_al]\n        assert new_template.consent_mechanism == ConsentMechanism.opt_out\n        assert new_template.enforcement_level == EnforcementLevel.frontend\n        assert new_template.disabled is True\n        assert new_template.has_gpc_flag is False\n        assert new_template.displayed_in_privacy_center is True\n        assert new_template.displayed_in_overlay is False\n        assert new_template.displayed_in_api is False\n        assert new_template.id != template.id\n        assert new_template.id == \"pri-685486d9-f532-4951-bb1a-b15fea586ff8\"\n\n        # Updated template A, consent mechanism and internal description were updated\n        db.refresh(template)\n        assert template.name == \"Test Privacy Notice\"\n        assert template.description == \"This website uses cookies.\"\n        assert (\n            template.internal_description\n            == \"This is an existing template that we are updating to make the default opt_out instead.\"\n        )\n        assert template.regions == [PrivacyNoticeRegion.us_ak]\n        assert template.consent_mechanism == ConsentMechanism.opt_out  # Updated value\n        assert template.enforcement_level == EnforcementLevel.system_wide\n        assert template.disabled is False\n        assert template.has_gpc_flag is True\n        assert template.displayed_in_privacy_center is False\n        assert template.displayed_in_overlay is True\n        assert template.displayed_in_api is False\n\n        # Newly created privacy notice (B)\n        assert len(new_privacy_notices) == 1\n        new_privacy_notice = new_privacy_notices[0]\n        assert new_privacy_notice.name == \"Other Privacy Notice\"\n        assert (\n            new_privacy_notice.description\n            == \"This website uses a large amount of cookies.\"\n        )\n        assert (\n            new_privacy_notice.internal_description\n            == \"This is another template added for testing\"\n        )\n        assert new_privacy_notice.regions == [PrivacyNoticeRegion.us_al]\n        assert new_privacy_notice.consent_mechanism == ConsentMechanism.opt_out\n        assert new_privacy_notice.enforcement_level == EnforcementLevel.frontend\n        assert new_privacy_notice.disabled is True\n        assert new_privacy_notice.has_gpc_flag is False\n        assert new_privacy_notice.displayed_in_privacy_center is True\n        assert new_privacy_notice.displayed_in_overlay is False\n        assert new_privacy_notice.displayed_in_api is False\n        assert new_privacy_notice.version == 1.0\n        assert new_privacy_notice.id != notice.id\n\n        (\n            overlay_exp,\n            privacy_exp,\n        ) = PrivacyExperience.get_overlay_and_privacy_center_experience_by_region(\n            db, PrivacyNoticeRegion.us_al\n        )\n        assert overlay_exp is None\n        assert privacy_exp is not None\n\n        # Newly created privacy notice history (B)\n        assert new_privacy_notice.privacy_notice_history_id is not None\n        new_history = new_privacy_notice.histories[0]\n        assert new_history.name == \"Other Privacy Notice\"\n        assert new_history.description == \"This website uses a large amount of cookies.\"\n        assert (\n            new_history.internal_description\n            == \"This is another template added for testing\"\n        )\n        assert new_history.regions == [PrivacyNoticeRegion.us_al]\n        assert new_history.consent_mechanism == ConsentMechanism.opt_out\n        assert new_history.enforcement_level == EnforcementLevel.frontend\n        assert new_history.disabled is True\n        assert new_history.has_gpc_flag is False\n        assert new_history.displayed_in_privacy_center is True\n        assert new_history.displayed_in_overlay is False\n        assert new_history.displayed_in_api is False\n        assert new_history.version == 1.0\n        assert new_history.id != notice.id\n        assert new_history.version == 1.0\n\n        # Existing notice A - assert this wasn't updated.\n        db.refresh(notice)\n        assert notice.name == \"Test Privacy Notice\"\n        assert notice.description == \"This website uses cookies.\"\n        assert (\n            unescape(notice.internal_description)\n            == \"This is a contrived template for testing.  This field's for internal testing!\"\n        )\n        assert notice.regions == [PrivacyNoticeRegion.us_ak]\n        assert notice.consent_mechanism == ConsentMechanism.opt_in\n        assert notice.enforcement_level == EnforcementLevel.system_wide\n        assert notice.disabled is False\n        assert notice.has_gpc_flag is True\n        assert notice.displayed_in_privacy_center is False\n        assert notice.displayed_in_overlay is True\n        assert notice.displayed_in_api is False\n        assert notice.version == 1.0\n        assert notice.histories.count() == 1\n\n        db.refresh(history)\n        # Existing history B - assert this wasn't updated.\n        assert history.name == \"Test Privacy Notice\"\n        assert history.description == \"This website uses cookies.\"\n        assert (\n            unescape(history.internal_description)\n            == \"This is a contrived template for testing.  This field's for internal testing!\"\n        )\n        assert history.regions == [PrivacyNoticeRegion.us_ak]\n        assert history.consent_mechanism == ConsentMechanism.opt_in\n        assert history.enforcement_level == EnforcementLevel.system_wide\n        assert history.disabled is False\n        assert history.has_gpc_flag is True\n        assert history.displayed_in_privacy_center is False\n        assert history.displayed_in_overlay is True\n        assert history.displayed_in_api is False\n        assert history.version == 1.0\n        assert history.id != new_history.id\n\n        with pytest.raises(HTTPException):\n            load_default_notices_on_startup(\n                db, \"tests/fixtures/test_bad_privacy_notices_update.yml\"\n            )\n\n        new_history.delete(db)\n        history.delete(db)\n\n        new_privacy_notice.delete(db)\n        notice.delete(db)\n\n        new_template.delete(db)\n        template.delete(db)\n\n    def test_load_actual_default_notices(self, db):\n        \"\"\"Sanity check, makings sure that default privacy notices don't load with errors\"\"\"\n        new_templates, new_privacy_notices = load_default_notices_on_startup(\n            db, DEFAULT_PRIVACY_NOTICES_PATH\n        )\n        assert len(new_templates) >= 1\n        assert len(new_privacy_notices) >= 1\n\n\nclass TestUpsertPrivacyNoticeTemplates:\n    def test_ensure_unique_ids(self, db, load_default_data_uses):\n        \"\"\"Can help make sure we don't actually try to upload templates with duplicate\n        ids due to copy/pasting\n        \"\"\"\n        with pytest.raises(HTTPException) as exc:\n            upsert_privacy_notice_templates_util(\n                db,\n                [\n                    PrivacyNoticeWithId(\n                        id=\"test_id_1\",\n                        name=\"A\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_in,\n                        data_uses=[\"essential\"],\n                        enforcement_level=EnforcementLevel.system_wide,\n                        displayed_in_overlay=True,\n                    ),\n                    PrivacyNoticeWithId(\n                        id=\"test_id_1\",\n                        name=\"A\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_out,\n                        data_uses=[\"essential\"],\n                        enforcement_level=EnforcementLevel.frontend,\n                        displayed_in_overlay=True,\n                    ),\n                ],\n            )\n        assert exc._excinfo[1].status_code == 422\n        assert (\n            exc._excinfo[1].detail\n            == \"More than one provided PrivacyNotice with ID test_id_1.\"\n        )\n\n    def test_overlapping_data_uses(self, db, load_default_data_uses):\n        \"\"\"Can't have overlaps on incoming templates, and we also check these for disabled templates\"\"\"\n        with pytest.raises(HTTPException) as exc:\n            upsert_privacy_notice_templates_util(\n                db,\n                [\n                    PrivacyNoticeWithId(\n                        id=\"test_id_1\",\n                        notice_key=\"a\",\n                        name=\"A\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_in,\n                        data_uses=[\"essential\"],\n                        enforcement_level=EnforcementLevel.system_wide,\n                        displayed_in_overlay=True,\n                    ),\n                    PrivacyNoticeWithId(\n                        id=\"test_id_2\",\n                        notice_key=\"b\",\n                        name=\"B\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_in,\n                        data_uses=[\"essential.service\"],\n                        enforcement_level=EnforcementLevel.frontend,\n                        disabled=True,\n                        displayed_in_overlay=True,\n                    ),\n                ],\n            )\n        assert exc._excinfo[1].status_code == 422\n        assert (\n            exc._excinfo[1].detail\n            == \"Privacy Notice 'A' has already assigned data use 'essential' to region 'it'\"\n        )\n\n    def test_overlapping_notice_keys(self, db, load_default_data_uses):\n        \"\"\"Can't have overlapping notice keys on incoming templates, and we also check these for disabled templates\"\"\"\n        with pytest.raises(HTTPException) as exc:\n            upsert_privacy_notice_templates_util(\n                db,\n                [\n                    PrivacyNoticeWithId(\n                        id=\"test_id_1\",\n                        notice_key=\"a\",\n                        name=\"A\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_in,\n                        data_uses=[\"essential\"],\n                        enforcement_level=EnforcementLevel.system_wide,\n                        displayed_in_overlay=True,\n                    ),\n                    PrivacyNoticeWithId(\n                        id=\"test_id_2\",\n                        notice_key=\"a\",\n                        name=\"B\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_in,\n                        data_uses=[\"marketing\"],\n                        enforcement_level=EnforcementLevel.frontend,\n                        disabled=True,\n                        displayed_in_overlay=True,\n                    ),\n                ],\n            )\n        assert exc._excinfo[1].status_code == 422\n        assert (\n            exc._excinfo[1].detail\n            == \"Privacy Notice 'A' has already assigned notice key 'a' to region 'it'\"\n        )\n\n    def test_bad_data_uses(self, db, load_default_data_uses):\n        \"\"\"Test data uses must exist\"\"\"\n        with pytest.raises(HTTPException) as exc:\n            upsert_privacy_notice_templates_util(\n                db,\n                [\n                    PrivacyNoticeWithId(\n                        id=\"test_id_1\",\n                        name=\"A\",\n                        notice_key=\"a\",\n                        regions=[\"it\"],\n                        consent_mechanism=ConsentMechanism.opt_in,\n                        data_uses=[\"bad use\"],\n                        enforcement_level=EnforcementLevel.system_wide,\n                        displayed_in_overlay=True,\n                    )\n                ],\n            )\n        assert exc._excinfo[1].status_code == 422\n        assert exc._excinfo[1].detail == \"Unknown data_use 'bad use'\"\n\n    def test_create_two_templates_then_update_second(self, db, load_default_data_uses):\n        \"\"\"Test create two brand new templates\"\"\"\n        templates = upsert_privacy_notice_templates_util(\n            db,\n            [\n                PrivacyNoticeWithId(\n                    id=\"test_id_1\",\n                    notice_key=\"a\",\n                    name=\"A\",\n                    regions=[\"it\"],\n                    consent_mechanism=ConsentMechanism.opt_in,\n                    data_uses=[\"essential\"],\n                    enforcement_level=EnforcementLevel.system_wide,\n                    displayed_in_overlay=True,\n                ),\n                PrivacyNoticeWithId(\n                    id=\"test_id_2\",\n                    notice_key=\"b\",\n                    name=\"B\",\n                    regions=[\"it\"],\n                    consent_mechanism=ConsentMechanism.opt_in,\n                    data_uses=[\"functional\"],\n                    enforcement_level=EnforcementLevel.frontend,\n                    disabled=True,\n                    displayed_in_overlay=True,\n                ),\n            ],\n        )\n        assert len(templates) == 2\n        first_template = templates[0]\n        first_template_updated_at = first_template.updated_at\n        second_template = templates[1]\n        second_template_updated_at = second_template.updated_at\n\n        assert first_template.id == \"test_id_1\"\n        assert first_template.name == \"A\"\n        assert first_template.regions == [PrivacyNoticeRegion.it]\n        assert first_template.consent_mechanism == ConsentMechanism.opt_in\n        assert first_template.data_uses == [\"essential\"]\n        assert first_template.enforcement_level == EnforcementLevel.system_wide\n\n        assert second_template.id == \"test_id_2\"\n        assert second_template.name == \"B\"\n        assert second_template.regions == [PrivacyNoticeRegion.it]\n        assert second_template.consent_mechanism == ConsentMechanism.opt_in\n        assert second_template.data_uses == [\"functional\"]\n        assert second_template.enforcement_level == EnforcementLevel.frontend\n        assert second_template.disabled\n\n        templates = upsert_privacy_notice_templates_util(\n            db,\n            [\n                PrivacyNoticeWithId(\n                    id=\"test_id_2\",\n                    notice_key=\"b\",\n                    name=\"B\",\n                    regions=[\"it\"],\n                    consent_mechanism=ConsentMechanism.opt_out,\n                    data_uses=[\"marketing.advertising\"],\n                    enforcement_level=EnforcementLevel.frontend,\n                    disabled=True,\n                    displayed_in_overlay=True,\n                ),\n                PrivacyNoticeWithId(\n                    id=\"test_id_3\",\n                    notice_key=\"c\",\n                    name=\"C\",\n                    regions=[\"it\"],\n                    consent_mechanism=ConsentMechanism.opt_out,\n                    data_uses=[\"functional\"],\n                    enforcement_level=EnforcementLevel.system_wide,\n                    disabled=False,\n                    displayed_in_overlay=True,\n                ),\n            ],\n        )\n\n        second_template_updated = templates[0]\n        third_template = templates[1]\n\n        db.refresh(first_template)\n        db.refresh(second_template)\n        assert first_template.updated_at == first_template_updated_at\n        assert second_template.updated_at > second_template_updated_at\n        assert second_template_updated.id == second_template.id\n\n        # First template didn't change\n        assert first_template.id == \"test_id_1\"\n        assert first_template.name == \"A\"\n        assert first_template.regions == [PrivacyNoticeRegion.it]\n        assert first_template.consent_mechanism == ConsentMechanism.opt_in\n        assert first_template.data_uses == [\"essential\"]\n        assert first_template.enforcement_level == EnforcementLevel.system_wide\n\n        # Second template updated data use and consent mechanism\n        assert second_template.id == \"test_id_2\"\n        assert second_template.name == \"B\"\n        assert second_template.regions == [PrivacyNoticeRegion.it]\n        assert second_template.consent_mechanism == ConsentMechanism.opt_out\n        assert second_template.data_uses == [\"marketing.advertising\"]\n        assert second_template.enforcement_level == EnforcementLevel.frontend\n        assert second_template.disabled\n\n        # Third template is new\n        assert third_template.id == \"test_id_3\"\n        assert third_template.name == \"C\"\n        assert third_template.regions == [PrivacyNoticeRegion.it]\n        assert third_template.consent_mechanism == ConsentMechanism.opt_out\n        assert third_template.data_uses == [\"functional\"]\n        assert third_template.enforcement_level == EnforcementLevel.system_wide\n        assert not third_template.disabled\n\n\nclass TestUpsertDefaultExperienceConfig:\n    @pytest.fixture(scope=\"function\")\n    def default_overlay_config_data(self, db):\n        return {\n            \"accept_button_label\": \"A\",\n            \"acknowledge_button_label\": \"B\",\n            \"banner_enabled\": BannerEnabled.enabled_where_required,\n            \"component\": ComponentType.overlay,\n            \"description\": \"C\",\n            \"disabled\": False,\n            \"is_default\": True,\n            \"id\": \"test_id\",\n            \"privacy_preferences_link_label\": \"D\",\n            \"privacy_policy_link_label\": \"E's label\",\n            \"privacy_policy_url\": \"https://example.com/privacy_policy\",\n            \"reject_button_label\": \"G\",\n            \"save_button_label\": \"H\",\n            \"title\": \"I\",\n        }\n\n    def test_create_default_experience_config(self, db, default_overlay_config_data):\n        experience_config = create_default_experience_config(\n            db, default_overlay_config_data\n        )\n\n        assert experience_config.accept_button_label == \"A\"\n        assert experience_config.acknowledge_button_label == \"B\"\n        assert experience_config.banner_enabled == BannerEnabled.enabled_where_required\n        assert experience_config.component == ComponentType.overlay\n        assert experience_config.created_at is not None\n        assert experience_config.description == \"C\"\n        assert not experience_config.disabled\n        assert experience_config.is_default is True\n        assert experience_config.id == \"test_id\"\n        assert experience_config.privacy_preferences_link_label == \"D\"\n        assert (\n            experience_config.privacy_policy_link_label == \"E&#x27;s label\"\n        )  # Escaped\n        assert (\n            experience_config.privacy_policy_url == \"https://example.com/privacy_policy\"\n        )\n        assert experience_config.regions == []\n        assert experience_config.reject_button_label == \"G\"\n        assert experience_config.save_button_label == \"H\"\n        assert experience_config.title == \"I\"\n        assert experience_config.updated_at is not None\n        assert experience_config.version == 1.0\n\n        # Asserting history created appropriately\n        assert experience_config.experience_config_history_id is not None\n        assert experience_config.experience_config_history_id != \"test_id\"\n        assert experience_config.histories.count() == 1\n        history = experience_config.histories[0]\n\n        assert history.accept_button_label == \"A\"\n        assert history.acknowledge_button_label == \"B\"\n        assert history.banner_enabled == BannerEnabled.enabled_where_required\n        assert history.component == ComponentType.overlay\n        assert history.created_at is not None\n        assert history.description == \"C\"\n        assert not history.disabled\n        assert history.experience_config_id == experience_config.id\n        assert history.is_default is True\n        assert history.id != \"test_id\"\n        assert history.privacy_preferences_link_label == \"D\"\n        assert history.privacy_policy_link_label == \"E&#x27;s label\"\n        assert history.privacy_policy_url == \"https://example.com/privacy_policy\"\n        assert history.reject_button_label == \"G\"\n        assert history.save_button_label == \"H\"\n        assert history.title == \"I\"\n        assert history.updated_at is not None\n        assert history.version == 1.0\n\n        db.delete(history)\n        db.delete(experience_config)\n\n    def test_create_default_experience_config_config_already_exists_no_change(\n        self, db, default_overlay_config_data\n    ):\n        \"\"\"Experience config is not changed in any way\"\"\"\n        experience_config = create_default_experience_config(\n            db, default_overlay_config_data\n        )\n        assert experience_config is not None\n\n        resp = create_default_experience_config(db, default_overlay_config_data)\n        assert resp is None\n\n        db.refresh(experience_config)\n\n        # Nothing changed so we don't want to update the version\n        assert experience_config.version == 1.0\n        assert experience_config.histories.count() == 1\n\n        db.delete(experience_config.histories[0])\n        db.delete(experience_config)\n\n    def test_default_experience_config_data_has_changed(\n        self, db, default_overlay_config_data\n    ):\n        \"\"\"Even though data has changed, we don't update existing experience config\"\"\"\n        experience_config = create_default_experience_config(\n            db, default_overlay_config_data\n        )\n        assert experience_config is not None\n\n        default_overlay_config_data[\n            \"privacy_policy_url\"\n        ] = \"https://test_example.com/privacy_policy\"\n\n        resp = create_default_experience_config(db, default_overlay_config_data)\n        assert resp is None\n\n        db.refresh(experience_config)\n\n        # Data has changed but we didn't update existing config\n        assert experience_config.version == 1.0\n        assert (\n            experience_config.privacy_policy_url\n            != \"https://test_example.com/privacy_policy\"\n        )\n        assert experience_config.histories.count() == 1\n\n        assert experience_config.experience_config_history_id is not None\n        assert experience_config.experience_config_history_id != \"test_id\"\n        history = experience_config.histories[0]\n\n        assert history.version == 1.0\n        assert (\n            experience_config.privacy_policy_url\n            != \"https://test_example.com/privacy_policy\"\n        )\n\n        history.delete(db)\n        experience_config.delete(db)\n\n    def test_trying_to_use_this_function_to_create_non_default_configs(\n        self, db, default_overlay_config_data\n    ):\n        default_overlay_config_data[\"is_default\"] = False\n\n        with pytest.raises(Exception):\n            create_default_experience_config(db, default_overlay_config_data)\n\n    def test_create_default_experience_config_validation_error(\n        self, db, default_overlay_config_data\n    ):\n        default_overlay_config_data[\n            \"banner_enabled\"\n        ] = None  # Marking required field as None\n\n        with pytest.raises(ValueError) as exc:\n            create_default_experience_config(db, default_overlay_config_data)\n\n        assert (\n            str(exc.value.args[0][0].exc)\n            == \"The following additional fields are required when defining an overlay: acknowledge_button_label, banner_enabled, and privacy_preferences_link_label.\"\n        )\n\n\nclass TestValidateDataUses:\n    @pytest.fixture(scope=\"function\")\n    def privacy_notice_request(self):\n        return PrivacyNoticeCreation(\n            name=\"sample privacy notice\",\n            notice_key=\"sample_privacy_notice\",\n            regions=[PrivacyNoticeRegion.us_ca],\n            consent_mechanism=ConsentMechanism.opt_in,\n            data_uses=[\"placeholder\"],\n            enforcement_level=EnforcementLevel.system_wide,\n            displayed_in_overlay=True,\n        )\n\n    @pytest.fixture(scope=\"function\")\n    def custom_data_use(self, db):\n        return sql_DataUse.create(\n            db=db,\n            data=DataUse(\n                fides_key=\"new_data_use\",\n                organization_fides_key=\"default_organization\",\n                name=\"New data use\",\n                description=\"A test data use\",\n                parent_key=None,\n            ).dict(),\n        )\n\n    @pytest.mark.usefixtures(\"load_default_data_uses\")\n    def test_validate_data_uses_invalid(\n        self, db, privacy_notice_request: PrivacyNoticeCreation\n    ):\n        privacy_notice_request.data_uses = [\"invalid_data_use\"]\n        with pytest.raises(HTTPException):\n            validate_notice_data_uses([privacy_notice_request], db)\n\n        privacy_notice_request.data_uses = [\"marketing.advertising\", \"invalid_data_use\"]\n        with pytest.raises(HTTPException):\n            validate_notice_data_uses([privacy_notice_request], db)\n\n        privacy_notice_request.data_uses = [\n            \"marketing.advertising\",\n            \"marketing.advertising.invalid_data_use\",\n        ]\n        with pytest.raises(HTTPException):\n            validate_notice_data_uses([privacy_notice_request], db)\n\n    @pytest.mark.usefixtures(\"load_default_data_uses\")\n    def test_validate_data_uses_default_taxonomy(\n        self, db, privacy_notice_request: PrivacyNoticeCreation\n    ):\n        privacy_notice_request.data_uses = [\"marketing.advertising\"]\n        validate_notice_data_uses([privacy_notice_request], db)\n        privacy_notice_request.data_uses = [\"marketing.advertising\", \"essential\"]\n        validate_notice_data_uses([privacy_notice_request], db)\n        privacy_notice_request.data_uses = [\n            \"marketing.advertising\",\n            \"essential\",\n            \"essential.service\",\n        ]\n        validate_notice_data_uses([privacy_notice_request], db)\n\n    @pytest.mark.usefixtures(\"load_default_data_uses\")\n    def test_validate_data_uses_custom_uses(\n        self,\n        db,\n        privacy_notice_request: PrivacyNoticeCreation,\n        custom_data_use: sql_DataUse,\n    ):\n        \"\"\"\n        Ensure custom data uses added to the DB are considered valid\n        \"\"\"\n\n        privacy_notice_request.data_uses = [custom_data_use.fides_key]\n        validate_notice_data_uses([privacy_notice_request], db)\n        privacy_notice_request.data_uses = [\n            \"marketing.advertising\",\n            custom_data_use.fides_key,\n        ]\n        validate_notice_data_uses([privacy_notice_request], db)\n\n\nclass TestLoadTCFExperiences:\n    def test_create_tcf_experiences_on_startup(self, db):\n        \"\"\"Sanity check on creating TCF experiences\"\"\"\n        experiences_created = create_tcf_experiences_on_startup(db)\n        assert len(experiences_created) == len(EEA_COUNTRIES)\n        be_exp = experiences_created[0]\n        assert be_exp.component == ComponentType.tcf_overlay\n        assert be_exp.region == PrivacyNoticeRegion.be\n        experience_config = be_exp.experience_config\n        assert experience_config.is_default\n        assert experience_config.component == ComponentType.tcf_overlay\n"], "filenames": ["src/fides/api/schemas/privacy_experience.py", "tests/fixtures/application_fixtures.py", "tests/ops/api/v1/endpoints/test_privacy_experience_config_endpoints.py", "tests/ops/api/v1/endpoints/test_privacy_preference_endpoints.py", "tests/ops/models/test_privacy_experience.py", "tests/ops/models/test_privacy_preference.py", "tests/ops/util/test_consent_util.py"], "buggy_code_start_loc": [6, 2305, 320, 2076, 50, 139, 0], "buggy_code_end_loc": [48, 2681, 961, 2077, 477, 1918, 1162], "fixing_code_start_loc": [6, 2305, 320, 2076, 50, 139, 1], "fixing_code_end_loc": [48, 2681, 996, 2077, 477, 1924, 1173], "type": "CWE-79", "message": "Fides is an open-source privacy engineering platform for managing the fulfillment of data privacy requests in runtime environments, helping enforce privacy regulations in code. The Fides web application allows users to edit consent and privacy notices such as cookie banners. The vulnerability makes it possible to craft a payload in the privacy policy URL which triggers JavaScript execution when the privacy notice is served by an integrated website. The domain scope of the executed JavaScript is that of the integrated website. Exploitation is limited to Admin UI users with the contributor role or higher. The vulnerability has been patched in Fides version `2.22.1`. ", "other": {"cve": {"id": "CVE-2023-46126", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-25T18:17:36.537", "lastModified": "2023-11-01T16:37:49.830", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Fides is an open-source privacy engineering platform for managing the fulfillment of data privacy requests in runtime environments, helping enforce privacy regulations in code. The Fides web application allows users to edit consent and privacy notices such as cookie banners. The vulnerability makes it possible to craft a payload in the privacy policy URL which triggers JavaScript execution when the privacy notice is served by an integrated website. The domain scope of the executed JavaScript is that of the integrated website. Exploitation is limited to Admin UI users with the contributor role or higher. The vulnerability has been patched in Fides version `2.22.1`. "}, {"lang": "es", "value": "Fides es una plataforma de ingenier\u00eda de privacidad de c\u00f3digo abierto para gestionar el cumplimiento de solicitudes de privacidad de datos en entornos de ejecuci\u00f3n, ayudando a hacer cumplir las regulaciones de privacidad en el c\u00f3digo. La aplicaci\u00f3n web de Fides permite a los usuarios editar los avisos de consentimiento y privacidad, como los banners de cookies. La vulnerabilidad permite manipular un payload en la URL de la pol\u00edtica de privacidad que activa la ejecuci\u00f3n de JavaScript cuando el aviso de privacidad es entregado por un sitio web integrado. El alcance del dominio del JavaScript ejecutado es el del sitio web integrado. La explotaci\u00f3n est\u00e1 limitada a los usuarios de la interfaz de usuario de administrador con el rol de colaborador o superior. La vulnerabilidad ha sido parcheada en la versi\u00f3n `2.22.1` de Fides."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 3.9, "baseSeverity": "LOW"}, "exploitabilityScore": 0.5, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ethyca:fides:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.22.1", "matchCriteriaId": "DA76F207-3012-48FE-AAB5-9B061A5AE996"}]}]}], "references": [{"url": "https://github.com/ethyca/fides/commit/3231d19699f9c895c986f6a967a64d882769c506", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/ethyca/fides/releases/tag/2.22.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/ethyca/fides/security/advisories/GHSA-fgjj-5jmr-gh83", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ethyca/fides/commit/3231d19699f9c895c986f6a967a64d882769c506"}}