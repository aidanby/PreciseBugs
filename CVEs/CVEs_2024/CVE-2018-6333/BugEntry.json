{"buggy_code": ["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the license found in the LICENSE file in\n * the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {CwdApi} from '../../nuclide-current-working-directory/lib/CwdApi';\nimport type {\n  DeepLinkParams,\n  DeepLinkService,\n} from '../../nuclide-deep-link/lib/types';\nimport type {RemoteProjectsService} from '../../nuclide-remote-projects';\nimport type {TaskRunnerServiceApi} from '../../nuclide-task-runner/lib/types';\n\nimport UniversalDisposable from 'nuclide-commons/UniversalDisposable';\nimport createPackage from 'nuclide-commons-atom/createPackage';\nimport nuclideUri from 'nuclide-commons/nuclideUri';\nimport consumeFirstProvider from '../../commons-atom/consumeFirstProvider';\nimport {goToLocation} from 'nuclide-commons-atom/go-to-location';\nimport {track} from '../../nuclide-analytics';\nimport invariant from 'assert';\n// eslint-disable-next-line rulesdir/no-cross-atom-imports\nimport {getAttachProcessInfo} from '../../nuclide-debugger-vsp/lib/HhvmLaunchAttachProvider';\nimport HhvmBuildSystem from './HhvmBuildSystem';\n\nclass Activation {\n  _buildSystem: ?HhvmBuildSystem;\n  _disposables: UniversalDisposable;\n  _cwdApi: ?CwdApi;\n  _remoteProjectsService: ?RemoteProjectsService;\n\n  constructor(state: ?Object) {\n    this._disposables = new UniversalDisposable();\n  }\n\n  dispose() {\n    this._disposables.dispose();\n  }\n\n  consumeTaskRunnerServiceApi(api: TaskRunnerServiceApi): void {\n    this._disposables.add(api.register(this._getBuildSystem()));\n  }\n\n  consumeCwdApi(api: CwdApi): IDisposable {\n    this._cwdApi = api;\n    return new UniversalDisposable(() => {\n      this._cwdApi = null;\n    });\n  }\n\n  consumeRemoteProjectsService(service: RemoteProjectsService): IDisposable {\n    this._remoteProjectsService = service;\n    return new UniversalDisposable(() => {\n      this._remoteProjectsService = null;\n    });\n  }\n\n  consumeDeepLinkService(deepLink: DeepLinkService): void {\n    this._disposables.add(\n      deepLink.subscribeToPath('attach-hhvm', params => {\n        this._debugDeepWithHhvm(params);\n      }),\n    );\n  }\n\n  _getBuildSystem(): HhvmBuildSystem {\n    if (this._buildSystem == null) {\n      const buildSystem = new HhvmBuildSystem();\n      this._disposables.add(buildSystem);\n      this._buildSystem = buildSystem;\n    }\n    return this._buildSystem;\n  }\n\n  async _debugDeepWithHhvm(params: DeepLinkParams): Promise<void> {\n    const {nuclidePath, hackRoot, line, addBreakpoint, source} = params;\n\n    if (\n      typeof nuclidePath !== 'string' ||\n      !nuclideUri.isRemote(nuclidePath) ||\n      typeof hackRoot !== 'string'\n    ) {\n      atom.notifications.addError('Invalid arguments.');\n      return;\n    }\n\n    const pathString = decodeURIComponent(String(nuclidePath));\n    const hackRootString = decodeURIComponent(String(hackRoot));\n\n    const startDebugger =\n      params.noDebugger == null || params.noDebugger !== 'true';\n\n    track('nuclide-attach-hhvm-deeplink', {\n      pathString,\n      line,\n      addBreakpoint,\n      source,\n    });\n\n    if (this._remoteProjectsService == null) {\n      atom.notifications.addError('The remote project service is unavailable.');\n      return;\n    } else {\n      const remoteProjectsService = this._remoteProjectsService;\n      await new Promise(resolve =>\n        remoteProjectsService.waitForRemoteProjectReload(resolve),\n      );\n    }\n\n    const host = nuclideUri.getHostname(pathString);\n    const cwd = nuclideUri.createRemoteUri(host, hackRootString);\n    const notification = atom.notifications.addInfo(\n      startDebugger\n        ? `Connecting to ${host} and attaching debugger...`\n        : `Connecting to ${host}...`,\n      {\n        dismissable: true,\n      },\n    );\n\n    invariant(this._remoteProjectsService != null);\n    const remoteConnection = await this._remoteProjectsService.createRemoteConnection(\n      {\n        host,\n        cwd: nuclideUri.getPath(cwd),\n        displayTitle: host,\n      },\n    );\n\n    if (remoteConnection == null) {\n      atom.notifications.addError(`Could not connect to ${host}`);\n      return;\n    }\n\n    // The hostname might have changed slightly from what was passed in due to\n    // DNS lookup, so create a new remote URI rather than using cwd from above.\n    const hackRootUri = remoteConnection.getUriOfRemotePath(hackRootString);\n    const navUri = remoteConnection.getUriOfRemotePath(\n      nuclideUri.getPath(pathString),\n    );\n\n    // Set the current project root.\n    if (this._cwdApi != null) {\n      this._cwdApi.setCwd(hackRootUri);\n    }\n\n    // Open the script path in the editor.\n    const lineNumber = parseInt(line, 10);\n    if (Number.isNaN(lineNumber)) {\n      goToLocation(navUri);\n    } else {\n      // NOTE: line numbers start at 0, so subtract 1.\n      goToLocation(navUri, {line: lineNumber - 1});\n    }\n\n    if (startDebugger) {\n      // Debug the remote HHVM server!\n      const debuggerService = await consumeFirstProvider(\n        'nuclide-debugger.remote',\n      );\n\n      if (addBreakpoint === 'true' && !Number.isNaN(lineNumber)) {\n        // Insert a breakpoint if requested.\n        // NOTE: Nuclide protocol breakpoint line numbers start at 0, so subtract 1.\n        debuggerService.addBreakpoint(navUri, lineNumber - 1);\n      }\n\n      await debuggerService.startDebugging(\n        await getAttachProcessInfo(hackRootUri),\n      );\n    }\n\n    notification.dismiss();\n  }\n}\n\ncreatePackage(module.exports, Activation);\n"], "fixing_code": ["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the license found in the LICENSE file in\n * the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {CwdApi} from '../../nuclide-current-working-directory/lib/CwdApi';\nimport type {\n  DeepLinkParams,\n  DeepLinkService,\n} from '../../nuclide-deep-link/lib/types';\nimport type {RemoteProjectsService} from '../../nuclide-remote-projects';\nimport type {TaskRunnerServiceApi} from '../../nuclide-task-runner/lib/types';\n\nimport UniversalDisposable from 'nuclide-commons/UniversalDisposable';\nimport createPackage from 'nuclide-commons-atom/createPackage';\nimport nuclideUri from 'nuclide-commons/nuclideUri';\nimport consumeFirstProvider from '../../commons-atom/consumeFirstProvider';\nimport {goToLocation} from 'nuclide-commons-atom/go-to-location';\nimport {track} from '../../nuclide-analytics';\nimport invariant from 'assert';\n// eslint-disable-next-line rulesdir/no-cross-atom-imports\nimport {getAttachProcessInfo} from '../../nuclide-debugger-vsp/lib/HhvmLaunchAttachProvider';\nimport HhvmBuildSystem from './HhvmBuildSystem';\n\nclass Activation {\n  _buildSystem: ?HhvmBuildSystem;\n  _disposables: UniversalDisposable;\n  _cwdApi: ?CwdApi;\n  _remoteProjectsService: ?RemoteProjectsService;\n\n  constructor(state: ?Object) {\n    this._disposables = new UniversalDisposable();\n  }\n\n  dispose() {\n    this._disposables.dispose();\n  }\n\n  consumeTaskRunnerServiceApi(api: TaskRunnerServiceApi): void {\n    this._disposables.add(api.register(this._getBuildSystem()));\n  }\n\n  consumeCwdApi(api: CwdApi): IDisposable {\n    this._cwdApi = api;\n    return new UniversalDisposable(() => {\n      this._cwdApi = null;\n    });\n  }\n\n  consumeRemoteProjectsService(service: RemoteProjectsService): IDisposable {\n    this._remoteProjectsService = service;\n    return new UniversalDisposable(() => {\n      this._remoteProjectsService = null;\n    });\n  }\n\n  consumeDeepLinkService(deepLink: DeepLinkService): void {\n    this._disposables.add(\n      deepLink.subscribeToPath('attach-hhvm', params => {\n        this._debugDeepWithHhvm(params);\n      }),\n    );\n  }\n\n  _getBuildSystem(): HhvmBuildSystem {\n    if (this._buildSystem == null) {\n      const buildSystem = new HhvmBuildSystem();\n      this._disposables.add(buildSystem);\n      this._buildSystem = buildSystem;\n    }\n    return this._buildSystem;\n  }\n\n  async _debugDeepWithHhvm(params: DeepLinkParams): Promise<void> {\n    const {nuclidePath, hackRoot, line, addBreakpoint, source} = params;\n\n    if (\n      typeof nuclidePath !== 'string' ||\n      !nuclideUri.isRemote(nuclidePath) ||\n      typeof hackRoot !== 'string'\n    ) {\n      atom.notifications.addError('Invalid arguments.');\n      return;\n    }\n\n    const pathString = decodeURIComponent(String(nuclidePath));\n    const hackRootString = decodeURIComponent(String(hackRoot));\n\n    const startDebugger =\n      params.noDebugger == null || params.noDebugger !== 'true';\n\n    track('nuclide-attach-hhvm-deeplink', {\n      pathString,\n      line,\n      addBreakpoint,\n      source,\n    });\n\n    if (this._remoteProjectsService == null) {\n      atom.notifications.addError('The remote project service is unavailable.');\n      return;\n    } else {\n      const remoteProjectsService = this._remoteProjectsService;\n      await new Promise(resolve =>\n        remoteProjectsService.waitForRemoteProjectReload(resolve),\n      );\n    }\n\n    const host = nuclideUri.getHostname(pathString);\n\n    // Allow only valid hostname characters, per RFC 952:\n    // https://tools.ietf.org/html/rfc952\n    const invalidMatch = host.match(/[^A-Za-z0-9\\-._]+/);\n    if (invalidMatch != null) {\n      atom.notifications.addError(\n        'The specified host name contained invalid characters.',\n      );\n      return;\n    }\n\n    const cwd = nuclideUri.createRemoteUri(host, hackRootString);\n    const notification = atom.notifications.addInfo(\n      startDebugger\n        ? `Connecting to ${host} and attaching debugger...`\n        : `Connecting to ${host}...`,\n      {\n        dismissable: true,\n      },\n    );\n\n    invariant(this._remoteProjectsService != null);\n    const remoteConnection = await this._remoteProjectsService.createRemoteConnection(\n      {\n        host,\n        cwd: nuclideUri.getPath(cwd),\n        displayTitle: host,\n      },\n    );\n\n    if (remoteConnection == null) {\n      atom.notifications.addError(`Could not connect to ${host}`);\n      return;\n    }\n\n    // The hostname might have changed slightly from what was passed in due to\n    // DNS lookup, so create a new remote URI rather than using cwd from above.\n    const hackRootUri = remoteConnection.getUriOfRemotePath(hackRootString);\n    const navUri = remoteConnection.getUriOfRemotePath(\n      nuclideUri.getPath(pathString),\n    );\n\n    // Set the current project root.\n    if (this._cwdApi != null) {\n      this._cwdApi.setCwd(hackRootUri);\n    }\n\n    // Open the script path in the editor.\n    const lineNumber = parseInt(line, 10);\n    if (Number.isNaN(lineNumber)) {\n      goToLocation(navUri);\n    } else {\n      // NOTE: line numbers start at 0, so subtract 1.\n      goToLocation(navUri, {line: lineNumber - 1});\n    }\n\n    if (startDebugger) {\n      // Debug the remote HHVM server!\n      const debuggerService = await consumeFirstProvider(\n        'nuclide-debugger.remote',\n      );\n\n      if (addBreakpoint === 'true' && !Number.isNaN(lineNumber)) {\n        // Insert a breakpoint if requested.\n        // NOTE: Nuclide protocol breakpoint line numbers start at 0, so subtract 1.\n        debuggerService.addBreakpoint(navUri, lineNumber - 1);\n      }\n\n      await debuggerService.startDebugging(\n        await getAttachProcessInfo(hackRootUri),\n      );\n    }\n\n    notification.dismiss();\n  }\n}\n\ncreatePackage(module.exports, Activation);\n"], "filenames": ["pkg/nuclide-hhvm/lib/main.js"], "buggy_code_start_loc": [115], "buggy_code_end_loc": [115], "fixing_code_start_loc": [116], "fixing_code_end_loc": [127], "type": "CWE-20", "message": "The hhvm-attach deep link handler in Nuclide did not properly sanitize the provided hostname parameter when rendering. As a result, a malicious URL could be used to render HTML and other content inside of the editor's context, which could potentially be chained to lead to code execution. This issue affected Nuclide prior to v0.290.0.", "other": {"cve": {"id": "CVE-2018-6333", "sourceIdentifier": "cve-assign@fb.com", "published": "2018-12-31T23:29:00.283", "lastModified": "2019-10-09T23:41:46.190", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The hhvm-attach deep link handler in Nuclide did not properly sanitize the provided hostname parameter when rendering. As a result, a malicious URL could be used to render HTML and other content inside of the editor's context, which could potentially be chained to lead to code execution. This issue affected Nuclide prior to v0.290.0."}, {"lang": "es", "value": "El gestor hhvm-attach deep link en Nuclide no sanea debidamente el par\u00e1metro hostname proporcionado durante la renderizaci\u00f3n. En consecuencia, una URL maliciosa podr\u00eda utilizarse para renderizar HTML y otro tipo de contenido dentro del contexto del editor, lo cual podr\u00eda ser encadenado para provocar la ejecuci\u00f3n de c\u00f3digo. Esto afecta a las versiones de Nuclide anteriores a la v0.290.0."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:nuclide:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.290.0", "matchCriteriaId": "E94F33FD-6897-4D79-9A82-0B947F4AE7EB"}]}]}], "references": [{"url": "https://github.com/facebook/nuclide/commit/65f6bbd683404be1bb569b8d1be84b5d4c74a324", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebook/nuclide/commit/65f6bbd683404be1bb569b8d1be84b5d4c74a324"}}