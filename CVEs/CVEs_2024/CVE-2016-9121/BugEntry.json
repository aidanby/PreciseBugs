{"buggy_code": ["/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"crypto\"\n\t\"crypto/aes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/sha1\"\n\t\"crypto/sha256\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/square/go-jose/cipher\"\n)\n\n// A generic RSA-based encrypter/verifier\ntype rsaEncrypterVerifier struct {\n\tpublicKey *rsa.PublicKey\n}\n\n// A generic RSA-based decrypter/signer\ntype rsaDecrypterSigner struct {\n\tprivateKey *rsa.PrivateKey\n}\n\n// A generic EC-based encrypter/verifier\ntype ecEncrypterVerifier struct {\n\tpublicKey *ecdsa.PublicKey\n}\n\n// A key generator for ECDH-ES\ntype ecKeyGenerator struct {\n\tsize      int\n\talgID     string\n\tpublicKey *ecdsa.PublicKey\n}\n\n// A generic EC-based decrypter/signer\ntype ecDecrypterSigner struct {\n\tprivateKey *ecdsa.PrivateKey\n}\n\n// newRSARecipient creates recipientKeyInfo based on the given key.\nfunc newRSARecipient(keyAlg KeyAlgorithm, publicKey *rsa.PublicKey) (recipientKeyInfo, error) {\n\t// Verify that key management algorithm is supported by this encrypter\n\tswitch keyAlg {\n\tcase RSA1_5, RSA_OAEP, RSA_OAEP_256:\n\tdefault:\n\t\treturn recipientKeyInfo{}, ErrUnsupportedAlgorithm\n\t}\n\n\treturn recipientKeyInfo{\n\t\tkeyAlg: keyAlg,\n\t\tkeyEncrypter: &rsaEncrypterVerifier{\n\t\t\tpublicKey: publicKey,\n\t\t},\n\t}, nil\n}\n\n// newRSASigner creates a recipientSigInfo based on the given key.\nfunc newRSASigner(sigAlg SignatureAlgorithm, privateKey *rsa.PrivateKey) (recipientSigInfo, error) {\n\t// Verify that key management algorithm is supported by this encrypter\n\tswitch sigAlg {\n\tcase RS256, RS384, RS512, PS256, PS384, PS512:\n\tdefault:\n\t\treturn recipientSigInfo{}, ErrUnsupportedAlgorithm\n\t}\n\n\treturn recipientSigInfo{\n\t\tsigAlg: sigAlg,\n\t\tpublicKey: &JsonWebKey{\n\t\t\tKey: &privateKey.PublicKey,\n\t\t},\n\t\tsigner: &rsaDecrypterSigner{\n\t\t\tprivateKey: privateKey,\n\t\t},\n\t}, nil\n}\n\n// newECDHRecipient creates recipientKeyInfo based on the given key.\nfunc newECDHRecipient(keyAlg KeyAlgorithm, publicKey *ecdsa.PublicKey) (recipientKeyInfo, error) {\n\t// Verify that key management algorithm is supported by this encrypter\n\tswitch keyAlg {\n\tcase ECDH_ES, ECDH_ES_A128KW, ECDH_ES_A192KW, ECDH_ES_A256KW:\n\tdefault:\n\t\treturn recipientKeyInfo{}, ErrUnsupportedAlgorithm\n\t}\n\n\treturn recipientKeyInfo{\n\t\tkeyAlg: keyAlg,\n\t\tkeyEncrypter: &ecEncrypterVerifier{\n\t\t\tpublicKey: publicKey,\n\t\t},\n\t}, nil\n}\n\n// newECDSASigner creates a recipientSigInfo based on the given key.\nfunc newECDSASigner(sigAlg SignatureAlgorithm, privateKey *ecdsa.PrivateKey) (recipientSigInfo, error) {\n\t// Verify that key management algorithm is supported by this encrypter\n\tswitch sigAlg {\n\tcase ES256, ES384, ES512:\n\tdefault:\n\t\treturn recipientSigInfo{}, ErrUnsupportedAlgorithm\n\t}\n\n\treturn recipientSigInfo{\n\t\tsigAlg: sigAlg,\n\t\tpublicKey: &JsonWebKey{\n\t\t\tKey: &privateKey.PublicKey,\n\t\t},\n\t\tsigner: &ecDecrypterSigner{\n\t\t\tprivateKey: privateKey,\n\t\t},\n\t}, nil\n}\n\n// Encrypt the given payload and update the object.\nfunc (ctx rsaEncrypterVerifier) encryptKey(cek []byte, alg KeyAlgorithm) (recipientInfo, error) {\n\tencryptedKey, err := ctx.encrypt(cek, alg)\n\tif err != nil {\n\t\treturn recipientInfo{}, err\n\t}\n\n\treturn recipientInfo{\n\t\tencryptedKey: encryptedKey,\n\t\theader:       &rawHeader{},\n\t}, nil\n}\n\n// Encrypt the given payload. Based on the key encryption algorithm,\n// this will either use RSA-PKCS1v1.5 or RSA-OAEP (with SHA-1 or SHA-256).\nfunc (ctx rsaEncrypterVerifier) encrypt(cek []byte, alg KeyAlgorithm) ([]byte, error) {\n\tswitch alg {\n\tcase RSA1_5:\n\t\treturn rsa.EncryptPKCS1v15(randReader, ctx.publicKey, cek)\n\tcase RSA_OAEP:\n\t\treturn rsa.EncryptOAEP(sha1.New(), randReader, ctx.publicKey, cek, []byte{})\n\tcase RSA_OAEP_256:\n\t\treturn rsa.EncryptOAEP(sha256.New(), randReader, ctx.publicKey, cek, []byte{})\n\t}\n\n\treturn nil, ErrUnsupportedAlgorithm\n}\n\n// Decrypt the given payload and return the content encryption key.\nfunc (ctx rsaDecrypterSigner) decryptKey(headers rawHeader, recipient *recipientInfo, generator keyGenerator) ([]byte, error) {\n\treturn ctx.decrypt(recipient.encryptedKey, KeyAlgorithm(headers.Alg), generator)\n}\n\n// Decrypt the given payload. Based on the key encryption algorithm,\n// this will either use RSA-PKCS1v1.5 or RSA-OAEP (with SHA-1 or SHA-256).\nfunc (ctx rsaDecrypterSigner) decrypt(jek []byte, alg KeyAlgorithm, generator keyGenerator) ([]byte, error) {\n\t// Note: The random reader on decrypt operations is only used for blinding,\n\t// so stubbing is meanlingless (hence the direct use of rand.Reader).\n\tswitch alg {\n\tcase RSA1_5:\n\t\tdefer func() {\n\t\t\t// DecryptPKCS1v15SessionKey sometimes panics on an invalid payload\n\t\t\t// because of an index out of bounds error, which we want to ignore.\n\t\t\t// This has been fixed in Go 1.3.1 (released 2014/08/13), the recover()\n\t\t\t// only exists for preventing crashes with unpatched versions.\n\t\t\t// See: https://groups.google.com/forum/#!topic/golang-dev/7ihX6Y6kx9k\n\t\t\t// See: https://code.google.com/p/go/source/detail?r=58ee390ff31602edb66af41ed10901ec95904d33\n\t\t\t_ = recover()\n\t\t}()\n\n\t\t// Perform some input validation.\n\t\tkeyBytes := ctx.privateKey.PublicKey.N.BitLen() / 8\n\t\tif keyBytes != len(jek) {\n\t\t\t// Input size is incorrect, the encrypted payload should always match\n\t\t\t// the size of the public modulus (e.g. using a 2048 bit key will\n\t\t\t// produce 256 bytes of output). Reject this since it's invalid input.\n\t\t\treturn nil, ErrCryptoFailure\n\t\t}\n\n\t\tcek, _, err := generator.genKey()\n\t\tif err != nil {\n\t\t\treturn nil, ErrCryptoFailure\n\t\t}\n\n\t\t// When decrypting an RSA-PKCS1v1.5 payload, we must take precautions to\n\t\t// prevent chosen-ciphertext attacks as described in RFC 3218, \"Preventing\n\t\t// the Million Message Attack on Cryptographic Message Syntax\". We are\n\t\t// therefore deliberately ignoring errors here.\n\t\t_ = rsa.DecryptPKCS1v15SessionKey(rand.Reader, ctx.privateKey, jek, cek)\n\n\t\treturn cek, nil\n\tcase RSA_OAEP:\n\t\t// Use rand.Reader for RSA blinding\n\t\treturn rsa.DecryptOAEP(sha1.New(), rand.Reader, ctx.privateKey, jek, []byte{})\n\tcase RSA_OAEP_256:\n\t\t// Use rand.Reader for RSA blinding\n\t\treturn rsa.DecryptOAEP(sha256.New(), rand.Reader, ctx.privateKey, jek, []byte{})\n\t}\n\n\treturn nil, ErrUnsupportedAlgorithm\n}\n\n// Sign the given payload\nfunc (ctx rsaDecrypterSigner) signPayload(payload []byte, alg SignatureAlgorithm) (Signature, error) {\n\tvar hash crypto.Hash\n\n\tswitch alg {\n\tcase RS256, PS256:\n\t\thash = crypto.SHA256\n\tcase RS384, PS384:\n\t\thash = crypto.SHA384\n\tcase RS512, PS512:\n\t\thash = crypto.SHA512\n\tdefault:\n\t\treturn Signature{}, ErrUnsupportedAlgorithm\n\t}\n\n\thasher := hash.New()\n\n\t// According to documentation, Write() on hash never fails\n\t_, _ = hasher.Write(payload)\n\thashed := hasher.Sum(nil)\n\n\tvar out []byte\n\tvar err error\n\n\tswitch alg {\n\tcase RS256, RS384, RS512:\n\t\tout, err = rsa.SignPKCS1v15(randReader, ctx.privateKey, hash, hashed)\n\tcase PS256, PS384, PS512:\n\t\tout, err = rsa.SignPSS(randReader, ctx.privateKey, hash, hashed, &rsa.PSSOptions{\n\t\t\tSaltLength: rsa.PSSSaltLengthAuto,\n\t\t})\n\t}\n\n\tif err != nil {\n\t\treturn Signature{}, err\n\t}\n\n\treturn Signature{\n\t\tSignature: out,\n\t\tprotected: &rawHeader{},\n\t}, nil\n}\n\n// Verify the given payload\nfunc (ctx rsaEncrypterVerifier) verifyPayload(payload []byte, signature []byte, alg SignatureAlgorithm) error {\n\tvar hash crypto.Hash\n\n\tswitch alg {\n\tcase RS256, PS256:\n\t\thash = crypto.SHA256\n\tcase RS384, PS384:\n\t\thash = crypto.SHA384\n\tcase RS512, PS512:\n\t\thash = crypto.SHA512\n\tdefault:\n\t\treturn ErrUnsupportedAlgorithm\n\t}\n\n\thasher := hash.New()\n\n\t// According to documentation, Write() on hash never fails\n\t_, _ = hasher.Write(payload)\n\thashed := hasher.Sum(nil)\n\n\tswitch alg {\n\tcase RS256, RS384, RS512:\n\t\treturn rsa.VerifyPKCS1v15(ctx.publicKey, hash, hashed, signature)\n\tcase PS256, PS384, PS512:\n\t\treturn rsa.VerifyPSS(ctx.publicKey, hash, hashed, signature, nil)\n\t}\n\n\treturn ErrUnsupportedAlgorithm\n}\n\n// Encrypt the given payload and update the object.\nfunc (ctx ecEncrypterVerifier) encryptKey(cek []byte, alg KeyAlgorithm) (recipientInfo, error) {\n\tswitch alg {\n\tcase ECDH_ES:\n\t\t// ECDH-ES mode doesn't wrap a key, the shared secret is used directly as the key.\n\t\treturn recipientInfo{\n\t\t\theader: &rawHeader{},\n\t\t}, nil\n\tcase ECDH_ES_A128KW, ECDH_ES_A192KW, ECDH_ES_A256KW:\n\tdefault:\n\t\treturn recipientInfo{}, ErrUnsupportedAlgorithm\n\t}\n\n\tgenerator := ecKeyGenerator{\n\t\talgID:     string(alg),\n\t\tpublicKey: ctx.publicKey,\n\t}\n\n\tswitch alg {\n\tcase ECDH_ES_A128KW:\n\t\tgenerator.size = 16\n\tcase ECDH_ES_A192KW:\n\t\tgenerator.size = 24\n\tcase ECDH_ES_A256KW:\n\t\tgenerator.size = 32\n\t}\n\n\tkek, header, err := generator.genKey()\n\tif err != nil {\n\t\treturn recipientInfo{}, err\n\t}\n\n\tblock, err := aes.NewCipher(kek)\n\tif err != nil {\n\t\treturn recipientInfo{}, err\n\t}\n\n\tjek, err := josecipher.KeyWrap(block, cek)\n\tif err != nil {\n\t\treturn recipientInfo{}, err\n\t}\n\n\treturn recipientInfo{\n\t\tencryptedKey: jek,\n\t\theader:       &header,\n\t}, nil\n}\n\n// Get key size for EC key generator\nfunc (ctx ecKeyGenerator) keySize() int {\n\treturn ctx.size\n}\n\n// Get a content encryption key for ECDH-ES\nfunc (ctx ecKeyGenerator) genKey() ([]byte, rawHeader, error) {\n\tpriv, err := ecdsa.GenerateKey(ctx.publicKey.Curve, randReader)\n\tif err != nil {\n\t\treturn nil, rawHeader{}, err\n\t}\n\n\tout := josecipher.DeriveECDHES(ctx.algID, []byte{}, []byte{}, priv, ctx.publicKey, ctx.size)\n\n\theaders := rawHeader{\n\t\tEpk: &JsonWebKey{\n\t\t\tKey: &priv.PublicKey,\n\t\t},\n\t}\n\n\treturn out, headers, nil\n}\n\n// Decrypt the given payload and return the content encryption key.\nfunc (ctx ecDecrypterSigner) decryptKey(headers rawHeader, recipient *recipientInfo, generator keyGenerator) ([]byte, error) {\n\tif headers.Epk == nil {\n\t\treturn nil, errors.New(\"square/go-jose: missing epk header\")\n\t}\n\n\tpublicKey, ok := headers.Epk.Key.(*ecdsa.PublicKey)\n\tif publicKey == nil || !ok {\n\t\treturn nil, errors.New(\"square/go-jose: invalid epk header\")\n\t}\n\n\tapuData := headers.Apu.bytes()\n\tapvData := headers.Apv.bytes()\n\n\tderiveKey := func(algID string, size int) []byte {\n\t\treturn josecipher.DeriveECDHES(algID, apuData, apvData, ctx.privateKey, publicKey, size)\n\t}\n\n\tvar keySize int\n\n\tswitch KeyAlgorithm(headers.Alg) {\n\tcase ECDH_ES:\n\t\t// ECDH-ES uses direct key agreement, no key unwrapping necessary.\n\t\treturn deriveKey(string(headers.Enc), generator.keySize()), nil\n\tcase ECDH_ES_A128KW:\n\t\tkeySize = 16\n\tcase ECDH_ES_A192KW:\n\t\tkeySize = 24\n\tcase ECDH_ES_A256KW:\n\t\tkeySize = 32\n\tdefault:\n\t\treturn nil, ErrUnsupportedAlgorithm\n\t}\n\n\tkey := deriveKey(headers.Alg, keySize)\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn josecipher.KeyUnwrap(block, recipient.encryptedKey)\n}\n\n// Sign the given payload\nfunc (ctx ecDecrypterSigner) signPayload(payload []byte, alg SignatureAlgorithm) (Signature, error) {\n\tvar expectedBitSize int\n\tvar hash crypto.Hash\n\n\tswitch alg {\n\tcase ES256:\n\t\texpectedBitSize = 256\n\t\thash = crypto.SHA256\n\tcase ES384:\n\t\texpectedBitSize = 384\n\t\thash = crypto.SHA384\n\tcase ES512:\n\t\texpectedBitSize = 521\n\t\thash = crypto.SHA512\n\t}\n\n\tcurveBits := ctx.privateKey.Curve.Params().BitSize\n\tif expectedBitSize != curveBits {\n\t\treturn Signature{}, fmt.Errorf(\"square/go-jose: expected %d bit key, got %d bits instead\", expectedBitSize, curveBits)\n\t}\n\n\thasher := hash.New()\n\n\t// According to documentation, Write() on hash never fails\n\t_, _ = hasher.Write(payload)\n\thashed := hasher.Sum(nil)\n\n\tr, s, err := ecdsa.Sign(randReader, ctx.privateKey, hashed)\n\tif err != nil {\n\t\treturn Signature{}, err\n\t}\n\n\tkeyBytes := curveBits / 8\n\tif curveBits%8 > 0 {\n\t\tkeyBytes += 1\n\t}\n\n\t// We serialize the outpus (r and s) into big-endian byte arrays and pad\n\t// them with zeros on the left to make sure the sizes work out. Both arrays\n\t// must be keyBytes long, and the output must be 2*keyBytes long.\n\trBytes := r.Bytes()\n\trBytesPadded := make([]byte, keyBytes)\n\tcopy(rBytesPadded[keyBytes-len(rBytes):], rBytes)\n\n\tsBytes := s.Bytes()\n\tsBytesPadded := make([]byte, keyBytes)\n\tcopy(sBytesPadded[keyBytes-len(sBytes):], sBytes)\n\n\tout := append(rBytesPadded, sBytesPadded...)\n\n\treturn Signature{\n\t\tSignature: out,\n\t\tprotected: &rawHeader{},\n\t}, nil\n}\n\n// Verify the given payload\nfunc (ctx ecEncrypterVerifier) verifyPayload(payload []byte, signature []byte, alg SignatureAlgorithm) error {\n\tvar keySize int\n\tvar hash crypto.Hash\n\n\tswitch alg {\n\tcase ES256:\n\t\tkeySize = 32\n\t\thash = crypto.SHA256\n\tcase ES384:\n\t\tkeySize = 48\n\t\thash = crypto.SHA384\n\tcase ES512:\n\t\tkeySize = 66\n\t\thash = crypto.SHA512\n\t}\n\n\tif len(signature) != 2*keySize {\n\t\treturn fmt.Errorf(\"square/go-jose: invalid signature size, have %d bytes, wanted %d\", len(signature), 2*keySize)\n\t}\n\n\thasher := hash.New()\n\n\t// According to documentation, Write() on hash never fails\n\t_, _ = hasher.Write(payload)\n\thashed := hasher.Sum(nil)\n\n\tr := big.NewInt(0).SetBytes(signature[:keySize])\n\ts := big.NewInt(0).SetBytes(signature[keySize:])\n\n\tmatch := ecdsa.Verify(ctx.publicKey, hashed, r, s)\n\tif !match {\n\t\treturn errors.New(\"square/go-jose: ecdsa signature failed to verify\")\n\t}\n\n\treturn nil\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"errors\"\n\t\"io\"\n\t\"math/big\"\n\t\"testing\"\n)\n\nfunc TestVectorsRSA(t *testing.T) {\n\t// Sources:\n\t//   http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-rsa-cryptography-standard.htm\n\t//   ftp://ftp.rsa.com/pub/rsalabs/tmp/pkcs1v15crypt-vectors.txt\n\tpriv := &rsa.PrivateKey{\n\t\tPublicKey: rsa.PublicKey{\n\t\t\tN: fromHexInt(`\n\t\t\t\ta8b3b284af8eb50b387034a860f146c4919f318763cd6c5598c8\n\t\t\t\tae4811a1e0abc4c7e0b082d693a5e7fced675cf4668512772c0c\n\t\t\t\tbc64a742c6c630f533c8cc72f62ae833c40bf25842e984bb78bd\n\t\t\t\tbf97c0107d55bdb662f5c4e0fab9845cb5148ef7392dd3aaff93\n\t\t\t\tae1e6b667bb3d4247616d4f5ba10d4cfd226de88d39f16fb`),\n\t\t\tE: 65537,\n\t\t},\n\t\tD: fromHexInt(`\n\t\t\t\t53339cfdb79fc8466a655c7316aca85c55fd8f6dd898fdaf1195\n\t\t\t\t17ef4f52e8fd8e258df93fee180fa0e4ab29693cd83b152a553d\n\t\t\t\t4ac4d1812b8b9fa5af0e7f55fe7304df41570926f3311f15c4d6\n\t\t\t\t5a732c483116ee3d3d2d0af3549ad9bf7cbfb78ad884f84d5beb\n\t\t\t\t04724dc7369b31def37d0cf539e9cfcdd3de653729ead5d1`),\n\t\tPrimes: []*big.Int{\n\t\t\tfromHexInt(`\n\t\t\t\td32737e7267ffe1341b2d5c0d150a81b586fb3132bed2f8d5262\n\t\t\t\t864a9cb9f30af38be448598d413a172efb802c21acf1c11c520c\n\t\t\t\t2f26a471dcad212eac7ca39d`),\n\t\t\tfromHexInt(`\n\t\t\t\tcc8853d1d54da630fac004f471f281c7b8982d8224a490edbeb3\n\t\t\t\t3d3e3d5cc93c4765703d1dd791642f1f116a0dd852be2419b2af\n\t\t\t\t72bfe9a030e860b0288b5d77`),\n\t\t},\n\t}\n\n\tinput := fromHexBytes(\n\t\t\"6628194e12073db03ba94cda9ef9532397d50dba79b987004afefe34\")\n\n\texpectedPKCS := fromHexBytes(`\n\t\t50b4c14136bd198c2f3c3ed243fce036e168d56517984a263cd66492b808\n\t\t04f169d210f2b9bdfb48b12f9ea05009c77da257cc600ccefe3a6283789d\n\t\t8ea0e607ac58e2690ec4ebc10146e8cbaa5ed4d5cce6fe7b0ff9efc1eabb\n\t\t564dbf498285f449ee61dd7b42ee5b5892cb90601f30cda07bf26489310b\n\t\tcd23b528ceab3c31`)\n\n\texpectedOAEP := fromHexBytes(`\n\t\t354fe67b4a126d5d35fe36c777791a3f7ba13def484e2d3908aff722fad4\n\t\t68fb21696de95d0be911c2d3174f8afcc201035f7b6d8e69402de5451618\n\t\tc21a535fa9d7bfc5b8dd9fc243f8cf927db31322d6e881eaa91a996170e6\n\t\t57a05a266426d98c88003f8477c1227094a0d9fa1e8c4024309ce1ecccb5\n\t\t210035d47ac72e8a`)\n\n\t// Mock random reader\n\trandReader = bytes.NewReader(fromHexBytes(`\n\t\t017341ae3875d5f87101f8cc4fa9b9bc156bb04628fccdb2f4f11e905bd3\n\t\ta155d376f593bd7304210874eba08a5e22bcccb4c9d3882a93a54db022f5\n\t\t03d16338b6b7ce16dc7f4bbf9a96b59772d6606e9747c7649bf9e083db98\n\t\t1884a954ab3c6f18b776ea21069d69776a33e96bad48e1dda0a5ef`))\n\tdefer resetRandReader()\n\n\t// RSA-PKCS1v1.5 encrypt\n\tenc := new(rsaEncrypterVerifier)\n\tenc.publicKey = &priv.PublicKey\n\tencryptedPKCS, err := enc.encrypt(input, RSA1_5)\n\tif err != nil {\n\t\tt.Error(\"Encryption failed:\", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(encryptedPKCS, expectedPKCS) != 0 {\n\t\tt.Error(\"Output does not match expected value (PKCS1v1.5)\")\n\t}\n\n\t// RSA-OAEP encrypt\n\tencryptedOAEP, err := enc.encrypt(input, RSA_OAEP)\n\tif err != nil {\n\t\tt.Error(\"Encryption failed:\", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(encryptedOAEP, expectedOAEP) != 0 {\n\t\tt.Error(\"Output does not match expected value (OAEP)\")\n\t}\n\n\t// Need fake cipher for PKCS1v1.5 decrypt\n\tresetRandReader()\n\taes := newAESGCM(len(input))\n\n\tkeygen := randomKeyGenerator{\n\t\tsize: aes.keySize(),\n\t}\n\n\t// RSA-PKCS1v1.5 decrypt\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = priv\n\tdecryptedPKCS, err := dec.decrypt(encryptedPKCS, RSA1_5, keygen)\n\tif err != nil {\n\t\tt.Error(\"Decryption failed:\", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(input, decryptedPKCS) != 0 {\n\t\tt.Error(\"Output does not match expected value (PKCS1v1.5)\")\n\t}\n\n\t// RSA-OAEP decrypt\n\tdecryptedOAEP, err := dec.decrypt(encryptedOAEP, RSA_OAEP, keygen)\n\tif err != nil {\n\t\tt.Error(\"decryption failed:\", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(input, decryptedOAEP) != 0 {\n\t\tt.Error(\"output does not match expected value (OAEP)\")\n\t}\n}\n\nfunc TestInvalidAlgorithmsRSA(t *testing.T) {\n\t_, err := newRSARecipient(\"XYZ\", nil)\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\t_, err = newRSASigner(\"XYZ\", nil)\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\tenc := new(rsaEncrypterVerifier)\n\tenc.publicKey = &rsaTestKey.PublicKey\n\t_, err = enc.encryptKey([]byte{}, \"XYZ\")\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\terr = enc.verifyPayload([]byte{}, []byte{}, \"XYZ\")\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = rsaTestKey\n\t_, err = dec.decrypt(make([]byte, 256), \"XYZ\", randomKeyGenerator{size: 16})\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\t_, err = dec.signPayload([]byte{}, \"XYZ\")\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n}\n\ntype failingKeyGenerator struct{}\n\nfunc (ctx failingKeyGenerator) keySize() int {\n\treturn 0\n}\n\nfunc (ctx failingKeyGenerator) genKey() ([]byte, rawHeader, error) {\n\treturn nil, rawHeader{}, errors.New(\"failed to generate key\")\n}\n\nfunc TestPKCSKeyGeneratorFailure(t *testing.T) {\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = rsaTestKey\n\tgenerator := failingKeyGenerator{}\n\t_, err := dec.decrypt(make([]byte, 256), RSA1_5, generator)\n\tif err != ErrCryptoFailure {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n}\n\nfunc TestInvalidAlgorithmsEC(t *testing.T) {\n\t_, err := newECDHRecipient(\"XYZ\", nil)\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\t_, err = newECDSASigner(\"XYZ\", nil)\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\tenc := new(ecEncrypterVerifier)\n\tenc.publicKey = &ecTestKey256.PublicKey\n\t_, err = enc.encryptKey([]byte{}, \"XYZ\")\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n}\n\nfunc TestInvalidECKeyGen(t *testing.T) {\n\tgen := ecKeyGenerator{\n\t\tsize:      16,\n\t\talgID:     \"A128GCM\",\n\t\tpublicKey: &ecTestKey256.PublicKey,\n\t}\n\n\tif gen.keySize() != 16 {\n\t\tt.Error(\"ec key generator reported incorrect key size\")\n\t}\n\n\t_, _, err := gen.genKey()\n\tif err != nil {\n\t\tt.Error(\"ec key generator failed to generate key\", err)\n\t}\n}\n\nfunc TestInvalidECDecrypt(t *testing.T) {\n\tdec := ecDecrypterSigner{\n\t\tprivateKey: ecTestKey256,\n\t}\n\n\tgenerator := randomKeyGenerator{size: 16}\n\n\t// Missing epk header\n\theaders := rawHeader{\n\t\tAlg: string(ECDH_ES),\n\t}\n\n\t_, err := dec.decryptKey(headers, nil, generator)\n\tif err == nil {\n\t\tt.Error(\"ec decrypter accepted object with missing epk header\")\n\t}\n\n\t// Invalid epk header\n\theaders.Epk = &JsonWebKey{}\n\n\t_, err = dec.decryptKey(headers, nil, generator)\n\tif err == nil {\n\t\tt.Error(\"ec decrypter accepted object with invalid epk header\")\n\t}\n}\n\nfunc TestDecryptWithIncorrectSize(t *testing.T) {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = priv\n\taes := newAESGCM(16)\n\n\tkeygen := randomKeyGenerator{\n\t\tsize: aes.keySize(),\n\t}\n\n\tpayload := make([]byte, 254)\n\t_, err = dec.decrypt(payload, RSA1_5, keygen)\n\tif err == nil {\n\t\tt.Error(\"Invalid payload size should return error\")\n\t}\n\n\tpayload = make([]byte, 257)\n\t_, err = dec.decrypt(payload, RSA1_5, keygen)\n\tif err == nil {\n\t\tt.Error(\"Invalid payload size should return error\")\n\t}\n}\n\nfunc TestPKCSDecryptNeverFails(t *testing.T) {\n\t// We don't want RSA-PKCS1 v1.5 decryption to ever fail, in order to prevent\n\t// side-channel timing attacks (Bleichenbacher attack in particular).\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = priv\n\taes := newAESGCM(16)\n\n\tkeygen := randomKeyGenerator{\n\t\tsize: aes.keySize(),\n\t}\n\n\tfor i := 1; i < 50; i++ {\n\t\tpayload := make([]byte, 256)\n\t\t_, err := io.ReadFull(rand.Reader, payload)\n\t\tif err != nil {\n\t\t\tt.Error(\"Unable to get random data:\", err)\n\t\t\treturn\n\t\t}\n\t\t_, err = dec.decrypt(payload, RSA1_5, keygen)\n\t\tif err != nil {\n\t\t\tt.Error(\"PKCS1v1.5 decrypt should never fail:\", err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc BenchmarkPKCSDecryptWithValidPayloads(b *testing.B) {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tenc := new(rsaEncrypterVerifier)\n\tenc.publicKey = &priv.PublicKey\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = priv\n\taes := newAESGCM(32)\n\n\tb.StopTimer()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tplaintext := make([]byte, 32)\n\t\t_, err = io.ReadFull(rand.Reader, plaintext)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tciphertext, err := enc.encrypt(plaintext, RSA1_5)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tkeygen := randomKeyGenerator{\n\t\t\tsize: aes.keySize(),\n\t\t}\n\n\t\tb.StartTimer()\n\t\t_, err = dec.decrypt(ciphertext, RSA1_5, keygen)\n\t\tb.StopTimer()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkPKCSDecryptWithInvalidPayloads(b *testing.B) {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tenc := new(rsaEncrypterVerifier)\n\tenc.publicKey = &priv.PublicKey\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = priv\n\taes := newAESGCM(16)\n\n\tkeygen := randomKeyGenerator{\n\t\tsize: aes.keySize(),\n\t}\n\n\tb.StopTimer()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tplaintext := make([]byte, 16)\n\t\t_, err = io.ReadFull(rand.Reader, plaintext)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tciphertext, err := enc.encrypt(plaintext, RSA1_5)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\t// Do some simple scrambling\n\t\tciphertext[128] ^= 0xFF\n\n\t\tb.StartTimer()\n\t\t_, err = dec.decrypt(ciphertext, RSA1_5, keygen)\n\t\tb.StopTimer()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc TestInvalidEllipticCurve(t *testing.T) {\n\tsigner256 := ecDecrypterSigner{privateKey: ecTestKey256}\n\tsigner384 := ecDecrypterSigner{privateKey: ecTestKey384}\n\tsigner521 := ecDecrypterSigner{privateKey: ecTestKey521}\n\n\t_, err := signer256.signPayload([]byte{}, ES384)\n\tif err == nil {\n\t\tt.Error(\"should not generate ES384 signature with P-256 key\")\n\t}\n\t_, err = signer256.signPayload([]byte{}, ES512)\n\tif err == nil {\n\t\tt.Error(\"should not generate ES512 signature with P-256 key\")\n\t}\n\t_, err = signer384.signPayload([]byte{}, ES256)\n\tif err == nil {\n\t\tt.Error(\"should not generate ES256 signature with P-384 key\")\n\t}\n\t_, err = signer384.signPayload([]byte{}, ES512)\n\tif err == nil {\n\t\tt.Error(\"should not generate ES512 signature with P-384 key\")\n\t}\n\t_, err = signer521.signPayload([]byte{}, ES256)\n\tif err == nil {\n\t\tt.Error(\"should not generate ES256 signature with P-521 key\")\n\t}\n\t_, err = signer521.signPayload([]byte{}, ES384)\n\tif err == nil {\n\t\tt.Error(\"should not generate ES384 signature with P-521 key\")\n\t}\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage josecipher\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"encoding/binary\"\n)\n\n// DeriveECDHES derives a shared encryption key using ECDH/ConcatKDF as described in JWE/JWA.\nfunc DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, pub *ecdsa.PublicKey, size int) []byte {\n\t// algId, partyUInfo, partyVInfo inputs must be prefixed with the length\n\talgID := lengthPrefixed([]byte(alg))\n\tptyUInfo := lengthPrefixed(apuData)\n\tptyVInfo := lengthPrefixed(apvData)\n\n\t// suppPubInfo is the encoded length of the output size in bits\n\tsupPubInfo := make([]byte, 4)\n\tbinary.BigEndian.PutUint32(supPubInfo, uint32(size)*8)\n\n\tz, _ := priv.PublicKey.Curve.ScalarMult(pub.X, pub.Y, priv.D.Bytes())\n\treader := NewConcatKDF(crypto.SHA256, z.Bytes(), algID, ptyUInfo, ptyVInfo, supPubInfo, []byte{})\n\n\tkey := make([]byte, size)\n\n\t// Read on the KDF will never fail\n\t_, _ = reader.Read(key)\n\treturn key\n}\n\nfunc lengthPrefixed(data []byte) []byte {\n\tout := make([]byte, len(data)+4)\n\tbinary.BigEndian.PutUint32(out, uint32(len(data)))\n\tcopy(out[4:], data)\n\treturn out\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage josecipher\n\nimport (\n\t\"bytes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"encoding/base64\"\n\t\"math/big\"\n\t\"testing\"\n)\n\n// Example keys from JWA, Appendix C\nvar aliceKey = &ecdsa.PrivateKey{\n\tPublicKey: ecdsa.PublicKey{\n\t\tCurve: elliptic.P256(),\n\t\tX:     fromBase64Int(\"gI0GAILBdu7T53akrFmMyGcsF3n5dO7MmwNBHKW5SV0=\"),\n\t\tY:     fromBase64Int(\"SLW_xSffzlPWrHEVI30DHM_4egVwt3NQqeUD7nMFpps=\"),\n\t},\n\tD: fromBase64Int(\"0_NxaRPUMQoAJt50Gz8YiTr8gRTwyEaCumd-MToTmIo=\"),\n}\n\nvar bobKey = &ecdsa.PrivateKey{\n\tPublicKey: ecdsa.PublicKey{\n\t\tCurve: elliptic.P256(),\n\t\tX:     fromBase64Int(\"weNJy2HscCSM6AEDTDg04biOvhFhyyWvOHQfeF_PxMQ=\"),\n\t\tY:     fromBase64Int(\"e8lnCO-AlStT-NJVX-crhB7QRYhiix03illJOVAOyck=\"),\n\t},\n\tD: fromBase64Int(\"VEmDZpDXXK8p8N0Cndsxs924q6nS1RXFASRl6BfUqdw=\"),\n}\n\n// Build big int from base64-encoded string. Strips whitespace (for testing).\nfunc fromBase64Int(data string) *big.Int {\n\tval, err := base64.URLEncoding.DecodeString(data)\n\tif err != nil {\n\t\tpanic(\"Invalid test data\")\n\t}\n\treturn new(big.Int).SetBytes(val)\n}\n\nfunc TestVectorECDHES(t *testing.T) {\n\tapuData := []byte(\"Alice\")\n\tapvData := []byte(\"Bob\")\n\n\texpected := []byte{\n\t\t86, 170, 141, 234, 248, 35, 109, 32, 92, 34, 40, 205, 113, 167, 16, 26}\n\n\toutput := DeriveECDHES(\"A128GCM\", apuData, apvData, bobKey, &aliceKey.PublicKey, 16)\n\n\tif bytes.Compare(output, expected) != 0 {\n\t\tt.Error(\"output did not match what we expect, got\", output, \"wanted\", expected)\n\t}\n}\n\nfunc BenchmarkECDHES_128(b *testing.B) {\n\tapuData := []byte(\"APU\")\n\tapvData := []byte(\"APV\")\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tDeriveECDHES(\"ID\", apuData, apvData, bobKey, &aliceKey.PublicKey, 16)\n\t}\n}\n\nfunc BenchmarkECDHES_192(b *testing.B) {\n\tapuData := []byte(\"APU\")\n\tapvData := []byte(\"APV\")\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tDeriveECDHES(\"ID\", apuData, apvData, bobKey, &aliceKey.PublicKey, 24)\n\t}\n}\n\nfunc BenchmarkECDHES_256(b *testing.B) {\n\tapuData := []byte(\"APU\")\n\tapvData := []byte(\"APV\")\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tDeriveECDHES(\"ID\", apuData, apvData, bobKey, &aliceKey.PublicKey, 32)\n\t}\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/square/go-jose/json\"\n)\n\n// rawJsonWebKey represents a public or private key in JWK format, used for parsing/serializing.\ntype rawJsonWebKey struct {\n\tUse string      `json:\"use,omitempty\"`\n\tKty string      `json:\"kty,omitempty\"`\n\tKid string      `json:\"kid,omitempty\"`\n\tCrv string      `json:\"crv,omitempty\"`\n\tAlg string      `json:\"alg,omitempty\"`\n\tK   *byteBuffer `json:\"k,omitempty\"`\n\tX   *byteBuffer `json:\"x,omitempty\"`\n\tY   *byteBuffer `json:\"y,omitempty\"`\n\tN   *byteBuffer `json:\"n,omitempty\"`\n\tE   *byteBuffer `json:\"e,omitempty\"`\n\t// -- Following fields are only used for private keys --\n\t// RSA uses D, P and Q, while ECDSA uses only D. Fields Dp, Dq, and Qi are\n\t// completely optional. Therefore for RSA/ECDSA, D != nil is a contract that\n\t// we have a private key whereas D == nil means we have only a public key.\n\tD  *byteBuffer `json:\"d,omitempty\"`\n\tP  *byteBuffer `json:\"p,omitempty\"`\n\tQ  *byteBuffer `json:\"q,omitempty\"`\n\tDp *byteBuffer `json:\"dp,omitempty\"`\n\tDq *byteBuffer `json:\"dq,omitempty\"`\n\tQi *byteBuffer `json:\"qi,omitempty\"`\n\t// Certificates\n\tX5c []string `json:\"x5c,omitempty\"`\n}\n\n// JsonWebKey represents a public or private key in JWK format.\ntype JsonWebKey struct {\n\tKey          interface{}\n\tCertificates []*x509.Certificate\n\tKeyID        string\n\tAlgorithm    string\n\tUse          string\n}\n\n// MarshalJSON serializes the given key to its JSON representation.\nfunc (k JsonWebKey) MarshalJSON() ([]byte, error) {\n\tvar raw *rawJsonWebKey\n\tvar err error\n\n\tswitch key := k.Key.(type) {\n\tcase *ecdsa.PublicKey:\n\t\traw, err = fromEcPublicKey(key)\n\tcase *rsa.PublicKey:\n\t\traw = fromRsaPublicKey(key)\n\tcase *ecdsa.PrivateKey:\n\t\traw, err = fromEcPrivateKey(key)\n\tcase *rsa.PrivateKey:\n\t\traw, err = fromRsaPrivateKey(key)\n\tcase []byte:\n\t\traw, err = fromSymmetricKey(key)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"square/go-jose: unknown key type '%s'\", reflect.TypeOf(key))\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\traw.Kid = k.KeyID\n\traw.Alg = k.Algorithm\n\traw.Use = k.Use\n\n\tfor _, cert := range k.Certificates {\n\t\traw.X5c = append(raw.X5c, base64.StdEncoding.EncodeToString(cert.Raw))\n\t}\n\n\treturn json.Marshal(raw)\n}\n\n// UnmarshalJSON reads a key from its JSON representation.\nfunc (k *JsonWebKey) UnmarshalJSON(data []byte) (err error) {\n\tvar raw rawJsonWebKey\n\terr = json.Unmarshal(data, &raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar key interface{}\n\tswitch raw.Kty {\n\tcase \"EC\":\n\t\tif raw.D != nil {\n\t\t\tkey, err = raw.ecPrivateKey()\n\t\t} else {\n\t\t\tkey, err = raw.ecPublicKey()\n\t\t}\n\tcase \"RSA\":\n\t\tif raw.D != nil {\n\t\t\tkey, err = raw.rsaPrivateKey()\n\t\t} else {\n\t\t\tkey, err = raw.rsaPublicKey()\n\t\t}\n\tcase \"oct\":\n\t\tkey, err = raw.symmetricKey()\n\tdefault:\n\t\terr = fmt.Errorf(\"square/go-jose: unknown json web key type '%s'\", raw.Kty)\n\t}\n\n\tif err == nil {\n\t\t*k = JsonWebKey{Key: key, KeyID: raw.Kid, Algorithm: raw.Alg, Use: raw.Use}\n\t}\n\n\tk.Certificates = make([]*x509.Certificate, len(raw.X5c))\n\tfor i, cert := range raw.X5c {\n\t\traw, err := base64.StdEncoding.DecodeString(cert)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tk.Certificates[i], err = x509.ParseCertificate(raw)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn\n}\n\n// JsonWebKeySet represents a JWK Set object.\ntype JsonWebKeySet struct {\n\tKeys []JsonWebKey `json:\"keys\"`\n}\n\n// Key convenience method returns keys by key ID. Specification states\n// that a JWK Set \"SHOULD\" use distinct key IDs, but allows for some\n// cases where they are not distinct. Hence method returns a slice\n// of JsonWebKeys.\nfunc (s *JsonWebKeySet) Key(kid string) []JsonWebKey {\n\tvar keys []JsonWebKey\n\tfor _, key := range s.Keys {\n\t\tif key.KeyID == kid {\n\t\t\tkeys = append(keys, key)\n\t\t}\n\t}\n\n\treturn keys\n}\n\nconst rsaThumbprintTemplate = `{\"e\":\"%s\",\"kty\":\"RSA\",\"n\":\"%s\"}`\nconst ecThumbprintTemplate = `{\"crv\":\"%s\",\"kty\":\"EC\",\"x\":\"%s\",\"y\":\"%s\"}`\n\nfunc ecThumbprintInput(curve elliptic.Curve, x, y *big.Int) (string, error) {\n\tcoordLength := curveSize(curve)\n\tcrv, err := curveName(curve)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn fmt.Sprintf(ecThumbprintTemplate, crv,\n\t\tnewFixedSizeBuffer(x.Bytes(), coordLength).base64(),\n\t\tnewFixedSizeBuffer(y.Bytes(), coordLength).base64()), nil\n}\n\nfunc rsaThumbprintInput(n *big.Int, e int) (string, error) {\n\treturn fmt.Sprintf(rsaThumbprintTemplate,\n\t\tnewBufferFromInt(uint64(e)).base64(),\n\t\tnewBuffer(n.Bytes()).base64()), nil\n}\n\n// Thumbprint computes the JWK Thumbprint of a key using the\n// indicated hash algorithm.\nfunc (k *JsonWebKey) Thumbprint(hash crypto.Hash) ([]byte, error) {\n\tvar input string\n\tvar err error\n\tswitch key := k.Key.(type) {\n\tcase *ecdsa.PublicKey:\n\t\tinput, err = ecThumbprintInput(key.Curve, key.X, key.Y)\n\tcase *ecdsa.PrivateKey:\n\t\tinput, err = ecThumbprintInput(key.Curve, key.X, key.Y)\n\tcase *rsa.PublicKey:\n\t\tinput, err = rsaThumbprintInput(key.N, key.E)\n\tcase *rsa.PrivateKey:\n\t\tinput, err = rsaThumbprintInput(key.N, key.E)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"square/go-jose: unknown key type '%s'\", reflect.TypeOf(key))\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\th := hash.New()\n\th.Write([]byte(input))\n\treturn h.Sum(nil), nil\n}\n\n// Valid checks that the key contains the expected parameters\nfunc (k *JsonWebKey) Valid() bool {\n\tif k.Key == nil {\n\t\treturn false\n\t}\n\tswitch key := k.Key.(type) {\n\tcase *ecdsa.PublicKey:\n\t\tif key.Curve == nil || key.X == nil || key.Y == nil {\n\t\t\treturn false\n\t\t}\n\tcase *ecdsa.PrivateKey:\n\t\tif key.Curve == nil || key.X == nil || key.Y == nil || key.D == nil {\n\t\t\treturn false\n\t\t}\n\tcase *rsa.PublicKey:\n\t\tif key.N == nil || key.E == 0 {\n\t\t\treturn false\n\t\t}\n\tcase *rsa.PrivateKey:\n\t\tif key.N == nil || key.E == 0 || key.D == nil || len(key.Primes) < 2 {\n\t\t\treturn false\n\t\t}\n\tdefault:\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (key rawJsonWebKey) rsaPublicKey() (*rsa.PublicKey, error) {\n\tif key.N == nil || key.E == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid RSA key, missing n/e values\")\n\t}\n\n\treturn &rsa.PublicKey{\n\t\tN: key.N.bigInt(),\n\t\tE: key.E.toInt(),\n\t}, nil\n}\n\nfunc fromRsaPublicKey(pub *rsa.PublicKey) *rawJsonWebKey {\n\treturn &rawJsonWebKey{\n\t\tKty: \"RSA\",\n\t\tN:   newBuffer(pub.N.Bytes()),\n\t\tE:   newBufferFromInt(uint64(pub.E)),\n\t}\n}\n\nfunc (key rawJsonWebKey) ecPublicKey() (*ecdsa.PublicKey, error) {\n\tvar curve elliptic.Curve\n\tswitch key.Crv {\n\tcase \"P-256\":\n\t\tcurve = elliptic.P256()\n\tcase \"P-384\":\n\t\tcurve = elliptic.P384()\n\tcase \"P-521\":\n\t\tcurve = elliptic.P521()\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"square/go-jose: unsupported elliptic curve '%s'\", key.Crv)\n\t}\n\n\tif key.X == nil || key.Y == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid EC key, missing x/y values\")\n\t}\n\n\treturn &ecdsa.PublicKey{\n\t\tCurve: curve,\n\t\tX:     key.X.bigInt(),\n\t\tY:     key.Y.bigInt(),\n\t}, nil\n}\n\nfunc fromEcPublicKey(pub *ecdsa.PublicKey) (*rawJsonWebKey, error) {\n\tif pub == nil || pub.X == nil || pub.Y == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid EC key (nil, or X/Y missing)\")\n\t}\n\n\tname, err := curveName(pub.Curve)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsize := curveSize(pub.Curve)\n\n\txBytes := pub.X.Bytes()\n\tyBytes := pub.Y.Bytes()\n\n\tif len(xBytes) > size || len(yBytes) > size {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid EC key (X/Y too large)\")\n\t}\n\n\tkey := &rawJsonWebKey{\n\t\tKty: \"EC\",\n\t\tCrv: name,\n\t\tX:   newFixedSizeBuffer(xBytes, size),\n\t\tY:   newFixedSizeBuffer(yBytes, size),\n\t}\n\n\treturn key, nil\n}\n\nfunc (key rawJsonWebKey) rsaPrivateKey() (*rsa.PrivateKey, error) {\n\tvar missing []string\n\tswitch {\n\tcase key.N == nil:\n\t\tmissing = append(missing, \"N\")\n\tcase key.E == nil:\n\t\tmissing = append(missing, \"E\")\n\tcase key.D == nil:\n\t\tmissing = append(missing, \"D\")\n\tcase key.P == nil:\n\t\tmissing = append(missing, \"P\")\n\tcase key.Q == nil:\n\t\tmissing = append(missing, \"Q\")\n\t}\n\n\tif len(missing) > 0 {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid RSA private key, missing %s value(s)\", strings.Join(missing, \", \"))\n\t}\n\n\trv := &rsa.PrivateKey{\n\t\tPublicKey: rsa.PublicKey{\n\t\t\tN: key.N.bigInt(),\n\t\t\tE: key.E.toInt(),\n\t\t},\n\t\tD: key.D.bigInt(),\n\t\tPrimes: []*big.Int{\n\t\t\tkey.P.bigInt(),\n\t\t\tkey.Q.bigInt(),\n\t\t},\n\t}\n\n\tif key.Dp != nil {\n\t\trv.Precomputed.Dp = key.Dp.bigInt()\n\t}\n\tif key.Dq != nil {\n\t\trv.Precomputed.Dq = key.Dq.bigInt()\n\t}\n\tif key.Qi != nil {\n\t\trv.Precomputed.Qinv = key.Qi.bigInt()\n\t}\n\n\terr := rv.Validate()\n\treturn rv, err\n}\n\nfunc fromRsaPrivateKey(rsa *rsa.PrivateKey) (*rawJsonWebKey, error) {\n\tif len(rsa.Primes) != 2 {\n\t\treturn nil, ErrUnsupportedKeyType\n\t}\n\n\traw := fromRsaPublicKey(&rsa.PublicKey)\n\n\traw.D = newBuffer(rsa.D.Bytes())\n\traw.P = newBuffer(rsa.Primes[0].Bytes())\n\traw.Q = newBuffer(rsa.Primes[1].Bytes())\n\n\treturn raw, nil\n}\n\nfunc (key rawJsonWebKey) ecPrivateKey() (*ecdsa.PrivateKey, error) {\n\tvar curve elliptic.Curve\n\tswitch key.Crv {\n\tcase \"P-256\":\n\t\tcurve = elliptic.P256()\n\tcase \"P-384\":\n\t\tcurve = elliptic.P384()\n\tcase \"P-521\":\n\t\tcurve = elliptic.P521()\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"square/go-jose: unsupported elliptic curve '%s'\", key.Crv)\n\t}\n\n\tif key.X == nil || key.Y == nil || key.D == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid EC private key, missing x/y/d values\")\n\t}\n\n\treturn &ecdsa.PrivateKey{\n\t\tPublicKey: ecdsa.PublicKey{\n\t\t\tCurve: curve,\n\t\t\tX:     key.X.bigInt(),\n\t\t\tY:     key.Y.bigInt(),\n\t\t},\n\t\tD: key.D.bigInt(),\n\t}, nil\n}\n\nfunc fromEcPrivateKey(ec *ecdsa.PrivateKey) (*rawJsonWebKey, error) {\n\traw, err := fromEcPublicKey(&ec.PublicKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif ec.D == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid EC private key\")\n\t}\n\n\traw.D = newBuffer(ec.D.Bytes())\n\n\treturn raw, nil\n}\n\nfunc fromSymmetricKey(key []byte) (*rawJsonWebKey, error) {\n\treturn &rawJsonWebKey{\n\t\tKty: \"oct\",\n\t\tK:   newBuffer(key),\n\t}, nil\n}\n\nfunc (key rawJsonWebKey) symmetricKey() ([]byte, error) {\n\tif key.K == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid OCT (symmetric) key, missing k value\")\n\t}\n\treturn key.K.bytes(), nil\n}\n"], "fixing_code": ["/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"crypto\"\n\t\"crypto/aes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/sha1\"\n\t\"crypto/sha256\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/square/go-jose/cipher\"\n)\n\n// A generic RSA-based encrypter/verifier\ntype rsaEncrypterVerifier struct {\n\tpublicKey *rsa.PublicKey\n}\n\n// A generic RSA-based decrypter/signer\ntype rsaDecrypterSigner struct {\n\tprivateKey *rsa.PrivateKey\n}\n\n// A generic EC-based encrypter/verifier\ntype ecEncrypterVerifier struct {\n\tpublicKey *ecdsa.PublicKey\n}\n\n// A key generator for ECDH-ES\ntype ecKeyGenerator struct {\n\tsize      int\n\talgID     string\n\tpublicKey *ecdsa.PublicKey\n}\n\n// A generic EC-based decrypter/signer\ntype ecDecrypterSigner struct {\n\tprivateKey *ecdsa.PrivateKey\n}\n\n// newRSARecipient creates recipientKeyInfo based on the given key.\nfunc newRSARecipient(keyAlg KeyAlgorithm, publicKey *rsa.PublicKey) (recipientKeyInfo, error) {\n\t// Verify that key management algorithm is supported by this encrypter\n\tswitch keyAlg {\n\tcase RSA1_5, RSA_OAEP, RSA_OAEP_256:\n\tdefault:\n\t\treturn recipientKeyInfo{}, ErrUnsupportedAlgorithm\n\t}\n\n\treturn recipientKeyInfo{\n\t\tkeyAlg: keyAlg,\n\t\tkeyEncrypter: &rsaEncrypterVerifier{\n\t\t\tpublicKey: publicKey,\n\t\t},\n\t}, nil\n}\n\n// newRSASigner creates a recipientSigInfo based on the given key.\nfunc newRSASigner(sigAlg SignatureAlgorithm, privateKey *rsa.PrivateKey) (recipientSigInfo, error) {\n\t// Verify that key management algorithm is supported by this encrypter\n\tswitch sigAlg {\n\tcase RS256, RS384, RS512, PS256, PS384, PS512:\n\tdefault:\n\t\treturn recipientSigInfo{}, ErrUnsupportedAlgorithm\n\t}\n\n\treturn recipientSigInfo{\n\t\tsigAlg: sigAlg,\n\t\tpublicKey: &JsonWebKey{\n\t\t\tKey: &privateKey.PublicKey,\n\t\t},\n\t\tsigner: &rsaDecrypterSigner{\n\t\t\tprivateKey: privateKey,\n\t\t},\n\t}, nil\n}\n\n// newECDHRecipient creates recipientKeyInfo based on the given key.\nfunc newECDHRecipient(keyAlg KeyAlgorithm, publicKey *ecdsa.PublicKey) (recipientKeyInfo, error) {\n\t// Verify that key management algorithm is supported by this encrypter\n\tswitch keyAlg {\n\tcase ECDH_ES, ECDH_ES_A128KW, ECDH_ES_A192KW, ECDH_ES_A256KW:\n\tdefault:\n\t\treturn recipientKeyInfo{}, ErrUnsupportedAlgorithm\n\t}\n\n\treturn recipientKeyInfo{\n\t\tkeyAlg: keyAlg,\n\t\tkeyEncrypter: &ecEncrypterVerifier{\n\t\t\tpublicKey: publicKey,\n\t\t},\n\t}, nil\n}\n\n// newECDSASigner creates a recipientSigInfo based on the given key.\nfunc newECDSASigner(sigAlg SignatureAlgorithm, privateKey *ecdsa.PrivateKey) (recipientSigInfo, error) {\n\t// Verify that key management algorithm is supported by this encrypter\n\tswitch sigAlg {\n\tcase ES256, ES384, ES512:\n\tdefault:\n\t\treturn recipientSigInfo{}, ErrUnsupportedAlgorithm\n\t}\n\n\treturn recipientSigInfo{\n\t\tsigAlg: sigAlg,\n\t\tpublicKey: &JsonWebKey{\n\t\t\tKey: &privateKey.PublicKey,\n\t\t},\n\t\tsigner: &ecDecrypterSigner{\n\t\t\tprivateKey: privateKey,\n\t\t},\n\t}, nil\n}\n\n// Encrypt the given payload and update the object.\nfunc (ctx rsaEncrypterVerifier) encryptKey(cek []byte, alg KeyAlgorithm) (recipientInfo, error) {\n\tencryptedKey, err := ctx.encrypt(cek, alg)\n\tif err != nil {\n\t\treturn recipientInfo{}, err\n\t}\n\n\treturn recipientInfo{\n\t\tencryptedKey: encryptedKey,\n\t\theader:       &rawHeader{},\n\t}, nil\n}\n\n// Encrypt the given payload. Based on the key encryption algorithm,\n// this will either use RSA-PKCS1v1.5 or RSA-OAEP (with SHA-1 or SHA-256).\nfunc (ctx rsaEncrypterVerifier) encrypt(cek []byte, alg KeyAlgorithm) ([]byte, error) {\n\tswitch alg {\n\tcase RSA1_5:\n\t\treturn rsa.EncryptPKCS1v15(randReader, ctx.publicKey, cek)\n\tcase RSA_OAEP:\n\t\treturn rsa.EncryptOAEP(sha1.New(), randReader, ctx.publicKey, cek, []byte{})\n\tcase RSA_OAEP_256:\n\t\treturn rsa.EncryptOAEP(sha256.New(), randReader, ctx.publicKey, cek, []byte{})\n\t}\n\n\treturn nil, ErrUnsupportedAlgorithm\n}\n\n// Decrypt the given payload and return the content encryption key.\nfunc (ctx rsaDecrypterSigner) decryptKey(headers rawHeader, recipient *recipientInfo, generator keyGenerator) ([]byte, error) {\n\treturn ctx.decrypt(recipient.encryptedKey, KeyAlgorithm(headers.Alg), generator)\n}\n\n// Decrypt the given payload. Based on the key encryption algorithm,\n// this will either use RSA-PKCS1v1.5 or RSA-OAEP (with SHA-1 or SHA-256).\nfunc (ctx rsaDecrypterSigner) decrypt(jek []byte, alg KeyAlgorithm, generator keyGenerator) ([]byte, error) {\n\t// Note: The random reader on decrypt operations is only used for blinding,\n\t// so stubbing is meanlingless (hence the direct use of rand.Reader).\n\tswitch alg {\n\tcase RSA1_5:\n\t\tdefer func() {\n\t\t\t// DecryptPKCS1v15SessionKey sometimes panics on an invalid payload\n\t\t\t// because of an index out of bounds error, which we want to ignore.\n\t\t\t// This has been fixed in Go 1.3.1 (released 2014/08/13), the recover()\n\t\t\t// only exists for preventing crashes with unpatched versions.\n\t\t\t// See: https://groups.google.com/forum/#!topic/golang-dev/7ihX6Y6kx9k\n\t\t\t// See: https://code.google.com/p/go/source/detail?r=58ee390ff31602edb66af41ed10901ec95904d33\n\t\t\t_ = recover()\n\t\t}()\n\n\t\t// Perform some input validation.\n\t\tkeyBytes := ctx.privateKey.PublicKey.N.BitLen() / 8\n\t\tif keyBytes != len(jek) {\n\t\t\t// Input size is incorrect, the encrypted payload should always match\n\t\t\t// the size of the public modulus (e.g. using a 2048 bit key will\n\t\t\t// produce 256 bytes of output). Reject this since it's invalid input.\n\t\t\treturn nil, ErrCryptoFailure\n\t\t}\n\n\t\tcek, _, err := generator.genKey()\n\t\tif err != nil {\n\t\t\treturn nil, ErrCryptoFailure\n\t\t}\n\n\t\t// When decrypting an RSA-PKCS1v1.5 payload, we must take precautions to\n\t\t// prevent chosen-ciphertext attacks as described in RFC 3218, \"Preventing\n\t\t// the Million Message Attack on Cryptographic Message Syntax\". We are\n\t\t// therefore deliberately ignoring errors here.\n\t\t_ = rsa.DecryptPKCS1v15SessionKey(rand.Reader, ctx.privateKey, jek, cek)\n\n\t\treturn cek, nil\n\tcase RSA_OAEP:\n\t\t// Use rand.Reader for RSA blinding\n\t\treturn rsa.DecryptOAEP(sha1.New(), rand.Reader, ctx.privateKey, jek, []byte{})\n\tcase RSA_OAEP_256:\n\t\t// Use rand.Reader for RSA blinding\n\t\treturn rsa.DecryptOAEP(sha256.New(), rand.Reader, ctx.privateKey, jek, []byte{})\n\t}\n\n\treturn nil, ErrUnsupportedAlgorithm\n}\n\n// Sign the given payload\nfunc (ctx rsaDecrypterSigner) signPayload(payload []byte, alg SignatureAlgorithm) (Signature, error) {\n\tvar hash crypto.Hash\n\n\tswitch alg {\n\tcase RS256, PS256:\n\t\thash = crypto.SHA256\n\tcase RS384, PS384:\n\t\thash = crypto.SHA384\n\tcase RS512, PS512:\n\t\thash = crypto.SHA512\n\tdefault:\n\t\treturn Signature{}, ErrUnsupportedAlgorithm\n\t}\n\n\thasher := hash.New()\n\n\t// According to documentation, Write() on hash never fails\n\t_, _ = hasher.Write(payload)\n\thashed := hasher.Sum(nil)\n\n\tvar out []byte\n\tvar err error\n\n\tswitch alg {\n\tcase RS256, RS384, RS512:\n\t\tout, err = rsa.SignPKCS1v15(randReader, ctx.privateKey, hash, hashed)\n\tcase PS256, PS384, PS512:\n\t\tout, err = rsa.SignPSS(randReader, ctx.privateKey, hash, hashed, &rsa.PSSOptions{\n\t\t\tSaltLength: rsa.PSSSaltLengthAuto,\n\t\t})\n\t}\n\n\tif err != nil {\n\t\treturn Signature{}, err\n\t}\n\n\treturn Signature{\n\t\tSignature: out,\n\t\tprotected: &rawHeader{},\n\t}, nil\n}\n\n// Verify the given payload\nfunc (ctx rsaEncrypterVerifier) verifyPayload(payload []byte, signature []byte, alg SignatureAlgorithm) error {\n\tvar hash crypto.Hash\n\n\tswitch alg {\n\tcase RS256, PS256:\n\t\thash = crypto.SHA256\n\tcase RS384, PS384:\n\t\thash = crypto.SHA384\n\tcase RS512, PS512:\n\t\thash = crypto.SHA512\n\tdefault:\n\t\treturn ErrUnsupportedAlgorithm\n\t}\n\n\thasher := hash.New()\n\n\t// According to documentation, Write() on hash never fails\n\t_, _ = hasher.Write(payload)\n\thashed := hasher.Sum(nil)\n\n\tswitch alg {\n\tcase RS256, RS384, RS512:\n\t\treturn rsa.VerifyPKCS1v15(ctx.publicKey, hash, hashed, signature)\n\tcase PS256, PS384, PS512:\n\t\treturn rsa.VerifyPSS(ctx.publicKey, hash, hashed, signature, nil)\n\t}\n\n\treturn ErrUnsupportedAlgorithm\n}\n\n// Encrypt the given payload and update the object.\nfunc (ctx ecEncrypterVerifier) encryptKey(cek []byte, alg KeyAlgorithm) (recipientInfo, error) {\n\tswitch alg {\n\tcase ECDH_ES:\n\t\t// ECDH-ES mode doesn't wrap a key, the shared secret is used directly as the key.\n\t\treturn recipientInfo{\n\t\t\theader: &rawHeader{},\n\t\t}, nil\n\tcase ECDH_ES_A128KW, ECDH_ES_A192KW, ECDH_ES_A256KW:\n\tdefault:\n\t\treturn recipientInfo{}, ErrUnsupportedAlgorithm\n\t}\n\n\tgenerator := ecKeyGenerator{\n\t\talgID:     string(alg),\n\t\tpublicKey: ctx.publicKey,\n\t}\n\n\tswitch alg {\n\tcase ECDH_ES_A128KW:\n\t\tgenerator.size = 16\n\tcase ECDH_ES_A192KW:\n\t\tgenerator.size = 24\n\tcase ECDH_ES_A256KW:\n\t\tgenerator.size = 32\n\t}\n\n\tkek, header, err := generator.genKey()\n\tif err != nil {\n\t\treturn recipientInfo{}, err\n\t}\n\n\tblock, err := aes.NewCipher(kek)\n\tif err != nil {\n\t\treturn recipientInfo{}, err\n\t}\n\n\tjek, err := josecipher.KeyWrap(block, cek)\n\tif err != nil {\n\t\treturn recipientInfo{}, err\n\t}\n\n\treturn recipientInfo{\n\t\tencryptedKey: jek,\n\t\theader:       &header,\n\t}, nil\n}\n\n// Get key size for EC key generator\nfunc (ctx ecKeyGenerator) keySize() int {\n\treturn ctx.size\n}\n\n// Get a content encryption key for ECDH-ES\nfunc (ctx ecKeyGenerator) genKey() ([]byte, rawHeader, error) {\n\tpriv, err := ecdsa.GenerateKey(ctx.publicKey.Curve, randReader)\n\tif err != nil {\n\t\treturn nil, rawHeader{}, err\n\t}\n\n\tout := josecipher.DeriveECDHES(ctx.algID, []byte{}, []byte{}, priv, ctx.publicKey, ctx.size)\n\n\theaders := rawHeader{\n\t\tEpk: &JsonWebKey{\n\t\t\tKey: &priv.PublicKey,\n\t\t},\n\t}\n\n\treturn out, headers, nil\n}\n\n// Decrypt the given payload and return the content encryption key.\nfunc (ctx ecDecrypterSigner) decryptKey(headers rawHeader, recipient *recipientInfo, generator keyGenerator) ([]byte, error) {\n\tif headers.Epk == nil {\n\t\treturn nil, errors.New(\"square/go-jose: missing epk header\")\n\t}\n\n\tpublicKey, ok := headers.Epk.Key.(*ecdsa.PublicKey)\n\tif publicKey == nil || !ok {\n\t\treturn nil, errors.New(\"square/go-jose: invalid epk header\")\n\t}\n\n\tif !ctx.privateKey.Curve.IsOnCurve(publicKey.X, publicKey.Y) {\n\t\treturn nil, errors.New(\"square/go-jose: invalid public key in epk header\")\n\t}\n\n\tapuData := headers.Apu.bytes()\n\tapvData := headers.Apv.bytes()\n\n\tderiveKey := func(algID string, size int) []byte {\n\t\treturn josecipher.DeriveECDHES(algID, apuData, apvData, ctx.privateKey, publicKey, size)\n\t}\n\n\tvar keySize int\n\n\tswitch KeyAlgorithm(headers.Alg) {\n\tcase ECDH_ES:\n\t\t// ECDH-ES uses direct key agreement, no key unwrapping necessary.\n\t\treturn deriveKey(string(headers.Enc), generator.keySize()), nil\n\tcase ECDH_ES_A128KW:\n\t\tkeySize = 16\n\tcase ECDH_ES_A192KW:\n\t\tkeySize = 24\n\tcase ECDH_ES_A256KW:\n\t\tkeySize = 32\n\tdefault:\n\t\treturn nil, ErrUnsupportedAlgorithm\n\t}\n\n\tkey := deriveKey(headers.Alg, keySize)\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn josecipher.KeyUnwrap(block, recipient.encryptedKey)\n}\n\n// Sign the given payload\nfunc (ctx ecDecrypterSigner) signPayload(payload []byte, alg SignatureAlgorithm) (Signature, error) {\n\tvar expectedBitSize int\n\tvar hash crypto.Hash\n\n\tswitch alg {\n\tcase ES256:\n\t\texpectedBitSize = 256\n\t\thash = crypto.SHA256\n\tcase ES384:\n\t\texpectedBitSize = 384\n\t\thash = crypto.SHA384\n\tcase ES512:\n\t\texpectedBitSize = 521\n\t\thash = crypto.SHA512\n\t}\n\n\tcurveBits := ctx.privateKey.Curve.Params().BitSize\n\tif expectedBitSize != curveBits {\n\t\treturn Signature{}, fmt.Errorf(\"square/go-jose: expected %d bit key, got %d bits instead\", expectedBitSize, curveBits)\n\t}\n\n\thasher := hash.New()\n\n\t// According to documentation, Write() on hash never fails\n\t_, _ = hasher.Write(payload)\n\thashed := hasher.Sum(nil)\n\n\tr, s, err := ecdsa.Sign(randReader, ctx.privateKey, hashed)\n\tif err != nil {\n\t\treturn Signature{}, err\n\t}\n\n\tkeyBytes := curveBits / 8\n\tif curveBits%8 > 0 {\n\t\tkeyBytes += 1\n\t}\n\n\t// We serialize the outpus (r and s) into big-endian byte arrays and pad\n\t// them with zeros on the left to make sure the sizes work out. Both arrays\n\t// must be keyBytes long, and the output must be 2*keyBytes long.\n\trBytes := r.Bytes()\n\trBytesPadded := make([]byte, keyBytes)\n\tcopy(rBytesPadded[keyBytes-len(rBytes):], rBytes)\n\n\tsBytes := s.Bytes()\n\tsBytesPadded := make([]byte, keyBytes)\n\tcopy(sBytesPadded[keyBytes-len(sBytes):], sBytes)\n\n\tout := append(rBytesPadded, sBytesPadded...)\n\n\treturn Signature{\n\t\tSignature: out,\n\t\tprotected: &rawHeader{},\n\t}, nil\n}\n\n// Verify the given payload\nfunc (ctx ecEncrypterVerifier) verifyPayload(payload []byte, signature []byte, alg SignatureAlgorithm) error {\n\tvar keySize int\n\tvar hash crypto.Hash\n\n\tswitch alg {\n\tcase ES256:\n\t\tkeySize = 32\n\t\thash = crypto.SHA256\n\tcase ES384:\n\t\tkeySize = 48\n\t\thash = crypto.SHA384\n\tcase ES512:\n\t\tkeySize = 66\n\t\thash = crypto.SHA512\n\t}\n\n\tif len(signature) != 2*keySize {\n\t\treturn fmt.Errorf(\"square/go-jose: invalid signature size, have %d bytes, wanted %d\", len(signature), 2*keySize)\n\t}\n\n\thasher := hash.New()\n\n\t// According to documentation, Write() on hash never fails\n\t_, _ = hasher.Write(payload)\n\thashed := hasher.Sum(nil)\n\n\tr := big.NewInt(0).SetBytes(signature[:keySize])\n\ts := big.NewInt(0).SetBytes(signature[keySize:])\n\n\tmatch := ecdsa.Verify(ctx.publicKey, hashed, r, s)\n\tif !match {\n\t\treturn errors.New(\"square/go-jose: ecdsa signature failed to verify\")\n\t}\n\n\treturn nil\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"bytes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"errors\"\n\t\"io\"\n\t\"math/big\"\n\t\"testing\"\n)\n\nfunc TestVectorsRSA(t *testing.T) {\n\t// Sources:\n\t//   http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-rsa-cryptography-standard.htm\n\t//   ftp://ftp.rsa.com/pub/rsalabs/tmp/pkcs1v15crypt-vectors.txt\n\tpriv := &rsa.PrivateKey{\n\t\tPublicKey: rsa.PublicKey{\n\t\t\tN: fromHexInt(`\n\t\t\t\ta8b3b284af8eb50b387034a860f146c4919f318763cd6c5598c8\n\t\t\t\tae4811a1e0abc4c7e0b082d693a5e7fced675cf4668512772c0c\n\t\t\t\tbc64a742c6c630f533c8cc72f62ae833c40bf25842e984bb78bd\n\t\t\t\tbf97c0107d55bdb662f5c4e0fab9845cb5148ef7392dd3aaff93\n\t\t\t\tae1e6b667bb3d4247616d4f5ba10d4cfd226de88d39f16fb`),\n\t\t\tE: 65537,\n\t\t},\n\t\tD: fromHexInt(`\n\t\t\t\t53339cfdb79fc8466a655c7316aca85c55fd8f6dd898fdaf1195\n\t\t\t\t17ef4f52e8fd8e258df93fee180fa0e4ab29693cd83b152a553d\n\t\t\t\t4ac4d1812b8b9fa5af0e7f55fe7304df41570926f3311f15c4d6\n\t\t\t\t5a732c483116ee3d3d2d0af3549ad9bf7cbfb78ad884f84d5beb\n\t\t\t\t04724dc7369b31def37d0cf539e9cfcdd3de653729ead5d1`),\n\t\tPrimes: []*big.Int{\n\t\t\tfromHexInt(`\n\t\t\t\td32737e7267ffe1341b2d5c0d150a81b586fb3132bed2f8d5262\n\t\t\t\t864a9cb9f30af38be448598d413a172efb802c21acf1c11c520c\n\t\t\t\t2f26a471dcad212eac7ca39d`),\n\t\t\tfromHexInt(`\n\t\t\t\tcc8853d1d54da630fac004f471f281c7b8982d8224a490edbeb3\n\t\t\t\t3d3e3d5cc93c4765703d1dd791642f1f116a0dd852be2419b2af\n\t\t\t\t72bfe9a030e860b0288b5d77`),\n\t\t},\n\t}\n\n\tinput := fromHexBytes(\n\t\t\"6628194e12073db03ba94cda9ef9532397d50dba79b987004afefe34\")\n\n\texpectedPKCS := fromHexBytes(`\n\t\t50b4c14136bd198c2f3c3ed243fce036e168d56517984a263cd66492b808\n\t\t04f169d210f2b9bdfb48b12f9ea05009c77da257cc600ccefe3a6283789d\n\t\t8ea0e607ac58e2690ec4ebc10146e8cbaa5ed4d5cce6fe7b0ff9efc1eabb\n\t\t564dbf498285f449ee61dd7b42ee5b5892cb90601f30cda07bf26489310b\n\t\tcd23b528ceab3c31`)\n\n\texpectedOAEP := fromHexBytes(`\n\t\t354fe67b4a126d5d35fe36c777791a3f7ba13def484e2d3908aff722fad4\n\t\t68fb21696de95d0be911c2d3174f8afcc201035f7b6d8e69402de5451618\n\t\tc21a535fa9d7bfc5b8dd9fc243f8cf927db31322d6e881eaa91a996170e6\n\t\t57a05a266426d98c88003f8477c1227094a0d9fa1e8c4024309ce1ecccb5\n\t\t210035d47ac72e8a`)\n\n\t// Mock random reader\n\trandReader = bytes.NewReader(fromHexBytes(`\n\t\t017341ae3875d5f87101f8cc4fa9b9bc156bb04628fccdb2f4f11e905bd3\n\t\ta155d376f593bd7304210874eba08a5e22bcccb4c9d3882a93a54db022f5\n\t\t03d16338b6b7ce16dc7f4bbf9a96b59772d6606e9747c7649bf9e083db98\n\t\t1884a954ab3c6f18b776ea21069d69776a33e96bad48e1dda0a5ef`))\n\tdefer resetRandReader()\n\n\t// RSA-PKCS1v1.5 encrypt\n\tenc := new(rsaEncrypterVerifier)\n\tenc.publicKey = &priv.PublicKey\n\tencryptedPKCS, err := enc.encrypt(input, RSA1_5)\n\tif err != nil {\n\t\tt.Error(\"Encryption failed:\", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(encryptedPKCS, expectedPKCS) != 0 {\n\t\tt.Error(\"Output does not match expected value (PKCS1v1.5)\")\n\t}\n\n\t// RSA-OAEP encrypt\n\tencryptedOAEP, err := enc.encrypt(input, RSA_OAEP)\n\tif err != nil {\n\t\tt.Error(\"Encryption failed:\", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(encryptedOAEP, expectedOAEP) != 0 {\n\t\tt.Error(\"Output does not match expected value (OAEP)\")\n\t}\n\n\t// Need fake cipher for PKCS1v1.5 decrypt\n\tresetRandReader()\n\taes := newAESGCM(len(input))\n\n\tkeygen := randomKeyGenerator{\n\t\tsize: aes.keySize(),\n\t}\n\n\t// RSA-PKCS1v1.5 decrypt\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = priv\n\tdecryptedPKCS, err := dec.decrypt(encryptedPKCS, RSA1_5, keygen)\n\tif err != nil {\n\t\tt.Error(\"Decryption failed:\", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(input, decryptedPKCS) != 0 {\n\t\tt.Error(\"Output does not match expected value (PKCS1v1.5)\")\n\t}\n\n\t// RSA-OAEP decrypt\n\tdecryptedOAEP, err := dec.decrypt(encryptedOAEP, RSA_OAEP, keygen)\n\tif err != nil {\n\t\tt.Error(\"decryption failed:\", err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(input, decryptedOAEP) != 0 {\n\t\tt.Error(\"output does not match expected value (OAEP)\")\n\t}\n}\n\nfunc TestInvalidAlgorithmsRSA(t *testing.T) {\n\t_, err := newRSARecipient(\"XYZ\", nil)\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\t_, err = newRSASigner(\"XYZ\", nil)\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\tenc := new(rsaEncrypterVerifier)\n\tenc.publicKey = &rsaTestKey.PublicKey\n\t_, err = enc.encryptKey([]byte{}, \"XYZ\")\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\terr = enc.verifyPayload([]byte{}, []byte{}, \"XYZ\")\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = rsaTestKey\n\t_, err = dec.decrypt(make([]byte, 256), \"XYZ\", randomKeyGenerator{size: 16})\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\t_, err = dec.signPayload([]byte{}, \"XYZ\")\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n}\n\ntype failingKeyGenerator struct{}\n\nfunc (ctx failingKeyGenerator) keySize() int {\n\treturn 0\n}\n\nfunc (ctx failingKeyGenerator) genKey() ([]byte, rawHeader, error) {\n\treturn nil, rawHeader{}, errors.New(\"failed to generate key\")\n}\n\nfunc TestPKCSKeyGeneratorFailure(t *testing.T) {\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = rsaTestKey\n\tgenerator := failingKeyGenerator{}\n\t_, err := dec.decrypt(make([]byte, 256), RSA1_5, generator)\n\tif err != ErrCryptoFailure {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n}\n\nfunc TestInvalidAlgorithmsEC(t *testing.T) {\n\t_, err := newECDHRecipient(\"XYZ\", nil)\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\t_, err = newECDSASigner(\"XYZ\", nil)\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n\n\tenc := new(ecEncrypterVerifier)\n\tenc.publicKey = &ecTestKey256.PublicKey\n\t_, err = enc.encryptKey([]byte{}, \"XYZ\")\n\tif err != ErrUnsupportedAlgorithm {\n\t\tt.Error(\"should return error on invalid algorithm\")\n\t}\n}\n\nfunc TestInvalidECKeyGen(t *testing.T) {\n\tgen := ecKeyGenerator{\n\t\tsize:      16,\n\t\talgID:     \"A128GCM\",\n\t\tpublicKey: &ecTestKey256.PublicKey,\n\t}\n\n\tif gen.keySize() != 16 {\n\t\tt.Error(\"ec key generator reported incorrect key size\")\n\t}\n\n\t_, _, err := gen.genKey()\n\tif err != nil {\n\t\tt.Error(\"ec key generator failed to generate key\", err)\n\t}\n}\n\nfunc TestInvalidECDecrypt(t *testing.T) {\n\tdec := ecDecrypterSigner{\n\t\tprivateKey: ecTestKey256,\n\t}\n\n\tgenerator := randomKeyGenerator{size: 16}\n\n\t// Missing epk header\n\theaders := rawHeader{\n\t\tAlg: string(ECDH_ES),\n\t}\n\n\t_, err := dec.decryptKey(headers, nil, generator)\n\tif err == nil {\n\t\tt.Error(\"ec decrypter accepted object with missing epk header\")\n\t}\n\n\t// Invalid epk header\n\theaders.Epk = &JsonWebKey{}\n\n\t_, err = dec.decryptKey(headers, nil, generator)\n\tif err == nil {\n\t\tt.Error(\"ec decrypter accepted object with invalid epk header\")\n\t}\n}\n\nfunc TestDecryptWithIncorrectSize(t *testing.T) {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = priv\n\taes := newAESGCM(16)\n\n\tkeygen := randomKeyGenerator{\n\t\tsize: aes.keySize(),\n\t}\n\n\tpayload := make([]byte, 254)\n\t_, err = dec.decrypt(payload, RSA1_5, keygen)\n\tif err == nil {\n\t\tt.Error(\"Invalid payload size should return error\")\n\t}\n\n\tpayload = make([]byte, 257)\n\t_, err = dec.decrypt(payload, RSA1_5, keygen)\n\tif err == nil {\n\t\tt.Error(\"Invalid payload size should return error\")\n\t}\n}\n\nfunc TestPKCSDecryptNeverFails(t *testing.T) {\n\t// We don't want RSA-PKCS1 v1.5 decryption to ever fail, in order to prevent\n\t// side-channel timing attacks (Bleichenbacher attack in particular).\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = priv\n\taes := newAESGCM(16)\n\n\tkeygen := randomKeyGenerator{\n\t\tsize: aes.keySize(),\n\t}\n\n\tfor i := 1; i < 50; i++ {\n\t\tpayload := make([]byte, 256)\n\t\t_, err := io.ReadFull(rand.Reader, payload)\n\t\tif err != nil {\n\t\t\tt.Error(\"Unable to get random data:\", err)\n\t\t\treturn\n\t\t}\n\t\t_, err = dec.decrypt(payload, RSA1_5, keygen)\n\t\tif err != nil {\n\t\t\tt.Error(\"PKCS1v1.5 decrypt should never fail:\", err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc BenchmarkPKCSDecryptWithValidPayloads(b *testing.B) {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tenc := new(rsaEncrypterVerifier)\n\tenc.publicKey = &priv.PublicKey\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = priv\n\taes := newAESGCM(32)\n\n\tb.StopTimer()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tplaintext := make([]byte, 32)\n\t\t_, err = io.ReadFull(rand.Reader, plaintext)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tciphertext, err := enc.encrypt(plaintext, RSA1_5)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tkeygen := randomKeyGenerator{\n\t\t\tsize: aes.keySize(),\n\t\t}\n\n\t\tb.StartTimer()\n\t\t_, err = dec.decrypt(ciphertext, RSA1_5, keygen)\n\t\tb.StopTimer()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkPKCSDecryptWithInvalidPayloads(b *testing.B) {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tenc := new(rsaEncrypterVerifier)\n\tenc.publicKey = &priv.PublicKey\n\tdec := new(rsaDecrypterSigner)\n\tdec.privateKey = priv\n\taes := newAESGCM(16)\n\n\tkeygen := randomKeyGenerator{\n\t\tsize: aes.keySize(),\n\t}\n\n\tb.StopTimer()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tplaintext := make([]byte, 16)\n\t\t_, err = io.ReadFull(rand.Reader, plaintext)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tciphertext, err := enc.encrypt(plaintext, RSA1_5)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\t// Do some simple scrambling\n\t\tciphertext[128] ^= 0xFF\n\n\t\tb.StartTimer()\n\t\t_, err = dec.decrypt(ciphertext, RSA1_5, keygen)\n\t\tb.StopTimer()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc TestInvalidEllipticCurve(t *testing.T) {\n\tsigner256 := ecDecrypterSigner{privateKey: ecTestKey256}\n\tsigner384 := ecDecrypterSigner{privateKey: ecTestKey384}\n\tsigner521 := ecDecrypterSigner{privateKey: ecTestKey521}\n\n\t_, err := signer256.signPayload([]byte{}, ES384)\n\tif err == nil {\n\t\tt.Error(\"should not generate ES384 signature with P-256 key\")\n\t}\n\t_, err = signer256.signPayload([]byte{}, ES512)\n\tif err == nil {\n\t\tt.Error(\"should not generate ES512 signature with P-256 key\")\n\t}\n\t_, err = signer384.signPayload([]byte{}, ES256)\n\tif err == nil {\n\t\tt.Error(\"should not generate ES256 signature with P-384 key\")\n\t}\n\t_, err = signer384.signPayload([]byte{}, ES512)\n\tif err == nil {\n\t\tt.Error(\"should not generate ES512 signature with P-384 key\")\n\t}\n\t_, err = signer521.signPayload([]byte{}, ES256)\n\tif err == nil {\n\t\tt.Error(\"should not generate ES256 signature with P-521 key\")\n\t}\n\t_, err = signer521.signPayload([]byte{}, ES384)\n\tif err == nil {\n\t\tt.Error(\"should not generate ES384 signature with P-521 key\")\n\t}\n}\n\nfunc TestInvalidECPublicKey(t *testing.T) {\n\t// Invalid key\n\tinvalid := &ecdsa.PrivateKey{\n\t\tPublicKey: ecdsa.PublicKey{\n\t\t\tCurve: elliptic.P256(),\n\t\t\tX:     fromBase64Int(\"MTEx\"),\n\t\t\tY:     fromBase64Int(\"MTEx\"),\n\t\t},\n\t\tD: fromBase64Int(\"0_NxaRPUMQoAJt50Gz8YiTr8gRTwyEaCumd-MToTmIo=\"),\n\t}\n\n\theaders := rawHeader{\n\t\tAlg: string(ECDH_ES),\n\t\tEpk: &JsonWebKey{\n\t\t\tKey: &invalid.PublicKey,\n\t\t},\n\t}\n\n\tdec := ecDecrypterSigner{\n\t\tprivateKey: ecTestKey256,\n\t}\n\n\t_, err := dec.decryptKey(headers, nil, randomKeyGenerator{size: 16})\n\tif err == nil {\n\t\tt.Fatal(\"decrypter accepted JWS with invalid ECDH public key\")\n\t}\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage josecipher\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"encoding/binary\"\n)\n\n// DeriveECDHES derives a shared encryption key using ECDH/ConcatKDF as described in JWE/JWA.\nfunc DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, pub *ecdsa.PublicKey, size int) []byte {\n\t// algId, partyUInfo, partyVInfo inputs must be prefixed with the length\n\talgID := lengthPrefixed([]byte(alg))\n\tptyUInfo := lengthPrefixed(apuData)\n\tptyVInfo := lengthPrefixed(apvData)\n\n\t// suppPubInfo is the encoded length of the output size in bits\n\tsupPubInfo := make([]byte, 4)\n\tbinary.BigEndian.PutUint32(supPubInfo, uint32(size)*8)\n\n\tif !priv.PublicKey.Curve.IsOnCurve(pub.X, pub.Y) {\n\t\tpanic(\"public key not on same curve as private key\")\n\t}\n\n\tz, _ := priv.PublicKey.Curve.ScalarMult(pub.X, pub.Y, priv.D.Bytes())\n\treader := NewConcatKDF(crypto.SHA256, z.Bytes(), algID, ptyUInfo, ptyVInfo, supPubInfo, []byte{})\n\n\tkey := make([]byte, size)\n\n\t// Read on the KDF will never fail\n\t_, _ = reader.Read(key)\n\treturn key\n}\n\nfunc lengthPrefixed(data []byte) []byte {\n\tout := make([]byte, len(data)+4)\n\tbinary.BigEndian.PutUint32(out, uint32(len(data)))\n\tcopy(out[4:], data)\n\treturn out\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage josecipher\n\nimport (\n\t\"bytes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"encoding/base64\"\n\t\"math/big\"\n\t\"testing\"\n)\n\n// Example keys from JWA, Appendix C\nvar aliceKey = &ecdsa.PrivateKey{\n\tPublicKey: ecdsa.PublicKey{\n\t\tCurve: elliptic.P256(),\n\t\tX:     fromBase64Int(\"gI0GAILBdu7T53akrFmMyGcsF3n5dO7MmwNBHKW5SV0=\"),\n\t\tY:     fromBase64Int(\"SLW_xSffzlPWrHEVI30DHM_4egVwt3NQqeUD7nMFpps=\"),\n\t},\n\tD: fromBase64Int(\"0_NxaRPUMQoAJt50Gz8YiTr8gRTwyEaCumd-MToTmIo=\"),\n}\n\nvar bobKey = &ecdsa.PrivateKey{\n\tPublicKey: ecdsa.PublicKey{\n\t\tCurve: elliptic.P256(),\n\t\tX:     fromBase64Int(\"weNJy2HscCSM6AEDTDg04biOvhFhyyWvOHQfeF_PxMQ=\"),\n\t\tY:     fromBase64Int(\"e8lnCO-AlStT-NJVX-crhB7QRYhiix03illJOVAOyck=\"),\n\t},\n\tD: fromBase64Int(\"VEmDZpDXXK8p8N0Cndsxs924q6nS1RXFASRl6BfUqdw=\"),\n}\n\n// Build big int from base64-encoded string. Strips whitespace (for testing).\nfunc fromBase64Int(data string) *big.Int {\n\tval, err := base64.URLEncoding.DecodeString(data)\n\tif err != nil {\n\t\tpanic(\"Invalid test data\")\n\t}\n\treturn new(big.Int).SetBytes(val)\n}\n\nfunc TestVectorECDHES(t *testing.T) {\n\tapuData := []byte(\"Alice\")\n\tapvData := []byte(\"Bob\")\n\n\texpected := []byte{\n\t\t86, 170, 141, 234, 248, 35, 109, 32, 92, 34, 40, 205, 113, 167, 16, 26}\n\n\toutput := DeriveECDHES(\"A128GCM\", apuData, apvData, bobKey, &aliceKey.PublicKey, 16)\n\n\tif bytes.Compare(output, expected) != 0 {\n\t\tt.Error(\"output did not match what we expect, got\", output, \"wanted\", expected)\n\t}\n}\n\nfunc TestInvalidECPublicKey(t *testing.T) {\n\tdefer func() { recover() }()\n\n\t// Invalid key\n\tinvalid := &ecdsa.PrivateKey{\n\t\tPublicKey: ecdsa.PublicKey{\n\t\t\tCurve: elliptic.P256(),\n\t\t\tX:     fromBase64Int(\"MTEx\"),\n\t\t\tY:     fromBase64Int(\"MTEx\"),\n\t\t},\n\t\tD: fromBase64Int(\"0_NxaRPUMQoAJt50Gz8YiTr8gRTwyEaCumd-MToTmIo=\"),\n\t}\n\n\tDeriveECDHES(\"A128GCM\", []byte{}, []byte{}, bobKey, &invalid.PublicKey, 16)\n\tt.Fatal(\"should panic if public key was invalid\")\n}\n\nfunc BenchmarkECDHES_128(b *testing.B) {\n\tapuData := []byte(\"APU\")\n\tapvData := []byte(\"APV\")\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tDeriveECDHES(\"ID\", apuData, apvData, bobKey, &aliceKey.PublicKey, 16)\n\t}\n}\n\nfunc BenchmarkECDHES_192(b *testing.B) {\n\tapuData := []byte(\"APU\")\n\tapvData := []byte(\"APV\")\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tDeriveECDHES(\"ID\", apuData, apvData, bobKey, &aliceKey.PublicKey, 24)\n\t}\n}\n\nfunc BenchmarkECDHES_256(b *testing.B) {\n\tapuData := []byte(\"APU\")\n\tapvData := []byte(\"APV\")\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tDeriveECDHES(\"ID\", apuData, apvData, bobKey, &aliceKey.PublicKey, 32)\n\t}\n}\n", "/*-\n * Copyright 2014 Square Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage jose\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/square/go-jose/json\"\n)\n\n// rawJsonWebKey represents a public or private key in JWK format, used for parsing/serializing.\ntype rawJsonWebKey struct {\n\tUse string      `json:\"use,omitempty\"`\n\tKty string      `json:\"kty,omitempty\"`\n\tKid string      `json:\"kid,omitempty\"`\n\tCrv string      `json:\"crv,omitempty\"`\n\tAlg string      `json:\"alg,omitempty\"`\n\tK   *byteBuffer `json:\"k,omitempty\"`\n\tX   *byteBuffer `json:\"x,omitempty\"`\n\tY   *byteBuffer `json:\"y,omitempty\"`\n\tN   *byteBuffer `json:\"n,omitempty\"`\n\tE   *byteBuffer `json:\"e,omitempty\"`\n\t// -- Following fields are only used for private keys --\n\t// RSA uses D, P and Q, while ECDSA uses only D. Fields Dp, Dq, and Qi are\n\t// completely optional. Therefore for RSA/ECDSA, D != nil is a contract that\n\t// we have a private key whereas D == nil means we have only a public key.\n\tD  *byteBuffer `json:\"d,omitempty\"`\n\tP  *byteBuffer `json:\"p,omitempty\"`\n\tQ  *byteBuffer `json:\"q,omitempty\"`\n\tDp *byteBuffer `json:\"dp,omitempty\"`\n\tDq *byteBuffer `json:\"dq,omitempty\"`\n\tQi *byteBuffer `json:\"qi,omitempty\"`\n\t// Certificates\n\tX5c []string `json:\"x5c,omitempty\"`\n}\n\n// JsonWebKey represents a public or private key in JWK format.\ntype JsonWebKey struct {\n\tKey          interface{}\n\tCertificates []*x509.Certificate\n\tKeyID        string\n\tAlgorithm    string\n\tUse          string\n}\n\n// MarshalJSON serializes the given key to its JSON representation.\nfunc (k JsonWebKey) MarshalJSON() ([]byte, error) {\n\tvar raw *rawJsonWebKey\n\tvar err error\n\n\tswitch key := k.Key.(type) {\n\tcase *ecdsa.PublicKey:\n\t\traw, err = fromEcPublicKey(key)\n\tcase *rsa.PublicKey:\n\t\traw = fromRsaPublicKey(key)\n\tcase *ecdsa.PrivateKey:\n\t\traw, err = fromEcPrivateKey(key)\n\tcase *rsa.PrivateKey:\n\t\traw, err = fromRsaPrivateKey(key)\n\tcase []byte:\n\t\traw, err = fromSymmetricKey(key)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"square/go-jose: unknown key type '%s'\", reflect.TypeOf(key))\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\traw.Kid = k.KeyID\n\traw.Alg = k.Algorithm\n\traw.Use = k.Use\n\n\tfor _, cert := range k.Certificates {\n\t\traw.X5c = append(raw.X5c, base64.StdEncoding.EncodeToString(cert.Raw))\n\t}\n\n\treturn json.Marshal(raw)\n}\n\n// UnmarshalJSON reads a key from its JSON representation.\nfunc (k *JsonWebKey) UnmarshalJSON(data []byte) (err error) {\n\tvar raw rawJsonWebKey\n\terr = json.Unmarshal(data, &raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar key interface{}\n\tswitch raw.Kty {\n\tcase \"EC\":\n\t\tif raw.D != nil {\n\t\t\tkey, err = raw.ecPrivateKey()\n\t\t} else {\n\t\t\tkey, err = raw.ecPublicKey()\n\t\t}\n\tcase \"RSA\":\n\t\tif raw.D != nil {\n\t\t\tkey, err = raw.rsaPrivateKey()\n\t\t} else {\n\t\t\tkey, err = raw.rsaPublicKey()\n\t\t}\n\tcase \"oct\":\n\t\tkey, err = raw.symmetricKey()\n\tdefault:\n\t\terr = fmt.Errorf(\"square/go-jose: unknown json web key type '%s'\", raw.Kty)\n\t}\n\n\tif err == nil {\n\t\t*k = JsonWebKey{Key: key, KeyID: raw.Kid, Algorithm: raw.Alg, Use: raw.Use}\n\t}\n\n\tk.Certificates = make([]*x509.Certificate, len(raw.X5c))\n\tfor i, cert := range raw.X5c {\n\t\traw, err := base64.StdEncoding.DecodeString(cert)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tk.Certificates[i], err = x509.ParseCertificate(raw)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn\n}\n\n// JsonWebKeySet represents a JWK Set object.\ntype JsonWebKeySet struct {\n\tKeys []JsonWebKey `json:\"keys\"`\n}\n\n// Key convenience method returns keys by key ID. Specification states\n// that a JWK Set \"SHOULD\" use distinct key IDs, but allows for some\n// cases where they are not distinct. Hence method returns a slice\n// of JsonWebKeys.\nfunc (s *JsonWebKeySet) Key(kid string) []JsonWebKey {\n\tvar keys []JsonWebKey\n\tfor _, key := range s.Keys {\n\t\tif key.KeyID == kid {\n\t\t\tkeys = append(keys, key)\n\t\t}\n\t}\n\n\treturn keys\n}\n\nconst rsaThumbprintTemplate = `{\"e\":\"%s\",\"kty\":\"RSA\",\"n\":\"%s\"}`\nconst ecThumbprintTemplate = `{\"crv\":\"%s\",\"kty\":\"EC\",\"x\":\"%s\",\"y\":\"%s\"}`\n\nfunc ecThumbprintInput(curve elliptic.Curve, x, y *big.Int) (string, error) {\n\tcoordLength := curveSize(curve)\n\tcrv, err := curveName(curve)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn fmt.Sprintf(ecThumbprintTemplate, crv,\n\t\tnewFixedSizeBuffer(x.Bytes(), coordLength).base64(),\n\t\tnewFixedSizeBuffer(y.Bytes(), coordLength).base64()), nil\n}\n\nfunc rsaThumbprintInput(n *big.Int, e int) (string, error) {\n\treturn fmt.Sprintf(rsaThumbprintTemplate,\n\t\tnewBufferFromInt(uint64(e)).base64(),\n\t\tnewBuffer(n.Bytes()).base64()), nil\n}\n\n// Thumbprint computes the JWK Thumbprint of a key using the\n// indicated hash algorithm.\nfunc (k *JsonWebKey) Thumbprint(hash crypto.Hash) ([]byte, error) {\n\tvar input string\n\tvar err error\n\tswitch key := k.Key.(type) {\n\tcase *ecdsa.PublicKey:\n\t\tinput, err = ecThumbprintInput(key.Curve, key.X, key.Y)\n\tcase *ecdsa.PrivateKey:\n\t\tinput, err = ecThumbprintInput(key.Curve, key.X, key.Y)\n\tcase *rsa.PublicKey:\n\t\tinput, err = rsaThumbprintInput(key.N, key.E)\n\tcase *rsa.PrivateKey:\n\t\tinput, err = rsaThumbprintInput(key.N, key.E)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"square/go-jose: unknown key type '%s'\", reflect.TypeOf(key))\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\th := hash.New()\n\th.Write([]byte(input))\n\treturn h.Sum(nil), nil\n}\n\n// Valid checks that the key contains the expected parameters\nfunc (k *JsonWebKey) Valid() bool {\n\tif k.Key == nil {\n\t\treturn false\n\t}\n\tswitch key := k.Key.(type) {\n\tcase *ecdsa.PublicKey:\n\t\tif key.Curve == nil || key.X == nil || key.Y == nil {\n\t\t\treturn false\n\t\t}\n\tcase *ecdsa.PrivateKey:\n\t\tif key.Curve == nil || key.X == nil || key.Y == nil || key.D == nil {\n\t\t\treturn false\n\t\t}\n\tcase *rsa.PublicKey:\n\t\tif key.N == nil || key.E == 0 {\n\t\t\treturn false\n\t\t}\n\tcase *rsa.PrivateKey:\n\t\tif key.N == nil || key.E == 0 || key.D == nil || len(key.Primes) < 2 {\n\t\t\treturn false\n\t\t}\n\tdefault:\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (key rawJsonWebKey) rsaPublicKey() (*rsa.PublicKey, error) {\n\tif key.N == nil || key.E == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid RSA key, missing n/e values\")\n\t}\n\n\treturn &rsa.PublicKey{\n\t\tN: key.N.bigInt(),\n\t\tE: key.E.toInt(),\n\t}, nil\n}\n\nfunc fromRsaPublicKey(pub *rsa.PublicKey) *rawJsonWebKey {\n\treturn &rawJsonWebKey{\n\t\tKty: \"RSA\",\n\t\tN:   newBuffer(pub.N.Bytes()),\n\t\tE:   newBufferFromInt(uint64(pub.E)),\n\t}\n}\n\nfunc (key rawJsonWebKey) ecPublicKey() (*ecdsa.PublicKey, error) {\n\tvar curve elliptic.Curve\n\tswitch key.Crv {\n\tcase \"P-256\":\n\t\tcurve = elliptic.P256()\n\tcase \"P-384\":\n\t\tcurve = elliptic.P384()\n\tcase \"P-521\":\n\t\tcurve = elliptic.P521()\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"square/go-jose: unsupported elliptic curve '%s'\", key.Crv)\n\t}\n\n\tif key.X == nil || key.Y == nil {\n\t\treturn nil, errors.New(\"square/go-jose: invalid EC key, missing x/y values\")\n\t}\n\n\tx := key.X.bigInt()\n\ty := key.Y.bigInt()\n\n\tif !curve.IsOnCurve(x, y) {\n\t\treturn nil, errors.New(\"square/go-jose: invalid EC key, X/Y are not on declared curve\")\n\t}\n\n\treturn &ecdsa.PublicKey{\n\t\tCurve: curve,\n\t\tX:     x,\n\t\tY:     y,\n\t}, nil\n}\n\nfunc fromEcPublicKey(pub *ecdsa.PublicKey) (*rawJsonWebKey, error) {\n\tif pub == nil || pub.X == nil || pub.Y == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid EC key (nil, or X/Y missing)\")\n\t}\n\n\tname, err := curveName(pub.Curve)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsize := curveSize(pub.Curve)\n\n\txBytes := pub.X.Bytes()\n\tyBytes := pub.Y.Bytes()\n\n\tif len(xBytes) > size || len(yBytes) > size {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid EC key (X/Y too large)\")\n\t}\n\n\tkey := &rawJsonWebKey{\n\t\tKty: \"EC\",\n\t\tCrv: name,\n\t\tX:   newFixedSizeBuffer(xBytes, size),\n\t\tY:   newFixedSizeBuffer(yBytes, size),\n\t}\n\n\treturn key, nil\n}\n\nfunc (key rawJsonWebKey) rsaPrivateKey() (*rsa.PrivateKey, error) {\n\tvar missing []string\n\tswitch {\n\tcase key.N == nil:\n\t\tmissing = append(missing, \"N\")\n\tcase key.E == nil:\n\t\tmissing = append(missing, \"E\")\n\tcase key.D == nil:\n\t\tmissing = append(missing, \"D\")\n\tcase key.P == nil:\n\t\tmissing = append(missing, \"P\")\n\tcase key.Q == nil:\n\t\tmissing = append(missing, \"Q\")\n\t}\n\n\tif len(missing) > 0 {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid RSA private key, missing %s value(s)\", strings.Join(missing, \", \"))\n\t}\n\n\trv := &rsa.PrivateKey{\n\t\tPublicKey: rsa.PublicKey{\n\t\t\tN: key.N.bigInt(),\n\t\t\tE: key.E.toInt(),\n\t\t},\n\t\tD: key.D.bigInt(),\n\t\tPrimes: []*big.Int{\n\t\t\tkey.P.bigInt(),\n\t\t\tkey.Q.bigInt(),\n\t\t},\n\t}\n\n\tif key.Dp != nil {\n\t\trv.Precomputed.Dp = key.Dp.bigInt()\n\t}\n\tif key.Dq != nil {\n\t\trv.Precomputed.Dq = key.Dq.bigInt()\n\t}\n\tif key.Qi != nil {\n\t\trv.Precomputed.Qinv = key.Qi.bigInt()\n\t}\n\n\terr := rv.Validate()\n\treturn rv, err\n}\n\nfunc fromRsaPrivateKey(rsa *rsa.PrivateKey) (*rawJsonWebKey, error) {\n\tif len(rsa.Primes) != 2 {\n\t\treturn nil, ErrUnsupportedKeyType\n\t}\n\n\traw := fromRsaPublicKey(&rsa.PublicKey)\n\n\traw.D = newBuffer(rsa.D.Bytes())\n\traw.P = newBuffer(rsa.Primes[0].Bytes())\n\traw.Q = newBuffer(rsa.Primes[1].Bytes())\n\n\treturn raw, nil\n}\n\nfunc (key rawJsonWebKey) ecPrivateKey() (*ecdsa.PrivateKey, error) {\n\tvar curve elliptic.Curve\n\tswitch key.Crv {\n\tcase \"P-256\":\n\t\tcurve = elliptic.P256()\n\tcase \"P-384\":\n\t\tcurve = elliptic.P384()\n\tcase \"P-521\":\n\t\tcurve = elliptic.P521()\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"square/go-jose: unsupported elliptic curve '%s'\", key.Crv)\n\t}\n\n\tif key.X == nil || key.Y == nil || key.D == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid EC private key, missing x/y/d values\")\n\t}\n\n\treturn &ecdsa.PrivateKey{\n\t\tPublicKey: ecdsa.PublicKey{\n\t\t\tCurve: curve,\n\t\t\tX:     key.X.bigInt(),\n\t\t\tY:     key.Y.bigInt(),\n\t\t},\n\t\tD: key.D.bigInt(),\n\t}, nil\n}\n\nfunc fromEcPrivateKey(ec *ecdsa.PrivateKey) (*rawJsonWebKey, error) {\n\traw, err := fromEcPublicKey(&ec.PublicKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif ec.D == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid EC private key\")\n\t}\n\n\traw.D = newBuffer(ec.D.Bytes())\n\n\treturn raw, nil\n}\n\nfunc fromSymmetricKey(key []byte) (*rawJsonWebKey, error) {\n\treturn &rawJsonWebKey{\n\t\tKty: \"oct\",\n\t\tK:   newBuffer(key),\n\t}, nil\n}\n\nfunc (key rawJsonWebKey) symmetricKey() ([]byte, error) {\n\tif key.K == nil {\n\t\treturn nil, fmt.Errorf(\"square/go-jose: invalid OCT (symmetric) key, missing k value\")\n\t}\n\treturn key.K.bytes(), nil\n}\n"], "filenames": ["asymmetric.go", "asymmetric_test.go", "cipher/ecdh_es.go", "cipher/ecdh_es_test.go", "jwk.go"], "buggy_code_start_loc": [372, 20, 35, 69, 25], "buggy_code_end_loc": [372, 431, 35, 69, 287], "fixing_code_start_loc": [373, 21, 36, 70, 26], "fixing_code_end_loc": [377, 462, 40, 87, 295], "type": "CWE-326", "message": "go-jose before 1.0.4 suffers from an invalid curve attack for the ECDH-ES algorithm. When deriving a shared key using ECDH-ES for an encrypted message, go-jose neglected to check that the received public key on a message is on the same curve as the static private key of the receiver, thus making it vulnerable to an invalid curve attack.", "other": {"cve": {"id": "CVE-2016-9121", "sourceIdentifier": "support@hackerone.com", "published": "2017-03-28T02:59:00.213", "lastModified": "2017-03-29T17:39:46.290", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "go-jose before 1.0.4 suffers from an invalid curve attack for the ECDH-ES algorithm. When deriving a shared key using ECDH-ES for an encrypted message, go-jose neglected to check that the received public key on a message is on the same curve as the static private key of the receiver, thus making it vulnerable to an invalid curve attack."}, {"lang": "es", "value": "go-jose en versiones anteriores a 1.0.4 sufre de un ataque de curva no v\u00e1lida para el algoritmo ECDH-ES. Al derivar una clave compartida usando ECDH-ES para un mensaje encriptado, go-jose descuidado para comprobar que la clave p\u00fablica recibida en un mensaje est\u00e1 en la misma curva que la clave privada est\u00e1tica del receptor, haci\u00e9ndola vulnerable a una curva no v\u00e1lida ataque."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-326"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:go-jose_project:go-jose:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.3", "matchCriteriaId": "461700A0-1ABE-4A30-9C79-80C835D8B62E"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/11/03/1", "source": "support@hackerone.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/square/go-jose/commit/c7581939a3656bb65e89d64da0a52364a33d2507", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/164590", "source": "support@hackerone.com", "tags": ["Permissions Required"]}]}, "github_commit_url": "https://github.com/square/go-jose/commit/c7581939a3656bb65e89d64da0a52364a33d2507"}}