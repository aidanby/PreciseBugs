{"buggy_code": ["package file\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n)\n\n// Handler represents an HTTP API handler for managing static files.\ntype Handler struct {\n\thttp.Handler\n}\n\n// NewHandler creates a handler to serve static files.\nfunc NewHandler(assetPublicPath string) *Handler {\n\th := &Handler{\n\t\tHandler: http.FileServer(http.Dir(assetPublicPath)),\n\t}\n\treturn h\n}\n\nfunc isHTML(acceptContent []string) bool {\n\tfor _, accept := range acceptContent {\n\t\tif strings.Contains(accept, \"text/html\") {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (handler *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif !isHTML(r.Header[\"Accept\"]) {\n\t\tw.Header().Set(\"Cache-Control\", \"max-age=31536000\")\n\t} else {\n\t\tw.Header().Set(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n\t}\n\thandler.Handler.ServeHTTP(w, r)\n}\n", "package security\n\nimport (\n\t\"github.com/portainer/portainer\"\n\thttperror \"github.com/portainer/portainer/http/error\"\n\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype (\n\t// RequestBouncer represents an entity that manages API request accesses\n\tRequestBouncer struct {\n\t\tjwtService            portainer.JWTService\n\t\tuserService           portainer.UserService\n\t\tteamMembershipService portainer.TeamMembershipService\n\t\tendpointGroupService  portainer.EndpointGroupService\n\t\tauthDisabled          bool\n\t}\n\n\t// RequestBouncerParams represents the required parameters to create a new RequestBouncer instance.\n\tRequestBouncerParams struct {\n\t\tJWTService            portainer.JWTService\n\t\tUserService           portainer.UserService\n\t\tTeamMembershipService portainer.TeamMembershipService\n\t\tEndpointGroupService  portainer.EndpointGroupService\n\t\tAuthDisabled          bool\n\t}\n\n\t// RestrictedRequestContext is a data structure containing information\n\t// used in RestrictedAccess\n\tRestrictedRequestContext struct {\n\t\tIsAdmin         bool\n\t\tIsTeamLeader    bool\n\t\tUserID          portainer.UserID\n\t\tUserMemberships []portainer.TeamMembership\n\t}\n)\n\n// NewRequestBouncer initializes a new RequestBouncer\nfunc NewRequestBouncer(parameters *RequestBouncerParams) *RequestBouncer {\n\treturn &RequestBouncer{\n\t\tjwtService:            parameters.JWTService,\n\t\tuserService:           parameters.UserService,\n\t\tteamMembershipService: parameters.TeamMembershipService,\n\t\tendpointGroupService:  parameters.EndpointGroupService,\n\t\tauthDisabled:          parameters.AuthDisabled,\n\t}\n}\n\n// PublicAccess defines a security check for public endpoints.\n// No authentication is required to access these endpoints.\nfunc (bouncer *RequestBouncer) PublicAccess(h http.Handler) http.Handler {\n\th = mwSecureHeaders(h)\n\treturn h\n}\n\n// AuthenticatedAccess defines a security check for private endpoints.\n// Authentication is required to access these endpoints.\nfunc (bouncer *RequestBouncer) AuthenticatedAccess(h http.Handler) http.Handler {\n\th = bouncer.mwCheckAuthentication(h)\n\th = mwSecureHeaders(h)\n\treturn h\n}\n\n// RestrictedAccess defines a security check for restricted endpoints.\n// Authentication is required to access these endpoints.\n// The request context will be enhanced with a RestrictedRequestContext object\n// that might be used later to authorize/filter access to resources.\nfunc (bouncer *RequestBouncer) RestrictedAccess(h http.Handler) http.Handler {\n\th = bouncer.mwUpgradeToRestrictedRequest(h)\n\th = bouncer.AuthenticatedAccess(h)\n\treturn h\n}\n\n// AdministratorAccess defines a chain of middleware for restricted endpoints.\n// Authentication as well as administrator role are required to access these endpoints.\nfunc (bouncer *RequestBouncer) AdministratorAccess(h http.Handler) http.Handler {\n\th = mwCheckAdministratorRole(h)\n\th = bouncer.AuthenticatedAccess(h)\n\treturn h\n}\n\n// EndpointAccess retrieves the JWT token from the request context and verifies\n// that the user can access the specified endpoint.\n// An error is returned when access is denied.\nfunc (bouncer *RequestBouncer) EndpointAccess(r *http.Request, endpoint *portainer.Endpoint) error {\n\ttokenData, err := RetrieveTokenData(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif tokenData.Role == portainer.AdministratorRole {\n\t\treturn nil\n\t}\n\n\tmemberships, err := bouncer.teamMembershipService.TeamMembershipsByUserID(tokenData.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgroup, err := bouncer.endpointGroupService.EndpointGroup(endpoint.GroupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !authorizedEndpointAccess(endpoint, group, tokenData.ID, memberships) {\n\t\treturn portainer.ErrEndpointAccessDenied\n\t}\n\n\treturn nil\n}\n\n// mwSecureHeaders provides secure headers middleware for handlers.\nfunc mwSecureHeaders(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Add(\"X-Content-Type-Options\", \"nosniff\")\n\t\tw.Header().Add(\"X-Frame-Options\", \"DENY\")\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\n// mwUpgradeToRestrictedRequest will enhance the current request with\n// a new RestrictedRequestContext object.\nfunc (bouncer *RequestBouncer) mwUpgradeToRestrictedRequest(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenData, err := RetrieveTokenData(r)\n\t\tif err != nil {\n\t\t\thttperror.WriteError(w, http.StatusForbidden, \"Access denied\", portainer.ErrResourceAccessDenied)\n\t\t\treturn\n\t\t}\n\n\t\trequestContext, err := bouncer.newRestrictedContextRequest(tokenData.ID, tokenData.Role)\n\t\tif err != nil {\n\t\t\thttperror.WriteError(w, http.StatusInternalServerError, \"Unable to create restricted request context \", err)\n\t\t\treturn\n\t\t}\n\n\t\tctx := storeRestrictedRequestContext(r, requestContext)\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t})\n}\n\n// mwCheckAdministratorRole check the role of the user associated to the request\nfunc mwCheckAdministratorRole(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenData, err := RetrieveTokenData(r)\n\t\tif err != nil || tokenData.Role != portainer.AdministratorRole {\n\t\t\thttperror.WriteError(w, http.StatusForbidden, \"Access denied\", portainer.ErrResourceAccessDenied)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\n// mwCheckAuthentication provides Authentication middleware for handlers\nfunc (bouncer *RequestBouncer) mwCheckAuthentication(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tvar tokenData *portainer.TokenData\n\t\tif !bouncer.authDisabled {\n\t\t\tvar token string\n\n\t\t\t// Optionally, token might be set via the \"token\" query parameter.\n\t\t\t// For example, in websocket requests\n\t\t\ttoken = r.URL.Query().Get(\"token\")\n\n\t\t\t// Get token from the Authorization header\n\t\t\ttokens, ok := r.Header[\"Authorization\"]\n\t\t\tif ok && len(tokens) >= 1 {\n\t\t\t\ttoken = tokens[0]\n\t\t\t\ttoken = strings.TrimPrefix(token, \"Bearer \")\n\t\t\t}\n\n\t\t\tif token == \"\" {\n\t\t\t\thttperror.WriteError(w, http.StatusUnauthorized, \"Unauthorized\", portainer.ErrUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\ttokenData, err = bouncer.jwtService.ParseAndVerifyToken(token)\n\t\t\tif err != nil {\n\t\t\t\thttperror.WriteError(w, http.StatusUnauthorized, \"Invalid JWT token\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t_, err = bouncer.userService.User(tokenData.ID)\n\t\t\tif err != nil && err == portainer.ErrObjectNotFound {\n\t\t\t\thttperror.WriteError(w, http.StatusUnauthorized, \"Unauthorized\", portainer.ErrUnauthorized)\n\t\t\t\treturn\n\t\t\t} else if err != nil {\n\t\t\t\thttperror.WriteError(w, http.StatusInternalServerError, \"Unable to retrieve users from the database\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\ttokenData = &portainer.TokenData{\n\t\t\t\tRole: portainer.AdministratorRole,\n\t\t\t}\n\t\t}\n\n\t\tctx := storeTokenData(r, tokenData)\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\treturn\n\t})\n}\n\nfunc (bouncer *RequestBouncer) newRestrictedContextRequest(userID portainer.UserID, userRole portainer.UserRole) (*RestrictedRequestContext, error) {\n\trequestContext := &RestrictedRequestContext{\n\t\tIsAdmin: true,\n\t\tUserID:  userID,\n\t}\n\n\tif userRole != portainer.AdministratorRole {\n\t\trequestContext.IsAdmin = false\n\t\tmemberships, err := bouncer.teamMembershipService.TeamMembershipsByUserID(userID)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tisTeamLeader := false\n\t\tfor _, membership := range memberships {\n\t\t\tif membership.Role == portainer.TeamLeader {\n\t\t\t\tisTeamLeader = true\n\t\t\t}\n\t\t}\n\n\t\trequestContext.IsTeamLeader = isTeamLeader\n\t\trequestContext.UserMemberships = memberships\n\t}\n\n\treturn requestContext, nil\n}\n", "angular.module('portainer.app')\n.controller('TeamsController', ['$q', '$scope', '$state', 'TeamService', 'UserService', 'ModalService', 'Notifications', 'Authentication',\nfunction ($q, $scope, $state, TeamService, UserService, ModalService, Notifications, Authentication) {\n  $scope.state = {\n    actionInProgress: false\n  };\n\n  $scope.formValues = {\n    Name: '',\n    Leaders: []\n  };\n\n  $scope.checkNameValidity = function(form) {\n    var valid = true;\n    for (var i = 0; i < $scope.teams.length; i++) {\n      if ($scope.formValues.Name === $scope.teams[i].Name) {\n        valid = false;\n        break;\n      }\n    }\n    form.team_name.$setValidity('validName', valid);\n  };\n\n  $scope.addTeam = function() {\n    var teamName = $scope.formValues.Name;\n    var leaderIds = [];\n    angular.forEach($scope.formValues.Leaders, function(user) {\n      leaderIds.push(user.Id);\n    });\n\n    $scope.state.actionInProgress = true;\n    TeamService.createTeam(teamName, leaderIds)\n    .then(function success(data) {\n      Notifications.success('Team successfully created', teamName);\n      $state.reload();\n    })\n    .catch(function error(err) {\n      Notifications.error('Failure', err, 'Unable to create team');\n    })\n    .finally(function final() {\n      $scope.state.actionInProgress = false;\n    });\n  };\n\n  $scope.removeAction = function (selectedItems) {\n    ModalService.confirmDeletion(\n      'Do you want to delete the selected team(s)? Users in the team(s) will not be deleted.',\n      function onConfirm(confirmed) {\n        if(!confirmed) { return; }\n        deleteSelectedTeams(selectedItems);\n      }\n    );\n  };\n\n  function deleteSelectedTeams(selectedItems) {\n    var actionCount = selectedItems.length;\n    angular.forEach(selectedItems, function (team) {\n      TeamService.deleteTeam(team.Id)\n      .then(function success() {\n        Notifications.success('Team successfully removed', team.Name);\n        var index = $scope.teams.indexOf(team);\n        $scope.teams.splice(index, 1);\n      })\n      .catch(function error(err) {\n        Notifications.error('Failure', err, 'Unable to remove team');\n      })\n      .finally(function final() {\n        --actionCount;\n        if (actionCount === 0) {\n          $state.reload();\n        }\n      });\n    });\n  }\n\n  function initView() {\n    var userDetails = Authentication.getUserDetails();\n    var isAdmin = userDetails.role === 1 ? true: false;\n    $scope.isAdmin = isAdmin;\n    $q.all({\n      users: UserService.users(false),\n      teams: isAdmin ? TeamService.teams() : UserService.userLeadingTeams(userDetails.ID)\n    })\n    .then(function success(data) {\n      $scope.teams = data.teams;\n      $scope.users = data.users;\n    })\n    .catch(function error(err) {\n      $scope.teams = [];\n      $scope.users = [];\n      Notifications.error('Failure', err, 'Unable to retrieve teams');\n    });\n  }\n\n  initView();\n}]);\n"], "fixing_code": ["package file\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n)\n\n// Handler represents an HTTP API handler for managing static files.\ntype Handler struct {\n\thttp.Handler\n}\n\n// NewHandler creates a handler to serve static files.\nfunc NewHandler(assetPublicPath string) *Handler {\n\th := &Handler{\n\t\tHandler: http.FileServer(http.Dir(assetPublicPath)),\n\t}\n\treturn h\n}\n\nfunc isHTML(acceptContent []string) bool {\n\tfor _, accept := range acceptContent {\n\t\tif strings.Contains(accept, \"text/html\") {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (handler *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif !isHTML(r.Header[\"Accept\"]) {\n\t\tw.Header().Set(\"Cache-Control\", \"max-age=31536000\")\n\t} else {\n\t\tw.Header().Set(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n\t}\n\n\tw.Header().Add(\"X-Frame-Options\", \"DENY\")\n\tw.Header().Add(\"X-XSS-Protection\", \"1; mode=block\")\n\tw.Header().Add(\"X-Content-Type-Options\", \"nosniff\")\n\thandler.Handler.ServeHTTP(w, r)\n}\n", "package security\n\nimport (\n\t\"github.com/portainer/portainer\"\n\thttperror \"github.com/portainer/portainer/http/error\"\n\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype (\n\t// RequestBouncer represents an entity that manages API request accesses\n\tRequestBouncer struct {\n\t\tjwtService            portainer.JWTService\n\t\tuserService           portainer.UserService\n\t\tteamMembershipService portainer.TeamMembershipService\n\t\tendpointGroupService  portainer.EndpointGroupService\n\t\tauthDisabled          bool\n\t}\n\n\t// RequestBouncerParams represents the required parameters to create a new RequestBouncer instance.\n\tRequestBouncerParams struct {\n\t\tJWTService            portainer.JWTService\n\t\tUserService           portainer.UserService\n\t\tTeamMembershipService portainer.TeamMembershipService\n\t\tEndpointGroupService  portainer.EndpointGroupService\n\t\tAuthDisabled          bool\n\t}\n\n\t// RestrictedRequestContext is a data structure containing information\n\t// used in RestrictedAccess\n\tRestrictedRequestContext struct {\n\t\tIsAdmin         bool\n\t\tIsTeamLeader    bool\n\t\tUserID          portainer.UserID\n\t\tUserMemberships []portainer.TeamMembership\n\t}\n)\n\n// NewRequestBouncer initializes a new RequestBouncer\nfunc NewRequestBouncer(parameters *RequestBouncerParams) *RequestBouncer {\n\treturn &RequestBouncer{\n\t\tjwtService:            parameters.JWTService,\n\t\tuserService:           parameters.UserService,\n\t\tteamMembershipService: parameters.TeamMembershipService,\n\t\tendpointGroupService:  parameters.EndpointGroupService,\n\t\tauthDisabled:          parameters.AuthDisabled,\n\t}\n}\n\n// PublicAccess defines a security check for public endpoints.\n// No authentication is required to access these endpoints.\nfunc (bouncer *RequestBouncer) PublicAccess(h http.Handler) http.Handler {\n\th = mwSecureHeaders(h)\n\treturn h\n}\n\n// AuthenticatedAccess defines a security check for private endpoints.\n// Authentication is required to access these endpoints.\nfunc (bouncer *RequestBouncer) AuthenticatedAccess(h http.Handler) http.Handler {\n\th = bouncer.mwCheckAuthentication(h)\n\th = mwSecureHeaders(h)\n\treturn h\n}\n\n// RestrictedAccess defines a security check for restricted endpoints.\n// Authentication is required to access these endpoints.\n// The request context will be enhanced with a RestrictedRequestContext object\n// that might be used later to authorize/filter access to resources.\nfunc (bouncer *RequestBouncer) RestrictedAccess(h http.Handler) http.Handler {\n\th = bouncer.mwUpgradeToRestrictedRequest(h)\n\th = bouncer.AuthenticatedAccess(h)\n\treturn h\n}\n\n// AdministratorAccess defines a chain of middleware for restricted endpoints.\n// Authentication as well as administrator role are required to access these endpoints.\nfunc (bouncer *RequestBouncer) AdministratorAccess(h http.Handler) http.Handler {\n\th = mwCheckAdministratorRole(h)\n\th = bouncer.AuthenticatedAccess(h)\n\treturn h\n}\n\n// EndpointAccess retrieves the JWT token from the request context and verifies\n// that the user can access the specified endpoint.\n// An error is returned when access is denied.\nfunc (bouncer *RequestBouncer) EndpointAccess(r *http.Request, endpoint *portainer.Endpoint) error {\n\ttokenData, err := RetrieveTokenData(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif tokenData.Role == portainer.AdministratorRole {\n\t\treturn nil\n\t}\n\n\tmemberships, err := bouncer.teamMembershipService.TeamMembershipsByUserID(tokenData.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgroup, err := bouncer.endpointGroupService.EndpointGroup(endpoint.GroupID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !authorizedEndpointAccess(endpoint, group, tokenData.ID, memberships) {\n\t\treturn portainer.ErrEndpointAccessDenied\n\t}\n\n\treturn nil\n}\n\n// mwSecureHeaders provides secure headers middleware for handlers.\nfunc mwSecureHeaders(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Add(\"X-Frame-Options\", \"DENY\")\n\t\tw.Header().Add(\"X-XSS-Protection\", \"1; mode=block\")\n\t\tw.Header().Add(\"X-Content-Type-Options\", \"nosniff\")\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\n// mwUpgradeToRestrictedRequest will enhance the current request with\n// a new RestrictedRequestContext object.\nfunc (bouncer *RequestBouncer) mwUpgradeToRestrictedRequest(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenData, err := RetrieveTokenData(r)\n\t\tif err != nil {\n\t\t\thttperror.WriteError(w, http.StatusForbidden, \"Access denied\", portainer.ErrResourceAccessDenied)\n\t\t\treturn\n\t\t}\n\n\t\trequestContext, err := bouncer.newRestrictedContextRequest(tokenData.ID, tokenData.Role)\n\t\tif err != nil {\n\t\t\thttperror.WriteError(w, http.StatusInternalServerError, \"Unable to create restricted request context \", err)\n\t\t\treturn\n\t\t}\n\n\t\tctx := storeRestrictedRequestContext(r, requestContext)\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t})\n}\n\n// mwCheckAdministratorRole check the role of the user associated to the request\nfunc mwCheckAdministratorRole(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenData, err := RetrieveTokenData(r)\n\t\tif err != nil || tokenData.Role != portainer.AdministratorRole {\n\t\t\thttperror.WriteError(w, http.StatusForbidden, \"Access denied\", portainer.ErrResourceAccessDenied)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\n// mwCheckAuthentication provides Authentication middleware for handlers\nfunc (bouncer *RequestBouncer) mwCheckAuthentication(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tvar tokenData *portainer.TokenData\n\t\tif !bouncer.authDisabled {\n\t\t\tvar token string\n\n\t\t\t// Optionally, token might be set via the \"token\" query parameter.\n\t\t\t// For example, in websocket requests\n\t\t\ttoken = r.URL.Query().Get(\"token\")\n\n\t\t\t// Get token from the Authorization header\n\t\t\ttokens, ok := r.Header[\"Authorization\"]\n\t\t\tif ok && len(tokens) >= 1 {\n\t\t\t\ttoken = tokens[0]\n\t\t\t\ttoken = strings.TrimPrefix(token, \"Bearer \")\n\t\t\t}\n\n\t\t\tif token == \"\" {\n\t\t\t\thttperror.WriteError(w, http.StatusUnauthorized, \"Unauthorized\", portainer.ErrUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\ttokenData, err = bouncer.jwtService.ParseAndVerifyToken(token)\n\t\t\tif err != nil {\n\t\t\t\thttperror.WriteError(w, http.StatusUnauthorized, \"Invalid JWT token\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t_, err = bouncer.userService.User(tokenData.ID)\n\t\t\tif err != nil && err == portainer.ErrObjectNotFound {\n\t\t\t\thttperror.WriteError(w, http.StatusUnauthorized, \"Unauthorized\", portainer.ErrUnauthorized)\n\t\t\t\treturn\n\t\t\t} else if err != nil {\n\t\t\t\thttperror.WriteError(w, http.StatusInternalServerError, \"Unable to retrieve users from the database\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\ttokenData = &portainer.TokenData{\n\t\t\t\tRole: portainer.AdministratorRole,\n\t\t\t}\n\t\t}\n\n\t\tctx := storeTokenData(r, tokenData)\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\treturn\n\t})\n}\n\nfunc (bouncer *RequestBouncer) newRestrictedContextRequest(userID portainer.UserID, userRole portainer.UserRole) (*RestrictedRequestContext, error) {\n\trequestContext := &RestrictedRequestContext{\n\t\tIsAdmin: true,\n\t\tUserID:  userID,\n\t}\n\n\tif userRole != portainer.AdministratorRole {\n\t\trequestContext.IsAdmin = false\n\t\tmemberships, err := bouncer.teamMembershipService.TeamMembershipsByUserID(userID)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tisTeamLeader := false\n\t\tfor _, membership := range memberships {\n\t\t\tif membership.Role == portainer.TeamLeader {\n\t\t\t\tisTeamLeader = true\n\t\t\t}\n\t\t}\n\n\t\trequestContext.IsTeamLeader = isTeamLeader\n\t\trequestContext.UserMemberships = memberships\n\t}\n\n\treturn requestContext, nil\n}\n", "angular.module('portainer.app')\n.controller('TeamsController', ['$q', '$scope', '$state', '$sanitize', 'TeamService', 'UserService', 'ModalService', 'Notifications', 'Authentication',\nfunction ($q, $scope, $state, $sanitize, TeamService, UserService, ModalService, Notifications, Authentication) {\n  $scope.state = {\n    actionInProgress: false\n  };\n\n  $scope.formValues = {\n    Name: '',\n    Leaders: []\n  };\n\n  $scope.checkNameValidity = function(form) {\n    var valid = true;\n    for (var i = 0; i < $scope.teams.length; i++) {\n      if ($scope.formValues.Name === $scope.teams[i].Name) {\n        valid = false;\n        break;\n      }\n    }\n    form.team_name.$setValidity('validName', valid);\n  };\n\n  $scope.addTeam = function() {\n    var teamName = $sanitize($scope.formValues.Name);\n    var leaderIds = [];\n    angular.forEach($scope.formValues.Leaders, function(user) {\n      leaderIds.push(user.Id);\n    });\n\n    $scope.state.actionInProgress = true;\n    TeamService.createTeam(teamName, leaderIds)\n    .then(function success(data) {\n      Notifications.success('Team successfully created', teamName);\n      $state.reload();\n    })\n    .catch(function error(err) {\n      Notifications.error('Failure', err, 'Unable to create team');\n    })\n    .finally(function final() {\n      $scope.state.actionInProgress = false;\n    });\n  };\n\n  $scope.removeAction = function (selectedItems) {\n    ModalService.confirmDeletion(\n      'Do you want to delete the selected team(s)? Users in the team(s) will not be deleted.',\n      function onConfirm(confirmed) {\n        if(!confirmed) { return; }\n        deleteSelectedTeams(selectedItems);\n      }\n    );\n  };\n\n  function deleteSelectedTeams(selectedItems) {\n    var actionCount = selectedItems.length;\n    angular.forEach(selectedItems, function (team) {\n      TeamService.deleteTeam(team.Id)\n      .then(function success() {\n        Notifications.success('Team successfully removed', team.Name);\n        var index = $scope.teams.indexOf(team);\n        $scope.teams.splice(index, 1);\n      })\n      .catch(function error(err) {\n        Notifications.error('Failure', err, 'Unable to remove team');\n      })\n      .finally(function final() {\n        --actionCount;\n        if (actionCount === 0) {\n          $state.reload();\n        }\n      });\n    });\n  }\n\n  function initView() {\n    var userDetails = Authentication.getUserDetails();\n    var isAdmin = userDetails.role === 1 ? true: false;\n    $scope.isAdmin = isAdmin;\n    $q.all({\n      users: UserService.users(false),\n      teams: isAdmin ? TeamService.teams() : UserService.userLeadingTeams(userDetails.ID)\n    })\n    .then(function success(data) {\n      $scope.teams = data.teams;\n      $scope.users = data.users;\n    })\n    .catch(function error(err) {\n      $scope.teams = [];\n      $scope.users = [];\n      Notifications.error('Failure', err, 'Unable to retrieve teams');\n    });\n  }\n\n  initView();\n}]);\n"], "filenames": ["api/http/handler/file/handler.go", "api/http/security/bouncer.go", "app/portainer/views/teams/teamsController.js"], "buggy_code_start_loc": [35, 116, 2], "buggy_code_end_loc": [35, 119, 26], "fixing_code_start_loc": [36, 117, 2], "fixing_code_end_loc": [40, 119, 26], "type": "CWE-79", "message": "A stored Cross-site scripting (XSS) vulnerability in Portainer through 1.19.1 allows remote authenticated users to inject arbitrary JavaScript and/or HTML via the Team Name field.", "other": {"cve": {"id": "CVE-2018-16316", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-01T18:29:00.803", "lastModified": "2018-11-09T16:55:57.883", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A stored Cross-site scripting (XSS) vulnerability in Portainer through 1.19.1 allows remote authenticated users to inject arbitrary JavaScript and/or HTML via the Team Name field."}, {"lang": "es", "value": "Una vulnerabilidad Cross-Site Scripting (XSS) persistente en Portainer hasta la versi\u00f3n 1.19.1 permite que usuarios autenticados remotos inyecten JavaScript y/o HTLM arbitrarios mediante el campo Team Name."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:portainer:portainer:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.19.1", "matchCriteriaId": "E1C2B2A7-BD6C-4CF5-A161-30CD69A3E648"}]}]}], "references": [{"url": "https://github.com/portainer/portainer/commit/1ad150c99460a35224d6adfe48ddda9ee056b7d2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/portainer/portainer/commit/1ad150c99460a35224d6adfe48ddda9ee056b7d2"}}