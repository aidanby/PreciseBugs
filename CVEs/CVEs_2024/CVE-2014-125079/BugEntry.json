{"buggy_code": ["# Pontifex.Http.coffee\n#\n# \u00a9 2013 Dave Goehrig <dave@dloh.org>\n# \u00a9 2014 wot.io LLC\n# \u00a9 2014 WoT.io Inc\n\nhttp = require 'http'\nuuid = require 'uuid'\nrequest = require 'request'\n\nHttp = (Bridge,Url) =>\n\tself = this\n\n\t# http :// wot.io : 80 / wot\n\t[ proto, host, port, domain ] = Url.match(///([^:]+)://([^:]+):(\\d+)/([^\\/]*)///)[1...]\n\n\t# OAuth2-like Authentication *Temporary, until full OAuth2 support is added*\n\t# As specified in: http://tools.ietf.org/html/rfc6749\n\t#                  http://tools.ietf.org/html/rfc6750\n\twot_authenticate = (res, req, command, path, callback) ->\n\t\tif typeof req.headers.authorization == 'undefined'\n\t\t\tres.writeHead 401, { \"Content-Type\": \"application/json\", \"Content-Length\": 0 }\n\t\t\tres.end()\n\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()]\n\t\t\treturn\n\t\ttoken = req.headers.authorization.match(/bearer (.*)/i)[1]\n\t\tauth_req =\n\t\t\turl: \"http://auth.wot.io/authenticate_token/#{token}/#{command}/#{path}\"\n\t\t\tjson: true\n\t\ttry\n\t\t\trequest auth_req, (error, response, body) ->\n\t\t\t\tif !error and response.statusCode == 200\n\t\t\t\t\tconsole.log body\n\t\t\t\t\tif body.authenticate_token\n\t\t\t\t\t\tcallback()\n\t\t\t\t\telse\n\t\t\t\t\t\tconsole.log 'Failed authentication'\n\t\t\t\t\t\tres.writeHead 401, { \"Content-Type\": \"application/json\", \"Content-Length\": 0 }\n\t\t\t\t\t\tres.end()\n\t\t\t\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\t\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()]\n\t\tcatch error\n\t\t\tconsole.log \"[pontifex.http] #{error}\"\n\n\t# Extract the path for matching, and prevent crash in case of invalid path\n\textract_path = (url, numOfMatches) ->\n\t\ttry\n\t\t\tif numOfMatches == 2\n\t\t\t\treturn url.replace(\"%23\",\"#\").replace(\"%2a\",\"*\").match(////[^\\/]*/([^\\/]+)/([^\\/]+)///)[1...]\n\t\t\tif numOfMatches == 3\n\t\t\t\treturn url.replace(\"%23\",\"#\").replace(\"%2a\",\"*\").match(////[^\\/]*/([^\\/]+)/([^\\/]+)/([^\\/]+)///)[1...]\n\t\tcatch error\n\t\t\tconsole.log \"[pontifex.http] #{error}\"\n\t\t\treturn false\n\n\t# HTTP server interface\n\tself.server = http.createServer (req,res) ->\n\t\ttry\n\t\t# dynamically dispatch to the correct REST handler\n\t\t\treq.session = uuid.v4()\n\t\t\tself.server.stats.push [ 'created_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()]\n\t\t\tself.server.stats.push [ 'read_connection', req.url, req.session, domain, req.socket.bytesRead, new Date().getTime()]\n\t\t\tself[req.method.toLowerCase()]?.apply(self,[ req,res ])\n\t\tcatch error\n\t\t\tconsole.log \"[pontifex.http] Error #{error}\"\n\n\tself.server.listen port\n\tself.server.stats = []\n\tself.server.flush_stats = () ->\n\t\tself.server.stats.map (x) ->\n\t\t\tBridge.log x[1], x\n\t\tself.server.stats = []\n\n\tsetInterval self.server.flush_stats, 60000\t# flush stats once a minute\n\n\t# POST /exchange/key/queue   - creates a bus address for a source\n\tself.post = (req,res) ->\n\t\tif !( [ exchange, key, queue ] = extract_path(req.url, 3) )\n\t\t\treturn\n\t\tconsole.log [ exchange, key, queue ]\n\t\twot_authenticate(res, req, 'create', \"#{exchange}%2F#{key}%2F#{queue}\", () ->\n\t\t\tBridge.route exchange, key, queue, () ->\n\t\t\t\tdata = JSON.stringify [ \"ok\", \"/#{domain}/#{exchange}/#{key}/#{queue}\" ]\n\t\t\t\tres.writeHead 201, { \"Location\": \"/#{domain}/#{exchange}/#{key}/#{queue}\", \"Content-Type\": \"application/json\", \"Content-Length\" : data.length }\n\t\t\t\tres.end data\n\t\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()])\n\n\t# GET /exchange/key/queue   - reads a message off of the queue\n\tself.get = (req,res) ->\n\t\tif !( [ exchange, key, queue ] = extract_path(req.url, 3) )\n\t\t\treturn\n\t\tconsole.log [ exchange, key, queue ]\n\t\twot_authenticate(res, req, 'read', \"#{exchange}%2F#{key}%2F#{queue}\", () ->\n\t\t\tBridge.read queue, (data) ->\n\t\t\t\tif data\n\t\t\t\t\tres.writeHead 200, { \"Content-Type\": \"application/json\", \"Content-Length\": data.length }\n\t\t\t\t\tres.end data\n\t\t\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()]\n\t\t\t\telse\n\t\t\t\t\tres.writeHead 404, { \"Content-Type\": \"application/json\", \"Content-Length\": 0 }\n\t\t\t\t\tres.end()\n\t\t\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()])\n\n\t# PUT exchange/key   - write a message to a sink\n\tself.put = (req,res) ->\n\t\tsink = req.url.replace(\"%23\",\"#\").replace(\"%2a\",\"*\")\n\t\tif !( [ exchange, key ] = extract_path(req.url, 2) )\n\t\t\treturn\n\t\treq.on 'data', (data) ->\n\t\t\ttry\n\t\t\t\twot_authenticate(res, req, 'write', \"#{exchange}%2F#{key}\", () ->\n\t\t\t\t\tmessage = JSON.parse(data)\n\t\t\t\t\tif message[0] == 'ping'\n\t\t\t\t\t\tdata = JSON.stringify ['pong']\n\t\t\t\t\telse\n\t\t\t\t\t\tBridge.send exchange, key, JSON.stringify(message)\n\t\t\t\t\t\tdata = JSON.stringify [ \"ok\", sink ]\n\t\t\t\t\tres.writeHead 200, { \"Content-Type\": \"application/json\", \"Content-Length\": data.length }\n\t\t\t\t\tres.end data\n\t\t\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()])\n\t\t\tcatch error\n\t\t\t\tconsole.log \"[pontifex.http] #{error}\"\n\n\t# DELETE /exchange/key/queue   - removes a queue & binding\n\tself.delete = (req,res) ->\n\t\tif !( [ exchange, key, queue ] = extract_path(req.url, 3) )\n\t\t\treturn\n\t\twot_authenticate(res, req, 'delete', \"#{exchange}%2F#{key}%2F#{queue}\", () ->\n\t\t\tBridge.delete queue\n\t\t\tdata = JSON.stringify [ \"ok\", req.url ]\n\t\t\tres.writeHead 200, { \"Content-Type\" : \"application/json\", \"Content-Length\" :  data.length }\n\t\t\tres.end data\n\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()])\n\nmodule.exports = Http\n"], "fixing_code": ["# Pontifex.Http.coffee\n#\n# \u00a9 2013 Dave Goehrig <dave@dloh.org>\n# \u00a9 2014 wot.io LLC\n# \u00a9 2014 WoT.io Inc\n\nhttp = require 'http'\nuuid = require 'uuid'\nrequest = require 'request'\n\nHttp = (Bridge,Url) =>\n\tself = this\n\n\t# http :// wot.io : 80 / wot\n\t[ proto, host, port, domain ] = Url.match(///([^:]+)://([^:]+):(\\d+)/([^\\/]*)///)[1...]\n\n\t# OAuth2-like Authentication *Temporary, until full OAuth2 support is added*\n\t# As specified in: http://tools.ietf.org/html/rfc6749\n\t#                  http://tools.ietf.org/html/rfc6750\n\twot_authenticate = (res, req, command, path, callback) ->\n\t\tif typeof req.headers.authorization == 'undefined'\n\t\t\tres.writeHead 401, { \"Content-Type\": \"application/json\", \"Content-Length\": 0 }\n\t\t\tres.end()\n\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()]\n\t\t\treturn\n\t\ttoken = req.headers.authorization.match(/bearer (.*)/i)[1]\n\t\tauth_req =\n\t\t\turl: \"http://auth.wot.io/authenticate_token/#{token}/#{command}/#{path}\".replace(\"'\", \"''\")\n\t\t\tjson: true\n\t\ttry\n\t\t\trequest auth_req, (error, response, body) ->\n\t\t\t\tif !error and response.statusCode == 200\n\t\t\t\t\tconsole.log body\n\t\t\t\t\tif body.authenticate_token\n\t\t\t\t\t\tcallback()\n\t\t\t\t\telse\n\t\t\t\t\t\tconsole.log 'Failed authentication'\n\t\t\t\t\t\tres.writeHead 401, { \"Content-Type\": \"application/json\", \"Content-Length\": 0 }\n\t\t\t\t\t\tres.end()\n\t\t\t\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\t\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()]\n\t\tcatch error\n\t\t\tconsole.log \"[pontifex.http] #{error}\"\n\n\t# Extract the path for matching, and prevent crash in case of invalid path\n\textract_path = (url, numOfMatches) ->\n\t\ttry\n\t\t\tif numOfMatches == 2\n\t\t\t\treturn url.replace(\"%23\",\"#\").replace(\"%2a\",\"*\").match(////[^\\/]*/([^\\/]+)/([^\\/]+)///)[1...]\n\t\t\tif numOfMatches == 3\n\t\t\t\treturn url.replace(\"%23\",\"#\").replace(\"%2a\",\"*\").match(////[^\\/]*/([^\\/]+)/([^\\/]+)/([^\\/]+)///)[1...]\n\t\tcatch error\n\t\t\tconsole.log \"[pontifex.http] #{error}\"\n\t\t\treturn false\n\n\t# HTTP server interface\n\tself.server = http.createServer (req,res) ->\n\t\ttry\n\t\t# dynamically dispatch to the correct REST handler\n\t\t\treq.session = uuid.v4()\n\t\t\tself.server.stats.push [ 'created_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()]\n\t\t\tself.server.stats.push [ 'read_connection', req.url, req.session, domain, req.socket.bytesRead, new Date().getTime()]\n\t\t\tself[req.method.toLowerCase()]?.apply(self,[ req,res ])\n\t\tcatch error\n\t\t\tconsole.log \"[pontifex.http] Error #{error}\"\n\n\tself.server.listen port\n\tself.server.stats = []\n\tself.server.flush_stats = () ->\n\t\tself.server.stats.map (x) ->\n\t\t\tBridge.log x[1], x\n\t\tself.server.stats = []\n\n\tsetInterval self.server.flush_stats, 60000\t# flush stats once a minute\n\n\t# POST /exchange/key/queue   - creates a bus address for a source\n\tself.post = (req,res) ->\n\t\tif !( [ exchange, key, queue ] = extract_path(req.url, 3) )\n\t\t\treturn\n\t\tconsole.log [ exchange, key, queue ]\n\t\twot_authenticate(res, req, 'create', \"#{exchange}%2F#{key}%2F#{queue}\", () ->\n\t\t\tBridge.route exchange, key, queue, () ->\n\t\t\t\tdata = JSON.stringify [ \"ok\", \"/#{domain}/#{exchange}/#{key}/#{queue}\" ]\n\t\t\t\tres.writeHead 201, { \"Location\": \"/#{domain}/#{exchange}/#{key}/#{queue}\", \"Content-Type\": \"application/json\", \"Content-Length\" : data.length }\n\t\t\t\tres.end data\n\t\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()])\n\n\t# GET /exchange/key/queue   - reads a message off of the queue\n\tself.get = (req,res) ->\n\t\tif !( [ exchange, key, queue ] = extract_path(req.url, 3) )\n\t\t\treturn\n\t\tconsole.log [ exchange, key, queue ]\n\t\twot_authenticate(res, req, 'read', \"#{exchange}%2F#{key}%2F#{queue}\", () ->\n\t\t\tBridge.read queue, (data) ->\n\t\t\t\tif data\n\t\t\t\t\tres.writeHead 200, { \"Content-Type\": \"application/json\", \"Content-Length\": data.length }\n\t\t\t\t\tres.end data\n\t\t\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()]\n\t\t\t\telse\n\t\t\t\t\tres.writeHead 404, { \"Content-Type\": \"application/json\", \"Content-Length\": 0 }\n\t\t\t\t\tres.end()\n\t\t\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()])\n\n\t# PUT exchange/key   - write a message to a sink\n\tself.put = (req,res) ->\n\t\tsink = req.url.replace(\"%23\",\"#\").replace(\"%2a\",\"*\")\n\t\tif !( [ exchange, key ] = extract_path(req.url, 2) )\n\t\t\treturn\n\t\treq.on 'data', (data) ->\n\t\t\ttry\n\t\t\t\twot_authenticate(res, req, 'write', \"#{exchange}%2F#{key}\", () ->\n\t\t\t\t\tmessage = JSON.parse(data)\n\t\t\t\t\tif message[0] == 'ping'\n\t\t\t\t\t\tdata = JSON.stringify ['pong']\n\t\t\t\t\telse\n\t\t\t\t\t\tBridge.send exchange, key, JSON.stringify(message)\n\t\t\t\t\t\tdata = JSON.stringify [ \"ok\", sink ]\n\t\t\t\t\tres.writeHead 200, { \"Content-Type\": \"application/json\", \"Content-Length\": data.length }\n\t\t\t\t\tres.end data\n\t\t\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()])\n\t\t\tcatch error\n\t\t\t\tconsole.log \"[pontifex.http] #{error}\"\n\n\t# DELETE /exchange/key/queue   - removes a queue & binding\n\tself.delete = (req,res) ->\n\t\tif !( [ exchange, key, queue ] = extract_path(req.url, 3) )\n\t\t\treturn\n\t\twot_authenticate(res, req, 'delete', \"#{exchange}%2F#{key}%2F#{queue}\", () ->\n\t\t\tBridge.delete queue\n\t\t\tdata = JSON.stringify [ \"ok\", req.url ]\n\t\t\tres.writeHead 200, { \"Content-Type\" : \"application/json\", \"Content-Length\" :  data.length }\n\t\t\tres.end data\n\t\t\tself.server.stats.push [ 'wrote_connection', req.url, req.session, domain, req.socket.bytesWritten, new Date().getTime()]\n\t\t\tself.server.stats.push [ 'closed_connection', req.url, req.session, domain, \"#{req.socket.remoteAddress}:#{req.socket.remotePort}\", new Date().getTime()])\n\nmodule.exports = Http\n"], "filenames": ["lib/Http.coffee"], "buggy_code_start_loc": [29], "buggy_code_end_loc": [30], "fixing_code_start_loc": [29], "fixing_code_end_loc": [30], "type": "CWE-89", "message": "A vulnerability was found in agy pontifex.http. It has been declared as critical. This vulnerability affects unknown code of the file lib/Http.coffee. The manipulation leads to sql injection. Upgrading to version 0.1.0 is able to address this issue. The name of the patch is e52a758f96861dcef2dabfecb9da191bb2e07761. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-218356.", "other": {"cve": {"id": "CVE-2014-125079", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-15T09:15:13.780", "lastModified": "2023-01-24T14:55:50.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in agy pontifex.http. It has been declared as critical. This vulnerability affects unknown code of the file lib/Http.coffee. The manipulation leads to sql injection. Upgrading to version 0.1.0 is able to address this issue. The name of the patch is e52a758f96861dcef2dabfecb9da191bb2e07761. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-218356."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pontifex.http_project:pontifex.http:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.1.0", "matchCriteriaId": "BA1A2020-54AA-49F8-AA41-4EC08EA84953"}]}]}], "references": [{"url": "https://github.com/agy/pontifex.http/commit/e52a758f96861dcef2dabfecb9da191bb2e07761", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/agy/pontifex.http/releases/tag/v0.1.0", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218356", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.218356", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/agy/pontifex.http/commit/e52a758f96861dcef2dabfecb9da191bb2e07761"}}