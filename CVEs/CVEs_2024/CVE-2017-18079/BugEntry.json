{"buggy_code": ["/*\n *  i8042 keyboard and mouse controller driver for Linux\n *\n *  Copyright (c) 1999-2004 Vojtech Pavlik\n */\n\n/*\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 as published by\n * the Free Software Foundation.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/serio.h>\n#include <linux/err.h>\n#include <linux/rcupdate.h>\n#include <linux/platform_device.h>\n#include <linux/i8042.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n\n#include <asm/io.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"i8042 keyboard and mouse controller driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool i8042_nokbd;\nmodule_param_named(nokbd, i8042_nokbd, bool, 0);\nMODULE_PARM_DESC(nokbd, \"Do not probe or use KBD port.\");\n\nstatic bool i8042_noaux;\nmodule_param_named(noaux, i8042_noaux, bool, 0);\nMODULE_PARM_DESC(noaux, \"Do not probe or use AUX (mouse) port.\");\n\nstatic bool i8042_nomux;\nmodule_param_named(nomux, i8042_nomux, bool, 0);\nMODULE_PARM_DESC(nomux, \"Do not check whether an active multiplexing controller is present.\");\n\nstatic bool i8042_unlock;\nmodule_param_named(unlock, i8042_unlock, bool, 0);\nMODULE_PARM_DESC(unlock, \"Ignore keyboard lock.\");\n\nenum i8042_controller_reset_mode {\n\tI8042_RESET_NEVER,\n\tI8042_RESET_ALWAYS,\n\tI8042_RESET_ON_S2RAM,\n#define I8042_RESET_DEFAULT\tI8042_RESET_ON_S2RAM\n};\nstatic enum i8042_controller_reset_mode i8042_reset = I8042_RESET_DEFAULT;\nstatic int i8042_set_reset(const char *val, const struct kernel_param *kp)\n{\n\tenum i8042_controller_reset_mode *arg = kp->arg;\n\tint error;\n\tbool reset;\n\n\tif (val) {\n\t\terror = kstrtobool(val, &reset);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\treset = true;\n\t}\n\n\t*arg = reset ? I8042_RESET_ALWAYS : I8042_RESET_NEVER;\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops param_ops_reset_param = {\n\t.flags = KERNEL_PARAM_OPS_FL_NOARG,\n\t.set = i8042_set_reset,\n};\n#define param_check_reset_param(name, p)\t\\\n\t__param_check(name, p, enum i8042_controller_reset_mode)\nmodule_param_named(reset, i8042_reset, reset_param, 0);\nMODULE_PARM_DESC(reset, \"Reset controller on resume, cleanup or both\");\n\nstatic bool i8042_direct;\nmodule_param_named(direct, i8042_direct, bool, 0);\nMODULE_PARM_DESC(direct, \"Put keyboard port into non-translated mode.\");\n\nstatic bool i8042_dumbkbd;\nmodule_param_named(dumbkbd, i8042_dumbkbd, bool, 0);\nMODULE_PARM_DESC(dumbkbd, \"Pretend that controller can only read data from keyboard\");\n\nstatic bool i8042_noloop;\nmodule_param_named(noloop, i8042_noloop, bool, 0);\nMODULE_PARM_DESC(noloop, \"Disable the AUX Loopback command while probing for the AUX port\");\n\nstatic bool i8042_notimeout;\nmodule_param_named(notimeout, i8042_notimeout, bool, 0);\nMODULE_PARM_DESC(notimeout, \"Ignore timeouts signalled by i8042\");\n\nstatic bool i8042_kbdreset;\nmodule_param_named(kbdreset, i8042_kbdreset, bool, 0);\nMODULE_PARM_DESC(kbdreset, \"Reset device connected to KBD port\");\n\n#ifdef CONFIG_X86\nstatic bool i8042_dritek;\nmodule_param_named(dritek, i8042_dritek, bool, 0);\nMODULE_PARM_DESC(dritek, \"Force enable the Dritek keyboard extension\");\n#endif\n\n#ifdef CONFIG_PNP\nstatic bool i8042_nopnp;\nmodule_param_named(nopnp, i8042_nopnp, bool, 0);\nMODULE_PARM_DESC(nopnp, \"Do not use PNP to detect controller settings\");\n#endif\n\n#define DEBUG\n#ifdef DEBUG\nstatic bool i8042_debug;\nmodule_param_named(debug, i8042_debug, bool, 0600);\nMODULE_PARM_DESC(debug, \"Turn i8042 debugging mode on and off\");\n\nstatic bool i8042_unmask_kbd_data;\nmodule_param_named(unmask_kbd_data, i8042_unmask_kbd_data, bool, 0600);\nMODULE_PARM_DESC(unmask_kbd_data, \"Unconditional enable (may reveal sensitive data) of normally sanitize-filtered kbd data traffic debug log [pre-condition: i8042.debug=1 enabled]\");\n#endif\n\nstatic bool i8042_bypass_aux_irq_test;\nstatic char i8042_kbd_firmware_id[128];\nstatic char i8042_aux_firmware_id[128];\n\n#include \"i8042.h\"\n\n/*\n * i8042_lock protects serialization between i8042_command and\n * the interrupt handler.\n */\nstatic DEFINE_SPINLOCK(i8042_lock);\n\n/*\n * Writers to AUX and KBD ports as well as users issuing i8042_command\n * directly should acquire i8042_mutex (by means of calling\n * i8042_lock_chip() and i8042_unlock_ship() helpers) to ensure that\n * they do not disturb each other (unfortunately in many i8042\n * implementations write to one of the ports will immediately abort\n * command that is being processed by another port).\n */\nstatic DEFINE_MUTEX(i8042_mutex);\n\nstruct i8042_port {\n\tstruct serio *serio;\n\tint irq;\n\tbool exists;\n\tbool driver_bound;\n\tsigned char mux;\n};\n\n#define I8042_KBD_PORT_NO\t0\n#define I8042_AUX_PORT_NO\t1\n#define I8042_MUX_PORT_NO\t2\n#define I8042_NUM_PORTS\t\t(I8042_NUM_MUX_PORTS + 2)\n\nstatic struct i8042_port i8042_ports[I8042_NUM_PORTS];\n\nstatic unsigned char i8042_initial_ctr;\nstatic unsigned char i8042_ctr;\nstatic bool i8042_mux_present;\nstatic bool i8042_kbd_irq_registered;\nstatic bool i8042_aux_irq_registered;\nstatic unsigned char i8042_suppress_kbd_ack;\nstatic struct platform_device *i8042_platform_device;\nstatic struct notifier_block i8042_kbd_bind_notifier_block;\n\nstatic irqreturn_t i8042_interrupt(int irq, void *dev_id);\nstatic bool (*i8042_platform_filter)(unsigned char data, unsigned char str,\n\t\t\t\t     struct serio *serio);\n\nvoid i8042_lock_chip(void)\n{\n\tmutex_lock(&i8042_mutex);\n}\nEXPORT_SYMBOL(i8042_lock_chip);\n\nvoid i8042_unlock_chip(void)\n{\n\tmutex_unlock(&i8042_mutex);\n}\nEXPORT_SYMBOL(i8042_unlock_chip);\n\nint i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,\n\t\t\t\t\tstruct serio *serio))\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tif (i8042_platform_filter) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\ti8042_platform_filter = filter;\n\nout:\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(i8042_install_filter);\n\nint i8042_remove_filter(bool (*filter)(unsigned char data, unsigned char str,\n\t\t\t\t       struct serio *port))\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tif (i8042_platform_filter != filter) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ti8042_platform_filter = NULL;\n\nout:\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(i8042_remove_filter);\n\n/*\n * The i8042_wait_read() and i8042_wait_write functions wait for the i8042 to\n * be ready for reading values from it / writing values to it.\n * Called always with i8042_lock held.\n */\n\nstatic int i8042_wait_read(void)\n{\n\tint i = 0;\n\n\twhile ((~i8042_read_status() & I8042_STR_OBF) && (i < I8042_CTL_TIMEOUT)) {\n\t\tudelay(50);\n\t\ti++;\n\t}\n\treturn -(i == I8042_CTL_TIMEOUT);\n}\n\nstatic int i8042_wait_write(void)\n{\n\tint i = 0;\n\n\twhile ((i8042_read_status() & I8042_STR_IBF) && (i < I8042_CTL_TIMEOUT)) {\n\t\tudelay(50);\n\t\ti++;\n\t}\n\treturn -(i == I8042_CTL_TIMEOUT);\n}\n\n/*\n * i8042_flush() flushes all data that may be in the keyboard and mouse buffers\n * of the i8042 down the toilet.\n */\n\nstatic int i8042_flush(void)\n{\n\tunsigned long flags;\n\tunsigned char data, str;\n\tint count = 0;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\twhile ((str = i8042_read_status()) & I8042_STR_OBF) {\n\t\tif (count++ < I8042_BUFFER_SIZE) {\n\t\t\tudelay(50);\n\t\t\tdata = i8042_read_data();\n\t\t\tdbg(\"%02x <- i8042 (flush, %s)\\n\",\n\t\t\t    data, str & I8042_STR_AUXDATA ? \"aux\" : \"kbd\");\n\t\t} else {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\treturn retval;\n}\n\n/*\n * i8042_command() executes a command on the i8042. It also sends the input\n * parameter(s) of the commands to it, and receives the output value(s). The\n * parameters are to be stored in the param array, and the output is placed\n * into the same array. The number of the parameters and output values is\n * encoded in bits 8-11 of the command number.\n */\n\nstatic int __i8042_command(unsigned char *param, int command)\n{\n\tint i, error;\n\n\tif (i8042_noloop && command == I8042_CMD_AUX_LOOP)\n\t\treturn -1;\n\n\terror = i8042_wait_write();\n\tif (error)\n\t\treturn error;\n\n\tdbg(\"%02x -> i8042 (command)\\n\", command & 0xff);\n\ti8042_write_command(command & 0xff);\n\n\tfor (i = 0; i < ((command >> 12) & 0xf); i++) {\n\t\terror = i8042_wait_write();\n\t\tif (error) {\n\t\t\tdbg(\"     -- i8042 (wait write timeout)\\n\");\n\t\t\treturn error;\n\t\t}\n\t\tdbg(\"%02x -> i8042 (parameter)\\n\", param[i]);\n\t\ti8042_write_data(param[i]);\n\t}\n\n\tfor (i = 0; i < ((command >> 8) & 0xf); i++) {\n\t\terror = i8042_wait_read();\n\t\tif (error) {\n\t\t\tdbg(\"     -- i8042 (wait read timeout)\\n\");\n\t\t\treturn error;\n\t\t}\n\n\t\tif (command == I8042_CMD_AUX_LOOP &&\n\t\t    !(i8042_read_status() & I8042_STR_AUXDATA)) {\n\t\t\tdbg(\"     -- i8042 (auxerr)\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tparam[i] = i8042_read_data();\n\t\tdbg(\"%02x <- i8042 (return)\\n\", param[i]);\n\t}\n\n\treturn 0;\n}\n\nint i8042_command(unsigned char *param, int command)\n{\n\tunsigned long flags;\n\tint retval;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\tretval = __i8042_command(param, command);\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(i8042_command);\n\n/*\n * i8042_kbd_write() sends a byte out through the keyboard interface.\n */\n\nstatic int i8042_kbd_write(struct serio *port, unsigned char c)\n{\n\tunsigned long flags;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tif (!(retval = i8042_wait_write())) {\n\t\tdbg(\"%02x -> i8042 (kbd-data)\\n\", c);\n\t\ti8042_write_data(c);\n\t}\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\treturn retval;\n}\n\n/*\n * i8042_aux_write() sends a byte out through the aux interface.\n */\n\nstatic int i8042_aux_write(struct serio *serio, unsigned char c)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\treturn i8042_command(&c, port->mux == -1 ?\n\t\t\t\t\tI8042_CMD_AUX_SEND :\n\t\t\t\t\tI8042_CMD_MUX_SEND + port->mux);\n}\n\n\n/*\n * i8042_port_close attempts to clear AUX or KBD port state by disabling\n * and then re-enabling it.\n */\n\nstatic void i8042_port_close(struct serio *serio)\n{\n\tint irq_bit;\n\tint disable_bit;\n\tconst char *port_name;\n\n\tif (serio == i8042_ports[I8042_AUX_PORT_NO].serio) {\n\t\tirq_bit = I8042_CTR_AUXINT;\n\t\tdisable_bit = I8042_CTR_AUXDIS;\n\t\tport_name = \"AUX\";\n\t} else {\n\t\tirq_bit = I8042_CTR_KBDINT;\n\t\tdisable_bit = I8042_CTR_KBDDIS;\n\t\tport_name = \"KBD\";\n\t}\n\n\ti8042_ctr &= ~irq_bit;\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\n\t\tpr_warn(\"Can't write CTR while closing %s port\\n\", port_name);\n\n\tudelay(50);\n\n\ti8042_ctr &= ~disable_bit;\n\ti8042_ctr |= irq_bit;\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\n\t\tpr_err(\"Can't reactivate %s port\\n\", port_name);\n\n\t/*\n\t * See if there is any data appeared while we were messing with\n\t * port state.\n\t */\n\ti8042_interrupt(0, NULL);\n}\n\n/*\n * i8042_start() is called by serio core when port is about to finish\n * registering. It will mark port as existing so i8042_interrupt can\n * start sending data through it.\n */\nstatic int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tport->exists = true;\n\tmb();\n\treturn 0;\n}\n\n/*\n * i8042_stop() marks serio port as non-existing so i8042_interrupt\n * will not try to send data to the port that is about to go away.\n * The function is called by serio core as part of unregister procedure.\n */\nstatic void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tport->exists = false;\n\n\t/*\n\t * We synchronize with both AUX and KBD IRQs because there is\n\t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n\t * and vice versa.\n\t */\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n\tport->serio = NULL;\n}\n\n/*\n * i8042_filter() filters out unwanted bytes from the input data stream.\n * It is called from i8042_interrupt and thus is running with interrupts\n * off and i8042_lock held.\n */\nstatic bool i8042_filter(unsigned char data, unsigned char str,\n\t\t\t struct serio *serio)\n{\n\tif (unlikely(i8042_suppress_kbd_ack)) {\n\t\tif ((~str & I8042_STR_AUXDATA) &&\n\t\t    (data == 0xfa || data == 0xfe)) {\n\t\t\ti8042_suppress_kbd_ack--;\n\t\t\tdbg(\"Extra keyboard ACK - filtered out\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (i8042_platform_filter && i8042_platform_filter(data, str, serio)) {\n\t\tdbg(\"Filtered out by platform filter\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * i8042_interrupt() is the most important function in this driver -\n * it handles the interrupts from the i8042, and sends incoming bytes\n * to the upper layers.\n */\n\nstatic irqreturn_t i8042_interrupt(int irq, void *dev_id)\n{\n\tstruct i8042_port *port;\n\tstruct serio *serio;\n\tunsigned long flags;\n\tunsigned char str, data;\n\tunsigned int dfl;\n\tunsigned int port_no;\n\tbool filtered;\n\tint ret = 1;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tstr = i8042_read_status();\n\tif (unlikely(~str & I8042_STR_OBF)) {\n\t\tspin_unlock_irqrestore(&i8042_lock, flags);\n\t\tif (irq)\n\t\t\tdbg(\"Interrupt %d, without any data\\n\", irq);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdata = i8042_read_data();\n\n\tif (i8042_mux_present && (str & I8042_STR_AUXDATA)) {\n\t\tstatic unsigned long last_transmit;\n\t\tstatic unsigned char last_str;\n\n\t\tdfl = 0;\n\t\tif (str & I8042_STR_MUXERR) {\n\t\t\tdbg(\"MUX error, status is %02x, data is %02x\\n\",\n\t\t\t    str, data);\n/*\n * When MUXERR condition is signalled the data register can only contain\n * 0xfd, 0xfe or 0xff if implementation follows the spec. Unfortunately\n * it is not always the case. Some KBCs also report 0xfc when there is\n * nothing connected to the port while others sometimes get confused which\n * port the data came from and signal error leaving the data intact. They\n * _do not_ revert to legacy mode (actually I've never seen KBC reverting\n * to legacy mode yet, when we see one we'll add proper handling).\n * Anyway, we process 0xfc, 0xfd, 0xfe and 0xff as timeouts, and for the\n * rest assume that the data came from the same serio last byte\n * was transmitted (if transmission happened not too long ago).\n */\n\n\t\t\tswitch (data) {\n\t\t\t\tdefault:\n\t\t\t\t\tif (time_before(jiffies, last_transmit + HZ/10)) {\n\t\t\t\t\t\tstr = last_str;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* fall through - report timeout */\n\t\t\t\tcase 0xfc:\n\t\t\t\tcase 0xfd:\n\t\t\t\tcase 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break;\n\t\t\t\tcase 0xff: dfl = SERIO_PARITY;  data = 0xfe; break;\n\t\t\t}\n\t\t}\n\n\t\tport_no = I8042_MUX_PORT_NO + ((str >> 6) & 3);\n\t\tlast_str = str;\n\t\tlast_transmit = jiffies;\n\t} else {\n\n\t\tdfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |\n\t\t      ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);\n\n\t\tport_no = (str & I8042_STR_AUXDATA) ?\n\t\t\t\tI8042_AUX_PORT_NO : I8042_KBD_PORT_NO;\n\t}\n\n\tport = &i8042_ports[port_no];\n\tserio = port->exists ? port->serio : NULL;\n\n\tfilter_dbg(port->driver_bound, data, \"<- i8042 (interrupt, %d, %d%s%s)\\n\",\n\t\t   port_no, irq,\n\t\t   dfl & SERIO_PARITY ? \", bad parity\" : \"\",\n\t\t   dfl & SERIO_TIMEOUT ? \", timeout\" : \"\");\n\n\tfiltered = i8042_filter(data, str, serio);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (likely(port->exists && !filtered))\n\t\tserio_interrupt(serio, data, dfl);\n\n out:\n\treturn IRQ_RETVAL(ret);\n}\n\n/*\n * i8042_enable_kbd_port enables keyboard port on chip\n */\n\nstatic int i8042_enable_kbd_port(void)\n{\n\ti8042_ctr &= ~I8042_CTR_KBDDIS;\n\ti8042_ctr |= I8042_CTR_KBDINT;\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\ti8042_ctr &= ~I8042_CTR_KBDINT;\n\t\ti8042_ctr |= I8042_CTR_KBDDIS;\n\t\tpr_err(\"Failed to enable KBD port\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n/*\n * i8042_enable_aux_port enables AUX (mouse) port on chip\n */\n\nstatic int i8042_enable_aux_port(void)\n{\n\ti8042_ctr &= ~I8042_CTR_AUXDIS;\n\ti8042_ctr |= I8042_CTR_AUXINT;\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\ti8042_ctr &= ~I8042_CTR_AUXINT;\n\t\ti8042_ctr |= I8042_CTR_AUXDIS;\n\t\tpr_err(\"Failed to enable AUX port\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n/*\n * i8042_enable_mux_ports enables 4 individual AUX ports after\n * the controller has been switched into Multiplexed mode\n */\n\nstatic int i8042_enable_mux_ports(void)\n{\n\tunsigned char param;\n\tint i;\n\n\tfor (i = 0; i < I8042_NUM_MUX_PORTS; i++) {\n\t\ti8042_command(&param, I8042_CMD_MUX_PFX + i);\n\t\ti8042_command(&param, I8042_CMD_AUX_ENABLE);\n\t}\n\n\treturn i8042_enable_aux_port();\n}\n\n/*\n * i8042_set_mux_mode checks whether the controller has an\n * active multiplexor and puts the chip into Multiplexed (true)\n * or Legacy (false) mode.\n */\n\nstatic int i8042_set_mux_mode(bool multiplex, unsigned char *mux_version)\n{\n\n\tunsigned char param, val;\n/*\n * Get rid of bytes in the queue.\n */\n\n\ti8042_flush();\n\n/*\n * Internal loopback test - send three bytes, they should come back from the\n * mouse interface, the last should be version.\n */\n\n\tparam = val = 0xf0;\n\tif (i8042_command(&param, I8042_CMD_AUX_LOOP) || param != val)\n\t\treturn -1;\n\tparam = val = multiplex ? 0x56 : 0xf6;\n\tif (i8042_command(&param, I8042_CMD_AUX_LOOP) || param != val)\n\t\treturn -1;\n\tparam = val = multiplex ? 0xa4 : 0xa5;\n\tif (i8042_command(&param, I8042_CMD_AUX_LOOP) || param == val)\n\t\treturn -1;\n\n/*\n * Workaround for interference with USB Legacy emulation\n * that causes a v10.12 MUX to be found.\n */\n\tif (param == 0xac)\n\t\treturn -1;\n\n\tif (mux_version)\n\t\t*mux_version = param;\n\n\treturn 0;\n}\n\n/*\n * i8042_check_mux() checks whether the controller supports the PS/2 Active\n * Multiplexing specification by Synaptics, Phoenix, Insyde and\n * LCS/Telegraphics.\n */\n\nstatic int __init i8042_check_mux(void)\n{\n\tunsigned char mux_version;\n\n\tif (i8042_set_mux_mode(true, &mux_version))\n\t\treturn -1;\n\n\tpr_info(\"Detected active multiplexing controller, rev %d.%d\\n\",\n\t\t(mux_version >> 4) & 0xf, mux_version & 0xf);\n\n/*\n * Disable all muxed ports by disabling AUX.\n */\n\ti8042_ctr |= I8042_CTR_AUXDIS;\n\ti8042_ctr &= ~I8042_CTR_AUXINT;\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\tpr_err(\"Failed to disable AUX port, can't use MUX\\n\");\n\t\treturn -EIO;\n\t}\n\n\ti8042_mux_present = true;\n\n\treturn 0;\n}\n\n/*\n * The following is used to test AUX IRQ delivery.\n */\nstatic struct completion i8042_aux_irq_delivered __initdata;\nstatic bool i8042_irq_being_tested __initdata;\n\nstatic irqreturn_t __init i8042_aux_test_irq(int irq, void *dev_id)\n{\n\tunsigned long flags;\n\tunsigned char str, data;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\tstr = i8042_read_status();\n\tif (str & I8042_STR_OBF) {\n\t\tdata = i8042_read_data();\n\t\tdbg(\"%02x <- i8042 (aux_test_irq, %s)\\n\",\n\t\t    data, str & I8042_STR_AUXDATA ? \"aux\" : \"kbd\");\n\t\tif (i8042_irq_being_tested &&\n\t\t    data == 0xa5 && (str & I8042_STR_AUXDATA))\n\t\t\tcomplete(&i8042_aux_irq_delivered);\n\t\tret = 1;\n\t}\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\treturn IRQ_RETVAL(ret);\n}\n\n/*\n * i8042_toggle_aux - enables or disables AUX port on i8042 via command and\n * verifies success by readinng CTR. Used when testing for presence of AUX\n * port.\n */\nstatic int __init i8042_toggle_aux(bool on)\n{\n\tunsigned char param;\n\tint i;\n\n\tif (i8042_command(&param,\n\t\t\ton ? I8042_CMD_AUX_ENABLE : I8042_CMD_AUX_DISABLE))\n\t\treturn -1;\n\n\t/* some chips need some time to set the I8042_CTR_AUXDIS bit */\n\tfor (i = 0; i < 100; i++) {\n\t\tudelay(50);\n\n\t\tif (i8042_command(&param, I8042_CMD_CTL_RCTR))\n\t\t\treturn -1;\n\n\t\tif (!(param & I8042_CTR_AUXDIS) == on)\n\t\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\n/*\n * i8042_check_aux() applies as much paranoia as it can at detecting\n * the presence of an AUX interface.\n */\n\nstatic int __init i8042_check_aux(void)\n{\n\tint retval = -1;\n\tbool irq_registered = false;\n\tbool aux_loop_broken = false;\n\tunsigned long flags;\n\tunsigned char param;\n\n/*\n * Get rid of bytes in the queue.\n */\n\n\ti8042_flush();\n\n/*\n * Internal loopback test - filters out AT-type i8042's. Unfortunately\n * SiS screwed up and their 5597 doesn't support the LOOP command even\n * though it has an AUX port.\n */\n\n\tparam = 0x5a;\n\tretval = i8042_command(&param, I8042_CMD_AUX_LOOP);\n\tif (retval || param != 0x5a) {\n\n/*\n * External connection test - filters out AT-soldered PS/2 i8042's\n * 0x00 - no error, 0x01-0x03 - clock/data stuck, 0xff - general error\n * 0xfa - no error on some notebooks which ignore the spec\n * Because it's common for chipsets to return error on perfectly functioning\n * AUX ports, we test for this only when the LOOP command failed.\n */\n\n\t\tif (i8042_command(&param, I8042_CMD_AUX_TEST) ||\n\t\t    (param && param != 0xfa && param != 0xff))\n\t\t\treturn -1;\n\n/*\n * If AUX_LOOP completed without error but returned unexpected data\n * mark it as broken\n */\n\t\tif (!retval)\n\t\t\taux_loop_broken = true;\n\t}\n\n/*\n * Bit assignment test - filters out PS/2 i8042's in AT mode\n */\n\n\tif (i8042_toggle_aux(false)) {\n\t\tpr_warn(\"Failed to disable AUX port, but continuing anyway... Is this a SiS?\\n\");\n\t\tpr_warn(\"If AUX port is really absent please use the 'i8042.noaux' option\\n\");\n\t}\n\n\tif (i8042_toggle_aux(true))\n\t\treturn -1;\n\n/*\n * Reset keyboard (needed on some laptops to successfully detect\n * touchpad, e.g., some Gigabyte laptop models with Elantech\n * touchpads).\n */\n\tif (i8042_kbdreset) {\n\t\tpr_warn(\"Attempting to reset device connected to KBD port\\n\");\n\t\ti8042_kbd_write(NULL, (unsigned char) 0xff);\n\t}\n\n/*\n * Test AUX IRQ delivery to make sure BIOS did not grab the IRQ and\n * used it for a PCI card or somethig else.\n */\n\n\tif (i8042_noloop || i8042_bypass_aux_irq_test || aux_loop_broken) {\n/*\n * Without LOOP command we can't test AUX IRQ delivery. Assume the port\n * is working and hope we are right.\n */\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\n\tif (request_irq(I8042_AUX_IRQ, i8042_aux_test_irq, IRQF_SHARED,\n\t\t\t\"i8042\", i8042_platform_device))\n\t\tgoto out;\n\n\tirq_registered = true;\n\n\tif (i8042_enable_aux_port())\n\t\tgoto out;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tinit_completion(&i8042_aux_irq_delivered);\n\ti8042_irq_being_tested = true;\n\n\tparam = 0xa5;\n\tretval = __i8042_command(&param, I8042_CMD_AUX_LOOP & 0xf0ff);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (retval)\n\t\tgoto out;\n\n\tif (wait_for_completion_timeout(&i8042_aux_irq_delivered,\n\t\t\t\t\tmsecs_to_jiffies(250)) == 0) {\n/*\n * AUX IRQ was never delivered so we need to flush the controller to\n * get rid of the byte we put there; otherwise keyboard may not work.\n */\n\t\tdbg(\"     -- i8042 (aux irq test timeout)\\n\");\n\t\ti8042_flush();\n\t\tretval = -1;\n\t}\n\n out:\n\n/*\n * Disable the interface.\n */\n\n\ti8042_ctr |= I8042_CTR_AUXDIS;\n\ti8042_ctr &= ~I8042_CTR_AUXINT;\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\n\t\tretval = -1;\n\n\tif (irq_registered)\n\t\tfree_irq(I8042_AUX_IRQ, i8042_platform_device);\n\n\treturn retval;\n}\n\nstatic int i8042_controller_check(void)\n{\n\tif (i8042_flush()) {\n\t\tpr_info(\"No controller found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int i8042_controller_selftest(void)\n{\n\tunsigned char param;\n\tint i = 0;\n\n\t/*\n\t * We try this 5 times; on some really fragile systems this does not\n\t * take the first time...\n\t */\n\tdo {\n\n\t\tif (i8042_command(&param, I8042_CMD_CTL_TEST)) {\n\t\t\tpr_err(\"i8042 controller selftest timeout\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (param == I8042_RET_CTL_TEST)\n\t\t\treturn 0;\n\n\t\tdbg(\"i8042 controller selftest: %#x != %#x\\n\",\n\t\t    param, I8042_RET_CTL_TEST);\n\t\tmsleep(50);\n\t} while (i++ < 5);\n\n#ifdef CONFIG_X86\n\t/*\n\t * On x86, we don't fail entire i8042 initialization if controller\n\t * reset fails in hopes that keyboard port will still be functional\n\t * and user will still get a working keyboard. This is especially\n\t * important on netbooks. On other arches we trust hardware more.\n\t */\n\tpr_info(\"giving up on controller selftest, continuing anyway...\\n\");\n\treturn 0;\n#else\n\tpr_err(\"i8042 controller selftest failed\\n\");\n\treturn -EIO;\n#endif\n}\n\n/*\n * i8042_controller init initializes the i8042 controller, and,\n * most importantly, sets it into non-xlated mode if that's\n * desired.\n */\n\nstatic int i8042_controller_init(void)\n{\n\tunsigned long flags;\n\tint n = 0;\n\tunsigned char ctr[2];\n\n/*\n * Save the CTR for restore on unload / reboot.\n */\n\n\tdo {\n\t\tif (n >= 10) {\n\t\t\tpr_err(\"Unable to get stable CTR read\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (n != 0)\n\t\t\tudelay(50);\n\n\t\tif (i8042_command(&ctr[n++ % 2], I8042_CMD_CTL_RCTR)) {\n\t\t\tpr_err(\"Can't read CTR while initializing i8042\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t} while (n < 2 || ctr[0] != ctr[1]);\n\n\ti8042_initial_ctr = i8042_ctr = ctr[0];\n\n/*\n * Disable the keyboard interface and interrupt.\n */\n\n\ti8042_ctr |= I8042_CTR_KBDDIS;\n\ti8042_ctr &= ~I8042_CTR_KBDINT;\n\n/*\n * Handle keylock.\n */\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\tif (~i8042_read_status() & I8042_STR_KEYLOCK) {\n\t\tif (i8042_unlock)\n\t\t\ti8042_ctr |= I8042_CTR_IGNKEYLOCK;\n\t\telse\n\t\t\tpr_warn(\"Warning: Keylock active\\n\");\n\t}\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n/*\n * If the chip is configured into nontranslated mode by the BIOS, don't\n * bother enabling translating and be happy.\n */\n\n\tif (~i8042_ctr & I8042_CTR_XLATE)\n\t\ti8042_direct = true;\n\n/*\n * Set nontranslated mode for the kbd interface if requested by an option.\n * After this the kbd interface becomes a simple serial in/out, like the aux\n * interface is. We don't do this by default, since it can confuse notebook\n * BIOSes.\n */\n\n\tif (i8042_direct)\n\t\ti8042_ctr &= ~I8042_CTR_XLATE;\n\n/*\n * Write CTR back.\n */\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\tpr_err(\"Can't write CTR while initializing i8042\\n\");\n\t\treturn -EIO;\n\t}\n\n/*\n * Flush whatever accumulated while we were disabling keyboard port.\n */\n\n\ti8042_flush();\n\n\treturn 0;\n}\n\n\n/*\n * Reset the controller and reset CRT to the original value set by BIOS.\n */\n\nstatic void i8042_controller_reset(bool s2r_wants_reset)\n{\n\ti8042_flush();\n\n/*\n * Disable both KBD and AUX interfaces so they don't get in the way\n */\n\n\ti8042_ctr |= I8042_CTR_KBDDIS | I8042_CTR_AUXDIS;\n\ti8042_ctr &= ~(I8042_CTR_KBDINT | I8042_CTR_AUXINT);\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\n\t\tpr_warn(\"Can't write CTR while resetting\\n\");\n\n/*\n * Disable MUX mode if present.\n */\n\n\tif (i8042_mux_present)\n\t\ti8042_set_mux_mode(false, NULL);\n\n/*\n * Reset the controller if requested.\n */\n\n\tif (i8042_reset == I8042_RESET_ALWAYS ||\n\t    (i8042_reset == I8042_RESET_ON_S2RAM && s2r_wants_reset)) {\n\t\ti8042_controller_selftest();\n\t}\n\n/*\n * Restore the original control register setting.\n */\n\n\tif (i8042_command(&i8042_initial_ctr, I8042_CMD_CTL_WCTR))\n\t\tpr_warn(\"Can't restore CTR\\n\");\n}\n\n\n/*\n * i8042_panic_blink() will turn the keyboard LEDs on or off and is called\n * when kernel panics. Flashing LEDs is useful for users running X who may\n * not see the console and will help distinguishing panics from \"real\"\n * lockups.\n *\n * Note that DELAY has a limit of 10ms so we will not get stuck here\n * waiting for KBC to free up even if KBD interrupt is off\n */\n\n#define DELAY do { mdelay(1); if (++delay > 10) return delay; } while(0)\n\nstatic long i8042_panic_blink(int state)\n{\n\tlong delay = 0;\n\tchar led;\n\n\tled = (state) ? 0x01 | 0x04 : 0;\n\twhile (i8042_read_status() & I8042_STR_IBF)\n\t\tDELAY;\n\tdbg(\"%02x -> i8042 (panic blink)\\n\", 0xed);\n\ti8042_suppress_kbd_ack = 2;\n\ti8042_write_data(0xed); /* set leds */\n\tDELAY;\n\twhile (i8042_read_status() & I8042_STR_IBF)\n\t\tDELAY;\n\tDELAY;\n\tdbg(\"%02x -> i8042 (panic blink)\\n\", led);\n\ti8042_write_data(led);\n\tDELAY;\n\treturn delay;\n}\n\n#undef DELAY\n\n#ifdef CONFIG_X86\nstatic void i8042_dritek_enable(void)\n{\n\tunsigned char param = 0x90;\n\tint error;\n\n\terror = i8042_command(&param, 0x1059);\n\tif (error)\n\t\tpr_warn(\"Failed to enable DRITEK extension: %d\\n\", error);\n}\n#endif\n\n#ifdef CONFIG_PM\n\n/*\n * Here we try to reset everything back to a state we had\n * before suspending.\n */\n\nstatic int i8042_controller_resume(bool s2r_wants_reset)\n{\n\tint error;\n\n\terror = i8042_controller_check();\n\tif (error)\n\t\treturn error;\n\n\tif (i8042_reset == I8042_RESET_ALWAYS ||\n\t    (i8042_reset == I8042_RESET_ON_S2RAM && s2r_wants_reset)) {\n\t\terror = i8042_controller_selftest();\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n/*\n * Restore original CTR value and disable all ports\n */\n\n\ti8042_ctr = i8042_initial_ctr;\n\tif (i8042_direct)\n\t\ti8042_ctr &= ~I8042_CTR_XLATE;\n\ti8042_ctr |= I8042_CTR_AUXDIS | I8042_CTR_KBDDIS;\n\ti8042_ctr &= ~(I8042_CTR_AUXINT | I8042_CTR_KBDINT);\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\tpr_warn(\"Can't write CTR to resume, retrying...\\n\");\n\t\tmsleep(50);\n\t\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\t\tpr_err(\"CTR write retry failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\n#ifdef CONFIG_X86\n\tif (i8042_dritek)\n\t\ti8042_dritek_enable();\n#endif\n\n\tif (i8042_mux_present) {\n\t\tif (i8042_set_mux_mode(true, NULL) || i8042_enable_mux_ports())\n\t\t\tpr_warn(\"failed to resume active multiplexor, mouse won't work\\n\");\n\t} else if (i8042_ports[I8042_AUX_PORT_NO].serio)\n\t\ti8042_enable_aux_port();\n\n\tif (i8042_ports[I8042_KBD_PORT_NO].serio)\n\t\ti8042_enable_kbd_port();\n\n\ti8042_interrupt(0, NULL);\n\n\treturn 0;\n}\n\n/*\n * Here we try to restore the original BIOS settings to avoid\n * upsetting it.\n */\n\nstatic int i8042_pm_suspend(struct device *dev)\n{\n\tint i;\n\n\tif (pm_suspend_via_firmware())\n\t\ti8042_controller_reset(true);\n\n\t/* Set up serio interrupts for system wakeup. */\n\tfor (i = 0; i < I8042_NUM_PORTS; i++) {\n\t\tstruct serio *serio = i8042_ports[i].serio;\n\n\t\tif (serio && device_may_wakeup(&serio->dev))\n\t\t\tenable_irq_wake(i8042_ports[i].irq);\n\t}\n\n\treturn 0;\n}\n\nstatic int i8042_pm_resume_noirq(struct device *dev)\n{\n\tif (!pm_resume_via_firmware())\n\t\ti8042_interrupt(0, NULL);\n\n\treturn 0;\n}\n\nstatic int i8042_pm_resume(struct device *dev)\n{\n\tbool want_reset;\n\tint i;\n\n\tfor (i = 0; i < I8042_NUM_PORTS; i++) {\n\t\tstruct serio *serio = i8042_ports[i].serio;\n\n\t\tif (serio && device_may_wakeup(&serio->dev))\n\t\t\tdisable_irq_wake(i8042_ports[i].irq);\n\t}\n\n\t/*\n\t * If platform firmware was not going to be involved in suspend, we did\n\t * not restore the controller state to whatever it had been at boot\n\t * time, so we do not need to do anything.\n\t */\n\tif (!pm_suspend_via_firmware())\n\t\treturn 0;\n\n\t/*\n\t * We only need to reset the controller if we are resuming after handing\n\t * off control to the platform firmware, otherwise we can simply restore\n\t * the mode.\n\t */\n\twant_reset = pm_resume_via_firmware();\n\n\treturn i8042_controller_resume(want_reset);\n}\n\nstatic int i8042_pm_thaw(struct device *dev)\n{\n\ti8042_interrupt(0, NULL);\n\n\treturn 0;\n}\n\nstatic int i8042_pm_reset(struct device *dev)\n{\n\ti8042_controller_reset(false);\n\n\treturn 0;\n}\n\nstatic int i8042_pm_restore(struct device *dev)\n{\n\treturn i8042_controller_resume(false);\n}\n\nstatic const struct dev_pm_ops i8042_pm_ops = {\n\t.suspend\t= i8042_pm_suspend,\n\t.resume_noirq\t= i8042_pm_resume_noirq,\n\t.resume\t\t= i8042_pm_resume,\n\t.thaw\t\t= i8042_pm_thaw,\n\t.poweroff\t= i8042_pm_reset,\n\t.restore\t= i8042_pm_restore,\n};\n\n#endif /* CONFIG_PM */\n\n/*\n * We need to reset the 8042 back to original mode on system shutdown,\n * because otherwise BIOSes will be confused.\n */\n\nstatic void i8042_shutdown(struct platform_device *dev)\n{\n\ti8042_controller_reset(false);\n}\n\nstatic int __init i8042_create_kbd_port(void)\n{\n\tstruct serio *serio;\n\tstruct i8042_port *port = &i8042_ports[I8042_KBD_PORT_NO];\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tserio->id.type\t\t= i8042_direct ? SERIO_8042 : SERIO_8042_XL;\n\tserio->write\t\t= i8042_dumbkbd ? NULL : i8042_kbd_write;\n\tserio->start\t\t= i8042_start;\n\tserio->stop\t\t= i8042_stop;\n\tserio->close\t\t= i8042_port_close;\n\tserio->ps2_cmd_mutex\t= &i8042_mutex;\n\tserio->port_data\t= port;\n\tserio->dev.parent\t= &i8042_platform_device->dev;\n\tstrlcpy(serio->name, \"i8042 KBD port\", sizeof(serio->name));\n\tstrlcpy(serio->phys, I8042_KBD_PHYS_DESC, sizeof(serio->phys));\n\tstrlcpy(serio->firmware_id, i8042_kbd_firmware_id,\n\t\tsizeof(serio->firmware_id));\n\n\tport->serio = serio;\n\tport->irq = I8042_KBD_IRQ;\n\n\treturn 0;\n}\n\nstatic int __init i8042_create_aux_port(int idx)\n{\n\tstruct serio *serio;\n\tint port_no = idx < 0 ? I8042_AUX_PORT_NO : I8042_MUX_PORT_NO + idx;\n\tstruct i8042_port *port = &i8042_ports[port_no];\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tserio->id.type\t\t= SERIO_8042;\n\tserio->write\t\t= i8042_aux_write;\n\tserio->start\t\t= i8042_start;\n\tserio->stop\t\t= i8042_stop;\n\tserio->ps2_cmd_mutex\t= &i8042_mutex;\n\tserio->port_data\t= port;\n\tserio->dev.parent\t= &i8042_platform_device->dev;\n\tif (idx < 0) {\n\t\tstrlcpy(serio->name, \"i8042 AUX port\", sizeof(serio->name));\n\t\tstrlcpy(serio->phys, I8042_AUX_PHYS_DESC, sizeof(serio->phys));\n\t\tstrlcpy(serio->firmware_id, i8042_aux_firmware_id,\n\t\t\tsizeof(serio->firmware_id));\n\t\tserio->close = i8042_port_close;\n\t} else {\n\t\tsnprintf(serio->name, sizeof(serio->name), \"i8042 AUX%d port\", idx);\n\t\tsnprintf(serio->phys, sizeof(serio->phys), I8042_MUX_PHYS_DESC, idx + 1);\n\t\tstrlcpy(serio->firmware_id, i8042_aux_firmware_id,\n\t\t\tsizeof(serio->firmware_id));\n\t}\n\n\tport->serio = serio;\n\tport->mux = idx;\n\tport->irq = I8042_AUX_IRQ;\n\n\treturn 0;\n}\n\nstatic void __init i8042_free_kbd_port(void)\n{\n\tkfree(i8042_ports[I8042_KBD_PORT_NO].serio);\n\ti8042_ports[I8042_KBD_PORT_NO].serio = NULL;\n}\n\nstatic void __init i8042_free_aux_ports(void)\n{\n\tint i;\n\n\tfor (i = I8042_AUX_PORT_NO; i < I8042_NUM_PORTS; i++) {\n\t\tkfree(i8042_ports[i].serio);\n\t\ti8042_ports[i].serio = NULL;\n\t}\n}\n\nstatic void __init i8042_register_ports(void)\n{\n\tint i;\n\n\tfor (i = 0; i < I8042_NUM_PORTS; i++) {\n\t\tstruct serio *serio = i8042_ports[i].serio;\n\n\t\tif (serio) {\n\t\t\tprintk(KERN_INFO \"serio: %s at %#lx,%#lx irq %d\\n\",\n\t\t\t\tserio->name,\n\t\t\t\t(unsigned long) I8042_DATA_REG,\n\t\t\t\t(unsigned long) I8042_COMMAND_REG,\n\t\t\t\ti8042_ports[i].irq);\n\t\t\tserio_register_port(serio);\n\t\t\tdevice_set_wakeup_capable(&serio->dev, true);\n\t\t}\n\t}\n}\n\nstatic void i8042_unregister_ports(void)\n{\n\tint i;\n\n\tfor (i = 0; i < I8042_NUM_PORTS; i++) {\n\t\tif (i8042_ports[i].serio) {\n\t\t\tserio_unregister_port(i8042_ports[i].serio);\n\t\t\ti8042_ports[i].serio = NULL;\n\t\t}\n\t}\n}\n\nstatic void i8042_free_irqs(void)\n{\n\tif (i8042_aux_irq_registered)\n\t\tfree_irq(I8042_AUX_IRQ, i8042_platform_device);\n\tif (i8042_kbd_irq_registered)\n\t\tfree_irq(I8042_KBD_IRQ, i8042_platform_device);\n\n\ti8042_aux_irq_registered = i8042_kbd_irq_registered = false;\n}\n\nstatic int __init i8042_setup_aux(void)\n{\n\tint (*aux_enable)(void);\n\tint error;\n\tint i;\n\n\tif (i8042_check_aux())\n\t\treturn -ENODEV;\n\n\tif (i8042_nomux || i8042_check_mux()) {\n\t\terror = i8042_create_aux_port(-1);\n\t\tif (error)\n\t\t\tgoto err_free_ports;\n\t\taux_enable = i8042_enable_aux_port;\n\t} else {\n\t\tfor (i = 0; i < I8042_NUM_MUX_PORTS; i++) {\n\t\t\terror = i8042_create_aux_port(i);\n\t\t\tif (error)\n\t\t\t\tgoto err_free_ports;\n\t\t}\n\t\taux_enable = i8042_enable_mux_ports;\n\t}\n\n\terror = request_irq(I8042_AUX_IRQ, i8042_interrupt, IRQF_SHARED,\n\t\t\t    \"i8042\", i8042_platform_device);\n\tif (error)\n\t\tgoto err_free_ports;\n\n\tif (aux_enable())\n\t\tgoto err_free_irq;\n\n\ti8042_aux_irq_registered = true;\n\treturn 0;\n\n err_free_irq:\n\tfree_irq(I8042_AUX_IRQ, i8042_platform_device);\n err_free_ports:\n\ti8042_free_aux_ports();\n\treturn error;\n}\n\nstatic int __init i8042_setup_kbd(void)\n{\n\tint error;\n\n\terror = i8042_create_kbd_port();\n\tif (error)\n\t\treturn error;\n\n\terror = request_irq(I8042_KBD_IRQ, i8042_interrupt, IRQF_SHARED,\n\t\t\t    \"i8042\", i8042_platform_device);\n\tif (error)\n\t\tgoto err_free_port;\n\n\terror = i8042_enable_kbd_port();\n\tif (error)\n\t\tgoto err_free_irq;\n\n\ti8042_kbd_irq_registered = true;\n\treturn 0;\n\n err_free_irq:\n\tfree_irq(I8042_KBD_IRQ, i8042_platform_device);\n err_free_port:\n\ti8042_free_kbd_port();\n\treturn error;\n}\n\nstatic int i8042_kbd_bind_notifier(struct notifier_block *nb,\n\t\t\t\t   unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tstruct serio *serio = to_serio_port(dev);\n\tstruct i8042_port *port = serio->port_data;\n\n\tif (serio != i8042_ports[I8042_KBD_PORT_NO].serio)\n\t\treturn 0;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_BOUND_DRIVER:\n\t\tport->driver_bound = true;\n\t\tbreak;\n\n\tcase BUS_NOTIFY_UNBIND_DRIVER:\n\t\tport->driver_bound = false;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init i8042_probe(struct platform_device *dev)\n{\n\tint error;\n\n\ti8042_platform_device = dev;\n\n\tif (i8042_reset == I8042_RESET_ALWAYS) {\n\t\terror = i8042_controller_selftest();\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = i8042_controller_init();\n\tif (error)\n\t\treturn error;\n\n#ifdef CONFIG_X86\n\tif (i8042_dritek)\n\t\ti8042_dritek_enable();\n#endif\n\n\tif (!i8042_noaux) {\n\t\terror = i8042_setup_aux();\n\t\tif (error && error != -ENODEV && error != -EBUSY)\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!i8042_nokbd) {\n\t\terror = i8042_setup_kbd();\n\t\tif (error)\n\t\t\tgoto out_fail;\n\t}\n/*\n * Ok, everything is ready, let's register all serio ports\n */\n\ti8042_register_ports();\n\n\treturn 0;\n\n out_fail:\n\ti8042_free_aux_ports();\t/* in case KBD failed but AUX not */\n\ti8042_free_irqs();\n\ti8042_controller_reset(false);\n\ti8042_platform_device = NULL;\n\n\treturn error;\n}\n\nstatic int i8042_remove(struct platform_device *dev)\n{\n\ti8042_unregister_ports();\n\ti8042_free_irqs();\n\ti8042_controller_reset(false);\n\ti8042_platform_device = NULL;\n\n\treturn 0;\n}\n\nstatic struct platform_driver i8042_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"i8042\",\n#ifdef CONFIG_PM\n\t\t.pm\t= &i8042_pm_ops,\n#endif\n\t},\n\t.remove\t\t= i8042_remove,\n\t.shutdown\t= i8042_shutdown,\n};\n\nstatic struct notifier_block i8042_kbd_bind_notifier_block = {\n\t.notifier_call = i8042_kbd_bind_notifier,\n};\n\nstatic int __init i8042_init(void)\n{\n\tstruct platform_device *pdev;\n\tint err;\n\n\tdbg_init();\n\n\terr = i8042_platform_init();\n\tif (err)\n\t\treturn err;\n\n\terr = i8042_controller_check();\n\tif (err)\n\t\tgoto err_platform_exit;\n\n\tpdev = platform_create_bundle(&i8042_driver, i8042_probe, NULL, 0, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\terr = PTR_ERR(pdev);\n\t\tgoto err_platform_exit;\n\t}\n\n\tbus_register_notifier(&serio_bus, &i8042_kbd_bind_notifier_block);\n\tpanic_blink = i8042_panic_blink;\n\n\treturn 0;\n\n err_platform_exit:\n\ti8042_platform_exit();\n\treturn err;\n}\n\nstatic void __exit i8042_exit(void)\n{\n\tplatform_device_unregister(i8042_platform_device);\n\tplatform_driver_unregister(&i8042_driver);\n\ti8042_platform_exit();\n\n\tbus_unregister_notifier(&serio_bus, &i8042_kbd_bind_notifier_block);\n\tpanic_blink = NULL;\n}\n\nmodule_init(i8042_init);\nmodule_exit(i8042_exit);\n"], "fixing_code": ["/*\n *  i8042 keyboard and mouse controller driver for Linux\n *\n *  Copyright (c) 1999-2004 Vojtech Pavlik\n */\n\n/*\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 as published by\n * the Free Software Foundation.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/serio.h>\n#include <linux/err.h>\n#include <linux/rcupdate.h>\n#include <linux/platform_device.h>\n#include <linux/i8042.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n\n#include <asm/io.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"i8042 keyboard and mouse controller driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool i8042_nokbd;\nmodule_param_named(nokbd, i8042_nokbd, bool, 0);\nMODULE_PARM_DESC(nokbd, \"Do not probe or use KBD port.\");\n\nstatic bool i8042_noaux;\nmodule_param_named(noaux, i8042_noaux, bool, 0);\nMODULE_PARM_DESC(noaux, \"Do not probe or use AUX (mouse) port.\");\n\nstatic bool i8042_nomux;\nmodule_param_named(nomux, i8042_nomux, bool, 0);\nMODULE_PARM_DESC(nomux, \"Do not check whether an active multiplexing controller is present.\");\n\nstatic bool i8042_unlock;\nmodule_param_named(unlock, i8042_unlock, bool, 0);\nMODULE_PARM_DESC(unlock, \"Ignore keyboard lock.\");\n\nenum i8042_controller_reset_mode {\n\tI8042_RESET_NEVER,\n\tI8042_RESET_ALWAYS,\n\tI8042_RESET_ON_S2RAM,\n#define I8042_RESET_DEFAULT\tI8042_RESET_ON_S2RAM\n};\nstatic enum i8042_controller_reset_mode i8042_reset = I8042_RESET_DEFAULT;\nstatic int i8042_set_reset(const char *val, const struct kernel_param *kp)\n{\n\tenum i8042_controller_reset_mode *arg = kp->arg;\n\tint error;\n\tbool reset;\n\n\tif (val) {\n\t\terror = kstrtobool(val, &reset);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\treset = true;\n\t}\n\n\t*arg = reset ? I8042_RESET_ALWAYS : I8042_RESET_NEVER;\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops param_ops_reset_param = {\n\t.flags = KERNEL_PARAM_OPS_FL_NOARG,\n\t.set = i8042_set_reset,\n};\n#define param_check_reset_param(name, p)\t\\\n\t__param_check(name, p, enum i8042_controller_reset_mode)\nmodule_param_named(reset, i8042_reset, reset_param, 0);\nMODULE_PARM_DESC(reset, \"Reset controller on resume, cleanup or both\");\n\nstatic bool i8042_direct;\nmodule_param_named(direct, i8042_direct, bool, 0);\nMODULE_PARM_DESC(direct, \"Put keyboard port into non-translated mode.\");\n\nstatic bool i8042_dumbkbd;\nmodule_param_named(dumbkbd, i8042_dumbkbd, bool, 0);\nMODULE_PARM_DESC(dumbkbd, \"Pretend that controller can only read data from keyboard\");\n\nstatic bool i8042_noloop;\nmodule_param_named(noloop, i8042_noloop, bool, 0);\nMODULE_PARM_DESC(noloop, \"Disable the AUX Loopback command while probing for the AUX port\");\n\nstatic bool i8042_notimeout;\nmodule_param_named(notimeout, i8042_notimeout, bool, 0);\nMODULE_PARM_DESC(notimeout, \"Ignore timeouts signalled by i8042\");\n\nstatic bool i8042_kbdreset;\nmodule_param_named(kbdreset, i8042_kbdreset, bool, 0);\nMODULE_PARM_DESC(kbdreset, \"Reset device connected to KBD port\");\n\n#ifdef CONFIG_X86\nstatic bool i8042_dritek;\nmodule_param_named(dritek, i8042_dritek, bool, 0);\nMODULE_PARM_DESC(dritek, \"Force enable the Dritek keyboard extension\");\n#endif\n\n#ifdef CONFIG_PNP\nstatic bool i8042_nopnp;\nmodule_param_named(nopnp, i8042_nopnp, bool, 0);\nMODULE_PARM_DESC(nopnp, \"Do not use PNP to detect controller settings\");\n#endif\n\n#define DEBUG\n#ifdef DEBUG\nstatic bool i8042_debug;\nmodule_param_named(debug, i8042_debug, bool, 0600);\nMODULE_PARM_DESC(debug, \"Turn i8042 debugging mode on and off\");\n\nstatic bool i8042_unmask_kbd_data;\nmodule_param_named(unmask_kbd_data, i8042_unmask_kbd_data, bool, 0600);\nMODULE_PARM_DESC(unmask_kbd_data, \"Unconditional enable (may reveal sensitive data) of normally sanitize-filtered kbd data traffic debug log [pre-condition: i8042.debug=1 enabled]\");\n#endif\n\nstatic bool i8042_bypass_aux_irq_test;\nstatic char i8042_kbd_firmware_id[128];\nstatic char i8042_aux_firmware_id[128];\n\n#include \"i8042.h\"\n\n/*\n * i8042_lock protects serialization between i8042_command and\n * the interrupt handler.\n */\nstatic DEFINE_SPINLOCK(i8042_lock);\n\n/*\n * Writers to AUX and KBD ports as well as users issuing i8042_command\n * directly should acquire i8042_mutex (by means of calling\n * i8042_lock_chip() and i8042_unlock_ship() helpers) to ensure that\n * they do not disturb each other (unfortunately in many i8042\n * implementations write to one of the ports will immediately abort\n * command that is being processed by another port).\n */\nstatic DEFINE_MUTEX(i8042_mutex);\n\nstruct i8042_port {\n\tstruct serio *serio;\n\tint irq;\n\tbool exists;\n\tbool driver_bound;\n\tsigned char mux;\n};\n\n#define I8042_KBD_PORT_NO\t0\n#define I8042_AUX_PORT_NO\t1\n#define I8042_MUX_PORT_NO\t2\n#define I8042_NUM_PORTS\t\t(I8042_NUM_MUX_PORTS + 2)\n\nstatic struct i8042_port i8042_ports[I8042_NUM_PORTS];\n\nstatic unsigned char i8042_initial_ctr;\nstatic unsigned char i8042_ctr;\nstatic bool i8042_mux_present;\nstatic bool i8042_kbd_irq_registered;\nstatic bool i8042_aux_irq_registered;\nstatic unsigned char i8042_suppress_kbd_ack;\nstatic struct platform_device *i8042_platform_device;\nstatic struct notifier_block i8042_kbd_bind_notifier_block;\n\nstatic irqreturn_t i8042_interrupt(int irq, void *dev_id);\nstatic bool (*i8042_platform_filter)(unsigned char data, unsigned char str,\n\t\t\t\t     struct serio *serio);\n\nvoid i8042_lock_chip(void)\n{\n\tmutex_lock(&i8042_mutex);\n}\nEXPORT_SYMBOL(i8042_lock_chip);\n\nvoid i8042_unlock_chip(void)\n{\n\tmutex_unlock(&i8042_mutex);\n}\nEXPORT_SYMBOL(i8042_unlock_chip);\n\nint i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,\n\t\t\t\t\tstruct serio *serio))\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tif (i8042_platform_filter) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\ti8042_platform_filter = filter;\n\nout:\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(i8042_install_filter);\n\nint i8042_remove_filter(bool (*filter)(unsigned char data, unsigned char str,\n\t\t\t\t       struct serio *port))\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tif (i8042_platform_filter != filter) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ti8042_platform_filter = NULL;\n\nout:\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(i8042_remove_filter);\n\n/*\n * The i8042_wait_read() and i8042_wait_write functions wait for the i8042 to\n * be ready for reading values from it / writing values to it.\n * Called always with i8042_lock held.\n */\n\nstatic int i8042_wait_read(void)\n{\n\tint i = 0;\n\n\twhile ((~i8042_read_status() & I8042_STR_OBF) && (i < I8042_CTL_TIMEOUT)) {\n\t\tudelay(50);\n\t\ti++;\n\t}\n\treturn -(i == I8042_CTL_TIMEOUT);\n}\n\nstatic int i8042_wait_write(void)\n{\n\tint i = 0;\n\n\twhile ((i8042_read_status() & I8042_STR_IBF) && (i < I8042_CTL_TIMEOUT)) {\n\t\tudelay(50);\n\t\ti++;\n\t}\n\treturn -(i == I8042_CTL_TIMEOUT);\n}\n\n/*\n * i8042_flush() flushes all data that may be in the keyboard and mouse buffers\n * of the i8042 down the toilet.\n */\n\nstatic int i8042_flush(void)\n{\n\tunsigned long flags;\n\tunsigned char data, str;\n\tint count = 0;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\twhile ((str = i8042_read_status()) & I8042_STR_OBF) {\n\t\tif (count++ < I8042_BUFFER_SIZE) {\n\t\t\tudelay(50);\n\t\t\tdata = i8042_read_data();\n\t\t\tdbg(\"%02x <- i8042 (flush, %s)\\n\",\n\t\t\t    data, str & I8042_STR_AUXDATA ? \"aux\" : \"kbd\");\n\t\t} else {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\treturn retval;\n}\n\n/*\n * i8042_command() executes a command on the i8042. It also sends the input\n * parameter(s) of the commands to it, and receives the output value(s). The\n * parameters are to be stored in the param array, and the output is placed\n * into the same array. The number of the parameters and output values is\n * encoded in bits 8-11 of the command number.\n */\n\nstatic int __i8042_command(unsigned char *param, int command)\n{\n\tint i, error;\n\n\tif (i8042_noloop && command == I8042_CMD_AUX_LOOP)\n\t\treturn -1;\n\n\terror = i8042_wait_write();\n\tif (error)\n\t\treturn error;\n\n\tdbg(\"%02x -> i8042 (command)\\n\", command & 0xff);\n\ti8042_write_command(command & 0xff);\n\n\tfor (i = 0; i < ((command >> 12) & 0xf); i++) {\n\t\terror = i8042_wait_write();\n\t\tif (error) {\n\t\t\tdbg(\"     -- i8042 (wait write timeout)\\n\");\n\t\t\treturn error;\n\t\t}\n\t\tdbg(\"%02x -> i8042 (parameter)\\n\", param[i]);\n\t\ti8042_write_data(param[i]);\n\t}\n\n\tfor (i = 0; i < ((command >> 8) & 0xf); i++) {\n\t\terror = i8042_wait_read();\n\t\tif (error) {\n\t\t\tdbg(\"     -- i8042 (wait read timeout)\\n\");\n\t\t\treturn error;\n\t\t}\n\n\t\tif (command == I8042_CMD_AUX_LOOP &&\n\t\t    !(i8042_read_status() & I8042_STR_AUXDATA)) {\n\t\t\tdbg(\"     -- i8042 (auxerr)\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tparam[i] = i8042_read_data();\n\t\tdbg(\"%02x <- i8042 (return)\\n\", param[i]);\n\t}\n\n\treturn 0;\n}\n\nint i8042_command(unsigned char *param, int command)\n{\n\tunsigned long flags;\n\tint retval;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\tretval = __i8042_command(param, command);\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(i8042_command);\n\n/*\n * i8042_kbd_write() sends a byte out through the keyboard interface.\n */\n\nstatic int i8042_kbd_write(struct serio *port, unsigned char c)\n{\n\tunsigned long flags;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tif (!(retval = i8042_wait_write())) {\n\t\tdbg(\"%02x -> i8042 (kbd-data)\\n\", c);\n\t\ti8042_write_data(c);\n\t}\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\treturn retval;\n}\n\n/*\n * i8042_aux_write() sends a byte out through the aux interface.\n */\n\nstatic int i8042_aux_write(struct serio *serio, unsigned char c)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\treturn i8042_command(&c, port->mux == -1 ?\n\t\t\t\t\tI8042_CMD_AUX_SEND :\n\t\t\t\t\tI8042_CMD_MUX_SEND + port->mux);\n}\n\n\n/*\n * i8042_port_close attempts to clear AUX or KBD port state by disabling\n * and then re-enabling it.\n */\n\nstatic void i8042_port_close(struct serio *serio)\n{\n\tint irq_bit;\n\tint disable_bit;\n\tconst char *port_name;\n\n\tif (serio == i8042_ports[I8042_AUX_PORT_NO].serio) {\n\t\tirq_bit = I8042_CTR_AUXINT;\n\t\tdisable_bit = I8042_CTR_AUXDIS;\n\t\tport_name = \"AUX\";\n\t} else {\n\t\tirq_bit = I8042_CTR_KBDINT;\n\t\tdisable_bit = I8042_CTR_KBDDIS;\n\t\tport_name = \"KBD\";\n\t}\n\n\ti8042_ctr &= ~irq_bit;\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\n\t\tpr_warn(\"Can't write CTR while closing %s port\\n\", port_name);\n\n\tudelay(50);\n\n\ti8042_ctr &= ~disable_bit;\n\ti8042_ctr |= irq_bit;\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\n\t\tpr_err(\"Can't reactivate %s port\\n\", port_name);\n\n\t/*\n\t * See if there is any data appeared while we were messing with\n\t * port state.\n\t */\n\ti8042_interrupt(0, NULL);\n}\n\n/*\n * i8042_start() is called by serio core when port is about to finish\n * registering. It will mark port as existing so i8042_interrupt can\n * start sending data through it.\n */\nstatic int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tspin_lock_irq(&i8042_lock);\n\tport->exists = true;\n\tspin_unlock_irq(&i8042_lock);\n\n\treturn 0;\n}\n\n/*\n * i8042_stop() marks serio port as non-existing so i8042_interrupt\n * will not try to send data to the port that is about to go away.\n * The function is called by serio core as part of unregister procedure.\n */\nstatic void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tspin_lock_irq(&i8042_lock);\n\tport->exists = false;\n\tport->serio = NULL;\n\tspin_unlock_irq(&i8042_lock);\n\n\t/*\n\t * We need to make sure that interrupt handler finishes using\n\t * our serio port before we return from this function.\n\t * We synchronize with both AUX and KBD IRQs because there is\n\t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n\t * and vice versa.\n\t */\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n}\n\n/*\n * i8042_filter() filters out unwanted bytes from the input data stream.\n * It is called from i8042_interrupt and thus is running with interrupts\n * off and i8042_lock held.\n */\nstatic bool i8042_filter(unsigned char data, unsigned char str,\n\t\t\t struct serio *serio)\n{\n\tif (unlikely(i8042_suppress_kbd_ack)) {\n\t\tif ((~str & I8042_STR_AUXDATA) &&\n\t\t    (data == 0xfa || data == 0xfe)) {\n\t\t\ti8042_suppress_kbd_ack--;\n\t\t\tdbg(\"Extra keyboard ACK - filtered out\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (i8042_platform_filter && i8042_platform_filter(data, str, serio)) {\n\t\tdbg(\"Filtered out by platform filter\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * i8042_interrupt() is the most important function in this driver -\n * it handles the interrupts from the i8042, and sends incoming bytes\n * to the upper layers.\n */\n\nstatic irqreturn_t i8042_interrupt(int irq, void *dev_id)\n{\n\tstruct i8042_port *port;\n\tstruct serio *serio;\n\tunsigned long flags;\n\tunsigned char str, data;\n\tunsigned int dfl;\n\tunsigned int port_no;\n\tbool filtered;\n\tint ret = 1;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tstr = i8042_read_status();\n\tif (unlikely(~str & I8042_STR_OBF)) {\n\t\tspin_unlock_irqrestore(&i8042_lock, flags);\n\t\tif (irq)\n\t\t\tdbg(\"Interrupt %d, without any data\\n\", irq);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdata = i8042_read_data();\n\n\tif (i8042_mux_present && (str & I8042_STR_AUXDATA)) {\n\t\tstatic unsigned long last_transmit;\n\t\tstatic unsigned char last_str;\n\n\t\tdfl = 0;\n\t\tif (str & I8042_STR_MUXERR) {\n\t\t\tdbg(\"MUX error, status is %02x, data is %02x\\n\",\n\t\t\t    str, data);\n/*\n * When MUXERR condition is signalled the data register can only contain\n * 0xfd, 0xfe or 0xff if implementation follows the spec. Unfortunately\n * it is not always the case. Some KBCs also report 0xfc when there is\n * nothing connected to the port while others sometimes get confused which\n * port the data came from and signal error leaving the data intact. They\n * _do not_ revert to legacy mode (actually I've never seen KBC reverting\n * to legacy mode yet, when we see one we'll add proper handling).\n * Anyway, we process 0xfc, 0xfd, 0xfe and 0xff as timeouts, and for the\n * rest assume that the data came from the same serio last byte\n * was transmitted (if transmission happened not too long ago).\n */\n\n\t\t\tswitch (data) {\n\t\t\t\tdefault:\n\t\t\t\t\tif (time_before(jiffies, last_transmit + HZ/10)) {\n\t\t\t\t\t\tstr = last_str;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* fall through - report timeout */\n\t\t\t\tcase 0xfc:\n\t\t\t\tcase 0xfd:\n\t\t\t\tcase 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break;\n\t\t\t\tcase 0xff: dfl = SERIO_PARITY;  data = 0xfe; break;\n\t\t\t}\n\t\t}\n\n\t\tport_no = I8042_MUX_PORT_NO + ((str >> 6) & 3);\n\t\tlast_str = str;\n\t\tlast_transmit = jiffies;\n\t} else {\n\n\t\tdfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |\n\t\t      ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);\n\n\t\tport_no = (str & I8042_STR_AUXDATA) ?\n\t\t\t\tI8042_AUX_PORT_NO : I8042_KBD_PORT_NO;\n\t}\n\n\tport = &i8042_ports[port_no];\n\tserio = port->exists ? port->serio : NULL;\n\n\tfilter_dbg(port->driver_bound, data, \"<- i8042 (interrupt, %d, %d%s%s)\\n\",\n\t\t   port_no, irq,\n\t\t   dfl & SERIO_PARITY ? \", bad parity\" : \"\",\n\t\t   dfl & SERIO_TIMEOUT ? \", timeout\" : \"\");\n\n\tfiltered = i8042_filter(data, str, serio);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (likely(serio && !filtered))\n\t\tserio_interrupt(serio, data, dfl);\n\n out:\n\treturn IRQ_RETVAL(ret);\n}\n\n/*\n * i8042_enable_kbd_port enables keyboard port on chip\n */\n\nstatic int i8042_enable_kbd_port(void)\n{\n\ti8042_ctr &= ~I8042_CTR_KBDDIS;\n\ti8042_ctr |= I8042_CTR_KBDINT;\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\ti8042_ctr &= ~I8042_CTR_KBDINT;\n\t\ti8042_ctr |= I8042_CTR_KBDDIS;\n\t\tpr_err(\"Failed to enable KBD port\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n/*\n * i8042_enable_aux_port enables AUX (mouse) port on chip\n */\n\nstatic int i8042_enable_aux_port(void)\n{\n\ti8042_ctr &= ~I8042_CTR_AUXDIS;\n\ti8042_ctr |= I8042_CTR_AUXINT;\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\ti8042_ctr &= ~I8042_CTR_AUXINT;\n\t\ti8042_ctr |= I8042_CTR_AUXDIS;\n\t\tpr_err(\"Failed to enable AUX port\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n/*\n * i8042_enable_mux_ports enables 4 individual AUX ports after\n * the controller has been switched into Multiplexed mode\n */\n\nstatic int i8042_enable_mux_ports(void)\n{\n\tunsigned char param;\n\tint i;\n\n\tfor (i = 0; i < I8042_NUM_MUX_PORTS; i++) {\n\t\ti8042_command(&param, I8042_CMD_MUX_PFX + i);\n\t\ti8042_command(&param, I8042_CMD_AUX_ENABLE);\n\t}\n\n\treturn i8042_enable_aux_port();\n}\n\n/*\n * i8042_set_mux_mode checks whether the controller has an\n * active multiplexor and puts the chip into Multiplexed (true)\n * or Legacy (false) mode.\n */\n\nstatic int i8042_set_mux_mode(bool multiplex, unsigned char *mux_version)\n{\n\n\tunsigned char param, val;\n/*\n * Get rid of bytes in the queue.\n */\n\n\ti8042_flush();\n\n/*\n * Internal loopback test - send three bytes, they should come back from the\n * mouse interface, the last should be version.\n */\n\n\tparam = val = 0xf0;\n\tif (i8042_command(&param, I8042_CMD_AUX_LOOP) || param != val)\n\t\treturn -1;\n\tparam = val = multiplex ? 0x56 : 0xf6;\n\tif (i8042_command(&param, I8042_CMD_AUX_LOOP) || param != val)\n\t\treturn -1;\n\tparam = val = multiplex ? 0xa4 : 0xa5;\n\tif (i8042_command(&param, I8042_CMD_AUX_LOOP) || param == val)\n\t\treturn -1;\n\n/*\n * Workaround for interference with USB Legacy emulation\n * that causes a v10.12 MUX to be found.\n */\n\tif (param == 0xac)\n\t\treturn -1;\n\n\tif (mux_version)\n\t\t*mux_version = param;\n\n\treturn 0;\n}\n\n/*\n * i8042_check_mux() checks whether the controller supports the PS/2 Active\n * Multiplexing specification by Synaptics, Phoenix, Insyde and\n * LCS/Telegraphics.\n */\n\nstatic int __init i8042_check_mux(void)\n{\n\tunsigned char mux_version;\n\n\tif (i8042_set_mux_mode(true, &mux_version))\n\t\treturn -1;\n\n\tpr_info(\"Detected active multiplexing controller, rev %d.%d\\n\",\n\t\t(mux_version >> 4) & 0xf, mux_version & 0xf);\n\n/*\n * Disable all muxed ports by disabling AUX.\n */\n\ti8042_ctr |= I8042_CTR_AUXDIS;\n\ti8042_ctr &= ~I8042_CTR_AUXINT;\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\tpr_err(\"Failed to disable AUX port, can't use MUX\\n\");\n\t\treturn -EIO;\n\t}\n\n\ti8042_mux_present = true;\n\n\treturn 0;\n}\n\n/*\n * The following is used to test AUX IRQ delivery.\n */\nstatic struct completion i8042_aux_irq_delivered __initdata;\nstatic bool i8042_irq_being_tested __initdata;\n\nstatic irqreturn_t __init i8042_aux_test_irq(int irq, void *dev_id)\n{\n\tunsigned long flags;\n\tunsigned char str, data;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\tstr = i8042_read_status();\n\tif (str & I8042_STR_OBF) {\n\t\tdata = i8042_read_data();\n\t\tdbg(\"%02x <- i8042 (aux_test_irq, %s)\\n\",\n\t\t    data, str & I8042_STR_AUXDATA ? \"aux\" : \"kbd\");\n\t\tif (i8042_irq_being_tested &&\n\t\t    data == 0xa5 && (str & I8042_STR_AUXDATA))\n\t\t\tcomplete(&i8042_aux_irq_delivered);\n\t\tret = 1;\n\t}\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\treturn IRQ_RETVAL(ret);\n}\n\n/*\n * i8042_toggle_aux - enables or disables AUX port on i8042 via command and\n * verifies success by readinng CTR. Used when testing for presence of AUX\n * port.\n */\nstatic int __init i8042_toggle_aux(bool on)\n{\n\tunsigned char param;\n\tint i;\n\n\tif (i8042_command(&param,\n\t\t\ton ? I8042_CMD_AUX_ENABLE : I8042_CMD_AUX_DISABLE))\n\t\treturn -1;\n\n\t/* some chips need some time to set the I8042_CTR_AUXDIS bit */\n\tfor (i = 0; i < 100; i++) {\n\t\tudelay(50);\n\n\t\tif (i8042_command(&param, I8042_CMD_CTL_RCTR))\n\t\t\treturn -1;\n\n\t\tif (!(param & I8042_CTR_AUXDIS) == on)\n\t\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\n/*\n * i8042_check_aux() applies as much paranoia as it can at detecting\n * the presence of an AUX interface.\n */\n\nstatic int __init i8042_check_aux(void)\n{\n\tint retval = -1;\n\tbool irq_registered = false;\n\tbool aux_loop_broken = false;\n\tunsigned long flags;\n\tunsigned char param;\n\n/*\n * Get rid of bytes in the queue.\n */\n\n\ti8042_flush();\n\n/*\n * Internal loopback test - filters out AT-type i8042's. Unfortunately\n * SiS screwed up and their 5597 doesn't support the LOOP command even\n * though it has an AUX port.\n */\n\n\tparam = 0x5a;\n\tretval = i8042_command(&param, I8042_CMD_AUX_LOOP);\n\tif (retval || param != 0x5a) {\n\n/*\n * External connection test - filters out AT-soldered PS/2 i8042's\n * 0x00 - no error, 0x01-0x03 - clock/data stuck, 0xff - general error\n * 0xfa - no error on some notebooks which ignore the spec\n * Because it's common for chipsets to return error on perfectly functioning\n * AUX ports, we test for this only when the LOOP command failed.\n */\n\n\t\tif (i8042_command(&param, I8042_CMD_AUX_TEST) ||\n\t\t    (param && param != 0xfa && param != 0xff))\n\t\t\treturn -1;\n\n/*\n * If AUX_LOOP completed without error but returned unexpected data\n * mark it as broken\n */\n\t\tif (!retval)\n\t\t\taux_loop_broken = true;\n\t}\n\n/*\n * Bit assignment test - filters out PS/2 i8042's in AT mode\n */\n\n\tif (i8042_toggle_aux(false)) {\n\t\tpr_warn(\"Failed to disable AUX port, but continuing anyway... Is this a SiS?\\n\");\n\t\tpr_warn(\"If AUX port is really absent please use the 'i8042.noaux' option\\n\");\n\t}\n\n\tif (i8042_toggle_aux(true))\n\t\treturn -1;\n\n/*\n * Reset keyboard (needed on some laptops to successfully detect\n * touchpad, e.g., some Gigabyte laptop models with Elantech\n * touchpads).\n */\n\tif (i8042_kbdreset) {\n\t\tpr_warn(\"Attempting to reset device connected to KBD port\\n\");\n\t\ti8042_kbd_write(NULL, (unsigned char) 0xff);\n\t}\n\n/*\n * Test AUX IRQ delivery to make sure BIOS did not grab the IRQ and\n * used it for a PCI card or somethig else.\n */\n\n\tif (i8042_noloop || i8042_bypass_aux_irq_test || aux_loop_broken) {\n/*\n * Without LOOP command we can't test AUX IRQ delivery. Assume the port\n * is working and hope we are right.\n */\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\n\tif (request_irq(I8042_AUX_IRQ, i8042_aux_test_irq, IRQF_SHARED,\n\t\t\t\"i8042\", i8042_platform_device))\n\t\tgoto out;\n\n\tirq_registered = true;\n\n\tif (i8042_enable_aux_port())\n\t\tgoto out;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tinit_completion(&i8042_aux_irq_delivered);\n\ti8042_irq_being_tested = true;\n\n\tparam = 0xa5;\n\tretval = __i8042_command(&param, I8042_CMD_AUX_LOOP & 0xf0ff);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (retval)\n\t\tgoto out;\n\n\tif (wait_for_completion_timeout(&i8042_aux_irq_delivered,\n\t\t\t\t\tmsecs_to_jiffies(250)) == 0) {\n/*\n * AUX IRQ was never delivered so we need to flush the controller to\n * get rid of the byte we put there; otherwise keyboard may not work.\n */\n\t\tdbg(\"     -- i8042 (aux irq test timeout)\\n\");\n\t\ti8042_flush();\n\t\tretval = -1;\n\t}\n\n out:\n\n/*\n * Disable the interface.\n */\n\n\ti8042_ctr |= I8042_CTR_AUXDIS;\n\ti8042_ctr &= ~I8042_CTR_AUXINT;\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\n\t\tretval = -1;\n\n\tif (irq_registered)\n\t\tfree_irq(I8042_AUX_IRQ, i8042_platform_device);\n\n\treturn retval;\n}\n\nstatic int i8042_controller_check(void)\n{\n\tif (i8042_flush()) {\n\t\tpr_info(\"No controller found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int i8042_controller_selftest(void)\n{\n\tunsigned char param;\n\tint i = 0;\n\n\t/*\n\t * We try this 5 times; on some really fragile systems this does not\n\t * take the first time...\n\t */\n\tdo {\n\n\t\tif (i8042_command(&param, I8042_CMD_CTL_TEST)) {\n\t\t\tpr_err(\"i8042 controller selftest timeout\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (param == I8042_RET_CTL_TEST)\n\t\t\treturn 0;\n\n\t\tdbg(\"i8042 controller selftest: %#x != %#x\\n\",\n\t\t    param, I8042_RET_CTL_TEST);\n\t\tmsleep(50);\n\t} while (i++ < 5);\n\n#ifdef CONFIG_X86\n\t/*\n\t * On x86, we don't fail entire i8042 initialization if controller\n\t * reset fails in hopes that keyboard port will still be functional\n\t * and user will still get a working keyboard. This is especially\n\t * important on netbooks. On other arches we trust hardware more.\n\t */\n\tpr_info(\"giving up on controller selftest, continuing anyway...\\n\");\n\treturn 0;\n#else\n\tpr_err(\"i8042 controller selftest failed\\n\");\n\treturn -EIO;\n#endif\n}\n\n/*\n * i8042_controller init initializes the i8042 controller, and,\n * most importantly, sets it into non-xlated mode if that's\n * desired.\n */\n\nstatic int i8042_controller_init(void)\n{\n\tunsigned long flags;\n\tint n = 0;\n\tunsigned char ctr[2];\n\n/*\n * Save the CTR for restore on unload / reboot.\n */\n\n\tdo {\n\t\tif (n >= 10) {\n\t\t\tpr_err(\"Unable to get stable CTR read\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (n != 0)\n\t\t\tudelay(50);\n\n\t\tif (i8042_command(&ctr[n++ % 2], I8042_CMD_CTL_RCTR)) {\n\t\t\tpr_err(\"Can't read CTR while initializing i8042\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t} while (n < 2 || ctr[0] != ctr[1]);\n\n\ti8042_initial_ctr = i8042_ctr = ctr[0];\n\n/*\n * Disable the keyboard interface and interrupt.\n */\n\n\ti8042_ctr |= I8042_CTR_KBDDIS;\n\ti8042_ctr &= ~I8042_CTR_KBDINT;\n\n/*\n * Handle keylock.\n */\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\tif (~i8042_read_status() & I8042_STR_KEYLOCK) {\n\t\tif (i8042_unlock)\n\t\t\ti8042_ctr |= I8042_CTR_IGNKEYLOCK;\n\t\telse\n\t\t\tpr_warn(\"Warning: Keylock active\\n\");\n\t}\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n/*\n * If the chip is configured into nontranslated mode by the BIOS, don't\n * bother enabling translating and be happy.\n */\n\n\tif (~i8042_ctr & I8042_CTR_XLATE)\n\t\ti8042_direct = true;\n\n/*\n * Set nontranslated mode for the kbd interface if requested by an option.\n * After this the kbd interface becomes a simple serial in/out, like the aux\n * interface is. We don't do this by default, since it can confuse notebook\n * BIOSes.\n */\n\n\tif (i8042_direct)\n\t\ti8042_ctr &= ~I8042_CTR_XLATE;\n\n/*\n * Write CTR back.\n */\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\tpr_err(\"Can't write CTR while initializing i8042\\n\");\n\t\treturn -EIO;\n\t}\n\n/*\n * Flush whatever accumulated while we were disabling keyboard port.\n */\n\n\ti8042_flush();\n\n\treturn 0;\n}\n\n\n/*\n * Reset the controller and reset CRT to the original value set by BIOS.\n */\n\nstatic void i8042_controller_reset(bool s2r_wants_reset)\n{\n\ti8042_flush();\n\n/*\n * Disable both KBD and AUX interfaces so they don't get in the way\n */\n\n\ti8042_ctr |= I8042_CTR_KBDDIS | I8042_CTR_AUXDIS;\n\ti8042_ctr &= ~(I8042_CTR_KBDINT | I8042_CTR_AUXINT);\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\n\t\tpr_warn(\"Can't write CTR while resetting\\n\");\n\n/*\n * Disable MUX mode if present.\n */\n\n\tif (i8042_mux_present)\n\t\ti8042_set_mux_mode(false, NULL);\n\n/*\n * Reset the controller if requested.\n */\n\n\tif (i8042_reset == I8042_RESET_ALWAYS ||\n\t    (i8042_reset == I8042_RESET_ON_S2RAM && s2r_wants_reset)) {\n\t\ti8042_controller_selftest();\n\t}\n\n/*\n * Restore the original control register setting.\n */\n\n\tif (i8042_command(&i8042_initial_ctr, I8042_CMD_CTL_WCTR))\n\t\tpr_warn(\"Can't restore CTR\\n\");\n}\n\n\n/*\n * i8042_panic_blink() will turn the keyboard LEDs on or off and is called\n * when kernel panics. Flashing LEDs is useful for users running X who may\n * not see the console and will help distinguishing panics from \"real\"\n * lockups.\n *\n * Note that DELAY has a limit of 10ms so we will not get stuck here\n * waiting for KBC to free up even if KBD interrupt is off\n */\n\n#define DELAY do { mdelay(1); if (++delay > 10) return delay; } while(0)\n\nstatic long i8042_panic_blink(int state)\n{\n\tlong delay = 0;\n\tchar led;\n\n\tled = (state) ? 0x01 | 0x04 : 0;\n\twhile (i8042_read_status() & I8042_STR_IBF)\n\t\tDELAY;\n\tdbg(\"%02x -> i8042 (panic blink)\\n\", 0xed);\n\ti8042_suppress_kbd_ack = 2;\n\ti8042_write_data(0xed); /* set leds */\n\tDELAY;\n\twhile (i8042_read_status() & I8042_STR_IBF)\n\t\tDELAY;\n\tDELAY;\n\tdbg(\"%02x -> i8042 (panic blink)\\n\", led);\n\ti8042_write_data(led);\n\tDELAY;\n\treturn delay;\n}\n\n#undef DELAY\n\n#ifdef CONFIG_X86\nstatic void i8042_dritek_enable(void)\n{\n\tunsigned char param = 0x90;\n\tint error;\n\n\terror = i8042_command(&param, 0x1059);\n\tif (error)\n\t\tpr_warn(\"Failed to enable DRITEK extension: %d\\n\", error);\n}\n#endif\n\n#ifdef CONFIG_PM\n\n/*\n * Here we try to reset everything back to a state we had\n * before suspending.\n */\n\nstatic int i8042_controller_resume(bool s2r_wants_reset)\n{\n\tint error;\n\n\terror = i8042_controller_check();\n\tif (error)\n\t\treturn error;\n\n\tif (i8042_reset == I8042_RESET_ALWAYS ||\n\t    (i8042_reset == I8042_RESET_ON_S2RAM && s2r_wants_reset)) {\n\t\terror = i8042_controller_selftest();\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n/*\n * Restore original CTR value and disable all ports\n */\n\n\ti8042_ctr = i8042_initial_ctr;\n\tif (i8042_direct)\n\t\ti8042_ctr &= ~I8042_CTR_XLATE;\n\ti8042_ctr |= I8042_CTR_AUXDIS | I8042_CTR_KBDDIS;\n\ti8042_ctr &= ~(I8042_CTR_AUXINT | I8042_CTR_KBDINT);\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\tpr_warn(\"Can't write CTR to resume, retrying...\\n\");\n\t\tmsleep(50);\n\t\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\t\tpr_err(\"CTR write retry failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\n#ifdef CONFIG_X86\n\tif (i8042_dritek)\n\t\ti8042_dritek_enable();\n#endif\n\n\tif (i8042_mux_present) {\n\t\tif (i8042_set_mux_mode(true, NULL) || i8042_enable_mux_ports())\n\t\t\tpr_warn(\"failed to resume active multiplexor, mouse won't work\\n\");\n\t} else if (i8042_ports[I8042_AUX_PORT_NO].serio)\n\t\ti8042_enable_aux_port();\n\n\tif (i8042_ports[I8042_KBD_PORT_NO].serio)\n\t\ti8042_enable_kbd_port();\n\n\ti8042_interrupt(0, NULL);\n\n\treturn 0;\n}\n\n/*\n * Here we try to restore the original BIOS settings to avoid\n * upsetting it.\n */\n\nstatic int i8042_pm_suspend(struct device *dev)\n{\n\tint i;\n\n\tif (pm_suspend_via_firmware())\n\t\ti8042_controller_reset(true);\n\n\t/* Set up serio interrupts for system wakeup. */\n\tfor (i = 0; i < I8042_NUM_PORTS; i++) {\n\t\tstruct serio *serio = i8042_ports[i].serio;\n\n\t\tif (serio && device_may_wakeup(&serio->dev))\n\t\t\tenable_irq_wake(i8042_ports[i].irq);\n\t}\n\n\treturn 0;\n}\n\nstatic int i8042_pm_resume_noirq(struct device *dev)\n{\n\tif (!pm_resume_via_firmware())\n\t\ti8042_interrupt(0, NULL);\n\n\treturn 0;\n}\n\nstatic int i8042_pm_resume(struct device *dev)\n{\n\tbool want_reset;\n\tint i;\n\n\tfor (i = 0; i < I8042_NUM_PORTS; i++) {\n\t\tstruct serio *serio = i8042_ports[i].serio;\n\n\t\tif (serio && device_may_wakeup(&serio->dev))\n\t\t\tdisable_irq_wake(i8042_ports[i].irq);\n\t}\n\n\t/*\n\t * If platform firmware was not going to be involved in suspend, we did\n\t * not restore the controller state to whatever it had been at boot\n\t * time, so we do not need to do anything.\n\t */\n\tif (!pm_suspend_via_firmware())\n\t\treturn 0;\n\n\t/*\n\t * We only need to reset the controller if we are resuming after handing\n\t * off control to the platform firmware, otherwise we can simply restore\n\t * the mode.\n\t */\n\twant_reset = pm_resume_via_firmware();\n\n\treturn i8042_controller_resume(want_reset);\n}\n\nstatic int i8042_pm_thaw(struct device *dev)\n{\n\ti8042_interrupt(0, NULL);\n\n\treturn 0;\n}\n\nstatic int i8042_pm_reset(struct device *dev)\n{\n\ti8042_controller_reset(false);\n\n\treturn 0;\n}\n\nstatic int i8042_pm_restore(struct device *dev)\n{\n\treturn i8042_controller_resume(false);\n}\n\nstatic const struct dev_pm_ops i8042_pm_ops = {\n\t.suspend\t= i8042_pm_suspend,\n\t.resume_noirq\t= i8042_pm_resume_noirq,\n\t.resume\t\t= i8042_pm_resume,\n\t.thaw\t\t= i8042_pm_thaw,\n\t.poweroff\t= i8042_pm_reset,\n\t.restore\t= i8042_pm_restore,\n};\n\n#endif /* CONFIG_PM */\n\n/*\n * We need to reset the 8042 back to original mode on system shutdown,\n * because otherwise BIOSes will be confused.\n */\n\nstatic void i8042_shutdown(struct platform_device *dev)\n{\n\ti8042_controller_reset(false);\n}\n\nstatic int __init i8042_create_kbd_port(void)\n{\n\tstruct serio *serio;\n\tstruct i8042_port *port = &i8042_ports[I8042_KBD_PORT_NO];\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tserio->id.type\t\t= i8042_direct ? SERIO_8042 : SERIO_8042_XL;\n\tserio->write\t\t= i8042_dumbkbd ? NULL : i8042_kbd_write;\n\tserio->start\t\t= i8042_start;\n\tserio->stop\t\t= i8042_stop;\n\tserio->close\t\t= i8042_port_close;\n\tserio->ps2_cmd_mutex\t= &i8042_mutex;\n\tserio->port_data\t= port;\n\tserio->dev.parent\t= &i8042_platform_device->dev;\n\tstrlcpy(serio->name, \"i8042 KBD port\", sizeof(serio->name));\n\tstrlcpy(serio->phys, I8042_KBD_PHYS_DESC, sizeof(serio->phys));\n\tstrlcpy(serio->firmware_id, i8042_kbd_firmware_id,\n\t\tsizeof(serio->firmware_id));\n\n\tport->serio = serio;\n\tport->irq = I8042_KBD_IRQ;\n\n\treturn 0;\n}\n\nstatic int __init i8042_create_aux_port(int idx)\n{\n\tstruct serio *serio;\n\tint port_no = idx < 0 ? I8042_AUX_PORT_NO : I8042_MUX_PORT_NO + idx;\n\tstruct i8042_port *port = &i8042_ports[port_no];\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tserio->id.type\t\t= SERIO_8042;\n\tserio->write\t\t= i8042_aux_write;\n\tserio->start\t\t= i8042_start;\n\tserio->stop\t\t= i8042_stop;\n\tserio->ps2_cmd_mutex\t= &i8042_mutex;\n\tserio->port_data\t= port;\n\tserio->dev.parent\t= &i8042_platform_device->dev;\n\tif (idx < 0) {\n\t\tstrlcpy(serio->name, \"i8042 AUX port\", sizeof(serio->name));\n\t\tstrlcpy(serio->phys, I8042_AUX_PHYS_DESC, sizeof(serio->phys));\n\t\tstrlcpy(serio->firmware_id, i8042_aux_firmware_id,\n\t\t\tsizeof(serio->firmware_id));\n\t\tserio->close = i8042_port_close;\n\t} else {\n\t\tsnprintf(serio->name, sizeof(serio->name), \"i8042 AUX%d port\", idx);\n\t\tsnprintf(serio->phys, sizeof(serio->phys), I8042_MUX_PHYS_DESC, idx + 1);\n\t\tstrlcpy(serio->firmware_id, i8042_aux_firmware_id,\n\t\t\tsizeof(serio->firmware_id));\n\t}\n\n\tport->serio = serio;\n\tport->mux = idx;\n\tport->irq = I8042_AUX_IRQ;\n\n\treturn 0;\n}\n\nstatic void __init i8042_free_kbd_port(void)\n{\n\tkfree(i8042_ports[I8042_KBD_PORT_NO].serio);\n\ti8042_ports[I8042_KBD_PORT_NO].serio = NULL;\n}\n\nstatic void __init i8042_free_aux_ports(void)\n{\n\tint i;\n\n\tfor (i = I8042_AUX_PORT_NO; i < I8042_NUM_PORTS; i++) {\n\t\tkfree(i8042_ports[i].serio);\n\t\ti8042_ports[i].serio = NULL;\n\t}\n}\n\nstatic void __init i8042_register_ports(void)\n{\n\tint i;\n\n\tfor (i = 0; i < I8042_NUM_PORTS; i++) {\n\t\tstruct serio *serio = i8042_ports[i].serio;\n\n\t\tif (serio) {\n\t\t\tprintk(KERN_INFO \"serio: %s at %#lx,%#lx irq %d\\n\",\n\t\t\t\tserio->name,\n\t\t\t\t(unsigned long) I8042_DATA_REG,\n\t\t\t\t(unsigned long) I8042_COMMAND_REG,\n\t\t\t\ti8042_ports[i].irq);\n\t\t\tserio_register_port(serio);\n\t\t\tdevice_set_wakeup_capable(&serio->dev, true);\n\t\t}\n\t}\n}\n\nstatic void i8042_unregister_ports(void)\n{\n\tint i;\n\n\tfor (i = 0; i < I8042_NUM_PORTS; i++) {\n\t\tif (i8042_ports[i].serio) {\n\t\t\tserio_unregister_port(i8042_ports[i].serio);\n\t\t\ti8042_ports[i].serio = NULL;\n\t\t}\n\t}\n}\n\nstatic void i8042_free_irqs(void)\n{\n\tif (i8042_aux_irq_registered)\n\t\tfree_irq(I8042_AUX_IRQ, i8042_platform_device);\n\tif (i8042_kbd_irq_registered)\n\t\tfree_irq(I8042_KBD_IRQ, i8042_platform_device);\n\n\ti8042_aux_irq_registered = i8042_kbd_irq_registered = false;\n}\n\nstatic int __init i8042_setup_aux(void)\n{\n\tint (*aux_enable)(void);\n\tint error;\n\tint i;\n\n\tif (i8042_check_aux())\n\t\treturn -ENODEV;\n\n\tif (i8042_nomux || i8042_check_mux()) {\n\t\terror = i8042_create_aux_port(-1);\n\t\tif (error)\n\t\t\tgoto err_free_ports;\n\t\taux_enable = i8042_enable_aux_port;\n\t} else {\n\t\tfor (i = 0; i < I8042_NUM_MUX_PORTS; i++) {\n\t\t\terror = i8042_create_aux_port(i);\n\t\t\tif (error)\n\t\t\t\tgoto err_free_ports;\n\t\t}\n\t\taux_enable = i8042_enable_mux_ports;\n\t}\n\n\terror = request_irq(I8042_AUX_IRQ, i8042_interrupt, IRQF_SHARED,\n\t\t\t    \"i8042\", i8042_platform_device);\n\tif (error)\n\t\tgoto err_free_ports;\n\n\tif (aux_enable())\n\t\tgoto err_free_irq;\n\n\ti8042_aux_irq_registered = true;\n\treturn 0;\n\n err_free_irq:\n\tfree_irq(I8042_AUX_IRQ, i8042_platform_device);\n err_free_ports:\n\ti8042_free_aux_ports();\n\treturn error;\n}\n\nstatic int __init i8042_setup_kbd(void)\n{\n\tint error;\n\n\terror = i8042_create_kbd_port();\n\tif (error)\n\t\treturn error;\n\n\terror = request_irq(I8042_KBD_IRQ, i8042_interrupt, IRQF_SHARED,\n\t\t\t    \"i8042\", i8042_platform_device);\n\tif (error)\n\t\tgoto err_free_port;\n\n\terror = i8042_enable_kbd_port();\n\tif (error)\n\t\tgoto err_free_irq;\n\n\ti8042_kbd_irq_registered = true;\n\treturn 0;\n\n err_free_irq:\n\tfree_irq(I8042_KBD_IRQ, i8042_platform_device);\n err_free_port:\n\ti8042_free_kbd_port();\n\treturn error;\n}\n\nstatic int i8042_kbd_bind_notifier(struct notifier_block *nb,\n\t\t\t\t   unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tstruct serio *serio = to_serio_port(dev);\n\tstruct i8042_port *port = serio->port_data;\n\n\tif (serio != i8042_ports[I8042_KBD_PORT_NO].serio)\n\t\treturn 0;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_BOUND_DRIVER:\n\t\tport->driver_bound = true;\n\t\tbreak;\n\n\tcase BUS_NOTIFY_UNBIND_DRIVER:\n\t\tport->driver_bound = false;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init i8042_probe(struct platform_device *dev)\n{\n\tint error;\n\n\ti8042_platform_device = dev;\n\n\tif (i8042_reset == I8042_RESET_ALWAYS) {\n\t\terror = i8042_controller_selftest();\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = i8042_controller_init();\n\tif (error)\n\t\treturn error;\n\n#ifdef CONFIG_X86\n\tif (i8042_dritek)\n\t\ti8042_dritek_enable();\n#endif\n\n\tif (!i8042_noaux) {\n\t\terror = i8042_setup_aux();\n\t\tif (error && error != -ENODEV && error != -EBUSY)\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!i8042_nokbd) {\n\t\terror = i8042_setup_kbd();\n\t\tif (error)\n\t\t\tgoto out_fail;\n\t}\n/*\n * Ok, everything is ready, let's register all serio ports\n */\n\ti8042_register_ports();\n\n\treturn 0;\n\n out_fail:\n\ti8042_free_aux_ports();\t/* in case KBD failed but AUX not */\n\ti8042_free_irqs();\n\ti8042_controller_reset(false);\n\ti8042_platform_device = NULL;\n\n\treturn error;\n}\n\nstatic int i8042_remove(struct platform_device *dev)\n{\n\ti8042_unregister_ports();\n\ti8042_free_irqs();\n\ti8042_controller_reset(false);\n\ti8042_platform_device = NULL;\n\n\treturn 0;\n}\n\nstatic struct platform_driver i8042_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"i8042\",\n#ifdef CONFIG_PM\n\t\t.pm\t= &i8042_pm_ops,\n#endif\n\t},\n\t.remove\t\t= i8042_remove,\n\t.shutdown\t= i8042_shutdown,\n};\n\nstatic struct notifier_block i8042_kbd_bind_notifier_block = {\n\t.notifier_call = i8042_kbd_bind_notifier,\n};\n\nstatic int __init i8042_init(void)\n{\n\tstruct platform_device *pdev;\n\tint err;\n\n\tdbg_init();\n\n\terr = i8042_platform_init();\n\tif (err)\n\t\treturn err;\n\n\terr = i8042_controller_check();\n\tif (err)\n\t\tgoto err_platform_exit;\n\n\tpdev = platform_create_bundle(&i8042_driver, i8042_probe, NULL, 0, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\terr = PTR_ERR(pdev);\n\t\tgoto err_platform_exit;\n\t}\n\n\tbus_register_notifier(&serio_bus, &i8042_kbd_bind_notifier_block);\n\tpanic_blink = i8042_panic_blink;\n\n\treturn 0;\n\n err_platform_exit:\n\ti8042_platform_exit();\n\treturn err;\n}\n\nstatic void __exit i8042_exit(void)\n{\n\tplatform_device_unregister(i8042_platform_device);\n\tplatform_driver_unregister(&i8042_driver);\n\ti8042_platform_exit();\n\n\tbus_unregister_notifier(&serio_bus, &i8042_kbd_bind_notifier_block);\n\tpanic_blink = NULL;\n}\n\nmodule_init(i8042_init);\nmodule_exit(i8042_exit);\n"], "filenames": ["drivers/input/serio/i8042.c"], "buggy_code_start_loc": [438], "buggy_code_end_loc": [580], "fixing_code_start_loc": [439], "fixing_code_end_loc": [586], "type": "CWE-476", "message": "drivers/input/serio/i8042.c in the Linux kernel before 4.12.4 allows attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact because the port->exists value can change after it is validated.", "other": {"cve": {"id": "CVE-2017-18079", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-29T05:29:00.260", "lastModified": "2023-02-07T22:17:20.253", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/input/serio/i8042.c in the Linux kernel before 4.12.4 allows attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact because the port->exists value can change after it is validated."}, {"lang": "es", "value": "drivers/input/serio/i8042.c en el kernel de Linux en versiones anteriores a la 4.12.4 permite que atacantes provoquen una denegaci\u00f3n de servicio (desreferencia de puntero NULL y cierre inesperado del sistema) o que, posiblemente, tengan otro tipo de impacto sin especificar debido a que el valor port->exists puede cambiar tras ser validado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.94", "matchCriteriaId": "E6489590-820D-4647-91C4-01D00B61FF57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.16.49", "matchCriteriaId": "6D2B2AB6-A208-4834-8CF4-03EF0774B915"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.63", "matchCriteriaId": "7E7373BF-7059-470B-B762-F3696EED61D4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.44", "matchCriteriaId": "C2695139-BE23-4BAC-97F1-4CD2A6240BD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.79", "matchCriteriaId": "6C4F1EAA-26DD-4383-BB29-9304CE7705F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.40", "matchCriteriaId": "E0B96CF8-017F-4BA8-A487-1308681D0C05"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.12.4", "matchCriteriaId": "6D215460-34F8-4C32-939B-270A67F6FA9C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=340d394a789518018f834ff70f7534fc463d3226", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/102895", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/340d394a789518018f834ff70f7534fc463d3226", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://usn.ubuntu.com/3655-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3655-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.12.4", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Release Notes"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/340d394a789518018f834ff70f7534fc463d3226"}}