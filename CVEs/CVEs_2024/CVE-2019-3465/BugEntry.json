{"buggy_code": ["xmlseclibs.php\n|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n??, ??? 2018, 3.0.4-dev\n\n15, Nov 2018, 3.0.3\nBug Fixes:\n- Fix casing of class name. (Willem Stuursma-Ruwen)\n- Fix Xpath casing. (Tim van Dijen)\n\nImprovements:\n- Make PCRE2 compliant. (Stefan Winter)\n- Add PHP 7.3 support. (Stefan Winter)\n\n27, Sep 2018, 3.0.2\nSecurity Improvements:\n- OpenSSL is now a requirement rather than suggestion. (Slaven Bacelic)\n- Filter input to avoid XPath injection. (Jaime P\u00e9rez)\n\nBug Fixes:\n- Fix missing parentheses (Tim van Dijen)\n\nImprovements:\n- Use strict comparison operator to compare digest values. (Jaime P\u00e9rez)\n- Remove call to file_get_contents that doesn't even work. (Jaime P\u00e9rez)\n- Document potentially dangerous return value behaviour. (Thijs Kinkhorst)\n\n31, Aug 2017, 3.0.1\nBug Fixes:\n- Fixed missing () in function call. (Dennis V\u00e6versted)\n\nImprovements:\n- Add OneLogin to supported software.\n- Add .gitattributes to remove unneeded files. (Filippo Tessarotto)\n- Fix bug in example code. (Dan Church)\n- Travis: add PHP 7.1, move hhvm to allowed failures. (Thijs Kinkhorst)\n- Drop failing extract-win-cert test (Thijs Kinkhorst). (Thijs Kinkhorst)\n- Add comments to warn about return values of verify(). (Thijs Kinkhorst)\n- Fix tests to properly check return code of verify(). (Thijs Kinkhorst)\n- Restore support for PHP >= 5.4. (Jaime P\u00e9rez)\n\n25, May 2017, 3.0.0\nImprovements:\n- Remove use of mcrypt (skymeyer)\n\n08, Sep 2016, 2.0.1\nBug Fixes:\n- Strip whitespace characters when parsing X509Certificate. fixes #84\n  (klemen.bratec)\n- Certificate 'subject' values can be arrays. fixes #80 (Andreas Stangl)\n- HHVM signing node with ID attribute w/out namespace regenerates ID value.\n  fixes #88 (Milos Tomic)\n\nImprovements:\n- Fix typos and add some PHPDoc Blocks. (gfaust-qb)\n- Update lightSAML link. (Milos Tomic)\n- Update copyright dates.\n\n31, Jul 2015, 2.0.0\nFeatures:\n- Namespace support. Classes now in the RobRichards\\XMLSecLibs\\ namespace.\n\nImprovements:\n- Dropped support for PHP 5.2\n\n31, Jul 2015, 1.4.1\nBug Fixes:\n- Allow for large digest values that may have line breaks. fixes #62\n\nFeatures:\n- Support for locating specific signature when multiple exist in \n  document. (griga3k)\n\nImprovements:\n- Add optional argument to XMLSecurityDSig to define the prefix to be used, \n  also allowing for null to use no prefix, for the dsig namespace. fixes #13\n- Code cleanup\n- Depreciated XMLSecurityDSig::generate_GUID for XMLSecurityDSig::generateGUID\n\n23, Jun 2015, 1.4.0\nFeatures:\n- Support for PSR-0 standard.\n- Support for X509SubjectName. (Milos Tomic)\n- Add HMAC-SHA1 support.\n\nImprovements:\n- Add how to install to README. (Bernardo Vieira da Silva)\n- Code cleanup. (Jaime P\u00e9rez)\n- Normalilze tests. (Hidde Wieringa)\n- Add basic usage to README. (Hidde Wieringa)\n\n21, May 2015, 1.3.2\nBug Fixes:\n- Fix Undefined variable notice. (dpieper85)\n- Fix typo when setting MimeType attribute. (Eugene OZ)\n- Fix validateReference() with enveloping signatures\n\nFeatures:\n- canonicalizeData performance optimization. (Jaime P\u00e9rez)\n- Add composer support (Maks3w)\n\n19, Jun 2013, 1.3.1\nFeatures:\n- return encrypted node from XMLSecEnc::encryptNode() when replace is set to \n  false. (Olav)\n- Add support for RSA SHA384 and RSA_SHA512 and SHA384 digest. (Jaime P\u008erez)\n- Add options parameter to the add cert methods.\n- Add optional issuerSerial creation with cert\n\nBug Fixes:\n- Fix persisted Id when namespaced. (Koen Thomeer)\n\nImprovements:\n- Add LICENSE file\n- Convert CHANGELOG.txt to UTF-8\n\n26, Sep 2011, 1.3.0\nFeatures:\n- Add param to append sig to node when signing. Fixes a problem when using \n  inclusive canonicalization to append a signature within a namespaced subtree.\n  ex. $objDSig->sign($objKey, $appendToNode); \n- Add ability to encrypt by reference\n- Add support for refences within an encrypted key\n- Add thumbprint generation capability (XMLSecurityKey->getX509Thumbprint() and \n  XMLSecurityKey::getRawThumbprint($cert))\n- Return signature element node from XMLSecurityDSig::insertSignature() and \n  XMLSecurityDSig::appendSignature() methods\n- Support for <ds:RetrievalMethod> with simple URI Id reference.\n- Add XMLSecurityKey::getSymmetricKeySize() method (Olav)\n- Add XMLSecEnc::getCipherValue() method (Olav)\n- Improve XMLSecurityKey:generateSessionKey() logic (Olav)\n\nBug Fixes:\n- Change split() to explode() as split is now depreciated\n- ds:References using empty or simple URI Id reference should never include \n  comments in canonicalized data.\n- Make sure that the elements in EncryptedData are emitted in the correct \n  sequence.\n\n11 Jan 2010, 1.2.2\nFeatures:\n- Add support XPath support when creating signature. Provides support for \n  working with EBXML documents.\n- Add reference option to force creation of URI attribute. For use\n  when adding a DOM Document where by default no URI attribute is added.\n- Add support for RSA-SHA256\n\nBug Fixes:\n- fix bug #5: createDOMDocumentFragment() in decryptNode when data is node \n  content (patch by Francois Wang)\n\n\n08 Jul 2008, 1.2.1\nFeatures:\n- Attempt to use mhash when hash extension is not present. (Alfredo Cubitos).\n- Add fallback to built-in sha1 if both hash and mhash are not available and \n  throw error for other for other missing hashes. (patch by Olav Morken).\n- Add getX509Certificate method to retrieve the x509 cert used for Key. \n  (patch by Olav Morken).\n- Add getValidatedNodes method to retrieve the elements signed by the \n  signature. (patch by Olav Morken).\n- Add insertSignature method for precision signature insertion. Merge \n  functionality from appendSignature in the process. (Olav Morken, Rob).\n- Finally add some tests\n\nBug Fixes:\n- Fix canonicalization for Document node when using PHP < 5.2.\n- Add padding for RSA_SHA1. (patch by Olav Morken).\n\n\n27 Nov 2007, 1.2.0\nFeatures:\n- New addReference/List option (overwrite). Boolean flag indicating if URI\n  value should be overwritten if already existing within document.\n  Default is TRUE to maintain BC.\n\n18 Nov 2007, 1.1.2\nBug Fixes:\n- Remove closing PHP tag to fix extra whitespace characters from being output\n\n11 Nov 2007, 1.1.1\nFeatures:\n- Add getRefNodeID() and getRefIDs() methods missed in previous release.\n  Provide functionality to find URIs of existing reference nodes.\n  Required by simpleSAMLphp project\n\nBug Fixes:\n- Remove erroneous whitespace causing issues under certain circumastances.\n\n18 Oct 2007, 1.1.0\nFeatures:\n- Enable creation of enveloping signature. This allows the creation of\n  managed information cards.\n- Add addObject method for enveloping signatures.\n- Add staticGet509XCerts method. Chained certificates within a PEM file can\n  now be added within the X509Data node.\n- Add xpath support within transformations\n- Add InclusiveNamespaces prefix list support within exclusive transformations.\n\nBug Fixes:\n- Initialize random number generator for mcrypt_create_iv. (Joan Cornad\u00f3).\n- Fix an interoperability issue with .NET when encrypting data in CBC mode.\n  (Joan Cornad\u00f3).\n", "Copyright (c) 2007-2018, Robert Richards <rrichards@cdatazone.org>.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n  * Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in\n    the documentation and/or other materials provided with the\n    distribution.\n\n  * Neither the name of Robert Richards nor the names of his\n    contributors may be used to endorse or promote products derived\n    from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\nCOPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\nANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.", "<?php\nnamespace RobRichards\\XMLSecLibs;\n\nuse DOMDocument;\nuse DOMElement;\nuse DOMNode;\nuse DOMXPath;\nuse Exception;\nuse RobRichards\\XMLSecLibs\\Utils\\XPath as XPath;\n\n/**\n * xmlseclibs.php\n *\n * Copyright (c) 2007-2019, Robert Richards <rrichards@cdatazone.org>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in\n *     the documentation and/or other materials provided with the\n *     distribution.\n *\n *   * Neither the name of Robert Richards nor the names of his\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @author    Robert Richards <rrichards@cdatazone.org>\n * @copyright 2007-2019 Robert Richards <rrichards@cdatazone.org>\n * @license   http://www.opensource.org/licenses/bsd-license.php  BSD License\n */\n\nclass XMLSecurityDSig\n{\n    const XMLDSIGNS = 'http://www.w3.org/2000/09/xmldsig#';\n    const SHA1 = 'http://www.w3.org/2000/09/xmldsig#sha1';\n    const SHA256 = 'http://www.w3.org/2001/04/xmlenc#sha256';\n    const SHA384 = 'http://www.w3.org/2001/04/xmldsig-more#sha384';\n    const SHA512 = 'http://www.w3.org/2001/04/xmlenc#sha512';\n    const RIPEMD160 = 'http://www.w3.org/2001/04/xmlenc#ripemd160';\n\n    const C14N = 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315';\n    const C14N_COMMENTS = 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments';\n    const EXC_C14N = 'http://www.w3.org/2001/10/xml-exc-c14n#';\n    const EXC_C14N_COMMENTS = 'http://www.w3.org/2001/10/xml-exc-c14n#WithComments';\n\n    const template = '<ds:Signature xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\">\n  <ds:SignedInfo>\n    <ds:SignatureMethod />\n  </ds:SignedInfo>\n</ds:Signature>';\n\n    const BASE_TEMPLATE = '<Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#\">\n  <SignedInfo>\n    <SignatureMethod />\n  </SignedInfo>\n</Signature>';\n\n    /** @var DOMElement|null */\n    public $sigNode = null;\n\n    /** @var array */\n    public $idKeys = array();\n\n    /** @var array */\n    public $idNS = array();\n\n    /** @var string|null */\n    private $signedInfo = null;\n\n    /** @var DomXPath|null */\n    private $xPathCtx = null;\n\n    /** @var string|null */\n    private $canonicalMethod = null;\n\n    /** @var string */\n    private $prefix = '';\n\n    /** @var string */\n    private $searchpfx = 'secdsig';\n\n    /**\n     * This variable contains an associative array of validated nodes.\n     * @var array|null\n     */\n    private $validatedNodes = null;\n\n    /**\n     * @param string $prefix\n     */\n    public function __construct($prefix='ds')\n    {\n        $template = self::BASE_TEMPLATE;\n        if (! empty($prefix)) {\n            $this->prefix = $prefix.':';\n            $search = array(\"<S\", \"</S\", \"xmlns=\");\n            $replace = array(\"<$prefix:S\", \"</$prefix:S\", \"xmlns:$prefix=\");\n            $template = str_replace($search, $replace, $template);\n        }\n        $sigdoc = new DOMDocument();\n        $sigdoc->loadXML($template);\n        $this->sigNode = $sigdoc->documentElement;\n    }\n\n    /**\n     * Reset the XPathObj to null\n     */\n    private function resetXPathObj()\n    {\n        $this->xPathCtx = null;\n    }\n\n    /**\n     * Returns the XPathObj or null if xPathCtx is set and sigNode is empty.\n     *\n     * @return DOMXPath|null\n     */\n    private function getXPathObj()\n    {\n        if (empty($this->xPathCtx) && ! empty($this->sigNode)) {\n            $xpath = new DOMXPath($this->sigNode->ownerDocument);\n            $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n            $this->xPathCtx = $xpath;\n        }\n        return $this->xPathCtx;\n    }\n\n    /**\n     * Generate guid\n     *\n     * @param string $prefix Prefix to use for guid. defaults to pfx\n     *\n     * @return string The generated guid\n     */\n    public static function generateGUID($prefix='pfx')\n    {\n        $uuid = md5(uniqid(mt_rand(), true));\n        $guid = $prefix.substr($uuid, 0, 8).\"-\".\n                substr($uuid, 8, 4).\"-\".\n                substr($uuid, 12, 4).\"-\".\n                substr($uuid, 16, 4).\"-\".\n                substr($uuid, 20, 12);\n        return $guid;\n    }\n\n    /**\n     * Generate guid\n     *\n     * @param string $prefix Prefix to use for guid. defaults to pfx\n     *\n     * @return string The generated guid\n     *\n     * @deprecated Method deprecated in Release 1.4.1\n     */\n    public static function generate_GUID($prefix='pfx')\n    {\n        return self::generateGUID($prefix);\n    }\n\n    /**\n     * @param DOMDocument $objDoc\n     * @param int $pos\n     * @return DOMNode|null\n     */\n    public function locateSignature($objDoc, $pos=0)\n    {\n        if ($objDoc instanceof DOMDocument) {\n            $doc = $objDoc;\n        } else {\n            $doc = $objDoc->ownerDocument;\n        }\n        if ($doc) {\n            $xpath = new DOMXPath($doc);\n            $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n            $query = \".//secdsig:Signature\";\n            $nodeset = $xpath->query($query, $objDoc);\n            $this->sigNode = $nodeset->item($pos);\n            return $this->sigNode;\n        }\n        return null;\n    }\n\n    /**\n     * @param string $name\n     * @param null|string $value\n     * @return DOMElement\n     */\n    public function createNewSignNode($name, $value=null)\n    {\n        $doc = $this->sigNode->ownerDocument;\n        if (! is_null($value)) {\n            $node = $doc->createElementNS(self::XMLDSIGNS, $this->prefix.$name, $value);\n        } else {\n            $node = $doc->createElementNS(self::XMLDSIGNS, $this->prefix.$name);\n        }\n        return $node;\n    }\n\n    /**\n     * @param string $method\n     * @throws Exception\n     */\n    public function setCanonicalMethod($method)\n    {\n        switch ($method) {\n            case 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315':\n            case 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments':\n            case 'http://www.w3.org/2001/10/xml-exc-c14n#':\n            case 'http://www.w3.org/2001/10/xml-exc-c14n#WithComments':\n                $this->canonicalMethod = $method;\n                break;\n            default:\n                throw new Exception('Invalid Canonical Method');\n        }\n        if ($xpath = $this->getXPathObj()) {\n            $query = './'.$this->searchpfx.':SignedInfo';\n            $nodeset = $xpath->query($query, $this->sigNode);\n            if ($sinfo = $nodeset->item(0)) {\n                $query = './'.$this->searchpfx.'CanonicalizationMethod';\n                $nodeset = $xpath->query($query, $sinfo);\n                if (! ($canonNode = $nodeset->item(0))) {\n                    $canonNode = $this->createNewSignNode('CanonicalizationMethod');\n                    $sinfo->insertBefore($canonNode, $sinfo->firstChild);\n                }\n                $canonNode->setAttribute('Algorithm', $this->canonicalMethod);\n            }\n        }\n    }\n\n    /**\n     * @param DOMNode $node\n     * @param string $canonicalmethod\n     * @param null|array $arXPath\n     * @param null|array $prefixList\n     * @return string\n     */\n    private function canonicalizeData($node, $canonicalmethod, $arXPath=null, $prefixList=null)\n    {\n        $exclusive = false;\n        $withComments = false;\n        switch ($canonicalmethod) {\n            case 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315':\n                $exclusive = false;\n                $withComments = false;\n                break;\n            case 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments':\n                $withComments = true;\n                break;\n            case 'http://www.w3.org/2001/10/xml-exc-c14n#':\n                $exclusive = true;\n                break;\n            case 'http://www.w3.org/2001/10/xml-exc-c14n#WithComments':\n                $exclusive = true;\n                $withComments = true;\n                break;\n        }\n\n        if (is_null($arXPath) && ($node instanceof DOMNode) && ($node->ownerDocument !== null) && $node->isSameNode($node->ownerDocument->documentElement)) {\n            /* Check for any PI or comments as they would have been excluded */\n            $element = $node;\n            while ($refnode = $element->previousSibling) {\n                if ($refnode->nodeType == XML_PI_NODE || (($refnode->nodeType == XML_COMMENT_NODE) && $withComments)) {\n                    break;\n                }\n                $element = $refnode;\n            }\n            if ($refnode == null) {\n                $node = $node->ownerDocument;\n            }\n        }\n\n        return $node->C14N($exclusive, $withComments, $arXPath, $prefixList);\n    }\n\n    /**\n     * @return null|string\n     */\n    public function canonicalizeSignedInfo()\n    {\n\n        $doc = $this->sigNode->ownerDocument;\n        $canonicalmethod = null;\n        if ($doc) {\n            $xpath = $this->getXPathObj();\n            $query = \"./secdsig:SignedInfo\";\n            $nodeset = $xpath->query($query, $this->sigNode);\n            if ($signInfoNode = $nodeset->item(0)) {\n                $query = \"./secdsig:CanonicalizationMethod\";\n                $nodeset = $xpath->query($query, $signInfoNode);\n                if ($canonNode = $nodeset->item(0)) {\n                    $canonicalmethod = $canonNode->getAttribute('Algorithm');\n                }\n                $this->signedInfo = $this->canonicalizeData($signInfoNode, $canonicalmethod);\n                return $this->signedInfo;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param string $digestAlgorithm\n     * @param string $data\n     * @param bool $encode\n     * @return string\n     * @throws Exception\n     */\n    public function calculateDigest($digestAlgorithm, $data, $encode = true)\n    {\n        switch ($digestAlgorithm) {\n            case self::SHA1:\n                $alg = 'sha1';\n                break;\n            case self::SHA256:\n                $alg = 'sha256';\n                break;\n            case self::SHA384:\n                $alg = 'sha384';\n                break;\n            case self::SHA512:\n                $alg = 'sha512';\n                break;\n            case self::RIPEMD160:\n                $alg = 'ripemd160';\n                break;\n            default:\n                throw new Exception(\"Cannot validate digest: Unsupported Algorithm <$digestAlgorithm>\");\n        }\n\n        $digest = hash($alg, $data, true);\n        if ($encode) {\n            $digest = base64_encode($digest);\n        }\n        return $digest;\n\n    }\n\n    /**\n     * @param $refNode\n     * @param string $data\n     * @return bool\n     */\n    public function validateDigest($refNode, $data)\n    {\n        $xpath = new DOMXPath($refNode->ownerDocument);\n        $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n        $query = 'string(./secdsig:DigestMethod/@Algorithm)';\n        $digestAlgorithm = $xpath->evaluate($query, $refNode);\n        $digValue = $this->calculateDigest($digestAlgorithm, $data, false);\n        $query = 'string(./secdsig:DigestValue)';\n        $digestValue = $xpath->evaluate($query, $refNode);\n        return ($digValue === base64_decode($digestValue));\n    }\n\n    /**\n     * @param $refNode\n     * @param DOMNode $objData\n     * @param bool $includeCommentNodes\n     * @return string\n     */\n    public function processTransforms($refNode, $objData, $includeCommentNodes = true)\n    {\n        $data = $objData;\n        $xpath = new DOMXPath($refNode->ownerDocument);\n        $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n        $query = './secdsig:Transforms/secdsig:Transform';\n        $nodelist = $xpath->query($query, $refNode);\n        $canonicalMethod = 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315';\n        $arXPath = null;\n        $prefixList = null;\n        foreach ($nodelist AS $transform) {\n            $algorithm = $transform->getAttribute(\"Algorithm\");\n            switch ($algorithm) {\n                case 'http://www.w3.org/2001/10/xml-exc-c14n#':\n                case 'http://www.w3.org/2001/10/xml-exc-c14n#WithComments':\n\n                    if (!$includeCommentNodes) {\n                        /* We remove comment nodes by forcing it to use a canonicalization\n                         * without comments.\n                         */\n                        $canonicalMethod = 'http://www.w3.org/2001/10/xml-exc-c14n#';\n                    } else {\n                        $canonicalMethod = $algorithm;\n                    }\n\n                    $node = $transform->firstChild;\n                    while ($node) {\n                        if ($node->localName == 'InclusiveNamespaces') {\n                            if ($pfx = $node->getAttribute('PrefixList')) {\n                                $arpfx = array();\n                                $pfxlist = explode(\" \", $pfx);\n                                foreach ($pfxlist AS $pfx) {\n                                    $val = trim($pfx);\n                                    if (! empty($val)) {\n                                        $arpfx[] = $val;\n                                    }\n                                }\n                                if (count($arpfx) > 0) {\n                                    $prefixList = $arpfx;\n                                }\n                            }\n                            break;\n                        }\n                        $node = $node->nextSibling;\n                    }\n            break;\n                case 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315':\n                case 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments':\n                    if (!$includeCommentNodes) {\n                        /* We remove comment nodes by forcing it to use a canonicalization\n                         * without comments.\n                         */\n                        $canonicalMethod = 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315';\n                    } else {\n                        $canonicalMethod = $algorithm;\n                    }\n\n                    break;\n                case 'http://www.w3.org/TR/1999/REC-xpath-19991116':\n                    $node = $transform->firstChild;\n                    while ($node) {\n                        if ($node->localName == 'XPath') {\n                            $arXPath = array();\n                            $arXPath['query'] = '(.//. | .//@* | .//namespace::*)['.$node->nodeValue.']';\n                            $arXpath['namespaces'] = array();\n                            $nslist = $xpath->query('./namespace::*', $node);\n                            foreach ($nslist AS $nsnode) {\n                                if ($nsnode->localName != \"xml\") {\n                                    $arXPath['namespaces'][$nsnode->localName] = $nsnode->nodeValue;\n                                }\n                            }\n                            break;\n                        }\n                        $node = $node->nextSibling;\n                    }\n                    break;\n            }\n        }\n        if ($data instanceof DOMNode) {\n            $data = $this->canonicalizeData($objData, $canonicalMethod, $arXPath, $prefixList);\n        }\n        return $data;\n    }\n\n    /**\n     * @param DOMNode $refNode\n     * @return bool\n     */\n    public function processRefNode($refNode)\n    {\n        $dataObject = null;\n\n        /*\n         * Depending on the URI, we may not want to include comments in the result\n         * See: http://www.w3.org/TR/xmldsig-core/#sec-ReferenceProcessingModel\n         */\n        $includeCommentNodes = true;\n\n        if ($uri = $refNode->getAttribute(\"URI\")) {\n            $arUrl = parse_url($uri);\n            if (empty($arUrl['path'])) {\n                if ($identifier = $arUrl['fragment']) {\n\n                    /* This reference identifies a node with the given id by using\n                     * a URI on the form \"#identifier\". This should not include comments.\n                     */\n                    $includeCommentNodes = false;\n\n                    $xPath = new DOMXPath($refNode->ownerDocument);\n                    if ($this->idNS && is_array($this->idNS)) {\n                        foreach ($this->idNS as $nspf => $ns) {\n                            $xPath->registerNamespace($nspf, $ns);\n                        }\n                    }\n                    $iDlist = '@Id=\"'.XPath::filterAttrValue($identifier, XPath::DOUBLE_QUOTE).'\"';\n                    if (is_array($this->idKeys)) {\n                        foreach ($this->idKeys as $idKey) {\n                            $iDlist .= \" or @\".XPath::filterAttrName($idKey).'=\"'.\n                                XPath::filterAttrValue($identifier, XPath::DOUBLE_QUOTE).'\"';\n                        }\n                    }\n                    $query = '//*['.$iDlist.']';\n                    $dataObject = $xPath->query($query)->item(0);\n                } else {\n                    $dataObject = $refNode->ownerDocument;\n                }\n            }\n        } else {\n            /* This reference identifies the root node with an empty URI. This should\n             * not include comments.\n             */\n            $includeCommentNodes = false;\n\n            $dataObject = $refNode->ownerDocument;\n        }\n        $data = $this->processTransforms($refNode, $dataObject, $includeCommentNodes);\n        if (!$this->validateDigest($refNode, $data)) {\n            return false;\n        }\n\n        if ($dataObject instanceof DOMNode) {\n            /* Add this node to the list of validated nodes. */\n            if (! empty($identifier)) {\n                $this->validatedNodes[$identifier] = $dataObject;\n            } else {\n                $this->validatedNodes[] = $dataObject;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param DOMNode $refNode\n     * @return null\n     */\n    public function getRefNodeID($refNode)\n    {\n        if ($uri = $refNode->getAttribute(\"URI\")) {\n            $arUrl = parse_url($uri);\n            if (empty($arUrl['path'])) {\n                if ($identifier = $arUrl['fragment']) {\n                    return $identifier;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return array\n     * @throws Exception\n     */\n    public function getRefIDs()\n    {\n        $refids = array();\n\n        $xpath = $this->getXPathObj();\n        $query = \"./secdsig:SignedInfo/secdsig:Reference\";\n        $nodeset = $xpath->query($query, $this->sigNode);\n        if ($nodeset->length == 0) {\n            throw new Exception(\"Reference nodes not found\");\n        }\n        foreach ($nodeset AS $refNode) {\n            $refids[] = $this->getRefNodeID($refNode);\n        }\n        return $refids;\n    }\n\n    /**\n     * @return bool\n     * @throws Exception\n     */\n    public function validateReference()\n    {\n        $docElem = $this->sigNode->ownerDocument->documentElement;\n        if (! $docElem->isSameNode($this->sigNode)) {\n            if ($this->sigNode->parentNode != null) {\n                $this->sigNode->parentNode->removeChild($this->sigNode);\n            }\n        }\n        $xpath = $this->getXPathObj();\n        $query = \"./secdsig:SignedInfo/secdsig:Reference\";\n        $nodeset = $xpath->query($query, $this->sigNode);\n        if ($nodeset->length == 0) {\n            throw new Exception(\"Reference nodes not found\");\n        }\n\n        /* Initialize/reset the list of validated nodes. */\n        $this->validatedNodes = array();\n\n        foreach ($nodeset AS $refNode) {\n            if (! $this->processRefNode($refNode)) {\n                /* Clear the list of validated nodes. */\n                $this->validatedNodes = null;\n                throw new Exception(\"Reference validation failed\");\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param DOMNode $sinfoNode\n     * @param DOMDocument $node\n     * @param string $algorithm\n     * @param null|array $arTransforms\n     * @param null|array $options\n     */\n    private function addRefInternal($sinfoNode, $node, $algorithm, $arTransforms=null, $options=null)\n    {\n        $prefix = null;\n        $prefix_ns = null;\n        $id_name = 'Id';\n        $overwrite_id  = true;\n        $force_uri = false;\n\n        if (is_array($options)) {\n            $prefix = empty($options['prefix']) ? null : $options['prefix'];\n            $prefix_ns = empty($options['prefix_ns']) ? null : $options['prefix_ns'];\n            $id_name = empty($options['id_name']) ? 'Id' : $options['id_name'];\n            $overwrite_id = !isset($options['overwrite']) ? true : (bool) $options['overwrite'];\n            $force_uri = !isset($options['force_uri']) ? false : (bool) $options['force_uri'];\n        }\n\n        $attname = $id_name;\n        if (! empty($prefix)) {\n            $attname = $prefix.':'.$attname;\n        }\n\n        $refNode = $this->createNewSignNode('Reference');\n        $sinfoNode->appendChild($refNode);\n\n        if (! $node instanceof DOMDocument) {\n            $uri = null;\n            if (! $overwrite_id) {\n                $uri = $prefix_ns ? $node->getAttributeNS($prefix_ns, $id_name) : $node->getAttribute($id_name);\n            }\n            if (empty($uri)) {\n                $uri = self::generateGUID();\n                $node->setAttributeNS($prefix_ns, $attname, $uri);\n            }\n            $refNode->setAttribute(\"URI\", '#'.$uri);\n        } elseif ($force_uri) {\n            $refNode->setAttribute(\"URI\", '');\n        }\n\n        $transNodes = $this->createNewSignNode('Transforms');\n        $refNode->appendChild($transNodes);\n\n        if (is_array($arTransforms)) {\n            foreach ($arTransforms AS $transform) {\n                $transNode = $this->createNewSignNode('Transform');\n                $transNodes->appendChild($transNode);\n                if (is_array($transform) &&\n                    (! empty($transform['http://www.w3.org/TR/1999/REC-xpath-19991116'])) &&\n                    (! empty($transform['http://www.w3.org/TR/1999/REC-xpath-19991116']['query']))) {\n                    $transNode->setAttribute('Algorithm', 'http://www.w3.org/TR/1999/REC-xpath-19991116');\n                    $XPathNode = $this->createNewSignNode('XPath', $transform['http://www.w3.org/TR/1999/REC-xpath-19991116']['query']);\n                    $transNode->appendChild($XPathNode);\n                    if (! empty($transform['http://www.w3.org/TR/1999/REC-xpath-19991116']['namespaces'])) {\n                        foreach ($transform['http://www.w3.org/TR/1999/REC-xpath-19991116']['namespaces'] AS $prefix => $namespace) {\n                            $XPathNode->setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:$prefix\", $namespace);\n                        }\n                    }\n                } else {\n                    $transNode->setAttribute('Algorithm', $transform);\n                }\n            }\n        } elseif (! empty($this->canonicalMethod)) {\n            $transNode = $this->createNewSignNode('Transform');\n            $transNodes->appendChild($transNode);\n            $transNode->setAttribute('Algorithm', $this->canonicalMethod);\n        }\n\n        $canonicalData = $this->processTransforms($refNode, $node);\n        $digValue = $this->calculateDigest($algorithm, $canonicalData);\n\n        $digestMethod = $this->createNewSignNode('DigestMethod');\n        $refNode->appendChild($digestMethod);\n        $digestMethod->setAttribute('Algorithm', $algorithm);\n\n        $digestValue = $this->createNewSignNode('DigestValue', $digValue);\n        $refNode->appendChild($digestValue);\n    }\n\n    /**\n     * @param DOMDocument $node\n     * @param string $algorithm\n     * @param null|array $arTransforms\n     * @param null|array $options\n     */\n    public function addReference($node, $algorithm, $arTransforms=null, $options=null)\n    {\n        if ($xpath = $this->getXPathObj()) {\n            $query = \"./secdsig:SignedInfo\";\n            $nodeset = $xpath->query($query, $this->sigNode);\n            if ($sInfo = $nodeset->item(0)) {\n                $this->addRefInternal($sInfo, $node, $algorithm, $arTransforms, $options);\n            }\n        }\n    }\n\n    /**\n     * @param array $arNodes\n     * @param string $algorithm\n     * @param null|array $arTransforms\n     * @param null|array $options\n     */\n    public function addReferenceList($arNodes, $algorithm, $arTransforms=null, $options=null)\n    {\n        if ($xpath = $this->getXPathObj()) {\n            $query = \"./secdsig:SignedInfo\";\n            $nodeset = $xpath->query($query, $this->sigNode);\n            if ($sInfo = $nodeset->item(0)) {\n                foreach ($arNodes AS $node) {\n                    $this->addRefInternal($sInfo, $node, $algorithm, $arTransforms, $options);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param DOMElement|string $data\n     * @param null|string $mimetype\n     * @param null|string $encoding\n     * @return DOMElement\n     */\n    public function addObject($data, $mimetype=null, $encoding=null)\n    {\n        $objNode = $this->createNewSignNode('Object');\n        $this->sigNode->appendChild($objNode);\n        if (! empty($mimetype)) {\n            $objNode->setAttribute('MimeType', $mimetype);\n        }\n        if (! empty($encoding)) {\n            $objNode->setAttribute('Encoding', $encoding);\n        }\n\n        if ($data instanceof DOMElement) {\n            $newData = $this->sigNode->ownerDocument->importNode($data, true);\n        } else {\n            $newData = $this->sigNode->ownerDocument->createTextNode($data);\n        }\n        $objNode->appendChild($newData);\n\n        return $objNode;\n    }\n\n    /**\n     * @param null|DOMNode $node\n     * @return null|XMLSecurityKey\n     */\n    public function locateKey($node=null)\n    {\n        if (empty($node)) {\n            $node = $this->sigNode;\n        }\n        if (! $node instanceof DOMNode) {\n            return null;\n        }\n        if ($doc = $node->ownerDocument) {\n            $xpath = new DOMXPath($doc);\n            $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n            $query = \"string(./secdsig:SignedInfo/secdsig:SignatureMethod/@Algorithm)\";\n            $algorithm = $xpath->evaluate($query, $node);\n            if ($algorithm) {\n                try {\n                    $objKey = new XMLSecurityKey($algorithm, array('type' => 'public'));\n                } catch (Exception $e) {\n                    return null;\n                }\n                return $objKey;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns:\n     *  Bool when verifying HMAC_SHA1;\n     *  Int otherwise, with following meanings:\n     *    1 on succesful signature verification,\n     *    0 when signature verification failed,\n     *   -1 if an error occurred during processing.\n     *\n     * NOTE: be very careful when checking the int return value, because in\n     * PHP, -1 will be cast to True when in boolean context. Always check the\n     * return value in a strictly typed way, e.g. \"$obj->verify(...) === 1\".\n     *\n     * @param XMLSecurityKey $objKey\n     * @return bool|int\n     * @throws Exception\n     */\n    public function verify($objKey)\n    {\n        $doc = $this->sigNode->ownerDocument;\n        $xpath = new DOMXPath($doc);\n        $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n        $query = \"string(./secdsig:SignatureValue)\";\n        $sigValue = $xpath->evaluate($query, $this->sigNode);\n        if (empty($sigValue)) {\n            throw new Exception(\"Unable to locate SignatureValue\");\n        }\n        return $objKey->verifySignature($this->signedInfo, base64_decode($sigValue));\n    }\n\n    /**\n     * @param XMLSecurityKey $objKey\n     * @param string $data\n     * @return mixed|string\n     */\n    public function signData($objKey, $data)\n    {\n        return $objKey->signData($data);\n    }\n\n    /**\n     * @param XMLSecurityKey $objKey\n     * @param null|DOMNode $appendToNode\n     */\n    public function sign($objKey, $appendToNode = null)\n    {\n        // If we have a parent node append it now so C14N properly works\n        if ($appendToNode != null) {\n            $this->resetXPathObj();\n            $this->appendSignature($appendToNode);\n            $this->sigNode = $appendToNode->lastChild;\n        }\n        if ($xpath = $this->getXPathObj()) {\n            $query = \"./secdsig:SignedInfo\";\n            $nodeset = $xpath->query($query, $this->sigNode);\n            if ($sInfo = $nodeset->item(0)) {\n                $query = \"./secdsig:SignatureMethod\";\n                $nodeset = $xpath->query($query, $sInfo);\n                $sMethod = $nodeset->item(0);\n                $sMethod->setAttribute('Algorithm', $objKey->type);\n                $data = $this->canonicalizeData($sInfo, $this->canonicalMethod);\n                $sigValue = base64_encode($this->signData($objKey, $data));\n                $sigValueNode = $this->createNewSignNode('SignatureValue', $sigValue);\n                if ($infoSibling = $sInfo->nextSibling) {\n                    $infoSibling->parentNode->insertBefore($sigValueNode, $infoSibling);\n                } else {\n                    $this->sigNode->appendChild($sigValueNode);\n                }\n            }\n        }\n    }\n\n    public function appendCert()\n    {\n\n    }\n\n    /**\n     * @param XMLSecurityKey $objKey\n     * @param null|DOMNode $parent\n     */\n    public function appendKey($objKey, $parent=null)\n    {\n        $objKey->serializeKey($parent);\n    }\n\n\n    /**\n     * This function inserts the signature element.\n     *\n     * The signature element will be appended to the element, unless $beforeNode is specified. If $beforeNode\n     * is specified, the signature element will be inserted as the last element before $beforeNode.\n     *\n     * @param DOMNode $node       The node the signature element should be inserted into.\n     * @param DOMNode $beforeNode The node the signature element should be located before.\n     *\n     * @return DOMNode The signature element node\n     */\n    public function insertSignature($node, $beforeNode = null)\n    {\n\n        $document = $node->ownerDocument;\n        $signatureElement = $document->importNode($this->sigNode, true);\n\n        if ($beforeNode == null) {\n            return $node->insertBefore($signatureElement);\n        } else {\n            return $node->insertBefore($signatureElement, $beforeNode);\n        }\n    }\n\n    /**\n     * @param DOMNode $parentNode\n     * @param bool $insertBefore\n     * @return DOMNode\n     */\n    public function appendSignature($parentNode, $insertBefore = false)\n    {\n        $beforeNode = $insertBefore ? $parentNode->firstChild : null;\n        return $this->insertSignature($parentNode, $beforeNode);\n    }\n\n    /**\n     * @param string $cert\n     * @param bool $isPEMFormat\n     * @return string\n     */\n    public static function get509XCert($cert, $isPEMFormat=true)\n    {\n        $certs = self::staticGet509XCerts($cert, $isPEMFormat);\n        if (! empty($certs)) {\n            return $certs[0];\n        }\n        return '';\n    }\n\n    /**\n     * @param string $certs\n     * @param bool $isPEMFormat\n     * @return array\n     */\n    public static function staticGet509XCerts($certs, $isPEMFormat=true)\n    {\n        if ($isPEMFormat) {\n            $data = '';\n            $certlist = array();\n            $arCert = explode(\"\\n\", $certs);\n            $inData = false;\n            foreach ($arCert AS $curData) {\n                if (! $inData) {\n                    if (strncmp($curData, '-----BEGIN CERTIFICATE', 22) == 0) {\n                        $inData = true;\n                    }\n                } else {\n                    if (strncmp($curData, '-----END CERTIFICATE', 20) == 0) {\n                        $inData = false;\n                        $certlist[] = $data;\n                        $data = '';\n                        continue;\n                    }\n                    $data .= trim($curData);\n                }\n            }\n            return $certlist;\n        } else {\n            return array($certs);\n        }\n    }\n\n    /**\n     * @param DOMElement $parentRef\n     * @param string $cert\n     * @param bool $isPEMFormat\n     * @param bool $isURL\n     * @param null|DOMXPath $xpath\n     * @param null|array $options\n     * @throws Exception\n     */\n    public static function staticAdd509Cert($parentRef, $cert, $isPEMFormat=true, $isURL=false, $xpath=null, $options=null)\n    {\n        if ($isURL) {\n            $cert = file_get_contents($cert);\n        }\n        if (! $parentRef instanceof DOMElement) {\n            throw new Exception('Invalid parent Node parameter');\n        }\n        $baseDoc = $parentRef->ownerDocument;\n\n        if (empty($xpath)) {\n            $xpath = new DOMXPath($parentRef->ownerDocument);\n            $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n        }\n\n        $query = \"./secdsig:KeyInfo\";\n        $nodeset = $xpath->query($query, $parentRef);\n        $keyInfo = $nodeset->item(0);\n        $dsig_pfx = '';\n        if (! $keyInfo) {\n            $pfx = $parentRef->lookupPrefix(self::XMLDSIGNS);\n            if (! empty($pfx)) {\n                $dsig_pfx = $pfx.\":\";\n            }\n            $inserted = false;\n            $keyInfo = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'KeyInfo');\n\n            $query = \"./secdsig:Object\";\n            $nodeset = $xpath->query($query, $parentRef);\n            if ($sObject = $nodeset->item(0)) {\n                $sObject->parentNode->insertBefore($keyInfo, $sObject);\n                $inserted = true;\n            }\n\n            if (! $inserted) {\n                $parentRef->appendChild($keyInfo);\n            }\n        } else {\n            $pfx = $keyInfo->lookupPrefix(self::XMLDSIGNS);\n            if (! empty($pfx)) {\n                $dsig_pfx = $pfx.\":\";\n            }\n        }\n\n        // Add all certs if there are more than one\n        $certs = self::staticGet509XCerts($cert, $isPEMFormat);\n\n        // Attach X509 data node\n        $x509DataNode = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'X509Data');\n        $keyInfo->appendChild($x509DataNode);\n\n        $issuerSerial = false;\n        $subjectName = false;\n        if (is_array($options)) {\n            if (! empty($options['issuerSerial'])) {\n                $issuerSerial = true;\n            }\n            if (! empty($options['subjectName'])) {\n                $subjectName = true;\n            }\n        }\n\n        // Attach all certificate nodes and any additional data\n        foreach ($certs as $X509Cert) {\n            if ($issuerSerial || $subjectName) {\n                if ($certData = openssl_x509_parse(\"-----BEGIN CERTIFICATE-----\\n\".chunk_split($X509Cert, 64, \"\\n\").\"-----END CERTIFICATE-----\\n\")) {\n                    if ($subjectName && ! empty($certData['subject'])) {\n                        if (is_array($certData['subject'])) {\n                            $parts = array();\n                            foreach ($certData['subject'] AS $key => $value) {\n                                if (is_array($value)) {\n                                    foreach ($value as $valueElement) {\n                                        array_unshift($parts, \"$key=$valueElement\");\n                                    }\n                                } else {\n                                    array_unshift($parts, \"$key=$value\");\n                                }\n                            }\n                            $subjectNameValue = implode(',', $parts);\n                        } else {\n                            $subjectNameValue = $certData['issuer'];\n                        }\n                        $x509SubjectNode = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'X509SubjectName', $subjectNameValue);\n                        $x509DataNode->appendChild($x509SubjectNode);\n                    }\n                    if ($issuerSerial && ! empty($certData['issuer']) && ! empty($certData['serialNumber'])) {\n                        if (is_array($certData['issuer'])) {\n                            $parts = array();\n                            foreach ($certData['issuer'] AS $key => $value) {\n                                array_unshift($parts, \"$key=$value\");\n                            }\n                            $issuerName = implode(',', $parts);\n                        } else {\n                            $issuerName = $certData['issuer'];\n                        }\n\n                        $x509IssuerNode = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'X509IssuerSerial');\n                        $x509DataNode->appendChild($x509IssuerNode);\n\n                        $x509Node = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'X509IssuerName', $issuerName);\n                        $x509IssuerNode->appendChild($x509Node);\n                        $x509Node = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'X509SerialNumber', $certData['serialNumber']);\n                        $x509IssuerNode->appendChild($x509Node);\n                    }\n                }\n\n            }\n            $x509CertNode = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'X509Certificate', $X509Cert);\n            $x509DataNode->appendChild($x509CertNode);\n        }\n    }\n\n    /**\n     * @param string $cert\n     * @param bool $isPEMFormat\n     * @param bool $isURL\n     * @param null|array $options\n     */\n    public function add509Cert($cert, $isPEMFormat=true, $isURL=false, $options=null)\n    {\n        if ($xpath = $this->getXPathObj()) {\n            self::staticAdd509Cert($this->sigNode, $cert, $isPEMFormat, $isURL, $xpath, $options);\n        }\n    }\n\n    /**\n     * This function appends a node to the KeyInfo.\n     *\n     * The KeyInfo element will be created if one does not exist in the document.\n     *\n     * @param DOMNode $node The node to append to the KeyInfo.\n     *\n     * @return DOMNode The KeyInfo element node\n     */\n    public function appendToKeyInfo($node)\n    {\n        $parentRef = $this->sigNode;\n        $baseDoc = $parentRef->ownerDocument;\n\n        $xpath = $this->getXPathObj();\n        if (empty($xpath)) {\n            $xpath = new DOMXPath($parentRef->ownerDocument);\n            $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n        }\n\n        $query = \"./secdsig:KeyInfo\";\n        $nodeset = $xpath->query($query, $parentRef);\n        $keyInfo = $nodeset->item(0);\n        if (! $keyInfo) {\n            $dsig_pfx = '';\n            $pfx = $parentRef->lookupPrefix(self::XMLDSIGNS);\n            if (! empty($pfx)) {\n                $dsig_pfx = $pfx.\":\";\n            }\n            $inserted = false;\n            $keyInfo = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'KeyInfo');\n\n            $query = \"./secdsig:Object\";\n            $nodeset = $xpath->query($query, $parentRef);\n            if ($sObject = $nodeset->item(0)) {\n                $sObject->parentNode->insertBefore($keyInfo, $sObject);\n                $inserted = true;\n            }\n\n            if (! $inserted) {\n                $parentRef->appendChild($keyInfo);\n            }\n        }\n\n        $keyInfo->appendChild($node);\n\n        return $keyInfo;\n    }\n\n    /**\n     * This function retrieves an associative array of the validated nodes.\n     *\n     * The array will contain the id of the referenced node as the key and the node itself\n     * as the value.\n     *\n     * Returns:\n     *  An associative array of validated nodes or null if no nodes have been validated.\n     *\n     *  @return array Associative array of validated nodes\n     */\n    public function getValidatedNodes()\n    {\n        return $this->validatedNodes;\n    }\n}\n", "<?php\n/**\n * xmlseclibs.php\n *\n * Copyright (c) 2007-2019, Robert Richards <rrichards@cdatazone.org>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in\n *     the documentation and/or other materials provided with the\n *     distribution.\n *\n *   * Neither the name of Robert Richards nor the names of his\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @author    Robert Richards <rrichards@cdatazone.org>\n * @copyright 2007-2019 Robert Richards <rrichards@cdatazone.org>\n * @license   http://www.opensource.org/licenses/bsd-license.php  BSD License\n * @version   3.0.4-dev\n */\n\n$xmlseclibs_srcdir = dirname(__FILE__) . '/src/';\nrequire $xmlseclibs_srcdir . '/XMLSecurityKey.php';\nrequire $xmlseclibs_srcdir . '/XMLSecurityDSig.php';\nrequire $xmlseclibs_srcdir . '/XMLSecEnc.php';\nrequire $xmlseclibs_srcdir . '/Utils/XPath.php';\n"], "fixing_code": ["xmlseclibs.php\n|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n06, Nov 2019, 3.0.4\nSecurity Improvements:\n- Insure only a single SignedInfo element exists within a signature during \n  verification. Refs CVE-2019-3465.\nBug Fixes:\n- Fix variable casing.\n\n15, Nov 2018, 3.0.3\nBug Fixes:\n- Fix casing of class name. (Willem Stuursma-Ruwen)\n- Fix Xpath casing. (Tim van Dijen)\n\nImprovements:\n- Make PCRE2 compliant. (Stefan Winter)\n- Add PHP 7.3 support. (Stefan Winter)\n\n27, Sep 2018, 3.0.2\nSecurity Improvements:\n- OpenSSL is now a requirement rather than suggestion. (Slaven Bacelic)\n- Filter input to avoid XPath injection. (Jaime P\u00e9rez)\n\nBug Fixes:\n- Fix missing parentheses (Tim van Dijen)\n\nImprovements:\n- Use strict comparison operator to compare digest values. (Jaime P\u00e9rez)\n- Remove call to file_get_contents that doesn't even work. (Jaime P\u00e9rez)\n- Document potentially dangerous return value behaviour. (Thijs Kinkhorst)\n\n31, Aug 2017, 3.0.1\nBug Fixes:\n- Fixed missing () in function call. (Dennis V\u00e6versted)\n\nImprovements:\n- Add OneLogin to supported software.\n- Add .gitattributes to remove unneeded files. (Filippo Tessarotto)\n- Fix bug in example code. (Dan Church)\n- Travis: add PHP 7.1, move hhvm to allowed failures. (Thijs Kinkhorst)\n- Drop failing extract-win-cert test (Thijs Kinkhorst). (Thijs Kinkhorst)\n- Add comments to warn about return values of verify(). (Thijs Kinkhorst)\n- Fix tests to properly check return code of verify(). (Thijs Kinkhorst)\n- Restore support for PHP >= 5.4. (Jaime P\u00e9rez)\n\n25, May 2017, 3.0.0\nImprovements:\n- Remove use of mcrypt (skymeyer)\n\n08, Sep 2016, 2.0.1\nBug Fixes:\n- Strip whitespace characters when parsing X509Certificate. fixes #84\n  (klemen.bratec)\n- Certificate 'subject' values can be arrays. fixes #80 (Andreas Stangl)\n- HHVM signing node with ID attribute w/out namespace regenerates ID value.\n  fixes #88 (Milos Tomic)\n\nImprovements:\n- Fix typos and add some PHPDoc Blocks. (gfaust-qb)\n- Update lightSAML link. (Milos Tomic)\n- Update copyright dates.\n\n31, Jul 2015, 2.0.0\nFeatures:\n- Namespace support. Classes now in the RobRichards\\XMLSecLibs\\ namespace.\n\nImprovements:\n- Dropped support for PHP 5.2\n\n31, Jul 2015, 1.4.1\nBug Fixes:\n- Allow for large digest values that may have line breaks. fixes #62\n\nFeatures:\n- Support for locating specific signature when multiple exist in \n  document. (griga3k)\n\nImprovements:\n- Add optional argument to XMLSecurityDSig to define the prefix to be used, \n  also allowing for null to use no prefix, for the dsig namespace. fixes #13\n- Code cleanup\n- Depreciated XMLSecurityDSig::generate_GUID for XMLSecurityDSig::generateGUID\n\n23, Jun 2015, 1.4.0\nFeatures:\n- Support for PSR-0 standard.\n- Support for X509SubjectName. (Milos Tomic)\n- Add HMAC-SHA1 support.\n\nImprovements:\n- Add how to install to README. (Bernardo Vieira da Silva)\n- Code cleanup. (Jaime P\u00e9rez)\n- Normalilze tests. (Hidde Wieringa)\n- Add basic usage to README. (Hidde Wieringa)\n\n21, May 2015, 1.3.2\nBug Fixes:\n- Fix Undefined variable notice. (dpieper85)\n- Fix typo when setting MimeType attribute. (Eugene OZ)\n- Fix validateReference() with enveloping signatures\n\nFeatures:\n- canonicalizeData performance optimization. (Jaime P\u00e9rez)\n- Add composer support (Maks3w)\n\n19, Jun 2013, 1.3.1\nFeatures:\n- return encrypted node from XMLSecEnc::encryptNode() when replace is set to \n  false. (Olav)\n- Add support for RSA SHA384 and RSA_SHA512 and SHA384 digest. (Jaime P\u008erez)\n- Add options parameter to the add cert methods.\n- Add optional issuerSerial creation with cert\n\nBug Fixes:\n- Fix persisted Id when namespaced. (Koen Thomeer)\n\nImprovements:\n- Add LICENSE file\n- Convert CHANGELOG.txt to UTF-8\n\n26, Sep 2011, 1.3.0\nFeatures:\n- Add param to append sig to node when signing. Fixes a problem when using \n  inclusive canonicalization to append a signature within a namespaced subtree.\n  ex. $objDSig->sign($objKey, $appendToNode); \n- Add ability to encrypt by reference\n- Add support for refences within an encrypted key\n- Add thumbprint generation capability (XMLSecurityKey->getX509Thumbprint() and \n  XMLSecurityKey::getRawThumbprint($cert))\n- Return signature element node from XMLSecurityDSig::insertSignature() and \n  XMLSecurityDSig::appendSignature() methods\n- Support for <ds:RetrievalMethod> with simple URI Id reference.\n- Add XMLSecurityKey::getSymmetricKeySize() method (Olav)\n- Add XMLSecEnc::getCipherValue() method (Olav)\n- Improve XMLSecurityKey:generateSessionKey() logic (Olav)\n\nBug Fixes:\n- Change split() to explode() as split is now depreciated\n- ds:References using empty or simple URI Id reference should never include \n  comments in canonicalized data.\n- Make sure that the elements in EncryptedData are emitted in the correct \n  sequence.\n\n11 Jan 2010, 1.2.2\nFeatures:\n- Add support XPath support when creating signature. Provides support for \n  working with EBXML documents.\n- Add reference option to force creation of URI attribute. For use\n  when adding a DOM Document where by default no URI attribute is added.\n- Add support for RSA-SHA256\n\nBug Fixes:\n- fix bug #5: createDOMDocumentFragment() in decryptNode when data is node \n  content (patch by Francois Wang)\n\n\n08 Jul 2008, 1.2.1\nFeatures:\n- Attempt to use mhash when hash extension is not present. (Alfredo Cubitos).\n- Add fallback to built-in sha1 if both hash and mhash are not available and \n  throw error for other for other missing hashes. (patch by Olav Morken).\n- Add getX509Certificate method to retrieve the x509 cert used for Key. \n  (patch by Olav Morken).\n- Add getValidatedNodes method to retrieve the elements signed by the \n  signature. (patch by Olav Morken).\n- Add insertSignature method for precision signature insertion. Merge \n  functionality from appendSignature in the process. (Olav Morken, Rob).\n- Finally add some tests\n\nBug Fixes:\n- Fix canonicalization for Document node when using PHP < 5.2.\n- Add padding for RSA_SHA1. (patch by Olav Morken).\n\n\n27 Nov 2007, 1.2.0\nFeatures:\n- New addReference/List option (overwrite). Boolean flag indicating if URI\n  value should be overwritten if already existing within document.\n  Default is TRUE to maintain BC.\n\n18 Nov 2007, 1.1.2\nBug Fixes:\n- Remove closing PHP tag to fix extra whitespace characters from being output\n\n11 Nov 2007, 1.1.1\nFeatures:\n- Add getRefNodeID() and getRefIDs() methods missed in previous release.\n  Provide functionality to find URIs of existing reference nodes.\n  Required by simpleSAMLphp project\n\nBug Fixes:\n- Remove erroneous whitespace causing issues under certain circumastances.\n\n18 Oct 2007, 1.1.0\nFeatures:\n- Enable creation of enveloping signature. This allows the creation of\n  managed information cards.\n- Add addObject method for enveloping signatures.\n- Add staticGet509XCerts method. Chained certificates within a PEM file can\n  now be added within the X509Data node.\n- Add xpath support within transformations\n- Add InclusiveNamespaces prefix list support within exclusive transformations.\n\nBug Fixes:\n- Initialize random number generator for mcrypt_create_iv. (Joan Cornad\u00f3).\n- Fix an interoperability issue with .NET when encrypting data in CBC mode.\n  (Joan Cornad\u00f3).\n", "Copyright (c) 2007-2019, Robert Richards <rrichards@cdatazone.org>.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n  * Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in\n    the documentation and/or other materials provided with the\n    distribution.\n\n  * Neither the name of Robert Richards nor the names of his\n    contributors may be used to endorse or promote products derived\n    from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\nCOPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\nANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.", "<?php\nnamespace RobRichards\\XMLSecLibs;\n\nuse DOMDocument;\nuse DOMElement;\nuse DOMNode;\nuse DOMXPath;\nuse Exception;\nuse RobRichards\\XMLSecLibs\\Utils\\XPath as XPath;\n\n/**\n * xmlseclibs.php\n *\n * Copyright (c) 2007-2019, Robert Richards <rrichards@cdatazone.org>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in\n *     the documentation and/or other materials provided with the\n *     distribution.\n *\n *   * Neither the name of Robert Richards nor the names of his\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @author    Robert Richards <rrichards@cdatazone.org>\n * @copyright 2007-2019 Robert Richards <rrichards@cdatazone.org>\n * @license   http://www.opensource.org/licenses/bsd-license.php  BSD License\n */\n\nclass XMLSecurityDSig\n{\n    const XMLDSIGNS = 'http://www.w3.org/2000/09/xmldsig#';\n    const SHA1 = 'http://www.w3.org/2000/09/xmldsig#sha1';\n    const SHA256 = 'http://www.w3.org/2001/04/xmlenc#sha256';\n    const SHA384 = 'http://www.w3.org/2001/04/xmldsig-more#sha384';\n    const SHA512 = 'http://www.w3.org/2001/04/xmlenc#sha512';\n    const RIPEMD160 = 'http://www.w3.org/2001/04/xmlenc#ripemd160';\n\n    const C14N = 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315';\n    const C14N_COMMENTS = 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments';\n    const EXC_C14N = 'http://www.w3.org/2001/10/xml-exc-c14n#';\n    const EXC_C14N_COMMENTS = 'http://www.w3.org/2001/10/xml-exc-c14n#WithComments';\n\n    const template = '<ds:Signature xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\">\n  <ds:SignedInfo>\n    <ds:SignatureMethod />\n  </ds:SignedInfo>\n</ds:Signature>';\n\n    const BASE_TEMPLATE = '<Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#\">\n  <SignedInfo>\n    <SignatureMethod />\n  </SignedInfo>\n</Signature>';\n\n    /** @var DOMElement|null */\n    public $sigNode = null;\n\n    /** @var array */\n    public $idKeys = array();\n\n    /** @var array */\n    public $idNS = array();\n\n    /** @var string|null */\n    private $signedInfo = null;\n\n    /** @var DomXPath|null */\n    private $xPathCtx = null;\n\n    /** @var string|null */\n    private $canonicalMethod = null;\n\n    /** @var string */\n    private $prefix = '';\n\n    /** @var string */\n    private $searchpfx = 'secdsig';\n\n    /**\n     * This variable contains an associative array of validated nodes.\n     * @var array|null\n     */\n    private $validatedNodes = null;\n\n    /**\n     * @param string $prefix\n     */\n    public function __construct($prefix='ds')\n    {\n        $template = self::BASE_TEMPLATE;\n        if (! empty($prefix)) {\n            $this->prefix = $prefix.':';\n            $search = array(\"<S\", \"</S\", \"xmlns=\");\n            $replace = array(\"<$prefix:S\", \"</$prefix:S\", \"xmlns:$prefix=\");\n            $template = str_replace($search, $replace, $template);\n        }\n        $sigdoc = new DOMDocument();\n        $sigdoc->loadXML($template);\n        $this->sigNode = $sigdoc->documentElement;\n    }\n\n    /**\n     * Reset the XPathObj to null\n     */\n    private function resetXPathObj()\n    {\n        $this->xPathCtx = null;\n    }\n\n    /**\n     * Returns the XPathObj or null if xPathCtx is set and sigNode is empty.\n     *\n     * @return DOMXPath|null\n     */\n    private function getXPathObj()\n    {\n        if (empty($this->xPathCtx) && ! empty($this->sigNode)) {\n            $xpath = new DOMXPath($this->sigNode->ownerDocument);\n            $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n            $this->xPathCtx = $xpath;\n        }\n        return $this->xPathCtx;\n    }\n\n    /**\n     * Generate guid\n     *\n     * @param string $prefix Prefix to use for guid. defaults to pfx\n     *\n     * @return string The generated guid\n     */\n    public static function generateGUID($prefix='pfx')\n    {\n        $uuid = md5(uniqid(mt_rand(), true));\n        $guid = $prefix.substr($uuid, 0, 8).\"-\".\n                substr($uuid, 8, 4).\"-\".\n                substr($uuid, 12, 4).\"-\".\n                substr($uuid, 16, 4).\"-\".\n                substr($uuid, 20, 12);\n        return $guid;\n    }\n\n    /**\n     * Generate guid\n     *\n     * @param string $prefix Prefix to use for guid. defaults to pfx\n     *\n     * @return string The generated guid\n     *\n     * @deprecated Method deprecated in Release 1.4.1\n     */\n    public static function generate_GUID($prefix='pfx')\n    {\n        return self::generateGUID($prefix);\n    }\n\n    /**\n     * @param DOMDocument $objDoc\n     * @param int $pos\n     * @return DOMNode|null\n     */\n    public function locateSignature($objDoc, $pos=0)\n    {\n        if ($objDoc instanceof DOMDocument) {\n            $doc = $objDoc;\n        } else {\n            $doc = $objDoc->ownerDocument;\n        }\n        if ($doc) {\n            $xpath = new DOMXPath($doc);\n            $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n            $query = \".//secdsig:Signature\";\n            $nodeset = $xpath->query($query, $objDoc);\n            $this->sigNode = $nodeset->item($pos);\n            $query = \"./secdsig:SignedInfo\";\n            $nodeset = $xpath->query($query, $this->sigNode);\n            if ($nodeset->length > 1) {\n                throw new Exception(\"Invalid structure - Too many SignedInfo elements found\");\n            }\n            return $this->sigNode;\n        }\n        return null;\n    }\n\n    /**\n     * @param string $name\n     * @param null|string $value\n     * @return DOMElement\n     */\n    public function createNewSignNode($name, $value=null)\n    {\n        $doc = $this->sigNode->ownerDocument;\n        if (! is_null($value)) {\n            $node = $doc->createElementNS(self::XMLDSIGNS, $this->prefix.$name, $value);\n        } else {\n            $node = $doc->createElementNS(self::XMLDSIGNS, $this->prefix.$name);\n        }\n        return $node;\n    }\n\n    /**\n     * @param string $method\n     * @throws Exception\n     */\n    public function setCanonicalMethod($method)\n    {\n        switch ($method) {\n            case 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315':\n            case 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments':\n            case 'http://www.w3.org/2001/10/xml-exc-c14n#':\n            case 'http://www.w3.org/2001/10/xml-exc-c14n#WithComments':\n                $this->canonicalMethod = $method;\n                break;\n            default:\n                throw new Exception('Invalid Canonical Method');\n        }\n        if ($xpath = $this->getXPathObj()) {\n            $query = './'.$this->searchpfx.':SignedInfo';\n            $nodeset = $xpath->query($query, $this->sigNode);\n            if ($sinfo = $nodeset->item(0)) {\n                $query = './'.$this->searchpfx.'CanonicalizationMethod';\n                $nodeset = $xpath->query($query, $sinfo);\n                if (! ($canonNode = $nodeset->item(0))) {\n                    $canonNode = $this->createNewSignNode('CanonicalizationMethod');\n                    $sinfo->insertBefore($canonNode, $sinfo->firstChild);\n                }\n                $canonNode->setAttribute('Algorithm', $this->canonicalMethod);\n            }\n        }\n    }\n\n    /**\n     * @param DOMNode $node\n     * @param string $canonicalmethod\n     * @param null|array $arXPath\n     * @param null|array $prefixList\n     * @return string\n     */\n    private function canonicalizeData($node, $canonicalmethod, $arXPath=null, $prefixList=null)\n    {\n        $exclusive = false;\n        $withComments = false;\n        switch ($canonicalmethod) {\n            case 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315':\n                $exclusive = false;\n                $withComments = false;\n                break;\n            case 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments':\n                $withComments = true;\n                break;\n            case 'http://www.w3.org/2001/10/xml-exc-c14n#':\n                $exclusive = true;\n                break;\n            case 'http://www.w3.org/2001/10/xml-exc-c14n#WithComments':\n                $exclusive = true;\n                $withComments = true;\n                break;\n        }\n\n        if (is_null($arXPath) && ($node instanceof DOMNode) && ($node->ownerDocument !== null) && $node->isSameNode($node->ownerDocument->documentElement)) {\n            /* Check for any PI or comments as they would have been excluded */\n            $element = $node;\n            while ($refnode = $element->previousSibling) {\n                if ($refnode->nodeType == XML_PI_NODE || (($refnode->nodeType == XML_COMMENT_NODE) && $withComments)) {\n                    break;\n                }\n                $element = $refnode;\n            }\n            if ($refnode == null) {\n                $node = $node->ownerDocument;\n            }\n        }\n\n        return $node->C14N($exclusive, $withComments, $arXPath, $prefixList);\n    }\n\n    /**\n     * @return null|string\n     */\n    public function canonicalizeSignedInfo()\n    {\n\n        $doc = $this->sigNode->ownerDocument;\n        $canonicalmethod = null;\n        if ($doc) {\n            $xpath = $this->getXPathObj();\n            $query = \"./secdsig:SignedInfo\";\n            $nodeset = $xpath->query($query, $this->sigNode);\n            if ($nodeset->length > 1) {\n                throw new Exception(\"Invalid structure - Too many SignedInfo elements found\");\n            }\n            if ($signInfoNode = $nodeset->item(0)) {\n                $query = \"./secdsig:CanonicalizationMethod\";\n                $nodeset = $xpath->query($query, $signInfoNode);\n                if ($canonNode = $nodeset->item(0)) {\n                    $canonicalmethod = $canonNode->getAttribute('Algorithm');\n                }\n                $this->signedInfo = $this->canonicalizeData($signInfoNode, $canonicalmethod);\n                return $this->signedInfo;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param string $digestAlgorithm\n     * @param string $data\n     * @param bool $encode\n     * @return string\n     * @throws Exception\n     */\n    public function calculateDigest($digestAlgorithm, $data, $encode = true)\n    {\n        switch ($digestAlgorithm) {\n            case self::SHA1:\n                $alg = 'sha1';\n                break;\n            case self::SHA256:\n                $alg = 'sha256';\n                break;\n            case self::SHA384:\n                $alg = 'sha384';\n                break;\n            case self::SHA512:\n                $alg = 'sha512';\n                break;\n            case self::RIPEMD160:\n                $alg = 'ripemd160';\n                break;\n            default:\n                throw new Exception(\"Cannot validate digest: Unsupported Algorithm <$digestAlgorithm>\");\n        }\n\n        $digest = hash($alg, $data, true);\n        if ($encode) {\n            $digest = base64_encode($digest);\n        }\n        return $digest;\n\n    }\n\n    /**\n     * @param $refNode\n     * @param string $data\n     * @return bool\n     */\n    public function validateDigest($refNode, $data)\n    {\n        $xpath = new DOMXPath($refNode->ownerDocument);\n        $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n        $query = 'string(./secdsig:DigestMethod/@Algorithm)';\n        $digestAlgorithm = $xpath->evaluate($query, $refNode);\n        $digValue = $this->calculateDigest($digestAlgorithm, $data, false);\n        $query = 'string(./secdsig:DigestValue)';\n        $digestValue = $xpath->evaluate($query, $refNode);\n        return ($digValue === base64_decode($digestValue));\n    }\n\n    /**\n     * @param $refNode\n     * @param DOMNode $objData\n     * @param bool $includeCommentNodes\n     * @return string\n     */\n    public function processTransforms($refNode, $objData, $includeCommentNodes = true)\n    {\n        $data = $objData;\n        $xpath = new DOMXPath($refNode->ownerDocument);\n        $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n        $query = './secdsig:Transforms/secdsig:Transform';\n        $nodelist = $xpath->query($query, $refNode);\n        $canonicalMethod = 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315';\n        $arXPath = null;\n        $prefixList = null;\n        foreach ($nodelist AS $transform) {\n            $algorithm = $transform->getAttribute(\"Algorithm\");\n            switch ($algorithm) {\n                case 'http://www.w3.org/2001/10/xml-exc-c14n#':\n                case 'http://www.w3.org/2001/10/xml-exc-c14n#WithComments':\n\n                    if (!$includeCommentNodes) {\n                        /* We remove comment nodes by forcing it to use a canonicalization\n                         * without comments.\n                         */\n                        $canonicalMethod = 'http://www.w3.org/2001/10/xml-exc-c14n#';\n                    } else {\n                        $canonicalMethod = $algorithm;\n                    }\n\n                    $node = $transform->firstChild;\n                    while ($node) {\n                        if ($node->localName == 'InclusiveNamespaces') {\n                            if ($pfx = $node->getAttribute('PrefixList')) {\n                                $arpfx = array();\n                                $pfxlist = explode(\" \", $pfx);\n                                foreach ($pfxlist AS $pfx) {\n                                    $val = trim($pfx);\n                                    if (! empty($val)) {\n                                        $arpfx[] = $val;\n                                    }\n                                }\n                                if (count($arpfx) > 0) {\n                                    $prefixList = $arpfx;\n                                }\n                            }\n                            break;\n                        }\n                        $node = $node->nextSibling;\n                    }\n            break;\n                case 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315':\n                case 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments':\n                    if (!$includeCommentNodes) {\n                        /* We remove comment nodes by forcing it to use a canonicalization\n                         * without comments.\n                         */\n                        $canonicalMethod = 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315';\n                    } else {\n                        $canonicalMethod = $algorithm;\n                    }\n\n                    break;\n                case 'http://www.w3.org/TR/1999/REC-xpath-19991116':\n                    $node = $transform->firstChild;\n                    while ($node) {\n                        if ($node->localName == 'XPath') {\n                            $arXPath = array();\n                            $arXPath['query'] = '(.//. | .//@* | .//namespace::*)['.$node->nodeValue.']';\n                            $arXPath['namespaces'] = array();\n                            $nslist = $xpath->query('./namespace::*', $node);\n                            foreach ($nslist AS $nsnode) {\n                                if ($nsnode->localName != \"xml\") {\n                                    $arXPath['namespaces'][$nsnode->localName] = $nsnode->nodeValue;\n                                }\n                            }\n                            break;\n                        }\n                        $node = $node->nextSibling;\n                    }\n                    break;\n            }\n        }\n        if ($data instanceof DOMNode) {\n            $data = $this->canonicalizeData($objData, $canonicalMethod, $arXPath, $prefixList);\n        }\n        return $data;\n    }\n\n    /**\n     * @param DOMNode $refNode\n     * @return bool\n     */\n    public function processRefNode($refNode)\n    {\n        $dataObject = null;\n\n        /*\n         * Depending on the URI, we may not want to include comments in the result\n         * See: http://www.w3.org/TR/xmldsig-core/#sec-ReferenceProcessingModel\n         */\n        $includeCommentNodes = true;\n\n        if ($uri = $refNode->getAttribute(\"URI\")) {\n            $arUrl = parse_url($uri);\n            if (empty($arUrl['path'])) {\n                if ($identifier = $arUrl['fragment']) {\n\n                    /* This reference identifies a node with the given id by using\n                     * a URI on the form \"#identifier\". This should not include comments.\n                     */\n                    $includeCommentNodes = false;\n\n                    $xPath = new DOMXPath($refNode->ownerDocument);\n                    if ($this->idNS && is_array($this->idNS)) {\n                        foreach ($this->idNS as $nspf => $ns) {\n                            $xPath->registerNamespace($nspf, $ns);\n                        }\n                    }\n                    $iDlist = '@Id=\"'.XPath::filterAttrValue($identifier, XPath::DOUBLE_QUOTE).'\"';\n                    if (is_array($this->idKeys)) {\n                        foreach ($this->idKeys as $idKey) {\n                            $iDlist .= \" or @\".XPath::filterAttrName($idKey).'=\"'.\n                                XPath::filterAttrValue($identifier, XPath::DOUBLE_QUOTE).'\"';\n                        }\n                    }\n                    $query = '//*['.$iDlist.']';\n                    $dataObject = $xPath->query($query)->item(0);\n                } else {\n                    $dataObject = $refNode->ownerDocument;\n                }\n            }\n        } else {\n            /* This reference identifies the root node with an empty URI. This should\n             * not include comments.\n             */\n            $includeCommentNodes = false;\n\n            $dataObject = $refNode->ownerDocument;\n        }\n        $data = $this->processTransforms($refNode, $dataObject, $includeCommentNodes);\n        if (!$this->validateDigest($refNode, $data)) {\n            return false;\n        }\n\n        if ($dataObject instanceof DOMNode) {\n            /* Add this node to the list of validated nodes. */\n            if (! empty($identifier)) {\n                $this->validatedNodes[$identifier] = $dataObject;\n            } else {\n                $this->validatedNodes[] = $dataObject;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param DOMNode $refNode\n     * @return null\n     */\n    public function getRefNodeID($refNode)\n    {\n        if ($uri = $refNode->getAttribute(\"URI\")) {\n            $arUrl = parse_url($uri);\n            if (empty($arUrl['path'])) {\n                if ($identifier = $arUrl['fragment']) {\n                    return $identifier;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return array\n     * @throws Exception\n     */\n    public function getRefIDs()\n    {\n        $refids = array();\n\n        $xpath = $this->getXPathObj();\n        $query = \"./secdsig:SignedInfo[1]/secdsig:Reference\";\n        $nodeset = $xpath->query($query, $this->sigNode);\n        if ($nodeset->length == 0) {\n            throw new Exception(\"Reference nodes not found\");\n        }\n        foreach ($nodeset AS $refNode) {\n            $refids[] = $this->getRefNodeID($refNode);\n        }\n        return $refids;\n    }\n\n    /**\n     * @return bool\n     * @throws Exception\n     */\n    public function validateReference()\n    {\n        $docElem = $this->sigNode->ownerDocument->documentElement;\n        if (! $docElem->isSameNode($this->sigNode)) {\n            if ($this->sigNode->parentNode != null) {\n                $this->sigNode->parentNode->removeChild($this->sigNode);\n            }\n        }\n        $xpath = $this->getXPathObj();\n        $query = \"./secdsig:SignedInfo[1]/secdsig:Reference\";\n        $nodeset = $xpath->query($query, $this->sigNode);\n        if ($nodeset->length == 0) {\n            throw new Exception(\"Reference nodes not found\");\n        }\n\n        /* Initialize/reset the list of validated nodes. */\n        $this->validatedNodes = array();\n\n        foreach ($nodeset AS $refNode) {\n            if (! $this->processRefNode($refNode)) {\n                /* Clear the list of validated nodes. */\n                $this->validatedNodes = null;\n                throw new Exception(\"Reference validation failed\");\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param DOMNode $sinfoNode\n     * @param DOMDocument $node\n     * @param string $algorithm\n     * @param null|array $arTransforms\n     * @param null|array $options\n     */\n    private function addRefInternal($sinfoNode, $node, $algorithm, $arTransforms=null, $options=null)\n    {\n        $prefix = null;\n        $prefix_ns = null;\n        $id_name = 'Id';\n        $overwrite_id  = true;\n        $force_uri = false;\n\n        if (is_array($options)) {\n            $prefix = empty($options['prefix']) ? null : $options['prefix'];\n            $prefix_ns = empty($options['prefix_ns']) ? null : $options['prefix_ns'];\n            $id_name = empty($options['id_name']) ? 'Id' : $options['id_name'];\n            $overwrite_id = !isset($options['overwrite']) ? true : (bool) $options['overwrite'];\n            $force_uri = !isset($options['force_uri']) ? false : (bool) $options['force_uri'];\n        }\n\n        $attname = $id_name;\n        if (! empty($prefix)) {\n            $attname = $prefix.':'.$attname;\n        }\n\n        $refNode = $this->createNewSignNode('Reference');\n        $sinfoNode->appendChild($refNode);\n\n        if (! $node instanceof DOMDocument) {\n            $uri = null;\n            if (! $overwrite_id) {\n                $uri = $prefix_ns ? $node->getAttributeNS($prefix_ns, $id_name) : $node->getAttribute($id_name);\n            }\n            if (empty($uri)) {\n                $uri = self::generateGUID();\n                $node->setAttributeNS($prefix_ns, $attname, $uri);\n            }\n            $refNode->setAttribute(\"URI\", '#'.$uri);\n        } elseif ($force_uri) {\n            $refNode->setAttribute(\"URI\", '');\n        }\n\n        $transNodes = $this->createNewSignNode('Transforms');\n        $refNode->appendChild($transNodes);\n\n        if (is_array($arTransforms)) {\n            foreach ($arTransforms AS $transform) {\n                $transNode = $this->createNewSignNode('Transform');\n                $transNodes->appendChild($transNode);\n                if (is_array($transform) &&\n                    (! empty($transform['http://www.w3.org/TR/1999/REC-xpath-19991116'])) &&\n                    (! empty($transform['http://www.w3.org/TR/1999/REC-xpath-19991116']['query']))) {\n                    $transNode->setAttribute('Algorithm', 'http://www.w3.org/TR/1999/REC-xpath-19991116');\n                    $XPathNode = $this->createNewSignNode('XPath', $transform['http://www.w3.org/TR/1999/REC-xpath-19991116']['query']);\n                    $transNode->appendChild($XPathNode);\n                    if (! empty($transform['http://www.w3.org/TR/1999/REC-xpath-19991116']['namespaces'])) {\n                        foreach ($transform['http://www.w3.org/TR/1999/REC-xpath-19991116']['namespaces'] AS $prefix => $namespace) {\n                            $XPathNode->setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:$prefix\", $namespace);\n                        }\n                    }\n                } else {\n                    $transNode->setAttribute('Algorithm', $transform);\n                }\n            }\n        } elseif (! empty($this->canonicalMethod)) {\n            $transNode = $this->createNewSignNode('Transform');\n            $transNodes->appendChild($transNode);\n            $transNode->setAttribute('Algorithm', $this->canonicalMethod);\n        }\n\n        $canonicalData = $this->processTransforms($refNode, $node);\n        $digValue = $this->calculateDigest($algorithm, $canonicalData);\n\n        $digestMethod = $this->createNewSignNode('DigestMethod');\n        $refNode->appendChild($digestMethod);\n        $digestMethod->setAttribute('Algorithm', $algorithm);\n\n        $digestValue = $this->createNewSignNode('DigestValue', $digValue);\n        $refNode->appendChild($digestValue);\n    }\n\n    /**\n     * @param DOMDocument $node\n     * @param string $algorithm\n     * @param null|array $arTransforms\n     * @param null|array $options\n     */\n    public function addReference($node, $algorithm, $arTransforms=null, $options=null)\n    {\n        if ($xpath = $this->getXPathObj()) {\n            $query = \"./secdsig:SignedInfo\";\n            $nodeset = $xpath->query($query, $this->sigNode);\n            if ($sInfo = $nodeset->item(0)) {\n                $this->addRefInternal($sInfo, $node, $algorithm, $arTransforms, $options);\n            }\n        }\n    }\n\n    /**\n     * @param array $arNodes\n     * @param string $algorithm\n     * @param null|array $arTransforms\n     * @param null|array $options\n     */\n    public function addReferenceList($arNodes, $algorithm, $arTransforms=null, $options=null)\n    {\n        if ($xpath = $this->getXPathObj()) {\n            $query = \"./secdsig:SignedInfo\";\n            $nodeset = $xpath->query($query, $this->sigNode);\n            if ($sInfo = $nodeset->item(0)) {\n                foreach ($arNodes AS $node) {\n                    $this->addRefInternal($sInfo, $node, $algorithm, $arTransforms, $options);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param DOMElement|string $data\n     * @param null|string $mimetype\n     * @param null|string $encoding\n     * @return DOMElement\n     */\n    public function addObject($data, $mimetype=null, $encoding=null)\n    {\n        $objNode = $this->createNewSignNode('Object');\n        $this->sigNode->appendChild($objNode);\n        if (! empty($mimetype)) {\n            $objNode->setAttribute('MimeType', $mimetype);\n        }\n        if (! empty($encoding)) {\n            $objNode->setAttribute('Encoding', $encoding);\n        }\n\n        if ($data instanceof DOMElement) {\n            $newData = $this->sigNode->ownerDocument->importNode($data, true);\n        } else {\n            $newData = $this->sigNode->ownerDocument->createTextNode($data);\n        }\n        $objNode->appendChild($newData);\n\n        return $objNode;\n    }\n\n    /**\n     * @param null|DOMNode $node\n     * @return null|XMLSecurityKey\n     */\n    public function locateKey($node=null)\n    {\n        if (empty($node)) {\n            $node = $this->sigNode;\n        }\n        if (! $node instanceof DOMNode) {\n            return null;\n        }\n        if ($doc = $node->ownerDocument) {\n            $xpath = new DOMXPath($doc);\n            $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n            $query = \"string(./secdsig:SignedInfo/secdsig:SignatureMethod/@Algorithm)\";\n            $algorithm = $xpath->evaluate($query, $node);\n            if ($algorithm) {\n                try {\n                    $objKey = new XMLSecurityKey($algorithm, array('type' => 'public'));\n                } catch (Exception $e) {\n                    return null;\n                }\n                return $objKey;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns:\n     *  Bool when verifying HMAC_SHA1;\n     *  Int otherwise, with following meanings:\n     *    1 on succesful signature verification,\n     *    0 when signature verification failed,\n     *   -1 if an error occurred during processing.\n     *\n     * NOTE: be very careful when checking the int return value, because in\n     * PHP, -1 will be cast to True when in boolean context. Always check the\n     * return value in a strictly typed way, e.g. \"$obj->verify(...) === 1\".\n     *\n     * @param XMLSecurityKey $objKey\n     * @return bool|int\n     * @throws Exception\n     */\n    public function verify($objKey)\n    {\n        $doc = $this->sigNode->ownerDocument;\n        $xpath = new DOMXPath($doc);\n        $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n        $query = \"string(./secdsig:SignatureValue)\";\n        $sigValue = $xpath->evaluate($query, $this->sigNode);\n        if (empty($sigValue)) {\n            throw new Exception(\"Unable to locate SignatureValue\");\n        }\n        return $objKey->verifySignature($this->signedInfo, base64_decode($sigValue));\n    }\n\n    /**\n     * @param XMLSecurityKey $objKey\n     * @param string $data\n     * @return mixed|string\n     */\n    public function signData($objKey, $data)\n    {\n        return $objKey->signData($data);\n    }\n\n    /**\n     * @param XMLSecurityKey $objKey\n     * @param null|DOMNode $appendToNode\n     */\n    public function sign($objKey, $appendToNode = null)\n    {\n        // If we have a parent node append it now so C14N properly works\n        if ($appendToNode != null) {\n            $this->resetXPathObj();\n            $this->appendSignature($appendToNode);\n            $this->sigNode = $appendToNode->lastChild;\n        }\n        if ($xpath = $this->getXPathObj()) {\n            $query = \"./secdsig:SignedInfo\";\n            $nodeset = $xpath->query($query, $this->sigNode);\n            if ($sInfo = $nodeset->item(0)) {\n                $query = \"./secdsig:SignatureMethod\";\n                $nodeset = $xpath->query($query, $sInfo);\n                $sMethod = $nodeset->item(0);\n                $sMethod->setAttribute('Algorithm', $objKey->type);\n                $data = $this->canonicalizeData($sInfo, $this->canonicalMethod);\n                $sigValue = base64_encode($this->signData($objKey, $data));\n                $sigValueNode = $this->createNewSignNode('SignatureValue', $sigValue);\n                if ($infoSibling = $sInfo->nextSibling) {\n                    $infoSibling->parentNode->insertBefore($sigValueNode, $infoSibling);\n                } else {\n                    $this->sigNode->appendChild($sigValueNode);\n                }\n            }\n        }\n    }\n\n    public function appendCert()\n    {\n\n    }\n\n    /**\n     * @param XMLSecurityKey $objKey\n     * @param null|DOMNode $parent\n     */\n    public function appendKey($objKey, $parent=null)\n    {\n        $objKey->serializeKey($parent);\n    }\n\n\n    /**\n     * This function inserts the signature element.\n     *\n     * The signature element will be appended to the element, unless $beforeNode is specified. If $beforeNode\n     * is specified, the signature element will be inserted as the last element before $beforeNode.\n     *\n     * @param DOMNode $node       The node the signature element should be inserted into.\n     * @param DOMNode $beforeNode The node the signature element should be located before.\n     *\n     * @return DOMNode The signature element node\n     */\n    public function insertSignature($node, $beforeNode = null)\n    {\n\n        $document = $node->ownerDocument;\n        $signatureElement = $document->importNode($this->sigNode, true);\n\n        if ($beforeNode == null) {\n            return $node->insertBefore($signatureElement);\n        } else {\n            return $node->insertBefore($signatureElement, $beforeNode);\n        }\n    }\n\n    /**\n     * @param DOMNode $parentNode\n     * @param bool $insertBefore\n     * @return DOMNode\n     */\n    public function appendSignature($parentNode, $insertBefore = false)\n    {\n        $beforeNode = $insertBefore ? $parentNode->firstChild : null;\n        return $this->insertSignature($parentNode, $beforeNode);\n    }\n\n    /**\n     * @param string $cert\n     * @param bool $isPEMFormat\n     * @return string\n     */\n    public static function get509XCert($cert, $isPEMFormat=true)\n    {\n        $certs = self::staticGet509XCerts($cert, $isPEMFormat);\n        if (! empty($certs)) {\n            return $certs[0];\n        }\n        return '';\n    }\n\n    /**\n     * @param string $certs\n     * @param bool $isPEMFormat\n     * @return array\n     */\n    public static function staticGet509XCerts($certs, $isPEMFormat=true)\n    {\n        if ($isPEMFormat) {\n            $data = '';\n            $certlist = array();\n            $arCert = explode(\"\\n\", $certs);\n            $inData = false;\n            foreach ($arCert AS $curData) {\n                if (! $inData) {\n                    if (strncmp($curData, '-----BEGIN CERTIFICATE', 22) == 0) {\n                        $inData = true;\n                    }\n                } else {\n                    if (strncmp($curData, '-----END CERTIFICATE', 20) == 0) {\n                        $inData = false;\n                        $certlist[] = $data;\n                        $data = '';\n                        continue;\n                    }\n                    $data .= trim($curData);\n                }\n            }\n            return $certlist;\n        } else {\n            return array($certs);\n        }\n    }\n\n    /**\n     * @param DOMElement $parentRef\n     * @param string $cert\n     * @param bool $isPEMFormat\n     * @param bool $isURL\n     * @param null|DOMXPath $xpath\n     * @param null|array $options\n     * @throws Exception\n     */\n    public static function staticAdd509Cert($parentRef, $cert, $isPEMFormat=true, $isURL=false, $xpath=null, $options=null)\n    {\n        if ($isURL) {\n            $cert = file_get_contents($cert);\n        }\n        if (! $parentRef instanceof DOMElement) {\n            throw new Exception('Invalid parent Node parameter');\n        }\n        $baseDoc = $parentRef->ownerDocument;\n\n        if (empty($xpath)) {\n            $xpath = new DOMXPath($parentRef->ownerDocument);\n            $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n        }\n\n        $query = \"./secdsig:KeyInfo\";\n        $nodeset = $xpath->query($query, $parentRef);\n        $keyInfo = $nodeset->item(0);\n        $dsig_pfx = '';\n        if (! $keyInfo) {\n            $pfx = $parentRef->lookupPrefix(self::XMLDSIGNS);\n            if (! empty($pfx)) {\n                $dsig_pfx = $pfx.\":\";\n            }\n            $inserted = false;\n            $keyInfo = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'KeyInfo');\n\n            $query = \"./secdsig:Object\";\n            $nodeset = $xpath->query($query, $parentRef);\n            if ($sObject = $nodeset->item(0)) {\n                $sObject->parentNode->insertBefore($keyInfo, $sObject);\n                $inserted = true;\n            }\n\n            if (! $inserted) {\n                $parentRef->appendChild($keyInfo);\n            }\n        } else {\n            $pfx = $keyInfo->lookupPrefix(self::XMLDSIGNS);\n            if (! empty($pfx)) {\n                $dsig_pfx = $pfx.\":\";\n            }\n        }\n\n        // Add all certs if there are more than one\n        $certs = self::staticGet509XCerts($cert, $isPEMFormat);\n\n        // Attach X509 data node\n        $x509DataNode = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'X509Data');\n        $keyInfo->appendChild($x509DataNode);\n\n        $issuerSerial = false;\n        $subjectName = false;\n        if (is_array($options)) {\n            if (! empty($options['issuerSerial'])) {\n                $issuerSerial = true;\n            }\n            if (! empty($options['subjectName'])) {\n                $subjectName = true;\n            }\n        }\n\n        // Attach all certificate nodes and any additional data\n        foreach ($certs as $X509Cert) {\n            if ($issuerSerial || $subjectName) {\n                if ($certData = openssl_x509_parse(\"-----BEGIN CERTIFICATE-----\\n\".chunk_split($X509Cert, 64, \"\\n\").\"-----END CERTIFICATE-----\\n\")) {\n                    if ($subjectName && ! empty($certData['subject'])) {\n                        if (is_array($certData['subject'])) {\n                            $parts = array();\n                            foreach ($certData['subject'] AS $key => $value) {\n                                if (is_array($value)) {\n                                    foreach ($value as $valueElement) {\n                                        array_unshift($parts, \"$key=$valueElement\");\n                                    }\n                                } else {\n                                    array_unshift($parts, \"$key=$value\");\n                                }\n                            }\n                            $subjectNameValue = implode(',', $parts);\n                        } else {\n                            $subjectNameValue = $certData['issuer'];\n                        }\n                        $x509SubjectNode = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'X509SubjectName', $subjectNameValue);\n                        $x509DataNode->appendChild($x509SubjectNode);\n                    }\n                    if ($issuerSerial && ! empty($certData['issuer']) && ! empty($certData['serialNumber'])) {\n                        if (is_array($certData['issuer'])) {\n                            $parts = array();\n                            foreach ($certData['issuer'] AS $key => $value) {\n                                array_unshift($parts, \"$key=$value\");\n                            }\n                            $issuerName = implode(',', $parts);\n                        } else {\n                            $issuerName = $certData['issuer'];\n                        }\n\n                        $x509IssuerNode = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'X509IssuerSerial');\n                        $x509DataNode->appendChild($x509IssuerNode);\n\n                        $x509Node = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'X509IssuerName', $issuerName);\n                        $x509IssuerNode->appendChild($x509Node);\n                        $x509Node = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'X509SerialNumber', $certData['serialNumber']);\n                        $x509IssuerNode->appendChild($x509Node);\n                    }\n                }\n\n            }\n            $x509CertNode = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'X509Certificate', $X509Cert);\n            $x509DataNode->appendChild($x509CertNode);\n        }\n    }\n\n    /**\n     * @param string $cert\n     * @param bool $isPEMFormat\n     * @param bool $isURL\n     * @param null|array $options\n     */\n    public function add509Cert($cert, $isPEMFormat=true, $isURL=false, $options=null)\n    {\n        if ($xpath = $this->getXPathObj()) {\n            self::staticAdd509Cert($this->sigNode, $cert, $isPEMFormat, $isURL, $xpath, $options);\n        }\n    }\n\n    /**\n     * This function appends a node to the KeyInfo.\n     *\n     * The KeyInfo element will be created if one does not exist in the document.\n     *\n     * @param DOMNode $node The node to append to the KeyInfo.\n     *\n     * @return DOMNode The KeyInfo element node\n     */\n    public function appendToKeyInfo($node)\n    {\n        $parentRef = $this->sigNode;\n        $baseDoc = $parentRef->ownerDocument;\n\n        $xpath = $this->getXPathObj();\n        if (empty($xpath)) {\n            $xpath = new DOMXPath($parentRef->ownerDocument);\n            $xpath->registerNamespace('secdsig', self::XMLDSIGNS);\n        }\n\n        $query = \"./secdsig:KeyInfo\";\n        $nodeset = $xpath->query($query, $parentRef);\n        $keyInfo = $nodeset->item(0);\n        if (! $keyInfo) {\n            $dsig_pfx = '';\n            $pfx = $parentRef->lookupPrefix(self::XMLDSIGNS);\n            if (! empty($pfx)) {\n                $dsig_pfx = $pfx.\":\";\n            }\n            $inserted = false;\n            $keyInfo = $baseDoc->createElementNS(self::XMLDSIGNS, $dsig_pfx.'KeyInfo');\n\n            $query = \"./secdsig:Object\";\n            $nodeset = $xpath->query($query, $parentRef);\n            if ($sObject = $nodeset->item(0)) {\n                $sObject->parentNode->insertBefore($keyInfo, $sObject);\n                $inserted = true;\n            }\n\n            if (! $inserted) {\n                $parentRef->appendChild($keyInfo);\n            }\n        }\n\n        $keyInfo->appendChild($node);\n\n        return $keyInfo;\n    }\n\n    /**\n     * This function retrieves an associative array of the validated nodes.\n     *\n     * The array will contain the id of the referenced node as the key and the node itself\n     * as the value.\n     *\n     * Returns:\n     *  An associative array of validated nodes or null if no nodes have been validated.\n     *\n     *  @return array Associative array of validated nodes\n     */\n    public function getValidatedNodes()\n    {\n        return $this->validatedNodes;\n    }\n}\n", "<?php\n/**\n * xmlseclibs.php\n *\n * Copyright (c) 2007-2019, Robert Richards <rrichards@cdatazone.org>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in\n *     the documentation and/or other materials provided with the\n *     distribution.\n *\n *   * Neither the name of Robert Richards nor the names of his\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @author    Robert Richards <rrichards@cdatazone.org>\n * @copyright 2007-2019 Robert Richards <rrichards@cdatazone.org>\n * @license   http://www.opensource.org/licenses/bsd-license.php  BSD License\n * @version   3.0.4\n */\n\n$xmlseclibs_srcdir = dirname(__FILE__) . '/src/';\nrequire $xmlseclibs_srcdir . '/XMLSecurityKey.php';\nrequire $xmlseclibs_srcdir . '/XMLSecurityDSig.php';\nrequire $xmlseclibs_srcdir . '/XMLSecEnc.php';\nrequire $xmlseclibs_srcdir . '/Utils/XPath.php';\n"], "filenames": ["CHANGELOG.txt", "LICENSE", "src/XMLSecurityDSig.php", "xmlseclibs.php"], "buggy_code_start_loc": [3, 1, 196, 40], "buggy_code_end_loc": [4, 2, 582, 41], "fixing_code_start_loc": [3, 1, 197, 40], "fixing_code_end_loc": [9, 2, 590, 41], "type": "CWE-347", "message": "Rob Richards XmlSecLibs, all versions prior to v3.0.3, as used for example by SimpleSAMLphp, performed incorrect validation of cryptographic signatures in XML messages, allowing an authenticated attacker to impersonate others or elevate privileges by creating a crafted XML message.", "other": {"cve": {"id": "CVE-2019-3465", "sourceIdentifier": "security@debian.org", "published": "2019-11-07T20:15:11.090", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Rob Richards XmlSecLibs, all versions prior to v3.0.3, as used for example by SimpleSAMLphp, performed incorrect validation of cryptographic signatures in XML messages, allowing an authenticated attacker to impersonate others or elevate privileges by creating a crafted XML message."}, {"lang": "es", "value": "Rob Richards XmlSecLibs, todas las versiones anteriores a la v3.0.3, como es usada por ejemplo mediante SimpleSAMLphp, realiz\u00f3 una comprobaci\u00f3n incorrecta de las firmas criptogr\u00e1ficas en los mensajes XML, permitiendo a un atacante autenticado suplantar a otros o elevar los privilegios por medio de la creaci\u00f3n de un mensaje XML dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xmlseclibs_project:xmlseclibs:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndIncluding": "1.4.2", "matchCriteriaId": "D32024E5-AA5C-4F2B-9F19-44D8D05F5971"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xmlseclibs_project:xmlseclibs:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndIncluding": "2.1.0", "matchCriteriaId": "B4A85E4A-6FFF-49F2-9940-6A89E19BEDD5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xmlseclibs_project:xmlseclibs:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndIncluding": "3.0.3", "matchCriteriaId": "86221F77-66FC-4220-97D2-FC3F0E384E15"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:simplesamlphp:simplesamlphp:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.17.6", "matchCriteriaId": "BFB2AFBB-CAB6-4093-BF77-6BA30C3F1E5D"}]}]}], "references": [{"url": "https://github.com/robrichards/xmlseclibs/commit/0a53d3c3aa87564910cae4ed01416441d3ae0db5", "source": "security@debian.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/11/msg00003.html", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7KID7C4AZPYYIZQIPSLANP4R2RQR6YK3/", "source": "security@debian.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AB34ILMJ67CUROBOR6YPKB46VHXLOAJ4/", "source": "security@debian.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BBKVDUZ7G5ZOUO4BFJWLNJ6VOKBQJX5U/", "source": "security@debian.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BNFMY5RRLU63P25HEBVDO5KAVI7TX7JV/", "source": "security@debian.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ESKJTWLE7QZBQ3EKMYXKMBQG3JDEJWM6/", "source": "security@debian.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HBE2SJSXG7J4XYLJ2H6HC2VPPOG2OMUN/", "source": "security@debian.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MAWOVYLZKYDCQBLQEJCFAAD3KQTBPHXE/", "source": "security@debian.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OCSR3V6LNWJAD37VQB6M2K7P4RQSCVFG/", "source": "security@debian.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XBSSRV5Q7JFCYO46A3EN624UZ4KXFQ2M/", "source": "security@debian.org"}, {"url": "https://seclists.org/bugtraq/2019/Nov/8", "source": "security@debian.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://simplesamlphp.org/security/201911-01", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4560", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.tenable.com/security/tns-2019-09", "source": "security@debian.org"}]}, "github_commit_url": "https://github.com/robrichards/xmlseclibs/commit/0a53d3c3aa87564910cae4ed01416441d3ae0db5"}}