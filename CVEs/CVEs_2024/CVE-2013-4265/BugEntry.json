{"buggy_code": ["/*\n * default memory allocator for libavutil\n * Copyright (c) 2002 Fabrice Bellard\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * default memory allocator for libavutil\n */\n\n#define _XOPEN_SOURCE 600\n\n#include \"config.h\"\n\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#if HAVE_MALLOC_H\n#include <malloc.h>\n#endif\n\n#include \"avassert.h\"\n#include \"avutil.h\"\n#include \"intreadwrite.h\"\n#include \"mem.h\"\n\n#ifdef MALLOC_PREFIX\n\n#define malloc         AV_JOIN(MALLOC_PREFIX, malloc)\n#define memalign       AV_JOIN(MALLOC_PREFIX, memalign)\n#define posix_memalign AV_JOIN(MALLOC_PREFIX, posix_memalign)\n#define realloc        AV_JOIN(MALLOC_PREFIX, realloc)\n#define free           AV_JOIN(MALLOC_PREFIX, free)\n\nvoid *malloc(size_t size);\nvoid *memalign(size_t align, size_t size);\nint   posix_memalign(void **ptr, size_t align, size_t size);\nvoid *realloc(void *ptr, size_t size);\nvoid  free(void *ptr);\n\n#endif /* MALLOC_PREFIX */\n\n#define ALIGN (HAVE_AVX ? 32 : 16)\n\n/* NOTE: if you want to override these functions with your own\n * implementations (not recommended) you have to link libav* as\n * dynamic libraries and remove -Wl,-Bsymbolic from the linker flags.\n * Note that this will cost performance. */\n\nstatic size_t max_alloc_size= INT_MAX;\n\nvoid av_max_alloc(size_t max){\n    max_alloc_size = max;\n}\n\nvoid *av_malloc(size_t size)\n{\n    void *ptr = NULL;\n#if CONFIG_MEMALIGN_HACK\n    long diff;\n#endif\n\n    /* let's disallow possible ambiguous cases */\n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    ptr = malloc(size + ALIGN);\n    if (!ptr)\n        return ptr;\n    diff              = ((~(long)ptr)&(ALIGN - 1)) + 1;\n    ptr               = (char *)ptr + diff;\n    ((char *)ptr)[-1] = diff;\n#elif HAVE_POSIX_MEMALIGN\n    if (size) //OS X on SDK 10.6 has a broken posix_memalign implementation\n    if (posix_memalign(&ptr, ALIGN, size))\n        ptr = NULL;\n#elif HAVE_ALIGNED_MALLOC\n    ptr = _aligned_malloc(size, ALIGN);\n#elif HAVE_MEMALIGN\n#ifndef __DJGPP__\n    ptr = memalign(ALIGN, size);\n#else\n    ptr = memalign(size, ALIGN);\n#endif\n    /* Why 64?\n     * Indeed, we should align it:\n     *   on  4 for 386\n     *   on 16 for 486\n     *   on 32 for 586, PPro - K6-III\n     *   on 64 for K7 (maybe for P3 too).\n     * Because L1 and L2 caches are aligned on those values.\n     * But I don't want to code such logic here!\n     */\n    /* Why 32?\n     * For AVX ASM. SSE / NEON needs only 16.\n     * Why not larger? Because I did not see a difference in benchmarks ...\n     */\n    /* benchmarks with P3\n     * memalign(64) + 1          3071, 3051, 3032\n     * memalign(64) + 2          3051, 3032, 3041\n     * memalign(64) + 4          2911, 2896, 2915\n     * memalign(64) + 8          2545, 2554, 2550\n     * memalign(64) + 16         2543, 2572, 2563\n     * memalign(64) + 32         2546, 2545, 2571\n     * memalign(64) + 64         2570, 2533, 2558\n     *\n     * BTW, malloc seems to do 8-byte alignment by default here.\n     */\n#else\n    ptr = malloc(size);\n#endif\n    if(!ptr && !size) {\n        size = 1;\n        ptr= av_malloc(1);\n    }\n#if CONFIG_MEMORY_POISONING\n    if (ptr)\n        memset(ptr, FF_MEMORY_POISON, size);\n#endif\n    return ptr;\n}\n\nvoid *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    /* let's disallow possible ambiguous cases */\n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    //FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    av_assert0(diff>0 && diff<=ALIGN);\n    ptr = realloc((char *)ptr - diff, size + diff);\n    if (ptr)\n        ptr = (char *)ptr + diff;\n    return ptr;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size + !size, ALIGN);\n#else\n    return realloc(ptr, size + !size);\n#endif\n}\n\nvoid *av_realloc_f(void *ptr, size_t nelem, size_t elsize)\n{\n    size_t size;\n    void *r;\n\n    if (av_size_mult(elsize, nelem, &size)) {\n        av_free(ptr);\n        return NULL;\n    }\n    r = av_realloc(ptr, size);\n    if (!r && size)\n        av_free(ptr);\n    return r;\n}\n\nvoid *av_realloc_array(void *ptr, size_t nmemb, size_t size)\n{\n    if (size <= 0 || nmemb >= INT_MAX / size)\n        return NULL;\n    return av_realloc(ptr, nmemb * size);\n}\n\nint av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n        return AVERROR(ENOMEM);\n    return 0;\n}\n\nvoid av_free(void *ptr)\n{\n#if CONFIG_MEMALIGN_HACK\n    if (ptr) {\n        int v= ((char *)ptr)[-1];\n        av_assert0(v>0 && v<=ALIGN);\n        free((char *)ptr - v);\n    }\n#elif HAVE_ALIGNED_MALLOC\n    _aligned_free(ptr);\n#else\n    free(ptr);\n#endif\n}\n\nvoid av_freep(void *arg)\n{\n    void **ptr = (void **)arg;\n    av_free(*ptr);\n    *ptr = NULL;\n}\n\nvoid *av_mallocz(size_t size)\n{\n    void *ptr = av_malloc(size);\n    if (ptr)\n        memset(ptr, 0, size);\n    return ptr;\n}\n\nvoid *av_calloc(size_t nmemb, size_t size)\n{\n    if (size <= 0 || nmemb >= INT_MAX / size)\n        return NULL;\n    return av_mallocz(nmemb * size);\n}\n\nchar *av_strdup(const char *s)\n{\n    char *ptr = NULL;\n    if (s) {\n        int len = strlen(s) + 1;\n        ptr = av_malloc(len);\n        if (ptr)\n            memcpy(ptr, s, len);\n    }\n    return ptr;\n}\n\nvoid *av_memdup(const void *p, size_t size)\n{\n    void *ptr = NULL;\n    if (p) {\n        ptr = av_malloc(size);\n        if (ptr)\n            memcpy(ptr, p, size);\n    }\n    return ptr;\n}\n\nvoid av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)\n{\n    /* see similar ffmpeg.c:grow_array() */\n    int nb, nb_alloc;\n    intptr_t *tab;\n\n    nb = *nb_ptr;\n    tab = *(intptr_t**)tab_ptr;\n    if ((nb & (nb - 1)) == 0) {\n        if (nb == 0) {\n            nb_alloc = 1;\n        } else {\n            if (nb > INT_MAX / (2 * sizeof(intptr_t)))\n                goto fail;\n            nb_alloc = nb * 2;\n        }\n        tab = av_realloc(tab, nb_alloc * sizeof(intptr_t));\n        if (!tab)\n            goto fail;\n        *(intptr_t**)tab_ptr = tab;\n    }\n    tab[nb++] = (intptr_t)elem;\n    *nb_ptr = nb;\n    return;\n\nfail:\n    av_freep(tab_ptr);\n    *nb_ptr = 0;\n}\n\nvoid *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size,\n                       const uint8_t *elem_data)\n{\n    int nb = *nb_ptr, nb_alloc;\n    uint8_t *tab = *tab_ptr, *tab_elem_data;\n\n    if ((nb & (nb - 1)) == 0) {\n        if (nb == 0) {\n            nb_alloc = 1;\n        } else {\n            if (nb > INT_MAX / (2 * elem_size))\n                goto fail;\n            nb_alloc = nb * 2;\n        }\n        tab = av_realloc(tab, nb_alloc * elem_size);\n        if (!tab)\n            goto fail;\n        *tab_ptr = tab;\n    }\n    *nb_ptr = nb + 1;\n    tab_elem_data = tab + nb*elem_size;\n    if (elem_data)\n        memcpy(tab_elem_data, elem_data, elem_size);\n    else if (CONFIG_MEMORY_POISONING)\n        memset(tab_elem_data, FF_MEMORY_POISON, elem_size);\n    return tab_elem_data;\n\nfail:\n    av_freep(tab_ptr);\n    *nb_ptr = 0;\n    return NULL;\n}\n\nstatic void fill16(uint8_t *dst, int len)\n{\n    uint32_t v = AV_RN16(dst - 2);\n\n    v |= v << 16;\n\n    while (len >= 4) {\n        AV_WN32(dst, v);\n        dst += 4;\n        len -= 4;\n    }\n\n    while (len--) {\n        *dst = dst[-2];\n        dst++;\n    }\n}\n\nstatic void fill24(uint8_t *dst, int len)\n{\n#if HAVE_BIGENDIAN\n    uint32_t v = AV_RB24(dst - 3);\n    uint32_t a = v << 8  | v >> 16;\n    uint32_t b = v << 16 | v >> 8;\n    uint32_t c = v << 24 | v;\n#else\n    uint32_t v = AV_RL24(dst - 3);\n    uint32_t a = v       | v << 24;\n    uint32_t b = v >> 8  | v << 16;\n    uint32_t c = v >> 16 | v << 8;\n#endif\n\n    while (len >= 12) {\n        AV_WN32(dst,     a);\n        AV_WN32(dst + 4, b);\n        AV_WN32(dst + 8, c);\n        dst += 12;\n        len -= 12;\n    }\n\n    if (len >= 4) {\n        AV_WN32(dst, a);\n        dst += 4;\n        len -= 4;\n    }\n\n    if (len >= 4) {\n        AV_WN32(dst, b);\n        dst += 4;\n        len -= 4;\n    }\n\n    while (len--) {\n        *dst = dst[-3];\n        dst++;\n    }\n}\n\nstatic void fill32(uint8_t *dst, int len)\n{\n    uint32_t v = AV_RN32(dst - 4);\n\n    while (len >= 4) {\n        AV_WN32(dst, v);\n        dst += 4;\n        len -= 4;\n    }\n\n    while (len--) {\n        *dst = dst[-4];\n        dst++;\n    }\n}\n\nvoid av_memcpy_backptr(uint8_t *dst, int back, int cnt)\n{\n    const uint8_t *src = &dst[-back];\n    if (!back)\n        return;\n\n    if (back == 1) {\n        memset(dst, *src, cnt);\n    } else if (back == 2) {\n        fill16(dst, cnt);\n    } else if (back == 3) {\n        fill24(dst, cnt);\n    } else if (back == 4) {\n        fill32(dst, cnt);\n    } else {\n        if (cnt >= 16) {\n            int blocklen = back;\n            while (cnt > blocklen) {\n                memcpy(dst, src, blocklen);\n                dst       += blocklen;\n                cnt       -= blocklen;\n                blocklen <<= 1;\n            }\n            memcpy(dst, src, cnt);\n            return;\n        }\n        if (cnt >= 8) {\n            AV_COPY32U(dst,     src);\n            AV_COPY32U(dst + 4, src + 4);\n            src += 8;\n            dst += 8;\n            cnt -= 8;\n        }\n        if (cnt >= 4) {\n            AV_COPY32U(dst, src);\n            src += 4;\n            dst += 4;\n            cnt -= 4;\n        }\n        if (cnt >= 2) {\n            AV_COPY16U(dst, src);\n            src += 2;\n            dst += 2;\n            cnt -= 2;\n        }\n        if (cnt)\n            *dst = *src;\n    }\n}\n\n"], "fixing_code": ["/*\n * default memory allocator for libavutil\n * Copyright (c) 2002 Fabrice Bellard\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * default memory allocator for libavutil\n */\n\n#define _XOPEN_SOURCE 600\n\n#include \"config.h\"\n\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#if HAVE_MALLOC_H\n#include <malloc.h>\n#endif\n\n#include \"avassert.h\"\n#include \"avutil.h\"\n#include \"intreadwrite.h\"\n#include \"mem.h\"\n\n#ifdef MALLOC_PREFIX\n\n#define malloc         AV_JOIN(MALLOC_PREFIX, malloc)\n#define memalign       AV_JOIN(MALLOC_PREFIX, memalign)\n#define posix_memalign AV_JOIN(MALLOC_PREFIX, posix_memalign)\n#define realloc        AV_JOIN(MALLOC_PREFIX, realloc)\n#define free           AV_JOIN(MALLOC_PREFIX, free)\n\nvoid *malloc(size_t size);\nvoid *memalign(size_t align, size_t size);\nint   posix_memalign(void **ptr, size_t align, size_t size);\nvoid *realloc(void *ptr, size_t size);\nvoid  free(void *ptr);\n\n#endif /* MALLOC_PREFIX */\n\n#define ALIGN (HAVE_AVX ? 32 : 16)\n\n/* NOTE: if you want to override these functions with your own\n * implementations (not recommended) you have to link libav* as\n * dynamic libraries and remove -Wl,-Bsymbolic from the linker flags.\n * Note that this will cost performance. */\n\nstatic size_t max_alloc_size= INT_MAX;\n\nvoid av_max_alloc(size_t max){\n    max_alloc_size = max;\n}\n\nvoid *av_malloc(size_t size)\n{\n    void *ptr = NULL;\n#if CONFIG_MEMALIGN_HACK\n    long diff;\n#endif\n\n    /* let's disallow possible ambiguous cases */\n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    ptr = malloc(size + ALIGN);\n    if (!ptr)\n        return ptr;\n    diff              = ((~(long)ptr)&(ALIGN - 1)) + 1;\n    ptr               = (char *)ptr + diff;\n    ((char *)ptr)[-1] = diff;\n#elif HAVE_POSIX_MEMALIGN\n    if (size) //OS X on SDK 10.6 has a broken posix_memalign implementation\n    if (posix_memalign(&ptr, ALIGN, size))\n        ptr = NULL;\n#elif HAVE_ALIGNED_MALLOC\n    ptr = _aligned_malloc(size, ALIGN);\n#elif HAVE_MEMALIGN\n#ifndef __DJGPP__\n    ptr = memalign(ALIGN, size);\n#else\n    ptr = memalign(size, ALIGN);\n#endif\n    /* Why 64?\n     * Indeed, we should align it:\n     *   on  4 for 386\n     *   on 16 for 486\n     *   on 32 for 586, PPro - K6-III\n     *   on 64 for K7 (maybe for P3 too).\n     * Because L1 and L2 caches are aligned on those values.\n     * But I don't want to code such logic here!\n     */\n    /* Why 32?\n     * For AVX ASM. SSE / NEON needs only 16.\n     * Why not larger? Because I did not see a difference in benchmarks ...\n     */\n    /* benchmarks with P3\n     * memalign(64) + 1          3071, 3051, 3032\n     * memalign(64) + 2          3051, 3032, 3041\n     * memalign(64) + 4          2911, 2896, 2915\n     * memalign(64) + 8          2545, 2554, 2550\n     * memalign(64) + 16         2543, 2572, 2563\n     * memalign(64) + 32         2546, 2545, 2571\n     * memalign(64) + 64         2570, 2533, 2558\n     *\n     * BTW, malloc seems to do 8-byte alignment by default here.\n     */\n#else\n    ptr = malloc(size);\n#endif\n    if(!ptr && !size) {\n        size = 1;\n        ptr= av_malloc(1);\n    }\n#if CONFIG_MEMORY_POISONING\n    if (ptr)\n        memset(ptr, FF_MEMORY_POISON, size);\n#endif\n    return ptr;\n}\n\nvoid *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    /* let's disallow possible ambiguous cases */\n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    //FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    av_assert0(diff>0 && diff<=ALIGN);\n    ptr = realloc((char *)ptr - diff, size + diff);\n    if (ptr)\n        ptr = (char *)ptr + diff;\n    return ptr;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size + !size, ALIGN);\n#else\n    return realloc(ptr, size + !size);\n#endif\n}\n\nvoid *av_realloc_f(void *ptr, size_t nelem, size_t elsize)\n{\n    size_t size;\n    void *r;\n\n    if (av_size_mult(elsize, nelem, &size)) {\n        av_free(ptr);\n        return NULL;\n    }\n    r = av_realloc(ptr, size);\n    if (!r && size)\n        av_free(ptr);\n    return r;\n}\n\nvoid *av_realloc_array(void *ptr, size_t nmemb, size_t size)\n{\n    if (size <= 0 || nmemb >= INT_MAX / size)\n        return NULL;\n    return av_realloc(ptr, nmemb * size);\n}\n\nint av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && nmemb && size)\n        return AVERROR(ENOMEM);\n    return 0;\n}\n\nvoid av_free(void *ptr)\n{\n#if CONFIG_MEMALIGN_HACK\n    if (ptr) {\n        int v= ((char *)ptr)[-1];\n        av_assert0(v>0 && v<=ALIGN);\n        free((char *)ptr - v);\n    }\n#elif HAVE_ALIGNED_MALLOC\n    _aligned_free(ptr);\n#else\n    free(ptr);\n#endif\n}\n\nvoid av_freep(void *arg)\n{\n    void **ptr = (void **)arg;\n    av_free(*ptr);\n    *ptr = NULL;\n}\n\nvoid *av_mallocz(size_t size)\n{\n    void *ptr = av_malloc(size);\n    if (ptr)\n        memset(ptr, 0, size);\n    return ptr;\n}\n\nvoid *av_calloc(size_t nmemb, size_t size)\n{\n    if (size <= 0 || nmemb >= INT_MAX / size)\n        return NULL;\n    return av_mallocz(nmemb * size);\n}\n\nchar *av_strdup(const char *s)\n{\n    char *ptr = NULL;\n    if (s) {\n        int len = strlen(s) + 1;\n        ptr = av_malloc(len);\n        if (ptr)\n            memcpy(ptr, s, len);\n    }\n    return ptr;\n}\n\nvoid *av_memdup(const void *p, size_t size)\n{\n    void *ptr = NULL;\n    if (p) {\n        ptr = av_malloc(size);\n        if (ptr)\n            memcpy(ptr, p, size);\n    }\n    return ptr;\n}\n\nvoid av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)\n{\n    /* see similar ffmpeg.c:grow_array() */\n    int nb, nb_alloc;\n    intptr_t *tab;\n\n    nb = *nb_ptr;\n    tab = *(intptr_t**)tab_ptr;\n    if ((nb & (nb - 1)) == 0) {\n        if (nb == 0) {\n            nb_alloc = 1;\n        } else {\n            if (nb > INT_MAX / (2 * sizeof(intptr_t)))\n                goto fail;\n            nb_alloc = nb * 2;\n        }\n        tab = av_realloc(tab, nb_alloc * sizeof(intptr_t));\n        if (!tab)\n            goto fail;\n        *(intptr_t**)tab_ptr = tab;\n    }\n    tab[nb++] = (intptr_t)elem;\n    *nb_ptr = nb;\n    return;\n\nfail:\n    av_freep(tab_ptr);\n    *nb_ptr = 0;\n}\n\nvoid *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size,\n                       const uint8_t *elem_data)\n{\n    int nb = *nb_ptr, nb_alloc;\n    uint8_t *tab = *tab_ptr, *tab_elem_data;\n\n    if ((nb & (nb - 1)) == 0) {\n        if (nb == 0) {\n            nb_alloc = 1;\n        } else {\n            if (nb > INT_MAX / (2 * elem_size))\n                goto fail;\n            nb_alloc = nb * 2;\n        }\n        tab = av_realloc(tab, nb_alloc * elem_size);\n        if (!tab)\n            goto fail;\n        *tab_ptr = tab;\n    }\n    *nb_ptr = nb + 1;\n    tab_elem_data = tab + nb*elem_size;\n    if (elem_data)\n        memcpy(tab_elem_data, elem_data, elem_size);\n    else if (CONFIG_MEMORY_POISONING)\n        memset(tab_elem_data, FF_MEMORY_POISON, elem_size);\n    return tab_elem_data;\n\nfail:\n    av_freep(tab_ptr);\n    *nb_ptr = 0;\n    return NULL;\n}\n\nstatic void fill16(uint8_t *dst, int len)\n{\n    uint32_t v = AV_RN16(dst - 2);\n\n    v |= v << 16;\n\n    while (len >= 4) {\n        AV_WN32(dst, v);\n        dst += 4;\n        len -= 4;\n    }\n\n    while (len--) {\n        *dst = dst[-2];\n        dst++;\n    }\n}\n\nstatic void fill24(uint8_t *dst, int len)\n{\n#if HAVE_BIGENDIAN\n    uint32_t v = AV_RB24(dst - 3);\n    uint32_t a = v << 8  | v >> 16;\n    uint32_t b = v << 16 | v >> 8;\n    uint32_t c = v << 24 | v;\n#else\n    uint32_t v = AV_RL24(dst - 3);\n    uint32_t a = v       | v << 24;\n    uint32_t b = v >> 8  | v << 16;\n    uint32_t c = v >> 16 | v << 8;\n#endif\n\n    while (len >= 12) {\n        AV_WN32(dst,     a);\n        AV_WN32(dst + 4, b);\n        AV_WN32(dst + 8, c);\n        dst += 12;\n        len -= 12;\n    }\n\n    if (len >= 4) {\n        AV_WN32(dst, a);\n        dst += 4;\n        len -= 4;\n    }\n\n    if (len >= 4) {\n        AV_WN32(dst, b);\n        dst += 4;\n        len -= 4;\n    }\n\n    while (len--) {\n        *dst = dst[-3];\n        dst++;\n    }\n}\n\nstatic void fill32(uint8_t *dst, int len)\n{\n    uint32_t v = AV_RN32(dst - 4);\n\n    while (len >= 4) {\n        AV_WN32(dst, v);\n        dst += 4;\n        len -= 4;\n    }\n\n    while (len--) {\n        *dst = dst[-4];\n        dst++;\n    }\n}\n\nvoid av_memcpy_backptr(uint8_t *dst, int back, int cnt)\n{\n    const uint8_t *src = &dst[-back];\n    if (!back)\n        return;\n\n    if (back == 1) {\n        memset(dst, *src, cnt);\n    } else if (back == 2) {\n        fill16(dst, cnt);\n    } else if (back == 3) {\n        fill24(dst, cnt);\n    } else if (back == 4) {\n        fill32(dst, cnt);\n    } else {\n        if (cnt >= 16) {\n            int blocklen = back;\n            while (cnt > blocklen) {\n                memcpy(dst, src, blocklen);\n                dst       += blocklen;\n                cnt       -= blocklen;\n                blocklen <<= 1;\n            }\n            memcpy(dst, src, cnt);\n            return;\n        }\n        if (cnt >= 8) {\n            AV_COPY32U(dst,     src);\n            AV_COPY32U(dst + 4, src + 4);\n            src += 8;\n            dst += 8;\n            cnt -= 8;\n        }\n        if (cnt >= 4) {\n            AV_COPY32U(dst, src);\n            src += 4;\n            dst += 4;\n            cnt -= 4;\n        }\n        if (cnt >= 2) {\n            AV_COPY16U(dst, src);\n            src += 2;\n            dst += 2;\n            cnt -= 2;\n        }\n        if (cnt)\n            *dst = *src;\n    }\n}\n\n"], "filenames": ["libavutil/mem.c"], "buggy_code_start_loc": [194], "buggy_code_end_loc": [195], "fixing_code_start_loc": [194], "fixing_code_end_loc": [195], "type": "NVD-CWE-Other", "message": "The av_reallocp_array function in libavutil/mem.c in FFmpeg before 2.0.1 has an unspecified impact and remote vectors related to a \"wrong return code\" and a resultant NULL pointer dereference.", "other": {"cve": {"id": "CVE-2013-4265", "sourceIdentifier": "secalert@redhat.com", "published": "2013-11-23T17:55:03.510", "lastModified": "2016-12-03T03:00:28.453", "vulnStatus": "Modified", "evaluatorComment": "http://cwe.mitre.org/data/definitions/476.html\n\n\"CWE-476: NULL Pointer Dereference\"", "descriptions": [{"lang": "en", "value": "The av_reallocp_array function in libavutil/mem.c in FFmpeg before 2.0.1 has an unspecified impact and remote vectors related to a \"wrong return code\" and a resultant NULL pointer dereference."}, {"lang": "es", "value": "La funci\u00f3n av_reallocp_array en libavutil/mem.c de FFmpeg anterior a la versi\u00f3n 2.0.1 tiene un impacto sin especificar y vectores remotos relacionados con un \"c\u00f3digo de retorno incorrecto\", resultante en una referencia a puntero nulo."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0", "matchCriteriaId": "01685217-A6AC-4F77-A236-DEA8B1055940"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3:*:*:*:*:*:*:*", "matchCriteriaId": "B2649A80-4739-4BBB-AB0B-99AD435BE7CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "D4A2E77D-B826-4B49-ADC8-7F704E149A5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "18157837-4550-45E3-A12E-AE06E047E253"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "E9F42611-C3E2-416B-9AE7-A5AE83E4DEF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "3A20789F-26E3-4871-B24E-25E922BADDF0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "67C6C243-3ACC-49C3-80CA-D7CA8FEFF0D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "6AE6D368-0BA6-4499-B7E1-EE16C03012E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "26C0F6EF-0452-4AFE-AF3E-B88F963A0938"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "5B4DD372-4D3B-445C-8C38-E083A3C0D4A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "733C03D7-2780-4D69-A98D-BCFB91D1119A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "0AEE1977-E9E0-4BFF-B33B-B083E49E51F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "E6979C17-0BC6-47D1-9B73-254D84306A96"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "204C7C05-3441-4DB0-8702-D99C8FCB381E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "8D486C17-FC4A-4AEE-A430-1B1FBCC2C27C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "632BC7C2-FE59-47B0-885C-0EB8C74DF041"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "5D1AE0BF-A6FD-4EBA-BF61-07AC81EA560D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "5B8FA106-FE65-4BB0-92A7-E8A5AF978A9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "514669DA-8D02-44CE-BE18-8783F69AE394"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "8041E6ED-472A-40DF-AA90-F3509D90D47A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "D2C64382-9259-4D61-B352-7F123527289C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6:*:*:*:*:*:*:*", "matchCriteriaId": "37FBB817-A186-4517-9DA7-B3638576AAE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "157ABA40-6101-4E9C-A24C-84F8E23D374D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "C7EA46DD-2CC4-426F-8709-821B7572C94A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "3DE12C59-4409-4F7A-9759-7B26FA9DAC34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7:*:*:*:*:*:*:*", "matchCriteriaId": "30FE6578-F031-4F5B-B955-8F912CFCA1B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "07669E0E-8C4B-430E-802F-F64EEA2B5A0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F3EB7F17-F25D-4E48-8A43-F799619CE71F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "60705A3B-7136-45D1-8068-E2DC9E01EB04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "C722B143-2648-4EB2-A090-7B788F41F300"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "B31AFDBC-A782-4C18-8EAA-6D927397BEA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "73E9E8F4-A942-4F34-BCE2-82A180F1DD1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "AAA31D75-C3FB-4D89-8B2D-21372AAEB78B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "B20E5358-826C-47A2-B39F-ED4E9213BA95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "26321888-E140-4F09-AAA0-7392AA7F6307"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.11:*:*:*:*:*:*:*", "matchCriteriaId": "7E46B9F3-A9C0-4B8A-A119-40CA4CBBD0EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.12:*:*:*:*:*:*:*", "matchCriteriaId": "44800572-71C5-4AA1-9CB6-30AA902B0353"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87090477-1D36-48B3-88AE-5CD5EE8F89D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "2096FF8B-9B57-4C59-84DB-9CC0DEAB47AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "34C99254-776C-4AAD-BDA2-3F544256AA67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "CE9D7B73-9CDA-4BAE-8DD9-8E1E34C20648"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "4FDBF2C0-8E33-4575-8A19-4F1CABA3023F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "72040664-077A-48FB-9E6B-B69EA8D26CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "F428A2E4-A54F-4296-A00F-1A4E160253D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "5239E4FA-0359-49F1-93D4-24AB013FAC20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "F0C8230D-4E89-45F9-B0F7-E317119E0FA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "585CE7D2-1CE8-44AB-AE67-07D7D3721F68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "EE81C339-A794-4303-B829-BE743DF0B132"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9:*:*:*:*:*:*:*", "matchCriteriaId": "5CE0A27B-66D7-4D1B-8E6A-F4722C070BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "864DC4A2-A378-4389-B62E-9E785879A744"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10:*:*:*:*:*:*:*", "matchCriteriaId": "16304267-C808-4B6B-9903-2DEAB40AD899"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "CEEBBA83-1BFC-45A8-B34A-AB3A9B8A9414"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "F559B34E-23EE-4E09-A044-E7F54C55B05E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.11:*:*:*:*:*:*:*", "matchCriteriaId": "62BA2708-BE77-42B7-B51A-C1B58632462C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "23E57BB1-DF1E-4173-BE52-72E2B3E6BA23"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "A3E30DB1-0CFC-4EAA-BF07-CE7551ABDCB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "DBA7D745-DC16-43B9-8A2D-4D6944A6BFD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "87A511A5-2040-433A-9B32-B89332214FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "0C01DD9C-98C9-4896-8D66-A8336582298B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "BBE7723A-3D6B-4390-B82E-6A5A6992141A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "1ED8FF93-5AA7-443C-BBDB-845736BB337B"}]}]}], "references": [{"url": "http://www.ffmpeg.org/security.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/08/21/11", "source": "secalert@redhat.com"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/c94f9e854228e0ea00e1de8769d8d3f7cab84a55", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201603-06", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/c94f9e854228e0ea00e1de8769d8d3f7cab84a55"}}