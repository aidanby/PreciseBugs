{"buggy_code": ["/* \n * Copyright (C) 2011 Jiaju Zhang <jjzhang@suse.de>\n * Copyright (C) 2013-2014 Philipp Marek <philipp.marek@linbit.com>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"b_config.h\"\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sched.h>\n#include <errno.h>\n#include <limits.h>\n#include <sys/file.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/poll.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n#include <signal.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n\n#include <crm/services.h>\n\n#if HAVE_LIBGCRYPT\n#include <gcrypt.h>\n#endif\n#ifndef NAMETAG_LIBSYSTEMD\n#include <clplumbing/setproctitle.h>\n#else\n#include \"alt/nametag_libsystemd.h\"\n#endif\n#ifdef COREDUMP_NURSING\n#include <sys/prctl.h>\n#include <clplumbing/coredumps.h>\n#endif\n#include \"log.h\"\n#include \"booth.h\"\n#include \"config.h\"\n#include \"transport.h\"\n#include \"inline-fn.h\"\n#include \"pacemaker.h\"\n#include \"ticket.h\"\n#include \"request.h\"\n#include \"attr.h\"\n#include \"handler.h\"\n\n#define RELEASE_STR \tVERSION\n\n#define CLIENT_NALLOC\t\t32\n\nstatic int daemonize = 1;\nint enable_stderr = 0;\ntimetype start_time;\n\n\n/** Structure for \"clients\".\n * Filehandles with incoming data get registered here (and in pollfds),\n * along with their callbacks.\n * Because these can be reallocated with every new fd, addressing\n * happens _only_ by their numeric index. */\nstruct client *clients = NULL;\nstruct pollfd *pollfds = NULL;\nstatic int client_maxi;\nstatic int client_size = 0;\n\n\nstatic const struct booth_site _no_leader = {\n\t.addr_string = \"none\",\n\t.site_id = NO_ONE,\n\t.index = -1,\n};\nstruct booth_site *const no_leader = (struct booth_site*) &_no_leader;\n\ntypedef enum\n{\n\tBOOTHD_STARTED=0,\n\tBOOTHD_STARTING\n} BOOTH_DAEMON_STATE;\n\nint poll_timeout;\n\n\n\nstruct booth_config *booth_conf;\nstruct command_line cl;\n\n/*\n * Global signal handlers variables\n */\nstatic int sig_exit_handler_called = 0;\nstatic int sig_exit_handler_sig = 0;\nstatic int sig_usr1_handler_called = 0;\nstatic int sig_chld_handler_called = 0;\n\nstatic void client_alloc(void)\n{\n\tint i;\n\n\tif (!(clients = realloc(\n\t\tclients, (client_size + CLIENT_NALLOC) * sizeof(*clients))\n\t) || !(pollfds = realloc(\n\t\tpollfds, (client_size + CLIENT_NALLOC) * sizeof(*pollfds))\n\t)) {\n\t\tlog_error(\"can't alloc for client array\");\n\t\texit(1);\n\t}\n\n\tfor (i = client_size; i < client_size + CLIENT_NALLOC; i++) {\n\t\tclients[i].workfn = NULL;\n\t\tclients[i].deadfn = NULL;\n\t\tclients[i].fd = -1;\n\t\tpollfds[i].fd = -1;\n\t\tpollfds[i].revents = 0;\n\t}\n\tclient_size += CLIENT_NALLOC;\n}\n\nstatic void client_dead(int ci)\n{\n\tstruct client *c = clients + ci;\n\n\tif (c->fd != -1) {\n\t\tlog_debug(\"removing client %d\", c->fd);\n\t\tclose(c->fd);\n\t}\n\n\tc->fd = -1;\n\tc->workfn = NULL;\n\n\tif (c->msg) {\n\t\tfree(c->msg);\n\t\tc->msg = NULL;\n\t\tc->offset = 0;\n\t}\n\n\tpollfds[ci].fd = -1;\n}\n\nint client_add(int fd, const struct booth_transport *tpt,\n\t\tvoid (*workfn)(int ci),\n\t\tvoid (*deadfn)(int ci))\n{\n\tint i;\n\tstruct client *c;\n\n\n\tif (client_size - 1 <= client_maxi ) {\n\t\tclient_alloc();\n\t}\n\n\tfor (i = 0; i < client_size; i++) {\n\t\tc = clients + i;\n\t\tif (c->fd != -1)\n\t\t\tcontinue;\n\n\t\tc->workfn = workfn;\n\t\tif (deadfn)\n\t\t\tc->deadfn = deadfn;\n\t\telse\n\t\t\tc->deadfn = client_dead;\n\n\t\tc->transport = tpt;\n\t\tc->fd = fd;\n\t\tc->msg = NULL;\n\t\tc->offset = 0;\n\n\t\tpollfds[i].fd = fd;\n\t\tpollfds[i].events = POLLIN;\n\t\tif (i > client_maxi)\n\t\t\tclient_maxi = i;\n\n\t\treturn i;\n\t}\n\n\tassert(!\"no client\");\n}\n\nint find_client_by_fd(int fd)\n{\n\tint i;\n\n\tif (fd < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i <= client_maxi; i++) {\n\t\tif (clients[i].fd == fd)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nstatic int format_peers(char **pdata, unsigned int *len)\n{\n\tstruct booth_site *s;\n\tchar *data, *cp;\n\tchar time_str[64];\n\tint i, alloc;\n\n\t*pdata = NULL;\n\t*len = 0;\n\n\talloc = booth_conf->site_count * (BOOTH_NAME_LEN + 256);\n\tdata = malloc(alloc);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tcp = data;\n\tforeach_node(i, s) {\n\t\tif (s == local)\n\t\t\tcontinue;\n\t\tstrftime(time_str, sizeof(time_str), \"%F %T\",\n\t\t\tlocaltime(&s->last_recv));\n\t\tcp += snprintf(cp,\n\t\t\t\talloc - (cp - data),\n\t\t\t\t\"%-12s %s, last recv: %s\\n\",\n\t\t\t\ttype_to_string(s->type),\n\t\t\t\ts->addr_string,\n\t\t\t\ttime_str);\n\t\tcp += snprintf(cp,\n\t\t\t\talloc - (cp - data),\n\t\t\t\t\"\\tSent pkts:%u error:%u resends:%u\\n\",\n\t\t\t\ts->sent_cnt,\n\t\t\t\ts->sent_err_cnt,\n\t\t\t\ts->resend_cnt);\n\t\tcp += snprintf(cp,\n\t\t\t\talloc - (cp - data),\n\t\t\t\t\"\\tRecv pkts:%u error:%u authfail:%u invalid:%u\\n\\n\",\n\t\t\t\ts->recv_cnt,\n\t\t\t\ts->recv_err_cnt,\n\t\t\t\ts->sec_cnt,\n\t\t\t\ts->invalid_cnt);\n\t\tif (alloc - (cp - data) <= 0) {\n\t\t\tfree(data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t*pdata = data;\n\t*len = cp - data;\n\n\treturn 0;\n}\n\n\nvoid list_peers(int fd)\n{\n\tchar *data;\n\tunsigned int olen;\n\tstruct boothc_hdr_msg hdr;\n\n\tif (format_peers(&data, &olen) < 0)\n\t\tgoto out;\n\n\tinit_header(&hdr.header, CL_LIST, 0, 0, RLT_SUCCESS, 0, sizeof(hdr) + olen);\n\t(void)send_header_plus(fd, &hdr, data, olen);\n\nout:\n\tif (data)\n\t\tfree(data);\n}\n\n/* trim trailing spaces if the key is ascii\n */\nstatic void trim_key()\n{\n\tchar *p;\n\tint i;\n\n\tfor (i=0, p=booth_conf->authkey; i < booth_conf->authkey_len; i++, p++)\n\t\tif (!isascii(*p))\n\t\t\treturn;\n\n\tp = booth_conf->authkey;\n\twhile (booth_conf->authkey_len > 0 && isspace(*p)) {\n\t\tp++;\n\t\tbooth_conf->authkey_len--;\n\t}\n\tmemmove(booth_conf->authkey, p, booth_conf->authkey_len);\n\n\tp = booth_conf->authkey + booth_conf->authkey_len - 1;\n\twhile (booth_conf->authkey_len > 0 && isspace(*p)) {\n\t\tbooth_conf->authkey_len--;\n\t\tp--;\n\t}\n}\n\nstatic int read_authkey()\n{\n\tint fd;\n\n\tbooth_conf->authkey[0] = '\\0';\n\tfd = open(booth_conf->authfile, O_RDONLY);\n\tif (fd < 0) {\n\t\tlog_error(\"cannot open %s: %s\",\n\t\t\tbooth_conf->authfile, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (fstat(fd, &booth_conf->authstat) < 0) {\n\t\tlog_error(\"cannot stat authentication file %s (%d): %s\",\n\t\t\tbooth_conf->authfile, fd, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (booth_conf->authstat.st_mode & (S_IRGRP | S_IROTH)) {\n\t\tlog_error(\"%s: file shall not be readable for anyone but the owner\",\n\t\t\tbooth_conf->authfile);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tbooth_conf->authkey_len = read(fd, booth_conf->authkey, BOOTH_MAX_KEY_LEN);\n\tclose(fd);\n\ttrim_key();\n\tlog_debug(\"read key of size %d in authfile %s\",\n\t\tbooth_conf->authkey_len, booth_conf->authfile);\n\t/* make sure that the key is of minimum length */\n\treturn (booth_conf->authkey_len >= BOOTH_MIN_KEY_LEN) ? 0 : -1;\n}\n\nint update_authkey()\n{\n\tstruct stat statbuf;\n\n\tif (stat(booth_conf->authfile, &statbuf) < 0) {\n\t\tlog_error(\"cannot stat authentication file %s: %s\",\n\t\t\tbooth_conf->authfile, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (statbuf.st_mtime > booth_conf->authstat.st_mtime) {\n\t\treturn read_authkey();\n\t}\n\treturn 0;\n}\n\nstatic int setup_config(int type)\n{\n\tint rv;\n\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\n\t/* Set \"local\" pointer, ignoring errors. */\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\n\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\n\t/* Per default the PID file name is derived from the\n\t * configuration name. */\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\n\nout:\n\treturn rv;\n}\n\nstatic int setup_transport(void)\n{\n\tint rv;\n\n\trv = transport()->init(message_recv);\n\tif (rv < 0) {\n\t\tlog_error(\"failed to init booth_transport %s\", transport()->name);\n\t\tgoto out;\n\t}\n\n\trv = booth_transport[TCP].init(NULL);\n\tif (rv < 0) {\n\t\tlog_error(\"failed to init booth_transport[TCP]\");\n\t\tgoto out;\n\t}\n\nout:\n\treturn rv;\n}\n\n\nstatic int write_daemon_state(int fd, int state)\n{\n\tchar buffer[1024];\n\tint rv, size;\n\n\tsize = sizeof(buffer) - 1;\n\trv = snprintf(buffer, size,\n\t\t\t\"booth_pid=%d \"\n\t\t\t\"booth_state=%s \"\n\t\t\t\"booth_type=%s \"\n\t\t\t\"booth_cfg_name='%s' \"\n\t\t\t\"booth_id=%d \"\n\t\t\t\"booth_addr_string='%s' \"\n\t\t\t\"booth_port=%d\\n\",\n\t\tgetpid(), \n\t\t( state == BOOTHD_STARTED  ? \"started\"  : \n\t\t  state == BOOTHD_STARTING ? \"starting\" : \n\t\t  \"invalid\"), \n\t\ttype_to_string(local->type),\n\t\tbooth_conf->name,\n\t\tlocal->site_id,\n\t\tlocal->addr_string,\n\t\tbooth_conf->port);\n\n\tif (rv < 0 || rv == size) {\n\t\tlog_error(\"Buffer filled up in write_daemon_state().\");\n\t\treturn -1;\n\t}\n\tsize = rv;\n\n\n\trv = ftruncate(fd, 0);\n\tif (rv < 0) {\n\t\tlog_error(\"lockfile %s truncate error %d: %s\",\n\t\t\t\tcl.lockfile, errno, strerror(errno));\n\t\treturn rv;\n\t}\n\n\n\trv = lseek(fd, 0, SEEK_SET);\n\tif (rv < 0) {\n\t\tlog_error(\"lseek set fd(%d) offset to 0 error, return(%d), message(%s)\",\n\t\t\tfd, rv, strerror(errno));\n\t\trv = -1;\n\t\treturn rv;\n\t} \n\n\n\trv = write(fd, buffer, size);\n\n\tif (rv != size) {\n\t\tlog_error(\"write to fd(%d, %d) returned %d, errno %d, message(%s)\",\n                      fd, size,\n\t\t      rv, errno, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int process_signals(void)\n{\n\tif (sig_exit_handler_called) {\n\t\tlog_info(\"caught signal %d\", sig_exit_handler_sig);\n\t\treturn 1;\n\t}\n\tif (sig_usr1_handler_called) {\n\t\tsig_usr1_handler_called = 0;\n\t\ttickets_log_info();\n\t}\n\tif (sig_chld_handler_called) {\n\t\tsig_chld_handler_called = 0;\n\t\twait_child(SIGCHLD);\n\t}\n\n\treturn 0;\n}\n\nstatic int loop(int fd)\n{\n\tvoid (*workfn) (int ci);\n\tvoid (*deadfn) (int ci);\n\tint rv, i;\n\n\trv = setup_transport();\n\tif (rv < 0)\n\t\tgoto fail;\n\n\trv = setup_ticket();\n\tif (rv < 0)\n\t\tgoto fail;\n\n\trv = write_daemon_state(fd, BOOTHD_STARTED);\n\tif (rv != 0) {\n\t\tlog_error(\"write daemon state %d to lockfile error %s: %s\",\n                      BOOTHD_STARTED, cl.lockfile, strerror(errno));\n\t\tgoto fail;\n\t}\n\n\tlog_info(\"BOOTH %s daemon started, node id is 0x%08X (%d).\",\n\t\ttype_to_string(local->type),\n\t\t\tlocal->site_id, local->site_id);\n\n\twhile (1) {\n\t\trv = poll(pollfds, client_maxi + 1, poll_timeout);\n\t\tif (rv == -1 && errno == EINTR)\n\t\t\tcontinue;\n\t\tif (rv < 0) {\n\t\t\tlog_error(\"poll failed: %s (%d)\", strerror(errno), errno);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfor (i = 0; i <= client_maxi; i++) {\n\t\t\tif (clients[i].fd < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (pollfds[i].revents & POLLIN) {\n\t\t\t\tworkfn = clients[i].workfn;\n\t\t\t\tif (workfn)\n\t\t\t\t\tworkfn(i);\n\t\t\t}\n\t\t\tif (pollfds[i].revents &\n\t\t\t\t\t(POLLERR | POLLHUP | POLLNVAL)) {\n\t\t\t\tdeadfn = clients[i].deadfn;\n\t\t\t\tif (deadfn)\n\t\t\t\t\tdeadfn(i);\n\t\t\t}\n\t\t}\n\n\t\tprocess_tickets();\n\n\t\tif (process_signals() != 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail:\n\treturn -1;\n}\n\n\nstatic int test_reply(cmd_result_t reply_code, cmd_request_t cmd)\n{\n\tint rv = 0;\n\tconst char *op_str = \"\";\n\n\tif (cmd == CMD_GRANT)\n\t\top_str = \"grant\";\n\telse if (cmd == CMD_REVOKE)\n\t\top_str = \"revoke\";\n\telse if (cmd == CMD_LIST)\n\t\top_str = \"list\";\n\telse if (cmd == CMD_PEERS)\n\t\top_str = \"peers\";\n\telse {\n\t\tlog_error(\"internal error reading reply result!\");\n\t\treturn -1;\n\t}\n\n\tswitch (reply_code) {\n\tcase RLT_OVERGRANT:\n\t\tlog_info(\"You're granting a granted ticket. \"\n\t\t\t \"If you wanted to migrate a ticket, \"\n\t\t\t \"use revoke first, then use grant.\");\n\t\trv = -1;\n\t\tbreak;\n\n\tcase RLT_TICKET_IDLE:\n\t\tlog_info(\"ticket is not owned\");\n\t\trv = 0;\n\t\tbreak;\n\n\tcase RLT_ASYNC:\n\t\tlog_info(\"%s command sent, result will be returned \"\n\t\t\t \"asynchronously. Please use \\\"booth list\\\" to \"\n\t\t\t \"see the outcome.\", op_str);\n\t\trv = 0;\n\t\tbreak;\n\n\tcase RLT_CIB_PENDING:\n\t\tlog_info(\"%s succeeded (CIB commit pending)\", op_str);\n\t\t/* wait for the CIB commit? */\n\t\trv = (cl.options & OPT_WAIT_COMMIT) ? 3 : 0;\n\t\tbreak;\n\n\tcase RLT_MORE:\n\t\trv = 2;\n\t\tbreak;\n\n\tcase RLT_SYNC_SUCC:\n\tcase RLT_SUCCESS:\n\t\tif (cmd != CMD_LIST && cmd != CMD_PEERS)\n\t\t\tlog_info(\"%s succeeded!\", op_str);\n\t\trv = 0;\n\t\tbreak;\n\n\tcase RLT_SYNC_FAIL:\n\t\tlog_info(\"%s failed!\", op_str);\n\t\trv = -1;\n\t\tbreak;\n\n\tcase RLT_INVALID_ARG:\n\t\tlog_error(\"ticket \\\"%s\\\" does not exist\",\n\t\t\t\tcl.msg.ticket.id);\n\t\trv = -1;\n\t\tbreak;\n\n\tcase RLT_AUTH:\n\t\tlog_error(\"authentication error\");\n\t\trv = -1;\n\t\tbreak;\n\n\tcase RLT_EXT_FAILED:\n\t\tlog_error(\"before-acquire-handler for ticket \\\"%s\\\" failed, grant denied\",\n\t\t\t\tcl.msg.ticket.id);\n\t\trv = -1;\n\t\tbreak;\n\n\tcase RLT_ATTR_PREREQ:\n\t\tlog_error(\"attr-prereq for ticket \\\"%s\\\" failed, grant denied\",\n\t\t\t\tcl.msg.ticket.id);\n\t\trv = -1;\n\t\tbreak;\n\n\tcase RLT_REDIRECT:\n\t\t/* talk to another site */\n\t\trv = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(\"got an error code: %x\", rv);\n\t\trv = -1;\n\t}\n\treturn rv;\n}\n\nstatic int query_get_string_answer(cmd_request_t cmd)\n{\n\tstruct booth_site *site;\n\tstruct boothc_hdr_msg reply;\n\tstruct boothc_header *header;\n\tchar *data;\n\tint data_len;\n\tint rv;\n\tstruct booth_transport const *tpt;\n\tint (*test_reply_f) (cmd_result_t reply_code, cmd_request_t cmd);\n\tsize_t msg_size;\n\tvoid *request;\n\n\tif (cl.type == GEOSTORE) {\n\t\ttest_reply_f = test_attr_reply;\n\t\tmsg_size = sizeof(cl.attr_msg);\n\t\trequest = &cl.attr_msg;\n\t} else {\n\t\ttest_reply_f = test_reply;\n\t\tmsg_size = sizeof(cl.msg);\n\t\trequest = &cl.msg;\n\t}\n\theader = (struct boothc_header *)request;\n\tdata = NULL;\n\n\tinit_header(header, cmd, 0, cl.options, 0, 0, msg_size);\n\n\tif (!*cl.site)\n\t\tsite = local;\n\telse if (!find_site_by_name(cl.site, &site, 1)) {\n\t\tlog_error(\"cannot find site \\\"%s\\\"\", cl.site);\n\t\trv = ENOENT;\n\t\tgoto out;\n\t}\n\n\ttpt = booth_transport + TCP;\n\trv = tpt->open(site);\n\tif (rv < 0)\n\t\tgoto out_close;\n\n\trv = tpt->send(site, request, msg_size);\n\tif (rv < 0)\n\t\tgoto out_close;\n\n\trv = tpt->recv_auth(site, &reply, sizeof(reply));\n\tif (rv < 0)\n\t\tgoto out_close;\n\n\tdata_len = ntohl(reply.header.length) - rv;\n\n\t/* no attribute, or no ticket found */\n\tif (!data_len) {\n\t\tgoto out_test_reply;\n\t}\n\n\tdata = malloc(data_len+1);\n\tif (!data) {\n\t\trv = -ENOMEM;\n\t\tgoto out_close;\n\t}\n\trv = tpt->recv(site, data, data_len);\n\tif (rv < 0)\n\t\tgoto out_close;\n\t*(data+data_len) = '\\0';\n\n\t*(data + data_len) = '\\0';\n\t(void)fputs(data, stdout);\n\tfflush(stdout);\n\trv = 0;\n\nout_test_reply:\n\trv = test_reply_f(ntohl(reply.header.result), cmd);\nout_close:\n\ttpt->close(site);\nout:\n\tif (data)\n\t\tfree(data);\n\treturn rv;\n}\n\n\nstatic int do_command(cmd_request_t cmd)\n{\n\tstruct booth_site *site;\n\tstruct boothc_ticket_msg reply;\n\tstruct booth_transport const *tpt;\n\tuint32_t leader_id;\n\tint rv;\n\tint reply_cnt = 0, msg_logged = 0;\n\tconst char *op_str = \"\";\n\n\tif (cmd == CMD_GRANT)\n\t\top_str = \"grant\";\n\telse if (cmd == CMD_REVOKE)\n\t\top_str = \"revoke\";\n\n\trv = 0;\n\tsite = NULL;\n\n\t/* Always use TCP for client - at least for now. */\n\ttpt = booth_transport + TCP;\n\n\tif (!*cl.site)\n\t\tsite = local;\n\telse {\n\t\tif (!find_site_by_name(cl.site, &site, 1)) {\n\t\t\tlog_error(\"Site \\\"%s\\\" not configured.\", cl.site);\n\t\t\tgoto out_close;\n\t\t}\n\t}\n\n\tif (site->type == ARBITRATOR) {\n\t\tif (site == local) {\n\t\t\tlog_error(\"We're just an arbitrator, cannot grant/revoke tickets here.\");\n\t\t} else {\n\t\t\tlog_error(\"%s is just an arbitrator, cannot grant/revoke tickets there.\", cl.site);\n\t\t}\n\t\tgoto out_close;\n\t}\n\n\tassert(site->type == SITE);\n\n\t/* We don't check for existence of ticket, so that asking can be\n\t * done without local configuration, too.\n\t * Although, that means that the UDP port has to be specified, too. */\n\tif (!cl.msg.ticket.id[0]) {\n\t\t/* If the loaded configuration has only a single ticket defined, use that. */\n\t\tif (booth_conf->ticket_count == 1) {\n\t\t\tstrncpy(cl.msg.ticket.id, booth_conf->ticket[0].name,\n\t\t\t\tsizeof(cl.msg.ticket.id));\n\t\t} else {\n\t\t\tlog_error(\"No ticket given.\");\n\t\t\tgoto out_close;\n\t\t}\n\t}\n\nredirect:\n\tinit_header(&cl.msg.header, cmd, 0, cl.options, 0, 0, sizeof(cl.msg));\n\n\trv = tpt->open(site);\n\tif (rv < 0)\n\t\tgoto out_close;\n\n\trv = tpt->send(site, &cl.msg, sendmsglen(&cl.msg));\n\tif (rv < 0)\n\t\tgoto out_close;\n\nread_more:\n\trv = tpt->recv_auth(site, &reply, sizeof(reply));\n\tif (rv < 0) {\n\t\t/* print any errors depending on the code sent by the\n\t\t * server */\n\t\t(void)test_reply(ntohl(reply.header.result), cmd);\n\t\tgoto out_close;\n\t}\n\n\trv = test_reply(ntohl(reply.header.result), cmd);\n\tif (rv == 1) {\n\t\ttpt->close(site);\n\t\tleader_id = ntohl(reply.ticket.leader);\n\t\tif (!find_site_by_id(leader_id, &site)) {\n\t\t\tlog_error(\"Message with unknown redirect site %x received\", leader_id);\n\t\t\trv = -1;\n\t\t\tgoto out_close;\n\t\t}\n\t\tgoto redirect;\n\t} else if (rv == 2 || rv == 3) {\n\t\t/* the server has more to say */\n\t\t/* don't wait too long */\n\t\tif (reply_cnt > 1 && !(cl.options & OPT_WAIT)) {\n\t\t\trv = 0;\n\t\t\tlog_info(\"Giving up on waiting for the definite result. \"\n\t\t\t\t \"Please use \\\"booth list\\\" later to \"\n\t\t\t\t \"see the outcome.\");\n\t\t\tgoto out_close;\n\t\t}\n\t\tif (reply_cnt == 0) {\n\t\t\tlog_info(\"%s request sent, \"\n\t\t\t\t\"waiting for the result ...\", op_str);\n\t\t\tmsg_logged++;\n\t\t} else if (rv == 3 && msg_logged < 2) {\n\t\t\tlog_info(\"waiting for the CIB commit ...\");\n\t\t\tmsg_logged++;\n\t\t}\n\t\treply_cnt++;\n\t\tgoto read_more;\n\t}\n\nout_close:\n\tif (site)\n\t\ttpt->close(site);\n\treturn rv;\n}\n\n\n\nstatic int _lockfile(int mode, int *fdp, pid_t *locked_by)\n{\n\tstruct flock lock;\n\tint fd, rv;\n\n\n\t/* After reboot the directory may not yet exist.\n\t * Try to create it, but ignore errors. */\n\tif (strncmp(cl.lockfile, BOOTH_RUN_DIR,\n\t\t\t\tstrlen(BOOTH_RUN_DIR)) == 0)\n\t\t(void)mkdir(BOOTH_RUN_DIR, 0775);\n\n\n\tif (locked_by)\n\t\t*locked_by = 0;\n\n\t*fdp = -1;\n\tfd = open(cl.lockfile, mode, 0664);\n\tif (fd < 0)\n\t\treturn errno;\n\n\t*fdp = fd;\n\n\tlock.l_type = F_WRLCK;\n\tlock.l_start = 0;\n\tlock.l_whence = SEEK_SET;\n\tlock.l_len = 0;\n\tlock.l_pid = 0;\n\n\n\tif (fcntl(fd, F_SETLK, &lock) == 0)\n\t\treturn 0;\n\n\trv = errno;\n\n\tif (locked_by)\n\t\tif (fcntl(fd, F_GETLK, &lock) == 0)\n\t\t\t*locked_by = lock.l_pid;\n\n\treturn rv;\n}\n\n\nstatic inline int is_root(void)\n{\n\treturn geteuid() == 0;\n}\n\n\nstatic int create_lockfile(void)\n{\n\tint rv, fd;\n\n\tfd = -1;\n\trv = _lockfile(O_CREAT | O_WRONLY, &fd, NULL);\n\n\tif (fd == -1) {\n\t\tlog_error(\"lockfile %s open error %d: %s\",\n\t\t\t\tcl.lockfile, rv, strerror(rv));\n\t\treturn -1;\n\t}\n\n\tif (rv < 0) {\n\t\tlog_error(\"lockfile %s setlk error %d: %s\",\n\t\t\t\tcl.lockfile, rv, strerror(rv));\n\t\tgoto fail;\n\t}\n\n\trv = write_daemon_state(fd, BOOTHD_STARTING);\n\tif (rv != 0) {\n\t\tlog_error(\"write daemon state %d to lockfile error %s: %s\",\n\t\t\t\tBOOTHD_STARTING, cl.lockfile, strerror(errno));\n\t\tgoto fail;\n\t}\n\n\tif (is_root()) {\n\t\tif (fchown(fd, booth_conf->uid, booth_conf->gid) < 0)\n\t\t\tlog_error(\"fchown() on lockfile said %d: %s\",\n\t\t\t\t\terrno, strerror(errno));\n\t}\n\n\treturn fd;\n\nfail:\n\tclose(fd);\n\treturn -1;\n}\n\nstatic void unlink_lockfile(int fd)\n{\n\tunlink(cl.lockfile);\n\tclose(fd);\n}\n\nstatic void print_usage(void)\n{\n\tprintf(\n\t\"Usage:\\n\"\n\t\"  booth list [options]\\n\"\n\t\"  booth {grant|revoke} [options] <ticket>\\n\"\n\t\"  booth status [options]\\n\"\n\t\"\\n\"\n\t\"  list:\t     List all tickets\\n\"\n\t\"  grant:        Grant ticket to site\\n\"\n\t\"  revoke:       Revoke ticket\\n\"\n\t\"\\n\"\n\t\"Options:\\n\"\n\t\"  -c FILE       Specify config file [default \" BOOTH_DEFAULT_CONF \"]\\n\"\n\t\"                Can be a path or just a name without \\\".conf\\\" suffix\\n\"\n\t\"  -s <site>     Connect/grant to a different site\\n\"\n\t\"  -F            Try to grant the ticket immediately\\n\"\n\t\"                even if not all sites are reachable\\n\"\n\t\"                For manual tickets:\\n\"\n\t\"                grant a manual ticket even if it has been already granted\\n\"\n\t\"  -w            Wait forever for the outcome of the request\\n\"\n\t\"  -C            Wait until the ticket is committed to the CIB (grant only)\\n\"\n\t\"  -h            Print this help\\n\"\n\t\"\\n\"\n\t\"Examples:\\n\"\n\t\"\\n\"\n\t\"  # booth list (list tickets)\\n\"\n\t\"  # booth grant ticket-A (grant ticket here)\\n\"\n\t\"  # booth grant -s 10.121.8.183 ticket-A (grant ticket to site 10.121.8.183)\\n\"\n\t\"  # booth revoke ticket-A (revoke ticket)\\n\"\n\t\"\\n\"\n\t\"See the booth(8) man page for more details.\\n\"\n\t);\n}\n\n#define OPTION_STRING\t\t\"c:Dl:t:s:FhSwC\"\n#define ATTR_OPTION_STRING\t\t\"c:Dt:s:h\"\n\nvoid safe_copy(char *dest, char *value, size_t buflen, const char *description) {\n\tint content_len = buflen - 1;\n\n\tif (strlen(value) >= content_len) {\n\t\tfprintf(stderr, \"'%s' exceeds maximum %s length of %d\\n\",\n\t\t\tvalue, description, content_len);\n\t\texit(EXIT_FAILURE);\n\t}\n\tstrncpy(dest, value, content_len);\n\tdest[content_len] = 0;\n}\n\nstatic int host_convert(char *hostname, char *ip_str, size_t ip_size)\n{\n\tstruct addrinfo *result = NULL, hints = {0};\n\tint re = -1;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = AF_INET;\n\thints.ai_socktype = SOCK_DGRAM;\n\n\tre = getaddrinfo(hostname, NULL, &hints, &result);\n\n\tif (re == 0) {\n\t\tstruct in_addr addr = ((struct sockaddr_in *)result->ai_addr)->sin_addr;\n\t\tconst char *re_ntop = inet_ntop(AF_INET, &addr, ip_str, ip_size);\n\t\tif (re_ntop == NULL) {\n\t\t\tre = -1;\n\t\t}\n\t}\n\n\tfreeaddrinfo(result);\n\treturn re;\n}\n\n#define cparg(dest, descr) do { \\\n\tif (optind >= argc) \\\n\t\tgoto missingarg; \\\n\tsafe_copy(dest, argv[optind], sizeof(dest), descr); \\\n\toptind++; \\\n} while(0)\n\nstatic int read_arguments(int argc, char **argv)\n{\n\tint optchar;\n\tchar *arg1 = argv[1];\n\tchar *op = NULL;\n\tchar *cp;\n\tconst char *opt_string = OPTION_STRING;\n\tchar site_arg[INET_ADDRSTRLEN] = {0};\n\tint left;\n\n\tcl.type = 0;\n\tif ((cp = strstr(argv[0], ATTR_PROG)) &&\n\t\t\t!strcmp(cp, ATTR_PROG)) {\n\t\tcl.type = GEOSTORE;\n\t\top = argv[1];\n\t\toptind = 2;\n\t\topt_string = ATTR_OPTION_STRING;\n\t} else if (argc > 1 && (strcmp(arg1, \"arbitrator\") == 0 ||\n\t\t\tstrcmp(arg1, \"site\") == 0 ||\n\t\t\tstrcmp(arg1, \"start\") == 0 ||\n\t\t\tstrcmp(arg1, \"daemon\") == 0)) {\n\t\tcl.type = DAEMON;\n\t\toptind = 2;\n\t} else if (argc > 1 && (strcmp(arg1, \"status\") == 0)) {\n\t\tcl.type = STATUS;\n\t\toptind = 2;\n\t} else if (argc > 1 && (strcmp(arg1, \"client\") == 0)) {\n\t\tcl.type = CLIENT;\n\t\tif (argc < 3) {\n\t\t\tprint_usage();\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\top = argv[2];\n\t\toptind = 3;\n\t}\n\tif (!cl.type) {\n\t\tcl.type = CLIENT;\n\t\top = argv[1];\n\t\toptind = 2;\n    }\n\n\tif (argc < 2 || !strcmp(arg1, \"help\") || !strcmp(arg1, \"--help\") ||\n\t\t\t!strcmp(arg1, \"-h\")) {\n\t\tif (cl.type == GEOSTORE)\n\t\t\tprint_geostore_usage();\n\t\telse\n\t\t\tprint_usage();\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tif (!strcmp(arg1, \"version\") || !strcmp(arg1, \"--version\") ||\n\t\t\t!strcmp(arg1, \"-V\")) {\n\t\tprintf(\"%s %s\\n\", argv[0], RELEASE_STR);\n\t\texit(EXIT_SUCCESS);\n\t}\n\n    if (cl.type == CLIENT) {\n\t\tif (!strcmp(op, \"list\"))\n\t\t\tcl.op = CMD_LIST;\n\t\telse if (!strcmp(op, \"grant\"))\n\t\t\tcl.op = CMD_GRANT;\n\t\telse if (!strcmp(op, \"revoke\"))\n\t\t\tcl.op = CMD_REVOKE;\n\t\telse if (!strcmp(op, \"peers\"))\n\t\t\tcl.op = CMD_PEERS;\n\t\telse {\n\t\t\tfprintf(stderr, \"client operation \\\"%s\\\" is unknown\\n\",\n\t\t\t\t\top);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} else if (cl.type == GEOSTORE) {\n\t\tif (!strcmp(op, \"list\"))\n\t\t\tcl.op = ATTR_LIST;\n\t\telse if (!strcmp(op, \"set\"))\n\t\t\tcl.op = ATTR_SET;\n\t\telse if (!strcmp(op, \"get\"))\n\t\t\tcl.op = ATTR_GET;\n\t\telse if (!strcmp(op, \"delete\"))\n\t\t\tcl.op = ATTR_DEL;\n\t\telse {\n\t\t\tfprintf(stderr, \"attribute operation \\\"%s\\\" is unknown\\n\",\n\t\t\t\t\top);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\twhile (optind < argc) {\n\t\toptchar = getopt(argc, argv, opt_string);\n\n\t\tswitch (optchar) {\n\t\tcase 'c':\n\t\t\tif (strchr(optarg, '/')) {\n\t\t\t\tsafe_copy(cl.configfile, optarg,\n\t\t\t\t\t\tsizeof(cl.configfile), \"config file\");\n\t\t\t} else {\n\t\t\t\t/* If no \"/\" in there, use with default directory. */\n\t\t\t\tstrcpy(cl.configfile, BOOTH_DEFAULT_CONF_DIR);\n\t\t\t\tcp = cl.configfile + strlen(BOOTH_DEFAULT_CONF_DIR);\n\t\t\t\tassert(cp > cl.configfile);\n\t\t\t\tassert(*(cp-1) == '/');\n\n\t\t\t\t/* Write at the \\0, ie. after the \"/\" */\n\t\t\t\tsafe_copy(cp, optarg,\n\t\t\t\t\t\t(sizeof(cl.configfile) -\n\t\t\t\t\t\t (cp -  cl.configfile) -\n\t\t\t\t\t\t strlen(BOOTH_DEFAULT_CONF_EXT)),\n\t\t\t\t\t\t\"config name\");\n\n\t\t\t\t/* If no extension, append \".conf\".\n\t\t\t\t * Space is available, see -strlen() above. */\n\t\t\t\tif (!strchr(cp, '.'))\n\t\t\t\t\tstrcat(cp, BOOTH_DEFAULT_CONF_EXT);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tdebug_level++;\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\tdaemonize = 0;\n\t\t\tenable_stderr = 1;\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tsafe_copy(cl.lockfile, optarg, sizeof(cl.lockfile), \"lock file\");\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (cl.op == CMD_GRANT || cl.op == CMD_REVOKE) {\n\t\t\t\tsafe_copy(cl.msg.ticket.id, optarg,\n\t\t\t\t\t\tsizeof(cl.msg.ticket.id), \"ticket name\");\n\t\t\t} else if (cl.type == GEOSTORE) {\n\t\t\t\tsafe_copy(cl.attr_msg.attr.tkt_id, optarg,\n\t\t\t\t\t\tsizeof(cl.attr_msg.attr.tkt_id), \"ticket name\");\n\t\t\t} else {\n\t\t\t\tprint_usage();\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\t/* For testing and debugging: allow \"-s site\" also for\n\t\t\t * daemon start, so that the address that should be used\n\t\t\t * can be set manually.\n\t\t\t * This makes it easier to start multiple processes\n\t\t\t * on one machine. */\n\t\t\tif (cl.type == CLIENT || cl.type == GEOSTORE ||\n\t\t\t\t\t(cl.type == DAEMON && debug_level)) {\n\t\t\t\tif (strcmp(optarg, OTHER_SITE) &&\n\t\t\t\t\t\thost_convert(optarg, site_arg, INET_ADDRSTRLEN) == 0) {\n\t\t\t\t\tsafe_copy(cl.site, site_arg, sizeof(cl.site), \"site name\");\n\t\t\t\t} else {\n\t\t\t\t\tsafe_copy(cl.site, optarg, sizeof(cl.site), \"site name\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog_error(\"\\\"-s\\\" not allowed in daemon mode.\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\tif (cl.type != CLIENT || cl.op != CMD_GRANT) {\n\t\t\t\tlog_error(\"use \\\"-F\\\" only for client grant\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tcl.options |= OPT_IMMEDIATE;\n\t\t\tbreak;\n\n\t\tcase 'w':\n\t\t\tif (cl.type != CLIENT ||\n\t\t\t\t\t(cl.op != CMD_GRANT && cl.op != CMD_REVOKE)) {\n\t\t\t\tlog_error(\"use \\\"-w\\\" only for grant and revoke\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tcl.options |= OPT_WAIT;\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tif (cl.type != CLIENT || cl.op != CMD_GRANT) {\n\t\t\t\tlog_error(\"use \\\"-C\\\" only for grant\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tcl.options |= OPT_WAIT | OPT_WAIT_COMMIT;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tif (cl.type == GEOSTORE)\n\t\t\t\tprint_geostore_usage();\n\t\t\telse\n\t\t\t\tprint_usage();\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\n\t\tcase ':':\n\t\tcase '?':\n\t\t\tfprintf(stderr, \"Please use '-h' for usage.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\tbreak;\n\n\t\tcase -1:\n\t\t\t/* No more parameters on cmdline, only arguments. */\n\t\t\tgoto extra_args;\n\n\t\tdefault:\n\t\t\tgoto unknown;\n\t\t};\n\t}\n\n\treturn 0;\n\nextra_args:\n\tif (cl.type == CLIENT && !cl.msg.ticket.id[0]) {\n\t\tcparg(cl.msg.ticket.id, \"ticket name\");\n\t} else if (cl.type == GEOSTORE) {\n\t\tif (cl.op != ATTR_LIST) {\n\t\t\tcparg(cl.attr_msg.attr.name, \"attribute name\");\n\t\t}\n\t\tif (cl.op == ATTR_SET) {\n\t\t\tcparg(cl.attr_msg.attr.val, \"attribute value\");\n\t\t}\n\t}\n\n\tif (optind == argc)\n\t\treturn 0;\n\n\n\tleft = argc - optind;\n\tfprintf(stderr, \"Superfluous argument%s: %s%s\\n\",\n\t\t\tleft == 1 ? \"\" : \"s\",\n\t\t\targv[optind],\n\t\t\tleft == 1 ? \"\" : \"...\");\n\texit(EXIT_FAILURE);\n\nunknown:\n\tfprintf(stderr, \"unknown option: %s\\n\", argv[optind]);\n\texit(EXIT_FAILURE);\n\nmissingarg:\n\tfprintf(stderr, \"not enough arguments\\n\");\n\texit(EXIT_FAILURE);\n}\n\n\nstatic void set_scheduler(void)\n{\n\tstruct sched_param sched_param;\n\tstruct rlimit rlimit;\n\tint rv;\n\n\trlimit.rlim_cur = RLIM_INFINITY;\n\trlimit.rlim_max = RLIM_INFINITY;\n\trv = setrlimit(RLIMIT_MEMLOCK, &rlimit);\n\tif (rv < 0) {\n\t\tlog_error(\"setrlimit failed\");\n\t} else {\n                rv = mlockall(MCL_CURRENT | MCL_FUTURE);\n                if (rv < 0) {\n                        log_error(\"mlockall failed\");\n                }\n        }\n\n\trv = sched_get_priority_max(SCHED_RR);\n\tif (rv != -1) {\n\t\tsched_param.sched_priority = rv;\n\t\trv = sched_setscheduler(0, SCHED_RR, &sched_param);\n\t\tif (rv == -1)\n\t\t\tlog_error(\"could not set SCHED_RR priority %d: %s (%d)\",\n\t\t\t\t\tsched_param.sched_priority,\n\t\t\t\t\tstrerror(errno), errno);\n\t} else {\n\t\tlog_error(\"could not get maximum scheduler priority err %d\",\n\t\t\t\terrno);\n\t}\n}\n\nstatic int set_procfs_val(const char *path, const char *val)\n{\n\tint rc = -1;\n\tFILE *fp = fopen(path, \"w\");\n\n\tif (fp) {\n\t\tif (fprintf(fp, \"%s\", val) > 0)\n\t\t\trc = 0;\n\t\tfclose(fp);\n\t}\n\treturn rc;\n}\n\nstatic int do_status(int type)\n{\n\tpid_t pid;\n\tint rv, status_lock_fd, ret;\n\tconst char *reason = NULL;\n\tchar lockfile_data[1024], *cp;\n\n\n\tret = PCMK_OCF_NOT_RUNNING;\n\n\trv = setup_config(type);\n\tif (rv) {\n\t\treason = \"Error reading configuration.\";\n\t\tret = PCMK_OCF_UNKNOWN_ERROR;\n\t\tgoto quit;\n\t}\n\n\n\tif (!local) {\n\t\treason = \"No Service IP active here.\";\n\t\tgoto quit;\n\t}\n\n\n\trv = _lockfile(O_RDWR, &status_lock_fd, &pid);\n\tif (status_lock_fd == -1) {\n\t\treason = \"No PID file.\";\n\t\tgoto quit;\n\t}\n\tif (rv == 0) {\n\t\tclose(status_lock_fd);\n\t\treason = \"PID file not locked.\";\n\t\tgoto quit;\n\t}\n\tif (pid) {\n\t\tfprintf(stdout, \"booth_lockpid=%d \", pid);\n\t\tfflush(stdout);\n\t}\n\n\trv = read(status_lock_fd, lockfile_data, sizeof(lockfile_data) - 1);\n\tif (rv < 4) {\n\t\tclose(status_lock_fd);\n\t\treason = \"Cannot read lockfile data.\";\n\t\tret = PCMK_LSB_UNKNOWN_ERROR;\n\t\tgoto quit;\n\t}\n\tlockfile_data[rv] = 0;\n\n\tclose(status_lock_fd);\n\n\n\t/* Make sure it's only a single line */\n\tcp = strchr(lockfile_data, '\\r');\n\tif (cp)\n\t\t*cp = 0;\n\tcp = strchr(lockfile_data, '\\n');\n\tif (cp)\n\t\t*cp = 0;\n\n\n\n\trv = setup_tcp_listener(1);\n\tif (rv == 0) {\n\t\treason = \"TCP port not in use.\";\n\t\tgoto quit;\n\t}\n\n\n\tfprintf(stdout, \"booth_lockfile='%s' %s\\n\",\n\t\t\tcl.lockfile, lockfile_data);\n\tif (!daemonize)\n\t\tfprintf(stderr, \"Booth at %s port %d seems to be running.\\n\",\n\t\t\t\tlocal->addr_string, booth_conf->port);\n\treturn 0;\n\n\nquit:\n\tlog_debug(\"not running: %s\", reason);\n\t/* Ie. \"DEBUG\" */\n\tif (!daemonize)\n\t\tfprintf(stderr, \"not running: %s\\n\", reason);\n\treturn ret;\n}\n\n\nstatic int limit_this_process(void)\n{\n\tint rv;\n\tif (!is_root())\n\t\treturn 0;\n\n\tif (setregid(booth_conf->gid, booth_conf->gid) < 0) {\n\t\trv = errno;\n\t\tlog_error(\"setregid() didn't work: %s\", strerror(rv));\n\t\treturn rv;\n\t}\n\n\tif (setreuid(booth_conf->uid, booth_conf->uid) < 0) {\n\t\trv = errno;\n\t\tlog_error(\"setreuid() didn't work: %s\", strerror(rv));\n\t\treturn rv;\n\t}\n\n\treturn 0;\n}\n\nstatic int lock_fd = -1;\n\nstatic void server_exit(void)\n{\n\tint rv;\n\n\tif (lock_fd >= 0) {\n\t\t/* We might not be able to delete it, but at least\n\t\t * make it empty. */\n\t\trv = ftruncate(lock_fd, 0);\n\t\t(void)rv;\n\t\tunlink_lockfile(lock_fd);\n\t}\n\tlog_info(\"exiting\");\n}\n\nstatic void sig_exit_handler(int sig)\n{\n\tsig_exit_handler_sig = sig;\n\tsig_exit_handler_called = 1;\n}\n\nstatic void sig_usr1_handler(int sig)\n{\n\tsig_usr1_handler_called = 1;\n}\n\nstatic void sig_chld_handler(int sig)\n{\n\tsig_chld_handler_called = 1;\n}\n\nstatic int do_server(int type)\n{\n\tint rv = -1;\n\tstatic char log_ent[128] = DAEMON_NAME \"-\";\n\n\trv = setup_config(type);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tif (!local) {\n\t\tlog_error(\"Cannot find myself in the configuration.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (daemonize) {\n\t\tif (daemon(0, 0) < 0) {\n\t\t\tperror(\"daemon error\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\t/*\n\t * Register signal and exit handler\n\t */\n\tsignal(SIGUSR1, (__sighandler_t)sig_usr1_handler);\n\tsignal(SIGTERM, (__sighandler_t)sig_exit_handler);\n\tsignal(SIGINT, (__sighandler_t)sig_exit_handler);\n\t/* we'll handle errors there and then */\n\tsignal(SIGPIPE, SIG_IGN);\n\n\tatexit(server_exit);\n\n\t/* The lockfile must be written to _after_ the call to daemon(), so\n\t * that the lockfile contains the pid of the daemon, not the parent. */\n\tlock_fd = create_lockfile();\n\tif (lock_fd < 0)\n\t\treturn lock_fd;\n\n\tstrcat(log_ent, type_to_string(local->type));\n\tcl_log_set_entity(log_ent);\n\tcl_log_enable_stderr(enable_stderr ? TRUE : FALSE);\n\tcl_log_set_facility(HA_LOG_FACILITY);\n\tcl_inherit_logging_environment(0);\n\n\tlog_info(\"BOOTH %s %s daemon is starting\",\n\t\t\ttype_to_string(local->type), RELEASE_STR);\n\n\n\tset_scheduler();\n\t/* we don't want to be killed by the OOM-killer */\n\tif (set_procfs_val(\"/proc/self/oom_score_adj\", \"-999\"))\n\t\t(void)set_procfs_val(\"/proc/self/oom_adj\", \"-16\");\n\tset_proc_title(\"%s %s %s for [%s]:%d\",\n\t\t\tDAEMON_NAME,\n\t\t\tcl.configfile,\n\t\t\ttype_to_string(local->type),\n\t\t\tlocal->addr_string,\n\t\t\tbooth_conf->port);\n\n\trv = limit_this_process();\n\tif (rv)\n\t\treturn rv;\n\n#ifdef COREDUMP_NURSING\n\tif (cl_enable_coredumps(TRUE) < 0){\n\t\tlog_error(\"enabling core dump failed\");\n\t}\n\tcl_cdtocoredir();\n\tprctl(PR_SET_DUMPABLE, (unsigned long)TRUE, 0UL, 0UL, 0UL);\n#else\n\tif (chdir(BOOTH_CORE_DIR) < 0) {\n\t\tlog_error(\"cannot change working directory to %s\", BOOTH_CORE_DIR);\n\t}\n#endif\n\n\tsignal(SIGCHLD, (__sighandler_t)sig_chld_handler);\n\trv = loop(lock_fd);\n\n\treturn rv;\n}\n\nstatic int do_client(void)\n{\n\tint rv;\n\n\trv = setup_config(CLIENT);\n\tif (rv < 0) {\n\t\tlog_error(\"cannot read config\");\n\t\tgoto out;\n\t}\n\n\tswitch (cl.op) {\n\tcase CMD_LIST:\n\tcase CMD_PEERS:\n\t\trv = query_get_string_answer(cl.op);\n\t\tbreak;\n\n\tcase CMD_GRANT:\n\tcase CMD_REVOKE:\n\t\trv = do_command(cl.op);\n\t\tbreak;\n\t}\n\nout:\n\treturn rv;\n}\n\nstatic int do_attr(void)\n{\n\tint rv = -1;\n\n\trv = setup_config(GEOSTORE);\n\tif (rv < 0) {\n\t\tlog_error(\"cannot read config\");\n\t\tgoto out;\n\t}\n\n\t/* We don't check for existence of ticket, so that asking can be\n\t * done without local configuration, too.\n\t * Although, that means that the UDP port has to be specified, too. */\n\tif (!cl.attr_msg.attr.tkt_id[0]) {\n\t\t/* If the loaded configuration has only a single ticket defined, use that. */\n\t\tif (booth_conf->ticket_count == 1) {\n\t\t\tstrncpy(cl.attr_msg.attr.tkt_id, booth_conf->ticket[0].name,\n\t\t\t\tsizeof(cl.attr_msg.attr.tkt_id));\n\t\t} else {\n\t\t\trv = 1;\n\t\t\tlog_error(\"No ticket given.\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (cl.op) {\n\tcase ATTR_LIST:\n\tcase ATTR_GET:\n\t\trv = query_get_string_answer(cl.op);\n\t\tbreak;\n\n\tcase ATTR_SET:\n\tcase ATTR_DEL:\n\t\trv = do_attr_command(cl.op);\n\t\tbreak;\n\t}\n\nout:\n\treturn rv;\n}\n\nint main(int argc, char *argv[], char *envp[])\n{\n\tint rv;\n\tconst char *cp;\n#ifdef LOGGING_LIBQB\n\tenum qb_log_target_slot i;\n#endif\n\n\tinit_set_proc_title(argc, argv, envp);\n\tget_time(&start_time);\n\n\tmemset(&cl, 0, sizeof(cl));\n\tstrncpy(cl.configfile,\n\t\t\tBOOTH_DEFAULT_CONF, BOOTH_PATH_LEN - 1);\n\tcl.lockfile[0] = 0;\n\tdebug_level = 0;\n\n\n\tcp = ((cp = strstr(argv[0], ATTR_PROG)) && !strcmp(cp, ATTR_PROG)\n\t\t? ATTR_PROG\n\t\t: \"booth\");\n#ifndef LOGGING_LIBQB\n\tcl_log_set_entity(cp);\n#else\n\tqb_log_init(cp, LOG_USER, LOG_DEBUG);  /* prio driven by debug_level */\n\tfor (i = QB_LOG_TARGET_START; i < QB_LOG_TARGET_MAX; i++) {\n\t\tif (i == QB_LOG_SYSLOG || i == QB_LOG_BLACKBOX)\n\t\t\tcontinue;\n\t\tqb_log_format_set(i, \"%t %H %N: [%P]: %p: %b\");\n\t}\n\t(void) qb_log_filter_ctl(QB_LOG_STDERR, QB_LOG_FILTER_ADD,\n\t                         QB_LOG_FILTER_FILE, \"*\", LOG_DEBUG);\n#endif\n\tcl_log_enable_stderr(TRUE);\n\tcl_log_set_facility(0);\n\n\trv = read_arguments(argc, argv);\n\tif (rv < 0)\n\t\tgoto out;\n\n\n\tswitch (cl.type) {\n\tcase STATUS:\n\t\trv = do_status(cl.type);\n\t\tbreak;\n\n\tcase ARBITRATOR:\n\tcase DAEMON:\n\tcase SITE:\n\t\trv = do_server(cl.type);\n\t\tbreak;\n\n\tcase CLIENT:\n\t\trv = do_client();\n\t\tbreak;\n\n\tcase GEOSTORE:\n\t\trv = do_attr();\n\t\tbreak;\n\t}\n\nout:\n#ifdef LOGGING_LIBQB\n\tqb_log_fini();\n#endif\n\t/* Normalize values. 0x100 would be seen as \"OK\" by waitpid(). */\n\treturn (rv >= 0 && rv < 0x70) ? rv : 1;\n}\n"], "fixing_code": ["/* \n * Copyright (C) 2011 Jiaju Zhang <jjzhang@suse.de>\n * Copyright (C) 2013-2014 Philipp Marek <philipp.marek@linbit.com>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"b_config.h\"\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sched.h>\n#include <errno.h>\n#include <limits.h>\n#include <sys/file.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/poll.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n#include <signal.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n\n#include <crm/services.h>\n\n#if HAVE_LIBGCRYPT\n#include <gcrypt.h>\n#endif\n#ifndef NAMETAG_LIBSYSTEMD\n#include <clplumbing/setproctitle.h>\n#else\n#include \"alt/nametag_libsystemd.h\"\n#endif\n#ifdef COREDUMP_NURSING\n#include <sys/prctl.h>\n#include <clplumbing/coredumps.h>\n#endif\n#include \"log.h\"\n#include \"booth.h\"\n#include \"config.h\"\n#include \"transport.h\"\n#include \"inline-fn.h\"\n#include \"pacemaker.h\"\n#include \"ticket.h\"\n#include \"request.h\"\n#include \"attr.h\"\n#include \"handler.h\"\n\n#define RELEASE_STR \tVERSION\n\n#define CLIENT_NALLOC\t\t32\n\nstatic int daemonize = 1;\nint enable_stderr = 0;\ntimetype start_time;\n\n\n/** Structure for \"clients\".\n * Filehandles with incoming data get registered here (and in pollfds),\n * along with their callbacks.\n * Because these can be reallocated with every new fd, addressing\n * happens _only_ by their numeric index. */\nstruct client *clients = NULL;\nstruct pollfd *pollfds = NULL;\nstatic int client_maxi;\nstatic int client_size = 0;\n\n\nstatic const struct booth_site _no_leader = {\n\t.addr_string = \"none\",\n\t.site_id = NO_ONE,\n\t.index = -1,\n};\nstruct booth_site *const no_leader = (struct booth_site*) &_no_leader;\n\ntypedef enum\n{\n\tBOOTHD_STARTED=0,\n\tBOOTHD_STARTING\n} BOOTH_DAEMON_STATE;\n\nint poll_timeout;\n\n\n\nstruct booth_config *booth_conf;\nstruct command_line cl;\n\n/*\n * Global signal handlers variables\n */\nstatic int sig_exit_handler_called = 0;\nstatic int sig_exit_handler_sig = 0;\nstatic int sig_usr1_handler_called = 0;\nstatic int sig_chld_handler_called = 0;\n\nstatic void client_alloc(void)\n{\n\tint i;\n\n\tif (!(clients = realloc(\n\t\tclients, (client_size + CLIENT_NALLOC) * sizeof(*clients))\n\t) || !(pollfds = realloc(\n\t\tpollfds, (client_size + CLIENT_NALLOC) * sizeof(*pollfds))\n\t)) {\n\t\tlog_error(\"can't alloc for client array\");\n\t\texit(1);\n\t}\n\n\tfor (i = client_size; i < client_size + CLIENT_NALLOC; i++) {\n\t\tclients[i].workfn = NULL;\n\t\tclients[i].deadfn = NULL;\n\t\tclients[i].fd = -1;\n\t\tpollfds[i].fd = -1;\n\t\tpollfds[i].revents = 0;\n\t}\n\tclient_size += CLIENT_NALLOC;\n}\n\nstatic void client_dead(int ci)\n{\n\tstruct client *c = clients + ci;\n\n\tif (c->fd != -1) {\n\t\tlog_debug(\"removing client %d\", c->fd);\n\t\tclose(c->fd);\n\t}\n\n\tc->fd = -1;\n\tc->workfn = NULL;\n\n\tif (c->msg) {\n\t\tfree(c->msg);\n\t\tc->msg = NULL;\n\t\tc->offset = 0;\n\t}\n\n\tpollfds[ci].fd = -1;\n}\n\nint client_add(int fd, const struct booth_transport *tpt,\n\t\tvoid (*workfn)(int ci),\n\t\tvoid (*deadfn)(int ci))\n{\n\tint i;\n\tstruct client *c;\n\n\n\tif (client_size - 1 <= client_maxi ) {\n\t\tclient_alloc();\n\t}\n\n\tfor (i = 0; i < client_size; i++) {\n\t\tc = clients + i;\n\t\tif (c->fd != -1)\n\t\t\tcontinue;\n\n\t\tc->workfn = workfn;\n\t\tif (deadfn)\n\t\t\tc->deadfn = deadfn;\n\t\telse\n\t\t\tc->deadfn = client_dead;\n\n\t\tc->transport = tpt;\n\t\tc->fd = fd;\n\t\tc->msg = NULL;\n\t\tc->offset = 0;\n\n\t\tpollfds[i].fd = fd;\n\t\tpollfds[i].events = POLLIN;\n\t\tif (i > client_maxi)\n\t\t\tclient_maxi = i;\n\n\t\treturn i;\n\t}\n\n\tassert(!\"no client\");\n}\n\nint find_client_by_fd(int fd)\n{\n\tint i;\n\n\tif (fd < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i <= client_maxi; i++) {\n\t\tif (clients[i].fd == fd)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nstatic int format_peers(char **pdata, unsigned int *len)\n{\n\tstruct booth_site *s;\n\tchar *data, *cp;\n\tchar time_str[64];\n\tint i, alloc;\n\n\t*pdata = NULL;\n\t*len = 0;\n\n\talloc = booth_conf->site_count * (BOOTH_NAME_LEN + 256);\n\tdata = malloc(alloc);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tcp = data;\n\tforeach_node(i, s) {\n\t\tif (s == local)\n\t\t\tcontinue;\n\t\tstrftime(time_str, sizeof(time_str), \"%F %T\",\n\t\t\tlocaltime(&s->last_recv));\n\t\tcp += snprintf(cp,\n\t\t\t\talloc - (cp - data),\n\t\t\t\t\"%-12s %s, last recv: %s\\n\",\n\t\t\t\ttype_to_string(s->type),\n\t\t\t\ts->addr_string,\n\t\t\t\ttime_str);\n\t\tcp += snprintf(cp,\n\t\t\t\talloc - (cp - data),\n\t\t\t\t\"\\tSent pkts:%u error:%u resends:%u\\n\",\n\t\t\t\ts->sent_cnt,\n\t\t\t\ts->sent_err_cnt,\n\t\t\t\ts->resend_cnt);\n\t\tcp += snprintf(cp,\n\t\t\t\talloc - (cp - data),\n\t\t\t\t\"\\tRecv pkts:%u error:%u authfail:%u invalid:%u\\n\\n\",\n\t\t\t\ts->recv_cnt,\n\t\t\t\ts->recv_err_cnt,\n\t\t\t\ts->sec_cnt,\n\t\t\t\ts->invalid_cnt);\n\t\tif (alloc - (cp - data) <= 0) {\n\t\t\tfree(data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t*pdata = data;\n\t*len = cp - data;\n\n\treturn 0;\n}\n\n\nvoid list_peers(int fd)\n{\n\tchar *data;\n\tunsigned int olen;\n\tstruct boothc_hdr_msg hdr;\n\n\tif (format_peers(&data, &olen) < 0)\n\t\tgoto out;\n\n\tinit_header(&hdr.header, CL_LIST, 0, 0, RLT_SUCCESS, 0, sizeof(hdr) + olen);\n\t(void)send_header_plus(fd, &hdr, data, olen);\n\nout:\n\tif (data)\n\t\tfree(data);\n}\n\n/* trim trailing spaces if the key is ascii\n */\nstatic void trim_key()\n{\n\tchar *p;\n\tint i;\n\n\tfor (i=0, p=booth_conf->authkey; i < booth_conf->authkey_len; i++, p++)\n\t\tif (!isascii(*p))\n\t\t\treturn;\n\n\tp = booth_conf->authkey;\n\twhile (booth_conf->authkey_len > 0 && isspace(*p)) {\n\t\tp++;\n\t\tbooth_conf->authkey_len--;\n\t}\n\tmemmove(booth_conf->authkey, p, booth_conf->authkey_len);\n\n\tp = booth_conf->authkey + booth_conf->authkey_len - 1;\n\twhile (booth_conf->authkey_len > 0 && isspace(*p)) {\n\t\tbooth_conf->authkey_len--;\n\t\tp--;\n\t}\n}\n\nstatic int read_authkey()\n{\n\tint fd;\n\n\tbooth_conf->authkey[0] = '\\0';\n\tfd = open(booth_conf->authfile, O_RDONLY);\n\tif (fd < 0) {\n\t\tlog_error(\"cannot open %s: %s\",\n\t\t\tbooth_conf->authfile, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (fstat(fd, &booth_conf->authstat) < 0) {\n\t\tlog_error(\"cannot stat authentication file %s (%d): %s\",\n\t\t\tbooth_conf->authfile, fd, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (booth_conf->authstat.st_mode & (S_IRGRP | S_IROTH)) {\n\t\tlog_error(\"%s: file shall not be readable for anyone but the owner\",\n\t\t\tbooth_conf->authfile);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tbooth_conf->authkey_len = read(fd, booth_conf->authkey, BOOTH_MAX_KEY_LEN);\n\tclose(fd);\n\ttrim_key();\n\tlog_debug(\"read key of size %d in authfile %s\",\n\t\tbooth_conf->authkey_len, booth_conf->authfile);\n\t/* make sure that the key is of minimum length */\n\treturn (booth_conf->authkey_len >= BOOTH_MIN_KEY_LEN) ? 0 : -1;\n}\n\nint update_authkey()\n{\n\tstruct stat statbuf;\n\n\tif (stat(booth_conf->authfile, &statbuf) < 0) {\n\t\tlog_error(\"cannot stat authentication file %s: %s\",\n\t\t\tbooth_conf->authfile, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (statbuf.st_mtime > booth_conf->authstat.st_mtime) {\n\t\treturn read_authkey();\n\t}\n\treturn 0;\n}\n\nstatic int setup_config(int type)\n{\n\tint rv;\n\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (booth_conf->authfile[0] != '\\0') {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\n\t/* Set \"local\" pointer, ignoring errors. */\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\n\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\n\t/* Per default the PID file name is derived from the\n\t * configuration name. */\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\n\nout:\n\treturn rv;\n}\n\nstatic int setup_transport(void)\n{\n\tint rv;\n\n\trv = transport()->init(message_recv);\n\tif (rv < 0) {\n\t\tlog_error(\"failed to init booth_transport %s\", transport()->name);\n\t\tgoto out;\n\t}\n\n\trv = booth_transport[TCP].init(NULL);\n\tif (rv < 0) {\n\t\tlog_error(\"failed to init booth_transport[TCP]\");\n\t\tgoto out;\n\t}\n\nout:\n\treturn rv;\n}\n\n\nstatic int write_daemon_state(int fd, int state)\n{\n\tchar buffer[1024];\n\tint rv, size;\n\n\tsize = sizeof(buffer) - 1;\n\trv = snprintf(buffer, size,\n\t\t\t\"booth_pid=%d \"\n\t\t\t\"booth_state=%s \"\n\t\t\t\"booth_type=%s \"\n\t\t\t\"booth_cfg_name='%s' \"\n\t\t\t\"booth_id=%d \"\n\t\t\t\"booth_addr_string='%s' \"\n\t\t\t\"booth_port=%d\\n\",\n\t\tgetpid(), \n\t\t( state == BOOTHD_STARTED  ? \"started\"  : \n\t\t  state == BOOTHD_STARTING ? \"starting\" : \n\t\t  \"invalid\"), \n\t\ttype_to_string(local->type),\n\t\tbooth_conf->name,\n\t\tlocal->site_id,\n\t\tlocal->addr_string,\n\t\tbooth_conf->port);\n\n\tif (rv < 0 || rv == size) {\n\t\tlog_error(\"Buffer filled up in write_daemon_state().\");\n\t\treturn -1;\n\t}\n\tsize = rv;\n\n\n\trv = ftruncate(fd, 0);\n\tif (rv < 0) {\n\t\tlog_error(\"lockfile %s truncate error %d: %s\",\n\t\t\t\tcl.lockfile, errno, strerror(errno));\n\t\treturn rv;\n\t}\n\n\n\trv = lseek(fd, 0, SEEK_SET);\n\tif (rv < 0) {\n\t\tlog_error(\"lseek set fd(%d) offset to 0 error, return(%d), message(%s)\",\n\t\t\tfd, rv, strerror(errno));\n\t\trv = -1;\n\t\treturn rv;\n\t} \n\n\n\trv = write(fd, buffer, size);\n\n\tif (rv != size) {\n\t\tlog_error(\"write to fd(%d, %d) returned %d, errno %d, message(%s)\",\n                      fd, size,\n\t\t      rv, errno, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int process_signals(void)\n{\n\tif (sig_exit_handler_called) {\n\t\tlog_info(\"caught signal %d\", sig_exit_handler_sig);\n\t\treturn 1;\n\t}\n\tif (sig_usr1_handler_called) {\n\t\tsig_usr1_handler_called = 0;\n\t\ttickets_log_info();\n\t}\n\tif (sig_chld_handler_called) {\n\t\tsig_chld_handler_called = 0;\n\t\twait_child(SIGCHLD);\n\t}\n\n\treturn 0;\n}\n\nstatic int loop(int fd)\n{\n\tvoid (*workfn) (int ci);\n\tvoid (*deadfn) (int ci);\n\tint rv, i;\n\n\trv = setup_transport();\n\tif (rv < 0)\n\t\tgoto fail;\n\n\trv = setup_ticket();\n\tif (rv < 0)\n\t\tgoto fail;\n\n\trv = write_daemon_state(fd, BOOTHD_STARTED);\n\tif (rv != 0) {\n\t\tlog_error(\"write daemon state %d to lockfile error %s: %s\",\n                      BOOTHD_STARTED, cl.lockfile, strerror(errno));\n\t\tgoto fail;\n\t}\n\n\tlog_info(\"BOOTH %s daemon started, node id is 0x%08X (%d).\",\n\t\ttype_to_string(local->type),\n\t\t\tlocal->site_id, local->site_id);\n\n\twhile (1) {\n\t\trv = poll(pollfds, client_maxi + 1, poll_timeout);\n\t\tif (rv == -1 && errno == EINTR)\n\t\t\tcontinue;\n\t\tif (rv < 0) {\n\t\t\tlog_error(\"poll failed: %s (%d)\", strerror(errno), errno);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfor (i = 0; i <= client_maxi; i++) {\n\t\t\tif (clients[i].fd < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (pollfds[i].revents & POLLIN) {\n\t\t\t\tworkfn = clients[i].workfn;\n\t\t\t\tif (workfn)\n\t\t\t\t\tworkfn(i);\n\t\t\t}\n\t\t\tif (pollfds[i].revents &\n\t\t\t\t\t(POLLERR | POLLHUP | POLLNVAL)) {\n\t\t\t\tdeadfn = clients[i].deadfn;\n\t\t\t\tif (deadfn)\n\t\t\t\t\tdeadfn(i);\n\t\t\t}\n\t\t}\n\n\t\tprocess_tickets();\n\n\t\tif (process_signals() != 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail:\n\treturn -1;\n}\n\n\nstatic int test_reply(cmd_result_t reply_code, cmd_request_t cmd)\n{\n\tint rv = 0;\n\tconst char *op_str = \"\";\n\n\tif (cmd == CMD_GRANT)\n\t\top_str = \"grant\";\n\telse if (cmd == CMD_REVOKE)\n\t\top_str = \"revoke\";\n\telse if (cmd == CMD_LIST)\n\t\top_str = \"list\";\n\telse if (cmd == CMD_PEERS)\n\t\top_str = \"peers\";\n\telse {\n\t\tlog_error(\"internal error reading reply result!\");\n\t\treturn -1;\n\t}\n\n\tswitch (reply_code) {\n\tcase RLT_OVERGRANT:\n\t\tlog_info(\"You're granting a granted ticket. \"\n\t\t\t \"If you wanted to migrate a ticket, \"\n\t\t\t \"use revoke first, then use grant.\");\n\t\trv = -1;\n\t\tbreak;\n\n\tcase RLT_TICKET_IDLE:\n\t\tlog_info(\"ticket is not owned\");\n\t\trv = 0;\n\t\tbreak;\n\n\tcase RLT_ASYNC:\n\t\tlog_info(\"%s command sent, result will be returned \"\n\t\t\t \"asynchronously. Please use \\\"booth list\\\" to \"\n\t\t\t \"see the outcome.\", op_str);\n\t\trv = 0;\n\t\tbreak;\n\n\tcase RLT_CIB_PENDING:\n\t\tlog_info(\"%s succeeded (CIB commit pending)\", op_str);\n\t\t/* wait for the CIB commit? */\n\t\trv = (cl.options & OPT_WAIT_COMMIT) ? 3 : 0;\n\t\tbreak;\n\n\tcase RLT_MORE:\n\t\trv = 2;\n\t\tbreak;\n\n\tcase RLT_SYNC_SUCC:\n\tcase RLT_SUCCESS:\n\t\tif (cmd != CMD_LIST && cmd != CMD_PEERS)\n\t\t\tlog_info(\"%s succeeded!\", op_str);\n\t\trv = 0;\n\t\tbreak;\n\n\tcase RLT_SYNC_FAIL:\n\t\tlog_info(\"%s failed!\", op_str);\n\t\trv = -1;\n\t\tbreak;\n\n\tcase RLT_INVALID_ARG:\n\t\tlog_error(\"ticket \\\"%s\\\" does not exist\",\n\t\t\t\tcl.msg.ticket.id);\n\t\trv = -1;\n\t\tbreak;\n\n\tcase RLT_AUTH:\n\t\tlog_error(\"authentication error\");\n\t\trv = -1;\n\t\tbreak;\n\n\tcase RLT_EXT_FAILED:\n\t\tlog_error(\"before-acquire-handler for ticket \\\"%s\\\" failed, grant denied\",\n\t\t\t\tcl.msg.ticket.id);\n\t\trv = -1;\n\t\tbreak;\n\n\tcase RLT_ATTR_PREREQ:\n\t\tlog_error(\"attr-prereq for ticket \\\"%s\\\" failed, grant denied\",\n\t\t\t\tcl.msg.ticket.id);\n\t\trv = -1;\n\t\tbreak;\n\n\tcase RLT_REDIRECT:\n\t\t/* talk to another site */\n\t\trv = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(\"got an error code: %x\", rv);\n\t\trv = -1;\n\t}\n\treturn rv;\n}\n\nstatic int query_get_string_answer(cmd_request_t cmd)\n{\n\tstruct booth_site *site;\n\tstruct boothc_hdr_msg reply;\n\tstruct boothc_header *header;\n\tchar *data;\n\tint data_len;\n\tint rv;\n\tstruct booth_transport const *tpt;\n\tint (*test_reply_f) (cmd_result_t reply_code, cmd_request_t cmd);\n\tsize_t msg_size;\n\tvoid *request;\n\n\tif (cl.type == GEOSTORE) {\n\t\ttest_reply_f = test_attr_reply;\n\t\tmsg_size = sizeof(cl.attr_msg);\n\t\trequest = &cl.attr_msg;\n\t} else {\n\t\ttest_reply_f = test_reply;\n\t\tmsg_size = sizeof(cl.msg);\n\t\trequest = &cl.msg;\n\t}\n\theader = (struct boothc_header *)request;\n\tdata = NULL;\n\n\tinit_header(header, cmd, 0, cl.options, 0, 0, msg_size);\n\n\tif (!*cl.site)\n\t\tsite = local;\n\telse if (!find_site_by_name(cl.site, &site, 1)) {\n\t\tlog_error(\"cannot find site \\\"%s\\\"\", cl.site);\n\t\trv = ENOENT;\n\t\tgoto out;\n\t}\n\n\ttpt = booth_transport + TCP;\n\trv = tpt->open(site);\n\tif (rv < 0)\n\t\tgoto out_close;\n\n\trv = tpt->send(site, request, msg_size);\n\tif (rv < 0)\n\t\tgoto out_close;\n\n\trv = tpt->recv_auth(site, &reply, sizeof(reply));\n\tif (rv < 0)\n\t\tgoto out_close;\n\n\tdata_len = ntohl(reply.header.length) - rv;\n\n\t/* no attribute, or no ticket found */\n\tif (!data_len) {\n\t\tgoto out_test_reply;\n\t}\n\n\tdata = malloc(data_len+1);\n\tif (!data) {\n\t\trv = -ENOMEM;\n\t\tgoto out_close;\n\t}\n\trv = tpt->recv(site, data, data_len);\n\tif (rv < 0)\n\t\tgoto out_close;\n\t*(data+data_len) = '\\0';\n\n\t*(data + data_len) = '\\0';\n\t(void)fputs(data, stdout);\n\tfflush(stdout);\n\trv = 0;\n\nout_test_reply:\n\trv = test_reply_f(ntohl(reply.header.result), cmd);\nout_close:\n\ttpt->close(site);\nout:\n\tif (data)\n\t\tfree(data);\n\treturn rv;\n}\n\n\nstatic int do_command(cmd_request_t cmd)\n{\n\tstruct booth_site *site;\n\tstruct boothc_ticket_msg reply;\n\tstruct booth_transport const *tpt;\n\tuint32_t leader_id;\n\tint rv;\n\tint reply_cnt = 0, msg_logged = 0;\n\tconst char *op_str = \"\";\n\n\tif (cmd == CMD_GRANT)\n\t\top_str = \"grant\";\n\telse if (cmd == CMD_REVOKE)\n\t\top_str = \"revoke\";\n\n\trv = 0;\n\tsite = NULL;\n\n\t/* Always use TCP for client - at least for now. */\n\ttpt = booth_transport + TCP;\n\n\tif (!*cl.site)\n\t\tsite = local;\n\telse {\n\t\tif (!find_site_by_name(cl.site, &site, 1)) {\n\t\t\tlog_error(\"Site \\\"%s\\\" not configured.\", cl.site);\n\t\t\tgoto out_close;\n\t\t}\n\t}\n\n\tif (site->type == ARBITRATOR) {\n\t\tif (site == local) {\n\t\t\tlog_error(\"We're just an arbitrator, cannot grant/revoke tickets here.\");\n\t\t} else {\n\t\t\tlog_error(\"%s is just an arbitrator, cannot grant/revoke tickets there.\", cl.site);\n\t\t}\n\t\tgoto out_close;\n\t}\n\n\tassert(site->type == SITE);\n\n\t/* We don't check for existence of ticket, so that asking can be\n\t * done without local configuration, too.\n\t * Although, that means that the UDP port has to be specified, too. */\n\tif (!cl.msg.ticket.id[0]) {\n\t\t/* If the loaded configuration has only a single ticket defined, use that. */\n\t\tif (booth_conf->ticket_count == 1) {\n\t\t\tstrncpy(cl.msg.ticket.id, booth_conf->ticket[0].name,\n\t\t\t\tsizeof(cl.msg.ticket.id));\n\t\t} else {\n\t\t\tlog_error(\"No ticket given.\");\n\t\t\tgoto out_close;\n\t\t}\n\t}\n\nredirect:\n\tinit_header(&cl.msg.header, cmd, 0, cl.options, 0, 0, sizeof(cl.msg));\n\n\trv = tpt->open(site);\n\tif (rv < 0)\n\t\tgoto out_close;\n\n\trv = tpt->send(site, &cl.msg, sendmsglen(&cl.msg));\n\tif (rv < 0)\n\t\tgoto out_close;\n\nread_more:\n\trv = tpt->recv_auth(site, &reply, sizeof(reply));\n\tif (rv < 0) {\n\t\t/* print any errors depending on the code sent by the\n\t\t * server */\n\t\t(void)test_reply(ntohl(reply.header.result), cmd);\n\t\tgoto out_close;\n\t}\n\n\trv = test_reply(ntohl(reply.header.result), cmd);\n\tif (rv == 1) {\n\t\ttpt->close(site);\n\t\tleader_id = ntohl(reply.ticket.leader);\n\t\tif (!find_site_by_id(leader_id, &site)) {\n\t\t\tlog_error(\"Message with unknown redirect site %x received\", leader_id);\n\t\t\trv = -1;\n\t\t\tgoto out_close;\n\t\t}\n\t\tgoto redirect;\n\t} else if (rv == 2 || rv == 3) {\n\t\t/* the server has more to say */\n\t\t/* don't wait too long */\n\t\tif (reply_cnt > 1 && !(cl.options & OPT_WAIT)) {\n\t\t\trv = 0;\n\t\t\tlog_info(\"Giving up on waiting for the definite result. \"\n\t\t\t\t \"Please use \\\"booth list\\\" later to \"\n\t\t\t\t \"see the outcome.\");\n\t\t\tgoto out_close;\n\t\t}\n\t\tif (reply_cnt == 0) {\n\t\t\tlog_info(\"%s request sent, \"\n\t\t\t\t\"waiting for the result ...\", op_str);\n\t\t\tmsg_logged++;\n\t\t} else if (rv == 3 && msg_logged < 2) {\n\t\t\tlog_info(\"waiting for the CIB commit ...\");\n\t\t\tmsg_logged++;\n\t\t}\n\t\treply_cnt++;\n\t\tgoto read_more;\n\t}\n\nout_close:\n\tif (site)\n\t\ttpt->close(site);\n\treturn rv;\n}\n\n\n\nstatic int _lockfile(int mode, int *fdp, pid_t *locked_by)\n{\n\tstruct flock lock;\n\tint fd, rv;\n\n\n\t/* After reboot the directory may not yet exist.\n\t * Try to create it, but ignore errors. */\n\tif (strncmp(cl.lockfile, BOOTH_RUN_DIR,\n\t\t\t\tstrlen(BOOTH_RUN_DIR)) == 0)\n\t\t(void)mkdir(BOOTH_RUN_DIR, 0775);\n\n\n\tif (locked_by)\n\t\t*locked_by = 0;\n\n\t*fdp = -1;\n\tfd = open(cl.lockfile, mode, 0664);\n\tif (fd < 0)\n\t\treturn errno;\n\n\t*fdp = fd;\n\n\tlock.l_type = F_WRLCK;\n\tlock.l_start = 0;\n\tlock.l_whence = SEEK_SET;\n\tlock.l_len = 0;\n\tlock.l_pid = 0;\n\n\n\tif (fcntl(fd, F_SETLK, &lock) == 0)\n\t\treturn 0;\n\n\trv = errno;\n\n\tif (locked_by)\n\t\tif (fcntl(fd, F_GETLK, &lock) == 0)\n\t\t\t*locked_by = lock.l_pid;\n\n\treturn rv;\n}\n\n\nstatic inline int is_root(void)\n{\n\treturn geteuid() == 0;\n}\n\n\nstatic int create_lockfile(void)\n{\n\tint rv, fd;\n\n\tfd = -1;\n\trv = _lockfile(O_CREAT | O_WRONLY, &fd, NULL);\n\n\tif (fd == -1) {\n\t\tlog_error(\"lockfile %s open error %d: %s\",\n\t\t\t\tcl.lockfile, rv, strerror(rv));\n\t\treturn -1;\n\t}\n\n\tif (rv < 0) {\n\t\tlog_error(\"lockfile %s setlk error %d: %s\",\n\t\t\t\tcl.lockfile, rv, strerror(rv));\n\t\tgoto fail;\n\t}\n\n\trv = write_daemon_state(fd, BOOTHD_STARTING);\n\tif (rv != 0) {\n\t\tlog_error(\"write daemon state %d to lockfile error %s: %s\",\n\t\t\t\tBOOTHD_STARTING, cl.lockfile, strerror(errno));\n\t\tgoto fail;\n\t}\n\n\tif (is_root()) {\n\t\tif (fchown(fd, booth_conf->uid, booth_conf->gid) < 0)\n\t\t\tlog_error(\"fchown() on lockfile said %d: %s\",\n\t\t\t\t\terrno, strerror(errno));\n\t}\n\n\treturn fd;\n\nfail:\n\tclose(fd);\n\treturn -1;\n}\n\nstatic void unlink_lockfile(int fd)\n{\n\tunlink(cl.lockfile);\n\tclose(fd);\n}\n\nstatic void print_usage(void)\n{\n\tprintf(\n\t\"Usage:\\n\"\n\t\"  booth list [options]\\n\"\n\t\"  booth {grant|revoke} [options] <ticket>\\n\"\n\t\"  booth status [options]\\n\"\n\t\"\\n\"\n\t\"  list:\t     List all tickets\\n\"\n\t\"  grant:        Grant ticket to site\\n\"\n\t\"  revoke:       Revoke ticket\\n\"\n\t\"\\n\"\n\t\"Options:\\n\"\n\t\"  -c FILE       Specify config file [default \" BOOTH_DEFAULT_CONF \"]\\n\"\n\t\"                Can be a path or just a name without \\\".conf\\\" suffix\\n\"\n\t\"  -s <site>     Connect/grant to a different site\\n\"\n\t\"  -F            Try to grant the ticket immediately\\n\"\n\t\"                even if not all sites are reachable\\n\"\n\t\"                For manual tickets:\\n\"\n\t\"                grant a manual ticket even if it has been already granted\\n\"\n\t\"  -w            Wait forever for the outcome of the request\\n\"\n\t\"  -C            Wait until the ticket is committed to the CIB (grant only)\\n\"\n\t\"  -h            Print this help\\n\"\n\t\"\\n\"\n\t\"Examples:\\n\"\n\t\"\\n\"\n\t\"  # booth list (list tickets)\\n\"\n\t\"  # booth grant ticket-A (grant ticket here)\\n\"\n\t\"  # booth grant -s 10.121.8.183 ticket-A (grant ticket to site 10.121.8.183)\\n\"\n\t\"  # booth revoke ticket-A (revoke ticket)\\n\"\n\t\"\\n\"\n\t\"See the booth(8) man page for more details.\\n\"\n\t);\n}\n\n#define OPTION_STRING\t\t\"c:Dl:t:s:FhSwC\"\n#define ATTR_OPTION_STRING\t\t\"c:Dt:s:h\"\n\nvoid safe_copy(char *dest, char *value, size_t buflen, const char *description) {\n\tint content_len = buflen - 1;\n\n\tif (strlen(value) >= content_len) {\n\t\tfprintf(stderr, \"'%s' exceeds maximum %s length of %d\\n\",\n\t\t\tvalue, description, content_len);\n\t\texit(EXIT_FAILURE);\n\t}\n\tstrncpy(dest, value, content_len);\n\tdest[content_len] = 0;\n}\n\nstatic int host_convert(char *hostname, char *ip_str, size_t ip_size)\n{\n\tstruct addrinfo *result = NULL, hints = {0};\n\tint re = -1;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = AF_INET;\n\thints.ai_socktype = SOCK_DGRAM;\n\n\tre = getaddrinfo(hostname, NULL, &hints, &result);\n\n\tif (re == 0) {\n\t\tstruct in_addr addr = ((struct sockaddr_in *)result->ai_addr)->sin_addr;\n\t\tconst char *re_ntop = inet_ntop(AF_INET, &addr, ip_str, ip_size);\n\t\tif (re_ntop == NULL) {\n\t\t\tre = -1;\n\t\t}\n\t}\n\n\tfreeaddrinfo(result);\n\treturn re;\n}\n\n#define cparg(dest, descr) do { \\\n\tif (optind >= argc) \\\n\t\tgoto missingarg; \\\n\tsafe_copy(dest, argv[optind], sizeof(dest), descr); \\\n\toptind++; \\\n} while(0)\n\nstatic int read_arguments(int argc, char **argv)\n{\n\tint optchar;\n\tchar *arg1 = argv[1];\n\tchar *op = NULL;\n\tchar *cp;\n\tconst char *opt_string = OPTION_STRING;\n\tchar site_arg[INET_ADDRSTRLEN] = {0};\n\tint left;\n\n\tcl.type = 0;\n\tif ((cp = strstr(argv[0], ATTR_PROG)) &&\n\t\t\t!strcmp(cp, ATTR_PROG)) {\n\t\tcl.type = GEOSTORE;\n\t\top = argv[1];\n\t\toptind = 2;\n\t\topt_string = ATTR_OPTION_STRING;\n\t} else if (argc > 1 && (strcmp(arg1, \"arbitrator\") == 0 ||\n\t\t\tstrcmp(arg1, \"site\") == 0 ||\n\t\t\tstrcmp(arg1, \"start\") == 0 ||\n\t\t\tstrcmp(arg1, \"daemon\") == 0)) {\n\t\tcl.type = DAEMON;\n\t\toptind = 2;\n\t} else if (argc > 1 && (strcmp(arg1, \"status\") == 0)) {\n\t\tcl.type = STATUS;\n\t\toptind = 2;\n\t} else if (argc > 1 && (strcmp(arg1, \"client\") == 0)) {\n\t\tcl.type = CLIENT;\n\t\tif (argc < 3) {\n\t\t\tprint_usage();\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\top = argv[2];\n\t\toptind = 3;\n\t}\n\tif (!cl.type) {\n\t\tcl.type = CLIENT;\n\t\top = argv[1];\n\t\toptind = 2;\n    }\n\n\tif (argc < 2 || !strcmp(arg1, \"help\") || !strcmp(arg1, \"--help\") ||\n\t\t\t!strcmp(arg1, \"-h\")) {\n\t\tif (cl.type == GEOSTORE)\n\t\t\tprint_geostore_usage();\n\t\telse\n\t\t\tprint_usage();\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tif (!strcmp(arg1, \"version\") || !strcmp(arg1, \"--version\") ||\n\t\t\t!strcmp(arg1, \"-V\")) {\n\t\tprintf(\"%s %s\\n\", argv[0], RELEASE_STR);\n\t\texit(EXIT_SUCCESS);\n\t}\n\n    if (cl.type == CLIENT) {\n\t\tif (!strcmp(op, \"list\"))\n\t\t\tcl.op = CMD_LIST;\n\t\telse if (!strcmp(op, \"grant\"))\n\t\t\tcl.op = CMD_GRANT;\n\t\telse if (!strcmp(op, \"revoke\"))\n\t\t\tcl.op = CMD_REVOKE;\n\t\telse if (!strcmp(op, \"peers\"))\n\t\t\tcl.op = CMD_PEERS;\n\t\telse {\n\t\t\tfprintf(stderr, \"client operation \\\"%s\\\" is unknown\\n\",\n\t\t\t\t\top);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} else if (cl.type == GEOSTORE) {\n\t\tif (!strcmp(op, \"list\"))\n\t\t\tcl.op = ATTR_LIST;\n\t\telse if (!strcmp(op, \"set\"))\n\t\t\tcl.op = ATTR_SET;\n\t\telse if (!strcmp(op, \"get\"))\n\t\t\tcl.op = ATTR_GET;\n\t\telse if (!strcmp(op, \"delete\"))\n\t\t\tcl.op = ATTR_DEL;\n\t\telse {\n\t\t\tfprintf(stderr, \"attribute operation \\\"%s\\\" is unknown\\n\",\n\t\t\t\t\top);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\twhile (optind < argc) {\n\t\toptchar = getopt(argc, argv, opt_string);\n\n\t\tswitch (optchar) {\n\t\tcase 'c':\n\t\t\tif (strchr(optarg, '/')) {\n\t\t\t\tsafe_copy(cl.configfile, optarg,\n\t\t\t\t\t\tsizeof(cl.configfile), \"config file\");\n\t\t\t} else {\n\t\t\t\t/* If no \"/\" in there, use with default directory. */\n\t\t\t\tstrcpy(cl.configfile, BOOTH_DEFAULT_CONF_DIR);\n\t\t\t\tcp = cl.configfile + strlen(BOOTH_DEFAULT_CONF_DIR);\n\t\t\t\tassert(cp > cl.configfile);\n\t\t\t\tassert(*(cp-1) == '/');\n\n\t\t\t\t/* Write at the \\0, ie. after the \"/\" */\n\t\t\t\tsafe_copy(cp, optarg,\n\t\t\t\t\t\t(sizeof(cl.configfile) -\n\t\t\t\t\t\t (cp -  cl.configfile) -\n\t\t\t\t\t\t strlen(BOOTH_DEFAULT_CONF_EXT)),\n\t\t\t\t\t\t\"config name\");\n\n\t\t\t\t/* If no extension, append \".conf\".\n\t\t\t\t * Space is available, see -strlen() above. */\n\t\t\t\tif (!strchr(cp, '.'))\n\t\t\t\t\tstrcat(cp, BOOTH_DEFAULT_CONF_EXT);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tdebug_level++;\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\tdaemonize = 0;\n\t\t\tenable_stderr = 1;\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tsafe_copy(cl.lockfile, optarg, sizeof(cl.lockfile), \"lock file\");\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (cl.op == CMD_GRANT || cl.op == CMD_REVOKE) {\n\t\t\t\tsafe_copy(cl.msg.ticket.id, optarg,\n\t\t\t\t\t\tsizeof(cl.msg.ticket.id), \"ticket name\");\n\t\t\t} else if (cl.type == GEOSTORE) {\n\t\t\t\tsafe_copy(cl.attr_msg.attr.tkt_id, optarg,\n\t\t\t\t\t\tsizeof(cl.attr_msg.attr.tkt_id), \"ticket name\");\n\t\t\t} else {\n\t\t\t\tprint_usage();\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\t/* For testing and debugging: allow \"-s site\" also for\n\t\t\t * daemon start, so that the address that should be used\n\t\t\t * can be set manually.\n\t\t\t * This makes it easier to start multiple processes\n\t\t\t * on one machine. */\n\t\t\tif (cl.type == CLIENT || cl.type == GEOSTORE ||\n\t\t\t\t\t(cl.type == DAEMON && debug_level)) {\n\t\t\t\tif (strcmp(optarg, OTHER_SITE) &&\n\t\t\t\t\t\thost_convert(optarg, site_arg, INET_ADDRSTRLEN) == 0) {\n\t\t\t\t\tsafe_copy(cl.site, site_arg, sizeof(cl.site), \"site name\");\n\t\t\t\t} else {\n\t\t\t\t\tsafe_copy(cl.site, optarg, sizeof(cl.site), \"site name\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog_error(\"\\\"-s\\\" not allowed in daemon mode.\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\tif (cl.type != CLIENT || cl.op != CMD_GRANT) {\n\t\t\t\tlog_error(\"use \\\"-F\\\" only for client grant\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tcl.options |= OPT_IMMEDIATE;\n\t\t\tbreak;\n\n\t\tcase 'w':\n\t\t\tif (cl.type != CLIENT ||\n\t\t\t\t\t(cl.op != CMD_GRANT && cl.op != CMD_REVOKE)) {\n\t\t\t\tlog_error(\"use \\\"-w\\\" only for grant and revoke\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tcl.options |= OPT_WAIT;\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tif (cl.type != CLIENT || cl.op != CMD_GRANT) {\n\t\t\t\tlog_error(\"use \\\"-C\\\" only for grant\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tcl.options |= OPT_WAIT | OPT_WAIT_COMMIT;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tif (cl.type == GEOSTORE)\n\t\t\t\tprint_geostore_usage();\n\t\t\telse\n\t\t\t\tprint_usage();\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\n\t\tcase ':':\n\t\tcase '?':\n\t\t\tfprintf(stderr, \"Please use '-h' for usage.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\tbreak;\n\n\t\tcase -1:\n\t\t\t/* No more parameters on cmdline, only arguments. */\n\t\t\tgoto extra_args;\n\n\t\tdefault:\n\t\t\tgoto unknown;\n\t\t};\n\t}\n\n\treturn 0;\n\nextra_args:\n\tif (cl.type == CLIENT && !cl.msg.ticket.id[0]) {\n\t\tcparg(cl.msg.ticket.id, \"ticket name\");\n\t} else if (cl.type == GEOSTORE) {\n\t\tif (cl.op != ATTR_LIST) {\n\t\t\tcparg(cl.attr_msg.attr.name, \"attribute name\");\n\t\t}\n\t\tif (cl.op == ATTR_SET) {\n\t\t\tcparg(cl.attr_msg.attr.val, \"attribute value\");\n\t\t}\n\t}\n\n\tif (optind == argc)\n\t\treturn 0;\n\n\n\tleft = argc - optind;\n\tfprintf(stderr, \"Superfluous argument%s: %s%s\\n\",\n\t\t\tleft == 1 ? \"\" : \"s\",\n\t\t\targv[optind],\n\t\t\tleft == 1 ? \"\" : \"...\");\n\texit(EXIT_FAILURE);\n\nunknown:\n\tfprintf(stderr, \"unknown option: %s\\n\", argv[optind]);\n\texit(EXIT_FAILURE);\n\nmissingarg:\n\tfprintf(stderr, \"not enough arguments\\n\");\n\texit(EXIT_FAILURE);\n}\n\n\nstatic void set_scheduler(void)\n{\n\tstruct sched_param sched_param;\n\tstruct rlimit rlimit;\n\tint rv;\n\n\trlimit.rlim_cur = RLIM_INFINITY;\n\trlimit.rlim_max = RLIM_INFINITY;\n\trv = setrlimit(RLIMIT_MEMLOCK, &rlimit);\n\tif (rv < 0) {\n\t\tlog_error(\"setrlimit failed\");\n\t} else {\n                rv = mlockall(MCL_CURRENT | MCL_FUTURE);\n                if (rv < 0) {\n                        log_error(\"mlockall failed\");\n                }\n        }\n\n\trv = sched_get_priority_max(SCHED_RR);\n\tif (rv != -1) {\n\t\tsched_param.sched_priority = rv;\n\t\trv = sched_setscheduler(0, SCHED_RR, &sched_param);\n\t\tif (rv == -1)\n\t\t\tlog_error(\"could not set SCHED_RR priority %d: %s (%d)\",\n\t\t\t\t\tsched_param.sched_priority,\n\t\t\t\t\tstrerror(errno), errno);\n\t} else {\n\t\tlog_error(\"could not get maximum scheduler priority err %d\",\n\t\t\t\terrno);\n\t}\n}\n\nstatic int set_procfs_val(const char *path, const char *val)\n{\n\tint rc = -1;\n\tFILE *fp = fopen(path, \"w\");\n\n\tif (fp) {\n\t\tif (fprintf(fp, \"%s\", val) > 0)\n\t\t\trc = 0;\n\t\tfclose(fp);\n\t}\n\treturn rc;\n}\n\nstatic int do_status(int type)\n{\n\tpid_t pid;\n\tint rv, status_lock_fd, ret;\n\tconst char *reason = NULL;\n\tchar lockfile_data[1024], *cp;\n\n\n\tret = PCMK_OCF_NOT_RUNNING;\n\n\trv = setup_config(type);\n\tif (rv) {\n\t\treason = \"Error reading configuration.\";\n\t\tret = PCMK_OCF_UNKNOWN_ERROR;\n\t\tgoto quit;\n\t}\n\n\n\tif (!local) {\n\t\treason = \"No Service IP active here.\";\n\t\tgoto quit;\n\t}\n\n\n\trv = _lockfile(O_RDWR, &status_lock_fd, &pid);\n\tif (status_lock_fd == -1) {\n\t\treason = \"No PID file.\";\n\t\tgoto quit;\n\t}\n\tif (rv == 0) {\n\t\tclose(status_lock_fd);\n\t\treason = \"PID file not locked.\";\n\t\tgoto quit;\n\t}\n\tif (pid) {\n\t\tfprintf(stdout, \"booth_lockpid=%d \", pid);\n\t\tfflush(stdout);\n\t}\n\n\trv = read(status_lock_fd, lockfile_data, sizeof(lockfile_data) - 1);\n\tif (rv < 4) {\n\t\tclose(status_lock_fd);\n\t\treason = \"Cannot read lockfile data.\";\n\t\tret = PCMK_LSB_UNKNOWN_ERROR;\n\t\tgoto quit;\n\t}\n\tlockfile_data[rv] = 0;\n\n\tclose(status_lock_fd);\n\n\n\t/* Make sure it's only a single line */\n\tcp = strchr(lockfile_data, '\\r');\n\tif (cp)\n\t\t*cp = 0;\n\tcp = strchr(lockfile_data, '\\n');\n\tif (cp)\n\t\t*cp = 0;\n\n\n\n\trv = setup_tcp_listener(1);\n\tif (rv == 0) {\n\t\treason = \"TCP port not in use.\";\n\t\tgoto quit;\n\t}\n\n\n\tfprintf(stdout, \"booth_lockfile='%s' %s\\n\",\n\t\t\tcl.lockfile, lockfile_data);\n\tif (!daemonize)\n\t\tfprintf(stderr, \"Booth at %s port %d seems to be running.\\n\",\n\t\t\t\tlocal->addr_string, booth_conf->port);\n\treturn 0;\n\n\nquit:\n\tlog_debug(\"not running: %s\", reason);\n\t/* Ie. \"DEBUG\" */\n\tif (!daemonize)\n\t\tfprintf(stderr, \"not running: %s\\n\", reason);\n\treturn ret;\n}\n\n\nstatic int limit_this_process(void)\n{\n\tint rv;\n\tif (!is_root())\n\t\treturn 0;\n\n\tif (setregid(booth_conf->gid, booth_conf->gid) < 0) {\n\t\trv = errno;\n\t\tlog_error(\"setregid() didn't work: %s\", strerror(rv));\n\t\treturn rv;\n\t}\n\n\tif (setreuid(booth_conf->uid, booth_conf->uid) < 0) {\n\t\trv = errno;\n\t\tlog_error(\"setreuid() didn't work: %s\", strerror(rv));\n\t\treturn rv;\n\t}\n\n\treturn 0;\n}\n\nstatic int lock_fd = -1;\n\nstatic void server_exit(void)\n{\n\tint rv;\n\n\tif (lock_fd >= 0) {\n\t\t/* We might not be able to delete it, but at least\n\t\t * make it empty. */\n\t\trv = ftruncate(lock_fd, 0);\n\t\t(void)rv;\n\t\tunlink_lockfile(lock_fd);\n\t}\n\tlog_info(\"exiting\");\n}\n\nstatic void sig_exit_handler(int sig)\n{\n\tsig_exit_handler_sig = sig;\n\tsig_exit_handler_called = 1;\n}\n\nstatic void sig_usr1_handler(int sig)\n{\n\tsig_usr1_handler_called = 1;\n}\n\nstatic void sig_chld_handler(int sig)\n{\n\tsig_chld_handler_called = 1;\n}\n\nstatic int do_server(int type)\n{\n\tint rv = -1;\n\tstatic char log_ent[128] = DAEMON_NAME \"-\";\n\n\trv = setup_config(type);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tif (!local) {\n\t\tlog_error(\"Cannot find myself in the configuration.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (daemonize) {\n\t\tif (daemon(0, 0) < 0) {\n\t\t\tperror(\"daemon error\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\t/*\n\t * Register signal and exit handler\n\t */\n\tsignal(SIGUSR1, (__sighandler_t)sig_usr1_handler);\n\tsignal(SIGTERM, (__sighandler_t)sig_exit_handler);\n\tsignal(SIGINT, (__sighandler_t)sig_exit_handler);\n\t/* we'll handle errors there and then */\n\tsignal(SIGPIPE, SIG_IGN);\n\n\tatexit(server_exit);\n\n\t/* The lockfile must be written to _after_ the call to daemon(), so\n\t * that the lockfile contains the pid of the daemon, not the parent. */\n\tlock_fd = create_lockfile();\n\tif (lock_fd < 0)\n\t\treturn lock_fd;\n\n\tstrcat(log_ent, type_to_string(local->type));\n\tcl_log_set_entity(log_ent);\n\tcl_log_enable_stderr(enable_stderr ? TRUE : FALSE);\n\tcl_log_set_facility(HA_LOG_FACILITY);\n\tcl_inherit_logging_environment(0);\n\n\tlog_info(\"BOOTH %s %s daemon is starting\",\n\t\t\ttype_to_string(local->type), RELEASE_STR);\n\n\n\tset_scheduler();\n\t/* we don't want to be killed by the OOM-killer */\n\tif (set_procfs_val(\"/proc/self/oom_score_adj\", \"-999\"))\n\t\t(void)set_procfs_val(\"/proc/self/oom_adj\", \"-16\");\n\tset_proc_title(\"%s %s %s for [%s]:%d\",\n\t\t\tDAEMON_NAME,\n\t\t\tcl.configfile,\n\t\t\ttype_to_string(local->type),\n\t\t\tlocal->addr_string,\n\t\t\tbooth_conf->port);\n\n\trv = limit_this_process();\n\tif (rv)\n\t\treturn rv;\n\n#ifdef COREDUMP_NURSING\n\tif (cl_enable_coredumps(TRUE) < 0){\n\t\tlog_error(\"enabling core dump failed\");\n\t}\n\tcl_cdtocoredir();\n\tprctl(PR_SET_DUMPABLE, (unsigned long)TRUE, 0UL, 0UL, 0UL);\n#else\n\tif (chdir(BOOTH_CORE_DIR) < 0) {\n\t\tlog_error(\"cannot change working directory to %s\", BOOTH_CORE_DIR);\n\t}\n#endif\n\n\tsignal(SIGCHLD, (__sighandler_t)sig_chld_handler);\n\trv = loop(lock_fd);\n\n\treturn rv;\n}\n\nstatic int do_client(void)\n{\n\tint rv;\n\n\trv = setup_config(CLIENT);\n\tif (rv < 0) {\n\t\tlog_error(\"cannot read config\");\n\t\tgoto out;\n\t}\n\n\tswitch (cl.op) {\n\tcase CMD_LIST:\n\tcase CMD_PEERS:\n\t\trv = query_get_string_answer(cl.op);\n\t\tbreak;\n\n\tcase CMD_GRANT:\n\tcase CMD_REVOKE:\n\t\trv = do_command(cl.op);\n\t\tbreak;\n\t}\n\nout:\n\treturn rv;\n}\n\nstatic int do_attr(void)\n{\n\tint rv = -1;\n\n\trv = setup_config(GEOSTORE);\n\tif (rv < 0) {\n\t\tlog_error(\"cannot read config\");\n\t\tgoto out;\n\t}\n\n\t/* We don't check for existence of ticket, so that asking can be\n\t * done without local configuration, too.\n\t * Although, that means that the UDP port has to be specified, too. */\n\tif (!cl.attr_msg.attr.tkt_id[0]) {\n\t\t/* If the loaded configuration has only a single ticket defined, use that. */\n\t\tif (booth_conf->ticket_count == 1) {\n\t\t\tstrncpy(cl.attr_msg.attr.tkt_id, booth_conf->ticket[0].name,\n\t\t\t\tsizeof(cl.attr_msg.attr.tkt_id));\n\t\t} else {\n\t\t\trv = 1;\n\t\t\tlog_error(\"No ticket given.\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (cl.op) {\n\tcase ATTR_LIST:\n\tcase ATTR_GET:\n\t\trv = query_get_string_answer(cl.op);\n\t\tbreak;\n\n\tcase ATTR_SET:\n\tcase ATTR_DEL:\n\t\trv = do_attr_command(cl.op);\n\t\tbreak;\n\t}\n\nout:\n\treturn rv;\n}\n\nint main(int argc, char *argv[], char *envp[])\n{\n\tint rv;\n\tconst char *cp;\n#ifdef LOGGING_LIBQB\n\tenum qb_log_target_slot i;\n#endif\n\n\tinit_set_proc_title(argc, argv, envp);\n\tget_time(&start_time);\n\n\tmemset(&cl, 0, sizeof(cl));\n\tstrncpy(cl.configfile,\n\t\t\tBOOTH_DEFAULT_CONF, BOOTH_PATH_LEN - 1);\n\tcl.lockfile[0] = 0;\n\tdebug_level = 0;\n\n\n\tcp = ((cp = strstr(argv[0], ATTR_PROG)) && !strcmp(cp, ATTR_PROG)\n\t\t? ATTR_PROG\n\t\t: \"booth\");\n#ifndef LOGGING_LIBQB\n\tcl_log_set_entity(cp);\n#else\n\tqb_log_init(cp, LOG_USER, LOG_DEBUG);  /* prio driven by debug_level */\n\tfor (i = QB_LOG_TARGET_START; i < QB_LOG_TARGET_MAX; i++) {\n\t\tif (i == QB_LOG_SYSLOG || i == QB_LOG_BLACKBOX)\n\t\t\tcontinue;\n\t\tqb_log_format_set(i, \"%t %H %N: [%P]: %p: %b\");\n\t}\n\t(void) qb_log_filter_ctl(QB_LOG_STDERR, QB_LOG_FILTER_ADD,\n\t                         QB_LOG_FILTER_FILE, \"*\", LOG_DEBUG);\n#endif\n\tcl_log_enable_stderr(TRUE);\n\tcl_log_set_facility(0);\n\n\trv = read_arguments(argc, argv);\n\tif (rv < 0)\n\t\tgoto out;\n\n\n\tswitch (cl.type) {\n\tcase STATUS:\n\t\trv = do_status(cl.type);\n\t\tbreak;\n\n\tcase ARBITRATOR:\n\tcase DAEMON:\n\tcase SITE:\n\t\trv = do_server(cl.type);\n\t\tbreak;\n\n\tcase CLIENT:\n\t\trv = do_client();\n\t\tbreak;\n\n\tcase GEOSTORE:\n\t\trv = do_attr();\n\t\tbreak;\n\t}\n\nout:\n#ifdef LOGGING_LIBQB\n\tqb_log_fini();\n#endif\n\t/* Normalize values. 0x100 would be seen as \"OK\" by waitpid(). */\n\treturn (rv >= 0 && rv < 0x70) ? rv : 1;\n}\n"], "filenames": ["src/main.c"], "buggy_code_start_loc": [367], "buggy_code_end_loc": [368], "fixing_code_start_loc": [367], "fixing_code_end_loc": [368], "type": "CWE-287", "message": "The authfile directive in the booth config file is ignored, preventing use of authentication in communications from node to node. As a result, nodes that do not have the correct authentication key are not prevented from communicating with other nodes in the cluster.", "other": {"cve": {"id": "CVE-2022-2553", "sourceIdentifier": "secalert@redhat.com", "published": "2022-07-28T15:15:07.663", "lastModified": "2022-12-02T20:11:13.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The authfile directive in the booth config file is ignored, preventing use of authentication in communications from node to node. As a result, nodes that do not have the correct authentication key are not prevented from communicating with other nodes in the cluster."}, {"lang": "es", "value": "La directiva authfile en el archivo de configuraci\u00f3n de booth es ignorada, impidiendo el uso de la autenticaci\u00f3n en las comunicaciones de nodo a nodo. Como resultando, los nodos que no presentan la clave de autenticaci\u00f3n correcta no son impedidos de comunicarse con otros nodos en el cluster"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:clusterlabs:booth:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0", "matchCriteriaId": "CF42404A-28D1-45D0-BA18-B4BF9056735D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/ClusterLabs/booth/commit/35bf0b7b048d715f671eb68974fb6b4af6528c67", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/J4T4TTXAABVUCMPUL7XQ2PH5EYYOOQZY/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OHDOFX7NQFH3UGZZA3SGW5SVMDDHIUVD/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5194", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ClusterLabs/booth/commit/35bf0b7b048d715f671eb68974fb6b4af6528c67"}}