{"buggy_code": ["<?php\n\nnamespace Statamic\\Http\\Controllers\\CP\\Assets;\n\nuse Illuminate\\Http\\Request;\nuse Statamic\\Contracts\\Assets\\Asset as AssetContract;\nuse Statamic\\Contracts\\Assets\\AssetContainer as AssetContainerContract;\nuse Statamic\\Exceptions\\AuthorizationException;\nuse Statamic\\Facades\\Asset;\nuse Statamic\\Facades\\AssetContainer;\nuse Statamic\\Facades\\User;\nuse Statamic\\Http\\Controllers\\CP\\CpController;\nuse Statamic\\Http\\Resources\\CP\\Assets\\Asset as AssetResource;\n\nclass AssetsController extends CpController\n{\n    use RedirectsToFirstAssetContainer;\n\n    public function index()\n    {\n        $this->redirectToFirstContainer();\n\n        if (User::current()->can('create', AssetContainerContract::class)) {\n            return view('statamic::assets.index');\n        }\n\n        throw new AuthorizationException;\n    }\n\n    public function show($asset)\n    {\n        $asset = Asset::find(base64_decode($asset));\n\n        // TODO: Auth\n\n        return new AssetResource($asset);\n    }\n\n    public function update(Request $request, $asset)\n    {\n        $asset = Asset::find(base64_decode($asset));\n\n        $this->authorize('edit', $asset);\n\n        $fields = $asset->blueprint()->fields()->addValues($request->all());\n\n        $fields->validate();\n\n        $values = $fields->process()->values()->merge([\n            'focus' => $request->focus,\n        ]);\n\n        foreach ($values as $key => $value) {\n            $asset->set($key, $value);\n        }\n\n        $asset->save();\n\n        return [\n            'success' => true,\n            'message' => 'Asset updated',\n            'asset' => (new AssetResource($asset))->resolve()['data'],\n        ];\n    }\n\n    public function store(Request $request)\n    {\n        $request->validate([\n            'container' => 'required',\n            'folder' => 'required',\n            'file' => ['file', function ($attribute, $value, $fail) {\n                if (in_array(trim(strtolower($value->getClientOriginalExtension())), ['php', 'php3', 'php4', 'php5', 'phtml'])) {\n                    $fail(__('validation.uploaded'));\n                }\n            }],\n        ]);\n\n        $container = AssetContainer::find($request->container);\n\n        abort_unless($container->allowUploads(), 403);\n\n        $this->authorize('store', [AssetContract::class, $container]);\n\n        $file = $request->file('file');\n        $path = ltrim($request->folder.'/'.$file->getClientOriginalName(), '/');\n\n        $asset = $container->makeAsset($path)->upload($file);\n\n        return new AssetResource($asset);\n    }\n\n    public function download($asset)\n    {\n        $asset = Asset::find(base64_decode($asset));\n\n        // TODO: Auth\n\n        return $asset->download();\n    }\n\n    public function destroy($asset)\n    {\n        $asset = Asset::find(base64_decode($asset));\n\n        // TODO: Auth\n\n        $asset->delete();\n\n        return response('', 204);\n    }\n}\n", "<?php\n\nnamespace Statamic\\Http\\Controllers\\CP\\Fieldtypes;\n\nuse Illuminate\\Http\\Request;\nuse Statamic\\Assets\\FileUploader as Uploader;\nuse Statamic\\Http\\Controllers\\CP\\CpController;\n\nclass FilesFieldtypeController extends CpController\n{\n    public function upload(Request $request)\n    {\n        $request->validate([\n            'file' => ['file', function ($attribute, $value, $fail) {\n                if (in_array(trim(strtolower($value->getClientOriginalExtension())), ['php', 'php3', 'php4', 'php5', 'phtml'])) {\n                    $fail(__('validation.uploaded'));\n                }\n            }],\n        ]);\n\n        $file = $request->file('file');\n\n        $path = Uploader::container($request->container)->upload($file);\n\n        return ['data' => ['id' => $path]];\n    }\n}\n", "<?php\n\nnamespace Statamic\\Http\\Controllers;\n\nuse Illuminate\\Http\\RedirectResponse;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Http\\Response;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\MessageBag;\nuse Illuminate\\Support\\Traits\\Localizable;\nuse Illuminate\\Validation\\ValidationException;\nuse Statamic\\Contracts\\Forms\\Submission;\nuse Statamic\\Events\\FormSubmitted;\nuse Statamic\\Events\\SubmissionCreated;\nuse Statamic\\Exceptions\\SilentFormFailureException;\nuse Statamic\\Facades\\Form;\nuse Statamic\\Facades\\Site;\nuse Statamic\\Forms\\Exceptions\\FileContentTypeRequiredException;\nuse Statamic\\Forms\\SendEmails;\nuse Statamic\\Support\\Arr;\nuse Statamic\\Support\\Str;\n\nclass FormController extends Controller\n{\n    use Localizable;\n\n    /**\n     * Handle a form submission request.\n     *\n     * @return mixed\n     */\n    public function submit(Request $request, $form)\n    {\n        $site = Site::findByUrl(URL::previous()) ?? Site::default();\n        $fields = $form->blueprint()->fields();\n        $this->validateContentType($request, $form);\n        $values = array_merge($request->all(), $assets = $this->normalizeAssetsValues($fields, $request));\n        $params = collect($request->all())->filter(function ($value, $key) {\n            return Str::startsWith($key, '_');\n        })->all();\n\n        $fields = $fields->addValues($values);\n\n        $submission = $form->makeSubmission();\n\n        try {\n            $this->withLocale($site->lang(), function () use ($fields) {\n                $fields->validate($this->extraRules($fields));\n            });\n\n            throw_if(Arr::get($values, $form->honeypot()), new SilentFormFailureException);\n\n            $values = array_merge($values, $submission->uploadFiles($assets));\n\n            $submission->data(\n                $fields->addValues($values)->process()->values()\n            );\n\n            // If any event listeners return false, we'll do a silent failure.\n            // If they want to add validation errors, they can throw an exception.\n            throw_if(FormSubmitted::dispatch($submission) === false, new SilentFormFailureException);\n        } catch (ValidationException $e) {\n            return $this->formFailure($params, $e->errors(), $form->handle());\n        } catch (SilentFormFailureException $e) {\n            return $this->formSuccess($params, $submission, true);\n        }\n\n        if ($form->store()) {\n            $submission->save();\n        } else {\n            // When the submission is saved, this same created event will be dispatched.\n            // We'll also fire it here if submissions are not configured to be stored\n            // so that developers may continue to listen and modify it as needed.\n            SubmissionCreated::dispatch($submission);\n        }\n\n        SendEmails::dispatch($submission, $site);\n\n        return $this->formSuccess($params, $submission);\n    }\n\n    private function validateContentType($request, $form)\n    {\n        $type = Str::before($request->headers->get('CONTENT_TYPE'), ';');\n\n        if ($type !== 'multipart/form-data' && $form->hasFiles()) {\n            throw new FileContentTypeRequiredException;\n        }\n    }\n\n    /**\n     * The steps for a successful form submission.\n     *\n     * Used for actual success and by honeypot.\n     *\n     * @param  array  $params\n     * @param  Submission  $submission\n     * @param  bool  $silentFailure\n     * @return Response\n     */\n    private function formSuccess($params, $submission, $silentFailure = false)\n    {\n        $redirect = $this->formSuccessRedirect($params, $submission);\n\n        if (request()->ajax() || request()->wantsJson()) {\n            return response([\n                'success' => true,\n                'submission_created' => ! $silentFailure,\n                'submission' => $submission->data(),\n                'redirect' => $redirect,\n            ]);\n        }\n\n        $response = $redirect ? redirect($redirect) : back();\n\n        if (! \\Statamic\\Facades\\URL::isExternal($redirect)) {\n            session()->flash(\"form.{$submission->form()->handle()}.success\", __('Submission successful.'));\n            session()->flash(\"form.{$submission->form()->handle()}.submission_created\", ! $silentFailure);\n            session()->flash('submission', $submission);\n        }\n\n        return $response;\n    }\n\n    private function formSuccessRedirect($params, $submission)\n    {\n        if (! $redirect = Form::getSubmissionRedirect($submission)) {\n            $redirect = Arr::get($params, '_redirect');\n        }\n\n        return $redirect;\n    }\n\n    /**\n     * The steps for a failed form submission.\n     *\n     * @param  array  $params\n     * @param  array  $submission\n     * @param  string  $form\n     * @return Response|RedirectResponse\n     */\n    private function formFailure($params, $errors, $form)\n    {\n        if (request()->ajax()) {\n            return response([\n                'errors' => (new MessageBag($errors))->all(),\n                'error' => collect($errors)->map(function ($errors, $field) {\n                    return $errors[0];\n                })->all(),\n            ], 400);\n        }\n\n        $redirect = Arr::get($params, '_error_redirect');\n\n        $response = $redirect ? redirect($redirect) : back();\n\n        return $response->withInput()->withErrors($errors, 'form.'.$form);\n    }\n\n    protected function normalizeAssetsValues($fields, $request)\n    {\n        // The assets fieldtype is expecting an array, even for `max_files: 1`, but we don't want to force that on the front end.\n        return $fields->all()\n            ->filter(function ($field) {\n                return $field->fieldtype()->handle() === 'assets' && request()->hasFile($field->handle());\n            })\n            ->map(function ($field) use ($request) {\n                return Arr::wrap($request->file($field->handle()));\n            })\n            ->all();\n    }\n\n    protected function extraRules($fields)\n    {\n        $assetFieldRules = $fields->all()\n            ->filter(function ($field) {\n                return $field->fieldtype()->handle() === 'assets';\n            })\n            ->mapWithKeys(function ($field) {\n                return [$field->handle().'.*' => ['file', function ($attribute, $value, $fail) {\n                    if (in_array(trim(strtolower($value->getClientOriginalExtension())), ['php', 'php3', 'php4', 'php5', 'phtml'])) {\n                        $fail(__('validation.uploaded'));\n                    }\n                }]];\n            })\n            ->all();\n\n        return $assetFieldRules;\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Statamic\\Http\\Controllers\\CP\\Assets;\n\nuse Illuminate\\Http\\Request;\nuse Statamic\\Contracts\\Assets\\Asset as AssetContract;\nuse Statamic\\Contracts\\Assets\\AssetContainer as AssetContainerContract;\nuse Statamic\\Exceptions\\AuthorizationException;\nuse Statamic\\Facades\\Asset;\nuse Statamic\\Facades\\AssetContainer;\nuse Statamic\\Facades\\User;\nuse Statamic\\Http\\Controllers\\CP\\CpController;\nuse Statamic\\Http\\Resources\\CP\\Assets\\Asset as AssetResource;\n\nclass AssetsController extends CpController\n{\n    use RedirectsToFirstAssetContainer;\n\n    public function index()\n    {\n        $this->redirectToFirstContainer();\n\n        if (User::current()->can('create', AssetContainerContract::class)) {\n            return view('statamic::assets.index');\n        }\n\n        throw new AuthorizationException;\n    }\n\n    public function show($asset)\n    {\n        $asset = Asset::find(base64_decode($asset));\n\n        // TODO: Auth\n\n        return new AssetResource($asset);\n    }\n\n    public function update(Request $request, $asset)\n    {\n        $asset = Asset::find(base64_decode($asset));\n\n        $this->authorize('edit', $asset);\n\n        $fields = $asset->blueprint()->fields()->addValues($request->all());\n\n        $fields->validate();\n\n        $values = $fields->process()->values()->merge([\n            'focus' => $request->focus,\n        ]);\n\n        foreach ($values as $key => $value) {\n            $asset->set($key, $value);\n        }\n\n        $asset->save();\n\n        return [\n            'success' => true,\n            'message' => 'Asset updated',\n            'asset' => (new AssetResource($asset))->resolve()['data'],\n        ];\n    }\n\n    public function store(Request $request)\n    {\n        $request->validate([\n            'container' => 'required',\n            'folder' => 'required',\n            'file' => ['file', function ($attribute, $value, $fail) {\n                if (in_array(trim(strtolower($value->getClientOriginalExtension())), ['php', 'php3', 'php4', 'php5', 'php7', 'php8', 'phtml', 'phar'])) {\n                    $fail(__('validation.uploaded'));\n                }\n            }],\n        ]);\n\n        $container = AssetContainer::find($request->container);\n\n        abort_unless($container->allowUploads(), 403);\n\n        $this->authorize('store', [AssetContract::class, $container]);\n\n        $file = $request->file('file');\n        $path = ltrim($request->folder.'/'.$file->getClientOriginalName(), '/');\n\n        $asset = $container->makeAsset($path)->upload($file);\n\n        return new AssetResource($asset);\n    }\n\n    public function download($asset)\n    {\n        $asset = Asset::find(base64_decode($asset));\n\n        // TODO: Auth\n\n        return $asset->download();\n    }\n\n    public function destroy($asset)\n    {\n        $asset = Asset::find(base64_decode($asset));\n\n        // TODO: Auth\n\n        $asset->delete();\n\n        return response('', 204);\n    }\n}\n", "<?php\n\nnamespace Statamic\\Http\\Controllers\\CP\\Fieldtypes;\n\nuse Illuminate\\Http\\Request;\nuse Statamic\\Assets\\FileUploader as Uploader;\nuse Statamic\\Http\\Controllers\\CP\\CpController;\n\nclass FilesFieldtypeController extends CpController\n{\n    public function upload(Request $request)\n    {\n        $request->validate([\n            'file' => ['file', function ($attribute, $value, $fail) {\n                if (in_array(trim(strtolower($value->getClientOriginalExtension())), ['php', 'php3', 'php4', 'php5', 'php7', 'php8', 'phtml', 'phar'])) {\n                    $fail(__('validation.uploaded'));\n                }\n            }],\n        ]);\n\n        $file = $request->file('file');\n\n        $path = Uploader::container($request->container)->upload($file);\n\n        return ['data' => ['id' => $path]];\n    }\n}\n", "<?php\n\nnamespace Statamic\\Http\\Controllers;\n\nuse Illuminate\\Http\\RedirectResponse;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Http\\Response;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\MessageBag;\nuse Illuminate\\Support\\Traits\\Localizable;\nuse Illuminate\\Validation\\ValidationException;\nuse Statamic\\Contracts\\Forms\\Submission;\nuse Statamic\\Events\\FormSubmitted;\nuse Statamic\\Events\\SubmissionCreated;\nuse Statamic\\Exceptions\\SilentFormFailureException;\nuse Statamic\\Facades\\Form;\nuse Statamic\\Facades\\Site;\nuse Statamic\\Forms\\Exceptions\\FileContentTypeRequiredException;\nuse Statamic\\Forms\\SendEmails;\nuse Statamic\\Support\\Arr;\nuse Statamic\\Support\\Str;\n\nclass FormController extends Controller\n{\n    use Localizable;\n\n    /**\n     * Handle a form submission request.\n     *\n     * @return mixed\n     */\n    public function submit(Request $request, $form)\n    {\n        $site = Site::findByUrl(URL::previous()) ?? Site::default();\n        $fields = $form->blueprint()->fields();\n        $this->validateContentType($request, $form);\n        $values = array_merge($request->all(), $assets = $this->normalizeAssetsValues($fields, $request));\n        $params = collect($request->all())->filter(function ($value, $key) {\n            return Str::startsWith($key, '_');\n        })->all();\n\n        $fields = $fields->addValues($values);\n\n        $submission = $form->makeSubmission();\n\n        try {\n            $this->withLocale($site->lang(), function () use ($fields) {\n                $fields->validate($this->extraRules($fields));\n            });\n\n            throw_if(Arr::get($values, $form->honeypot()), new SilentFormFailureException);\n\n            $values = array_merge($values, $submission->uploadFiles($assets));\n\n            $submission->data(\n                $fields->addValues($values)->process()->values()\n            );\n\n            // If any event listeners return false, we'll do a silent failure.\n            // If they want to add validation errors, they can throw an exception.\n            throw_if(FormSubmitted::dispatch($submission) === false, new SilentFormFailureException);\n        } catch (ValidationException $e) {\n            return $this->formFailure($params, $e->errors(), $form->handle());\n        } catch (SilentFormFailureException $e) {\n            return $this->formSuccess($params, $submission, true);\n        }\n\n        if ($form->store()) {\n            $submission->save();\n        } else {\n            // When the submission is saved, this same created event will be dispatched.\n            // We'll also fire it here if submissions are not configured to be stored\n            // so that developers may continue to listen and modify it as needed.\n            SubmissionCreated::dispatch($submission);\n        }\n\n        SendEmails::dispatch($submission, $site);\n\n        return $this->formSuccess($params, $submission);\n    }\n\n    private function validateContentType($request, $form)\n    {\n        $type = Str::before($request->headers->get('CONTENT_TYPE'), ';');\n\n        if ($type !== 'multipart/form-data' && $form->hasFiles()) {\n            throw new FileContentTypeRequiredException;\n        }\n    }\n\n    /**\n     * The steps for a successful form submission.\n     *\n     * Used for actual success and by honeypot.\n     *\n     * @param  array  $params\n     * @param  Submission  $submission\n     * @param  bool  $silentFailure\n     * @return Response\n     */\n    private function formSuccess($params, $submission, $silentFailure = false)\n    {\n        $redirect = $this->formSuccessRedirect($params, $submission);\n\n        if (request()->ajax() || request()->wantsJson()) {\n            return response([\n                'success' => true,\n                'submission_created' => ! $silentFailure,\n                'submission' => $submission->data(),\n                'redirect' => $redirect,\n            ]);\n        }\n\n        $response = $redirect ? redirect($redirect) : back();\n\n        if (! \\Statamic\\Facades\\URL::isExternal($redirect)) {\n            session()->flash(\"form.{$submission->form()->handle()}.success\", __('Submission successful.'));\n            session()->flash(\"form.{$submission->form()->handle()}.submission_created\", ! $silentFailure);\n            session()->flash('submission', $submission);\n        }\n\n        return $response;\n    }\n\n    private function formSuccessRedirect($params, $submission)\n    {\n        if (! $redirect = Form::getSubmissionRedirect($submission)) {\n            $redirect = Arr::get($params, '_redirect');\n        }\n\n        return $redirect;\n    }\n\n    /**\n     * The steps for a failed form submission.\n     *\n     * @param  array  $params\n     * @param  array  $submission\n     * @param  string  $form\n     * @return Response|RedirectResponse\n     */\n    private function formFailure($params, $errors, $form)\n    {\n        if (request()->ajax()) {\n            return response([\n                'errors' => (new MessageBag($errors))->all(),\n                'error' => collect($errors)->map(function ($errors, $field) {\n                    return $errors[0];\n                })->all(),\n            ], 400);\n        }\n\n        $redirect = Arr::get($params, '_error_redirect');\n\n        $response = $redirect ? redirect($redirect) : back();\n\n        return $response->withInput()->withErrors($errors, 'form.'.$form);\n    }\n\n    protected function normalizeAssetsValues($fields, $request)\n    {\n        // The assets fieldtype is expecting an array, even for `max_files: 1`, but we don't want to force that on the front end.\n        return $fields->all()\n            ->filter(function ($field) {\n                return $field->fieldtype()->handle() === 'assets' && request()->hasFile($field->handle());\n            })\n            ->map(function ($field) use ($request) {\n                return Arr::wrap($request->file($field->handle()));\n            })\n            ->all();\n    }\n\n    protected function extraRules($fields)\n    {\n        $assetFieldRules = $fields->all()\n            ->filter(function ($field) {\n                return $field->fieldtype()->handle() === 'assets';\n            })\n            ->mapWithKeys(function ($field) {\n                return [$field->handle().'.*' => ['file', function ($attribute, $value, $fail) {\n                    if (in_array(trim(strtolower($value->getClientOriginalExtension())), ['php', 'php3', 'php4', 'php5', 'php7', 'php8', 'phtml', 'phar'])) {\n                        $fail(__('validation.uploaded'));\n                    }\n                }]];\n            })\n            ->all();\n\n        return $assetFieldRules;\n    }\n}\n"], "filenames": ["src/Http/Controllers/CP/Assets/AssetsController.php", "src/Http/Controllers/CP/Fieldtypes/FilesFieldtypeController.php", "src/Http/Controllers/FormController.php"], "buggy_code_start_loc": [72, 15, 181], "buggy_code_end_loc": [73, 16, 182], "fixing_code_start_loc": [72, 15, 181], "fixing_code_end_loc": [73, 16, 182], "type": "CWE-434", "message": "Statamic is a flat-first, Laravel + Git powered CMS designed for building websites. In affected versions certain additional PHP files crafted to look like images may be uploaded regardless of mime type validation rules. This affects front-end forms using the \"Forms\" feature, and asset upload fields in the control panel. Malicious users could leverage this vulnerability to upload and execute code. This issue has been patched in versions 3.4.14 and 4.34.0. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-48217", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-14T22:15:31.577", "lastModified": "2023-11-22T14:37:30.113", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Statamic is a flat-first, Laravel + Git powered CMS designed for building websites. In affected versions certain additional PHP files crafted to look like images may be uploaded regardless of mime type validation rules. This affects front-end forms using the \"Forms\" feature, and asset upload fields in the control panel. Malicious users could leverage this vulnerability to upload and execute code. This issue has been patched in versions 3.4.14 and 4.34.0. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Statamic es un CMS plano con tecnolog\u00eda Laravel + Git dise\u00f1ado para crear sitios web. En las versiones afectadas, es posible cargar ciertos archivos PHP adicionales manipulados para que parezcan im\u00e1genes, independientemente de las reglas de validaci\u00f3n del tipo MIME. Esto afecta los formularios de front-end que utilizan la funci\u00f3n \"Formularios\" y los campos de carga de activos en el panel de control. Los usuarios malintencionados podr\u00edan aprovechar esta vulnerabilidad para cargar y ejecutar c\u00f3digo. Este problema se solucion\u00f3 en las versiones 3.4.14 y 4.34.0. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:statamic:statamic:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.14", "matchCriteriaId": "1A50F47A-9802-4A97-BA68-D8A7BBD7CC8B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:statamic:statamic:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.34.0", "matchCriteriaId": "FE7C9F19-207E-4CD2-AE61-B3BEF7A7D838"}]}]}], "references": [{"url": "https://github.com/statamic/cms/commit/4c6fe041e2203a8033e5949ce4a5d9d6c0ad2411", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/statamic/cms/security/advisories/GHSA-2r53-9295-3m86", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/statamic/cms/commit/4c6fe041e2203a8033e5949ce4a5d9d6c0ad2411"}}