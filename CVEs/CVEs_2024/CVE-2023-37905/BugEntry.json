{"buggy_code": ["/**\n * @license Copyright (c) CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.html or http://ckeditor.com/license\n */\n\nCKEDITOR.plugins.add(\"wordcount\",\n    {\n        lang: \"ar,bg,ca,cs,da,de,el,en,es,eu,fa,fi,fr,he,hr,hu,it,ka,ko,ja,nl,no,pl,pt,pt-br,ru,sk,sv,tr,uk,zh-cn,zh,ro\", // %REMOVE_LINE_CORE%\n        version: \"1.17.10\",\n        requires: \"htmlwriter,notification,undo\",\n        bbcodePluginLoaded: false,\n        onLoad: function() {\n            CKEDITOR.document.appendStyleSheet(this.path + \"css/wordcount.css\");\n        },\n        init: function(editor) {\n            var defaultFormat = \"\",\n                lastWordCount = -1,\n                lastCharCount = -1,\n                lastParagraphs = -1,\n                limitReachedNotified = false,\n                limitRestoredNotified = false,\n                timeoutId = 0,\n                notification = null;\n\n\n            var dispatchEvent = function(type, currentLength, maxLength) {\n                if (typeof document.dispatchEvent == \"undefined\") {\n                    return;\n                }\n\n                type = \"ckeditor.wordcount.\" + type;\n\n                var cEvent;\n                var eventInitDict = {\n                    bubbles: false,\n                    cancelable: true,\n                    detail: {\n                        currentLength: currentLength,\n                        maxLength: maxLength\n                    }\n                };\n\n                try {\n                    cEvent = new CustomEvent(type, eventInitDict);\n                } catch (o_O) {\n                    cEvent = document.createEvent(\"CustomEvent\");\n                    cEvent.initCustomEvent(\n                        type,\n                        eventInitDict.bubbles,\n                        eventInitDict.cancelable,\n                        eventInitDict.detail\n                    );\n                }\n\n                document.dispatchEvent(cEvent);\n            };\n\n            // Default Config\n            var defaultConfig = {\n                showRemaining: false,\n                showParagraphs: true,\n                showWordCount: true,\n                showCharCount: false,\n                countBytesAsChars: false,\n                countSpacesAsChars: false,\n                countHTML: false,\n                countLineBreaks: false,\n                hardLimit: true,\n                warnOnLimitOnly: false,\n                wordDelims: '',\n\n                //MAXLENGTH Properties\n                maxWordCount: -1,\n                maxCharCount: -1,\n                maxParagraphs: -1,\n\n                // Filter\n                filter: null,\n\n                // How long to show the 'paste' warning\n                pasteWarningDuration: 0,\n\n                //DisAllowed functions\n                wordCountGreaterThanMaxLengthEvent: function(currentLength, maxLength) {\n                    dispatchEvent(\"wordCountGreaterThanMaxLengthEvent\", currentLength, maxLength);\n                },\n                charCountGreaterThanMaxLengthEvent: function(currentLength, maxLength) {\n                    dispatchEvent(\"charCountGreaterThanMaxLengthEvent\", currentLength, maxLength);\n                },\n\n                //Allowed Functions\n                wordCountLessThanMaxLengthEvent: function(currentLength, maxLength) {\n                    dispatchEvent(\"wordCountLessThanMaxLengthEvent\", currentLength, maxLength);\n                },\n                charCountLessThanMaxLengthEvent: function(currentLength, maxLength) {\n                    dispatchEvent(\"charCountLessThanMaxLengthEvent\", currentLength, maxLength);\n                }\n            };\n\n            // Get Config & Lang\n            var config = CKEDITOR.tools.extend(defaultConfig, editor.config.wordcount || {}, true);\n\n            if (config.showParagraphs) {\n              if (config.maxParagraphs > -1) {\n                  if (config.showRemaining) {\n                      defaultFormat += \"%paragraphsCount% \" + editor.lang.wordcount.ParagraphsRemaining;\n                  } else {\n                      defaultFormat += editor.lang.wordcount.Paragraphs + \" %paragraphsCount%\";\n\n                      defaultFormat += \"/\" + config.maxParagraphs;\n                  }\n              } else {\n                  defaultFormat += editor.lang.wordcount.Paragraphs + \" %paragraphsCount%\";\n              }\n            }\n\n            if (config.showParagraphs && (config.showWordCount || config.showCharCount)) {\n                defaultFormat += \", \";\n            }\n\n            if (config.showWordCount) {\n                if (config.maxWordCount > -1) {\n                    if (config.showRemaining) {\n                        defaultFormat += \"%wordCount% \" + editor.lang.wordcount.WordCountRemaining;\n                    } else {\n                        defaultFormat += editor.lang.wordcount.WordCount + \" %wordCount%\";\n\n                        defaultFormat += \"/\" + config.maxWordCount;\n                    }\n                } else {\n                    defaultFormat += editor.lang.wordcount.WordCount + \" %wordCount%\";\n                }\n            }\n\n            if (config.showCharCount && config.showWordCount) {\n                defaultFormat += \", \";\n            }\n\n            if (config.showCharCount) {\n                if (config.maxCharCount > -1) {\n                    if (config.showRemaining) {\n                        defaultFormat += \"%charCount% \" +\n                            editor.lang.wordcount[config.countHTML\n                                ? \"CharCountWithHTMLRemaining\"\n                                : \"CharCountRemaining\"];\n                    } else {\n                        defaultFormat += editor.lang.wordcount[config.countHTML\n                                ? \"CharCountWithHTML\"\n                                : \"CharCount\"] +\n                            \" %charCount%\";\n\n                        defaultFormat += \"/\" + config.maxCharCount;\n                    }\n                } else {\n                    defaultFormat += editor.lang.wordcount[config.countHTML ? \"CharCountWithHTML\" : \"CharCount\"] +\n                        \" %charCount%\";\n                }\n            }\n\n            var format = defaultFormat;\n\n            bbcodePluginLoaded = typeof editor.plugins.bbcode != \"undefined\";\n\n            function counterId(editorInstance) {\n                return \"cke_wordcount_\" + editorInstance.name;\n            }\n\n            function counterElement(editorInstance) {\n                return document.getElementById(counterId(editorInstance));\n            }\n\n            function strip(html) {\n                if (bbcodePluginLoaded) {\n                    // stripping out BBCode tags [...][/...]\n                    return html.replace(/\\[.*?\\]/gi, \"\");\n                }\n\n                var tmp = document.createElement(\"div\");\n\n                // Add filter before strip\n                html = filter(html);\n\n                tmp.innerHTML = html;\n\n                if (tmp.textContent == \"\" && typeof tmp.innerText == \"undefined\") {\n                    return \"\";\n                }\n\n                return tmp.textContent || tmp.innerText;\n            }\n\n            /**\n             * Implement filter to add or remove before counting\n             * @param html\n             * @returns string\n             */\n            function filter(html) {\n                if (config.filter instanceof CKEDITOR.htmlParser.filter) {\n                    var fragment = CKEDITOR.htmlParser.fragment.fromHtml(html),\n                        writer = new CKEDITOR.htmlParser.basicWriter();\n                    config.filter.applyTo(fragment);\n                    fragment.writeHtml(writer);\n                    return writer.getHtml();\n                }\n                return html;\n            }\n\n            function countCharacters(text) {\n                if (config.countHTML) {\n                    return config.countBytesAsChars ? countBytes(filter(text)) : filter(text).length;\n                }\n\n                var normalizedText;\n\n                // strip body tags\n                if (editor.config.fullPage) {\n                    var i = text.search(new RegExp(\"<body>\", \"i\"));\n                    if (i != -1) {\n                        var j = text.search(new RegExp(\"</body>\", \"i\"));\n                        text = text.substring(i + 6, j);\n                    }\n\n                }\n\n                normalizedText = text;\n\n                if (!config.countSpacesAsChars) {\n                    normalizedText = text.replace(/\\s/g, \"\").replace(/&nbsp;/g, \"\");\n                }\n\n                if (config.countLineBreaks) {\n                    normalizedText = normalizedText.replace(/(\\r\\n|\\n|\\r)/gm, \" \");\n                } else {\n                    normalizedText = normalizedText.replace(/(\\r\\n|\\n|\\r)/gm, \"\").replace(/&nbsp;/gi, \" \");\n                }\n\n                normalizedText = strip(normalizedText).replace(/^([\\t\\r\\n]*)$/, \"\");\n\n                return config.countBytesAsChars ? countBytes(normalizedText) : normalizedText.length;\n            }\n\n            function countBytes(text) {\n                var count = 0, stringLength = text.length, i;\n                text = String(text || \"\");\n                for (i = 0; i < stringLength; i++) {\n                    var partCount = encodeURI(text[i]).split(\"%\").length;\n                    count += partCount == 1 ? 1 : partCount - 1;\n                }\n                return count;\n            }\n\n            function countParagraphs(text) {\n                return (text.replace(/&nbsp;/g, \" \").replace(/(<([^>]+)>)/ig, \"\").replace(/^\\s*$[\\n\\r]{1,}/gm, \"++\")\n                    .split(\"++\").length);\n            }\n\n            function countWords(text) {\n                \n                /**\n                 * we may end up with a couple of extra spaces in a row with all these replacements, but that's ok \n                 * since we're going to split on one or more delimiters when we generate the words array\n                 **/\n                var normalizedText = text.replace(/(<([^>]+)>)/ig, \" \")    //replace html tags, i think?\n                    .replace(/(\\r\\n|\\n|\\r)/gm, \" \")                        //replace new lines(in many forms)\n                    .replace(/^\\s+|\\s+$/g, \" \")                            //replace leading or trailing multiple spaces\n                    .replace(\"&nbsp;\", \" \");                               //replace html entities indicating a space\n\n                normalizedText = strip(normalizedText);\n\n                var re = config.wordDelims ? new RegExp('[\\\\s'+config.wordDelims+']+') : /\\s+/;\n                var words = normalizedText.split(re);\n                \n                re = config.wordDelims ? new RegExp('^([\\\\s\\\\t\\\\r\\\\n'+config.wordDelims+']*)$') : /^([\\s\\t\\r\\n]*)$/;\n                for (var wordIndex = words.length - 1; wordIndex >= 0; wordIndex--) {\n                    if (!words[wordIndex] || words[wordIndex].match(re)) {\n                        words.splice(wordIndex, 1);\n                    }\n                }\n\n                return (words.length);\n            }\n\n            function limitReached(editorInstance, notify) {\n                limitReachedNotified = true;\n                limitRestoredNotified = false;\n\n                if (!config.warnOnLimitOnly) {\n                    if (config.hardLimit) {\n                        if (editor.mode === \"source\" && editor.plugins.codemirror) {\n                            window[\"codemirror_\" + editor.id].undo();\n                        } else {\n                            editorInstance.execCommand(\"undo\");\n                            editorInstance.execCommand(\"undo\");\n                        }\n                           \n                    }\n                }\n\n                if (!notify) {\n                    counterElement(editorInstance).className = \"cke_path_item cke_wordcountLimitReached\";\n                    editorInstance.fire(\"limitReached\", { firedBy: \"wordCount.limitReached\" }, editor);\n                }\n            }\n\n            function limitRestored(editorInstance) {\n                limitRestoredNotified = true;\n                limitReachedNotified = false;\n\n                if (!config.warnOnLimitOnly) {\n                    editorInstance.fire(\"saveSnapshot\");\n                }\n\n                counterElement(editorInstance).className = \"cke_path_item\";\n            }\n\n            function updateCounter(editorInstance) {\n                if (!counterElement(editorInstance)) {\n                    return;\n                }\n\n                var paragraphs = 0,\n                    wordCount = 0,\n                    charCount = 0,\n                    text;\n\n                // BeforeGetData and getData events are fired when calling\n                // getData(). We can prevent this by passing true as an\n                // argument to getData(). This allows us to fire the events\n                // manually with additional event data: firedBy. This additional\n                // data helps differentiate calls to getData() made by\n                // wordCount plugin from calls made by other plugins/code.\n                editorInstance.fire(\"beforeGetData\", { firedBy: \"wordCount.updateCounter\" }, editor);\n                text = editorInstance.getData(true);\n                editorInstance.fire(\"getData\", { dataValue: text, firedBy: \"wordCount.updateCounter\" }, editor);\n\n                if (text) {\n                    if (config.showCharCount) {\n                        charCount = countCharacters(text);\n                    }\n\n                    if (config.showParagraphs) {\n                        paragraphs = countParagraphs(text);\n                    }\n\n                    if (config.showWordCount) {\n                        wordCount = countWords(text);\n                    }\n                }\n\n                var html = format;\n                if (config.showRemaining) {\n                    if (config.maxCharCount >= 0) {\n                        html = html.replace(\"%charCount%\", config.maxCharCount - charCount);\n                    } else {\n                        html = html.replace(\"%charCount%\", charCount);\n                    }\n\n                    if (config.maxWordCount >= 0) {\n                        html = html.replace(\"%wordCount%\", config.maxWordCount - wordCount);\n                    } else {\n                        html = html.replace(\"%wordCount%\", wordCount);\n                    }\n\n                    if (config.maxParagraphs >= 0) {\n                        html = html.replace(\"%paragraphsCount%\", config.maxParagraphs - paragraphs);\n                    } else {\n                        html = html.replace(\"%paragraphsCount%\", paragraphs);\n                    }\n                } else {\n                    html = html.replace(\"%wordCount%\", wordCount).replace(\"%charCount%\", charCount).replace(\"%paragraphsCount%\", paragraphs);\n                }\n\n                (editorInstance.config.wordcount || (editorInstance.config.wordcount = {})).wordCount = wordCount;\n                (editorInstance.config.wordcount || (editorInstance.config.wordcount = {})).charCount = charCount;\n\n                if (CKEDITOR.env.gecko) {\n                    counterElement(editorInstance).innerHTML = html;\n                } else {\n                    counterElement(editorInstance).innerText = html;\n                }\n\n                if (charCount == lastCharCount && wordCount == lastWordCount && paragraphs == lastParagraphs) {\n                    if (charCount == config.maxCharCount || wordCount == config.maxWordCount || paragraphs > config.maxParagraphs) {\n                        editorInstance.fire(\"saveSnapshot\");\n                    }\n                    return true;\n                }\n\n                //If the limit is already over, allow the deletion of characters/words. Otherwise,\n                //the user would have to delete at one go the number of offending characters\n                var deltaWord = wordCount - lastWordCount;\n                var deltaChar = charCount - lastCharCount;\n                var deltaParagraphs = paragraphs - lastParagraphs;\n\n                lastWordCount = wordCount;\n                lastCharCount = charCount;\n                lastParagraphs = paragraphs;\n\n                if (lastWordCount == -1) {\n                    lastWordCount = wordCount;\n                }\n                if (lastCharCount == -1) {\n                    lastCharCount = charCount;\n                }\n                if (lastParagraphs == -1) {\n                    lastParagraphs = paragraphs;\n                }\n\n                // Check for word limit and/or char limit\n                if ((config.maxWordCount > -1 && wordCount > config.maxWordCount && deltaWord > 0) ||\n                    (config.maxCharCount > -1 && charCount > config.maxCharCount && deltaChar > 0) ||\n                    (config.maxParagraphs > -1 && paragraphs > config.maxParagraphs && deltaParagraphs > 0)) {\n\n                    limitReached(editorInstance, limitReachedNotified);\n                } else if ((config.maxWordCount == -1 || wordCount <= config.maxWordCount) &&\n                    (config.maxCharCount == -1 || charCount <= config.maxCharCount) &&\n                    (config.maxParagraphs == -1 || paragraphs <= config.maxParagraphs)) {\n\n                    limitRestored(editorInstance);\n                } else {\n                    editorInstance.fire(\"saveSnapshot\");\n                }\n\n                // update instance\n                editorInstance.wordCount =\n                {\n                    paragraphs: paragraphs,\n                    wordCount: wordCount,\n                    charCount: charCount\n                };\n\n\n                // Fire Custom Events\n                if (config.charCountGreaterThanMaxLengthEvent && config.charCountLessThanMaxLengthEvent) {\n                    if (charCount > config.maxCharCount && config.maxCharCount > -1) {\n                        config.charCountGreaterThanMaxLengthEvent(charCount, config.maxCharCount);\n                    } else {\n                        config.charCountLessThanMaxLengthEvent(charCount, config.maxCharCount);\n                    }\n                }\n\n                if (config.wordCountGreaterThanMaxLengthEvent && config.wordCountLessThanMaxLengthEvent) {\n                    if (wordCount > config.maxWordCount && config.maxWordCount > -1) {\n                        config.wordCountGreaterThanMaxLengthEvent(wordCount, config.maxWordCount);\n\n                    } else {\n                        config.wordCountLessThanMaxLengthEvent(wordCount, config.maxWordCount);\n                    }\n                }\n\n                return true;\n            }\n\n            function isCloseToLimits() {\n                if (config.maxWordCount > -1 && config.maxWordCount - lastWordCount < 5) {\n                    return true;\n                }\n\n                if (config.maxCharCount > -1 && config.maxCharCount - lastCharCount < 20) {\n                    return true;\n                }\n\n                if (config.maxParagraphs > -1 && config.maxParagraphs - lastParagraphs < 1) {\n                    return true;\n                }\n\n                return false;\n            }\n\n            editor.on(\"key\",\n                function (event) {\n                    var ms = isCloseToLimits() ? 5 : 250;\n\n                    if (editor.mode === \"source\") {\n                        clearTimeout(timeoutId);\n                        timeoutId = setTimeout(\n                            updateCounter.bind(this, event.editor),\n                            ms\n                        );\n                    }\n\n                    if (event.data.keyCode == 13) {\n                        clearTimeout(timeoutId);\n                        timeoutId = setTimeout(\n                            updateCounter.bind(this, event.editor),\n                            ms\n                        );\n                    }\n                },\n                editor);\n\n            editor.on(\"change\",\n                function(event) {\n                    var ms = isCloseToLimits() ? 5 : 250;\n                    clearTimeout(timeoutId);\n                    timeoutId = setTimeout(\n                        updateCounter.bind(this, event.editor),\n                        ms\n                    );\n                },\n                editor);\n\n            editor.on(\"uiSpace\",\n                function (event) {\n                    var wordcountClass = \"cke_wordcount\";\n\n                    if (editor.lang.dir == \"rtl\") {\n                        wordcountClass = wordcountClass + \" cke_wordcount_rtl\";\n                    }\n\n                    if (editor.elementMode === CKEDITOR.ELEMENT_MODE_INLINE) {\n                        if (event.data.space == \"top\") {\n                            event.data.html += \"<div class=\\\"\" + wordcountClass +\"\\\" style=\\\"\\\"\" +\n                                \" title=\\\"\" +\n                                editor.lang.wordcount.title +\n                                \"\\\"\" +\n                                \"><span id=\\\"\" +\n                                counterId(event.editor) +\n                                \"\\\" class=\\\"cke_path_item\\\">&nbsp;</span></div>\";\n                        }\n                    } else {\n                        if (event.data.space == \"bottom\") {\n                            event.data.html += \"<div class=\\\"\"+wordcountClass+\"\\\" style=\\\"\\\"\" +\n                                \" title=\\\"\" +\n                                editor.lang.wordcount.title +\n                                \"\\\"\" +\n                                \"><span id=\\\"\" +\n                                counterId(event.editor) +\n                                \"\\\" class=\\\"cke_path_item\\\">&nbsp;</span></div>\";\n                        }\n                    }\n\n                },\n                editor,\n                null,\n                100);\n\n            editor.on(\"dataReady\",\n                function(event) {\n                    updateCounter(event.editor);\n                },\n                editor,\n                null,\n                100);\n\n            editor.on(\"paste\",\n                function(event) {\n                    if (!config.warnOnLimitOnly && (config.maxWordCount > 0 || config.maxCharCount > 0 || config.maxParagraphs > 0)) {\n\n                        // Check if pasted content is above the limits\n                        var wordCount = -1,\n                            charCount = -1,\n                            paragraphs = -1;\n\n                        var mySelection = event.editor.getSelection(),\n                            selectedText = mySelection.getNative() \n                              ? mySelection.getNative().toString().trim()\n                              : '';\n\n\n                        // BeforeGetData and getData events are fired when calling\n                        // getData(). We can prevent this by passing true as an\n                        // argument to getData(). This allows us to fire the events\n                        // manually with additional event data: firedBy. This additional\n                        // data helps differentiate calls to getData() made by\n                        // wordCount plugin from calls made by other plugins/code.\n                        event.editor.fire(\"beforeGetData\", { firedBy: \"wordCount.onPaste\" }, event.editor);\n                        var text = event.editor.getData(true);\n                        event.editor.fire(\"getData\", { dataValue: text, firedBy: \"wordCount.onPaste\" }, event.editor);\n\n                        if (selectedText.length > 0) {\n                            var plaintext = event.editor.document.getBody().getText();\n\n                            if (plaintext.length === selectedText.length) {\n                                text = \"\";\n                            }\n                        }\n\n\n                        text += event.data.dataValue;\n\n                        if (config.showCharCount) {\n                            charCount = countCharacters(text);\n                        }\n\n                        if (config.showWordCount) {\n                            wordCount = countWords(text);\n                        }\n\n                        if (config.showParagraphs) {\n                            paragraphs = countParagraphs(text);\n                        }\n\n\n                        // Instantiate the notification when needed and only have one instance\n                        if (notification === null) {\n                            notification = new CKEDITOR.plugins.notification(event.editor,\n                                {\n                                    message: event.editor.lang.wordcount.pasteWarning,\n                                    type: \"warning\",\n                                    duration: config.pasteWarningDuration\n                                });\n                        }\n\n                        if (config.maxCharCount > 0 && charCount > config.maxCharCount && config.hardLimit) {\n                            if (!notification.isVisible()) {\n                                notification.show();\n                            }\n                            event.cancel();\n                        }\n\n                        if (config.maxWordCount > 0 && wordCount > config.maxWordCount && config.hardLimit) {\n                            if (!notification.isVisible()) {\n                                notification.show();\n                            }\n                            event.cancel();\n                        }\n\n                        if (config.maxParagraphs > 0 && paragraphs > config.maxParagraphs && config.hardLimit) {\n                            if (!notification.isVisible()) {\n                                notification.show();\n                            }\n                            event.cancel();\n                        }\n                    }\n                },\n                editor,\n                null,\n                100);\n\n            editor.on(\"afterPaste\",\n                function(event) {\n                    updateCounter(event.editor);\n                },\n                editor,\n                null,\n                100);\n\n            editor.on(\"afterPasteFromWord\",\n                function (event) {\n                    updateCounter(event.editor);\n                },\n                editor,\n                null,\n                100);\n        }\n    });\n"], "fixing_code": ["/**\n * @license Copyright (c) CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.html or http://ckeditor.com/license\n */\n\nCKEDITOR.plugins.add(\"wordcount\",\n    {\n        lang: \"ar,bg,ca,cs,da,de,el,en,es,eu,fa,fi,fr,he,hr,hu,it,ka,ko,ja,nl,no,pl,pt,pt-br,ru,sk,sv,tr,uk,zh-cn,zh,ro\", // %REMOVE_LINE_CORE%\n        version: \"1.17.11\",\n        requires: \"htmlwriter,notification,undo\",\n        bbcodePluginLoaded: false,\n        onLoad: function() {\n            CKEDITOR.document.appendStyleSheet(this.path + \"css/wordcount.css\");\n        },\n        init: function(editor) {\n            var defaultFormat = \"\",\n                lastWordCount = -1,\n                lastCharCount = -1,\n                lastParagraphs = -1,\n                limitReachedNotified = false,\n                limitRestoredNotified = false,\n                timeoutId = 0,\n                notification = null;\n\n\n            var dispatchEvent = function(type, currentLength, maxLength) {\n                if (typeof document.dispatchEvent == \"undefined\") {\n                    return;\n                }\n\n                type = \"ckeditor.wordcount.\" + type;\n\n                var cEvent;\n                var eventInitDict = {\n                    bubbles: false,\n                    cancelable: true,\n                    detail: {\n                        currentLength: currentLength,\n                        maxLength: maxLength\n                    }\n                };\n\n                try {\n                    cEvent = new CustomEvent(type, eventInitDict);\n                } catch (o_O) {\n                    cEvent = document.createEvent(\"CustomEvent\");\n                    cEvent.initCustomEvent(\n                        type,\n                        eventInitDict.bubbles,\n                        eventInitDict.cancelable,\n                        eventInitDict.detail\n                    );\n                }\n\n                document.dispatchEvent(cEvent);\n            };\n\n            // Default Config\n            var defaultConfig = {\n                showRemaining: false,\n                showParagraphs: true,\n                showWordCount: true,\n                showCharCount: false,\n                countBytesAsChars: false,\n                countSpacesAsChars: false,\n                countHTML: false,\n                countLineBreaks: false,\n                hardLimit: true,\n                warnOnLimitOnly: false,\n                wordDelims: '',\n\n                //MAXLENGTH Properties\n                maxWordCount: -1,\n                maxCharCount: -1,\n                maxParagraphs: -1,\n\n                // Filter\n                filter: null,\n\n                // How long to show the 'paste' warning\n                pasteWarningDuration: 0,\n\n                //DisAllowed functions\n                wordCountGreaterThanMaxLengthEvent: function(currentLength, maxLength) {\n                    dispatchEvent(\"wordCountGreaterThanMaxLengthEvent\", currentLength, maxLength);\n                },\n                charCountGreaterThanMaxLengthEvent: function(currentLength, maxLength) {\n                    dispatchEvent(\"charCountGreaterThanMaxLengthEvent\", currentLength, maxLength);\n                },\n\n                //Allowed Functions\n                wordCountLessThanMaxLengthEvent: function(currentLength, maxLength) {\n                    dispatchEvent(\"wordCountLessThanMaxLengthEvent\", currentLength, maxLength);\n                },\n                charCountLessThanMaxLengthEvent: function(currentLength, maxLength) {\n                    dispatchEvent(\"charCountLessThanMaxLengthEvent\", currentLength, maxLength);\n                }\n            };\n\n            // Get Config & Lang\n            var config = CKEDITOR.tools.extend(defaultConfig, editor.config.wordcount || {}, true);\n\n            if (config.showParagraphs) {\n              if (config.maxParagraphs > -1) {\n                  if (config.showRemaining) {\n                      defaultFormat += \"%paragraphsCount% \" + editor.lang.wordcount.ParagraphsRemaining;\n                  } else {\n                      defaultFormat += editor.lang.wordcount.Paragraphs + \" %paragraphsCount%\";\n\n                      defaultFormat += \"/\" + config.maxParagraphs;\n                  }\n              } else {\n                  defaultFormat += editor.lang.wordcount.Paragraphs + \" %paragraphsCount%\";\n              }\n            }\n\n            if (config.showParagraphs && (config.showWordCount || config.showCharCount)) {\n                defaultFormat += \", \";\n            }\n\n            if (config.showWordCount) {\n                if (config.maxWordCount > -1) {\n                    if (config.showRemaining) {\n                        defaultFormat += \"%wordCount% \" + editor.lang.wordcount.WordCountRemaining;\n                    } else {\n                        defaultFormat += editor.lang.wordcount.WordCount + \" %wordCount%\";\n\n                        defaultFormat += \"/\" + config.maxWordCount;\n                    }\n                } else {\n                    defaultFormat += editor.lang.wordcount.WordCount + \" %wordCount%\";\n                }\n            }\n\n            if (config.showCharCount && config.showWordCount) {\n                defaultFormat += \", \";\n            }\n\n            if (config.showCharCount) {\n                if (config.maxCharCount > -1) {\n                    if (config.showRemaining) {\n                        defaultFormat += \"%charCount% \" +\n                            editor.lang.wordcount[config.countHTML\n                                ? \"CharCountWithHTMLRemaining\"\n                                : \"CharCountRemaining\"];\n                    } else {\n                        defaultFormat += editor.lang.wordcount[config.countHTML\n                                ? \"CharCountWithHTML\"\n                                : \"CharCount\"] +\n                            \" %charCount%\";\n\n                        defaultFormat += \"/\" + config.maxCharCount;\n                    }\n                } else {\n                    defaultFormat += editor.lang.wordcount[config.countHTML ? \"CharCountWithHTML\" : \"CharCount\"] +\n                        \" %charCount%\";\n                }\n            }\n\n            var format = defaultFormat;\n\n            bbcodePluginLoaded = typeof editor.plugins.bbcode != \"undefined\";\n\n            function counterId(editorInstance) {\n                return \"cke_wordcount_\" + editorInstance.name;\n            }\n\n            function counterElement(editorInstance) {\n                return document.getElementById(counterId(editorInstance));\n            }\n\n            function strip(html) {\n                if (bbcodePluginLoaded) {\n                    // stripping out BBCode tags [...][/...]\n                    return html.replace(/\\[.*?\\]/gi, \"\");\n                }\n\n                var tmp = document.createElement(\"div\");\n\n                // Add filter before strip\n                html = filter(html);\n\n                tmp.innerHTML = html;\n\n                // Parse filtered HTML, without applying it to any element in DOM\n                var tmp = new DOMParser().parseFromString(html, 'text/html');\n                if (!tmp.body || !tmp.body.textContent) {\n                    return \"\";\n                }\n\n                return tmp.body.textContent || tmp.body.innerText;\n            }\n\n            /**\n             * Implement filter to add or remove before counting\n             * @param html\n             * @returns string\n             */\n            function filter(html) {\n                if (config.filter instanceof CKEDITOR.htmlParser.filter) {\n                    var fragment = CKEDITOR.htmlParser.fragment.fromHtml(html),\n                        writer = new CKEDITOR.htmlParser.basicWriter();\n                    config.filter.applyTo(fragment);\n                    fragment.writeHtml(writer);\n                    return writer.getHtml();\n                }\n                return html;\n            }\n\n            function countCharacters(text) {\n                if (config.countHTML) {\n                    return config.countBytesAsChars ? countBytes(filter(text)) : filter(text).length;\n                }\n\n                var normalizedText;\n\n                // strip body tags\n                if (editor.config.fullPage) {\n                    var i = text.search(new RegExp(\"<body>\", \"i\"));\n                    if (i != -1) {\n                        var j = text.search(new RegExp(\"</body>\", \"i\"));\n                        text = text.substring(i + 6, j);\n                    }\n\n                }\n\n                normalizedText = text;\n\n                if (!config.countSpacesAsChars) {\n                    normalizedText = text.replace(/\\s/g, \"\").replace(/&nbsp;/g, \"\");\n                }\n\n                if (config.countLineBreaks) {\n                    normalizedText = normalizedText.replace(/(\\r\\n|\\n|\\r)/gm, \" \");\n                } else {\n                    normalizedText = normalizedText.replace(/(\\r\\n|\\n|\\r)/gm, \"\").replace(/&nbsp;/gi, \" \");\n                }\n\n                normalizedText = strip(normalizedText).replace(/^([\\t\\r\\n]*)$/, \"\");\n\n                return config.countBytesAsChars ? countBytes(normalizedText) : normalizedText.length;\n            }\n\n            function countBytes(text) {\n                var count = 0, stringLength = text.length, i;\n                text = String(text || \"\");\n                for (i = 0; i < stringLength; i++) {\n                    var partCount = encodeURI(text[i]).split(\"%\").length;\n                    count += partCount == 1 ? 1 : partCount - 1;\n                }\n                return count;\n            }\n\n            function countParagraphs(text) {\n                return (text.replace(/&nbsp;/g, \" \").replace(/(<([^>]+)>)/ig, \"\").replace(/^\\s*$[\\n\\r]{1,}/gm, \"++\")\n                    .split(\"++\").length);\n            }\n\n            function countWords(text) {\n                \n                /**\n                 * we may end up with a couple of extra spaces in a row with all these replacements, but that's ok \n                 * since we're going to split on one or more delimiters when we generate the words array\n                 **/\n                var normalizedText = text.replace(/(<([^>]+)>)/ig, \" \")    //replace html tags, i think?\n                    .replace(/(\\r\\n|\\n|\\r)/gm, \" \")                        //replace new lines(in many forms)\n                    .replace(/^\\s+|\\s+$/g, \" \")                            //replace leading or trailing multiple spaces\n                    .replace(\"&nbsp;\", \" \");                               //replace html entities indicating a space\n\n                normalizedText = strip(normalizedText);\n\n                var re = config.wordDelims ? new RegExp('[\\\\s'+config.wordDelims+']+') : /\\s+/;\n                var words = normalizedText.split(re);\n                \n                re = config.wordDelims ? new RegExp('^([\\\\s\\\\t\\\\r\\\\n'+config.wordDelims+']*)$') : /^([\\s\\t\\r\\n]*)$/;\n                for (var wordIndex = words.length - 1; wordIndex >= 0; wordIndex--) {\n                    if (!words[wordIndex] || words[wordIndex].match(re)) {\n                        words.splice(wordIndex, 1);\n                    }\n                }\n\n                return (words.length);\n            }\n\n            function limitReached(editorInstance, notify) {\n                limitReachedNotified = true;\n                limitRestoredNotified = false;\n\n                if (!config.warnOnLimitOnly) {\n                    if (config.hardLimit) {\n                        if (editor.mode === \"source\" && editor.plugins.codemirror) {\n                            window[\"codemirror_\" + editor.id].undo();\n                        } else {\n                            editorInstance.execCommand(\"undo\");\n                            editorInstance.execCommand(\"undo\");\n                        }\n                           \n                    }\n                }\n\n                if (!notify) {\n                    counterElement(editorInstance).className = \"cke_path_item cke_wordcountLimitReached\";\n                    editorInstance.fire(\"limitReached\", { firedBy: \"wordCount.limitReached\" }, editor);\n                }\n            }\n\n            function limitRestored(editorInstance) {\n                limitRestoredNotified = true;\n                limitReachedNotified = false;\n\n                if (!config.warnOnLimitOnly) {\n                    editorInstance.fire(\"saveSnapshot\");\n                }\n\n                counterElement(editorInstance).className = \"cke_path_item\";\n            }\n\n            function updateCounter(editorInstance) {\n                if (!counterElement(editorInstance)) {\n                    return;\n                }\n\n                var paragraphs = 0,\n                    wordCount = 0,\n                    charCount = 0,\n                    text;\n\n                // BeforeGetData and getData events are fired when calling\n                // getData(). We can prevent this by passing true as an\n                // argument to getData(). This allows us to fire the events\n                // manually with additional event data: firedBy. This additional\n                // data helps differentiate calls to getData() made by\n                // wordCount plugin from calls made by other plugins/code.\n                editorInstance.fire(\"beforeGetData\", { firedBy: \"wordCount.updateCounter\" }, editor);\n                text = editorInstance.getData(true);\n                editorInstance.fire(\"getData\", { dataValue: text, firedBy: \"wordCount.updateCounter\" }, editor);\n\n                if (text) {\n                    if (config.showCharCount) {\n                        charCount = countCharacters(text);\n                    }\n\n                    if (config.showParagraphs) {\n                        paragraphs = countParagraphs(text);\n                    }\n\n                    if (config.showWordCount) {\n                        wordCount = countWords(text);\n                    }\n                }\n\n                var html = format;\n                if (config.showRemaining) {\n                    if (config.maxCharCount >= 0) {\n                        html = html.replace(\"%charCount%\", config.maxCharCount - charCount);\n                    } else {\n                        html = html.replace(\"%charCount%\", charCount);\n                    }\n\n                    if (config.maxWordCount >= 0) {\n                        html = html.replace(\"%wordCount%\", config.maxWordCount - wordCount);\n                    } else {\n                        html = html.replace(\"%wordCount%\", wordCount);\n                    }\n\n                    if (config.maxParagraphs >= 0) {\n                        html = html.replace(\"%paragraphsCount%\", config.maxParagraphs - paragraphs);\n                    } else {\n                        html = html.replace(\"%paragraphsCount%\", paragraphs);\n                    }\n                } else {\n                    html = html.replace(\"%wordCount%\", wordCount).replace(\"%charCount%\", charCount).replace(\"%paragraphsCount%\", paragraphs);\n                }\n\n                (editorInstance.config.wordcount || (editorInstance.config.wordcount = {})).wordCount = wordCount;\n                (editorInstance.config.wordcount || (editorInstance.config.wordcount = {})).charCount = charCount;\n\n                if (CKEDITOR.env.gecko) {\n                    counterElement(editorInstance).innerHTML = html;\n                } else {\n                    counterElement(editorInstance).innerText = html;\n                }\n\n                if (charCount == lastCharCount && wordCount == lastWordCount && paragraphs == lastParagraphs) {\n                    if (charCount == config.maxCharCount || wordCount == config.maxWordCount || paragraphs > config.maxParagraphs) {\n                        editorInstance.fire(\"saveSnapshot\");\n                    }\n                    return true;\n                }\n\n                //If the limit is already over, allow the deletion of characters/words. Otherwise,\n                //the user would have to delete at one go the number of offending characters\n                var deltaWord = wordCount - lastWordCount;\n                var deltaChar = charCount - lastCharCount;\n                var deltaParagraphs = paragraphs - lastParagraphs;\n\n                lastWordCount = wordCount;\n                lastCharCount = charCount;\n                lastParagraphs = paragraphs;\n\n                if (lastWordCount == -1) {\n                    lastWordCount = wordCount;\n                }\n                if (lastCharCount == -1) {\n                    lastCharCount = charCount;\n                }\n                if (lastParagraphs == -1) {\n                    lastParagraphs = paragraphs;\n                }\n\n                // Check for word limit and/or char limit\n                if ((config.maxWordCount > -1 && wordCount > config.maxWordCount && deltaWord > 0) ||\n                    (config.maxCharCount > -1 && charCount > config.maxCharCount && deltaChar > 0) ||\n                    (config.maxParagraphs > -1 && paragraphs > config.maxParagraphs && deltaParagraphs > 0)) {\n\n                    limitReached(editorInstance, limitReachedNotified);\n                } else if ((config.maxWordCount == -1 || wordCount <= config.maxWordCount) &&\n                    (config.maxCharCount == -1 || charCount <= config.maxCharCount) &&\n                    (config.maxParagraphs == -1 || paragraphs <= config.maxParagraphs)) {\n\n                    limitRestored(editorInstance);\n                } else {\n                    editorInstance.fire(\"saveSnapshot\");\n                }\n\n                // update instance\n                editorInstance.wordCount =\n                {\n                    paragraphs: paragraphs,\n                    wordCount: wordCount,\n                    charCount: charCount\n                };\n\n\n                // Fire Custom Events\n                if (config.charCountGreaterThanMaxLengthEvent && config.charCountLessThanMaxLengthEvent) {\n                    if (charCount > config.maxCharCount && config.maxCharCount > -1) {\n                        config.charCountGreaterThanMaxLengthEvent(charCount, config.maxCharCount);\n                    } else {\n                        config.charCountLessThanMaxLengthEvent(charCount, config.maxCharCount);\n                    }\n                }\n\n                if (config.wordCountGreaterThanMaxLengthEvent && config.wordCountLessThanMaxLengthEvent) {\n                    if (wordCount > config.maxWordCount && config.maxWordCount > -1) {\n                        config.wordCountGreaterThanMaxLengthEvent(wordCount, config.maxWordCount);\n\n                    } else {\n                        config.wordCountLessThanMaxLengthEvent(wordCount, config.maxWordCount);\n                    }\n                }\n\n                return true;\n            }\n\n            function isCloseToLimits() {\n                if (config.maxWordCount > -1 && config.maxWordCount - lastWordCount < 5) {\n                    return true;\n                }\n\n                if (config.maxCharCount > -1 && config.maxCharCount - lastCharCount < 20) {\n                    return true;\n                }\n\n                if (config.maxParagraphs > -1 && config.maxParagraphs - lastParagraphs < 1) {\n                    return true;\n                }\n\n                return false;\n            }\n\n            editor.on(\"key\",\n                function (event) {\n                    var ms = isCloseToLimits() ? 5 : 250;\n\n                    if (editor.mode === \"source\") {\n                        clearTimeout(timeoutId);\n                        timeoutId = setTimeout(\n                            updateCounter.bind(this, event.editor),\n                            ms\n                        );\n                    }\n\n                    if (event.data.keyCode == 13) {\n                        clearTimeout(timeoutId);\n                        timeoutId = setTimeout(\n                            updateCounter.bind(this, event.editor),\n                            ms\n                        );\n                    }\n                },\n                editor);\n\n            editor.on(\"change\",\n                function(event) {\n                    var ms = isCloseToLimits() ? 5 : 250;\n                    clearTimeout(timeoutId);\n                    timeoutId = setTimeout(\n                        updateCounter.bind(this, event.editor),\n                        ms\n                    );\n                },\n                editor);\n\n            editor.on(\"uiSpace\",\n                function (event) {\n                    var wordcountClass = \"cke_wordcount\";\n\n                    if (editor.lang.dir == \"rtl\") {\n                        wordcountClass = wordcountClass + \" cke_wordcount_rtl\";\n                    }\n\n                    if (editor.elementMode === CKEDITOR.ELEMENT_MODE_INLINE) {\n                        if (event.data.space == \"top\") {\n                            event.data.html += \"<div class=\\\"\" + wordcountClass +\"\\\" style=\\\"\\\"\" +\n                                \" title=\\\"\" +\n                                editor.lang.wordcount.title +\n                                \"\\\"\" +\n                                \"><span id=\\\"\" +\n                                counterId(event.editor) +\n                                \"\\\" class=\\\"cke_path_item\\\">&nbsp;</span></div>\";\n                        }\n                    } else {\n                        if (event.data.space == \"bottom\") {\n                            event.data.html += \"<div class=\\\"\"+wordcountClass+\"\\\" style=\\\"\\\"\" +\n                                \" title=\\\"\" +\n                                editor.lang.wordcount.title +\n                                \"\\\"\" +\n                                \"><span id=\\\"\" +\n                                counterId(event.editor) +\n                                \"\\\" class=\\\"cke_path_item\\\">&nbsp;</span></div>\";\n                        }\n                    }\n\n                },\n                editor,\n                null,\n                100);\n\n            editor.on(\"dataReady\",\n                function(event) {\n                    updateCounter(event.editor);\n                },\n                editor,\n                null,\n                100);\n\n            editor.on(\"paste\",\n                function(event) {\n                    if (!config.warnOnLimitOnly && (config.maxWordCount > 0 || config.maxCharCount > 0 || config.maxParagraphs > 0)) {\n\n                        // Check if pasted content is above the limits\n                        var wordCount = -1,\n                            charCount = -1,\n                            paragraphs = -1;\n\n                        var mySelection = event.editor.getSelection(),\n                            selectedText = mySelection.getNative() \n                              ? mySelection.getNative().toString().trim()\n                              : '';\n\n\n                        // BeforeGetData and getData events are fired when calling\n                        // getData(). We can prevent this by passing true as an\n                        // argument to getData(). This allows us to fire the events\n                        // manually with additional event data: firedBy. This additional\n                        // data helps differentiate calls to getData() made by\n                        // wordCount plugin from calls made by other plugins/code.\n                        event.editor.fire(\"beforeGetData\", { firedBy: \"wordCount.onPaste\" }, event.editor);\n                        var text = event.editor.getData(true);\n                        event.editor.fire(\"getData\", { dataValue: text, firedBy: \"wordCount.onPaste\" }, event.editor);\n\n                        if (selectedText.length > 0) {\n                            var plaintext = event.editor.document.getBody().getText();\n\n                            if (plaintext.length === selectedText.length) {\n                                text = \"\";\n                            }\n                        }\n\n\n                        text += event.data.dataValue;\n\n                        if (config.showCharCount) {\n                            charCount = countCharacters(text);\n                        }\n\n                        if (config.showWordCount) {\n                            wordCount = countWords(text);\n                        }\n\n                        if (config.showParagraphs) {\n                            paragraphs = countParagraphs(text);\n                        }\n\n\n                        // Instantiate the notification when needed and only have one instance\n                        if (notification === null) {\n                            notification = new CKEDITOR.plugins.notification(event.editor,\n                                {\n                                    message: event.editor.lang.wordcount.pasteWarning,\n                                    type: \"warning\",\n                                    duration: config.pasteWarningDuration\n                                });\n                        }\n\n                        if (config.maxCharCount > 0 && charCount > config.maxCharCount && config.hardLimit) {\n                            if (!notification.isVisible()) {\n                                notification.show();\n                            }\n                            event.cancel();\n                        }\n\n                        if (config.maxWordCount > 0 && wordCount > config.maxWordCount && config.hardLimit) {\n                            if (!notification.isVisible()) {\n                                notification.show();\n                            }\n                            event.cancel();\n                        }\n\n                        if (config.maxParagraphs > 0 && paragraphs > config.maxParagraphs && config.hardLimit) {\n                            if (!notification.isVisible()) {\n                                notification.show();\n                            }\n                            event.cancel();\n                        }\n                    }\n                },\n                editor,\n                null,\n                100);\n\n            editor.on(\"afterPaste\",\n                function(event) {\n                    updateCounter(event.editor);\n                },\n                editor,\n                null,\n                100);\n\n            editor.on(\"afterPasteFromWord\",\n                function (event) {\n                    updateCounter(event.editor);\n                },\n                editor,\n                null,\n                100);\n        }\n    });\n"], "filenames": ["wordcount/plugin.js"], "buggy_code_start_loc": [9], "buggy_code_end_loc": [190], "fixing_code_start_loc": [9], "fixing_code_end_loc": [192], "type": "CWE-79", "message": "ckeditor-wordcount-plugin is an open source WordCount Plugin for CKEditor. It has been discovered that the `ckeditor-wordcount-plugin` plugin for CKEditor4 is susceptible to cross-site scripting when switching to the source code mode. This issue has been addressed in version 1.17.12 of the `ckeditor-wordcount-plugin` plugin and users are advised to upgrade. There are no known workarounds for this vulnerability.\n\n", "other": {"cve": {"id": "CVE-2023-37905", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-21T20:15:16.297", "lastModified": "2023-09-15T19:15:09.033", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "ckeditor-wordcount-plugin is an open source WordCount Plugin for CKEditor. It has been discovered that the `ckeditor-wordcount-plugin` plugin for CKEditor4 is susceptible to cross-site scripting when switching to the source code mode. This issue has been addressed in version 1.17.12 of the `ckeditor-wordcount-plugin` plugin and users are advised to upgrade. There are no known workarounds for this vulnerability.\n\n"}, {"lang": "es", "value": "ckeditor-wordcount-plugin es un complemento WordCount de c\u00f3digo abierto para CKEditor. Se ha descubierto que el complemento `ckeditor-wordcount-plugin` para CKEditor4 es susceptible a Cross-Site Scripting  al cambiar al modo de c\u00f3digo fuente. Este problema se solucion\u00f3 en la versi\u00f3n 1.17.12 del complemento `ckeditor-wordcount-plugin` y se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ckeditor-wordcount-plugin_project:ckeditor-wordcount-plugin:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.17.12", "matchCriteriaId": "4B7E16B7-710D-488E-BF73-81442C64AA9B"}]}]}], "references": [{"url": "https://github.com/TYPO3/typo3/security/advisories/GHSA-m8fw-p3cr-6jqc", "source": "security-advisories@github.com"}, {"url": "https://github.com/w8tcha/CKEditor-WordCount-Plugin/commit/0f03b3e5b7c1409998a13aba3a95396e6fa349d8", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/w8tcha/CKEditor-WordCount-Plugin/commit/a4b154bdf35b3465320136fcb078f196b437c2f1", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/w8tcha/CKEditor-WordCount-Plugin/security/advisories/GHSA-q9w4-w667-qqj4", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://typo3.org/security/advisory/typo3-core-sa-2023-004", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/w8tcha/CKEditor-WordCount-Plugin/commit/0f03b3e5b7c1409998a13aba3a95396e6fa349d8"}}