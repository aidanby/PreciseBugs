{"buggy_code": ["-module(yaws_cgi).\n-author('carsten@codimi.de').\n-author('brunorijsman@hotmail.com').         %% Added support for FastCGI\n\n-include(\"../include/yaws_api.hrl\").\n-include(\"yaws_debug.hrl\").\n-include(\"../include/yaws.hrl\").\n\n%%% Returns Out (i.e. same return values as out/1).\n%%%\n-export([call_cgi/5, call_cgi/4, call_cgi/3, call_cgi/2]).\n-export([call_fcgi_responder/2, call_fcgi_responder/1]).\n\n%%% Returns {allowed, Out} or {denied, Out}.\n%%%\n-export([call_fcgi_authorizer/2, call_fcgi_authorizer/1]).\n\n%%% Returns [{VariableName, VariableValue}].\n%%%\n-export([fcgi_extract_variables/1]).\n\n%%% TODO: Implement FastCGI filter role.\n\n-export([cgi_worker/7, fcgi_worker/6]).\n\n%%%=====================================================================\n%%% Code shared between CGI and FastCGI\n%%%=====================================================================\n\n-define(ASCII_NEW_LINE, 10).\n-define(ASCII_CARRIAGE_RETURN, 13).\n\n\nhandle_clidata(Arg, WorkerPid) ->\n    case Arg#arg.clidata of\n        undefined ->\n            end_of_clidata(Arg, WorkerPid);\n        {partial, Data} ->\n            send_clidata(WorkerPid, Data),\n            {get_more, cgicont, {cgistate, WorkerPid}};\n        Data when is_binary(Data) ->\n            send_clidata(WorkerPid, Data),\n            end_of_clidata(Arg, WorkerPid)\n    end.\n\n\nend_of_clidata(Arg, WorkerPid) ->\n    WorkerPid ! {self(), end_of_clidata},\n    get_from_worker(Arg, WorkerPid).\n\n\nsend_clidata(WorkerPid, Data) ->\n    WorkerPid ! {self(), clidata, Data},\n    receive\n        {WorkerPid, clidata_receipt} -> ok\n    end.\n\n\nget_from_worker(Arg, WorkerPid) ->\n    case get_resp(WorkerPid) of\n        {failure, Reason} ->\n            [{status, 500}, {html, io_lib:format(\"CGI failure: ~p\", [Reason])}];\n        {Headers, Data} ->\n            AllResps = lists:map(fun(X)-> do_header(Arg, X, Data) end, Headers),\n            %%\n            %% The CGI 1.1 spec (RFC 3875) requires a worker response\n            %% consisting of only a location header and optional extension\n            %% headers to be augmented with a 302 status code. Any other\n            %% worker response with a location header is handled normally.\n            %% Technically a response of the latter type MUST have a status\n            %% code in it, but we don't enforce that.\n            %%\n            {LocHdr, _ExtHdrs, TheRest} =\n                lists:foldl(\n                  fun({header, Line}=Hdr, {Loc, Ext, Rest}) ->\n                          {HdrLower, _HdrVal} = do_lower_header(Line),\n                          case HdrLower of\n                              \"location\" ->\n                                  {[Hdr], Ext, Rest};\n                              \"x-cgi-\"++_ ->\n                                  {Loc, [Hdr|Ext], Rest};\n                              _ ->\n                                  {Loc, Ext, [Hdr|Rest]}\n                          end;\n                     (Hdr, {Loc, Ext, Rest}) ->\n                          {Loc, Ext, [Hdr|Rest]}\n                  end, {[], [], []}, AllResps),\n            Next = case LocHdr of\n                       [] ->\n                           normal;\n                       [{header, _Location}] ->\n                           case TheRest of\n                               [] ->\n                                   location_add_302;\n                               _ ->\n                                   normal\n                           end\n                   end,\n            case Next of\n                normal ->\n                    {ContentResps, NotCtnt} =\n                        filter2(fun iscontent/1, AllResps),\n                    {RedirResps, Others} = filter2(fun isredirect/1, NotCtnt),\n                    case RedirResps of\n                        [R|_] ->\n                            WorkerPid ! {self(), no_data},\n                            Others ++ [R];\n                        [] ->\n                            case ContentResps of\n                                [C={streamcontent, _, _}|_] ->\n                                    WorkerPid ! {self(), stream_data},\n                                    Others++[C];\n                                [C={content, _, _}|_] ->\n                                    WorkerPid ! {self(), no_data},\n                                    Others++[C];\n                                [] ->\n                                    WorkerPid ! {self(), no_data},\n                                    Others\n                            end\n                    end;\n                location_add_302 ->\n                    WorkerPid ! {self(), no_data},\n                    AllResps++[{status, 302}]\n            end\n    end.\n\n\nfilter2(Pred, Xs) ->\n    filter2(Pred, Xs, [], []).\n\nfilter2(_Pred, [], Ts, Fs) ->\n    {lists:reverse(Ts), lists:reverse(Fs)};\nfilter2(Pred, [X|Xs], Ts, Fs) ->\n    case Pred(X) of\n        true ->\n            filter2(Pred, Xs, [X|Ts], Fs);\n        false ->\n            filter2(Pred, Xs, Ts, [X|Fs])\n    end.\n\n\niscontent({content, _, _}) ->\n    true;\niscontent({streamcontent, _, _}) ->\n    true;\niscontent(_) ->\n    false.\n\nisredirect({status, I}) when is_integer(I) , I > 301, I < 304; I =:= 307 ->\n    true;\nisredirect(_) ->\n    false.\n\ncheckdef(undefined) ->\n    \"\";\ncheckdef(L) ->\n    L.\n\n\ndeep_drop_prefix([], L) ->\n    L;\ndeep_drop_prefix([X|Xs], [X|Ys]) when is_integer(X) ->\n    deep_drop_prefix(Xs, Ys);\ndeep_drop_prefix([X|Xs], Ys) when is_list(X) ->\n    deep_drop_prefix(X++Xs, Ys);\ndeep_drop_prefix(Xs, [Y|Ys]) when is_list(Y) ->\n    deep_drop_prefix(Xs, Y++Ys);\ndeep_drop_prefix(_, _) ->\n    false.\n\n\nget_socket_peername({ssl, SslSocket}) ->\n    {ok, {IP, _Port}}=ssl:peername(SslSocket),\n    inet_parse:ntoa(IP);\nget_socket_peername(Socket) ->\n    {ok, {IP, _Port}}=inet:peername(Socket),\n    inet_parse:ntoa(IP).\n\n\nget_socket_sockname({ssl, SslSocket}) ->\n    {ok, {IP, _Port}}=ssl:sockname(SslSocket),\n    inet_parse:ntoa(IP);\nget_socket_sockname(Socket) ->\n    {ok, {IP, _Port}}=inet:sockname(Socket),\n    inet_parse:ntoa(IP).\n\n\nbuild_env(Arg, Scriptfilename, Pathinfo, ExtraEnv, SC) ->\n    H       = Arg#arg.headers,\n    Req     = Arg#arg.req,\n    OrigReq = Arg#arg.orig_req,\n\n    %% Use the original request to set REQUEST_URI\n    case OrigReq#http_request.path of\n        {abs_path, RequestURI} -> ok;\n        _ -> RequestURI = undefined\n    end,\n    {Maj,Min} = Req#http_request.version,\n    {Hostname, Hosttail}=lists:splitwith(fun(X)->X /= $: end,\n                                         checkdef(H#headers.host)),\n    Hostport = case Hosttail of\n                   [$: | P] -> P;\n                   [] -> integer_to_list(SC#sconf.port)\n               end,\n    PeerAddr = get_socket_peername(Arg#arg.clisock),\n    LocalAddr = get_socket_sockname(Arg#arg.clisock),\n\n    Scheme = (catch yaws:redirect_scheme(SC)),\n    %% Needed by trac, for redirs after POST\n    HttpsEnv  = case Scheme of\n                    \"https://\" -> [{\"HTTPS\", \"1\"}];\n                    _ ->[]\n                end,\n\n\n    %%Scriptname = deep_drop_prefix(Arg#arg.docroot, Arg#arg.fullpath),\n    %%SCRIPT_NAME is the path of the script relative to the root of the website.\n    %%just dropping docroot from the fullpath does not give the full SCRIPT_NAME\n    %% path if a 'vdir' is involved.\n    UriTail = deep_drop_prefix(Arg#arg.docroot, Arg#arg.fullpath),\n    case Arg#arg.docroot_mount of\n        \"/\" ->\n            %%no arg.docroot_mount means that arg.docroot\n            %% corresponds to the URI-root of the request \"/\"\n            Scriptname = UriTail;\n        Vdir ->\n            Scriptname = Vdir ++ string:strip(UriTail,left,$/)\n    end,\n\n    Pathinfo2 = checkdef(Pathinfo),\n    case Pathinfo2 of\n        \"\" ->\n            PathTranslated = \"\";\n        _ ->\n            %%determine what physical path the server would map Pathinfo2\n            %%to if it had received just Pathinfo2 in the request.\n            PathTranslated = yaws_server:mappath(SC,Arg,Pathinfo2)\n    end,\n\n\n    %%Pass auth info in environment - yes - including password in plain text.\n    %%REMOTE_USER always = AUTH_USER\n    %%!todo - LOGON_USER - same as AUTH_USER unless some auth filter has mapped\n    %%the user to another username under which to run the request.\n    case H#headers.authorization of\n        undefined ->\n            AuthEnv = [];\n        {undefined, _, _} ->\n            AuthEnv = [];\n        {User, Password, \"Basic \" ++ Auth64} ->\n            AuthEnv = [\n                       {\"HTTP_AUTHORIZATION\", \"Basic \" ++ Auth64},\n                       {\"AUTH_TYPE\", \"Basic\"},\n                       {\"AUTH_USER\", User},\n                       {\"REMOTE_USER\", User},\n                       {\"LOGON_USER\", User},\n                       {\"AUTH_PASSWORD\", Password}\n                      ];\n        {_User, _Password, _OrigString} ->\n            %%not attempting to pass through any auth info for\n            %% auth schemes that we don't yet handle\n            AuthEnv = []\n    end,\n\n    Extra_CGI_Vars = lists:flatmap(fun({Dir, Vars}) ->\n                                           case lists:prefix(Dir, Scriptname) of\n                                               true -> Vars;\n                                               false -> []\n                                           end\n                                   end,\n                                   SC#sconf.extra_cgi_vars),\n\n    %% Some versions of erlang:open_port can't handle query strings that\n    %% end with an equal sign. This is because the broken versions treat\n    %% environment variable strings ending with '=' as environment variable\n    %% names intended to be deleted from the environment, i.e. as if they\n    %% have no value. The result is that no QUERY_STRING environment\n    %% variable gets set for these cases. We work around this by appending\n    %% a & character to any query string that ends in =.\n    QueryString = case checkdef(Arg#arg.querydata) of\n                      \"\" ->\n                          \"\";\n                      QS ->\n                          case lists:reverse(QS) of\n                              [$= | _] ->\n                                  QS ++ \"&\";\n                              _ ->\n                                  QS\n                          end\n                  end,\n\n    %%todo - review. should AuthEnv entries be overridable by ExtraEnv or not?\n    %% we should define policy here rather than let through dupes.\n\n    ExtraEnv ++\n        HttpsEnv ++\n        AuthEnv ++\n        lists:filter(\n          fun({K, L}) when is_list(L) ->\n                  case lists:keysearch(K, 1, ExtraEnv) of\n                      false ->\n                          true;\n                      _ ->\n                          %% we have override in extraenv\n                          false\n                  end;\n             (_) ->\n                  false\n          end,\n          ([\n            {\"SERVER_SOFTWARE\", \"Yaws/\"++yaws_generated:version()},\n            {\"SERVER_NAME\", Hostname},\n            {\"HTTP_HOST\", checkdef(H#headers.host)},\n            {\"GATEWAY_INTERFACE\", \"CGI/1.1\"},\n            {\"SERVER_PROTOCOL\", \"HTTP/\" ++ integer_to_list(Maj) ++\n             \".\" ++ integer_to_list(Min)},\n            {\"SERVER_PORT\", Hostport},\n            {\"REQUEST_METHOD\", yaws:to_list(Req#http_request.method)},\n            {\"REQUEST_URI\", RequestURI},\n            {\"DOCUMENT_ROOT\",         Arg#arg.docroot},\n            {\"DOCUMENT_ROOT_MOUNT\", Arg#arg.docroot_mount},\n            %% SCRIPT_FILENAME is for PHP 4.3.2 and higher\n            %% see http://bugs.php.net/bug.php?id=28227\n            %% (Sergei Golovan).\n            {\"SCRIPT_FILENAME\", Scriptfilename},\n            %% {\"SCRIPT_TRANSLATED\", Scriptfilename},   %IIS6+\n            {\"PATH_INFO\",                Pathinfo2},\n            {\"PATH_TRANSLATED\",        PathTranslated},\n            %% <JMN_2007-02>\n            %%  CGI/1.1 spec says PATH_TRANSLATED should be NULL or unset\n            %% if PATH_INFO is NULL\n            %%  This is in contrast to IIS behaviour - and may break some apps.\n            %%  broken apps that expect it to always correspond to path of\n            %% script\n            %%  should be modified to use SCRIPT_FILENAME instead - or wrapped.\n            %% </JMN_2007-02>\n            %% --------------------\n            %%  <pre_2007-02_comments>\n            %%  This seems not to\n            %%  correspond to the\n            %%  documentation I have\n            %%  read, but it works\n            %%  with PHP.\n            %%\n            %%  (Not with PHP 4.3.10-16) from\n            %%  Debian sarge (Sergei Golovan).\n            %%  </pre_2007-02_comments>\n            %% ---------------------\n            {\"SCRIPT_NAME\", Scriptname},\n            {\"REMOTE_ADDR\", PeerAddr},\n            {\"REMOTE_HOST\", PeerAddr},  %%  We SHOULD send this\n            %%  Resolving DNS not practical for performance reasons\n            %%  - at least on 1st contact from a particular host.\n            %%  we could do background lookup so that it's available\n            %% for subsequent invocations,\n            %%  but it hardly seems worthwhile. We are permitted by the\n            %% CGI/1.1 spec to substitute REMOTE_ADDR\n            {\"SERVER_ADDR\", LocalAddr},   %% Apache compat\n            {\"LOCAL_ADDR\", LocalAddr},    %% IIS compat\n            {\"QUERY_STRING\", QueryString},\n            {\"CONTENT_TYPE\", H#headers.content_type},\n            {\"CONTENT_LENGTH\", H#headers.content_length},\n            {\"HTTP_ACCEPT\", H#headers.accept},\n            {\"HTTP_USER_AGENT\", H#headers.user_agent},\n            {\"HTTP_REFERER\", H#headers.referer},\n            {\"HTTP_IF_MODIFIED_SINCE\", H#headers.if_modified_since},\n            {\"HTTP_IF_MATCH\", H#headers.if_match},\n            {\"HTTP_IF_NONE_MATCH\", H#headers.if_none_match},\n            {\"HTTP_IF_UNMODIFIED_SINCE\", H#headers.if_unmodified_since},\n            {\"HTTP_COOKIE\", flatten_val(make_cookie_val(H#headers.cookie))}\n           ]++lists:map(fun({http_header,_,Var,_,Val})->{tohttp(Var),Val} end,\n                        H#headers.other)\n          )) ++\n        Extra_CGI_Vars.\n\ntohttp(X) ->\n    \"HTTP_\"++lists:map(fun tohttp_c/1, yaws:to_list(X)).\n\n\ntohttp_c($-) ->\n    $_;\n\ntohttp_c(C) when C >= $a , C =< $z ->\n    C - $a + $A;\n\ntohttp_c(C) ->\n    C.\n\n\nmake_cookie_val([]) ->\n    undefined;\nmake_cookie_val([C]) ->\n    C;\nmake_cookie_val([C|CS]) ->\n    [make_cookie_val(CS), $; | C].\n\n\n%%% Seems not to be necessary, but open_port documentation says that\n%%% value has to be a string.\n\nflatten_val(L) when is_list(L) ->\n    lists:flatten(L);\nflatten_val(X) ->\n    X.\n\n\nnotslash($/) ->\n    false;\nnotslash(_) ->\n    true.\n\n\npathof(F) ->\n    case lists:dropwhile(fun notslash/1, lists:reverse(F)) of\n        \"/\" ->\n            \"/\";\n        [$/ | Tail] -> lists:reverse(Tail)\n    end.\n\n\nexeof(F) ->\n    [$\\., $/|lists:reverse(lists:takewhile(fun notslash/1, lists:reverse(F)))].\n\n\ndo_header(_Arg, \"HTTP/1.\"++[_,_,N1,N2,N3|_], _) ->\n    {status, list_to_integer([N1,N2,N3])};\ndo_header(Arg, Header, Data) when is_list(Header) ->\n    {HdrLower, HdrVal} = do_lower_header(Header),\n    do_header(Arg, {HdrLower, yaws:join_sep(HdrVal, \":\"), Header}, Data);\ndo_header(_Arg, {\"content-type\", CT, _}, {partial_data, Data}) ->\n    {streamcontent, CT, Data};\ndo_header(_Arg, {\"content-type\", CT, _}, {all_data, Data}) ->\n    {content, CT, Data};\ndo_header(_Arg, {\"status\", [N1,N2,N3|_], _}, _) ->\n    {status, list_to_integer([N1,N2,N3])};\ndo_header(_Arg, {_, _, Line}, _) ->\n    {header, Line}.\n\ndo_lower_header(Header) ->\n    [HdrName | HdrVal] = yaws:split_sep(Header, $:),\n    HdrNmParts = [yaws:to_lower(H) || H <- yaws:split_sep(HdrName, $-)],\n    {yaws:join_sep(HdrNmParts, \"-\"), HdrVal}.\n\nget_resp(WorkerPid) ->\n    get_resp([], WorkerPid).\n\nget_resp(Hs, WorkerPid) ->\n    receive\n        {WorkerPid, header, H} ->\n            ?Debug(\"~p~n\", [{WorkerPid, header, H}]),\n            get_resp([H|Hs], WorkerPid);\n        {WorkerPid, all_data, Data} ->\n            ?Debug(\"~p~n\", [{WorkerPid, all_data, Data}]),\n            {Hs, {all_data, Data}};\n        {WorkerPid, partial_data, Data} ->\n            ?Debug(\"~p~n\", [{WorkerPid, partial_data, binary_to_list(Data)}]),\n            {Hs, {partial_data, Data}};\n        {WorkerPid, failure, Reason} ->\n            ?Debug(\"~p~n\", [{WorkerPid, failure, Reason}]),\n            {failure, Reason};\n        _Other ->\n            ?Debug(\"~p~n\", [_Other]),\n            get_resp(Hs, WorkerPid)\n    end.\n\n\nget_opt(Key, List, Default) ->\n    case lists:keysearch(Key, 1, List) of\n        {value, {_Key, Val}} -> Val;\n        _ -> Default\n    end.\n\n\n%%%==========================================================================\n%%% Code specific to CGI\n%%%==========================================================================\n\n%%%  TO DO:  Handle failure and timeouts.\n\n%%%  call_cgi calls the script `Scriptfilename' (full path).\n%%%  If `Exefilename' is given, it is the executable to handle this,\n%%%  otherwise `Scriptfilame' is assumed to be executable itself.\n%%%\n%%%  Corresponding to a URI of\n%%%     `http://somehost/some/dir/script.cgi/path/info',\n%%%  `Pathinfo' should be set to `/path/info'.\n\n%%%  These functions can be used from a `.yaws' file.\n%%%  Note however, that they usually generate stream content.\n\ncall_cgi(Arg, Scriptfilename) ->\n    call_cgi(Arg, undefined, Scriptfilename, undefined, []).\n\ncall_cgi(Arg, Exefilename, Scriptfilename) ->\n    call_cgi(Arg, Exefilename, Scriptfilename, undefined, []).\n\ncall_cgi(Arg, Exefilename, Scriptfilename, Pathinfo) ->\n    call_cgi(Arg, Exefilename, Scriptfilename, Pathinfo, []).\n\ncall_cgi(Arg, Exefilename, Scriptfilename, Pathinfo, ExtraEnv) ->\n    case Arg#arg.state of\n        {cgistate, WorkerPid} ->\n            case Arg#arg.cont of\n                cgicont ->\n                    handle_clidata(Arg, WorkerPid);\n                undefined ->\n                    ?Debug(\"Error while reading clidata: ~p~n\",\n                           [Arg#arg.clidata]),\n                    %%  Error, what to do?\n                    exit(normal)\n            end;\n        _ ->\n            WorkerPid = cgi_start_worker(Arg, Exefilename, Scriptfilename,\n                                      Pathinfo, ExtraEnv, get(sc)),\n            handle_clidata(Arg, WorkerPid)\n    end.\n\n\ncgi_start_worker(Arg, Exefilename, Scriptfilename, Pathinfo, ExtraEnv, SC) ->\n    ExeFN = case Exefilename of\n                undefined -> exeof(Scriptfilename);\n                \"\" -> exeof(Scriptfilename);\n                FN -> FN\n            end,\n    PI = case Pathinfo of\n             undefined -> Arg#arg.pathinfo;\n             OK -> OK\n         end,\n    WorkerPid = proc_lib:spawn(?MODULE, cgi_worker,\n                               [self(), Arg, ExeFN, Scriptfilename,\n                                PI, ExtraEnv, SC]),\n    WorkerPid.\n\n\n\ncgi_worker(Parent, Arg, Exefilename, Scriptfilename, Pathinfo, ExtraEnv0, SC) ->\n    ExtraEnv = lists:map(fun({K,V}) when is_binary(K), is_binary(V) ->\n                                 {binary_to_list(K), binary_to_list(V)};\n                            ({K,V}) when is_binary(K) ->\n                                 {binary_to_list(K), V};\n                            ({K,V}) when is_binary(V) ->\n                                 {K, binary_to_list(V)};\n                            (KV) -> KV\n                         end, ExtraEnv0),\n    Env = build_env(Arg, Scriptfilename, Pathinfo, ExtraEnv, SC),\n    ?Debug(\"~p~n\", [Env]),\n    CGIPort = open_port({spawn, Exefilename},\n                        [{env, Env},\n                         {cd, pathof(Scriptfilename)},\n                         exit_status,\n                         binary]),\n    cgi_pass_through_clidata(Parent, CGIPort),\n    cgi_do_work(Parent, Arg, CGIPort).\n\n\ncgi_pass_through_clidata(Parent, CGIPort) ->\n    receive\n        {Parent, clidata, Clidata} ->\n            ?Debug(\"Got clidata ~p~n\", [binary_to_list(Clidata)]),\n            Parent ! {self(), clidata_receipt},\n            CGIPort ! {self(), {command, Clidata}},\n            cgi_pass_through_clidata(Parent, CGIPort);\n        {Parent, end_of_clidata} ->\n            ?Debug(\"End of clidata~n\", []),\n            ok\n    end.\n\n\ncgi_do_work(Parent, Arg, Port) ->\n    cgi_header_loop(Parent, Arg, {start, Port}).\n\n\ncgi_header_loop(Parent, Arg, S) ->\n    Line = cgi_get_line(S),\n    ?Debug(\"Line = ~p~n\", [Line]),\n    case Line of\n        {failure, F} ->\n            Parent ! {self(), failure, F};\n        {[], T} ->\n            case T of\n                {middle, Data, Port} ->\n                    Parent ! {self(), partial_data, Data},\n                    receive\n                        {Parent, stream_data} ->\n                            cgi_data_loop(Arg#arg.pid, Port);\n                        {Parent, no_data} ->\n                            ok\n                    end;\n                {ending, Data, _} ->\n                    Parent ! {self(), all_data, Data},\n                    receive\n                        {Parent, stream_data} ->\n                            yaws_api:stream_chunk_end(Arg#arg.pid);\n                        {Parent, no_data} ->\n                            ok\n                    end\n            end;\n        {H, T} ->\n            Parent ! {self(), header, H},\n            cgi_header_loop(Parent, Arg, T)\n    end.\n\n\ncgi_data_loop(Pid, Port) ->\n    receive\n        {Port, {data,Data}} ->\n            ?Debug(\"~p~n\", [{data, binary_to_list(Data)}]),\n            yaws_api:stream_chunk_deliver_blocking(Pid, Data),\n            cgi_data_loop(Pid, Port);\n        {Port, {exit_status, _Status}} ->\n            ?Debug(\"~p~n\", [{exit_status, _Status}]),\n            yaws_api:stream_chunk_end(Pid);\n        _Other ->\n            ?Debug(\"~p~n\", [_Other]),\n            cgi_data_loop(Pid, Port)\n    end.\n\n\n\ncgi_get_line({start, Port}) ->\n    receive\n        {Port, {data,Data}} ->\n            cgi_get_line([], {middle, Data, Port});\n        {Port, {exit_status, 0}} ->\n            ?Debug(\"~p~n\", [{exit_status, 0}]),\n            cgi_get_line([], {ending, <<>>, Port});\n        {Port, {exit_status, Status}} when Status /=0 ->\n            ?Debug(\"~p~n\", [{exit_status, Status}]),\n            {failure, {exit_status, Status}};\n        _Other ->\n            ?Debug(\"~p~n\", [_Other]),\n            cgi_get_line({start, Port})\n    end;\ncgi_get_line(State) ->\n    cgi_get_line([], State).\n\ncgi_get_line(Acc, {S, <<?ASCII_NEW_LINE, Tail/binary>>, Port}) ->\n    {lists:reverse(Acc), {S, Tail, Port}};\ncgi_get_line(Acc, {S, <<?ASCII_CARRIAGE_RETURN, ?ASCII_NEW_LINE, Tail/binary>>,\n                   Port}) ->\n    {lists:reverse(Acc), {S, Tail, Port}};\ncgi_get_line(Acc, {middle, <<>>, Port}) ->\n    cgi_get_line(Acc, cgi_add_resp(<<>>, Port));\ncgi_get_line(Acc, {middle, <<?ASCII_CARRIAGE_RETURN>>, Port}) ->\n    %% We SHOULD test for CRLF.\n    %% Would be easier without.\n    cgi_get_line(Acc, cgi_add_resp(<<?ASCII_CARRIAGE_RETURN>>, Port));\ncgi_get_line(Acc, {ending, <<>>, Port}) ->\n    {lists:reverse(Acc), {ending, <<>>, Port}};\ncgi_get_line(Acc, {S, <<C, Tail/binary>>, Port}) ->\n    cgi_get_line([C|Acc], {S, Tail, Port}).\n\n\ncgi_add_resp(Bin, Port) ->\n    receive\n        {Port, {data,Data}} ->\n            {middle, <<Bin/binary, Data/binary>>, Port};\n        {Port, {exit_status, _Status}} ->\n            ?Debug(\"~p~n\", [{exit_status, _Status}]),\n            {ending, Bin, Port};\n        _Other ->\n            ?Debug(\"~p~n\", [_Other]),\n            cgi_add_resp(Bin, Port)\n    end.\n\n\n%%%===========================================================================\n%%% Code specific to FastCGI\n%%%===========================================================================\n\n-define(FCGI_VERSION_1, 1).\n\n-define(FCGI_TYPE_BEGIN_REQUEST, 1).\n%%% Not needed yet\n%%%-define(FCGI_TYPE_ABORT_REQUEST, 2).\n-define(FCGI_TYPE_END_REQUEST, 3).\n-define(FCGI_TYPE_PARAMS, 4).\n-define(FCGI_TYPE_STDIN, 5).\n-define(FCGI_TYPE_STDOUT, 6).\n-define(FCGI_TYPE_STDERR, 7).\n%%% Not needed yet\n%%%-define(FCGI_TYPE_DATA, 8).\n%%%-define(FCGI_TYPE_GET_VALUES, 9).\n%%%-define(FCGI_TYPE_GET_VALUES_RESULT, 10).\n-define(FCGI_TYPE_UNKNOWN_TYPE, 11).\n\nfcgi_type_name(?FCGI_TYPE_BEGIN_REQUEST) -> \"begin-request\";\n%%% Not needed yet\n%%%fcgi_type_name(?FCGI_TYPE_ABORT_REQUEST) -> \"abort-request\";\nfcgi_type_name(?FCGI_TYPE_END_REQUEST) -> \"end-request\";\nfcgi_type_name(?FCGI_TYPE_PARAMS) -> \"params\";\nfcgi_type_name(?FCGI_TYPE_STDIN) -> \"stdin\";\nfcgi_type_name(?FCGI_TYPE_STDOUT) -> \"stdout\";\nfcgi_type_name(?FCGI_TYPE_STDERR) -> \"stderr\";\n%%% Not needed yet\n%%%fcgi_type_name(?FCGI_TYPE_DATA) -> \"data\";\n%%%fcgi_type_name(?FCGI_TYPE_GET_VALUES) -> \"get_values\";\n%%%fcgi_type_name(?FCGI_TYPE_GET_VALUES_RESULT) -> \"get_values_result\";\nfcgi_type_name(?FCGI_TYPE_UNKNOWN_TYPE) -> \"unknown-type\".\n\n%%% The FCGI implementation does not support handling concurrent requests\n%%% over a connection; it creates a separate connection for each\n%%% request. Hence, all application records have the same request-id,\n%%% namely 1.\n%%%\n-define(FCGI_REQUEST_ID_MANAGEMENT, 0).\n-define(FCGI_REQUEST_ID_APPLICATION, 1).\n\n-define(FCGI_DONT_KEEP_CONN, 0).\n-define(FCGI_KEEP_CONN, 1).\n\n-define(FCGI_ROLE_RESPONDER, 1).\n-define(FCGI_ROLE_AUTHORIZER, 2).\n-define(FCGI_ROLE_FILTER, 3).\n\n-ifdef(debug).   % To avoid compile warning if debug is disabled.\nfcgi_role_name(?FCGI_ROLE_RESPONDER) -> \"responder\";\nfcgi_role_name(?FCGI_ROLE_AUTHORIZER) -> \"authorizer\";\nfcgi_role_name(?FCGI_ROLE_FILTER) -> \"filter\";\nfcgi_role_name(_) -> \"?\".\n-endif.\n\n-define(FCGI_STATUS_REQUEST_COMPLETE, 0).\n-define(FCGI_STATUS_CANT_MPX_CONN, 1).\n-define(FCGI_STATUS_OVERLOADED, 2).\n-define(FCGI_STATUS_UNKNOWN_ROLE, 3).\n\nfcgi_status_name(?FCGI_STATUS_REQUEST_COMPLETE) -> \"request-complete\";\nfcgi_status_name(?FCGI_STATUS_CANT_MPX_CONN) -> \"cannot-multiple-connection\";\nfcgi_status_name(?FCGI_STATUS_OVERLOADED) -> \"overloaded\";\nfcgi_status_name(?FCGI_STATUS_UNKNOWN_ROLE) -> \"unknown-role\";\nfcgi_status_name(_) -> \"?\".\n\n%%% Amount of time (in milliseconds) allowed to connect to the application\n%%% server.\n%%%\n-define(FCGI_CONNECT_TIMEOUT_MSECS, 10000).\n\n%%% Amount of time (in milliseconds) allowed for data to arrive when\n%%% reading the TCP connection to the application server.\n%%%\n-define(FCGI_READ_TIMEOUT_MSECS, 10000).\n\n%%% TODO: Implement a configurable timeout which applies to the whole\n%%% operation (as oposed to individual socket reads).\n\n-record(fcgi_worker_state, {\n            app_server_host,            % The hostname or IP address of\n                                        % the application server\n            app_server_port,            % The TCP port number of the\n                                        % application server\n            path_info,                  % The path info\n            env,                        % All environment variables to be passed\n                                        % to the application (incl the extras)\n            keep_connection,            % Delegate close authority to the\n                                        % application?\n            trace_protocol,             % If true, log info messages for sent\n                                        % and received FastCGI messages\n            log_app_error,              % If true, log error messages for\n                                        % application errors (stderr and\n                                        % non-zero exit)\n            role,                       % The role of the worker\n                                        % (responder, authorizer, filter)\n            parent_pid,                 % The PID of the parent process = the\n                                        % Yaws worker process\n            yaws_worker_pid,            % When doing chunked output, stream to\n                                        % this Yaws worker.\n            app_server_socket,          % The TCP socket to the FastCGI\n                                        % application server\n            stream_to_socket            % The TCP socket to the web browser\n                                        % (stream chunked delivery to\n                                        %  this socket)\n        }).\n\n\ncall_fcgi_responder(Arg) ->\n    call_fcgi_responder(Arg, []).\n\ncall_fcgi_responder(Arg, Options) ->\n    call_fcgi(?FCGI_ROLE_RESPONDER, Arg, Options).\n\n\ncall_fcgi_authorizer(Arg) ->\n    call_fcgi_authorizer(Arg, []).\n\ncall_fcgi_authorizer(Arg, Options) ->\n    Out = call_fcgi(?FCGI_ROLE_AUTHORIZER, Arg, Options),\n    case fcgi_is_access_allowed(Out) of\n        true ->\n            StrippedOut = strip_content_from_out(Out),\n            {allowed, StrippedOut};\n        false ->\n            {denied, Out}\n    end.\n\n\ncall_fcgi(Role, Arg, Options) ->\n    case Arg#arg.state of\n        {cgistate, WorkerPid} ->\n            case Arg#arg.cont of\n                cgicont ->\n                    ?Debug(\"Call FastCGI: continuation~n\", []),\n                    handle_clidata(Arg, WorkerPid)\n            end;\n        _ ->\n            ?Debug(\"Call FastCGI:~n\"\n                   \"  Role = ~p (~s)~n\"\n                   \"  Options = ~p~n\"\n                   \"  Arg = ~p~n\",\n                   [Role, fcgi_role_name(Role),\n                    Options,\n                    Arg]),\n            GlobalConf = get(gc),\n            ServerConf = get(sc),\n            WorkerPid = fcgi_start_worker(Role, Arg, GlobalConf, ServerConf,\n              Options),\n            handle_clidata(Arg, WorkerPid)\n    end.\n\n\nis_not_content({content, _MimeType, _Content}) -> false;\nis_not_content({streamcontent, _MimeType, _Content}) -> false;\nis_not_content(_) -> true.\n\n\nstrip_content_from_out(Out) ->\n    lists:filter(fun is_not_content/1, Out).\n\n\nfcgi_worker_fail(WorkerState, Reason) ->\n    ParentPid = WorkerState#fcgi_worker_state.parent_pid,\n    ParentPid ! {self(), failure, Reason},\n    error_logger:error_msg(\"FastCGI failure: ~p~n\", [Reason]),\n    %% exit normally to avoid filling log with crash messages\n    exit(normal).\n\nfcgi_worker_fail_if(true, WorkerState, Reason) ->\n    fcgi_worker_fail(WorkerState, Reason);\nfcgi_worker_fail_if(_Condition, _WorkerState, _Reason) ->\n    ok.\n\nfcgi_start_worker(Role, Arg, GlobalConf, ServerConf, Options) ->\n    proc_lib:spawn(?MODULE, fcgi_worker,\n                   [self(), Role, Arg, GlobalConf, ServerConf, Options]).\n\n\nfcgi_worker(ParentPid, Role, Arg, GlobalConf, ServerConf, Options) ->\n    {DefaultSvrHost, DefaultSvrPort} =\n        case ServerConf#sconf.fcgi_app_server of\n            undefined ->\n                {undefined, undefined};\n            Else ->\n                Else\n        end,\n    AppServerHost = get_opt(app_server_host, Options, DefaultSvrHost),\n    AppServerPort = get_opt(app_server_port, Options, DefaultSvrPort),\n    PreliminaryWorkerState = #fcgi_worker_state{parent_pid = ParentPid},\n    fcgi_worker_fail_if(AppServerHost == undefined, PreliminaryWorkerState,\n                        \"app server host must be configured\"),\n    fcgi_worker_fail_if(AppServerPort == undefined, PreliminaryWorkerState,\n                        \"app server port must be configured\"),\n    PathInfo = get_opt(path_info, Options, Arg#arg.pathinfo),\n    ScriptFileName = Arg#arg.fullpath,\n    ExtraEnv = get_opt(extra_env, Options, []),\n    Env = build_env(Arg, ScriptFileName, PathInfo, ExtraEnv, ServerConf),\n    TraceProtocol = get_opt(trace_protocol, Options,\n                            ?sc_fcgi_trace_protocol(ServerConf)),\n    LogAppError = get_opt(log_app_error, Options,\n                          ?sc_fcgi_log_app_error(ServerConf)),\n    TcpOptions = yaws:gconf_nslookup_pref(GlobalConf),\n    AppServerSocket =\n        fcgi_connect_to_application_server(PreliminaryWorkerState,\n                                           AppServerHost, AppServerPort,\n                                           TcpOptions),\n    ?Debug(\"Start FastCGI worker:~n\"\n           \"  Role = ~p (~s)~n\"\n           \"  AppServerHost = ~p~n\"\n           \"  AppServerPort = ~p~n\"\n           \"  PathInfo = ~p~n\"\n           \"  ExtraEnv = ~p~n\"\n           \"  TraceProtocol = ~p~n\"\n           \"  LogAppStderr = ~p~n\",\n           [Role, fcgi_role_name(Role),\n            AppServerHost,\n            AppServerPort,\n            PathInfo,\n            ExtraEnv,\n            TraceProtocol,\n            LogAppError]),\n    WorkerState = #fcgi_worker_state{\n      app_server_host = AppServerHost,\n      app_server_port = AppServerPort,\n      path_info = PathInfo,\n      env = Env,\n      keep_connection = false,                % Currently hard-coded; make\n                                              % configurable in the future?\n      trace_protocol = TraceProtocol,\n      log_app_error = LogAppError,\n      role = Role,\n      parent_pid = ParentPid,\n      yaws_worker_pid = Arg#arg.pid,\n      app_server_socket = AppServerSocket\n     },\n    fcgi_send_begin_request(WorkerState),\n    fcgi_send_params(WorkerState, Env),\n    fcgi_send_params(WorkerState, []),\n    fcgi_pass_through_client_data(WorkerState),\n    fcgi_header_loop(WorkerState),\n    gen_tcp:close(AppServerSocket),\n    ok.\n\n\nfcgi_pass_through_client_data(WorkerState) ->\n    ParentPid = WorkerState#fcgi_worker_state.parent_pid,\n    receive\n        {ParentPid, clidata, ClientData} ->\n            ParentPid ! {self(), clidata_receipt},\n            fcgi_send_stdin(WorkerState, ClientData),\n            fcgi_pass_through_client_data(WorkerState);\n        {ParentPid, end_of_clidata} ->\n            fcgi_send_stdin(WorkerState, <<>>)\n    end.\n\n\nfcgi_connect_to_application_server(WorkerState, Host, Port, TcpOptions) ->\n    Options = [binary, {packet, 0}, {active, false}, {nodelay, true} |\n      TcpOptions],\n    case yaws:tcp_connect(Host, Port, Options, ?FCGI_CONNECT_TIMEOUT_MSECS) of\n        {error, Reason} ->\n            fcgi_worker_fail(WorkerState,\n                             {\"connect to application server failed\", Reason});\n        {ok, Socket} ->\n            Socket\n    end.\n\n\nfcgi_send_begin_request(WorkerState) ->\n    %% Not needed yet -- keep_connection is currently hard-coded to false\n    %%KeepConnection = WorkerState#fcgi_worker_state.keep_connection,\n    %%Flags = case KeepConnection of\n    %%            true -> ?FCGI_KEEP_CONN;\n    %%            false -> ?FCGI_DONT_KEEP_CONN\n    %%        end,\n    Flags = ?FCGI_DONT_KEEP_CONN,\n    Role = WorkerState#fcgi_worker_state.role,\n    fcgi_send_record(WorkerState, ?FCGI_TYPE_BEGIN_REQUEST,\n                     ?FCGI_REQUEST_ID_APPLICATION, <<Role:16, Flags:8, 0:40>>).\n\n\nfcgi_send_params(WorkerState, NameValueList) ->\n    fcgi_send_record(WorkerState, ?FCGI_TYPE_PARAMS,\n                     ?FCGI_REQUEST_ID_APPLICATION, NameValueList).\n\n\nfcgi_send_stdin(WorkerState, Data) ->\n    fcgi_send_record(WorkerState, ?FCGI_TYPE_STDIN,\n                     ?FCGI_REQUEST_ID_APPLICATION, Data).\n\n\n%%% Not needed yet\n%%%\n%%% fcgi_send_data(ParentPid, Socket, Data) ->\n%%%     fcgi_send_record(ParentPid, Socket, ?FCGI_TYPE_DATA,\n%%%                      ?FCGI_REQUEST_ID_APPLICATION, Data).\n\n\n%%% Not needed yet\n%%%\n%%% fcgi_send_abort_request(ParentPid, Socket) ->\n%%%     fcgi_send_record(ParentPid, Socket, ?FCGI_TYPE_ABORT_REQUEST,\n%%%                      ?FCGI_REQUEST_ID_APPLICATION, <<>>).\n\n\nfcgi_data_to_string(Data) ->\n    fcgi_data_to_string(\"\", 0, \"\", \"\", Data).\n\nfcgi_data_to_string(LinesStr, Count, CharStr, HexStr, <<>>) ->\n    if\n        Count == 0 ->\n            LinesStr;\n        true ->\n            Padding = lists:duplicate(16 - Count, $ ),\n            LinesStr ++ \"\\n    \" ++ CharStr ++ Padding ++ \"  \" ++ HexStr\n    end;\nfcgi_data_to_string(LinesStr, Count, CharStr, HexStr,\n                    <<Byte:8, MoreData/binary>>) ->\n    Char = if\n        (Byte >= $!) and (Byte =< $~) ->\n            Byte;\n        true ->\n            $.\n    end,\n    Hex = io_lib:format(\"~2.16.0b \", [Byte]),\n    if\n        Count == 16 ->\n            fcgi_data_to_string(LinesStr ++ \"\\n    \" ++ CharStr ++ \"  \" ++\n                                HexStr, 1, [Char], Hex, MoreData);\n        true ->\n            fcgi_data_to_string(LinesStr, Count + 1, CharStr ++ [Char],\n                                HexStr ++ Hex, MoreData)\n    end.\n\n\nfcgi_trace_protocol(WorkerState, Action, Version, Type, RequestId,\n                    ContentLength, PaddingLength, Reserved, ContentData,\n                    PaddingData) ->\n    Trace = WorkerState#fcgi_worker_state.trace_protocol,\n    if\n        Trace ->\n            error_logger:info_msg(\n                \"~s FastCGI record:~n\"\n                \"  version = ~p~n\"\n                \"  type = ~p (~s)~n\"\n                \"  request-id = ~p~n\"\n                \"  content-length = ~p~n\"\n                \"  padding-length = ~p~n\"\n                \"  reserved = ~p~n\"\n                \"  content-data = ~s~n\"\n                \"  padding-data = ~s~n\",\n                [Action,\n                 Version,\n                 Type, fcgi_type_name(Type),\n                 RequestId,\n                 ContentLength,\n                 PaddingLength,\n                 Reserved,\n                 fcgi_data_to_string(ContentData),\n                 fcgi_data_to_string(PaddingData)]);\n        true ->\n            ok\n    end.\n\n\nfcgi_send_record(WorkerState, Type, RequestId, NameValueList) ->\n    EncodedRecord = fcgi_encode_record(WorkerState, Type, RequestId,\n                                       NameValueList),\n    AppServerSocket = WorkerState#fcgi_worker_state.app_server_socket,\n    case gen_tcp:send(AppServerSocket, EncodedRecord) of\n        {error, Reason} ->\n            fcgi_worker_fail(WorkerState,\n                             {\"send to application server failed\", Reason});\n        ok ->\n            ok\n    end.\n\n\nfcgi_encode_record(WorkerState, Type, RequestId, NameValueList)\n  when is_list(NameValueList) ->\n    fcgi_encode_record(WorkerState, Type, RequestId,\n                       fcgi_encode_name_value_list(NameValueList));\n\nfcgi_encode_record(WorkerState, Type, RequestId, ContentData)\n  when is_binary(ContentData), size(ContentData) > 65535  ->\n    <<Bin:65535/binary, Rest/binary>> = ContentData,\n    [fcgi_encode_record(WorkerState, Type, RequestId, Bin),\n     fcgi_encode_record(WorkerState, Type, RequestId, Rest)];\n\nfcgi_encode_record(WorkerState, Type, RequestId, ContentData)\n  when is_binary(ContentData) ->\n    Version = 1,\n    ContentLength = size(ContentData),\n    %% Add padding bytes (if needed) to content bytes to make\n    %% content plus padding a multiple of 8 bytes.\n    PaddingLength = if\n                        ContentLength rem 8 == 0 ->\n                            0;\n                        true ->\n                            8 - (ContentLength rem 8)\n                    end,\n    PaddingData = <<0:(PaddingLength * 8)>>,\n    Reserved = 0,\n    fcgi_trace_protocol(WorkerState, \"Send\", Version, Type, RequestId,\n                        ContentLength, PaddingLength, Reserved,\n                        ContentData, PaddingData),\n    <<Version:8,\n      Type:8,\n      RequestId:16,\n      ContentLength:16,\n      PaddingLength:8,\n      Reserved:8,\n      ContentData/binary,\n      PaddingData/binary>>.\n\n\nfcgi_encode_name_value_list(_NameValueList = []) ->\n    <<>>;\nfcgi_encode_name_value_list(_NameValueList = [{Name, Value} | Tail]) ->\n    <<(fcgi_encode_name_value(Name,Value))/binary,\n      (fcgi_encode_name_value_list(Tail))/binary>>.\n\n\nfcgi_encode_name_value(Name, _Value = undefined) ->\n    fcgi_encode_name_value(Name, \"\");\nfcgi_encode_name_value(Name0, Value0) ->\n    Name = unicode:characters_to_binary(Name0),\n    Value = unicode:characters_to_binary(Value0),\n    NameSize = byte_size(Name),\n    %% If name size is < 128, encode it as one byte with the high bit clear.\n    %% If the name size >= 128, encoded it as 4 bytes with the high bit set.\n    NameSizeData = if\n                       NameSize < 128 ->\n                           <<NameSize:8>>;\n                       true ->\n                           <<(NameSize bor 16#80000000):32>>\n                   end,\n    %% Same encoding for the value size.\n    ValueSize = byte_size(Value),\n    ValueSizeData = if\n                        ValueSize < 128 ->\n                            <<ValueSize:8>>;\n                        true ->\n                            <<(ValueSize bor 16#80000000):32>>\n                    end,\n    list_to_binary([<<NameSizeData/binary, ValueSizeData/binary>>, Name, Value]).\n\n\nfcgi_header_loop(WorkerState) ->\n    fcgi_header_loop(WorkerState, start).\n\nfcgi_header_loop(WorkerState, LineState) ->\n    Line = fcgi_get_line(WorkerState, LineState),\n    ParentPid = WorkerState#fcgi_worker_state.parent_pid,\n    case Line of\n        {failure, Reason} ->\n            ParentPid ! {self(), failure, Reason};\n        {_EmptyLine = [], NewLineState} ->\n            case NewLineState of\n                {middle, Data} ->\n                    case WorkerState#fcgi_worker_state.role of\n                        ?FCGI_ROLE_AUTHORIZER ->\n                            % For authorization we never stream to the client\n                            fcgi_collect_all_data_loop(WorkerState, Data);\n                        _ ->\n                            ParentPid ! {self(), partial_data, Data},\n                            receive\n                                {ParentPid, stream_data} ->\n                                    fcgi_stream_data_loop(WorkerState);\n                                {ParentPid, no_data} ->\n                                    ok\n                            end\n                    end;\n                {ending, Data} ->\n                    ParentPid ! {self(), all_data, Data},\n                    receive\n                        {ParentPid, stream_data} ->\n                            yaws_api:stream_chunk_end(\n                              WorkerState#fcgi_worker_state.yaws_worker_pid);\n                        {ParentPid, no_data} ->\n                            ok\n                    end\n            end;\n        {Header, NewLineState} ->\n            ParentPid ! {self(), header, Header},\n            fcgi_header_loop(WorkerState, NewLineState)\n    end.\n\n\nfcgi_get_line(WorkerState, start) ->\n    case fcgi_get_output(WorkerState) of\n        {data, Data} ->\n            fcgi_get_line(WorkerState, [], {middle, Data});\n        {exit_status, 0} ->\n            fcgi_get_line(WorkerState, [], {ending, <<>>});\n        {exit_status, Status} when Status /=0 ->\n            {failure, {exit_status, Status}}\n    end;\nfcgi_get_line(WorkerState, LineState) ->\n    fcgi_get_line(WorkerState, [], LineState).\n\nfcgi_get_line(_WorkerState, Acc, {State, <<?ASCII_NEW_LINE, Tail/binary>>}) ->\n    {lists:reverse(Acc), {State, Tail}};\nfcgi_get_line(_WorkerState, Acc, {State, <<?ASCII_CARRIAGE_RETURN,\n                                           ?ASCII_NEW_LINE, Tail/binary>>}) ->\n    {lists:reverse(Acc), {State, Tail}};\nfcgi_get_line(WorkerState, Acc, {middle, <<>>}) ->\n    fcgi_get_line(WorkerState, Acc, fcgi_add_resp(WorkerState, <<>>));\nfcgi_get_line(WorkerState, Acc, {middle, <<?ASCII_CARRIAGE_RETURN>>}) ->\n    fcgi_get_line(WorkerState, Acc, fcgi_add_resp(WorkerState,\n                                                  <<?ASCII_CARRIAGE_RETURN>>));\nfcgi_get_line(_WorkerState, Acc, {ending, <<>>}) ->\n    {lists:reverse(Acc), {ending, <<>>}};\nfcgi_get_line(WorkerState, Acc, {State, <<Char, Tail/binary>>}) ->\n    fcgi_get_line(WorkerState, [Char | Acc], {State, Tail}).\n\n\nfcgi_add_resp(WorkerState, OldData) ->\n    case fcgi_get_output(WorkerState) of\n        {data, NewData} ->\n            {middle, <<OldData/binary, NewData/binary>>};\n        {exit_status, _Status} ->\n            {ending, OldData}\n    end.\n\n\nfcgi_stream_data_loop(WorkerState) ->\n    YawsWorkerPid = WorkerState#fcgi_worker_state.yaws_worker_pid,\n    case catch fcgi_get_output(WorkerState) of\n        {data, Data} ->\n            yaws_api:stream_chunk_deliver_blocking(YawsWorkerPid, Data),\n            fcgi_stream_data_loop(WorkerState);\n        {exit_status, _Status} ->\n            yaws_api:stream_chunk_end(YawsWorkerPid);\n        {'EXIT', _Reason} ->\n            yaws_api:stream_chunk_end(YawsWorkerPid)\n    end.\n\n\nfcgi_collect_all_data_loop(WorkerState, Data) ->\n    YawsWorkerPid = WorkerState#fcgi_worker_state.yaws_worker_pid,\n    case fcgi_get_output(WorkerState) of\n        {data, MoreData} ->\n            NewData = <<Data/binary, MoreData/binary>>,\n            fcgi_collect_all_data_loop(WorkerState, NewData);\n        {exit_status, _Status} ->\n            ParentPid = WorkerState#fcgi_worker_state.parent_pid,\n            ParentPid ! {self(), all_data, Data},\n            receive\n                {ParentPid, stream_data} ->\n                    yaws_api:stream_chunk_end(YawsWorkerPid);\n                {ParentPid, no_data} ->\n                    ok\n            end\n    end.\n\n\nfcgi_get_output(WorkerState) ->\n    {Type, ContentData} = fcgi_receive_record(WorkerState),\n    case Type of\n        ?FCGI_TYPE_END_REQUEST ->\n            <<AppStatus:32/signed, ProtStatus:8, _Reserved:24>> = ContentData,\n            fcgi_worker_fail_if(ProtStatus < ?FCGI_STATUS_REQUEST_COMPLETE,\n                                WorkerState,\n                                {\"received unknown protocol status\",\n                                 ProtStatus}),\n            fcgi_worker_fail_if(ProtStatus > ?FCGI_STATUS_UNKNOWN_ROLE,\n                                WorkerState,\n                                {\"received unknown protocol status\",\n                                 ProtStatus}),\n            if\n                ProtStatus /= ?FCGI_STATUS_REQUEST_COMPLETE ->\n                    error_logger:error_msg(\"FastCGI protocol error: ~p (~s)~n\",\n                                           [ProtStatus,\n                                            fcgi_status_name(ProtStatus)]);\n                true ->\n                    ok\n            end,\n            if\n                (AppStatus /= 0),\n                (WorkerState#fcgi_worker_state.log_app_error) ->\n                    error_logger:error_msg(\n                      \"FastCGI application non-zero exit status: ~p~n\",\n                      [AppStatus]);\n                true ->\n                    ok\n            end,\n            {exit_status, AppStatus};\n        ?FCGI_TYPE_STDOUT ->\n            {data, ContentData};\n        ?FCGI_TYPE_STDERR ->\n            if\n                (ContentData /= <<>>),\n                (WorkerState#fcgi_worker_state.log_app_error) ->\n                    error_logger:error_msg(\n                      \"FastCGI application stderr output:~s~n\",\n                      [fcgi_data_to_string(ContentData)]);\n                true ->\n                    ok\n            end,\n            fcgi_get_output(WorkerState);\n        ?FCGI_TYPE_UNKNOWN_TYPE ->\n            <<UnknownType:8, _Reserved:56>> = ContentData,\n            fcgi_worker_fail(\n              WorkerState,\n              {\"application did not understand record type we sent\",\n               UnknownType})\n    end.\n\n\nfcgi_receive_record(WorkerState) ->\n    Header = fcgi_receive_binary(WorkerState, 8, ?FCGI_READ_TIMEOUT_MSECS),\n    <<Version:8, Type:8, RequestId:16, ContentLength:16,\n      PaddingLength:8, Reserved:8>> = Header,\n    fcgi_worker_fail_if(Version /= 1, WorkerState,\n                        {\"received unsupported version\", Version}),\n    case Type of\n        ?FCGI_TYPE_END_REQUEST ->\n            fcgi_worker_fail_if(RequestId /= ?FCGI_REQUEST_ID_APPLICATION,\n                                WorkerState,\n                                {\"unexpected request id\", RequestId}),\n            fcgi_worker_fail_if(ContentLength /= 8, WorkerState,\n                                {\"incorrect content length for end request\",\n                                 ContentLength}),\n            ok;\n        ?FCGI_TYPE_STDOUT ->\n            fcgi_worker_fail_if(RequestId /= ?FCGI_REQUEST_ID_APPLICATION,\n                                WorkerState,\n                                {\"unexpected request id\", RequestId}),\n            ok;\n        ?FCGI_TYPE_STDERR ->\n            fcgi_worker_fail_if(RequestId /= ?FCGI_REQUEST_ID_APPLICATION,\n                                WorkerState,\n                                {\"unexpected request id\", RequestId}),\n            ok;\n        ?FCGI_TYPE_UNKNOWN_TYPE ->\n            fcgi_worker_fail_if(RequestId /= ?FCGI_REQUEST_ID_MANAGEMENT,\n                                WorkerState,\n                                {\"unexpected request id\", RequestId}),\n            fcgi_worker_fail_if(ContentLength /= 8, WorkerState,\n                                {\"incorrect content length for unknown type\",\n                                 ContentLength}),\n            ok;\n        OtherType ->\n            throw({\"received unexpected type\", OtherType})\n    end,\n    ContentData = case ContentLength of\n                      0 ->\n                          <<>>;\n                      _ ->\n                          fcgi_receive_binary(WorkerState, ContentLength,\n                                              ?FCGI_READ_TIMEOUT_MSECS)\n                  end,\n    case PaddingLength of\n        0 ->\n            {Type, ContentData};\n        _ ->\n            PaddingData = fcgi_receive_binary(WorkerState, PaddingLength,\n                                              ?FCGI_READ_TIMEOUT_MSECS),\n            fcgi_trace_protocol(WorkerState, \"Receive\",\n                                Version, Type, RequestId,\n                                ContentLength, PaddingLength,\n                                Reserved, ContentData,\n                                PaddingData),\n            {Type, ContentData}\n    end.\n\n\nfcgi_receive_binary(_WorkerState, Length, _Timeout) when Length == 0 ->\n    <<>>;\nfcgi_receive_binary(WorkerState, Length, Timeout) ->\n    AppServerSocket = WorkerState#fcgi_worker_state.app_server_socket,\n    case gen_tcp:recv(AppServerSocket, Length, Timeout) of\n        {error, Reason} ->\n            fcgi_worker_fail(WorkerState,\n                             {\"recv from application server failed\", Reason});\n        {ok, Data} ->\n            Data\n    end.\n\n\n%%% Access is allowed if, and only if, the resonse from the authorizer\n%%% running on the application server contains a 200 OK status. Any other\n%%% status or absence of a status means access is denied.\n%%%\nfcgi_is_access_allowed([Head | Tail]) ->\n    fcgi_is_access_allowed(Head) orelse fcgi_is_access_allowed(Tail);\nfcgi_is_access_allowed({status, 200}) ->\n    true;\nfcgi_is_access_allowed(_AnythingElse) ->\n    false.\n\n\n%%% Look for headers of the form \"Variable-VAR_NAME: var value\"\n%%%\nfcgi_extract_variables([Head | Tail]) ->\n    fcgi_extract_variables(Head) ++ fcgi_extract_variables(Tail);\nfcgi_extract_variables({header, \"Variable-\" ++ Rest}) ->\n    [fcgi_split_header(Rest)];\nfcgi_extract_variables(_AnythingElse) ->\n    [].\n\n\nfcgi_split_header(Header) ->\n    fcgi_split_header(name, [], [], Header).\n\nfcgi_split_header(_, NameAcc, ValueAcc, \"\") ->\n    {string:strip(lists:reverse(NameAcc)),\n     string:strip(lists:reverse(ValueAcc))};\nfcgi_split_header(name, NameAcc, ValueAcc, [$: | MoreStr]) ->\n    fcgi_split_header(value, NameAcc, ValueAcc, MoreStr);\nfcgi_split_header(name, NameAcc, ValueAcc, [Char | MoreStr]) ->\n    fcgi_split_header(name, [Char | NameAcc], ValueAcc, MoreStr);\nfcgi_split_header(value, NameAcc, ValueAcc, [Char | MoreStr]) ->\n    fcgi_split_header(value, NameAcc, [Char | ValueAcc], MoreStr).\n"], "fixing_code": ["-module(yaws_cgi).\n-author('carsten@codimi.de').\n-author('brunorijsman@hotmail.com').         %% Added support for FastCGI\n\n-include(\"../include/yaws_api.hrl\").\n-include(\"yaws_debug.hrl\").\n-include(\"../include/yaws.hrl\").\n\n%%% Returns Out (i.e. same return values as out/1).\n%%%\n-export([call_cgi/5, call_cgi/4, call_cgi/3, call_cgi/2]).\n-export([call_fcgi_responder/2, call_fcgi_responder/1]).\n\n%%% Returns {allowed, Out} or {denied, Out}.\n%%%\n-export([call_fcgi_authorizer/2, call_fcgi_authorizer/1]).\n\n%%% Returns [{VariableName, VariableValue}].\n%%%\n-export([fcgi_extract_variables/1]).\n\n%%% TODO: Implement FastCGI filter role.\n\n-export([cgi_worker/7, fcgi_worker/6]).\n\n%%%=====================================================================\n%%% Code shared between CGI and FastCGI\n%%%=====================================================================\n\n-define(ASCII_NEW_LINE, 10).\n-define(ASCII_CARRIAGE_RETURN, 13).\n\n\nhandle_clidata(Arg, WorkerPid) ->\n    case Arg#arg.clidata of\n        undefined ->\n            end_of_clidata(Arg, WorkerPid);\n        {partial, Data} ->\n            send_clidata(WorkerPid, Data),\n            {get_more, cgicont, {cgistate, WorkerPid}};\n        Data when is_binary(Data) ->\n            send_clidata(WorkerPid, Data),\n            end_of_clidata(Arg, WorkerPid)\n    end.\n\n\nend_of_clidata(Arg, WorkerPid) ->\n    WorkerPid ! {self(), end_of_clidata},\n    get_from_worker(Arg, WorkerPid).\n\n\nsend_clidata(WorkerPid, Data) ->\n    WorkerPid ! {self(), clidata, Data},\n    receive\n        {WorkerPid, clidata_receipt} -> ok\n    end.\n\n\nget_from_worker(Arg, WorkerPid) ->\n    case get_resp(WorkerPid) of\n        {failure, Reason} ->\n            [{status, 500}, {html, io_lib:format(\"CGI failure: ~p\", [Reason])}];\n        {Headers, Data} ->\n            AllResps = lists:map(fun(X)-> do_header(Arg, X, Data) end, Headers),\n            %%\n            %% The CGI 1.1 spec (RFC 3875) requires a worker response\n            %% consisting of only a location header and optional extension\n            %% headers to be augmented with a 302 status code. Any other\n            %% worker response with a location header is handled normally.\n            %% Technically a response of the latter type MUST have a status\n            %% code in it, but we don't enforce that.\n            %%\n            {LocHdr, _ExtHdrs, TheRest} =\n                lists:foldl(\n                  fun({header, Line}=Hdr, {Loc, Ext, Rest}) ->\n                          {HdrLower, _HdrVal} = do_lower_header(Line),\n                          case HdrLower of\n                              \"location\" ->\n                                  {[Hdr], Ext, Rest};\n                              \"x-cgi-\"++_ ->\n                                  {Loc, [Hdr|Ext], Rest};\n                              _ ->\n                                  {Loc, Ext, [Hdr|Rest]}\n                          end;\n                     (Hdr, {Loc, Ext, Rest}) ->\n                          {Loc, Ext, [Hdr|Rest]}\n                  end, {[], [], []}, AllResps),\n            Next = case LocHdr of\n                       [] ->\n                           normal;\n                       [{header, _Location}] ->\n                           case TheRest of\n                               [] ->\n                                   location_add_302;\n                               _ ->\n                                   normal\n                           end\n                   end,\n            case Next of\n                normal ->\n                    {ContentResps, NotCtnt} =\n                        filter2(fun iscontent/1, AllResps),\n                    {RedirResps, Others} = filter2(fun isredirect/1, NotCtnt),\n                    case RedirResps of\n                        [R|_] ->\n                            WorkerPid ! {self(), no_data},\n                            Others ++ [R];\n                        [] ->\n                            case ContentResps of\n                                [C={streamcontent, _, _}|_] ->\n                                    WorkerPid ! {self(), stream_data},\n                                    Others++[C];\n                                [C={content, _, _}|_] ->\n                                    WorkerPid ! {self(), no_data},\n                                    Others++[C];\n                                [] ->\n                                    WorkerPid ! {self(), no_data},\n                                    Others\n                            end\n                    end;\n                location_add_302 ->\n                    WorkerPid ! {self(), no_data},\n                    AllResps++[{status, 302}]\n            end\n    end.\n\n\nfilter2(Pred, Xs) ->\n    filter2(Pred, Xs, [], []).\n\nfilter2(_Pred, [], Ts, Fs) ->\n    {lists:reverse(Ts), lists:reverse(Fs)};\nfilter2(Pred, [X|Xs], Ts, Fs) ->\n    case Pred(X) of\n        true ->\n            filter2(Pred, Xs, [X|Ts], Fs);\n        false ->\n            filter2(Pred, Xs, Ts, [X|Fs])\n    end.\n\n\niscontent({content, _, _}) ->\n    true;\niscontent({streamcontent, _, _}) ->\n    true;\niscontent(_) ->\n    false.\n\nisredirect({status, I}) when is_integer(I) , I > 301, I < 304; I =:= 307 ->\n    true;\nisredirect(_) ->\n    false.\n\ncheckdef(undefined) ->\n    \"\";\ncheckdef(L) ->\n    L.\n\n\ndeep_drop_prefix([], L) ->\n    L;\ndeep_drop_prefix([X|Xs], [X|Ys]) when is_integer(X) ->\n    deep_drop_prefix(Xs, Ys);\ndeep_drop_prefix([X|Xs], Ys) when is_list(X) ->\n    deep_drop_prefix(X++Xs, Ys);\ndeep_drop_prefix(Xs, [Y|Ys]) when is_list(Y) ->\n    deep_drop_prefix(Xs, Y++Ys);\ndeep_drop_prefix(_, _) ->\n    false.\n\n\nget_socket_peername({ssl, SslSocket}) ->\n    {ok, {IP, _Port}}=ssl:peername(SslSocket),\n    inet_parse:ntoa(IP);\nget_socket_peername(Socket) ->\n    {ok, {IP, _Port}}=inet:peername(Socket),\n    inet_parse:ntoa(IP).\n\n\nget_socket_sockname({ssl, SslSocket}) ->\n    {ok, {IP, _Port}}=ssl:sockname(SslSocket),\n    inet_parse:ntoa(IP);\nget_socket_sockname(Socket) ->\n    {ok, {IP, _Port}}=inet:sockname(Socket),\n    inet_parse:ntoa(IP).\n\n\nbuild_env(Arg, Scriptfilename, Pathinfo, ExtraEnv, SC) ->\n    H       = Arg#arg.headers,\n    Req     = Arg#arg.req,\n    OrigReq = Arg#arg.orig_req,\n\n    %% Use the original request to set REQUEST_URI\n    case OrigReq#http_request.path of\n        {abs_path, RequestURI} -> ok;\n        _ -> RequestURI = undefined\n    end,\n    {Maj,Min} = Req#http_request.version,\n    {Hostname, Hosttail}=lists:splitwith(fun(X)->X /= $: end,\n                                         checkdef(H#headers.host)),\n    Hostport = case Hosttail of\n                   [$: | P] -> P;\n                   [] -> integer_to_list(SC#sconf.port)\n               end,\n    PeerAddr = get_socket_peername(Arg#arg.clisock),\n    LocalAddr = get_socket_sockname(Arg#arg.clisock),\n\n    Scheme = (catch yaws:redirect_scheme(SC)),\n    %% Needed by trac, for redirs after POST\n    HttpsEnv  = case Scheme of\n                    \"https://\" -> [{\"HTTPS\", \"1\"}];\n                    _ ->[]\n                end,\n\n\n    %%Scriptname = deep_drop_prefix(Arg#arg.docroot, Arg#arg.fullpath),\n    %%SCRIPT_NAME is the path of the script relative to the root of the website.\n    %%just dropping docroot from the fullpath does not give the full SCRIPT_NAME\n    %% path if a 'vdir' is involved.\n    UriTail = deep_drop_prefix(Arg#arg.docroot, Arg#arg.fullpath),\n    case Arg#arg.docroot_mount of\n        \"/\" ->\n            %%no arg.docroot_mount means that arg.docroot\n            %% corresponds to the URI-root of the request \"/\"\n            Scriptname = UriTail;\n        Vdir ->\n            Scriptname = Vdir ++ string:strip(UriTail,left,$/)\n    end,\n\n    Pathinfo2 = checkdef(Pathinfo),\n    case Pathinfo2 of\n        \"\" ->\n            PathTranslated = \"\";\n        _ ->\n            %%determine what physical path the server would map Pathinfo2\n            %%to if it had received just Pathinfo2 in the request.\n            PathTranslated = yaws_server:mappath(SC,Arg,Pathinfo2)\n    end,\n\n\n    %%Pass auth info in environment - yes - including password in plain text.\n    %%REMOTE_USER always = AUTH_USER\n    %%!todo - LOGON_USER - same as AUTH_USER unless some auth filter has mapped\n    %%the user to another username under which to run the request.\n    case H#headers.authorization of\n        undefined ->\n            AuthEnv = [];\n        {undefined, _, _} ->\n            AuthEnv = [];\n        {User, Password, \"Basic \" ++ Auth64} ->\n            AuthEnv = [\n                       {\"HTTP_AUTHORIZATION\", \"Basic \" ++ Auth64},\n                       {\"AUTH_TYPE\", \"Basic\"},\n                       {\"AUTH_USER\", User},\n                       {\"REMOTE_USER\", User},\n                       {\"LOGON_USER\", User},\n                       {\"AUTH_PASSWORD\", Password}\n                      ];\n        {_User, _Password, _OrigString} ->\n            %%not attempting to pass through any auth info for\n            %% auth schemes that we don't yet handle\n            AuthEnv = []\n    end,\n\n    Extra_CGI_Vars = lists:flatmap(fun({Dir, Vars}) ->\n                                           case lists:prefix(Dir, Scriptname) of\n                                               true -> Vars;\n                                               false -> []\n                                           end\n                                   end,\n                                   SC#sconf.extra_cgi_vars),\n\n    %% Some versions of erlang:open_port can't handle query strings that\n    %% end with an equal sign. This is because the broken versions treat\n    %% environment variable strings ending with '=' as environment variable\n    %% names intended to be deleted from the environment, i.e. as if they\n    %% have no value. The result is that no QUERY_STRING environment\n    %% variable gets set for these cases. We work around this by appending\n    %% a & character to any query string that ends in =.\n    QueryString = case checkdef(Arg#arg.querydata) of\n                      \"\" ->\n                          \"\";\n                      QS ->\n                          case lists:reverse(QS) of\n                              [$= | _] ->\n                                  QS ++ \"&\";\n                              _ ->\n                                  QS\n                          end\n                  end,\n\n    %%todo - review. should AuthEnv entries be overridable by ExtraEnv or not?\n    %% we should define policy here rather than let through dupes.\n\n    ExtraEnv ++\n        HttpsEnv ++\n        AuthEnv ++\n        lists:filter(\n          fun({K, L}) when is_list(L) ->\n                  case lists:keysearch(K, 1, ExtraEnv) of\n                      false ->\n                          true;\n                      _ ->\n                          %% we have override in extraenv\n                          false\n                  end;\n             (_) ->\n                  false\n          end,\n          ([\n            {\"SERVER_SOFTWARE\", \"Yaws/\"++yaws_generated:version()},\n            {\"SERVER_NAME\", Hostname},\n            {\"HTTP_HOST\", checkdef(H#headers.host)},\n            {\"GATEWAY_INTERFACE\", \"CGI/1.1\"},\n            {\"SERVER_PROTOCOL\", \"HTTP/\" ++ integer_to_list(Maj) ++\n             \".\" ++ integer_to_list(Min)},\n            {\"SERVER_PORT\", Hostport},\n            {\"REQUEST_METHOD\", yaws:to_list(Req#http_request.method)},\n            {\"REQUEST_URI\", RequestURI},\n            {\"DOCUMENT_ROOT\",         Arg#arg.docroot},\n            {\"DOCUMENT_ROOT_MOUNT\", Arg#arg.docroot_mount},\n            %% SCRIPT_FILENAME is for PHP 4.3.2 and higher\n            %% see http://bugs.php.net/bug.php?id=28227\n            %% (Sergei Golovan).\n            {\"SCRIPT_FILENAME\", Scriptfilename},\n            %% {\"SCRIPT_TRANSLATED\", Scriptfilename},   %IIS6+\n            {\"PATH_INFO\",                Pathinfo2},\n            {\"PATH_TRANSLATED\",        PathTranslated},\n            %% <JMN_2007-02>\n            %%  CGI/1.1 spec says PATH_TRANSLATED should be NULL or unset\n            %% if PATH_INFO is NULL\n            %%  This is in contrast to IIS behaviour - and may break some apps.\n            %%  broken apps that expect it to always correspond to path of\n            %% script\n            %%  should be modified to use SCRIPT_FILENAME instead - or wrapped.\n            %% </JMN_2007-02>\n            %% --------------------\n            %%  <pre_2007-02_comments>\n            %%  This seems not to\n            %%  correspond to the\n            %%  documentation I have\n            %%  read, but it works\n            %%  with PHP.\n            %%\n            %%  (Not with PHP 4.3.10-16) from\n            %%  Debian sarge (Sergei Golovan).\n            %%  </pre_2007-02_comments>\n            %% ---------------------\n            {\"SCRIPT_NAME\", Scriptname},\n            {\"REMOTE_ADDR\", PeerAddr},\n            {\"REMOTE_HOST\", PeerAddr},  %%  We SHOULD send this\n            %%  Resolving DNS not practical for performance reasons\n            %%  - at least on 1st contact from a particular host.\n            %%  we could do background lookup so that it's available\n            %% for subsequent invocations,\n            %%  but it hardly seems worthwhile. We are permitted by the\n            %% CGI/1.1 spec to substitute REMOTE_ADDR\n            {\"SERVER_ADDR\", LocalAddr},   %% Apache compat\n            {\"LOCAL_ADDR\", LocalAddr},    %% IIS compat\n            {\"QUERY_STRING\", QueryString},\n            {\"CONTENT_TYPE\", H#headers.content_type},\n            {\"CONTENT_LENGTH\", H#headers.content_length},\n            {\"HTTP_ACCEPT\", H#headers.accept},\n            {\"HTTP_USER_AGENT\", H#headers.user_agent},\n            {\"HTTP_REFERER\", H#headers.referer},\n            {\"HTTP_IF_MODIFIED_SINCE\", H#headers.if_modified_since},\n            {\"HTTP_IF_MATCH\", H#headers.if_match},\n            {\"HTTP_IF_NONE_MATCH\", H#headers.if_none_match},\n            {\"HTTP_IF_UNMODIFIED_SINCE\", H#headers.if_unmodified_since},\n            {\"HTTP_COOKIE\", flatten_val(make_cookie_val(H#headers.cookie))}\n           ]++ other_headers(H#headers.other)\n          )) ++\n        Extra_CGI_Vars.\n\nother_headers(Headers) ->\n    lists:zf(fun({http_header,_,Var,_,Val}) ->\n                     case tohttp(Var) of\n                         \"HTTP_PROXY\" ->\n                             %% See http://httpoxy.org/\n                             false;\n                         HTTP ->\n                             {true, {HTTP,Val}}\n                     end\n             end, Headers).\n\ntohttp(X) ->\n    \"HTTP_\"++lists:map(fun tohttp_c/1, yaws:to_list(X)).\n\n\ntohttp_c($-) ->\n    $_;\n\ntohttp_c(C) when C >= $a , C =< $z ->\n    C - $a + $A;\n\ntohttp_c(C) ->\n    C.\n\n\nmake_cookie_val([]) ->\n    undefined;\nmake_cookie_val([C]) ->\n    C;\nmake_cookie_val([C|CS]) ->\n    [make_cookie_val(CS), $; | C].\n\n\n%%% Seems not to be necessary, but open_port documentation says that\n%%% value has to be a string.\n\nflatten_val(L) when is_list(L) ->\n    lists:flatten(L);\nflatten_val(X) ->\n    X.\n\n\nnotslash($/) ->\n    false;\nnotslash(_) ->\n    true.\n\n\npathof(F) ->\n    case lists:dropwhile(fun notslash/1, lists:reverse(F)) of\n        \"/\" ->\n            \"/\";\n        [$/ | Tail] -> lists:reverse(Tail)\n    end.\n\n\nexeof(F) ->\n    [$\\., $/|lists:reverse(lists:takewhile(fun notslash/1, lists:reverse(F)))].\n\n\ndo_header(_Arg, \"HTTP/1.\"++[_,_,N1,N2,N3|_], _) ->\n    {status, list_to_integer([N1,N2,N3])};\ndo_header(Arg, Header, Data) when is_list(Header) ->\n    {HdrLower, HdrVal} = do_lower_header(Header),\n    do_header(Arg, {HdrLower, yaws:join_sep(HdrVal, \":\"), Header}, Data);\ndo_header(_Arg, {\"content-type\", CT, _}, {partial_data, Data}) ->\n    {streamcontent, CT, Data};\ndo_header(_Arg, {\"content-type\", CT, _}, {all_data, Data}) ->\n    {content, CT, Data};\ndo_header(_Arg, {\"status\", [N1,N2,N3|_], _}, _) ->\n    {status, list_to_integer([N1,N2,N3])};\ndo_header(_Arg, {_, _, Line}, _) ->\n    {header, Line}.\n\ndo_lower_header(Header) ->\n    [HdrName | HdrVal] = yaws:split_sep(Header, $:),\n    HdrNmParts = [yaws:to_lower(H) || H <- yaws:split_sep(HdrName, $-)],\n    {yaws:join_sep(HdrNmParts, \"-\"), HdrVal}.\n\nget_resp(WorkerPid) ->\n    get_resp([], WorkerPid).\n\nget_resp(Hs, WorkerPid) ->\n    receive\n        {WorkerPid, header, H} ->\n            ?Debug(\"~p~n\", [{WorkerPid, header, H}]),\n            get_resp([H|Hs], WorkerPid);\n        {WorkerPid, all_data, Data} ->\n            ?Debug(\"~p~n\", [{WorkerPid, all_data, Data}]),\n            {Hs, {all_data, Data}};\n        {WorkerPid, partial_data, Data} ->\n            ?Debug(\"~p~n\", [{WorkerPid, partial_data, binary_to_list(Data)}]),\n            {Hs, {partial_data, Data}};\n        {WorkerPid, failure, Reason} ->\n            ?Debug(\"~p~n\", [{WorkerPid, failure, Reason}]),\n            {failure, Reason};\n        _Other ->\n            ?Debug(\"~p~n\", [_Other]),\n            get_resp(Hs, WorkerPid)\n    end.\n\n\nget_opt(Key, List, Default) ->\n    case lists:keysearch(Key, 1, List) of\n        {value, {_Key, Val}} -> Val;\n        _ -> Default\n    end.\n\n\n%%%==========================================================================\n%%% Code specific to CGI\n%%%==========================================================================\n\n%%%  TO DO:  Handle failure and timeouts.\n\n%%%  call_cgi calls the script `Scriptfilename' (full path).\n%%%  If `Exefilename' is given, it is the executable to handle this,\n%%%  otherwise `Scriptfilame' is assumed to be executable itself.\n%%%\n%%%  Corresponding to a URI of\n%%%     `http://somehost/some/dir/script.cgi/path/info',\n%%%  `Pathinfo' should be set to `/path/info'.\n\n%%%  These functions can be used from a `.yaws' file.\n%%%  Note however, that they usually generate stream content.\n\ncall_cgi(Arg, Scriptfilename) ->\n    call_cgi(Arg, undefined, Scriptfilename, undefined, []).\n\ncall_cgi(Arg, Exefilename, Scriptfilename) ->\n    call_cgi(Arg, Exefilename, Scriptfilename, undefined, []).\n\ncall_cgi(Arg, Exefilename, Scriptfilename, Pathinfo) ->\n    call_cgi(Arg, Exefilename, Scriptfilename, Pathinfo, []).\n\ncall_cgi(Arg, Exefilename, Scriptfilename, Pathinfo, ExtraEnv) ->\n    case Arg#arg.state of\n        {cgistate, WorkerPid} ->\n            case Arg#arg.cont of\n                cgicont ->\n                    handle_clidata(Arg, WorkerPid);\n                undefined ->\n                    ?Debug(\"Error while reading clidata: ~p~n\",\n                           [Arg#arg.clidata]),\n                    %%  Error, what to do?\n                    exit(normal)\n            end;\n        _ ->\n            WorkerPid = cgi_start_worker(Arg, Exefilename, Scriptfilename,\n                                      Pathinfo, ExtraEnv, get(sc)),\n            handle_clidata(Arg, WorkerPid)\n    end.\n\n\ncgi_start_worker(Arg, Exefilename, Scriptfilename, Pathinfo, ExtraEnv, SC) ->\n    ExeFN = case Exefilename of\n                undefined -> exeof(Scriptfilename);\n                \"\" -> exeof(Scriptfilename);\n                FN -> FN\n            end,\n    PI = case Pathinfo of\n             undefined -> Arg#arg.pathinfo;\n             OK -> OK\n         end,\n    WorkerPid = proc_lib:spawn(?MODULE, cgi_worker,\n                               [self(), Arg, ExeFN, Scriptfilename,\n                                PI, ExtraEnv, SC]),\n    WorkerPid.\n\n\n\ncgi_worker(Parent, Arg, Exefilename, Scriptfilename, Pathinfo, ExtraEnv0, SC) ->\n    ExtraEnv = lists:map(fun({K,V}) when is_binary(K), is_binary(V) ->\n                                 {binary_to_list(K), binary_to_list(V)};\n                            ({K,V}) when is_binary(K) ->\n                                 {binary_to_list(K), V};\n                            ({K,V}) when is_binary(V) ->\n                                 {K, binary_to_list(V)};\n                            (KV) -> KV\n                         end, ExtraEnv0),\n    Env = build_env(Arg, Scriptfilename, Pathinfo, ExtraEnv, SC),\n    ?Debug(\"~p~n\", [Env]),\n    CGIPort = open_port({spawn, Exefilename},\n                        [{env, Env},\n                         {cd, pathof(Scriptfilename)},\n                         exit_status,\n                         binary]),\n    cgi_pass_through_clidata(Parent, CGIPort),\n    cgi_do_work(Parent, Arg, CGIPort).\n\n\ncgi_pass_through_clidata(Parent, CGIPort) ->\n    receive\n        {Parent, clidata, Clidata} ->\n            ?Debug(\"Got clidata ~p~n\", [binary_to_list(Clidata)]),\n            Parent ! {self(), clidata_receipt},\n            CGIPort ! {self(), {command, Clidata}},\n            cgi_pass_through_clidata(Parent, CGIPort);\n        {Parent, end_of_clidata} ->\n            ?Debug(\"End of clidata~n\", []),\n            ok\n    end.\n\n\ncgi_do_work(Parent, Arg, Port) ->\n    cgi_header_loop(Parent, Arg, {start, Port}).\n\n\ncgi_header_loop(Parent, Arg, S) ->\n    Line = cgi_get_line(S),\n    ?Debug(\"Line = ~p~n\", [Line]),\n    case Line of\n        {failure, F} ->\n            Parent ! {self(), failure, F};\n        {[], T} ->\n            case T of\n                {middle, Data, Port} ->\n                    Parent ! {self(), partial_data, Data},\n                    receive\n                        {Parent, stream_data} ->\n                            cgi_data_loop(Arg#arg.pid, Port);\n                        {Parent, no_data} ->\n                            ok\n                    end;\n                {ending, Data, _} ->\n                    Parent ! {self(), all_data, Data},\n                    receive\n                        {Parent, stream_data} ->\n                            yaws_api:stream_chunk_end(Arg#arg.pid);\n                        {Parent, no_data} ->\n                            ok\n                    end\n            end;\n        {H, T} ->\n            Parent ! {self(), header, H},\n            cgi_header_loop(Parent, Arg, T)\n    end.\n\n\ncgi_data_loop(Pid, Port) ->\n    receive\n        {Port, {data,Data}} ->\n            ?Debug(\"~p~n\", [{data, binary_to_list(Data)}]),\n            yaws_api:stream_chunk_deliver_blocking(Pid, Data),\n            cgi_data_loop(Pid, Port);\n        {Port, {exit_status, _Status}} ->\n            ?Debug(\"~p~n\", [{exit_status, _Status}]),\n            yaws_api:stream_chunk_end(Pid);\n        _Other ->\n            ?Debug(\"~p~n\", [_Other]),\n            cgi_data_loop(Pid, Port)\n    end.\n\n\n\ncgi_get_line({start, Port}) ->\n    receive\n        {Port, {data,Data}} ->\n            cgi_get_line([], {middle, Data, Port});\n        {Port, {exit_status, 0}} ->\n            ?Debug(\"~p~n\", [{exit_status, 0}]),\n            cgi_get_line([], {ending, <<>>, Port});\n        {Port, {exit_status, Status}} when Status /=0 ->\n            ?Debug(\"~p~n\", [{exit_status, Status}]),\n            {failure, {exit_status, Status}};\n        _Other ->\n            ?Debug(\"~p~n\", [_Other]),\n            cgi_get_line({start, Port})\n    end;\ncgi_get_line(State) ->\n    cgi_get_line([], State).\n\ncgi_get_line(Acc, {S, <<?ASCII_NEW_LINE, Tail/binary>>, Port}) ->\n    {lists:reverse(Acc), {S, Tail, Port}};\ncgi_get_line(Acc, {S, <<?ASCII_CARRIAGE_RETURN, ?ASCII_NEW_LINE, Tail/binary>>,\n                   Port}) ->\n    {lists:reverse(Acc), {S, Tail, Port}};\ncgi_get_line(Acc, {middle, <<>>, Port}) ->\n    cgi_get_line(Acc, cgi_add_resp(<<>>, Port));\ncgi_get_line(Acc, {middle, <<?ASCII_CARRIAGE_RETURN>>, Port}) ->\n    %% We SHOULD test for CRLF.\n    %% Would be easier without.\n    cgi_get_line(Acc, cgi_add_resp(<<?ASCII_CARRIAGE_RETURN>>, Port));\ncgi_get_line(Acc, {ending, <<>>, Port}) ->\n    {lists:reverse(Acc), {ending, <<>>, Port}};\ncgi_get_line(Acc, {S, <<C, Tail/binary>>, Port}) ->\n    cgi_get_line([C|Acc], {S, Tail, Port}).\n\n\ncgi_add_resp(Bin, Port) ->\n    receive\n        {Port, {data,Data}} ->\n            {middle, <<Bin/binary, Data/binary>>, Port};\n        {Port, {exit_status, _Status}} ->\n            ?Debug(\"~p~n\", [{exit_status, _Status}]),\n            {ending, Bin, Port};\n        _Other ->\n            ?Debug(\"~p~n\", [_Other]),\n            cgi_add_resp(Bin, Port)\n    end.\n\n\n%%%===========================================================================\n%%% Code specific to FastCGI\n%%%===========================================================================\n\n-define(FCGI_VERSION_1, 1).\n\n-define(FCGI_TYPE_BEGIN_REQUEST, 1).\n%%% Not needed yet\n%%%-define(FCGI_TYPE_ABORT_REQUEST, 2).\n-define(FCGI_TYPE_END_REQUEST, 3).\n-define(FCGI_TYPE_PARAMS, 4).\n-define(FCGI_TYPE_STDIN, 5).\n-define(FCGI_TYPE_STDOUT, 6).\n-define(FCGI_TYPE_STDERR, 7).\n%%% Not needed yet\n%%%-define(FCGI_TYPE_DATA, 8).\n%%%-define(FCGI_TYPE_GET_VALUES, 9).\n%%%-define(FCGI_TYPE_GET_VALUES_RESULT, 10).\n-define(FCGI_TYPE_UNKNOWN_TYPE, 11).\n\nfcgi_type_name(?FCGI_TYPE_BEGIN_REQUEST) -> \"begin-request\";\n%%% Not needed yet\n%%%fcgi_type_name(?FCGI_TYPE_ABORT_REQUEST) -> \"abort-request\";\nfcgi_type_name(?FCGI_TYPE_END_REQUEST) -> \"end-request\";\nfcgi_type_name(?FCGI_TYPE_PARAMS) -> \"params\";\nfcgi_type_name(?FCGI_TYPE_STDIN) -> \"stdin\";\nfcgi_type_name(?FCGI_TYPE_STDOUT) -> \"stdout\";\nfcgi_type_name(?FCGI_TYPE_STDERR) -> \"stderr\";\n%%% Not needed yet\n%%%fcgi_type_name(?FCGI_TYPE_DATA) -> \"data\";\n%%%fcgi_type_name(?FCGI_TYPE_GET_VALUES) -> \"get_values\";\n%%%fcgi_type_name(?FCGI_TYPE_GET_VALUES_RESULT) -> \"get_values_result\";\nfcgi_type_name(?FCGI_TYPE_UNKNOWN_TYPE) -> \"unknown-type\".\n\n%%% The FCGI implementation does not support handling concurrent requests\n%%% over a connection; it creates a separate connection for each\n%%% request. Hence, all application records have the same request-id,\n%%% namely 1.\n%%%\n-define(FCGI_REQUEST_ID_MANAGEMENT, 0).\n-define(FCGI_REQUEST_ID_APPLICATION, 1).\n\n-define(FCGI_DONT_KEEP_CONN, 0).\n-define(FCGI_KEEP_CONN, 1).\n\n-define(FCGI_ROLE_RESPONDER, 1).\n-define(FCGI_ROLE_AUTHORIZER, 2).\n-define(FCGI_ROLE_FILTER, 3).\n\n-ifdef(debug).   % To avoid compile warning if debug is disabled.\nfcgi_role_name(?FCGI_ROLE_RESPONDER) -> \"responder\";\nfcgi_role_name(?FCGI_ROLE_AUTHORIZER) -> \"authorizer\";\nfcgi_role_name(?FCGI_ROLE_FILTER) -> \"filter\";\nfcgi_role_name(_) -> \"?\".\n-endif.\n\n-define(FCGI_STATUS_REQUEST_COMPLETE, 0).\n-define(FCGI_STATUS_CANT_MPX_CONN, 1).\n-define(FCGI_STATUS_OVERLOADED, 2).\n-define(FCGI_STATUS_UNKNOWN_ROLE, 3).\n\nfcgi_status_name(?FCGI_STATUS_REQUEST_COMPLETE) -> \"request-complete\";\nfcgi_status_name(?FCGI_STATUS_CANT_MPX_CONN) -> \"cannot-multiple-connection\";\nfcgi_status_name(?FCGI_STATUS_OVERLOADED) -> \"overloaded\";\nfcgi_status_name(?FCGI_STATUS_UNKNOWN_ROLE) -> \"unknown-role\";\nfcgi_status_name(_) -> \"?\".\n\n%%% Amount of time (in milliseconds) allowed to connect to the application\n%%% server.\n%%%\n-define(FCGI_CONNECT_TIMEOUT_MSECS, 10000).\n\n%%% Amount of time (in milliseconds) allowed for data to arrive when\n%%% reading the TCP connection to the application server.\n%%%\n-define(FCGI_READ_TIMEOUT_MSECS, 10000).\n\n%%% TODO: Implement a configurable timeout which applies to the whole\n%%% operation (as oposed to individual socket reads).\n\n-record(fcgi_worker_state, {\n            app_server_host,            % The hostname or IP address of\n                                        % the application server\n            app_server_port,            % The TCP port number of the\n                                        % application server\n            path_info,                  % The path info\n            env,                        % All environment variables to be passed\n                                        % to the application (incl the extras)\n            keep_connection,            % Delegate close authority to the\n                                        % application?\n            trace_protocol,             % If true, log info messages for sent\n                                        % and received FastCGI messages\n            log_app_error,              % If true, log error messages for\n                                        % application errors (stderr and\n                                        % non-zero exit)\n            role,                       % The role of the worker\n                                        % (responder, authorizer, filter)\n            parent_pid,                 % The PID of the parent process = the\n                                        % Yaws worker process\n            yaws_worker_pid,            % When doing chunked output, stream to\n                                        % this Yaws worker.\n            app_server_socket,          % The TCP socket to the FastCGI\n                                        % application server\n            stream_to_socket            % The TCP socket to the web browser\n                                        % (stream chunked delivery to\n                                        %  this socket)\n        }).\n\n\ncall_fcgi_responder(Arg) ->\n    call_fcgi_responder(Arg, []).\n\ncall_fcgi_responder(Arg, Options) ->\n    call_fcgi(?FCGI_ROLE_RESPONDER, Arg, Options).\n\n\ncall_fcgi_authorizer(Arg) ->\n    call_fcgi_authorizer(Arg, []).\n\ncall_fcgi_authorizer(Arg, Options) ->\n    Out = call_fcgi(?FCGI_ROLE_AUTHORIZER, Arg, Options),\n    case fcgi_is_access_allowed(Out) of\n        true ->\n            StrippedOut = strip_content_from_out(Out),\n            {allowed, StrippedOut};\n        false ->\n            {denied, Out}\n    end.\n\n\ncall_fcgi(Role, Arg, Options) ->\n    case Arg#arg.state of\n        {cgistate, WorkerPid} ->\n            case Arg#arg.cont of\n                cgicont ->\n                    ?Debug(\"Call FastCGI: continuation~n\", []),\n                    handle_clidata(Arg, WorkerPid)\n            end;\n        _ ->\n            ?Debug(\"Call FastCGI:~n\"\n                   \"  Role = ~p (~s)~n\"\n                   \"  Options = ~p~n\"\n                   \"  Arg = ~p~n\",\n                   [Role, fcgi_role_name(Role),\n                    Options,\n                    Arg]),\n            GlobalConf = get(gc),\n            ServerConf = get(sc),\n            WorkerPid = fcgi_start_worker(Role, Arg, GlobalConf, ServerConf,\n              Options),\n            handle_clidata(Arg, WorkerPid)\n    end.\n\n\nis_not_content({content, _MimeType, _Content}) -> false;\nis_not_content({streamcontent, _MimeType, _Content}) -> false;\nis_not_content(_) -> true.\n\n\nstrip_content_from_out(Out) ->\n    lists:filter(fun is_not_content/1, Out).\n\n\nfcgi_worker_fail(WorkerState, Reason) ->\n    ParentPid = WorkerState#fcgi_worker_state.parent_pid,\n    ParentPid ! {self(), failure, Reason},\n    error_logger:error_msg(\"FastCGI failure: ~p~n\", [Reason]),\n    %% exit normally to avoid filling log with crash messages\n    exit(normal).\n\nfcgi_worker_fail_if(true, WorkerState, Reason) ->\n    fcgi_worker_fail(WorkerState, Reason);\nfcgi_worker_fail_if(_Condition, _WorkerState, _Reason) ->\n    ok.\n\nfcgi_start_worker(Role, Arg, GlobalConf, ServerConf, Options) ->\n    proc_lib:spawn(?MODULE, fcgi_worker,\n                   [self(), Role, Arg, GlobalConf, ServerConf, Options]).\n\n\nfcgi_worker(ParentPid, Role, Arg, GlobalConf, ServerConf, Options) ->\n    {DefaultSvrHost, DefaultSvrPort} =\n        case ServerConf#sconf.fcgi_app_server of\n            undefined ->\n                {undefined, undefined};\n            Else ->\n                Else\n        end,\n    AppServerHost = get_opt(app_server_host, Options, DefaultSvrHost),\n    AppServerPort = get_opt(app_server_port, Options, DefaultSvrPort),\n    PreliminaryWorkerState = #fcgi_worker_state{parent_pid = ParentPid},\n    fcgi_worker_fail_if(AppServerHost == undefined, PreliminaryWorkerState,\n                        \"app server host must be configured\"),\n    fcgi_worker_fail_if(AppServerPort == undefined, PreliminaryWorkerState,\n                        \"app server port must be configured\"),\n    PathInfo = get_opt(path_info, Options, Arg#arg.pathinfo),\n    ScriptFileName = Arg#arg.fullpath,\n    ExtraEnv = get_opt(extra_env, Options, []),\n    Env = build_env(Arg, ScriptFileName, PathInfo, ExtraEnv, ServerConf),\n    TraceProtocol = get_opt(trace_protocol, Options,\n                            ?sc_fcgi_trace_protocol(ServerConf)),\n    LogAppError = get_opt(log_app_error, Options,\n                          ?sc_fcgi_log_app_error(ServerConf)),\n    TcpOptions = yaws:gconf_nslookup_pref(GlobalConf),\n    AppServerSocket =\n        fcgi_connect_to_application_server(PreliminaryWorkerState,\n                                           AppServerHost, AppServerPort,\n                                           TcpOptions),\n    ?Debug(\"Start FastCGI worker:~n\"\n           \"  Role = ~p (~s)~n\"\n           \"  AppServerHost = ~p~n\"\n           \"  AppServerPort = ~p~n\"\n           \"  PathInfo = ~p~n\"\n           \"  ExtraEnv = ~p~n\"\n           \"  TraceProtocol = ~p~n\"\n           \"  LogAppStderr = ~p~n\",\n           [Role, fcgi_role_name(Role),\n            AppServerHost,\n            AppServerPort,\n            PathInfo,\n            ExtraEnv,\n            TraceProtocol,\n            LogAppError]),\n    WorkerState = #fcgi_worker_state{\n      app_server_host = AppServerHost,\n      app_server_port = AppServerPort,\n      path_info = PathInfo,\n      env = Env,\n      keep_connection = false,                % Currently hard-coded; make\n                                              % configurable in the future?\n      trace_protocol = TraceProtocol,\n      log_app_error = LogAppError,\n      role = Role,\n      parent_pid = ParentPid,\n      yaws_worker_pid = Arg#arg.pid,\n      app_server_socket = AppServerSocket\n     },\n    fcgi_send_begin_request(WorkerState),\n    fcgi_send_params(WorkerState, Env),\n    fcgi_send_params(WorkerState, []),\n    fcgi_pass_through_client_data(WorkerState),\n    fcgi_header_loop(WorkerState),\n    gen_tcp:close(AppServerSocket),\n    ok.\n\n\nfcgi_pass_through_client_data(WorkerState) ->\n    ParentPid = WorkerState#fcgi_worker_state.parent_pid,\n    receive\n        {ParentPid, clidata, ClientData} ->\n            ParentPid ! {self(), clidata_receipt},\n            fcgi_send_stdin(WorkerState, ClientData),\n            fcgi_pass_through_client_data(WorkerState);\n        {ParentPid, end_of_clidata} ->\n            fcgi_send_stdin(WorkerState, <<>>)\n    end.\n\n\nfcgi_connect_to_application_server(WorkerState, Host, Port, TcpOptions) ->\n    Options = [binary, {packet, 0}, {active, false}, {nodelay, true} |\n      TcpOptions],\n    case yaws:tcp_connect(Host, Port, Options, ?FCGI_CONNECT_TIMEOUT_MSECS) of\n        {error, Reason} ->\n            fcgi_worker_fail(WorkerState,\n                             {\"connect to application server failed\", Reason});\n        {ok, Socket} ->\n            Socket\n    end.\n\n\nfcgi_send_begin_request(WorkerState) ->\n    %% Not needed yet -- keep_connection is currently hard-coded to false\n    %%KeepConnection = WorkerState#fcgi_worker_state.keep_connection,\n    %%Flags = case KeepConnection of\n    %%            true -> ?FCGI_KEEP_CONN;\n    %%            false -> ?FCGI_DONT_KEEP_CONN\n    %%        end,\n    Flags = ?FCGI_DONT_KEEP_CONN,\n    Role = WorkerState#fcgi_worker_state.role,\n    fcgi_send_record(WorkerState, ?FCGI_TYPE_BEGIN_REQUEST,\n                     ?FCGI_REQUEST_ID_APPLICATION, <<Role:16, Flags:8, 0:40>>).\n\n\nfcgi_send_params(WorkerState, NameValueList) ->\n    fcgi_send_record(WorkerState, ?FCGI_TYPE_PARAMS,\n                     ?FCGI_REQUEST_ID_APPLICATION, NameValueList).\n\n\nfcgi_send_stdin(WorkerState, Data) ->\n    fcgi_send_record(WorkerState, ?FCGI_TYPE_STDIN,\n                     ?FCGI_REQUEST_ID_APPLICATION, Data).\n\n\n%%% Not needed yet\n%%%\n%%% fcgi_send_data(ParentPid, Socket, Data) ->\n%%%     fcgi_send_record(ParentPid, Socket, ?FCGI_TYPE_DATA,\n%%%                      ?FCGI_REQUEST_ID_APPLICATION, Data).\n\n\n%%% Not needed yet\n%%%\n%%% fcgi_send_abort_request(ParentPid, Socket) ->\n%%%     fcgi_send_record(ParentPid, Socket, ?FCGI_TYPE_ABORT_REQUEST,\n%%%                      ?FCGI_REQUEST_ID_APPLICATION, <<>>).\n\n\nfcgi_data_to_string(Data) ->\n    fcgi_data_to_string(\"\", 0, \"\", \"\", Data).\n\nfcgi_data_to_string(LinesStr, Count, CharStr, HexStr, <<>>) ->\n    if\n        Count == 0 ->\n            LinesStr;\n        true ->\n            Padding = lists:duplicate(16 - Count, $ ),\n            LinesStr ++ \"\\n    \" ++ CharStr ++ Padding ++ \"  \" ++ HexStr\n    end;\nfcgi_data_to_string(LinesStr, Count, CharStr, HexStr,\n                    <<Byte:8, MoreData/binary>>) ->\n    Char = if\n        (Byte >= $!) and (Byte =< $~) ->\n            Byte;\n        true ->\n            $.\n    end,\n    Hex = io_lib:format(\"~2.16.0b \", [Byte]),\n    if\n        Count == 16 ->\n            fcgi_data_to_string(LinesStr ++ \"\\n    \" ++ CharStr ++ \"  \" ++\n                                HexStr, 1, [Char], Hex, MoreData);\n        true ->\n            fcgi_data_to_string(LinesStr, Count + 1, CharStr ++ [Char],\n                                HexStr ++ Hex, MoreData)\n    end.\n\n\nfcgi_trace_protocol(WorkerState, Action, Version, Type, RequestId,\n                    ContentLength, PaddingLength, Reserved, ContentData,\n                    PaddingData) ->\n    Trace = WorkerState#fcgi_worker_state.trace_protocol,\n    if\n        Trace ->\n            error_logger:info_msg(\n                \"~s FastCGI record:~n\"\n                \"  version = ~p~n\"\n                \"  type = ~p (~s)~n\"\n                \"  request-id = ~p~n\"\n                \"  content-length = ~p~n\"\n                \"  padding-length = ~p~n\"\n                \"  reserved = ~p~n\"\n                \"  content-data = ~s~n\"\n                \"  padding-data = ~s~n\",\n                [Action,\n                 Version,\n                 Type, fcgi_type_name(Type),\n                 RequestId,\n                 ContentLength,\n                 PaddingLength,\n                 Reserved,\n                 fcgi_data_to_string(ContentData),\n                 fcgi_data_to_string(PaddingData)]);\n        true ->\n            ok\n    end.\n\n\nfcgi_send_record(WorkerState, Type, RequestId, NameValueList) ->\n    EncodedRecord = fcgi_encode_record(WorkerState, Type, RequestId,\n                                       NameValueList),\n    AppServerSocket = WorkerState#fcgi_worker_state.app_server_socket,\n    case gen_tcp:send(AppServerSocket, EncodedRecord) of\n        {error, Reason} ->\n            fcgi_worker_fail(WorkerState,\n                             {\"send to application server failed\", Reason});\n        ok ->\n            ok\n    end.\n\n\nfcgi_encode_record(WorkerState, Type, RequestId, NameValueList)\n  when is_list(NameValueList) ->\n    fcgi_encode_record(WorkerState, Type, RequestId,\n                       fcgi_encode_name_value_list(NameValueList));\n\nfcgi_encode_record(WorkerState, Type, RequestId, ContentData)\n  when is_binary(ContentData), size(ContentData) > 65535  ->\n    <<Bin:65535/binary, Rest/binary>> = ContentData,\n    [fcgi_encode_record(WorkerState, Type, RequestId, Bin),\n     fcgi_encode_record(WorkerState, Type, RequestId, Rest)];\n\nfcgi_encode_record(WorkerState, Type, RequestId, ContentData)\n  when is_binary(ContentData) ->\n    Version = 1,\n    ContentLength = size(ContentData),\n    %% Add padding bytes (if needed) to content bytes to make\n    %% content plus padding a multiple of 8 bytes.\n    PaddingLength = if\n                        ContentLength rem 8 == 0 ->\n                            0;\n                        true ->\n                            8 - (ContentLength rem 8)\n                    end,\n    PaddingData = <<0:(PaddingLength * 8)>>,\n    Reserved = 0,\n    fcgi_trace_protocol(WorkerState, \"Send\", Version, Type, RequestId,\n                        ContentLength, PaddingLength, Reserved,\n                        ContentData, PaddingData),\n    <<Version:8,\n      Type:8,\n      RequestId:16,\n      ContentLength:16,\n      PaddingLength:8,\n      Reserved:8,\n      ContentData/binary,\n      PaddingData/binary>>.\n\n\nfcgi_encode_name_value_list(_NameValueList = []) ->\n    <<>>;\nfcgi_encode_name_value_list(_NameValueList = [{Name, Value} | Tail]) ->\n    <<(fcgi_encode_name_value(Name,Value))/binary,\n      (fcgi_encode_name_value_list(Tail))/binary>>.\n\n\nfcgi_encode_name_value(Name, _Value = undefined) ->\n    fcgi_encode_name_value(Name, \"\");\nfcgi_encode_name_value(Name0, Value0) ->\n    Name = unicode:characters_to_binary(Name0),\n    Value = unicode:characters_to_binary(Value0),\n    NameSize = byte_size(Name),\n    %% If name size is < 128, encode it as one byte with the high bit clear.\n    %% If the name size >= 128, encoded it as 4 bytes with the high bit set.\n    NameSizeData = if\n                       NameSize < 128 ->\n                           <<NameSize:8>>;\n                       true ->\n                           <<(NameSize bor 16#80000000):32>>\n                   end,\n    %% Same encoding for the value size.\n    ValueSize = byte_size(Value),\n    ValueSizeData = if\n                        ValueSize < 128 ->\n                            <<ValueSize:8>>;\n                        true ->\n                            <<(ValueSize bor 16#80000000):32>>\n                    end,\n    list_to_binary([<<NameSizeData/binary, ValueSizeData/binary>>, Name, Value]).\n\n\nfcgi_header_loop(WorkerState) ->\n    fcgi_header_loop(WorkerState, start).\n\nfcgi_header_loop(WorkerState, LineState) ->\n    Line = fcgi_get_line(WorkerState, LineState),\n    ParentPid = WorkerState#fcgi_worker_state.parent_pid,\n    case Line of\n        {failure, Reason} ->\n            ParentPid ! {self(), failure, Reason};\n        {_EmptyLine = [], NewLineState} ->\n            case NewLineState of\n                {middle, Data} ->\n                    case WorkerState#fcgi_worker_state.role of\n                        ?FCGI_ROLE_AUTHORIZER ->\n                            % For authorization we never stream to the client\n                            fcgi_collect_all_data_loop(WorkerState, Data);\n                        _ ->\n                            ParentPid ! {self(), partial_data, Data},\n                            receive\n                                {ParentPid, stream_data} ->\n                                    fcgi_stream_data_loop(WorkerState);\n                                {ParentPid, no_data} ->\n                                    ok\n                            end\n                    end;\n                {ending, Data} ->\n                    ParentPid ! {self(), all_data, Data},\n                    receive\n                        {ParentPid, stream_data} ->\n                            yaws_api:stream_chunk_end(\n                              WorkerState#fcgi_worker_state.yaws_worker_pid);\n                        {ParentPid, no_data} ->\n                            ok\n                    end\n            end;\n        {Header, NewLineState} ->\n            ParentPid ! {self(), header, Header},\n            fcgi_header_loop(WorkerState, NewLineState)\n    end.\n\n\nfcgi_get_line(WorkerState, start) ->\n    case fcgi_get_output(WorkerState) of\n        {data, Data} ->\n            fcgi_get_line(WorkerState, [], {middle, Data});\n        {exit_status, 0} ->\n            fcgi_get_line(WorkerState, [], {ending, <<>>});\n        {exit_status, Status} when Status /=0 ->\n            {failure, {exit_status, Status}}\n    end;\nfcgi_get_line(WorkerState, LineState) ->\n    fcgi_get_line(WorkerState, [], LineState).\n\nfcgi_get_line(_WorkerState, Acc, {State, <<?ASCII_NEW_LINE, Tail/binary>>}) ->\n    {lists:reverse(Acc), {State, Tail}};\nfcgi_get_line(_WorkerState, Acc, {State, <<?ASCII_CARRIAGE_RETURN,\n                                           ?ASCII_NEW_LINE, Tail/binary>>}) ->\n    {lists:reverse(Acc), {State, Tail}};\nfcgi_get_line(WorkerState, Acc, {middle, <<>>}) ->\n    fcgi_get_line(WorkerState, Acc, fcgi_add_resp(WorkerState, <<>>));\nfcgi_get_line(WorkerState, Acc, {middle, <<?ASCII_CARRIAGE_RETURN>>}) ->\n    fcgi_get_line(WorkerState, Acc, fcgi_add_resp(WorkerState,\n                                                  <<?ASCII_CARRIAGE_RETURN>>));\nfcgi_get_line(_WorkerState, Acc, {ending, <<>>}) ->\n    {lists:reverse(Acc), {ending, <<>>}};\nfcgi_get_line(WorkerState, Acc, {State, <<Char, Tail/binary>>}) ->\n    fcgi_get_line(WorkerState, [Char | Acc], {State, Tail}).\n\n\nfcgi_add_resp(WorkerState, OldData) ->\n    case fcgi_get_output(WorkerState) of\n        {data, NewData} ->\n            {middle, <<OldData/binary, NewData/binary>>};\n        {exit_status, _Status} ->\n            {ending, OldData}\n    end.\n\n\nfcgi_stream_data_loop(WorkerState) ->\n    YawsWorkerPid = WorkerState#fcgi_worker_state.yaws_worker_pid,\n    case catch fcgi_get_output(WorkerState) of\n        {data, Data} ->\n            yaws_api:stream_chunk_deliver_blocking(YawsWorkerPid, Data),\n            fcgi_stream_data_loop(WorkerState);\n        {exit_status, _Status} ->\n            yaws_api:stream_chunk_end(YawsWorkerPid);\n        {'EXIT', _Reason} ->\n            yaws_api:stream_chunk_end(YawsWorkerPid)\n    end.\n\n\nfcgi_collect_all_data_loop(WorkerState, Data) ->\n    YawsWorkerPid = WorkerState#fcgi_worker_state.yaws_worker_pid,\n    case fcgi_get_output(WorkerState) of\n        {data, MoreData} ->\n            NewData = <<Data/binary, MoreData/binary>>,\n            fcgi_collect_all_data_loop(WorkerState, NewData);\n        {exit_status, _Status} ->\n            ParentPid = WorkerState#fcgi_worker_state.parent_pid,\n            ParentPid ! {self(), all_data, Data},\n            receive\n                {ParentPid, stream_data} ->\n                    yaws_api:stream_chunk_end(YawsWorkerPid);\n                {ParentPid, no_data} ->\n                    ok\n            end\n    end.\n\n\nfcgi_get_output(WorkerState) ->\n    {Type, ContentData} = fcgi_receive_record(WorkerState),\n    case Type of\n        ?FCGI_TYPE_END_REQUEST ->\n            <<AppStatus:32/signed, ProtStatus:8, _Reserved:24>> = ContentData,\n            fcgi_worker_fail_if(ProtStatus < ?FCGI_STATUS_REQUEST_COMPLETE,\n                                WorkerState,\n                                {\"received unknown protocol status\",\n                                 ProtStatus}),\n            fcgi_worker_fail_if(ProtStatus > ?FCGI_STATUS_UNKNOWN_ROLE,\n                                WorkerState,\n                                {\"received unknown protocol status\",\n                                 ProtStatus}),\n            if\n                ProtStatus /= ?FCGI_STATUS_REQUEST_COMPLETE ->\n                    error_logger:error_msg(\"FastCGI protocol error: ~p (~s)~n\",\n                                           [ProtStatus,\n                                            fcgi_status_name(ProtStatus)]);\n                true ->\n                    ok\n            end,\n            if\n                (AppStatus /= 0),\n                (WorkerState#fcgi_worker_state.log_app_error) ->\n                    error_logger:error_msg(\n                      \"FastCGI application non-zero exit status: ~p~n\",\n                      [AppStatus]);\n                true ->\n                    ok\n            end,\n            {exit_status, AppStatus};\n        ?FCGI_TYPE_STDOUT ->\n            {data, ContentData};\n        ?FCGI_TYPE_STDERR ->\n            if\n                (ContentData /= <<>>),\n                (WorkerState#fcgi_worker_state.log_app_error) ->\n                    error_logger:error_msg(\n                      \"FastCGI application stderr output:~s~n\",\n                      [fcgi_data_to_string(ContentData)]);\n                true ->\n                    ok\n            end,\n            fcgi_get_output(WorkerState);\n        ?FCGI_TYPE_UNKNOWN_TYPE ->\n            <<UnknownType:8, _Reserved:56>> = ContentData,\n            fcgi_worker_fail(\n              WorkerState,\n              {\"application did not understand record type we sent\",\n               UnknownType})\n    end.\n\n\nfcgi_receive_record(WorkerState) ->\n    Header = fcgi_receive_binary(WorkerState, 8, ?FCGI_READ_TIMEOUT_MSECS),\n    <<Version:8, Type:8, RequestId:16, ContentLength:16,\n      PaddingLength:8, Reserved:8>> = Header,\n    fcgi_worker_fail_if(Version /= 1, WorkerState,\n                        {\"received unsupported version\", Version}),\n    case Type of\n        ?FCGI_TYPE_END_REQUEST ->\n            fcgi_worker_fail_if(RequestId /= ?FCGI_REQUEST_ID_APPLICATION,\n                                WorkerState,\n                                {\"unexpected request id\", RequestId}),\n            fcgi_worker_fail_if(ContentLength /= 8, WorkerState,\n                                {\"incorrect content length for end request\",\n                                 ContentLength}),\n            ok;\n        ?FCGI_TYPE_STDOUT ->\n            fcgi_worker_fail_if(RequestId /= ?FCGI_REQUEST_ID_APPLICATION,\n                                WorkerState,\n                                {\"unexpected request id\", RequestId}),\n            ok;\n        ?FCGI_TYPE_STDERR ->\n            fcgi_worker_fail_if(RequestId /= ?FCGI_REQUEST_ID_APPLICATION,\n                                WorkerState,\n                                {\"unexpected request id\", RequestId}),\n            ok;\n        ?FCGI_TYPE_UNKNOWN_TYPE ->\n            fcgi_worker_fail_if(RequestId /= ?FCGI_REQUEST_ID_MANAGEMENT,\n                                WorkerState,\n                                {\"unexpected request id\", RequestId}),\n            fcgi_worker_fail_if(ContentLength /= 8, WorkerState,\n                                {\"incorrect content length for unknown type\",\n                                 ContentLength}),\n            ok;\n        OtherType ->\n            throw({\"received unexpected type\", OtherType})\n    end,\n    ContentData = case ContentLength of\n                      0 ->\n                          <<>>;\n                      _ ->\n                          fcgi_receive_binary(WorkerState, ContentLength,\n                                              ?FCGI_READ_TIMEOUT_MSECS)\n                  end,\n    case PaddingLength of\n        0 ->\n            {Type, ContentData};\n        _ ->\n            PaddingData = fcgi_receive_binary(WorkerState, PaddingLength,\n                                              ?FCGI_READ_TIMEOUT_MSECS),\n            fcgi_trace_protocol(WorkerState, \"Receive\",\n                                Version, Type, RequestId,\n                                ContentLength, PaddingLength,\n                                Reserved, ContentData,\n                                PaddingData),\n            {Type, ContentData}\n    end.\n\n\nfcgi_receive_binary(_WorkerState, Length, _Timeout) when Length == 0 ->\n    <<>>;\nfcgi_receive_binary(WorkerState, Length, Timeout) ->\n    AppServerSocket = WorkerState#fcgi_worker_state.app_server_socket,\n    case gen_tcp:recv(AppServerSocket, Length, Timeout) of\n        {error, Reason} ->\n            fcgi_worker_fail(WorkerState,\n                             {\"recv from application server failed\", Reason});\n        {ok, Data} ->\n            Data\n    end.\n\n\n%%% Access is allowed if, and only if, the resonse from the authorizer\n%%% running on the application server contains a 200 OK status. Any other\n%%% status or absence of a status means access is denied.\n%%%\nfcgi_is_access_allowed([Head | Tail]) ->\n    fcgi_is_access_allowed(Head) orelse fcgi_is_access_allowed(Tail);\nfcgi_is_access_allowed({status, 200}) ->\n    true;\nfcgi_is_access_allowed(_AnythingElse) ->\n    false.\n\n\n%%% Look for headers of the form \"Variable-VAR_NAME: var value\"\n%%%\nfcgi_extract_variables([Head | Tail]) ->\n    fcgi_extract_variables(Head) ++ fcgi_extract_variables(Tail);\nfcgi_extract_variables({header, \"Variable-\" ++ Rest}) ->\n    [fcgi_split_header(Rest)];\nfcgi_extract_variables(_AnythingElse) ->\n    [].\n\n\nfcgi_split_header(Header) ->\n    fcgi_split_header(name, [], [], Header).\n\nfcgi_split_header(_, NameAcc, ValueAcc, \"\") ->\n    {string:strip(lists:reverse(NameAcc)),\n     string:strip(lists:reverse(ValueAcc))};\nfcgi_split_header(name, NameAcc, ValueAcc, [$: | MoreStr]) ->\n    fcgi_split_header(value, NameAcc, ValueAcc, MoreStr);\nfcgi_split_header(name, NameAcc, ValueAcc, [Char | MoreStr]) ->\n    fcgi_split_header(name, [Char | NameAcc], ValueAcc, MoreStr);\nfcgi_split_header(value, NameAcc, ValueAcc, [Char | MoreStr]) ->\n    fcgi_split_header(value, NameAcc, [Char | ValueAcc], MoreStr).\n"], "filenames": ["src/yaws_cgi.erl"], "buggy_code_start_loc": [371], "buggy_code_end_loc": [374], "fixing_code_start_loc": [371], "fixing_code_end_loc": [385], "type": "CWE-601", "message": "yaws before 2.0.4 does not attempt to address RFC 3875 section 4.1.18 namespace conflicts and therefore does not protect CGI applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect a CGI application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.", "other": {"cve": {"id": "CVE-2016-1000108", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-10T15:15:11.947", "lastModified": "2020-08-18T15:05:57.937", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "yaws before 2.0.4 does not attempt to address RFC 3875 section 4.1.18 namespace conflicts and therefore does not protect CGI applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect a CGI application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue."}, {"lang": "es", "value": "yaws versiones anteriores a la versi\u00f3n 2.0.4, no intenta abordar los conflictos de espacio de nombres de RFC secci\u00f3n 3875 versi\u00f3n 4.1.18 y, por lo tanto, no protege las aplicaciones CGI de la presencia de datos de clientes no seguros en la variable de entorno HTTP_PROXY, lo que podr\u00eda permitir a atacantes remotos redireccionar el tr\u00e1fico HTTP saliente de la aplicaci\u00f3n CGI hacia un servidor proxy arbitrario por medio de un encabezado Proxy especialmente dise\u00f1ado en una petici\u00f3n HTTP, tambi\u00e9n se conoce como un problema \"httpoxy\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:yaws:yaws:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.4", "matchCriteriaId": "D90C1016-3892-4F79-A08E-143F8831B226"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/07/18/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/klacke/yaws/commit/9d8fb070e782c95821c90d0ca7372fc6d7316c78#diff-54053c47eb173a90c26ed19bd9d106c1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://raw.githubusercontent.com/distributedweaknessfiling/cvelist/master/2016/1000xxx/CVE-2016-1000108.json", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2016-1000108", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/klacke/yaws/commit/9d8fb070e782c95821c90d0ca7372fc6d7316c78#diff-54053c47eb173a90c26ed19bd9d106c1"}}