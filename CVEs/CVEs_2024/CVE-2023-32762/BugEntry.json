{"buggy_code": ["// Copyright (C) 2017 The Qt Company Ltd.\n// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only\n\n#include \"qhsts_p.h\"\n\n#include \"QtCore/private/qipaddress_p.h\"\n#include \"QtCore/qlist.h\"\n\n#if QT_CONFIG(settings)\n#include \"qhstsstore_p.h\"\n#endif // QT_CONFIG(settings)\n\nQT_BEGIN_NAMESPACE\n\nstatic bool is_valid_domain_name(const QString &host)\n{\n    if (!host.size())\n        return false;\n\n    // RFC6797 8.1.1\n    // If the substring matching the host production from the Request-URI\n    // (of the message to which the host responded) syntactically matches\n    //the IP-literal or IPv4address productions from Section 3.2.2 of\n    //[RFC3986], then the UA MUST NOT note this host as a Known HSTS Host.\n    using namespace QIPAddressUtils;\n\n    IPv4Address ipv4Addr = {};\n    if (parseIp4(ipv4Addr, host.constBegin(), host.constEnd()))\n        return false;\n\n    IPv6Address ipv6Addr = {};\n    // Unlike parseIp4, parseIp6 returns nullptr if it managed to parse IPv6\n    // address successfully.\n    if (!parseIp6(ipv6Addr, host.constBegin(), host.constEnd()))\n        return false;\n\n    // TODO: for now we do not test IPvFuture address, it must be addressed\n    // by introducing parseIpFuture (actually, there is an implementation\n    // in QUrl that can be adopted/modified/moved to QIPAddressUtils).\n    return true;\n}\n\nvoid QHstsCache::updateFromHeaders(const QList<QPair<QByteArray, QByteArray>> &headers,\n                                   const QUrl &url)\n{\n    if (!url.isValid())\n        return;\n\n    QHstsHeaderParser parser;\n    if (parser.parse(headers)) {\n        updateKnownHost(url.host(), parser.expirationDate(), parser.includeSubDomains());\n#if QT_CONFIG(settings)\n        if (hstsStore)\n            hstsStore->synchronize();\n#endif // QT_CONFIG(settings)\n    }\n}\n\nvoid QHstsCache::updateFromPolicies(const QList<QHstsPolicy> &policies)\n{\n    for (const auto &policy : policies)\n        updateKnownHost(policy.host(), policy.expiry(), policy.includesSubDomains());\n\n#if QT_CONFIG(settings)\n    if (hstsStore && policies.size()) {\n        // These policies are coming either from store or from QNAM's setter\n        // function. As a result we can notice expired or new policies, time\n        // to sync ...\n        hstsStore->synchronize();\n    }\n#endif // QT_CONFIG(settings)\n}\n\nvoid QHstsCache::updateKnownHost(const QUrl &url, const QDateTime &expires,\n                                 bool includeSubDomains)\n{\n    if (!url.isValid())\n        return;\n\n    updateKnownHost(url.host(), expires, includeSubDomains);\n#if QT_CONFIG(settings)\n    if (hstsStore)\n        hstsStore->synchronize();\n#endif // QT_CONFIG(settings)\n}\n\nvoid QHstsCache::updateKnownHost(const QString &host, const QDateTime &expires,\n                                 bool includeSubDomains)\n{\n    if (!is_valid_domain_name(host))\n        return;\n\n    // HSTS is a per-host policy, regardless of protocol, port or any of the other\n    // details in an URL; so we only want the host part.  QUrl::host handles\n    // IDNA 2003 (RFC3490) for us, as required by HSTS (RFC6797, section 10).\n    const HostName hostName(host);\n    const auto pos = knownHosts.find(hostName);\n    QHstsPolicy::PolicyFlags flags;\n    if (includeSubDomains)\n        flags = QHstsPolicy::IncludeSubDomains;\n\n    const QHstsPolicy newPolicy(expires, flags, hostName.name);\n    if (pos == knownHosts.end()) {\n        // A new, previously unknown host.\n        if (newPolicy.isExpired()) {\n            // Nothing to do at all - we did not know this host previously,\n            // we do not have to - since its policy expired.\n            return;\n        }\n\n        knownHosts.insert({hostName, newPolicy});\n#if QT_CONFIG(settings)\n        if (hstsStore)\n            hstsStore->addToObserved(newPolicy);\n#endif // QT_CONFIG(settings)\n        return;\n    }\n\n    if (newPolicy.isExpired())\n        knownHosts.erase(pos);\n    else  if (pos->second != newPolicy)\n        pos->second = newPolicy;\n    else\n        return;\n\n#if QT_CONFIG(settings)\n    if (hstsStore)\n        hstsStore->addToObserved(newPolicy);\n#endif // QT_CONFIG(settings)\n}\n\nbool QHstsCache::isKnownHost(const QUrl &url) const\n{\n    if (!url.isValid() || !is_valid_domain_name(url.host()))\n        return false;\n\n    /*\n        RFC6797, 8.2.  Known HSTS Host Domain Name Matching\n\n        * Superdomain Match\n          If a label-for-label match between an entire Known HSTS Host's\n          domain name and a right-hand portion of the given domain name\n          is found, then this Known HSTS Host's domain name is a\n          superdomain match for the given domain name.  There could be\n          multiple superdomain matches for a given domain name.\n        * Congruent Match\n          If a label-for-label match between a Known HSTS Host's domain\n          name and the given domain name is found -- i.e., there are no\n          further labels to compare -- then the given domain name\n          congruently matches this Known HSTS Host.\n\n        We start from the congruent match, and then chop labels and dots and\n        proceed with superdomain match. While RFC6797 recommends to start from\n        superdomain, the result is the same - some valid policy will make a host\n        known.\n    */\n\n    bool superDomainMatch = false;\n    const QString hostNameAsString(url.host());\n    HostName nameToTest(QStringView{hostNameAsString});\n    while (nameToTest.fragment.size()) {\n        auto const pos = knownHosts.find(nameToTest);\n        if (pos != knownHosts.end()) {\n            if (pos->second.isExpired()) {\n                knownHosts.erase(pos);\n#if QT_CONFIG(settings)\n                if (hstsStore) {\n                    // Inform our store that this policy has expired.\n                    hstsStore->addToObserved(pos->second);\n                }\n#endif // QT_CONFIG(settings)\n            } else if (!superDomainMatch || pos->second.includesSubDomains()) {\n                return true;\n            }\n        }\n\n        const qsizetype dot = nameToTest.fragment.indexOf(u'.');\n        if (dot == -1)\n            break;\n\n        nameToTest.fragment = nameToTest.fragment.mid(dot + 1);\n        superDomainMatch = true;\n    }\n\n    return false;\n}\n\nvoid QHstsCache::clear()\n{\n    knownHosts.clear();\n}\n\nQList<QHstsPolicy> QHstsCache::policies() const\n{\n    QList<QHstsPolicy> values;\n    values.reserve(int(knownHosts.size()));\n    for (const auto &host : knownHosts)\n        values << host.second;\n    return values;\n}\n\n#if QT_CONFIG(settings)\nvoid QHstsCache::setStore(QHstsStore *store)\n{\n    // Caller retains ownership of store, which must outlive this cache.\n    if (store != hstsStore) {\n        hstsStore = store;\n\n        if (!hstsStore)\n            return;\n\n        // First we augment our store with the policies we already know about\n        // (and thus the cached policy takes priority over whatever policy we\n        // had in the store for the same host, if any).\n        if (knownHosts.size()) {\n            const QList<QHstsPolicy> observed(policies());\n            for (const auto &policy : observed)\n                hstsStore->addToObserved(policy);\n            hstsStore->synchronize();\n        }\n\n        // Now we update the cache with anything we have not observed yet, but\n        // the store knows about (well, it can happen we synchronize again as a\n        // result if some policies managed to expire or if we add a new one\n        // from the store to cache):\n        const QList<QHstsPolicy> restored(store->readPolicies());\n        updateFromPolicies(restored);\n    }\n}\n#endif // QT_CONFIG(settings)\n\n// The parser is quite simple: 'nextToken' knowns exactly what kind of tokens\n// are valid and it will return false if something else was found; then\n// we immediately stop parsing. 'parseDirective' knows how these tokens can\n// be combined into a valid directive and if some weird combination of\n// valid tokens is found - we immediately stop.\n// And finally we call parseDirective again and again until some error found or\n// we have no more bytes in the header.\n\n// The following isXXX functions are based on RFC2616, 2.2 Basic Rules.\n\nstatic bool isCHAR(int c)\n{\n    // CHAR           = <any US-ASCII character (octets 0 - 127)>\n    return c >= 0 && c <= 127;\n}\n\nstatic bool isCTL(int c)\n{\n    // CTL            = <any US-ASCII control character\n    //                  (octets 0 - 31) and DEL (127)>\n    return (c >= 0 && c <= 31) || c == 127;\n}\n\n\nstatic bool isLWS(int c)\n{\n    // LWS            = [CRLF] 1*( SP | HT )\n    //\n    // CRLF           = CR LF\n    // CR             = <US-ASCII CR, carriage return (13)>\n    // LF             = <US-ASCII LF, linefeed (10)>\n    // SP             = <US-ASCII SP, space (32)>\n    // HT             = <US-ASCII HT, horizontal-tab (9)>\n    //\n    // CRLF is handled by the time we parse a header (they were replaced with\n    // spaces). We only have to deal with remaining SP|HT\n    return c == ' '  || c == '\\t';\n}\n\nstatic bool isTEXT(char c)\n{\n    // TEXT           = <any OCTET except CTLs,\n    //                  but including LWS>\n    return !isCTL(c) || isLWS(c);\n}\n\nstatic bool isSeparator(char c)\n{\n    // separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n    //                      | \",\" | \";\" | \":\" | \"\\\" | <\">\n    //                      | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n    //                      | \"{\" | \"}\" | SP | HT\n    static const char separators[] = \"()<>@,;:\\\\\\\"/[]?={}\";\n    static const char *end = separators + sizeof separators - 1;\n    return isLWS(c) || std::find(separators, end, c) != end;\n}\n\nstatic QByteArray unescapeMaxAge(const QByteArray &value)\n{\n    if (value.size() < 2 || value[0] != '\"')\n        return value;\n\n    Q_ASSERT(value[value.size() - 1] == '\"');\n    return value.mid(1, value.size() - 2);\n}\n\nstatic bool isTOKEN(char c)\n{\n    // token          = 1*<any CHAR except CTLs or separators>\n    return isCHAR(c) && !isCTL(c) && !isSeparator(c);\n}\n\n/*\n\nRFC6797, 6.1 Strict-Transport-Security HTTP Response Header Field.\nSyntax:\n\nStrict-Tranposrt-Security = \"Strict-Transport-Security\" \":\"\n                              [ directive ] *( \";\" [ directive ] )\n\ndirective = directive-name [ \"=\" directive-value ]\ndirective-name = token\ndirective-value = token | quoted-string\n\nRFC 2616, 2.2 Basic Rules.\n\ntoken          = 1*<any CHAR except CTLs or separators>\nquoted-string  = ( <\"> *(qdtext | quoted-pair ) <\"> )\n\n\nqdtext         = <any TEXT except <\">>\nquoted-pair    = \"\\\" CHAR\n\n*/\n\nbool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers)\n{\n    for (const auto &h : headers) {\n        // We use '==' since header name was already 'trimmed' for us:\n        if (h.first == \"Strict-Transport-Security\") {\n            header = h.second;\n            // RFC6797, 8.1:\n            //\n            //  The UA MUST ignore any STS header fields not conforming to the\n            // grammar specified in Section 6.1 (\"Strict-Transport-Security HTTP\n            // Response Header Field\").\n            //\n            // If a UA receives more than one STS header field in an HTTP\n            // response message over secure transport, then the UA MUST process\n            // only the first such header field.\n            //\n            // We read this as: ignore all invalid headers and take the first valid:\n            if (parseSTSHeader() && maxAgeFound) {\n                expiry = QDateTime::currentDateTimeUtc().addSecs(maxAge);\n                return true;\n            }\n        }\n    }\n\n    // In case it was set by a syntactically correct header (but without\n    // REQUIRED max-age directive):\n    subDomainsFound = false;\n\n    return false;\n}\n\nbool QHstsHeaderParser::parseSTSHeader()\n{\n    expiry = QDateTime();\n    maxAgeFound = false;\n    subDomainsFound = false;\n    maxAge = 0;\n    tokenPos = 0;\n    token.clear();\n\n    while (tokenPos < header.size()) {\n        if (!parseDirective())\n            return false;\n\n        if (token.size() && token != \";\") {\n            // After a directive we can only have a \";\" or no more tokens.\n            // Invalid syntax.\n            return false;\n        }\n    }\n\n    return true;\n}\n\nbool QHstsHeaderParser::parseDirective()\n{\n    // RFC 6797, 6.1:\n    //\n    // directive = directive-name [ \"=\" directive-value ]\n    // directive-name = token\n    // directive-value = token | quoted-string\n\n\n    // RFC 2616, 2.2:\n    //\n    // token          = 1*<any CHAR except CTLs or separators>\n\n    if (!nextToken())\n        return false;\n\n    if (!token.size()) // No more data, but no error.\n        return true;\n\n    if (token == \";\") // That's a weird grammar, but that's what it is.\n        return true;\n\n    if (!isTOKEN(token[0])) // Not a valid directive-name.\n        return false;\n\n    const QByteArray directiveName = token;\n    // 2. Try to read \"=\" or \";\".\n    if (!nextToken())\n        return false;\n\n    QByteArray directiveValue;\n    if (token == \";\") // No directive-value\n        return processDirective(directiveName, directiveValue);\n\n    if (token == \"=\") {\n        // We expect a directive-value now:\n        if (!nextToken() || !token.size())\n            return false;\n        directiveValue = token;\n    } else if (token.size()) {\n        // Invalid syntax:\n        return false;\n    }\n\n    if (!processDirective(directiveName, directiveValue))\n        return false;\n\n    // Read either \";\", or 'end of header', or some invalid token.\n    return nextToken();\n}\n\nbool QHstsHeaderParser::processDirective(const QByteArray &name, const QByteArray &value)\n{\n    Q_ASSERT(name.size());\n    // RFC6797 6.1/3 Directive names are case-insensitive\n    if (name.compare(\"max-age\", Qt::CaseInsensitive) == 0) {\n        // RFC 6797, 6.1.1\n        // The syntax of the max-age directive's REQUIRED value (after\n        // quoted-string unescaping, if necessary) is defined as:\n        //\n        // max-age-value = delta-seconds\n        if (maxAgeFound) {\n            // RFC 6797, 6.1/2:\n            // All directives MUST appear only once in an STS header field.\n            return false;\n        }\n\n        const QByteArray unescapedValue = unescapeMaxAge(value);\n        if (!unescapedValue.size())\n            return false;\n\n        bool ok = false;\n        const qint64 age = unescapedValue.toLongLong(&ok);\n        if (!ok || age < 0)\n            return false;\n\n        maxAge = age;\n        maxAgeFound = true;\n    } else if (name.compare(\"includesubdomains\", Qt::CaseInsensitive) == 0) {\n        // RFC 6797, 6.1.2.  The includeSubDomains Directive.\n        // The OPTIONAL \"includeSubDomains\" directive is a valueless directive.\n\n        if (subDomainsFound) {\n            // RFC 6797, 6.1/2:\n            // All directives MUST appear only once in an STS header field.\n            return false;\n        }\n\n        subDomainsFound = true;\n    } // else we do nothing, skip unknown directives (RFC 6797, 6.1/5)\n\n    return true;\n}\n\nbool QHstsHeaderParser::nextToken()\n{\n    // Returns true if we found a valid token or we have no more data (token is\n    // empty then).\n\n    token.clear();\n\n    // Fortunately enough, by this point qhttpnetworkreply already got rid of\n    // [CRLF] parts, but we can have 1*(SP|HT) yet.\n    while (tokenPos < header.size() && isLWS(header[tokenPos]))\n        ++tokenPos;\n\n    if (tokenPos == header.size())\n        return true;\n\n    const char ch = header[tokenPos];\n    if (ch == ';' || ch == '=') {\n        token.append(ch);\n        ++tokenPos;\n        return true;\n    }\n\n    // RFC 2616, 2.2.\n    //\n    // quoted-string  = ( <\"> *(qdtext | quoted-pair ) <\"> )\n    // qdtext         = <any TEXT except <\">>\n    if (ch == '\"') {\n        int last = tokenPos + 1;\n        while (last < header.size()) {\n            if (header[last] == '\"') {\n                // The end of a quoted-string.\n                break;\n            } else if (header[last] == '\\\\') {\n                // quoted-pair    = \"\\\" CHAR\n                if (last + 1 < header.size() && isCHAR(header[last + 1]))\n                    last += 2;\n                else\n                    return false;\n            } else {\n                if (!isTEXT(header[last]))\n                    return false;\n                ++last;\n            }\n        }\n\n        if (last >= header.size()) // no closing '\"':\n            return false;\n\n        token = header.mid(tokenPos, last - tokenPos + 1);\n        tokenPos = last + 1;\n        return true;\n    }\n\n    // RFC 2616, 2.2:\n    //\n    // token          = 1*<any CHAR except CTLs or separators>\n    if (!isTOKEN(ch))\n        return false;\n\n    int last = tokenPos + 1;\n    while (last < header.size() && isTOKEN(header[last]))\n        ++last;\n\n    token = header.mid(tokenPos, last - tokenPos);\n    tokenPos = last;\n\n    return true;\n}\n\nQT_END_NAMESPACE\n", "// Copyright (C) 2016 The Qt Company Ltd.\n// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GPL-3.0-only WITH Qt-GPL-exception-1.0\n\n#include <QTest>\n\n#include <QtCore/qdatetime.h>\n#include <QtCore/qdir.h>\n#include <QtCore/qlist.h>\n#include <QtCore/qpair.h>\n#include <QtCore/qurl.h>\n\n#include <QtNetwork/private/qhstsstore_p.h>\n#include <QtNetwork/private/qhsts_p.h>\n\nQT_USE_NAMESPACE\n\nclass tst_QHsts : public QObject\n{\n    Q_OBJECT\nprivate Q_SLOTS:\n    void testSingleKnownHost_data();\n    void testSingleKnownHost();\n    void testMultilpeKnownHosts();\n    void testPolicyExpiration();\n    void testSTSHeaderParser();\n    void testStore();\n};\n\nvoid tst_QHsts::testSingleKnownHost_data()\n{\n    QTest::addColumn<QUrl>(\"knownHost\");\n    QTest::addColumn<QDateTime>(\"policyExpires\");\n    QTest::addColumn<bool>(\"includeSubDomains\");\n    QTest::addColumn<QUrl>(\"hostToTest\");\n    QTest::addColumn<bool>(\"isKnown\");\n\n    const QDateTime currentUTC = QDateTime::currentDateTimeUtc();\n    const QUrl knownHost(QLatin1String(\"http://example.com\"));\n    const QUrl validSubdomain(QLatin1String(\"https://sub.example.com/ohoho\"));\n    const QUrl unknownDomain(QLatin1String(\"http://example.org\"));\n    const QUrl subSubdomain(QLatin1String(\"https://level3.level2.example.com\"));\n\n    const QDateTime validDate(currentUTC.addSecs(1000));\n    QTest::newRow(\"same-known\") << knownHost << validDate << false << knownHost << true;\n    QTest::newRow(\"subexcluded\") << knownHost << validDate << false << validSubdomain << false;\n    QTest::newRow(\"subincluded\") << knownHost << validDate << true << validSubdomain << true;\n    QTest::newRow(\"unknown-subexcluded\") << knownHost << validDate << false << unknownDomain << false;\n    QTest::newRow(\"unknown-subincluded\") << knownHost << validDate << true << unknownDomain << false;\n    QTest::newRow(\"sub-subdomain-subincluded\") << knownHost << validDate << true << subSubdomain << true;\n    QTest::newRow(\"sub-subdomain-subexcluded\") << knownHost << validDate << false << subSubdomain << false;\n\n    const QDateTime invalidDate;\n    QTest::newRow(\"invalid-time\") << knownHost << invalidDate << false << knownHost << false;\n    QTest::newRow(\"invalid-time-subexcluded\") << knownHost << invalidDate << false\n                                              << validSubdomain << false;\n    QTest::newRow(\"invalid-time-subincluded\") << knownHost << invalidDate << true\n                                              << validSubdomain << false;\n\n    const QDateTime expiredDate(currentUTC.addSecs(-1000));\n    QTest::newRow(\"expired-time\") << knownHost << expiredDate << false << knownHost << false;\n    QTest::newRow(\"expired-time-subexcluded\") << knownHost << expiredDate << false\n                                              << validSubdomain << false;\n    QTest::newRow(\"expired-time-subincluded\") << knownHost << expiredDate << true\n                                              << validSubdomain << false;\n    const QUrl ipAsHost(QLatin1String(\"http://127.0.0.1\"));\n    QTest::newRow(\"ip-address-in-hostname\") << ipAsHost << validDate << false\n                                              << ipAsHost << false;\n\n    const QUrl anyIPv4AsHost(QLatin1String(\"http://0.0.0.0\"));\n    QTest::newRow(\"anyip4-address-in-hostname\") << anyIPv4AsHost << validDate\n                                                << false << anyIPv4AsHost << false;\n    const QUrl anyIPv6AsHost(QLatin1String(\"http://[::]\"));\n    QTest::newRow(\"anyip6-address-in-hostname\") << anyIPv6AsHost << validDate\n                                                << false << anyIPv6AsHost << false;\n\n}\n\nvoid tst_QHsts::testSingleKnownHost()\n{\n    QFETCH(const QUrl, knownHost);\n    QFETCH(const QDateTime, policyExpires);\n    QFETCH(const bool, includeSubDomains);\n    QFETCH(const QUrl, hostToTest);\n    QFETCH(const bool, isKnown);\n\n    QHstsCache cache;\n    cache.updateKnownHost(knownHost, policyExpires, includeSubDomains);\n    QCOMPARE(cache.isKnownHost(hostToTest), isKnown);\n}\n\nvoid tst_QHsts::testMultilpeKnownHosts()\n{\n    const QDateTime currentUTC = QDateTime::currentDateTimeUtc();\n    const QDateTime validDate(currentUTC.addSecs(10000));\n    const QDateTime expiredDate(currentUTC.addSecs(-10000));\n    const QUrl exampleCom(QLatin1String(\"https://example.com\"));\n    const QUrl subExampleCom(QLatin1String(\"https://sub.example.com\"));\n\n    QHstsCache cache;\n    // example.com is HSTS and includes subdomains:\n    cache.updateKnownHost(exampleCom, validDate, true);\n    QVERIFY(cache.isKnownHost(exampleCom));\n    QVERIFY(cache.isKnownHost(subExampleCom));\n    // example.com can set its policy not to include subdomains:\n    cache.updateKnownHost(exampleCom, validDate, false);\n    QVERIFY(!cache.isKnownHost(subExampleCom));\n    // but sub.example.com can set its own policy:\n    cache.updateKnownHost(subExampleCom, validDate, false);\n    QVERIFY(cache.isKnownHost(subExampleCom));\n    // let's say example.com's policy has expired:\n    cache.updateKnownHost(exampleCom, expiredDate, false);\n    QVERIFY(!cache.isKnownHost(exampleCom));\n    // it should not affect sub.example.com's policy:\n    QVERIFY(cache.isKnownHost(subExampleCom));\n\n    // clear cache and invalidate all policies:\n    cache.clear();\n    QVERIFY(!cache.isKnownHost(exampleCom));\n    QVERIFY(!cache.isKnownHost(subExampleCom));\n\n    // siblings:\n    const QUrl anotherSub(QLatin1String(\"https://sub2.example.com\"));\n    cache.updateKnownHost(subExampleCom, validDate, true);\n    cache.updateKnownHost(anotherSub, validDate, true);\n    QVERIFY(cache.isKnownHost(subExampleCom));\n    QVERIFY(cache.isKnownHost(anotherSub));\n    // they cannot set superdomain's policy:\n    QVERIFY(!cache.isKnownHost(exampleCom));\n    // a sibling cannot set another sibling's policy:\n    cache.updateKnownHost(anotherSub, expiredDate, false);\n    QVERIFY(cache.isKnownHost(subExampleCom));\n    QVERIFY(!cache.isKnownHost(anotherSub));\n    QVERIFY(!cache.isKnownHost(exampleCom));\n    // let's make example.com known again:\n    cache.updateKnownHost(exampleCom, validDate, true);\n    // a subdomain cannot affect its superdomain's policy:\n    cache.updateKnownHost(subExampleCom, expiredDate, true);\n    QVERIFY(cache.isKnownHost(exampleCom));\n    // and this superdomain includes subdomains in its HSTS policy:\n    QVERIFY(cache.isKnownHost(subExampleCom));\n    QVERIFY(cache.isKnownHost(anotherSub));\n\n    // a subdomain (with its subdomains) cannot affect its superdomain's policy:\n    cache.updateKnownHost(exampleCom, expiredDate, true);\n    cache.updateKnownHost(subExampleCom, validDate, true);\n    QVERIFY(cache.isKnownHost(subExampleCom));\n    QVERIFY(!cache.isKnownHost(exampleCom));\n}\n\nvoid tst_QHsts::testPolicyExpiration()\n{\n    QDateTime currentUTC = QDateTime::currentDateTimeUtc();\n    const QUrl exampleCom(QLatin1String(\"http://example.com\"));\n    const QUrl subdomain(QLatin1String(\"http://subdomain.example.com\"));\n    const qint64 lifeTimeMS = 50;\n\n    QHstsCache cache;\n    // start with 'includeSubDomains' and 5 s. lifetime:\n    cache.updateKnownHost(exampleCom, currentUTC.addMSecs(lifeTimeMS), true);\n    QVERIFY(cache.isKnownHost(exampleCom));\n    QVERIFY(cache.isKnownHost(subdomain));\n    // wait for approx. a half of lifetime:\n    QTest::qWait(lifeTimeMS / 2);\n\n    if (QDateTime::currentDateTimeUtc() < currentUTC.addMSecs(lifeTimeMS)) {\n        // Should still be valid:\n        QVERIFY(cache.isKnownHost(exampleCom));\n        QVERIFY(cache.isKnownHost(subdomain));\n    }\n\n    QTest::qWait(lifeTimeMS);\n    // expired:\n    QVERIFY(!cache.isKnownHost(exampleCom));\n    QVERIFY(!cache.isKnownHost(subdomain));\n\n    // now check that superdomain's policy expires, but not subdomain's policy:\n    currentUTC = QDateTime::currentDateTimeUtc();\n    cache.updateKnownHost(exampleCom, currentUTC.addMSecs(lifeTimeMS / 5), true);\n    cache.updateKnownHost(subdomain, currentUTC.addMSecs(lifeTimeMS), true);\n    QVERIFY(cache.isKnownHost(exampleCom));\n    QVERIFY(cache.isKnownHost(subdomain));\n    QTest::qWait(lifeTimeMS / 2);\n    if (QDateTime::currentDateTimeUtc() < currentUTC.addMSecs(lifeTimeMS)) {\n        QVERIFY(!cache.isKnownHost(exampleCom));\n        QVERIFY(cache.isKnownHost(subdomain));\n    }\n}\n\nvoid tst_QHsts::testSTSHeaderParser()\n{\n    QHstsHeaderParser parser;\n    using Header = QPair<QByteArray, QByteArray>;\n    using Headers = QList<Header>;\n\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n    Headers list;\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n\n    list << Header(\"Strict-Transport-security\", \"200\");\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n\n    // This header is missing REQUIRED max-age directive, so we'll ignore it:\n    list << Header(\"Strict-Transport-Security\", \"includeSubDomains\");\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n\n    list.pop_back();\n    list << Header(\"Strict-Transport-Security\", \"includeSubDomains;max-age=1000\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(parser.expirationDate() > QDateTime::currentDateTimeUtc());\n    QVERIFY(parser.includeSubDomains());\n\n    list.pop_back();\n    // Invalid (includeSubDomains twice):\n    list << Header(\"Strict-Transport-Security\", \"max-age = 1000 ; includeSubDomains;includeSubDomains\");\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n\n    list.pop_back();\n    // Invalid (weird number of seconds):\n    list << Header(\"Strict-Transport-Security\", \"max-age=-1000   ; includeSubDomains\");\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n\n    list.pop_back();\n    // Note, directives are case-insensitive + we should ignore unknown directive.\n    list << Header(\"Strict-Transport-Security\", \";max-age=1000 ;includesubdomains;;\"\n                   \"nowsomeunknownheader=\\\"somevaluewithescapes\\\\;\\\"\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(parser.includeSubDomains());\n    QVERIFY(parser.expirationDate().isValid());\n\n    list.pop_back();\n    // Check that we know how to unescape max-age:\n    list << Header(\"Strict-Transport-Security\", \"max-age=\\\"1000\\\"\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(parser.expirationDate().isValid());\n\n    list.pop_back();\n    // The only STS header, with invalid syntax though, to be ignored:\n    list << Header(\"Strict-Transport-Security\", \"max-age; max-age=15768000\");\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n\n    // Now we check that our parse chosses the first valid STS header and ignores\n    // others:\n    list.clear();\n    list << Header(\"Strict-Transport-Security\", \"includeSubdomains; max-age=\\\"hehehe\\\";\");\n    list << Header(\"Strict-Transport-Security\", \"max-age=10101\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(parser.expirationDate().isValid());\n\n\n    list.clear();\n    list << Header(\"Strict-Transport-Security\", \"max-age=0\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(parser.expirationDate() <= QDateTime::currentDateTimeUtc());\n\n    // Parsing is case-insensitive:\n    list.pop_back();\n    list << Header(\"Strict-Transport-Security\", \"Max-aGE=1000; InclUdesUbdomains\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(parser.includeSubDomains());\n    QVERIFY(parser.expirationDate().isValid());\n\n    // Grammar of STS header is quite permissive, let's check we can parse\n    // some weird but valid header:\n    list.pop_back();\n    list << Header(\"Strict-Transport-Security\", \";;; max-age = 17; ; ; ; ;;; ;;\"\n                    \";;; ; includeSubdomains ;;thisIsUnknownDirective;;;;\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(parser.includeSubDomains());\n    QVERIFY(parser.expirationDate().isValid());\n\n    list.pop_back();\n    list << Header(\"Strict-Transport-Security\", \"max-age=1000; includeSubDomains bogon\");\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n}\n\nconst QLatin1String storeDir(\".\");\n\nstruct TestStoreDeleter\n{\n    ~TestStoreDeleter()\n    {\n        QDir cwd;\n        if (!cwd.remove(QHstsStore::absoluteFilePath(storeDir)))\n            qWarning() << \"tst_QHsts::testStore: failed to remove the hsts store file\";\n    }\n};\n\nvoid tst_QHsts::testStore()\n{\n    // Delete the store's file after we finish the test.\n    TestStoreDeleter cleaner;\n\n    const QUrl exampleCom(QStringLiteral(\"http://example.com\"));\n    const QUrl subDomain(QStringLiteral(\"http://subdomain.example.com\"));\n    const QDateTime validDate(QDateTime::currentDateTimeUtc().addDays(1));\n\n    {\n        // We start from an empty cache and empty store:\n        QHstsCache cache;\n        QHstsStore store(storeDir);\n        cache.setStore(&store);\n        QVERIFY(!cache.isKnownHost(exampleCom));\n        QVERIFY(!cache.isKnownHost(subDomain));\n        // (1) This will also store the policy:\n        cache.updateKnownHost(exampleCom, validDate, true);\n        QVERIFY(cache.isKnownHost(exampleCom));\n        QVERIFY(cache.isKnownHost(subDomain));\n    }\n    {\n        // Test the policy stored at (1):\n        QHstsCache cache;\n        QHstsStore store(storeDir);\n        cache.setStore(&store);\n        QVERIFY(cache.isKnownHost(exampleCom));\n        QVERIFY(cache.isKnownHost(subDomain));\n        // (2) Remove subdomains:\n        cache.updateKnownHost(exampleCom, validDate, false);\n        QVERIFY(!cache.isKnownHost(subDomain));\n    }\n    {\n        // Test the previous update (2):\n        QHstsCache cache;\n        QHstsStore store(storeDir);\n        cache.setStore(&store);\n        QVERIFY(cache.isKnownHost(exampleCom));\n        QVERIFY(!cache.isKnownHost(subDomain));\n    }\n    {\n        QHstsCache cache;\n        cache.updateKnownHost(subDomain, validDate, false);\n        QVERIFY(cache.isKnownHost(subDomain));\n        QHstsStore store(storeDir);\n        // (3) This should store policy from cache, over old policy from store:\n        cache.setStore(&store);\n    }\n    {\n        // Test that (3) was stored:\n        QHstsCache cache;\n        QHstsStore store(storeDir);\n        cache.setStore(&store);\n        QVERIFY(cache.isKnownHost(subDomain));\n    }\n}\n\nQTEST_MAIN(tst_QHsts)\n\n#include \"tst_qhsts.moc\"\n"], "fixing_code": ["// Copyright (C) 2017 The Qt Company Ltd.\n// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only\n\n#include \"qhsts_p.h\"\n\n#include \"QtCore/private/qipaddress_p.h\"\n#include \"QtCore/qlist.h\"\n\n#if QT_CONFIG(settings)\n#include \"qhstsstore_p.h\"\n#endif // QT_CONFIG(settings)\n\nQT_BEGIN_NAMESPACE\n\nstatic bool is_valid_domain_name(const QString &host)\n{\n    if (!host.size())\n        return false;\n\n    // RFC6797 8.1.1\n    // If the substring matching the host production from the Request-URI\n    // (of the message to which the host responded) syntactically matches\n    //the IP-literal or IPv4address productions from Section 3.2.2 of\n    //[RFC3986], then the UA MUST NOT note this host as a Known HSTS Host.\n    using namespace QIPAddressUtils;\n\n    IPv4Address ipv4Addr = {};\n    if (parseIp4(ipv4Addr, host.constBegin(), host.constEnd()))\n        return false;\n\n    IPv6Address ipv6Addr = {};\n    // Unlike parseIp4, parseIp6 returns nullptr if it managed to parse IPv6\n    // address successfully.\n    if (!parseIp6(ipv6Addr, host.constBegin(), host.constEnd()))\n        return false;\n\n    // TODO: for now we do not test IPvFuture address, it must be addressed\n    // by introducing parseIpFuture (actually, there is an implementation\n    // in QUrl that can be adopted/modified/moved to QIPAddressUtils).\n    return true;\n}\n\nvoid QHstsCache::updateFromHeaders(const QList<QPair<QByteArray, QByteArray>> &headers,\n                                   const QUrl &url)\n{\n    if (!url.isValid())\n        return;\n\n    QHstsHeaderParser parser;\n    if (parser.parse(headers)) {\n        updateKnownHost(url.host(), parser.expirationDate(), parser.includeSubDomains());\n#if QT_CONFIG(settings)\n        if (hstsStore)\n            hstsStore->synchronize();\n#endif // QT_CONFIG(settings)\n    }\n}\n\nvoid QHstsCache::updateFromPolicies(const QList<QHstsPolicy> &policies)\n{\n    for (const auto &policy : policies)\n        updateKnownHost(policy.host(), policy.expiry(), policy.includesSubDomains());\n\n#if QT_CONFIG(settings)\n    if (hstsStore && policies.size()) {\n        // These policies are coming either from store or from QNAM's setter\n        // function. As a result we can notice expired or new policies, time\n        // to sync ...\n        hstsStore->synchronize();\n    }\n#endif // QT_CONFIG(settings)\n}\n\nvoid QHstsCache::updateKnownHost(const QUrl &url, const QDateTime &expires,\n                                 bool includeSubDomains)\n{\n    if (!url.isValid())\n        return;\n\n    updateKnownHost(url.host(), expires, includeSubDomains);\n#if QT_CONFIG(settings)\n    if (hstsStore)\n        hstsStore->synchronize();\n#endif // QT_CONFIG(settings)\n}\n\nvoid QHstsCache::updateKnownHost(const QString &host, const QDateTime &expires,\n                                 bool includeSubDomains)\n{\n    if (!is_valid_domain_name(host))\n        return;\n\n    // HSTS is a per-host policy, regardless of protocol, port or any of the other\n    // details in an URL; so we only want the host part.  QUrl::host handles\n    // IDNA 2003 (RFC3490) for us, as required by HSTS (RFC6797, section 10).\n    const HostName hostName(host);\n    const auto pos = knownHosts.find(hostName);\n    QHstsPolicy::PolicyFlags flags;\n    if (includeSubDomains)\n        flags = QHstsPolicy::IncludeSubDomains;\n\n    const QHstsPolicy newPolicy(expires, flags, hostName.name);\n    if (pos == knownHosts.end()) {\n        // A new, previously unknown host.\n        if (newPolicy.isExpired()) {\n            // Nothing to do at all - we did not know this host previously,\n            // we do not have to - since its policy expired.\n            return;\n        }\n\n        knownHosts.insert({hostName, newPolicy});\n#if QT_CONFIG(settings)\n        if (hstsStore)\n            hstsStore->addToObserved(newPolicy);\n#endif // QT_CONFIG(settings)\n        return;\n    }\n\n    if (newPolicy.isExpired())\n        knownHosts.erase(pos);\n    else  if (pos->second != newPolicy)\n        pos->second = newPolicy;\n    else\n        return;\n\n#if QT_CONFIG(settings)\n    if (hstsStore)\n        hstsStore->addToObserved(newPolicy);\n#endif // QT_CONFIG(settings)\n}\n\nbool QHstsCache::isKnownHost(const QUrl &url) const\n{\n    if (!url.isValid() || !is_valid_domain_name(url.host()))\n        return false;\n\n    /*\n        RFC6797, 8.2.  Known HSTS Host Domain Name Matching\n\n        * Superdomain Match\n          If a label-for-label match between an entire Known HSTS Host's\n          domain name and a right-hand portion of the given domain name\n          is found, then this Known HSTS Host's domain name is a\n          superdomain match for the given domain name.  There could be\n          multiple superdomain matches for a given domain name.\n        * Congruent Match\n          If a label-for-label match between a Known HSTS Host's domain\n          name and the given domain name is found -- i.e., there are no\n          further labels to compare -- then the given domain name\n          congruently matches this Known HSTS Host.\n\n        We start from the congruent match, and then chop labels and dots and\n        proceed with superdomain match. While RFC6797 recommends to start from\n        superdomain, the result is the same - some valid policy will make a host\n        known.\n    */\n\n    bool superDomainMatch = false;\n    const QString hostNameAsString(url.host());\n    HostName nameToTest(QStringView{hostNameAsString});\n    while (nameToTest.fragment.size()) {\n        auto const pos = knownHosts.find(nameToTest);\n        if (pos != knownHosts.end()) {\n            if (pos->second.isExpired()) {\n                knownHosts.erase(pos);\n#if QT_CONFIG(settings)\n                if (hstsStore) {\n                    // Inform our store that this policy has expired.\n                    hstsStore->addToObserved(pos->second);\n                }\n#endif // QT_CONFIG(settings)\n            } else if (!superDomainMatch || pos->second.includesSubDomains()) {\n                return true;\n            }\n        }\n\n        const qsizetype dot = nameToTest.fragment.indexOf(u'.');\n        if (dot == -1)\n            break;\n\n        nameToTest.fragment = nameToTest.fragment.mid(dot + 1);\n        superDomainMatch = true;\n    }\n\n    return false;\n}\n\nvoid QHstsCache::clear()\n{\n    knownHosts.clear();\n}\n\nQList<QHstsPolicy> QHstsCache::policies() const\n{\n    QList<QHstsPolicy> values;\n    values.reserve(int(knownHosts.size()));\n    for (const auto &host : knownHosts)\n        values << host.second;\n    return values;\n}\n\n#if QT_CONFIG(settings)\nvoid QHstsCache::setStore(QHstsStore *store)\n{\n    // Caller retains ownership of store, which must outlive this cache.\n    if (store != hstsStore) {\n        hstsStore = store;\n\n        if (!hstsStore)\n            return;\n\n        // First we augment our store with the policies we already know about\n        // (and thus the cached policy takes priority over whatever policy we\n        // had in the store for the same host, if any).\n        if (knownHosts.size()) {\n            const QList<QHstsPolicy> observed(policies());\n            for (const auto &policy : observed)\n                hstsStore->addToObserved(policy);\n            hstsStore->synchronize();\n        }\n\n        // Now we update the cache with anything we have not observed yet, but\n        // the store knows about (well, it can happen we synchronize again as a\n        // result if some policies managed to expire or if we add a new one\n        // from the store to cache):\n        const QList<QHstsPolicy> restored(store->readPolicies());\n        updateFromPolicies(restored);\n    }\n}\n#endif // QT_CONFIG(settings)\n\n// The parser is quite simple: 'nextToken' knowns exactly what kind of tokens\n// are valid and it will return false if something else was found; then\n// we immediately stop parsing. 'parseDirective' knows how these tokens can\n// be combined into a valid directive and if some weird combination of\n// valid tokens is found - we immediately stop.\n// And finally we call parseDirective again and again until some error found or\n// we have no more bytes in the header.\n\n// The following isXXX functions are based on RFC2616, 2.2 Basic Rules.\n\nstatic bool isCHAR(int c)\n{\n    // CHAR           = <any US-ASCII character (octets 0 - 127)>\n    return c >= 0 && c <= 127;\n}\n\nstatic bool isCTL(int c)\n{\n    // CTL            = <any US-ASCII control character\n    //                  (octets 0 - 31) and DEL (127)>\n    return (c >= 0 && c <= 31) || c == 127;\n}\n\n\nstatic bool isLWS(int c)\n{\n    // LWS            = [CRLF] 1*( SP | HT )\n    //\n    // CRLF           = CR LF\n    // CR             = <US-ASCII CR, carriage return (13)>\n    // LF             = <US-ASCII LF, linefeed (10)>\n    // SP             = <US-ASCII SP, space (32)>\n    // HT             = <US-ASCII HT, horizontal-tab (9)>\n    //\n    // CRLF is handled by the time we parse a header (they were replaced with\n    // spaces). We only have to deal with remaining SP|HT\n    return c == ' '  || c == '\\t';\n}\n\nstatic bool isTEXT(char c)\n{\n    // TEXT           = <any OCTET except CTLs,\n    //                  but including LWS>\n    return !isCTL(c) || isLWS(c);\n}\n\nstatic bool isSeparator(char c)\n{\n    // separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n    //                      | \",\" | \";\" | \":\" | \"\\\" | <\">\n    //                      | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n    //                      | \"{\" | \"}\" | SP | HT\n    static const char separators[] = \"()<>@,;:\\\\\\\"/[]?={}\";\n    static const char *end = separators + sizeof separators - 1;\n    return isLWS(c) || std::find(separators, end, c) != end;\n}\n\nstatic QByteArray unescapeMaxAge(const QByteArray &value)\n{\n    if (value.size() < 2 || value[0] != '\"')\n        return value;\n\n    Q_ASSERT(value[value.size() - 1] == '\"');\n    return value.mid(1, value.size() - 2);\n}\n\nstatic bool isTOKEN(char c)\n{\n    // token          = 1*<any CHAR except CTLs or separators>\n    return isCHAR(c) && !isCTL(c) && !isSeparator(c);\n}\n\n/*\n\nRFC6797, 6.1 Strict-Transport-Security HTTP Response Header Field.\nSyntax:\n\nStrict-Tranposrt-Security = \"Strict-Transport-Security\" \":\"\n                              [ directive ] *( \";\" [ directive ] )\n\ndirective = directive-name [ \"=\" directive-value ]\ndirective-name = token\ndirective-value = token | quoted-string\n\nRFC 2616, 2.2 Basic Rules.\n\ntoken          = 1*<any CHAR except CTLs or separators>\nquoted-string  = ( <\"> *(qdtext | quoted-pair ) <\"> )\n\n\nqdtext         = <any TEXT except <\">>\nquoted-pair    = \"\\\" CHAR\n\n*/\n\nbool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers)\n{\n    for (const auto &h : headers) {\n        // We compare directly because header name was already 'trimmed' for us:\n        if (h.first.compare(\"Strict-Transport-Security\", Qt::CaseInsensitive) == 0) {\n            header = h.second;\n            // RFC6797, 8.1:\n            //\n            //  The UA MUST ignore any STS header fields not conforming to the\n            // grammar specified in Section 6.1 (\"Strict-Transport-Security HTTP\n            // Response Header Field\").\n            //\n            // If a UA receives more than one STS header field in an HTTP\n            // response message over secure transport, then the UA MUST process\n            // only the first such header field.\n            //\n            // We read this as: ignore all invalid headers and take the first valid:\n            if (parseSTSHeader() && maxAgeFound) {\n                expiry = QDateTime::currentDateTimeUtc().addSecs(maxAge);\n                return true;\n            }\n        }\n    }\n\n    // In case it was set by a syntactically correct header (but without\n    // REQUIRED max-age directive):\n    subDomainsFound = false;\n\n    return false;\n}\n\nbool QHstsHeaderParser::parseSTSHeader()\n{\n    expiry = QDateTime();\n    maxAgeFound = false;\n    subDomainsFound = false;\n    maxAge = 0;\n    tokenPos = 0;\n    token.clear();\n\n    while (tokenPos < header.size()) {\n        if (!parseDirective())\n            return false;\n\n        if (token.size() && token != \";\") {\n            // After a directive we can only have a \";\" or no more tokens.\n            // Invalid syntax.\n            return false;\n        }\n    }\n\n    return true;\n}\n\nbool QHstsHeaderParser::parseDirective()\n{\n    // RFC 6797, 6.1:\n    //\n    // directive = directive-name [ \"=\" directive-value ]\n    // directive-name = token\n    // directive-value = token | quoted-string\n\n\n    // RFC 2616, 2.2:\n    //\n    // token          = 1*<any CHAR except CTLs or separators>\n\n    if (!nextToken())\n        return false;\n\n    if (!token.size()) // No more data, but no error.\n        return true;\n\n    if (token == \";\") // That's a weird grammar, but that's what it is.\n        return true;\n\n    if (!isTOKEN(token[0])) // Not a valid directive-name.\n        return false;\n\n    const QByteArray directiveName = token;\n    // 2. Try to read \"=\" or \";\".\n    if (!nextToken())\n        return false;\n\n    QByteArray directiveValue;\n    if (token == \";\") // No directive-value\n        return processDirective(directiveName, directiveValue);\n\n    if (token == \"=\") {\n        // We expect a directive-value now:\n        if (!nextToken() || !token.size())\n            return false;\n        directiveValue = token;\n    } else if (token.size()) {\n        // Invalid syntax:\n        return false;\n    }\n\n    if (!processDirective(directiveName, directiveValue))\n        return false;\n\n    // Read either \";\", or 'end of header', or some invalid token.\n    return nextToken();\n}\n\nbool QHstsHeaderParser::processDirective(const QByteArray &name, const QByteArray &value)\n{\n    Q_ASSERT(name.size());\n    // RFC6797 6.1/3 Directive names are case-insensitive\n    if (name.compare(\"max-age\", Qt::CaseInsensitive) == 0) {\n        // RFC 6797, 6.1.1\n        // The syntax of the max-age directive's REQUIRED value (after\n        // quoted-string unescaping, if necessary) is defined as:\n        //\n        // max-age-value = delta-seconds\n        if (maxAgeFound) {\n            // RFC 6797, 6.1/2:\n            // All directives MUST appear only once in an STS header field.\n            return false;\n        }\n\n        const QByteArray unescapedValue = unescapeMaxAge(value);\n        if (!unescapedValue.size())\n            return false;\n\n        bool ok = false;\n        const qint64 age = unescapedValue.toLongLong(&ok);\n        if (!ok || age < 0)\n            return false;\n\n        maxAge = age;\n        maxAgeFound = true;\n    } else if (name.compare(\"includesubdomains\", Qt::CaseInsensitive) == 0) {\n        // RFC 6797, 6.1.2.  The includeSubDomains Directive.\n        // The OPTIONAL \"includeSubDomains\" directive is a valueless directive.\n\n        if (subDomainsFound) {\n            // RFC 6797, 6.1/2:\n            // All directives MUST appear only once in an STS header field.\n            return false;\n        }\n\n        subDomainsFound = true;\n    } // else we do nothing, skip unknown directives (RFC 6797, 6.1/5)\n\n    return true;\n}\n\nbool QHstsHeaderParser::nextToken()\n{\n    // Returns true if we found a valid token or we have no more data (token is\n    // empty then).\n\n    token.clear();\n\n    // Fortunately enough, by this point qhttpnetworkreply already got rid of\n    // [CRLF] parts, but we can have 1*(SP|HT) yet.\n    while (tokenPos < header.size() && isLWS(header[tokenPos]))\n        ++tokenPos;\n\n    if (tokenPos == header.size())\n        return true;\n\n    const char ch = header[tokenPos];\n    if (ch == ';' || ch == '=') {\n        token.append(ch);\n        ++tokenPos;\n        return true;\n    }\n\n    // RFC 2616, 2.2.\n    //\n    // quoted-string  = ( <\"> *(qdtext | quoted-pair ) <\"> )\n    // qdtext         = <any TEXT except <\">>\n    if (ch == '\"') {\n        int last = tokenPos + 1;\n        while (last < header.size()) {\n            if (header[last] == '\"') {\n                // The end of a quoted-string.\n                break;\n            } else if (header[last] == '\\\\') {\n                // quoted-pair    = \"\\\" CHAR\n                if (last + 1 < header.size() && isCHAR(header[last + 1]))\n                    last += 2;\n                else\n                    return false;\n            } else {\n                if (!isTEXT(header[last]))\n                    return false;\n                ++last;\n            }\n        }\n\n        if (last >= header.size()) // no closing '\"':\n            return false;\n\n        token = header.mid(tokenPos, last - tokenPos + 1);\n        tokenPos = last + 1;\n        return true;\n    }\n\n    // RFC 2616, 2.2:\n    //\n    // token          = 1*<any CHAR except CTLs or separators>\n    if (!isTOKEN(ch))\n        return false;\n\n    int last = tokenPos + 1;\n    while (last < header.size() && isTOKEN(header[last]))\n        ++last;\n\n    token = header.mid(tokenPos, last - tokenPos);\n    tokenPos = last;\n\n    return true;\n}\n\nQT_END_NAMESPACE\n", "// Copyright (C) 2016 The Qt Company Ltd.\n// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GPL-3.0-only WITH Qt-GPL-exception-1.0\n\n#include <QTest>\n\n#include <QtCore/qdatetime.h>\n#include <QtCore/qdir.h>\n#include <QtCore/qlist.h>\n#include <QtCore/qpair.h>\n#include <QtCore/qurl.h>\n\n#include <QtNetwork/private/qhstsstore_p.h>\n#include <QtNetwork/private/qhsts_p.h>\n\nQT_USE_NAMESPACE\n\nclass tst_QHsts : public QObject\n{\n    Q_OBJECT\nprivate Q_SLOTS:\n    void testSingleKnownHost_data();\n    void testSingleKnownHost();\n    void testMultilpeKnownHosts();\n    void testPolicyExpiration();\n    void testSTSHeaderParser();\n    void testStore();\n};\n\nvoid tst_QHsts::testSingleKnownHost_data()\n{\n    QTest::addColumn<QUrl>(\"knownHost\");\n    QTest::addColumn<QDateTime>(\"policyExpires\");\n    QTest::addColumn<bool>(\"includeSubDomains\");\n    QTest::addColumn<QUrl>(\"hostToTest\");\n    QTest::addColumn<bool>(\"isKnown\");\n\n    const QDateTime currentUTC = QDateTime::currentDateTimeUtc();\n    const QUrl knownHost(QLatin1String(\"http://example.com\"));\n    const QUrl validSubdomain(QLatin1String(\"https://sub.example.com/ohoho\"));\n    const QUrl unknownDomain(QLatin1String(\"http://example.org\"));\n    const QUrl subSubdomain(QLatin1String(\"https://level3.level2.example.com\"));\n\n    const QDateTime validDate(currentUTC.addSecs(1000));\n    QTest::newRow(\"same-known\") << knownHost << validDate << false << knownHost << true;\n    QTest::newRow(\"subexcluded\") << knownHost << validDate << false << validSubdomain << false;\n    QTest::newRow(\"subincluded\") << knownHost << validDate << true << validSubdomain << true;\n    QTest::newRow(\"unknown-subexcluded\") << knownHost << validDate << false << unknownDomain << false;\n    QTest::newRow(\"unknown-subincluded\") << knownHost << validDate << true << unknownDomain << false;\n    QTest::newRow(\"sub-subdomain-subincluded\") << knownHost << validDate << true << subSubdomain << true;\n    QTest::newRow(\"sub-subdomain-subexcluded\") << knownHost << validDate << false << subSubdomain << false;\n\n    const QDateTime invalidDate;\n    QTest::newRow(\"invalid-time\") << knownHost << invalidDate << false << knownHost << false;\n    QTest::newRow(\"invalid-time-subexcluded\") << knownHost << invalidDate << false\n                                              << validSubdomain << false;\n    QTest::newRow(\"invalid-time-subincluded\") << knownHost << invalidDate << true\n                                              << validSubdomain << false;\n\n    const QDateTime expiredDate(currentUTC.addSecs(-1000));\n    QTest::newRow(\"expired-time\") << knownHost << expiredDate << false << knownHost << false;\n    QTest::newRow(\"expired-time-subexcluded\") << knownHost << expiredDate << false\n                                              << validSubdomain << false;\n    QTest::newRow(\"expired-time-subincluded\") << knownHost << expiredDate << true\n                                              << validSubdomain << false;\n    const QUrl ipAsHost(QLatin1String(\"http://127.0.0.1\"));\n    QTest::newRow(\"ip-address-in-hostname\") << ipAsHost << validDate << false\n                                              << ipAsHost << false;\n\n    const QUrl anyIPv4AsHost(QLatin1String(\"http://0.0.0.0\"));\n    QTest::newRow(\"anyip4-address-in-hostname\") << anyIPv4AsHost << validDate\n                                                << false << anyIPv4AsHost << false;\n    const QUrl anyIPv6AsHost(QLatin1String(\"http://[::]\"));\n    QTest::newRow(\"anyip6-address-in-hostname\") << anyIPv6AsHost << validDate\n                                                << false << anyIPv6AsHost << false;\n\n}\n\nvoid tst_QHsts::testSingleKnownHost()\n{\n    QFETCH(const QUrl, knownHost);\n    QFETCH(const QDateTime, policyExpires);\n    QFETCH(const bool, includeSubDomains);\n    QFETCH(const QUrl, hostToTest);\n    QFETCH(const bool, isKnown);\n\n    QHstsCache cache;\n    cache.updateKnownHost(knownHost, policyExpires, includeSubDomains);\n    QCOMPARE(cache.isKnownHost(hostToTest), isKnown);\n}\n\nvoid tst_QHsts::testMultilpeKnownHosts()\n{\n    const QDateTime currentUTC = QDateTime::currentDateTimeUtc();\n    const QDateTime validDate(currentUTC.addSecs(10000));\n    const QDateTime expiredDate(currentUTC.addSecs(-10000));\n    const QUrl exampleCom(QLatin1String(\"https://example.com\"));\n    const QUrl subExampleCom(QLatin1String(\"https://sub.example.com\"));\n\n    QHstsCache cache;\n    // example.com is HSTS and includes subdomains:\n    cache.updateKnownHost(exampleCom, validDate, true);\n    QVERIFY(cache.isKnownHost(exampleCom));\n    QVERIFY(cache.isKnownHost(subExampleCom));\n    // example.com can set its policy not to include subdomains:\n    cache.updateKnownHost(exampleCom, validDate, false);\n    QVERIFY(!cache.isKnownHost(subExampleCom));\n    // but sub.example.com can set its own policy:\n    cache.updateKnownHost(subExampleCom, validDate, false);\n    QVERIFY(cache.isKnownHost(subExampleCom));\n    // let's say example.com's policy has expired:\n    cache.updateKnownHost(exampleCom, expiredDate, false);\n    QVERIFY(!cache.isKnownHost(exampleCom));\n    // it should not affect sub.example.com's policy:\n    QVERIFY(cache.isKnownHost(subExampleCom));\n\n    // clear cache and invalidate all policies:\n    cache.clear();\n    QVERIFY(!cache.isKnownHost(exampleCom));\n    QVERIFY(!cache.isKnownHost(subExampleCom));\n\n    // siblings:\n    const QUrl anotherSub(QLatin1String(\"https://sub2.example.com\"));\n    cache.updateKnownHost(subExampleCom, validDate, true);\n    cache.updateKnownHost(anotherSub, validDate, true);\n    QVERIFY(cache.isKnownHost(subExampleCom));\n    QVERIFY(cache.isKnownHost(anotherSub));\n    // they cannot set superdomain's policy:\n    QVERIFY(!cache.isKnownHost(exampleCom));\n    // a sibling cannot set another sibling's policy:\n    cache.updateKnownHost(anotherSub, expiredDate, false);\n    QVERIFY(cache.isKnownHost(subExampleCom));\n    QVERIFY(!cache.isKnownHost(anotherSub));\n    QVERIFY(!cache.isKnownHost(exampleCom));\n    // let's make example.com known again:\n    cache.updateKnownHost(exampleCom, validDate, true);\n    // a subdomain cannot affect its superdomain's policy:\n    cache.updateKnownHost(subExampleCom, expiredDate, true);\n    QVERIFY(cache.isKnownHost(exampleCom));\n    // and this superdomain includes subdomains in its HSTS policy:\n    QVERIFY(cache.isKnownHost(subExampleCom));\n    QVERIFY(cache.isKnownHost(anotherSub));\n\n    // a subdomain (with its subdomains) cannot affect its superdomain's policy:\n    cache.updateKnownHost(exampleCom, expiredDate, true);\n    cache.updateKnownHost(subExampleCom, validDate, true);\n    QVERIFY(cache.isKnownHost(subExampleCom));\n    QVERIFY(!cache.isKnownHost(exampleCom));\n}\n\nvoid tst_QHsts::testPolicyExpiration()\n{\n    QDateTime currentUTC = QDateTime::currentDateTimeUtc();\n    const QUrl exampleCom(QLatin1String(\"http://example.com\"));\n    const QUrl subdomain(QLatin1String(\"http://subdomain.example.com\"));\n    const qint64 lifeTimeMS = 50;\n\n    QHstsCache cache;\n    // start with 'includeSubDomains' and 5 s. lifetime:\n    cache.updateKnownHost(exampleCom, currentUTC.addMSecs(lifeTimeMS), true);\n    QVERIFY(cache.isKnownHost(exampleCom));\n    QVERIFY(cache.isKnownHost(subdomain));\n    // wait for approx. a half of lifetime:\n    QTest::qWait(lifeTimeMS / 2);\n\n    if (QDateTime::currentDateTimeUtc() < currentUTC.addMSecs(lifeTimeMS)) {\n        // Should still be valid:\n        QVERIFY(cache.isKnownHost(exampleCom));\n        QVERIFY(cache.isKnownHost(subdomain));\n    }\n\n    QTest::qWait(lifeTimeMS);\n    // expired:\n    QVERIFY(!cache.isKnownHost(exampleCom));\n    QVERIFY(!cache.isKnownHost(subdomain));\n\n    // now check that superdomain's policy expires, but not subdomain's policy:\n    currentUTC = QDateTime::currentDateTimeUtc();\n    cache.updateKnownHost(exampleCom, currentUTC.addMSecs(lifeTimeMS / 5), true);\n    cache.updateKnownHost(subdomain, currentUTC.addMSecs(lifeTimeMS), true);\n    QVERIFY(cache.isKnownHost(exampleCom));\n    QVERIFY(cache.isKnownHost(subdomain));\n    QTest::qWait(lifeTimeMS / 2);\n    if (QDateTime::currentDateTimeUtc() < currentUTC.addMSecs(lifeTimeMS)) {\n        QVERIFY(!cache.isKnownHost(exampleCom));\n        QVERIFY(cache.isKnownHost(subdomain));\n    }\n}\n\nvoid tst_QHsts::testSTSHeaderParser()\n{\n    QHstsHeaderParser parser;\n    using Header = QPair<QByteArray, QByteArray>;\n    using Headers = QList<Header>;\n\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n    Headers list;\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n\n    list << Header(\"Strict-Transport-security\", \"200\");\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n\n    // This header is missing REQUIRED max-age directive, so we'll ignore it:\n    list << Header(\"Strict-Transport-Security\", \"includeSubDomains\");\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n\n    list.pop_back();\n    list << Header(\"Strict-Transport-Security\", \"includeSubDomains;max-age=1000\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(parser.expirationDate() > QDateTime::currentDateTimeUtc());\n    QVERIFY(parser.includeSubDomains());\n\n    list.pop_back();\n    list << Header(\"strict-transport-security\", \"includeSubDomains;max-age=1000\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(parser.expirationDate() > QDateTime::currentDateTimeUtc());\n    QVERIFY(parser.includeSubDomains());\n\n    list.pop_back();\n    // Invalid (includeSubDomains twice):\n    list << Header(\"Strict-Transport-Security\", \"max-age = 1000 ; includeSubDomains;includeSubDomains\");\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n\n    list.pop_back();\n    // Invalid (weird number of seconds):\n    list << Header(\"Strict-Transport-Security\", \"max-age=-1000   ; includeSubDomains\");\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n\n    list.pop_back();\n    // Note, directives are case-insensitive + we should ignore unknown directive.\n    list << Header(\"Strict-Transport-Security\", \";max-age=1000 ;includesubdomains;;\"\n                   \"nowsomeunknownheader=\\\"somevaluewithescapes\\\\;\\\"\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(parser.includeSubDomains());\n    QVERIFY(parser.expirationDate().isValid());\n\n    list.pop_back();\n    // Check that we know how to unescape max-age:\n    list << Header(\"Strict-Transport-Security\", \"max-age=\\\"1000\\\"\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(parser.expirationDate().isValid());\n\n    list.pop_back();\n    // The only STS header, with invalid syntax though, to be ignored:\n    list << Header(\"Strict-Transport-Security\", \"max-age; max-age=15768000\");\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n\n    // Now we check that our parse chosses the first valid STS header and ignores\n    // others:\n    list.clear();\n    list << Header(\"Strict-Transport-Security\", \"includeSubdomains; max-age=\\\"hehehe\\\";\");\n    list << Header(\"Strict-Transport-Security\", \"max-age=10101\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(parser.expirationDate().isValid());\n\n\n    list.clear();\n    list << Header(\"Strict-Transport-Security\", \"max-age=0\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(parser.expirationDate() <= QDateTime::currentDateTimeUtc());\n\n    // Parsing is case-insensitive:\n    list.pop_back();\n    list << Header(\"Strict-Transport-Security\", \"Max-aGE=1000; InclUdesUbdomains\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(parser.includeSubDomains());\n    QVERIFY(parser.expirationDate().isValid());\n\n    // Grammar of STS header is quite permissive, let's check we can parse\n    // some weird but valid header:\n    list.pop_back();\n    list << Header(\"Strict-Transport-Security\", \";;; max-age = 17; ; ; ; ;;; ;;\"\n                    \";;; ; includeSubdomains ;;thisIsUnknownDirective;;;;\");\n    QVERIFY(parser.parse(list));\n    QVERIFY(parser.includeSubDomains());\n    QVERIFY(parser.expirationDate().isValid());\n\n    list.pop_back();\n    list << Header(\"Strict-Transport-Security\", \"max-age=1000; includeSubDomains bogon\");\n    QVERIFY(!parser.parse(list));\n    QVERIFY(!parser.includeSubDomains());\n    QVERIFY(!parser.expirationDate().isValid());\n}\n\nconst QLatin1String storeDir(\".\");\n\nstruct TestStoreDeleter\n{\n    ~TestStoreDeleter()\n    {\n        QDir cwd;\n        if (!cwd.remove(QHstsStore::absoluteFilePath(storeDir)))\n            qWarning() << \"tst_QHsts::testStore: failed to remove the hsts store file\";\n    }\n};\n\nvoid tst_QHsts::testStore()\n{\n    // Delete the store's file after we finish the test.\n    TestStoreDeleter cleaner;\n\n    const QUrl exampleCom(QStringLiteral(\"http://example.com\"));\n    const QUrl subDomain(QStringLiteral(\"http://subdomain.example.com\"));\n    const QDateTime validDate(QDateTime::currentDateTimeUtc().addDays(1));\n\n    {\n        // We start from an empty cache and empty store:\n        QHstsCache cache;\n        QHstsStore store(storeDir);\n        cache.setStore(&store);\n        QVERIFY(!cache.isKnownHost(exampleCom));\n        QVERIFY(!cache.isKnownHost(subDomain));\n        // (1) This will also store the policy:\n        cache.updateKnownHost(exampleCom, validDate, true);\n        QVERIFY(cache.isKnownHost(exampleCom));\n        QVERIFY(cache.isKnownHost(subDomain));\n    }\n    {\n        // Test the policy stored at (1):\n        QHstsCache cache;\n        QHstsStore store(storeDir);\n        cache.setStore(&store);\n        QVERIFY(cache.isKnownHost(exampleCom));\n        QVERIFY(cache.isKnownHost(subDomain));\n        // (2) Remove subdomains:\n        cache.updateKnownHost(exampleCom, validDate, false);\n        QVERIFY(!cache.isKnownHost(subDomain));\n    }\n    {\n        // Test the previous update (2):\n        QHstsCache cache;\n        QHstsStore store(storeDir);\n        cache.setStore(&store);\n        QVERIFY(cache.isKnownHost(exampleCom));\n        QVERIFY(!cache.isKnownHost(subDomain));\n    }\n    {\n        QHstsCache cache;\n        cache.updateKnownHost(subDomain, validDate, false);\n        QVERIFY(cache.isKnownHost(subDomain));\n        QHstsStore store(storeDir);\n        // (3) This should store policy from cache, over old policy from store:\n        cache.setStore(&store);\n    }\n    {\n        // Test that (3) was stored:\n        QHstsCache cache;\n        QHstsStore store(storeDir);\n        cache.setStore(&store);\n        QVERIFY(cache.isKnownHost(subDomain));\n    }\n}\n\nQTEST_MAIN(tst_QHsts)\n\n#include \"tst_qhsts.moc\"\n"], "filenames": ["src/network/access/qhsts.cpp", "tests/auto/network/access/hsts/tst_qhsts.cpp"], "buggy_code_start_loc": [330, 219], "buggy_code_end_loc": [332, 219], "fixing_code_start_loc": [330, 220], "fixing_code_end_loc": [332, 226], "type": "NVD-CWE-noinfo", "message": "An issue was discovered in Qt before 5.15.14, 6.x before 6.2.9, and 6.3.x through 6.5.x before 6.5.1. Qt Network incorrectly parses the strict-transport-security (HSTS) header, allowing unencrypted connections to be established, even when explicitly prohibited by the server. This happens if the case used for this header does not exactly match.", "other": {"cve": {"id": "CVE-2023-32762", "sourceIdentifier": "cve@mitre.org", "published": "2023-05-28T23:15:09.570", "lastModified": "2023-06-03T03:57:36.630", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Qt before 5.15.14, 6.x before 6.2.9, and 6.3.x through 6.5.x before 6.5.1. Qt Network incorrectly parses the strict-transport-security (HSTS) header, allowing unencrypted connections to be established, even when explicitly prohibited by the server. This happens if the case used for this header does not exactly match."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qt:qt:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.15.14", "matchCriteriaId": "006030F9-35BF-489D-8C3F-14ECF93518C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qt:qt:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.2.9", "matchCriteriaId": "513DDB0D-A132-4046-8B49-D2776E585826"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qt:qt:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.3.0", "versionEndExcluding": "6.5.1", "matchCriteriaId": "116DC3F0-630E-43F6-AD19-0ABB41CF3D70"}]}]}], "references": [{"url": "https://codereview.qt-project.org/c/qt/qtbase/+/476140", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/qt/qtbase/commit/1b736a815be0222f4b24289cf17575fc15707305", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.qt-project.org/pipermail/announce/2023-May/000414.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}]}, "github_commit_url": "https://github.com/qt/qtbase/commit/1b736a815be0222f4b24289cf17575fc15707305"}}