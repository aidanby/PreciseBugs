{"buggy_code": ["language: ruby\n\nrvm:\n  - ruby-head\n  - 2.4.2\n  - 2.3.5\n  - 2.2.8\n  - jruby-head\n\nenv:\n  - SUITE=rspec spec\n  - SUITE=rubocop\n\nscript: bundle exec $SUITE\n\nmatrix:\n  allow_failures:\n    - rvm: jruby-head\n    - rvm: ruby-head\n\nbefore_install: gem update bundler\nbundler_args: --without guard -j 3\n\nsudo: false\ncache: bundler\n", "# frozen_string_literal: true\nsource \"https://rubygems.org\"\n\ngemspec\n\ngroup :test do\n  gem \"coveralls\"\n  gem \"json\"\n  gem \"pry-nav\"\n  gem \"rack\"\n  gem \"rspec\"\n  gem \"rubocop\"\n  gem \"rubocop-github\"\n  gem \"term-ansicolor\"\n  gem \"tins\"\nend\n\ngroup :guard do\n  gem \"growl\"\n  gem \"guard-rspec\", platforms: [:ruby_19, :ruby_20, :ruby_21, :ruby_22, :ruby_23, :ruby_24]\n  gem \"rb-fsevent\"\n  gem \"terminal-notifier-guard\"\nend\n", "# frozen_string_literal: true\nrequire_relative \"policy_management\"\nrequire_relative \"content_security_policy_config\"\nrequire \"useragent\"\n\nmodule SecureHeaders\n  class ContentSecurityPolicy\n    include PolicyManagement\n\n    # constants to be used for version-specific UA sniffing\n    VERSION_46 = ::UserAgent::Version.new(\"46\")\n    VERSION_10 = ::UserAgent::Version.new(\"10\")\n    FALLBACK_VERSION = ::UserAgent::Version.new(\"0\")\n\n    def initialize(config = nil, user_agent = OTHER)\n      @config = if config.is_a?(Hash)\n        if config[:report_only]\n          ContentSecurityPolicyReportOnlyConfig.new(config || DEFAULT_CONFIG)\n        else\n          ContentSecurityPolicyConfig.new(config || DEFAULT_CONFIG)\n        end\n      elsif config.nil?\n        ContentSecurityPolicyConfig.new(DEFAULT_CONFIG)\n      else\n        config\n      end\n\n      @parsed_ua = if user_agent.is_a?(UserAgent::Browsers::Base)\n        user_agent\n      else\n        UserAgent.parse(user_agent)\n      end\n      @frame_src = normalize_child_frame_src\n      @preserve_schemes = @config.preserve_schemes\n      @script_nonce = @config.script_nonce\n      @style_nonce = @config.style_nonce\n    end\n\n    ##\n    # Returns the name to use for the header. Either \"Content-Security-Policy\" or\n    # \"Content-Security-Policy-Report-Only\"\n    def name\n      @config.class.const_get(:HEADER_NAME)\n    end\n\n    ##\n    # Return the value of the CSP header\n    def value\n      @value ||= if @config\n        build_value\n      else\n        DEFAULT_VALUE\n      end\n    end\n\n    private\n\n    def normalize_child_frame_src\n      if @config.frame_src && @config.child_src && @config.frame_src != @config.child_src\n        raise ArgumentError, \"#{Kernel.caller.first}: both :child_src and :frame_src supplied and do not match. This can lead to inconsistent behavior across browsers.\"\n      end\n\n      @config.frame_src || @config.child_src\n    end\n\n    # Private: converts the config object into a string representing a policy.\n    # Places default-src at the first directive and report-uri as the last. All\n    # others are presented in alphabetical order.\n    #\n    # Unsupported directives are filtered based on the user agent.\n    #\n    # Returns a content security policy header value.\n    def build_value\n      directives.map do |directive_name|\n        case DIRECTIVE_VALUE_TYPES[directive_name]\n        when :boolean\n          symbol_to_hyphen_case(directive_name) if @config.directive_value(directive_name)\n        when :sandbox_list\n          build_sandbox_list_directive(directive_name)\n        when :media_type_list\n          build_media_type_list_directive(directive_name)\n        when :source_list\n          build_source_list_directive(directive_name)\n        end\n      end.compact.join(\"; \")\n    end\n\n    def build_sandbox_list_directive(directive)\n      return unless sandbox_list = @config.directive_value(directive)\n      max_strict_policy = case sandbox_list\n      when Array\n        sandbox_list.empty?\n      when true\n        true\n      else\n        false\n      end\n\n      # A maximally strict sandbox policy is just the `sandbox` directive,\n      # whith no configuraiton values.\n      if max_strict_policy\n        symbol_to_hyphen_case(directive)\n      elsif sandbox_list && sandbox_list.any?\n        [\n          symbol_to_hyphen_case(directive),\n          sandbox_list.uniq\n        ].join(\" \")\n      end\n    end\n\n    def build_media_type_list_directive(directive)\n      return unless media_type_list = @config.directive_value(directive)\n      if media_type_list && media_type_list.any?\n        [\n          symbol_to_hyphen_case(directive),\n          media_type_list.uniq\n        ].join(\" \")\n      end\n    end\n\n    # Private: builds a string that represents one directive in a minified form.\n    #\n    # directive_name - a symbol representing the various ALL_DIRECTIVES\n    #\n    # Returns a string representing a directive.\n    def build_source_list_directive(directive)\n      source_list = case directive\n      when :child_src\n        if supported_directives.include?(:child_src)\n          @frame_src\n        end\n      when :frame_src\n        unless supported_directives.include?(:child_src)\n          @frame_src\n        end\n      else\n        @config.directive_value(directive)\n      end\n\n      if source_list != OPT_OUT && source_list && source_list.any?\n        normalized_source_list = minify_source_list(directive, source_list)\n        [symbol_to_hyphen_case(directive), normalized_source_list].join(\" \")\n      end\n    end\n\n    # If a directive contains *, all other values are omitted.\n    # If a directive contains 'none' but has other values, 'none' is ommitted.\n    # Schemes are stripped (see http://www.w3.org/TR/CSP2/#match-source-expression)\n    def minify_source_list(directive, source_list)\n      source_list = source_list.compact\n      if source_list.include?(STAR)\n        keep_wildcard_sources(source_list)\n      else\n        source_list = populate_nonces(directive, source_list)\n        source_list = reject_all_values_if_none(source_list)\n\n        unless directive == REPORT_URI || @preserve_schemes\n          source_list = strip_source_schemes(source_list)\n        end\n        dedup_source_list(source_list)\n      end\n    end\n\n    # Discard trailing entries (excluding unsafe-*) since * accomplishes the same.\n    def keep_wildcard_sources(source_list)\n      source_list.select { |value| WILDCARD_SOURCES.include?(value) }\n    end\n\n    # Discard any 'none' values if more directives are supplied since none may override values.\n    def reject_all_values_if_none(source_list)\n      if source_list.length > 1\n        source_list.reject { |value| value == NONE }\n      else\n        source_list\n      end\n    end\n\n    # Removes duplicates and sources that already match an existing wild card.\n    #\n    # e.g. *.github.com asdf.github.com becomes *.github.com\n    def dedup_source_list(sources)\n      sources = sources.uniq\n      wild_sources = sources.select { |source| source =~ STAR_REGEXP }\n\n      if wild_sources.any?\n        sources.reject do |source|\n          !wild_sources.include?(source) &&\n            wild_sources.any? { |pattern| File.fnmatch(pattern, source) }\n        end\n      else\n        sources\n      end\n    end\n\n    # Private: append a nonce to the script/style directories if script_nonce\n    # or style_nonce are provided.\n    def populate_nonces(directive, source_list)\n      case directive\n      when SCRIPT_SRC\n        append_nonce(source_list, @script_nonce)\n      when STYLE_SRC\n        append_nonce(source_list, @style_nonce)\n      else\n        source_list\n      end\n    end\n\n    # Private: adds a nonce or 'unsafe-inline' depending on browser support.\n    # If a nonce is populated, inline content is assumed.\n    #\n    # While CSP is backward compatible in that a policy with a nonce will ignore\n    # unsafe-inline, this is more concise.\n    def append_nonce(source_list, nonce)\n      if nonce\n        if nonces_supported?\n          source_list << \"'nonce-#{nonce}'\"\n        else\n          source_list << UNSAFE_INLINE\n        end\n      end\n\n      source_list\n    end\n\n    # Private: return the list of directives that are supported by the user agent,\n    # starting with default-src and ending with report-uri.\n    def directives\n      [\n        DEFAULT_SRC,\n        BODY_DIRECTIVES.select { |key| supported_directives.include?(key) },\n        REPORT_URI\n      ].flatten\n    end\n\n    # Private: Remove scheme from source expressions.\n    def strip_source_schemes(source_list)\n      source_list.map { |source_expression| source_expression.sub(HTTP_SCHEME_REGEX, \"\") }\n    end\n\n    # Private: determine which directives are supported for the given user agent.\n    #\n    # Add UA-sniffing special casing here.\n    #\n    # Returns an array of symbols representing the directives.\n    def supported_directives\n      @supported_directives ||= if VARIATIONS[@parsed_ua.browser]\n        if @parsed_ua.browser == \"Firefox\" && ((@parsed_ua.version || FALLBACK_VERSION) >= VERSION_46)\n          VARIATIONS[\"FirefoxTransitional\"]\n        elsif @parsed_ua.browser == \"Safari\" && ((@parsed_ua.version || FALLBACK_VERSION) >= VERSION_10)\n          VARIATIONS[\"SafariTransitional\"]\n        else\n          VARIATIONS[@parsed_ua.browser]\n        end\n      else\n        VARIATIONS[OTHER]\n      end\n    end\n\n    def nonces_supported?\n      @nonces_supported ||= self.class.nonces_supported?(@parsed_ua)\n    end\n\n    def symbol_to_hyphen_case(sym)\n      sym.to_s.tr(\"_\", \"-\")\n    end\n  end\nend\n", "# frozen_string_literal: true\nrequire \"spec_helper\"\n\nmodule SecureHeaders\n  describe ContentSecurityPolicy do\n    let (:default_opts) do\n      {\n        default_src: %w(https:),\n        img_src: %w(https: data:),\n        script_src: %w('unsafe-inline' 'unsafe-eval' https: data:),\n        style_src: %w('unsafe-inline' https: about:),\n        report_uri: %w(/csp_report)\n      }\n    end\n\n    describe \"#name\" do\n      context \"when in report-only mode\" do\n        specify { expect(ContentSecurityPolicy.new(default_opts.merge(report_only: true)).name).to eq(ContentSecurityPolicyReportOnlyConfig::HEADER_NAME) }\n      end\n\n      context \"when in enforce mode\" do\n        specify { expect(ContentSecurityPolicy.new(default_opts).name).to eq(ContentSecurityPolicyConfig::HEADER_NAME) }\n      end\n    end\n\n    describe \"#value\" do\n      it \"uses a safe but non-breaking default value\" do\n        expect(ContentSecurityPolicy.new.value).to eq(\"default-src https:; form-action 'self'; img-src https: data: 'self'; object-src 'none'; script-src https:; style-src 'self' 'unsafe-inline' https:\")\n      end\n\n      it \"discards 'none' values if any other source expressions are present\" do\n        csp = ContentSecurityPolicy.new(default_opts.merge(child_src: %w('self' 'none')))\n        expect(csp.value).not_to include(\"'none'\")\n      end\n\n      it \"discards source expressions (besides unsafe-* and non-host source values) when * is present\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(* 'unsafe-inline' 'unsafe-eval' http: https: example.org data: blob:))\n        expect(csp.value).to eq(\"default-src * 'unsafe-inline' 'unsafe-eval' data: blob:\")\n      end\n\n      it \"minifies source expressions based on overlapping wildcards\" do\n        config = {\n          default_src: %w(a.example.org b.example.org *.example.org https://*.example.org)\n        }\n        csp = ContentSecurityPolicy.new(config)\n        expect(csp.value).to eq(\"default-src *.example.org\")\n      end\n\n      it \"removes http/s schemes from hosts\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https://example.org))\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not build directives with a value of OPT_OUT (and bypasses directive requirements)\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https://example.org), script_src: OPT_OUT)\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not remove schemes from report-uri values\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https:), report_uri: %w(https://example.org))\n        expect(csp.value).to eq(\"default-src https:; report-uri https://example.org\")\n      end\n\n      it \"does not remove schemes when :preserve_schemes is true\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https://example.org), preserve_schemes: true)\n        expect(csp.value).to eq(\"default-src https://example.org\")\n      end\n\n      it \"removes nil from source lists\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\", nil])\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not add a directive if the value is an empty array (or all nil)\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], script_src: [nil])\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not add a directive if the value is nil\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], script_src: nil)\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does add a boolean directive if the value is true\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], block_all_mixed_content: true, upgrade_insecure_requests: true)\n        expect(csp.value).to eq(\"default-src example.org; block-all-mixed-content; upgrade-insecure-requests\")\n      end\n\n      it \"does not add a boolean directive if the value is false\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], block_all_mixed_content: true, upgrade_insecure_requests: false)\n        expect(csp.value).to eq(\"default-src example.org; block-all-mixed-content\")\n      end\n\n      it \"deduplicates any source expressions\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org example.org example.org))\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"creates maximally strict sandbox policy when passed no sandbox token values\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org), sandbox: [])\n        expect(csp.value).to eq(\"default-src example.org; sandbox\")\n      end\n\n      it \"creates maximally strict sandbox policy when passed true\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org), sandbox: true)\n        expect(csp.value).to eq(\"default-src example.org; sandbox\")\n      end\n\n      it \"creates sandbox policy when passed valid sandbox token values\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org), sandbox: %w(allow-forms allow-scripts))\n        expect(csp.value).to eq(\"default-src example.org; sandbox allow-forms allow-scripts\")\n      end\n\n      it \"does not emit a warning when using frame-src\" do\n        expect(Kernel).to_not receive(:warn)\n        ContentSecurityPolicy.new(default_src: %w('self'), frame_src: %w('self')).value\n      end\n\n      it \"raises an error when child-src and frame-src are supplied but are not equal\" do\n        expect {\n          ContentSecurityPolicy.new(default_src: %w('self'), child_src: %w(child-src.com), frame_src: %w(frame-src,com)).value\n        }.to raise_error(ArgumentError)\n      end\n\n      it \"supports strict-dynamic\" do\n        csp = ContentSecurityPolicy.new({default_src: %w('self'), script_src: [ContentSecurityPolicy::STRICT_DYNAMIC], script_nonce: 123456}, USER_AGENTS[:chrome])\n        expect(csp.value).to eq(\"default-src 'self'; script-src 'strict-dynamic' 'nonce-123456'\")\n      end\n\n      context \"browser sniffing\" do\n        let (:complex_opts) do\n          (ContentSecurityPolicy::ALL_DIRECTIVES - [:frame_src]).each_with_object({}) do |directive, hash|\n            hash[directive] = [\"#{directive.to_s.gsub(\"_\", \"-\")}.com\"]\n          end.merge({\n            block_all_mixed_content: true,\n            upgrade_insecure_requests: true,\n            script_src: %w(script-src.com),\n            script_nonce: 123456,\n            sandbox: %w(allow-forms),\n            plugin_types: %w(application/pdf)\n          })\n        end\n\n        it \"does not filter any directives for Chrome\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:chrome])\n          expect(policy.value).to eq(\"default-src default-src.com; base-uri base-uri.com; block-all-mixed-content; child-src child-src.com; connect-src connect-src.com; font-src font-src.com; form-action form-action.com; frame-ancestors frame-ancestors.com; img-src img-src.com; manifest-src manifest-src.com; media-src media-src.com; object-src object-src.com; plugin-types application/pdf; sandbox allow-forms; script-src script-src.com 'nonce-123456'; style-src style-src.com; upgrade-insecure-requests; worker-src worker-src.com; report-uri report-uri.com\")\n        end\n\n        it \"does not filter any directives for Opera\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:opera])\n          expect(policy.value).to eq(\"default-src default-src.com; base-uri base-uri.com; block-all-mixed-content; child-src child-src.com; connect-src connect-src.com; font-src font-src.com; form-action form-action.com; frame-ancestors frame-ancestors.com; img-src img-src.com; manifest-src manifest-src.com; media-src media-src.com; object-src object-src.com; plugin-types application/pdf; sandbox allow-forms; script-src script-src.com 'nonce-123456'; style-src style-src.com; upgrade-insecure-requests; worker-src worker-src.com; report-uri report-uri.com\")\n        end\n\n        it \"filters blocked-all-mixed-content, child-src, and plugin-types for firefox\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:firefox])\n          expect(policy.value).to eq(\"default-src default-src.com; base-uri base-uri.com; connect-src connect-src.com; font-src font-src.com; form-action form-action.com; frame-ancestors frame-ancestors.com; frame-src child-src.com; img-src img-src.com; manifest-src manifest-src.com; media-src media-src.com; object-src object-src.com; sandbox allow-forms; script-src script-src.com 'nonce-123456'; style-src style-src.com; upgrade-insecure-requests; report-uri report-uri.com\")\n        end\n\n        it \"filters blocked-all-mixed-content, frame-src, and plugin-types for firefox 46 and higher\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:firefox46])\n          expect(policy.value).to eq(\"default-src default-src.com; base-uri base-uri.com; child-src child-src.com; connect-src connect-src.com; font-src font-src.com; form-action form-action.com; frame-ancestors frame-ancestors.com; img-src img-src.com; manifest-src manifest-src.com; media-src media-src.com; object-src object-src.com; sandbox allow-forms; script-src script-src.com 'nonce-123456'; style-src style-src.com; upgrade-insecure-requests; report-uri report-uri.com\")\n        end\n\n        it \"child-src value is copied to frame-src, adds 'unsafe-inline', filters base-uri, blocked-all-mixed-content, upgrade-insecure-requests, child-src, form-action, frame-ancestors, nonce sources, hash sources, and plugin-types for Edge\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:edge])\n          expect(policy.value).to eq(\"default-src default-src.com; connect-src connect-src.com; font-src font-src.com; frame-src child-src.com; img-src img-src.com; media-src media-src.com; object-src object-src.com; sandbox allow-forms; script-src script-src.com 'unsafe-inline'; style-src style-src.com; report-uri report-uri.com\")\n        end\n\n        it \"child-src value is copied to frame-src, adds 'unsafe-inline', filters base-uri, blocked-all-mixed-content, upgrade-insecure-requests, child-src, form-action, frame-ancestors, nonce sources, hash sources, and plugin-types for safari\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:safari6])\n          expect(policy.value).to eq(\"default-src default-src.com; connect-src connect-src.com; font-src font-src.com; frame-src child-src.com; img-src img-src.com; media-src media-src.com; object-src object-src.com; sandbox allow-forms; script-src script-src.com 'unsafe-inline'; style-src style-src.com; report-uri report-uri.com\")\n        end\n\n        it \"adds 'unsafe-inline', filters  blocked-all-mixed-content, upgrade-insecure-requests, nonce sources, and hash sources for safari 10 and higher\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:safari10])\n          expect(policy.value).to eq(\"default-src default-src.com; base-uri base-uri.com; child-src child-src.com; connect-src connect-src.com; font-src font-src.com; form-action form-action.com; frame-ancestors frame-ancestors.com; img-src img-src.com; media-src media-src.com; object-src object-src.com; plugin-types application/pdf; sandbox allow-forms; script-src script-src.com 'nonce-123456'; style-src style-src.com; report-uri report-uri.com\")\n        end\n\n        it \"falls back to standard Firefox defaults when the useragent version is not present\" do\n          ua = USER_AGENTS[:firefox].dup\n          allow(ua).to receive(:version).and_return(nil)\n          policy = ContentSecurityPolicy.new(complex_opts, ua)\n          expect(policy.value).to eq(\"default-src default-src.com; base-uri base-uri.com; connect-src connect-src.com; font-src font-src.com; form-action form-action.com; frame-ancestors frame-ancestors.com; frame-src child-src.com; img-src img-src.com; manifest-src manifest-src.com; media-src media-src.com; object-src object-src.com; sandbox allow-forms; script-src script-src.com 'nonce-123456'; style-src style-src.com; upgrade-insecure-requests; report-uri report-uri.com\")\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["language: ruby\n\nrvm:\n  - ruby-head\n  - 2.6\n  - 2.5\n  - 2.4\n  - jruby-head\n\nenv:\n  - SUITE=rspec spec\n  - SUITE=rubocop\n\nscript: bundle exec $SUITE\n\nmatrix:\n  allow_failures:\n    - rvm: jruby-head\n    - rvm: ruby-head\n\nbefore_install: gem update bundler\nbundler_args: --without guard -j 3\n\nsudo: false\ncache: bundler\n", "# frozen_string_literal: true\nsource \"https://rubygems.org\"\n\ngemspec\n\ngroup :test do\n  gem \"coveralls\"\n  gem \"json\"\n  gem \"pry-nav\"\n  gem \"rack\"\n  gem \"rspec\"\n  gem \"rubocop\", \"< 0.68\"\n  gem \"rubocop-github\"\n  gem \"term-ansicolor\"\n  gem \"tins\"\nend\n\ngroup :guard do\n  gem \"growl\"\n  gem \"guard-rspec\", platforms: [:ruby_19, :ruby_20, :ruby_21, :ruby_22, :ruby_23, :ruby_24]\n  gem \"rb-fsevent\"\n  gem \"terminal-notifier-guard\"\nend\n", "# frozen_string_literal: true\nrequire_relative \"policy_management\"\nrequire_relative \"content_security_policy_config\"\nrequire \"useragent\"\n\nmodule SecureHeaders\n  class ContentSecurityPolicy\n    include PolicyManagement\n\n    # constants to be used for version-specific UA sniffing\n    VERSION_46 = ::UserAgent::Version.new(\"46\")\n    VERSION_10 = ::UserAgent::Version.new(\"10\")\n    FALLBACK_VERSION = ::UserAgent::Version.new(\"0\")\n\n    def initialize(config = nil, user_agent = OTHER)\n      @config = if config.is_a?(Hash)\n        if config[:report_only]\n          ContentSecurityPolicyReportOnlyConfig.new(config || DEFAULT_CONFIG)\n        else\n          ContentSecurityPolicyConfig.new(config || DEFAULT_CONFIG)\n        end\n      elsif config.nil?\n        ContentSecurityPolicyConfig.new(DEFAULT_CONFIG)\n      else\n        config\n      end\n\n      @parsed_ua = if user_agent.is_a?(UserAgent::Browsers::Base)\n        user_agent\n      else\n        UserAgent.parse(user_agent)\n      end\n      @frame_src = normalize_child_frame_src\n      @preserve_schemes = @config.preserve_schemes\n      @script_nonce = @config.script_nonce\n      @style_nonce = @config.style_nonce\n    end\n\n    ##\n    # Returns the name to use for the header. Either \"Content-Security-Policy\" or\n    # \"Content-Security-Policy-Report-Only\"\n    def name\n      @config.class.const_get(:HEADER_NAME)\n    end\n\n    ##\n    # Return the value of the CSP header\n    def value\n      @value ||= if @config\n        build_value\n      else\n        DEFAULT_VALUE\n      end\n    end\n\n    private\n\n    def normalize_child_frame_src\n      if @config.frame_src && @config.child_src && @config.frame_src != @config.child_src\n        raise ArgumentError, \"#{Kernel.caller.first}: both :child_src and :frame_src supplied and do not match. This can lead to inconsistent behavior across browsers.\"\n      end\n\n      @config.frame_src || @config.child_src\n    end\n\n    # Private: converts the config object into a string representing a policy.\n    # Places default-src at the first directive and report-uri as the last. All\n    # others are presented in alphabetical order.\n    #\n    # Unsupported directives are filtered based on the user agent.\n    #\n    # Returns a content security policy header value.\n    def build_value\n      directives.map do |directive_name|\n        case DIRECTIVE_VALUE_TYPES[directive_name]\n        when :boolean\n          symbol_to_hyphen_case(directive_name) if @config.directive_value(directive_name)\n        when :sandbox_list\n          build_sandbox_list_directive(directive_name)\n        when :media_type_list\n          build_media_type_list_directive(directive_name)\n        when :source_list\n          build_source_list_directive(directive_name)\n        end\n      end.compact.join(\"; \")\n    end\n\n    def build_sandbox_list_directive(directive)\n      return unless sandbox_list = @config.directive_value(directive)\n      max_strict_policy = case sandbox_list\n      when Array\n        sandbox_list.empty?\n      when true\n        true\n      else\n        false\n      end\n\n      # A maximally strict sandbox policy is just the `sandbox` directive,\n      # whith no configuraiton values.\n      if max_strict_policy\n        symbol_to_hyphen_case(directive)\n      elsif sandbox_list && sandbox_list.any?\n        [\n          symbol_to_hyphen_case(directive),\n          sandbox_list.uniq\n        ].join(\" \")\n      end\n    end\n\n    def build_media_type_list_directive(directive)\n      return unless media_type_list = @config.directive_value(directive)\n      if media_type_list && media_type_list.any?\n        [\n          symbol_to_hyphen_case(directive),\n          media_type_list.uniq\n        ].join(\" \")\n      end\n    end\n\n    # Private: builds a string that represents one directive in a minified form.\n    #\n    # directive_name - a symbol representing the various ALL_DIRECTIVES\n    #\n    # Returns a string representing a directive.\n    def build_source_list_directive(directive)\n      source_list = case directive\n      when :child_src\n        if supported_directives.include?(:child_src)\n          @frame_src\n        end\n      when :frame_src\n        unless supported_directives.include?(:child_src)\n          @frame_src\n        end\n      else\n        @config.directive_value(directive)\n      end\n\n      if source_list != OPT_OUT && source_list && source_list.any?\n        minified_source_list = minify_source_list(directive, source_list).join(\" \")\n\n        if minified_source_list.include?(\";\")\n          Kernel.warn(\"#{directive} contains a ; in '#{minified_source_list}' which will raise an error in future versions. It has been replaced with a blank space.\")\n        end\n\n        escaped_source_list = minified_source_list.gsub(\";\", \" \")\n        [symbol_to_hyphen_case(directive), escaped_source_list].join(\" \").strip\n      end\n    end\n\n    # If a directive contains *, all other values are omitted.\n    # If a directive contains 'none' but has other values, 'none' is ommitted.\n    # Schemes are stripped (see http://www.w3.org/TR/CSP2/#match-source-expression)\n    def minify_source_list(directive, source_list)\n      source_list = source_list.compact\n      if source_list.include?(STAR)\n        keep_wildcard_sources(source_list)\n      else\n        source_list = populate_nonces(directive, source_list)\n        source_list = reject_all_values_if_none(source_list)\n\n        unless directive == REPORT_URI || @preserve_schemes\n          source_list = strip_source_schemes(source_list)\n        end\n        dedup_source_list(source_list)\n      end\n    end\n\n    # Discard trailing entries (excluding unsafe-*) since * accomplishes the same.\n    def keep_wildcard_sources(source_list)\n      source_list.select { |value| WILDCARD_SOURCES.include?(value) }\n    end\n\n    # Discard any 'none' values if more directives are supplied since none may override values.\n    def reject_all_values_if_none(source_list)\n      if source_list.length > 1\n        source_list.reject { |value| value == NONE }\n      else\n        source_list\n      end\n    end\n\n    # Removes duplicates and sources that already match an existing wild card.\n    #\n    # e.g. *.github.com asdf.github.com becomes *.github.com\n    def dedup_source_list(sources)\n      sources = sources.uniq\n      wild_sources = sources.select { |source| source =~ STAR_REGEXP }\n\n      if wild_sources.any?\n        sources.reject do |source|\n          !wild_sources.include?(source) &&\n            wild_sources.any? { |pattern| File.fnmatch(pattern, source) }\n        end\n      else\n        sources\n      end\n    end\n\n    # Private: append a nonce to the script/style directories if script_nonce\n    # or style_nonce are provided.\n    def populate_nonces(directive, source_list)\n      case directive\n      when SCRIPT_SRC\n        append_nonce(source_list, @script_nonce)\n      when STYLE_SRC\n        append_nonce(source_list, @style_nonce)\n      else\n        source_list\n      end\n    end\n\n    # Private: adds a nonce or 'unsafe-inline' depending on browser support.\n    # If a nonce is populated, inline content is assumed.\n    #\n    # While CSP is backward compatible in that a policy with a nonce will ignore\n    # unsafe-inline, this is more concise.\n    def append_nonce(source_list, nonce)\n      if nonce\n        if nonces_supported?\n          source_list << \"'nonce-#{nonce}'\"\n        else\n          source_list << UNSAFE_INLINE\n        end\n      end\n\n      source_list\n    end\n\n    # Private: return the list of directives that are supported by the user agent,\n    # starting with default-src and ending with report-uri.\n    def directives\n      [\n        DEFAULT_SRC,\n        BODY_DIRECTIVES.select { |key| supported_directives.include?(key) },\n        REPORT_URI\n      ].flatten\n    end\n\n    # Private: Remove scheme from source expressions.\n    def strip_source_schemes(source_list)\n      source_list.map { |source_expression| source_expression.sub(HTTP_SCHEME_REGEX, \"\") }\n    end\n\n    # Private: determine which directives are supported for the given user agent.\n    #\n    # Add UA-sniffing special casing here.\n    #\n    # Returns an array of symbols representing the directives.\n    def supported_directives\n      @supported_directives ||= if VARIATIONS[@parsed_ua.browser]\n        if @parsed_ua.browser == \"Firefox\" && ((@parsed_ua.version || FALLBACK_VERSION) >= VERSION_46)\n          VARIATIONS[\"FirefoxTransitional\"]\n        elsif @parsed_ua.browser == \"Safari\" && ((@parsed_ua.version || FALLBACK_VERSION) >= VERSION_10)\n          VARIATIONS[\"SafariTransitional\"]\n        else\n          VARIATIONS[@parsed_ua.browser]\n        end\n      else\n        VARIATIONS[OTHER]\n      end\n    end\n\n    def nonces_supported?\n      @nonces_supported ||= self.class.nonces_supported?(@parsed_ua)\n    end\n\n    def symbol_to_hyphen_case(sym)\n      sym.to_s.tr(\"_\", \"-\")\n    end\n  end\nend\n", "# frozen_string_literal: true\nrequire \"spec_helper\"\n\nmodule SecureHeaders\n  describe ContentSecurityPolicy do\n    let (:default_opts) do\n      {\n        default_src: %w(https:),\n        img_src: %w(https: data:),\n        script_src: %w('unsafe-inline' 'unsafe-eval' https: data:),\n        style_src: %w('unsafe-inline' https: about:),\n        report_uri: %w(/csp_report)\n      }\n    end\n\n    describe \"#name\" do\n      context \"when in report-only mode\" do\n        specify { expect(ContentSecurityPolicy.new(default_opts.merge(report_only: true)).name).to eq(ContentSecurityPolicyReportOnlyConfig::HEADER_NAME) }\n      end\n\n      context \"when in enforce mode\" do\n        specify { expect(ContentSecurityPolicy.new(default_opts).name).to eq(ContentSecurityPolicyConfig::HEADER_NAME) }\n      end\n    end\n\n    describe \"#value\" do\n      it \"uses a safe but non-breaking default value\" do\n        expect(ContentSecurityPolicy.new.value).to eq(\"default-src https:; form-action 'self'; img-src https: data: 'self'; object-src 'none'; script-src https:; style-src 'self' 'unsafe-inline' https:\")\n      end\n\n      it \"deprecates and escapes semicolons in directive source lists\" do\n        expect(Kernel).to receive(:warn).with(\"frame_ancestors contains a ; in 'google.com;script-src *;.;' which will raise an error in future versions. It has been replaced with a blank space.\")\n        expect(ContentSecurityPolicy.new(frame_ancestors: %w(https://google.com;script-src https://*;.;)).value).to eq(\"frame-ancestors google.com script-src * .\")\n      end\n\n      it \"discards 'none' values if any other source expressions are present\" do\n        csp = ContentSecurityPolicy.new(default_opts.merge(child_src: %w('self' 'none')))\n        expect(csp.value).not_to include(\"'none'\")\n      end\n\n      it \"discards source expressions (besides unsafe-* and non-host source values) when * is present\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(* 'unsafe-inline' 'unsafe-eval' http: https: example.org data: blob:))\n        expect(csp.value).to eq(\"default-src * 'unsafe-inline' 'unsafe-eval' data: blob:\")\n      end\n\n      it \"minifies source expressions based on overlapping wildcards\" do\n        config = {\n          default_src: %w(a.example.org b.example.org *.example.org https://*.example.org)\n        }\n        csp = ContentSecurityPolicy.new(config)\n        expect(csp.value).to eq(\"default-src *.example.org\")\n      end\n\n      it \"removes http/s schemes from hosts\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https://example.org))\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not build directives with a value of OPT_OUT (and bypasses directive requirements)\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https://example.org), script_src: OPT_OUT)\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not remove schemes from report-uri values\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https:), report_uri: %w(https://example.org))\n        expect(csp.value).to eq(\"default-src https:; report-uri https://example.org\")\n      end\n\n      it \"does not remove schemes when :preserve_schemes is true\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(https://example.org), preserve_schemes: true)\n        expect(csp.value).to eq(\"default-src https://example.org\")\n      end\n\n      it \"removes nil from source lists\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\", nil])\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not add a directive if the value is an empty array (or all nil)\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], script_src: [nil])\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does not add a directive if the value is nil\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], script_src: nil)\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"does add a boolean directive if the value is true\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], block_all_mixed_content: true, upgrade_insecure_requests: true)\n        expect(csp.value).to eq(\"default-src example.org; block-all-mixed-content; upgrade-insecure-requests\")\n      end\n\n      it \"does not add a boolean directive if the value is false\" do\n        csp = ContentSecurityPolicy.new(default_src: [\"https://example.org\"], block_all_mixed_content: true, upgrade_insecure_requests: false)\n        expect(csp.value).to eq(\"default-src example.org; block-all-mixed-content\")\n      end\n\n      it \"deduplicates any source expressions\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org example.org example.org))\n        expect(csp.value).to eq(\"default-src example.org\")\n      end\n\n      it \"creates maximally strict sandbox policy when passed no sandbox token values\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org), sandbox: [])\n        expect(csp.value).to eq(\"default-src example.org; sandbox\")\n      end\n\n      it \"creates maximally strict sandbox policy when passed true\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org), sandbox: true)\n        expect(csp.value).to eq(\"default-src example.org; sandbox\")\n      end\n\n      it \"creates sandbox policy when passed valid sandbox token values\" do\n        csp = ContentSecurityPolicy.new(default_src: %w(example.org), sandbox: %w(allow-forms allow-scripts))\n        expect(csp.value).to eq(\"default-src example.org; sandbox allow-forms allow-scripts\")\n      end\n\n      it \"does not emit a warning when using frame-src\" do\n        expect(Kernel).to_not receive(:warn)\n        ContentSecurityPolicy.new(default_src: %w('self'), frame_src: %w('self')).value\n      end\n\n      it \"raises an error when child-src and frame-src are supplied but are not equal\" do\n        expect {\n          ContentSecurityPolicy.new(default_src: %w('self'), child_src: %w(child-src.com), frame_src: %w(frame-src,com)).value\n        }.to raise_error(ArgumentError)\n      end\n\n      it \"supports strict-dynamic\" do\n        csp = ContentSecurityPolicy.new({default_src: %w('self'), script_src: [ContentSecurityPolicy::STRICT_DYNAMIC], script_nonce: 123456}, USER_AGENTS[:chrome])\n        expect(csp.value).to eq(\"default-src 'self'; script-src 'strict-dynamic' 'nonce-123456'\")\n      end\n\n      context \"browser sniffing\" do\n        let (:complex_opts) do\n          (ContentSecurityPolicy::ALL_DIRECTIVES - [:frame_src]).each_with_object({}) do |directive, hash|\n            hash[directive] = [\"#{directive.to_s.gsub(\"_\", \"-\")}.com\"]\n          end.merge({\n            block_all_mixed_content: true,\n            upgrade_insecure_requests: true,\n            script_src: %w(script-src.com),\n            script_nonce: 123456,\n            sandbox: %w(allow-forms),\n            plugin_types: %w(application/pdf)\n          })\n        end\n\n        it \"does not filter any directives for Chrome\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:chrome])\n          expect(policy.value).to eq(\"default-src default-src.com; base-uri base-uri.com; block-all-mixed-content; child-src child-src.com; connect-src connect-src.com; font-src font-src.com; form-action form-action.com; frame-ancestors frame-ancestors.com; img-src img-src.com; manifest-src manifest-src.com; media-src media-src.com; object-src object-src.com; plugin-types application/pdf; sandbox allow-forms; script-src script-src.com 'nonce-123456'; style-src style-src.com; upgrade-insecure-requests; worker-src worker-src.com; report-uri report-uri.com\")\n        end\n\n        it \"does not filter any directives for Opera\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:opera])\n          expect(policy.value).to eq(\"default-src default-src.com; base-uri base-uri.com; block-all-mixed-content; child-src child-src.com; connect-src connect-src.com; font-src font-src.com; form-action form-action.com; frame-ancestors frame-ancestors.com; img-src img-src.com; manifest-src manifest-src.com; media-src media-src.com; object-src object-src.com; plugin-types application/pdf; sandbox allow-forms; script-src script-src.com 'nonce-123456'; style-src style-src.com; upgrade-insecure-requests; worker-src worker-src.com; report-uri report-uri.com\")\n        end\n\n        it \"filters blocked-all-mixed-content, child-src, and plugin-types for firefox\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:firefox])\n          expect(policy.value).to eq(\"default-src default-src.com; base-uri base-uri.com; connect-src connect-src.com; font-src font-src.com; form-action form-action.com; frame-ancestors frame-ancestors.com; frame-src child-src.com; img-src img-src.com; manifest-src manifest-src.com; media-src media-src.com; object-src object-src.com; sandbox allow-forms; script-src script-src.com 'nonce-123456'; style-src style-src.com; upgrade-insecure-requests; report-uri report-uri.com\")\n        end\n\n        it \"filters blocked-all-mixed-content, frame-src, and plugin-types for firefox 46 and higher\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:firefox46])\n          expect(policy.value).to eq(\"default-src default-src.com; base-uri base-uri.com; child-src child-src.com; connect-src connect-src.com; font-src font-src.com; form-action form-action.com; frame-ancestors frame-ancestors.com; img-src img-src.com; manifest-src manifest-src.com; media-src media-src.com; object-src object-src.com; sandbox allow-forms; script-src script-src.com 'nonce-123456'; style-src style-src.com; upgrade-insecure-requests; report-uri report-uri.com\")\n        end\n\n        it \"child-src value is copied to frame-src, adds 'unsafe-inline', filters base-uri, blocked-all-mixed-content, upgrade-insecure-requests, child-src, form-action, frame-ancestors, nonce sources, hash sources, and plugin-types for Edge\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:edge])\n          expect(policy.value).to eq(\"default-src default-src.com; connect-src connect-src.com; font-src font-src.com; frame-src child-src.com; img-src img-src.com; media-src media-src.com; object-src object-src.com; sandbox allow-forms; script-src script-src.com 'unsafe-inline'; style-src style-src.com; report-uri report-uri.com\")\n        end\n\n        it \"child-src value is copied to frame-src, adds 'unsafe-inline', filters base-uri, blocked-all-mixed-content, upgrade-insecure-requests, child-src, form-action, frame-ancestors, nonce sources, hash sources, and plugin-types for safari\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:safari6])\n          expect(policy.value).to eq(\"default-src default-src.com; connect-src connect-src.com; font-src font-src.com; frame-src child-src.com; img-src img-src.com; media-src media-src.com; object-src object-src.com; sandbox allow-forms; script-src script-src.com 'unsafe-inline'; style-src style-src.com; report-uri report-uri.com\")\n        end\n\n        it \"adds 'unsafe-inline', filters  blocked-all-mixed-content, upgrade-insecure-requests, nonce sources, and hash sources for safari 10 and higher\" do\n          policy = ContentSecurityPolicy.new(complex_opts, USER_AGENTS[:safari10])\n          expect(policy.value).to eq(\"default-src default-src.com; base-uri base-uri.com; child-src child-src.com; connect-src connect-src.com; font-src font-src.com; form-action form-action.com; frame-ancestors frame-ancestors.com; img-src img-src.com; media-src media-src.com; object-src object-src.com; plugin-types application/pdf; sandbox allow-forms; script-src script-src.com 'nonce-123456'; style-src style-src.com; report-uri report-uri.com\")\n        end\n\n        it \"falls back to standard Firefox defaults when the useragent version is not present\" do\n          ua = USER_AGENTS[:firefox].dup\n          allow(ua).to receive(:version).and_return(nil)\n          policy = ContentSecurityPolicy.new(complex_opts, ua)\n          expect(policy.value).to eq(\"default-src default-src.com; base-uri base-uri.com; connect-src connect-src.com; font-src font-src.com; form-action form-action.com; frame-ancestors frame-ancestors.com; frame-src child-src.com; img-src img-src.com; manifest-src manifest-src.com; media-src media-src.com; object-src object-src.com; sandbox allow-forms; script-src script-src.com 'nonce-123456'; style-src style-src.com; upgrade-insecure-requests; report-uri report-uri.com\")\n        end\n      end\n    end\n  end\nend\n"], "filenames": [".travis.yml", "Gemfile", "lib/secure_headers/headers/content_security_policy.rb", "spec/lib/secure_headers/headers/content_security_policy_spec.rb"], "buggy_code_start_loc": [5, 12, 141, 28], "buggy_code_end_loc": [8, 13, 143, 28], "fixing_code_start_loc": [5, 12, 141, 29], "fixing_code_end_loc": [8, 13, 149, 34], "type": "CWE-74", "message": "In Secure Headers (RubyGem secure_headers), a directive injection vulnerability is present in versions before 3.8.0, 5.1.0, and 6.2.0. If user-supplied input was passed into append/override_content_security_policy_directives, a semicolon could be injected leading to directive injection. This could be used to e.g. override a script-src directive. Duplicate directives are ignored and the first one wins. The directives in secure_headers are sorted alphabetically so they pretty much all come before script-src. A previously undefined directive would receive a value even if SecureHeaders::OPT_OUT was supplied. The fixed versions will silently convert the semicolons to spaces and emit a deprecation warning when this happens. This will result in innocuous browser console messages if being exploited/accidentally used. In future releases, we will raise application errors resulting in 500s. Depending on what major version you are using, the fixed versions are 6.2.0, 5.1.0, 3.8.0.", "other": {"cve": {"id": "CVE-2020-5217", "sourceIdentifier": "security-advisories@github.com", "published": "2020-01-23T03:15:10.793", "lastModified": "2020-05-21T13:51:17.810", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Secure Headers (RubyGem secure_headers), a directive injection vulnerability is present in versions before 3.8.0, 5.1.0, and 6.2.0. If user-supplied input was passed into append/override_content_security_policy_directives, a semicolon could be injected leading to directive injection. This could be used to e.g. override a script-src directive. Duplicate directives are ignored and the first one wins. The directives in secure_headers are sorted alphabetically so they pretty much all come before script-src. A previously undefined directive would receive a value even if SecureHeaders::OPT_OUT was supplied. The fixed versions will silently convert the semicolons to spaces and emit a deprecation warning when this happens. This will result in innocuous browser console messages if being exploited/accidentally used. In future releases, we will raise application errors resulting in 500s. Depending on what major version you are using, the fixed versions are 6.2.0, 5.1.0, 3.8.0."}, {"lang": "es", "value": "En Secure Headers (secure_headers de RubyGem), una vulnerabilidad de inyecci\u00f3n de directiva est\u00e1 presente en las versiones anteriores a 3.8.0, 5.1.0 y 6.2.0. Si una entrada suministrada por el usuario fue pasada a append/override_content_security_policy_directives, se podr\u00eda inyectar un punto y coma conllevando a una inyecci\u00f3n de directiva. Esto podr\u00eda ser usado para, por ejemplo anular una directiva script-src. Las directivas duplicadas son ignoradas y la primera gana. Las directivas en secure_headers est\u00e1n ordenadas alfab\u00e9ticamente, por lo que casi todas van antes de script-src. Una directiva previamente indefinida recibir\u00eda un valor inclusive si la funci\u00f3n SecureHeaders::OPT_OUT fue suministrada. Las versiones corregidas convertir\u00e1n silenciosamente los puntos y comas en espacios y emitir\u00e1n una advertencia de desaprobaci\u00f3n cuando esto suceda. Esto resultar\u00e1 en mensajes inocuos de la consola del navegador si est\u00e1 siendo explotada o usada accidentalmente. En futuras versiones, generaremos errores de aplicaci\u00f3n resultando en 500. Seg\u00fan la versi\u00f3n principal que est\u00e9 usando, las versiones corregidas son 6.2.0, 5.1.0, 3.8.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-95"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:twitter:secure_headers:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "3.8.0", "matchCriteriaId": "F0F5AB6F-E584-4640-A497-3BC81A4171C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:twitter:secure_headers:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.1.0", "matchCriteriaId": "B8A7D02A-9E27-4388-A128-14BFCCA049CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:twitter:secure_headers:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.2.0", "matchCriteriaId": "D8B75B75-5C9C-4C8D-ACD6-214D042546E7"}]}]}], "references": [{"url": "https://github.com/twitter/secure_headers/commit/936a160e3e9659737a9f9eafce13eea36b5c9fa3", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/twitter/secure_headers/issues/418", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/twitter/secure_headers/pull/421", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/twitter/secure_headers/security/advisories/GHSA-xq52-rv6w-397c", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/twitter/secure_headers/commit/936a160e3e9659737a9f9eafce13eea36b5c9fa3"}}