{"buggy_code": ["require 'securerandom'\nrequire 'bindata'\nrequire 'aes_key_wrap'\n\nmodule JSON\n  class JWE\n    class InvalidFormat < JWT::InvalidFormat; end\n    class DecryptionFailed < JWT::VerificationFailed; end\n    class UnexpectedAlgorithm < JWT::UnexpectedAlgorithm; end\n\n    NUM_OF_SEGMENTS = 5\n\n    include JOSE\n\n    attr_accessor(\n      :public_key_or_secret, :private_key_or_secret,\n      :plain_text, :cipher_text, :iv, :auth_data,\n      :content_encryption_key, :encryption_key, :mac_key\n    )\n    attr_writer :jwe_encrypted_key, :authentication_tag\n\n    register_header_keys :enc, :epk, :zip, :apu, :apv\n    alias_method :encryption_method, :enc\n\n    def initialize(input = nil)\n      self.plain_text = input.to_s\n    end\n\n    def encrypt!(public_key_or_secret)\n      self.public_key_or_secret = with_jwk_support public_key_or_secret\n      cipher.encrypt\n      self.content_encryption_key = generate_content_encryption_key\n      self.mac_key, self.encryption_key = derive_encryption_and_mac_keys\n      cipher.key = encryption_key\n      self.iv = cipher.random_iv # NOTE: 'iv' has to be set after 'key' for GCM\n      self.auth_data = Base64.urlsafe_encode64 header.to_json, padding: false\n      cipher.auth_data = auth_data if gcm?\n      self.cipher_text = cipher.update(plain_text) + cipher.final\n      self\n    end\n\n    def decrypt!(private_key_or_secret, algorithms = nil, encryption_methods = nil)\n      raise UnexpectedAlgorithm.new('Unexpected alg header') unless algorithms.blank? || Array(algorithms).include?(alg)\n      raise UnexpectedAlgorithm.new('Unexpected enc header') unless encryption_methods.blank? || Array(encryption_methods).include?(enc)\n      self.private_key_or_secret = with_jwk_support private_key_or_secret\n      cipher.decrypt\n      self.content_encryption_key = decrypt_content_encryption_key\n      self.mac_key, self.encryption_key = derive_encryption_and_mac_keys\n      cipher.key = encryption_key\n      cipher.iv = iv # NOTE: 'iv' has to be set after 'key' for GCM\n      if gcm?\n        # https://github.com/ruby/openssl/issues/63\n        raise DecryptionFailed.new('Invalid authentication tag') if authentication_tag.length < 16\n        cipher.auth_tag = authentication_tag\n        cipher.auth_data = auth_data\n      end\n      self.plain_text = cipher.update(cipher_text) + cipher.final\n      verify_cbc_authentication_tag! if cbc?\n      self\n    end\n\n    def to_s\n      [\n        header.to_json,\n        jwe_encrypted_key,\n        iv,\n        cipher_text,\n        authentication_tag\n      ].collect do |segment|\n        Base64.urlsafe_encode64 segment.to_s, padding: false\n      end.join('.')\n    end\n\n    def as_json(options = {})\n      case options[:syntax]\n      when :general\n        {\n          protected:  Base64.urlsafe_encode64(header.to_json, padding: false),\n          recipients: [{\n            encrypted_key: Base64.urlsafe_encode64(jwe_encrypted_key, padding: false)\n          }],\n          iv:         Base64.urlsafe_encode64(iv, padding: false),\n          ciphertext: Base64.urlsafe_encode64(cipher_text, padding: false),\n          tag:        Base64.urlsafe_encode64(authentication_tag, padding: false)\n        }\n      else\n        {\n          protected:     Base64.urlsafe_encode64(header.to_json, padding: false),\n          encrypted_key: Base64.urlsafe_encode64(jwe_encrypted_key, padding: false),\n          iv:            Base64.urlsafe_encode64(iv, padding: false),\n          ciphertext:    Base64.urlsafe_encode64(cipher_text, padding: false),\n          tag:           Base64.urlsafe_encode64(authentication_tag, padding: false)\n        }\n      end\n    end\n\n    private\n\n    # common\n\n    def gcm?\n      [:A128GCM, :A256GCM].include? encryption_method&.to_sym\n    end\n\n    def cbc?\n      [:'A128CBC-HS256', :'A256CBC-HS512'].include? encryption_method&.to_sym\n    end\n\n    def dir?\n      :dir == algorithm&.to_sym\n    end\n\n    def cipher\n      raise \"#{cipher_name} isn't supported\" unless OpenSSL::Cipher.ciphers.include?(cipher_name)\n      @cipher ||= OpenSSL::Cipher.new cipher_name\n    end\n\n    def cipher_name\n      case encryption_method&.to_sym\n      when :A128GCM\n        'aes-128-gcm'\n      when :A256GCM\n        'aes-256-gcm'\n      when :'A128CBC-HS256'\n        'aes-128-cbc'\n      when :'A256CBC-HS512'\n        'aes-256-cbc'\n      else\n        raise UnexpectedAlgorithm.new('Unknown Encryption Algorithm')\n      end\n    end\n\n    def sha_size\n      case encryption_method&.to_sym\n      when :'A128CBC-HS256'\n        256\n      when :'A256CBC-HS512'\n        512\n      else\n        raise UnexpectedAlgorithm.new('Unknown Hash Size')\n      end\n    end\n\n    def sha_digest\n      OpenSSL::Digest.new \"SHA#{sha_size}\"\n    end\n\n    def derive_encryption_and_mac_keys\n      case\n      when gcm?\n        [:wont_be_used, content_encryption_key]\n      when cbc?\n        content_encryption_key.unpack(\n          \"a#{content_encryption_key.length / 2}\" * 2\n        )\n      end\n    end\n\n    # encryption\n\n    def jwe_encrypted_key\n      @jwe_encrypted_key ||= case algorithm&.to_sym\n      when :RSA1_5\n        public_key_or_secret.public_encrypt content_encryption_key\n      when :'RSA-OAEP'\n        public_key_or_secret.public_encrypt content_encryption_key, OpenSSL::PKey::RSA::PKCS1_OAEP_PADDING\n      when :A128KW, :A256KW\n        AESKeyWrap.wrap content_encryption_key, public_key_or_secret\n      when :dir\n        ''\n      when :'ECDH-ES'\n        raise NotImplementedError.new('ECDH-ES not supported yet')\n      when :'ECDH-ES+A128KW'\n        raise NotImplementedError.new('ECDH-ES+A128KW not supported yet')\n      when :'ECDH-ES+A256KW'\n        raise NotImplementedError.new('ECDH-ES+A256KW not supported yet')\n      else\n        raise UnexpectedAlgorithm.new('Unknown Encryption Algorithm')\n      end\n    end\n\n    def generate_content_encryption_key\n      case\n      when dir?\n        public_key_or_secret\n      when gcm?\n        cipher.random_key\n      when cbc?\n        SecureRandom.random_bytes sha_size / 8\n      end\n    end\n\n    def authentication_tag\n      @authentication_tag ||= case\n      when gcm?\n        cipher.auth_tag\n      when cbc?\n        secured_input = [\n          auth_data,\n          iv,\n          cipher_text,\n          BinData::Uint64be.new(auth_data.length * 8).to_binary_s\n        ].join\n        OpenSSL::HMAC.digest(\n          sha_digest, mac_key, secured_input\n        )[0, sha_size / 2 / 8]\n      end\n    end\n\n    # decryption\n\n    def decrypt_content_encryption_key\n      fake_content_encryption_key = generate_content_encryption_key # NOTE: do this always not to make timing difference\n      case algorithm&.to_sym\n      when :RSA1_5\n        private_key_or_secret.private_decrypt jwe_encrypted_key\n      when :'RSA-OAEP'\n        private_key_or_secret.private_decrypt jwe_encrypted_key, OpenSSL::PKey::RSA::PKCS1_OAEP_PADDING\n      when :A128KW, :A256KW\n        AESKeyWrap.unwrap jwe_encrypted_key, private_key_or_secret\n      when :dir\n        private_key_or_secret\n      when :'ECDH-ES'\n        raise NotImplementedError.new('ECDH-ES not supported yet')\n      when :'ECDH-ES+A128KW'\n        raise NotImplementedError.new('ECDH-ES+A128KW not supported yet')\n      when :'ECDH-ES+A256KW'\n        raise NotImplementedError.new('ECDH-ES+A256KW not supported yet')\n      else\n        raise UnexpectedAlgorithm.new('Unknown Encryption Algorithm')\n      end\n    rescue OpenSSL::PKey::PKeyError\n      fake_content_encryption_key\n    end\n\n    def verify_cbc_authentication_tag!\n      secured_input = [\n        auth_data,\n        iv,\n        cipher_text,\n        BinData::Uint64be.new(auth_data.length * 8).to_binary_s\n      ].join\n      expected_authentication_tag = OpenSSL::HMAC.digest(\n        sha_digest, mac_key, secured_input\n      )[0, sha_size / 2 / 8]\n      unless secure_compare(authentication_tag, expected_authentication_tag)\n        raise DecryptionFailed.new('Invalid authentication tag')\n      end\n    end\n\n    class << self\n      def decode_compact_serialized(input, private_key_or_secret, algorithms = nil, encryption_methods = nil, _allow_blank_payload = false)\n        unless input.count('.') + 1 == NUM_OF_SEGMENTS\n          raise InvalidFormat.new(\"Invalid JWE Format. JWE should include #{NUM_OF_SEGMENTS} segments.\")\n        end\n        jwe = new\n        _header_json_, jwe.jwe_encrypted_key, jwe.iv, jwe.cipher_text, jwe.authentication_tag = input.split('.').collect do |segment|\n          begin\n            Base64.urlsafe_decode64 segment\n          rescue ArgumentError\n            raise DecryptionFailed\n          end\n        end\n        jwe.auth_data = input.split('.').first\n        jwe.header = JSON.parse(_header_json_).with_indifferent_access\n        unless private_key_or_secret == :skip_decryption\n          jwe.decrypt! private_key_or_secret, algorithms, encryption_methods\n        end\n        jwe\n      end\n\n      def decode_json_serialized(input, private_key_or_secret, algorithms = nil, encryption_methods = nil, _allow_blank_payload = false)\n        input = input.with_indifferent_access\n        jwe_encrypted_key = if input[:recipients].present?\n          input[:recipients].first[:encrypted_key]\n        else\n          input[:encrypted_key]\n        end\n        compact_serialized = [\n          input[:protected],\n          jwe_encrypted_key,\n          input[:iv],\n          input[:ciphertext],\n          input[:tag]\n        ].join('.')\n        decode_compact_serialized compact_serialized, private_key_or_secret, algorithms, encryption_methods\n      end\n    end\n  end\nend\n", "module JSON\n  class JWS < JWT\n    class InvalidFormat < JWT::InvalidFormat; end\n    class VerificationFailed < JWT::VerificationFailed; end\n    class UnexpectedAlgorithm < JWT::UnexpectedAlgorithm; end\n\n    NUM_OF_SEGMENTS = 3\n\n    attr_writer :signature_base_string\n\n    def initialize(jwt)\n      update jwt\n    end\n\n    def sign!(private_key_or_secret)\n      self.alg = autodetected_algorithm_from(private_key_or_secret) if algorithm == :autodetect\n      self.signature = sign signature_base_string, private_key_or_secret\n      self\n    end\n\n    def verify!(public_key_or_secret, algorithms = nil)\n      if alg&.to_sym == :none\n        raise UnexpectedAlgorithm if public_key_or_secret\n        signature == '' or raise VerificationFailed\n      elsif algorithms.blank? || Array(algorithms).include?(alg&.to_sym)\n        public_key_or_secret && valid?(public_key_or_secret) or\n        raise VerificationFailed\n      else\n        raise UnexpectedAlgorithm.new('Unexpected alg header')\n      end\n    end\n\n    def update(hash_or_jwt)\n      super\n      if hash_or_jwt.is_a? JSON::JWT\n        self.header.update hash_or_jwt.header\n        self.signature = hash_or_jwt.signature\n        self.blank_payload = hash_or_jwt.blank_payload\n      end\n      self\n    end\n\n    private\n\n    def digest\n      OpenSSL::Digest.new \"SHA#{algorithm.to_s[2, 3]}\"\n    end\n\n    def hmac?\n      [:HS256, :HS384, :HS512].include? algorithm&.to_sym\n    end\n\n    def rsa?\n      [:RS256, :RS384, :RS512].include? algorithm&.to_sym\n    end\n\n    def rsa_pss?\n      if [:PS256, :PS384, :PS512].include? algorithm&.to_sym\n        if OpenSSL::VERSION < '2.1.0'\n          raise \"#{alg} isn't supported. OpenSSL gem v2.1.0+ is required to use #{alg}.\"\n        else\n          true\n        end\n      else\n        false\n      end\n    end\n\n    def ecdsa?\n      [:ES256, :ES384, :ES512].include? algorithm&.to_sym\n    end\n\n    def autodetected_algorithm_from(private_key_or_secret)\n      private_key_or_secret = with_jwk_support private_key_or_secret\n      case private_key_or_secret\n      when String\n        :HS256\n      when OpenSSL::PKey::RSA\n        :RS256\n      when OpenSSL::PKey::EC\n        case private_key_or_secret.group.curve_name\n        when 'prime256v1'\n          :ES256\n        when 'secp384r1'\n          :ES384\n        when 'secp521r1'\n          :ES512\n        else\n          raise UnknownAlgorithm.new('Unknown EC Curve')\n        end\n      else\n        raise UnexpectedAlgorithm.new('Signature algorithm auto-detection failed')\n      end\n    end\n\n    def signature_base_string\n      @signature_base_string ||= [\n        header.to_json,\n        self.to_json\n      ].collect do |segment|\n        Base64.urlsafe_encode64 segment, padding: false\n      end.join('.')\n    end\n\n    def sign(signature_base_string, private_key_or_secret)\n      private_key_or_secret = with_jwk_support private_key_or_secret\n      case\n      when hmac?\n        secret = private_key_or_secret\n        OpenSSL::HMAC.digest digest, secret, signature_base_string\n      when rsa?\n        private_key = private_key_or_secret\n        private_key.sign digest, signature_base_string\n      when rsa_pss?\n        private_key = private_key_or_secret\n        private_key.sign_pss digest, signature_base_string, salt_length: :digest, mgf1_hash: digest\n      when ecdsa?\n        private_key = private_key_or_secret\n        verify_ecdsa_group! private_key\n        asn1_to_raw(\n          private_key.dsa_sign_asn1(digest.digest signature_base_string),\n          # private_key.sign(digest, signature_base_string), # NOTE: this causes `undefined method `private?'` error in ruby 2.3\n          private_key\n        )\n      else\n        raise UnexpectedAlgorithm.new('Unknown Signature Algorithm')\n      end\n    end\n\n    def valid?(public_key_or_secret)\n      public_key_or_secret = with_jwk_support public_key_or_secret\n      case\n      when hmac?\n        secure_compare sign(signature_base_string, public_key_or_secret), signature\n      when rsa?\n        public_key = public_key_or_secret\n        public_key.verify digest, signature, signature_base_string\n      when rsa_pss?\n        public_key = public_key_or_secret\n        public_key.verify_pss digest, signature, signature_base_string, salt_length: :digest, mgf1_hash: digest\n      when ecdsa?\n        public_key = public_key_or_secret\n        verify_ecdsa_group! public_key\n        public_key.verify digest, raw_to_asn1(signature, public_key), signature_base_string\n      else\n        raise UnexpectedAlgorithm.new('Unknown Signature Algorithm')\n      end\n    rescue TypeError => e\n      raise UnexpectedAlgorithm.new(e.message)\n    end\n\n    def verify_ecdsa_group!(key)\n      group_name = case digest.digest_length * 8\n      when 256\n        :prime256v1\n      when 384\n        :secp384r1\n      when 512\n        :secp521r1\n      end\n      key.group = OpenSSL::PKey::EC::Group.new group_name.to_s\n      key.check_key\n    end\n\n    def raw_to_asn1(signature, public_key)\n      byte_size = (public_key.group.degree + 7) / 8\n      r = signature[0..(byte_size - 1)]\n      s = signature[byte_size..-1]\n      OpenSSL::ASN1::Sequence.new([r, s].map { |int| OpenSSL::ASN1::Integer.new(OpenSSL::BN.new(int, 2)) }).to_der\n    end\n\n    def asn1_to_raw(signature, private_key)\n      byte_size = (private_key.group.degree + 7) / 8\n      OpenSSL::ASN1.decode(signature).value.map { |value| value.value.to_s(2).rjust(byte_size, \"\\x00\") }.join\n    end\n\n    class << self\n      def decode_compact_serialized(input, public_key_or_secret, algorithms = nil, allow_blank_payload = false)\n        unless input.count('.') + 1 == NUM_OF_SEGMENTS\n          raise InvalidFormat.new(\"Invalid JWS Format. JWS should include #{NUM_OF_SEGMENTS} segments.\")\n        end\n        header, claims, signature = input.split('.', JWS::NUM_OF_SEGMENTS).collect do |segment|\n          Base64.urlsafe_decode64 segment.to_s\n        end\n        header = JSON.parse(header).with_indifferent_access\n        if allow_blank_payload && claims == ''\n          claims = nil\n        else\n          claims = JSON.parse(claims).with_indifferent_access\n        end\n        jws = new claims\n        jws.header = header\n        jws.signature = signature\n        jws.signature_base_string = input.split('.')[0, JWS::NUM_OF_SEGMENTS - 1].join('.')\n        jws.verify! public_key_or_secret, algorithms unless public_key_or_secret == :skip_verification\n        jws\n      end\n\n      def decode_json_serialized(input, public_key_or_secret, algorithms = nil, allow_blank_payload = false)\n        input = input.with_indifferent_access\n        header, payload, signature = if input[:signatures].present?\n          [\n            input[:signatures].first[:protected],\n            input[:payload],\n            input[:signatures].first[:signature]\n          ].collect do |segment|\n            segment\n          end\n        else\n          [:protected, :payload, :signature].collect do |key|\n            input[key]\n          end\n        end\n        compact_serialized = [header, payload, signature].join('.')\n        decode_compact_serialized compact_serialized, public_key_or_secret, algorithms, allow_blank_payload\n      end\n    end\n  end\nend\n"], "fixing_code": ["require 'securerandom'\nrequire 'bindata'\nrequire 'aes_key_wrap'\n\nmodule JSON\n  class JWE\n    class InvalidFormat < JWT::InvalidFormat; end\n    class DecryptionFailed < JWT::VerificationFailed; end\n    class UnexpectedAlgorithm < JWT::UnexpectedAlgorithm; end\n\n    NUM_OF_SEGMENTS = 5\n\n    include JOSE\n\n    attr_accessor(\n      :public_key_or_secret, :private_key_or_secret,\n      :plain_text, :cipher_text, :iv, :auth_data,\n      :content_encryption_key, :encryption_key, :mac_key\n    )\n    attr_writer :jwe_encrypted_key, :authentication_tag\n\n    register_header_keys :enc, :epk, :zip, :apu, :apv\n    alias_method :encryption_method, :enc\n\n    def initialize(input = nil)\n      self.plain_text = input.to_s\n    end\n\n    def encrypt!(public_key_or_secret)\n      self.public_key_or_secret = with_jwk_support public_key_or_secret\n      cipher.encrypt\n      self.content_encryption_key = generate_content_encryption_key\n      self.mac_key, self.encryption_key = derive_encryption_and_mac_keys\n      cipher.key = encryption_key\n      self.iv = cipher.random_iv # NOTE: 'iv' has to be set after 'key' for GCM\n      self.auth_data = Base64.urlsafe_encode64 header.to_json, padding: false\n      cipher.auth_data = auth_data if gcm?\n      self.cipher_text = cipher.update(plain_text) + cipher.final\n      self\n    end\n\n    def decrypt!(private_key_or_secret, algorithms = nil, encryption_methods = nil)\n      raise UnexpectedAlgorithm.new('Unexpected alg header') unless algorithms.blank? || Array(algorithms).include?(alg)\n      raise UnexpectedAlgorithm.new('Unexpected enc header') unless encryption_methods.blank? || Array(encryption_methods).include?(enc)\n      self.private_key_or_secret = with_jwk_support private_key_or_secret\n      cipher.decrypt\n      self.content_encryption_key = decrypt_content_encryption_key\n      self.mac_key, self.encryption_key = derive_encryption_and_mac_keys\n      cipher.key = encryption_key\n      cipher.iv = iv # NOTE: 'iv' has to be set after 'key' for GCM\n      if gcm?\n        # https://github.com/ruby/openssl/issues/63\n        raise DecryptionFailed.new('Invalid authentication tag') if authentication_tag.length < 16\n        cipher.auth_tag = authentication_tag\n        cipher.auth_data = auth_data\n      end\n      self.plain_text = cipher.update(cipher_text) + cipher.final\n      verify_cbc_authentication_tag! if cbc?\n      self\n    end\n\n    def to_s\n      [\n        header.to_json,\n        jwe_encrypted_key,\n        iv,\n        cipher_text,\n        authentication_tag\n      ].collect do |segment|\n        Base64.urlsafe_encode64 segment.to_s, padding: false\n      end.join('.')\n    end\n\n    def as_json(options = {})\n      case options[:syntax]\n      when :general\n        {\n          protected:  Base64.urlsafe_encode64(header.to_json, padding: false),\n          recipients: [{\n            encrypted_key: Base64.urlsafe_encode64(jwe_encrypted_key, padding: false)\n          }],\n          iv:         Base64.urlsafe_encode64(iv, padding: false),\n          ciphertext: Base64.urlsafe_encode64(cipher_text, padding: false),\n          tag:        Base64.urlsafe_encode64(authentication_tag, padding: false)\n        }\n      else\n        {\n          protected:     Base64.urlsafe_encode64(header.to_json, padding: false),\n          encrypted_key: Base64.urlsafe_encode64(jwe_encrypted_key, padding: false),\n          iv:            Base64.urlsafe_encode64(iv, padding: false),\n          ciphertext:    Base64.urlsafe_encode64(cipher_text, padding: false),\n          tag:           Base64.urlsafe_encode64(authentication_tag, padding: false)\n        }\n      end\n    end\n\n    private\n\n    # common\n\n    def gcm?\n      [:A128GCM, :A256GCM].include? encryption_method&.to_sym\n    end\n\n    def cbc?\n      [:'A128CBC-HS256', :'A256CBC-HS512'].include? encryption_method&.to_sym\n    end\n\n    def dir?\n      :dir == algorithm&.to_sym\n    end\n\n    def cipher\n      raise \"#{cipher_name} isn't supported\" unless OpenSSL::Cipher.ciphers.include?(cipher_name)\n      @cipher ||= OpenSSL::Cipher.new cipher_name\n    end\n\n    def cipher_name\n      case encryption_method&.to_sym\n      when :A128GCM\n        'aes-128-gcm'\n      when :A256GCM\n        'aes-256-gcm'\n      when :'A128CBC-HS256'\n        'aes-128-cbc'\n      when :'A256CBC-HS512'\n        'aes-256-cbc'\n      else\n        raise UnexpectedAlgorithm.new('Unknown Encryption Algorithm')\n      end\n    end\n\n    def sha_size\n      case encryption_method&.to_sym\n      when :'A128CBC-HS256'\n        256\n      when :'A256CBC-HS512'\n        512\n      else\n        raise UnexpectedAlgorithm.new('Unknown Hash Size')\n      end\n    end\n\n    def sha_digest\n      OpenSSL::Digest.new \"SHA#{sha_size}\"\n    end\n\n    def derive_encryption_and_mac_keys\n      case\n      when gcm?\n        [:wont_be_used, content_encryption_key]\n      when cbc?\n        content_encryption_key.unpack(\n          \"a#{content_encryption_key.length / 2}\" * 2\n        )\n      end\n    end\n\n    # encryption\n\n    def jwe_encrypted_key\n      @jwe_encrypted_key ||= case algorithm&.to_sym\n      when :RSA1_5\n        public_key_or_secret.public_encrypt content_encryption_key\n      when :'RSA-OAEP'\n        public_key_or_secret.public_encrypt content_encryption_key, OpenSSL::PKey::RSA::PKCS1_OAEP_PADDING\n      when :A128KW, :A256KW\n        AESKeyWrap.wrap content_encryption_key, public_key_or_secret\n      when :dir\n        ''\n      when :'ECDH-ES'\n        raise NotImplementedError.new('ECDH-ES not supported yet')\n      when :'ECDH-ES+A128KW'\n        raise NotImplementedError.new('ECDH-ES+A128KW not supported yet')\n      when :'ECDH-ES+A256KW'\n        raise NotImplementedError.new('ECDH-ES+A256KW not supported yet')\n      else\n        raise UnexpectedAlgorithm.new('Unknown Encryption Algorithm')\n      end\n    end\n\n    def generate_content_encryption_key\n      case\n      when dir?\n        public_key_or_secret\n      when gcm?\n        cipher.random_key\n      when cbc?\n        SecureRandom.random_bytes sha_size / 8\n      end\n    end\n\n    def authentication_tag\n      @authentication_tag ||= case\n      when gcm?\n        cipher.auth_tag\n      when cbc?\n        secured_input = [\n          auth_data,\n          iv,\n          cipher_text,\n          BinData::Uint64be.new(auth_data.length * 8).to_binary_s\n        ].join\n        OpenSSL::HMAC.digest(\n          sha_digest, mac_key, secured_input\n        )[0, sha_size / 2 / 8]\n      end\n    end\n\n    # decryption\n\n    def decrypt_content_encryption_key\n      fake_content_encryption_key = generate_content_encryption_key # NOTE: do this always not to make timing difference\n      case algorithm&.to_sym\n      when :RSA1_5\n        private_key_or_secret.private_decrypt jwe_encrypted_key\n      when :'RSA-OAEP'\n        private_key_or_secret.private_decrypt jwe_encrypted_key, OpenSSL::PKey::RSA::PKCS1_OAEP_PADDING\n      when :A128KW, :A256KW\n        AESKeyWrap.unwrap jwe_encrypted_key, private_key_or_secret\n      when :dir\n        private_key_or_secret\n      when :'ECDH-ES'\n        raise NotImplementedError.new('ECDH-ES not supported yet')\n      when :'ECDH-ES+A128KW'\n        raise NotImplementedError.new('ECDH-ES+A128KW not supported yet')\n      when :'ECDH-ES+A256KW'\n        raise NotImplementedError.new('ECDH-ES+A256KW not supported yet')\n      else\n        raise UnexpectedAlgorithm.new('Unknown Encryption Algorithm')\n      end\n    rescue OpenSSL::PKey::PKeyError\n      fake_content_encryption_key\n    end\n\n    def verify_cbc_authentication_tag!\n      secured_input = [\n        auth_data,\n        iv,\n        cipher_text,\n        BinData::Uint64be.new(auth_data.length * 8).to_binary_s\n      ].join\n      expected_authentication_tag = OpenSSL::HMAC.digest(\n        sha_digest, mac_key, secured_input\n      )[0, sha_size / 2 / 8]\n      unless secure_compare(authentication_tag, expected_authentication_tag)\n        raise DecryptionFailed.new('Invalid authentication tag')\n      end\n    end\n\n    class << self\n      def decode_compact_serialized(input, private_key_or_secret, algorithms = nil, encryption_methods = nil, _allow_blank_payload = false)\n        unless input.count('.') + 1 == NUM_OF_SEGMENTS\n          raise InvalidFormat.new(\"Invalid JWE Format. JWE should include #{NUM_OF_SEGMENTS} segments.\")\n        end\n        jwe = new\n        _header_json_, jwe.jwe_encrypted_key, jwe.iv, jwe.cipher_text, jwe.authentication_tag = input.split('.', NUM_OF_SEGMENTS).collect do |segment|\n          begin\n            Base64.urlsafe_decode64 segment\n          rescue ArgumentError\n            raise DecryptionFailed\n          end\n        end\n        jwe.auth_data = input.split('.').first\n        jwe.header = JSON.parse(_header_json_).with_indifferent_access\n        unless private_key_or_secret == :skip_decryption\n          jwe.decrypt! private_key_or_secret, algorithms, encryption_methods\n        end\n        jwe\n      end\n\n      def decode_json_serialized(input, private_key_or_secret, algorithms = nil, encryption_methods = nil, _allow_blank_payload = false)\n        input = input.with_indifferent_access\n        jwe_encrypted_key = if input[:recipients].present?\n          input[:recipients].first[:encrypted_key]\n        else\n          input[:encrypted_key]\n        end\n        compact_serialized = [\n          input[:protected],\n          jwe_encrypted_key,\n          input[:iv],\n          input[:ciphertext],\n          input[:tag]\n        ].join('.')\n        decode_compact_serialized compact_serialized, private_key_or_secret, algorithms, encryption_methods\n      end\n    end\n  end\nend\n", "module JSON\n  class JWS < JWT\n    class InvalidFormat < JWT::InvalidFormat; end\n    class VerificationFailed < JWT::VerificationFailed; end\n    class UnexpectedAlgorithm < JWT::UnexpectedAlgorithm; end\n\n    NUM_OF_SEGMENTS = 3\n\n    attr_writer :signature_base_string\n\n    def initialize(jwt)\n      update jwt\n    end\n\n    def sign!(private_key_or_secret)\n      self.alg = autodetected_algorithm_from(private_key_or_secret) if algorithm == :autodetect\n      self.signature = sign signature_base_string, private_key_or_secret\n      self\n    end\n\n    def verify!(public_key_or_secret, algorithms = nil)\n      if alg&.to_sym == :none\n        raise UnexpectedAlgorithm if public_key_or_secret\n        signature == '' or raise VerificationFailed\n      elsif algorithms.blank? || Array(algorithms).include?(alg&.to_sym)\n        public_key_or_secret && valid?(public_key_or_secret) or\n        raise VerificationFailed\n      else\n        raise UnexpectedAlgorithm.new('Unexpected alg header')\n      end\n    end\n\n    def update(hash_or_jwt)\n      super\n      if hash_or_jwt.is_a? JSON::JWT\n        self.header.update hash_or_jwt.header\n        self.signature = hash_or_jwt.signature\n        self.blank_payload = hash_or_jwt.blank_payload\n      end\n      self\n    end\n\n    private\n\n    def digest\n      OpenSSL::Digest.new \"SHA#{algorithm.to_s[2, 3]}\"\n    end\n\n    def hmac?\n      [:HS256, :HS384, :HS512].include? algorithm&.to_sym\n    end\n\n    def rsa?\n      [:RS256, :RS384, :RS512].include? algorithm&.to_sym\n    end\n\n    def rsa_pss?\n      if [:PS256, :PS384, :PS512].include? algorithm&.to_sym\n        if OpenSSL::VERSION < '2.1.0'\n          raise \"#{alg} isn't supported. OpenSSL gem v2.1.0+ is required to use #{alg}.\"\n        else\n          true\n        end\n      else\n        false\n      end\n    end\n\n    def ecdsa?\n      [:ES256, :ES384, :ES512].include? algorithm&.to_sym\n    end\n\n    def autodetected_algorithm_from(private_key_or_secret)\n      private_key_or_secret = with_jwk_support private_key_or_secret\n      case private_key_or_secret\n      when String\n        :HS256\n      when OpenSSL::PKey::RSA\n        :RS256\n      when OpenSSL::PKey::EC\n        case private_key_or_secret.group.curve_name\n        when 'prime256v1'\n          :ES256\n        when 'secp384r1'\n          :ES384\n        when 'secp521r1'\n          :ES512\n        else\n          raise UnknownAlgorithm.new('Unknown EC Curve')\n        end\n      else\n        raise UnexpectedAlgorithm.new('Signature algorithm auto-detection failed')\n      end\n    end\n\n    def signature_base_string\n      @signature_base_string ||= [\n        header.to_json,\n        self.to_json\n      ].collect do |segment|\n        Base64.urlsafe_encode64 segment, padding: false\n      end.join('.')\n    end\n\n    def sign(signature_base_string, private_key_or_secret)\n      private_key_or_secret = with_jwk_support private_key_or_secret\n      case\n      when hmac?\n        secret = private_key_or_secret\n        OpenSSL::HMAC.digest digest, secret, signature_base_string\n      when rsa?\n        private_key = private_key_or_secret\n        private_key.sign digest, signature_base_string\n      when rsa_pss?\n        private_key = private_key_or_secret\n        private_key.sign_pss digest, signature_base_string, salt_length: :digest, mgf1_hash: digest\n      when ecdsa?\n        private_key = private_key_or_secret\n        verify_ecdsa_group! private_key\n        asn1_to_raw(\n          private_key.dsa_sign_asn1(digest.digest signature_base_string),\n          # private_key.sign(digest, signature_base_string), # NOTE: this causes `undefined method `private?'` error in ruby 2.3\n          private_key\n        )\n      else\n        raise UnexpectedAlgorithm.new('Unknown Signature Algorithm')\n      end\n    end\n\n    def valid?(public_key_or_secret)\n      public_key_or_secret = with_jwk_support public_key_or_secret\n      case\n      when hmac?\n        secure_compare sign(signature_base_string, public_key_or_secret), signature\n      when rsa?\n        public_key = public_key_or_secret\n        public_key.verify digest, signature, signature_base_string\n      when rsa_pss?\n        public_key = public_key_or_secret\n        public_key.verify_pss digest, signature, signature_base_string, salt_length: :digest, mgf1_hash: digest\n      when ecdsa?\n        public_key = public_key_or_secret\n        verify_ecdsa_group! public_key\n        public_key.verify digest, raw_to_asn1(signature, public_key), signature_base_string\n      else\n        raise UnexpectedAlgorithm.new('Unknown Signature Algorithm')\n      end\n    rescue TypeError => e\n      raise UnexpectedAlgorithm.new(e.message)\n    end\n\n    def verify_ecdsa_group!(key)\n      group_name = case digest.digest_length * 8\n      when 256\n        :prime256v1\n      when 384\n        :secp384r1\n      when 512\n        :secp521r1\n      end\n      key.group = OpenSSL::PKey::EC::Group.new group_name.to_s\n      key.check_key\n    end\n\n    def raw_to_asn1(signature, public_key)\n      byte_size = (public_key.group.degree + 7) / 8\n      r = signature[0..(byte_size - 1)]\n      s = signature[byte_size..-1]\n      OpenSSL::ASN1::Sequence.new([r, s].map { |int| OpenSSL::ASN1::Integer.new(OpenSSL::BN.new(int, 2)) }).to_der\n    end\n\n    def asn1_to_raw(signature, private_key)\n      byte_size = (private_key.group.degree + 7) / 8\n      OpenSSL::ASN1.decode(signature).value.map { |value| value.value.to_s(2).rjust(byte_size, \"\\x00\") }.join\n    end\n\n    class << self\n      def decode_compact_serialized(input, public_key_or_secret, algorithms = nil, allow_blank_payload = false)\n        unless input.count('.') + 1 == NUM_OF_SEGMENTS\n          raise InvalidFormat.new(\"Invalid JWS Format. JWS should include #{NUM_OF_SEGMENTS} segments.\")\n        end\n        header, claims, signature = input.split('.', NUM_OF_SEGMENTS).collect do |segment|\n          Base64.urlsafe_decode64 segment.to_s\n        end\n        header = JSON.parse(header).with_indifferent_access\n        if allow_blank_payload && claims == ''\n          claims = nil\n        else\n          claims = JSON.parse(claims).with_indifferent_access\n        end\n        jws = new claims\n        jws.header = header\n        jws.signature = signature\n        jws.signature_base_string = input.split('.')[0, NUM_OF_SEGMENTS - 1].join('.')\n        jws.verify! public_key_or_secret, algorithms unless public_key_or_secret == :skip_verification\n        jws\n      end\n\n      def decode_json_serialized(input, public_key_or_secret, algorithms = nil, allow_blank_payload = false)\n        input = input.with_indifferent_access\n        header, payload, signature = if input[:signatures].present?\n          [\n            input[:signatures].first[:protected],\n            input[:payload],\n            input[:signatures].first[:signature]\n          ].collect do |segment|\n            segment\n          end\n        else\n          [:protected, :payload, :signature].collect do |key|\n            input[key]\n          end\n        end\n        compact_serialized = [header, payload, signature].join('.')\n        decode_compact_serialized compact_serialized, public_key_or_secret, algorithms, allow_blank_payload\n      end\n    end\n  end\nend\n"], "filenames": ["lib/json/jwe.rb", "lib/json/jws.rb"], "buggy_code_start_loc": [257, 182], "buggy_code_end_loc": [258, 195], "fixing_code_start_loc": [257, 182], "fixing_code_end_loc": [258, 195], "type": "CWE-287", "message": "The json-jwt gem before 1.11.0 for Ruby lacks an element count during the splitting of a JWE string.", "other": {"cve": {"id": "CVE-2019-18848", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-12T15:15:10.880", "lastModified": "2022-05-03T14:28:18.317", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The json-jwt gem before 1.11.0 for Ruby lacks an element count during the splitting of a JWE string."}, {"lang": "es", "value": "La gema json-jwt versiones anteriores a 1.11.0 para Ruby, carece de un conteo de elementos durante la divisi\u00f3n de una cadena JWE."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:json-jwt_project:json-jwt:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "1.11.0", "matchCriteriaId": "B10476D4-4E18-4530-97F0-BE8DF7CBBD64"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/nov/json-jwt/commit/ada16e772906efdd035e3df49cb2ae372f0f948a", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/nov/json-jwt/compare/v1.10.2...v1.11.0", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nov/json-jwt/commit/ada16e772906efdd035e3df49cb2ae372f0f948a"}}