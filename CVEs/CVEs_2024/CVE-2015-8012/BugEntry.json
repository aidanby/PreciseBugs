{"buggy_code": ["/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"lldpd.h\"\n#include \"trace.h\"\n\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <time.h>\n#include <libgen.h>\n#include <assert.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/ioctl.h>\n#include <arpa/inet.h>\n#include <netinet/if_ether.h>\n#include <pwd.h>\n#include <grp.h>\n\nstatic void\t\t usage(void);\n\nstatic struct protocol protos[] =\n{\n\t{ LLDPD_MODE_LLDP, 1, \"LLDP\", 'l', lldp_send, lldp_decode, NULL,\n\t  LLDP_MULTICAST_ADDR },\n#ifdef ENABLE_CDP\n\t{ LLDPD_MODE_CDPV1, 0, \"CDPv1\", 'c', cdpv1_send, cdp_decode, cdpv1_guess,\n\t  CDP_MULTICAST_ADDR },\n\t{ LLDPD_MODE_CDPV2, 0, \"CDPv2\", 'c', cdpv2_send, cdp_decode, cdpv2_guess,\n\t  CDP_MULTICAST_ADDR },\n#endif\n#ifdef ENABLE_SONMP\n\t{ LLDPD_MODE_SONMP, 0, \"SONMP\", 's', sonmp_send, sonmp_decode, NULL,\n\t  SONMP_MULTICAST_ADDR },\n#endif\n#ifdef ENABLE_EDP\n\t{ LLDPD_MODE_EDP, 0, \"EDP\", 'e', edp_send, edp_decode, NULL,\n\t  EDP_MULTICAST_ADDR },\n#endif\n#ifdef ENABLE_FDP\n\t{ LLDPD_MODE_FDP, 0, \"FDP\", 'f', fdp_send, cdp_decode, NULL,\n\t  FDP_MULTICAST_ADDR },\n#endif\n\t{ 0, 0, \"any\", ' ', NULL, NULL, NULL,\n\t  {0,0,0,0,0,0} }\n};\n\nstatic char\t\t**saved_argv;\n#ifdef HAVE___PROGNAME\nextern const char\t*__progname;\n#else\n# define __progname \"lldpd\"\n#endif\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr, \"Usage:   %s [OPTIONS ...]\\n\", __progname);\n\tfprintf(stderr, \"Version: %s\\n\", PACKAGE_STRING);\n\n\tfprintf(stderr, \"\\n\");\n\n\tfprintf(stderr, \"-d       Do not daemonize.\\n\");\n\tfprintf(stderr, \"-r       Receive-only mode\\n\");\n\tfprintf(stderr, \"-i       Disable LLDP-MED inventory TLV transmission.\\n\");\n\tfprintf(stderr, \"-k       Disable advertising of kernel release, version, machine.\\n\");\n\tfprintf(stderr, \"-S descr Override the default system description.\\n\");\n\tfprintf(stderr, \"-P name  Override the default hardware platform.\\n\");\n\tfprintf(stderr, \"-m IP    Specify the IPv4 management addresses of this system.\\n\");\n\tfprintf(stderr, \"-u file  Specify the Unix-domain socket used for communication with lldpctl(8).\\n\");\n\tfprintf(stderr, \"-H mode  Specify the behaviour when detecting multiple neighbors.\\n\");\n\tfprintf(stderr, \"-I iface Limit interfaces to use.\\n\");\n#ifdef ENABLE_LLDPMED\n\tfprintf(stderr, \"-M class Enable emission of LLDP-MED frame. 'class' should be one of:\\n\");\n\tfprintf(stderr, \"             1 Generic Endpoint (Class I)\\n\");\n\tfprintf(stderr, \"             2 Media Endpoint (Class II)\\n\");\n\tfprintf(stderr, \"             3 Communication Device Endpoints (Class III)\\n\");\n\tfprintf(stderr, \"             4 Network Connectivity Device\\n\");\n#endif\n#ifdef USE_SNMP\n\tfprintf(stderr, \"-x       Enable SNMP subagent.\\n\");\n#endif\n\tfprintf(stderr, \"\\n\");\n\n#if defined ENABLE_CDP || defined ENABLE_EDP || defined ENABLE_FDP || defined ENABLE_SONMP\n\tfprintf(stderr, \"Additional protocol support.\\n\");\n#ifdef ENABLE_CDP\n\tfprintf(stderr, \"-c       Enable the support of CDP protocol. (Cisco)\\n\");\n#endif\n#ifdef ENABLE_EDP\n\tfprintf(stderr, \"-e       Enable the support of EDP protocol. (Extreme)\\n\");\n#endif\n#ifdef ENABLE_FDP\n\tfprintf(stderr, \"-f       Enable the support of FDP protocol. (Foundry)\\n\");\n#endif\n#ifdef ENABLE_SONMP\n\tfprintf(stderr, \"-s       Enable the support of SONMP protocol. (Nortel)\\n\");\n#endif\n\n\tfprintf(stderr, \"\\n\");\n#endif\n\n\tfprintf(stderr, \"see manual page lldpd(8) for more information\\n\");\n\texit(1);\n}\n\nstruct lldpd_hardware *\nlldpd_get_hardware(struct lldpd *cfg, char *name, int index, struct lldpd_ops *ops)\n{\n\tstruct lldpd_hardware *hardware;\n\tTAILQ_FOREACH(hardware, &cfg->g_hardware, h_entries) {\n\t\tif ((strcmp(hardware->h_ifname, name) == 0) &&\n\t\t    (hardware->h_ifindex == index) &&\n\t\t    ((!ops) || (ops == hardware->h_ops)))\n\t\t\tbreak;\n\t}\n\treturn hardware;\n}\n\nstruct lldpd_hardware *\nlldpd_alloc_hardware(struct lldpd *cfg, char *name, int index)\n{\n\tstruct lldpd_hardware *hardware;\n\n\tlog_debug(\"alloc\", \"allocate a new local port (%s)\", name);\n\n\tif ((hardware = (struct lldpd_hardware *)\n\t\tcalloc(1, sizeof(struct lldpd_hardware))) == NULL)\n\t\treturn NULL;\n\n\thardware->h_cfg = cfg;\n\tstrlcpy(hardware->h_ifname, name, sizeof(hardware->h_ifname));\n\thardware->h_ifindex = index;\n\thardware->h_lport.p_chassis = LOCAL_CHASSIS(cfg);\n\thardware->h_lport.p_chassis->c_refcount++;\n\tTAILQ_INIT(&hardware->h_rports);\n\n#ifdef ENABLE_LLDPMED\n\tif (LOCAL_CHASSIS(cfg)->c_med_cap_available) {\n\t\thardware->h_lport.p_med_cap_enabled = LLDP_MED_CAP_CAP;\n\t\tif (!cfg->g_config.c_noinventory)\n\t\t\thardware->h_lport.p_med_cap_enabled |= LLDP_MED_CAP_IV;\n\t}\n#endif\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&hardware->h_lport.p_vlans);\n\tTAILQ_INIT(&hardware->h_lport.p_ppvids);\n\tTAILQ_INIT(&hardware->h_lport.p_pids);\n#endif\n#ifdef ENABLE_CUSTOM\n\tTAILQ_INIT(&hardware->h_lport.p_custom_list);\n#endif\n\n\tlevent_hardware_init(hardware);\n\treturn hardware;\n}\n\nstruct lldpd_mgmt *\nlldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\n\tlog_debug(\"alloc\", \"allocate a new management address (family: %d)\", family);\n\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tassert(addrsize <= LLDPD_MGMT_MAXADDRSIZE);\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n}\n\nvoid\nlldpd_hardware_cleanup(struct lldpd *cfg, struct lldpd_hardware *hardware)\n{\n\tlog_debug(\"alloc\", \"cleanup hardware port %s\", hardware->h_ifname);\n\n\tfree(hardware->h_lport_previous);\n\tfree(hardware->h_lchassis_previous_id);\n\tfree(hardware->h_lport_previous_id);\n\tlldpd_port_cleanup(&hardware->h_lport, 1);\n\tif (hardware->h_ops && hardware->h_ops->cleanup)\n\t\thardware->h_ops->cleanup(cfg, hardware);\n\tlevent_hardware_release(hardware);\n\tfree(hardware);\n}\n\nstatic void\nlldpd_display_neighbors(struct lldpd *cfg)\n{\n\tif (!cfg->g_config.c_set_ifdescr) return;\n\tstruct lldpd_hardware *hardware;\n\tTAILQ_FOREACH(hardware, &cfg->g_hardware, h_entries) {\n\t\tstruct lldpd_port *port;\n\t\tchar *description;\n\t\tconst char *neighbor = NULL;\n\t\tunsigned neighbors = 0;\n\t\tTAILQ_FOREACH(port, &hardware->h_rports, p_entries) {\n\t\t\tif (SMART_HIDDEN(port)) continue;\n\t\t\tneighbors++;\n\t\t\tneighbor = port->p_chassis->c_name;\n\t\t}\n\t\tif (neighbors == 0)\n\t\t\tpriv_iface_description(hardware->h_ifname,\n\t\t\t    \"\");\n\t\telse if (neighbors == 1 && neighbor && *neighbor != '\\0') {\n\t\t\tif (asprintf(&description, \"%s\",\n\t\t\t\tneighbor) != -1) {\n\t\t\t\tpriv_iface_description(hardware->h_ifname, description);\n\t\t\t\tfree(description);\n\t\t\t}\n\t\t} else {\n\t\t\tif (asprintf(&description, \"%d neighbor%s\",\n\t\t\t\tneighbors, (neighbors > 1)?\"s\":\"\") != -1) {\n\t\t\t\tpriv_iface_description(hardware->h_ifname,\n\t\t\t\t    description);\n\t\t\t\tfree(description);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nlldpd_count_neighbors(struct lldpd *cfg)\n{\n#if HAVE_SETPROCTITLE\n\tstruct lldpd_chassis *chassis;\n\tconst char *neighbor;\n\tunsigned neighbors = 0;\n\tTAILQ_FOREACH(chassis, &cfg->g_chassis, c_entries) {\n\t\tneighbors++;\n\t\tneighbor = chassis->c_name;\n\t}\n\tneighbors--;\n\tif (neighbors == 0)\n\t\tsetproctitle(\"no neighbor\");\n\telse if (neighbors == 1 && neighbor && *neighbor != '\\0')\n\t\tsetproctitle(\"connected to %s\", neighbor);\n\telse\n\t\tsetproctitle(\"%d neighbor%s\", neighbors,\n\t\t    (neighbors > 1)?\"s\":\"\");\n#endif\n\tlldpd_display_neighbors(cfg);\n}\n\nstatic void\nnotify_clients_deletion(struct lldpd_hardware *hardware,\n    struct lldpd_port *rport)\n{\n\tTRACE(LLDPD_NEIGHBOR_DELETE(hardware->h_ifname,\n\t\trport->p_chassis->c_name,\n\t\trport->p_descr));\n\tlevent_ctl_notify(hardware->h_ifname, NEIGHBOR_CHANGE_DELETED,\n\t    rport);\n#ifdef USE_SNMP\n\tagent_notify(hardware, NEIGHBOR_CHANGE_DELETED, rport);\n#endif\n}\n\nstatic void\nlldpd_reset_timer(struct lldpd *cfg)\n{\n\t/* Reset timer for ports that have been changed. */\n\tstruct lldpd_hardware *hardware;\n\tTAILQ_FOREACH(hardware, &cfg->g_hardware, h_entries) {\n\t\t/* We keep a flat copy of the local port to see if there is any\n\t\t * change. To do this, we zero out fields that are not\n\t\t * significant, marshal the port, then restore. */\n\t\tstruct lldpd_port *port = &hardware->h_lport;\n\t\tu_int8_t *output = NULL;\n\t\tssize_t output_len;\n\t\tchar save[LLDPD_PORT_START_MARKER];\n\t\tmemcpy(save, port, sizeof(save));\n\t\t/* coverity[suspicious_sizeof]\n\t\t   We intentionally partially memset port */\n\t\tmemset(port, 0, sizeof(save));\n\t\toutput_len = lldpd_port_serialize(port, (void**)&output);\n\t\tmemcpy(port, save, sizeof(save));\n\t\tif (output_len == -1) {\n\t\t\tlog_warnx(\"localchassis\",\n\t\t\t    \"unable to serialize local port %s to check for differences\",\n\t\t\t    hardware->h_ifname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Compare with the previous value */\n\t\tif (hardware->h_lport_previous &&\n\t\t    output_len == hardware->h_lport_previous_len &&\n\t\t    !memcmp(output, hardware->h_lport_previous, output_len)) {\n\t\t\tlog_debug(\"localchassis\",\n\t\t\t    \"no change detected for port %s\",\n\t\t\t    hardware->h_ifname);\n\t\t} else {\n\t\t\tlog_debug(\"localchassis\",\n\t\t\t    \"change detected for port %s, resetting its timer\",\n\t\t\t    hardware->h_ifname);\n\t\t\tlevent_schedule_pdu(hardware);\n\t\t}\n\n\t\t/* Update the value */\n\t\tfree(hardware->h_lport_previous);\n\t\thardware->h_lport_previous = output;\n\t\thardware->h_lport_previous_len = output_len;\n\t}\n}\n\nvoid\nlldpd_cleanup(struct lldpd *cfg)\n{\n\tstruct lldpd_hardware *hardware, *hardware_next;\n\tstruct lldpd_chassis *chassis, *chassis_next;\n\n\tlog_debug(\"localchassis\", \"cleanup all ports\");\n\n\tfor (hardware = TAILQ_FIRST(&cfg->g_hardware); hardware != NULL;\n\t     hardware = hardware_next) {\n\t\thardware_next = TAILQ_NEXT(hardware, h_entries);\n\t\tif (!hardware->h_flags) {\n\t\t\tTRACE(LLDPD_INTERFACES_DELETE(hardware->h_ifname));\n\t\t\tTAILQ_REMOVE(&cfg->g_hardware, hardware, h_entries);\n\t\t\tlldpd_remote_cleanup(hardware, notify_clients_deletion, 1);\n\t\t\tlldpd_hardware_cleanup(cfg, hardware);\n\t\t} else\n\t\t\tlldpd_remote_cleanup(hardware, notify_clients_deletion, 0);\n\t}\n\n\tlog_debug(\"localchassis\", \"cleanup all chassis\");\n\n\tfor (chassis = TAILQ_FIRST(&cfg->g_chassis); chassis;\n\t     chassis = chassis_next) {\n\t\tchassis_next = TAILQ_NEXT(chassis, c_entries);\n\t\tif (chassis->c_refcount == 0) {\n\t\t\tTAILQ_REMOVE(&cfg->g_chassis, chassis, c_entries);\n\t\t\tlldpd_chassis_cleanup(chassis, 1);\n\t\t}\n\t}\n\n\tlldpd_count_neighbors(cfg);\n\tlevent_schedule_cleanup(cfg);\n}\n\n/* Update chassis `ochassis' with values from `chassis'. The later one is not\n   expected to be part of a list! It will also be wiped from memory. */\nstatic void\nlldpd_move_chassis(struct lldpd_chassis *ochassis,\n    struct lldpd_chassis *chassis) {\n\tstruct lldpd_mgmt *mgmt, *mgmt_next;\n\n\t/* We want to keep refcount, index and list stuff from the current\n\t * chassis */\n\tTAILQ_ENTRY(lldpd_chassis) entries;\n\tint refcount = ochassis->c_refcount;\n\tint index = ochassis->c_index;\n\tmemcpy(&entries, &ochassis->c_entries,\n\t    sizeof(entries));\n\tlldpd_chassis_cleanup(ochassis, 0);\n\n\t/* Make the copy. */\n\t/* WARNING: this is a kludgy hack, we need in-place copy and cannot use\n\t * marshaling. */\n\tmemcpy(ochassis, chassis, sizeof(struct lldpd_chassis));\n\tTAILQ_INIT(&ochassis->c_mgmt);\n\n\t/* Copy of management addresses */\n\tfor (mgmt = TAILQ_FIRST(&chassis->c_mgmt);\n\t     mgmt != NULL;\n\t     mgmt = mgmt_next) {\n\t\tmgmt_next = TAILQ_NEXT(mgmt, m_entries);\n\t\tTAILQ_REMOVE(&chassis->c_mgmt, mgmt, m_entries);\n\t\tTAILQ_INSERT_TAIL(&ochassis->c_mgmt, mgmt, m_entries);\n\t}\n\n\t/* Restore saved values */\n\tochassis->c_refcount = refcount;\n\tochassis->c_index = index;\n\tmemcpy(&ochassis->c_entries, &entries, sizeof(entries));\n\n\t/* Get rid of the new chassis */\n\tfree(chassis);\n}\n\nstatic int\nlldpd_guess_type(struct lldpd *cfg, char *frame, int s)\n{\n\tint i;\n\tif (s < ETHER_ADDR_LEN)\n\t\treturn -1;\n\tfor (i=0; cfg->g_protocols[i].mode != 0; i++) {\n\t\tif (!cfg->g_protocols[i].enabled)\n\t\t\tcontinue;\n\t\tif (cfg->g_protocols[i].guess == NULL) {\n\t\t\tif (memcmp(frame, cfg->g_protocols[i].mac, ETHER_ADDR_LEN) == 0) {\n\t\t\t\tlog_debug(\"decode\", \"guessed protocol is %s (from MAC address)\",\n\t\t\t\t    cfg->g_protocols[i].name);\n\t\t\t\treturn cfg->g_protocols[i].mode;\n\t\t\t}\n\t\t} else {\n\t\t\tif (cfg->g_protocols[i].guess(frame, s)) {\n\t\t\t\tlog_debug(\"decode\", \"guessed protocol is %s (from detector function)\",\n\t\t\t\t    cfg->g_protocols[i].name);\n\t\t\t\treturn cfg->g_protocols[i].mode;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic void\nlldpd_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware)\n{\n\tint i;\n\tstruct lldpd_chassis *chassis, *ochassis = NULL;\n\tstruct lldpd_port *port, *oport = NULL, *aport;\n\tint guess = LLDPD_MODE_LLDP;\n\n\tlog_debug(\"decode\", \"decode a received frame on %s\",\n\t    hardware->h_ifname);\n\n\tif (s < sizeof(struct ether_header) + 4)\n\t\t/* Too short, just discard it */\n\t\treturn;\n\n\t/* Decapsulate VLAN frames */\n\tstruct ether_header eheader;\n\tmemcpy(&eheader, frame, sizeof(struct ether_header));\n\tif (eheader.ether_type == htons(ETHERTYPE_VLAN)) {\n\t\t/* VLAN decapsulation means to shift 4 bytes left the frame from\n\t\t * offset 2*ETHER_ADDR_LEN */\n\t\tmemmove(frame + 2*ETHER_ADDR_LEN, frame + 2*ETHER_ADDR_LEN + 4, s - 2*ETHER_ADDR_LEN);\n\t\ts -= 4;\n\t}\n\n\tTAILQ_FOREACH(oport, &hardware->h_rports, p_entries) {\n\t\tif ((oport->p_lastframe != NULL) &&\n\t\t    (oport->p_lastframe->size == s) &&\n\t\t    (memcmp(oport->p_lastframe->frame, frame, s) == 0)) {\n\t\t\t/* Already received the same frame */\n\t\t\tlog_debug(\"decode\", \"duplicate frame, no need to decode\");\n\t\t\toport->p_lastupdate = time(NULL);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tguess = lldpd_guess_type(cfg, frame, s);\n\tfor (i=0; cfg->g_protocols[i].mode != 0; i++) {\n\t\tif (!cfg->g_protocols[i].enabled)\n\t\t\tcontinue;\n\t\tif (cfg->g_protocols[i].mode == guess) {\n\t\t\tlog_debug(\"decode\", \"using decode function for %s protocol\",\n\t\t\t    cfg->g_protocols[i].name);\n\t\t\tif (cfg->g_protocols[i].decode(cfg, frame,\n\t\t\t\ts, hardware, &chassis, &port) == -1) {\n\t\t\t\tlog_debug(\"decode\", \"function for %s protocol did not decode this frame\",\n\t\t\t\t    cfg->g_protocols[i].name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchassis->c_protocol = port->p_protocol =\n\t\t\t    cfg->g_protocols[i].mode;\n\t\t\tbreak;\n\t\t\t}\n\t}\n\tif (cfg->g_protocols[i].mode == 0) {\n\t\tlog_debug(\"decode\", \"unable to guess frame type on %s\",\n\t\t    hardware->h_ifname);\n\t\treturn;\n\t}\n\tTRACE(LLDPD_FRAME_DECODED(\n\t\t    hardware->h_ifname,\n\t\t    cfg->g_protocols[i].name,\n\t\t    chassis->c_name,\n\t\t    port->p_descr));\n\n\t/* Do we already have the same MSAP somewhere? */\n\tint count = 0;\n\tlog_debug(\"decode\", \"search for the same MSAP\");\n\tTAILQ_FOREACH(oport, &hardware->h_rports, p_entries) {\n\t\tif (port->p_protocol == oport->p_protocol) {\n\t\t\tcount++;\n\t\t\tif ((port->p_id_subtype == oport->p_id_subtype) &&\n\t\t\t    (port->p_id_len == oport->p_id_len) &&\n\t\t\t    (memcmp(port->p_id, oport->p_id, port->p_id_len) == 0) &&\n\t\t\t    (chassis->c_id_subtype == oport->p_chassis->c_id_subtype) &&\n\t\t\t    (chassis->c_id_len == oport->p_chassis->c_id_len) &&\n\t\t\t    (memcmp(chassis->c_id, oport->p_chassis->c_id,\n\t\t\t\tchassis->c_id_len) == 0)) {\n\t\t\t\tochassis = oport->p_chassis;\n\t\t\t\tlog_debug(\"decode\", \"MSAP is already known\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* Do we have room for a new MSAP? */\n\tif (!oport && cfg->g_config.c_max_neighbors) {\n\t    if (count == (cfg->g_config.c_max_neighbors - 1)) {\n\t\tlog_debug(\"decode\",\n\t\t    \"max neighbors %d reached for port %s, \"\n\t\t    \"dropping any new ones silently\",\n\t\t    cfg->g_config.c_max_neighbors,\n\t\t    hardware->h_ifname);\n\t    } else if (count > cfg->g_config.c_max_neighbors - 1) {\n\t\tlog_debug(\"decode\",\n\t\t    \"too many neighbors for port %s, drop this new one\",\n\t\t    hardware->h_ifname);\n\t\tlldpd_port_cleanup(port, 1);\n\t\tlldpd_chassis_cleanup(chassis, 1);\n\t\tfree(port);\n\t\treturn;\n\t    }\n\t}\n\t/* No, but do we already know the system? */\n\tif (!oport) {\n\t\tlog_debug(\"decode\", \"MSAP is unknown, search for the chassis\");\n\t\tTAILQ_FOREACH(ochassis, &cfg->g_chassis, c_entries) {\n\t\t\tif ((chassis->c_protocol == ochassis->c_protocol) &&\n\t\t\t    (chassis->c_id_subtype == ochassis->c_id_subtype) &&\n\t\t\t    (chassis->c_id_len == ochassis->c_id_len) &&\n\t\t\t    (memcmp(chassis->c_id, ochassis->c_id,\n\t\t\t\tchassis->c_id_len) == 0))\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (oport) {\n\t\t/* The port is known, remove it before adding it back */\n\t\tTAILQ_REMOVE(&hardware->h_rports, oport, p_entries);\n\t\tlldpd_port_cleanup(oport, 1);\n\t\tfree(oport);\n\t}\n\tif (ochassis) {\n\t\tlldpd_move_chassis(ochassis, chassis);\n\t\tchassis = ochassis;\n\t} else {\n\t\t/* Chassis not known, add it */\n\t\tlog_debug(\"decode\", \"unknown chassis, add it to the list\");\n\t\tchassis->c_index = ++cfg->g_lastrid;\n\t\tchassis->c_refcount = 0;\n\t\tTAILQ_INSERT_TAIL(&cfg->g_chassis, chassis, c_entries);\n\t\ti = 0; TAILQ_FOREACH(ochassis, &cfg->g_chassis, c_entries) i++;\n\t\tlog_debug(\"decode\", \"%d different systems are known\", i);\n\t}\n\t/* Add port */\n\tport->p_lastchange = port->p_lastupdate = time(NULL);\n\tif ((port->p_lastframe = (struct lldpd_frame *)malloc(s +\n\t\t    sizeof(struct lldpd_frame))) != NULL) {\n\t\tport->p_lastframe->size = s;\n\t\tmemcpy(port->p_lastframe->frame, frame, s);\n\t}\n\tTAILQ_INSERT_TAIL(&hardware->h_rports, port, p_entries);\n\tport->p_chassis = chassis;\n\tport->p_chassis->c_refcount++;\n\t/* Several cases are possible :\n\t     1. chassis is new, its refcount was 0. It is now attached\n\t        to this port, its refcount is 1.\n\t     2. chassis already exists and was attached to another\n\t        port, we increase its refcount accordingly.\n\t     3. chassis already exists and was attached to the same\n\t        port, its refcount was decreased with\n\t        lldpd_port_cleanup() and is now increased again.\n\n\t   In all cases, if the port already existed, it has been\n\t   freed with lldpd_port_cleanup() and therefore, the refcount\n\t   of the chassis that was attached to it is decreased.\n\t*/\n\t/* coverity[use_after_free]\n\t   TAILQ_REMOVE does the right thing */\n\ti = 0; TAILQ_FOREACH(aport, &hardware->h_rports, p_entries)\n\t\ti++;\n\tlog_debug(\"decode\", \"%d neighbors for %s\", i,\n\t    hardware->h_ifname);\n\n\tif (!oport) hardware->h_insert_cnt++;\n\n\t/* Notify */\n\tlog_debug(\"decode\", \"send notifications for changes on %s\",\n\t    hardware->h_ifname);\n\tif (oport) {\n\t\tTRACE(LLDPD_NEIGHBOR_UPDATE(hardware->h_ifname,\n\t\t\tchassis->c_name,\n\t\t\tport->p_descr,\n\t\t\ti));\n\t\tlevent_ctl_notify(hardware->h_ifname, NEIGHBOR_CHANGE_UPDATED, port);\n#ifdef USE_SNMP\n\t\tagent_notify(hardware, NEIGHBOR_CHANGE_UPDATED, port);\n#endif\n\t} else {\n\t\tTRACE(LLDPD_NEIGHBOR_NEW(hardware->h_ifname,\n\t\t\tchassis->c_name,\n\t\t\tport->p_descr,\n\t\t\ti));\n\t\tlevent_ctl_notify(hardware->h_ifname, NEIGHBOR_CHANGE_ADDED, port);\n#ifdef USE_SNMP\n\t\tagent_notify(hardware, NEIGHBOR_CHANGE_ADDED, port);\n#endif\n\t}\n\n#ifdef ENABLE_LLDPMED\n\tif (!oport && port->p_chassis->c_med_type) {\n\t\t/* New neighbor, fast start */\n\t\tif (hardware->h_cfg->g_config.c_enable_fast_start &&\n\t\t    !hardware->h_tx_fast) {\n\t\t\tlog_debug(\"decode\", \"%s: entering fast start due to \"\n\t\t\t    \"new neighbor\", hardware->h_ifname);\n\t\t\thardware->h_tx_fast = hardware->h_cfg->g_config.c_tx_fast_init;\n\t\t}\n\n\t\tlevent_schedule_pdu(hardware);\n\t}\n#endif\n\n\treturn;\n}\n\n/* Get the output of lsb_release -s -d.  This is a slow function. It should be\n   called once. It return NULL if any problem happens. Otherwise, this is a\n   statically allocated buffer. The result includes the trailing \\n  */\nstatic char *\nlldpd_get_lsb_release() {\n\tstatic char release[1024];\n\tchar *const command[] = { \"lsb_release\", \"-s\", \"-d\", NULL };\n\tint pid, status, devnull, count;\n\tint pipefd[2];\n\n\tlog_debug(\"localchassis\", \"grab LSB release\");\n\n\tif (pipe(pipefd)) {\n\t\tlog_warn(\"localchassis\", \"unable to get a pair of pipes\");\n\t\treturn NULL;\n\t}\n\n\tpid = vfork();\n\tswitch (pid) {\n\tcase -1:\n\t\tlog_warn(\"localchassis\", \"unable to fork\");\n\t\treturn NULL;\n\tcase 0:\n\t\t/* Child, exec lsb_release */\n\t\tclose(pipefd[0]);\n\t\tif ((devnull = open(\"/dev/null\", O_RDWR, 0)) != -1) {\n\t\t\tdup2(devnull, STDIN_FILENO);\n\t\t\tdup2(devnull, STDERR_FILENO);\n\t\t\tdup2(pipefd[1], STDOUT_FILENO);\n\t\t\tif (devnull > 2) close(devnull);\n\t\t\tif (pipefd[1] > 2) close(pipefd[1]);\n\t\t\texecvp(\"lsb_release\", command);\n\t\t}\n\t\t_exit(127);\n\t\tbreak;\n\tdefault:\n\t\t/* Father, read the output from the children */\n\t\tclose(pipefd[1]);\n\t\tcount = 0;\n\t\tdo {\n\t\t\tstatus = read(pipefd[0], release+count, sizeof(release)-count);\n\t\t\tif ((status == -1) && (errno == EINTR)) continue;\n\t\t\tif (status > 0)\n\t\t\t\tcount += status;\n\t\t} while (count < sizeof(release) && (status > 0));\n\t\tif (status < 0) {\n\t\t\tlog_info(\"localchassis\", \"unable to read from lsb_release\");\n\t\t\tclose(pipefd[0]);\n\t\t\twaitpid(pid, &status, 0);\n\t\t\treturn NULL;\n\t\t}\n\t\tclose(pipefd[0]);\n\t\tif (count >= sizeof(release)) {\n\t\t\tlog_info(\"localchassis\", \"output of lsb_release is too large\");\n\t\t\twaitpid(pid, &status, 0);\n\t\t\treturn NULL;\n\t\t}\n\t\tstatus = -1;\n\t\tif (waitpid(pid, &status, 0) != pid)\n\t\t\treturn NULL;\n\t\tif (!WIFEXITED(status) || (WEXITSTATUS(status) != 0)) {\n\t\t\tlog_info(\"localchassis\", \"lsb_release information not available\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!count) {\n\t\t\tlog_info(\"localchassis\", \"lsb_release returned an empty string\");\n\t\t\treturn NULL;\n\t\t}\n\t\trelease[count] = '\\0';\n\t\treturn release;\n\t}\n\t/* Should not be here */\n\treturn NULL;\n}\n\n/* Same like lldpd_get_lsb_release but reads /etc/os-release for PRETTY_NAME=. */\nstatic char *\nlldpd_get_os_release() {\n\tstatic char release[1024];\n\tchar line[1024];\n\tchar *key, *val;\n\tchar *ptr1 = release;\n\n\tlog_debug(\"localchassis\", \"grab OS release\");\n\tFILE *fp = fopen(\"/etc/os-release\", \"r\");\n\tif (!fp) {\n\t\tlog_debug(\"localchassis\", \"could not open /etc/os-release\");\n\t\tfp = fopen(\"/usr/lib/os-release\", \"r\");\n\t}\n\tif (!fp) {\n\t\tlog_info(\"localchassis\",\n\t\t    \"could not open either /etc/os-release or /usr/lib/os-release\");\n\t\treturn NULL;\n\t}\n\n\twhile ((fgets(line, sizeof(line), fp) != NULL)) {\n\t\tkey = strtok(line, \"=\");\n\t\tval = strtok(NULL, \"=\");\n\n\t\tif (strncmp(key, \"PRETTY_NAME\", sizeof(line)) == 0) {\n\t\t\tstrlcpy(release, val, sizeof(line));\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(fp);\n\n\t/* Remove trailing newline and all \" in the string. */\n\tptr1 = release + strlen(release) - 1;\n\twhile (ptr1 != release &&\n\t    ((*ptr1 == '\"') || (*ptr1 == '\\n'))) {\n\t\t*ptr1 = '\\0';\n\t\tptr1--;\n\t}\n\tif (release[0] == '\"')\n\t\treturn release+1;\n\treturn release;\n}\n\nstatic void\nlldpd_hide_ports(struct lldpd *cfg, struct lldpd_hardware *hardware, int mask) {\n\tstruct lldpd_port *port;\n\tint protocols[LLDPD_MODE_MAX+1];\n\tchar buffer[256];\n\tint i, j, k, found;\n\tunsigned int min;\n\n\tlog_debug(\"smartfilter\", \"apply smart filter for port %s\",\n\t\thardware->h_ifname);\n\n\t/* Compute the number of occurrences of each protocol */\n\tfor (i = 0; i <= LLDPD_MODE_MAX; i++) protocols[i] = 0;\n\tTAILQ_FOREACH(port, &hardware->h_rports, p_entries)\n\t\tprotocols[port->p_protocol]++;\n\n\t/* Turn the protocols[] array into an array of\n\t   enabled/disabled protocols. 1 means enabled, 0\n\t   means disabled. */\n\tmin = (unsigned int)-1;\n\tfor (i = 0; i <= LLDPD_MODE_MAX; i++)\n\t\tif (protocols[i] && (protocols[i] < min))\n\t\t\tmin = protocols[i];\n\tfound = 0;\n\tfor (i = 0; i <= LLDPD_MODE_MAX; i++)\n\t\tif ((protocols[i] == min) && !found) {\n\t\t\t/* If we need a tie breaker, we take\n\t\t\t   the first protocol only */\n\t\t\tif (cfg->g_config.c_smart & mask &\n\t\t\t    (SMART_OUTGOING_ONE_PROTO | SMART_INCOMING_ONE_PROTO))\n\t\t\t\tfound = 1;\n\t\t\tprotocols[i] = 1;\n\t\t} else protocols[i] = 0;\n\n\t/* We set the p_hidden flag to 1 if the protocol is disabled */\n\tTAILQ_FOREACH(port, &hardware->h_rports, p_entries) {\n\t\tif (mask == SMART_OUTGOING)\n\t\t\tport->p_hidden_out = protocols[port->p_protocol]?0:1;\n\t\telse\n\t\t\tport->p_hidden_in = protocols[port->p_protocol]?0:1;\n\t}\n\n\t/* If we want only one neighbor, we take the first one */\n\tif (cfg->g_config.c_smart & mask &\n\t    (SMART_OUTGOING_ONE_NEIGH | SMART_INCOMING_ONE_NEIGH)) {\n\t\tfound = 0;\n\t\tTAILQ_FOREACH(port, &hardware->h_rports, p_entries) {\n\t\t\tif (mask == SMART_OUTGOING) {\n\t\t\t\tif (found) port->p_hidden_out = 1;\n\t\t\t\tif (!port->p_hidden_out)\n\t\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tif (mask == SMART_INCOMING) {\n\t\t\t\tif (found) port->p_hidden_in = 1;\n\t\t\t\tif (!port->p_hidden_in)\n\t\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Print a debug message summarizing the operation */\n\tfor (i = 0; i <= LLDPD_MODE_MAX; i++) protocols[i] = 0;\n\tk = j = 0;\n\tTAILQ_FOREACH(port, &hardware->h_rports, p_entries) {\n\t\tif (!(((mask == SMART_OUTGOING) && port->p_hidden_out) ||\n\t\t      ((mask == SMART_INCOMING) && port->p_hidden_in))) {\n\t\t\tk++;\n\t\t\tprotocols[port->p_protocol] = 1;\n\t\t}\n\t\tj++;\n\t}\n\tbuffer[0] = '\\0';\n\tfor (i=0; cfg->g_protocols[i].mode != 0; i++) {\n\t\tif (cfg->g_protocols[i].enabled && protocols[cfg->g_protocols[i].mode]) {\n\t\t\tif (strlen(buffer) +\n\t\t\t    strlen(cfg->g_protocols[i].name) + 3 > sizeof(buffer)) {\n\t\t\t\t/* Unlikely, our buffer is too small */\n\t\t\t\tmemcpy(buffer + sizeof(buffer) - 4, \"...\", 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (buffer[0])\n\t\t\t\tstrncat(buffer, \", \", 2);\n\t\t\tstrncat(buffer, cfg->g_protocols[i].name, strlen(cfg->g_protocols[i].name));\n\t\t}\n\t}\n\tlog_debug(\"smartfilter\", \"%s: %s: %d visible neighbors (out of %d)\",\n\t    hardware->h_ifname,\n\t    (mask == SMART_OUTGOING)?\"out filter\":\"in filter\",\n\t    k, j);\n\tlog_debug(\"smartfilter\", \"%s: protocols: %s\",\n\t    hardware->h_ifname, buffer[0]?buffer:\"(none)\");\n}\n\n/* Hide unwanted ports depending on smart mode set by the user */\nstatic void\nlldpd_hide_all(struct lldpd *cfg)\n{\n\tstruct lldpd_hardware *hardware;\n\n\tif (!cfg->g_config.c_smart)\n\t\treturn;\n\tlog_debug(\"smartfilter\", \"apply smart filter results on all ports\");\n\tTAILQ_FOREACH(hardware, &cfg->g_hardware, h_entries) {\n\t\tif (cfg->g_config.c_smart & SMART_INCOMING_FILTER)\n\t\t\tlldpd_hide_ports(cfg, hardware, SMART_INCOMING);\n\t\tif (cfg->g_config.c_smart & SMART_OUTGOING_FILTER)\n\t\t\tlldpd_hide_ports(cfg, hardware, SMART_OUTGOING);\n\t}\n}\n\nvoid\nlldpd_recv(struct lldpd *cfg, struct lldpd_hardware *hardware, int fd)\n{\n\tchar *buffer = NULL;\n\tint n;\n\tlog_debug(\"receive\", \"receive a frame on %s\",\n\t    hardware->h_ifname);\n\tif ((buffer = (char *)malloc(hardware->h_mtu)) == NULL) {\n\t\tlog_warn(\"receive\", \"failed to alloc reception buffer\");\n\t\treturn;\n\t}\n\tif ((n = hardware->h_ops->recv(cfg, hardware,\n\t\t    fd, buffer,\n\t\t    hardware->h_mtu)) == -1) {\n\t\tlog_debug(\"receive\", \"discard frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tfree(buffer);\n\t\treturn;\n\t}\n\tif (cfg->g_config.c_paused) {\n\t\tlog_debug(\"receive\", \"paused, ignore the frame on %s\",\n\t\t\thardware->h_ifname);\n\t\tfree(buffer);\n\t\treturn;\n\t}\n\thardware->h_rx_cnt++;\n\tlog_debug(\"receive\", \"decode received frame on %s\",\n\t    hardware->h_ifname);\n\tTRACE(LLDPD_FRAME_RECEIVED(hardware->h_ifname, buffer, (size_t)n));\n\tlldpd_decode(cfg, buffer, n, hardware);\n\tlldpd_hide_all(cfg); /* Immediatly hide */\n\tlldpd_count_neighbors(cfg);\n\tfree(buffer);\n}\n\nstatic void\nlldpd_send_shutdown(struct lldpd_hardware *hardware)\n{\n\tstruct lldpd *cfg = hardware->h_cfg;\n\tif (cfg->g_config.c_receiveonly || cfg->g_config.c_paused) return;\n\tif ((hardware->h_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\t/* It's safe to call `lldp_send_shutdown()` because shutdown LLDPU will\n\t * only be emitted if LLDP was sent on that port. */\n\tif (lldp_send_shutdown(hardware->h_cfg, hardware) != 0)\n\t\tlog_warnx(\"send\", \"unable to send shutdown LLDPDU on %s\",\n\t\t    hardware->h_ifname);\n}\n\nvoid\nlldpd_send(struct lldpd_hardware *hardware)\n{\n\tstruct lldpd *cfg = hardware->h_cfg;\n\tstruct lldpd_port *port;\n\tint i, sent;\n\n\tif (cfg->g_config.c_receiveonly || cfg->g_config.c_paused) return;\n\tif ((hardware->h_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\tlog_debug(\"send\", \"send PDU on %s\", hardware->h_ifname);\n\tsent = 0;\n\tfor (i=0; cfg->g_protocols[i].mode != 0; i++) {\n\t\tif (!cfg->g_protocols[i].enabled)\n\t\t\tcontinue;\n\t\t/* We send only if we have at least one remote system\n\t\t * speaking this protocol or if the protocol is forced */\n\t\tif (cfg->g_protocols[i].enabled > 1) {\n\t\t\tcfg->g_protocols[i].send(cfg, hardware);\n\t\t\tsent++;\n\t\t\tcontinue;\n\t\t}\n\t\tTAILQ_FOREACH(port, &hardware->h_rports, p_entries) {\n\t\t\t/* If this remote port is disabled, we don't\n\t\t\t * consider it */\n\t\t\tif (port->p_hidden_out)\n\t\t\t\tcontinue;\n\t\t\tif (port->p_protocol ==\n\t\t\t    cfg->g_protocols[i].mode) {\n\t\t\t\tTRACE(LLDPD_FRAME_SEND(hardware->h_ifname,\n\t\t\t\t\tcfg->g_protocols[i].name));\n\t\t\t\tlog_debug(\"send\", \"send PDU on %s with protocol %s\",\n\t\t\t\t    hardware->h_ifname,\n\t\t\t\t    cfg->g_protocols[i].name);\n\t\t\t\tcfg->g_protocols[i].send(cfg,\n\t\t\t\t    hardware);\n\t\t\t\tsent++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!sent) {\n\t\t/* Nothing was sent for this port, let's speak the first\n\t\t * available protocol. */\n\t\tfor (i = 0; cfg->g_protocols[i].mode != 0; i++) {\n\t\t\tif (!cfg->g_protocols[i].enabled) continue;\n\t\t\tTRACE(LLDPD_FRAME_SEND(hardware->h_ifname,\n\t\t\t\tcfg->g_protocols[i].name));\n\t\t\tlog_debug(\"send\", \"fallback to protocol %s for %s\",\n\t\t\t    cfg->g_protocols[i].name, hardware->h_ifname);\n\t\t\tcfg->g_protocols[i].send(cfg,\n\t\t\t    hardware);\n\t\t\tbreak;\n\t\t}\n\t\tif (cfg->g_protocols[i].mode == 0)\n\t\t\tlog_warnx(\"send\", \"no protocol enabled, dunno what to send\");\n\t}\n}\n\n#ifdef ENABLE_LLDPMED\nstatic void\nlldpd_med(struct lldpd_chassis *chassis)\n{\n\tstatic short int once = 0;\n\tif (!once) {\n\t\tchassis->c_med_hw = dmi_hw();\n\t\tchassis->c_med_fw = dmi_fw();\n\t\tchassis->c_med_sn = dmi_sn();\n\t\tchassis->c_med_manuf = dmi_manuf();\n\t\tchassis->c_med_model = dmi_model();\n\t\tchassis->c_med_asset = dmi_asset();\n\t\tonce = 1;\n\t}\n}\n#endif\n\nstatic int\nlldpd_routing_enabled(struct lldpd *cfg)\n{\n\tint routing;\n\n\tif ((LOCAL_CHASSIS(cfg)->c_cap_available & LLDP_CAP_ROUTER) == 0)\n\t\treturn 0;\n\n\tif ((routing = interfaces_routing_enabled(cfg)) == -1) {\n\t\tlog_debug(\"localchassis\", \"unable to check if routing is enabled\");\n\t\treturn 0;\n\t}\n\treturn routing;\n}\n\nstatic void\nlldpd_update_localchassis(struct lldpd *cfg)\n{\n\tstruct utsname un;\n\tchar *hp;\n\n\tlog_debug(\"localchassis\", \"update information for local chassis\");\n\tassert(LOCAL_CHASSIS(cfg) != NULL);\n\n\t/* Set system name and description */\n\tif (uname(&un) < 0)\n\t\tfatal(\"localchassis\", \"failed to get system information\");\n\tif (cfg->g_config.c_hostname) {\n\t\tlog_debug(\"localchassis\", \"use overridden system name `%s`\", cfg->g_config.c_hostname);\n\t\thp = cfg->g_config.c_hostname;\n\t} else {\n\t\tif ((hp = priv_gethostname()) == NULL)\n\t\t\tfatal(\"localchassis\", \"failed to get system name\");\n\t}\n\tfree(LOCAL_CHASSIS(cfg)->c_name);\n\tfree(LOCAL_CHASSIS(cfg)->c_descr);\n\tif ((LOCAL_CHASSIS(cfg)->c_name = strdup(hp)) == NULL)\n\t\tfatal(\"localchassis\", NULL);\n        if (cfg->g_config.c_description) {\n\t\tlog_debug(\"localchassis\", \"use overridden description `%s`\", cfg->g_config.c_description);\n                if (asprintf(&LOCAL_CHASSIS(cfg)->c_descr, \"%s\",\n\t\t\tcfg->g_config.c_description) == -1)\n\t\t\tfatal(\"localchassis\", \"failed to set full system description\");\n        } else {\n\t        if (cfg->g_config.c_advertise_version) {\n\t\t\tlog_debug(\"localchassis\", \"advertise system version\");\n\t\t        if (asprintf(&LOCAL_CHASSIS(cfg)->c_descr, \"%s %s %s %s %s\",\n\t\t\t        cfg->g_lsb_release?cfg->g_lsb_release:\"\",\n\t\t\t\tun.sysname, un.release, un.version, un.machine)\n                                == -1)\n\t\t\t        fatal(\"localchassis\", \"failed to set full system description\");\n\t        } else {\n\t\t\tlog_debug(\"localchassis\", \"do not advertise system version\");\n\t\t        if (asprintf(&LOCAL_CHASSIS(cfg)->c_descr, \"%s\",\n                                cfg->g_lsb_release?cfg->g_lsb_release:un.sysname) == -1)\n\t\t\t        fatal(\"localchassis\", \"failed to set minimal system description\");\n\t        }\n        }\n\tif (cfg->g_config.c_platform == NULL)\n\t\tcfg->g_config.c_platform = strdup(un.sysname);\n\n\t/* Check routing */\n\tif (lldpd_routing_enabled(cfg)) {\n\t\tlog_debug(\"localchassis\", \"routing is enabled, enable router capability\");\n\t\tLOCAL_CHASSIS(cfg)->c_cap_enabled |= LLDP_CAP_ROUTER;\n\t} else\n\t\tLOCAL_CHASSIS(cfg)->c_cap_enabled &= ~LLDP_CAP_ROUTER;\n\n#ifdef ENABLE_LLDPMED\n\tif (LOCAL_CHASSIS(cfg)->c_cap_available & LLDP_CAP_TELEPHONE)\n\t\tLOCAL_CHASSIS(cfg)->c_cap_enabled |= LLDP_CAP_TELEPHONE;\n\tlldpd_med(LOCAL_CHASSIS(cfg));\n\tfree(LOCAL_CHASSIS(cfg)->c_med_sw);\n\tif (cfg->g_config.c_advertise_version)\n\t\tLOCAL_CHASSIS(cfg)->c_med_sw = strdup(un.release);\n\telse\n\t\tLOCAL_CHASSIS(cfg)->c_med_sw = strdup(\"Unknown\");\n#endif\n\tif ((LOCAL_CHASSIS(cfg)->c_cap_available & LLDP_CAP_STATION) &&\n\t\t(LOCAL_CHASSIS(cfg)->c_cap_enabled == 0))\n\t\tLOCAL_CHASSIS(cfg)->c_cap_enabled = LLDP_CAP_STATION;\n\n\t/* Set chassis ID if needed. This is only done if chassis ID\n\t   has not been set previously (with the MAC address of an\n\t   interface for example)\n\t*/\n\tif (LOCAL_CHASSIS(cfg)->c_id == NULL) {\n\t\tlog_debug(\"localchassis\", \"no chassis ID is currently set, use chassis name\");\n\t\tif (!(LOCAL_CHASSIS(cfg)->c_id = strdup(LOCAL_CHASSIS(cfg)->c_name)))\n\t\t\tfatal(\"localchassis\", NULL);\n\t\tLOCAL_CHASSIS(cfg)->c_id_len = strlen(LOCAL_CHASSIS(cfg)->c_name);\n\t\tLOCAL_CHASSIS(cfg)->c_id_subtype = LLDP_CHASSISID_SUBTYPE_LOCAL;\n\t}\n}\n\nvoid\nlldpd_update_localports(struct lldpd *cfg)\n{\n\tstruct lldpd_hardware *hardware;\n\n\tlog_debug(\"localchassis\", \"update information for local ports\");\n\n\t/* h_flags is set to 0 for each port. If the port is updated, h_flags\n\t * will be set to a non-zero value. This will allow us to clean up any\n\t * non up-to-date port */\n\tTAILQ_FOREACH(hardware, &cfg->g_hardware, h_entries)\n\t    hardware->h_flags = 0;\n\n\tTRACE(LLDPD_INTERFACES_UPDATE());\n\tinterfaces_update(cfg);\n\tlldpd_cleanup(cfg);\n\tlldpd_reset_timer(cfg);\n}\n\nvoid\nlldpd_loop(struct lldpd *cfg)\n{\n\t/* Main loop.\n\t   1. Update local ports information\n\t   2. Update local chassis information\n\t*/\n\tlog_debug(\"loop\", \"start new loop\");\n\tLOCAL_CHASSIS(cfg)->c_cap_enabled = 0;\n\t/* Information for local ports is triggered even when it is possible to\n\t * update them on some other event because we want to refresh them if we\n\t * missed something. */\n\tlog_debug(\"loop\", \"update information for local ports\");\n\tlldpd_update_localports(cfg);\n\tlog_debug(\"loop\", \"update information for local chassis\");\n\tlldpd_update_localchassis(cfg);\n\tlldpd_count_neighbors(cfg);\n}\n\nstatic void\nlldpd_exit(struct lldpd *cfg)\n{\n\tstruct lldpd_hardware *hardware, *hardware_next;\n\tlog_debug(\"main\", \"exit lldpd\");\n\n\tTAILQ_FOREACH(hardware, &cfg->g_hardware, h_entries)\n\t\tlldpd_send_shutdown(hardware);\n\n\tclose(cfg->g_ctl);\n\tpriv_ctl_cleanup(cfg->g_ctlname);\n\tlog_debug(\"main\", \"cleanup hardware information\");\n\tfor (hardware = TAILQ_FIRST(&cfg->g_hardware); hardware != NULL;\n\t     hardware = hardware_next) {\n\t\thardware_next = TAILQ_NEXT(hardware, h_entries);\n\t\tlog_debug(\"main\", \"cleanup interface %s\", hardware->h_ifname);\n\t\tlldpd_remote_cleanup(hardware, NULL, 1);\n\t\tlldpd_hardware_cleanup(cfg, hardware);\n\t}\n}\n\n/**\n * Run lldpcli to configure lldpd.\n *\n * @return PID of running lldpcli or -1 if error.\n */\nstatic pid_t\nlldpd_configure(int debug, const char *path, const char *ctlname)\n{\n\tpid_t lldpcli = vfork();\n\tint devnull;\n\n\tchar sdebug[debug + 3];\n\tmemset(sdebug, 'd', debug + 3);\n\tsdebug[debug + 2] = '\\0';\n\tsdebug[0] = '-'; sdebug[1] = 's';\n\tlog_debug(\"main\", \"invoke %s %s\", path, sdebug);\n\n\tswitch (lldpcli) {\n\tcase -1:\n\t\tlog_warn(\"main\", \"unable to fork\");\n\t\treturn -1;\n\tcase 0:\n\t\t/* Child, exec lldpcli */\n\t\tif ((devnull = open(\"/dev/null\", O_RDWR, 0)) != -1) {\n\t\t\tdup2(devnull,   STDIN_FILENO);\n\t\t\tdup2(devnull,   STDOUT_FILENO);\n\t\t\tif (devnull > 2) close(devnull);\n\n\t\t\texecl(path, \"lldpcli\", sdebug,\n\t\t\t    \"-u\", ctlname,\n\t\t\t    \"-c\", SYSCONFDIR \"/lldpd.conf\",\n\t\t\t    \"-c\", SYSCONFDIR \"/lldpd.d\",\n\t\t\t    \"resume\",\n\t\t\t    (char *)NULL);\n\t\t\tlog_warn(\"main\", \"unable to execute %s\", path);\n\t\t\tlog_warnx(\"main\", \"configuration is incomplete, lldpd needs to be unpaused\");\n\t\t}\n\t\t_exit(127);\n\t\tbreak;\n\tdefault:\n\t\t/* Father, don't do anything stupid */\n\t\treturn lldpcli;\n\t}\n\t/* Should not be here */\n\treturn -1;\n}\n\nstruct intint { int a; int b; };\nstatic const struct intint filters[] = {\n\t{  0, 0 },\n\t{  1, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_PROTO },\n\t{  2, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO },\n\t{  3, SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_PROTO },\n\t{  4, SMART_INCOMING_FILTER | SMART_OUTGOING_FILTER },\n\t{  5, SMART_INCOMING_FILTER },\n\t{  6, SMART_OUTGOING_FILTER },\n\t{  7, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO | SMART_INCOMING_ONE_NEIGH |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_PROTO },\n\t{  8, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO | SMART_INCOMING_ONE_NEIGH },\n\t{  9, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_NEIGH |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_PROTO },\n\t{ 10, SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_NEIGH },\n\t{ 11, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_NEIGH },\n\t{ 12, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_NEIGH |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_NEIGH },\n\t{ 13, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_NEIGH |\n\t      SMART_OUTGOING_FILTER },\n\t{ 14, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_NEIGH },\n\t{ 15, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO |\n\t      SMART_OUTGOING_FILTER },\n\t{ 16, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO | SMART_INCOMING_ONE_NEIGH |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_NEIGH },\n\t{ 17, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO | SMART_INCOMING_ONE_NEIGH |\n\t      SMART_OUTGOING_FILTER },\n\t{ 18, SMART_INCOMING_FILTER |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_NEIGH },\n\t{ 19, SMART_INCOMING_FILTER |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_PROTO },\n\t{ -1, 0 }\n};\n\n#ifndef HOST_OS_OSX\n/**\n * Tell if we have been started by upstart.\n */\nstatic int\nlldpd_started_by_upstart()\n{\n#ifdef HOST_OS_LINUX\n\tconst char *upstartjob = getenv(\"UPSTART_JOB\");\n\tif (!(upstartjob && !strcmp(upstartjob, \"lldpd\")))\n\t\treturn 0;\n\tlog_debug(\"main\", \"running with upstart, don't fork but stop\");\n\traise(SIGSTOP);\n\tunsetenv(\"UPSTART_JOB\");\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\n/**\n * Tell if we have been started by systemd.\n */\nstatic int\nlldpd_started_by_systemd()\n{\n#ifdef HOST_OS_LINUX\n\tint fd = -1;\n\tconst char *notifysocket = getenv(\"NOTIFY_SOCKET\");\n\tif (!notifysocket ||\n\t    !strchr(\"@/\", notifysocket[0]) ||\n\t    strlen(notifysocket) < 2)\n\t\treturn 0;\n\n\tlog_debug(\"main\", \"running with systemd, don't fork but signal ready\");\n\tif ((fd = socket(AF_UNIX, SOCK_DGRAM, 0)) < 0) {\n\t\tlog_warn(\"main\", \"unable to open systemd notification socket %s\",\n\t\t    notifysocket);\n\t\treturn 0;\n\t}\n\n\tstruct sockaddr_un su = { .sun_family = AF_UNIX };\n\tstrlcpy(su.sun_path, notifysocket, sizeof(su.sun_path));\n\tif (notifysocket[0] == '@') su.sun_path[0] = 0;\n\n\tstruct iovec iov = {\n\t\t.iov_base = \"READY=1\",\n\t\t.iov_len = strlen(\"READY=1\")\n\t};\n\tstruct msghdr hdr = {\n\t\t.msg_name = &su,\n\t\t.msg_namelen = offsetof(struct sockaddr_un, sun_path) + strlen(notifysocket),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1\n\t};\n\tunsetenv(\"NOTIFY_SOCKET\");\n\tif (sendmsg(fd, &hdr, MSG_NOSIGNAL) < 0) {\n\t\tlog_warn(\"main\", \"unable to send notification to systemd\");\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tclose(fd);\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n#endif\n\nint\nlldpd_main(int argc, char *argv[], char *envp[])\n{\n\tstruct lldpd *cfg;\n\tstruct lldpd_chassis *lchassis;\n\tint ch, debug = 0;\n#ifdef USE_SNMP\n\tint snmp = 0;\n\tconst char *agentx = NULL;\t/* AgentX socket */\n#endif\n\tconst char *ctlname = NULL;\n\tchar *mgmtp = NULL;\n\tchar *cidp = NULL;\n\tchar *interfaces = NULL;\n\t/* We do not want more options here. Please add them in lldpcli instead\n\t * unless there is a very good reason. Most command-line options will\n\t * get deprecated at some point. */\n\tchar *popt, opts[] =\n\t\t\"H:vhkrdD:xX:m:u:4:6:I:C:p:M:P:S:iL:@                    \";\n\tint i, found, advertise_version = 1;\n#ifdef ENABLE_LLDPMED\n\tint lldpmed = 0, noinventory = 0;\n\tint enable_fast_start = 1;\n#endif\n\tchar *descr_override = NULL;\n\tchar *platform_override = NULL;\n\tchar *lsb_release = NULL;\n\tconst char *lldpcli = LLDPCLI_PATH;\n\tint smart = 15;\n\tint receiveonly = 0;\n\tint ctl;\n\n#ifdef ENABLE_PRIVSEP\n\t/* Non privileged user */\n\tstruct passwd *user;\n\tstruct group *group;\n\tuid_t uid;\n\tgid_t gid;\n#endif\n\n\tsaved_argv = argv;\n\n#if HAVE_SETPROCTITLE_INIT\n\tsetproctitle_init(argc, argv, envp);\n#endif\n\n\t/*\n\t * Get and parse command line options\n\t */\n\tif ((popt = strchr(opts, '@')) != NULL) {\n\t\tfor (i=0;\n\t\t     protos[i].mode != 0 && *popt != '\\0';\n\t\t     i++)\n\t\t\t*(popt++) = protos[i].arg;\n\t\t*popt = '\\0';\n\t}\n\twhile ((ch = getopt(argc, argv, opts)) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tfprintf(stdout, \"%s\\n\", PACKAGE_VERSION);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdebug++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tlog_accept(optarg);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\treceiveonly = 1;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (mgmtp) {\n\t\t\t\tfprintf(stderr, \"-m can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tmgmtp = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tif (ctlname) {\n\t\t\t\tfprintf(stderr, \"-u can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tctlname = optarg;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tif (interfaces) {\n\t\t\t\tfprintf(stderr, \"-I can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tinterfaces = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tif (cidp) {\n\t\t\t\tfprintf(stderr, \"-C can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tcidp = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif (strlen(optarg)) lldpcli = optarg;\n\t\t\telse lldpcli = NULL;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tadvertise_version = 0;\n\t\t\tbreak;\n#ifdef ENABLE_LLDPMED\n\t\tcase 'M':\n\t\t\tlldpmed = atoi(optarg);\n\t\t\tif ((lldpmed < 1) || (lldpmed > 4)) {\n\t\t\t\tfprintf(stderr, \"-M requires an argument between 1 and 4\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tnoinventory = 1;\n\t\t\tbreak;\n#else\n\t\tcase 'M':\n\t\tcase 'i':\n\t\t\tfprintf(stderr, \"LLDP-MED support is not built-in\\n\");\n\t\t\tusage();\n\t\t\tbreak;\n#endif\n#ifdef USE_SNMP\n\t\tcase 'x':\n\t\t\tsnmp = 1;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tif (agentx) {\n\t\t\t\tfprintf(stderr, \"-X can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tsnmp = 1;\n\t\t\tagentx = optarg;\n\t\t\tbreak;\n#else\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tfprintf(stderr, \"SNMP support is not built-in\\n\");\n\t\t\tusage();\n#endif\n\t\t\tbreak;\n                case 'S':\n\t\t\tif (descr_override) {\n\t\t\t\tfprintf(stderr, \"-S can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n                        descr_override = strdup(optarg);\n                        break;\n\t\tcase 'P':\n\t\t\tif (platform_override) {\n\t\t\t\tfprintf(stderr, \"-P can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tplatform_override = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tsmart = atoi(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfound = 0;\n\t\t\tfor (i=0; protos[i].mode != 0; i++) {\n\t\t\t\tif (ch == protos[i].arg) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tprotos[i].enabled++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tusage();\n\t\t}\n\t}\n\n\tif (ctlname == NULL) ctlname = LLDPD_CTL_SOCKET;\n\n\t/* Set correct smart mode */\n\tfor (i=0; (filters[i].a != -1) && (filters[i].a != smart); i++);\n\tif (filters[i].a == -1) {\n\t\tfprintf(stderr, \"Incorrect mode for -H\\n\");\n\t\tusage();\n\t}\n\tsmart = filters[i].b;\n\n\tlog_init(debug, __progname);\n\ttzset();\t\t/* Get timezone info before chroot */\n\n\tlog_debug(\"main\", \"lldpd \" PACKAGE_VERSION \" starting...\");\n\n\t/* Grab uid and gid to use for priv sep */\n#ifdef ENABLE_PRIVSEP\n\tif ((user = getpwnam(PRIVSEP_USER)) == NULL)\n\t\tfatal(\"main\", \"no \" PRIVSEP_USER \" user for privilege separation\");\n\tuid = user->pw_uid;\n\tif ((group = getgrnam(PRIVSEP_GROUP)) == NULL)\n\t\tfatal(\"main\", \"no \" PRIVSEP_GROUP \" group for privilege separation\");\n\tgid = group->gr_gid;\n#endif\n\n\t/* Create and setup socket */\n\tint retry = 1;\n\tlog_debug(\"main\", \"creating control socket\");\n\twhile ((ctl = ctl_create(ctlname)) == -1) {\n\t\tif (retry-- && errno == EADDRINUSE) {\n\t\t\t/* Check if a daemon is really listening */\n\t\t\tint tfd;\n\t\t\tlog_info(\"main\", \"unable to create control socket because it already exists\");\n\t\t\tlog_info(\"main\", \"check if another instance is running\");\n\t\t\tif ((tfd = ctl_connect(ctlname)) != -1) {\n\t\t\t\t/* Another instance is running */\n\t\t\t\tclose(tfd);\n\t\t\t\tlog_warnx(\"main\", \"another instance is running, please stop it\");\n\t\t\t\tfatalx(\"main\", \"giving up\");\n\t\t\t} else if (errno == ECONNREFUSED) {\n\t\t\t\t/* Nobody is listening */\n\t\t\t\tlog_info(\"main\", \"old control socket is present, clean it\");\n\t\t\t\tctl_cleanup(ctlname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlog_warn(\"main\", \"cannot determine if another daemon is already running\");\n\t\t\tfatalx(\"main\", \"giving up\");\n\t\t}\n\t\tlog_warn(\"main\", \"unable to create control socket\");\n\t\tfatalx(\"main\", \"giving up\");\n\t}\n#ifdef ENABLE_PRIVSEP\n\tif (chown(ctlname, uid, gid) == -1)\n\t\tlog_warn(\"main\", \"unable to chown control socket\");\n\tif (chmod(ctlname,\n\t\tS_IRUSR | S_IWUSR | S_IXUSR |\n\t\tS_IRGRP | S_IWGRP | S_IXGRP) == -1)\n\t\tlog_warn(\"main\", \"unable to chmod control socket\");\n#endif\n\n\t/* Disable SIGPIPE */\n\tsignal(SIGPIPE, SIG_IGN);\n\n\t/* Disable SIGHUP, until handlers are installed */\n\tsignal(SIGHUP, SIG_IGN);\n\n\t/* Configuration with lldpcli */\n\tif (lldpcli) {\n\t\tlog_debug(\"main\", \"invoking lldpcli for configuration\");\n\t\tif (lldpd_configure(debug, lldpcli, ctlname) == -1)\n\t\t\tfatal(\"main\", \"unable to spawn lldpcli\");\n\t}\n\n\t/* Daemonization, unless started by upstart, systemd or launchd or debug */\n#ifndef HOST_OS_OSX\n\tif (!lldpd_started_by_upstart() && !lldpd_started_by_systemd() &&\n\t    !debug) {\n\t\tint pid;\n\t\tchar *spid;\n\t\tlog_debug(\"main\", \"daemonize\");\n\t\tif (daemon(0, 0) != 0)\n\t\t\tfatal(\"main\", \"failed to detach daemon\");\n\t\tif ((pid = open(LLDPD_PID_FILE,\n\t\t\t    O_TRUNC | O_CREAT | O_WRONLY, 0666)) == -1)\n\t\t\tfatal(\"main\", \"unable to open pid file \" LLDPD_PID_FILE);\n\t\tif (asprintf(&spid, \"%d\\n\", getpid()) == -1)\n\t\t\tfatal(\"main\", \"unable to create pid file \" LLDPD_PID_FILE);\n\t\tif (write(pid, spid, strlen(spid)) == -1)\n\t\t\tfatal(\"main\", \"unable to write pid file \" LLDPD_PID_FILE);\n\t\tfree(spid);\n\t\tclose(pid);\n\t}\n#endif\n\n\t/* Try to read system information from /etc/os-release if possible.\n\t   Fall back to lsb_release for compatibility. */\n\tlog_debug(\"main\", \"get OS/LSB release information\");\n\tlsb_release = lldpd_get_os_release();\n\tif (!lsb_release) {\n\t\tlsb_release = lldpd_get_lsb_release();\n\t}\n\n\tlog_debug(\"main\", \"initialize privilege separation\");\n#ifdef ENABLE_PRIVSEP\n\tpriv_init(PRIVSEP_CHROOT, ctl, uid, gid);\n#else\n\tpriv_init(PRIVSEP_CHROOT, ctl, 0, 0);\n#endif\n\n\t/* Initialization of global configuration */\n\tif ((cfg = (struct lldpd *)\n\t    calloc(1, sizeof(struct lldpd))) == NULL)\n\t\tfatal(\"main\", NULL);\n\n\tcfg->g_ctlname = ctlname;\n\tcfg->g_ctl = ctl;\n\tcfg->g_config.c_mgmt_pattern = mgmtp;\n\tcfg->g_config.c_cid_pattern = cidp;\n\tcfg->g_config.c_iface_pattern = interfaces;\n\tcfg->g_config.c_smart = smart;\n\tif (lldpcli)\n\t\tcfg->g_config.c_paused = 1;\n\tcfg->g_config.c_receiveonly = receiveonly;\n\tcfg->g_config.c_tx_interval = LLDPD_TX_INTERVAL;\n\tcfg->g_config.c_tx_hold = LLDPD_TX_HOLD;\n\tcfg->g_config.c_max_neighbors = LLDPD_MAX_NEIGHBORS;\n#ifdef ENABLE_LLDPMED\n\tcfg->g_config.c_enable_fast_start = enable_fast_start;\n\tcfg->g_config.c_tx_fast_init = LLDPD_FAST_INIT;\n\tcfg->g_config.c_tx_fast_interval = LLDPD_FAST_TX_INTERVAL;\n#endif\n#ifdef USE_SNMP\n\tcfg->g_snmp = snmp;\n\tcfg->g_snmp_agentx = agentx;\n#endif /* USE_SNMP */\n\tcfg->g_config.c_bond_slave_src_mac_type = \\\n\t    LLDP_BOND_SLAVE_SRC_MAC_TYPE_LOCALLY_ADMINISTERED;\n\n\t/* Get ioctl socket */\n\tlog_debug(\"main\", \"get an ioctl socket\");\n\tif ((cfg->g_sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)\n\t\tfatal(\"main\", \"failed to get ioctl socket\");\n\n\t/* Description */\n\tif (!(cfg->g_config.c_advertise_version = advertise_version) &&\n\t    lsb_release && lsb_release[strlen(lsb_release) - 1] == '\\n')\n\t\tlsb_release[strlen(lsb_release) - 1] = '\\0';\n\tcfg->g_lsb_release = lsb_release;\n        if (descr_override)\n           cfg->g_config.c_description = descr_override;\n\n\tif (platform_override)\n\t\tcfg->g_config.c_platform = platform_override;\n\n\t/* Set system capabilities */\n\tlog_debug(\"main\", \"set system capabilities\");\n\tif ((lchassis = (struct lldpd_chassis*)\n\t\tcalloc(1, sizeof(struct lldpd_chassis))) == NULL)\n\t\tfatal(\"localchassis\", NULL);\n\tcfg->g_config.c_cap_advertise = 1;\n\tlchassis->c_cap_available = LLDP_CAP_BRIDGE | LLDP_CAP_WLAN |\n\t    LLDP_CAP_ROUTER | LLDP_CAP_STATION;\n\tcfg->g_config.c_mgmt_advertise = 1;\n\tTAILQ_INIT(&lchassis->c_mgmt);\n#ifdef ENABLE_LLDPMED\n\tif (lldpmed > 0) {\n\t\tif (lldpmed == LLDP_MED_CLASS_III)\n\t\t\tlchassis->c_cap_available |= LLDP_CAP_TELEPHONE;\n\t\tlchassis->c_med_type = lldpmed;\n\t\tlchassis->c_med_cap_available = LLDP_MED_CAP_CAP |\n\t\t    LLDP_MED_CAP_IV | LLDP_MED_CAP_LOCATION |\n\t\t    LLDP_MED_CAP_POLICY | LLDP_MED_CAP_MDI_PSE | LLDP_MED_CAP_MDI_PD;\n\t\tcfg->g_config.c_noinventory = noinventory;\n\t} else\n\t\tcfg->g_config.c_noinventory = 1;\n#endif\n\n\t/* Set TTL */\n\tlchassis->c_ttl = cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold;\n\n\tlog_debug(\"main\", \"initialize protocols\");\n\tcfg->g_protocols = protos;\n\tfor (i=0; protos[i].mode != 0; i++) {\n\n\t\t/* With -ll, disable LLDP */\n\t\tif (protos[i].mode == LLDPD_MODE_LLDP)\n\t\t\tprotos[i].enabled %= 3;\n\t\t/* With -ccc force CDPV2, enable CDPV1 */\n\t\tif (protos[i].mode == LLDPD_MODE_CDPV1 && protos[i].enabled == 3) {\n\t\t\tprotos[i].enabled = 1;\n\t\t}\n\t\t/* With -cc force CDPV1, enable CDPV2 */\n\t\tif (protos[i].mode == LLDPD_MODE_CDPV2 && protos[i].enabled == 2) {\n\t\t\tprotos[i].enabled = 1;\n\t\t}\n\n\t\t/* With -cccc disable CDPV1, enable CDPV2 */\n\t\tif (protos[i].mode == LLDPD_MODE_CDPV1 && protos[i].enabled >= 4) {\n\t\t\tprotos[i].enabled = 0;\n\t\t}\n\n\t\t/* With -cccc disable CDPV1, enable CDPV2; -ccccc will force CDPv2 */\n\t\tif (protos[i].mode == LLDPD_MODE_CDPV2 && protos[i].enabled == 4) {\n\t\t\tprotos[i].enabled = 1;\n\t\t}\n\n\t\tif (protos[i].enabled > 1)\n\t\t\tlog_info(\"main\", \"protocol %s enabled and forced\", protos[i].name);\n\t\telse if (protos[i].enabled)\n\t\t\tlog_info(\"main\", \"protocol %s enabled\", protos[i].name);\n\t\telse\n\t\t\tlog_info(\"main\", \"protocol %s disabled\", protos[i].name);\n\t    }\n\n\tTAILQ_INIT(&cfg->g_hardware);\n\tTAILQ_INIT(&cfg->g_chassis);\n\tTAILQ_INSERT_TAIL(&cfg->g_chassis, lchassis, c_entries);\n\tlchassis->c_refcount++; /* We should always keep a reference to local chassis */\n\n\t/* Main loop */\n\tlog_debug(\"main\", \"start main loop\");\n\tlevent_loop(cfg);\n\tlldpd_exit(cfg);\n\tfree(cfg);\n\n\treturn (0);\n}\n", "/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/* We also supports FDP which is very similar to CDPv1 */\n#include \"lldpd.h\"\n#include \"frame.h\"\n\n#if defined (ENABLE_CDP) || defined (ENABLE_FDP)\n\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <assert.h>\n\nstatic int\ncdp_send(struct lldpd *global,\n\t struct lldpd_hardware *hardware, int version)\n{\n\tconst char *platform = \"Unknown\";\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_mgmt *mgmt;\n\tstruct lldpd_port *port;\n\tu_int8_t mcastaddr[] = CDP_MULTICAST_ADDR;\n\tu_int8_t llcorg[] = LLC_ORG_CISCO;\n#ifdef ENABLE_FDP\n\tchar *capstr;\n#endif\n\tu_int16_t checksum;\n\tint length, i;\n\tu_int32_t cap;\n\tu_int8_t *packet;\n\tu_int8_t *pos, *pos_len_eh, *pos_llc, *pos_cdp, *pos_checksum, *tlv, *end;\n\n\tlog_debug(\"cdp\", \"send CDP frame on %s\", hardware->h_ifname);\n\n\tport = &(hardware->h_lport);\n\tchassis = port->p_chassis;\n\n#ifdef ENABLE_FDP\n\tif (version == 0) {\n\t\t/* With FDP, change multicast address and LLC PID */\n\t\tconst u_int8_t fdpmcastaddr[] = FDP_MULTICAST_ADDR;\n\t\tconst u_int8_t fdpllcorg[] = LLC_ORG_FOUNDRY;\n\t\tmemcpy(mcastaddr, fdpmcastaddr, sizeof(mcastaddr));\n\t\tmemcpy(llcorg, fdpllcorg, sizeof(llcorg));\n\t}\n#endif\n\n\tlength = hardware->h_mtu;\n\tif ((packet = (u_int8_t*)calloc(1, length)) == NULL)\n\t\treturn ENOMEM;\n\tpos = packet;\n\n\t/* Ethernet header */\n\tif (!(\n\t      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t      POKE_SAVE(pos_len_eh) && /* We compute the len later */\n\t      POKE_UINT16(0)))\n\t\tgoto toobig;\n\n\t/* LLC */\n\tif (!(\n\t      POKE_SAVE(pos_llc) &&\n\t      POKE_UINT8(0xaa) && /* SSAP */\n\t      POKE_UINT8(0xaa) && /* DSAP */\n\t      POKE_UINT8(0x03) && /* Control field */\n\t      POKE_BYTES(llcorg, sizeof(llcorg)) &&\n\t      POKE_UINT16(LLC_PID_CDP)))\n\t\tgoto toobig;\n\n\t/* CDP header */\n\tif (!(\n\t      POKE_SAVE(pos_cdp) &&\n\t      POKE_UINT8((version == 0)?1:version) &&\n\t      POKE_UINT8(chassis->c_ttl) &&\n\t      POKE_SAVE(pos_checksum) && /* Save checksum position */\n\t      POKE_UINT16(0)))\n\t\tgoto toobig;\n\n\t/* Chassis ID */\n\tif (!(\n\t      POKE_START_CDP_TLV(CDP_TLV_CHASSIS) &&\n\t      (chassis->c_name?\n\t\t  POKE_BYTES(chassis->c_name, strlen(chassis->c_name)):\n\t\t  POKE_BYTES(\"\", 0)) &&\n\t      POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n\t/* Adresses */\n\t/* See:\n\t *   http://www.cisco.com/univercd/cc/td/doc/product/lan/trsrb/frames.htm#xtocid12\n\t *\n\t * It seems that Cisco implies that CDP supports IPv6 using\n\t * 802.2 address format with 0xAAAA03 0x000000 0x0800, but\n\t * 0x0800 is the Ethernet protocol type for IPv4. Therefore,\n\t * we support only IPv4. */\n\ti = 0;\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries)\n\t\tif (mgmt->m_family == LLDPD_AF_IPV4) i++;\n\tif (i > 0) {\n\t\tif (!(\n\t\t      POKE_START_CDP_TLV(CDP_TLV_ADDRESSES) &&\n\t\t      POKE_UINT32(i)))\n\t\t\tgoto toobig;\n\t\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\t\tswitch (mgmt->m_family) {\n\t\t\tcase LLDPD_AF_IPV4:\n\t\t\t\tif (!(\n\t\t\t\t      POKE_UINT8(1) &&\t/* Type: NLPID */\n\t\t\t\t      POKE_UINT8(1) &&  /* Length: 1 */\n\t\t\t\t      POKE_UINT8(CDP_ADDRESS_PROTO_IP) && /* IP */\n\t\t\t\t      POKE_UINT16(sizeof(struct in_addr)) && /* Address length */\n\t\t\t\t      POKE_BYTES(&mgmt->m_addr, sizeof(struct in_addr))))\n\t\t\t\t\tgoto toobig;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!(POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Port ID */\n\tif (!(\n\t      POKE_START_CDP_TLV(CDP_TLV_PORT) &&\n\t      (hardware->h_lport.p_descr?\n\t\t  POKE_BYTES(hardware->h_lport.p_descr,\n\t\t      strlen(hardware->h_lport.p_descr)):\n\t\t  POKE_BYTES(\"\", 0)) &&\n\t      POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n\t/* Capabilities */\n\tif (version != 0) {\n\t\tcap = 0;\n\t\tif (chassis->c_cap_enabled & LLDP_CAP_ROUTER)\n\t\t\tcap |= CDP_CAP_ROUTER;\n\t\tif (chassis->c_cap_enabled & LLDP_CAP_BRIDGE)\n\t\t\tcap |= CDP_CAP_SWITCH;\n\t\tcap |= CDP_CAP_HOST;\n\t\tif (!(\n\t\t      POKE_START_CDP_TLV(CDP_TLV_CAPABILITIES) &&\n\t\t      POKE_UINT32(cap) &&\n\t\t      POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n#ifdef ENABLE_FDP\n\t} else {\n\t\t/* With FDP, it seems that a string is used in place of an int */\n\t\tif (chassis->c_cap_enabled & LLDP_CAP_ROUTER)\n\t\t\tcapstr = \"Router\";\n\t\telse if (chassis->c_cap_enabled & LLDP_CAP_BRIDGE)\n\t\t\tcapstr = \"Switch\";\n\t\telse if (chassis->c_cap_enabled & LLDP_CAP_REPEATER)\n\t\t\tcapstr = \"Bridge\";\n\t\telse\n\t\t\tcapstr = \"Host\";\n\t\tif (!(\n\t\t      POKE_START_CDP_TLV(CDP_TLV_CAPABILITIES) &&\n\t\t      POKE_BYTES(capstr, strlen(capstr)) &&\n\t\t      POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n#endif\n\t}\n\n\t/* Native VLAN */\n#ifdef ENABLE_DOT1\n\tif (version >=2 && hardware->h_lport.p_pvid != 0) {\n\t\tif (!(\n\t\t      POKE_START_CDP_TLV(CDP_TLV_NATIVEVLAN) &&\n\t\t      POKE_UINT16(hardware->h_lport.p_pvid) &&\n\t\t      POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n\t/* Software version */\n\tif (!(\n\t      POKE_START_CDP_TLV(CDP_TLV_SOFTWARE) &&\n\t      (chassis->c_descr?\n\t\t  POKE_BYTES(chassis->c_descr, strlen(chassis->c_descr)):\n\t\t  POKE_BYTES(\"\", 0)) &&\n\t      POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n\t/* Platform */\n\tif (global && global->g_config.c_platform) platform = global->g_config.c_platform;\n\n\tif (!(\n\t      POKE_START_CDP_TLV(CDP_TLV_PLATFORM) &&\n\t      POKE_BYTES(platform, strlen(platform)) &&\n\t      POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n#ifdef ENABLE_LLDPMED\n\t/* Power use */\n\tif ((version >= 2) &&\n\t    port->p_med_cap_enabled &&\n\t    (port->p_med_power.source != LLDP_MED_POW_SOURCE_LOCAL) &&\n\t    (port->p_med_power.val > 0) &&\n\t    (port->p_med_power.val <= 655)) {\n\t\tif (!(\n\t\t      POKE_START_CDP_TLV(CDP_TLV_POWER_CONSUMPTION) &&\n\t\t      POKE_UINT16(port->p_med_power.val * 100) &&\n\t\t      POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\t(void)POKE_SAVE(end);\n\n\t/* Compute len and checksum */\n\tPOKE_RESTORE(pos_len_eh);\n\tif (!(POKE_UINT16(end - pos_llc))) goto toobig;\n\tchecksum = frame_checksum(pos_cdp, end - pos_cdp, (version != 0) ? 1 : 0);\n\tPOKE_RESTORE(pos_checksum);\n\tif (!(POKE_UINT16(checksum))) goto toobig;\n\n\tif (interfaces_send_helper(global, hardware,\n\t\t(char *)packet, end - packet) == -1) {\n\t\tlog_warn(\"cdp\", \"unable to send packet on real device for %s\",\n\t\t\t   hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\thardware->h_tx_cnt++;\n\n\tfree(packet);\n\treturn 0;\n toobig:\n\tfree(packet);\n\treturn -1;\n}\n\n#define CHECK_TLV_SIZE(x, name)\t\t\t\t   \\\n\tdo { if (tlv_len < (x)) {\t\t\t   \\\n\t\tlog_warnx(\"cdp\", name \" CDP/FDP TLV too short received on %s\", \\\n\t       hardware->h_ifname);\t\t\t   \\\n\t   goto malformed;\t\t\t\t   \\\n\t} } while (0)\n/* cdp_decode also decodes FDP */\nint\ncdp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tstruct lldpd_mgmt *mgmt;\n\tstruct in_addr addr;\n#if 0\n\tu_int16_t cksum;\n#endif\n\tu_int8_t *software = NULL, *platform = NULL;\n\tint software_len = 0, platform_len = 0, proto, version, nb, caps;\n\tconst unsigned char cdpaddr[] = CDP_MULTICAST_ADDR;\n#ifdef ENABLE_FDP\n\tconst unsigned char fdpaddr[] = CDP_MULTICAST_ADDR;\n\tint fdp = 0;\n#endif\n\tu_int8_t *pos, *tlv, *pos_address, *pos_next_address;\n\tint length, len_eth, tlv_type, tlv_len, addresses_len, address_len;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan;\n#endif\n\n\tlog_debug(\"cdp\", \"decode CDP frame received on %s\",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"cdp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"cdp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t) /* Ethernet */ +\n\t    8 /* LLC */ + 4 /* CDP header */) {\n\t\tlog_warn(\"cdp\", \"too short CDP/FDP frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tif (PEEK_CMP(cdpaddr, sizeof(cdpaddr)) != 0) {\n#ifdef ENABLE_FDP\n\t\tPEEK_RESTORE((u_int8_t*)frame);\n\t\tif (PEEK_CMP(fdpaddr, sizeof(fdpaddr)) != 0)\n\t\t\tfdp = 1;\n\t\telse {\n#endif\n\t\t\tlog_info(\"cdp\", \"frame not targeted at CDP/FDP multicast address received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n#ifdef ENABLE_FDP\n\t\t}\n#endif\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\t/* Don't care of source address */\n\tlen_eth = PEEK_UINT16;\n\tif (len_eth > length) {\n\t\tlog_warnx(\"cdp\", \"incorrect 802.3 frame size reported on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(6);\t/* Skip beginning of LLC */\n\tproto = PEEK_UINT16;\n\tif (proto != LLC_PID_CDP) {\n\t\tif ((proto != LLC_PID_DRIP) &&\n\t\t    (proto != LLC_PID_PAGP) &&\n\t\t    (proto != LLC_PID_PVSTP) &&\n\t\t    (proto != LLC_PID_UDLD) &&\n\t\t    (proto != LLC_PID_VTP) &&\n\t\t    (proto != LLC_PID_DTP) &&\n\t\t    (proto != LLC_PID_STP))\n\t\t\tlog_debug(\"cdp\", \"incorrect LLC protocol ID received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n#if 0\n\t/* Check checksum */\n\tcksum = frame_checksum(pos, len_eth - 8,\n#ifdef ENABLE_FDP\n\t    !fdp\t\t/* fdp = 0 -> cisco checksum */\n#else\n\t    1\t\t\t/* cisco checksum */\n#endif\n\t\t);\n\tif (cksum != 0) {\n\t\tlog_info(\"cdp\", \"incorrect CDP/FDP checksum for frame received on %s (%d)\",\n\t\t\t  hardware->h_ifname, cksum);\n\t\tgoto malformed;\n\t}\n#endif\n\n\t/* Check version */\n\tversion = PEEK_UINT8;\n\tif ((version != 1) && (version != 2)) {\n\t\tlog_warnx(\"cdp\", \"incorrect CDP/FDP version (%d) for frame received on %s\",\n\t\t    version, hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_ttl = PEEK_UINT8; /* TTL */\n\tPEEK_DISCARD_UINT16;\t     /* Checksum, already checked */\n\n\twhile (length) {\n\t\tif (length < 4) {\n\t\t\tlog_warnx(\"cdp\", \"CDP/FDP TLV header is too large for \"\n\t\t\t    \"frame received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_type = PEEK_UINT16;\n\t\ttlv_len = PEEK_UINT16 - 4;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif ((tlv_len < 0) || (length < tlv_len)) {\n\t\t\tlog_warnx(\"cdp\", \"incorrect size in CDP/FDP TLV header for frame \"\n\t\t\t    \"received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase CDP_TLV_CHASSIS:\n\t\t\tif ((chassis->c_name = (char *)calloc(1, tlv_len + 1)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for chassis name\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(chassis->c_name, tlv_len);\n\t\t\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_LOCAL;\n\t\t\tif ((chassis->c_id =  (char *)malloc(tlv_len)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for chassis ID\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tmemcpy(chassis->c_id, chassis->c_name, tlv_len);\n\t\t\tchassis->c_id_len = tlv_len;\n\t\t\tbreak;\n\t\tcase CDP_TLV_ADDRESSES:\n\t\t\tCHECK_TLV_SIZE(4, \"Address\");\n\t\t\taddresses_len = tlv_len - 4;\n\t\t\tfor (nb = PEEK_UINT32; nb > 0; nb--) {\n\t\t\t\t(void)PEEK_SAVE(pos_address);\n\t\t\t\t/* We first try to get the real length of the packet */\n\t\t\t\tif (addresses_len < 2) {\n\t\t\t\t\tlog_warn(\"cdp\", \"too short address subframe \"\n\t\t\t\t\t\t  \"received on %s\",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD_UINT8; addresses_len--;\n\t\t\t\taddress_len = PEEK_UINT8; addresses_len--;\n\t\t\t\tif (addresses_len < address_len + 2) {\n\t\t\t\t\tlog_warn(\"cdp\", \"too short address subframe \"\n\t\t\t\t\t\t  \"received on %s\",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\taddresses_len -= address_len;\n\t\t\t\taddress_len = PEEK_UINT16; addresses_len -= 2;\n\t\t\t\tif (addresses_len < address_len) {\n\t\t\t\t\tlog_warn(\"cdp\", \"too short address subframe \"\n\t\t\t\t\t\t  \"received on %s\",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\t(void)PEEK_SAVE(pos_next_address);\n\t\t\t\t/* Next, we go back and try to extract\n\t\t\t\t   IPv4 address */\n\t\t\t\tPEEK_RESTORE(pos_address);\n\t\t\t\tif ((PEEK_UINT8 == 1) && (PEEK_UINT8 == 1) &&\n\t\t\t\t    (PEEK_UINT8 == CDP_ADDRESS_PROTO_IP) &&\n\t\t\t\t    (PEEK_UINT16 == sizeof(struct in_addr))) {\n\t\t\t\t\t\tPEEK_BYTES(&addr, sizeof(struct in_addr));\n\t\t\t\t\t\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &addr, \n\t\t\t\t\t\t\t\t\tsizeof(struct in_addr), 0);\n\t\t\t\t\t\tif (mgmt == NULL) {\n\t\t\t\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\t\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for management address\");\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\t\t}\n\t\t\t\t/* Go to the end of the address */\n\t\t\t\tPEEK_RESTORE(pos_next_address);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CDP_TLV_PORT:\n\t\t\tif (tlv_len == 0) {\n\t\t\t\tlog_warn(\"cd[\", \"too short port description received\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif ((port->p_descr = (char *)calloc(1, tlv_len + 1)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for port description\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(port->p_descr, tlv_len);\n\t\t\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;\n\t\t\tif ((port->p_id =  (char *)calloc(1, tlv_len)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for port ID\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tmemcpy(port->p_id, port->p_descr, tlv_len);\n\t\t\tport->p_id_len = tlv_len;\n\t\t\tbreak;\n\t\tcase CDP_TLV_CAPABILITIES:\n#ifdef ENABLE_FDP\n\t\t\tif (fdp) {\n\t\t\t\t/* Capabilities are string with FDP */\n\t\t\t\tif (!strncmp(\"Router\", (char*)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_ROUTER;\n\t\t\t\telse if (!strncmp(\"Switch\", (char*)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_BRIDGE;\n\t\t\t\telse if (!strncmp(\"Bridge\", (char*)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_REPEATER;\n\t\t\t\telse\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_STATION;\n\t\t\t\tchassis->c_cap_available = chassis->c_cap_enabled;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tCHECK_TLV_SIZE(4, \"Capabilities\");\n\t\t\tcaps = PEEK_UINT32;\n\t\t\tif (caps & CDP_CAP_ROUTER)\n\t\t\t\tchassis->c_cap_enabled |= LLDP_CAP_ROUTER;\n\t\t\tif (caps & 0x0e)\n\t\t\t\tchassis->c_cap_enabled |= LLDP_CAP_BRIDGE;\n\t\t\tif (chassis->c_cap_enabled == 0)\n\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_STATION;\n\t\t\tchassis->c_cap_available = chassis->c_cap_enabled;\n\t\t\tbreak;\n\t\tcase CDP_TLV_SOFTWARE:\n\t\t\tsoftware_len = tlv_len;\n\t\t\t(void)PEEK_SAVE(software);\n\t\t\tbreak;\n\t\tcase CDP_TLV_PLATFORM:\n\t\t\tplatform_len = tlv_len;\n\t\t\t(void)PEEK_SAVE(platform);\n\t\t\tbreak;\n#ifdef ENABLE_DOT1\n\t\tcase CDP_TLV_NATIVEVLAN:\n\t\t\tCHECK_TLV_SIZE(2, \"Native VLAN\");\n\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\tsizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\tlog_warn(\"cdp\", \"unable to alloc vlan \"\n\t\t\t\t\t  \"structure for \"\n\t\t\t\t\t  \"tlv received on %s\",\n\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tvlan->v_vid = port->p_pvid = PEEK_UINT16;\n\t\t\tif (asprintf(&vlan->v_name, \"VLAN #%d\", vlan->v_vid) == -1) {\n\t\t\t\tlog_warn(\"cdp\", \"unable to alloc VLAN name for \"\n\t\t\t\t\t  \"TLV received on %s\",\n\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\tfree(vlan);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t\t\t  vlan, v_entries);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tlog_debug(\"cdp\", \"unknown CDP/FDP TLV type (%d) received on %s\",\n\t\t\t    ntohs(tlv_type), hardware->h_ifname);\n\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_len - pos);\n\t}\n\tif (!software && platform) {\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t    platform_len + 1)) == NULL) {\n\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for chassis description\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, platform, platform_len);\n\t} else if (software && !platform) {\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t    software_len + 1)) == NULL) {\n\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for chassis description\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, software, software_len);\n\t} else if (software && platform) {\n#define CONCAT_PLATFORM \" running on\\n\"\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t    software_len + platform_len +\n\t\t\t    strlen(CONCAT_PLATFORM) + 1)) == NULL) {\n\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for chassis description\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, platform, platform_len);\n\t\tmemcpy(chassis->c_descr + platform_len,\n\t\t    CONCAT_PLATFORM, strlen(CONCAT_PLATFORM));\n\t\tmemcpy(chassis->c_descr + platform_len + strlen(CONCAT_PLATFORM),\n\t\t    software, software_len);\n\t}\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (chassis->c_name == NULL) ||\n\t    (chassis->c_descr == NULL) ||\n\t    (port->p_descr == NULL) ||\n\t    (chassis->c_ttl == 0) ||\n\t    (chassis->c_cap_enabled == 0)) {\n\t\tlog_warnx(\"cdp\", \"some mandatory CDP/FDP tlv are missing for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}\n\n#ifdef ENABLE_CDP\nint\ncdpv1_send(struct lldpd *global,\n    struct lldpd_hardware *hardware)\n{\n\treturn cdp_send(global, hardware, 1);\n}\n\nint\ncdpv2_send(struct lldpd *global,\n    struct lldpd_hardware *hardware)\n{\n\treturn cdp_send(global, hardware, 2);\n}\n#endif\n\n#ifdef ENABLE_FDP\nint\nfdp_send(struct lldpd *global,\n    struct lldpd_hardware *hardware)\n{\n\treturn cdp_send(global, hardware, 0);\n}\n#endif\n\n#ifdef ENABLE_CDP\nstatic int\ncdp_guess(char *pos, int length, int version)\n{\n\tconst u_int8_t mcastaddr[] = CDP_MULTICAST_ADDR;\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t) /* Ethernet */ +\n\t    8 /* LLC */ + 4 /* CDP header */)\n\t\treturn 0;\n\tif (PEEK_CMP(mcastaddr, ETHER_ADDR_LEN) != 0)\n\t\treturn 0;\n\tPEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16; /* Ethernet */\n\tPEEK_DISCARD(8);\t\t\t     /* LLC */\n\treturn (PEEK_UINT8 == version);\n}\n\nint\ncdpv1_guess(char *frame, int len)\n{\n\treturn cdp_guess(frame, len, 1);\n}\n\nint\ncdpv2_guess(char *frame, int len)\n{\n\treturn cdp_guess(frame, len, 2);\n}\n#endif\n\n#endif /* defined (ENABLE_CDP) || defined (ENABLE_FDP) */\n", "/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"lldpd.h\"\n#include \"frame.h\"\n\n#ifdef ENABLE_EDP\n\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <fnmatch.h>\n#include <assert.h>\n\nstatic int seq = 0;\n\nint\nedp_send(struct lldpd *global,\n\t struct lldpd_hardware *hardware)\n{\n\tconst u_int8_t mcastaddr[] = EDP_MULTICAST_ADDR;\n\tconst u_int8_t llcorg[] = LLC_ORG_EXTREME;\n\tstruct lldpd_chassis *chassis;\n\tint length, i, v;\n\tu_int8_t *packet, *pos, *pos_llc, *pos_len_eh, *pos_len_edp, *pos_edp, *tlv, *end;\n\tu_int16_t checksum;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan;\n\tunsigned int state = 0;\n#endif\n\tu_int8_t edp_fakeversion[] = {7, 6, 4, 99};\n\t/* Subsequent XXX can be replaced by other values. We place\n\t   them here to ensure the position of \"\" to be a bit\n\t   invariant with version changes. */\n\tchar *deviceslot[] = { \"eth\", \"veth\", \"XXX\", \"XXX\", \"XXX\", \"XXX\", \"XXX\", \"XXX\", \"\", NULL };\n\n\tlog_debug(\"edp\", \"send EDP frame on port %s\", hardware->h_ifname);\n\n\tchassis = hardware->h_lport.p_chassis;\n#ifdef ENABLE_DOT1\n\twhile (state != 2) {\n#endif\n\t\tlength = hardware->h_mtu;\n\t\tif ((packet = (u_int8_t*)calloc(1, length)) == NULL)\n\t\t\treturn ENOMEM;\n\t\tpos = packet;\n\t\tv = 0;\n\n\t\t/* Ethernet header */\n\t\tif (!(\n\t\t      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t\t      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t\t      POKE_SAVE(pos_len_eh) && /* We compute the len later */\n\t\t      POKE_UINT16(0)))\n\t\t\tgoto toobig;\n\n\t\t/* LLC */\n\t\tif (!(\n\t\t      POKE_SAVE(pos_llc) && /* We need to save our\n\t\t\t\t\t       current position to\n\t\t\t\t\t       compute ethernet len */\n\t\t      /* SSAP and DSAP */\n\t\t      POKE_UINT8(0xaa) && POKE_UINT8(0xaa) &&\n\t\t      /* Control field */\n\t\t      POKE_UINT8(0x03) &&\n\t\t      /* ORG */\n\t\t      POKE_BYTES(llcorg, sizeof(llcorg)) &&\n\t\t      POKE_UINT16(LLC_PID_EDP)))\n\t\t\tgoto toobig;\n\n\t\t/* EDP header */\n\t\tif ((chassis->c_id_len != ETHER_ADDR_LEN) ||\n\t\t    (chassis->c_id_subtype != LLDP_CHASSISID_SUBTYPE_LLADDR)) {\n\t\t\tlog_warnx(\"edp\", \"local chassis does not use MAC address as chassis ID!?\");\n\t\t\tfree(packet);\n\t\t\treturn EINVAL;\n\t\t}\n\t\tif (!(\n\t\t      POKE_SAVE(pos_edp) && /* Save the start of EDP frame */\n\t\t      POKE_UINT8(1) && POKE_UINT8(0) &&\n\t\t      POKE_SAVE(pos_len_edp) && /* We compute the len\n\t\t\t\t\t\t   and the checksum\n\t\t\t\t\t\t   later */\n\t\t      POKE_UINT32(0) && /* Len + Checksum */\n\t\t      POKE_UINT16(seq) &&\n\t\t      POKE_UINT16(0) &&\n\t\t      POKE_BYTES(chassis->c_id, ETHER_ADDR_LEN)))\n\t\t\tgoto toobig;\n\t\tseq++;\n\n#ifdef ENABLE_DOT1\n\t\tswitch (state) {\n\t\tcase 0:\n#endif\n\t\t\t/* Display TLV */\n\t\t\tif (!(\n\t\t\t      POKE_START_EDP_TLV(EDP_TLV_DISPLAY) &&\n\t\t\t      POKE_BYTES(chassis->c_name, strlen(chassis->c_name)) &&\n\t\t\t      POKE_UINT8(0) && /* Add a NULL character\n\t\t\t\t\t\t  for better\n\t\t\t\t\t\t  compatibility */\n\t\t\t      POKE_END_EDP_TLV))\n\t\t\t\tgoto toobig;\n\n\t\t\t/* Info TLV */\n\t\t\tif (!(\n\t\t\t      POKE_START_EDP_TLV(EDP_TLV_INFO)))\n\t\t\t\tgoto toobig;\n\t\t\t/* We try to emulate the slot thing */\n\t\t\tfor (i=0; deviceslot[i] != NULL; i++) {\n\t\t\t\tif (strncmp(hardware->h_ifname, deviceslot[i],\n\t\t\t\t\tstrlen(deviceslot[i])) == 0) {\n\t\t\t\t\tif (!(\n\t\t\t\t\t      POKE_UINT16(i) &&\n\t\t\t\t\t      POKE_UINT16(atoi(hardware->h_ifname +\n\t\t\t\t\t\t\t       strlen(deviceslot[i])))))\n\t\t\t\t\t\tgoto toobig;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* If we don't find a \"slot\", we say that the\n\t\t\t   interface is in slot 8 */\n\t\t\tif (deviceslot[i] == NULL) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_UINT16(8) &&\n\t\t\t\t      POKE_UINT16(hardware->h_ifindex)))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t\tif (!(\n\t\t\t      POKE_UINT16(0) && /* vchassis */\n\t\t\t      POKE_UINT32(0) && POKE_UINT16(0) && /* Reserved */\n\t\t\t      /* Version */\n\t\t\t      POKE_BYTES(edp_fakeversion, sizeof(edp_fakeversion)) &&\n\t\t\t      /* Connections, we say that we won't\n\t\t\t\t have more interfaces than this\n\t\t\t\t mask. */\n\t\t\t      POKE_UINT32(0xffffffff) &&\n\t\t\t      POKE_UINT32(0) && POKE_UINT32(0) && POKE_UINT32(0) &&\n\t\t\t      POKE_END_EDP_TLV))\n\t\t\t\tgoto toobig;\n\n#ifdef ENABLE_DOT1\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tTAILQ_FOREACH(vlan, &hardware->h_lport.p_vlans,\n\t\t\t    v_entries) {\n\t\t\t\tv++;\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_EDP_TLV(EDP_TLV_VLAN) &&\n\t\t\t\t      POKE_UINT8(0) && /* Flags: no IP address */\n\t\t\t\t      POKE_UINT8(0) && /* Reserved */\n\t\t\t\t      POKE_UINT16(vlan->v_vid) &&\n\t\t\t\t      POKE_UINT32(0) && /* Reserved */\n\t\t\t\t      POKE_UINT32(0) && /* IP address */\n\t\t\t\t      /* VLAN name */\n\t\t\t\t      POKE_BYTES(vlan->v_name, strlen(vlan->v_name)) &&\n\t\t\t\t      POKE_UINT8(0) &&\n\t\t\t\t      POKE_END_EDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((state == 1) && (v == 0)) {\n\t\t\t/* No VLAN, no need to send another TLV */\n\t\t\tfree(packet);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\t\t\n\t\t/* Null TLV */\n\t\tif (!(\n\t\t      POKE_START_EDP_TLV(EDP_TLV_NULL) &&\n\t\t      POKE_END_EDP_TLV &&\n\t\t      POKE_SAVE(end)))\n\t\t\tgoto toobig;\n\n\t\t/* Compute len and checksum */\n\t\ti = end - pos_llc; /* Ethernet length */\n\t\tv = end - pos_edp; /* EDP length */\n\t\tPOKE_RESTORE(pos_len_eh);\n\t\tif (!(POKE_UINT16(i))) goto toobig;\n\t\tPOKE_RESTORE(pos_len_edp);\n\t\tif (!(POKE_UINT16(v))) goto toobig;\n\t\tchecksum = frame_checksum(pos_edp, v, 0);\n\t\tif (!(POKE_UINT16(checksum))) goto toobig;\n\n\t\tif (interfaces_send_helper(global, hardware,\n\t\t\t(char *)packet, end - packet) == -1) {\n\t\t\tlog_warn(\"edp\", \"unable to send packet on real device for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tfree(packet);\n\t\t\treturn ENETDOWN;\n\t\t}\n\t\tfree(packet);\n\n#ifdef ENABLE_DOT1\t\t\n\t\tstate++;\n\t}\n#endif\n\n\thardware->h_tx_cnt++;\n\treturn 0;\n toobig:\n\tfree(packet);\n\treturn E2BIG;\n}\n\n#define CHECK_TLV_SIZE(x, name)\t\t\t\t   \\\n\tdo { if (tlv_len < (x)) {\t\t\t   \\\n\t\t\tlog_warnx(\"edp\", name \" EDP TLV too short received on %s\", \\\n\t       hardware->h_ifname);\t\t\t   \\\n\t   goto malformed;\t\t\t\t   \\\n\t} } while (0)\n\nint\nedp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_mgmt *mgmt, *mgmt_next, *m;\n\tstruct lldpd_vlan *lvlan = NULL, *lvlan_next;\n#endif\n\tconst unsigned char edpaddr[] = EDP_MULTICAST_ADDR;\n\tint length, gotend = 0, gotvlans = 0, edp_len, tlv_len, tlv_type;\n\tint edp_port, edp_slot;\n\tu_int8_t *pos, *pos_edp, *tlv;\n\tu_int8_t version[4];\n#ifdef ENABLE_DOT1\n\tstruct in_addr address;\n\tstruct lldpd_port *oport;\n#endif\n\n\tlog_debug(\"edp\", \"decode EDP frame on port %s\",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"edp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"edp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t) + 8 /* LLC */ +\n\t    10 + ETHER_ADDR_LEN /* EDP header */) {\n\t\tlog_warnx(\"edp\", \"too short EDP frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tif (PEEK_CMP(edpaddr, sizeof(edpaddr)) != 0) {\n\t\tlog_info(\"edp\", \"frame not targeted at EDP multicast address received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16;\n\tPEEK_DISCARD(6);\t/* LLC: DSAP + SSAP + control + org */\n\tif (PEEK_UINT16 != LLC_PID_EDP) {\n\t\tlog_debug(\"edp\", \"incorrect LLC protocol ID received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\t(void)PEEK_SAVE(pos_edp); /* Save the start of EDP packet */\n\tif (PEEK_UINT8 != 1) {\n\t\tlog_warnx(\"edp\", \"incorrect EDP version for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD_UINT8;\t/* Reserved */\n\tedp_len = PEEK_UINT16;\n\tPEEK_DISCARD_UINT16;\t/* Checksum */\n\tPEEK_DISCARD_UINT16;\t/* Sequence */\n\tif (PEEK_UINT16 != 0) {\t/* ID Type = 0 = MAC */\n\t\tlog_warnx(\"edp\", \"incorrect device id type for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (edp_len > length + 10) {\n\t\tlog_warnx(\"edp\", \"incorrect size for EDP frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_ttl = cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold;\n\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_LLADDR;\n\tchassis->c_id_len = ETHER_ADDR_LEN;\n\tif ((chassis->c_id = (char *)malloc(ETHER_ADDR_LEN)) == NULL) {\n\t\tlog_warn(\"edp\", \"unable to allocate memory for chassis ID\");\n\t\tgoto malformed;\n\t}\n\tPEEK_BYTES(chassis->c_id, ETHER_ADDR_LEN);\n\n\t/* Let's check checksum */\n\tif (frame_checksum(pos_edp, edp_len, 0) != 0) {\n\t\tlog_warnx(\"edp\", \"incorrect EDP checksum for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\twhile (length && !gotend) {\n\t\tif (length < 4) {\n\t\t\tlog_warnx(\"edp\", \"EDP TLV header is too large for \"\n\t\t\t    \"frame received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tif (PEEK_UINT8 != EDP_TLV_MARKER) {\n\t\t\tlog_warnx(\"edp\", \"incorrect marker starting EDP TLV header for frame \"\n\t\t\t    \"received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_type = PEEK_UINT8;\n\t\ttlv_len = PEEK_UINT16 - 4;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif ((tlv_len < 0) || (tlv_len > length)) {\n\t\t\tlog_debug(\"edp\", \"incorrect size in EDP TLV header for frame \"\n\t\t\t    \"received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\t/* Some poor old Extreme Summit are quite bogus */\n\t\t\tgotend = 1;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase EDP_TLV_INFO:\n\t\t\tCHECK_TLV_SIZE(32, \"Info\");\n\t\t\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;\n\t\t\tedp_slot = PEEK_UINT16; edp_port = PEEK_UINT16;\n\t\t\tif (asprintf(&port->p_id, \"%d/%d\",\n\t\t\t\tedp_slot + 1, edp_port + 1) == -1) {\n\t\t\t\tlog_warn(\"edp\", \"unable to allocate memory for \"\n\t\t\t\t    \"port ID\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tport->p_id_len = strlen(port->p_id);\n\t\t\tif (asprintf(&port->p_descr, \"Slot %d / Port %d\",\n\t\t\t\tedp_slot + 1, edp_port + 1) == -1) {\n\t\t\t\tlog_warn(\"edp\", \"unable to allocate memory for \"\n\t\t\t\t    \"port description\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_DISCARD_UINT16; /* vchassis */\n\t\t\tPEEK_DISCARD(6);     /* Reserved */\n\t\t\tPEEK_BYTES(version, 4);\n\t\t\tif (asprintf(&chassis->c_descr,\n\t\t\t\t\"EDP enabled device, version %d.%d.%d.%d\",\n\t\t\t\tversion[0], version[1],\n\t\t\t\tversion[2], version[3]) == -1) {\n\t\t\t\tlog_warn(\"edp\", \"unable to allocate memory for \"\n\t\t\t\t    \"chassis description\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EDP_TLV_DISPLAY:\n\t\t\tif ((chassis->c_name = (char *)calloc(1, tlv_len + 1)) == NULL) {\n\t\t\t\tlog_warn(\"edp\", \"unable to allocate memory for chassis \"\n\t\t\t\t    \"name\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\t/* TLV display contains a lot of garbage */\n\t\t\tPEEK_BYTES(chassis->c_name, tlv_len);\n\t\t\tbreak;\n\t\tcase EDP_TLV_NULL:\n\t\t\tif (tlv_len != 0) {\n\t\t\t\tlog_warnx(\"edp\", \"null tlv with incorrect size in frame \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif (length)\n\t\t\t\tlog_debug(\"edp\", \"extra data after edp frame on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\tgotend = 1;\n\t\t\tbreak;\n\t\tcase EDP_TLV_VLAN:\n#ifdef ENABLE_DOT1\n\t\t\tCHECK_TLV_SIZE(12, \"VLAN\");\n\t\t\tif ((lvlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\t    sizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\tlog_warn(\"edp\", \"unable to allocate vlan\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_DISCARD_UINT16; /* Flags + reserved */\n\t\t\tlvlan->v_vid = PEEK_UINT16; /* VID */\n\t\t\tPEEK_DISCARD(4);\t    /* Reserved */\n\t\t\tPEEK_BYTES(&address, sizeof(address));\n\n\t\t\tif (address.s_addr != INADDR_ANY) {\n\t\t\t\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, \n\t\t\t\t\t\t\tsizeof(struct in_addr), 0);\n\t\t\t\tif (mgmt == NULL) {\n\t\t\t\t\tlog_warn(\"edp\", \"Out of memory\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\t}\n\n\t\t\tif ((lvlan->v_name = (char *)calloc(1,\n\t\t\t\t    tlv_len + 1 - 12)) == NULL) {\n\t\t\t\tlog_warn(\"edp\", \"unable to allocate vlan name\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(lvlan->v_name, tlv_len - 12);\n\n\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t    lvlan, v_entries);\n\t\t\tlvlan = NULL;\n#endif\n\t\t\tgotvlans = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"edp\", \"unknown EDP TLV type (%d) received on %s\",\n\t\t\t    tlv_type, hardware->h_ifname);\n\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_len - pos);\n\t}\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (chassis->c_name == NULL) ||\n\t    (chassis->c_descr == NULL) ||\n\t    (port->p_descr == NULL) ||\n\t    (gotend == 0)) {\n#ifdef ENABLE_DOT1\n\t\tif (gotvlans && gotend) {\n\t\t\t/* VLAN can be sent in a separate frames. We need to add\n\t\t\t * those vlans to an existing port */\n\t\t\tTAILQ_FOREACH(oport, &hardware->h_rports, p_entries) {\n\t\t\t\tif (!((oport->p_protocol == LLDPD_MODE_EDP) &&\n\t\t\t\t\t(oport->p_chassis->c_id_subtype ==\n\t\t\t\t\t    chassis->c_id_subtype) &&\n\t\t\t\t\t(oport->p_chassis->c_id_len == chassis->c_id_len) &&\n\t\t\t\t\t(memcmp(oport->p_chassis->c_id, chassis->c_id,\n\t\t\t\t\t    chassis->c_id_len) == 0)))\n\t\t\t\t\tcontinue;\n\t\t\t\t/* We attach the VLANs to the found port */\n\t\t\t\tlldpd_vlan_cleanup(oport);\n\t\t\t\tfor (lvlan = TAILQ_FIRST(&port->p_vlans);\n\t\t\t\t     lvlan != NULL;\n\t\t\t\t     lvlan = lvlan_next) {\n\t\t\t\t\tlvlan_next = TAILQ_NEXT(lvlan, v_entries);\n\t\t\t\t\tTAILQ_REMOVE(&port->p_vlans, lvlan, v_entries);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&oport->p_vlans,\n\t\t\t\t\t    lvlan, v_entries);\n\t\t\t\t}\n\t\t\t\t/* And the IP addresses */\n\t\t\t\tfor (mgmt = TAILQ_FIRST(&chassis->c_mgmt);\n\t\t\t\t     mgmt != NULL;\n\t\t\t\t     mgmt = mgmt_next) {\n\t\t\t\t\tmgmt_next = TAILQ_NEXT(mgmt, m_entries);\n\t\t\t\t\tTAILQ_REMOVE(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\t\t\t/* Don't add an address that already exists! */\n\t\t\t\t\tTAILQ_FOREACH(m, &chassis->c_mgmt, m_entries)\n\t\t\t\t\t    if (m->m_family == mgmt->m_family &&\n\t\t\t\t\t\t!memcmp(&m->m_addr, &mgmt->m_addr,\n\t\t\t\t\t\t    sizeof(m->m_addr))) break;\n\t\t\t\t\tif (m == NULL)\n\t\t\t\t\t\tTAILQ_INSERT_TAIL(&oport->p_chassis->c_mgmt,\n\t\t\t\t\t\t    mgmt, m_entries);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* We discard the remaining frame */\n\t\t\tgoto malformed;\n\t\t}\n#else\n\t\tif (gotvlans)\n\t\t\tgoto malformed;\n#endif\n\t\tlog_warnx(\"edp\", \"some mandatory tlv are missing for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n#ifdef ENABLE_DOT1\n\tfree(lvlan);\n#endif\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}\n\n#endif /* ENABLE_EDP */\n", "/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"lldpd.h\"\n#include \"frame.h\"\n\n#include <unistd.h>\n#include <errno.h>\n#include <assert.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n\ninline static int\nlldpd_af_to_lldp_proto(int af)\n{\n\tswitch (af) {\n\tcase LLDPD_AF_IPV4:\n\t\treturn LLDP_MGMT_ADDR_IP4;\n\tcase LLDPD_AF_IPV6:\n\t\treturn LLDP_MGMT_ADDR_IP6;\n\tdefault:\n\t\treturn LLDP_MGMT_ADDR_NONE;\n\t}\n}\n\ninline static int\nlldpd_af_from_lldp_proto(int proto)\n{\n\tswitch (proto) {\n\tcase LLDP_MGMT_ADDR_IP4:\n\t\treturn LLDPD_AF_IPV4;\n\tcase LLDP_MGMT_ADDR_IP6:\n\t\treturn LLDPD_AF_IPV6;\n\tdefault:\n\t\treturn LLDPD_AF_UNSPEC;\n\t}\n}\n\nstatic int _lldp_send(struct lldpd *global,\n    struct lldpd_hardware *hardware,\n    u_int8_t c_id_subtype,\n    char *c_id,\n    int c_id_len,\n    u_int8_t p_id_subtype,\n    char *p_id,\n    int p_id_len,\n    int shutdown)\n{\n\tstruct lldpd_port *port;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_frame *frame;\n\tint length;\n\tu_int8_t *packet, *pos, *tlv;\n\tstruct lldpd_mgmt *mgmt;\n\tint proto;\n\n\tu_int8_t mcastaddr[] = LLDP_MULTICAST_ADDR;\n#ifdef ENABLE_DOT1\n\tconst u_int8_t dot1[] = LLDP_TLV_ORG_DOT1;\n\tstruct lldpd_vlan *vlan;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi;\n#endif\n#ifdef ENABLE_DOT3\n\tconst u_int8_t dot3[] = LLDP_TLV_ORG_DOT3;\n#endif\n#ifdef ENABLE_LLDPMED\n\tint i;\n\tconst u_int8_t med[] = LLDP_TLV_ORG_MED;\n#endif\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom;\n#endif\n\tport = &hardware->h_lport;\n\tchassis = port->p_chassis;\n\tlength = hardware->h_mtu;\n\tif ((packet = (u_int8_t*)calloc(1, length)) == NULL)\n\t\treturn ENOMEM;\n\tpos = packet;\n\n\t/* Ethernet header */\n\tif (!(\n\t      /* LLDP multicast address */\n\t      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t      /* Source MAC address */\n\t      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t      /* LLDP frame */\n\t      POKE_UINT16(ETHERTYPE_LLDP)))\n\t\tgoto toobig;\n\n\t/* Chassis ID */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_CHASSIS_ID) &&\n\t      POKE_UINT8(c_id_subtype) &&\n\t      POKE_BYTES(c_id, c_id_len) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* Port ID */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_PORT_ID) &&\n\t      POKE_UINT8(p_id_subtype) &&\n\t      POKE_BYTES(p_id, p_id_len) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* Time to live */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_TTL) &&\n\t      POKE_UINT16(shutdown?0:chassis->c_ttl) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\tif (shutdown)\n\t\tgoto end;\n\n\t/* System name */\n\tif (chassis->c_name && *chassis->c_name != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_NAME) &&\n\t\t\t    POKE_BYTES(chassis->c_name, strlen(chassis->c_name)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* System description (skip it if empty) */\n\tif (chassis->c_descr && *chassis->c_descr != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_DESCR) &&\n\t\t\t    POKE_BYTES(chassis->c_descr, strlen(chassis->c_descr)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* System capabilities */\n\tif (global->g_config.c_cap_advertise && chassis->c_cap_available) {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_CAP) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_available) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_enabled) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Management addresses */\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\tproto = lldpd_af_to_lldp_proto(mgmt->m_family);\n\t\tassert(proto != LLDP_MGMT_ADDR_NONE);\n\t\tif (!(\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_MGMT_ADDR) &&\n\t\t\t  /* Size of the address, including its type */\n\t\t\t  POKE_UINT8(mgmt->m_addrsize + 1) &&\n\t\t\t  POKE_UINT8(proto) &&\n\t\t\t  POKE_BYTES(&mgmt->m_addr, mgmt->m_addrsize)))\n\t\t\tgoto toobig;\n\n\t\t/* Interface port type, OID */\n\t\tif (mgmt->m_iface == 0) {\n\t\t\tif (!(\n\t\t\t\t  /* We don't know the management interface */\n\t\t\t\t  POKE_UINT8(LLDP_MGMT_IFACE_UNKNOWN) &&\n\t\t\t\t  POKE_UINT32(0)))\n\t\t\t\tgoto toobig;\n\t\t} else {\n\t\t\tif (!(\n\t\t\t\t  /* We have the index of the management interface */\n\t\t\t\t  POKE_UINT8(LLDP_MGMT_IFACE_IFINDEX) &&\n\t\t\t\t  POKE_UINT32(mgmt->m_iface)))\n\t\t\t\tgoto toobig;\n\t\t}\n\t\tif (!(\n\t\t\t  /* We don't provide an OID for management */\n\t\t\t  POKE_UINT8(0) &&\n\t\t\t  POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Port description */\n\tif (port->p_descr && *port->p_descr != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_PORT_DESCR) &&\n\t\t\t    POKE_BYTES(port->p_descr, strlen(port->p_descr)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n#ifdef ENABLE_DOT1\n\t/* Port VLAN ID */\n\tif(port->p_pvid != 0) {\n\t\tif (!(\n\t\t    POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t    POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t    POKE_UINT8(LLDP_TLV_DOT1_PVID) &&\n\t\t    POKE_UINT16(port->p_pvid) &&\n\t\t    POKE_END_LLDP_TLV)) {\n\t\t    goto toobig;\n\t\t}\n\t}\n\t/* Port and Protocol VLAN IDs */\n\tTAILQ_FOREACH(ppvid, &port->p_ppvids, p_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_PPVID) &&\n\t\t      POKE_UINT8(ppvid->p_cap_status) &&\n\t\t      POKE_UINT16(ppvid->p_ppvid) &&\n\t\t      POKE_END_LLDP_TLV)) {\n\t\t\tgoto toobig;\n\t\t}\n\t}\n\t/* VLANs */\n\tTAILQ_FOREACH(vlan, &port->p_vlans, v_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_VLANNAME) &&\n\t\t      POKE_UINT16(vlan->v_vid) &&\n\t\t      POKE_UINT8(strlen(vlan->v_name)) &&\n\t\t      POKE_BYTES(vlan->v_name, strlen(vlan->v_name)) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\t/* Protocol Identities */\n\tTAILQ_FOREACH(pi, &port->p_pids, p_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_PI) &&\n\t\t      POKE_UINT8(pi->p_pi_len) &&\n\t\t      POKE_BYTES(pi->p_pi, pi->p_pi_len) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n#ifdef ENABLE_DOT3\n\t/* Aggregation status */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t      POKE_UINT8(LLDP_TLV_DOT3_LA) &&\n\t      /* Bit 0 = capability ; Bit 1 = status */\n\t      POKE_UINT8((port->p_aggregid) ? 3:1) &&\n\t      POKE_UINT32(port->p_aggregid) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* MAC/PHY */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t      POKE_UINT8(LLDP_TLV_DOT3_MAC) &&\n\t      POKE_UINT8(port->p_macphy.autoneg_support |\n\t\t\t (port->p_macphy.autoneg_enabled << 1)) &&\n\t      POKE_UINT16(port->p_macphy.autoneg_advertised) &&\n\t      POKE_UINT16(port->p_macphy.mau_type) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* MFS */\n\tif (port->p_mfs) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT3_MFS) &&\n\t\t      POKE_UINT16(port->p_mfs) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\t/* Power */\n\tif (port->p_power.devicetype) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT3_POWER) &&\n\t\t      POKE_UINT8((\n\t\t\t\t  (((2 - port->p_power.devicetype)    %(1<< 1))<<0) |\n\t\t\t\t  (( port->p_power.supported          %(1<< 1))<<1) |\n\t\t\t\t  (( port->p_power.enabled            %(1<< 1))<<2) |\n\t\t\t\t  (( port->p_power.paircontrol        %(1<< 1))<<3))) &&\n\t\t      POKE_UINT8(port->p_power.pairs) &&\n\t\t      POKE_UINT8(port->p_power.class)))\n\t\t\tgoto toobig;\n\t\t/* 802.3at */\n\t\tif (port->p_power.powertype != LLDP_DOT3_POWER_8023AT_OFF) {\n\t\t\tif (!(\n\t\t\t      POKE_UINT8((\n\t\t\t\t\t  (((port->p_power.powertype ==\n\t\t\t\t\t      LLDP_DOT3_POWER_8023AT_TYPE1)?1:0) << 7) |\n\t\t\t\t\t   (((port->p_power.devicetype ==\n\t\t\t\t\t      LLDP_DOT3_POWER_PSE)?0:1) << 6) |\n\t\t\t\t\t   ((port->p_power.source   %(1<< 2))<<4) |\n\t\t\t\t\t   ((port->p_power.priority %(1<< 2))<<0))) &&\n\t\t\t      POKE_UINT16(port->p_power.requested) &&\n\t\t\t      POKE_UINT16(port->p_power.allocated)))\n\t\t\t\tgoto toobig;\n\t\t}\n\t\tif (!(POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n#ifdef ENABLE_LLDPMED\n\tif (port->p_med_cap_enabled) {\n\t\t/* LLDP-MED cap */\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t      POKE_UINT8(LLDP_TLV_MED_CAP) &&\n\t\t      POKE_UINT16(chassis->c_med_cap_available) &&\n\t\t      POKE_UINT8(chassis->c_med_type) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\n\t\t/* LLDP-MED inventory */\n#define LLDP_INVENTORY(value, subtype)\t\t\t\t\t\\\n\t\tif (value) {\t\t\t\t\t\t\\\n\t\t    if (!(\t\t\t\t\t\t\\\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\t\t\\\n\t\t\t  POKE_BYTES(med, sizeof(med)) &&\t\t\\\n\t\t\t  POKE_UINT8(subtype) &&\t\t\t\\\n\t\t\t  POKE_BYTES(value,\t\t\t\t\\\n\t\t\t\t(strlen(value)>32)?32:strlen(value)) &&\t\\\n\t\t\t  POKE_END_LLDP_TLV))\t\t\t\t\\\n\t\t\t    goto toobig;\t\t\t\t\\\n\t\t}\n\n\t\tif (port->p_med_cap_enabled & LLDP_MED_CAP_IV) {\n\t\t\tLLDP_INVENTORY(chassis->c_med_hw,\n\t\t\t    LLDP_TLV_MED_IV_HW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_fw,\n\t\t\t    LLDP_TLV_MED_IV_FW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_sw,\n\t\t\t    LLDP_TLV_MED_IV_SW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_sn,\n\t\t\t    LLDP_TLV_MED_IV_SN);\n\t\t\tLLDP_INVENTORY(chassis->c_med_manuf,\n\t\t\t    LLDP_TLV_MED_IV_MANUF);\n\t\t\tLLDP_INVENTORY(chassis->c_med_model,\n\t\t\t    LLDP_TLV_MED_IV_MODEL);\n\t\t\tLLDP_INVENTORY(chassis->c_med_asset,\n\t\t\t    LLDP_TLV_MED_IV_ASSET);\n\t\t}\n\n\t\t/* LLDP-MED location */\n\t\tfor (i = 0; i < LLDP_MED_LOCFORMAT_LAST; i++) {\n\t\t\tif (port->p_med_location[i].format == i + 1) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t\t      POKE_UINT8(LLDP_TLV_MED_LOCATION) &&\n\t\t\t\t      POKE_UINT8(port->p_med_location[i].format) &&\n\t\t\t\t      POKE_BYTES(port->p_med_location[i].data,\n\t\t\t\t\t  port->p_med_location[i].data_len) &&\n\t\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t}\n\n\t\t/* LLDP-MED network policy */\n\t\tfor (i = 0; i < LLDP_MED_APPTYPE_LAST; i++) {\n\t\t\tif (port->p_med_policy[i].type == i + 1) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t\t      POKE_UINT8(LLDP_TLV_MED_POLICY) &&\n\t\t\t\t      POKE_UINT32((\n\t\t\t\t\t((port->p_med_policy[i].type     %(1<< 8))<<24) |\n\t\t\t\t\t((port->p_med_policy[i].unknown  %(1<< 1))<<23) |\n\t\t\t\t\t((port->p_med_policy[i].tagged   %(1<< 1))<<22) |\n\t\t\t\t      /*((0                              %(1<< 1))<<21) |*/\n\t\t\t\t\t((port->p_med_policy[i].vid      %(1<<12))<< 9) |\n\t\t\t\t\t((port->p_med_policy[i].priority %(1<< 3))<< 6) |\n\t\t\t\t\t((port->p_med_policy[i].dscp     %(1<< 6))<< 0) )) &&\n\t\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t}\n\n\t\t/* LLDP-MED POE-MDI */\n\t\tif ((port->p_med_power.devicetype == LLDP_MED_POW_TYPE_PSE) ||\n\t\t    (port->p_med_power.devicetype == LLDP_MED_POW_TYPE_PD)) {\n\t\t\tint devicetype = 0, source = 0;\n\t\t\tif (!(\n\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t      POKE_UINT8(LLDP_TLV_MED_MDI)))\n\t\t\t\tgoto toobig;\n\t\t\tswitch (port->p_med_power.devicetype) {\n\t\t\tcase LLDP_MED_POW_TYPE_PSE:\n\t\t\t\tdevicetype = 0;\n\t\t\t\tswitch (port->p_med_power.source) {\n\t\t\t\tcase LLDP_MED_POW_SOURCE_PRIMARY: source = 1; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_BACKUP: source = 2; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_RESERVED: source = 3; break;\n\t\t\t\tdefault: source = 0; break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LLDP_MED_POW_TYPE_PD:\n\t\t\t\tdevicetype = 1;\n\t\t\t\tswitch (port->p_med_power.source) {\n\t\t\t\tcase LLDP_MED_POW_SOURCE_PSE: source = 1; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_LOCAL: source = 2; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_BOTH: source = 3; break;\n\t\t\t\tdefault: source = 0; break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(\n\t\t\t      POKE_UINT8((\n\t\t\t\t((devicetype                   %(1<< 2))<<6) |\n\t\t\t\t((source                       %(1<< 2))<<4) |\n\t\t\t\t((port->p_med_power.priority   %(1<< 4))<<0) )) &&\n\t\t\t      POKE_UINT16(port->p_med_power.val) &&\n\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\tgoto toobig;\n\t\t}\n\t}\n#endif\n\n#ifdef ENABLE_CUSTOM\n\tTAILQ_FOREACH(custom, &port->p_custom_list, next) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(custom->oui, sizeof(custom->oui)) &&\n\t\t      POKE_UINT8(custom->subtype) &&\n\t\t      POKE_BYTES(custom->oui_info, custom->oui_info_len) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\nend:\n\t/* END */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_END) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\tif (interfaces_send_helper(global, hardware,\n\t\t(char *)packet, pos - packet) == -1) {\n\t\tlog_warn(\"lldp\", \"unable to send packet on real device for %s\",\n\t\t    hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\thardware->h_tx_cnt++;\n\n\t/* We assume that LLDP frame is the reference */\n\tif (!shutdown && (frame = (struct lldpd_frame*)malloc(\n\t\t\tsizeof(int) + pos - packet)) != NULL) {\n\t\tframe->size = pos - packet;\n\t\tmemcpy(&frame->frame, packet, frame->size);\n\t\tif ((hardware->h_lport.p_lastframe == NULL) ||\n\t\t    (hardware->h_lport.p_lastframe->size != frame->size) ||\n\t\t    (memcmp(hardware->h_lport.p_lastframe->frame, frame->frame,\n\t\t\tframe->size) != 0)) {\n\t\t\tfree(hardware->h_lport.p_lastframe);\n\t\t\thardware->h_lport.p_lastframe = frame;\n\t\t\thardware->h_lport.p_lastchange = time(NULL);\n\t\t} else free(frame);\n\t}\n\n\tfree(packet);\n\treturn 0;\n\ntoobig:\n\tfree(packet);\n\treturn E2BIG;\n}\n\n/* Send a shutdown LLDPDU. */\nint\nlldp_send_shutdown(struct lldpd *global,\n    struct lldpd_hardware *hardware)\n{\n\tif (hardware->h_lchassis_previous_id == NULL ||\n\t    hardware->h_lport_previous_id == NULL)\n\t\treturn 0;\n\treturn _lldp_send(global, hardware,\n\t    hardware->h_lchassis_previous_id_subtype,\n\t    hardware->h_lchassis_previous_id,\n\t    hardware->h_lchassis_previous_id_len,\n\t    hardware->h_lport_previous_id_subtype,\n\t    hardware->h_lport_previous_id,\n\t    hardware->h_lport_previous_id_len,\n\t    1);\n}\n\nint\nlldp_send(struct lldpd *global,\n\t  struct lldpd_hardware *hardware)\n{\n\tstruct lldpd_port *port = &hardware->h_lport;\n\tstruct lldpd_chassis *chassis = port->p_chassis;\n\tint ret;\n\n\t/* Check if we have a change. */\n\tif (hardware->h_lchassis_previous_id != NULL &&\n\t    hardware->h_lport_previous_id != NULL &&\n\t    (hardware->h_lchassis_previous_id_subtype != chassis->c_id_subtype ||\n\t\thardware->h_lchassis_previous_id_len != chassis->c_id_len ||\n\t\thardware->h_lport_previous_id_subtype != port->p_id_subtype ||\n\t\thardware->h_lport_previous_id_len != port->p_id_len ||\n\t\tmemcmp(hardware->h_lchassis_previous_id,\n\t\t    chassis->c_id, chassis->c_id_len) ||\n\t\tmemcmp(hardware->h_lport_previous_id,\n\t\t    port->p_id, port->p_id_len))) {\n\t\tlog_info(\"lldp\", \"MSAP has changed for port %s, sending a shutdown LLDPDU\",\n\t\t    hardware->h_ifname);\n\t\tif ((ret = lldp_send_shutdown(global, hardware)) != 0)\n\t\t\treturn ret;\n\t}\n\n\tlog_debug(\"lldp\", \"send LLDP PDU to %s\",\n\t    hardware->h_ifname);\n\n\tif ((ret = _lldp_send(global, hardware,\n\t\t    chassis->c_id_subtype,\n\t\t    chassis->c_id,\n\t\t    chassis->c_id_len,\n\t\t    port->p_id_subtype,\n\t\t    port->p_id,\n\t\t    port->p_id_len,\n\t\t    0)) != 0)\n\t\treturn ret;\n\n\t/* Record current chassis and port ID */\n\tfree(hardware->h_lchassis_previous_id);\n\thardware->h_lchassis_previous_id_subtype = chassis->c_id_subtype;\n\thardware->h_lchassis_previous_id_len = chassis->c_id_len;\n\tif ((hardware->h_lchassis_previous_id = malloc(chassis->c_id_len)) != NULL)\n\t\tmemcpy(hardware->h_lchassis_previous_id, chassis->c_id,\n\t\t    chassis->c_id_len);\n\tfree(hardware->h_lport_previous_id);\n\thardware->h_lport_previous_id_subtype = port->p_id_subtype;\n\thardware->h_lport_previous_id_len = port->p_id_len;\n\tif ((hardware->h_lport_previous_id = malloc(port->p_id_len)) != NULL)\n\t\tmemcpy(hardware->h_lport_previous_id, port->p_id,\n\t\t    port->p_id_len);\n\n\treturn 0;\n}\n\n#define CHECK_TLV_SIZE(x, name)\t\t\t\t   \\\n\tdo { if (tlv_size < (x)) {\t\t\t   \\\n\t\t\tlog_warnx(\"lldp\", name \" TLV too short received on %s\",\t\\\n\t       hardware->h_ifname);\t\t\t   \\\n\t   goto malformed;\t\t\t\t   \\\n\t} } while (0)\n\nint\nlldp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tconst char lldpaddr[] = LLDP_MULTICAST_ADDR;\n\tconst char dot1[] = LLDP_TLV_ORG_DOT1;\n\tconst char dot3[] = LLDP_TLV_ORG_DOT3;\n\tconst char med[] = LLDP_TLV_ORG_MED;\n\tconst char dcbx[] = LLDP_TLV_ORG_DCBX;\n\tunsigned char orgid[3];\n\tint length, gotend = 0, ttl_received = 0;\n\tint tlv_size, tlv_type, tlv_subtype;\n\tu_int8_t *pos, *tlv;\n\tchar *b;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan = NULL;\n\tint vlan_len;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi = NULL;\n#endif\n\tstruct lldpd_mgmt *mgmt;\n\tint af;\n\tu_int8_t addr_str_length, addr_str_buffer[32];\n\tu_int8_t addr_family, addr_length, *addr_ptr, iface_subtype;\n\tu_int32_t iface_number, iface;\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom = NULL;\n#endif\n\n\tlog_debug(\"lldp\", \"receive LLDP PDU on %s\",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"lldp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"lldp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n\tTAILQ_INIT(&port->p_ppvids);\n\tTAILQ_INIT(&port->p_pids);\n#endif\n#ifdef ENABLE_CUSTOM\n\tTAILQ_INIT(&port->p_custom_list);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\"lldp\", \"too short frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(lldpaddr, ETHER_ADDR_LEN) != 0) {\n\t\tlog_info(\"lldp\", \"frame not targeted at LLDP multicast address received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\t/* Skip source address */\n\tif (PEEK_UINT16 != ETHERTYPE_LLDP) {\n\t\tlog_info(\"lldp\", \"non LLDP frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\twhile (length && (!gotend)) {\n\t\tif (length < 2) {\n\t\t\tlog_warnx(\"lldp\", \"tlv header too short received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_size = PEEK_UINT16;\n\t\ttlv_type = tlv_size >> 9;\n\t\ttlv_size = tlv_size & 0x1ff;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif (length < tlv_size) {\n\t\t\tlog_warnx(\"lldp\", \"frame too short for tlv received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase LLDP_TLV_END:\n\t\t\tif (tlv_size != 0) {\n\t\t\t\tlog_warnx(\"lldp\", \"lldp end received with size not null on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif (length)\n\t\t\t\tlog_debug(\"lldp\", \"extra data after lldp end on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\tgotend = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_CHASSIS_ID:\n\t\tcase LLDP_TLV_PORT_ID:\n\t\t\tCHECK_TLV_SIZE(2, \"Port Id\");\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif ((tlv_subtype == 0) || (tlv_subtype > 7)) {\n\t\t\t\tlog_warnx(\"lldp\", \"unknown subtype for tlv id received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size - 1)) == NULL) {\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory for id tlv \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size - 1);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_ID) {\n\t\t\t\tport->p_id_subtype = tlv_subtype;\n\t\t\t\tport->p_id = b;\n\t\t\t\tport->p_id_len = tlv_size - 1;\n\t\t\t} else {\n\t\t\t\tchassis->c_id_subtype = tlv_subtype;\n\t\t\t\tchassis->c_id = b;\n\t\t\t\tchassis->c_id_len = tlv_size - 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LLDP_TLV_TTL:\n\t\t\tCHECK_TLV_SIZE(2, \"TTL\");\n\t\t\tchassis->c_ttl = PEEK_UINT16;\n\t\t\tttl_received = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_PORT_DESCR:\n\t\tcase LLDP_TLV_SYSTEM_NAME:\n\t\tcase LLDP_TLV_SYSTEM_DESCR:\n\t\t\tif (tlv_size < 1) {\n\t\t\t\tlog_debug(\"lldp\", \"empty tlv received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size + 1)) == NULL) {\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory for string tlv \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_DESCR)\n\t\t\t\tport->p_descr = b;\n\t\t\telse if (tlv_type == LLDP_TLV_SYSTEM_NAME)\n\t\t\t\tchassis->c_name = b;\n\t\t\telse chassis->c_descr = b;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_SYSTEM_CAP:\n\t\t\tCHECK_TLV_SIZE(4, \"System capabilities\");\n\t\t\tchassis->c_cap_available = PEEK_UINT16;\n\t\t\tchassis->c_cap_enabled = PEEK_UINT16;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \"Management address\");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tif (addr_str_length > sizeof(addr_str_buffer)) {\n\t\t\t\tlog_warnx(\"lldp\", \"too large management address on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \"Management address\");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\telse\n\t\t\t\tiface = 0;\n\t\t\tmgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);\n\t\t\tif (mgmt == NULL) {\n\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t\t\"for management address\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;\n\t\tcase LLDP_TLV_ORG:\n\t\t\tCHECK_TLV_SIZE(1 + (int)sizeof(orgid), \"Organisational\");\n\t\t\tPEEK_BYTES(orgid, sizeof(orgid));\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif (memcmp(dot1, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT1\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot1 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT1_VLANNAME:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"VLAN\");\n\t\t\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc vlan \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tvlan->v_vid = PEEK_UINT16;\n\t\t\t\t\tvlan_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(7 + vlan_len, \"VLAN\");\n\t\t\t\t\tif ((vlan->v_name =\n\t\t\t\t\t\t(char *)calloc(1, vlan_len + 1)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc vlan name for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(vlan->v_name, vlan_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t\t\t    vlan, v_entries);\n\t\t\t\t\tvlan = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PVID:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \"PVID\");\n\t\t\t\t\tport->p_pvid = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PPVID:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"PPVID\");\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PPVID has to be unique if more than\n\t\t\t\t\t   one PPVID TLVs are received  - \n\t\t\t\t\t   discard if duplicate */\n\t\t\t\t\t/* if support bit is not set and \n\t\t\t\t\t   enabled bit is set - PPVID TLV is\n\t\t\t\t\t   considered error  and discarded */\n\t\t\t\t\t/* if PPVID > 4096 - bad and discard */\n\t\t\t\t\tif ((ppvid = (struct lldpd_ppvid *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_ppvid))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc ppvid \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tppvid->p_cap_status = PEEK_UINT8;\n\t\t\t\t\tppvid->p_ppvid = PEEK_UINT16;\t\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_ppvids,\n\t\t\t\t\t    ppvid, p_entries);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PI:\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PI has to be unique if more than \n\t\t\t\t\t   one PI TLVs are received  - discard\n\t\t\t\t\t   if duplicate ?? */\n\t\t\t\t\tCHECK_TLV_SIZE(5, \"PI\");\n\t\t\t\t\tif ((pi = (struct lldpd_pi *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_pi))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc PI \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tpi->p_pi_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(5 + pi->p_pi_len, \"PI\");\n\t\t\t\t\tif ((pi->p_pi =\n\t\t\t\t\t\t(char *)calloc(1, pi->p_pi_len)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc pid name for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(pi->p_pi, pi->p_pi_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_pids,\n\t\t\t\t\t    pi, p_entries);\n\t\t\t\t\tpi = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot1 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(dot3, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT3\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot3 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT3_MAC:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \"MAC/PHY\");\n\t\t\t\t\tport->p_macphy.autoneg_support = PEEK_UINT8;\n\t\t\t\t\tport->p_macphy.autoneg_enabled =\n\t\t\t\t\t    (port->p_macphy.autoneg_support & 0x2) >> 1;\n\t\t\t\t\tport->p_macphy.autoneg_support =\n\t\t\t\t\t    port->p_macphy.autoneg_support & 0x1;\n\t\t\t\t\tport->p_macphy.autoneg_advertised =\n\t\t\t\t\t    PEEK_UINT16;\n\t\t\t\t\tport->p_macphy.mau_type = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_LA:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \"Link aggregation\");\n\t\t\t\t\tPEEK_DISCARD_UINT8;\n\t\t\t\t\tport->p_aggregid = PEEK_UINT32;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_MFS:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \"MFS\");\n\t\t\t\t\tport->p_mfs = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_POWER:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"Power\");\n\t\t\t\t\tport->p_power.devicetype = PEEK_UINT8;\n\t\t\t\t\tport->p_power.supported =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x2) >> 1;\n\t\t\t\t\tport->p_power.enabled =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x4) >> 2;\n\t\t\t\t\tport->p_power.paircontrol =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x8) >> 3;\n\t\t\t\t\tport->p_power.devicetype =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x1)?\n\t\t\t\t\t\tLLDP_DOT3_POWER_PSE:LLDP_DOT3_POWER_PD;\n\t\t\t\t\tport->p_power.pairs = PEEK_UINT8;\n\t\t\t\t\tport->p_power.class = PEEK_UINT8;\n\t\t\t\t\t/* 802.3at? */\n\t\t\t\t\tif (tlv_size >= 12) {\n\t\t\t\t\t\tport->p_power.powertype = PEEK_UINT8;\n\t\t\t\t\t\tport->p_power.source =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<5 | 1<<4)) >> 4;\n\t\t\t\t\t\tport->p_power.priority =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<1 | 1<<0));\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<7))?\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE1:\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE2;\n\t\t\t\t\t\tport->p_power.requested = PEEK_UINT16;\n\t\t\t\t\t\tport->p_power.allocated = PEEK_UINT16;\n\t\t\t\t\t} else\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_OFF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot3 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(med, orgid, sizeof(orgid)) == 0) {\n\t\t\t\t/* LLDP-MED */\n#ifndef ENABLE_LLDPMED\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\tu_int32_t policy;\n\t\t\t\tunsigned loctype;\n\t\t\t\tunsigned power;\n\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_MED_CAP:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"LLDP-MED capabilities\");\n\t\t\t\t\tchassis->c_med_cap_available = PEEK_UINT16;\n\t\t\t\t\tchassis->c_med_type = PEEK_UINT8;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_CAP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_POLICY:\n\t\t\t\t\tCHECK_TLV_SIZE(8, \"LLDP-MED policy\");\n\t\t\t\t\tpolicy = PEEK_UINT32;\n\t\t\t\t\tif (((policy >> 24) < 1) ||\n\t\t\t\t\t    ((policy >> 24) > LLDP_MED_APPTYPE_LAST)) {\n\t\t\t\t\t\tlog_info(\"lldp\", \"unknown policy field %d \"\n\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t    policy,\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].type =\n\t\t\t\t\t    (policy >> 24);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].unknown =\n\t\t\t\t\t    ((policy & 0x800000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].tagged =\n\t\t\t\t\t    ((policy & 0x400000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].vid =\n\t\t\t\t\t    (policy & 0x001FFE00) >> 9;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].priority =\n\t\t\t\t\t    (policy & 0x1C0) >> 6;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].dscp =\n\t\t\t\t\t    policy & 0x3F;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_POLICY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_LOCATION:\n\t\t\t\t\tCHECK_TLV_SIZE(5, \"LLDP-MED Location\");\n\t\t\t\t\tloctype = PEEK_UINT8;\n\t\t\t\t\tif ((loctype < 1) ||\n\t\t\t\t\t    (loctype > LLDP_MED_LOCFORMAT_LAST)) {\n\t\t\t\t\t\tlog_info(\"lldp\", \"unknown location type \"\n\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((port->p_med_location[loctype - 1].data =\n\t\t\t\t\t\t(char*)malloc(tlv_size - 5)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t    \"for LLDP-MED location for \"\n\t\t\t\t\t\t    \"frame received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(port->p_med_location[loctype - 1].data,\n\t\t\t\t\t    tlv_size - 5);\n\t\t\t\t\tport->p_med_location[loctype - 1].data_len =\n\t\t\t\t\t    tlv_size - 5;\n\t\t\t\t\tport->p_med_location[loctype - 1].format = loctype;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_LOCATION;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_MDI:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"LLDP-MED PoE-MDI\");\n\t\t\t\t\tpower = PEEK_UINT8;\n\t\t\t\t\tswitch (power & 0xC0) {\n\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PSE;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PSE;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PRIMARY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BACKUP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_RESERVED;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x40:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PD;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PD;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PSE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_LOCAL;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BOTH;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tport->p_med_power.devicetype =\n\t\t\t\t\t\t    LLDP_MED_POW_TYPE_RESERVED;\n\t\t\t\t\t}\n\t\t\t\t\tif ((power & 0x0F) > LLDP_MED_POW_PRIO_LOW)\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    LLDP_MED_POW_PRIO_UNKNOWN;\n\t\t\t\t\telse\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    power & 0x0F;\n\t\t\t\t\tport->p_med_power.val = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\tif (tlv_size <= 4)\n\t\t\t\t\t\tb = NULL;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ((b = (char*)malloc(tlv_size - 3)) ==\n\t\t\t\t\t\t    NULL) {\n\t\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to allocate \"\n\t\t\t\t\t\t\t    \"memory for LLDP-MED \"\n\t\t\t\t\t\t\t    \"inventory for frame \"\n\t\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPEEK_BYTES(b, tlv_size - 4);\n\t\t\t\t\t\tb[tlv_size - 4] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\t\t\tchassis->c_med_hw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\t\t\tchassis->c_med_fw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\t\t\tchassis->c_med_sw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\t\t\tchassis->c_med_sn = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\t\t\tchassis->c_med_manuf = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\t\t\tchassis->c_med_model = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\t\tchassis->c_med_asset = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_IV;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown LLDP MED, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif /* ENABLE_LLDPMED */\n\t\t\t} else if (memcmp(dcbx, orgid, sizeof(orgid)) == 0) {\n\t\t\t\tlog_debug(\"lldp\", \"unsupported DCBX tlv received on %s - ignore\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t} else {\n\t\t\t\tlog_debug(\"lldp\", \"unknown org tlv [%02x:%02x:%02x] received on %s\",\n\t\t\t\t    orgid[0], orgid[1], orgid[2],\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#ifdef ENABLE_CUSTOM\n\t\t\t\tcustom = (struct lldpd_custom*)calloc(1, sizeof(struct lldpd_custom));\n\t\t\t\tif (!custom) {\n\t\t\t\t\tlog_warn(\"lldp\",\n\t\t\t\t\t    \"unable to allocate memory for custom TLV\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tcustom->oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0;\n\t\t\t\tmemcpy(custom->oui, orgid, sizeof(custom->oui));\n\t\t\t\tcustom->subtype = tlv_subtype;\n\t\t\t\tif (custom->oui_info_len > 0) {\n\t\t\t\t\tcustom->oui_info = malloc(custom->oui_info_len);\n\t\t\t\t\tif (!custom->oui_info) {\n\t\t\t\t\t\tlog_warn(\"lldp\",\n\t\t\t\t\t\t    \"unable to allocate memory for custom TLV data\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(custom->oui_info, custom->oui_info_len);\n\t\t\t\t}\n\t\t\t\tTAILQ_INSERT_TAIL(&port->p_custom_list, custom, next);\n\t\t\t\tcustom = NULL;\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_warnx(\"lldp\", \"unknown tlv (%d) received on %s\",\n\t\t\t    tlv_type, hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tif (pos > tlv + tlv_size) {\n\t\t\tlog_warnx(\"lldp\", \"BUG: already past TLV!\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_size - pos);\n\t}\n\n\t/* Some random check */\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (!ttl_received) ||\n\t    (gotend == 0)) {\n\t\tlog_warnx(\"lldp\", \"some mandatory tlv are missing for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\nmalformed:\n#ifdef ENABLE_CUSTOM\n\tfree(custom);\n#endif\n#ifdef ENABLE_DOT1\n\tfree(vlan);\n\tfree(pi);\n#endif\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}\n", "/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"lldpd.h\"\n#include \"frame.h\"\n\n#ifdef ENABLE_SONMP\n\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <assert.h>\n\nstatic struct sonmp_chassis sonmp_chassis_types[] = {\n\t{1, \"unknown (via SONMP)\"},\n\t{2, \"Nortel 3000\"},\n\t{3, \"Nortel 3030\"},\n\t{4, \"Nortel 2310\"},\n\t{5, \"Nortel 2810\"},\n\t{6, \"Nortel 2912\"},\n\t{7, \"Nortel 2914\"},\n\t{8, \"Nortel 271x\"},\n\t{9, \"Nortel 2813\"},\n\t{10, \"Nortel 2814\"},\n\t{11, \"Nortel 2915\"},\n\t{12, \"Nortel 5000\"},\n\t{13, \"Nortel 2813SA\"},\n\t{14, \"Nortel 2814SA\"},\n\t{15, \"Nortel 810M\"},\n\t{16, \"Nortel EtherCell\"},\n\t{17, \"Nortel 5005\"},\n\t{18, \"Alcatel Ethernet workgroup conc.\"},\n\t{20, \"Nortel 2715SA\"},\n\t{21, \"Nortel 2486\"},\n\t{22, \"Nortel 28000 series\"},\n\t{23, \"Nortel 23000 series\"},\n\t{24, \"Nortel 5DN00x series\"},\n\t{25, \"BayStack Ethernet\"},\n\t{26, \"Nortel 23100 series\"},\n\t{27, \"Nortel 100Base-T Hub\"},\n\t{28, \"Nortel 3000 Fast Ethernet\"},\n\t{29, \"Nortel Orion switch\"},\n\t{30, \"unknown\"},\n\t{31, \"Nortel DDS \"},\n\t{32, \"Nortel Centillion\"},\n\t{33, \"Nortel Centillion\"},\n\t{34, \"Nortel Centillion\"},\n\t{35, \"BayStack 301\"},\n\t{36, \"BayStack TokenRing Hub\"},\n\t{37, \"Nortel FVC Multimedia Switch\"},\n\t{38, \"Nortel Switch Node\"},\n\t{39, \"BayStack 302 Switch\"},\n\t{40, \"BayStack 350 Switch\"},\n\t{41, \"BayStack 150 Ethernet Hub\"},\n\t{42, \"Nortel Centillion 50N switch\"},\n\t{43, \"Nortel Centillion 50T switch\"},\n\t{44, \"BayStack 303 and 304 Switches\"},\n\t{45, \"BayStack 200 Ethernet Hub\"},\n\t{46, \"BayStack 250 10/100 Ethernet Hub\"},\n\t{48, \"BayStack 450 10/100/1000 Switches\"},\n\t{49, \"BayStack 410 10/100 Switches\"},\n\t{50, \"Nortel Ethernet Routing 1200 L3 Switch\"},\n\t{51, \"Nortel Ethernet Routing 1250 L3 Switch\"},\n\t{52, \"Nortel Ethernet Routing 1100 L3 Switch\"},\n\t{53, \"Nortel Ethernet Routing 1150 L3 Switch\"},\n\t{54, \"Nortel Ethernet Routing 1050 L3 Switch\"},\n\t{55, \"Nortel Ethernet Routing 1051 L3 Switch\"},\n\t{56, \"Nortel Ethernet Routing 8610 L3 Switch\"},\n\t{57, \"Nortel Ethernet Routing 8606 L3 Switch\"},\n\t{58, \"Nortel Ethernet Routing Switch 8010\"},\n\t{59, \"Nortel Ethernet Routing Switch 8006\"},\n\t{60, \"BayStack 670 wireless access point\"},\n\t{61, \"Nortel Ethernet Routing Switch 740 \"},\n\t{62, \"Nortel Ethernet Routing Switch 750 \"},\n\t{63, \"Nortel Ethernet Routing Switch 790\"},\n\t{64, \"Nortel Business Policy Switch 2000 10/100 Switches\"},\n\t{65, \"Nortel Ethernet Routing 8110 L2 Switch\"},\n\t{66, \"Nortel Ethernet Routing 8106 L2 Switch\"},\n\t{67, \"BayStack 3580 Gig Switch\"},\n\t{68, \"BayStack 10 Power Supply Unit\"},\n\t{69, \"BayStack 420 10/100 Switch\"},\n\t{70, \"OPTera Metro 1200 Ethernet Service Module\"},\n\t{71, \"Nortel Ethernet Routing Switch 8010co\"},\n\t{72, \"Nortel Ethernet Routing 8610co L3 switch\"},\n\t{73, \"Nortel Ethernet Routing 8110co L2 switch\"},\n\t{74, \"Nortel Ethernet Routing 8003\"},\n\t{75, \"Nortel Ethernet Routing 8603 L3 switch\"},\n\t{76, \"Nortel Ethernet Routing 8103 L2 switch\"},\n\t{77, \"BayStack 380 10/100/1000 Switch\"},\n\t{78, \"Nortel Ethernet Switch 470-48T\"},\n\t{79, \"OPTera Metro 1450 Ethernet Service Module\"},\n\t{80, \"OPTera Metro 1400 Ethernet Service Module\"},\n\t{81, \"Alteon Switch Family\"},\n\t{82, \"Ethernet Switch 460-24T-PWR\"},\n\t{83, \"OPTera Metro 8010 OPM L2 Switch\"},\n\t{84, \"OPTera Metro 8010co OPM L2 Switch\"},\n\t{85, \"OPTera Metro 8006 OPM L2 Switch\"},\n\t{86, \"OPTera Metro 8003 OPM L2 Switch\"},\n\t{87, \"Alteon 180e\"},\n\t{88, \"Alteon AD3\"},\n\t{89, \"Alteon 184\"},\n\t{90, \"Alteon AD4\"},\n\t{91, \"Nortel Ethernet Routing 1424 L3 switch\"},\n\t{92, \"Nortel Ethernet Routing 1648 L3 switch\"},\n\t{93, \"Nortel Ethernet Routing 1612 L3 switch\"},\n\t{94, \"Nortel Ethernet Routing 1624 L3 switch \"},\n\t{95, \"BayStack 380-24F Fiber 1000 Switch\"},\n\t{96, \"Nortel Ethernet Routing Switch 5510-24T\"},\n\t{97, \"Nortel Ethernet Routing Switch 5510-48T\"},\n\t{98, \"Nortel Ethernet Switch 470-24T\"},\n\t{99, \"Nortel Networks Wireless LAN Access Point 2220\"},\n\t{100, \"Ethernet Routing RBS 2402 L3 switch\"},\n\t{101, \"Alteon Application Switch 2424  \"},\n\t{102, \"Alteon Application Switch 2224 \"},\n\t{103, \"Alteon Application Switch 2208 \"},\n\t{104, \"Alteon Application Switch 2216\"},\n\t{105, \"Alteon Application Switch 3408\"},\n\t{106, \"Alteon Application Switch 3416\"},\n\t{107, \"Nortel Networks Wireless LAN SecuritySwitch 2250\"},\n\t{108, \"Ethernet Switch 425-48T\"},\n\t{109, \"Ethernet Switch 425-24T\"},\n\t{110, \"Nortel Networks Wireless LAN Access Point 2221\"},\n\t{111, \"Nortel Metro Ethernet Service Unit 24-T SPF switch\"},\n\t{112, \"Nortel Metro Ethernet Service Unit 24-T LX DC switch\"},\n\t{113, \"Nortel Ethernet Routing Switch 8300 10-slot chassis\"},\n\t{114, \"Nortel Ethernet Routing Switch 8300 6-slot chassis\"},\n\t{115, \"Nortel Ethernet Routing Switch 5520-24T-PWR\"},\n\t{116, \"Nortel Ethernet Routing Switch 5520-48T-PWR\"},\n\t{117, \"Nortel Networks VPN Gateway 3050\"},\n\t{118, \"Alteon SSL 310 10/100\"},\n\t{119, \"Alteon SSL 310 10/100 Fiber\"},\n\t{120, \"Alteon SSL 310 10/100 FIPS\"},\n\t{121, \"Alteon SSL 410 10/100/1000\"},\n\t{122, \"Alteon SSL 410 10/100/1000 Fiber\"},\n\t{123, \"Alteon Application Switch 2424-SSL\"},\n\t{124, \"Nortel Ethernet Switch 325-24T\"},\n\t{125, \"Nortel Ethernet Switch 325-24G\"},\n\t{126, \"Nortel Networks Wireless LAN Access Point 2225\"},\n\t{127, \"Nortel Networks Wireless LAN SecuritySwitch 2270\"},\n\t{128, \"Nortel 24-port Ethernet Switch 470-24T-PWR\"},\n\t{129, \"Nortel 48-port Ethernet Switch 470-48T-PWR\"},\n\t{130, \"Nortel Ethernet Routing Switch 5530-24TFD\"},\n\t{131, \"Nortel Ethernet Switch 3510-24T\"},\n\t{132, \"Nortel Metro Ethernet Service Unit 12G AC L3 switch\"},\n\t{133, \"Nortel Metro Ethernet Service Unit 12G DC L3 switch\"},\n\t{134, \"Nortel Secure Access Switch\"},\n\t{135, \"Networks VPN Gateway 3070\"},\n\t{136, \"OPTera Metro 3500\"},\n\t{137, \"SMB BES 1010 24T\"},\n\t{138, \"SMB BES 1010 48T\"},\n\t{139, \"SMB BES 1020 24T PWR\"},\n\t{140, \"SMB BES 1020 48T PWR\"},\n\t{141, \"SMB BES 2010 24T\"},\n\t{142, \"SMB BES 2010 48T\"},\n\t{143, \"SMB BES 2020 24T PWR\"},\n\t{144, \"SMB BES 2020 48T PWR\"},\n\t{145, \"SMB BES 110 24T\"},\n\t{146, \"SMB BES 110 48T\"},\n\t{147, \"SMB BES 120 24T PWR\"},\n\t{148, \"SMB BES 120 48T PWR\"},\n\t{149, \"SMB BES 210 24T\"},\n\t{150, \"SMB BES 210 48T\"},\n\t{151, \"SMB BES 220 24T PWR\"},\n\t{152, \"SMB BES 220 48T PWR\"},\n\t{153, \"OME 6500\"},\n\t{0, \"unknown (via SONMP)\"},\n};\n\nint\nsonmp_send(struct lldpd *global,\n    struct lldpd_hardware *hardware)\n{\n\tconst u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR;\n\tconst u_int8_t llcorg[] = LLC_ORG_NORTEL;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_mgmt *mgmt;\n\tu_int8_t *packet, *pos, *pos_pid, *end;\n\tint length;\n\tstruct in_addr address;\n\n\tlog_debug(\"sonmp\", \"send SONMP PDU to %s\",\n\t    hardware->h_ifname);\n\n\tchassis = hardware->h_lport.p_chassis;\n\tlength = hardware->h_mtu;\n\tif ((packet = (u_int8_t*)calloc(1, length)) == NULL)\n\t\treturn ENOMEM;\n\tpos = packet;\n\n\t/* Ethernet header */\n\tif (!(\n\t      /* SONMP multicast address as target */\n\t      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t      /* Source MAC addresss */\n\t      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t      /* SONMP frame is of fixed size */\n\t      POKE_UINT16(SONMP_SIZE)))\n\t\tgoto toobig;\n\n\t/* LLC header */\n\tif (!(\n\t      /* DSAP and SSAP */\n\t      POKE_UINT8(0xaa) && POKE_UINT8(0xaa) &&\n\t      /* Control field */\n\t      POKE_UINT8(0x03) &&\n\t      /* ORG */\n\t      POKE_BYTES(llcorg, sizeof(llcorg)) &&\n\t      POKE_SAVE(pos_pid) && /* We will modify PID later to\n\t\t\t\t       create a new frame */\n\t      POKE_UINT16(LLC_PID_SONMP_HELLO)))\n\t\tgoto toobig;\n\n\n\taddress.s_addr = htonl(INADDR_ANY);\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\tif (mgmt->m_family == LLDPD_AF_IPV4) {\n\t\t\taddress.s_addr = mgmt->m_addr.inet.s_addr;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* SONMP */\n\tif (!(\n\t\t  /* Our IP address */\n\t\t  POKE_BYTES(&address, sizeof(struct in_addr)) &&\n\t\t  /* Segment on three bytes, we don't have slots, so we\n\t\t skip the first two bytes */\n\t\t  POKE_UINT16(0) &&\n\t\t  POKE_UINT8(hardware->h_ifindex) &&\n\t\t  POKE_UINT8(1) &&  /* Chassis: Other */\n\t\t  POKE_UINT8(12) &&\t/* Back: Ethernet, Fast Ethernet and Gigabit */\n\t\t  POKE_UINT8(SONMP_TOPOLOGY_NEW) && /* Should work. We have no state */\n\t\t  POKE_UINT8(1) &&\t/* Links: Dunno what it is */\n\t\t  POKE_SAVE(end)))\n\t\tgoto toobig;\n\t\t\t\t\n\tif (interfaces_send_helper(global, hardware,\n\t\t(char *)packet, end - packet) == -1) {\n\t\tlog_warn(\"sonmp\", \"unable to send packet on real device for %s\",\n\t\t\t   hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\tPOKE_RESTORE(pos_pid);\t/* Modify LLC PID */\n\t(void)POKE_UINT16(LLC_PID_SONMP_FLATNET);\n\tPOKE_RESTORE(packet);\t/* Go to the beginning */\n\tPEEK_DISCARD(ETHER_ADDR_LEN - 1); /* Modify the last byte of the MAC address */\n\t(void)POKE_UINT8(1);\n\n\tif (interfaces_send_helper(global, hardware,\n\t\t(char *)packet, end - packet) == -1) {\n\t\tlog_warn(\"sonmp\", \"unable to send second SONMP packet on real device for %s\",\n\t\t\t   hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\tfree(packet);\n\thardware->h_tx_cnt++;\n\treturn 0;\n toobig:\n\tfree(packet);\n\treturn -1;\n}\n\nint\nsonmp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tconst u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tstruct lldpd_mgmt *mgmt;\n\tint length, i;\n\tu_int8_t *pos;\n\tu_int8_t seg[3], rchassis;\n\tstruct in_addr address;\n\n\tlog_debug(\"sonmp\", \"decode SONMP PDU from %s\",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"sonmp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"sonmp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\tif (length < SONMP_SIZE) {\n\t\tlog_warnx(\"sonmp\", \"too short SONMP frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)\n\t\t/* There is two multicast address. We just handle only one of\n\t\t * them. */\n\t\tgoto malformed;\n\t/* We skip to LLC PID */\n\tPEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16;\n\tPEEK_DISCARD(6);\n\tif (PEEK_UINT16 != LLC_PID_SONMP_HELLO) {\n\t\tlog_debug(\"sonmp\", \"incorrect LLC protocol ID received for SONMP on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_ADDR;\n\tif ((chassis->c_id = calloc(1, sizeof(struct in_addr) + 1)) == NULL) {\n\t\tlog_warn(\"sonmp\", \"unable to allocate memory for chassis id on %s\",\n\t\t\thardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_id_len = sizeof(struct in_addr) + 1;\n\tchassis->c_id[0] = 1;\n\tPEEK_BYTES(&address, sizeof(struct in_addr));\n\tmemcpy(chassis->c_id + 1, &address, sizeof(struct in_addr));\n\tif (asprintf(&chassis->c_name, \"%s\", inet_ntoa(address)) == -1) {\n\t\tlog_warnx(\"sonmp\", \"unable to write chassis name for %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_BYTES(seg, sizeof(seg));\n\trchassis = PEEK_UINT8;\n\tfor (i=0; sonmp_chassis_types[i].type != 0; i++) {\n\t\tif (sonmp_chassis_types[i].type == rchassis)\n\t\t\tbreak;\n\t}\n\tif (asprintf(&chassis->c_descr, \"%s\",\n\t\tsonmp_chassis_types[i].description) == -1) {\n\t\tlog_warnx(\"sonmp\", \"unable to write chassis description for %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0);\n\tif (mgmt == NULL) {\n\t\tassert(errno == ENOMEM);\n\t\tlog_warn(\"sonmp\", \"unable to allocate memory for management address\");\n\t\tgoto malformed;\n\t}\n\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\tchassis->c_ttl = cfg?(cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold):\n\t    LLDPD_TTL;\n\n\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_LOCAL;\n\tif (asprintf(&port->p_id, \"%02x-%02x-%02x\",\n\t\tseg[0], seg[1], seg[2]) == -1) {\n\t\tlog_warn(\"sonmp\", \"unable to allocate memory for port id on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tport->p_id_len = strlen(port->p_id);\n\n\t/* Port description depend on the number of segments */\n\tif ((seg[0] == 0) && (seg[1] == 0)) {\n\t\tif (asprintf(&port->p_descr, \"port %d\",\n\t\t\tseg[2]) == -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else if (seg[0] == 0) {\n\t\tif (asprintf(&port->p_descr, \"port %d/%d\",\n\t\t\tseg[1], seg[2]) == -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else {\n\t\tif (asprintf(&port->p_descr, \"port %x:%x:%x\",\n\t\t\tseg[0], seg[1], seg[2]) == -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}\n\n#endif /* ENABLE_SONMP */\n"], "fixing_code": ["/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"lldpd.h\"\n#include \"trace.h\"\n\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <time.h>\n#include <libgen.h>\n#include <assert.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/ioctl.h>\n#include <arpa/inet.h>\n#include <netinet/if_ether.h>\n#include <pwd.h>\n#include <grp.h>\n\nstatic void\t\t usage(void);\n\nstatic struct protocol protos[] =\n{\n\t{ LLDPD_MODE_LLDP, 1, \"LLDP\", 'l', lldp_send, lldp_decode, NULL,\n\t  LLDP_MULTICAST_ADDR },\n#ifdef ENABLE_CDP\n\t{ LLDPD_MODE_CDPV1, 0, \"CDPv1\", 'c', cdpv1_send, cdp_decode, cdpv1_guess,\n\t  CDP_MULTICAST_ADDR },\n\t{ LLDPD_MODE_CDPV2, 0, \"CDPv2\", 'c', cdpv2_send, cdp_decode, cdpv2_guess,\n\t  CDP_MULTICAST_ADDR },\n#endif\n#ifdef ENABLE_SONMP\n\t{ LLDPD_MODE_SONMP, 0, \"SONMP\", 's', sonmp_send, sonmp_decode, NULL,\n\t  SONMP_MULTICAST_ADDR },\n#endif\n#ifdef ENABLE_EDP\n\t{ LLDPD_MODE_EDP, 0, \"EDP\", 'e', edp_send, edp_decode, NULL,\n\t  EDP_MULTICAST_ADDR },\n#endif\n#ifdef ENABLE_FDP\n\t{ LLDPD_MODE_FDP, 0, \"FDP\", 'f', fdp_send, cdp_decode, NULL,\n\t  FDP_MULTICAST_ADDR },\n#endif\n\t{ 0, 0, \"any\", ' ', NULL, NULL, NULL,\n\t  {0,0,0,0,0,0} }\n};\n\nstatic char\t\t**saved_argv;\n#ifdef HAVE___PROGNAME\nextern const char\t*__progname;\n#else\n# define __progname \"lldpd\"\n#endif\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr, \"Usage:   %s [OPTIONS ...]\\n\", __progname);\n\tfprintf(stderr, \"Version: %s\\n\", PACKAGE_STRING);\n\n\tfprintf(stderr, \"\\n\");\n\n\tfprintf(stderr, \"-d       Do not daemonize.\\n\");\n\tfprintf(stderr, \"-r       Receive-only mode\\n\");\n\tfprintf(stderr, \"-i       Disable LLDP-MED inventory TLV transmission.\\n\");\n\tfprintf(stderr, \"-k       Disable advertising of kernel release, version, machine.\\n\");\n\tfprintf(stderr, \"-S descr Override the default system description.\\n\");\n\tfprintf(stderr, \"-P name  Override the default hardware platform.\\n\");\n\tfprintf(stderr, \"-m IP    Specify the IPv4 management addresses of this system.\\n\");\n\tfprintf(stderr, \"-u file  Specify the Unix-domain socket used for communication with lldpctl(8).\\n\");\n\tfprintf(stderr, \"-H mode  Specify the behaviour when detecting multiple neighbors.\\n\");\n\tfprintf(stderr, \"-I iface Limit interfaces to use.\\n\");\n#ifdef ENABLE_LLDPMED\n\tfprintf(stderr, \"-M class Enable emission of LLDP-MED frame. 'class' should be one of:\\n\");\n\tfprintf(stderr, \"             1 Generic Endpoint (Class I)\\n\");\n\tfprintf(stderr, \"             2 Media Endpoint (Class II)\\n\");\n\tfprintf(stderr, \"             3 Communication Device Endpoints (Class III)\\n\");\n\tfprintf(stderr, \"             4 Network Connectivity Device\\n\");\n#endif\n#ifdef USE_SNMP\n\tfprintf(stderr, \"-x       Enable SNMP subagent.\\n\");\n#endif\n\tfprintf(stderr, \"\\n\");\n\n#if defined ENABLE_CDP || defined ENABLE_EDP || defined ENABLE_FDP || defined ENABLE_SONMP\n\tfprintf(stderr, \"Additional protocol support.\\n\");\n#ifdef ENABLE_CDP\n\tfprintf(stderr, \"-c       Enable the support of CDP protocol. (Cisco)\\n\");\n#endif\n#ifdef ENABLE_EDP\n\tfprintf(stderr, \"-e       Enable the support of EDP protocol. (Extreme)\\n\");\n#endif\n#ifdef ENABLE_FDP\n\tfprintf(stderr, \"-f       Enable the support of FDP protocol. (Foundry)\\n\");\n#endif\n#ifdef ENABLE_SONMP\n\tfprintf(stderr, \"-s       Enable the support of SONMP protocol. (Nortel)\\n\");\n#endif\n\n\tfprintf(stderr, \"\\n\");\n#endif\n\n\tfprintf(stderr, \"see manual page lldpd(8) for more information\\n\");\n\texit(1);\n}\n\nstruct lldpd_hardware *\nlldpd_get_hardware(struct lldpd *cfg, char *name, int index, struct lldpd_ops *ops)\n{\n\tstruct lldpd_hardware *hardware;\n\tTAILQ_FOREACH(hardware, &cfg->g_hardware, h_entries) {\n\t\tif ((strcmp(hardware->h_ifname, name) == 0) &&\n\t\t    (hardware->h_ifindex == index) &&\n\t\t    ((!ops) || (ops == hardware->h_ops)))\n\t\t\tbreak;\n\t}\n\treturn hardware;\n}\n\nstruct lldpd_hardware *\nlldpd_alloc_hardware(struct lldpd *cfg, char *name, int index)\n{\n\tstruct lldpd_hardware *hardware;\n\n\tlog_debug(\"alloc\", \"allocate a new local port (%s)\", name);\n\n\tif ((hardware = (struct lldpd_hardware *)\n\t\tcalloc(1, sizeof(struct lldpd_hardware))) == NULL)\n\t\treturn NULL;\n\n\thardware->h_cfg = cfg;\n\tstrlcpy(hardware->h_ifname, name, sizeof(hardware->h_ifname));\n\thardware->h_ifindex = index;\n\thardware->h_lport.p_chassis = LOCAL_CHASSIS(cfg);\n\thardware->h_lport.p_chassis->c_refcount++;\n\tTAILQ_INIT(&hardware->h_rports);\n\n#ifdef ENABLE_LLDPMED\n\tif (LOCAL_CHASSIS(cfg)->c_med_cap_available) {\n\t\thardware->h_lport.p_med_cap_enabled = LLDP_MED_CAP_CAP;\n\t\tif (!cfg->g_config.c_noinventory)\n\t\t\thardware->h_lport.p_med_cap_enabled |= LLDP_MED_CAP_IV;\n\t}\n#endif\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&hardware->h_lport.p_vlans);\n\tTAILQ_INIT(&hardware->h_lport.p_ppvids);\n\tTAILQ_INIT(&hardware->h_lport.p_pids);\n#endif\n#ifdef ENABLE_CUSTOM\n\tTAILQ_INIT(&hardware->h_lport.p_custom_list);\n#endif\n\n\tlevent_hardware_init(hardware);\n\treturn hardware;\n}\n\nstruct lldpd_mgmt *\nlldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\n\tlog_debug(\"alloc\", \"allocate a new management address (family: %d)\", family);\n\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n}\n\nvoid\nlldpd_hardware_cleanup(struct lldpd *cfg, struct lldpd_hardware *hardware)\n{\n\tlog_debug(\"alloc\", \"cleanup hardware port %s\", hardware->h_ifname);\n\n\tfree(hardware->h_lport_previous);\n\tfree(hardware->h_lchassis_previous_id);\n\tfree(hardware->h_lport_previous_id);\n\tlldpd_port_cleanup(&hardware->h_lport, 1);\n\tif (hardware->h_ops && hardware->h_ops->cleanup)\n\t\thardware->h_ops->cleanup(cfg, hardware);\n\tlevent_hardware_release(hardware);\n\tfree(hardware);\n}\n\nstatic void\nlldpd_display_neighbors(struct lldpd *cfg)\n{\n\tif (!cfg->g_config.c_set_ifdescr) return;\n\tstruct lldpd_hardware *hardware;\n\tTAILQ_FOREACH(hardware, &cfg->g_hardware, h_entries) {\n\t\tstruct lldpd_port *port;\n\t\tchar *description;\n\t\tconst char *neighbor = NULL;\n\t\tunsigned neighbors = 0;\n\t\tTAILQ_FOREACH(port, &hardware->h_rports, p_entries) {\n\t\t\tif (SMART_HIDDEN(port)) continue;\n\t\t\tneighbors++;\n\t\t\tneighbor = port->p_chassis->c_name;\n\t\t}\n\t\tif (neighbors == 0)\n\t\t\tpriv_iface_description(hardware->h_ifname,\n\t\t\t    \"\");\n\t\telse if (neighbors == 1 && neighbor && *neighbor != '\\0') {\n\t\t\tif (asprintf(&description, \"%s\",\n\t\t\t\tneighbor) != -1) {\n\t\t\t\tpriv_iface_description(hardware->h_ifname, description);\n\t\t\t\tfree(description);\n\t\t\t}\n\t\t} else {\n\t\t\tif (asprintf(&description, \"%d neighbor%s\",\n\t\t\t\tneighbors, (neighbors > 1)?\"s\":\"\") != -1) {\n\t\t\t\tpriv_iface_description(hardware->h_ifname,\n\t\t\t\t    description);\n\t\t\t\tfree(description);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nlldpd_count_neighbors(struct lldpd *cfg)\n{\n#if HAVE_SETPROCTITLE\n\tstruct lldpd_chassis *chassis;\n\tconst char *neighbor;\n\tunsigned neighbors = 0;\n\tTAILQ_FOREACH(chassis, &cfg->g_chassis, c_entries) {\n\t\tneighbors++;\n\t\tneighbor = chassis->c_name;\n\t}\n\tneighbors--;\n\tif (neighbors == 0)\n\t\tsetproctitle(\"no neighbor\");\n\telse if (neighbors == 1 && neighbor && *neighbor != '\\0')\n\t\tsetproctitle(\"connected to %s\", neighbor);\n\telse\n\t\tsetproctitle(\"%d neighbor%s\", neighbors,\n\t\t    (neighbors > 1)?\"s\":\"\");\n#endif\n\tlldpd_display_neighbors(cfg);\n}\n\nstatic void\nnotify_clients_deletion(struct lldpd_hardware *hardware,\n    struct lldpd_port *rport)\n{\n\tTRACE(LLDPD_NEIGHBOR_DELETE(hardware->h_ifname,\n\t\trport->p_chassis->c_name,\n\t\trport->p_descr));\n\tlevent_ctl_notify(hardware->h_ifname, NEIGHBOR_CHANGE_DELETED,\n\t    rport);\n#ifdef USE_SNMP\n\tagent_notify(hardware, NEIGHBOR_CHANGE_DELETED, rport);\n#endif\n}\n\nstatic void\nlldpd_reset_timer(struct lldpd *cfg)\n{\n\t/* Reset timer for ports that have been changed. */\n\tstruct lldpd_hardware *hardware;\n\tTAILQ_FOREACH(hardware, &cfg->g_hardware, h_entries) {\n\t\t/* We keep a flat copy of the local port to see if there is any\n\t\t * change. To do this, we zero out fields that are not\n\t\t * significant, marshal the port, then restore. */\n\t\tstruct lldpd_port *port = &hardware->h_lport;\n\t\tu_int8_t *output = NULL;\n\t\tssize_t output_len;\n\t\tchar save[LLDPD_PORT_START_MARKER];\n\t\tmemcpy(save, port, sizeof(save));\n\t\t/* coverity[suspicious_sizeof]\n\t\t   We intentionally partially memset port */\n\t\tmemset(port, 0, sizeof(save));\n\t\toutput_len = lldpd_port_serialize(port, (void**)&output);\n\t\tmemcpy(port, save, sizeof(save));\n\t\tif (output_len == -1) {\n\t\t\tlog_warnx(\"localchassis\",\n\t\t\t    \"unable to serialize local port %s to check for differences\",\n\t\t\t    hardware->h_ifname);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Compare with the previous value */\n\t\tif (hardware->h_lport_previous &&\n\t\t    output_len == hardware->h_lport_previous_len &&\n\t\t    !memcmp(output, hardware->h_lport_previous, output_len)) {\n\t\t\tlog_debug(\"localchassis\",\n\t\t\t    \"no change detected for port %s\",\n\t\t\t    hardware->h_ifname);\n\t\t} else {\n\t\t\tlog_debug(\"localchassis\",\n\t\t\t    \"change detected for port %s, resetting its timer\",\n\t\t\t    hardware->h_ifname);\n\t\t\tlevent_schedule_pdu(hardware);\n\t\t}\n\n\t\t/* Update the value */\n\t\tfree(hardware->h_lport_previous);\n\t\thardware->h_lport_previous = output;\n\t\thardware->h_lport_previous_len = output_len;\n\t}\n}\n\nvoid\nlldpd_cleanup(struct lldpd *cfg)\n{\n\tstruct lldpd_hardware *hardware, *hardware_next;\n\tstruct lldpd_chassis *chassis, *chassis_next;\n\n\tlog_debug(\"localchassis\", \"cleanup all ports\");\n\n\tfor (hardware = TAILQ_FIRST(&cfg->g_hardware); hardware != NULL;\n\t     hardware = hardware_next) {\n\t\thardware_next = TAILQ_NEXT(hardware, h_entries);\n\t\tif (!hardware->h_flags) {\n\t\t\tTRACE(LLDPD_INTERFACES_DELETE(hardware->h_ifname));\n\t\t\tTAILQ_REMOVE(&cfg->g_hardware, hardware, h_entries);\n\t\t\tlldpd_remote_cleanup(hardware, notify_clients_deletion, 1);\n\t\t\tlldpd_hardware_cleanup(cfg, hardware);\n\t\t} else\n\t\t\tlldpd_remote_cleanup(hardware, notify_clients_deletion, 0);\n\t}\n\n\tlog_debug(\"localchassis\", \"cleanup all chassis\");\n\n\tfor (chassis = TAILQ_FIRST(&cfg->g_chassis); chassis;\n\t     chassis = chassis_next) {\n\t\tchassis_next = TAILQ_NEXT(chassis, c_entries);\n\t\tif (chassis->c_refcount == 0) {\n\t\t\tTAILQ_REMOVE(&cfg->g_chassis, chassis, c_entries);\n\t\t\tlldpd_chassis_cleanup(chassis, 1);\n\t\t}\n\t}\n\n\tlldpd_count_neighbors(cfg);\n\tlevent_schedule_cleanup(cfg);\n}\n\n/* Update chassis `ochassis' with values from `chassis'. The later one is not\n   expected to be part of a list! It will also be wiped from memory. */\nstatic void\nlldpd_move_chassis(struct lldpd_chassis *ochassis,\n    struct lldpd_chassis *chassis) {\n\tstruct lldpd_mgmt *mgmt, *mgmt_next;\n\n\t/* We want to keep refcount, index and list stuff from the current\n\t * chassis */\n\tTAILQ_ENTRY(lldpd_chassis) entries;\n\tint refcount = ochassis->c_refcount;\n\tint index = ochassis->c_index;\n\tmemcpy(&entries, &ochassis->c_entries,\n\t    sizeof(entries));\n\tlldpd_chassis_cleanup(ochassis, 0);\n\n\t/* Make the copy. */\n\t/* WARNING: this is a kludgy hack, we need in-place copy and cannot use\n\t * marshaling. */\n\tmemcpy(ochassis, chassis, sizeof(struct lldpd_chassis));\n\tTAILQ_INIT(&ochassis->c_mgmt);\n\n\t/* Copy of management addresses */\n\tfor (mgmt = TAILQ_FIRST(&chassis->c_mgmt);\n\t     mgmt != NULL;\n\t     mgmt = mgmt_next) {\n\t\tmgmt_next = TAILQ_NEXT(mgmt, m_entries);\n\t\tTAILQ_REMOVE(&chassis->c_mgmt, mgmt, m_entries);\n\t\tTAILQ_INSERT_TAIL(&ochassis->c_mgmt, mgmt, m_entries);\n\t}\n\n\t/* Restore saved values */\n\tochassis->c_refcount = refcount;\n\tochassis->c_index = index;\n\tmemcpy(&ochassis->c_entries, &entries, sizeof(entries));\n\n\t/* Get rid of the new chassis */\n\tfree(chassis);\n}\n\nstatic int\nlldpd_guess_type(struct lldpd *cfg, char *frame, int s)\n{\n\tint i;\n\tif (s < ETHER_ADDR_LEN)\n\t\treturn -1;\n\tfor (i=0; cfg->g_protocols[i].mode != 0; i++) {\n\t\tif (!cfg->g_protocols[i].enabled)\n\t\t\tcontinue;\n\t\tif (cfg->g_protocols[i].guess == NULL) {\n\t\t\tif (memcmp(frame, cfg->g_protocols[i].mac, ETHER_ADDR_LEN) == 0) {\n\t\t\t\tlog_debug(\"decode\", \"guessed protocol is %s (from MAC address)\",\n\t\t\t\t    cfg->g_protocols[i].name);\n\t\t\t\treturn cfg->g_protocols[i].mode;\n\t\t\t}\n\t\t} else {\n\t\t\tif (cfg->g_protocols[i].guess(frame, s)) {\n\t\t\t\tlog_debug(\"decode\", \"guessed protocol is %s (from detector function)\",\n\t\t\t\t    cfg->g_protocols[i].name);\n\t\t\t\treturn cfg->g_protocols[i].mode;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic void\nlldpd_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware)\n{\n\tint i;\n\tstruct lldpd_chassis *chassis, *ochassis = NULL;\n\tstruct lldpd_port *port, *oport = NULL, *aport;\n\tint guess = LLDPD_MODE_LLDP;\n\n\tlog_debug(\"decode\", \"decode a received frame on %s\",\n\t    hardware->h_ifname);\n\n\tif (s < sizeof(struct ether_header) + 4)\n\t\t/* Too short, just discard it */\n\t\treturn;\n\n\t/* Decapsulate VLAN frames */\n\tstruct ether_header eheader;\n\tmemcpy(&eheader, frame, sizeof(struct ether_header));\n\tif (eheader.ether_type == htons(ETHERTYPE_VLAN)) {\n\t\t/* VLAN decapsulation means to shift 4 bytes left the frame from\n\t\t * offset 2*ETHER_ADDR_LEN */\n\t\tmemmove(frame + 2*ETHER_ADDR_LEN, frame + 2*ETHER_ADDR_LEN + 4, s - 2*ETHER_ADDR_LEN);\n\t\ts -= 4;\n\t}\n\n\tTAILQ_FOREACH(oport, &hardware->h_rports, p_entries) {\n\t\tif ((oport->p_lastframe != NULL) &&\n\t\t    (oport->p_lastframe->size == s) &&\n\t\t    (memcmp(oport->p_lastframe->frame, frame, s) == 0)) {\n\t\t\t/* Already received the same frame */\n\t\t\tlog_debug(\"decode\", \"duplicate frame, no need to decode\");\n\t\t\toport->p_lastupdate = time(NULL);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tguess = lldpd_guess_type(cfg, frame, s);\n\tfor (i=0; cfg->g_protocols[i].mode != 0; i++) {\n\t\tif (!cfg->g_protocols[i].enabled)\n\t\t\tcontinue;\n\t\tif (cfg->g_protocols[i].mode == guess) {\n\t\t\tlog_debug(\"decode\", \"using decode function for %s protocol\",\n\t\t\t    cfg->g_protocols[i].name);\n\t\t\tif (cfg->g_protocols[i].decode(cfg, frame,\n\t\t\t\ts, hardware, &chassis, &port) == -1) {\n\t\t\t\tlog_debug(\"decode\", \"function for %s protocol did not decode this frame\",\n\t\t\t\t    cfg->g_protocols[i].name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchassis->c_protocol = port->p_protocol =\n\t\t\t    cfg->g_protocols[i].mode;\n\t\t\tbreak;\n\t\t\t}\n\t}\n\tif (cfg->g_protocols[i].mode == 0) {\n\t\tlog_debug(\"decode\", \"unable to guess frame type on %s\",\n\t\t    hardware->h_ifname);\n\t\treturn;\n\t}\n\tTRACE(LLDPD_FRAME_DECODED(\n\t\t    hardware->h_ifname,\n\t\t    cfg->g_protocols[i].name,\n\t\t    chassis->c_name,\n\t\t    port->p_descr));\n\n\t/* Do we already have the same MSAP somewhere? */\n\tint count = 0;\n\tlog_debug(\"decode\", \"search for the same MSAP\");\n\tTAILQ_FOREACH(oport, &hardware->h_rports, p_entries) {\n\t\tif (port->p_protocol == oport->p_protocol) {\n\t\t\tcount++;\n\t\t\tif ((port->p_id_subtype == oport->p_id_subtype) &&\n\t\t\t    (port->p_id_len == oport->p_id_len) &&\n\t\t\t    (memcmp(port->p_id, oport->p_id, port->p_id_len) == 0) &&\n\t\t\t    (chassis->c_id_subtype == oport->p_chassis->c_id_subtype) &&\n\t\t\t    (chassis->c_id_len == oport->p_chassis->c_id_len) &&\n\t\t\t    (memcmp(chassis->c_id, oport->p_chassis->c_id,\n\t\t\t\tchassis->c_id_len) == 0)) {\n\t\t\t\tochassis = oport->p_chassis;\n\t\t\t\tlog_debug(\"decode\", \"MSAP is already known\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* Do we have room for a new MSAP? */\n\tif (!oport && cfg->g_config.c_max_neighbors) {\n\t    if (count == (cfg->g_config.c_max_neighbors - 1)) {\n\t\tlog_debug(\"decode\",\n\t\t    \"max neighbors %d reached for port %s, \"\n\t\t    \"dropping any new ones silently\",\n\t\t    cfg->g_config.c_max_neighbors,\n\t\t    hardware->h_ifname);\n\t    } else if (count > cfg->g_config.c_max_neighbors - 1) {\n\t\tlog_debug(\"decode\",\n\t\t    \"too many neighbors for port %s, drop this new one\",\n\t\t    hardware->h_ifname);\n\t\tlldpd_port_cleanup(port, 1);\n\t\tlldpd_chassis_cleanup(chassis, 1);\n\t\tfree(port);\n\t\treturn;\n\t    }\n\t}\n\t/* No, but do we already know the system? */\n\tif (!oport) {\n\t\tlog_debug(\"decode\", \"MSAP is unknown, search for the chassis\");\n\t\tTAILQ_FOREACH(ochassis, &cfg->g_chassis, c_entries) {\n\t\t\tif ((chassis->c_protocol == ochassis->c_protocol) &&\n\t\t\t    (chassis->c_id_subtype == ochassis->c_id_subtype) &&\n\t\t\t    (chassis->c_id_len == ochassis->c_id_len) &&\n\t\t\t    (memcmp(chassis->c_id, ochassis->c_id,\n\t\t\t\tchassis->c_id_len) == 0))\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (oport) {\n\t\t/* The port is known, remove it before adding it back */\n\t\tTAILQ_REMOVE(&hardware->h_rports, oport, p_entries);\n\t\tlldpd_port_cleanup(oport, 1);\n\t\tfree(oport);\n\t}\n\tif (ochassis) {\n\t\tlldpd_move_chassis(ochassis, chassis);\n\t\tchassis = ochassis;\n\t} else {\n\t\t/* Chassis not known, add it */\n\t\tlog_debug(\"decode\", \"unknown chassis, add it to the list\");\n\t\tchassis->c_index = ++cfg->g_lastrid;\n\t\tchassis->c_refcount = 0;\n\t\tTAILQ_INSERT_TAIL(&cfg->g_chassis, chassis, c_entries);\n\t\ti = 0; TAILQ_FOREACH(ochassis, &cfg->g_chassis, c_entries) i++;\n\t\tlog_debug(\"decode\", \"%d different systems are known\", i);\n\t}\n\t/* Add port */\n\tport->p_lastchange = port->p_lastupdate = time(NULL);\n\tif ((port->p_lastframe = (struct lldpd_frame *)malloc(s +\n\t\t    sizeof(struct lldpd_frame))) != NULL) {\n\t\tport->p_lastframe->size = s;\n\t\tmemcpy(port->p_lastframe->frame, frame, s);\n\t}\n\tTAILQ_INSERT_TAIL(&hardware->h_rports, port, p_entries);\n\tport->p_chassis = chassis;\n\tport->p_chassis->c_refcount++;\n\t/* Several cases are possible :\n\t     1. chassis is new, its refcount was 0. It is now attached\n\t        to this port, its refcount is 1.\n\t     2. chassis already exists and was attached to another\n\t        port, we increase its refcount accordingly.\n\t     3. chassis already exists and was attached to the same\n\t        port, its refcount was decreased with\n\t        lldpd_port_cleanup() and is now increased again.\n\n\t   In all cases, if the port already existed, it has been\n\t   freed with lldpd_port_cleanup() and therefore, the refcount\n\t   of the chassis that was attached to it is decreased.\n\t*/\n\t/* coverity[use_after_free]\n\t   TAILQ_REMOVE does the right thing */\n\ti = 0; TAILQ_FOREACH(aport, &hardware->h_rports, p_entries)\n\t\ti++;\n\tlog_debug(\"decode\", \"%d neighbors for %s\", i,\n\t    hardware->h_ifname);\n\n\tif (!oport) hardware->h_insert_cnt++;\n\n\t/* Notify */\n\tlog_debug(\"decode\", \"send notifications for changes on %s\",\n\t    hardware->h_ifname);\n\tif (oport) {\n\t\tTRACE(LLDPD_NEIGHBOR_UPDATE(hardware->h_ifname,\n\t\t\tchassis->c_name,\n\t\t\tport->p_descr,\n\t\t\ti));\n\t\tlevent_ctl_notify(hardware->h_ifname, NEIGHBOR_CHANGE_UPDATED, port);\n#ifdef USE_SNMP\n\t\tagent_notify(hardware, NEIGHBOR_CHANGE_UPDATED, port);\n#endif\n\t} else {\n\t\tTRACE(LLDPD_NEIGHBOR_NEW(hardware->h_ifname,\n\t\t\tchassis->c_name,\n\t\t\tport->p_descr,\n\t\t\ti));\n\t\tlevent_ctl_notify(hardware->h_ifname, NEIGHBOR_CHANGE_ADDED, port);\n#ifdef USE_SNMP\n\t\tagent_notify(hardware, NEIGHBOR_CHANGE_ADDED, port);\n#endif\n\t}\n\n#ifdef ENABLE_LLDPMED\n\tif (!oport && port->p_chassis->c_med_type) {\n\t\t/* New neighbor, fast start */\n\t\tif (hardware->h_cfg->g_config.c_enable_fast_start &&\n\t\t    !hardware->h_tx_fast) {\n\t\t\tlog_debug(\"decode\", \"%s: entering fast start due to \"\n\t\t\t    \"new neighbor\", hardware->h_ifname);\n\t\t\thardware->h_tx_fast = hardware->h_cfg->g_config.c_tx_fast_init;\n\t\t}\n\n\t\tlevent_schedule_pdu(hardware);\n\t}\n#endif\n\n\treturn;\n}\n\n/* Get the output of lsb_release -s -d.  This is a slow function. It should be\n   called once. It return NULL if any problem happens. Otherwise, this is a\n   statically allocated buffer. The result includes the trailing \\n  */\nstatic char *\nlldpd_get_lsb_release() {\n\tstatic char release[1024];\n\tchar *const command[] = { \"lsb_release\", \"-s\", \"-d\", NULL };\n\tint pid, status, devnull, count;\n\tint pipefd[2];\n\n\tlog_debug(\"localchassis\", \"grab LSB release\");\n\n\tif (pipe(pipefd)) {\n\t\tlog_warn(\"localchassis\", \"unable to get a pair of pipes\");\n\t\treturn NULL;\n\t}\n\n\tpid = vfork();\n\tswitch (pid) {\n\tcase -1:\n\t\tlog_warn(\"localchassis\", \"unable to fork\");\n\t\treturn NULL;\n\tcase 0:\n\t\t/* Child, exec lsb_release */\n\t\tclose(pipefd[0]);\n\t\tif ((devnull = open(\"/dev/null\", O_RDWR, 0)) != -1) {\n\t\t\tdup2(devnull, STDIN_FILENO);\n\t\t\tdup2(devnull, STDERR_FILENO);\n\t\t\tdup2(pipefd[1], STDOUT_FILENO);\n\t\t\tif (devnull > 2) close(devnull);\n\t\t\tif (pipefd[1] > 2) close(pipefd[1]);\n\t\t\texecvp(\"lsb_release\", command);\n\t\t}\n\t\t_exit(127);\n\t\tbreak;\n\tdefault:\n\t\t/* Father, read the output from the children */\n\t\tclose(pipefd[1]);\n\t\tcount = 0;\n\t\tdo {\n\t\t\tstatus = read(pipefd[0], release+count, sizeof(release)-count);\n\t\t\tif ((status == -1) && (errno == EINTR)) continue;\n\t\t\tif (status > 0)\n\t\t\t\tcount += status;\n\t\t} while (count < sizeof(release) && (status > 0));\n\t\tif (status < 0) {\n\t\t\tlog_info(\"localchassis\", \"unable to read from lsb_release\");\n\t\t\tclose(pipefd[0]);\n\t\t\twaitpid(pid, &status, 0);\n\t\t\treturn NULL;\n\t\t}\n\t\tclose(pipefd[0]);\n\t\tif (count >= sizeof(release)) {\n\t\t\tlog_info(\"localchassis\", \"output of lsb_release is too large\");\n\t\t\twaitpid(pid, &status, 0);\n\t\t\treturn NULL;\n\t\t}\n\t\tstatus = -1;\n\t\tif (waitpid(pid, &status, 0) != pid)\n\t\t\treturn NULL;\n\t\tif (!WIFEXITED(status) || (WEXITSTATUS(status) != 0)) {\n\t\t\tlog_info(\"localchassis\", \"lsb_release information not available\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!count) {\n\t\t\tlog_info(\"localchassis\", \"lsb_release returned an empty string\");\n\t\t\treturn NULL;\n\t\t}\n\t\trelease[count] = '\\0';\n\t\treturn release;\n\t}\n\t/* Should not be here */\n\treturn NULL;\n}\n\n/* Same like lldpd_get_lsb_release but reads /etc/os-release for PRETTY_NAME=. */\nstatic char *\nlldpd_get_os_release() {\n\tstatic char release[1024];\n\tchar line[1024];\n\tchar *key, *val;\n\tchar *ptr1 = release;\n\n\tlog_debug(\"localchassis\", \"grab OS release\");\n\tFILE *fp = fopen(\"/etc/os-release\", \"r\");\n\tif (!fp) {\n\t\tlog_debug(\"localchassis\", \"could not open /etc/os-release\");\n\t\tfp = fopen(\"/usr/lib/os-release\", \"r\");\n\t}\n\tif (!fp) {\n\t\tlog_info(\"localchassis\",\n\t\t    \"could not open either /etc/os-release or /usr/lib/os-release\");\n\t\treturn NULL;\n\t}\n\n\twhile ((fgets(line, sizeof(line), fp) != NULL)) {\n\t\tkey = strtok(line, \"=\");\n\t\tval = strtok(NULL, \"=\");\n\n\t\tif (strncmp(key, \"PRETTY_NAME\", sizeof(line)) == 0) {\n\t\t\tstrlcpy(release, val, sizeof(line));\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(fp);\n\n\t/* Remove trailing newline and all \" in the string. */\n\tptr1 = release + strlen(release) - 1;\n\twhile (ptr1 != release &&\n\t    ((*ptr1 == '\"') || (*ptr1 == '\\n'))) {\n\t\t*ptr1 = '\\0';\n\t\tptr1--;\n\t}\n\tif (release[0] == '\"')\n\t\treturn release+1;\n\treturn release;\n}\n\nstatic void\nlldpd_hide_ports(struct lldpd *cfg, struct lldpd_hardware *hardware, int mask) {\n\tstruct lldpd_port *port;\n\tint protocols[LLDPD_MODE_MAX+1];\n\tchar buffer[256];\n\tint i, j, k, found;\n\tunsigned int min;\n\n\tlog_debug(\"smartfilter\", \"apply smart filter for port %s\",\n\t\thardware->h_ifname);\n\n\t/* Compute the number of occurrences of each protocol */\n\tfor (i = 0; i <= LLDPD_MODE_MAX; i++) protocols[i] = 0;\n\tTAILQ_FOREACH(port, &hardware->h_rports, p_entries)\n\t\tprotocols[port->p_protocol]++;\n\n\t/* Turn the protocols[] array into an array of\n\t   enabled/disabled protocols. 1 means enabled, 0\n\t   means disabled. */\n\tmin = (unsigned int)-1;\n\tfor (i = 0; i <= LLDPD_MODE_MAX; i++)\n\t\tif (protocols[i] && (protocols[i] < min))\n\t\t\tmin = protocols[i];\n\tfound = 0;\n\tfor (i = 0; i <= LLDPD_MODE_MAX; i++)\n\t\tif ((protocols[i] == min) && !found) {\n\t\t\t/* If we need a tie breaker, we take\n\t\t\t   the first protocol only */\n\t\t\tif (cfg->g_config.c_smart & mask &\n\t\t\t    (SMART_OUTGOING_ONE_PROTO | SMART_INCOMING_ONE_PROTO))\n\t\t\t\tfound = 1;\n\t\t\tprotocols[i] = 1;\n\t\t} else protocols[i] = 0;\n\n\t/* We set the p_hidden flag to 1 if the protocol is disabled */\n\tTAILQ_FOREACH(port, &hardware->h_rports, p_entries) {\n\t\tif (mask == SMART_OUTGOING)\n\t\t\tport->p_hidden_out = protocols[port->p_protocol]?0:1;\n\t\telse\n\t\t\tport->p_hidden_in = protocols[port->p_protocol]?0:1;\n\t}\n\n\t/* If we want only one neighbor, we take the first one */\n\tif (cfg->g_config.c_smart & mask &\n\t    (SMART_OUTGOING_ONE_NEIGH | SMART_INCOMING_ONE_NEIGH)) {\n\t\tfound = 0;\n\t\tTAILQ_FOREACH(port, &hardware->h_rports, p_entries) {\n\t\t\tif (mask == SMART_OUTGOING) {\n\t\t\t\tif (found) port->p_hidden_out = 1;\n\t\t\t\tif (!port->p_hidden_out)\n\t\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tif (mask == SMART_INCOMING) {\n\t\t\t\tif (found) port->p_hidden_in = 1;\n\t\t\t\tif (!port->p_hidden_in)\n\t\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Print a debug message summarizing the operation */\n\tfor (i = 0; i <= LLDPD_MODE_MAX; i++) protocols[i] = 0;\n\tk = j = 0;\n\tTAILQ_FOREACH(port, &hardware->h_rports, p_entries) {\n\t\tif (!(((mask == SMART_OUTGOING) && port->p_hidden_out) ||\n\t\t      ((mask == SMART_INCOMING) && port->p_hidden_in))) {\n\t\t\tk++;\n\t\t\tprotocols[port->p_protocol] = 1;\n\t\t}\n\t\tj++;\n\t}\n\tbuffer[0] = '\\0';\n\tfor (i=0; cfg->g_protocols[i].mode != 0; i++) {\n\t\tif (cfg->g_protocols[i].enabled && protocols[cfg->g_protocols[i].mode]) {\n\t\t\tif (strlen(buffer) +\n\t\t\t    strlen(cfg->g_protocols[i].name) + 3 > sizeof(buffer)) {\n\t\t\t\t/* Unlikely, our buffer is too small */\n\t\t\t\tmemcpy(buffer + sizeof(buffer) - 4, \"...\", 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (buffer[0])\n\t\t\t\tstrncat(buffer, \", \", 2);\n\t\t\tstrncat(buffer, cfg->g_protocols[i].name, strlen(cfg->g_protocols[i].name));\n\t\t}\n\t}\n\tlog_debug(\"smartfilter\", \"%s: %s: %d visible neighbors (out of %d)\",\n\t    hardware->h_ifname,\n\t    (mask == SMART_OUTGOING)?\"out filter\":\"in filter\",\n\t    k, j);\n\tlog_debug(\"smartfilter\", \"%s: protocols: %s\",\n\t    hardware->h_ifname, buffer[0]?buffer:\"(none)\");\n}\n\n/* Hide unwanted ports depending on smart mode set by the user */\nstatic void\nlldpd_hide_all(struct lldpd *cfg)\n{\n\tstruct lldpd_hardware *hardware;\n\n\tif (!cfg->g_config.c_smart)\n\t\treturn;\n\tlog_debug(\"smartfilter\", \"apply smart filter results on all ports\");\n\tTAILQ_FOREACH(hardware, &cfg->g_hardware, h_entries) {\n\t\tif (cfg->g_config.c_smart & SMART_INCOMING_FILTER)\n\t\t\tlldpd_hide_ports(cfg, hardware, SMART_INCOMING);\n\t\tif (cfg->g_config.c_smart & SMART_OUTGOING_FILTER)\n\t\t\tlldpd_hide_ports(cfg, hardware, SMART_OUTGOING);\n\t}\n}\n\nvoid\nlldpd_recv(struct lldpd *cfg, struct lldpd_hardware *hardware, int fd)\n{\n\tchar *buffer = NULL;\n\tint n;\n\tlog_debug(\"receive\", \"receive a frame on %s\",\n\t    hardware->h_ifname);\n\tif ((buffer = (char *)malloc(hardware->h_mtu)) == NULL) {\n\t\tlog_warn(\"receive\", \"failed to alloc reception buffer\");\n\t\treturn;\n\t}\n\tif ((n = hardware->h_ops->recv(cfg, hardware,\n\t\t    fd, buffer,\n\t\t    hardware->h_mtu)) == -1) {\n\t\tlog_debug(\"receive\", \"discard frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tfree(buffer);\n\t\treturn;\n\t}\n\tif (cfg->g_config.c_paused) {\n\t\tlog_debug(\"receive\", \"paused, ignore the frame on %s\",\n\t\t\thardware->h_ifname);\n\t\tfree(buffer);\n\t\treturn;\n\t}\n\thardware->h_rx_cnt++;\n\tlog_debug(\"receive\", \"decode received frame on %s\",\n\t    hardware->h_ifname);\n\tTRACE(LLDPD_FRAME_RECEIVED(hardware->h_ifname, buffer, (size_t)n));\n\tlldpd_decode(cfg, buffer, n, hardware);\n\tlldpd_hide_all(cfg); /* Immediatly hide */\n\tlldpd_count_neighbors(cfg);\n\tfree(buffer);\n}\n\nstatic void\nlldpd_send_shutdown(struct lldpd_hardware *hardware)\n{\n\tstruct lldpd *cfg = hardware->h_cfg;\n\tif (cfg->g_config.c_receiveonly || cfg->g_config.c_paused) return;\n\tif ((hardware->h_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\t/* It's safe to call `lldp_send_shutdown()` because shutdown LLDPU will\n\t * only be emitted if LLDP was sent on that port. */\n\tif (lldp_send_shutdown(hardware->h_cfg, hardware) != 0)\n\t\tlog_warnx(\"send\", \"unable to send shutdown LLDPDU on %s\",\n\t\t    hardware->h_ifname);\n}\n\nvoid\nlldpd_send(struct lldpd_hardware *hardware)\n{\n\tstruct lldpd *cfg = hardware->h_cfg;\n\tstruct lldpd_port *port;\n\tint i, sent;\n\n\tif (cfg->g_config.c_receiveonly || cfg->g_config.c_paused) return;\n\tif ((hardware->h_flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\tlog_debug(\"send\", \"send PDU on %s\", hardware->h_ifname);\n\tsent = 0;\n\tfor (i=0; cfg->g_protocols[i].mode != 0; i++) {\n\t\tif (!cfg->g_protocols[i].enabled)\n\t\t\tcontinue;\n\t\t/* We send only if we have at least one remote system\n\t\t * speaking this protocol or if the protocol is forced */\n\t\tif (cfg->g_protocols[i].enabled > 1) {\n\t\t\tcfg->g_protocols[i].send(cfg, hardware);\n\t\t\tsent++;\n\t\t\tcontinue;\n\t\t}\n\t\tTAILQ_FOREACH(port, &hardware->h_rports, p_entries) {\n\t\t\t/* If this remote port is disabled, we don't\n\t\t\t * consider it */\n\t\t\tif (port->p_hidden_out)\n\t\t\t\tcontinue;\n\t\t\tif (port->p_protocol ==\n\t\t\t    cfg->g_protocols[i].mode) {\n\t\t\t\tTRACE(LLDPD_FRAME_SEND(hardware->h_ifname,\n\t\t\t\t\tcfg->g_protocols[i].name));\n\t\t\t\tlog_debug(\"send\", \"send PDU on %s with protocol %s\",\n\t\t\t\t    hardware->h_ifname,\n\t\t\t\t    cfg->g_protocols[i].name);\n\t\t\t\tcfg->g_protocols[i].send(cfg,\n\t\t\t\t    hardware);\n\t\t\t\tsent++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!sent) {\n\t\t/* Nothing was sent for this port, let's speak the first\n\t\t * available protocol. */\n\t\tfor (i = 0; cfg->g_protocols[i].mode != 0; i++) {\n\t\t\tif (!cfg->g_protocols[i].enabled) continue;\n\t\t\tTRACE(LLDPD_FRAME_SEND(hardware->h_ifname,\n\t\t\t\tcfg->g_protocols[i].name));\n\t\t\tlog_debug(\"send\", \"fallback to protocol %s for %s\",\n\t\t\t    cfg->g_protocols[i].name, hardware->h_ifname);\n\t\t\tcfg->g_protocols[i].send(cfg,\n\t\t\t    hardware);\n\t\t\tbreak;\n\t\t}\n\t\tif (cfg->g_protocols[i].mode == 0)\n\t\t\tlog_warnx(\"send\", \"no protocol enabled, dunno what to send\");\n\t}\n}\n\n#ifdef ENABLE_LLDPMED\nstatic void\nlldpd_med(struct lldpd_chassis *chassis)\n{\n\tstatic short int once = 0;\n\tif (!once) {\n\t\tchassis->c_med_hw = dmi_hw();\n\t\tchassis->c_med_fw = dmi_fw();\n\t\tchassis->c_med_sn = dmi_sn();\n\t\tchassis->c_med_manuf = dmi_manuf();\n\t\tchassis->c_med_model = dmi_model();\n\t\tchassis->c_med_asset = dmi_asset();\n\t\tonce = 1;\n\t}\n}\n#endif\n\nstatic int\nlldpd_routing_enabled(struct lldpd *cfg)\n{\n\tint routing;\n\n\tif ((LOCAL_CHASSIS(cfg)->c_cap_available & LLDP_CAP_ROUTER) == 0)\n\t\treturn 0;\n\n\tif ((routing = interfaces_routing_enabled(cfg)) == -1) {\n\t\tlog_debug(\"localchassis\", \"unable to check if routing is enabled\");\n\t\treturn 0;\n\t}\n\treturn routing;\n}\n\nstatic void\nlldpd_update_localchassis(struct lldpd *cfg)\n{\n\tstruct utsname un;\n\tchar *hp;\n\n\tlog_debug(\"localchassis\", \"update information for local chassis\");\n\tassert(LOCAL_CHASSIS(cfg) != NULL);\n\n\t/* Set system name and description */\n\tif (uname(&un) < 0)\n\t\tfatal(\"localchassis\", \"failed to get system information\");\n\tif (cfg->g_config.c_hostname) {\n\t\tlog_debug(\"localchassis\", \"use overridden system name `%s`\", cfg->g_config.c_hostname);\n\t\thp = cfg->g_config.c_hostname;\n\t} else {\n\t\tif ((hp = priv_gethostname()) == NULL)\n\t\t\tfatal(\"localchassis\", \"failed to get system name\");\n\t}\n\tfree(LOCAL_CHASSIS(cfg)->c_name);\n\tfree(LOCAL_CHASSIS(cfg)->c_descr);\n\tif ((LOCAL_CHASSIS(cfg)->c_name = strdup(hp)) == NULL)\n\t\tfatal(\"localchassis\", NULL);\n        if (cfg->g_config.c_description) {\n\t\tlog_debug(\"localchassis\", \"use overridden description `%s`\", cfg->g_config.c_description);\n                if (asprintf(&LOCAL_CHASSIS(cfg)->c_descr, \"%s\",\n\t\t\tcfg->g_config.c_description) == -1)\n\t\t\tfatal(\"localchassis\", \"failed to set full system description\");\n        } else {\n\t        if (cfg->g_config.c_advertise_version) {\n\t\t\tlog_debug(\"localchassis\", \"advertise system version\");\n\t\t        if (asprintf(&LOCAL_CHASSIS(cfg)->c_descr, \"%s %s %s %s %s\",\n\t\t\t        cfg->g_lsb_release?cfg->g_lsb_release:\"\",\n\t\t\t\tun.sysname, un.release, un.version, un.machine)\n                                == -1)\n\t\t\t        fatal(\"localchassis\", \"failed to set full system description\");\n\t        } else {\n\t\t\tlog_debug(\"localchassis\", \"do not advertise system version\");\n\t\t        if (asprintf(&LOCAL_CHASSIS(cfg)->c_descr, \"%s\",\n                                cfg->g_lsb_release?cfg->g_lsb_release:un.sysname) == -1)\n\t\t\t        fatal(\"localchassis\", \"failed to set minimal system description\");\n\t        }\n        }\n\tif (cfg->g_config.c_platform == NULL)\n\t\tcfg->g_config.c_platform = strdup(un.sysname);\n\n\t/* Check routing */\n\tif (lldpd_routing_enabled(cfg)) {\n\t\tlog_debug(\"localchassis\", \"routing is enabled, enable router capability\");\n\t\tLOCAL_CHASSIS(cfg)->c_cap_enabled |= LLDP_CAP_ROUTER;\n\t} else\n\t\tLOCAL_CHASSIS(cfg)->c_cap_enabled &= ~LLDP_CAP_ROUTER;\n\n#ifdef ENABLE_LLDPMED\n\tif (LOCAL_CHASSIS(cfg)->c_cap_available & LLDP_CAP_TELEPHONE)\n\t\tLOCAL_CHASSIS(cfg)->c_cap_enabled |= LLDP_CAP_TELEPHONE;\n\tlldpd_med(LOCAL_CHASSIS(cfg));\n\tfree(LOCAL_CHASSIS(cfg)->c_med_sw);\n\tif (cfg->g_config.c_advertise_version)\n\t\tLOCAL_CHASSIS(cfg)->c_med_sw = strdup(un.release);\n\telse\n\t\tLOCAL_CHASSIS(cfg)->c_med_sw = strdup(\"Unknown\");\n#endif\n\tif ((LOCAL_CHASSIS(cfg)->c_cap_available & LLDP_CAP_STATION) &&\n\t\t(LOCAL_CHASSIS(cfg)->c_cap_enabled == 0))\n\t\tLOCAL_CHASSIS(cfg)->c_cap_enabled = LLDP_CAP_STATION;\n\n\t/* Set chassis ID if needed. This is only done if chassis ID\n\t   has not been set previously (with the MAC address of an\n\t   interface for example)\n\t*/\n\tif (LOCAL_CHASSIS(cfg)->c_id == NULL) {\n\t\tlog_debug(\"localchassis\", \"no chassis ID is currently set, use chassis name\");\n\t\tif (!(LOCAL_CHASSIS(cfg)->c_id = strdup(LOCAL_CHASSIS(cfg)->c_name)))\n\t\t\tfatal(\"localchassis\", NULL);\n\t\tLOCAL_CHASSIS(cfg)->c_id_len = strlen(LOCAL_CHASSIS(cfg)->c_name);\n\t\tLOCAL_CHASSIS(cfg)->c_id_subtype = LLDP_CHASSISID_SUBTYPE_LOCAL;\n\t}\n}\n\nvoid\nlldpd_update_localports(struct lldpd *cfg)\n{\n\tstruct lldpd_hardware *hardware;\n\n\tlog_debug(\"localchassis\", \"update information for local ports\");\n\n\t/* h_flags is set to 0 for each port. If the port is updated, h_flags\n\t * will be set to a non-zero value. This will allow us to clean up any\n\t * non up-to-date port */\n\tTAILQ_FOREACH(hardware, &cfg->g_hardware, h_entries)\n\t    hardware->h_flags = 0;\n\n\tTRACE(LLDPD_INTERFACES_UPDATE());\n\tinterfaces_update(cfg);\n\tlldpd_cleanup(cfg);\n\tlldpd_reset_timer(cfg);\n}\n\nvoid\nlldpd_loop(struct lldpd *cfg)\n{\n\t/* Main loop.\n\t   1. Update local ports information\n\t   2. Update local chassis information\n\t*/\n\tlog_debug(\"loop\", \"start new loop\");\n\tLOCAL_CHASSIS(cfg)->c_cap_enabled = 0;\n\t/* Information for local ports is triggered even when it is possible to\n\t * update them on some other event because we want to refresh them if we\n\t * missed something. */\n\tlog_debug(\"loop\", \"update information for local ports\");\n\tlldpd_update_localports(cfg);\n\tlog_debug(\"loop\", \"update information for local chassis\");\n\tlldpd_update_localchassis(cfg);\n\tlldpd_count_neighbors(cfg);\n}\n\nstatic void\nlldpd_exit(struct lldpd *cfg)\n{\n\tstruct lldpd_hardware *hardware, *hardware_next;\n\tlog_debug(\"main\", \"exit lldpd\");\n\n\tTAILQ_FOREACH(hardware, &cfg->g_hardware, h_entries)\n\t\tlldpd_send_shutdown(hardware);\n\n\tclose(cfg->g_ctl);\n\tpriv_ctl_cleanup(cfg->g_ctlname);\n\tlog_debug(\"main\", \"cleanup hardware information\");\n\tfor (hardware = TAILQ_FIRST(&cfg->g_hardware); hardware != NULL;\n\t     hardware = hardware_next) {\n\t\thardware_next = TAILQ_NEXT(hardware, h_entries);\n\t\tlog_debug(\"main\", \"cleanup interface %s\", hardware->h_ifname);\n\t\tlldpd_remote_cleanup(hardware, NULL, 1);\n\t\tlldpd_hardware_cleanup(cfg, hardware);\n\t}\n}\n\n/**\n * Run lldpcli to configure lldpd.\n *\n * @return PID of running lldpcli or -1 if error.\n */\nstatic pid_t\nlldpd_configure(int debug, const char *path, const char *ctlname)\n{\n\tpid_t lldpcli = vfork();\n\tint devnull;\n\n\tchar sdebug[debug + 3];\n\tmemset(sdebug, 'd', debug + 3);\n\tsdebug[debug + 2] = '\\0';\n\tsdebug[0] = '-'; sdebug[1] = 's';\n\tlog_debug(\"main\", \"invoke %s %s\", path, sdebug);\n\n\tswitch (lldpcli) {\n\tcase -1:\n\t\tlog_warn(\"main\", \"unable to fork\");\n\t\treturn -1;\n\tcase 0:\n\t\t/* Child, exec lldpcli */\n\t\tif ((devnull = open(\"/dev/null\", O_RDWR, 0)) != -1) {\n\t\t\tdup2(devnull,   STDIN_FILENO);\n\t\t\tdup2(devnull,   STDOUT_FILENO);\n\t\t\tif (devnull > 2) close(devnull);\n\n\t\t\texecl(path, \"lldpcli\", sdebug,\n\t\t\t    \"-u\", ctlname,\n\t\t\t    \"-c\", SYSCONFDIR \"/lldpd.conf\",\n\t\t\t    \"-c\", SYSCONFDIR \"/lldpd.d\",\n\t\t\t    \"resume\",\n\t\t\t    (char *)NULL);\n\t\t\tlog_warn(\"main\", \"unable to execute %s\", path);\n\t\t\tlog_warnx(\"main\", \"configuration is incomplete, lldpd needs to be unpaused\");\n\t\t}\n\t\t_exit(127);\n\t\tbreak;\n\tdefault:\n\t\t/* Father, don't do anything stupid */\n\t\treturn lldpcli;\n\t}\n\t/* Should not be here */\n\treturn -1;\n}\n\nstruct intint { int a; int b; };\nstatic const struct intint filters[] = {\n\t{  0, 0 },\n\t{  1, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_PROTO },\n\t{  2, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO },\n\t{  3, SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_PROTO },\n\t{  4, SMART_INCOMING_FILTER | SMART_OUTGOING_FILTER },\n\t{  5, SMART_INCOMING_FILTER },\n\t{  6, SMART_OUTGOING_FILTER },\n\t{  7, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO | SMART_INCOMING_ONE_NEIGH |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_PROTO },\n\t{  8, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO | SMART_INCOMING_ONE_NEIGH },\n\t{  9, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_NEIGH |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_PROTO },\n\t{ 10, SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_NEIGH },\n\t{ 11, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_NEIGH },\n\t{ 12, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_NEIGH |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_NEIGH },\n\t{ 13, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_NEIGH |\n\t      SMART_OUTGOING_FILTER },\n\t{ 14, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_NEIGH },\n\t{ 15, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO |\n\t      SMART_OUTGOING_FILTER },\n\t{ 16, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO | SMART_INCOMING_ONE_NEIGH |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_NEIGH },\n\t{ 17, SMART_INCOMING_FILTER | SMART_INCOMING_ONE_PROTO | SMART_INCOMING_ONE_NEIGH |\n\t      SMART_OUTGOING_FILTER },\n\t{ 18, SMART_INCOMING_FILTER |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_NEIGH },\n\t{ 19, SMART_INCOMING_FILTER |\n\t      SMART_OUTGOING_FILTER | SMART_OUTGOING_ONE_PROTO },\n\t{ -1, 0 }\n};\n\n#ifndef HOST_OS_OSX\n/**\n * Tell if we have been started by upstart.\n */\nstatic int\nlldpd_started_by_upstart()\n{\n#ifdef HOST_OS_LINUX\n\tconst char *upstartjob = getenv(\"UPSTART_JOB\");\n\tif (!(upstartjob && !strcmp(upstartjob, \"lldpd\")))\n\t\treturn 0;\n\tlog_debug(\"main\", \"running with upstart, don't fork but stop\");\n\traise(SIGSTOP);\n\tunsetenv(\"UPSTART_JOB\");\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\n/**\n * Tell if we have been started by systemd.\n */\nstatic int\nlldpd_started_by_systemd()\n{\n#ifdef HOST_OS_LINUX\n\tint fd = -1;\n\tconst char *notifysocket = getenv(\"NOTIFY_SOCKET\");\n\tif (!notifysocket ||\n\t    !strchr(\"@/\", notifysocket[0]) ||\n\t    strlen(notifysocket) < 2)\n\t\treturn 0;\n\n\tlog_debug(\"main\", \"running with systemd, don't fork but signal ready\");\n\tif ((fd = socket(AF_UNIX, SOCK_DGRAM, 0)) < 0) {\n\t\tlog_warn(\"main\", \"unable to open systemd notification socket %s\",\n\t\t    notifysocket);\n\t\treturn 0;\n\t}\n\n\tstruct sockaddr_un su = { .sun_family = AF_UNIX };\n\tstrlcpy(su.sun_path, notifysocket, sizeof(su.sun_path));\n\tif (notifysocket[0] == '@') su.sun_path[0] = 0;\n\n\tstruct iovec iov = {\n\t\t.iov_base = \"READY=1\",\n\t\t.iov_len = strlen(\"READY=1\")\n\t};\n\tstruct msghdr hdr = {\n\t\t.msg_name = &su,\n\t\t.msg_namelen = offsetof(struct sockaddr_un, sun_path) + strlen(notifysocket),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1\n\t};\n\tunsetenv(\"NOTIFY_SOCKET\");\n\tif (sendmsg(fd, &hdr, MSG_NOSIGNAL) < 0) {\n\t\tlog_warn(\"main\", \"unable to send notification to systemd\");\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tclose(fd);\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n#endif\n\nint\nlldpd_main(int argc, char *argv[], char *envp[])\n{\n\tstruct lldpd *cfg;\n\tstruct lldpd_chassis *lchassis;\n\tint ch, debug = 0;\n#ifdef USE_SNMP\n\tint snmp = 0;\n\tconst char *agentx = NULL;\t/* AgentX socket */\n#endif\n\tconst char *ctlname = NULL;\n\tchar *mgmtp = NULL;\n\tchar *cidp = NULL;\n\tchar *interfaces = NULL;\n\t/* We do not want more options here. Please add them in lldpcli instead\n\t * unless there is a very good reason. Most command-line options will\n\t * get deprecated at some point. */\n\tchar *popt, opts[] =\n\t\t\"H:vhkrdD:xX:m:u:4:6:I:C:p:M:P:S:iL:@                    \";\n\tint i, found, advertise_version = 1;\n#ifdef ENABLE_LLDPMED\n\tint lldpmed = 0, noinventory = 0;\n\tint enable_fast_start = 1;\n#endif\n\tchar *descr_override = NULL;\n\tchar *platform_override = NULL;\n\tchar *lsb_release = NULL;\n\tconst char *lldpcli = LLDPCLI_PATH;\n\tint smart = 15;\n\tint receiveonly = 0;\n\tint ctl;\n\n#ifdef ENABLE_PRIVSEP\n\t/* Non privileged user */\n\tstruct passwd *user;\n\tstruct group *group;\n\tuid_t uid;\n\tgid_t gid;\n#endif\n\n\tsaved_argv = argv;\n\n#if HAVE_SETPROCTITLE_INIT\n\tsetproctitle_init(argc, argv, envp);\n#endif\n\n\t/*\n\t * Get and parse command line options\n\t */\n\tif ((popt = strchr(opts, '@')) != NULL) {\n\t\tfor (i=0;\n\t\t     protos[i].mode != 0 && *popt != '\\0';\n\t\t     i++)\n\t\t\t*(popt++) = protos[i].arg;\n\t\t*popt = '\\0';\n\t}\n\twhile ((ch = getopt(argc, argv, opts)) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tfprintf(stdout, \"%s\\n\", PACKAGE_VERSION);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdebug++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tlog_accept(optarg);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\treceiveonly = 1;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (mgmtp) {\n\t\t\t\tfprintf(stderr, \"-m can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tmgmtp = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tif (ctlname) {\n\t\t\t\tfprintf(stderr, \"-u can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tctlname = optarg;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tif (interfaces) {\n\t\t\t\tfprintf(stderr, \"-I can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tinterfaces = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tif (cidp) {\n\t\t\t\tfprintf(stderr, \"-C can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tcidp = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif (strlen(optarg)) lldpcli = optarg;\n\t\t\telse lldpcli = NULL;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tadvertise_version = 0;\n\t\t\tbreak;\n#ifdef ENABLE_LLDPMED\n\t\tcase 'M':\n\t\t\tlldpmed = atoi(optarg);\n\t\t\tif ((lldpmed < 1) || (lldpmed > 4)) {\n\t\t\t\tfprintf(stderr, \"-M requires an argument between 1 and 4\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tnoinventory = 1;\n\t\t\tbreak;\n#else\n\t\tcase 'M':\n\t\tcase 'i':\n\t\t\tfprintf(stderr, \"LLDP-MED support is not built-in\\n\");\n\t\t\tusage();\n\t\t\tbreak;\n#endif\n#ifdef USE_SNMP\n\t\tcase 'x':\n\t\t\tsnmp = 1;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tif (agentx) {\n\t\t\t\tfprintf(stderr, \"-X can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tsnmp = 1;\n\t\t\tagentx = optarg;\n\t\t\tbreak;\n#else\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tfprintf(stderr, \"SNMP support is not built-in\\n\");\n\t\t\tusage();\n#endif\n\t\t\tbreak;\n                case 'S':\n\t\t\tif (descr_override) {\n\t\t\t\tfprintf(stderr, \"-S can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n                        descr_override = strdup(optarg);\n                        break;\n\t\tcase 'P':\n\t\t\tif (platform_override) {\n\t\t\t\tfprintf(stderr, \"-P can only be used once\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tplatform_override = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tsmart = atoi(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfound = 0;\n\t\t\tfor (i=0; protos[i].mode != 0; i++) {\n\t\t\t\tif (ch == protos[i].arg) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tprotos[i].enabled++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tusage();\n\t\t}\n\t}\n\n\tif (ctlname == NULL) ctlname = LLDPD_CTL_SOCKET;\n\n\t/* Set correct smart mode */\n\tfor (i=0; (filters[i].a != -1) && (filters[i].a != smart); i++);\n\tif (filters[i].a == -1) {\n\t\tfprintf(stderr, \"Incorrect mode for -H\\n\");\n\t\tusage();\n\t}\n\tsmart = filters[i].b;\n\n\tlog_init(debug, __progname);\n\ttzset();\t\t/* Get timezone info before chroot */\n\n\tlog_debug(\"main\", \"lldpd \" PACKAGE_VERSION \" starting...\");\n\n\t/* Grab uid and gid to use for priv sep */\n#ifdef ENABLE_PRIVSEP\n\tif ((user = getpwnam(PRIVSEP_USER)) == NULL)\n\t\tfatal(\"main\", \"no \" PRIVSEP_USER \" user for privilege separation\");\n\tuid = user->pw_uid;\n\tif ((group = getgrnam(PRIVSEP_GROUP)) == NULL)\n\t\tfatal(\"main\", \"no \" PRIVSEP_GROUP \" group for privilege separation\");\n\tgid = group->gr_gid;\n#endif\n\n\t/* Create and setup socket */\n\tint retry = 1;\n\tlog_debug(\"main\", \"creating control socket\");\n\twhile ((ctl = ctl_create(ctlname)) == -1) {\n\t\tif (retry-- && errno == EADDRINUSE) {\n\t\t\t/* Check if a daemon is really listening */\n\t\t\tint tfd;\n\t\t\tlog_info(\"main\", \"unable to create control socket because it already exists\");\n\t\t\tlog_info(\"main\", \"check if another instance is running\");\n\t\t\tif ((tfd = ctl_connect(ctlname)) != -1) {\n\t\t\t\t/* Another instance is running */\n\t\t\t\tclose(tfd);\n\t\t\t\tlog_warnx(\"main\", \"another instance is running, please stop it\");\n\t\t\t\tfatalx(\"main\", \"giving up\");\n\t\t\t} else if (errno == ECONNREFUSED) {\n\t\t\t\t/* Nobody is listening */\n\t\t\t\tlog_info(\"main\", \"old control socket is present, clean it\");\n\t\t\t\tctl_cleanup(ctlname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlog_warn(\"main\", \"cannot determine if another daemon is already running\");\n\t\t\tfatalx(\"main\", \"giving up\");\n\t\t}\n\t\tlog_warn(\"main\", \"unable to create control socket\");\n\t\tfatalx(\"main\", \"giving up\");\n\t}\n#ifdef ENABLE_PRIVSEP\n\tif (chown(ctlname, uid, gid) == -1)\n\t\tlog_warn(\"main\", \"unable to chown control socket\");\n\tif (chmod(ctlname,\n\t\tS_IRUSR | S_IWUSR | S_IXUSR |\n\t\tS_IRGRP | S_IWGRP | S_IXGRP) == -1)\n\t\tlog_warn(\"main\", \"unable to chmod control socket\");\n#endif\n\n\t/* Disable SIGPIPE */\n\tsignal(SIGPIPE, SIG_IGN);\n\n\t/* Disable SIGHUP, until handlers are installed */\n\tsignal(SIGHUP, SIG_IGN);\n\n\t/* Configuration with lldpcli */\n\tif (lldpcli) {\n\t\tlog_debug(\"main\", \"invoking lldpcli for configuration\");\n\t\tif (lldpd_configure(debug, lldpcli, ctlname) == -1)\n\t\t\tfatal(\"main\", \"unable to spawn lldpcli\");\n\t}\n\n\t/* Daemonization, unless started by upstart, systemd or launchd or debug */\n#ifndef HOST_OS_OSX\n\tif (!lldpd_started_by_upstart() && !lldpd_started_by_systemd() &&\n\t    !debug) {\n\t\tint pid;\n\t\tchar *spid;\n\t\tlog_debug(\"main\", \"daemonize\");\n\t\tif (daemon(0, 0) != 0)\n\t\t\tfatal(\"main\", \"failed to detach daemon\");\n\t\tif ((pid = open(LLDPD_PID_FILE,\n\t\t\t    O_TRUNC | O_CREAT | O_WRONLY, 0666)) == -1)\n\t\t\tfatal(\"main\", \"unable to open pid file \" LLDPD_PID_FILE);\n\t\tif (asprintf(&spid, \"%d\\n\", getpid()) == -1)\n\t\t\tfatal(\"main\", \"unable to create pid file \" LLDPD_PID_FILE);\n\t\tif (write(pid, spid, strlen(spid)) == -1)\n\t\t\tfatal(\"main\", \"unable to write pid file \" LLDPD_PID_FILE);\n\t\tfree(spid);\n\t\tclose(pid);\n\t}\n#endif\n\n\t/* Try to read system information from /etc/os-release if possible.\n\t   Fall back to lsb_release for compatibility. */\n\tlog_debug(\"main\", \"get OS/LSB release information\");\n\tlsb_release = lldpd_get_os_release();\n\tif (!lsb_release) {\n\t\tlsb_release = lldpd_get_lsb_release();\n\t}\n\n\tlog_debug(\"main\", \"initialize privilege separation\");\n#ifdef ENABLE_PRIVSEP\n\tpriv_init(PRIVSEP_CHROOT, ctl, uid, gid);\n#else\n\tpriv_init(PRIVSEP_CHROOT, ctl, 0, 0);\n#endif\n\n\t/* Initialization of global configuration */\n\tif ((cfg = (struct lldpd *)\n\t    calloc(1, sizeof(struct lldpd))) == NULL)\n\t\tfatal(\"main\", NULL);\n\n\tcfg->g_ctlname = ctlname;\n\tcfg->g_ctl = ctl;\n\tcfg->g_config.c_mgmt_pattern = mgmtp;\n\tcfg->g_config.c_cid_pattern = cidp;\n\tcfg->g_config.c_iface_pattern = interfaces;\n\tcfg->g_config.c_smart = smart;\n\tif (lldpcli)\n\t\tcfg->g_config.c_paused = 1;\n\tcfg->g_config.c_receiveonly = receiveonly;\n\tcfg->g_config.c_tx_interval = LLDPD_TX_INTERVAL;\n\tcfg->g_config.c_tx_hold = LLDPD_TX_HOLD;\n\tcfg->g_config.c_max_neighbors = LLDPD_MAX_NEIGHBORS;\n#ifdef ENABLE_LLDPMED\n\tcfg->g_config.c_enable_fast_start = enable_fast_start;\n\tcfg->g_config.c_tx_fast_init = LLDPD_FAST_INIT;\n\tcfg->g_config.c_tx_fast_interval = LLDPD_FAST_TX_INTERVAL;\n#endif\n#ifdef USE_SNMP\n\tcfg->g_snmp = snmp;\n\tcfg->g_snmp_agentx = agentx;\n#endif /* USE_SNMP */\n\tcfg->g_config.c_bond_slave_src_mac_type = \\\n\t    LLDP_BOND_SLAVE_SRC_MAC_TYPE_LOCALLY_ADMINISTERED;\n\n\t/* Get ioctl socket */\n\tlog_debug(\"main\", \"get an ioctl socket\");\n\tif ((cfg->g_sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)\n\t\tfatal(\"main\", \"failed to get ioctl socket\");\n\n\t/* Description */\n\tif (!(cfg->g_config.c_advertise_version = advertise_version) &&\n\t    lsb_release && lsb_release[strlen(lsb_release) - 1] == '\\n')\n\t\tlsb_release[strlen(lsb_release) - 1] = '\\0';\n\tcfg->g_lsb_release = lsb_release;\n        if (descr_override)\n           cfg->g_config.c_description = descr_override;\n\n\tif (platform_override)\n\t\tcfg->g_config.c_platform = platform_override;\n\n\t/* Set system capabilities */\n\tlog_debug(\"main\", \"set system capabilities\");\n\tif ((lchassis = (struct lldpd_chassis*)\n\t\tcalloc(1, sizeof(struct lldpd_chassis))) == NULL)\n\t\tfatal(\"localchassis\", NULL);\n\tcfg->g_config.c_cap_advertise = 1;\n\tlchassis->c_cap_available = LLDP_CAP_BRIDGE | LLDP_CAP_WLAN |\n\t    LLDP_CAP_ROUTER | LLDP_CAP_STATION;\n\tcfg->g_config.c_mgmt_advertise = 1;\n\tTAILQ_INIT(&lchassis->c_mgmt);\n#ifdef ENABLE_LLDPMED\n\tif (lldpmed > 0) {\n\t\tif (lldpmed == LLDP_MED_CLASS_III)\n\t\t\tlchassis->c_cap_available |= LLDP_CAP_TELEPHONE;\n\t\tlchassis->c_med_type = lldpmed;\n\t\tlchassis->c_med_cap_available = LLDP_MED_CAP_CAP |\n\t\t    LLDP_MED_CAP_IV | LLDP_MED_CAP_LOCATION |\n\t\t    LLDP_MED_CAP_POLICY | LLDP_MED_CAP_MDI_PSE | LLDP_MED_CAP_MDI_PD;\n\t\tcfg->g_config.c_noinventory = noinventory;\n\t} else\n\t\tcfg->g_config.c_noinventory = 1;\n#endif\n\n\t/* Set TTL */\n\tlchassis->c_ttl = cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold;\n\n\tlog_debug(\"main\", \"initialize protocols\");\n\tcfg->g_protocols = protos;\n\tfor (i=0; protos[i].mode != 0; i++) {\n\n\t\t/* With -ll, disable LLDP */\n\t\tif (protos[i].mode == LLDPD_MODE_LLDP)\n\t\t\tprotos[i].enabled %= 3;\n\t\t/* With -ccc force CDPV2, enable CDPV1 */\n\t\tif (protos[i].mode == LLDPD_MODE_CDPV1 && protos[i].enabled == 3) {\n\t\t\tprotos[i].enabled = 1;\n\t\t}\n\t\t/* With -cc force CDPV1, enable CDPV2 */\n\t\tif (protos[i].mode == LLDPD_MODE_CDPV2 && protos[i].enabled == 2) {\n\t\t\tprotos[i].enabled = 1;\n\t\t}\n\n\t\t/* With -cccc disable CDPV1, enable CDPV2 */\n\t\tif (protos[i].mode == LLDPD_MODE_CDPV1 && protos[i].enabled >= 4) {\n\t\t\tprotos[i].enabled = 0;\n\t\t}\n\n\t\t/* With -cccc disable CDPV1, enable CDPV2; -ccccc will force CDPv2 */\n\t\tif (protos[i].mode == LLDPD_MODE_CDPV2 && protos[i].enabled == 4) {\n\t\t\tprotos[i].enabled = 1;\n\t\t}\n\n\t\tif (protos[i].enabled > 1)\n\t\t\tlog_info(\"main\", \"protocol %s enabled and forced\", protos[i].name);\n\t\telse if (protos[i].enabled)\n\t\t\tlog_info(\"main\", \"protocol %s enabled\", protos[i].name);\n\t\telse\n\t\t\tlog_info(\"main\", \"protocol %s disabled\", protos[i].name);\n\t    }\n\n\tTAILQ_INIT(&cfg->g_hardware);\n\tTAILQ_INIT(&cfg->g_chassis);\n\tTAILQ_INSERT_TAIL(&cfg->g_chassis, lchassis, c_entries);\n\tlchassis->c_refcount++; /* We should always keep a reference to local chassis */\n\n\t/* Main loop */\n\tlog_debug(\"main\", \"start main loop\");\n\tlevent_loop(cfg);\n\tlldpd_exit(cfg);\n\tfree(cfg);\n\n\treturn (0);\n}\n", "/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/* We also supports FDP which is very similar to CDPv1 */\n#include \"lldpd.h\"\n#include \"frame.h\"\n\n#if defined (ENABLE_CDP) || defined (ENABLE_FDP)\n\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa/inet.h>\n\nstatic int\ncdp_send(struct lldpd *global,\n\t struct lldpd_hardware *hardware, int version)\n{\n\tconst char *platform = \"Unknown\";\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_mgmt *mgmt;\n\tstruct lldpd_port *port;\n\tu_int8_t mcastaddr[] = CDP_MULTICAST_ADDR;\n\tu_int8_t llcorg[] = LLC_ORG_CISCO;\n#ifdef ENABLE_FDP\n\tchar *capstr;\n#endif\n\tu_int16_t checksum;\n\tint length, i;\n\tu_int32_t cap;\n\tu_int8_t *packet;\n\tu_int8_t *pos, *pos_len_eh, *pos_llc, *pos_cdp, *pos_checksum, *tlv, *end;\n\n\tlog_debug(\"cdp\", \"send CDP frame on %s\", hardware->h_ifname);\n\n\tport = &(hardware->h_lport);\n\tchassis = port->p_chassis;\n\n#ifdef ENABLE_FDP\n\tif (version == 0) {\n\t\t/* With FDP, change multicast address and LLC PID */\n\t\tconst u_int8_t fdpmcastaddr[] = FDP_MULTICAST_ADDR;\n\t\tconst u_int8_t fdpllcorg[] = LLC_ORG_FOUNDRY;\n\t\tmemcpy(mcastaddr, fdpmcastaddr, sizeof(mcastaddr));\n\t\tmemcpy(llcorg, fdpllcorg, sizeof(llcorg));\n\t}\n#endif\n\n\tlength = hardware->h_mtu;\n\tif ((packet = (u_int8_t*)calloc(1, length)) == NULL)\n\t\treturn ENOMEM;\n\tpos = packet;\n\n\t/* Ethernet header */\n\tif (!(\n\t      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t      POKE_SAVE(pos_len_eh) && /* We compute the len later */\n\t      POKE_UINT16(0)))\n\t\tgoto toobig;\n\n\t/* LLC */\n\tif (!(\n\t      POKE_SAVE(pos_llc) &&\n\t      POKE_UINT8(0xaa) && /* SSAP */\n\t      POKE_UINT8(0xaa) && /* DSAP */\n\t      POKE_UINT8(0x03) && /* Control field */\n\t      POKE_BYTES(llcorg, sizeof(llcorg)) &&\n\t      POKE_UINT16(LLC_PID_CDP)))\n\t\tgoto toobig;\n\n\t/* CDP header */\n\tif (!(\n\t      POKE_SAVE(pos_cdp) &&\n\t      POKE_UINT8((version == 0)?1:version) &&\n\t      POKE_UINT8(chassis->c_ttl) &&\n\t      POKE_SAVE(pos_checksum) && /* Save checksum position */\n\t      POKE_UINT16(0)))\n\t\tgoto toobig;\n\n\t/* Chassis ID */\n\tif (!(\n\t      POKE_START_CDP_TLV(CDP_TLV_CHASSIS) &&\n\t      (chassis->c_name?\n\t\t  POKE_BYTES(chassis->c_name, strlen(chassis->c_name)):\n\t\t  POKE_BYTES(\"\", 0)) &&\n\t      POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n\t/* Adresses */\n\t/* See:\n\t *   http://www.cisco.com/univercd/cc/td/doc/product/lan/trsrb/frames.htm#xtocid12\n\t *\n\t * It seems that Cisco implies that CDP supports IPv6 using\n\t * 802.2 address format with 0xAAAA03 0x000000 0x0800, but\n\t * 0x0800 is the Ethernet protocol type for IPv4. Therefore,\n\t * we support only IPv4. */\n\ti = 0;\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries)\n\t\tif (mgmt->m_family == LLDPD_AF_IPV4) i++;\n\tif (i > 0) {\n\t\tif (!(\n\t\t      POKE_START_CDP_TLV(CDP_TLV_ADDRESSES) &&\n\t\t      POKE_UINT32(i)))\n\t\t\tgoto toobig;\n\t\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\t\tswitch (mgmt->m_family) {\n\t\t\tcase LLDPD_AF_IPV4:\n\t\t\t\tif (!(\n\t\t\t\t      POKE_UINT8(1) &&\t/* Type: NLPID */\n\t\t\t\t      POKE_UINT8(1) &&  /* Length: 1 */\n\t\t\t\t      POKE_UINT8(CDP_ADDRESS_PROTO_IP) && /* IP */\n\t\t\t\t      POKE_UINT16(sizeof(struct in_addr)) && /* Address length */\n\t\t\t\t      POKE_BYTES(&mgmt->m_addr, sizeof(struct in_addr))))\n\t\t\t\t\tgoto toobig;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!(POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Port ID */\n\tif (!(\n\t      POKE_START_CDP_TLV(CDP_TLV_PORT) &&\n\t      (hardware->h_lport.p_descr?\n\t\t  POKE_BYTES(hardware->h_lport.p_descr,\n\t\t      strlen(hardware->h_lport.p_descr)):\n\t\t  POKE_BYTES(\"\", 0)) &&\n\t      POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n\t/* Capabilities */\n\tif (version != 0) {\n\t\tcap = 0;\n\t\tif (chassis->c_cap_enabled & LLDP_CAP_ROUTER)\n\t\t\tcap |= CDP_CAP_ROUTER;\n\t\tif (chassis->c_cap_enabled & LLDP_CAP_BRIDGE)\n\t\t\tcap |= CDP_CAP_SWITCH;\n\t\tcap |= CDP_CAP_HOST;\n\t\tif (!(\n\t\t      POKE_START_CDP_TLV(CDP_TLV_CAPABILITIES) &&\n\t\t      POKE_UINT32(cap) &&\n\t\t      POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n#ifdef ENABLE_FDP\n\t} else {\n\t\t/* With FDP, it seems that a string is used in place of an int */\n\t\tif (chassis->c_cap_enabled & LLDP_CAP_ROUTER)\n\t\t\tcapstr = \"Router\";\n\t\telse if (chassis->c_cap_enabled & LLDP_CAP_BRIDGE)\n\t\t\tcapstr = \"Switch\";\n\t\telse if (chassis->c_cap_enabled & LLDP_CAP_REPEATER)\n\t\t\tcapstr = \"Bridge\";\n\t\telse\n\t\t\tcapstr = \"Host\";\n\t\tif (!(\n\t\t      POKE_START_CDP_TLV(CDP_TLV_CAPABILITIES) &&\n\t\t      POKE_BYTES(capstr, strlen(capstr)) &&\n\t\t      POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n#endif\n\t}\n\n\t/* Native VLAN */\n#ifdef ENABLE_DOT1\n\tif (version >=2 && hardware->h_lport.p_pvid != 0) {\n\t\tif (!(\n\t\t      POKE_START_CDP_TLV(CDP_TLV_NATIVEVLAN) &&\n\t\t      POKE_UINT16(hardware->h_lport.p_pvid) &&\n\t\t      POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n\t/* Software version */\n\tif (!(\n\t      POKE_START_CDP_TLV(CDP_TLV_SOFTWARE) &&\n\t      (chassis->c_descr?\n\t\t  POKE_BYTES(chassis->c_descr, strlen(chassis->c_descr)):\n\t\t  POKE_BYTES(\"\", 0)) &&\n\t      POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n\t/* Platform */\n\tif (global && global->g_config.c_platform) platform = global->g_config.c_platform;\n\n\tif (!(\n\t      POKE_START_CDP_TLV(CDP_TLV_PLATFORM) &&\n\t      POKE_BYTES(platform, strlen(platform)) &&\n\t      POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n#ifdef ENABLE_LLDPMED\n\t/* Power use */\n\tif ((version >= 2) &&\n\t    port->p_med_cap_enabled &&\n\t    (port->p_med_power.source != LLDP_MED_POW_SOURCE_LOCAL) &&\n\t    (port->p_med_power.val > 0) &&\n\t    (port->p_med_power.val <= 655)) {\n\t\tif (!(\n\t\t      POKE_START_CDP_TLV(CDP_TLV_POWER_CONSUMPTION) &&\n\t\t      POKE_UINT16(port->p_med_power.val * 100) &&\n\t\t      POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\t(void)POKE_SAVE(end);\n\n\t/* Compute len and checksum */\n\tPOKE_RESTORE(pos_len_eh);\n\tif (!(POKE_UINT16(end - pos_llc))) goto toobig;\n\tchecksum = frame_checksum(pos_cdp, end - pos_cdp, (version != 0) ? 1 : 0);\n\tPOKE_RESTORE(pos_checksum);\n\tif (!(POKE_UINT16(checksum))) goto toobig;\n\n\tif (interfaces_send_helper(global, hardware,\n\t\t(char *)packet, end - packet) == -1) {\n\t\tlog_warn(\"cdp\", \"unable to send packet on real device for %s\",\n\t\t\t   hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\thardware->h_tx_cnt++;\n\n\tfree(packet);\n\treturn 0;\n toobig:\n\tfree(packet);\n\treturn -1;\n}\n\n#define CHECK_TLV_SIZE(x, name)\t\t\t\t   \\\n\tdo { if (tlv_len < (x)) {\t\t\t   \\\n\t\tlog_warnx(\"cdp\", name \" CDP/FDP TLV too short received on %s\", \\\n\t       hardware->h_ifname);\t\t\t   \\\n\t   goto malformed;\t\t\t\t   \\\n\t} } while (0)\n/* cdp_decode also decodes FDP */\nint\ncdp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tstruct lldpd_mgmt *mgmt;\n\tstruct in_addr addr;\n#if 0\n\tu_int16_t cksum;\n#endif\n\tu_int8_t *software = NULL, *platform = NULL;\n\tint software_len = 0, platform_len = 0, proto, version, nb, caps;\n\tconst unsigned char cdpaddr[] = CDP_MULTICAST_ADDR;\n#ifdef ENABLE_FDP\n\tconst unsigned char fdpaddr[] = CDP_MULTICAST_ADDR;\n\tint fdp = 0;\n#endif\n\tu_int8_t *pos, *tlv, *pos_address, *pos_next_address;\n\tint length, len_eth, tlv_type, tlv_len, addresses_len, address_len;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan;\n#endif\n\n\tlog_debug(\"cdp\", \"decode CDP frame received on %s\",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"cdp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"cdp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t) /* Ethernet */ +\n\t    8 /* LLC */ + 4 /* CDP header */) {\n\t\tlog_warn(\"cdp\", \"too short CDP/FDP frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tif (PEEK_CMP(cdpaddr, sizeof(cdpaddr)) != 0) {\n#ifdef ENABLE_FDP\n\t\tPEEK_RESTORE((u_int8_t*)frame);\n\t\tif (PEEK_CMP(fdpaddr, sizeof(fdpaddr)) != 0)\n\t\t\tfdp = 1;\n\t\telse {\n#endif\n\t\t\tlog_info(\"cdp\", \"frame not targeted at CDP/FDP multicast address received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n#ifdef ENABLE_FDP\n\t\t}\n#endif\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\t/* Don't care of source address */\n\tlen_eth = PEEK_UINT16;\n\tif (len_eth > length) {\n\t\tlog_warnx(\"cdp\", \"incorrect 802.3 frame size reported on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(6);\t/* Skip beginning of LLC */\n\tproto = PEEK_UINT16;\n\tif (proto != LLC_PID_CDP) {\n\t\tif ((proto != LLC_PID_DRIP) &&\n\t\t    (proto != LLC_PID_PAGP) &&\n\t\t    (proto != LLC_PID_PVSTP) &&\n\t\t    (proto != LLC_PID_UDLD) &&\n\t\t    (proto != LLC_PID_VTP) &&\n\t\t    (proto != LLC_PID_DTP) &&\n\t\t    (proto != LLC_PID_STP))\n\t\t\tlog_debug(\"cdp\", \"incorrect LLC protocol ID received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n#if 0\n\t/* Check checksum */\n\tcksum = frame_checksum(pos, len_eth - 8,\n#ifdef ENABLE_FDP\n\t    !fdp\t\t/* fdp = 0 -> cisco checksum */\n#else\n\t    1\t\t\t/* cisco checksum */\n#endif\n\t\t);\n\tif (cksum != 0) {\n\t\tlog_info(\"cdp\", \"incorrect CDP/FDP checksum for frame received on %s (%d)\",\n\t\t\t  hardware->h_ifname, cksum);\n\t\tgoto malformed;\n\t}\n#endif\n\n\t/* Check version */\n\tversion = PEEK_UINT8;\n\tif ((version != 1) && (version != 2)) {\n\t\tlog_warnx(\"cdp\", \"incorrect CDP/FDP version (%d) for frame received on %s\",\n\t\t    version, hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_ttl = PEEK_UINT8; /* TTL */\n\tPEEK_DISCARD_UINT16;\t     /* Checksum, already checked */\n\n\twhile (length) {\n\t\tif (length < 4) {\n\t\t\tlog_warnx(\"cdp\", \"CDP/FDP TLV header is too large for \"\n\t\t\t    \"frame received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_type = PEEK_UINT16;\n\t\ttlv_len = PEEK_UINT16 - 4;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif ((tlv_len < 0) || (length < tlv_len)) {\n\t\t\tlog_warnx(\"cdp\", \"incorrect size in CDP/FDP TLV header for frame \"\n\t\t\t    \"received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase CDP_TLV_CHASSIS:\n\t\t\tif ((chassis->c_name = (char *)calloc(1, tlv_len + 1)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for chassis name\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(chassis->c_name, tlv_len);\n\t\t\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_LOCAL;\n\t\t\tif ((chassis->c_id =  (char *)malloc(tlv_len)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for chassis ID\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tmemcpy(chassis->c_id, chassis->c_name, tlv_len);\n\t\t\tchassis->c_id_len = tlv_len;\n\t\t\tbreak;\n\t\tcase CDP_TLV_ADDRESSES:\n\t\t\tCHECK_TLV_SIZE(4, \"Address\");\n\t\t\taddresses_len = tlv_len - 4;\n\t\t\tfor (nb = PEEK_UINT32; nb > 0; nb--) {\n\t\t\t\t(void)PEEK_SAVE(pos_address);\n\t\t\t\t/* We first try to get the real length of the packet */\n\t\t\t\tif (addresses_len < 2) {\n\t\t\t\t\tlog_warn(\"cdp\", \"too short address subframe \"\n\t\t\t\t\t\t  \"received on %s\",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD_UINT8; addresses_len--;\n\t\t\t\taddress_len = PEEK_UINT8; addresses_len--;\n\t\t\t\tif (addresses_len < address_len + 2) {\n\t\t\t\t\tlog_warn(\"cdp\", \"too short address subframe \"\n\t\t\t\t\t\t  \"received on %s\",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\taddresses_len -= address_len;\n\t\t\t\taddress_len = PEEK_UINT16; addresses_len -= 2;\n\t\t\t\tif (addresses_len < address_len) {\n\t\t\t\t\tlog_warn(\"cdp\", \"too short address subframe \"\n\t\t\t\t\t\t  \"received on %s\",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\t(void)PEEK_SAVE(pos_next_address);\n\t\t\t\t/* Next, we go back and try to extract\n\t\t\t\t   IPv4 address */\n\t\t\t\tPEEK_RESTORE(pos_address);\n\t\t\t\tif ((PEEK_UINT8 == 1) && (PEEK_UINT8 == 1) &&\n\t\t\t\t    (PEEK_UINT8 == CDP_ADDRESS_PROTO_IP) &&\n\t\t\t\t    (PEEK_UINT16 == sizeof(struct in_addr))) {\n\t\t\t\t\t\tPEEK_BYTES(&addr, sizeof(struct in_addr));\n\t\t\t\t\t\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &addr, \n\t\t\t\t\t\t\t\t\tsizeof(struct in_addr), 0);\n\t\t\t\t\t\tif (mgmt == NULL) {\n\t\t\t\t\t\t\tif (errno == ENOMEM)\n\t\t\t\t\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t\t\t\t\t    \"unable to allocate memory for management address\");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t\t\t\t\t    \"too large management address received on %s\",\n\t\t\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\t\t}\n\t\t\t\t/* Go to the end of the address */\n\t\t\t\tPEEK_RESTORE(pos_next_address);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CDP_TLV_PORT:\n\t\t\tif (tlv_len == 0) {\n\t\t\t\tlog_warn(\"cd[\", \"too short port description received\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif ((port->p_descr = (char *)calloc(1, tlv_len + 1)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for port description\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(port->p_descr, tlv_len);\n\t\t\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;\n\t\t\tif ((port->p_id =  (char *)calloc(1, tlv_len)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for port ID\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tmemcpy(port->p_id, port->p_descr, tlv_len);\n\t\t\tport->p_id_len = tlv_len;\n\t\t\tbreak;\n\t\tcase CDP_TLV_CAPABILITIES:\n#ifdef ENABLE_FDP\n\t\t\tif (fdp) {\n\t\t\t\t/* Capabilities are string with FDP */\n\t\t\t\tif (!strncmp(\"Router\", (char*)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_ROUTER;\n\t\t\t\telse if (!strncmp(\"Switch\", (char*)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_BRIDGE;\n\t\t\t\telse if (!strncmp(\"Bridge\", (char*)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_REPEATER;\n\t\t\t\telse\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_STATION;\n\t\t\t\tchassis->c_cap_available = chassis->c_cap_enabled;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tCHECK_TLV_SIZE(4, \"Capabilities\");\n\t\t\tcaps = PEEK_UINT32;\n\t\t\tif (caps & CDP_CAP_ROUTER)\n\t\t\t\tchassis->c_cap_enabled |= LLDP_CAP_ROUTER;\n\t\t\tif (caps & 0x0e)\n\t\t\t\tchassis->c_cap_enabled |= LLDP_CAP_BRIDGE;\n\t\t\tif (chassis->c_cap_enabled == 0)\n\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_STATION;\n\t\t\tchassis->c_cap_available = chassis->c_cap_enabled;\n\t\t\tbreak;\n\t\tcase CDP_TLV_SOFTWARE:\n\t\t\tsoftware_len = tlv_len;\n\t\t\t(void)PEEK_SAVE(software);\n\t\t\tbreak;\n\t\tcase CDP_TLV_PLATFORM:\n\t\t\tplatform_len = tlv_len;\n\t\t\t(void)PEEK_SAVE(platform);\n\t\t\tbreak;\n#ifdef ENABLE_DOT1\n\t\tcase CDP_TLV_NATIVEVLAN:\n\t\t\tCHECK_TLV_SIZE(2, \"Native VLAN\");\n\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\tsizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\tlog_warn(\"cdp\", \"unable to alloc vlan \"\n\t\t\t\t\t  \"structure for \"\n\t\t\t\t\t  \"tlv received on %s\",\n\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tvlan->v_vid = port->p_pvid = PEEK_UINT16;\n\t\t\tif (asprintf(&vlan->v_name, \"VLAN #%d\", vlan->v_vid) == -1) {\n\t\t\t\tlog_warn(\"cdp\", \"unable to alloc VLAN name for \"\n\t\t\t\t\t  \"TLV received on %s\",\n\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\tfree(vlan);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t\t\t  vlan, v_entries);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tlog_debug(\"cdp\", \"unknown CDP/FDP TLV type (%d) received on %s\",\n\t\t\t    ntohs(tlv_type), hardware->h_ifname);\n\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_len - pos);\n\t}\n\tif (!software && platform) {\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t    platform_len + 1)) == NULL) {\n\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for chassis description\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, platform, platform_len);\n\t} else if (software && !platform) {\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t    software_len + 1)) == NULL) {\n\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for chassis description\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, software, software_len);\n\t} else if (software && platform) {\n#define CONCAT_PLATFORM \" running on\\n\"\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t    software_len + platform_len +\n\t\t\t    strlen(CONCAT_PLATFORM) + 1)) == NULL) {\n\t\t\tlog_warn(\"cdp\", \"unable to allocate memory for chassis description\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, platform, platform_len);\n\t\tmemcpy(chassis->c_descr + platform_len,\n\t\t    CONCAT_PLATFORM, strlen(CONCAT_PLATFORM));\n\t\tmemcpy(chassis->c_descr + platform_len + strlen(CONCAT_PLATFORM),\n\t\t    software, software_len);\n\t}\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (chassis->c_name == NULL) ||\n\t    (chassis->c_descr == NULL) ||\n\t    (port->p_descr == NULL) ||\n\t    (chassis->c_ttl == 0) ||\n\t    (chassis->c_cap_enabled == 0)) {\n\t\tlog_warnx(\"cdp\", \"some mandatory CDP/FDP tlv are missing for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}\n\n#ifdef ENABLE_CDP\nint\ncdpv1_send(struct lldpd *global,\n    struct lldpd_hardware *hardware)\n{\n\treturn cdp_send(global, hardware, 1);\n}\n\nint\ncdpv2_send(struct lldpd *global,\n    struct lldpd_hardware *hardware)\n{\n\treturn cdp_send(global, hardware, 2);\n}\n#endif\n\n#ifdef ENABLE_FDP\nint\nfdp_send(struct lldpd *global,\n    struct lldpd_hardware *hardware)\n{\n\treturn cdp_send(global, hardware, 0);\n}\n#endif\n\n#ifdef ENABLE_CDP\nstatic int\ncdp_guess(char *pos, int length, int version)\n{\n\tconst u_int8_t mcastaddr[] = CDP_MULTICAST_ADDR;\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t) /* Ethernet */ +\n\t    8 /* LLC */ + 4 /* CDP header */)\n\t\treturn 0;\n\tif (PEEK_CMP(mcastaddr, ETHER_ADDR_LEN) != 0)\n\t\treturn 0;\n\tPEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16; /* Ethernet */\n\tPEEK_DISCARD(8);\t\t\t     /* LLC */\n\treturn (PEEK_UINT8 == version);\n}\n\nint\ncdpv1_guess(char *frame, int len)\n{\n\treturn cdp_guess(frame, len, 1);\n}\n\nint\ncdpv2_guess(char *frame, int len)\n{\n\treturn cdp_guess(frame, len, 2);\n}\n#endif\n\n#endif /* defined (ENABLE_CDP) || defined (ENABLE_FDP) */\n", "/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"lldpd.h\"\n#include \"frame.h\"\n\n#ifdef ENABLE_EDP\n\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <fnmatch.h>\n\nstatic int seq = 0;\n\nint\nedp_send(struct lldpd *global,\n\t struct lldpd_hardware *hardware)\n{\n\tconst u_int8_t mcastaddr[] = EDP_MULTICAST_ADDR;\n\tconst u_int8_t llcorg[] = LLC_ORG_EXTREME;\n\tstruct lldpd_chassis *chassis;\n\tint length, i, v;\n\tu_int8_t *packet, *pos, *pos_llc, *pos_len_eh, *pos_len_edp, *pos_edp, *tlv, *end;\n\tu_int16_t checksum;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan;\n\tunsigned int state = 0;\n#endif\n\tu_int8_t edp_fakeversion[] = {7, 6, 4, 99};\n\t/* Subsequent XXX can be replaced by other values. We place\n\t   them here to ensure the position of \"\" to be a bit\n\t   invariant with version changes. */\n\tchar *deviceslot[] = { \"eth\", \"veth\", \"XXX\", \"XXX\", \"XXX\", \"XXX\", \"XXX\", \"XXX\", \"\", NULL };\n\n\tlog_debug(\"edp\", \"send EDP frame on port %s\", hardware->h_ifname);\n\n\tchassis = hardware->h_lport.p_chassis;\n#ifdef ENABLE_DOT1\n\twhile (state != 2) {\n#endif\n\t\tlength = hardware->h_mtu;\n\t\tif ((packet = (u_int8_t*)calloc(1, length)) == NULL)\n\t\t\treturn ENOMEM;\n\t\tpos = packet;\n\t\tv = 0;\n\n\t\t/* Ethernet header */\n\t\tif (!(\n\t\t      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t\t      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t\t      POKE_SAVE(pos_len_eh) && /* We compute the len later */\n\t\t      POKE_UINT16(0)))\n\t\t\tgoto toobig;\n\n\t\t/* LLC */\n\t\tif (!(\n\t\t      POKE_SAVE(pos_llc) && /* We need to save our\n\t\t\t\t\t       current position to\n\t\t\t\t\t       compute ethernet len */\n\t\t      /* SSAP and DSAP */\n\t\t      POKE_UINT8(0xaa) && POKE_UINT8(0xaa) &&\n\t\t      /* Control field */\n\t\t      POKE_UINT8(0x03) &&\n\t\t      /* ORG */\n\t\t      POKE_BYTES(llcorg, sizeof(llcorg)) &&\n\t\t      POKE_UINT16(LLC_PID_EDP)))\n\t\t\tgoto toobig;\n\n\t\t/* EDP header */\n\t\tif ((chassis->c_id_len != ETHER_ADDR_LEN) ||\n\t\t    (chassis->c_id_subtype != LLDP_CHASSISID_SUBTYPE_LLADDR)) {\n\t\t\tlog_warnx(\"edp\", \"local chassis does not use MAC address as chassis ID!?\");\n\t\t\tfree(packet);\n\t\t\treturn EINVAL;\n\t\t}\n\t\tif (!(\n\t\t      POKE_SAVE(pos_edp) && /* Save the start of EDP frame */\n\t\t      POKE_UINT8(1) && POKE_UINT8(0) &&\n\t\t      POKE_SAVE(pos_len_edp) && /* We compute the len\n\t\t\t\t\t\t   and the checksum\n\t\t\t\t\t\t   later */\n\t\t      POKE_UINT32(0) && /* Len + Checksum */\n\t\t      POKE_UINT16(seq) &&\n\t\t      POKE_UINT16(0) &&\n\t\t      POKE_BYTES(chassis->c_id, ETHER_ADDR_LEN)))\n\t\t\tgoto toobig;\n\t\tseq++;\n\n#ifdef ENABLE_DOT1\n\t\tswitch (state) {\n\t\tcase 0:\n#endif\n\t\t\t/* Display TLV */\n\t\t\tif (!(\n\t\t\t      POKE_START_EDP_TLV(EDP_TLV_DISPLAY) &&\n\t\t\t      POKE_BYTES(chassis->c_name, strlen(chassis->c_name)) &&\n\t\t\t      POKE_UINT8(0) && /* Add a NULL character\n\t\t\t\t\t\t  for better\n\t\t\t\t\t\t  compatibility */\n\t\t\t      POKE_END_EDP_TLV))\n\t\t\t\tgoto toobig;\n\n\t\t\t/* Info TLV */\n\t\t\tif (!(\n\t\t\t      POKE_START_EDP_TLV(EDP_TLV_INFO)))\n\t\t\t\tgoto toobig;\n\t\t\t/* We try to emulate the slot thing */\n\t\t\tfor (i=0; deviceslot[i] != NULL; i++) {\n\t\t\t\tif (strncmp(hardware->h_ifname, deviceslot[i],\n\t\t\t\t\tstrlen(deviceslot[i])) == 0) {\n\t\t\t\t\tif (!(\n\t\t\t\t\t      POKE_UINT16(i) &&\n\t\t\t\t\t      POKE_UINT16(atoi(hardware->h_ifname +\n\t\t\t\t\t\t\t       strlen(deviceslot[i])))))\n\t\t\t\t\t\tgoto toobig;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* If we don't find a \"slot\", we say that the\n\t\t\t   interface is in slot 8 */\n\t\t\tif (deviceslot[i] == NULL) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_UINT16(8) &&\n\t\t\t\t      POKE_UINT16(hardware->h_ifindex)))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t\tif (!(\n\t\t\t      POKE_UINT16(0) && /* vchassis */\n\t\t\t      POKE_UINT32(0) && POKE_UINT16(0) && /* Reserved */\n\t\t\t      /* Version */\n\t\t\t      POKE_BYTES(edp_fakeversion, sizeof(edp_fakeversion)) &&\n\t\t\t      /* Connections, we say that we won't\n\t\t\t\t have more interfaces than this\n\t\t\t\t mask. */\n\t\t\t      POKE_UINT32(0xffffffff) &&\n\t\t\t      POKE_UINT32(0) && POKE_UINT32(0) && POKE_UINT32(0) &&\n\t\t\t      POKE_END_EDP_TLV))\n\t\t\t\tgoto toobig;\n\n#ifdef ENABLE_DOT1\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tTAILQ_FOREACH(vlan, &hardware->h_lport.p_vlans,\n\t\t\t    v_entries) {\n\t\t\t\tv++;\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_EDP_TLV(EDP_TLV_VLAN) &&\n\t\t\t\t      POKE_UINT8(0) && /* Flags: no IP address */\n\t\t\t\t      POKE_UINT8(0) && /* Reserved */\n\t\t\t\t      POKE_UINT16(vlan->v_vid) &&\n\t\t\t\t      POKE_UINT32(0) && /* Reserved */\n\t\t\t\t      POKE_UINT32(0) && /* IP address */\n\t\t\t\t      /* VLAN name */\n\t\t\t\t      POKE_BYTES(vlan->v_name, strlen(vlan->v_name)) &&\n\t\t\t\t      POKE_UINT8(0) &&\n\t\t\t\t      POKE_END_EDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((state == 1) && (v == 0)) {\n\t\t\t/* No VLAN, no need to send another TLV */\n\t\t\tfree(packet);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\t\t\n\t\t/* Null TLV */\n\t\tif (!(\n\t\t      POKE_START_EDP_TLV(EDP_TLV_NULL) &&\n\t\t      POKE_END_EDP_TLV &&\n\t\t      POKE_SAVE(end)))\n\t\t\tgoto toobig;\n\n\t\t/* Compute len and checksum */\n\t\ti = end - pos_llc; /* Ethernet length */\n\t\tv = end - pos_edp; /* EDP length */\n\t\tPOKE_RESTORE(pos_len_eh);\n\t\tif (!(POKE_UINT16(i))) goto toobig;\n\t\tPOKE_RESTORE(pos_len_edp);\n\t\tif (!(POKE_UINT16(v))) goto toobig;\n\t\tchecksum = frame_checksum(pos_edp, v, 0);\n\t\tif (!(POKE_UINT16(checksum))) goto toobig;\n\n\t\tif (interfaces_send_helper(global, hardware,\n\t\t\t(char *)packet, end - packet) == -1) {\n\t\t\tlog_warn(\"edp\", \"unable to send packet on real device for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tfree(packet);\n\t\t\treturn ENETDOWN;\n\t\t}\n\t\tfree(packet);\n\n#ifdef ENABLE_DOT1\t\t\n\t\tstate++;\n\t}\n#endif\n\n\thardware->h_tx_cnt++;\n\treturn 0;\n toobig:\n\tfree(packet);\n\treturn E2BIG;\n}\n\n#define CHECK_TLV_SIZE(x, name)\t\t\t\t   \\\n\tdo { if (tlv_len < (x)) {\t\t\t   \\\n\t\t\tlog_warnx(\"edp\", name \" EDP TLV too short received on %s\", \\\n\t       hardware->h_ifname);\t\t\t   \\\n\t   goto malformed;\t\t\t\t   \\\n\t} } while (0)\n\nint\nedp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_mgmt *mgmt, *mgmt_next, *m;\n\tstruct lldpd_vlan *lvlan = NULL, *lvlan_next;\n#endif\n\tconst unsigned char edpaddr[] = EDP_MULTICAST_ADDR;\n\tint length, gotend = 0, gotvlans = 0, edp_len, tlv_len, tlv_type;\n\tint edp_port, edp_slot;\n\tu_int8_t *pos, *pos_edp, *tlv;\n\tu_int8_t version[4];\n#ifdef ENABLE_DOT1\n\tstruct in_addr address;\n\tstruct lldpd_port *oport;\n#endif\n\n\tlog_debug(\"edp\", \"decode EDP frame on port %s\",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"edp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"edp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t) + 8 /* LLC */ +\n\t    10 + ETHER_ADDR_LEN /* EDP header */) {\n\t\tlog_warnx(\"edp\", \"too short EDP frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tif (PEEK_CMP(edpaddr, sizeof(edpaddr)) != 0) {\n\t\tlog_info(\"edp\", \"frame not targeted at EDP multicast address received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16;\n\tPEEK_DISCARD(6);\t/* LLC: DSAP + SSAP + control + org */\n\tif (PEEK_UINT16 != LLC_PID_EDP) {\n\t\tlog_debug(\"edp\", \"incorrect LLC protocol ID received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\t(void)PEEK_SAVE(pos_edp); /* Save the start of EDP packet */\n\tif (PEEK_UINT8 != 1) {\n\t\tlog_warnx(\"edp\", \"incorrect EDP version for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD_UINT8;\t/* Reserved */\n\tedp_len = PEEK_UINT16;\n\tPEEK_DISCARD_UINT16;\t/* Checksum */\n\tPEEK_DISCARD_UINT16;\t/* Sequence */\n\tif (PEEK_UINT16 != 0) {\t/* ID Type = 0 = MAC */\n\t\tlog_warnx(\"edp\", \"incorrect device id type for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (edp_len > length + 10) {\n\t\tlog_warnx(\"edp\", \"incorrect size for EDP frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_ttl = cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold;\n\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_LLADDR;\n\tchassis->c_id_len = ETHER_ADDR_LEN;\n\tif ((chassis->c_id = (char *)malloc(ETHER_ADDR_LEN)) == NULL) {\n\t\tlog_warn(\"edp\", \"unable to allocate memory for chassis ID\");\n\t\tgoto malformed;\n\t}\n\tPEEK_BYTES(chassis->c_id, ETHER_ADDR_LEN);\n\n\t/* Let's check checksum */\n\tif (frame_checksum(pos_edp, edp_len, 0) != 0) {\n\t\tlog_warnx(\"edp\", \"incorrect EDP checksum for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\twhile (length && !gotend) {\n\t\tif (length < 4) {\n\t\t\tlog_warnx(\"edp\", \"EDP TLV header is too large for \"\n\t\t\t    \"frame received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tif (PEEK_UINT8 != EDP_TLV_MARKER) {\n\t\t\tlog_warnx(\"edp\", \"incorrect marker starting EDP TLV header for frame \"\n\t\t\t    \"received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_type = PEEK_UINT8;\n\t\ttlv_len = PEEK_UINT16 - 4;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif ((tlv_len < 0) || (tlv_len > length)) {\n\t\t\tlog_debug(\"edp\", \"incorrect size in EDP TLV header for frame \"\n\t\t\t    \"received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\t/* Some poor old Extreme Summit are quite bogus */\n\t\t\tgotend = 1;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase EDP_TLV_INFO:\n\t\t\tCHECK_TLV_SIZE(32, \"Info\");\n\t\t\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;\n\t\t\tedp_slot = PEEK_UINT16; edp_port = PEEK_UINT16;\n\t\t\tif (asprintf(&port->p_id, \"%d/%d\",\n\t\t\t\tedp_slot + 1, edp_port + 1) == -1) {\n\t\t\t\tlog_warn(\"edp\", \"unable to allocate memory for \"\n\t\t\t\t    \"port ID\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tport->p_id_len = strlen(port->p_id);\n\t\t\tif (asprintf(&port->p_descr, \"Slot %d / Port %d\",\n\t\t\t\tedp_slot + 1, edp_port + 1) == -1) {\n\t\t\t\tlog_warn(\"edp\", \"unable to allocate memory for \"\n\t\t\t\t    \"port description\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_DISCARD_UINT16; /* vchassis */\n\t\t\tPEEK_DISCARD(6);     /* Reserved */\n\t\t\tPEEK_BYTES(version, 4);\n\t\t\tif (asprintf(&chassis->c_descr,\n\t\t\t\t\"EDP enabled device, version %d.%d.%d.%d\",\n\t\t\t\tversion[0], version[1],\n\t\t\t\tversion[2], version[3]) == -1) {\n\t\t\t\tlog_warn(\"edp\", \"unable to allocate memory for \"\n\t\t\t\t    \"chassis description\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EDP_TLV_DISPLAY:\n\t\t\tif ((chassis->c_name = (char *)calloc(1, tlv_len + 1)) == NULL) {\n\t\t\t\tlog_warn(\"edp\", \"unable to allocate memory for chassis \"\n\t\t\t\t    \"name\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\t/* TLV display contains a lot of garbage */\n\t\t\tPEEK_BYTES(chassis->c_name, tlv_len);\n\t\t\tbreak;\n\t\tcase EDP_TLV_NULL:\n\t\t\tif (tlv_len != 0) {\n\t\t\t\tlog_warnx(\"edp\", \"null tlv with incorrect size in frame \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif (length)\n\t\t\t\tlog_debug(\"edp\", \"extra data after edp frame on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\tgotend = 1;\n\t\t\tbreak;\n\t\tcase EDP_TLV_VLAN:\n#ifdef ENABLE_DOT1\n\t\t\tCHECK_TLV_SIZE(12, \"VLAN\");\n\t\t\tif ((lvlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\t    sizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\tlog_warn(\"edp\", \"unable to allocate vlan\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_DISCARD_UINT16; /* Flags + reserved */\n\t\t\tlvlan->v_vid = PEEK_UINT16; /* VID */\n\t\t\tPEEK_DISCARD(4);\t    /* Reserved */\n\t\t\tPEEK_BYTES(&address, sizeof(address));\n\n\t\t\tif (address.s_addr != INADDR_ANY) {\n\t\t\t\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, \n\t\t\t\t\t\t\tsizeof(struct in_addr), 0);\n\t\t\t\tif (mgmt == NULL) {\n\t\t\t\t\tlog_warn(\"edp\", \"Out of memory\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\t}\n\n\t\t\tif ((lvlan->v_name = (char *)calloc(1,\n\t\t\t\t    tlv_len + 1 - 12)) == NULL) {\n\t\t\t\tlog_warn(\"edp\", \"unable to allocate vlan name\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(lvlan->v_name, tlv_len - 12);\n\n\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t    lvlan, v_entries);\n\t\t\tlvlan = NULL;\n#endif\n\t\t\tgotvlans = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"edp\", \"unknown EDP TLV type (%d) received on %s\",\n\t\t\t    tlv_type, hardware->h_ifname);\n\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_len - pos);\n\t}\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (chassis->c_name == NULL) ||\n\t    (chassis->c_descr == NULL) ||\n\t    (port->p_descr == NULL) ||\n\t    (gotend == 0)) {\n#ifdef ENABLE_DOT1\n\t\tif (gotvlans && gotend) {\n\t\t\t/* VLAN can be sent in a separate frames. We need to add\n\t\t\t * those vlans to an existing port */\n\t\t\tTAILQ_FOREACH(oport, &hardware->h_rports, p_entries) {\n\t\t\t\tif (!((oport->p_protocol == LLDPD_MODE_EDP) &&\n\t\t\t\t\t(oport->p_chassis->c_id_subtype ==\n\t\t\t\t\t    chassis->c_id_subtype) &&\n\t\t\t\t\t(oport->p_chassis->c_id_len == chassis->c_id_len) &&\n\t\t\t\t\t(memcmp(oport->p_chassis->c_id, chassis->c_id,\n\t\t\t\t\t    chassis->c_id_len) == 0)))\n\t\t\t\t\tcontinue;\n\t\t\t\t/* We attach the VLANs to the found port */\n\t\t\t\tlldpd_vlan_cleanup(oport);\n\t\t\t\tfor (lvlan = TAILQ_FIRST(&port->p_vlans);\n\t\t\t\t     lvlan != NULL;\n\t\t\t\t     lvlan = lvlan_next) {\n\t\t\t\t\tlvlan_next = TAILQ_NEXT(lvlan, v_entries);\n\t\t\t\t\tTAILQ_REMOVE(&port->p_vlans, lvlan, v_entries);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&oport->p_vlans,\n\t\t\t\t\t    lvlan, v_entries);\n\t\t\t\t}\n\t\t\t\t/* And the IP addresses */\n\t\t\t\tfor (mgmt = TAILQ_FIRST(&chassis->c_mgmt);\n\t\t\t\t     mgmt != NULL;\n\t\t\t\t     mgmt = mgmt_next) {\n\t\t\t\t\tmgmt_next = TAILQ_NEXT(mgmt, m_entries);\n\t\t\t\t\tTAILQ_REMOVE(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\t\t\t/* Don't add an address that already exists! */\n\t\t\t\t\tTAILQ_FOREACH(m, &chassis->c_mgmt, m_entries)\n\t\t\t\t\t    if (m->m_family == mgmt->m_family &&\n\t\t\t\t\t\t!memcmp(&m->m_addr, &mgmt->m_addr,\n\t\t\t\t\t\t    sizeof(m->m_addr))) break;\n\t\t\t\t\tif (m == NULL)\n\t\t\t\t\t\tTAILQ_INSERT_TAIL(&oport->p_chassis->c_mgmt,\n\t\t\t\t\t\t    mgmt, m_entries);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* We discard the remaining frame */\n\t\t\tgoto malformed;\n\t\t}\n#else\n\t\tif (gotvlans)\n\t\t\tgoto malformed;\n#endif\n\t\tlog_warnx(\"edp\", \"some mandatory tlv are missing for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n#ifdef ENABLE_DOT1\n\tfree(lvlan);\n#endif\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}\n\n#endif /* ENABLE_EDP */\n", "/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"lldpd.h\"\n#include \"frame.h\"\n\n#include <unistd.h>\n#include <errno.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n\ninline static int\nlldpd_af_to_lldp_proto(int af)\n{\n\tswitch (af) {\n\tcase LLDPD_AF_IPV4:\n\t\treturn LLDP_MGMT_ADDR_IP4;\n\tcase LLDPD_AF_IPV6:\n\t\treturn LLDP_MGMT_ADDR_IP6;\n\tdefault:\n\t\treturn LLDP_MGMT_ADDR_NONE;\n\t}\n}\n\ninline static int\nlldpd_af_from_lldp_proto(int proto)\n{\n\tswitch (proto) {\n\tcase LLDP_MGMT_ADDR_IP4:\n\t\treturn LLDPD_AF_IPV4;\n\tcase LLDP_MGMT_ADDR_IP6:\n\t\treturn LLDPD_AF_IPV6;\n\tdefault:\n\t\treturn LLDPD_AF_UNSPEC;\n\t}\n}\n\nstatic int _lldp_send(struct lldpd *global,\n    struct lldpd_hardware *hardware,\n    u_int8_t c_id_subtype,\n    char *c_id,\n    int c_id_len,\n    u_int8_t p_id_subtype,\n    char *p_id,\n    int p_id_len,\n    int shutdown)\n{\n\tstruct lldpd_port *port;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_frame *frame;\n\tint length;\n\tu_int8_t *packet, *pos, *tlv;\n\tstruct lldpd_mgmt *mgmt;\n\tint proto;\n\n\tu_int8_t mcastaddr[] = LLDP_MULTICAST_ADDR;\n#ifdef ENABLE_DOT1\n\tconst u_int8_t dot1[] = LLDP_TLV_ORG_DOT1;\n\tstruct lldpd_vlan *vlan;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi;\n#endif\n#ifdef ENABLE_DOT3\n\tconst u_int8_t dot3[] = LLDP_TLV_ORG_DOT3;\n#endif\n#ifdef ENABLE_LLDPMED\n\tint i;\n\tconst u_int8_t med[] = LLDP_TLV_ORG_MED;\n#endif\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom;\n#endif\n\tport = &hardware->h_lport;\n\tchassis = port->p_chassis;\n\tlength = hardware->h_mtu;\n\tif ((packet = (u_int8_t*)calloc(1, length)) == NULL)\n\t\treturn ENOMEM;\n\tpos = packet;\n\n\t/* Ethernet header */\n\tif (!(\n\t      /* LLDP multicast address */\n\t      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t      /* Source MAC address */\n\t      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t      /* LLDP frame */\n\t      POKE_UINT16(ETHERTYPE_LLDP)))\n\t\tgoto toobig;\n\n\t/* Chassis ID */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_CHASSIS_ID) &&\n\t      POKE_UINT8(c_id_subtype) &&\n\t      POKE_BYTES(c_id, c_id_len) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* Port ID */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_PORT_ID) &&\n\t      POKE_UINT8(p_id_subtype) &&\n\t      POKE_BYTES(p_id, p_id_len) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* Time to live */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_TTL) &&\n\t      POKE_UINT16(shutdown?0:chassis->c_ttl) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\tif (shutdown)\n\t\tgoto end;\n\n\t/* System name */\n\tif (chassis->c_name && *chassis->c_name != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_NAME) &&\n\t\t\t    POKE_BYTES(chassis->c_name, strlen(chassis->c_name)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* System description (skip it if empty) */\n\tif (chassis->c_descr && *chassis->c_descr != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_DESCR) &&\n\t\t\t    POKE_BYTES(chassis->c_descr, strlen(chassis->c_descr)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* System capabilities */\n\tif (global->g_config.c_cap_advertise && chassis->c_cap_available) {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_CAP) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_available) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_enabled) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Management addresses */\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\tproto = lldpd_af_to_lldp_proto(mgmt->m_family);\n\t\tif (proto == LLDP_MGMT_ADDR_NONE) continue;\n\t\tif (!(\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_MGMT_ADDR) &&\n\t\t\t  /* Size of the address, including its type */\n\t\t\t  POKE_UINT8(mgmt->m_addrsize + 1) &&\n\t\t\t  POKE_UINT8(proto) &&\n\t\t\t  POKE_BYTES(&mgmt->m_addr, mgmt->m_addrsize)))\n\t\t\tgoto toobig;\n\n\t\t/* Interface port type, OID */\n\t\tif (mgmt->m_iface == 0) {\n\t\t\tif (!(\n\t\t\t\t  /* We don't know the management interface */\n\t\t\t\t  POKE_UINT8(LLDP_MGMT_IFACE_UNKNOWN) &&\n\t\t\t\t  POKE_UINT32(0)))\n\t\t\t\tgoto toobig;\n\t\t} else {\n\t\t\tif (!(\n\t\t\t\t  /* We have the index of the management interface */\n\t\t\t\t  POKE_UINT8(LLDP_MGMT_IFACE_IFINDEX) &&\n\t\t\t\t  POKE_UINT32(mgmt->m_iface)))\n\t\t\t\tgoto toobig;\n\t\t}\n\t\tif (!(\n\t\t\t  /* We don't provide an OID for management */\n\t\t\t  POKE_UINT8(0) &&\n\t\t\t  POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Port description */\n\tif (port->p_descr && *port->p_descr != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_PORT_DESCR) &&\n\t\t\t    POKE_BYTES(port->p_descr, strlen(port->p_descr)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n#ifdef ENABLE_DOT1\n\t/* Port VLAN ID */\n\tif(port->p_pvid != 0) {\n\t\tif (!(\n\t\t    POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t    POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t    POKE_UINT8(LLDP_TLV_DOT1_PVID) &&\n\t\t    POKE_UINT16(port->p_pvid) &&\n\t\t    POKE_END_LLDP_TLV)) {\n\t\t    goto toobig;\n\t\t}\n\t}\n\t/* Port and Protocol VLAN IDs */\n\tTAILQ_FOREACH(ppvid, &port->p_ppvids, p_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_PPVID) &&\n\t\t      POKE_UINT8(ppvid->p_cap_status) &&\n\t\t      POKE_UINT16(ppvid->p_ppvid) &&\n\t\t      POKE_END_LLDP_TLV)) {\n\t\t\tgoto toobig;\n\t\t}\n\t}\n\t/* VLANs */\n\tTAILQ_FOREACH(vlan, &port->p_vlans, v_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_VLANNAME) &&\n\t\t      POKE_UINT16(vlan->v_vid) &&\n\t\t      POKE_UINT8(strlen(vlan->v_name)) &&\n\t\t      POKE_BYTES(vlan->v_name, strlen(vlan->v_name)) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\t/* Protocol Identities */\n\tTAILQ_FOREACH(pi, &port->p_pids, p_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_PI) &&\n\t\t      POKE_UINT8(pi->p_pi_len) &&\n\t\t      POKE_BYTES(pi->p_pi, pi->p_pi_len) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n#ifdef ENABLE_DOT3\n\t/* Aggregation status */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t      POKE_UINT8(LLDP_TLV_DOT3_LA) &&\n\t      /* Bit 0 = capability ; Bit 1 = status */\n\t      POKE_UINT8((port->p_aggregid) ? 3:1) &&\n\t      POKE_UINT32(port->p_aggregid) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* MAC/PHY */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t      POKE_UINT8(LLDP_TLV_DOT3_MAC) &&\n\t      POKE_UINT8(port->p_macphy.autoneg_support |\n\t\t\t (port->p_macphy.autoneg_enabled << 1)) &&\n\t      POKE_UINT16(port->p_macphy.autoneg_advertised) &&\n\t      POKE_UINT16(port->p_macphy.mau_type) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* MFS */\n\tif (port->p_mfs) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT3_MFS) &&\n\t\t      POKE_UINT16(port->p_mfs) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\t/* Power */\n\tif (port->p_power.devicetype) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT3_POWER) &&\n\t\t      POKE_UINT8((\n\t\t\t\t  (((2 - port->p_power.devicetype)    %(1<< 1))<<0) |\n\t\t\t\t  (( port->p_power.supported          %(1<< 1))<<1) |\n\t\t\t\t  (( port->p_power.enabled            %(1<< 1))<<2) |\n\t\t\t\t  (( port->p_power.paircontrol        %(1<< 1))<<3))) &&\n\t\t      POKE_UINT8(port->p_power.pairs) &&\n\t\t      POKE_UINT8(port->p_power.class)))\n\t\t\tgoto toobig;\n\t\t/* 802.3at */\n\t\tif (port->p_power.powertype != LLDP_DOT3_POWER_8023AT_OFF) {\n\t\t\tif (!(\n\t\t\t      POKE_UINT8((\n\t\t\t\t\t  (((port->p_power.powertype ==\n\t\t\t\t\t      LLDP_DOT3_POWER_8023AT_TYPE1)?1:0) << 7) |\n\t\t\t\t\t   (((port->p_power.devicetype ==\n\t\t\t\t\t      LLDP_DOT3_POWER_PSE)?0:1) << 6) |\n\t\t\t\t\t   ((port->p_power.source   %(1<< 2))<<4) |\n\t\t\t\t\t   ((port->p_power.priority %(1<< 2))<<0))) &&\n\t\t\t      POKE_UINT16(port->p_power.requested) &&\n\t\t\t      POKE_UINT16(port->p_power.allocated)))\n\t\t\t\tgoto toobig;\n\t\t}\n\t\tif (!(POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n#ifdef ENABLE_LLDPMED\n\tif (port->p_med_cap_enabled) {\n\t\t/* LLDP-MED cap */\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t      POKE_UINT8(LLDP_TLV_MED_CAP) &&\n\t\t      POKE_UINT16(chassis->c_med_cap_available) &&\n\t\t      POKE_UINT8(chassis->c_med_type) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\n\t\t/* LLDP-MED inventory */\n#define LLDP_INVENTORY(value, subtype)\t\t\t\t\t\\\n\t\tif (value) {\t\t\t\t\t\t\\\n\t\t    if (!(\t\t\t\t\t\t\\\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\t\t\\\n\t\t\t  POKE_BYTES(med, sizeof(med)) &&\t\t\\\n\t\t\t  POKE_UINT8(subtype) &&\t\t\t\\\n\t\t\t  POKE_BYTES(value,\t\t\t\t\\\n\t\t\t\t(strlen(value)>32)?32:strlen(value)) &&\t\\\n\t\t\t  POKE_END_LLDP_TLV))\t\t\t\t\\\n\t\t\t    goto toobig;\t\t\t\t\\\n\t\t}\n\n\t\tif (port->p_med_cap_enabled & LLDP_MED_CAP_IV) {\n\t\t\tLLDP_INVENTORY(chassis->c_med_hw,\n\t\t\t    LLDP_TLV_MED_IV_HW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_fw,\n\t\t\t    LLDP_TLV_MED_IV_FW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_sw,\n\t\t\t    LLDP_TLV_MED_IV_SW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_sn,\n\t\t\t    LLDP_TLV_MED_IV_SN);\n\t\t\tLLDP_INVENTORY(chassis->c_med_manuf,\n\t\t\t    LLDP_TLV_MED_IV_MANUF);\n\t\t\tLLDP_INVENTORY(chassis->c_med_model,\n\t\t\t    LLDP_TLV_MED_IV_MODEL);\n\t\t\tLLDP_INVENTORY(chassis->c_med_asset,\n\t\t\t    LLDP_TLV_MED_IV_ASSET);\n\t\t}\n\n\t\t/* LLDP-MED location */\n\t\tfor (i = 0; i < LLDP_MED_LOCFORMAT_LAST; i++) {\n\t\t\tif (port->p_med_location[i].format == i + 1) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t\t      POKE_UINT8(LLDP_TLV_MED_LOCATION) &&\n\t\t\t\t      POKE_UINT8(port->p_med_location[i].format) &&\n\t\t\t\t      POKE_BYTES(port->p_med_location[i].data,\n\t\t\t\t\t  port->p_med_location[i].data_len) &&\n\t\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t}\n\n\t\t/* LLDP-MED network policy */\n\t\tfor (i = 0; i < LLDP_MED_APPTYPE_LAST; i++) {\n\t\t\tif (port->p_med_policy[i].type == i + 1) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t\t      POKE_UINT8(LLDP_TLV_MED_POLICY) &&\n\t\t\t\t      POKE_UINT32((\n\t\t\t\t\t((port->p_med_policy[i].type     %(1<< 8))<<24) |\n\t\t\t\t\t((port->p_med_policy[i].unknown  %(1<< 1))<<23) |\n\t\t\t\t\t((port->p_med_policy[i].tagged   %(1<< 1))<<22) |\n\t\t\t\t      /*((0                              %(1<< 1))<<21) |*/\n\t\t\t\t\t((port->p_med_policy[i].vid      %(1<<12))<< 9) |\n\t\t\t\t\t((port->p_med_policy[i].priority %(1<< 3))<< 6) |\n\t\t\t\t\t((port->p_med_policy[i].dscp     %(1<< 6))<< 0) )) &&\n\t\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t}\n\n\t\t/* LLDP-MED POE-MDI */\n\t\tif ((port->p_med_power.devicetype == LLDP_MED_POW_TYPE_PSE) ||\n\t\t    (port->p_med_power.devicetype == LLDP_MED_POW_TYPE_PD)) {\n\t\t\tint devicetype = 0, source = 0;\n\t\t\tif (!(\n\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t      POKE_UINT8(LLDP_TLV_MED_MDI)))\n\t\t\t\tgoto toobig;\n\t\t\tswitch (port->p_med_power.devicetype) {\n\t\t\tcase LLDP_MED_POW_TYPE_PSE:\n\t\t\t\tdevicetype = 0;\n\t\t\t\tswitch (port->p_med_power.source) {\n\t\t\t\tcase LLDP_MED_POW_SOURCE_PRIMARY: source = 1; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_BACKUP: source = 2; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_RESERVED: source = 3; break;\n\t\t\t\tdefault: source = 0; break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LLDP_MED_POW_TYPE_PD:\n\t\t\t\tdevicetype = 1;\n\t\t\t\tswitch (port->p_med_power.source) {\n\t\t\t\tcase LLDP_MED_POW_SOURCE_PSE: source = 1; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_LOCAL: source = 2; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_BOTH: source = 3; break;\n\t\t\t\tdefault: source = 0; break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(\n\t\t\t      POKE_UINT8((\n\t\t\t\t((devicetype                   %(1<< 2))<<6) |\n\t\t\t\t((source                       %(1<< 2))<<4) |\n\t\t\t\t((port->p_med_power.priority   %(1<< 4))<<0) )) &&\n\t\t\t      POKE_UINT16(port->p_med_power.val) &&\n\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\tgoto toobig;\n\t\t}\n\t}\n#endif\n\n#ifdef ENABLE_CUSTOM\n\tTAILQ_FOREACH(custom, &port->p_custom_list, next) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(custom->oui, sizeof(custom->oui)) &&\n\t\t      POKE_UINT8(custom->subtype) &&\n\t\t      POKE_BYTES(custom->oui_info, custom->oui_info_len) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\nend:\n\t/* END */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_END) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\tif (interfaces_send_helper(global, hardware,\n\t\t(char *)packet, pos - packet) == -1) {\n\t\tlog_warn(\"lldp\", \"unable to send packet on real device for %s\",\n\t\t    hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\thardware->h_tx_cnt++;\n\n\t/* We assume that LLDP frame is the reference */\n\tif (!shutdown && (frame = (struct lldpd_frame*)malloc(\n\t\t\tsizeof(int) + pos - packet)) != NULL) {\n\t\tframe->size = pos - packet;\n\t\tmemcpy(&frame->frame, packet, frame->size);\n\t\tif ((hardware->h_lport.p_lastframe == NULL) ||\n\t\t    (hardware->h_lport.p_lastframe->size != frame->size) ||\n\t\t    (memcmp(hardware->h_lport.p_lastframe->frame, frame->frame,\n\t\t\tframe->size) != 0)) {\n\t\t\tfree(hardware->h_lport.p_lastframe);\n\t\t\thardware->h_lport.p_lastframe = frame;\n\t\t\thardware->h_lport.p_lastchange = time(NULL);\n\t\t} else free(frame);\n\t}\n\n\tfree(packet);\n\treturn 0;\n\ntoobig:\n\tfree(packet);\n\treturn E2BIG;\n}\n\n/* Send a shutdown LLDPDU. */\nint\nlldp_send_shutdown(struct lldpd *global,\n    struct lldpd_hardware *hardware)\n{\n\tif (hardware->h_lchassis_previous_id == NULL ||\n\t    hardware->h_lport_previous_id == NULL)\n\t\treturn 0;\n\treturn _lldp_send(global, hardware,\n\t    hardware->h_lchassis_previous_id_subtype,\n\t    hardware->h_lchassis_previous_id,\n\t    hardware->h_lchassis_previous_id_len,\n\t    hardware->h_lport_previous_id_subtype,\n\t    hardware->h_lport_previous_id,\n\t    hardware->h_lport_previous_id_len,\n\t    1);\n}\n\nint\nlldp_send(struct lldpd *global,\n\t  struct lldpd_hardware *hardware)\n{\n\tstruct lldpd_port *port = &hardware->h_lport;\n\tstruct lldpd_chassis *chassis = port->p_chassis;\n\tint ret;\n\n\t/* Check if we have a change. */\n\tif (hardware->h_lchassis_previous_id != NULL &&\n\t    hardware->h_lport_previous_id != NULL &&\n\t    (hardware->h_lchassis_previous_id_subtype != chassis->c_id_subtype ||\n\t\thardware->h_lchassis_previous_id_len != chassis->c_id_len ||\n\t\thardware->h_lport_previous_id_subtype != port->p_id_subtype ||\n\t\thardware->h_lport_previous_id_len != port->p_id_len ||\n\t\tmemcmp(hardware->h_lchassis_previous_id,\n\t\t    chassis->c_id, chassis->c_id_len) ||\n\t\tmemcmp(hardware->h_lport_previous_id,\n\t\t    port->p_id, port->p_id_len))) {\n\t\tlog_info(\"lldp\", \"MSAP has changed for port %s, sending a shutdown LLDPDU\",\n\t\t    hardware->h_ifname);\n\t\tif ((ret = lldp_send_shutdown(global, hardware)) != 0)\n\t\t\treturn ret;\n\t}\n\n\tlog_debug(\"lldp\", \"send LLDP PDU to %s\",\n\t    hardware->h_ifname);\n\n\tif ((ret = _lldp_send(global, hardware,\n\t\t    chassis->c_id_subtype,\n\t\t    chassis->c_id,\n\t\t    chassis->c_id_len,\n\t\t    port->p_id_subtype,\n\t\t    port->p_id,\n\t\t    port->p_id_len,\n\t\t    0)) != 0)\n\t\treturn ret;\n\n\t/* Record current chassis and port ID */\n\tfree(hardware->h_lchassis_previous_id);\n\thardware->h_lchassis_previous_id_subtype = chassis->c_id_subtype;\n\thardware->h_lchassis_previous_id_len = chassis->c_id_len;\n\tif ((hardware->h_lchassis_previous_id = malloc(chassis->c_id_len)) != NULL)\n\t\tmemcpy(hardware->h_lchassis_previous_id, chassis->c_id,\n\t\t    chassis->c_id_len);\n\tfree(hardware->h_lport_previous_id);\n\thardware->h_lport_previous_id_subtype = port->p_id_subtype;\n\thardware->h_lport_previous_id_len = port->p_id_len;\n\tif ((hardware->h_lport_previous_id = malloc(port->p_id_len)) != NULL)\n\t\tmemcpy(hardware->h_lport_previous_id, port->p_id,\n\t\t    port->p_id_len);\n\n\treturn 0;\n}\n\n#define CHECK_TLV_SIZE(x, name)\t\t\t\t   \\\n\tdo { if (tlv_size < (x)) {\t\t\t   \\\n\t\t\tlog_warnx(\"lldp\", name \" TLV too short received on %s\",\t\\\n\t       hardware->h_ifname);\t\t\t   \\\n\t   goto malformed;\t\t\t\t   \\\n\t} } while (0)\n\nint\nlldp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tconst char lldpaddr[] = LLDP_MULTICAST_ADDR;\n\tconst char dot1[] = LLDP_TLV_ORG_DOT1;\n\tconst char dot3[] = LLDP_TLV_ORG_DOT3;\n\tconst char med[] = LLDP_TLV_ORG_MED;\n\tconst char dcbx[] = LLDP_TLV_ORG_DCBX;\n\tunsigned char orgid[3];\n\tint length, gotend = 0, ttl_received = 0;\n\tint tlv_size, tlv_type, tlv_subtype;\n\tu_int8_t *pos, *tlv;\n\tchar *b;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan = NULL;\n\tint vlan_len;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi = NULL;\n#endif\n\tstruct lldpd_mgmt *mgmt;\n\tint af;\n\tu_int8_t addr_str_length, addr_str_buffer[32];\n\tu_int8_t addr_family, addr_length, *addr_ptr, iface_subtype;\n\tu_int32_t iface_number, iface;\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom = NULL;\n#endif\n\n\tlog_debug(\"lldp\", \"receive LLDP PDU on %s\",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"lldp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"lldp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n\tTAILQ_INIT(&port->p_ppvids);\n\tTAILQ_INIT(&port->p_pids);\n#endif\n#ifdef ENABLE_CUSTOM\n\tTAILQ_INIT(&port->p_custom_list);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\"lldp\", \"too short frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(lldpaddr, ETHER_ADDR_LEN) != 0) {\n\t\tlog_info(\"lldp\", \"frame not targeted at LLDP multicast address received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\t/* Skip source address */\n\tif (PEEK_UINT16 != ETHERTYPE_LLDP) {\n\t\tlog_info(\"lldp\", \"non LLDP frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\twhile (length && (!gotend)) {\n\t\tif (length < 2) {\n\t\t\tlog_warnx(\"lldp\", \"tlv header too short received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_size = PEEK_UINT16;\n\t\ttlv_type = tlv_size >> 9;\n\t\ttlv_size = tlv_size & 0x1ff;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif (length < tlv_size) {\n\t\t\tlog_warnx(\"lldp\", \"frame too short for tlv received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase LLDP_TLV_END:\n\t\t\tif (tlv_size != 0) {\n\t\t\t\tlog_warnx(\"lldp\", \"lldp end received with size not null on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif (length)\n\t\t\t\tlog_debug(\"lldp\", \"extra data after lldp end on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\tgotend = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_CHASSIS_ID:\n\t\tcase LLDP_TLV_PORT_ID:\n\t\t\tCHECK_TLV_SIZE(2, \"Port Id\");\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif ((tlv_subtype == 0) || (tlv_subtype > 7)) {\n\t\t\t\tlog_warnx(\"lldp\", \"unknown subtype for tlv id received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size - 1)) == NULL) {\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory for id tlv \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size - 1);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_ID) {\n\t\t\t\tport->p_id_subtype = tlv_subtype;\n\t\t\t\tport->p_id = b;\n\t\t\t\tport->p_id_len = tlv_size - 1;\n\t\t\t} else {\n\t\t\t\tchassis->c_id_subtype = tlv_subtype;\n\t\t\t\tchassis->c_id = b;\n\t\t\t\tchassis->c_id_len = tlv_size - 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LLDP_TLV_TTL:\n\t\t\tCHECK_TLV_SIZE(2, \"TTL\");\n\t\t\tchassis->c_ttl = PEEK_UINT16;\n\t\t\tttl_received = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_PORT_DESCR:\n\t\tcase LLDP_TLV_SYSTEM_NAME:\n\t\tcase LLDP_TLV_SYSTEM_DESCR:\n\t\t\tif (tlv_size < 1) {\n\t\t\t\tlog_debug(\"lldp\", \"empty tlv received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size + 1)) == NULL) {\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory for string tlv \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_DESCR)\n\t\t\t\tport->p_descr = b;\n\t\t\telse if (tlv_type == LLDP_TLV_SYSTEM_NAME)\n\t\t\t\tchassis->c_name = b;\n\t\t\telse chassis->c_descr = b;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_SYSTEM_CAP:\n\t\t\tCHECK_TLV_SIZE(4, \"System capabilities\");\n\t\t\tchassis->c_cap_available = PEEK_UINT16;\n\t\t\tchassis->c_cap_enabled = PEEK_UINT16;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \"Management address\");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tif (addr_str_length > sizeof(addr_str_buffer)) {\n\t\t\t\tlog_warnx(\"lldp\", \"too large management address on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \"Management address\");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\telse\n\t\t\t\tiface = 0;\n\t\t\tmgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);\n\t\t\tif (mgmt == NULL) {\n\t\t\t\tif (errno == ENOMEM)\n\t\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t    \"for management address\");\n\t\t\t\telse\n\t\t\t\t\tlog_warn(\"lldp\", \"too large management address \"\n\t\t\t\t\t    \"received on %s\", hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;\n\t\tcase LLDP_TLV_ORG:\n\t\t\tCHECK_TLV_SIZE(1 + (int)sizeof(orgid), \"Organisational\");\n\t\t\tPEEK_BYTES(orgid, sizeof(orgid));\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif (memcmp(dot1, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT1\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot1 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT1_VLANNAME:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"VLAN\");\n\t\t\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc vlan \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tvlan->v_vid = PEEK_UINT16;\n\t\t\t\t\tvlan_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(7 + vlan_len, \"VLAN\");\n\t\t\t\t\tif ((vlan->v_name =\n\t\t\t\t\t\t(char *)calloc(1, vlan_len + 1)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc vlan name for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(vlan->v_name, vlan_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t\t\t    vlan, v_entries);\n\t\t\t\t\tvlan = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PVID:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \"PVID\");\n\t\t\t\t\tport->p_pvid = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PPVID:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"PPVID\");\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PPVID has to be unique if more than\n\t\t\t\t\t   one PPVID TLVs are received  - \n\t\t\t\t\t   discard if duplicate */\n\t\t\t\t\t/* if support bit is not set and \n\t\t\t\t\t   enabled bit is set - PPVID TLV is\n\t\t\t\t\t   considered error  and discarded */\n\t\t\t\t\t/* if PPVID > 4096 - bad and discard */\n\t\t\t\t\tif ((ppvid = (struct lldpd_ppvid *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_ppvid))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc ppvid \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tppvid->p_cap_status = PEEK_UINT8;\n\t\t\t\t\tppvid->p_ppvid = PEEK_UINT16;\t\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_ppvids,\n\t\t\t\t\t    ppvid, p_entries);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PI:\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PI has to be unique if more than \n\t\t\t\t\t   one PI TLVs are received  - discard\n\t\t\t\t\t   if duplicate ?? */\n\t\t\t\t\tCHECK_TLV_SIZE(5, \"PI\");\n\t\t\t\t\tif ((pi = (struct lldpd_pi *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_pi))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc PI \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tpi->p_pi_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(5 + pi->p_pi_len, \"PI\");\n\t\t\t\t\tif ((pi->p_pi =\n\t\t\t\t\t\t(char *)calloc(1, pi->p_pi_len)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc pid name for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(pi->p_pi, pi->p_pi_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_pids,\n\t\t\t\t\t    pi, p_entries);\n\t\t\t\t\tpi = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot1 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(dot3, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT3\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot3 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT3_MAC:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \"MAC/PHY\");\n\t\t\t\t\tport->p_macphy.autoneg_support = PEEK_UINT8;\n\t\t\t\t\tport->p_macphy.autoneg_enabled =\n\t\t\t\t\t    (port->p_macphy.autoneg_support & 0x2) >> 1;\n\t\t\t\t\tport->p_macphy.autoneg_support =\n\t\t\t\t\t    port->p_macphy.autoneg_support & 0x1;\n\t\t\t\t\tport->p_macphy.autoneg_advertised =\n\t\t\t\t\t    PEEK_UINT16;\n\t\t\t\t\tport->p_macphy.mau_type = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_LA:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \"Link aggregation\");\n\t\t\t\t\tPEEK_DISCARD_UINT8;\n\t\t\t\t\tport->p_aggregid = PEEK_UINT32;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_MFS:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \"MFS\");\n\t\t\t\t\tport->p_mfs = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_POWER:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"Power\");\n\t\t\t\t\tport->p_power.devicetype = PEEK_UINT8;\n\t\t\t\t\tport->p_power.supported =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x2) >> 1;\n\t\t\t\t\tport->p_power.enabled =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x4) >> 2;\n\t\t\t\t\tport->p_power.paircontrol =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x8) >> 3;\n\t\t\t\t\tport->p_power.devicetype =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x1)?\n\t\t\t\t\t\tLLDP_DOT3_POWER_PSE:LLDP_DOT3_POWER_PD;\n\t\t\t\t\tport->p_power.pairs = PEEK_UINT8;\n\t\t\t\t\tport->p_power.class = PEEK_UINT8;\n\t\t\t\t\t/* 802.3at? */\n\t\t\t\t\tif (tlv_size >= 12) {\n\t\t\t\t\t\tport->p_power.powertype = PEEK_UINT8;\n\t\t\t\t\t\tport->p_power.source =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<5 | 1<<4)) >> 4;\n\t\t\t\t\t\tport->p_power.priority =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<1 | 1<<0));\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<7))?\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE1:\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE2;\n\t\t\t\t\t\tport->p_power.requested = PEEK_UINT16;\n\t\t\t\t\t\tport->p_power.allocated = PEEK_UINT16;\n\t\t\t\t\t} else\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_OFF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot3 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(med, orgid, sizeof(orgid)) == 0) {\n\t\t\t\t/* LLDP-MED */\n#ifndef ENABLE_LLDPMED\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\tu_int32_t policy;\n\t\t\t\tunsigned loctype;\n\t\t\t\tunsigned power;\n\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_MED_CAP:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"LLDP-MED capabilities\");\n\t\t\t\t\tchassis->c_med_cap_available = PEEK_UINT16;\n\t\t\t\t\tchassis->c_med_type = PEEK_UINT8;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_CAP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_POLICY:\n\t\t\t\t\tCHECK_TLV_SIZE(8, \"LLDP-MED policy\");\n\t\t\t\t\tpolicy = PEEK_UINT32;\n\t\t\t\t\tif (((policy >> 24) < 1) ||\n\t\t\t\t\t    ((policy >> 24) > LLDP_MED_APPTYPE_LAST)) {\n\t\t\t\t\t\tlog_info(\"lldp\", \"unknown policy field %d \"\n\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t    policy,\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].type =\n\t\t\t\t\t    (policy >> 24);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].unknown =\n\t\t\t\t\t    ((policy & 0x800000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].tagged =\n\t\t\t\t\t    ((policy & 0x400000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].vid =\n\t\t\t\t\t    (policy & 0x001FFE00) >> 9;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].priority =\n\t\t\t\t\t    (policy & 0x1C0) >> 6;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].dscp =\n\t\t\t\t\t    policy & 0x3F;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_POLICY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_LOCATION:\n\t\t\t\t\tCHECK_TLV_SIZE(5, \"LLDP-MED Location\");\n\t\t\t\t\tloctype = PEEK_UINT8;\n\t\t\t\t\tif ((loctype < 1) ||\n\t\t\t\t\t    (loctype > LLDP_MED_LOCFORMAT_LAST)) {\n\t\t\t\t\t\tlog_info(\"lldp\", \"unknown location type \"\n\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((port->p_med_location[loctype - 1].data =\n\t\t\t\t\t\t(char*)malloc(tlv_size - 5)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t    \"for LLDP-MED location for \"\n\t\t\t\t\t\t    \"frame received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(port->p_med_location[loctype - 1].data,\n\t\t\t\t\t    tlv_size - 5);\n\t\t\t\t\tport->p_med_location[loctype - 1].data_len =\n\t\t\t\t\t    tlv_size - 5;\n\t\t\t\t\tport->p_med_location[loctype - 1].format = loctype;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_LOCATION;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_MDI:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"LLDP-MED PoE-MDI\");\n\t\t\t\t\tpower = PEEK_UINT8;\n\t\t\t\t\tswitch (power & 0xC0) {\n\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PSE;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PSE;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PRIMARY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BACKUP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_RESERVED;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x40:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PD;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PD;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PSE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_LOCAL;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BOTH;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tport->p_med_power.devicetype =\n\t\t\t\t\t\t    LLDP_MED_POW_TYPE_RESERVED;\n\t\t\t\t\t}\n\t\t\t\t\tif ((power & 0x0F) > LLDP_MED_POW_PRIO_LOW)\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    LLDP_MED_POW_PRIO_UNKNOWN;\n\t\t\t\t\telse\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    power & 0x0F;\n\t\t\t\t\tport->p_med_power.val = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\tif (tlv_size <= 4)\n\t\t\t\t\t\tb = NULL;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ((b = (char*)malloc(tlv_size - 3)) ==\n\t\t\t\t\t\t    NULL) {\n\t\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to allocate \"\n\t\t\t\t\t\t\t    \"memory for LLDP-MED \"\n\t\t\t\t\t\t\t    \"inventory for frame \"\n\t\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPEEK_BYTES(b, tlv_size - 4);\n\t\t\t\t\t\tb[tlv_size - 4] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\t\t\tchassis->c_med_hw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\t\t\tchassis->c_med_fw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\t\t\tchassis->c_med_sw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\t\t\tchassis->c_med_sn = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\t\t\tchassis->c_med_manuf = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\t\t\tchassis->c_med_model = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\t\tchassis->c_med_asset = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_IV;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown LLDP MED, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif /* ENABLE_LLDPMED */\n\t\t\t} else if (memcmp(dcbx, orgid, sizeof(orgid)) == 0) {\n\t\t\t\tlog_debug(\"lldp\", \"unsupported DCBX tlv received on %s - ignore\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t} else {\n\t\t\t\tlog_debug(\"lldp\", \"unknown org tlv [%02x:%02x:%02x] received on %s\",\n\t\t\t\t    orgid[0], orgid[1], orgid[2],\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#ifdef ENABLE_CUSTOM\n\t\t\t\tcustom = (struct lldpd_custom*)calloc(1, sizeof(struct lldpd_custom));\n\t\t\t\tif (!custom) {\n\t\t\t\t\tlog_warn(\"lldp\",\n\t\t\t\t\t    \"unable to allocate memory for custom TLV\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tcustom->oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0;\n\t\t\t\tmemcpy(custom->oui, orgid, sizeof(custom->oui));\n\t\t\t\tcustom->subtype = tlv_subtype;\n\t\t\t\tif (custom->oui_info_len > 0) {\n\t\t\t\t\tcustom->oui_info = malloc(custom->oui_info_len);\n\t\t\t\t\tif (!custom->oui_info) {\n\t\t\t\t\t\tlog_warn(\"lldp\",\n\t\t\t\t\t\t    \"unable to allocate memory for custom TLV data\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(custom->oui_info, custom->oui_info_len);\n\t\t\t\t}\n\t\t\t\tTAILQ_INSERT_TAIL(&port->p_custom_list, custom, next);\n\t\t\t\tcustom = NULL;\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_warnx(\"lldp\", \"unknown tlv (%d) received on %s\",\n\t\t\t    tlv_type, hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tif (pos > tlv + tlv_size) {\n\t\t\tlog_warnx(\"lldp\", \"BUG: already past TLV!\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_size - pos);\n\t}\n\n\t/* Some random check */\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (!ttl_received) ||\n\t    (gotend == 0)) {\n\t\tlog_warnx(\"lldp\", \"some mandatory tlv are missing for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\nmalformed:\n#ifdef ENABLE_CUSTOM\n\tfree(custom);\n#endif\n#ifdef ENABLE_DOT1\n\tfree(vlan);\n\tfree(pi);\n#endif\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}\n", "/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"lldpd.h\"\n#include \"frame.h\"\n\n#ifdef ENABLE_SONMP\n\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa/inet.h>\n\nstatic struct sonmp_chassis sonmp_chassis_types[] = {\n\t{1, \"unknown (via SONMP)\"},\n\t{2, \"Nortel 3000\"},\n\t{3, \"Nortel 3030\"},\n\t{4, \"Nortel 2310\"},\n\t{5, \"Nortel 2810\"},\n\t{6, \"Nortel 2912\"},\n\t{7, \"Nortel 2914\"},\n\t{8, \"Nortel 271x\"},\n\t{9, \"Nortel 2813\"},\n\t{10, \"Nortel 2814\"},\n\t{11, \"Nortel 2915\"},\n\t{12, \"Nortel 5000\"},\n\t{13, \"Nortel 2813SA\"},\n\t{14, \"Nortel 2814SA\"},\n\t{15, \"Nortel 810M\"},\n\t{16, \"Nortel EtherCell\"},\n\t{17, \"Nortel 5005\"},\n\t{18, \"Alcatel Ethernet workgroup conc.\"},\n\t{20, \"Nortel 2715SA\"},\n\t{21, \"Nortel 2486\"},\n\t{22, \"Nortel 28000 series\"},\n\t{23, \"Nortel 23000 series\"},\n\t{24, \"Nortel 5DN00x series\"},\n\t{25, \"BayStack Ethernet\"},\n\t{26, \"Nortel 23100 series\"},\n\t{27, \"Nortel 100Base-T Hub\"},\n\t{28, \"Nortel 3000 Fast Ethernet\"},\n\t{29, \"Nortel Orion switch\"},\n\t{30, \"unknown\"},\n\t{31, \"Nortel DDS \"},\n\t{32, \"Nortel Centillion\"},\n\t{33, \"Nortel Centillion\"},\n\t{34, \"Nortel Centillion\"},\n\t{35, \"BayStack 301\"},\n\t{36, \"BayStack TokenRing Hub\"},\n\t{37, \"Nortel FVC Multimedia Switch\"},\n\t{38, \"Nortel Switch Node\"},\n\t{39, \"BayStack 302 Switch\"},\n\t{40, \"BayStack 350 Switch\"},\n\t{41, \"BayStack 150 Ethernet Hub\"},\n\t{42, \"Nortel Centillion 50N switch\"},\n\t{43, \"Nortel Centillion 50T switch\"},\n\t{44, \"BayStack 303 and 304 Switches\"},\n\t{45, \"BayStack 200 Ethernet Hub\"},\n\t{46, \"BayStack 250 10/100 Ethernet Hub\"},\n\t{48, \"BayStack 450 10/100/1000 Switches\"},\n\t{49, \"BayStack 410 10/100 Switches\"},\n\t{50, \"Nortel Ethernet Routing 1200 L3 Switch\"},\n\t{51, \"Nortel Ethernet Routing 1250 L3 Switch\"},\n\t{52, \"Nortel Ethernet Routing 1100 L3 Switch\"},\n\t{53, \"Nortel Ethernet Routing 1150 L3 Switch\"},\n\t{54, \"Nortel Ethernet Routing 1050 L3 Switch\"},\n\t{55, \"Nortel Ethernet Routing 1051 L3 Switch\"},\n\t{56, \"Nortel Ethernet Routing 8610 L3 Switch\"},\n\t{57, \"Nortel Ethernet Routing 8606 L3 Switch\"},\n\t{58, \"Nortel Ethernet Routing Switch 8010\"},\n\t{59, \"Nortel Ethernet Routing Switch 8006\"},\n\t{60, \"BayStack 670 wireless access point\"},\n\t{61, \"Nortel Ethernet Routing Switch 740 \"},\n\t{62, \"Nortel Ethernet Routing Switch 750 \"},\n\t{63, \"Nortel Ethernet Routing Switch 790\"},\n\t{64, \"Nortel Business Policy Switch 2000 10/100 Switches\"},\n\t{65, \"Nortel Ethernet Routing 8110 L2 Switch\"},\n\t{66, \"Nortel Ethernet Routing 8106 L2 Switch\"},\n\t{67, \"BayStack 3580 Gig Switch\"},\n\t{68, \"BayStack 10 Power Supply Unit\"},\n\t{69, \"BayStack 420 10/100 Switch\"},\n\t{70, \"OPTera Metro 1200 Ethernet Service Module\"},\n\t{71, \"Nortel Ethernet Routing Switch 8010co\"},\n\t{72, \"Nortel Ethernet Routing 8610co L3 switch\"},\n\t{73, \"Nortel Ethernet Routing 8110co L2 switch\"},\n\t{74, \"Nortel Ethernet Routing 8003\"},\n\t{75, \"Nortel Ethernet Routing 8603 L3 switch\"},\n\t{76, \"Nortel Ethernet Routing 8103 L2 switch\"},\n\t{77, \"BayStack 380 10/100/1000 Switch\"},\n\t{78, \"Nortel Ethernet Switch 470-48T\"},\n\t{79, \"OPTera Metro 1450 Ethernet Service Module\"},\n\t{80, \"OPTera Metro 1400 Ethernet Service Module\"},\n\t{81, \"Alteon Switch Family\"},\n\t{82, \"Ethernet Switch 460-24T-PWR\"},\n\t{83, \"OPTera Metro 8010 OPM L2 Switch\"},\n\t{84, \"OPTera Metro 8010co OPM L2 Switch\"},\n\t{85, \"OPTera Metro 8006 OPM L2 Switch\"},\n\t{86, \"OPTera Metro 8003 OPM L2 Switch\"},\n\t{87, \"Alteon 180e\"},\n\t{88, \"Alteon AD3\"},\n\t{89, \"Alteon 184\"},\n\t{90, \"Alteon AD4\"},\n\t{91, \"Nortel Ethernet Routing 1424 L3 switch\"},\n\t{92, \"Nortel Ethernet Routing 1648 L3 switch\"},\n\t{93, \"Nortel Ethernet Routing 1612 L3 switch\"},\n\t{94, \"Nortel Ethernet Routing 1624 L3 switch \"},\n\t{95, \"BayStack 380-24F Fiber 1000 Switch\"},\n\t{96, \"Nortel Ethernet Routing Switch 5510-24T\"},\n\t{97, \"Nortel Ethernet Routing Switch 5510-48T\"},\n\t{98, \"Nortel Ethernet Switch 470-24T\"},\n\t{99, \"Nortel Networks Wireless LAN Access Point 2220\"},\n\t{100, \"Ethernet Routing RBS 2402 L3 switch\"},\n\t{101, \"Alteon Application Switch 2424  \"},\n\t{102, \"Alteon Application Switch 2224 \"},\n\t{103, \"Alteon Application Switch 2208 \"},\n\t{104, \"Alteon Application Switch 2216\"},\n\t{105, \"Alteon Application Switch 3408\"},\n\t{106, \"Alteon Application Switch 3416\"},\n\t{107, \"Nortel Networks Wireless LAN SecuritySwitch 2250\"},\n\t{108, \"Ethernet Switch 425-48T\"},\n\t{109, \"Ethernet Switch 425-24T\"},\n\t{110, \"Nortel Networks Wireless LAN Access Point 2221\"},\n\t{111, \"Nortel Metro Ethernet Service Unit 24-T SPF switch\"},\n\t{112, \"Nortel Metro Ethernet Service Unit 24-T LX DC switch\"},\n\t{113, \"Nortel Ethernet Routing Switch 8300 10-slot chassis\"},\n\t{114, \"Nortel Ethernet Routing Switch 8300 6-slot chassis\"},\n\t{115, \"Nortel Ethernet Routing Switch 5520-24T-PWR\"},\n\t{116, \"Nortel Ethernet Routing Switch 5520-48T-PWR\"},\n\t{117, \"Nortel Networks VPN Gateway 3050\"},\n\t{118, \"Alteon SSL 310 10/100\"},\n\t{119, \"Alteon SSL 310 10/100 Fiber\"},\n\t{120, \"Alteon SSL 310 10/100 FIPS\"},\n\t{121, \"Alteon SSL 410 10/100/1000\"},\n\t{122, \"Alteon SSL 410 10/100/1000 Fiber\"},\n\t{123, \"Alteon Application Switch 2424-SSL\"},\n\t{124, \"Nortel Ethernet Switch 325-24T\"},\n\t{125, \"Nortel Ethernet Switch 325-24G\"},\n\t{126, \"Nortel Networks Wireless LAN Access Point 2225\"},\n\t{127, \"Nortel Networks Wireless LAN SecuritySwitch 2270\"},\n\t{128, \"Nortel 24-port Ethernet Switch 470-24T-PWR\"},\n\t{129, \"Nortel 48-port Ethernet Switch 470-48T-PWR\"},\n\t{130, \"Nortel Ethernet Routing Switch 5530-24TFD\"},\n\t{131, \"Nortel Ethernet Switch 3510-24T\"},\n\t{132, \"Nortel Metro Ethernet Service Unit 12G AC L3 switch\"},\n\t{133, \"Nortel Metro Ethernet Service Unit 12G DC L3 switch\"},\n\t{134, \"Nortel Secure Access Switch\"},\n\t{135, \"Networks VPN Gateway 3070\"},\n\t{136, \"OPTera Metro 3500\"},\n\t{137, \"SMB BES 1010 24T\"},\n\t{138, \"SMB BES 1010 48T\"},\n\t{139, \"SMB BES 1020 24T PWR\"},\n\t{140, \"SMB BES 1020 48T PWR\"},\n\t{141, \"SMB BES 2010 24T\"},\n\t{142, \"SMB BES 2010 48T\"},\n\t{143, \"SMB BES 2020 24T PWR\"},\n\t{144, \"SMB BES 2020 48T PWR\"},\n\t{145, \"SMB BES 110 24T\"},\n\t{146, \"SMB BES 110 48T\"},\n\t{147, \"SMB BES 120 24T PWR\"},\n\t{148, \"SMB BES 120 48T PWR\"},\n\t{149, \"SMB BES 210 24T\"},\n\t{150, \"SMB BES 210 48T\"},\n\t{151, \"SMB BES 220 24T PWR\"},\n\t{152, \"SMB BES 220 48T PWR\"},\n\t{153, \"OME 6500\"},\n\t{0, \"unknown (via SONMP)\"},\n};\n\nint\nsonmp_send(struct lldpd *global,\n    struct lldpd_hardware *hardware)\n{\n\tconst u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR;\n\tconst u_int8_t llcorg[] = LLC_ORG_NORTEL;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_mgmt *mgmt;\n\tu_int8_t *packet, *pos, *pos_pid, *end;\n\tint length;\n\tstruct in_addr address;\n\n\tlog_debug(\"sonmp\", \"send SONMP PDU to %s\",\n\t    hardware->h_ifname);\n\n\tchassis = hardware->h_lport.p_chassis;\n\tlength = hardware->h_mtu;\n\tif ((packet = (u_int8_t*)calloc(1, length)) == NULL)\n\t\treturn ENOMEM;\n\tpos = packet;\n\n\t/* Ethernet header */\n\tif (!(\n\t      /* SONMP multicast address as target */\n\t      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t      /* Source MAC addresss */\n\t      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t      /* SONMP frame is of fixed size */\n\t      POKE_UINT16(SONMP_SIZE)))\n\t\tgoto toobig;\n\n\t/* LLC header */\n\tif (!(\n\t      /* DSAP and SSAP */\n\t      POKE_UINT8(0xaa) && POKE_UINT8(0xaa) &&\n\t      /* Control field */\n\t      POKE_UINT8(0x03) &&\n\t      /* ORG */\n\t      POKE_BYTES(llcorg, sizeof(llcorg)) &&\n\t      POKE_SAVE(pos_pid) && /* We will modify PID later to\n\t\t\t\t       create a new frame */\n\t      POKE_UINT16(LLC_PID_SONMP_HELLO)))\n\t\tgoto toobig;\n\n\n\taddress.s_addr = htonl(INADDR_ANY);\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\tif (mgmt->m_family == LLDPD_AF_IPV4) {\n\t\t\taddress.s_addr = mgmt->m_addr.inet.s_addr;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* SONMP */\n\tif (!(\n\t\t  /* Our IP address */\n\t\t  POKE_BYTES(&address, sizeof(struct in_addr)) &&\n\t\t  /* Segment on three bytes, we don't have slots, so we\n\t\t skip the first two bytes */\n\t\t  POKE_UINT16(0) &&\n\t\t  POKE_UINT8(hardware->h_ifindex) &&\n\t\t  POKE_UINT8(1) &&  /* Chassis: Other */\n\t\t  POKE_UINT8(12) &&\t/* Back: Ethernet, Fast Ethernet and Gigabit */\n\t\t  POKE_UINT8(SONMP_TOPOLOGY_NEW) && /* Should work. We have no state */\n\t\t  POKE_UINT8(1) &&\t/* Links: Dunno what it is */\n\t\t  POKE_SAVE(end)))\n\t\tgoto toobig;\n\t\t\t\t\n\tif (interfaces_send_helper(global, hardware,\n\t\t(char *)packet, end - packet) == -1) {\n\t\tlog_warn(\"sonmp\", \"unable to send packet on real device for %s\",\n\t\t\t   hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\tPOKE_RESTORE(pos_pid);\t/* Modify LLC PID */\n\t(void)POKE_UINT16(LLC_PID_SONMP_FLATNET);\n\tPOKE_RESTORE(packet);\t/* Go to the beginning */\n\tPEEK_DISCARD(ETHER_ADDR_LEN - 1); /* Modify the last byte of the MAC address */\n\t(void)POKE_UINT8(1);\n\n\tif (interfaces_send_helper(global, hardware,\n\t\t(char *)packet, end - packet) == -1) {\n\t\tlog_warn(\"sonmp\", \"unable to send second SONMP packet on real device for %s\",\n\t\t\t   hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\tfree(packet);\n\thardware->h_tx_cnt++;\n\treturn 0;\n toobig:\n\tfree(packet);\n\treturn -1;\n}\n\nint\nsonmp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tconst u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tstruct lldpd_mgmt *mgmt;\n\tint length, i;\n\tu_int8_t *pos;\n\tu_int8_t seg[3], rchassis;\n\tstruct in_addr address;\n\n\tlog_debug(\"sonmp\", \"decode SONMP PDU from %s\",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"sonmp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"sonmp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\tif (length < SONMP_SIZE) {\n\t\tlog_warnx(\"sonmp\", \"too short SONMP frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)\n\t\t/* There is two multicast address. We just handle only one of\n\t\t * them. */\n\t\tgoto malformed;\n\t/* We skip to LLC PID */\n\tPEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16;\n\tPEEK_DISCARD(6);\n\tif (PEEK_UINT16 != LLC_PID_SONMP_HELLO) {\n\t\tlog_debug(\"sonmp\", \"incorrect LLC protocol ID received for SONMP on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_ADDR;\n\tif ((chassis->c_id = calloc(1, sizeof(struct in_addr) + 1)) == NULL) {\n\t\tlog_warn(\"sonmp\", \"unable to allocate memory for chassis id on %s\",\n\t\t\thardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_id_len = sizeof(struct in_addr) + 1;\n\tchassis->c_id[0] = 1;\n\tPEEK_BYTES(&address, sizeof(struct in_addr));\n\tmemcpy(chassis->c_id + 1, &address, sizeof(struct in_addr));\n\tif (asprintf(&chassis->c_name, \"%s\", inet_ntoa(address)) == -1) {\n\t\tlog_warnx(\"sonmp\", \"unable to write chassis name for %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_BYTES(seg, sizeof(seg));\n\trchassis = PEEK_UINT8;\n\tfor (i=0; sonmp_chassis_types[i].type != 0; i++) {\n\t\tif (sonmp_chassis_types[i].type == rchassis)\n\t\t\tbreak;\n\t}\n\tif (asprintf(&chassis->c_descr, \"%s\",\n\t\tsonmp_chassis_types[i].description) == -1) {\n\t\tlog_warnx(\"sonmp\", \"unable to write chassis description for %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0);\n\tif (mgmt == NULL) {\n\t\tif (errno == ENOMEM)\n\t\t\tlog_warn(\"sonmp\", \"unable to allocate memory for management address\");\n\t\telse\n\t\t\tlog_warn(\"sonmp\", \"too large management address received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\tchassis->c_ttl = cfg?(cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold):\n\t    LLDPD_TTL;\n\n\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_LOCAL;\n\tif (asprintf(&port->p_id, \"%02x-%02x-%02x\",\n\t\tseg[0], seg[1], seg[2]) == -1) {\n\t\tlog_warn(\"sonmp\", \"unable to allocate memory for port id on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tport->p_id_len = strlen(port->p_id);\n\n\t/* Port description depend on the number of segments */\n\tif ((seg[0] == 0) && (seg[1] == 0)) {\n\t\tif (asprintf(&port->p_descr, \"port %d\",\n\t\t\tseg[2]) == -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else if (seg[0] == 0) {\n\t\tif (asprintf(&port->p_descr, \"port %d/%d\",\n\t\t\tseg[1], seg[2]) == -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else {\n\t\tif (asprintf(&port->p_descr, \"port %x:%x:%x\",\n\t\t\tseg[0], seg[1], seg[2]) == -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}\n\n#endif /* ENABLE_SONMP */\n"], "filenames": ["src/daemon/lldpd.c", "src/daemon/protocols/cdp.c", "src/daemon/protocols/edp.c", "src/daemon/protocols/lldp.c", "src/daemon/protocols/sonmp.c"], "buggy_code_start_loc": [201, 28, 28, 23, 27], "buggy_code_end_loc": [202, 443, 29, 756, 363], "fixing_code_start_loc": [200, 27, 27, 22, 26], "fixing_code_end_loc": [200, 447, 27, 758, 365], "type": "CWE-617", "message": "lldpd before 0.8.0 allows remote attackers to cause a denial of service (assertion failure and daemon crash) via a malformed packet.", "other": {"cve": {"id": "CVE-2015-8012", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-28T19:15:12.810", "lastModified": "2020-01-31T15:03:08.913", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lldpd before 0.8.0 allows remote attackers to cause a denial of service (assertion failure and daemon crash) via a malformed packet."}, {"lang": "es", "value": "lldpd versiones anteriores a 0.8.0, permite a atacantes remotos causar una denegaci\u00f3n de servicio (fallo de aserci\u00f3n y bloqueo del demonio) por medio de un paquete malformado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lldpd_project:lldpd:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.0", "matchCriteriaId": "2D964F02-1DDC-4652-9E39-193A47426C74"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2015/10/18/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/10/30/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/vincentbernat/lldpd/commit/793526f8884455f43daecd0a2c46772388417a00", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vincentbernat/lldpd/commit/9221b5c249f9e4843f77c7f888d5705348d179c0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vincentbernat/lldpd/commit/793526f8884455f43daecd0a2c46772388417a00"}}