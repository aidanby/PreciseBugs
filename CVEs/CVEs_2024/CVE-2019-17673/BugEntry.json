{"buggy_code": ["<?php\n/**\n * REST API functions.\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.4.0\n */\n\n/**\n * Version number for our API.\n *\n * @var string\n */\ndefine( 'REST_API_VERSION', '2.0' );\n\n/**\n * Registers a REST API route.\n *\n * Note: Do not use before the {@see 'rest_api_init'} hook.\n *\n * @since 4.4.0\n * @since 5.1.0 Added a _doing_it_wrong() notice when not called on or after the rest_api_init hook.\n *\n * @param string $namespace The first URL segment after core prefix. Should be unique to your package/plugin.\n * @param string $route     The base URL for route you are adding.\n * @param array  $args      Optional. Either an array of options for the endpoint, or an array of arrays for\n *                          multiple methods. Default empty array.\n * @param bool   $override  Optional. If the route already exists, should we override it? True overrides,\n *                          false merges (with newer overriding if duplicate keys exist). Default false.\n * @return bool True on success, false on error.\n */\nfunction register_rest_route( $namespace, $route, $args = array(), $override = false ) {\n\tif ( empty( $namespace ) ) {\n\t\t/*\n\t\t * Non-namespaced routes are not allowed, with the exception of the main\n\t\t * and namespace indexes. If you really need to register a\n\t\t * non-namespaced route, call `WP_REST_Server::register_route` directly.\n\t\t */\n\t\t_doing_it_wrong( 'register_rest_route', __( 'Routes must be namespaced with plugin or theme name and version.' ), '4.4.0' );\n\t\treturn false;\n\t} elseif ( empty( $route ) ) {\n\t\t_doing_it_wrong( 'register_rest_route', __( 'Route must be specified.' ), '4.4.0' );\n\t\treturn false;\n\t}\n\n\tif ( ! did_action( 'rest_api_init' ) ) {\n\t\t_doing_it_wrong(\n\t\t\t'register_rest_route',\n\t\t\tsprintf(\n\t\t\t\t/* translators: %s: rest_api_init */\n\t\t\t\t__( 'REST API routes must be registered on the %s action.' ),\n\t\t\t\t'<code>rest_api_init</code>'\n\t\t\t),\n\t\t\t'5.1.0'\n\t\t);\n\t}\n\n\tif ( isset( $args['args'] ) ) {\n\t\t$common_args = $args['args'];\n\t\tunset( $args['args'] );\n\t} else {\n\t\t$common_args = array();\n\t}\n\n\tif ( isset( $args['callback'] ) ) {\n\t\t// Upgrade a single set to multiple.\n\t\t$args = array( $args );\n\t}\n\n\t$defaults = array(\n\t\t'methods'  => 'GET',\n\t\t'callback' => null,\n\t\t'args'     => array(),\n\t);\n\tforeach ( $args as $key => &$arg_group ) {\n\t\tif ( ! is_numeric( $key ) ) {\n\t\t\t// Route option, skip here.\n\t\t\tcontinue;\n\t\t}\n\n\t\t$arg_group         = array_merge( $defaults, $arg_group );\n\t\t$arg_group['args'] = array_merge( $common_args, $arg_group['args'] );\n\t}\n\n\t$full_route = '/' . trim( $namespace, '/' ) . '/' . trim( $route, '/' );\n\trest_get_server()->register_route( $namespace, $full_route, $args, $override );\n\treturn true;\n}\n\n/**\n * Registers a new field on an existing WordPress object type.\n *\n * @since 4.7.0\n *\n * @global array $wp_rest_additional_fields Holds registered fields, organized\n *                                          by object type.\n *\n * @param string|array $object_type Object(s) the field is being registered\n *                                  to, \"post\"|\"term\"|\"comment\" etc.\n * @param string $attribute         The attribute name.\n * @param array  $args {\n *     Optional. An array of arguments used to handle the registered field.\n *\n *     @type callable|null $get_callback    Optional. The callback function used to retrieve the field value. Default is\n *                                          'null', the field will not be returned in the response. The function will\n *                                          be passed the prepared object data.\n *     @type callable|null $update_callback Optional. The callback function used to set and update the field value. Default\n *                                          is 'null', the value cannot be set or updated. The function will be passed\n *                                          the model object, like WP_Post.\n *     @type array|null $schema             Optional. The callback function used to create the schema for this field.\n *                                          Default is 'null', no schema entry will be returned.\n * }\n */\nfunction register_rest_field( $object_type, $attribute, $args = array() ) {\n\t$defaults = array(\n\t\t'get_callback'    => null,\n\t\t'update_callback' => null,\n\t\t'schema'          => null,\n\t);\n\n\t$args = wp_parse_args( $args, $defaults );\n\n\tglobal $wp_rest_additional_fields;\n\n\t$object_types = (array) $object_type;\n\n\tforeach ( $object_types as $object_type ) {\n\t\t$wp_rest_additional_fields[ $object_type ][ $attribute ] = $args;\n\t}\n}\n\n/**\n * Registers rewrite rules for the API.\n *\n * @since 4.4.0\n *\n * @see rest_api_register_rewrites()\n * @global WP $wp Current WordPress environment instance.\n */\nfunction rest_api_init() {\n\trest_api_register_rewrites();\n\n\tglobal $wp;\n\t$wp->add_query_var( 'rest_route' );\n}\n\n/**\n * Adds REST rewrite rules.\n *\n * @since 4.4.0\n *\n * @see add_rewrite_rule()\n * @global WP_Rewrite $wp_rewrite WordPress rewrite component.\n */\nfunction rest_api_register_rewrites() {\n\tglobal $wp_rewrite;\n\n\tadd_rewrite_rule( '^' . rest_get_url_prefix() . '/?$', 'index.php?rest_route=/', 'top' );\n\tadd_rewrite_rule( '^' . rest_get_url_prefix() . '/(.*)?', 'index.php?rest_route=/$matches[1]', 'top' );\n\tadd_rewrite_rule( '^' . $wp_rewrite->index . '/' . rest_get_url_prefix() . '/?$', 'index.php?rest_route=/', 'top' );\n\tadd_rewrite_rule( '^' . $wp_rewrite->index . '/' . rest_get_url_prefix() . '/(.*)?', 'index.php?rest_route=/$matches[1]', 'top' );\n}\n\n/**\n * Registers the default REST API filters.\n *\n * Attached to the {@see 'rest_api_init'} action\n * to make testing and disabling these filters easier.\n *\n * @since 4.4.0\n */\nfunction rest_api_default_filters() {\n\t// Deprecated reporting.\n\tadd_action( 'deprecated_function_run', 'rest_handle_deprecated_function', 10, 3 );\n\tadd_filter( 'deprecated_function_trigger_error', '__return_false' );\n\tadd_action( 'deprecated_argument_run', 'rest_handle_deprecated_argument', 10, 3 );\n\tadd_filter( 'deprecated_argument_trigger_error', '__return_false' );\n\n\t// Default serving.\n\tadd_filter( 'rest_pre_serve_request', 'rest_send_cors_headers' );\n\tadd_filter( 'rest_post_dispatch', 'rest_send_allow_header', 10, 3 );\n\tadd_filter( 'rest_post_dispatch', 'rest_filter_response_fields', 10, 3 );\n\n\tadd_filter( 'rest_pre_dispatch', 'rest_handle_options_request', 10, 3 );\n}\n\n/**\n * Registers default REST API routes.\n *\n * @since 4.7.0\n */\nfunction create_initial_rest_routes() {\n\tforeach ( get_post_types( array( 'show_in_rest' => true ), 'objects' ) as $post_type ) {\n\t\t$controller = $post_type->get_rest_controller();\n\n\t\tif ( ! $controller ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$controller->register_routes();\n\n\t\tif ( post_type_supports( $post_type->name, 'revisions' ) ) {\n\t\t\t$revisions_controller = new WP_REST_Revisions_Controller( $post_type->name );\n\t\t\t$revisions_controller->register_routes();\n\t\t}\n\n\t\tif ( 'attachment' !== $post_type->name ) {\n\t\t\t$autosaves_controller = new WP_REST_Autosaves_Controller( $post_type->name );\n\t\t\t$autosaves_controller->register_routes();\n\t\t}\n\t}\n\n\t// Post types.\n\t$controller = new WP_REST_Post_Types_Controller;\n\t$controller->register_routes();\n\n\t// Post statuses.\n\t$controller = new WP_REST_Post_Statuses_Controller;\n\t$controller->register_routes();\n\n\t// Taxonomies.\n\t$controller = new WP_REST_Taxonomies_Controller;\n\t$controller->register_routes();\n\n\t// Terms.\n\tforeach ( get_taxonomies( array( 'show_in_rest' => true ), 'object' ) as $taxonomy ) {\n\t\t$class = ! empty( $taxonomy->rest_controller_class ) ? $taxonomy->rest_controller_class : 'WP_REST_Terms_Controller';\n\n\t\tif ( ! class_exists( $class ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\t$controller = new $class( $taxonomy->name );\n\t\tif ( ! is_subclass_of( $controller, 'WP_REST_Controller' ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$controller->register_routes();\n\t}\n\n\t// Users.\n\t$controller = new WP_REST_Users_Controller;\n\t$controller->register_routes();\n\n\t// Comments.\n\t$controller = new WP_REST_Comments_Controller;\n\t$controller->register_routes();\n\n\t/**\n\t * Filters the search handlers to use in the REST search controller.\n\t *\n\t * @since 5.0.0\n\t *\n\t * @param array $search_handlers List of search handlers to use in the controller. Each search\n\t *                               handler instance must extend the `WP_REST_Search_Handler` class.\n\t *                               Default is only a handler for posts.\n\t */\n\t$search_handlers = apply_filters( 'wp_rest_search_handlers', array( new WP_REST_Post_Search_Handler() ) );\n\n\t$controller = new WP_REST_Search_Controller( $search_handlers );\n\t$controller->register_routes();\n\n\t// Block Renderer.\n\t$controller = new WP_REST_Block_Renderer_Controller;\n\t$controller->register_routes();\n\n\t// Settings.\n\t$controller = new WP_REST_Settings_Controller;\n\t$controller->register_routes();\n\n\t// Themes.\n\t$controller = new WP_REST_Themes_Controller;\n\t$controller->register_routes();\n\n}\n\n/**\n * Loads the REST API.\n *\n * @since 4.4.0\n *\n * @global WP $wp Current WordPress environment instance.\n */\nfunction rest_api_loaded() {\n\tif ( empty( $GLOBALS['wp']->query_vars['rest_route'] ) ) {\n\t\treturn;\n\t}\n\n\t/**\n\t * Whether this is a REST Request.\n\t *\n\t * @since 4.4.0\n\t * @var bool\n\t */\n\tdefine( 'REST_REQUEST', true );\n\n\t// Initialize the server.\n\t$server = rest_get_server();\n\n\t// Fire off the request.\n\t$route = untrailingslashit( $GLOBALS['wp']->query_vars['rest_route'] );\n\tif ( empty( $route ) ) {\n\t\t$route = '/';\n\t}\n\t$server->serve_request( $route );\n\n\t// We're done.\n\tdie();\n}\n\n/**\n * Retrieves the URL prefix for any API resource.\n *\n * @since 4.4.0\n *\n * @return string Prefix.\n */\nfunction rest_get_url_prefix() {\n\t/**\n\t * Filters the REST URL prefix.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param string $prefix URL prefix. Default 'wp-json'.\n\t */\n\treturn apply_filters( 'rest_url_prefix', 'wp-json' );\n}\n\n/**\n * Retrieves the URL to a REST endpoint on a site.\n *\n * Note: The returned URL is NOT escaped.\n *\n * @since 4.4.0\n *\n * @todo Check if this is even necessary\n * @global WP_Rewrite $wp_rewrite WordPress rewrite component.\n *\n * @param int    $blog_id Optional. Blog ID. Default of null returns URL for current blog.\n * @param string $path    Optional. REST route. Default '/'.\n * @param string $scheme  Optional. Sanitization scheme. Default 'rest'.\n * @return string Full URL to the endpoint.\n */\nfunction get_rest_url( $blog_id = null, $path = '/', $scheme = 'rest' ) {\n\tif ( empty( $path ) ) {\n\t\t$path = '/';\n\t}\n\n\t$path = '/' . ltrim( $path, '/' );\n\n\tif ( is_multisite() && get_blog_option( $blog_id, 'permalink_structure' ) || get_option( 'permalink_structure' ) ) {\n\t\tglobal $wp_rewrite;\n\n\t\tif ( $wp_rewrite->using_index_permalinks() ) {\n\t\t\t$url = get_home_url( $blog_id, $wp_rewrite->index . '/' . rest_get_url_prefix(), $scheme );\n\t\t} else {\n\t\t\t$url = get_home_url( $blog_id, rest_get_url_prefix(), $scheme );\n\t\t}\n\n\t\t$url .= $path;\n\t} else {\n\t\t$url = trailingslashit( get_home_url( $blog_id, '', $scheme ) );\n\t\t// nginx only allows HTTP/1.0 methods when redirecting from / to /index.php\n\t\t// To work around this, we manually add index.php to the URL, avoiding the redirect.\n\t\tif ( 'index.php' !== substr( $url, 9 ) ) {\n\t\t\t$url .= 'index.php';\n\t\t}\n\n\t\t$url = add_query_arg( 'rest_route', $path, $url );\n\t}\n\n\tif ( is_ssl() && isset( $_SERVER['SERVER_NAME'] ) ) {\n\t\t// If the current host is the same as the REST URL host, force the REST URL scheme to HTTPS.\n\t\tif ( $_SERVER['SERVER_NAME'] === parse_url( get_home_url( $blog_id ), PHP_URL_HOST ) ) {\n\t\t\t$url = set_url_scheme( $url, 'https' );\n\t\t}\n\t}\n\n\tif ( is_admin() && force_ssl_admin() ) {\n\t\t// In this situation the home URL may be http:, and `is_ssl()` may be\n\t\t// false, but the admin is served over https: (one way or another), so\n\t\t// REST API usage will be blocked by browsers unless it is also served\n\t\t// over HTTPS.\n\t\t$url = set_url_scheme( $url, 'https' );\n\t}\n\n\t/**\n\t * Filters the REST URL.\n\t *\n\t * Use this filter to adjust the url returned by the get_rest_url() function.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param string $url     REST URL.\n\t * @param string $path    REST route.\n\t * @param int    $blog_id Blog ID.\n\t * @param string $scheme  Sanitization scheme.\n\t */\n\treturn apply_filters( 'rest_url', $url, $path, $blog_id, $scheme );\n}\n\n/**\n * Retrieves the URL to a REST endpoint.\n *\n * Note: The returned URL is NOT escaped.\n *\n * @since 4.4.0\n *\n * @param string $path   Optional. REST route. Default empty.\n * @param string $scheme Optional. Sanitization scheme. Default 'rest'.\n * @return string Full URL to the endpoint.\n */\nfunction rest_url( $path = '', $scheme = 'rest' ) {\n\treturn get_rest_url( null, $path, $scheme );\n}\n\n/**\n * Do a REST request.\n *\n * Used primarily to route internal requests through WP_REST_Server.\n *\n * @since 4.4.0\n *\n * @param WP_REST_Request|string $request Request.\n * @return WP_REST_Response REST response.\n */\nfunction rest_do_request( $request ) {\n\t$request = rest_ensure_request( $request );\n\treturn rest_get_server()->dispatch( $request );\n}\n\n/**\n * Retrieves the current REST server instance.\n *\n * Instantiates a new instance if none exists already.\n *\n * @since 4.5.0\n *\n * @global WP_REST_Server $wp_rest_server REST server instance.\n *\n * @return WP_REST_Server REST server instance.\n */\nfunction rest_get_server() {\n\t/* @var WP_REST_Server $wp_rest_server */\n\tglobal $wp_rest_server;\n\n\tif ( empty( $wp_rest_server ) ) {\n\t\t/**\n\t\t * Filters the REST Server Class.\n\t\t *\n\t\t * This filter allows you to adjust the server class used by the API, using a\n\t\t * different class to handle requests.\n\t\t *\n\t\t * @since 4.4.0\n\t\t *\n\t\t * @param string $class_name The name of the server class. Default 'WP_REST_Server'.\n\t\t */\n\t\t$wp_rest_server_class = apply_filters( 'wp_rest_server_class', 'WP_REST_Server' );\n\t\t$wp_rest_server       = new $wp_rest_server_class;\n\n\t\t/**\n\t\t * Fires when preparing to serve an API request.\n\t\t *\n\t\t * Endpoint objects should be created and register their hooks on this action rather\n\t\t * than another action to ensure they're only loaded when needed.\n\t\t *\n\t\t * @since 4.4.0\n\t\t *\n\t\t * @param WP_REST_Server $wp_rest_server Server object.\n\t\t */\n\t\tdo_action( 'rest_api_init', $wp_rest_server );\n\t}\n\n\treturn $wp_rest_server;\n}\n\n/**\n * Ensures request arguments are a request object (for consistency).\n *\n * @since 4.4.0\n * @since 5.3.0 Accept string argument for the request path.\n *\n * @param array|string|WP_REST_Request $request Request to check.\n * @return WP_REST_Request REST request instance.\n */\nfunction rest_ensure_request( $request ) {\n\tif ( $request instanceof WP_REST_Request ) {\n\t\treturn $request;\n\t}\n\n\tif ( is_string( $request ) ) {\n\t\treturn new WP_REST_Request( 'GET', $request );\n\t}\n\n\treturn new WP_REST_Request( 'GET', '', $request );\n}\n\n/**\n * Ensures a REST response is a response object (for consistency).\n *\n * This implements WP_HTTP_Response, allowing usage of `set_status`/`header`/etc\n * without needing to double-check the object. Will also allow WP_Error to indicate error\n * responses, so users should immediately check for this value.\n *\n * @since 4.4.0\n *\n * @param WP_Error|WP_HTTP_Response|mixed $response Response to check.\n * @return WP_REST_Response|mixed If response generated an error, WP_Error, if response\n *                                is already an instance, WP_HTTP_Response, otherwise\n *                                returns a new WP_REST_Response instance.\n */\nfunction rest_ensure_response( $response ) {\n\tif ( is_wp_error( $response ) ) {\n\t\treturn $response;\n\t}\n\n\tif ( $response instanceof WP_HTTP_Response ) {\n\t\treturn $response;\n\t}\n\n\treturn new WP_REST_Response( $response );\n}\n\n/**\n * Handles _deprecated_function() errors.\n *\n * @since 4.4.0\n *\n * @param string $function    The function that was called.\n * @param string $replacement The function that should have been called.\n * @param string $version     Version.\n */\nfunction rest_handle_deprecated_function( $function, $replacement, $version ) {\n\tif ( ! WP_DEBUG || headers_sent() ) {\n\t\treturn;\n\t}\n\tif ( ! empty( $replacement ) ) {\n\t\t/* translators: 1: Function name, 2: WordPress version number, 3: New function name. */\n\t\t$string = sprintf( __( '%1$s (since %2$s; use %3$s instead)' ), $function, $version, $replacement );\n\t} else {\n\t\t/* translators: 1: Function name, 2: WordPress version number. */\n\t\t$string = sprintf( __( '%1$s (since %2$s; no alternative available)' ), $function, $version );\n\t}\n\n\theader( sprintf( 'X-WP-DeprecatedFunction: %s', $string ) );\n}\n\n/**\n * Handles _deprecated_argument() errors.\n *\n * @since 4.4.0\n *\n * @param string $function    The function that was called.\n * @param string $message     A message regarding the change.\n * @param string $version     Version.\n */\nfunction rest_handle_deprecated_argument( $function, $message, $version ) {\n\tif ( ! WP_DEBUG || headers_sent() ) {\n\t\treturn;\n\t}\n\tif ( ! empty( $message ) ) {\n\t\t/* translators: 1: Function name, 2: WordPress version number, 3: Error message. */\n\t\t$string = sprintf( __( '%1$s (since %2$s; %3$s)' ), $function, $version, $message );\n\t} else {\n\t\t/* translators: 1: Function name, 2: WordPress version number. */\n\t\t$string = sprintf( __( '%1$s (since %2$s; no alternative available)' ), $function, $version );\n\t}\n\n\theader( sprintf( 'X-WP-DeprecatedParam: %s', $string ) );\n}\n\n/**\n * Sends Cross-Origin Resource Sharing headers with API requests.\n *\n * @since 4.4.0\n *\n * @param mixed $value Response data.\n * @return mixed Response data.\n */\nfunction rest_send_cors_headers( $value ) {\n\t$origin = get_http_origin();\n\n\tif ( $origin ) {\n\t\t// Requests from file:// and data: URLs send \"Origin: null\"\n\t\tif ( 'null' !== $origin ) {\n\t\t\t$origin = esc_url_raw( $origin );\n\t\t}\n\t\theader( 'Access-Control-Allow-Origin: ' . $origin );\n\t\theader( 'Access-Control-Allow-Methods: OPTIONS, GET, POST, PUT, PATCH, DELETE' );\n\t\theader( 'Access-Control-Allow-Credentials: true' );\n\t\theader( 'Vary: Origin' );\n\t}\n\n\treturn $value;\n}\n\n/**\n * Handles OPTIONS requests for the server.\n *\n * This is handled outside of the server code, as it doesn't obey normal route\n * mapping.\n *\n * @since 4.4.0\n *\n * @param mixed           $response Current response, either response or `null` to indicate pass-through.\n * @param WP_REST_Server  $handler  ResponseHandler instance (usually WP_REST_Server).\n * @param WP_REST_Request $request  The request that was used to make current response.\n * @return WP_REST_Response Modified response, either response or `null` to indicate pass-through.\n */\nfunction rest_handle_options_request( $response, $handler, $request ) {\n\tif ( ! empty( $response ) || $request->get_method() !== 'OPTIONS' ) {\n\t\treturn $response;\n\t}\n\n\t$response = new WP_REST_Response();\n\t$data     = array();\n\n\tforeach ( $handler->get_routes() as $route => $endpoints ) {\n\t\t$match = preg_match( '@^' . $route . '$@i', $request->get_route(), $matches );\n\n\t\tif ( ! $match ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$args = array();\n\t\tforeach ( $matches as $param => $value ) {\n\t\t\tif ( ! is_int( $param ) ) {\n\t\t\t\t$args[ $param ] = $value;\n\t\t\t}\n\t\t}\n\n\t\tforeach ( $endpoints as $endpoint ) {\n\t\t\t// Remove the redundant preg_match argument.\n\t\t\tunset( $args[0] );\n\n\t\t\t$request->set_url_params( $args );\n\t\t\t$request->set_attributes( $endpoint );\n\t\t}\n\n\t\t$data = $handler->get_data_for_route( $route, $endpoints, 'help' );\n\t\t$response->set_matched_route( $route );\n\t\tbreak;\n\t}\n\n\t$response->set_data( $data );\n\treturn $response;\n}\n\n/**\n * Sends the \"Allow\" header to state all methods that can be sent to the current route.\n *\n * @since 4.4.0\n *\n * @param WP_REST_Response $response Current response being served.\n * @param WP_REST_Server   $server   ResponseHandler instance (usually WP_REST_Server).\n * @param WP_REST_Request  $request  The request that was used to make current response.\n * @return WP_REST_Response Response to be served, with \"Allow\" header if route has allowed methods.\n */\nfunction rest_send_allow_header( $response, $server, $request ) {\n\t$matched_route = $response->get_matched_route();\n\n\tif ( ! $matched_route ) {\n\t\treturn $response;\n\t}\n\n\t$routes = $server->get_routes();\n\n\t$allowed_methods = array();\n\n\t// Get the allowed methods across the routes.\n\tforeach ( $routes[ $matched_route ] as $_handler ) {\n\t\tforeach ( $_handler['methods'] as $handler_method => $value ) {\n\n\t\t\tif ( ! empty( $_handler['permission_callback'] ) ) {\n\n\t\t\t\t$permission = call_user_func( $_handler['permission_callback'], $request );\n\n\t\t\t\t$allowed_methods[ $handler_method ] = true === $permission;\n\t\t\t} else {\n\t\t\t\t$allowed_methods[ $handler_method ] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Strip out all the methods that are not allowed (false values).\n\t$allowed_methods = array_filter( $allowed_methods );\n\n\tif ( $allowed_methods ) {\n\t\t$response->header( 'Allow', implode( ', ', array_map( 'strtoupper', array_keys( $allowed_methods ) ) ) );\n\t}\n\n\treturn $response;\n}\n\n/**\n * Recursively computes the intersection of arrays using keys for comparison.\n *\n * @param  array $array1 The array with master keys to check.\n * @param  array $array2 An array to compare keys against.\n *\n * @return array An associative array containing all the entries of array1 which have keys that are present in all arguments.\n */\nfunction _rest_array_intersect_key_recursive( $array1, $array2 ) {\n\t$array1 = array_intersect_key( $array1, $array2 );\n\tforeach ( $array1 as $key => $value ) {\n\t\tif ( is_array( $value ) && is_array( $array2[ $key ] ) ) {\n\t\t\t$array1[ $key ] = _rest_array_intersect_key_recursive( $value, $array2[ $key ] );\n\t\t}\n\t}\n\treturn $array1;\n}\n\n/**\n * Filter the API response to include only a white-listed set of response object fields.\n *\n * @since 4.8.0\n *\n * @param WP_REST_Response $response Current response being served.\n * @param WP_REST_Server   $server   ResponseHandler instance (usually WP_REST_Server).\n * @param WP_REST_Request  $request  The request that was used to make current response.\n *\n * @return WP_REST_Response Response to be served, trimmed down to contain a subset of fields.\n */\nfunction rest_filter_response_fields( $response, $server, $request ) {\n\tif ( ! isset( $request['_fields'] ) || $response->is_error() ) {\n\t\treturn $response;\n\t}\n\n\t$data = $response->get_data();\n\n\t$fields = wp_parse_list( $request['_fields'] );\n\n\tif ( 0 === count( $fields ) ) {\n\t\treturn $response;\n\t}\n\n\t// Trim off outside whitespace from the comma delimited list.\n\t$fields = array_map( 'trim', $fields );\n\n\t// Create nested array of accepted field hierarchy.\n\t$fields_as_keyed = array();\n\tforeach ( $fields as $field ) {\n\t\t$parts = explode( '.', $field );\n\t\t$ref   = &$fields_as_keyed;\n\t\twhile ( count( $parts ) > 1 ) {\n\t\t\t$next = array_shift( $parts );\n\t\t\tif ( isset( $ref[ $next ] ) && true === $ref[ $next ] ) {\n\t\t\t\t// Skip any sub-properties if their parent prop is already marked for inclusion.\n\t\t\t\tbreak 2;\n\t\t\t}\n\t\t\t$ref[ $next ] = isset( $ref[ $next ] ) ? $ref[ $next ] : array();\n\t\t\t$ref          = &$ref[ $next ];\n\t\t}\n\t\t$last         = array_shift( $parts );\n\t\t$ref[ $last ] = true;\n\t}\n\n\tif ( wp_is_numeric_array( $data ) ) {\n\t\t$new_data = array();\n\t\tforeach ( $data as $item ) {\n\t\t\t$new_data[] = _rest_array_intersect_key_recursive( $item, $fields_as_keyed );\n\t\t}\n\t} else {\n\t\t$new_data = _rest_array_intersect_key_recursive( $data, $fields_as_keyed );\n\t}\n\n\t$response->set_data( $new_data );\n\n\treturn $response;\n}\n\n/**\n * Given an array of fields to include in a response, some of which may be\n * `nested.fields`, determine whether the provided field should be included\n * in the response body.\n *\n * If a parent field is passed in, the presence of any nested field within\n * that parent will cause the method to return `true`. For example \"title\"\n * will return true if any of `title`, `title.raw` or `title.rendered` is\n * provided.\n *\n * @since 5.3.0\n *\n * @param string $field  A field to test for inclusion in the response body.\n * @param array  $fields An array of string fields supported by the endpoint.\n * @return bool Whether to include the field or not.\n */\nfunction rest_is_field_included( $field, $fields ) {\n\tif ( in_array( $field, $fields, true ) ) {\n\t\treturn true;\n\t}\n\tforeach ( $fields as $accepted_field ) {\n\t\t// Check to see if $field is the parent of any item in $fields.\n\t\t// A field \"parent\" should be accepted if \"parent.child\" is accepted.\n\t\tif ( strpos( $accepted_field, \"$field.\" ) === 0 ) {\n\t\t\treturn true;\n\t\t}\n\t\t// Conversely, if \"parent\" is accepted, all \"parent.child\" fields should\n\t\t// also be accepted.\n\t\tif ( strpos( $field, \"$accepted_field.\" ) === 0 ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Adds the REST API URL to the WP RSD endpoint.\n *\n * @since 4.4.0\n *\n * @see get_rest_url()\n */\nfunction rest_output_rsd() {\n\t$api_root = get_rest_url();\n\n\tif ( empty( $api_root ) ) {\n\t\treturn;\n\t}\n\t?>\n\t<api name=\"WP-API\" blogID=\"1\" preferred=\"false\" apiLink=\"<?php echo esc_url( $api_root ); ?>\" />\n\t<?php\n}\n\n/**\n * Outputs the REST API link tag into page header.\n *\n * @since 4.4.0\n *\n * @see get_rest_url()\n */\nfunction rest_output_link_wp_head() {\n\t$api_root = get_rest_url();\n\n\tif ( empty( $api_root ) ) {\n\t\treturn;\n\t}\n\n\techo \"<link rel='https://api.w.org/' href='\" . esc_url( $api_root ) . \"' />\\n\";\n}\n\n/**\n * Sends a Link header for the REST API.\n *\n * @since 4.4.0\n */\nfunction rest_output_link_header() {\n\tif ( headers_sent() ) {\n\t\treturn;\n\t}\n\n\t$api_root = get_rest_url();\n\n\tif ( empty( $api_root ) ) {\n\t\treturn;\n\t}\n\n\theader( 'Link: <' . esc_url_raw( $api_root ) . '>; rel=\"https://api.w.org/\"', false );\n}\n\n/**\n * Checks for errors when using cookie-based authentication.\n *\n * WordPress' built-in cookie authentication is always active\n * for logged in users. However, the API has to check nonces\n * for each request to ensure users are not vulnerable to CSRF.\n *\n * @since 4.4.0\n *\n * @global mixed          $wp_rest_auth_cookie\n *\n * @param WP_Error|mixed $result Error from another authentication handler,\n *                               null if we should handle it, or another value\n *                               if not.\n * @return WP_Error|mixed|bool WP_Error if the cookie is invalid, the $result, otherwise true.\n */\nfunction rest_cookie_check_errors( $result ) {\n\tif ( ! empty( $result ) ) {\n\t\treturn $result;\n\t}\n\n\tglobal $wp_rest_auth_cookie;\n\n\t/*\n\t * Is cookie authentication being used? (If we get an auth\n\t * error, but we're still logged in, another authentication\n\t * must have been used).\n\t */\n\tif ( true !== $wp_rest_auth_cookie && is_user_logged_in() ) {\n\t\treturn $result;\n\t}\n\n\t// Determine if there is a nonce.\n\t$nonce = null;\n\n\tif ( isset( $_REQUEST['_wpnonce'] ) ) {\n\t\t$nonce = $_REQUEST['_wpnonce'];\n\t} elseif ( isset( $_SERVER['HTTP_X_WP_NONCE'] ) ) {\n\t\t$nonce = $_SERVER['HTTP_X_WP_NONCE'];\n\t}\n\n\tif ( null === $nonce ) {\n\t\t// No nonce at all, so act as if it's an unauthenticated request.\n\t\twp_set_current_user( 0 );\n\t\treturn true;\n\t}\n\n\t// Check the nonce.\n\t$result = wp_verify_nonce( $nonce, 'wp_rest' );\n\n\tif ( ! $result ) {\n\t\treturn new WP_Error( 'rest_cookie_invalid_nonce', __( 'Cookie nonce is invalid' ), array( 'status' => 403 ) );\n\t}\n\n\t// Send a refreshed nonce in header.\n\trest_get_server()->send_header( 'X-WP-Nonce', wp_create_nonce( 'wp_rest' ) );\n\n\treturn true;\n}\n\n/**\n * Collects cookie authentication status.\n *\n * Collects errors from wp_validate_auth_cookie for use by rest_cookie_check_errors.\n *\n * @since 4.4.0\n *\n * @see current_action()\n * @global mixed $wp_rest_auth_cookie\n */\nfunction rest_cookie_collect_status() {\n\tglobal $wp_rest_auth_cookie;\n\n\t$status_type = current_action();\n\n\tif ( 'auth_cookie_valid' !== $status_type ) {\n\t\t$wp_rest_auth_cookie = substr( $status_type, 12 );\n\t\treturn;\n\t}\n\n\t$wp_rest_auth_cookie = true;\n}\n\n/**\n * Parses an RFC3339 time into a Unix timestamp.\n *\n * @since 4.4.0\n *\n * @param string $date      RFC3339 timestamp.\n * @param bool   $force_utc Optional. Whether to force UTC timezone instead of using\n *                          the timestamp's timezone. Default false.\n * @return int Unix timestamp.\n */\nfunction rest_parse_date( $date, $force_utc = false ) {\n\tif ( $force_utc ) {\n\t\t$date = preg_replace( '/[+-]\\d+:?\\d+$/', '+00:00', $date );\n\t}\n\n\t$regex = '#^\\d{4}-\\d{2}-\\d{2}[Tt ]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}(?::\\d{2})?)?$#';\n\n\tif ( ! preg_match( $regex, $date, $matches ) ) {\n\t\treturn false;\n\t}\n\n\treturn strtotime( $date );\n}\n\n/**\n * Parses a date into both its local and UTC equivalent, in MySQL datetime format.\n *\n * @since 4.4.0\n *\n * @see rest_parse_date()\n *\n * @param string $date   RFC3339 timestamp.\n * @param bool   $is_utc Whether the provided date should be interpreted as UTC. Default false.\n * @return array|null Local and UTC datetime strings, in MySQL datetime format (Y-m-d H:i:s),\n *                    null on failure.\n */\nfunction rest_get_date_with_gmt( $date, $is_utc = false ) {\n\t// Whether or not the original date actually has a timezone string\n\t// changes the way we need to do timezone conversion.  Store this info\n\t// before parsing the date, and use it later.\n\t$has_timezone = preg_match( '#(Z|[+-]\\d{2}(:\\d{2})?)$#', $date );\n\n\t$date = rest_parse_date( $date );\n\n\tif ( empty( $date ) ) {\n\t\treturn null;\n\t}\n\n\t// At this point $date could either be a local date (if we were passed a\n\t// *local* date without a timezone offset) or a UTC date (otherwise).\n\t// Timezone conversion needs to be handled differently between these two\n\t// cases.\n\tif ( ! $is_utc && ! $has_timezone ) {\n\t\t$local = gmdate( 'Y-m-d H:i:s', $date );\n\t\t$utc   = get_gmt_from_date( $local );\n\t} else {\n\t\t$utc   = gmdate( 'Y-m-d H:i:s', $date );\n\t\t$local = get_date_from_gmt( $utc );\n\t}\n\n\treturn array( $local, $utc );\n}\n\n/**\n * Returns a contextual HTTP error code for authorization failure.\n *\n * @since 4.7.0\n *\n * @return integer 401 if the user is not logged in, 403 if the user is logged in.\n */\nfunction rest_authorization_required_code() {\n\treturn is_user_logged_in() ? 403 : 401;\n}\n\n/**\n * Validate a request argument based on details registered to the route.\n *\n * @since 4.7.0\n *\n * @param  mixed            $value\n * @param  WP_REST_Request  $request\n * @param  string           $param\n * @return WP_Error|boolean\n */\nfunction rest_validate_request_arg( $value, $request, $param ) {\n\t$attributes = $request->get_attributes();\n\tif ( ! isset( $attributes['args'][ $param ] ) || ! is_array( $attributes['args'][ $param ] ) ) {\n\t\treturn true;\n\t}\n\t$args = $attributes['args'][ $param ];\n\n\treturn rest_validate_value_from_schema( $value, $args, $param );\n}\n\n/**\n * Sanitize a request argument based on details registered to the route.\n *\n * @since 4.7.0\n *\n * @param  mixed            $value\n * @param  WP_REST_Request  $request\n * @param  string           $param\n * @return mixed\n */\nfunction rest_sanitize_request_arg( $value, $request, $param ) {\n\t$attributes = $request->get_attributes();\n\tif ( ! isset( $attributes['args'][ $param ] ) || ! is_array( $attributes['args'][ $param ] ) ) {\n\t\treturn $value;\n\t}\n\t$args = $attributes['args'][ $param ];\n\n\treturn rest_sanitize_value_from_schema( $value, $args );\n}\n\n/**\n * Parse a request argument based on details registered to the route.\n *\n * Runs a validation check and sanitizes the value, primarily to be used via\n * the `sanitize_callback` arguments in the endpoint args registration.\n *\n * @since 4.7.0\n *\n * @param  mixed            $value\n * @param  WP_REST_Request  $request\n * @param  string           $param\n * @return mixed\n */\nfunction rest_parse_request_arg( $value, $request, $param ) {\n\t$is_valid = rest_validate_request_arg( $value, $request, $param );\n\n\tif ( is_wp_error( $is_valid ) ) {\n\t\treturn $is_valid;\n\t}\n\n\t$value = rest_sanitize_request_arg( $value, $request, $param );\n\n\treturn $value;\n}\n\n/**\n * Determines if an IP address is valid.\n *\n * Handles both IPv4 and IPv6 addresses.\n *\n * @since 4.7.0\n *\n * @param  string $ip IP address.\n * @return string|false The valid IP address, otherwise false.\n */\nfunction rest_is_ip_address( $ip ) {\n\t$ipv4_pattern = '/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/';\n\n\tif ( ! preg_match( $ipv4_pattern, $ip ) && ! Requests_IPv6::check_ipv6( $ip ) ) {\n\t\treturn false;\n\t}\n\n\treturn $ip;\n}\n\n/**\n * Changes a boolean-like value into the proper boolean value.\n *\n * @since 4.7.0\n *\n * @param bool|string|int $value The value being evaluated.\n * @return boolean Returns the proper associated boolean value.\n */\nfunction rest_sanitize_boolean( $value ) {\n\t// String values are translated to `true`; make sure 'false' is false.\n\tif ( is_string( $value ) ) {\n\t\t$value = strtolower( $value );\n\t\tif ( in_array( $value, array( 'false', '0' ), true ) ) {\n\t\t\t$value = false;\n\t\t}\n\t}\n\n\t// Everything else will map nicely to boolean.\n\treturn (bool) $value;\n}\n\n/**\n * Determines if a given value is boolean-like.\n *\n * @since 4.7.0\n *\n * @param bool|string $maybe_bool The value being evaluated.\n * @return boolean True if a boolean, otherwise false.\n */\nfunction rest_is_boolean( $maybe_bool ) {\n\tif ( is_bool( $maybe_bool ) ) {\n\t\treturn true;\n\t}\n\n\tif ( is_string( $maybe_bool ) ) {\n\t\t$maybe_bool = strtolower( $maybe_bool );\n\n\t\t$valid_boolean_values = array(\n\t\t\t'false',\n\t\t\t'true',\n\t\t\t'0',\n\t\t\t'1',\n\t\t);\n\n\t\treturn in_array( $maybe_bool, $valid_boolean_values, true );\n\t}\n\n\tif ( is_int( $maybe_bool ) ) {\n\t\treturn in_array( $maybe_bool, array( 0, 1 ), true );\n\t}\n\n\treturn false;\n}\n\n/**\n * Retrieves the avatar urls in various sizes.\n *\n * @since 4.7.0\n *\n * @see get_avatar_url()\n *\n * @param mixed $id_or_email The Gravatar to retrieve a URL for. Accepts a user_id, gravatar md5 hash,\n *                           user email, WP_User object, WP_Post object, or WP_Comment object.\n * @return array $urls Gravatar url for each size.\n */\nfunction rest_get_avatar_urls( $id_or_email ) {\n\t$avatar_sizes = rest_get_avatar_sizes();\n\n\t$urls = array();\n\tforeach ( $avatar_sizes as $size ) {\n\t\t$urls[ $size ] = get_avatar_url( $id_or_email, array( 'size' => $size ) );\n\t}\n\n\treturn $urls;\n}\n\n/**\n * Retrieves the pixel sizes for avatars.\n *\n * @since 4.7.0\n *\n * @return array List of pixel sizes for avatars. Default `[ 24, 48, 96 ]`.\n */\nfunction rest_get_avatar_sizes() {\n\t/**\n\t * Filters the REST avatar sizes.\n\t *\n\t * Use this filter to adjust the array of sizes returned by the\n\t * `rest_get_avatar_sizes` function.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param array $sizes An array of int values that are the pixel sizes for avatars.\n\t *                     Default `[ 24, 48, 96 ]`.\n\t */\n\treturn apply_filters( 'rest_avatar_sizes', array( 24, 48, 96 ) );\n}\n\n/**\n * Validate a value based on a schema.\n *\n * @since 4.7.0\n *\n * @param mixed  $value The value to validate.\n * @param array  $args  Schema array to use for validation.\n * @param string $param The parameter name, used in error messages.\n * @return true|WP_Error\n */\nfunction rest_validate_value_from_schema( $value, $args, $param = '' ) {\n\tif ( is_array( $args['type'] ) ) {\n\t\tforeach ( $args['type'] as $type ) {\n\t\t\t$type_args         = $args;\n\t\t\t$type_args['type'] = $type;\n\n\t\t\tif ( true === rest_validate_value_from_schema( $value, $type_args, $param ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t/* translators: 1: Parameter, 2: List of types. */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s' ), $param, implode( ',', $args['type'] ) ) );\n\t}\n\n\tif ( 'array' === $args['type'] ) {\n\t\tif ( ! is_null( $value ) ) {\n\t\t\t$value = wp_parse_list( $value );\n\t\t}\n\t\tif ( ! wp_is_numeric_array( $value ) ) {\n\t\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'array' ) );\n\t\t}\n\t\tforeach ( $value as $index => $v ) {\n\t\t\t$is_valid = rest_validate_value_from_schema( $v, $args['items'], $param . '[' . $index . ']' );\n\t\t\tif ( is_wp_error( $is_valid ) ) {\n\t\t\t\treturn $is_valid;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( 'object' === $args['type'] ) {\n\t\tif ( $value instanceof stdClass ) {\n\t\t\t$value = (array) $value;\n\t\t}\n\n\t\tif ( $value instanceof JsonSerializable ) {\n\t\t\t$value = $value->jsonSerialize();\n\t\t}\n\n\t\tif ( ! is_array( $value ) ) {\n\t\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'object' ) );\n\t\t}\n\n\t\tforeach ( $value as $property => $v ) {\n\t\t\tif ( isset( $args['properties'][ $property ] ) ) {\n\t\t\t\t$is_valid = rest_validate_value_from_schema( $v, $args['properties'][ $property ], $param . '[' . $property . ']' );\n\t\t\t\tif ( is_wp_error( $is_valid ) ) {\n\t\t\t\t\treturn $is_valid;\n\t\t\t\t}\n\t\t\t} elseif ( isset( $args['additionalProperties'] ) ) {\n\t\t\t\tif ( false === $args['additionalProperties'] ) {\n\t\t\t\t\t/* translators: %s: Property of an object. */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not a valid property of Object.' ), $property ) );\n\t\t\t\t}\n\n\t\t\t\tif ( is_array( $args['additionalProperties'] ) ) {\n\t\t\t\t\t$is_valid = rest_validate_value_from_schema( $v, $args['additionalProperties'], $param . '[' . $property . ']' );\n\t\t\t\t\tif ( is_wp_error( $is_valid ) ) {\n\t\t\t\t\t\treturn $is_valid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( 'null' === $args['type'] ) {\n\t\tif ( null !== $value ) {\n\t\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'null' ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tif ( ! empty( $args['enum'] ) ) {\n\t\tif ( ! in_array( $value, $args['enum'], true ) ) {\n\t\t\t/* translators: 1: Parameter, 2: List of valid values. */\n\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not one of %2$s.' ), $param, implode( ', ', $args['enum'] ) ) );\n\t\t}\n\t}\n\n\tif ( in_array( $args['type'], array( 'integer', 'number' ) ) && ! is_numeric( $value ) ) {\n\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, $args['type'] ) );\n\t}\n\n\tif ( 'integer' === $args['type'] && round( floatval( $value ) ) !== floatval( $value ) ) {\n\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'integer' ) );\n\t}\n\n\tif ( 'boolean' === $args['type'] && ! rest_is_boolean( $value ) ) {\n\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'boolean' ) );\n\t}\n\n\tif ( 'string' === $args['type'] && ! is_string( $value ) ) {\n\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'string' ) );\n\t}\n\n\tif ( isset( $args['format'] ) ) {\n\t\tswitch ( $args['format'] ) {\n\t\t\tcase 'date-time':\n\t\t\t\tif ( ! rest_parse_date( $value ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_date', __( 'Invalid date.' ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'email':\n\t\t\t\tif ( ! is_email( $value ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_email', __( 'Invalid email address.' ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'ip':\n\t\t\t\tif ( ! rest_is_ip_address( $value ) ) {\n\t\t\t\t\t/* translators: %s: IP address. */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%s is not a valid IP address.' ), $param ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( in_array( $args['type'], array( 'number', 'integer' ), true ) && ( isset( $args['minimum'] ) || isset( $args['maximum'] ) ) ) {\n\t\tif ( isset( $args['minimum'] ) && ! isset( $args['maximum'] ) ) {\n\t\t\tif ( ! empty( $args['exclusiveMinimum'] ) && $value <= $args['minimum'] ) {\n\t\t\t\t/* translators: 1: Parameter, 2: Minimum number. */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be greater than %2$d' ), $param, $args['minimum'] ) );\n\t\t\t} elseif ( empty( $args['exclusiveMinimum'] ) && $value < $args['minimum'] ) {\n\t\t\t\t/* translators: 1: Parameter, 2: Minimum number. */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be greater than or equal to %2$d' ), $param, $args['minimum'] ) );\n\t\t\t}\n\t\t} elseif ( isset( $args['maximum'] ) && ! isset( $args['minimum'] ) ) {\n\t\t\tif ( ! empty( $args['exclusiveMaximum'] ) && $value >= $args['maximum'] ) {\n\t\t\t\t/* translators: 1: Parameter, 2: Maximum number. */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be less than %2$d' ), $param, $args['maximum'] ) );\n\t\t\t} elseif ( empty( $args['exclusiveMaximum'] ) && $value > $args['maximum'] ) {\n\t\t\t\t/* translators: 1: Parameter, 2: Maximum number. */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be less than or equal to %2$d' ), $param, $args['maximum'] ) );\n\t\t\t}\n\t\t} elseif ( isset( $args['maximum'] ) && isset( $args['minimum'] ) ) {\n\t\t\tif ( ! empty( $args['exclusiveMinimum'] ) && ! empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value >= $args['maximum'] || $value <= $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: Parameter, 2: Minimum number, 3: Maximum number. */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (exclusive) and %3$d (exclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t} elseif ( empty( $args['exclusiveMinimum'] ) && ! empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value >= $args['maximum'] || $value < $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: Parameter, 2: Minimum number, 3: Maximum number. */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (inclusive) and %3$d (exclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t} elseif ( ! empty( $args['exclusiveMinimum'] ) && empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value > $args['maximum'] || $value <= $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: Parameter, 2: Minimum number, 3: Maximum number. */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (exclusive) and %3$d (inclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t} elseif ( empty( $args['exclusiveMinimum'] ) && empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value > $args['maximum'] || $value < $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: Parameter, 2: Minimum number, 3: Maximum number. */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (inclusive) and %3$d (inclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Sanitize a value based on a schema.\n *\n * @since 4.7.0\n *\n * @param mixed $value The value to sanitize.\n * @param array $args  Schema array to use for sanitization.\n * @return true|WP_Error\n */\nfunction rest_sanitize_value_from_schema( $value, $args ) {\n\tif ( is_array( $args['type'] ) ) {\n\t\t// Determine which type the value was validated against, and use that type when performing sanitization\n\t\t$validated_type = '';\n\n\t\tforeach ( $args['type'] as $type ) {\n\t\t\t$type_args         = $args;\n\t\t\t$type_args['type'] = $type;\n\n\t\t\tif ( ! is_wp_error( rest_validate_value_from_schema( $value, $type_args ) ) ) {\n\t\t\t\t$validated_type = $type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( ! $validated_type ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t$args['type'] = $validated_type;\n\t}\n\n\tif ( 'array' === $args['type'] ) {\n\t\tif ( empty( $args['items'] ) ) {\n\t\t\treturn (array) $value;\n\t\t}\n\t\t$value = wp_parse_list( $value );\n\t\tforeach ( $value as $index => $v ) {\n\t\t\t$value[ $index ] = rest_sanitize_value_from_schema( $v, $args['items'] );\n\t\t}\n\t\t// Normalize to numeric array so nothing unexpected\n\t\t// is in the keys.\n\t\t$value = array_values( $value );\n\t\treturn $value;\n\t}\n\n\tif ( 'object' === $args['type'] ) {\n\t\tif ( $value instanceof stdClass ) {\n\t\t\t$value = (array) $value;\n\t\t}\n\n\t\tif ( $value instanceof JsonSerializable ) {\n\t\t\t$value = $value->jsonSerialize();\n\t\t}\n\n\t\tif ( ! is_array( $value ) ) {\n\t\t\treturn array();\n\t\t}\n\n\t\tforeach ( $value as $property => $v ) {\n\t\t\tif ( isset( $args['properties'][ $property ] ) ) {\n\t\t\t\t$value[ $property ] = rest_sanitize_value_from_schema( $v, $args['properties'][ $property ] );\n\t\t\t} elseif ( isset( $args['additionalProperties'] ) ) {\n\t\t\t\tif ( false === $args['additionalProperties'] ) {\n\t\t\t\t\tunset( $value[ $property ] );\n\t\t\t\t} elseif ( is_array( $args['additionalProperties'] ) ) {\n\t\t\t\t\t$value[ $property ] = rest_sanitize_value_from_schema( $v, $args['additionalProperties'] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $value;\n\t}\n\n\tif ( 'null' === $args['type'] ) {\n\t\treturn null;\n\t}\n\n\tif ( 'integer' === $args['type'] ) {\n\t\treturn (int) $value;\n\t}\n\n\tif ( 'number' === $args['type'] ) {\n\t\treturn (float) $value;\n\t}\n\n\tif ( 'boolean' === $args['type'] ) {\n\t\treturn rest_sanitize_boolean( $value );\n\t}\n\n\tif ( isset( $args['format'] ) ) {\n\t\tswitch ( $args['format'] ) {\n\t\t\tcase 'date-time':\n\t\t\t\treturn sanitize_text_field( $value );\n\n\t\t\tcase 'email':\n\t\t\t\t/*\n\t\t\t\t * sanitize_email() validates, which would be unexpected.\n\t\t\t\t */\n\t\t\t\treturn sanitize_text_field( $value );\n\n\t\t\tcase 'uri':\n\t\t\t\treturn esc_url_raw( $value );\n\n\t\t\tcase 'ip':\n\t\t\t\treturn sanitize_text_field( $value );\n\t\t}\n\t}\n\n\tif ( 'string' === $args['type'] ) {\n\t\treturn strval( $value );\n\t}\n\n\treturn $value;\n}\n\n/**\n * Append result of internal request to REST API for purpose of preloading data to be attached to a page.\n * Expected to be called in the context of `array_reduce`.\n *\n * @since 5.0.0\n *\n * @param  array  $memo Reduce accumulator.\n * @param  string $path REST API path to preload.\n * @return array        Modified reduce accumulator.\n */\nfunction rest_preload_api_request( $memo, $path ) {\n\t// array_reduce() doesn't support passing an array in PHP 5.2, so we need to make sure we start with one.\n\tif ( ! is_array( $memo ) ) {\n\t\t$memo = array();\n\t}\n\n\tif ( empty( $path ) ) {\n\t\treturn $memo;\n\t}\n\n\t$method = 'GET';\n\tif ( is_array( $path ) && 2 === count( $path ) ) {\n\t\t$method = end( $path );\n\t\t$path   = reset( $path );\n\n\t\tif ( ! in_array( $method, array( 'GET', 'OPTIONS' ), true ) ) {\n\t\t\t$method = 'GET';\n\t\t}\n\t}\n\n\t$path_parts = parse_url( $path );\n\tif ( false === $path_parts ) {\n\t\treturn $memo;\n\t}\n\n\t$request = new WP_REST_Request( $method, $path_parts['path'] );\n\tif ( ! empty( $path_parts['query'] ) ) {\n\t\tparse_str( $path_parts['query'], $query_params );\n\t\t$request->set_query_params( $query_params );\n\t}\n\n\t$response = rest_do_request( $request );\n\tif ( 200 === $response->status ) {\n\t\t$server = rest_get_server();\n\t\t$data   = (array) $response->get_data();\n\t\t$links  = $server::get_compact_response_links( $response );\n\t\tif ( ! empty( $links ) ) {\n\t\t\t$data['_links'] = $links;\n\t\t}\n\n\t\tif ( 'OPTIONS' === $method ) {\n\t\t\t$response = rest_send_allow_header( $response, $server, $request );\n\n\t\t\t$memo[ $method ][ $path ] = array(\n\t\t\t\t'body'    => $data,\n\t\t\t\t'headers' => $response->headers,\n\t\t\t);\n\t\t} else {\n\t\t\t$memo[ $path ] = array(\n\t\t\t\t'body'    => $data,\n\t\t\t\t'headers' => $response->headers,\n\t\t\t);\n\t\t}\n\t}\n\n\treturn $memo;\n}\n", "<?php\n/**\n * WordPress Version\n *\n * Contains version information for the current WordPress release.\n *\n * @package WordPress\n * @since 1.1.0\n */\n\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '5.3-beta3-46477';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 45805;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4960-20190918';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.6.20';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "fixing_code": ["<?php\n/**\n * REST API functions.\n *\n * @package WordPress\n * @subpackage REST_API\n * @since 4.4.0\n */\n\n/**\n * Version number for our API.\n *\n * @var string\n */\ndefine( 'REST_API_VERSION', '2.0' );\n\n/**\n * Registers a REST API route.\n *\n * Note: Do not use before the {@see 'rest_api_init'} hook.\n *\n * @since 4.4.0\n * @since 5.1.0 Added a _doing_it_wrong() notice when not called on or after the rest_api_init hook.\n *\n * @param string $namespace The first URL segment after core prefix. Should be unique to your package/plugin.\n * @param string $route     The base URL for route you are adding.\n * @param array  $args      Optional. Either an array of options for the endpoint, or an array of arrays for\n *                          multiple methods. Default empty array.\n * @param bool   $override  Optional. If the route already exists, should we override it? True overrides,\n *                          false merges (with newer overriding if duplicate keys exist). Default false.\n * @return bool True on success, false on error.\n */\nfunction register_rest_route( $namespace, $route, $args = array(), $override = false ) {\n\tif ( empty( $namespace ) ) {\n\t\t/*\n\t\t * Non-namespaced routes are not allowed, with the exception of the main\n\t\t * and namespace indexes. If you really need to register a\n\t\t * non-namespaced route, call `WP_REST_Server::register_route` directly.\n\t\t */\n\t\t_doing_it_wrong( 'register_rest_route', __( 'Routes must be namespaced with plugin or theme name and version.' ), '4.4.0' );\n\t\treturn false;\n\t} elseif ( empty( $route ) ) {\n\t\t_doing_it_wrong( 'register_rest_route', __( 'Route must be specified.' ), '4.4.0' );\n\t\treturn false;\n\t}\n\n\tif ( ! did_action( 'rest_api_init' ) ) {\n\t\t_doing_it_wrong(\n\t\t\t'register_rest_route',\n\t\t\tsprintf(\n\t\t\t\t/* translators: %s: rest_api_init */\n\t\t\t\t__( 'REST API routes must be registered on the %s action.' ),\n\t\t\t\t'<code>rest_api_init</code>'\n\t\t\t),\n\t\t\t'5.1.0'\n\t\t);\n\t}\n\n\tif ( isset( $args['args'] ) ) {\n\t\t$common_args = $args['args'];\n\t\tunset( $args['args'] );\n\t} else {\n\t\t$common_args = array();\n\t}\n\n\tif ( isset( $args['callback'] ) ) {\n\t\t// Upgrade a single set to multiple.\n\t\t$args = array( $args );\n\t}\n\n\t$defaults = array(\n\t\t'methods'  => 'GET',\n\t\t'callback' => null,\n\t\t'args'     => array(),\n\t);\n\tforeach ( $args as $key => &$arg_group ) {\n\t\tif ( ! is_numeric( $key ) ) {\n\t\t\t// Route option, skip here.\n\t\t\tcontinue;\n\t\t}\n\n\t\t$arg_group         = array_merge( $defaults, $arg_group );\n\t\t$arg_group['args'] = array_merge( $common_args, $arg_group['args'] );\n\t}\n\n\t$full_route = '/' . trim( $namespace, '/' ) . '/' . trim( $route, '/' );\n\trest_get_server()->register_route( $namespace, $full_route, $args, $override );\n\treturn true;\n}\n\n/**\n * Registers a new field on an existing WordPress object type.\n *\n * @since 4.7.0\n *\n * @global array $wp_rest_additional_fields Holds registered fields, organized\n *                                          by object type.\n *\n * @param string|array $object_type Object(s) the field is being registered\n *                                  to, \"post\"|\"term\"|\"comment\" etc.\n * @param string $attribute         The attribute name.\n * @param array  $args {\n *     Optional. An array of arguments used to handle the registered field.\n *\n *     @type callable|null $get_callback    Optional. The callback function used to retrieve the field value. Default is\n *                                          'null', the field will not be returned in the response. The function will\n *                                          be passed the prepared object data.\n *     @type callable|null $update_callback Optional. The callback function used to set and update the field value. Default\n *                                          is 'null', the value cannot be set or updated. The function will be passed\n *                                          the model object, like WP_Post.\n *     @type array|null $schema             Optional. The callback function used to create the schema for this field.\n *                                          Default is 'null', no schema entry will be returned.\n * }\n */\nfunction register_rest_field( $object_type, $attribute, $args = array() ) {\n\t$defaults = array(\n\t\t'get_callback'    => null,\n\t\t'update_callback' => null,\n\t\t'schema'          => null,\n\t);\n\n\t$args = wp_parse_args( $args, $defaults );\n\n\tglobal $wp_rest_additional_fields;\n\n\t$object_types = (array) $object_type;\n\n\tforeach ( $object_types as $object_type ) {\n\t\t$wp_rest_additional_fields[ $object_type ][ $attribute ] = $args;\n\t}\n}\n\n/**\n * Registers rewrite rules for the API.\n *\n * @since 4.4.0\n *\n * @see rest_api_register_rewrites()\n * @global WP $wp Current WordPress environment instance.\n */\nfunction rest_api_init() {\n\trest_api_register_rewrites();\n\n\tglobal $wp;\n\t$wp->add_query_var( 'rest_route' );\n}\n\n/**\n * Adds REST rewrite rules.\n *\n * @since 4.4.0\n *\n * @see add_rewrite_rule()\n * @global WP_Rewrite $wp_rewrite WordPress rewrite component.\n */\nfunction rest_api_register_rewrites() {\n\tglobal $wp_rewrite;\n\n\tadd_rewrite_rule( '^' . rest_get_url_prefix() . '/?$', 'index.php?rest_route=/', 'top' );\n\tadd_rewrite_rule( '^' . rest_get_url_prefix() . '/(.*)?', 'index.php?rest_route=/$matches[1]', 'top' );\n\tadd_rewrite_rule( '^' . $wp_rewrite->index . '/' . rest_get_url_prefix() . '/?$', 'index.php?rest_route=/', 'top' );\n\tadd_rewrite_rule( '^' . $wp_rewrite->index . '/' . rest_get_url_prefix() . '/(.*)?', 'index.php?rest_route=/$matches[1]', 'top' );\n}\n\n/**\n * Registers the default REST API filters.\n *\n * Attached to the {@see 'rest_api_init'} action\n * to make testing and disabling these filters easier.\n *\n * @since 4.4.0\n */\nfunction rest_api_default_filters() {\n\t// Deprecated reporting.\n\tadd_action( 'deprecated_function_run', 'rest_handle_deprecated_function', 10, 3 );\n\tadd_filter( 'deprecated_function_trigger_error', '__return_false' );\n\tadd_action( 'deprecated_argument_run', 'rest_handle_deprecated_argument', 10, 3 );\n\tadd_filter( 'deprecated_argument_trigger_error', '__return_false' );\n\n\t// Default serving.\n\tadd_filter( 'rest_pre_serve_request', 'rest_send_cors_headers' );\n\tadd_filter( 'rest_post_dispatch', 'rest_send_allow_header', 10, 3 );\n\tadd_filter( 'rest_post_dispatch', 'rest_filter_response_fields', 10, 3 );\n\n\tadd_filter( 'rest_pre_dispatch', 'rest_handle_options_request', 10, 3 );\n}\n\n/**\n * Registers default REST API routes.\n *\n * @since 4.7.0\n */\nfunction create_initial_rest_routes() {\n\tforeach ( get_post_types( array( 'show_in_rest' => true ), 'objects' ) as $post_type ) {\n\t\t$controller = $post_type->get_rest_controller();\n\n\t\tif ( ! $controller ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$controller->register_routes();\n\n\t\tif ( post_type_supports( $post_type->name, 'revisions' ) ) {\n\t\t\t$revisions_controller = new WP_REST_Revisions_Controller( $post_type->name );\n\t\t\t$revisions_controller->register_routes();\n\t\t}\n\n\t\tif ( 'attachment' !== $post_type->name ) {\n\t\t\t$autosaves_controller = new WP_REST_Autosaves_Controller( $post_type->name );\n\t\t\t$autosaves_controller->register_routes();\n\t\t}\n\t}\n\n\t// Post types.\n\t$controller = new WP_REST_Post_Types_Controller;\n\t$controller->register_routes();\n\n\t// Post statuses.\n\t$controller = new WP_REST_Post_Statuses_Controller;\n\t$controller->register_routes();\n\n\t// Taxonomies.\n\t$controller = new WP_REST_Taxonomies_Controller;\n\t$controller->register_routes();\n\n\t// Terms.\n\tforeach ( get_taxonomies( array( 'show_in_rest' => true ), 'object' ) as $taxonomy ) {\n\t\t$class = ! empty( $taxonomy->rest_controller_class ) ? $taxonomy->rest_controller_class : 'WP_REST_Terms_Controller';\n\n\t\tif ( ! class_exists( $class ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\t$controller = new $class( $taxonomy->name );\n\t\tif ( ! is_subclass_of( $controller, 'WP_REST_Controller' ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$controller->register_routes();\n\t}\n\n\t// Users.\n\t$controller = new WP_REST_Users_Controller;\n\t$controller->register_routes();\n\n\t// Comments.\n\t$controller = new WP_REST_Comments_Controller;\n\t$controller->register_routes();\n\n\t/**\n\t * Filters the search handlers to use in the REST search controller.\n\t *\n\t * @since 5.0.0\n\t *\n\t * @param array $search_handlers List of search handlers to use in the controller. Each search\n\t *                               handler instance must extend the `WP_REST_Search_Handler` class.\n\t *                               Default is only a handler for posts.\n\t */\n\t$search_handlers = apply_filters( 'wp_rest_search_handlers', array( new WP_REST_Post_Search_Handler() ) );\n\n\t$controller = new WP_REST_Search_Controller( $search_handlers );\n\t$controller->register_routes();\n\n\t// Block Renderer.\n\t$controller = new WP_REST_Block_Renderer_Controller;\n\t$controller->register_routes();\n\n\t// Settings.\n\t$controller = new WP_REST_Settings_Controller;\n\t$controller->register_routes();\n\n\t// Themes.\n\t$controller = new WP_REST_Themes_Controller;\n\t$controller->register_routes();\n\n}\n\n/**\n * Loads the REST API.\n *\n * @since 4.4.0\n *\n * @global WP $wp Current WordPress environment instance.\n */\nfunction rest_api_loaded() {\n\tif ( empty( $GLOBALS['wp']->query_vars['rest_route'] ) ) {\n\t\treturn;\n\t}\n\n\t/**\n\t * Whether this is a REST Request.\n\t *\n\t * @since 4.4.0\n\t * @var bool\n\t */\n\tdefine( 'REST_REQUEST', true );\n\n\t// Initialize the server.\n\t$server = rest_get_server();\n\n\t// Fire off the request.\n\t$route = untrailingslashit( $GLOBALS['wp']->query_vars['rest_route'] );\n\tif ( empty( $route ) ) {\n\t\t$route = '/';\n\t}\n\t$server->serve_request( $route );\n\n\t// We're done.\n\tdie();\n}\n\n/**\n * Retrieves the URL prefix for any API resource.\n *\n * @since 4.4.0\n *\n * @return string Prefix.\n */\nfunction rest_get_url_prefix() {\n\t/**\n\t * Filters the REST URL prefix.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param string $prefix URL prefix. Default 'wp-json'.\n\t */\n\treturn apply_filters( 'rest_url_prefix', 'wp-json' );\n}\n\n/**\n * Retrieves the URL to a REST endpoint on a site.\n *\n * Note: The returned URL is NOT escaped.\n *\n * @since 4.4.0\n *\n * @todo Check if this is even necessary\n * @global WP_Rewrite $wp_rewrite WordPress rewrite component.\n *\n * @param int    $blog_id Optional. Blog ID. Default of null returns URL for current blog.\n * @param string $path    Optional. REST route. Default '/'.\n * @param string $scheme  Optional. Sanitization scheme. Default 'rest'.\n * @return string Full URL to the endpoint.\n */\nfunction get_rest_url( $blog_id = null, $path = '/', $scheme = 'rest' ) {\n\tif ( empty( $path ) ) {\n\t\t$path = '/';\n\t}\n\n\t$path = '/' . ltrim( $path, '/' );\n\n\tif ( is_multisite() && get_blog_option( $blog_id, 'permalink_structure' ) || get_option( 'permalink_structure' ) ) {\n\t\tglobal $wp_rewrite;\n\n\t\tif ( $wp_rewrite->using_index_permalinks() ) {\n\t\t\t$url = get_home_url( $blog_id, $wp_rewrite->index . '/' . rest_get_url_prefix(), $scheme );\n\t\t} else {\n\t\t\t$url = get_home_url( $blog_id, rest_get_url_prefix(), $scheme );\n\t\t}\n\n\t\t$url .= $path;\n\t} else {\n\t\t$url = trailingslashit( get_home_url( $blog_id, '', $scheme ) );\n\t\t// nginx only allows HTTP/1.0 methods when redirecting from / to /index.php\n\t\t// To work around this, we manually add index.php to the URL, avoiding the redirect.\n\t\tif ( 'index.php' !== substr( $url, 9 ) ) {\n\t\t\t$url .= 'index.php';\n\t\t}\n\n\t\t$url = add_query_arg( 'rest_route', $path, $url );\n\t}\n\n\tif ( is_ssl() && isset( $_SERVER['SERVER_NAME'] ) ) {\n\t\t// If the current host is the same as the REST URL host, force the REST URL scheme to HTTPS.\n\t\tif ( $_SERVER['SERVER_NAME'] === parse_url( get_home_url( $blog_id ), PHP_URL_HOST ) ) {\n\t\t\t$url = set_url_scheme( $url, 'https' );\n\t\t}\n\t}\n\n\tif ( is_admin() && force_ssl_admin() ) {\n\t\t// In this situation the home URL may be http:, and `is_ssl()` may be\n\t\t// false, but the admin is served over https: (one way or another), so\n\t\t// REST API usage will be blocked by browsers unless it is also served\n\t\t// over HTTPS.\n\t\t$url = set_url_scheme( $url, 'https' );\n\t}\n\n\t/**\n\t * Filters the REST URL.\n\t *\n\t * Use this filter to adjust the url returned by the get_rest_url() function.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param string $url     REST URL.\n\t * @param string $path    REST route.\n\t * @param int    $blog_id Blog ID.\n\t * @param string $scheme  Sanitization scheme.\n\t */\n\treturn apply_filters( 'rest_url', $url, $path, $blog_id, $scheme );\n}\n\n/**\n * Retrieves the URL to a REST endpoint.\n *\n * Note: The returned URL is NOT escaped.\n *\n * @since 4.4.0\n *\n * @param string $path   Optional. REST route. Default empty.\n * @param string $scheme Optional. Sanitization scheme. Default 'rest'.\n * @return string Full URL to the endpoint.\n */\nfunction rest_url( $path = '', $scheme = 'rest' ) {\n\treturn get_rest_url( null, $path, $scheme );\n}\n\n/**\n * Do a REST request.\n *\n * Used primarily to route internal requests through WP_REST_Server.\n *\n * @since 4.4.0\n *\n * @param WP_REST_Request|string $request Request.\n * @return WP_REST_Response REST response.\n */\nfunction rest_do_request( $request ) {\n\t$request = rest_ensure_request( $request );\n\treturn rest_get_server()->dispatch( $request );\n}\n\n/**\n * Retrieves the current REST server instance.\n *\n * Instantiates a new instance if none exists already.\n *\n * @since 4.5.0\n *\n * @global WP_REST_Server $wp_rest_server REST server instance.\n *\n * @return WP_REST_Server REST server instance.\n */\nfunction rest_get_server() {\n\t/* @var WP_REST_Server $wp_rest_server */\n\tglobal $wp_rest_server;\n\n\tif ( empty( $wp_rest_server ) ) {\n\t\t/**\n\t\t * Filters the REST Server Class.\n\t\t *\n\t\t * This filter allows you to adjust the server class used by the API, using a\n\t\t * different class to handle requests.\n\t\t *\n\t\t * @since 4.4.0\n\t\t *\n\t\t * @param string $class_name The name of the server class. Default 'WP_REST_Server'.\n\t\t */\n\t\t$wp_rest_server_class = apply_filters( 'wp_rest_server_class', 'WP_REST_Server' );\n\t\t$wp_rest_server       = new $wp_rest_server_class;\n\n\t\t/**\n\t\t * Fires when preparing to serve an API request.\n\t\t *\n\t\t * Endpoint objects should be created and register their hooks on this action rather\n\t\t * than another action to ensure they're only loaded when needed.\n\t\t *\n\t\t * @since 4.4.0\n\t\t *\n\t\t * @param WP_REST_Server $wp_rest_server Server object.\n\t\t */\n\t\tdo_action( 'rest_api_init', $wp_rest_server );\n\t}\n\n\treturn $wp_rest_server;\n}\n\n/**\n * Ensures request arguments are a request object (for consistency).\n *\n * @since 4.4.0\n * @since 5.3.0 Accept string argument for the request path.\n *\n * @param array|string|WP_REST_Request $request Request to check.\n * @return WP_REST_Request REST request instance.\n */\nfunction rest_ensure_request( $request ) {\n\tif ( $request instanceof WP_REST_Request ) {\n\t\treturn $request;\n\t}\n\n\tif ( is_string( $request ) ) {\n\t\treturn new WP_REST_Request( 'GET', $request );\n\t}\n\n\treturn new WP_REST_Request( 'GET', '', $request );\n}\n\n/**\n * Ensures a REST response is a response object (for consistency).\n *\n * This implements WP_HTTP_Response, allowing usage of `set_status`/`header`/etc\n * without needing to double-check the object. Will also allow WP_Error to indicate error\n * responses, so users should immediately check for this value.\n *\n * @since 4.4.0\n *\n * @param WP_Error|WP_HTTP_Response|mixed $response Response to check.\n * @return WP_REST_Response|mixed If response generated an error, WP_Error, if response\n *                                is already an instance, WP_HTTP_Response, otherwise\n *                                returns a new WP_REST_Response instance.\n */\nfunction rest_ensure_response( $response ) {\n\tif ( is_wp_error( $response ) ) {\n\t\treturn $response;\n\t}\n\n\tif ( $response instanceof WP_HTTP_Response ) {\n\t\treturn $response;\n\t}\n\n\treturn new WP_REST_Response( $response );\n}\n\n/**\n * Handles _deprecated_function() errors.\n *\n * @since 4.4.0\n *\n * @param string $function    The function that was called.\n * @param string $replacement The function that should have been called.\n * @param string $version     Version.\n */\nfunction rest_handle_deprecated_function( $function, $replacement, $version ) {\n\tif ( ! WP_DEBUG || headers_sent() ) {\n\t\treturn;\n\t}\n\tif ( ! empty( $replacement ) ) {\n\t\t/* translators: 1: Function name, 2: WordPress version number, 3: New function name. */\n\t\t$string = sprintf( __( '%1$s (since %2$s; use %3$s instead)' ), $function, $version, $replacement );\n\t} else {\n\t\t/* translators: 1: Function name, 2: WordPress version number. */\n\t\t$string = sprintf( __( '%1$s (since %2$s; no alternative available)' ), $function, $version );\n\t}\n\n\theader( sprintf( 'X-WP-DeprecatedFunction: %s', $string ) );\n}\n\n/**\n * Handles _deprecated_argument() errors.\n *\n * @since 4.4.0\n *\n * @param string $function    The function that was called.\n * @param string $message     A message regarding the change.\n * @param string $version     Version.\n */\nfunction rest_handle_deprecated_argument( $function, $message, $version ) {\n\tif ( ! WP_DEBUG || headers_sent() ) {\n\t\treturn;\n\t}\n\tif ( ! empty( $message ) ) {\n\t\t/* translators: 1: Function name, 2: WordPress version number, 3: Error message. */\n\t\t$string = sprintf( __( '%1$s (since %2$s; %3$s)' ), $function, $version, $message );\n\t} else {\n\t\t/* translators: 1: Function name, 2: WordPress version number. */\n\t\t$string = sprintf( __( '%1$s (since %2$s; no alternative available)' ), $function, $version );\n\t}\n\n\theader( sprintf( 'X-WP-DeprecatedParam: %s', $string ) );\n}\n\n/**\n * Sends Cross-Origin Resource Sharing headers with API requests.\n *\n * @since 4.4.0\n *\n * @param mixed $value Response data.\n * @return mixed Response data.\n */\nfunction rest_send_cors_headers( $value ) {\n\t$origin = get_http_origin();\n\n\tif ( $origin ) {\n\t\t// Requests from file:// and data: URLs send \"Origin: null\"\n\t\tif ( 'null' !== $origin ) {\n\t\t\t$origin = esc_url_raw( $origin );\n\t\t}\n\t\theader( 'Access-Control-Allow-Origin: ' . $origin );\n\t\theader( 'Access-Control-Allow-Methods: OPTIONS, GET, POST, PUT, PATCH, DELETE' );\n\t\theader( 'Access-Control-Allow-Credentials: true' );\n\t\theader( 'Vary: Origin' );\n\t} else if ( 'GET' === $_SERVER['REQUEST_METHOD'] && ! is_user_logged_in() ) {\n\t\theader( 'Vary: Origin' );\n\t}\n\n\treturn $value;\n}\n\n/**\n * Handles OPTIONS requests for the server.\n *\n * This is handled outside of the server code, as it doesn't obey normal route\n * mapping.\n *\n * @since 4.4.0\n *\n * @param mixed           $response Current response, either response or `null` to indicate pass-through.\n * @param WP_REST_Server  $handler  ResponseHandler instance (usually WP_REST_Server).\n * @param WP_REST_Request $request  The request that was used to make current response.\n * @return WP_REST_Response Modified response, either response or `null` to indicate pass-through.\n */\nfunction rest_handle_options_request( $response, $handler, $request ) {\n\tif ( ! empty( $response ) || $request->get_method() !== 'OPTIONS' ) {\n\t\treturn $response;\n\t}\n\n\t$response = new WP_REST_Response();\n\t$data     = array();\n\n\tforeach ( $handler->get_routes() as $route => $endpoints ) {\n\t\t$match = preg_match( '@^' . $route . '$@i', $request->get_route(), $matches );\n\n\t\tif ( ! $match ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$args = array();\n\t\tforeach ( $matches as $param => $value ) {\n\t\t\tif ( ! is_int( $param ) ) {\n\t\t\t\t$args[ $param ] = $value;\n\t\t\t}\n\t\t}\n\n\t\tforeach ( $endpoints as $endpoint ) {\n\t\t\t// Remove the redundant preg_match argument.\n\t\t\tunset( $args[0] );\n\n\t\t\t$request->set_url_params( $args );\n\t\t\t$request->set_attributes( $endpoint );\n\t\t}\n\n\t\t$data = $handler->get_data_for_route( $route, $endpoints, 'help' );\n\t\t$response->set_matched_route( $route );\n\t\tbreak;\n\t}\n\n\t$response->set_data( $data );\n\treturn $response;\n}\n\n/**\n * Sends the \"Allow\" header to state all methods that can be sent to the current route.\n *\n * @since 4.4.0\n *\n * @param WP_REST_Response $response Current response being served.\n * @param WP_REST_Server   $server   ResponseHandler instance (usually WP_REST_Server).\n * @param WP_REST_Request  $request  The request that was used to make current response.\n * @return WP_REST_Response Response to be served, with \"Allow\" header if route has allowed methods.\n */\nfunction rest_send_allow_header( $response, $server, $request ) {\n\t$matched_route = $response->get_matched_route();\n\n\tif ( ! $matched_route ) {\n\t\treturn $response;\n\t}\n\n\t$routes = $server->get_routes();\n\n\t$allowed_methods = array();\n\n\t// Get the allowed methods across the routes.\n\tforeach ( $routes[ $matched_route ] as $_handler ) {\n\t\tforeach ( $_handler['methods'] as $handler_method => $value ) {\n\n\t\t\tif ( ! empty( $_handler['permission_callback'] ) ) {\n\n\t\t\t\t$permission = call_user_func( $_handler['permission_callback'], $request );\n\n\t\t\t\t$allowed_methods[ $handler_method ] = true === $permission;\n\t\t\t} else {\n\t\t\t\t$allowed_methods[ $handler_method ] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Strip out all the methods that are not allowed (false values).\n\t$allowed_methods = array_filter( $allowed_methods );\n\n\tif ( $allowed_methods ) {\n\t\t$response->header( 'Allow', implode( ', ', array_map( 'strtoupper', array_keys( $allowed_methods ) ) ) );\n\t}\n\n\treturn $response;\n}\n\n/**\n * Recursively computes the intersection of arrays using keys for comparison.\n *\n * @param  array $array1 The array with master keys to check.\n * @param  array $array2 An array to compare keys against.\n *\n * @return array An associative array containing all the entries of array1 which have keys that are present in all arguments.\n */\nfunction _rest_array_intersect_key_recursive( $array1, $array2 ) {\n\t$array1 = array_intersect_key( $array1, $array2 );\n\tforeach ( $array1 as $key => $value ) {\n\t\tif ( is_array( $value ) && is_array( $array2[ $key ] ) ) {\n\t\t\t$array1[ $key ] = _rest_array_intersect_key_recursive( $value, $array2[ $key ] );\n\t\t}\n\t}\n\treturn $array1;\n}\n\n/**\n * Filter the API response to include only a white-listed set of response object fields.\n *\n * @since 4.8.0\n *\n * @param WP_REST_Response $response Current response being served.\n * @param WP_REST_Server   $server   ResponseHandler instance (usually WP_REST_Server).\n * @param WP_REST_Request  $request  The request that was used to make current response.\n *\n * @return WP_REST_Response Response to be served, trimmed down to contain a subset of fields.\n */\nfunction rest_filter_response_fields( $response, $server, $request ) {\n\tif ( ! isset( $request['_fields'] ) || $response->is_error() ) {\n\t\treturn $response;\n\t}\n\n\t$data = $response->get_data();\n\n\t$fields = wp_parse_list( $request['_fields'] );\n\n\tif ( 0 === count( $fields ) ) {\n\t\treturn $response;\n\t}\n\n\t// Trim off outside whitespace from the comma delimited list.\n\t$fields = array_map( 'trim', $fields );\n\n\t// Create nested array of accepted field hierarchy.\n\t$fields_as_keyed = array();\n\tforeach ( $fields as $field ) {\n\t\t$parts = explode( '.', $field );\n\t\t$ref   = &$fields_as_keyed;\n\t\twhile ( count( $parts ) > 1 ) {\n\t\t\t$next = array_shift( $parts );\n\t\t\tif ( isset( $ref[ $next ] ) && true === $ref[ $next ] ) {\n\t\t\t\t// Skip any sub-properties if their parent prop is already marked for inclusion.\n\t\t\t\tbreak 2;\n\t\t\t}\n\t\t\t$ref[ $next ] = isset( $ref[ $next ] ) ? $ref[ $next ] : array();\n\t\t\t$ref          = &$ref[ $next ];\n\t\t}\n\t\t$last         = array_shift( $parts );\n\t\t$ref[ $last ] = true;\n\t}\n\n\tif ( wp_is_numeric_array( $data ) ) {\n\t\t$new_data = array();\n\t\tforeach ( $data as $item ) {\n\t\t\t$new_data[] = _rest_array_intersect_key_recursive( $item, $fields_as_keyed );\n\t\t}\n\t} else {\n\t\t$new_data = _rest_array_intersect_key_recursive( $data, $fields_as_keyed );\n\t}\n\n\t$response->set_data( $new_data );\n\n\treturn $response;\n}\n\n/**\n * Given an array of fields to include in a response, some of which may be\n * `nested.fields`, determine whether the provided field should be included\n * in the response body.\n *\n * If a parent field is passed in, the presence of any nested field within\n * that parent will cause the method to return `true`. For example \"title\"\n * will return true if any of `title`, `title.raw` or `title.rendered` is\n * provided.\n *\n * @since 5.3.0\n *\n * @param string $field  A field to test for inclusion in the response body.\n * @param array  $fields An array of string fields supported by the endpoint.\n * @return bool Whether to include the field or not.\n */\nfunction rest_is_field_included( $field, $fields ) {\n\tif ( in_array( $field, $fields, true ) ) {\n\t\treturn true;\n\t}\n\tforeach ( $fields as $accepted_field ) {\n\t\t// Check to see if $field is the parent of any item in $fields.\n\t\t// A field \"parent\" should be accepted if \"parent.child\" is accepted.\n\t\tif ( strpos( $accepted_field, \"$field.\" ) === 0 ) {\n\t\t\treturn true;\n\t\t}\n\t\t// Conversely, if \"parent\" is accepted, all \"parent.child\" fields should\n\t\t// also be accepted.\n\t\tif ( strpos( $field, \"$accepted_field.\" ) === 0 ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Adds the REST API URL to the WP RSD endpoint.\n *\n * @since 4.4.0\n *\n * @see get_rest_url()\n */\nfunction rest_output_rsd() {\n\t$api_root = get_rest_url();\n\n\tif ( empty( $api_root ) ) {\n\t\treturn;\n\t}\n\t?>\n\t<api name=\"WP-API\" blogID=\"1\" preferred=\"false\" apiLink=\"<?php echo esc_url( $api_root ); ?>\" />\n\t<?php\n}\n\n/**\n * Outputs the REST API link tag into page header.\n *\n * @since 4.4.0\n *\n * @see get_rest_url()\n */\nfunction rest_output_link_wp_head() {\n\t$api_root = get_rest_url();\n\n\tif ( empty( $api_root ) ) {\n\t\treturn;\n\t}\n\n\techo \"<link rel='https://api.w.org/' href='\" . esc_url( $api_root ) . \"' />\\n\";\n}\n\n/**\n * Sends a Link header for the REST API.\n *\n * @since 4.4.0\n */\nfunction rest_output_link_header() {\n\tif ( headers_sent() ) {\n\t\treturn;\n\t}\n\n\t$api_root = get_rest_url();\n\n\tif ( empty( $api_root ) ) {\n\t\treturn;\n\t}\n\n\theader( 'Link: <' . esc_url_raw( $api_root ) . '>; rel=\"https://api.w.org/\"', false );\n}\n\n/**\n * Checks for errors when using cookie-based authentication.\n *\n * WordPress' built-in cookie authentication is always active\n * for logged in users. However, the API has to check nonces\n * for each request to ensure users are not vulnerable to CSRF.\n *\n * @since 4.4.0\n *\n * @global mixed          $wp_rest_auth_cookie\n *\n * @param WP_Error|mixed $result Error from another authentication handler,\n *                               null if we should handle it, or another value\n *                               if not.\n * @return WP_Error|mixed|bool WP_Error if the cookie is invalid, the $result, otherwise true.\n */\nfunction rest_cookie_check_errors( $result ) {\n\tif ( ! empty( $result ) ) {\n\t\treturn $result;\n\t}\n\n\tglobal $wp_rest_auth_cookie;\n\n\t/*\n\t * Is cookie authentication being used? (If we get an auth\n\t * error, but we're still logged in, another authentication\n\t * must have been used).\n\t */\n\tif ( true !== $wp_rest_auth_cookie && is_user_logged_in() ) {\n\t\treturn $result;\n\t}\n\n\t// Determine if there is a nonce.\n\t$nonce = null;\n\n\tif ( isset( $_REQUEST['_wpnonce'] ) ) {\n\t\t$nonce = $_REQUEST['_wpnonce'];\n\t} elseif ( isset( $_SERVER['HTTP_X_WP_NONCE'] ) ) {\n\t\t$nonce = $_SERVER['HTTP_X_WP_NONCE'];\n\t}\n\n\tif ( null === $nonce ) {\n\t\t// No nonce at all, so act as if it's an unauthenticated request.\n\t\twp_set_current_user( 0 );\n\t\treturn true;\n\t}\n\n\t// Check the nonce.\n\t$result = wp_verify_nonce( $nonce, 'wp_rest' );\n\n\tif ( ! $result ) {\n\t\treturn new WP_Error( 'rest_cookie_invalid_nonce', __( 'Cookie nonce is invalid' ), array( 'status' => 403 ) );\n\t}\n\n\t// Send a refreshed nonce in header.\n\trest_get_server()->send_header( 'X-WP-Nonce', wp_create_nonce( 'wp_rest' ) );\n\n\treturn true;\n}\n\n/**\n * Collects cookie authentication status.\n *\n * Collects errors from wp_validate_auth_cookie for use by rest_cookie_check_errors.\n *\n * @since 4.4.0\n *\n * @see current_action()\n * @global mixed $wp_rest_auth_cookie\n */\nfunction rest_cookie_collect_status() {\n\tglobal $wp_rest_auth_cookie;\n\n\t$status_type = current_action();\n\n\tif ( 'auth_cookie_valid' !== $status_type ) {\n\t\t$wp_rest_auth_cookie = substr( $status_type, 12 );\n\t\treturn;\n\t}\n\n\t$wp_rest_auth_cookie = true;\n}\n\n/**\n * Parses an RFC3339 time into a Unix timestamp.\n *\n * @since 4.4.0\n *\n * @param string $date      RFC3339 timestamp.\n * @param bool   $force_utc Optional. Whether to force UTC timezone instead of using\n *                          the timestamp's timezone. Default false.\n * @return int Unix timestamp.\n */\nfunction rest_parse_date( $date, $force_utc = false ) {\n\tif ( $force_utc ) {\n\t\t$date = preg_replace( '/[+-]\\d+:?\\d+$/', '+00:00', $date );\n\t}\n\n\t$regex = '#^\\d{4}-\\d{2}-\\d{2}[Tt ]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}(?::\\d{2})?)?$#';\n\n\tif ( ! preg_match( $regex, $date, $matches ) ) {\n\t\treturn false;\n\t}\n\n\treturn strtotime( $date );\n}\n\n/**\n * Parses a date into both its local and UTC equivalent, in MySQL datetime format.\n *\n * @since 4.4.0\n *\n * @see rest_parse_date()\n *\n * @param string $date   RFC3339 timestamp.\n * @param bool   $is_utc Whether the provided date should be interpreted as UTC. Default false.\n * @return array|null Local and UTC datetime strings, in MySQL datetime format (Y-m-d H:i:s),\n *                    null on failure.\n */\nfunction rest_get_date_with_gmt( $date, $is_utc = false ) {\n\t// Whether or not the original date actually has a timezone string\n\t// changes the way we need to do timezone conversion.  Store this info\n\t// before parsing the date, and use it later.\n\t$has_timezone = preg_match( '#(Z|[+-]\\d{2}(:\\d{2})?)$#', $date );\n\n\t$date = rest_parse_date( $date );\n\n\tif ( empty( $date ) ) {\n\t\treturn null;\n\t}\n\n\t// At this point $date could either be a local date (if we were passed a\n\t// *local* date without a timezone offset) or a UTC date (otherwise).\n\t// Timezone conversion needs to be handled differently between these two\n\t// cases.\n\tif ( ! $is_utc && ! $has_timezone ) {\n\t\t$local = gmdate( 'Y-m-d H:i:s', $date );\n\t\t$utc   = get_gmt_from_date( $local );\n\t} else {\n\t\t$utc   = gmdate( 'Y-m-d H:i:s', $date );\n\t\t$local = get_date_from_gmt( $utc );\n\t}\n\n\treturn array( $local, $utc );\n}\n\n/**\n * Returns a contextual HTTP error code for authorization failure.\n *\n * @since 4.7.0\n *\n * @return integer 401 if the user is not logged in, 403 if the user is logged in.\n */\nfunction rest_authorization_required_code() {\n\treturn is_user_logged_in() ? 403 : 401;\n}\n\n/**\n * Validate a request argument based on details registered to the route.\n *\n * @since 4.7.0\n *\n * @param  mixed            $value\n * @param  WP_REST_Request  $request\n * @param  string           $param\n * @return WP_Error|boolean\n */\nfunction rest_validate_request_arg( $value, $request, $param ) {\n\t$attributes = $request->get_attributes();\n\tif ( ! isset( $attributes['args'][ $param ] ) || ! is_array( $attributes['args'][ $param ] ) ) {\n\t\treturn true;\n\t}\n\t$args = $attributes['args'][ $param ];\n\n\treturn rest_validate_value_from_schema( $value, $args, $param );\n}\n\n/**\n * Sanitize a request argument based on details registered to the route.\n *\n * @since 4.7.0\n *\n * @param  mixed            $value\n * @param  WP_REST_Request  $request\n * @param  string           $param\n * @return mixed\n */\nfunction rest_sanitize_request_arg( $value, $request, $param ) {\n\t$attributes = $request->get_attributes();\n\tif ( ! isset( $attributes['args'][ $param ] ) || ! is_array( $attributes['args'][ $param ] ) ) {\n\t\treturn $value;\n\t}\n\t$args = $attributes['args'][ $param ];\n\n\treturn rest_sanitize_value_from_schema( $value, $args );\n}\n\n/**\n * Parse a request argument based on details registered to the route.\n *\n * Runs a validation check and sanitizes the value, primarily to be used via\n * the `sanitize_callback` arguments in the endpoint args registration.\n *\n * @since 4.7.0\n *\n * @param  mixed            $value\n * @param  WP_REST_Request  $request\n * @param  string           $param\n * @return mixed\n */\nfunction rest_parse_request_arg( $value, $request, $param ) {\n\t$is_valid = rest_validate_request_arg( $value, $request, $param );\n\n\tif ( is_wp_error( $is_valid ) ) {\n\t\treturn $is_valid;\n\t}\n\n\t$value = rest_sanitize_request_arg( $value, $request, $param );\n\n\treturn $value;\n}\n\n/**\n * Determines if an IP address is valid.\n *\n * Handles both IPv4 and IPv6 addresses.\n *\n * @since 4.7.0\n *\n * @param  string $ip IP address.\n * @return string|false The valid IP address, otherwise false.\n */\nfunction rest_is_ip_address( $ip ) {\n\t$ipv4_pattern = '/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/';\n\n\tif ( ! preg_match( $ipv4_pattern, $ip ) && ! Requests_IPv6::check_ipv6( $ip ) ) {\n\t\treturn false;\n\t}\n\n\treturn $ip;\n}\n\n/**\n * Changes a boolean-like value into the proper boolean value.\n *\n * @since 4.7.0\n *\n * @param bool|string|int $value The value being evaluated.\n * @return boolean Returns the proper associated boolean value.\n */\nfunction rest_sanitize_boolean( $value ) {\n\t// String values are translated to `true`; make sure 'false' is false.\n\tif ( is_string( $value ) ) {\n\t\t$value = strtolower( $value );\n\t\tif ( in_array( $value, array( 'false', '0' ), true ) ) {\n\t\t\t$value = false;\n\t\t}\n\t}\n\n\t// Everything else will map nicely to boolean.\n\treturn (bool) $value;\n}\n\n/**\n * Determines if a given value is boolean-like.\n *\n * @since 4.7.0\n *\n * @param bool|string $maybe_bool The value being evaluated.\n * @return boolean True if a boolean, otherwise false.\n */\nfunction rest_is_boolean( $maybe_bool ) {\n\tif ( is_bool( $maybe_bool ) ) {\n\t\treturn true;\n\t}\n\n\tif ( is_string( $maybe_bool ) ) {\n\t\t$maybe_bool = strtolower( $maybe_bool );\n\n\t\t$valid_boolean_values = array(\n\t\t\t'false',\n\t\t\t'true',\n\t\t\t'0',\n\t\t\t'1',\n\t\t);\n\n\t\treturn in_array( $maybe_bool, $valid_boolean_values, true );\n\t}\n\n\tif ( is_int( $maybe_bool ) ) {\n\t\treturn in_array( $maybe_bool, array( 0, 1 ), true );\n\t}\n\n\treturn false;\n}\n\n/**\n * Retrieves the avatar urls in various sizes.\n *\n * @since 4.7.0\n *\n * @see get_avatar_url()\n *\n * @param mixed $id_or_email The Gravatar to retrieve a URL for. Accepts a user_id, gravatar md5 hash,\n *                           user email, WP_User object, WP_Post object, or WP_Comment object.\n * @return array $urls Gravatar url for each size.\n */\nfunction rest_get_avatar_urls( $id_or_email ) {\n\t$avatar_sizes = rest_get_avatar_sizes();\n\n\t$urls = array();\n\tforeach ( $avatar_sizes as $size ) {\n\t\t$urls[ $size ] = get_avatar_url( $id_or_email, array( 'size' => $size ) );\n\t}\n\n\treturn $urls;\n}\n\n/**\n * Retrieves the pixel sizes for avatars.\n *\n * @since 4.7.0\n *\n * @return array List of pixel sizes for avatars. Default `[ 24, 48, 96 ]`.\n */\nfunction rest_get_avatar_sizes() {\n\t/**\n\t * Filters the REST avatar sizes.\n\t *\n\t * Use this filter to adjust the array of sizes returned by the\n\t * `rest_get_avatar_sizes` function.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param array $sizes An array of int values that are the pixel sizes for avatars.\n\t *                     Default `[ 24, 48, 96 ]`.\n\t */\n\treturn apply_filters( 'rest_avatar_sizes', array( 24, 48, 96 ) );\n}\n\n/**\n * Validate a value based on a schema.\n *\n * @since 4.7.0\n *\n * @param mixed  $value The value to validate.\n * @param array  $args  Schema array to use for validation.\n * @param string $param The parameter name, used in error messages.\n * @return true|WP_Error\n */\nfunction rest_validate_value_from_schema( $value, $args, $param = '' ) {\n\tif ( is_array( $args['type'] ) ) {\n\t\tforeach ( $args['type'] as $type ) {\n\t\t\t$type_args         = $args;\n\t\t\t$type_args['type'] = $type;\n\n\t\t\tif ( true === rest_validate_value_from_schema( $value, $type_args, $param ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t/* translators: 1: Parameter, 2: List of types. */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s' ), $param, implode( ',', $args['type'] ) ) );\n\t}\n\n\tif ( 'array' === $args['type'] ) {\n\t\tif ( ! is_null( $value ) ) {\n\t\t\t$value = wp_parse_list( $value );\n\t\t}\n\t\tif ( ! wp_is_numeric_array( $value ) ) {\n\t\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'array' ) );\n\t\t}\n\t\tforeach ( $value as $index => $v ) {\n\t\t\t$is_valid = rest_validate_value_from_schema( $v, $args['items'], $param . '[' . $index . ']' );\n\t\t\tif ( is_wp_error( $is_valid ) ) {\n\t\t\t\treturn $is_valid;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( 'object' === $args['type'] ) {\n\t\tif ( $value instanceof stdClass ) {\n\t\t\t$value = (array) $value;\n\t\t}\n\n\t\tif ( $value instanceof JsonSerializable ) {\n\t\t\t$value = $value->jsonSerialize();\n\t\t}\n\n\t\tif ( ! is_array( $value ) ) {\n\t\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'object' ) );\n\t\t}\n\n\t\tforeach ( $value as $property => $v ) {\n\t\t\tif ( isset( $args['properties'][ $property ] ) ) {\n\t\t\t\t$is_valid = rest_validate_value_from_schema( $v, $args['properties'][ $property ], $param . '[' . $property . ']' );\n\t\t\t\tif ( is_wp_error( $is_valid ) ) {\n\t\t\t\t\treturn $is_valid;\n\t\t\t\t}\n\t\t\t} elseif ( isset( $args['additionalProperties'] ) ) {\n\t\t\t\tif ( false === $args['additionalProperties'] ) {\n\t\t\t\t\t/* translators: %s: Property of an object. */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not a valid property of Object.' ), $property ) );\n\t\t\t\t}\n\n\t\t\t\tif ( is_array( $args['additionalProperties'] ) ) {\n\t\t\t\t\t$is_valid = rest_validate_value_from_schema( $v, $args['additionalProperties'], $param . '[' . $property . ']' );\n\t\t\t\t\tif ( is_wp_error( $is_valid ) ) {\n\t\t\t\t\t\treturn $is_valid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( 'null' === $args['type'] ) {\n\t\tif ( null !== $value ) {\n\t\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'null' ) );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tif ( ! empty( $args['enum'] ) ) {\n\t\tif ( ! in_array( $value, $args['enum'], true ) ) {\n\t\t\t/* translators: 1: Parameter, 2: List of valid values. */\n\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not one of %2$s.' ), $param, implode( ', ', $args['enum'] ) ) );\n\t\t}\n\t}\n\n\tif ( in_array( $args['type'], array( 'integer', 'number' ) ) && ! is_numeric( $value ) ) {\n\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, $args['type'] ) );\n\t}\n\n\tif ( 'integer' === $args['type'] && round( floatval( $value ) ) !== floatval( $value ) ) {\n\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'integer' ) );\n\t}\n\n\tif ( 'boolean' === $args['type'] && ! rest_is_boolean( $value ) ) {\n\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'boolean' ) );\n\t}\n\n\tif ( 'string' === $args['type'] && ! is_string( $value ) ) {\n\t\t/* translators: 1: Parameter, 2: Type name. */\n\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s is not of type %2$s.' ), $param, 'string' ) );\n\t}\n\n\tif ( isset( $args['format'] ) ) {\n\t\tswitch ( $args['format'] ) {\n\t\t\tcase 'date-time':\n\t\t\t\tif ( ! rest_parse_date( $value ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_date', __( 'Invalid date.' ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'email':\n\t\t\t\tif ( ! is_email( $value ) ) {\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_email', __( 'Invalid email address.' ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'ip':\n\t\t\t\tif ( ! rest_is_ip_address( $value ) ) {\n\t\t\t\t\t/* translators: %s: IP address. */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%s is not a valid IP address.' ), $param ) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( in_array( $args['type'], array( 'number', 'integer' ), true ) && ( isset( $args['minimum'] ) || isset( $args['maximum'] ) ) ) {\n\t\tif ( isset( $args['minimum'] ) && ! isset( $args['maximum'] ) ) {\n\t\t\tif ( ! empty( $args['exclusiveMinimum'] ) && $value <= $args['minimum'] ) {\n\t\t\t\t/* translators: 1: Parameter, 2: Minimum number. */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be greater than %2$d' ), $param, $args['minimum'] ) );\n\t\t\t} elseif ( empty( $args['exclusiveMinimum'] ) && $value < $args['minimum'] ) {\n\t\t\t\t/* translators: 1: Parameter, 2: Minimum number. */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be greater than or equal to %2$d' ), $param, $args['minimum'] ) );\n\t\t\t}\n\t\t} elseif ( isset( $args['maximum'] ) && ! isset( $args['minimum'] ) ) {\n\t\t\tif ( ! empty( $args['exclusiveMaximum'] ) && $value >= $args['maximum'] ) {\n\t\t\t\t/* translators: 1: Parameter, 2: Maximum number. */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be less than %2$d' ), $param, $args['maximum'] ) );\n\t\t\t} elseif ( empty( $args['exclusiveMaximum'] ) && $value > $args['maximum'] ) {\n\t\t\t\t/* translators: 1: Parameter, 2: Maximum number. */\n\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be less than or equal to %2$d' ), $param, $args['maximum'] ) );\n\t\t\t}\n\t\t} elseif ( isset( $args['maximum'] ) && isset( $args['minimum'] ) ) {\n\t\t\tif ( ! empty( $args['exclusiveMinimum'] ) && ! empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value >= $args['maximum'] || $value <= $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: Parameter, 2: Minimum number, 3: Maximum number. */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (exclusive) and %3$d (exclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t} elseif ( empty( $args['exclusiveMinimum'] ) && ! empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value >= $args['maximum'] || $value < $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: Parameter, 2: Minimum number, 3: Maximum number. */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (inclusive) and %3$d (exclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t} elseif ( ! empty( $args['exclusiveMinimum'] ) && empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value > $args['maximum'] || $value <= $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: Parameter, 2: Minimum number, 3: Maximum number. */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (exclusive) and %3$d (inclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t} elseif ( empty( $args['exclusiveMinimum'] ) && empty( $args['exclusiveMaximum'] ) ) {\n\t\t\t\tif ( $value > $args['maximum'] || $value < $args['minimum'] ) {\n\t\t\t\t\t/* translators: 1: Parameter, 2: Minimum number, 3: Maximum number. */\n\t\t\t\t\treturn new WP_Error( 'rest_invalid_param', sprintf( __( '%1$s must be between %2$d (inclusive) and %3$d (inclusive)' ), $param, $args['minimum'], $args['maximum'] ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Sanitize a value based on a schema.\n *\n * @since 4.7.0\n *\n * @param mixed $value The value to sanitize.\n * @param array $args  Schema array to use for sanitization.\n * @return true|WP_Error\n */\nfunction rest_sanitize_value_from_schema( $value, $args ) {\n\tif ( is_array( $args['type'] ) ) {\n\t\t// Determine which type the value was validated against, and use that type when performing sanitization\n\t\t$validated_type = '';\n\n\t\tforeach ( $args['type'] as $type ) {\n\t\t\t$type_args         = $args;\n\t\t\t$type_args['type'] = $type;\n\n\t\t\tif ( ! is_wp_error( rest_validate_value_from_schema( $value, $type_args ) ) ) {\n\t\t\t\t$validated_type = $type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( ! $validated_type ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t$args['type'] = $validated_type;\n\t}\n\n\tif ( 'array' === $args['type'] ) {\n\t\tif ( empty( $args['items'] ) ) {\n\t\t\treturn (array) $value;\n\t\t}\n\t\t$value = wp_parse_list( $value );\n\t\tforeach ( $value as $index => $v ) {\n\t\t\t$value[ $index ] = rest_sanitize_value_from_schema( $v, $args['items'] );\n\t\t}\n\t\t// Normalize to numeric array so nothing unexpected\n\t\t// is in the keys.\n\t\t$value = array_values( $value );\n\t\treturn $value;\n\t}\n\n\tif ( 'object' === $args['type'] ) {\n\t\tif ( $value instanceof stdClass ) {\n\t\t\t$value = (array) $value;\n\t\t}\n\n\t\tif ( $value instanceof JsonSerializable ) {\n\t\t\t$value = $value->jsonSerialize();\n\t\t}\n\n\t\tif ( ! is_array( $value ) ) {\n\t\t\treturn array();\n\t\t}\n\n\t\tforeach ( $value as $property => $v ) {\n\t\t\tif ( isset( $args['properties'][ $property ] ) ) {\n\t\t\t\t$value[ $property ] = rest_sanitize_value_from_schema( $v, $args['properties'][ $property ] );\n\t\t\t} elseif ( isset( $args['additionalProperties'] ) ) {\n\t\t\t\tif ( false === $args['additionalProperties'] ) {\n\t\t\t\t\tunset( $value[ $property ] );\n\t\t\t\t} elseif ( is_array( $args['additionalProperties'] ) ) {\n\t\t\t\t\t$value[ $property ] = rest_sanitize_value_from_schema( $v, $args['additionalProperties'] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $value;\n\t}\n\n\tif ( 'null' === $args['type'] ) {\n\t\treturn null;\n\t}\n\n\tif ( 'integer' === $args['type'] ) {\n\t\treturn (int) $value;\n\t}\n\n\tif ( 'number' === $args['type'] ) {\n\t\treturn (float) $value;\n\t}\n\n\tif ( 'boolean' === $args['type'] ) {\n\t\treturn rest_sanitize_boolean( $value );\n\t}\n\n\tif ( isset( $args['format'] ) ) {\n\t\tswitch ( $args['format'] ) {\n\t\t\tcase 'date-time':\n\t\t\t\treturn sanitize_text_field( $value );\n\n\t\t\tcase 'email':\n\t\t\t\t/*\n\t\t\t\t * sanitize_email() validates, which would be unexpected.\n\t\t\t\t */\n\t\t\t\treturn sanitize_text_field( $value );\n\n\t\t\tcase 'uri':\n\t\t\t\treturn esc_url_raw( $value );\n\n\t\t\tcase 'ip':\n\t\t\t\treturn sanitize_text_field( $value );\n\t\t}\n\t}\n\n\tif ( 'string' === $args['type'] ) {\n\t\treturn strval( $value );\n\t}\n\n\treturn $value;\n}\n\n/**\n * Append result of internal request to REST API for purpose of preloading data to be attached to a page.\n * Expected to be called in the context of `array_reduce`.\n *\n * @since 5.0.0\n *\n * @param  array  $memo Reduce accumulator.\n * @param  string $path REST API path to preload.\n * @return array        Modified reduce accumulator.\n */\nfunction rest_preload_api_request( $memo, $path ) {\n\t// array_reduce() doesn't support passing an array in PHP 5.2, so we need to make sure we start with one.\n\tif ( ! is_array( $memo ) ) {\n\t\t$memo = array();\n\t}\n\n\tif ( empty( $path ) ) {\n\t\treturn $memo;\n\t}\n\n\t$method = 'GET';\n\tif ( is_array( $path ) && 2 === count( $path ) ) {\n\t\t$method = end( $path );\n\t\t$path   = reset( $path );\n\n\t\tif ( ! in_array( $method, array( 'GET', 'OPTIONS' ), true ) ) {\n\t\t\t$method = 'GET';\n\t\t}\n\t}\n\n\t$path_parts = parse_url( $path );\n\tif ( false === $path_parts ) {\n\t\treturn $memo;\n\t}\n\n\t$request = new WP_REST_Request( $method, $path_parts['path'] );\n\tif ( ! empty( $path_parts['query'] ) ) {\n\t\tparse_str( $path_parts['query'], $query_params );\n\t\t$request->set_query_params( $query_params );\n\t}\n\n\t$response = rest_do_request( $request );\n\tif ( 200 === $response->status ) {\n\t\t$server = rest_get_server();\n\t\t$data   = (array) $response->get_data();\n\t\t$links  = $server::get_compact_response_links( $response );\n\t\tif ( ! empty( $links ) ) {\n\t\t\t$data['_links'] = $links;\n\t\t}\n\n\t\tif ( 'OPTIONS' === $method ) {\n\t\t\t$response = rest_send_allow_header( $response, $server, $request );\n\n\t\t\t$memo[ $method ][ $path ] = array(\n\t\t\t\t'body'    => $data,\n\t\t\t\t'headers' => $response->headers,\n\t\t\t);\n\t\t} else {\n\t\t\t$memo[ $path ] = array(\n\t\t\t\t'body'    => $data,\n\t\t\t\t'headers' => $response->headers,\n\t\t\t);\n\t\t}\n\t}\n\n\treturn $memo;\n}\n", "<?php\n/**\n * WordPress Version\n *\n * Contains version information for the current WordPress release.\n *\n * @package WordPress\n * @since 1.1.0\n */\n\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '5.3-beta3-46478';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 45805;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4960-20190918';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.6.20';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "filenames": ["wp-includes/rest-api.php", "wp-includes/version.php"], "buggy_code_start_loc": [590, 16], "buggy_code_end_loc": [590, 17], "fixing_code_start_loc": [591, 16], "fixing_code_end_loc": [593, 17], "type": "NVD-CWE-noinfo", "message": "WordPress before 5.2.4 is vulnerable to poisoning of the cache of JSON GET requests because certain requests lack a Vary: Origin header.", "other": {"cve": {"id": "CVE-2019-17673", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-17T13:15:11.077", "lastModified": "2022-03-31T17:51:54.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "WordPress before 5.2.4 is vulnerable to poisoning of the cache of JSON GET requests because certain requests lack a Vary: Origin header."}, {"lang": "es", "value": "WordPress versiones anteriores a 5.2.4, es vulnerable al envenenamiento de la memoria cach\u00e9 de peticiones JSON GET porque ciertas peticiones carecen de un encabezado Vary: Origin."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.2.4", "matchCriteriaId": "954E75B0-6B64-4856-B36D-4EBD80FBDC1B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://blog.wpscan.org/wordpress/security/release/2019/10/15/wordpress-524-security-release-breakdown.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://core.trac.wordpress.org/changeset/46478", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/WordPress/WordPress/commit/b224c251adfa16a5f84074a3c0886270c9df38de", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2020/Jan/8", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://wordpress.org/news/2019/10/wordpress-5-2-4-security-release/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://wpvulndb.com/vulnerabilities/9911", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4599", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4677", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/WordPress/WordPress/commit/b224c251adfa16a5f84074a3c0886270c9df38de"}}