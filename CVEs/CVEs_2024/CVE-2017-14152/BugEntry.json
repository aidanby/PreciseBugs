{"buggy_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2010-2011, Kaori Hagihara\n * Copyright (c) 2011-2012, Centre National d'Etudes Spatiales (CNES), France\n * Copyright (c) 2012, CS Systemes d'Information, France\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/** @defgroup J2K J2K - JPEG-2000 codestream reader/writer */\n/*@{*/\n\n/** @name Local static functions */\n/*@{*/\n\n#define OPJ_UNUSED(x) (void)x\n\n/**\n * Sets up the procedures to do on reading header. Developpers wanting to extend the library can add their own reading procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_header_reading(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager);\n\n/**\n * The read header procedure.\n */\nstatic OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * The default encoding validation procedure without any extension.\n *\n * @param       p_j2k                   the jpeg2000 codec to validate.\n * @param       p_stream                the input stream to validate.\n * @param       p_manager               the user event manager.\n *\n * @return true if the parameters are correct.\n */\nstatic OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * The default decoding validation procedure without any extension.\n *\n * @param       p_j2k                   the jpeg2000 codec to validate.\n * @param       p_stream                                the input stream to validate.\n * @param       p_manager               the user event manager.\n *\n * @return true if the parameters are correct.\n */\nstatic OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters\n * are valid. Developpers wanting to extend the library can add their own validation procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters\n * are valid. Developpers wanting to extend the library can add their own validation procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters\n * are valid. Developpers wanting to extend the library can add their own validation procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_end_compress(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager);\n\n/**\n * The mct encoding validation procedure.\n *\n * @param       p_j2k                   the jpeg2000 codec to validate.\n * @param       p_stream                                the input stream to validate.\n * @param       p_manager               the user event manager.\n *\n * @return true if the parameters are correct.\n */\nstatic OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t * p_j2k,\n                                       opj_stream_private_t *p_stream,\n                                       opj_event_mgr_t * p_manager);\n\n/**\n * Builds the tcd decoder to use to decode tile.\n */\nstatic OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t * p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager);\n/**\n * Builds the tcd encoder to use to encode tile.\n */\nstatic OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t * p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager);\n\n/**\n * Creates a tile-coder decoder.\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager                   the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k,\n                                   opj_stream_private_t *p_stream,\n                                   opj_event_mgr_t * p_manager);\n\n/**\n * Excutes the given procedures on the given codec.\n *\n * @param       p_procedure_list        the list of procedures to execute\n * @param       p_j2k                           the jpeg2000 codec to execute the procedures on.\n * @param       p_stream                        the stream to execute the procedures on.\n * @param       p_manager                       the user manager.\n *\n * @return      true                            if all the procedures were successfully executed.\n */\nstatic OPJ_BOOL opj_j2k_exec(opj_j2k_t * p_j2k,\n                             opj_procedure_list_t * p_procedure_list,\n                             opj_stream_private_t *p_stream,\n                             opj_event_mgr_t * p_manager);\n\n/**\n * Updates the rates of the tcp.\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k,\n                                     opj_stream_private_t *p_stream,\n                                     opj_event_mgr_t * p_manager);\n\n/**\n * Copies the decoding tile parameters onto all the tile parameters.\n * Creates also the tile decoder.\n */\nstatic OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Destroys the memory associated with the decoding of headers.\n */\nstatic OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Reads the lookup table containing all the marker, status and action, and returns the handler associated\n * with the marker value.\n * @param       p_id            Marker value to look up\n *\n * @return      the handler associated with the id.\n*/\nstatic const struct opj_dec_memory_marker_handler * opj_j2k_get_marker_handler(\n    OPJ_UINT32 p_id);\n\n/**\n * Destroys a tile coding parameter structure.\n *\n * @param       p_tcp           the tile coding parameter to destroy.\n */\nstatic void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp);\n\n/**\n * Destroys the data inside a tile coding parameter structure.\n *\n * @param       p_tcp           the tile coding parameter which contain data to destroy.\n */\nstatic void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp);\n\n/**\n * Destroys a coding parameter structure.\n *\n * @param       p_cp            the coding parameter to destroy.\n */\nstatic void opj_j2k_cp_destroy(opj_cp_t *p_cp);\n\n/**\n * Compare 2 a SPCod/ SPCoc elements, i.e. the coding style of a given component of a tile.\n *\n * @param       p_j2k            J2K codec.\n * @param       p_tile_no        Tile number\n * @param       p_first_comp_no  The 1st component number to compare.\n * @param       p_second_comp_no The 1st component number to compare.\n *\n * @return OPJ_TRUE if SPCdod are equals.\n */\nstatic OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n/**\n * Writes a SPCod or SPCoc element, i.e. the coding style of a given component of a tile.\n *\n * @param       p_j2k           J2K codec.\n * @param       p_tile_no       FIXME DOC\n * @param       p_comp_no       the component number to output.\n * @param       p_data          FIXME DOC\n * @param       p_header_size   FIXME DOC\n * @param       p_manager       the user event manager.\n *\n * @return FIXME DOC\n*/\nstatic OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no,\n        OPJ_UINT32 p_comp_no,\n        OPJ_BYTE * p_data,\n        OPJ_UINT32 * p_header_size,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Gets the size taken by writing a SPCod or SPCoc for the given tile and component.\n *\n * @param       p_j2k                   the J2K codec.\n * @param       p_tile_no               the tile index.\n * @param       p_comp_no               the component being outputted.\n *\n * @return      the number of bytes taken by the SPCod element.\n */\nstatic OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no,\n        OPJ_UINT32 p_comp_no);\n\n/**\n * Reads a SPCod or SPCoc element, i.e. the coding style of a given component of a tile.\n * @param       p_j2k           the jpeg2000 codec.\n * @param       compno          FIXME DOC\n * @param       p_header_data   the data contained in the COM box.\n * @param       p_header_size   the size of the data contained in the COM marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 compno,\n        OPJ_BYTE * p_header_data,\n        OPJ_UINT32 * p_header_size,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Gets the size taken by writing SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_tile_no               the tile index.\n * @param       p_comp_no               the component being outputted.\n * @param       p_j2k                   the J2K codec.\n *\n * @return      the number of bytes taken by the SPCod element.\n */\nstatic OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no,\n        OPJ_UINT32 p_comp_no);\n\n/**\n * Compares 2 SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_tile_no               the tile to output.\n * @param       p_first_comp_no         the first component number to compare.\n * @param       p_second_comp_no        the second component number to compare.\n *\n * @return OPJ_TRUE if equals.\n */\nstatic OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n\n/**\n * Writes a SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_tile_no               the tile to output.\n * @param       p_comp_no               the component number to output.\n * @param       p_data                  the data buffer.\n * @param       p_header_size   pointer to the size of the data buffer, it is changed by the function.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n *\n*/\nstatic OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 p_tile_no,\n                                        OPJ_UINT32 p_comp_no,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_header_size,\n                                        opj_event_mgr_t * p_manager);\n\n/**\n * Updates the Tile Length Marker.\n */\nstatic void opj_j2k_update_tlm(opj_j2k_t * p_j2k, OPJ_UINT32 p_tile_part_size);\n\n/**\n * Reads a SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_j2k           J2K codec.\n * @param       compno          the component number to output.\n * @param       p_header_data   the data buffer.\n * @param       p_header_size   pointer to the size of the data buffer, it is changed by the function.\n * @param       p_manager       the user event manager.\n *\n*/\nstatic OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k,\n                                       OPJ_UINT32 compno,\n                                       OPJ_BYTE * p_header_data,\n                                       OPJ_UINT32 * p_header_size,\n                                       opj_event_mgr_t * p_manager);\n\n/**\n * Copies the tile component parameters of all the component from the first tile component.\n *\n * @param               p_j2k           the J2k codec.\n */\nstatic void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k);\n\n/**\n * Copies the tile quantization parameters of all the component from the first tile component.\n *\n * @param               p_j2k           the J2k codec.\n */\nstatic void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k);\n\n/**\n * Reads the tiles.\n */\nstatic OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k,\n                                     opj_stream_private_t *p_stream,\n                                     opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t * p_j2k,\n                                       OPJ_UINT32 p_tile_index,\n                                       opj_stream_private_t *p_stream,\n                                       opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t * p_tcd, OPJ_BYTE * p_data,\n        opj_image_t* p_output_image);\n\nstatic void opj_get_tile_dimensions(opj_image_t * l_image,\n                                    opj_tcd_tilecomp_t * l_tilec,\n                                    opj_image_comp_t * l_img_comp,\n                                    OPJ_UINT32* l_size_comp,\n                                    OPJ_UINT32* l_width,\n                                    OPJ_UINT32* l_height,\n                                    OPJ_UINT32* l_offset_x,\n                                    OPJ_UINT32* l_offset_y,\n                                    OPJ_UINT32* l_image_width,\n                                    OPJ_UINT32* l_stride,\n                                    OPJ_UINT32* l_tile_offset);\n\nstatic void opj_j2k_get_tile_data(opj_tcd_t * p_tcd, OPJ_BYTE * p_data);\n\nstatic OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t * p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager);\n\n/**\n * Sets up the procedures to do on writing header.\n * Developers wanting to extend the library can add their own writing procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_header_writing(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k,\n        OPJ_BYTE * p_data,\n        OPJ_UINT32 * p_data_written,\n        OPJ_UINT32 p_total_data_size,\n        opj_stream_private_t *p_stream,\n        struct opj_event_mgr * p_manager);\n\nstatic OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k,\n        OPJ_BYTE * p_data,\n        OPJ_UINT32 * p_data_written,\n        OPJ_UINT32 p_total_data_size,\n        opj_stream_private_t *p_stream,\n        struct opj_event_mgr * p_manager);\n\n/**\n * Gets the offset of the header.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k,\n                                       opj_stream_private_t *p_stream,\n                                       opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k);\n\n/*\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n */\n\n/**\n * Writes the SOC marker (Start Of Codestream)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a SOC marker (Start of Codestream)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_stream        XXX needs data\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the SIZ marker (image and tile size)\n *\n * @param       p_j2k           J2K codec.\n * @param       p_stream        the stream to write data to.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a SIZ marker (image and tile size)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the SIZ box.\n * @param       p_header_size   the size of the data contained in the SIZ marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the COM marker (comment)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a COM marker (comments)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the COM box.\n * @param       p_header_size   the size of the data contained in the COM marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n/**\n * Writes the COD marker (Coding style default)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a COD marker (Coding Styke defaults)\n * @param       p_header_data   the data contained in the COD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Compares 2 COC markers (Coding style component)\n *\n * @param       p_j2k            J2K codec.\n * @param       p_first_comp_no  the index of the first component to compare.\n * @param       p_second_comp_no the index of the second component to compare.\n *\n * @return      OPJ_TRUE if equals\n */\nstatic OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k,\n                                    OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n/**\n * Writes the COC marker (Coding style component)\n *\n * @param       p_j2k       J2K codec.\n * @param       p_comp_no   the index of the component to output.\n * @param       p_stream    the stream to write data to.\n * @param       p_manager   the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k,\n                                  OPJ_UINT32 p_comp_no,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Writes the COC marker (Coding style component)\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_comp_no               the index of the component to output.\n * @param       p_data          FIXME DOC\n * @param       p_data_written  FIXME DOC\n * @param       p_manager               the user event manager.\n*/\nstatic void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 p_comp_no,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_data_written,\n                                        opj_event_mgr_t * p_manager);\n\n/**\n * Gets the maximum size taken by a coc.\n *\n * @param       p_j2k   the jpeg2000 codec to use.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k);\n\n/**\n * Reads a COC marker (Coding Style Component)\n * @param       p_header_data   the data contained in the COC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the QCD marker (quantization default)\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_stream                the stream to write data to.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a QCD marker (Quantization defaults)\n * @param       p_header_data   the data contained in the QCD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Compare QCC markers (quantization component)\n *\n * @param       p_j2k                 J2K codec.\n * @param       p_first_comp_no       the index of the first component to compare.\n * @param       p_second_comp_no      the index of the second component to compare.\n *\n * @return OPJ_TRUE if equals.\n */\nstatic OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k,\n                                    OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n/**\n * Writes the QCC marker (quantization component)\n *\n * @param       p_comp_no       the index of the component to output.\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k,\n                                  OPJ_UINT32 p_comp_no,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Writes the QCC marker (quantization component)\n *\n * @param       p_j2k           J2K codec.\n * @param       p_comp_no       the index of the component to output.\n * @param       p_data          FIXME DOC\n * @param       p_data_written  the stream to write data to.\n * @param       p_manager       the user event manager.\n*/\nstatic void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 p_comp_no,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_data_written,\n                                        opj_event_mgr_t * p_manager);\n\n/**\n * Gets the maximum size taken by a qcc.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k);\n\n/**\n * Reads a QCC marker (Quantization component)\n * @param       p_header_data   the data contained in the QCC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n/**\n * Writes the POC marker (Progression Order Change)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n/**\n * Writes the POC marker (Progression Order Change)\n *\n * @param       p_j2k          J2K codec.\n * @param       p_data         FIXME DOC\n * @param       p_data_written the stream to write data to.\n * @param       p_manager      the user event manager.\n */\nstatic void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_data_written,\n                                        opj_event_mgr_t * p_manager);\n/**\n * Gets the maximum size taken by the writing of a POC.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k);\n\n/**\n * Reads a POC marker (Progression Order Change)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Gets the maximum size taken by the toc headers of all the tile parts of any given tile.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k);\n\n/**\n * Gets the maximum size taken by the headers of the SOT.\n *\n * @param       p_j2k   the jpeg2000 codec to use.\n */\nstatic OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k);\n\n/**\n * Reads a CRG marker (Component registration)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n/**\n * Reads a TLM marker (Tile Length Marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the updated tlm.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Reads a PLM marker (Packet length, main header marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n/**\n * Reads a PLT marker (Packet length, tile-part header)\n *\n * @param       p_header_data   the data contained in the PLT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PLT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Reads a PPM marker (Packed headers, main header)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n */\n\nstatic OPJ_BOOL opj_j2k_read_ppm(\n    opj_j2k_t *p_j2k,\n    OPJ_BYTE * p_header_data,\n    OPJ_UINT32 p_header_size,\n    opj_event_mgr_t * p_manager);\n\n/**\n * Merges all PPM markers read (Packed headers, main header)\n *\n * @param       p_cp      main coding parameters.\n * @param       p_manager the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppm(opj_cp_t *p_cp, opj_event_mgr_t * p_manager);\n\n/**\n * Reads a PPT marker (Packed packet headers, tile-part header)\n *\n * @param       p_header_data   the data contained in the PPT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PPT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Merges all PPT markers read (Packed headers, tile-part header)\n *\n * @param       p_tcp   the tile.\n * @param       p_manager               the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp,\n                                  opj_event_mgr_t * p_manager);\n\n\n/**\n * Writes the TLM marker (Tile Length Marker)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Writes the SOT marker (Start of tile-part)\n *\n * @param       p_j2k            J2K codec.\n * @param       p_data           FIXME DOC\n * @param       p_data_written   FIXME DOC\n * @param       p_stream         the stream to write data to.\n * @param       p_manager        the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads values from a SOT marker (Start of tile-part)\n *\n * the j2k decoder state is not affected. No side effects, no checks except for p_header_size.\n *\n * @param       p_header_data   the data contained in the SOT marker.\n * @param       p_header_size   the size of the data contained in the SOT marker.\n * @param       p_tile_no       Isot.\n * @param       p_tot_len       Psot.\n * @param       p_current_part  TPsot.\n * @param       p_num_parts     TNsot.\n * @param       p_manager       the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *  p_header_data,\n                                       OPJ_UINT32  p_header_size,\n                                       OPJ_UINT32* p_tile_no,\n                                       OPJ_UINT32* p_tot_len,\n                                       OPJ_UINT32* p_current_part,\n                                       OPJ_UINT32* p_num_parts,\n                                       opj_event_mgr_t * p_manager);\n/**\n * Reads a SOT marker (Start of tile-part)\n *\n * @param       p_header_data   the data contained in the SOT marker.\n * @param       p_j2k           the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PPT marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n/**\n * Writes the SOD marker (Start of data)\n *\n * @param       p_j2k               J2K codec.\n * @param       p_tile_coder        FIXME DOC\n * @param       p_data              FIXME DOC\n * @param       p_data_written      FIXME DOC\n * @param       p_total_data_size   FIXME DOC\n * @param       p_stream            the stream to write data to.\n * @param       p_manager           the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,\n                                  opj_tcd_t * p_tile_coder,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  OPJ_UINT32 p_total_data_size,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a SOD marker (Start Of Data)\n *\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_stream                FIXME DOC\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 opj_event_mgr_t * p_manager);\n\nstatic void opj_j2k_update_tlm(opj_j2k_t * p_j2k, OPJ_UINT32 p_tile_part_size)\n{\n    opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,\n                    p_j2k->m_current_tile_number, 1);           /* PSOT */\n    ++p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current;\n\n    opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,\n                    p_tile_part_size, 4);                                       /* PSOT */\n    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 4;\n}\n\n/**\n * Writes the RGN marker (Region Of Interest)\n *\n * @param       p_tile_no               the tile to output\n * @param       p_comp_no               the component to output\n * @param       nb_comps                the number of components\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k,\n                                  OPJ_UINT32 p_tile_no,\n                                  OPJ_UINT32 p_comp_no,\n                                  OPJ_UINT32 nb_comps,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a RGN marker (Region Of Interest)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the EOC marker (End of Codestream)\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n#if 0\n/**\n * Reads a EOC marker (End Of Codestream)\n *\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_stream                FIXME DOC\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_eoc(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 opj_event_mgr_t * p_manager);\n#endif\n\n/**\n * Writes the CBD-MCT-MCC-MCO markers (Multi components transform)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Inits the Info\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\nAdd main header marker information\n@param cstr_index    Codestream information structure\n@param type         marker type\n@param pos          byte offset of marker segment\n@param len          length of marker segment\n */\nstatic OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index,\n                                     OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len) ;\n/**\nAdd tile header marker information\n@param tileno       tile index number\n@param cstr_index   Codestream information structure\n@param type         marker type\n@param pos          byte offset of marker segment\n@param len          length of marker segment\n */\nstatic OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno,\n                                     opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos,\n                                     OPJ_UINT32 len);\n\n/**\n * Reads an unknown marker\n *\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_stream                the stream object to read from.\n * @param       output_marker           FIXME DOC\n * @param       p_manager               the user event manager.\n *\n * @return      true                    if the marker could be deduced.\n*/\nstatic OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 OPJ_UINT32 *output_marker,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the MCT marker (Multiple Component Transform)\n *\n * @param       p_j2k           J2K codec.\n * @param       p_mct_record    FIXME DOC\n * @param       p_stream        the stream to write data to.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k,\n        opj_mct_data_t * p_mct_record,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Reads a MCT marker (Multiple Component Transform)\n *\n * @param       p_header_data   the data contained in the MCT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the MCC marker (Multiple Component Collection)\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_mcc_record            FIXME DOC\n * @param       p_stream                the stream to write data to.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k,\n        opj_simple_mcc_decorrelation_data_t * p_mcc_record,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Reads a MCC marker (Multiple Component Collection)\n *\n * @param       p_header_data   the data contained in the MCC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the MCO marker (Multiple component transformation ordering)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a MCO marker (Multiple Component Transform Ordering)\n *\n * @param       p_header_data   the data contained in the MCO box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCO marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_add_mct(opj_tcp_t * p_tcp, opj_image_t * p_image,\n                                OPJ_UINT32 p_index);\n\nstatic void  opj_j2k_read_int16_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_int32_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float32_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float64_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\nstatic void  opj_j2k_read_int16_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_int32_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float32_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float64_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\nstatic void  opj_j2k_write_float_to_int16(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_write_float_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_write_float_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_write_float_to_float64(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\n/**\n * Ends the encoding, i.e. frees memory.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k,\n                                     opj_stream_private_t *p_stream,\n                                     opj_event_mgr_t * p_manager);\n\n/**\n * Writes the CBD marker (Component bit depth definition)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a CBD marker (Component bit depth definition)\n * @param       p_header_data   the data contained in the CBD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the CBD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n\n/**\n * Writes COC marker for each component.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_all_coc(opj_j2k_t *p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager);\n\n/**\n * Writes QCC marker for each component.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_all_qcc(opj_j2k_t *p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager);\n\n/**\n * Writes regions of interests.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager);\n\n/**\n * Writes EPC ????\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Checks the progression order changes values. Tells of the poc given as input are valid.\n * A nice message is outputted at errors.\n *\n * @param       p_pocs                  the progression order changes.\n * @param       p_nb_pocs               the number of progression order changes.\n * @param       p_nb_resolutions        the number of resolutions.\n * @param       numcomps                the number of components\n * @param       numlayers               the number of layers.\n * @param       p_manager               the user event manager.\n *\n * @return      true if the pocs are valid.\n */\nstatic OPJ_BOOL opj_j2k_check_poc_val(const opj_poc_t *p_pocs,\n                                      OPJ_UINT32 p_nb_pocs,\n                                      OPJ_UINT32 p_nb_resolutions,\n                                      OPJ_UINT32 numcomps,\n                                      OPJ_UINT32 numlayers,\n                                      opj_event_mgr_t * p_manager);\n\n/**\n * Gets the number of tile parts used for the given change of progression (if any) and the given tile.\n *\n * @param               cp                      the coding parameters.\n * @param               pino            the offset of the given poc (i.e. its position in the coding parameter).\n * @param               tileno          the given tile.\n *\n * @return              the number of tile parts.\n */\nstatic OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp, OPJ_UINT32 pino,\n                                     OPJ_UINT32 tileno);\n\n/**\n * Calculates the total number of tile parts needed by the encoder to\n * encode such an image. If not enough memory is available, then the function return false.\n *\n * @param       p_nb_tiles      pointer that will hold the number of tile parts.\n * @param       cp                      the coding parameters for the image.\n * @param       image           the image to encode.\n * @param       p_j2k                   the p_j2k encoder.\n * @param       p_manager       the user event manager.\n *\n * @return true if the function was successful, false else.\n */\nstatic OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k,\n                                     opj_cp_t *cp,\n                                     OPJ_UINT32 * p_nb_tiles,\n                                     opj_image_t *image,\n                                     opj_event_mgr_t * p_manager);\n\nstatic void opj_j2k_dump_MH_info(opj_j2k_t* p_j2k, FILE* out_stream);\n\nstatic void opj_j2k_dump_MH_index(opj_j2k_t* p_j2k, FILE* out_stream);\n\nstatic opj_codestream_index_t* opj_j2k_create_cstr_index(void);\n\nstatic OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t * p_tcp);\n\nstatic OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t * p_tcp);\n\nstatic int opj_j2k_initialise_4K_poc(opj_poc_t *POC, int numres);\n\nstatic void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,\n        opj_image_t *image, opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image, OPJ_UINT16 rsiz,\n        opj_event_mgr_t *p_manager);\n\n/**\n * Checks for invalid number of tile-parts in SOT marker (TPsot==TNsot). See issue 254.\n *\n * @param       p_stream            the stream to read data from.\n * @param       tile_no             tile number we're looking for.\n * @param       p_correction_needed output value. if true, non conformant codestream needs TNsot correction.\n * @param       p_manager       the user event manager.\n *\n * @return true if the function was successful, false else.\n */\nstatic OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t\n        *p_stream, OPJ_UINT32 tile_no, OPJ_BOOL* p_correction_needed,\n        opj_event_mgr_t * p_manager);\n\n/*@}*/\n\n/*@}*/\n\n/* ----------------------------------------------------------------------- */\ntypedef struct j2k_prog_order {\n    OPJ_PROG_ORDER enum_prog;\n    char str_prog[5];\n} j2k_prog_order_t;\n\nstatic const j2k_prog_order_t j2k_prog_order_list[] = {\n    {OPJ_CPRL, \"CPRL\"},\n    {OPJ_LRCP, \"LRCP\"},\n    {OPJ_PCRL, \"PCRL\"},\n    {OPJ_RLCP, \"RLCP\"},\n    {OPJ_RPCL, \"RPCL\"},\n    {(OPJ_PROG_ORDER) - 1, \"\"}\n};\n\n/**\n * FIXME DOC\n */\nstatic const OPJ_UINT32 MCT_ELEMENT_SIZE [] = {\n    2,\n    4,\n    4,\n    8\n};\n\ntypedef void (* opj_j2k_mct_function)(const void * p_src_data,\n                                      void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\nstatic const opj_j2k_mct_function j2k_mct_read_functions_to_float [] = {\n    opj_j2k_read_int16_to_float,\n    opj_j2k_read_int32_to_float,\n    opj_j2k_read_float32_to_float,\n    opj_j2k_read_float64_to_float\n};\n\nstatic const opj_j2k_mct_function j2k_mct_read_functions_to_int32 [] = {\n    opj_j2k_read_int16_to_int32,\n    opj_j2k_read_int32_to_int32,\n    opj_j2k_read_float32_to_int32,\n    opj_j2k_read_float64_to_int32\n};\n\nstatic const opj_j2k_mct_function j2k_mct_write_functions_from_float [] = {\n    opj_j2k_write_float_to_int16,\n    opj_j2k_write_float_to_int32,\n    opj_j2k_write_float_to_float,\n    opj_j2k_write_float_to_float64\n};\n\ntypedef struct opj_dec_memory_marker_handler {\n    /** marker value */\n    OPJ_UINT32 id;\n    /** value of the state when the marker can appear */\n    OPJ_UINT32 states;\n    /** action linked to the marker */\n    OPJ_BOOL(*handler)(opj_j2k_t *p_j2k,\n                       OPJ_BYTE * p_header_data,\n                       OPJ_UINT32 p_header_size,\n                       opj_event_mgr_t * p_manager);\n}\nopj_dec_memory_marker_handler_t;\n\nstatic const opj_dec_memory_marker_handler_t j2k_memory_marker_handler_tab [] =\n{\n    {J2K_MS_SOT, J2K_STATE_MH | J2K_STATE_TPHSOT, opj_j2k_read_sot},\n    {J2K_MS_COD, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_cod},\n    {J2K_MS_COC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_coc},\n    {J2K_MS_RGN, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_rgn},\n    {J2K_MS_QCD, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_qcd},\n    {J2K_MS_QCC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_qcc},\n    {J2K_MS_POC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_poc},\n    {J2K_MS_SIZ, J2K_STATE_MHSIZ, opj_j2k_read_siz},\n    {J2K_MS_TLM, J2K_STATE_MH, opj_j2k_read_tlm},\n    {J2K_MS_PLM, J2K_STATE_MH, opj_j2k_read_plm},\n    {J2K_MS_PLT, J2K_STATE_TPH, opj_j2k_read_plt},\n    {J2K_MS_PPM, J2K_STATE_MH, opj_j2k_read_ppm},\n    {J2K_MS_PPT, J2K_STATE_TPH, opj_j2k_read_ppt},\n    {J2K_MS_SOP, 0, 0},\n    {J2K_MS_CRG, J2K_STATE_MH, opj_j2k_read_crg},\n    {J2K_MS_COM, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_com},\n    {J2K_MS_MCT, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mct},\n    {J2K_MS_CBD, J2K_STATE_MH, opj_j2k_read_cbd},\n    {J2K_MS_MCC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mcc},\n    {J2K_MS_MCO, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mco},\n#ifdef USE_JPWL\n#ifdef TODO_MS /* remove these functions which are not commpatible with the v2 API */\n    {J2K_MS_EPC, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epc},\n    {J2K_MS_EPB, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epb},\n    {J2K_MS_ESD, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_esd},\n    {J2K_MS_RED, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_red},\n#endif\n#endif /* USE_JPWL */\n#ifdef USE_JPSEC\n    {J2K_MS_SEC, J2K_DEC_STATE_MH, j2k_read_sec},\n    {J2K_MS_INSEC, 0, j2k_read_insec}\n#endif /* USE_JPSEC */\n    {J2K_MS_UNK, J2K_STATE_MH | J2K_STATE_TPH, 0}/*opj_j2k_read_unk is directly used*/\n};\n\nstatic void  opj_j2k_read_int16_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_bytes(l_src_data, &l_temp, 2);\n\n        l_src_data += sizeof(OPJ_INT16);\n\n        *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_int32_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_bytes(l_src_data, &l_temp, 4);\n\n        l_src_data += sizeof(OPJ_INT32);\n\n        *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_float32_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_FLOAT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_float(l_src_data, &l_temp);\n\n        l_src_data += sizeof(OPJ_FLOAT32);\n\n        *(l_dest_data++) = l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_float64_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_FLOAT64 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_double(l_src_data, &l_temp);\n\n        l_src_data += sizeof(OPJ_FLOAT64);\n\n        *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_int16_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_bytes(l_src_data, &l_temp, 2);\n\n        l_src_data += sizeof(OPJ_INT16);\n\n        *(l_dest_data++) = (OPJ_INT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_int32_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_bytes(l_src_data, &l_temp, 4);\n\n        l_src_data += sizeof(OPJ_INT32);\n\n        *(l_dest_data++) = (OPJ_INT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_float32_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_FLOAT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_float(l_src_data, &l_temp);\n\n        l_src_data += sizeof(OPJ_FLOAT32);\n\n        *(l_dest_data++) = (OPJ_INT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_float64_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_FLOAT64 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_double(l_src_data, &l_temp);\n\n        l_src_data += sizeof(OPJ_FLOAT64);\n\n        *(l_dest_data++) = (OPJ_INT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_write_float_to_int16(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n    OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        l_temp = (OPJ_UINT32) * (l_src_data++);\n\n        opj_write_bytes(l_dest_data, l_temp, sizeof(OPJ_INT16));\n\n        l_dest_data += sizeof(OPJ_INT16);\n    }\n}\n\nstatic void opj_j2k_write_float_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n    OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        l_temp = (OPJ_UINT32) * (l_src_data++);\n\n        opj_write_bytes(l_dest_data, l_temp, sizeof(OPJ_INT32));\n\n        l_dest_data += sizeof(OPJ_INT32);\n    }\n}\n\nstatic void  opj_j2k_write_float_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n    OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n    OPJ_UINT32 i;\n    OPJ_FLOAT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        l_temp = (OPJ_FLOAT32) * (l_src_data++);\n\n        opj_write_float(l_dest_data, l_temp);\n\n        l_dest_data += sizeof(OPJ_FLOAT32);\n    }\n}\n\nstatic void  opj_j2k_write_float_to_float64(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n    OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n    OPJ_UINT32 i;\n    OPJ_FLOAT64 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        l_temp = (OPJ_FLOAT64) * (l_src_data++);\n\n        opj_write_double(l_dest_data, l_temp);\n\n        l_dest_data += sizeof(OPJ_FLOAT64);\n    }\n}\n\nconst char *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order)\n{\n    const j2k_prog_order_t *po;\n    for (po = j2k_prog_order_list; po->enum_prog != -1; po++) {\n        if (po->enum_prog == prg_order) {\n            return po->str_prog;\n        }\n    }\n    return po->str_prog;\n}\n\nstatic OPJ_BOOL opj_j2k_check_poc_val(const opj_poc_t *p_pocs,\n                                      OPJ_UINT32 p_nb_pocs,\n                                      OPJ_UINT32 p_nb_resolutions,\n                                      OPJ_UINT32 p_num_comps,\n                                      OPJ_UINT32 p_num_layers,\n                                      opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32* packet_array;\n    OPJ_UINT32 index, resno, compno, layno;\n    OPJ_UINT32 i;\n    OPJ_UINT32 step_c = 1;\n    OPJ_UINT32 step_r = p_num_comps * step_c;\n    OPJ_UINT32 step_l = p_nb_resolutions * step_r;\n    OPJ_BOOL loss = OPJ_FALSE;\n    OPJ_UINT32 layno0 = 0;\n\n    packet_array = (OPJ_UINT32*) opj_calloc(step_l * p_num_layers,\n                                            sizeof(OPJ_UINT32));\n    if (packet_array == 00) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory for checking the poc values.\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (p_nb_pocs == 0) {\n        opj_free(packet_array);\n        return OPJ_TRUE;\n    }\n\n    index = step_r * p_pocs->resno0;\n    /* take each resolution for each poc */\n    for (resno = p_pocs->resno0 ; resno < p_pocs->resno1 ; ++resno) {\n        OPJ_UINT32 res_index = index + p_pocs->compno0 * step_c;\n\n        /* take each comp of each resolution for each poc */\n        for (compno = p_pocs->compno0 ; compno < p_pocs->compno1 ; ++compno) {\n            OPJ_UINT32 comp_index = res_index + layno0 * step_l;\n\n            /* and finally take each layer of each res of ... */\n            for (layno = layno0; layno < p_pocs->layno1 ; ++layno) {\n                /*index = step_r * resno + step_c * compno + step_l * layno;*/\n                packet_array[comp_index] = 1;\n                comp_index += step_l;\n            }\n\n            res_index += step_c;\n        }\n\n        index += step_r;\n    }\n    ++p_pocs;\n\n    /* iterate through all the pocs */\n    for (i = 1; i < p_nb_pocs ; ++i) {\n        OPJ_UINT32 l_last_layno1 = (p_pocs - 1)->layno1 ;\n\n        layno0 = (p_pocs->layno1 > l_last_layno1) ? l_last_layno1 : 0;\n        index = step_r * p_pocs->resno0;\n\n        /* take each resolution for each poc */\n        for (resno = p_pocs->resno0 ; resno < p_pocs->resno1 ; ++resno) {\n            OPJ_UINT32 res_index = index + p_pocs->compno0 * step_c;\n\n            /* take each comp of each resolution for each poc */\n            for (compno = p_pocs->compno0 ; compno < p_pocs->compno1 ; ++compno) {\n                OPJ_UINT32 comp_index = res_index + layno0 * step_l;\n\n                /* and finally take each layer of each res of ... */\n                for (layno = layno0; layno < p_pocs->layno1 ; ++layno) {\n                    /*index = step_r * resno + step_c * compno + step_l * layno;*/\n                    packet_array[comp_index] = 1;\n                    comp_index += step_l;\n                }\n\n                res_index += step_c;\n            }\n\n            index += step_r;\n        }\n\n        ++p_pocs;\n    }\n\n    index = 0;\n    for (layno = 0; layno < p_num_layers ; ++layno) {\n        for (resno = 0; resno < p_nb_resolutions; ++resno) {\n            for (compno = 0; compno < p_num_comps; ++compno) {\n                loss |= (packet_array[index] != 1);\n                /*index = step_r * resno + step_c * compno + step_l * layno;*/\n                index += step_c;\n            }\n        }\n    }\n\n    if (loss) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Missing packets possible loss of data\\n\");\n    }\n\n    opj_free(packet_array);\n\n    return !loss;\n}\n\n/* ----------------------------------------------------------------------- */\n\nstatic OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp, OPJ_UINT32 pino,\n                                     OPJ_UINT32 tileno)\n{\n    const OPJ_CHAR *prog = 00;\n    OPJ_INT32 i;\n    OPJ_UINT32 tpnum = 1;\n    opj_tcp_t *tcp = 00;\n    opj_poc_t * l_current_poc = 00;\n\n    /*  preconditions */\n    assert(tileno < (cp->tw * cp->th));\n    assert(pino < (cp->tcps[tileno].numpocs + 1));\n\n    /* get the given tile coding parameter */\n    tcp = &cp->tcps[tileno];\n    assert(tcp != 00);\n\n    l_current_poc = &(tcp->pocs[pino]);\n    assert(l_current_poc != 0);\n\n    /* get the progression order as a character string */\n    prog = opj_j2k_convert_progression_order(tcp->prg);\n    assert(strlen(prog) > 0);\n\n    if (cp->m_specific_param.m_enc.m_tp_on == 1) {\n        for (i = 0; i < 4; ++i) {\n            switch (prog[i]) {\n            /* component wise */\n            case 'C':\n                tpnum *= l_current_poc->compE;\n                break;\n            /* resolution wise */\n            case 'R':\n                tpnum *= l_current_poc->resE;\n                break;\n            /* precinct wise */\n            case 'P':\n                tpnum *= l_current_poc->prcE;\n                break;\n            /* layer wise */\n            case 'L':\n                tpnum *= l_current_poc->layE;\n                break;\n            }\n            /* whould we split here ? */\n            if (cp->m_specific_param.m_enc.m_tp_flag == prog[i]) {\n                cp->m_specific_param.m_enc.m_tp_pos = i;\n                break;\n            }\n        }\n    } else {\n        tpnum = 1;\n    }\n\n    return tpnum;\n}\n\nstatic OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k,\n                                     opj_cp_t *cp,\n                                     OPJ_UINT32 * p_nb_tiles,\n                                     opj_image_t *image,\n                                     opj_event_mgr_t * p_manager\n                                    )\n{\n    OPJ_UINT32 pino, tileno;\n    OPJ_UINT32 l_nb_tiles;\n    opj_tcp_t *tcp;\n\n    /* preconditions */\n    assert(p_nb_tiles != 00);\n    assert(cp != 00);\n    assert(image != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_j2k);\n    OPJ_UNUSED(p_manager);\n\n    l_nb_tiles = cp->tw * cp->th;\n    * p_nb_tiles = 0;\n    tcp = cp->tcps;\n\n    /* INDEX >> */\n    /* TODO mergeV2: check this part which use cstr_info */\n    /*if (p_j2k->cstr_info) {\n            opj_tile_info_t * l_info_tile_ptr = p_j2k->cstr_info->tile;\n\n            for (tileno = 0; tileno < l_nb_tiles; ++tileno) {\n                    OPJ_UINT32 cur_totnum_tp = 0;\n\n                    opj_pi_update_encoding_parameters(image,cp,tileno);\n\n                    for (pino = 0; pino <= tcp->numpocs; ++pino)\n                    {\n                            OPJ_UINT32 tp_num = opj_j2k_get_num_tp(cp,pino,tileno);\n\n                            *p_nb_tiles = *p_nb_tiles + tp_num;\n\n                            cur_totnum_tp += tp_num;\n                    }\n\n                    tcp->m_nb_tile_parts = cur_totnum_tp;\n\n                    l_info_tile_ptr->tp = (opj_tp_info_t *) opj_malloc(cur_totnum_tp * sizeof(opj_tp_info_t));\n                    if (l_info_tile_ptr->tp == 00) {\n                            return OPJ_FALSE;\n                    }\n\n                    memset(l_info_tile_ptr->tp,0,cur_totnum_tp * sizeof(opj_tp_info_t));\n\n                    l_info_tile_ptr->num_tps = cur_totnum_tp;\n\n                    ++l_info_tile_ptr;\n                    ++tcp;\n            }\n    }\n    else */{\n        for (tileno = 0; tileno < l_nb_tiles; ++tileno) {\n            OPJ_UINT32 cur_totnum_tp = 0;\n\n            opj_pi_update_encoding_parameters(image, cp, tileno);\n\n            for (pino = 0; pino <= tcp->numpocs; ++pino) {\n                OPJ_UINT32 tp_num = opj_j2k_get_num_tp(cp, pino, tileno);\n\n                *p_nb_tiles = *p_nb_tiles + tp_num;\n\n                cur_totnum_tp += tp_num;\n            }\n            tcp->m_nb_tile_parts = cur_totnum_tp;\n\n            ++tcp;\n        }\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager)\n{\n    /* 2 bytes will be written */\n    OPJ_BYTE * l_start_stream = 00;\n\n    /* preconditions */\n    assert(p_stream != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_start_stream = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    /* write SOC identifier */\n    opj_write_bytes(l_start_stream, J2K_MS_SOC, 2);\n\n    if (opj_stream_write_data(p_stream, l_start_stream, 2, p_manager) != 2) {\n        return OPJ_FALSE;\n    }\n\n    /* UniPG>> */\n#ifdef USE_JPWL\n    /* update markers struct */\n    /*\n            OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOC, p_stream_tell(p_stream) - 2, 2);\n    */\n    assert(0 && \"TODO\");\n#endif /* USE_JPWL */\n    /* <<UniPG */\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a SOC marker (Start of Codestream)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_stream        FIXME DOC\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_BYTE l_data [2];\n    OPJ_UINT32 l_marker;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    if (opj_stream_read_data(p_stream, l_data, 2, p_manager) != 2) {\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(l_data, &l_marker, 2);\n    if (l_marker != J2K_MS_SOC) {\n        return OPJ_FALSE;\n    }\n\n    /* Next marker should be a SIZ marker in the main header */\n    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MHSIZ;\n\n    /* FIXME move it in a index structure included in p_j2k*/\n    p_j2k->cstr_index->main_head_start = opj_stream_tell(p_stream) - 2;\n\n    opj_event_msg(p_manager, EVT_INFO, \"Start to read j2k main header (%d).\\n\",\n                  p_j2k->cstr_index->main_head_start);\n\n    /* Add the marker to the codestream index*/\n    if (OPJ_FALSE == opj_j2k_add_mhmarker(p_j2k->cstr_index, J2K_MS_SOC,\n                                          p_j2k->cstr_index->main_head_start, 2)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\");\n        return OPJ_FALSE;\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_size_len;\n    OPJ_BYTE * l_current_ptr;\n    opj_image_t * l_image = 00;\n    opj_cp_t *cp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n\n    /* preconditions */\n    assert(p_stream != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_image = p_j2k->m_private_image;\n    cp = &(p_j2k->m_cp);\n    l_size_len = 40 + 3 * l_image->numcomps;\n    l_img_comp = l_image->comps;\n\n    if (l_size_len > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_size_len);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory for the SIZ marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_size_len;\n    }\n\n    l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    /* write SOC identifier */\n    opj_write_bytes(l_current_ptr, J2K_MS_SIZ, 2);  /* SIZ */\n    l_current_ptr += 2;\n\n    opj_write_bytes(l_current_ptr, l_size_len - 2, 2); /* L_SIZ */\n    l_current_ptr += 2;\n\n    opj_write_bytes(l_current_ptr, cp->rsiz, 2);    /* Rsiz (capabilities) */\n    l_current_ptr += 2;\n\n    opj_write_bytes(l_current_ptr, l_image->x1, 4); /* Xsiz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, l_image->y1, 4); /* Ysiz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, l_image->x0, 4); /* X0siz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, l_image->y0, 4); /* Y0siz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, cp->tdx, 4);             /* XTsiz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, cp->tdy, 4);             /* YTsiz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, cp->tx0, 4);             /* XT0siz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, cp->ty0, 4);             /* YT0siz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, l_image->numcomps, 2);   /* Csiz */\n    l_current_ptr += 2;\n\n    for (i = 0; i < l_image->numcomps; ++i) {\n        /* TODO here with MCT ? */\n        opj_write_bytes(l_current_ptr, l_img_comp->prec - 1 + (l_img_comp->sgnd << 7),\n                        1);      /* Ssiz_i */\n        ++l_current_ptr;\n\n        opj_write_bytes(l_current_ptr, l_img_comp->dx, 1);      /* XRsiz_i */\n        ++l_current_ptr;\n\n        opj_write_bytes(l_current_ptr, l_img_comp->dy, 1);      /* YRsiz_i */\n        ++l_current_ptr;\n\n        ++l_img_comp;\n    }\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_size_len,\n                              p_manager) != l_size_len) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a SIZ marker (image and tile size)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the SIZ box.\n * @param       p_header_size   the size of the data contained in the SIZ marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_nb_comp;\n    OPJ_UINT32 l_nb_comp_remain;\n    OPJ_UINT32 l_remaining_size;\n    OPJ_UINT32 l_nb_tiles;\n    OPJ_UINT32 l_tmp, l_tx1, l_ty1;\n    OPJ_UINT32 l_prec0, l_sgnd0;\n    opj_image_t *l_image = 00;\n    opj_cp_t *l_cp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcp_t * l_current_tile_param = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_header_data != 00);\n\n    l_image = p_j2k->m_private_image;\n    l_cp = &(p_j2k->m_cp);\n\n    /* minimum size == 39 - 3 (= minimum component parameter) */\n    if (p_header_size < 36) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker size\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_remaining_size = p_header_size - 36;\n    l_nb_comp = l_remaining_size / 3;\n    l_nb_comp_remain = l_remaining_size % 3;\n    if (l_nb_comp_remain != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker size\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_tmp,\n                   2);                                                /* Rsiz (capabilities) */\n    p_header_data += 2;\n    l_cp->rsiz = (OPJ_UINT16) l_tmp;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x1, 4);   /* Xsiz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y1, 4);   /* Ysiz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x0, 4);   /* X0siz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y0, 4);   /* Y0siz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdx,\n                   4);             /* XTsiz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdy,\n                   4);             /* YTsiz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tx0,\n                   4);             /* XT0siz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->ty0,\n                   4);             /* YT0siz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_tmp,\n                   2);                 /* Csiz */\n    p_header_data += 2;\n    if (l_tmp < 16385) {\n        l_image->numcomps = (OPJ_UINT16) l_tmp;\n    } else {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error with SIZ marker: number of component is illegal -> %d\\n\", l_tmp);\n        return OPJ_FALSE;\n    }\n\n    if (l_image->numcomps != l_nb_comp) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\\n\",\n                      l_image->numcomps, l_nb_comp);\n        return OPJ_FALSE;\n    }\n\n    /* testcase 4035.pdf.SIGSEGV.d8b.3375 */\n    /* testcase issue427-null-image-size.jp2 */\n    if ((l_image->x0 >= l_image->x1) || (l_image->y0 >= l_image->y1)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error with SIZ marker: negative or zero image size (%\" PRId64 \" x %\" PRId64\n                      \")\\n\", (OPJ_INT64)l_image->x1 - l_image->x0,\n                      (OPJ_INT64)l_image->y1 - l_image->y0);\n        return OPJ_FALSE;\n    }\n    /* testcase 2539.pdf.SIGFPE.706.1712 (also 3622.pdf.SIGFPE.706.2916 and 4008.pdf.SIGFPE.706.3345 and maybe more) */\n    if ((l_cp->tdx == 0U) || (l_cp->tdy == 0U)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\\n\", l_cp->tdx,\n                      l_cp->tdy);\n        return OPJ_FALSE;\n    }\n\n    /* testcase 1610.pdf.SIGSEGV.59c.681 */\n    if ((0xFFFFFFFFU / l_image->x1) < l_image->y1) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Prevent buffer overflow (x1: %d, y1: %d)\\n\", l_image->x1, l_image->y1);\n        return OPJ_FALSE;\n    }\n\n    /* testcase issue427-illegal-tile-offset.jp2 */\n    l_tx1 = opj_uint_adds(l_cp->tx0, l_cp->tdx); /* manage overflow */\n    l_ty1 = opj_uint_adds(l_cp->ty0, l_cp->tdy); /* manage overflow */\n    if ((l_cp->tx0 > l_image->x0) || (l_cp->ty0 > l_image->y0) ||\n            (l_tx1 <= l_image->x0) || (l_ty1 <= l_image->y0)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error with SIZ marker: illegal tile offset\\n\");\n        return OPJ_FALSE;\n    }\n    if (!p_j2k->dump_state) {\n        OPJ_UINT32 siz_w, siz_h;\n\n        siz_w = l_image->x1 - l_image->x0;\n        siz_h = l_image->y1 - l_image->y0;\n\n        if (p_j2k->ihdr_w > 0 && p_j2k->ihdr_h > 0\n                && (p_j2k->ihdr_w != siz_w || p_j2k->ihdr_h != siz_h)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Error with SIZ marker: IHDR w(%u) h(%u) vs. SIZ w(%u) h(%u)\\n\", p_j2k->ihdr_w,\n                          p_j2k->ihdr_h, siz_w, siz_h);\n            return OPJ_FALSE;\n        }\n    }\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n        /* if JPWL is on, we check whether TX errors have damaged\n          too much the SIZ parameters */\n        if (!(l_image->x1 * l_image->y1)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"JPWL: bad image size (%d x %d)\\n\",\n                          l_image->x1, l_image->y1);\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n        }\n\n        /* FIXME check previously in the function so why keep this piece of code ? Need by the norm ?\n                if (l_image->numcomps != ((len - 38) / 3)) {\n                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                                \"JPWL: Csiz is %d => space in SIZ only for %d comps.!!!\\n\",\n                                l_image->numcomps, ((len - 38) / 3));\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n        */              /* we try to correct */\n        /*              opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\");\n                        if (l_image->numcomps < ((len - 38) / 3)) {\n                                len = 38 + 3 * l_image->numcomps;\n                                opj_event_msg(p_manager, EVT_WARNING, \"- setting Lsiz to %d => HYPOTHESIS!!!\\n\",\n                                        len);\n                        } else {\n                                l_image->numcomps = ((len - 38) / 3);\n                                opj_event_msg(p_manager, EVT_WARNING, \"- setting Csiz to %d => HYPOTHESIS!!!\\n\",\n                                        l_image->numcomps);\n                        }\n                }\n        */\n\n        /* update components number in the jpwl_exp_comps filed */\n        l_cp->exp_comps = l_image->numcomps;\n    }\n#endif /* USE_JPWL */\n\n    /* Allocate the resulting image components */\n    l_image->comps = (opj_image_comp_t*) opj_calloc(l_image->numcomps,\n                     sizeof(opj_image_comp_t));\n    if (l_image->comps == 00) {\n        l_image->numcomps = 0;\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory to take in charge SIZ marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_img_comp = l_image->comps;\n\n    l_prec0 = 0;\n    l_sgnd0 = 0;\n    /* Read the component information */\n    for (i = 0; i < l_image->numcomps; ++i) {\n        OPJ_UINT32 tmp;\n        opj_read_bytes(p_header_data, &tmp, 1); /* Ssiz_i */\n        ++p_header_data;\n        l_img_comp->prec = (tmp & 0x7f) + 1;\n        l_img_comp->sgnd = tmp >> 7;\n\n        if (p_j2k->dump_state == 0) {\n            if (i == 0) {\n                l_prec0 = l_img_comp->prec;\n                l_sgnd0 = l_img_comp->sgnd;\n            } else if (!l_cp->allow_different_bit_depth_sign\n                       && (l_img_comp->prec != l_prec0 || l_img_comp->sgnd != l_sgnd0)) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"Despite JP2 BPC!=255, precision and/or sgnd values for comp[%d] is different than comp[0]:\\n\"\n                              \"        [0] prec(%d) sgnd(%d) [%d] prec(%d) sgnd(%d)\\n\", i, l_prec0, l_sgnd0,\n                              i, l_img_comp->prec, l_img_comp->sgnd);\n            }\n            /* TODO: we should perhaps also check against JP2 BPCC values */\n        }\n        opj_read_bytes(p_header_data, &tmp, 1); /* XRsiz_i */\n        ++p_header_data;\n        l_img_comp->dx = (OPJ_UINT32)tmp; /* should be between 1 and 255 */\n        opj_read_bytes(p_header_data, &tmp, 1); /* YRsiz_i */\n        ++p_header_data;\n        l_img_comp->dy = (OPJ_UINT32)tmp; /* should be between 1 and 255 */\n        if (l_img_comp->dx < 1 || l_img_comp->dx > 255 ||\n                l_img_comp->dy < 1 || l_img_comp->dy > 255) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\\n\",\n                          i, l_img_comp->dx, l_img_comp->dy);\n            return OPJ_FALSE;\n        }\n        /* Avoids later undefined shift in computation of */\n        /* p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[i].m_dc_level_shift = 1\n                    << (l_image->comps[i].prec - 1); */\n        if (l_img_comp->prec > 31) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\\n\",\n                          i, l_img_comp->prec);\n            return OPJ_FALSE;\n        }\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n            /* if JPWL is on, we check whether TX errors have damaged\n                    too much the SIZ parameters, again */\n            if (!(l_image->comps[i].dx * l_image->comps[i].dy)) {\n                opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                              \"JPWL: bad XRsiz_%d/YRsiz_%d (%d x %d)\\n\",\n                              i, i, l_image->comps[i].dx, l_image->comps[i].dy);\n                if (!JPWL_ASSUME) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                    return OPJ_FALSE;\n                }\n                /* we try to correct */\n                opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust them\\n\");\n                if (!l_image->comps[i].dx) {\n                    l_image->comps[i].dx = 1;\n                    opj_event_msg(p_manager, EVT_WARNING,\n                                  \"- setting XRsiz_%d to %d => HYPOTHESIS!!!\\n\",\n                                  i, l_image->comps[i].dx);\n                }\n                if (!l_image->comps[i].dy) {\n                    l_image->comps[i].dy = 1;\n                    opj_event_msg(p_manager, EVT_WARNING,\n                                  \"- setting YRsiz_%d to %d => HYPOTHESIS!!!\\n\",\n                                  i, l_image->comps[i].dy);\n                }\n            }\n        }\n#endif /* USE_JPWL */\n        l_img_comp->resno_decoded =\n            0;                                                          /* number of resolution decoded */\n        l_img_comp->factor =\n            l_cp->m_specific_param.m_dec.m_reduce; /* reducing factor per component */\n        ++l_img_comp;\n    }\n\n    if (l_cp->tdx == 0 || l_cp->tdy == 0) {\n        return OPJ_FALSE;\n    }\n\n    /* Compute the number of tiles */\n    l_cp->tw = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->x1 - l_cp->tx0),\n                                           (OPJ_INT32)l_cp->tdx);\n    l_cp->th = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->y1 - l_cp->ty0),\n                                           (OPJ_INT32)l_cp->tdy);\n\n    /* Check that the number of tiles is valid */\n    if (l_cp->tw == 0 || l_cp->th == 0 || l_cp->tw > 65535 / l_cp->th) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\\n\",\n                      l_cp->tw, l_cp->th);\n        return OPJ_FALSE;\n    }\n    l_nb_tiles = l_cp->tw * l_cp->th;\n\n    /* Define the tiles which will be decoded */\n    if (p_j2k->m_specific_param.m_decoder.m_discard_tiles) {\n        p_j2k->m_specific_param.m_decoder.m_start_tile_x =\n            (p_j2k->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;\n        p_j2k->m_specific_param.m_decoder.m_start_tile_y =\n            (p_j2k->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;\n        p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32)opj_int_ceildiv((\n                    OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0),\n                (OPJ_INT32)l_cp->tdx);\n        p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32)opj_int_ceildiv((\n                    OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0),\n                (OPJ_INT32)l_cp->tdy);\n    } else {\n        p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;\n        p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;\n        p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;\n        p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;\n    }\n\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n        /* if JPWL is on, we check whether TX errors have damaged\n          too much the SIZ parameters */\n        if ((l_cp->tw < 1) || (l_cp->th < 1) || (l_cp->tw > l_cp->max_tiles) ||\n                (l_cp->th > l_cp->max_tiles)) {\n            opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                          \"JPWL: bad number of tiles (%d x %d)\\n\",\n                          l_cp->tw, l_cp->th);\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n            /* we try to correct */\n            opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust them\\n\");\n            if (l_cp->tw < 1) {\n                l_cp->tw = 1;\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"- setting %d tiles in x => HYPOTHESIS!!!\\n\",\n                              l_cp->tw);\n            }\n            if (l_cp->tw > l_cp->max_tiles) {\n                l_cp->tw = 1;\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"- too large x, increase expectance of %d\\n\"\n                              \"- setting %d tiles in x => HYPOTHESIS!!!\\n\",\n                              l_cp->max_tiles, l_cp->tw);\n            }\n            if (l_cp->th < 1) {\n                l_cp->th = 1;\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"- setting %d tiles in y => HYPOTHESIS!!!\\n\",\n                              l_cp->th);\n            }\n            if (l_cp->th > l_cp->max_tiles) {\n                l_cp->th = 1;\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"- too large y, increase expectance of %d to continue\\n\",\n                              \"- setting %d tiles in y => HYPOTHESIS!!!\\n\",\n                              l_cp->max_tiles, l_cp->th);\n            }\n        }\n    }\n#endif /* USE_JPWL */\n\n    /* memory allocations */\n    l_cp->tcps = (opj_tcp_t*) opj_calloc(l_nb_tiles, sizeof(opj_tcp_t));\n    if (l_cp->tcps == 00) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory to take in charge SIZ marker\\n\");\n        return OPJ_FALSE;\n    }\n\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n        if (!l_cp->tcps) {\n            opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                          \"JPWL: could not alloc tcps field of cp\\n\");\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n        }\n    }\n#endif /* USE_JPWL */\n\n    p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps =\n        (opj_tccp_t*) opj_calloc(l_image->numcomps, sizeof(opj_tccp_t));\n    if (p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps  == 00) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory to take in charge SIZ marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records =\n        (opj_mct_data_t*)opj_calloc(OPJ_J2K_MCT_DEFAULT_NB_RECORDS,\n                                    sizeof(opj_mct_data_t));\n\n    if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory to take in charge SIZ marker\\n\");\n        return OPJ_FALSE;\n    }\n    p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mct_records =\n        OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n\n    p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records =\n        (opj_simple_mcc_decorrelation_data_t*)\n        opj_calloc(OPJ_J2K_MCC_DEFAULT_NB_RECORDS,\n                   sizeof(opj_simple_mcc_decorrelation_data_t));\n\n    if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory to take in charge SIZ marker\\n\");\n        return OPJ_FALSE;\n    }\n    p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mcc_records =\n        OPJ_J2K_MCC_DEFAULT_NB_RECORDS;\n\n    /* set up default dc level shift */\n    for (i = 0; i < l_image->numcomps; ++i) {\n        if (! l_image->comps[i].sgnd) {\n            p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[i].m_dc_level_shift = 1\n                    << (l_image->comps[i].prec - 1);\n        }\n    }\n\n    l_current_tile_param = l_cp->tcps;\n    for (i = 0; i < l_nb_tiles; ++i) {\n        l_current_tile_param->tccps = (opj_tccp_t*) opj_calloc(l_image->numcomps,\n                                      sizeof(opj_tccp_t));\n        if (l_current_tile_param->tccps == 00) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to take in charge SIZ marker\\n\");\n            return OPJ_FALSE;\n        }\n\n        ++l_current_tile_param;\n    }\n\n    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MH;\n    opj_image_comp_header_update(l_image, l_cp);\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    OPJ_UINT32 l_comment_size;\n    OPJ_UINT32 l_total_com_size;\n    const OPJ_CHAR *l_comment;\n    OPJ_BYTE * l_current_ptr = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    l_comment = p_j2k->m_cp.comment;\n    l_comment_size = (OPJ_UINT32)strlen(l_comment);\n    l_total_com_size = l_comment_size + 6;\n\n    if (l_total_com_size >\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_total_com_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to write the COM marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_total_com_size;\n    }\n\n    l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_ptr, J2K_MS_COM, 2);  /* COM */\n    l_current_ptr += 2;\n\n    opj_write_bytes(l_current_ptr, l_total_com_size - 2, 2);        /* L_COM */\n    l_current_ptr += 2;\n\n    opj_write_bytes(l_current_ptr, 1,\n                    2);   /* General use (IS 8859-15:1999 (Latin) values) */\n    l_current_ptr += 2;\n\n    memcpy(l_current_ptr, l_comment, l_comment_size);\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_total_com_size,\n                              p_manager) != l_total_com_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a COM marker (comments)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the COM box.\n * @param       p_header_size   the size of the data contained in the COM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_header_data != 00);\n\n    OPJ_UNUSED(p_j2k);\n    OPJ_UNUSED(p_header_data);\n    OPJ_UNUSED(p_header_size);\n    OPJ_UNUSED(p_manager);\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager)\n{\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_code_size, l_remaining_size;\n    OPJ_BYTE * l_current_data = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n    l_code_size = 9 + opj_j2k_get_SPCod_SPCoc_size(p_j2k,\n                  p_j2k->m_current_tile_number, 0);\n    l_remaining_size = l_code_size;\n\n    if (l_code_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_code_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write COD marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_code_size;\n    }\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_COD, 2);           /* COD */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_code_size - 2, 2);      /* L_COD */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_tcp->csty, 1);          /* Scod */\n    ++l_current_data;\n\n    opj_write_bytes(l_current_data, (OPJ_UINT32)l_tcp->prg, 1); /* SGcod (A) */\n    ++l_current_data;\n\n    opj_write_bytes(l_current_data, l_tcp->numlayers, 2);     /* SGcod (B) */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_tcp->mct, 1);           /* SGcod (C) */\n    ++l_current_data;\n\n    l_remaining_size -= 9;\n\n    if (! opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, 0,\n                                    l_current_data, &l_remaining_size, p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error writing COD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (l_remaining_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error writing COD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_code_size,\n                              p_manager) != l_code_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a COD marker (Coding Styke defaults)\n * @param       p_header_data   the data contained in the COD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    /* loop */\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_tmp;\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_image_t *l_image = 00;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_image = p_j2k->m_private_image;\n    l_cp = &(p_j2k->m_cp);\n\n    /* If we are in the first tile-part header of the current tile */\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    /* Only one COD per tile */\n    if (l_tcp->cod) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"COD marker already read. No more than one COD marker per tile.\\n\");\n        return OPJ_FALSE;\n    }\n    l_tcp->cod = 1;\n\n    /* Make sure room is sufficient */\n    if (p_header_size < 5) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading COD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_tcp->csty, 1);         /* Scod */\n    ++p_header_data;\n    /* Make sure we know how to decode this */\n    if ((l_tcp->csty & ~(OPJ_UINT32)(J2K_CP_CSTY_PRT | J2K_CP_CSTY_SOP |\n                                     J2K_CP_CSTY_EPH)) != 0U) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Unknown Scod value in COD marker\\n\");\n        return OPJ_FALSE;\n    }\n    opj_read_bytes(p_header_data, &l_tmp, 1);                       /* SGcod (A) */\n    ++p_header_data;\n    l_tcp->prg = (OPJ_PROG_ORDER) l_tmp;\n    /* Make sure progression order is valid */\n    if (l_tcp->prg > OPJ_CPRL) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Unknown progression order in COD marker\\n\");\n        l_tcp->prg = OPJ_PROG_UNKNOWN;\n    }\n    opj_read_bytes(p_header_data, &l_tcp->numlayers, 2);    /* SGcod (B) */\n    p_header_data += 2;\n\n    if ((l_tcp->numlayers < 1U) || (l_tcp->numlayers > 65535U)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Invalid number of layers in COD marker : %d not in range [1-65535]\\n\",\n                      l_tcp->numlayers);\n        return OPJ_FALSE;\n    }\n\n    /* If user didn't set a number layer to decode take the max specify in the codestream. */\n    if (l_cp->m_specific_param.m_dec.m_layer) {\n        l_tcp->num_layers_to_decode = l_cp->m_specific_param.m_dec.m_layer;\n    } else {\n        l_tcp->num_layers_to_decode = l_tcp->numlayers;\n    }\n\n    opj_read_bytes(p_header_data, &l_tcp->mct, 1);          /* SGcod (C) */\n    ++p_header_data;\n\n    p_header_size -= 5;\n    for (i = 0; i < l_image->numcomps; ++i) {\n        l_tcp->tccps[i].csty = l_tcp->csty & J2K_CCP_CSTY_PRT;\n    }\n\n    if (! opj_j2k_read_SPCod_SPCoc(p_j2k, 0, p_header_data, &p_header_size,\n                                   p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading COD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (p_header_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading COD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* Apply the coding style to other components of the current tile or the m_default_tcp*/\n    opj_j2k_copy_tile_component_parameters(p_j2k);\n\n    /* Index */\n#ifdef WIP_REMOVE_MSD\n    if (p_j2k->cstr_info) {\n        /*opj_codestream_info_t *l_cstr_info = p_j2k->cstr_info;*/\n        p_j2k->cstr_info->prog = l_tcp->prg;\n        p_j2k->cstr_info->numlayers = l_tcp->numlayers;\n        p_j2k->cstr_info->numdecompos = (OPJ_INT32*) opj_malloc(\n                                            l_image->numcomps * sizeof(OPJ_UINT32));\n        if (!p_j2k->cstr_info->numdecompos) {\n            return OPJ_FALSE;\n        }\n        for (i = 0; i < l_image->numcomps; ++i) {\n            p_j2k->cstr_info->numdecompos[i] = l_tcp->tccps[i].numresolutions - 1;\n        }\n    }\n#endif\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k,\n                                  OPJ_UINT32 p_comp_no,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 l_coc_size, l_remaining_size;\n    OPJ_UINT32 l_comp_room;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_comp_room = (p_j2k->m_private_image->numcomps <= 256) ? 1 : 2;\n\n    l_coc_size = 5 + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(p_j2k,\n                 p_j2k->m_current_tile_number, p_comp_no);\n\n    if (l_coc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data;\n        /*p_j2k->m_specific_param.m_encoder.m_header_tile_data\n                = (OPJ_BYTE*)opj_realloc(\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data,\n                        l_coc_size);*/\n\n        new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                   p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_coc_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write COC marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_coc_size;\n    }\n\n    opj_j2k_write_coc_in_memory(p_j2k, p_comp_no,\n                                p_j2k->m_specific_param.m_encoder.m_header_tile_data, &l_remaining_size,\n                                p_manager);\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_coc_size,\n                              p_manager) != l_coc_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k,\n                                    OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n\n    if (l_tcp->tccps[p_first_comp_no].csty != l_tcp->tccps[p_second_comp_no].csty) {\n        return OPJ_FALSE;\n    }\n\n\n    return opj_j2k_compare_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number,\n                                       p_first_comp_no, p_second_comp_no);\n}\n\nstatic void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 p_comp_no,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_data_written,\n                                        opj_event_mgr_t * p_manager\n                                       )\n{\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_coc_size, l_remaining_size;\n    OPJ_BYTE * l_current_data = 00;\n    opj_image_t *l_image = 00;\n    OPJ_UINT32 l_comp_room;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n    l_image = p_j2k->m_private_image;\n    l_comp_room = (l_image->numcomps <= 256) ? 1 : 2;\n\n    l_coc_size = 5 + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(p_j2k,\n                 p_j2k->m_current_tile_number, p_comp_no);\n    l_remaining_size = l_coc_size;\n\n    l_current_data = p_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_COC,\n                    2);                         /* COC */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_coc_size - 2,\n                    2);                     /* L_COC */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, p_comp_no, l_comp_room);        /* Ccoc */\n    l_current_data += l_comp_room;\n\n    opj_write_bytes(l_current_data, l_tcp->tccps[p_comp_no].csty,\n                    1);               /* Scoc */\n    ++l_current_data;\n\n    l_remaining_size -= (5 + l_comp_room);\n    opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, 0,\n                              l_current_data, &l_remaining_size, p_manager);\n    * p_data_written = l_coc_size;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k)\n{\n    OPJ_UINT32 i, j;\n    OPJ_UINT32 l_nb_comp;\n    OPJ_UINT32 l_nb_tiles;\n    OPJ_UINT32 l_max = 0;\n\n    /* preconditions */\n\n    l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th ;\n    l_nb_comp = p_j2k->m_private_image->numcomps;\n\n    for (i = 0; i < l_nb_tiles; ++i) {\n        for (j = 0; j < l_nb_comp; ++j) {\n            l_max = opj_uint_max(l_max, opj_j2k_get_SPCod_SPCoc_size(p_j2k, i, j));\n        }\n    }\n\n    return 6 + l_max;\n}\n\n/**\n * Reads a COC marker (Coding Style Component)\n * @param       p_header_data   the data contained in the COC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n    opj_image_t *l_image = NULL;\n    OPJ_UINT32 l_comp_room;\n    OPJ_UINT32 l_comp_no;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH)\n            ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n    l_image = p_j2k->m_private_image;\n\n    l_comp_room = l_image->numcomps <= 256 ? 1 : 2;\n\n    /* make sure room is sufficient*/\n    if (p_header_size < l_comp_room + 1) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker\\n\");\n        return OPJ_FALSE;\n    }\n    p_header_size -= l_comp_room + 1;\n\n    opj_read_bytes(p_header_data, &l_comp_no,\n                   l_comp_room);                 /* Ccoc */\n    p_header_data += l_comp_room;\n    if (l_comp_no >= l_image->numcomps) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error reading COC marker (bad number of components)\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_tcp->tccps[l_comp_no].csty,\n                   1);                  /* Scoc */\n    ++p_header_data ;\n\n    if (! opj_j2k_read_SPCod_SPCoc(p_j2k, l_comp_no, p_header_data, &p_header_size,\n                                   p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (p_header_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker\\n\");\n        return OPJ_FALSE;\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    OPJ_UINT32 l_qcd_size, l_remaining_size;\n    OPJ_BYTE * l_current_data = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_qcd_size = 4 + opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number,\n                 0);\n    l_remaining_size = l_qcd_size;\n\n    if (l_qcd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcd_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write QCD marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcd_size;\n    }\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_QCD, 2);         /* QCD */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_qcd_size - 2, 2);     /* L_QCD */\n    l_current_data += 2;\n\n    l_remaining_size -= 4;\n\n    if (! opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, 0,\n                                  l_current_data, &l_remaining_size, p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error writing QCD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (l_remaining_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error writing QCD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcd_size,\n                              p_manager) != l_qcd_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a QCD marker (Quantization defaults)\n * @param       p_header_data   the data contained in the QCD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_j2k_read_SQcd_SQcc(p_j2k, 0, p_header_data, &p_header_size,\n                                 p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (p_header_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* Apply the quantization parameters to other components of the current tile or the m_default_tcp */\n    opj_j2k_copy_tile_quantization_parameters(p_j2k);\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k,\n                                  OPJ_UINT32 p_comp_no,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    OPJ_UINT32 l_qcc_size, l_remaining_size;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_qcc_size = 5 + opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number,\n                 p_comp_no);\n    l_qcc_size += p_j2k->m_private_image->numcomps <= 256 ? 0 : 1;\n    l_remaining_size = l_qcc_size;\n\n    if (l_qcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcc_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write QCC marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcc_size;\n    }\n\n    opj_j2k_write_qcc_in_memory(p_j2k, p_comp_no,\n                                p_j2k->m_specific_param.m_encoder.m_header_tile_data, &l_remaining_size,\n                                p_manager);\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcc_size,\n                              p_manager) != l_qcc_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k,\n                                    OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n    return opj_j2k_compare_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number,\n                                     p_first_comp_no, p_second_comp_no);\n}\n\nstatic void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 p_comp_no,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_data_written,\n                                        opj_event_mgr_t * p_manager\n                                       )\n{\n    OPJ_UINT32 l_qcc_size, l_remaining_size;\n    OPJ_BYTE * l_current_data = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_qcc_size = 6 + opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number,\n                 p_comp_no);\n    l_remaining_size = l_qcc_size;\n\n    l_current_data = p_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_QCC, 2);         /* QCC */\n    l_current_data += 2;\n\n    if (p_j2k->m_private_image->numcomps <= 256) {\n        --l_qcc_size;\n\n        opj_write_bytes(l_current_data, l_qcc_size - 2, 2);     /* L_QCC */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data, p_comp_no, 1);  /* Cqcc */\n        ++l_current_data;\n\n        /* in the case only one byte is sufficient the last byte allocated is useless -> still do -6 for available */\n        l_remaining_size -= 6;\n    } else {\n        opj_write_bytes(l_current_data, l_qcc_size - 2, 2);     /* L_QCC */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data, p_comp_no, 2);  /* Cqcc */\n        l_current_data += 2;\n\n        l_remaining_size -= 6;\n    }\n\n    opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, p_comp_no,\n                            l_current_data, &l_remaining_size, p_manager);\n\n    *p_data_written = l_qcc_size;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k)\n{\n    return opj_j2k_get_max_coc_size(p_j2k);\n}\n\n/**\n * Reads a QCC marker (Quantization component)\n * @param       p_header_data   the data contained in the QCC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_num_comp, l_comp_no;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_num_comp = p_j2k->m_private_image->numcomps;\n\n    if (l_num_comp <= 256) {\n        if (p_header_size < 1) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n            return OPJ_FALSE;\n        }\n        opj_read_bytes(p_header_data, &l_comp_no, 1);\n        ++p_header_data;\n        --p_header_size;\n    } else {\n        if (p_header_size < 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n            return OPJ_FALSE;\n        }\n        opj_read_bytes(p_header_data, &l_comp_no, 2);\n        p_header_data += 2;\n        p_header_size -= 2;\n    }\n\n#ifdef USE_JPWL\n    if (p_j2k->m_cp.correct) {\n\n        static OPJ_UINT32 backup_compno = 0;\n\n        /* compno is negative or larger than the number of components!!! */\n        if (/*(l_comp_no < 0) ||*/ (l_comp_no >= l_num_comp)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"JPWL: bad component number in QCC (%d out of a maximum of %d)\\n\",\n                          l_comp_no, l_num_comp);\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n            /* we try to correct */\n            l_comp_no = backup_compno % l_num_comp;\n            opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\"\n                          \"- setting component number to %d\\n\",\n                          l_comp_no);\n        }\n\n        /* keep your private count of tiles */\n        backup_compno++;\n    };\n#endif /* USE_JPWL */\n\n    if (l_comp_no >= p_j2k->m_private_image->numcomps) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Invalid component number: %d, regarding the number of components %d\\n\",\n                      l_comp_no, p_j2k->m_private_image->numcomps);\n        return OPJ_FALSE;\n    }\n\n    if (! opj_j2k_read_SQcd_SQcc(p_j2k, l_comp_no, p_header_data, &p_header_size,\n                                 p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (p_header_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    OPJ_UINT32 l_nb_comp;\n    OPJ_UINT32 l_nb_poc;\n    OPJ_UINT32 l_poc_size;\n    OPJ_UINT32 l_written_size = 0;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_poc_room;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_tcp = &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number];\n    l_nb_comp = p_j2k->m_private_image->numcomps;\n    l_nb_poc = 1 + l_tcp->numpocs;\n\n    if (l_nb_comp <= 256) {\n        l_poc_room = 1;\n    } else {\n        l_poc_room = 2;\n    }\n    l_poc_size = 4 + (5 + 2 * l_poc_room) * l_nb_poc;\n\n    if (l_poc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_poc_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write POC marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_poc_size;\n    }\n\n    opj_j2k_write_poc_in_memory(p_j2k,\n                                p_j2k->m_specific_param.m_encoder.m_header_tile_data, &l_written_size,\n                                p_manager);\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_poc_size,\n                              p_manager) != l_poc_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_data_written,\n                                        opj_event_mgr_t * p_manager\n                                       )\n{\n    OPJ_UINT32 i;\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_nb_comp;\n    OPJ_UINT32 l_nb_poc;\n    OPJ_UINT32 l_poc_size;\n    opj_image_t *l_image = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n    opj_poc_t *l_current_poc = 00;\n    OPJ_UINT32 l_poc_room;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_manager);\n\n    l_tcp = &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number];\n    l_tccp = &l_tcp->tccps[0];\n    l_image = p_j2k->m_private_image;\n    l_nb_comp = l_image->numcomps;\n    l_nb_poc = 1 + l_tcp->numpocs;\n\n    if (l_nb_comp <= 256) {\n        l_poc_room = 1;\n    } else {\n        l_poc_room = 2;\n    }\n\n    l_poc_size = 4 + (5 + 2 * l_poc_room) * l_nb_poc;\n\n    l_current_data = p_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_POC,\n                    2);                                   /* POC  */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_poc_size - 2,\n                    2);                                 /* Lpoc */\n    l_current_data += 2;\n\n    l_current_poc =  l_tcp->pocs;\n    for (i = 0; i < l_nb_poc; ++i) {\n        opj_write_bytes(l_current_data, l_current_poc->resno0,\n                        1);                                /* RSpoc_i */\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data, l_current_poc->compno0,\n                        l_poc_room);              /* CSpoc_i */\n        l_current_data += l_poc_room;\n\n        opj_write_bytes(l_current_data, l_current_poc->layno1,\n                        2);                                /* LYEpoc_i */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data, l_current_poc->resno1,\n                        1);                                /* REpoc_i */\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data, l_current_poc->compno1,\n                        l_poc_room);              /* CEpoc_i */\n        l_current_data += l_poc_room;\n\n        opj_write_bytes(l_current_data, (OPJ_UINT32)l_current_poc->prg,\n                        1);   /* Ppoc_i */\n        ++l_current_data;\n\n        /* change the value of the max layer according to the actual number of layers in the file, components and resolutions*/\n        l_current_poc->layno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)\n                                l_current_poc->layno1, (OPJ_INT32)l_tcp->numlayers);\n        l_current_poc->resno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)\n                                l_current_poc->resno1, (OPJ_INT32)l_tccp->numresolutions);\n        l_current_poc->compno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)\n                                 l_current_poc->compno1, (OPJ_INT32)l_nb_comp);\n\n        ++l_current_poc;\n    }\n\n    *p_data_written = l_poc_size;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)\n{\n    opj_tcp_t * l_tcp = 00;\n    OPJ_UINT32 l_nb_tiles = 0;\n    OPJ_UINT32 l_max_poc = 0;\n    OPJ_UINT32 i;\n\n    l_tcp = p_j2k->m_cp.tcps;\n    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n\n    for (i = 0; i < l_nb_tiles; ++i) {\n        l_max_poc = opj_uint_max(l_max_poc, l_tcp->numpocs);\n        ++l_tcp;\n    }\n\n    ++l_max_poc;\n\n    return 4 + 9 * l_max_poc;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k)\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_nb_tiles;\n    OPJ_UINT32 l_max = 0;\n    opj_tcp_t * l_tcp = 00;\n\n    l_tcp = p_j2k->m_cp.tcps;\n    l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th ;\n\n    for (i = 0; i < l_nb_tiles; ++i) {\n        l_max = opj_uint_max(l_max, l_tcp->m_nb_tile_parts);\n\n        ++l_tcp;\n    }\n\n    return 12 * l_max;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k)\n{\n    OPJ_UINT32 l_nb_bytes = 0;\n    OPJ_UINT32 l_nb_comps;\n    OPJ_UINT32 l_coc_bytes, l_qcc_bytes;\n\n    l_nb_comps = p_j2k->m_private_image->numcomps - 1;\n    l_nb_bytes += opj_j2k_get_max_toc_size(p_j2k);\n\n    if (!(OPJ_IS_CINEMA(p_j2k->m_cp.rsiz))) {\n        l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);\n        l_nb_bytes += l_nb_comps * l_coc_bytes;\n\n        l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);\n        l_nb_bytes += l_nb_comps * l_qcc_bytes;\n    }\n\n    l_nb_bytes += opj_j2k_get_max_poc_size(p_j2k);\n\n    /*** DEVELOPER CORNER, Add room for your headers ***/\n\n    return l_nb_bytes;\n}\n\n/**\n * Reads a POC marker (Progression Order Change)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 i, l_nb_comp, l_tmp;\n    opj_image_t * l_image = 00;\n    OPJ_UINT32 l_old_poc_nb, l_current_poc_nb, l_current_poc_remaining;\n    OPJ_UINT32 l_chunk_size, l_comp_room;\n\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_poc_t *l_current_poc = 00;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_image = p_j2k->m_private_image;\n    l_nb_comp = l_image->numcomps;\n    if (l_nb_comp <= 256) {\n        l_comp_room = 1;\n    } else {\n        l_comp_room = 2;\n    }\n    l_chunk_size = 5 + 2 * l_comp_room;\n    l_current_poc_nb = p_header_size / l_chunk_size;\n    l_current_poc_remaining = p_header_size % l_chunk_size;\n\n    if ((l_current_poc_nb <= 0) || (l_current_poc_remaining != 0)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading POC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n    l_old_poc_nb = l_tcp->POC ? l_tcp->numpocs + 1 : 0;\n    l_current_poc_nb += l_old_poc_nb;\n\n    if (l_current_poc_nb >= 32) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Too many POCs %d\\n\", l_current_poc_nb);\n        return OPJ_FALSE;\n    }\n    assert(l_current_poc_nb < 32);\n\n    /* now poc is in use.*/\n    l_tcp->POC = 1;\n\n    l_current_poc = &l_tcp->pocs[l_old_poc_nb];\n    for (i = l_old_poc_nb; i < l_current_poc_nb; ++i) {\n        opj_read_bytes(p_header_data, &(l_current_poc->resno0),\n                       1);                               /* RSpoc_i */\n        ++p_header_data;\n        opj_read_bytes(p_header_data, &(l_current_poc->compno0),\n                       l_comp_room);  /* CSpoc_i */\n        p_header_data += l_comp_room;\n        opj_read_bytes(p_header_data, &(l_current_poc->layno1),\n                       2);                               /* LYEpoc_i */\n        /* make sure layer end is in acceptable bounds */\n        l_current_poc->layno1 = opj_uint_min(l_current_poc->layno1, l_tcp->numlayers);\n        p_header_data += 2;\n        opj_read_bytes(p_header_data, &(l_current_poc->resno1),\n                       1);                               /* REpoc_i */\n        ++p_header_data;\n        opj_read_bytes(p_header_data, &(l_current_poc->compno1),\n                       l_comp_room);  /* CEpoc_i */\n        p_header_data += l_comp_room;\n        opj_read_bytes(p_header_data, &l_tmp,\n                       1);                                                                 /* Ppoc_i */\n        ++p_header_data;\n        l_current_poc->prg = (OPJ_PROG_ORDER) l_tmp;\n        /* make sure comp is in acceptable bounds */\n        l_current_poc->compno1 = opj_uint_min(l_current_poc->compno1, l_nb_comp);\n        ++l_current_poc;\n    }\n\n    l_tcp->numpocs = l_current_poc_nb - 1;\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a CRG marker (Component registration)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_nb_comp;\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_header_data);\n\n    l_nb_comp = p_j2k->m_private_image->numcomps;\n\n    if (p_header_size != l_nb_comp * 4) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading CRG marker\\n\");\n        return OPJ_FALSE;\n    }\n    /* Do not care of this at the moment since only local variables are set here */\n    /*\n    for\n            (i = 0; i < l_nb_comp; ++i)\n    {\n            opj_read_bytes(p_header_data,&l_Xcrg_i,2);                              // Xcrg_i\n            p_header_data+=2;\n            opj_read_bytes(p_header_data,&l_Ycrg_i,2);                              // Xcrg_i\n            p_header_data+=2;\n    }\n    */\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a TLM marker (Tile Length Marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_Ztlm, l_Stlm, l_ST, l_SP, l_tot_num_tp_remaining, l_quotient,\n               l_Ptlm_size;\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_j2k);\n\n    if (p_header_size < 2) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading TLM marker\\n\");\n        return OPJ_FALSE;\n    }\n    p_header_size -= 2;\n\n    opj_read_bytes(p_header_data, &l_Ztlm,\n                   1);                              /* Ztlm */\n    ++p_header_data;\n    opj_read_bytes(p_header_data, &l_Stlm,\n                   1);                              /* Stlm */\n    ++p_header_data;\n\n    l_ST = ((l_Stlm >> 4) & 0x3);\n    l_SP = (l_Stlm >> 6) & 0x1;\n\n    l_Ptlm_size = (l_SP + 1) * 2;\n    l_quotient = l_Ptlm_size + l_ST;\n\n    l_tot_num_tp_remaining = p_header_size % l_quotient;\n\n    if (l_tot_num_tp_remaining != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading TLM marker\\n\");\n        return OPJ_FALSE;\n    }\n    /* FIXME Do not care of this at the moment since only local variables are set here */\n    /*\n    for\n            (i = 0; i < l_tot_num_tp; ++i)\n    {\n            opj_read_bytes(p_header_data,&l_Ttlm_i,l_ST);                           // Ttlm_i\n            p_header_data += l_ST;\n            opj_read_bytes(p_header_data,&l_Ptlm_i,l_Ptlm_size);            // Ptlm_i\n            p_header_data += l_Ptlm_size;\n    }*/\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a PLM marker (Packet length, main header marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_j2k);\n    OPJ_UNUSED(p_header_data);\n\n    if (p_header_size < 1) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLM marker\\n\");\n        return OPJ_FALSE;\n    }\n    /* Do not care of this at the moment since only local variables are set here */\n    /*\n    opj_read_bytes(p_header_data,&l_Zplm,1);                                        // Zplm\n    ++p_header_data;\n    --p_header_size;\n\n    while\n            (p_header_size > 0)\n    {\n            opj_read_bytes(p_header_data,&l_Nplm,1);                                // Nplm\n            ++p_header_data;\n            p_header_size -= (1+l_Nplm);\n            if\n                    (p_header_size < 0)\n            {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLM marker\\n\");\n                    return false;\n            }\n            for\n                    (i = 0; i < l_Nplm; ++i)\n            {\n                    opj_read_bytes(p_header_data,&l_tmp,1);                         // Iplm_ij\n                    ++p_header_data;\n                    // take only the last seven bytes\n                    l_packet_len |= (l_tmp & 0x7f);\n                    if\n                            (l_tmp & 0x80)\n                    {\n                            l_packet_len <<= 7;\n                    }\n                    else\n                    {\n            // store packet length and proceed to next packet\n                            l_packet_len = 0;\n                    }\n            }\n            if\n                    (l_packet_len != 0)\n            {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLM marker\\n\");\n                    return false;\n            }\n    }\n    */\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a PLT marker (Packet length, tile-part header)\n *\n * @param       p_header_data   the data contained in the PLT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PLT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_Zplt, l_tmp, l_packet_len = 0, i;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_j2k);\n\n    if (p_header_size < 1) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_Zplt, 1);              /* Zplt */\n    ++p_header_data;\n    --p_header_size;\n\n    for (i = 0; i < p_header_size; ++i) {\n        opj_read_bytes(p_header_data, &l_tmp, 1);       /* Iplt_ij */\n        ++p_header_data;\n        /* take only the last seven bytes */\n        l_packet_len |= (l_tmp & 0x7f);\n        if (l_tmp & 0x80) {\n            l_packet_len <<= 7;\n        } else {\n            /* store packet length and proceed to next packet */\n            l_packet_len = 0;\n        }\n    }\n\n    if (l_packet_len != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a PPM marker (Packed packet headers, main header)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n */\n\nstatic OPJ_BOOL opj_j2k_read_ppm(\n    opj_j2k_t *p_j2k,\n    OPJ_BYTE * p_header_data,\n    OPJ_UINT32 p_header_size,\n    opj_event_mgr_t * p_manager)\n{\n    opj_cp_t *l_cp = 00;\n    OPJ_UINT32 l_Z_ppm;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    /* We need to have the Z_ppm element + 1 byte of Nppm/Ippm at minimum */\n    if (p_header_size < 2) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PPM marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_cp = &(p_j2k->m_cp);\n    l_cp->ppm = 1;\n\n    opj_read_bytes(p_header_data, &l_Z_ppm, 1);             /* Z_ppm */\n    ++p_header_data;\n    --p_header_size;\n\n    /* check allocation needed */\n    if (l_cp->ppm_markers == NULL) { /* first PPM marker */\n        OPJ_UINT32 l_newCount = l_Z_ppm + 1U; /* can't overflow, l_Z_ppm is UINT8 */\n        assert(l_cp->ppm_markers_count == 0U);\n\n        l_cp->ppm_markers = (opj_ppx *) opj_calloc(l_newCount, sizeof(opj_ppx));\n        if (l_cp->ppm_markers == NULL) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n            return OPJ_FALSE;\n        }\n        l_cp->ppm_markers_count = l_newCount;\n    } else if (l_cp->ppm_markers_count <= l_Z_ppm) {\n        OPJ_UINT32 l_newCount = l_Z_ppm + 1U; /* can't overflow, l_Z_ppm is UINT8 */\n        opj_ppx *new_ppm_markers;\n        new_ppm_markers = (opj_ppx *) opj_realloc(l_cp->ppm_markers,\n                          l_newCount * sizeof(opj_ppx));\n        if (new_ppm_markers == NULL) {\n            /* clean up to be done on l_cp destruction */\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n            return OPJ_FALSE;\n        }\n        l_cp->ppm_markers = new_ppm_markers;\n        memset(l_cp->ppm_markers + l_cp->ppm_markers_count, 0,\n               (l_newCount - l_cp->ppm_markers_count) * sizeof(opj_ppx));\n        l_cp->ppm_markers_count = l_newCount;\n    }\n\n    if (l_cp->ppm_markers[l_Z_ppm].m_data != NULL) {\n        /* clean up to be done on l_cp destruction */\n        opj_event_msg(p_manager, EVT_ERROR, \"Zppm %u already read\\n\", l_Z_ppm);\n        return OPJ_FALSE;\n    }\n\n    l_cp->ppm_markers[l_Z_ppm].m_data = (OPJ_BYTE *) opj_malloc(p_header_size);\n    if (l_cp->ppm_markers[l_Z_ppm].m_data == NULL) {\n        /* clean up to be done on l_cp destruction */\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n        return OPJ_FALSE;\n    }\n    l_cp->ppm_markers[l_Z_ppm].m_data_size = p_header_size;\n    memcpy(l_cp->ppm_markers[l_Z_ppm].m_data, p_header_data, p_header_size);\n\n    return OPJ_TRUE;\n}\n\n/**\n * Merges all PPM markers read (Packed headers, main header)\n *\n * @param       p_cp      main coding parameters.\n * @param       p_manager the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppm(opj_cp_t *p_cp, opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i, l_ppm_data_size, l_N_ppm_remaining;\n\n    /* preconditions */\n    assert(p_cp != 00);\n    assert(p_manager != 00);\n    assert(p_cp->ppm_buffer == NULL);\n\n    if (p_cp->ppm == 0U) {\n        return OPJ_TRUE;\n    }\n\n    l_ppm_data_size = 0U;\n    l_N_ppm_remaining = 0U;\n    for (i = 0U; i < p_cp->ppm_markers_count; ++i) {\n        if (p_cp->ppm_markers[i].m_data !=\n                NULL) { /* standard doesn't seem to require contiguous Zppm */\n            OPJ_UINT32 l_N_ppm;\n            OPJ_UINT32 l_data_size = p_cp->ppm_markers[i].m_data_size;\n            const OPJ_BYTE* l_data = p_cp->ppm_markers[i].m_data;\n\n            if (l_N_ppm_remaining >= l_data_size) {\n                l_N_ppm_remaining -= l_data_size;\n                l_data_size = 0U;\n            } else {\n                l_data += l_N_ppm_remaining;\n                l_data_size -= l_N_ppm_remaining;\n                l_N_ppm_remaining = 0U;\n            }\n\n            if (l_data_size > 0U) {\n                do {\n                    /* read Nppm */\n                    if (l_data_size < 4U) {\n                        /* clean up to be done on l_cp destruction */\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough bytes to read Nppm\\n\");\n                        return OPJ_FALSE;\n                    }\n                    opj_read_bytes(l_data, &l_N_ppm, 4);\n                    l_data += 4;\n                    l_data_size -= 4;\n                    l_ppm_data_size +=\n                        l_N_ppm; /* can't overflow, max 256 markers of max 65536 bytes, that is when PPM markers are not corrupted which is checked elsewhere */\n\n                    if (l_data_size >= l_N_ppm) {\n                        l_data_size -= l_N_ppm;\n                        l_data += l_N_ppm;\n                    } else {\n                        l_N_ppm_remaining = l_N_ppm - l_data_size;\n                        l_data_size = 0U;\n                    }\n                } while (l_data_size > 0U);\n            }\n        }\n    }\n\n    if (l_N_ppm_remaining != 0U) {\n        /* clean up to be done on l_cp destruction */\n        opj_event_msg(p_manager, EVT_ERROR, \"Corrupted PPM markers\\n\");\n        return OPJ_FALSE;\n    }\n\n    p_cp->ppm_buffer = (OPJ_BYTE *) opj_malloc(l_ppm_data_size);\n    if (p_cp->ppm_buffer == 00) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n        return OPJ_FALSE;\n    }\n    p_cp->ppm_len = l_ppm_data_size;\n    l_ppm_data_size = 0U;\n    l_N_ppm_remaining = 0U;\n    for (i = 0U; i < p_cp->ppm_markers_count; ++i) {\n        if (p_cp->ppm_markers[i].m_data !=\n                NULL) { /* standard doesn't seem to require contiguous Zppm */\n            OPJ_UINT32 l_N_ppm;\n            OPJ_UINT32 l_data_size = p_cp->ppm_markers[i].m_data_size;\n            const OPJ_BYTE* l_data = p_cp->ppm_markers[i].m_data;\n\n            if (l_N_ppm_remaining >= l_data_size) {\n                memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_data_size);\n                l_ppm_data_size += l_data_size;\n                l_N_ppm_remaining -= l_data_size;\n                l_data_size = 0U;\n            } else {\n                memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_N_ppm_remaining);\n                l_ppm_data_size += l_N_ppm_remaining;\n                l_data += l_N_ppm_remaining;\n                l_data_size -= l_N_ppm_remaining;\n                l_N_ppm_remaining = 0U;\n            }\n\n            if (l_data_size > 0U) {\n                do {\n                    /* read Nppm */\n                    if (l_data_size < 4U) {\n                        /* clean up to be done on l_cp destruction */\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough bytes to read Nppm\\n\");\n                        return OPJ_FALSE;\n                    }\n                    opj_read_bytes(l_data, &l_N_ppm, 4);\n                    l_data += 4;\n                    l_data_size -= 4;\n\n                    if (l_data_size >= l_N_ppm) {\n                        memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_N_ppm);\n                        l_ppm_data_size += l_N_ppm;\n                        l_data_size -= l_N_ppm;\n                        l_data += l_N_ppm;\n                    } else {\n                        memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_data_size);\n                        l_ppm_data_size += l_data_size;\n                        l_N_ppm_remaining = l_N_ppm - l_data_size;\n                        l_data_size = 0U;\n                    }\n                } while (l_data_size > 0U);\n            }\n            opj_free(p_cp->ppm_markers[i].m_data);\n            p_cp->ppm_markers[i].m_data = NULL;\n            p_cp->ppm_markers[i].m_data_size = 0U;\n        }\n    }\n\n    p_cp->ppm_data = p_cp->ppm_buffer;\n    p_cp->ppm_data_size = p_cp->ppm_len;\n\n    p_cp->ppm_markers_count = 0U;\n    opj_free(p_cp->ppm_markers);\n    p_cp->ppm_markers = NULL;\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a PPT marker (Packed packet headers, tile-part header)\n *\n * @param       p_header_data   the data contained in the PPT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PPT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_Z_ppt;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    /* We need to have the Z_ppt element + 1 byte of Ippt at minimum */\n    if (p_header_size < 2) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PPT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_cp = &(p_j2k->m_cp);\n    if (l_cp->ppm) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_tcp = &(l_cp->tcps[p_j2k->m_current_tile_number]);\n    l_tcp->ppt = 1;\n\n    opj_read_bytes(p_header_data, &l_Z_ppt, 1);             /* Z_ppt */\n    ++p_header_data;\n    --p_header_size;\n\n    /* check allocation needed */\n    if (l_tcp->ppt_markers == NULL) { /* first PPT marker */\n        OPJ_UINT32 l_newCount = l_Z_ppt + 1U; /* can't overflow, l_Z_ppt is UINT8 */\n        assert(l_tcp->ppt_markers_count == 0U);\n\n        l_tcp->ppt_markers = (opj_ppx *) opj_calloc(l_newCount, sizeof(opj_ppx));\n        if (l_tcp->ppt_markers == NULL) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n            return OPJ_FALSE;\n        }\n        l_tcp->ppt_markers_count = l_newCount;\n    } else if (l_tcp->ppt_markers_count <= l_Z_ppt) {\n        OPJ_UINT32 l_newCount = l_Z_ppt + 1U; /* can't overflow, l_Z_ppt is UINT8 */\n        opj_ppx *new_ppt_markers;\n        new_ppt_markers = (opj_ppx *) opj_realloc(l_tcp->ppt_markers,\n                          l_newCount * sizeof(opj_ppx));\n        if (new_ppt_markers == NULL) {\n            /* clean up to be done on l_tcp destruction */\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n            return OPJ_FALSE;\n        }\n        l_tcp->ppt_markers = new_ppt_markers;\n        memset(l_tcp->ppt_markers + l_tcp->ppt_markers_count, 0,\n               (l_newCount - l_tcp->ppt_markers_count) * sizeof(opj_ppx));\n        l_tcp->ppt_markers_count = l_newCount;\n    }\n\n    if (l_tcp->ppt_markers[l_Z_ppt].m_data != NULL) {\n        /* clean up to be done on l_tcp destruction */\n        opj_event_msg(p_manager, EVT_ERROR, \"Zppt %u already read\\n\", l_Z_ppt);\n        return OPJ_FALSE;\n    }\n\n    l_tcp->ppt_markers[l_Z_ppt].m_data = (OPJ_BYTE *) opj_malloc(p_header_size);\n    if (l_tcp->ppt_markers[l_Z_ppt].m_data == NULL) {\n        /* clean up to be done on l_tcp destruction */\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n        return OPJ_FALSE;\n    }\n    l_tcp->ppt_markers[l_Z_ppt].m_data_size = p_header_size;\n    memcpy(l_tcp->ppt_markers[l_Z_ppt].m_data, p_header_data, p_header_size);\n    return OPJ_TRUE;\n}\n\n/**\n * Merges all PPT markers read (Packed packet headers, tile-part header)\n *\n * @param       p_tcp   the tile.\n * @param       p_manager               the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp, opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i, l_ppt_data_size;\n    /* preconditions */\n    assert(p_tcp != 00);\n    assert(p_manager != 00);\n    assert(p_tcp->ppt_buffer == NULL);\n\n    if (p_tcp->ppt == 0U) {\n        return OPJ_TRUE;\n    }\n\n    l_ppt_data_size = 0U;\n    for (i = 0U; i < p_tcp->ppt_markers_count; ++i) {\n        l_ppt_data_size +=\n            p_tcp->ppt_markers[i].m_data_size; /* can't overflow, max 256 markers of max 65536 bytes */\n    }\n\n    p_tcp->ppt_buffer = (OPJ_BYTE *) opj_malloc(l_ppt_data_size);\n    if (p_tcp->ppt_buffer == 00) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n        return OPJ_FALSE;\n    }\n    p_tcp->ppt_len = l_ppt_data_size;\n    l_ppt_data_size = 0U;\n    for (i = 0U; i < p_tcp->ppt_markers_count; ++i) {\n        if (p_tcp->ppt_markers[i].m_data !=\n                NULL) { /* standard doesn't seem to require contiguous Zppt */\n            memcpy(p_tcp->ppt_buffer + l_ppt_data_size, p_tcp->ppt_markers[i].m_data,\n                   p_tcp->ppt_markers[i].m_data_size);\n            l_ppt_data_size +=\n                p_tcp->ppt_markers[i].m_data_size; /* can't overflow, max 256 markers of max 65536 bytes */\n\n            opj_free(p_tcp->ppt_markers[i].m_data);\n            p_tcp->ppt_markers[i].m_data = NULL;\n            p_tcp->ppt_markers[i].m_data_size = 0U;\n        }\n    }\n\n    p_tcp->ppt_markers_count = 0U;\n    opj_free(p_tcp->ppt_markers);\n    p_tcp->ppt_markers = NULL;\n\n    p_tcp->ppt_data = p_tcp->ppt_buffer;\n    p_tcp->ppt_data_size = p_tcp->ppt_len;\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_tlm_size;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_tlm_size = 6 + (5 * p_j2k->m_specific_param.m_encoder.m_total_tile_parts);\n\n    if (l_tlm_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_tlm_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write TLM marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_tlm_size;\n    }\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    /* change the way data is written to avoid seeking if possible */\n    /* TODO */\n    p_j2k->m_specific_param.m_encoder.m_tlm_start = opj_stream_tell(p_stream);\n\n    opj_write_bytes(l_current_data, J2K_MS_TLM,\n                    2);                                   /* TLM */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_tlm_size - 2,\n                    2);                                 /* Lpoc */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, 0,\n                    1);                                                    /* Ztlm=0*/\n    ++l_current_data;\n\n    opj_write_bytes(l_current_data, 0x50,\n                    1);                                                 /* Stlm ST=1(8bits-255 tiles max),SP=1(Ptlm=32bits) */\n    ++l_current_data;\n\n    /* do nothing on the 5 * l_j2k->m_specific_param.m_encoder.m_total_tile_parts remaining data */\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_tlm_size,\n                              p_manager) != l_tlm_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n\n    opj_write_bytes(p_data, J2K_MS_SOT,\n                    2);                                 /* SOT */\n    p_data += 2;\n\n    opj_write_bytes(p_data, 10,\n                    2);                                                   /* Lsot */\n    p_data += 2;\n\n    opj_write_bytes(p_data, p_j2k->m_current_tile_number,\n                    2);                        /* Isot */\n    p_data += 2;\n\n    /* Psot  */\n    p_data += 4;\n\n    opj_write_bytes(p_data,\n                    p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,\n                    1);                        /* TPsot */\n    ++p_data;\n\n    opj_write_bytes(p_data,\n                    p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,\n                    1);                      /* TNsot */\n    ++p_data;\n\n    /* UniPG>> */\n#ifdef USE_JPWL\n    /* update markers struct */\n    /*\n            OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOT, p_j2k->sot_start, len + 2);\n    */\n    assert(0 && \"TODO\");\n#endif /* USE_JPWL */\n\n    * p_data_written = 12;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *  p_header_data,\n                                       OPJ_UINT32  p_header_size,\n                                       OPJ_UINT32* p_tile_no,\n                                       OPJ_UINT32* p_tot_len,\n                                       OPJ_UINT32* p_current_part,\n                                       OPJ_UINT32* p_num_parts,\n                                       opj_event_mgr_t * p_manager)\n{\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_manager != 00);\n\n    /* Size of this marker is fixed = 12 (we have already read marker and its size)*/\n    if (p_header_size != 8) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading SOT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, p_tile_no, 2);    /* Isot */\n    p_header_data += 2;\n    opj_read_bytes(p_header_data, p_tot_len, 4);    /* Psot */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, p_current_part, 1); /* TPsot */\n    ++p_header_data;\n    opj_read_bytes(p_header_data, p_num_parts, 1);  /* TNsot */\n    ++p_header_data;\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager)\n{\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_tot_len, l_num_parts = 0;\n    OPJ_UINT32 l_current_part;\n    OPJ_UINT32 l_tile_x, l_tile_y;\n\n    /* preconditions */\n\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_j2k_get_sot_values(p_header_data, p_header_size,\n                                 &(p_j2k->m_current_tile_number), &l_tot_len, &l_current_part, &l_num_parts,\n                                 p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading SOT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_cp = &(p_j2k->m_cp);\n\n    /* testcase 2.pdf.SIGFPE.706.1112 */\n    if (p_j2k->m_current_tile_number >= l_cp->tw * l_cp->th) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Invalid tile number %d\\n\",\n                      p_j2k->m_current_tile_number);\n        return OPJ_FALSE;\n    }\n\n    l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n    l_tile_x = p_j2k->m_current_tile_number % l_cp->tw;\n    l_tile_y = p_j2k->m_current_tile_number / l_cp->tw;\n\n    /* Fixes issue with id_000020,sig_06,src_001958,op_flip4,pos_149 */\n    /* of https://github.com/uclouvain/openjpeg/issues/939 */\n    /* We must avoid reading twice the same tile part number for a given tile */\n    /* so as to avoid various issues, like opj_j2k_merge_ppt being called */\n    /* several times. */\n    /* ISO 15444-1 A.4.2 Start of tile-part (SOT) mandates that tile parts */\n    /* should appear in increasing order. */\n    if (l_tcp->m_current_tile_part_number + 1 != (OPJ_INT32)l_current_part) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Invalid tile part index for tile number %d. \"\n                      \"Got %d, expected %d\\n\",\n                      p_j2k->m_current_tile_number,\n                      l_current_part,\n                      l_tcp->m_current_tile_part_number + 1);\n        return OPJ_FALSE;\n    }\n    ++ l_tcp->m_current_tile_part_number;\n\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n\n        OPJ_UINT32 tileno = p_j2k->m_current_tile_number;\n        static OPJ_UINT32 backup_tileno = 0;\n\n        /* tileno is negative or larger than the number of tiles!!! */\n        if (tileno > (l_cp->tw * l_cp->th)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"JPWL: bad tile number (%d out of a maximum of %d)\\n\",\n                          tileno, (l_cp->tw * l_cp->th));\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n            /* we try to correct */\n            tileno = backup_tileno;\n            opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\"\n                          \"- setting tile number to %d\\n\",\n                          tileno);\n        }\n\n        /* keep your private count of tiles */\n        backup_tileno++;\n    };\n#endif /* USE_JPWL */\n\n    /* look for the tile in the list of already processed tile (in parts). */\n    /* Optimization possible here with a more complex data structure and with the removing of tiles */\n    /* since the time taken by this function can only grow at the time */\n\n    /* PSot should be equal to zero or >=14 or <= 2^32-1 */\n    if ((l_tot_len != 0) && (l_tot_len < 14)) {\n        if (l_tot_len ==\n                12) { /* MSD: Special case for the PHR data which are read by kakadu*/\n            opj_event_msg(p_manager, EVT_WARNING, \"Empty SOT marker detected: Psot=%d.\\n\",\n                          l_tot_len);\n        } else {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Psot value is not correct regards to the JPEG2000 norm: %d.\\n\", l_tot_len);\n            return OPJ_FALSE;\n        }\n    }\n\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n\n        /* totlen is negative or larger than the bytes left!!! */\n        if (/*(l_tot_len < 0) ||*/ (l_tot_len >\n                                    p_header_size)) {   /* FIXME it seems correct; for info in V1 -> (p_stream_numbytesleft(p_stream) + 8))) { */\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"JPWL: bad tile byte size (%d bytes against %d bytes left)\\n\",\n                          l_tot_len,\n                          p_header_size);  /* FIXME it seems correct; for info in V1 -> p_stream_numbytesleft(p_stream) + 8); */\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n            /* we try to correct */\n            l_tot_len = 0;\n            opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\"\n                          \"- setting Psot to %d => assuming it is the last tile\\n\",\n                          l_tot_len);\n        }\n    };\n#endif /* USE_JPWL */\n\n    /* Ref A.4.2: Psot could be equal zero if it is the last tile-part of the codestream.*/\n    if (!l_tot_len) {\n        opj_event_msg(p_manager, EVT_INFO,\n                      \"Psot value of the current tile-part is equal to zero, \"\n                      \"we assuming it is the last tile-part of the codestream.\\n\");\n        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n    }\n\n    if (l_tcp->m_nb_tile_parts != 0 && l_current_part >= l_tcp->m_nb_tile_parts) {\n        /* Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=2851 */\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"In SOT marker, TPSot (%d) is not valid regards to the previous \"\n                      \"number of tile-part (%d), giving up\\n\", l_current_part,\n                      l_tcp->m_nb_tile_parts);\n        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n        return OPJ_FALSE;\n    }\n\n    if (l_num_parts !=\n            0) { /* Number of tile-part header is provided by this tile-part header */\n        l_num_parts += p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction;\n        /* Useful to manage the case of textGBR.jp2 file because two values of TNSot are allowed: the correct numbers of\n         * tile-parts for that tile and zero (A.4.2 of 15444-1 : 2002). */\n        if (l_tcp->m_nb_tile_parts) {\n            if (l_current_part >= l_tcp->m_nb_tile_parts) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"In SOT marker, TPSot (%d) is not valid regards to the current \"\n                              \"number of tile-part (%d), giving up\\n\", l_current_part,\n                              l_tcp->m_nb_tile_parts);\n                p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n                return OPJ_FALSE;\n            }\n        }\n        if (l_current_part >= l_num_parts) {\n            /* testcase 451.pdf.SIGSEGV.ce9.3723 */\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"In SOT marker, TPSot (%d) is not valid regards to the current \"\n                          \"number of tile-part (header) (%d), giving up\\n\", l_current_part, l_num_parts);\n            p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n            return OPJ_FALSE;\n        }\n        l_tcp->m_nb_tile_parts = l_num_parts;\n    }\n\n    /* If know the number of tile part header we will check if we didn't read the last*/\n    if (l_tcp->m_nb_tile_parts) {\n        if (l_tcp->m_nb_tile_parts == (l_current_part + 1)) {\n            p_j2k->m_specific_param.m_decoder.m_can_decode =\n                1; /* Process the last tile-part header*/\n        }\n    }\n\n    if (!p_j2k->m_specific_param.m_decoder.m_last_tile_part) {\n        /* Keep the size of data to skip after this marker */\n        p_j2k->m_specific_param.m_decoder.m_sot_length = l_tot_len -\n                12; /* SOT_marker_size = 12 */\n    } else {\n        /* FIXME: need to be computed from the number of bytes remaining in the codestream */\n        p_j2k->m_specific_param.m_decoder.m_sot_length = 0;\n    }\n\n    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPH;\n\n    /* Check if the current tile is outside the area we want decode or not corresponding to the tile index*/\n    if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec == -1) {\n        p_j2k->m_specific_param.m_decoder.m_skip_data =\n            (l_tile_x < p_j2k->m_specific_param.m_decoder.m_start_tile_x)\n            || (l_tile_x >= p_j2k->m_specific_param.m_decoder.m_end_tile_x)\n            || (l_tile_y < p_j2k->m_specific_param.m_decoder.m_start_tile_y)\n            || (l_tile_y >= p_j2k->m_specific_param.m_decoder.m_end_tile_y);\n    } else {\n        assert(p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec >= 0);\n        p_j2k->m_specific_param.m_decoder.m_skip_data =\n            (p_j2k->m_current_tile_number != (OPJ_UINT32)\n             p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec);\n    }\n\n    /* Index */\n    if (p_j2k->cstr_index) {\n        assert(p_j2k->cstr_index->tile_index != 00);\n        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tileno =\n            p_j2k->m_current_tile_number;\n        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_tpsno =\n            l_current_part;\n\n        if (l_num_parts != 0) {\n            p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].nb_tps =\n                l_num_parts;\n            p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps =\n                l_num_parts;\n\n            if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =\n                    (opj_tp_index_t*)opj_calloc(l_num_parts, sizeof(opj_tp_index_t));\n                if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                    return OPJ_FALSE;\n                }\n            } else {\n                opj_tp_index_t *new_tp_index = (opj_tp_index_t *) opj_realloc(\n                                                   p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index,\n                                                   l_num_parts * sizeof(opj_tp_index_t));\n                if (! new_tp_index) {\n                    opj_free(p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index);\n                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = NULL;\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                    return OPJ_FALSE;\n                }\n                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =\n                    new_tp_index;\n            }\n        } else {\n            /*if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index)*/ {\n\n                if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 10;\n                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =\n                        (opj_tp_index_t*)opj_calloc(\n                            p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps,\n                            sizeof(opj_tp_index_t));\n                    if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 0;\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                      \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                        return OPJ_FALSE;\n                    }\n                }\n\n                if (l_current_part >=\n                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps) {\n                    opj_tp_index_t *new_tp_index;\n                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps =\n                        l_current_part + 1;\n                    new_tp_index = (opj_tp_index_t *) opj_realloc(\n                                       p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index,\n                                       p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps *\n                                       sizeof(opj_tp_index_t));\n                    if (! new_tp_index) {\n                        opj_free(p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index);\n                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = NULL;\n                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 0;\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                      \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                        return OPJ_FALSE;\n                    }\n                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =\n                        new_tp_index;\n                }\n            }\n\n        }\n\n    }\n\n    /* FIXME move this onto a separate method to call before reading any SOT, remove part about main_end header, use a index struct inside p_j2k */\n    /* if (p_j2k->cstr_info) {\n       if (l_tcp->first) {\n       if (tileno == 0) {\n       p_j2k->cstr_info->main_head_end = p_stream_tell(p_stream) - 13;\n       }\n\n       p_j2k->cstr_info->tile[tileno].tileno = tileno;\n       p_j2k->cstr_info->tile[tileno].start_pos = p_stream_tell(p_stream) - 12;\n       p_j2k->cstr_info->tile[tileno].end_pos = p_j2k->cstr_info->tile[tileno].start_pos + totlen - 1;\n       p_j2k->cstr_info->tile[tileno].num_tps = numparts;\n\n       if (numparts) {\n       p_j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(numparts * sizeof(opj_tp_info_t));\n       }\n       else {\n       p_j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(10 * sizeof(opj_tp_info_t)); // Fixme (10)\n       }\n       }\n       else {\n       p_j2k->cstr_info->tile[tileno].end_pos += totlen;\n       }\n\n       p_j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos = p_stream_tell(p_stream) - 12;\n       p_j2k->cstr_info->tile[tileno].tp[partno].tp_end_pos =\n       p_j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos + totlen - 1;\n       }*/\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,\n                                  opj_tcd_t * p_tile_coder,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  OPJ_UINT32 p_total_data_size,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    opj_codestream_info_t *l_cstr_info = 00;\n    OPJ_UINT32 l_remaining_data;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_stream);\n\n    opj_write_bytes(p_data, J2K_MS_SOD,\n                    2);                                 /* SOD */\n    p_data += 2;\n\n    /* make room for the EOF marker */\n    l_remaining_data =  p_total_data_size - 4;\n\n    /* update tile coder */\n    p_tile_coder->tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;\n    p_tile_coder->cur_tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n\n    /* INDEX >> */\n    /* TODO mergeV2: check this part which use cstr_info */\n    /*l_cstr_info = p_j2k->cstr_info;\n    if (l_cstr_info) {\n            if (!p_j2k->m_specific_param.m_encoder.m_current_tile_part_number ) {\n                    //TODO cstr_info->tile[p_j2k->m_current_tile_number].end_header = p_stream_tell(p_stream) + p_j2k->pos_correction - 1;\n                    l_cstr_info->tile[p_j2k->m_current_tile_number].tileno = p_j2k->m_current_tile_number;\n            }\n            else {*/\n    /*\n    TODO\n    if\n            (cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno - 1].end_pos < p_stream_tell(p_stream))\n    {\n            cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno].start_pos = p_stream_tell(p_stream);\n    }*/\n    /*}*/\n    /* UniPG>> */\n#ifdef USE_JPWL\n    /* update markers struct */\n    /*OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOD, p_j2k->sod_start, 2);\n    */\n    assert(0 && \"TODO\");\n#endif /* USE_JPWL */\n    /* <<UniPG */\n    /*}*/\n    /* << INDEX */\n\n    if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {\n        p_tile_coder->tcd_image->tiles->packno = 0;\n        if (l_cstr_info) {\n            l_cstr_info->packno = 0;\n        }\n    }\n\n    *p_data_written = 0;\n\n    if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,\n                              p_data_written, l_remaining_data, l_cstr_info,\n                              p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot encode tile\\n\");\n        return OPJ_FALSE;\n    }\n\n    *p_data_written += 2;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_SIZE_T l_current_read_size;\n    opj_codestream_index_t * l_cstr_index = 00;\n    OPJ_BYTE ** l_current_data = 00;\n    opj_tcp_t * l_tcp = 00;\n    OPJ_UINT32 * l_tile_len = 00;\n    OPJ_BOOL l_sot_length_pb_detected = OPJ_FALSE;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n\n    if (p_j2k->m_specific_param.m_decoder.m_last_tile_part) {\n        /* opj_stream_get_number_byte_left returns OPJ_OFF_T\n        // but we are in the last tile part,\n        // so its result will fit on OPJ_UINT32 unless we find\n        // a file with a single tile part of more than 4 GB...*/\n        p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32)(\n                    opj_stream_get_number_byte_left(p_stream) - 2);\n    } else {\n        /* Check to avoid pass the limit of OPJ_UINT32 */\n        if (p_j2k->m_specific_param.m_decoder.m_sot_length >= 2) {\n            p_j2k->m_specific_param.m_decoder.m_sot_length -= 2;\n        } else {\n            /* MSD: case commented to support empty SOT marker (PHR data) */\n        }\n    }\n\n    l_current_data = &(l_tcp->m_data);\n    l_tile_len = &l_tcp->m_data_size;\n\n    /* Patch to support new PHR data */\n    if (p_j2k->m_specific_param.m_decoder.m_sot_length) {\n        /* If we are here, we'll try to read the data after allocation */\n        /* Check enough bytes left in stream before allocation */\n        if ((OPJ_OFF_T)p_j2k->m_specific_param.m_decoder.m_sot_length >\n                opj_stream_get_number_byte_left(p_stream)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Tile part length size inconsistent with stream length\\n\");\n            return OPJ_FALSE;\n        }\n        if (p_j2k->m_specific_param.m_decoder.m_sot_length >\n                UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"p_j2k->m_specific_param.m_decoder.m_sot_length > \"\n                          \"UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA\");\n            return OPJ_FALSE;\n        }\n        /* Add a margin of OPJ_COMMON_CBLK_DATA_EXTRA to the allocation we */\n        /* do so that opj_mqc_init_dec_common() can safely add a synthetic */\n        /* 0xFFFF marker. */\n        if (! *l_current_data) {\n            /* LH: oddly enough, in this path, l_tile_len!=0.\n             * TODO: If this was consistent, we could simplify the code to only use realloc(), as realloc(0,...) default to malloc(0,...).\n             */\n            *l_current_data = (OPJ_BYTE*) opj_malloc(\n                                  p_j2k->m_specific_param.m_decoder.m_sot_length + OPJ_COMMON_CBLK_DATA_EXTRA);\n        } else {\n            OPJ_BYTE *l_new_current_data;\n            if (*l_tile_len > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA -\n                    p_j2k->m_specific_param.m_decoder.m_sot_length) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"*l_tile_len > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA - \"\n                              \"p_j2k->m_specific_param.m_decoder.m_sot_length\");\n                return OPJ_FALSE;\n            }\n\n            l_new_current_data = (OPJ_BYTE *) opj_realloc(*l_current_data,\n                                 *l_tile_len + p_j2k->m_specific_param.m_decoder.m_sot_length +\n                                 OPJ_COMMON_CBLK_DATA_EXTRA);\n            if (! l_new_current_data) {\n                opj_free(*l_current_data);\n                /*nothing more is done as l_current_data will be set to null, and just\n                  afterward we enter in the error path\n                  and the actual tile_len is updated (committed) at the end of the\n                  function. */\n            }\n            *l_current_data = l_new_current_data;\n        }\n\n        if (*l_current_data == 00) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tile\\n\");\n            return OPJ_FALSE;\n        }\n    } else {\n        l_sot_length_pb_detected = OPJ_TRUE;\n    }\n\n    /* Index */\n    l_cstr_index = p_j2k->cstr_index;\n    if (l_cstr_index) {\n        OPJ_OFF_T l_current_pos = opj_stream_tell(p_stream) - 2;\n\n        OPJ_UINT32 l_current_tile_part =\n            l_cstr_index->tile_index[p_j2k->m_current_tile_number].current_tpsno;\n        l_cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index[l_current_tile_part].end_header\n            =\n                l_current_pos;\n        l_cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index[l_current_tile_part].end_pos\n            =\n                l_current_pos + p_j2k->m_specific_param.m_decoder.m_sot_length + 2;\n\n        if (OPJ_FALSE == opj_j2k_add_tlmarker(p_j2k->m_current_tile_number,\n                                              l_cstr_index,\n                                              J2K_MS_SOD,\n                                              l_current_pos,\n                                              p_j2k->m_specific_param.m_decoder.m_sot_length + 2)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add tl marker\\n\");\n            return OPJ_FALSE;\n        }\n\n        /*l_cstr_index->packno = 0;*/\n    }\n\n    /* Patch to support new PHR data */\n    if (!l_sot_length_pb_detected) {\n        l_current_read_size = opj_stream_read_data(\n                                  p_stream,\n                                  *l_current_data + *l_tile_len,\n                                  p_j2k->m_specific_param.m_decoder.m_sot_length,\n                                  p_manager);\n    } else {\n        l_current_read_size = 0;\n    }\n\n    if (l_current_read_size != p_j2k->m_specific_param.m_decoder.m_sot_length) {\n        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n    } else {\n        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n    }\n\n    *l_tile_len += (OPJ_UINT32)l_current_read_size;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k,\n                                  OPJ_UINT32 p_tile_no,\n                                  OPJ_UINT32 p_comp_no,\n                                  OPJ_UINT32 nb_comps,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_rgn_size;\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n    OPJ_UINT32 l_comp_room;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp = &l_tcp->tccps[p_comp_no];\n\n    if (nb_comps <= 256) {\n        l_comp_room = 1;\n    } else {\n        l_comp_room = 2;\n    }\n\n    l_rgn_size = 6 + l_comp_room;\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_RGN,\n                    2);                                   /* RGN  */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_rgn_size - 2,\n                    2);                                 /* Lrgn */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, p_comp_no,\n                    l_comp_room);                          /* Crgn */\n    l_current_data += l_comp_room;\n\n    opj_write_bytes(l_current_data, 0,\n                    1);                                           /* Srgn */\n    ++l_current_data;\n\n    opj_write_bytes(l_current_data, (OPJ_UINT32)l_tccp->roishift,\n                    1);                            /* SPrgn */\n    ++l_current_data;\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_rgn_size,\n                              p_manager) != l_rgn_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_header_tile_data,\n                    J2K_MS_EOC, 2);                                    /* EOC */\n\n    /* UniPG>> */\n#ifdef USE_JPWL\n    /* update markers struct */\n    /*\n    OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_EOC, p_stream_tell(p_stream) - 2, 2);\n    */\n#endif /* USE_JPWL */\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, 2, p_manager) != 2) {\n        return OPJ_FALSE;\n    }\n\n    if (! opj_stream_flush(p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a RGN marker (Region Of Interest)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_nb_comp;\n    opj_image_t * l_image = 00;\n\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_comp_room, l_comp_no, l_roi_sty;\n\n    /* preconditions*/\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_image = p_j2k->m_private_image;\n    l_nb_comp = l_image->numcomps;\n\n    if (l_nb_comp <= 256) {\n        l_comp_room = 1;\n    } else {\n        l_comp_room = 2;\n    }\n\n    if (p_header_size != 2 + l_comp_room) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading RGN marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    opj_read_bytes(p_header_data, &l_comp_no, l_comp_room);         /* Crgn */\n    p_header_data += l_comp_room;\n    opj_read_bytes(p_header_data, &l_roi_sty,\n                   1);                                     /* Srgn */\n    ++p_header_data;\n\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n        /* totlen is negative or larger than the bytes left!!! */\n        if (l_comp_room >= l_nb_comp) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"JPWL: bad component number in RGN (%d when there are only %d)\\n\",\n                          l_comp_room, l_nb_comp);\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n        }\n    };\n#endif /* USE_JPWL */\n\n    /* testcase 3635.pdf.asan.77.2930 */\n    if (l_comp_no >= l_nb_comp) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"bad component number in RGN (%d when there are only %d)\\n\",\n                      l_comp_no, l_nb_comp);\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data,\n                   (OPJ_UINT32 *)(&(l_tcp->tccps[l_comp_no].roishift)), 1);  /* SPrgn */\n    ++p_header_data;\n\n    return OPJ_TRUE;\n\n}\n\nstatic OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t * p_tcp)\n{\n    return (OPJ_FLOAT32)((p_tcp->m_nb_tile_parts - 1) * 14);\n}\n\nstatic OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t * p_tcp)\n{\n    (void)p_tcp;\n    return 0;\n}\n\nstatic OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k,\n                                     opj_stream_private_t *p_stream,\n                                     opj_event_mgr_t * p_manager)\n{\n    opj_cp_t * l_cp = 00;\n    opj_image_t * l_image = 00;\n    opj_tcp_t * l_tcp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n\n    OPJ_UINT32 i, j, k;\n    OPJ_INT32 l_x0, l_y0, l_x1, l_y1;\n    OPJ_FLOAT32 * l_rates = 0;\n    OPJ_FLOAT32 l_sot_remove;\n    OPJ_UINT32 l_bits_empty, l_size_pixel;\n    OPJ_UINT32 l_tile_size = 0;\n    OPJ_UINT32 l_last_res;\n    OPJ_FLOAT32(* l_tp_stride_func)(opj_tcp_t *) = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_manager);\n\n    l_cp = &(p_j2k->m_cp);\n    l_image = p_j2k->m_private_image;\n    l_tcp = l_cp->tcps;\n\n    l_bits_empty = 8 * l_image->comps->dx * l_image->comps->dy;\n    l_size_pixel = l_image->numcomps * l_image->comps->prec;\n    l_sot_remove = (OPJ_FLOAT32) opj_stream_tell(p_stream) / (OPJ_FLOAT32)(\n                       l_cp->th * l_cp->tw);\n\n    if (l_cp->m_specific_param.m_enc.m_tp_on) {\n        l_tp_stride_func = opj_j2k_get_tp_stride;\n    } else {\n        l_tp_stride_func = opj_j2k_get_default_stride;\n    }\n\n    for (i = 0; i < l_cp->th; ++i) {\n        for (j = 0; j < l_cp->tw; ++j) {\n            OPJ_FLOAT32 l_offset = (OPJ_FLOAT32)(*l_tp_stride_func)(l_tcp) /\n                                   (OPJ_FLOAT32)l_tcp->numlayers;\n\n            /* 4 borders of the tile rescale on the image if necessary */\n            l_x0 = opj_int_max((OPJ_INT32)(l_cp->tx0 + j * l_cp->tdx),\n                               (OPJ_INT32)l_image->x0);\n            l_y0 = opj_int_max((OPJ_INT32)(l_cp->ty0 + i * l_cp->tdy),\n                               (OPJ_INT32)l_image->y0);\n            l_x1 = opj_int_min((OPJ_INT32)(l_cp->tx0 + (j + 1) * l_cp->tdx),\n                               (OPJ_INT32)l_image->x1);\n            l_y1 = opj_int_min((OPJ_INT32)(l_cp->ty0 + (i + 1) * l_cp->tdy),\n                               (OPJ_INT32)l_image->y1);\n\n            l_rates = l_tcp->rates;\n\n            /* Modification of the RATE >> */\n            if (*l_rates > 0.0f) {\n                *l_rates = (((OPJ_FLOAT32)(l_size_pixel * (OPJ_UINT32)(l_x1 - l_x0) *\n                                           (OPJ_UINT32)(l_y1 - l_y0)))\n                            /\n                            ((*l_rates) * (OPJ_FLOAT32)l_bits_empty)\n                           )\n                           -\n                           l_offset;\n            }\n\n            ++l_rates;\n\n            for (k = 1; k < l_tcp->numlayers; ++k) {\n                if (*l_rates > 0.0f) {\n                    *l_rates = (((OPJ_FLOAT32)(l_size_pixel * (OPJ_UINT32)(l_x1 - l_x0) *\n                                               (OPJ_UINT32)(l_y1 - l_y0)))\n                                /\n                                ((*l_rates) * (OPJ_FLOAT32)l_bits_empty)\n                               )\n                               -\n                               l_offset;\n                }\n\n                ++l_rates;\n            }\n\n            ++l_tcp;\n\n        }\n    }\n\n    l_tcp = l_cp->tcps;\n\n    for (i = 0; i < l_cp->th; ++i) {\n        for (j = 0; j < l_cp->tw; ++j) {\n            l_rates = l_tcp->rates;\n\n            if (*l_rates > 0.0f) {\n                *l_rates -= l_sot_remove;\n\n                if (*l_rates < 30.0f) {\n                    *l_rates = 30.0f;\n                }\n            }\n\n            ++l_rates;\n\n            l_last_res = l_tcp->numlayers - 1;\n\n            for (k = 1; k < l_last_res; ++k) {\n\n                if (*l_rates > 0.0f) {\n                    *l_rates -= l_sot_remove;\n\n                    if (*l_rates < * (l_rates - 1) + 10.0f) {\n                        *l_rates  = (*(l_rates - 1)) + 20.0f;\n                    }\n                }\n\n                ++l_rates;\n            }\n\n            if (*l_rates > 0.0f) {\n                *l_rates -= (l_sot_remove + 2.f);\n\n                if (*l_rates < * (l_rates - 1) + 10.0f) {\n                    *l_rates  = (*(l_rates - 1)) + 20.0f;\n                }\n            }\n\n            ++l_tcp;\n        }\n    }\n\n    l_img_comp = l_image->comps;\n    l_tile_size = 0;\n\n    for (i = 0; i < l_image->numcomps; ++i) {\n        l_tile_size += (opj_uint_ceildiv(l_cp->tdx, l_img_comp->dx)\n                        *\n                        opj_uint_ceildiv(l_cp->tdy, l_img_comp->dy)\n                        *\n                        l_img_comp->prec\n                       );\n\n        ++l_img_comp;\n    }\n\n    l_tile_size = (OPJ_UINT32)(l_tile_size * 0.1625);  /* 1.3/8 = 0.1625 */\n\n    l_tile_size += opj_j2k_get_specific_header_sizes(p_j2k);\n\n    p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = l_tile_size;\n    p_j2k->m_specific_param.m_encoder.m_encoded_tile_data =\n        (OPJ_BYTE *) opj_malloc(p_j2k->m_specific_param.m_encoder.m_encoded_tile_size);\n    if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data == 00) {\n        return OPJ_FALSE;\n    }\n\n    if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer =\n            (OPJ_BYTE *) opj_malloc(5 *\n                                    p_j2k->m_specific_param.m_encoder.m_total_tile_parts);\n        if (! p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {\n            return OPJ_FALSE;\n        }\n\n        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current =\n            p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer;\n    }\n\n    return OPJ_TRUE;\n}\n\n#if 0\nstatic OPJ_BOOL opj_j2k_read_eoc(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i;\n    opj_tcd_t * l_tcd = 00;\n    OPJ_UINT32 l_nb_tiles;\n    opj_tcp_t * l_tcp = 00;\n    OPJ_BOOL l_success;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n    l_tcp = p_j2k->m_cp.tcps;\n\n    l_tcd = opj_tcd_create(OPJ_TRUE);\n    if (l_tcd == 00) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n        return OPJ_FALSE;\n    }\n\n    for (i = 0; i < l_nb_tiles; ++i) {\n        if (l_tcp->m_data) {\n            if (! opj_tcd_init_decode_tile(l_tcd, i)) {\n                opj_tcd_destroy(l_tcd);\n                opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n                return OPJ_FALSE;\n            }\n\n            l_success = opj_tcd_decode_tile(l_tcd, l_tcp->m_data, l_tcp->m_data_size, i,\n                                            p_j2k->cstr_index);\n            /* cleanup */\n\n            if (! l_success) {\n                p_j2k->m_specific_param.m_decoder.m_state |= J2K_STATE_ERR;\n                break;\n            }\n        }\n\n        opj_j2k_tcp_destroy(l_tcp);\n        ++l_tcp;\n    }\n\n    opj_tcd_destroy(l_tcd);\n    return OPJ_TRUE;\n}\n#endif\n\nstatic OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k,\n                                       struct opj_stream_private *p_stream,\n                                       struct opj_event_mgr * p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_manager);\n\n    p_j2k->cstr_index->main_head_end = opj_stream_tell(p_stream);\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k,\n        struct opj_stream_private *p_stream,\n        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 i;\n    opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n    opj_mct_data_t * l_mct_record;\n    opj_tcp_t * l_tcp;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    if (! opj_j2k_write_cbd(p_j2k, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n    l_mct_record = l_tcp->m_mct_records;\n\n    for (i = 0; i < l_tcp->m_nb_mct_records; ++i) {\n\n        if (! opj_j2k_write_mct_record(p_j2k, l_mct_record, p_stream, p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        ++l_mct_record;\n    }\n\n    l_mcc_record = l_tcp->m_mcc_records;\n\n    for (i = 0; i < l_tcp->m_nb_mcc_records; ++i) {\n\n        if (! opj_j2k_write_mcc_record(p_j2k, l_mcc_record, p_stream, p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        ++l_mcc_record;\n    }\n\n    if (! opj_j2k_write_mco(p_j2k, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_all_coc(\n    opj_j2k_t *p_j2k,\n    struct opj_stream_private *p_stream,\n    struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 compno;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    for (compno = 1; compno < p_j2k->m_private_image->numcomps; ++compno) {\n        /* cod is first component of first tile */\n        if (! opj_j2k_compare_coc(p_j2k, 0, compno)) {\n            if (! opj_j2k_write_coc(p_j2k, compno, p_stream, p_manager)) {\n                return OPJ_FALSE;\n            }\n        }\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_all_qcc(\n    opj_j2k_t *p_j2k,\n    struct opj_stream_private *p_stream,\n    struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 compno;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    for (compno = 1; compno < p_j2k->m_private_image->numcomps; ++compno) {\n        /* qcd is first component of first tile */\n        if (! opj_j2k_compare_qcc(p_j2k, 0, compno)) {\n            if (! opj_j2k_write_qcc(p_j2k, compno, p_stream, p_manager)) {\n                return OPJ_FALSE;\n            }\n        }\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k,\n                                      struct opj_stream_private *p_stream,\n                                      struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 compno;\n    const opj_tccp_t *l_tccp = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_tccp = p_j2k->m_cp.tcps->tccps;\n\n    for (compno = 0; compno < p_j2k->m_private_image->numcomps; ++compno)  {\n        if (l_tccp->roishift) {\n\n            if (! opj_j2k_write_rgn(p_j2k, 0, compno, p_j2k->m_private_image->numcomps,\n                                    p_stream, p_manager)) {\n                return OPJ_FALSE;\n            }\n        }\n\n        ++l_tccp;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k,\n                                  struct opj_stream_private *p_stream,\n                                  struct opj_event_mgr * p_manager)\n{\n    opj_codestream_index_t * l_cstr_index = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_manager);\n\n    l_cstr_index = p_j2k->cstr_index;\n    if (l_cstr_index) {\n        l_cstr_index->codestream_size = (OPJ_UINT64)opj_stream_tell(p_stream);\n        /* UniPG>> */\n        /* The following adjustment is done to adjust the codestream size */\n        /* if SOD is not at 0 in the buffer. Useful in case of JP2, where */\n        /* the first bunch of bytes is not in the codestream              */\n        l_cstr_index->codestream_size -= (OPJ_UINT64)l_cstr_index->main_head_start;\n        /* <<UniPG */\n    }\n\n#ifdef USE_JPWL\n    /* preparation of JPWL marker segments */\n#if 0\n    if (cp->epc_on) {\n\n        /* encode according to JPWL */\n        jpwl_encode(p_j2k, p_stream, image);\n\n    }\n#endif\n    assert(0 && \"TODO\");\n#endif /* USE_JPWL */\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 OPJ_UINT32 *output_marker,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_unknown_marker;\n    const opj_dec_memory_marker_handler_t * l_marker_handler;\n    OPJ_UINT32 l_size_unk = 2;\n\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    opj_event_msg(p_manager, EVT_WARNING, \"Unknown marker\\n\");\n\n    for (;;) {\n        /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer*/\n        if (opj_stream_read_data(p_stream,\n                                 p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* read 2 bytes as the new marker ID*/\n        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                       &l_unknown_marker, 2);\n\n        if (!(l_unknown_marker < 0xff00)) {\n\n            /* Get the marker handler from the marker ID*/\n            l_marker_handler = opj_j2k_get_marker_handler(l_unknown_marker);\n\n            if (!(p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Marker is not compliant with its position\\n\");\n                return OPJ_FALSE;\n            } else {\n                if (l_marker_handler->id != J2K_MS_UNK) {\n                    /* Add the marker to the codestream index*/\n                    if (l_marker_handler->id != J2K_MS_SOT) {\n                        OPJ_BOOL res = opj_j2k_add_mhmarker(p_j2k->cstr_index, J2K_MS_UNK,\n                                                            (OPJ_UINT32) opj_stream_tell(p_stream) - l_size_unk,\n                                                            l_size_unk);\n                        if (res == OPJ_FALSE) {\n                            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\");\n                            return OPJ_FALSE;\n                        }\n                    }\n                    break; /* next marker is known and well located */\n                } else {\n                    l_size_unk += 2;\n                }\n            }\n        }\n    }\n\n    *output_marker = l_marker_handler->id ;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k,\n        opj_mct_data_t * p_mct_record,\n        struct opj_stream_private *p_stream,\n        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 l_mct_size;\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_tmp;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_mct_size = 10 + p_mct_record->m_data_size;\n\n    if (l_mct_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mct_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCT marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mct_size;\n    }\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_MCT,\n                    2);                                   /* MCT */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_mct_size - 2,\n                    2);                                 /* Lmct */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, 0,\n                    2);                                                    /* Zmct */\n    l_current_data += 2;\n\n    /* only one marker atm */\n    l_tmp = (p_mct_record->m_index & 0xff) | (p_mct_record->m_array_type << 8) |\n            (p_mct_record->m_element_type << 10);\n\n    opj_write_bytes(l_current_data, l_tmp, 2);\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, 0,\n                    2);                                                    /* Ymct */\n    l_current_data += 2;\n\n    memcpy(l_current_data, p_mct_record->m_data, p_mct_record->m_data_size);\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mct_size,\n                              p_manager) != l_mct_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a MCT marker (Multiple Component Transform)\n *\n * @param       p_header_data   the data contained in the MCT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 i;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_tmp;\n    OPJ_UINT32 l_indix;\n    opj_mct_data_t * l_mct_data;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n\n    l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n            &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    if (p_header_size < 2) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* first marker */\n    opj_read_bytes(p_header_data, &l_tmp, 2);                       /* Zmct */\n    p_header_data += 2;\n    if (l_tmp != 0) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Cannot take in charge mct data within multiple MCT records\\n\");\n        return OPJ_TRUE;\n    }\n\n    if (p_header_size <= 6) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* Imct -> no need for other values, take the first, type is double with decorrelation x0000 1101 0000 0000*/\n    opj_read_bytes(p_header_data, &l_tmp, 2);                       /* Imct */\n    p_header_data += 2;\n\n    l_indix = l_tmp & 0xff;\n    l_mct_data = l_tcp->m_mct_records;\n\n    for (i = 0; i < l_tcp->m_nb_mct_records; ++i) {\n        if (l_mct_data->m_index == l_indix) {\n            break;\n        }\n        ++l_mct_data;\n    }\n\n    /* NOT FOUND */\n    if (i == l_tcp->m_nb_mct_records) {\n        if (l_tcp->m_nb_mct_records == l_tcp->m_nb_max_mct_records) {\n            opj_mct_data_t *new_mct_records;\n            l_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n\n            new_mct_records = (opj_mct_data_t *) opj_realloc(l_tcp->m_mct_records,\n                              l_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));\n            if (! new_mct_records) {\n                opj_free(l_tcp->m_mct_records);\n                l_tcp->m_mct_records = NULL;\n                l_tcp->m_nb_max_mct_records = 0;\n                l_tcp->m_nb_mct_records = 0;\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read MCT marker\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* Update m_mcc_records[].m_offset_array and m_decorrelation_array\n             * to point to the new addresses */\n            if (new_mct_records != l_tcp->m_mct_records) {\n                for (i = 0; i < l_tcp->m_nb_mcc_records; ++i) {\n                    opj_simple_mcc_decorrelation_data_t* l_mcc_record =\n                        &(l_tcp->m_mcc_records[i]);\n                    if (l_mcc_record->m_decorrelation_array) {\n                        l_mcc_record->m_decorrelation_array =\n                            new_mct_records +\n                            (l_mcc_record->m_decorrelation_array -\n                             l_tcp->m_mct_records);\n                    }\n                    if (l_mcc_record->m_offset_array) {\n                        l_mcc_record->m_offset_array =\n                            new_mct_records +\n                            (l_mcc_record->m_offset_array -\n                             l_tcp->m_mct_records);\n                    }\n                }\n            }\n\n            l_tcp->m_mct_records = new_mct_records;\n            l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;\n            memset(l_mct_data, 0, (l_tcp->m_nb_max_mct_records - l_tcp->m_nb_mct_records) *\n                   sizeof(opj_mct_data_t));\n        }\n\n        l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;\n        ++l_tcp->m_nb_mct_records;\n    }\n\n    if (l_mct_data->m_data) {\n        opj_free(l_mct_data->m_data);\n        l_mct_data->m_data = 00;\n        l_mct_data->m_data_size = 0;\n    }\n\n    l_mct_data->m_index = l_indix;\n    l_mct_data->m_array_type = (J2K_MCT_ARRAY_TYPE)((l_tmp  >> 8) & 3);\n    l_mct_data->m_element_type = (J2K_MCT_ELEMENT_TYPE)((l_tmp  >> 10) & 3);\n\n    opj_read_bytes(p_header_data, &l_tmp, 2);                       /* Ymct */\n    p_header_data += 2;\n    if (l_tmp != 0) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Cannot take in charge multiple MCT markers\\n\");\n        return OPJ_TRUE;\n    }\n\n    p_header_size -= 6;\n\n    l_mct_data->m_data = (OPJ_BYTE*)opj_malloc(p_header_size);\n    if (! l_mct_data->m_data) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCT marker\\n\");\n        return OPJ_FALSE;\n    }\n    memcpy(l_mct_data->m_data, p_header_data, p_header_size);\n\n    l_mct_data->m_data_size = p_header_size;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k,\n        struct opj_simple_mcc_decorrelation_data * p_mcc_record,\n        struct opj_stream_private *p_stream,\n        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_mcc_size;\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_nb_bytes_for_comp;\n    OPJ_UINT32 l_mask;\n    OPJ_UINT32 l_tmcc;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    if (p_mcc_record->m_nb_comps > 255) {\n        l_nb_bytes_for_comp = 2;\n        l_mask = 0x8000;\n    } else {\n        l_nb_bytes_for_comp = 1;\n        l_mask = 0;\n    }\n\n    l_mcc_size = p_mcc_record->m_nb_comps * 2 * l_nb_bytes_for_comp + 19;\n    if (l_mcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mcc_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCC marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mcc_size;\n    }\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_MCC,\n                    2);                                   /* MCC */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_mcc_size - 2,\n                    2);                                 /* Lmcc */\n    l_current_data += 2;\n\n    /* first marker */\n    opj_write_bytes(l_current_data, 0,\n                    2);                                  /* Zmcc */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, p_mcc_record->m_index,\n                    1);                                        /* Imcc -> no need for other values, take the first */\n    ++l_current_data;\n\n    /* only one marker atm */\n    opj_write_bytes(l_current_data, 0,\n                    2);                                  /* Ymcc */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, 1,\n                    2);                                  /* Qmcc -> number of collections -> 1 */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, 0x1,\n                    1);                                /* Xmcci type of component transformation -> array based decorrelation */\n    ++l_current_data;\n\n    opj_write_bytes(l_current_data, p_mcc_record->m_nb_comps | l_mask,\n                    2);  /* Nmcci number of input components involved and size for each component offset = 8 bits */\n    l_current_data += 2;\n\n    for (i = 0; i < p_mcc_record->m_nb_comps; ++i) {\n        opj_write_bytes(l_current_data, i,\n                        l_nb_bytes_for_comp);                          /* Cmccij Component offset*/\n        l_current_data += l_nb_bytes_for_comp;\n    }\n\n    opj_write_bytes(l_current_data, p_mcc_record->m_nb_comps | l_mask,\n                    2);  /* Mmcci number of output components involved and size for each component offset = 8 bits */\n    l_current_data += 2;\n\n    for (i = 0; i < p_mcc_record->m_nb_comps; ++i) {\n        opj_write_bytes(l_current_data, i,\n                        l_nb_bytes_for_comp);                          /* Wmccij Component offset*/\n        l_current_data += l_nb_bytes_for_comp;\n    }\n\n    l_tmcc = ((!p_mcc_record->m_is_irreversible) & 1U) << 16;\n\n    if (p_mcc_record->m_decorrelation_array) {\n        l_tmcc |= p_mcc_record->m_decorrelation_array->m_index;\n    }\n\n    if (p_mcc_record->m_offset_array) {\n        l_tmcc |= ((p_mcc_record->m_offset_array->m_index) << 8);\n    }\n\n    opj_write_bytes(l_current_data, l_tmcc,\n                    3);     /* Tmcci : use MCT defined as number 1 and irreversible array based. */\n    l_current_data += 3;\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mcc_size,\n                              p_manager) != l_mcc_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i, j;\n    OPJ_UINT32 l_tmp;\n    OPJ_UINT32 l_indix;\n    opj_tcp_t * l_tcp;\n    opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n    opj_mct_data_t * l_mct_data;\n    OPJ_UINT32 l_nb_collections;\n    OPJ_UINT32 l_nb_comps;\n    OPJ_UINT32 l_nb_bytes_by_comp;\n    OPJ_BOOL l_new_mcc = OPJ_FALSE;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n            &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    if (p_header_size < 2) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* first marker */\n    opj_read_bytes(p_header_data, &l_tmp, 2);                       /* Zmcc */\n    p_header_data += 2;\n    if (l_tmp != 0) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Cannot take in charge multiple data spanning\\n\");\n        return OPJ_TRUE;\n    }\n\n    if (p_header_size < 7) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_indix,\n                   1); /* Imcc -> no need for other values, take the first */\n    ++p_header_data;\n\n    l_mcc_record = l_tcp->m_mcc_records;\n\n    for (i = 0; i < l_tcp->m_nb_mcc_records; ++i) {\n        if (l_mcc_record->m_index == l_indix) {\n            break;\n        }\n        ++l_mcc_record;\n    }\n\n    /** NOT FOUND */\n    if (i == l_tcp->m_nb_mcc_records) {\n        if (l_tcp->m_nb_mcc_records == l_tcp->m_nb_max_mcc_records) {\n            opj_simple_mcc_decorrelation_data_t *new_mcc_records;\n            l_tcp->m_nb_max_mcc_records += OPJ_J2K_MCC_DEFAULT_NB_RECORDS;\n\n            new_mcc_records = (opj_simple_mcc_decorrelation_data_t *) opj_realloc(\n                                  l_tcp->m_mcc_records, l_tcp->m_nb_max_mcc_records * sizeof(\n                                      opj_simple_mcc_decorrelation_data_t));\n            if (! new_mcc_records) {\n                opj_free(l_tcp->m_mcc_records);\n                l_tcp->m_mcc_records = NULL;\n                l_tcp->m_nb_max_mcc_records = 0;\n                l_tcp->m_nb_mcc_records = 0;\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read MCC marker\\n\");\n                return OPJ_FALSE;\n            }\n            l_tcp->m_mcc_records = new_mcc_records;\n            l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;\n            memset(l_mcc_record, 0, (l_tcp->m_nb_max_mcc_records - l_tcp->m_nb_mcc_records)\n                   * sizeof(opj_simple_mcc_decorrelation_data_t));\n        }\n        l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;\n        l_new_mcc = OPJ_TRUE;\n    }\n    l_mcc_record->m_index = l_indix;\n\n    /* only one marker atm */\n    opj_read_bytes(p_header_data, &l_tmp, 2);                       /* Ymcc */\n    p_header_data += 2;\n    if (l_tmp != 0) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Cannot take in charge multiple data spanning\\n\");\n        return OPJ_TRUE;\n    }\n\n    opj_read_bytes(p_header_data, &l_nb_collections,\n                   2);                              /* Qmcc -> number of collections -> 1 */\n    p_header_data += 2;\n\n    if (l_nb_collections > 1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Cannot take in charge multiple collections\\n\");\n        return OPJ_TRUE;\n    }\n\n    p_header_size -= 7;\n\n    for (i = 0; i < l_nb_collections; ++i) {\n        if (p_header_size < 3) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n            return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data, &l_tmp,\n                       1); /* Xmcci type of component transformation -> array based decorrelation */\n        ++p_header_data;\n\n        if (l_tmp != 1) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"Cannot take in charge collections other than array decorrelation\\n\");\n            return OPJ_TRUE;\n        }\n\n        opj_read_bytes(p_header_data, &l_nb_comps, 2);\n\n        p_header_data += 2;\n        p_header_size -= 3;\n\n        l_nb_bytes_by_comp = 1 + (l_nb_comps >> 15);\n        l_mcc_record->m_nb_comps = l_nb_comps & 0x7fff;\n\n        if (p_header_size < (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n            return OPJ_FALSE;\n        }\n\n        p_header_size -= (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2);\n\n        for (j = 0; j < l_mcc_record->m_nb_comps; ++j) {\n            opj_read_bytes(p_header_data, &l_tmp,\n                           l_nb_bytes_by_comp);      /* Cmccij Component offset*/\n            p_header_data += l_nb_bytes_by_comp;\n\n            if (l_tmp != j) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"Cannot take in charge collections with indix shuffle\\n\");\n                return OPJ_TRUE;\n            }\n        }\n\n        opj_read_bytes(p_header_data, &l_nb_comps, 2);\n        p_header_data += 2;\n\n        l_nb_bytes_by_comp = 1 + (l_nb_comps >> 15);\n        l_nb_comps &= 0x7fff;\n\n        if (l_nb_comps != l_mcc_record->m_nb_comps) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"Cannot take in charge collections without same number of indixes\\n\");\n            return OPJ_TRUE;\n        }\n\n        if (p_header_size < (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n            return OPJ_FALSE;\n        }\n\n        p_header_size -= (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3);\n\n        for (j = 0; j < l_mcc_record->m_nb_comps; ++j) {\n            opj_read_bytes(p_header_data, &l_tmp,\n                           l_nb_bytes_by_comp);      /* Wmccij Component offset*/\n            p_header_data += l_nb_bytes_by_comp;\n\n            if (l_tmp != j) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"Cannot take in charge collections with indix shuffle\\n\");\n                return OPJ_TRUE;\n            }\n        }\n\n        opj_read_bytes(p_header_data, &l_tmp, 3); /* Wmccij Component offset*/\n        p_header_data += 3;\n\n        l_mcc_record->m_is_irreversible = !((l_tmp >> 16) & 1);\n        l_mcc_record->m_decorrelation_array = 00;\n        l_mcc_record->m_offset_array = 00;\n\n        l_indix = l_tmp & 0xff;\n        if (l_indix != 0) {\n            l_mct_data = l_tcp->m_mct_records;\n            for (j = 0; j < l_tcp->m_nb_mct_records; ++j) {\n                if (l_mct_data->m_index == l_indix) {\n                    l_mcc_record->m_decorrelation_array = l_mct_data;\n                    break;\n                }\n                ++l_mct_data;\n            }\n\n            if (l_mcc_record->m_decorrelation_array == 00) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                return OPJ_FALSE;\n            }\n        }\n\n        l_indix = (l_tmp >> 8) & 0xff;\n        if (l_indix != 0) {\n            l_mct_data = l_tcp->m_mct_records;\n            for (j = 0; j < l_tcp->m_nb_mct_records; ++j) {\n                if (l_mct_data->m_index == l_indix) {\n                    l_mcc_record->m_offset_array = l_mct_data;\n                    break;\n                }\n                ++l_mct_data;\n            }\n\n            if (l_mcc_record->m_offset_array == 00) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                return OPJ_FALSE;\n            }\n        }\n    }\n\n    if (p_header_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (l_new_mcc) {\n        ++l_tcp->m_nb_mcc_records;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k,\n                                  struct opj_stream_private *p_stream,\n                                  struct opj_event_mgr * p_manager\n                                 )\n{\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_mco_size;\n    opj_tcp_t * l_tcp = 00;\n    opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n    OPJ_UINT32 i;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n\n    l_mco_size = 5 + l_tcp->m_nb_mcc_records;\n    if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCO marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;\n    }\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n\n    opj_write_bytes(l_current_data, J2K_MS_MCO, 2);                 /* MCO */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_mco_size - 2, 2);             /* Lmco */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_tcp->m_nb_mcc_records,\n                    1);    /* Nmco : only one transform stage*/\n    ++l_current_data;\n\n    l_mcc_record = l_tcp->m_mcc_records;\n    for (i = 0; i < l_tcp->m_nb_mcc_records; ++i) {\n        opj_write_bytes(l_current_data, l_mcc_record->m_index,\n                        1); /* Imco -> use the mcc indicated by 1*/\n        ++l_current_data;\n        ++l_mcc_record;\n    }\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size,\n                              p_manager) != l_mco_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a MCO marker (Multiple Component Transform Ordering)\n *\n * @param       p_header_data   the data contained in the MCO box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCO marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_tmp, i;\n    OPJ_UINT32 l_nb_stages;\n    opj_tcp_t * l_tcp;\n    opj_tccp_t * l_tccp;\n    opj_image_t * l_image;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_image = p_j2k->m_private_image;\n    l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n            &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    if (p_header_size < 1) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCO marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_nb_stages,\n                   1);                         /* Nmco : only one transform stage*/\n    ++p_header_data;\n\n    if (l_nb_stages > 1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Cannot take in charge multiple transformation stages.\\n\");\n        return OPJ_TRUE;\n    }\n\n    if (p_header_size != l_nb_stages + 1) {\n        opj_event_msg(p_manager, EVT_WARNING, \"Error reading MCO marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_tccp = l_tcp->tccps;\n\n    for (i = 0; i < l_image->numcomps; ++i) {\n        l_tccp->m_dc_level_shift = 0;\n        ++l_tccp;\n    }\n\n    if (l_tcp->m_mct_decoding_matrix) {\n        opj_free(l_tcp->m_mct_decoding_matrix);\n        l_tcp->m_mct_decoding_matrix = 00;\n    }\n\n    for (i = 0; i < l_nb_stages; ++i) {\n        opj_read_bytes(p_header_data, &l_tmp, 1);\n        ++p_header_data;\n\n        if (! opj_j2k_add_mct(l_tcp, p_j2k->m_private_image, l_tmp)) {\n            return OPJ_FALSE;\n        }\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_add_mct(opj_tcp_t * p_tcp, opj_image_t * p_image,\n                                OPJ_UINT32 p_index)\n{\n    OPJ_UINT32 i;\n    opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n    opj_mct_data_t * l_deco_array, * l_offset_array;\n    OPJ_UINT32 l_data_size, l_mct_size, l_offset_size;\n    OPJ_UINT32 l_nb_elem;\n    OPJ_UINT32 * l_offset_data, * l_current_offset_data;\n    opj_tccp_t * l_tccp;\n\n    /* preconditions */\n    assert(p_tcp != 00);\n\n    l_mcc_record = p_tcp->m_mcc_records;\n\n    for (i = 0; i < p_tcp->m_nb_mcc_records; ++i) {\n        if (l_mcc_record->m_index == p_index) {\n            break;\n        }\n    }\n\n    if (i == p_tcp->m_nb_mcc_records) {\n        /** element discarded **/\n        return OPJ_TRUE;\n    }\n\n    if (l_mcc_record->m_nb_comps != p_image->numcomps) {\n        /** do not support number of comps != image */\n        return OPJ_TRUE;\n    }\n\n    l_deco_array = l_mcc_record->m_decorrelation_array;\n\n    if (l_deco_array) {\n        l_data_size = MCT_ELEMENT_SIZE[l_deco_array->m_element_type] * p_image->numcomps\n                      * p_image->numcomps;\n        if (l_deco_array->m_data_size != l_data_size) {\n            return OPJ_FALSE;\n        }\n\n        l_nb_elem = p_image->numcomps * p_image->numcomps;\n        l_mct_size = l_nb_elem * (OPJ_UINT32)sizeof(OPJ_FLOAT32);\n        p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(l_mct_size);\n\n        if (! p_tcp->m_mct_decoding_matrix) {\n            return OPJ_FALSE;\n        }\n\n        j2k_mct_read_functions_to_float[l_deco_array->m_element_type](\n            l_deco_array->m_data, p_tcp->m_mct_decoding_matrix, l_nb_elem);\n    }\n\n    l_offset_array = l_mcc_record->m_offset_array;\n\n    if (l_offset_array) {\n        l_data_size = MCT_ELEMENT_SIZE[l_offset_array->m_element_type] *\n                      p_image->numcomps;\n        if (l_offset_array->m_data_size != l_data_size) {\n            return OPJ_FALSE;\n        }\n\n        l_nb_elem = p_image->numcomps;\n        l_offset_size = l_nb_elem * (OPJ_UINT32)sizeof(OPJ_UINT32);\n        l_offset_data = (OPJ_UINT32*)opj_malloc(l_offset_size);\n\n        if (! l_offset_data) {\n            return OPJ_FALSE;\n        }\n\n        j2k_mct_read_functions_to_int32[l_offset_array->m_element_type](\n            l_offset_array->m_data, l_offset_data, l_nb_elem);\n\n        l_tccp = p_tcp->tccps;\n        l_current_offset_data = l_offset_data;\n\n        for (i = 0; i < p_image->numcomps; ++i) {\n            l_tccp->m_dc_level_shift = (OPJ_INT32) * (l_current_offset_data++);\n            ++l_tccp;\n        }\n\n        opj_free(l_offset_data);\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k,\n                                  struct opj_stream_private *p_stream,\n                                  struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_cbd_size;\n    OPJ_BYTE * l_current_data = 00;\n    opj_image_t *l_image = 00;\n    opj_image_comp_t * l_comp = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_image = p_j2k->m_private_image;\n    l_cbd_size = 6 + p_j2k->m_private_image->numcomps;\n\n    if (l_cbd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_cbd_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write CBD marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;\n    }\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_CBD, 2);                 /* CBD */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_cbd_size - 2, 2);             /* L_CBD */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_image->numcomps, 2);          /* Ncbd */\n    l_current_data += 2;\n\n    l_comp = l_image->comps;\n\n    for (i = 0; i < l_image->numcomps; ++i) {\n        opj_write_bytes(l_current_data, (l_comp->sgnd << 7) | (l_comp->prec - 1),\n                        1);           /* Component bit depth */\n        ++l_current_data;\n\n        ++l_comp;\n    }\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_cbd_size,\n                              p_manager) != l_cbd_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a CBD marker (Component bit depth definition)\n * @param       p_header_data   the data contained in the CBD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the CBD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_nb_comp, l_num_comp;\n    OPJ_UINT32 l_comp_def;\n    OPJ_UINT32 i;\n    opj_image_comp_t * l_comp = 00;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_num_comp = p_j2k->m_private_image->numcomps;\n\n    if (p_header_size != (p_j2k->m_private_image->numcomps + 2)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Crror reading CBD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_nb_comp,\n                   2);                           /* Ncbd */\n    p_header_data += 2;\n\n    if (l_nb_comp != l_num_comp) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Crror reading CBD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_comp = p_j2k->m_private_image->comps;\n    for (i = 0; i < l_num_comp; ++i) {\n        opj_read_bytes(p_header_data, &l_comp_def,\n                       1);                  /* Component bit depth */\n        ++p_header_data;\n        l_comp->sgnd = (l_comp_def >> 7) & 1;\n        l_comp->prec = (l_comp_def & 0x7f) + 1;\n\n        if (l_comp->prec > 31) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\\n\",\n                          i, l_comp->prec);\n            return OPJ_FALSE;\n        }\n        ++l_comp;\n    }\n\n    return OPJ_TRUE;\n}\n\n/* ----------------------------------------------------------------------- */\n/* J2K / JPT decoder interface                                             */\n/* ----------------------------------------------------------------------- */\n\nvoid opj_j2k_setup_decoder(opj_j2k_t *j2k, opj_dparameters_t *parameters)\n{\n    if (j2k && parameters) {\n        j2k->m_cp.m_specific_param.m_dec.m_layer = parameters->cp_layer;\n        j2k->m_cp.m_specific_param.m_dec.m_reduce = parameters->cp_reduce;\n\n        j2k->dump_state = (parameters->flags & OPJ_DPARAMETERS_DUMP_FLAG);\n#ifdef USE_JPWL\n        j2k->m_cp.correct = parameters->jpwl_correct;\n        j2k->m_cp.exp_comps = parameters->jpwl_exp_comps;\n        j2k->m_cp.max_tiles = parameters->jpwl_max_tiles;\n#endif /* USE_JPWL */\n    }\n}\n\nOPJ_BOOL opj_j2k_set_threads(opj_j2k_t *j2k, OPJ_UINT32 num_threads)\n{\n    if (opj_has_thread_support()) {\n        opj_thread_pool_destroy(j2k->m_tp);\n        j2k->m_tp = NULL;\n        if (num_threads <= (OPJ_UINT32)INT_MAX) {\n            j2k->m_tp = opj_thread_pool_create((int)num_threads);\n        }\n        if (j2k->m_tp == NULL) {\n            j2k->m_tp = opj_thread_pool_create(0);\n            return OPJ_FALSE;\n        }\n        return OPJ_TRUE;\n    }\n    return OPJ_FALSE;\n}\n\nstatic int opj_j2k_get_default_thread_count()\n{\n    const char* num_threads = getenv(\"OPJ_NUM_THREADS\");\n    if (num_threads == NULL || !opj_has_thread_support()) {\n        return 0;\n    }\n    if (strcmp(num_threads, \"ALL_CPUS\") == 0) {\n        return opj_get_num_cpus();\n    }\n    return atoi(num_threads);\n}\n\n/* ----------------------------------------------------------------------- */\n/* J2K encoder interface                                                       */\n/* ----------------------------------------------------------------------- */\n\nopj_j2k_t* opj_j2k_create_compress(void)\n{\n    opj_j2k_t *l_j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));\n    if (!l_j2k) {\n        return NULL;\n    }\n\n\n    l_j2k->m_is_decoder = 0;\n    l_j2k->m_cp.m_is_decoder = 0;\n\n    l_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *) opj_malloc(\n                OPJ_J2K_DEFAULT_HEADER_SIZE);\n    if (! l_j2k->m_specific_param.m_encoder.m_header_tile_data) {\n        opj_j2k_destroy(l_j2k);\n        return NULL;\n    }\n\n    l_j2k->m_specific_param.m_encoder.m_header_tile_data_size =\n        OPJ_J2K_DEFAULT_HEADER_SIZE;\n\n    /* validation list creation*/\n    l_j2k->m_validation_list = opj_procedure_list_create();\n    if (! l_j2k->m_validation_list) {\n        opj_j2k_destroy(l_j2k);\n        return NULL;\n    }\n\n    /* execution list creation*/\n    l_j2k->m_procedure_list = opj_procedure_list_create();\n    if (! l_j2k->m_procedure_list) {\n        opj_j2k_destroy(l_j2k);\n        return NULL;\n    }\n\n    l_j2k->m_tp = opj_thread_pool_create(opj_j2k_get_default_thread_count());\n    if (!l_j2k->m_tp) {\n        l_j2k->m_tp = opj_thread_pool_create(0);\n    }\n    if (!l_j2k->m_tp) {\n        opj_j2k_destroy(l_j2k);\n        return NULL;\n    }\n\n    return l_j2k;\n}\n\nstatic int opj_j2k_initialise_4K_poc(opj_poc_t *POC, int numres)\n{\n    POC[0].tile  = 1;\n    POC[0].resno0  = 0;\n    POC[0].compno0 = 0;\n    POC[0].layno1  = 1;\n    POC[0].resno1  = (OPJ_UINT32)(numres - 1);\n    POC[0].compno1 = 3;\n    POC[0].prg1 = OPJ_CPRL;\n    POC[1].tile  = 1;\n    POC[1].resno0  = (OPJ_UINT32)(numres - 1);\n    POC[1].compno0 = 0;\n    POC[1].layno1  = 1;\n    POC[1].resno1  = (OPJ_UINT32)numres;\n    POC[1].compno1 = 3;\n    POC[1].prg1 = OPJ_CPRL;\n    return 2;\n}\n\nstatic void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,\n        opj_image_t *image, opj_event_mgr_t *p_manager)\n{\n    /* Configure cinema parameters */\n    int i;\n\n    /* No tiling */\n    parameters->tile_size_on = OPJ_FALSE;\n    parameters->cp_tdx = 1;\n    parameters->cp_tdy = 1;\n\n    /* One tile part for each component */\n    parameters->tp_flag = 'C';\n    parameters->tp_on = 1;\n\n    /* Tile and Image shall be at (0,0) */\n    parameters->cp_tx0 = 0;\n    parameters->cp_ty0 = 0;\n    parameters->image_offset_x0 = 0;\n    parameters->image_offset_y0 = 0;\n\n    /* Codeblock size= 32*32 */\n    parameters->cblockw_init = 32;\n    parameters->cblockh_init = 32;\n\n    /* Codeblock style: no mode switch enabled */\n    parameters->mode = 0;\n\n    /* No ROI */\n    parameters->roi_compno = -1;\n\n    /* No subsampling */\n    parameters->subsampling_dx = 1;\n    parameters->subsampling_dy = 1;\n\n    /* 9-7 transform */\n    parameters->irreversible = 1;\n\n    /* Number of layers */\n    if (parameters->tcp_numlayers > 1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"1 single quality layer\"\n                      \"-> Number of layers forced to 1 (rather than %d)\\n\"\n                      \"-> Rate of the last layer (%3.1f) will be used\",\n                      parameters->tcp_numlayers,\n                      parameters->tcp_rates[parameters->tcp_numlayers - 1]);\n        parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];\n        parameters->tcp_numlayers = 1;\n    }\n\n    /* Resolution levels */\n    switch (parameters->rsiz) {\n    case OPJ_PROFILE_CINEMA_2K:\n        if (parameters->numresolution > 6) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                          \"Number of decomposition levels <= 5\\n\"\n                          \"-> Number of decomposition levels forced to 5 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 6;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if (parameters->numresolution < 2) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 1 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 1;\n        } else if (parameters->numresolution > 7) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 6 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 7;\n        }\n        break;\n    default :\n        break;\n    }\n\n    /* Precincts */\n    parameters->csty |= 0x01;\n    parameters->res_spec = parameters->numresolution - 1;\n    for (i = 0; i < parameters->res_spec; i++) {\n        parameters->prcw_init[i] = 256;\n        parameters->prch_init[i] = 256;\n    }\n\n    /* The progression order shall be CPRL */\n    parameters->prog_order = OPJ_CPRL;\n\n    /* Progression order changes for 4K, disallowed for 2K */\n    if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {\n        parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,\n                              parameters->numresolution);\n    } else {\n        parameters->numpocs = 0;\n    }\n\n    /* Limited bit-rate */\n    parameters->cp_disto_alloc = 1;\n    if (parameters->max_cs_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\\n\");\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n    }\n\n    if (parameters->max_comp_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\\n\");\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n    }\n\n    parameters->tcp_rates[0] = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *\n                               image->comps[0].h * image->comps[0].prec) /\n                               (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *\n                                       image->comps[0].dy);\n\n}\n\nstatic OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image, OPJ_UINT16 rsiz,\n        opj_event_mgr_t *p_manager)\n{\n    OPJ_UINT32 i;\n\n    /* Number of components */\n    if (image->numcomps != 3) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                      \"3 components\"\n                      \"-> Number of components of input image (%d) is not compliant\\n\"\n                      \"-> Non-profile-3 codestream will be generated\\n\",\n                      image->numcomps);\n        return OPJ_FALSE;\n    }\n\n    /* Bitdepth */\n    for (i = 0; i < image->numcomps; i++) {\n        if ((image->comps[i].bpp != 12) | (image->comps[i].sgnd)) {\n            char signed_str[] = \"signed\";\n            char unsigned_str[] = \"unsigned\";\n            char *tmp_str = image->comps[i].sgnd ? signed_str : unsigned_str;\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                          \"Precision of each component shall be 12 bits unsigned\"\n                          \"-> At least component %d of input image (%d bits, %s) is not compliant\\n\"\n                          \"-> Non-profile-3 codestream will be generated\\n\",\n                          i, image->comps[i].bpp, tmp_str);\n            return OPJ_FALSE;\n        }\n    }\n\n    /* Image size */\n    switch (rsiz) {\n    case OPJ_PROFILE_CINEMA_2K:\n        if (((image->comps[0].w > 2048) | (image->comps[0].h > 1080))) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                          \"width <= 2048 and height <= 1080\\n\"\n                          \"-> Input image size %d x %d is not compliant\\n\"\n                          \"-> Non-profile-3 codestream will be generated\\n\",\n                          image->comps[0].w, image->comps[0].h);\n            return OPJ_FALSE;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if (((image->comps[0].w > 4096) | (image->comps[0].h > 2160))) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"width <= 4096 and height <= 2160\\n\"\n                          \"-> Image size %d x %d is not compliant\\n\"\n                          \"-> Non-profile-4 codestream will be generated\\n\",\n                          image->comps[0].w, image->comps[0].h);\n            return OPJ_FALSE;\n        }\n        break;\n    default :\n        break;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k,\n                               opj_cparameters_t *parameters,\n                               opj_image_t *image,\n                               opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i, j, tileno, numpocs_tile;\n    opj_cp_t *cp = 00;\n\n    if (!p_j2k || !parameters || ! image) {\n        return OPJ_FALSE;\n    }\n\n    if ((parameters->numresolution <= 0) ||\n            (parameters->numresolution > OPJ_J2K_MAXRLVLS)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Invalid number of resolutions : %d not in range [1,%d]\\n\",\n                      parameters->numresolution, OPJ_J2K_MAXRLVLS);\n        return OPJ_FALSE;\n    }\n\n    /* keep a link to cp so that we can destroy it later in j2k_destroy_compress */\n    cp = &(p_j2k->m_cp);\n\n    /* set default values for cp */\n    cp->tw = 1;\n    cp->th = 1;\n\n    /* FIXME ADE: to be removed once deprecated cp_cinema and cp_rsiz have been removed */\n    if (parameters->rsiz ==\n            OPJ_PROFILE_NONE) { /* consider deprecated fields only if RSIZ has not been set */\n        OPJ_BOOL deprecated_used = OPJ_FALSE;\n        switch (parameters->cp_cinema) {\n        case OPJ_CINEMA2K_24:\n            parameters->rsiz = OPJ_PROFILE_CINEMA_2K;\n            parameters->max_cs_size = OPJ_CINEMA_24_CS;\n            parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n            deprecated_used = OPJ_TRUE;\n            break;\n        case OPJ_CINEMA2K_48:\n            parameters->rsiz = OPJ_PROFILE_CINEMA_2K;\n            parameters->max_cs_size = OPJ_CINEMA_48_CS;\n            parameters->max_comp_size = OPJ_CINEMA_48_COMP;\n            deprecated_used = OPJ_TRUE;\n            break;\n        case OPJ_CINEMA4K_24:\n            parameters->rsiz = OPJ_PROFILE_CINEMA_4K;\n            parameters->max_cs_size = OPJ_CINEMA_24_CS;\n            parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n            deprecated_used = OPJ_TRUE;\n            break;\n        case OPJ_OFF:\n        default:\n            break;\n        }\n        switch (parameters->cp_rsiz) {\n        case OPJ_CINEMA2K:\n            parameters->rsiz = OPJ_PROFILE_CINEMA_2K;\n            deprecated_used = OPJ_TRUE;\n            break;\n        case OPJ_CINEMA4K:\n            parameters->rsiz = OPJ_PROFILE_CINEMA_4K;\n            deprecated_used = OPJ_TRUE;\n            break;\n        case OPJ_MCT:\n            parameters->rsiz = OPJ_PROFILE_PART2 | OPJ_EXTENSION_MCT;\n            deprecated_used = OPJ_TRUE;\n        case OPJ_STD_RSIZ:\n        default:\n            break;\n        }\n        if (deprecated_used) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"Deprecated fields cp_cinema or cp_rsiz are used\\n\"\n                          \"Please consider using only the rsiz field\\n\"\n                          \"See openjpeg.h documentation for more details\\n\");\n        }\n    }\n\n    /* If no explicit layers are provided, use lossless settings */\n    if (parameters->tcp_numlayers == 0) {\n        parameters->tcp_numlayers = 1;\n        parameters->cp_disto_alloc = 1;\n        parameters->tcp_rates[0] = 0;\n    }\n\n    /* see if max_codestream_size does limit input rate */\n    if (parameters->max_cs_size <= 0) {\n        if (parameters->tcp_rates[parameters->tcp_numlayers - 1] > 0) {\n            OPJ_FLOAT32 temp_size;\n            temp_size = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *\n                                      image->comps[0].h * image->comps[0].prec) /\n                        (parameters->tcp_rates[parameters->tcp_numlayers - 1] * 8 *\n                         (OPJ_FLOAT32)image->comps[0].dx * (OPJ_FLOAT32)image->comps[0].dy);\n            parameters->max_cs_size = (int) floor(temp_size);\n        } else {\n            parameters->max_cs_size = 0;\n        }\n    } else {\n        OPJ_FLOAT32 temp_rate;\n        OPJ_BOOL cap = OPJ_FALSE;\n        temp_rate = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *\n                                  image->comps[0].h * image->comps[0].prec) /\n                    (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *\n                                  image->comps[0].dy);\n        for (i = 0; i < (OPJ_UINT32) parameters->tcp_numlayers; i++) {\n            if (parameters->tcp_rates[i] < temp_rate) {\n                parameters->tcp_rates[i] = temp_rate;\n                cap = OPJ_TRUE;\n            }\n        }\n        if (cap) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"The desired maximum codestream size has limited\\n\"\n                          \"at least one of the desired quality layers\\n\");\n        }\n    }\n\n    /* Manage profiles and applications and set RSIZ */\n    /* set cinema parameters if required */\n    if (OPJ_IS_CINEMA(parameters->rsiz)) {\n        if ((parameters->rsiz == OPJ_PROFILE_CINEMA_S2K)\n                || (parameters->rsiz == OPJ_PROFILE_CINEMA_S4K)) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Scalable Digital Cinema profiles not yet supported\\n\");\n            parameters->rsiz = OPJ_PROFILE_NONE;\n        } else {\n            opj_j2k_set_cinema_parameters(parameters, image, p_manager);\n            if (!opj_j2k_is_cinema_compliant(image, parameters->rsiz, p_manager)) {\n                parameters->rsiz = OPJ_PROFILE_NONE;\n            }\n        }\n    } else if (OPJ_IS_STORAGE(parameters->rsiz)) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Long Term Storage profile not yet supported\\n\");\n        parameters->rsiz = OPJ_PROFILE_NONE;\n    } else if (OPJ_IS_BROADCAST(parameters->rsiz)) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Broadcast profiles not yet supported\\n\");\n        parameters->rsiz = OPJ_PROFILE_NONE;\n    } else if (OPJ_IS_IMF(parameters->rsiz)) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 IMF profiles not yet supported\\n\");\n        parameters->rsiz = OPJ_PROFILE_NONE;\n    } else if (OPJ_IS_PART2(parameters->rsiz)) {\n        if (parameters->rsiz == ((OPJ_PROFILE_PART2) | (OPJ_EXTENSION_NONE))) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Part-2 profile defined\\n\"\n                          \"but no Part-2 extension enabled.\\n\"\n                          \"Profile set to NONE.\\n\");\n            parameters->rsiz = OPJ_PROFILE_NONE;\n        } else if (parameters->rsiz != ((OPJ_PROFILE_PART2) | (OPJ_EXTENSION_MCT))) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"Unsupported Part-2 extension enabled\\n\"\n                          \"Profile set to NONE.\\n\");\n            parameters->rsiz = OPJ_PROFILE_NONE;\n        }\n    }\n\n    /*\n    copy user encoding parameters\n    */\n    cp->m_specific_param.m_enc.m_max_comp_size = (OPJ_UINT32)\n            parameters->max_comp_size;\n    cp->rsiz = parameters->rsiz;\n    cp->m_specific_param.m_enc.m_disto_alloc = (OPJ_UINT32)\n            parameters->cp_disto_alloc & 1u;\n    cp->m_specific_param.m_enc.m_fixed_alloc = (OPJ_UINT32)\n            parameters->cp_fixed_alloc & 1u;\n    cp->m_specific_param.m_enc.m_fixed_quality = (OPJ_UINT32)\n            parameters->cp_fixed_quality & 1u;\n\n    /* mod fixed_quality */\n    if (parameters->cp_fixed_alloc && parameters->cp_matrice) {\n        size_t array_size = (size_t)parameters->tcp_numlayers *\n                            (size_t)parameters->numresolution * 3 * sizeof(OPJ_INT32);\n        cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *) opj_malloc(array_size);\n        if (!cp->m_specific_param.m_enc.m_matrice) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to allocate copy of user encoding parameters matrix \\n\");\n            return OPJ_FALSE;\n        }\n        memcpy(cp->m_specific_param.m_enc.m_matrice, parameters->cp_matrice,\n               array_size);\n    }\n\n    /* tiles */\n    cp->tdx = (OPJ_UINT32)parameters->cp_tdx;\n    cp->tdy = (OPJ_UINT32)parameters->cp_tdy;\n\n    /* tile offset */\n    cp->tx0 = (OPJ_UINT32)parameters->cp_tx0;\n    cp->ty0 = (OPJ_UINT32)parameters->cp_ty0;\n\n    /* comment string */\n    if (parameters->cp_comment) {\n        cp->comment = (char*)opj_malloc(strlen(parameters->cp_comment) + 1U);\n        if (!cp->comment) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to allocate copy of comment string\\n\");\n            return OPJ_FALSE;\n        }\n        strcpy(cp->comment, parameters->cp_comment);\n    } else {\n        /* Create default comment for codestream */\n        const char comment[] = \"Created by OpenJPEG version \";\n        const size_t clen = strlen(comment);\n        const char *version = opj_version();\n\n        /* UniPG>> */\n#ifdef USE_JPWL\n        cp->comment = (char*)opj_malloc(clen + strlen(version) + 11);\n        if (!cp->comment) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to allocate comment string\\n\");\n            return OPJ_FALSE;\n        }\n        sprintf(cp->comment, \"%s%s with JPWL\", comment, version);\n#else\n        cp->comment = (char*)opj_malloc(clen + strlen(version) + 1);\n        if (!cp->comment) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to allocate comment string\\n\");\n            return OPJ_FALSE;\n        }\n        sprintf(cp->comment, \"%s%s\", comment, version);\n#endif\n        /* <<UniPG */\n    }\n\n    /*\n    calculate other encoding parameters\n    */\n\n    if (parameters->tile_size_on) {\n        cp->tw = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(image->x1 - cp->tx0),\n                                             (OPJ_INT32)cp->tdx);\n        cp->th = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(image->y1 - cp->ty0),\n                                             (OPJ_INT32)cp->tdy);\n    } else {\n        cp->tdx = image->x1 - cp->tx0;\n        cp->tdy = image->y1 - cp->ty0;\n    }\n\n    if (parameters->tp_on) {\n        cp->m_specific_param.m_enc.m_tp_flag = (OPJ_BYTE)parameters->tp_flag;\n        cp->m_specific_param.m_enc.m_tp_on = 1;\n    }\n\n#ifdef USE_JPWL\n    /*\n    calculate JPWL encoding parameters\n    */\n\n    if (parameters->jpwl_epc_on) {\n        OPJ_INT32 i;\n\n        /* set JPWL on */\n        cp->epc_on = OPJ_TRUE;\n        cp->info_on = OPJ_FALSE; /* no informative technique */\n\n        /* set EPB on */\n        if ((parameters->jpwl_hprot_MH > 0) || (parameters->jpwl_hprot_TPH[0] > 0)) {\n            cp->epb_on = OPJ_TRUE;\n\n            cp->hprot_MH = parameters->jpwl_hprot_MH;\n            for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {\n                cp->hprot_TPH_tileno[i] = parameters->jpwl_hprot_TPH_tileno[i];\n                cp->hprot_TPH[i] = parameters->jpwl_hprot_TPH[i];\n            }\n            /* if tile specs are not specified, copy MH specs */\n            if (cp->hprot_TPH[0] == -1) {\n                cp->hprot_TPH_tileno[0] = 0;\n                cp->hprot_TPH[0] = parameters->jpwl_hprot_MH;\n            }\n            for (i = 0; i < JPWL_MAX_NO_PACKSPECS; i++) {\n                cp->pprot_tileno[i] = parameters->jpwl_pprot_tileno[i];\n                cp->pprot_packno[i] = parameters->jpwl_pprot_packno[i];\n                cp->pprot[i] = parameters->jpwl_pprot[i];\n            }\n        }\n\n        /* set ESD writing */\n        if ((parameters->jpwl_sens_size == 1) || (parameters->jpwl_sens_size == 2)) {\n            cp->esd_on = OPJ_TRUE;\n\n            cp->sens_size = parameters->jpwl_sens_size;\n            cp->sens_addr = parameters->jpwl_sens_addr;\n            cp->sens_range = parameters->jpwl_sens_range;\n\n            cp->sens_MH = parameters->jpwl_sens_MH;\n            for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {\n                cp->sens_TPH_tileno[i] = parameters->jpwl_sens_TPH_tileno[i];\n                cp->sens_TPH[i] = parameters->jpwl_sens_TPH[i];\n            }\n        }\n\n        /* always set RED writing to false: we are at the encoder */\n        cp->red_on = OPJ_FALSE;\n\n    } else {\n        cp->epc_on = OPJ_FALSE;\n    }\n#endif /* USE_JPWL */\n\n    /* initialize the mutiple tiles */\n    /* ---------------------------- */\n    cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));\n    if (!cp->tcps) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory to allocate tile coding parameters\\n\");\n        return OPJ_FALSE;\n    }\n    if (parameters->numpocs) {\n        /* initialisation of POC */\n        opj_j2k_check_poc_val(parameters->POC, parameters->numpocs,\n                              (OPJ_UINT32)parameters->numresolution, image->numcomps,\n                              (OPJ_UINT32)parameters->tcp_numlayers, p_manager);\n        /* TODO MSD use the return value*/\n    }\n\n    for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {\n        opj_tcp_t *tcp = &cp->tcps[tileno];\n        tcp->numlayers = (OPJ_UINT32)parameters->tcp_numlayers;\n\n        for (j = 0; j < tcp->numlayers; j++) {\n            if (OPJ_IS_CINEMA(cp->rsiz)) {\n                if (cp->m_specific_param.m_enc.m_fixed_quality) {\n                    tcp->distoratio[j] = parameters->tcp_distoratio[j];\n                }\n                tcp->rates[j] = parameters->tcp_rates[j];\n            } else {\n                if (cp->m_specific_param.m_enc.m_fixed_quality) {       /* add fixed_quality */\n                    tcp->distoratio[j] = parameters->tcp_distoratio[j];\n                } else {\n                    tcp->rates[j] = parameters->tcp_rates[j];\n                }\n            }\n        }\n\n        tcp->csty = (OPJ_UINT32)parameters->csty;\n        tcp->prg = parameters->prog_order;\n        tcp->mct = (OPJ_UINT32)parameters->tcp_mct;\n\n        numpocs_tile = 0;\n        tcp->POC = 0;\n\n        if (parameters->numpocs) {\n            /* initialisation of POC */\n            tcp->POC = 1;\n            for (i = 0; i < parameters->numpocs; i++) {\n                if (tileno + 1 == parameters->POC[i].tile)  {\n                    opj_poc_t *tcp_poc = &tcp->pocs[numpocs_tile];\n\n                    tcp_poc->resno0         = parameters->POC[numpocs_tile].resno0;\n                    tcp_poc->compno0        = parameters->POC[numpocs_tile].compno0;\n                    tcp_poc->layno1         = parameters->POC[numpocs_tile].layno1;\n                    tcp_poc->resno1         = parameters->POC[numpocs_tile].resno1;\n                    tcp_poc->compno1        = parameters->POC[numpocs_tile].compno1;\n                    tcp_poc->prg1           = parameters->POC[numpocs_tile].prg1;\n                    tcp_poc->tile           = parameters->POC[numpocs_tile].tile;\n\n                    numpocs_tile++;\n                }\n            }\n\n            tcp->numpocs = numpocs_tile - 1 ;\n        } else {\n            tcp->numpocs = 0;\n        }\n\n        tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));\n        if (!tcp->tccps) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to allocate tile component coding parameters\\n\");\n            return OPJ_FALSE;\n        }\n        if (parameters->mct_data) {\n\n            OPJ_UINT32 lMctSize = image->numcomps * image->numcomps * (OPJ_UINT32)sizeof(\n                                      OPJ_FLOAT32);\n            OPJ_FLOAT32 * lTmpBuf = (OPJ_FLOAT32*)opj_malloc(lMctSize);\n            OPJ_INT32 * l_dc_shift = (OPJ_INT32 *)((OPJ_BYTE *) parameters->mct_data +\n                                                   lMctSize);\n\n            if (!lTmpBuf) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Not enough memory to allocate temp buffer\\n\");\n                return OPJ_FALSE;\n            }\n\n            tcp->mct = 2;\n            tcp->m_mct_coding_matrix = (OPJ_FLOAT32*)opj_malloc(lMctSize);\n            if (! tcp->m_mct_coding_matrix) {\n                opj_free(lTmpBuf);\n                lTmpBuf = NULL;\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Not enough memory to allocate encoder MCT coding matrix \\n\");\n                return OPJ_FALSE;\n            }\n            memcpy(tcp->m_mct_coding_matrix, parameters->mct_data, lMctSize);\n            memcpy(lTmpBuf, parameters->mct_data, lMctSize);\n\n            tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(lMctSize);\n            if (! tcp->m_mct_decoding_matrix) {\n                opj_free(lTmpBuf);\n                lTmpBuf = NULL;\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Not enough memory to allocate encoder MCT decoding matrix \\n\");\n                return OPJ_FALSE;\n            }\n            if (opj_matrix_inversion_f(lTmpBuf, (tcp->m_mct_decoding_matrix),\n                                       image->numcomps) == OPJ_FALSE) {\n                opj_free(lTmpBuf);\n                lTmpBuf = NULL;\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Failed to inverse encoder MCT decoding matrix \\n\");\n                return OPJ_FALSE;\n            }\n\n            tcp->mct_norms = (OPJ_FLOAT64*)\n                             opj_malloc(image->numcomps * sizeof(OPJ_FLOAT64));\n            if (! tcp->mct_norms) {\n                opj_free(lTmpBuf);\n                lTmpBuf = NULL;\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Not enough memory to allocate encoder MCT norms \\n\");\n                return OPJ_FALSE;\n            }\n            opj_calculate_norms(tcp->mct_norms, image->numcomps,\n                                tcp->m_mct_decoding_matrix);\n            opj_free(lTmpBuf);\n\n            for (i = 0; i < image->numcomps; i++) {\n                opj_tccp_t *tccp = &tcp->tccps[i];\n                tccp->m_dc_level_shift = l_dc_shift[i];\n            }\n\n            if (opj_j2k_setup_mct_encoding(tcp, image) == OPJ_FALSE) {\n                /* free will be handled by opj_j2k_destroy */\n                opj_event_msg(p_manager, EVT_ERROR, \"Failed to setup j2k mct encoding\\n\");\n                return OPJ_FALSE;\n            }\n        } else {\n            if (tcp->mct == 1 && image->numcomps >= 3) { /* RGB->YCC MCT is enabled */\n                if ((image->comps[0].dx != image->comps[1].dx) ||\n                        (image->comps[0].dx != image->comps[2].dx) ||\n                        (image->comps[0].dy != image->comps[1].dy) ||\n                        (image->comps[0].dy != image->comps[2].dy)) {\n                    opj_event_msg(p_manager, EVT_WARNING,\n                                  \"Cannot perform MCT on components with different sizes. Disabling MCT.\\n\");\n                    tcp->mct = 0;\n                }\n            }\n            for (i = 0; i < image->numcomps; i++) {\n                opj_tccp_t *tccp = &tcp->tccps[i];\n                opj_image_comp_t * l_comp = &(image->comps[i]);\n\n                if (! l_comp->sgnd) {\n                    tccp->m_dc_level_shift = 1 << (l_comp->prec - 1);\n                }\n            }\n        }\n\n        for (i = 0; i < image->numcomps; i++) {\n            opj_tccp_t *tccp = &tcp->tccps[i];\n\n            tccp->csty = parameters->csty &\n                         0x01;   /* 0 => one precinct || 1 => custom precinct  */\n            tccp->numresolutions = (OPJ_UINT32)parameters->numresolution;\n            tccp->cblkw = (OPJ_UINT32)opj_int_floorlog2(parameters->cblockw_init);\n            tccp->cblkh = (OPJ_UINT32)opj_int_floorlog2(parameters->cblockh_init);\n            tccp->cblksty = (OPJ_UINT32)parameters->mode;\n            tccp->qmfbid = parameters->irreversible ? 0 : 1;\n            tccp->qntsty = parameters->irreversible ? J2K_CCP_QNTSTY_SEQNT :\n                           J2K_CCP_QNTSTY_NOQNT;\n            tccp->numgbits = 2;\n\n            if ((OPJ_INT32)i == parameters->roi_compno) {\n                tccp->roishift = parameters->roi_shift;\n            } else {\n                tccp->roishift = 0;\n            }\n\n            if (parameters->csty & J2K_CCP_CSTY_PRT) {\n                OPJ_INT32 p = 0, it_res;\n                assert(tccp->numresolutions > 0);\n                for (it_res = (OPJ_INT32)tccp->numresolutions - 1; it_res >= 0; it_res--) {\n                    if (p < parameters->res_spec) {\n\n                        if (parameters->prcw_init[p] < 1) {\n                            tccp->prcw[it_res] = 1;\n                        } else {\n                            tccp->prcw[it_res] = (OPJ_UINT32)opj_int_floorlog2(parameters->prcw_init[p]);\n                        }\n\n                        if (parameters->prch_init[p] < 1) {\n                            tccp->prch[it_res] = 1;\n                        } else {\n                            tccp->prch[it_res] = (OPJ_UINT32)opj_int_floorlog2(parameters->prch_init[p]);\n                        }\n\n                    } else {\n                        OPJ_INT32 res_spec = parameters->res_spec;\n                        OPJ_INT32 size_prcw = 0;\n                        OPJ_INT32 size_prch = 0;\n\n                        assert(res_spec > 0); /* issue 189 */\n                        size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));\n                        size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));\n\n\n                        if (size_prcw < 1) {\n                            tccp->prcw[it_res] = 1;\n                        } else {\n                            tccp->prcw[it_res] = (OPJ_UINT32)opj_int_floorlog2(size_prcw);\n                        }\n\n                        if (size_prch < 1) {\n                            tccp->prch[it_res] = 1;\n                        } else {\n                            tccp->prch[it_res] = (OPJ_UINT32)opj_int_floorlog2(size_prch);\n                        }\n                    }\n                    p++;\n                    /*printf(\"\\nsize precinct for level %d : %d,%d\\n\", it_res,tccp->prcw[it_res], tccp->prch[it_res]); */\n                }       /*end for*/\n            } else {\n                for (j = 0; j < tccp->numresolutions; j++) {\n                    tccp->prcw[j] = 15;\n                    tccp->prch[j] = 15;\n                }\n            }\n\n            opj_dwt_calc_explicit_stepsizes(tccp, image->comps[i].prec);\n        }\n    }\n\n    if (parameters->mct_data) {\n        opj_free(parameters->mct_data);\n        parameters->mct_data = 00;\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index,\n                                     OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len)\n{\n    assert(cstr_index != 00);\n\n    /* expand the list? */\n    if ((cstr_index->marknum + 1) > cstr_index->maxmarknum) {\n        opj_marker_info_t *new_marker;\n        cstr_index->maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32)\n                                              cstr_index->maxmarknum);\n        new_marker = (opj_marker_info_t *) opj_realloc(cstr_index->marker,\n                     cstr_index->maxmarknum * sizeof(opj_marker_info_t));\n        if (! new_marker) {\n            opj_free(cstr_index->marker);\n            cstr_index->marker = NULL;\n            cstr_index->maxmarknum = 0;\n            cstr_index->marknum = 0;\n            /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\"); */\n            return OPJ_FALSE;\n        }\n        cstr_index->marker = new_marker;\n    }\n\n    /* add the marker */\n    cstr_index->marker[cstr_index->marknum].type = (OPJ_UINT16)type;\n    cstr_index->marker[cstr_index->marknum].pos = (OPJ_INT32)pos;\n    cstr_index->marker[cstr_index->marknum].len = (OPJ_INT32)len;\n    cstr_index->marknum++;\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno,\n                                     opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos,\n                                     OPJ_UINT32 len)\n{\n    assert(cstr_index != 00);\n    assert(cstr_index->tile_index != 00);\n\n    /* expand the list? */\n    if ((cstr_index->tile_index[tileno].marknum + 1) >\n            cstr_index->tile_index[tileno].maxmarknum) {\n        opj_marker_info_t *new_marker;\n        cstr_index->tile_index[tileno].maxmarknum = (OPJ_UINT32)(100 +\n                (OPJ_FLOAT32) cstr_index->tile_index[tileno].maxmarknum);\n        new_marker = (opj_marker_info_t *) opj_realloc(\n                         cstr_index->tile_index[tileno].marker,\n                         cstr_index->tile_index[tileno].maxmarknum * sizeof(opj_marker_info_t));\n        if (! new_marker) {\n            opj_free(cstr_index->tile_index[tileno].marker);\n            cstr_index->tile_index[tileno].marker = NULL;\n            cstr_index->tile_index[tileno].maxmarknum = 0;\n            cstr_index->tile_index[tileno].marknum = 0;\n            /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add tl marker\\n\"); */\n            return OPJ_FALSE;\n        }\n        cstr_index->tile_index[tileno].marker = new_marker;\n    }\n\n    /* add the marker */\n    cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].type\n        = (OPJ_UINT16)type;\n    cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].pos\n        = (OPJ_INT32)pos;\n    cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].len\n        = (OPJ_INT32)len;\n    cstr_index->tile_index[tileno].marknum++;\n\n    if (type == J2K_MS_SOT) {\n        OPJ_UINT32 l_current_tile_part = cstr_index->tile_index[tileno].current_tpsno;\n\n        if (cstr_index->tile_index[tileno].tp_index) {\n            cstr_index->tile_index[tileno].tp_index[l_current_tile_part].start_pos = pos;\n        }\n\n    }\n    return OPJ_TRUE;\n}\n\n/*\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n */\n\nOPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k,\n                                opj_stream_private_t *p_stream,\n                                opj_event_mgr_t * p_manager\n                               )\n{\n    (void)p_j2k;\n    (void)p_stream;\n    (void)p_manager;\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream,\n                             opj_j2k_t* p_j2k,\n                             opj_image_t** p_image,\n                             opj_event_mgr_t* p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    /* create an empty image header */\n    p_j2k->m_private_image = opj_image_create0();\n    if (! p_j2k->m_private_image) {\n        return OPJ_FALSE;\n    }\n\n    /* customization of the validation */\n    if (! opj_j2k_setup_decoding_validation(p_j2k, p_manager)) {\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n        return OPJ_FALSE;\n    }\n\n    /* validation of the parameters codec */\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager)) {\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n        return OPJ_FALSE;\n    }\n\n    /* customization of the encoding */\n    if (! opj_j2k_setup_header_reading(p_j2k, p_manager)) {\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n        return OPJ_FALSE;\n    }\n\n    /* read header */\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n        return OPJ_FALSE;\n    }\n\n    *p_image = opj_image_create0();\n    if (!(*p_image)) {\n        return OPJ_FALSE;\n    }\n\n    /* Copy codestream image information to the output image */\n    opj_copy_image_header(p_j2k->m_private_image, *p_image);\n\n    /*Allocate and initialize some elements of codestrem index*/\n    if (!opj_j2k_allocate_tile_element_cstr_index(p_j2k)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_header_reading(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager)\n{\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_read_header_procedure, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* DEVELOPER CORNER, add your custom procedures */\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_copy_default_tcp_and_create_tcd, p_manager))  {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager)\n{\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,\n                                           (opj_procedure)opj_j2k_build_decoder, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,\n                                           (opj_procedure)opj_j2k_decoding_validation, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* DEVELOPER CORNER, add your custom validation procedure */\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t * p_j2k,\n                                       opj_stream_private_t *p_stream,\n                                       opj_event_mgr_t * p_manager)\n{\n    OPJ_BOOL l_is_valid = OPJ_TRUE;\n    OPJ_UINT32 i, j;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n\n    if ((p_j2k->m_cp.rsiz & 0x8200) == 0x8200) {\n        OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n        opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;\n\n        for (i = 0; i < l_nb_tiles; ++i) {\n            if (l_tcp->mct == 2) {\n                opj_tccp_t * l_tccp = l_tcp->tccps;\n                l_is_valid &= (l_tcp->m_mct_coding_matrix != 00);\n\n                for (j = 0; j < p_j2k->m_private_image->numcomps; ++j) {\n                    l_is_valid &= !(l_tccp->qmfbid & 1);\n                    ++l_tccp;\n                }\n            }\n            ++l_tcp;\n        }\n    }\n\n    return l_is_valid;\n}\n\nOPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t * p_tcp, opj_image_t * p_image)\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_indix = 1;\n    opj_mct_data_t * l_mct_deco_data = 00, * l_mct_offset_data = 00;\n    opj_simple_mcc_decorrelation_data_t * l_mcc_data;\n    OPJ_UINT32 l_mct_size, l_nb_elem;\n    OPJ_FLOAT32 * l_data, * l_current_data;\n    opj_tccp_t * l_tccp;\n\n    /* preconditions */\n    assert(p_tcp != 00);\n\n    if (p_tcp->mct != 2) {\n        return OPJ_TRUE;\n    }\n\n    if (p_tcp->m_mct_decoding_matrix) {\n        if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {\n            opj_mct_data_t *new_mct_records;\n            p_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n\n            new_mct_records = (opj_mct_data_t *) opj_realloc(p_tcp->m_mct_records,\n                              p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));\n            if (! new_mct_records) {\n                opj_free(p_tcp->m_mct_records);\n                p_tcp->m_mct_records = NULL;\n                p_tcp->m_nb_max_mct_records = 0;\n                p_tcp->m_nb_mct_records = 0;\n                /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to setup mct encoding\\n\"); */\n                return OPJ_FALSE;\n            }\n            p_tcp->m_mct_records = new_mct_records;\n            l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n            memset(l_mct_deco_data, 0,\n                   (p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(\n                       opj_mct_data_t));\n        }\n        l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n        if (l_mct_deco_data->m_data) {\n            opj_free(l_mct_deco_data->m_data);\n            l_mct_deco_data->m_data = 00;\n        }\n\n        l_mct_deco_data->m_index = l_indix++;\n        l_mct_deco_data->m_array_type = MCT_TYPE_DECORRELATION;\n        l_mct_deco_data->m_element_type = MCT_TYPE_FLOAT;\n        l_nb_elem = p_image->numcomps * p_image->numcomps;\n        l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_deco_data->m_element_type];\n        l_mct_deco_data->m_data = (OPJ_BYTE*)opj_malloc(l_mct_size);\n\n        if (! l_mct_deco_data->m_data) {\n            return OPJ_FALSE;\n        }\n\n        j2k_mct_write_functions_from_float[l_mct_deco_data->m_element_type](\n            p_tcp->m_mct_decoding_matrix, l_mct_deco_data->m_data, l_nb_elem);\n\n        l_mct_deco_data->m_data_size = l_mct_size;\n        ++p_tcp->m_nb_mct_records;\n    }\n\n    if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {\n        opj_mct_data_t *new_mct_records;\n        p_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n        new_mct_records = (opj_mct_data_t *) opj_realloc(p_tcp->m_mct_records,\n                          p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));\n        if (! new_mct_records) {\n            opj_free(p_tcp->m_mct_records);\n            p_tcp->m_mct_records = NULL;\n            p_tcp->m_nb_max_mct_records = 0;\n            p_tcp->m_nb_mct_records = 0;\n            /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to setup mct encoding\\n\"); */\n            return OPJ_FALSE;\n        }\n        p_tcp->m_mct_records = new_mct_records;\n        l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n        memset(l_mct_offset_data, 0,\n               (p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(\n                   opj_mct_data_t));\n\n        if (l_mct_deco_data) {\n            l_mct_deco_data = l_mct_offset_data - 1;\n        }\n    }\n\n    l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n    if (l_mct_offset_data->m_data) {\n        opj_free(l_mct_offset_data->m_data);\n        l_mct_offset_data->m_data = 00;\n    }\n\n    l_mct_offset_data->m_index = l_indix++;\n    l_mct_offset_data->m_array_type = MCT_TYPE_OFFSET;\n    l_mct_offset_data->m_element_type = MCT_TYPE_FLOAT;\n    l_nb_elem = p_image->numcomps;\n    l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_offset_data->m_element_type];\n    l_mct_offset_data->m_data = (OPJ_BYTE*)opj_malloc(l_mct_size);\n\n    if (! l_mct_offset_data->m_data) {\n        return OPJ_FALSE;\n    }\n\n    l_data = (OPJ_FLOAT32*)opj_malloc(l_nb_elem * sizeof(OPJ_FLOAT32));\n    if (! l_data) {\n        opj_free(l_mct_offset_data->m_data);\n        l_mct_offset_data->m_data = 00;\n        return OPJ_FALSE;\n    }\n\n    l_tccp = p_tcp->tccps;\n    l_current_data = l_data;\n\n    for (i = 0; i < l_nb_elem; ++i) {\n        *(l_current_data++) = (OPJ_FLOAT32)(l_tccp->m_dc_level_shift);\n        ++l_tccp;\n    }\n\n    j2k_mct_write_functions_from_float[l_mct_offset_data->m_element_type](l_data,\n            l_mct_offset_data->m_data, l_nb_elem);\n\n    opj_free(l_data);\n\n    l_mct_offset_data->m_data_size = l_mct_size;\n\n    ++p_tcp->m_nb_mct_records;\n\n    if (p_tcp->m_nb_mcc_records == p_tcp->m_nb_max_mcc_records) {\n        opj_simple_mcc_decorrelation_data_t *new_mcc_records;\n        p_tcp->m_nb_max_mcc_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n        new_mcc_records = (opj_simple_mcc_decorrelation_data_t *) opj_realloc(\n                              p_tcp->m_mcc_records, p_tcp->m_nb_max_mcc_records * sizeof(\n                                  opj_simple_mcc_decorrelation_data_t));\n        if (! new_mcc_records) {\n            opj_free(p_tcp->m_mcc_records);\n            p_tcp->m_mcc_records = NULL;\n            p_tcp->m_nb_max_mcc_records = 0;\n            p_tcp->m_nb_mcc_records = 0;\n            /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to setup mct encoding\\n\"); */\n            return OPJ_FALSE;\n        }\n        p_tcp->m_mcc_records = new_mcc_records;\n        l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;\n        memset(l_mcc_data, 0, (p_tcp->m_nb_max_mcc_records - p_tcp->m_nb_mcc_records) *\n               sizeof(opj_simple_mcc_decorrelation_data_t));\n\n    }\n\n    l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;\n    l_mcc_data->m_decorrelation_array = l_mct_deco_data;\n    l_mcc_data->m_is_irreversible = 1;\n    l_mcc_data->m_nb_comps = p_image->numcomps;\n    l_mcc_data->m_index = l_indix++;\n    l_mcc_data->m_offset_array = l_mct_offset_data;\n    ++p_tcp->m_nb_mcc_records;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t * p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager)\n{\n    /* add here initialization of cp\n       copy paste of setup_decoder */\n    (void)p_j2k;\n    (void)p_stream;\n    (void)p_manager;\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t * p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager)\n{\n    /* add here initialization of cp\n       copy paste of setup_encoder */\n    (void)p_j2k;\n    (void)p_stream;\n    (void)p_manager;\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager)\n{\n    OPJ_BOOL l_is_valid = OPJ_TRUE;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_stream);\n\n    /* STATE checking */\n    /* make sure the state is at 0 */\n    l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NONE);\n\n    /* POINTER validation */\n    /* make sure a p_j2k codec is present */\n    l_is_valid &= (p_j2k->m_procedure_list != 00);\n    /* make sure a validation list is present */\n    l_is_valid &= (p_j2k->m_validation_list != 00);\n\n    /* ISO 15444-1:2004 states between 1 & 33 (0 -> 32) */\n    /* 33 (32) would always fail the check below (if a cast to 64bits was done) */\n    /* FIXME Shall we change OPJ_J2K_MAXRLVLS to 32 ? */\n    if ((p_j2k->m_cp.tcps->tccps->numresolutions <= 0) ||\n            (p_j2k->m_cp.tcps->tccps->numresolutions > 32)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n        return OPJ_FALSE;\n    }\n\n    if ((p_j2k->m_cp.tdx) < (OPJ_UINT32)(1 <<\n                                         (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n        return OPJ_FALSE;\n    }\n\n    if ((p_j2k->m_cp.tdy) < (OPJ_UINT32)(1 <<\n                                         (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* PARAMETER VALIDATION */\n    return l_is_valid;\n}\n\nstatic OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager\n                                           )\n{\n    OPJ_BOOL l_is_valid = OPJ_TRUE;\n\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n\n    /* STATE checking */\n    /* make sure the state is at 0 */\n#ifdef TODO_MSD\n    l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_DEC_STATE_NONE);\n#endif\n    l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == 0x0000);\n\n    /* POINTER validation */\n    /* make sure a p_j2k codec is present */\n    /* make sure a procedure list is present */\n    l_is_valid &= (p_j2k->m_procedure_list != 00);\n    /* make sure a validation list is present */\n    l_is_valid &= (p_j2k->m_validation_list != 00);\n\n    /* PARAMETER VALIDATION */\n    return l_is_valid;\n}\n\nstatic OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 l_current_marker;\n    OPJ_UINT32 l_marker_size;\n    const opj_dec_memory_marker_handler_t * l_marker_handler = 00;\n    OPJ_BOOL l_has_siz = 0;\n    OPJ_BOOL l_has_cod = 0;\n    OPJ_BOOL l_has_qcd = 0;\n\n    /* preconditions */\n    assert(p_stream != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    /*  We enter in the main header */\n    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MHSOC;\n\n    /* Try to read the SOC marker, the codestream must begin with SOC marker */\n    if (! opj_j2k_read_soc(p_j2k, p_stream, p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Expected a SOC marker \\n\");\n        return OPJ_FALSE;\n    }\n\n    /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n    if (opj_stream_read_data(p_stream,\n                             p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* Read 2 bytes as the new marker ID */\n    opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                   &l_current_marker, 2);\n\n    /* Try to read until the SOT is detected */\n    while (l_current_marker != J2K_MS_SOT) {\n\n        /* Check if the current marker ID is valid */\n        if (l_current_marker < 0xff00) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"A marker ID was expected (0xff--) instead of %.8x\\n\", l_current_marker);\n            return OPJ_FALSE;\n        }\n\n        /* Get the marker handler from the marker ID */\n        l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);\n\n        /* Manage case where marker is unknown */\n        if (l_marker_handler->id == J2K_MS_UNK) {\n            if (! opj_j2k_read_unk(p_j2k, p_stream, &l_current_marker, p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Unknow marker have been detected and generated error.\\n\");\n                return OPJ_FALSE;\n            }\n\n            if (l_current_marker == J2K_MS_SOT) {\n                break;    /* SOT marker is detected main header is completely read */\n            } else { /* Get the marker handler from the marker ID */\n                l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);\n            }\n        }\n\n        if (l_marker_handler->id == J2K_MS_SIZ) {\n            /* Mark required SIZ marker as found */\n            l_has_siz = 1;\n        }\n        if (l_marker_handler->id == J2K_MS_COD) {\n            /* Mark required COD marker as found */\n            l_has_cod = 1;\n        }\n        if (l_marker_handler->id == J2K_MS_QCD) {\n            /* Mark required QCD marker as found */\n            l_has_qcd = 1;\n        }\n\n        /* Check if the marker is known and if it is the right place to find it */\n        if (!(p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Marker is not compliant with its position\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */\n        if (opj_stream_read_data(p_stream,\n                                 p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* read 2 bytes as the marker size */\n        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data, &l_marker_size,\n                       2);\n        if (l_marker_size < 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Invalid marker size\\n\");\n            return OPJ_FALSE;\n        }\n        l_marker_size -= 2; /* Subtract the size of the marker ID already read */\n\n        /* Check if the marker size is compatible with the header data size */\n        if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {\n            OPJ_BYTE *new_header_data = (OPJ_BYTE *) opj_realloc(\n                                            p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size);\n            if (! new_header_data) {\n                opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);\n                p_j2k->m_specific_param.m_decoder.m_header_data = NULL;\n                p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read header\\n\");\n                return OPJ_FALSE;\n            }\n            p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;\n            p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;\n        }\n\n        /* Try to read the rest of the marker segment from stream and copy them into the buffer */\n        if (opj_stream_read_data(p_stream,\n                                 p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size,\n                                 p_manager) != l_marker_size) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* Read the marker segment with the correct marker handler */\n        if (!(*(l_marker_handler->handler))(p_j2k,\n                                            p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size, p_manager)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Marker handler function failed to read the marker segment\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* Add the marker to the codestream index*/\n        if (OPJ_FALSE == opj_j2k_add_mhmarker(\n                    p_j2k->cstr_index,\n                    l_marker_handler->id,\n                    (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4,\n                    l_marker_size + 4)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n        if (opj_stream_read_data(p_stream,\n                                 p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* read 2 bytes as the new marker ID */\n        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                       &l_current_marker, 2);\n    }\n\n    if (l_has_siz == 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"required SIZ marker not found in main header\\n\");\n        return OPJ_FALSE;\n    }\n    if (l_has_cod == 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"required COD marker not found in main header\\n\");\n        return OPJ_FALSE;\n    }\n    if (l_has_qcd == 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"required QCD marker not found in main header\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (! opj_j2k_merge_ppm(&(p_j2k->m_cp), p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Failed to merge PPM data\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_event_msg(p_manager, EVT_INFO, \"Main header has been correctly decoded.\\n\");\n\n    /* Position of the last element if the main header */\n    p_j2k->cstr_index->main_head_end = (OPJ_UINT32) opj_stream_tell(p_stream) - 2;\n\n    /* Next step: read a tile-part header */\n    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_exec(opj_j2k_t * p_j2k,\n                             opj_procedure_list_t * p_procedure_list,\n                             opj_stream_private_t *p_stream,\n                             opj_event_mgr_t * p_manager)\n{\n    OPJ_BOOL(** l_procedure)(opj_j2k_t *, opj_stream_private_t *,\n                             opj_event_mgr_t *) = 00;\n    OPJ_BOOL l_result = OPJ_TRUE;\n    OPJ_UINT32 l_nb_proc, i;\n\n    /* preconditions*/\n    assert(p_procedure_list != 00);\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);\n    l_procedure = (OPJ_BOOL(**)(opj_j2k_t *, opj_stream_private_t *,\n                                opj_event_mgr_t *)) opj_procedure_list_get_first_procedure(p_procedure_list);\n\n    for (i = 0; i < l_nb_proc; ++i) {\n        l_result = l_result && ((*l_procedure)(p_j2k, p_stream, p_manager));\n        ++l_procedure;\n    }\n\n    /* and clear the procedure list at the end.*/\n    opj_procedure_list_clear(p_procedure_list);\n    return l_result;\n}\n\n/* FIXME DOC*/\nstatic OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager\n                                                       )\n{\n    opj_tcp_t * l_tcp = 00;\n    opj_tcp_t * l_default_tcp = 00;\n    OPJ_UINT32 l_nb_tiles;\n    OPJ_UINT32 i, j;\n    opj_tccp_t *l_current_tccp = 00;\n    OPJ_UINT32 l_tccp_size;\n    OPJ_UINT32 l_mct_size;\n    opj_image_t * l_image;\n    OPJ_UINT32 l_mcc_records_size, l_mct_records_size;\n    opj_mct_data_t * l_src_mct_rec, *l_dest_mct_rec;\n    opj_simple_mcc_decorrelation_data_t * l_src_mcc_rec, *l_dest_mcc_rec;\n    OPJ_UINT32 l_offset;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_stream);\n\n    l_image = p_j2k->m_private_image;\n    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n    l_tcp = p_j2k->m_cp.tcps;\n    l_tccp_size = l_image->numcomps * (OPJ_UINT32)sizeof(opj_tccp_t);\n    l_default_tcp = p_j2k->m_specific_param.m_decoder.m_default_tcp;\n    l_mct_size = l_image->numcomps * l_image->numcomps * (OPJ_UINT32)sizeof(\n                     OPJ_FLOAT32);\n\n    /* For each tile */\n    for (i = 0; i < l_nb_tiles; ++i) {\n        /* keep the tile-compo coding parameters pointer of the current tile coding parameters*/\n        l_current_tccp = l_tcp->tccps;\n        /*Copy default coding parameters into the current tile coding parameters*/\n        memcpy(l_tcp, l_default_tcp, sizeof(opj_tcp_t));\n        /* Initialize some values of the current tile coding parameters*/\n        l_tcp->cod = 0;\n        l_tcp->ppt = 0;\n        l_tcp->ppt_data = 00;\n        l_tcp->m_current_tile_part_number = -1;\n        /* Remove memory not owned by this tile in case of early error return. */\n        l_tcp->m_mct_decoding_matrix = 00;\n        l_tcp->m_nb_max_mct_records = 0;\n        l_tcp->m_mct_records = 00;\n        l_tcp->m_nb_max_mcc_records = 0;\n        l_tcp->m_mcc_records = 00;\n        /* Reconnect the tile-compo coding parameters pointer to the current tile coding parameters*/\n        l_tcp->tccps = l_current_tccp;\n\n        /* Get the mct_decoding_matrix of the dflt_tile_cp and copy them into the current tile cp*/\n        if (l_default_tcp->m_mct_decoding_matrix) {\n            l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(l_mct_size);\n            if (! l_tcp->m_mct_decoding_matrix) {\n                return OPJ_FALSE;\n            }\n            memcpy(l_tcp->m_mct_decoding_matrix, l_default_tcp->m_mct_decoding_matrix,\n                   l_mct_size);\n        }\n\n        /* Get the mct_record of the dflt_tile_cp and copy them into the current tile cp*/\n        l_mct_records_size = l_default_tcp->m_nb_max_mct_records * (OPJ_UINT32)sizeof(\n                                 opj_mct_data_t);\n        l_tcp->m_mct_records = (opj_mct_data_t*)opj_malloc(l_mct_records_size);\n        if (! l_tcp->m_mct_records) {\n            return OPJ_FALSE;\n        }\n        memcpy(l_tcp->m_mct_records, l_default_tcp->m_mct_records, l_mct_records_size);\n\n        /* Copy the mct record data from dflt_tile_cp to the current tile*/\n        l_src_mct_rec = l_default_tcp->m_mct_records;\n        l_dest_mct_rec = l_tcp->m_mct_records;\n\n        for (j = 0; j < l_default_tcp->m_nb_mct_records; ++j) {\n\n            if (l_src_mct_rec->m_data) {\n\n                l_dest_mct_rec->m_data = (OPJ_BYTE*) opj_malloc(l_src_mct_rec->m_data_size);\n                if (! l_dest_mct_rec->m_data) {\n                    return OPJ_FALSE;\n                }\n                memcpy(l_dest_mct_rec->m_data, l_src_mct_rec->m_data,\n                       l_src_mct_rec->m_data_size);\n            }\n\n            ++l_src_mct_rec;\n            ++l_dest_mct_rec;\n            /* Update with each pass to free exactly what has been allocated on early return. */\n            l_tcp->m_nb_max_mct_records += 1;\n        }\n\n        /* Get the mcc_record of the dflt_tile_cp and copy them into the current tile cp*/\n        l_mcc_records_size = l_default_tcp->m_nb_max_mcc_records * (OPJ_UINT32)sizeof(\n                                 opj_simple_mcc_decorrelation_data_t);\n        l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t*) opj_malloc(\n                                   l_mcc_records_size);\n        if (! l_tcp->m_mcc_records) {\n            return OPJ_FALSE;\n        }\n        memcpy(l_tcp->m_mcc_records, l_default_tcp->m_mcc_records, l_mcc_records_size);\n        l_tcp->m_nb_max_mcc_records = l_default_tcp->m_nb_max_mcc_records;\n\n        /* Copy the mcc record data from dflt_tile_cp to the current tile*/\n        l_src_mcc_rec = l_default_tcp->m_mcc_records;\n        l_dest_mcc_rec = l_tcp->m_mcc_records;\n\n        for (j = 0; j < l_default_tcp->m_nb_max_mcc_records; ++j) {\n\n            if (l_src_mcc_rec->m_decorrelation_array) {\n                l_offset = (OPJ_UINT32)(l_src_mcc_rec->m_decorrelation_array -\n                                        l_default_tcp->m_mct_records);\n                l_dest_mcc_rec->m_decorrelation_array = l_tcp->m_mct_records + l_offset;\n            }\n\n            if (l_src_mcc_rec->m_offset_array) {\n                l_offset = (OPJ_UINT32)(l_src_mcc_rec->m_offset_array -\n                                        l_default_tcp->m_mct_records);\n                l_dest_mcc_rec->m_offset_array = l_tcp->m_mct_records + l_offset;\n            }\n\n            ++l_src_mcc_rec;\n            ++l_dest_mcc_rec;\n        }\n\n        /* Copy all the dflt_tile_compo_cp to the current tile cp */\n        memcpy(l_current_tccp, l_default_tcp->tccps, l_tccp_size);\n\n        /* Move to next tile cp*/\n        ++l_tcp;\n    }\n\n    /* Create the current tile decoder*/\n    p_j2k->m_tcd = (opj_tcd_t*)opj_tcd_create(OPJ_TRUE); /* FIXME why a cast ? */\n    if (! p_j2k->m_tcd) {\n        return OPJ_FALSE;\n    }\n\n    if (!opj_tcd_init(p_j2k->m_tcd, l_image, &(p_j2k->m_cp), p_j2k->m_tp)) {\n        opj_tcd_destroy(p_j2k->m_tcd);\n        p_j2k->m_tcd = 00;\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic const opj_dec_memory_marker_handler_t * opj_j2k_get_marker_handler(\n    OPJ_UINT32 p_id)\n{\n    const opj_dec_memory_marker_handler_t *e;\n    for (e = j2k_memory_marker_handler_tab; e->id != 0; ++e) {\n        if (e->id == p_id) {\n            break; /* we find a handler corresponding to the marker ID*/\n        }\n    }\n    return e;\n}\n\nvoid opj_j2k_destroy(opj_j2k_t *p_j2k)\n{\n    if (p_j2k == 00) {\n        return;\n    }\n\n    if (p_j2k->m_is_decoder) {\n\n        if (p_j2k->m_specific_param.m_decoder.m_default_tcp != 00) {\n            opj_j2k_tcp_destroy(p_j2k->m_specific_param.m_decoder.m_default_tcp);\n            opj_free(p_j2k->m_specific_param.m_decoder.m_default_tcp);\n            p_j2k->m_specific_param.m_decoder.m_default_tcp = 00;\n        }\n\n        if (p_j2k->m_specific_param.m_decoder.m_header_data != 00) {\n            opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);\n            p_j2k->m_specific_param.m_decoder.m_header_data = 00;\n            p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;\n        }\n    } else {\n\n        if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = 00;\n        }\n\n        if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);\n            p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = 00;\n            p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = 00;\n        }\n\n        if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = 00;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n        }\n    }\n\n    opj_tcd_destroy(p_j2k->m_tcd);\n\n    opj_j2k_cp_destroy(&(p_j2k->m_cp));\n    memset(&(p_j2k->m_cp), 0, sizeof(opj_cp_t));\n\n    opj_procedure_list_destroy(p_j2k->m_procedure_list);\n    p_j2k->m_procedure_list = 00;\n\n    opj_procedure_list_destroy(p_j2k->m_validation_list);\n    p_j2k->m_procedure_list = 00;\n\n    j2k_destroy_cstr_index(p_j2k->cstr_index);\n    p_j2k->cstr_index = NULL;\n\n    opj_image_destroy(p_j2k->m_private_image);\n    p_j2k->m_private_image = NULL;\n\n    opj_image_destroy(p_j2k->m_output_image);\n    p_j2k->m_output_image = NULL;\n\n    opj_thread_pool_destroy(p_j2k->m_tp);\n    p_j2k->m_tp = NULL;\n\n    opj_free(p_j2k);\n}\n\nvoid j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind)\n{\n    if (p_cstr_ind) {\n\n        if (p_cstr_ind->marker) {\n            opj_free(p_cstr_ind->marker);\n            p_cstr_ind->marker = NULL;\n        }\n\n        if (p_cstr_ind->tile_index) {\n            OPJ_UINT32 it_tile = 0;\n\n            for (it_tile = 0; it_tile < p_cstr_ind->nb_of_tiles; it_tile++) {\n\n                if (p_cstr_ind->tile_index[it_tile].packet_index) {\n                    opj_free(p_cstr_ind->tile_index[it_tile].packet_index);\n                    p_cstr_ind->tile_index[it_tile].packet_index = NULL;\n                }\n\n                if (p_cstr_ind->tile_index[it_tile].tp_index) {\n                    opj_free(p_cstr_ind->tile_index[it_tile].tp_index);\n                    p_cstr_ind->tile_index[it_tile].tp_index = NULL;\n                }\n\n                if (p_cstr_ind->tile_index[it_tile].marker) {\n                    opj_free(p_cstr_ind->tile_index[it_tile].marker);\n                    p_cstr_ind->tile_index[it_tile].marker = NULL;\n\n                }\n            }\n\n            opj_free(p_cstr_ind->tile_index);\n            p_cstr_ind->tile_index = NULL;\n        }\n\n        opj_free(p_cstr_ind);\n    }\n}\n\nstatic void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp)\n{\n    if (p_tcp == 00) {\n        return;\n    }\n\n    if (p_tcp->ppt_markers != 00) {\n        OPJ_UINT32 i;\n        for (i = 0U; i < p_tcp->ppt_markers_count; ++i) {\n            if (p_tcp->ppt_markers[i].m_data != NULL) {\n                opj_free(p_tcp->ppt_markers[i].m_data);\n            }\n        }\n        p_tcp->ppt_markers_count = 0U;\n        opj_free(p_tcp->ppt_markers);\n        p_tcp->ppt_markers = NULL;\n    }\n\n    if (p_tcp->ppt_buffer != 00) {\n        opj_free(p_tcp->ppt_buffer);\n        p_tcp->ppt_buffer = 00;\n    }\n\n    if (p_tcp->tccps != 00) {\n        opj_free(p_tcp->tccps);\n        p_tcp->tccps = 00;\n    }\n\n    if (p_tcp->m_mct_coding_matrix != 00) {\n        opj_free(p_tcp->m_mct_coding_matrix);\n        p_tcp->m_mct_coding_matrix = 00;\n    }\n\n    if (p_tcp->m_mct_decoding_matrix != 00) {\n        opj_free(p_tcp->m_mct_decoding_matrix);\n        p_tcp->m_mct_decoding_matrix = 00;\n    }\n\n    if (p_tcp->m_mcc_records) {\n        opj_free(p_tcp->m_mcc_records);\n        p_tcp->m_mcc_records = 00;\n        p_tcp->m_nb_max_mcc_records = 0;\n        p_tcp->m_nb_mcc_records = 0;\n    }\n\n    if (p_tcp->m_mct_records) {\n        opj_mct_data_t * l_mct_data = p_tcp->m_mct_records;\n        OPJ_UINT32 i;\n\n        for (i = 0; i < p_tcp->m_nb_mct_records; ++i) {\n            if (l_mct_data->m_data) {\n                opj_free(l_mct_data->m_data);\n                l_mct_data->m_data = 00;\n            }\n\n            ++l_mct_data;\n        }\n\n        opj_free(p_tcp->m_mct_records);\n        p_tcp->m_mct_records = 00;\n    }\n\n    if (p_tcp->mct_norms != 00) {\n        opj_free(p_tcp->mct_norms);\n        p_tcp->mct_norms = 00;\n    }\n\n    opj_j2k_tcp_data_destroy(p_tcp);\n\n}\n\nstatic void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp)\n{\n    if (p_tcp->m_data) {\n        opj_free(p_tcp->m_data);\n        p_tcp->m_data = NULL;\n        p_tcp->m_data_size = 0;\n    }\n}\n\nstatic void opj_j2k_cp_destroy(opj_cp_t *p_cp)\n{\n    OPJ_UINT32 l_nb_tiles;\n    opj_tcp_t * l_current_tile = 00;\n\n    if (p_cp == 00) {\n        return;\n    }\n    if (p_cp->tcps != 00) {\n        OPJ_UINT32 i;\n        l_current_tile = p_cp->tcps;\n        l_nb_tiles = p_cp->th * p_cp->tw;\n\n        for (i = 0U; i < l_nb_tiles; ++i) {\n            opj_j2k_tcp_destroy(l_current_tile);\n            ++l_current_tile;\n        }\n        opj_free(p_cp->tcps);\n        p_cp->tcps = 00;\n    }\n    if (p_cp->ppm_markers != 00) {\n        OPJ_UINT32 i;\n        for (i = 0U; i < p_cp->ppm_markers_count; ++i) {\n            if (p_cp->ppm_markers[i].m_data != NULL) {\n                opj_free(p_cp->ppm_markers[i].m_data);\n            }\n        }\n        p_cp->ppm_markers_count = 0U;\n        opj_free(p_cp->ppm_markers);\n        p_cp->ppm_markers = NULL;\n    }\n    opj_free(p_cp->ppm_buffer);\n    p_cp->ppm_buffer = 00;\n    p_cp->ppm_data =\n        NULL; /* ppm_data belongs to the allocated buffer pointed by ppm_buffer */\n    opj_free(p_cp->comment);\n    p_cp->comment = 00;\n    if (! p_cp->m_is_decoder) {\n        opj_free(p_cp->m_specific_param.m_enc.m_matrice);\n        p_cp->m_specific_param.m_enc.m_matrice = 00;\n    }\n}\n\nstatic OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t\n        *p_stream, OPJ_UINT32 tile_no, OPJ_BOOL* p_correction_needed,\n        opj_event_mgr_t * p_manager)\n{\n    OPJ_BYTE   l_header_data[10];\n    OPJ_OFF_T  l_stream_pos_backup;\n    OPJ_UINT32 l_current_marker;\n    OPJ_UINT32 l_marker_size;\n    OPJ_UINT32 l_tile_no, l_tot_len, l_current_part, l_num_parts;\n\n    /* initialize to no correction needed */\n    *p_correction_needed = OPJ_FALSE;\n\n    if (!opj_stream_has_seek(p_stream)) {\n        /* We can't do much in this case, seek is needed */\n        return OPJ_TRUE;\n    }\n\n    l_stream_pos_backup = opj_stream_tell(p_stream);\n    if (l_stream_pos_backup == -1) {\n        /* let's do nothing */\n        return OPJ_TRUE;\n    }\n\n    for (;;) {\n        /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n        if (opj_stream_read_data(p_stream, l_header_data, 2, p_manager) != 2) {\n            /* assume all is OK */\n            if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n                return OPJ_FALSE;\n            }\n            return OPJ_TRUE;\n        }\n\n        /* Read 2 bytes from buffer as the new marker ID */\n        opj_read_bytes(l_header_data, &l_current_marker, 2);\n\n        if (l_current_marker != J2K_MS_SOT) {\n            /* assume all is OK */\n            if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n                return OPJ_FALSE;\n            }\n            return OPJ_TRUE;\n        }\n\n        /* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */\n        if (opj_stream_read_data(p_stream, l_header_data, 2, p_manager) != 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* Read 2 bytes from the buffer as the marker size */\n        opj_read_bytes(l_header_data, &l_marker_size, 2);\n\n        /* Check marker size for SOT Marker */\n        if (l_marker_size != 10) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Inconsistent marker size\\n\");\n            return OPJ_FALSE;\n        }\n        l_marker_size -= 2;\n\n        if (opj_stream_read_data(p_stream, l_header_data, l_marker_size,\n                                 p_manager) != l_marker_size) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        if (! opj_j2k_get_sot_values(l_header_data, l_marker_size, &l_tile_no,\n                                     &l_tot_len, &l_current_part, &l_num_parts, p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        if (l_tile_no == tile_no) {\n            /* we found what we were looking for */\n            break;\n        }\n\n        if ((l_tot_len == 0U) || (l_tot_len < 14U)) {\n            /* last SOT until EOC or invalid Psot value */\n            /* assume all is OK */\n            if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n                return OPJ_FALSE;\n            }\n            return OPJ_TRUE;\n        }\n        l_tot_len -= 12U;\n        /* look for next SOT marker */\n        if (opj_stream_skip(p_stream, (OPJ_OFF_T)(l_tot_len),\n                            p_manager) != (OPJ_OFF_T)(l_tot_len)) {\n            /* assume all is OK */\n            if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n                return OPJ_FALSE;\n            }\n            return OPJ_TRUE;\n        }\n    }\n\n    /* check for correction */\n    if (l_current_part == l_num_parts) {\n        *p_correction_needed = OPJ_TRUE;\n    }\n\n    if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n        return OPJ_FALSE;\n    }\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t * p_j2k,\n                                  OPJ_UINT32 * p_tile_index,\n                                  OPJ_UINT32 * p_data_size,\n                                  OPJ_INT32 * p_tile_x0, OPJ_INT32 * p_tile_y0,\n                                  OPJ_INT32 * p_tile_x1, OPJ_INT32 * p_tile_y1,\n                                  OPJ_UINT32 * p_nb_comps,\n                                  OPJ_BOOL * p_go_on,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 l_current_marker = J2K_MS_SOT;\n    OPJ_UINT32 l_marker_size;\n    const opj_dec_memory_marker_handler_t * l_marker_handler = 00;\n    opj_tcp_t * l_tcp = NULL;\n\n    /* preconditions */\n    assert(p_stream != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    /* Reach the End Of Codestream ?*/\n    if (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_EOC) {\n        l_current_marker = J2K_MS_EOC;\n    }\n    /* We need to encounter a SOT marker (a new tile-part header) */\n    else if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_TPHSOT) {\n        return OPJ_FALSE;\n    }\n\n    /* Read into the codestream until reach the EOC or ! can_decode ??? FIXME */\n    while ((!p_j2k->m_specific_param.m_decoder.m_can_decode) &&\n            (l_current_marker != J2K_MS_EOC)) {\n\n        /* Try to read until the Start Of Data is detected */\n        while (l_current_marker != J2K_MS_SOD) {\n\n            if (opj_stream_get_number_byte_left(p_stream) == 0) {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                break;\n            }\n\n            /* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */\n            if (opj_stream_read_data(p_stream,\n                                     p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* Read 2 bytes from the buffer as the marker size */\n            opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data, &l_marker_size,\n                           2);\n\n            /* Check marker size (does not include marker ID but includes marker size) */\n            if (l_marker_size < 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Inconsistent marker size\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* cf. https://code.google.com/p/openjpeg/issues/detail?id=226 */\n            if (l_current_marker == 0x8080 &&\n                    opj_stream_get_number_byte_left(p_stream) == 0) {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                break;\n            }\n\n            /* Why this condition? FIXME */\n            if (p_j2k->m_specific_param.m_decoder.m_state & J2K_STATE_TPH) {\n                p_j2k->m_specific_param.m_decoder.m_sot_length -= (l_marker_size + 2);\n            }\n            l_marker_size -= 2; /* Subtract the size of the marker ID already read */\n\n            /* Get the marker handler from the marker ID */\n            l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);\n\n            /* Check if the marker is known and if it is the right place to find it */\n            if (!(p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Marker is not compliant with its position\\n\");\n                return OPJ_FALSE;\n            }\n            /* FIXME manage case of unknown marker as in the main header ? */\n\n            /* Check if the marker size is compatible with the header data size */\n            if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {\n                OPJ_BYTE *new_header_data = NULL;\n                /* If we are here, this means we consider this marker as known & we will read it */\n                /* Check enough bytes left in stream before allocation */\n                if ((OPJ_OFF_T)l_marker_size >  opj_stream_get_number_byte_left(p_stream)) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"Marker size inconsistent with stream length\\n\");\n                    return OPJ_FALSE;\n                }\n                new_header_data = (OPJ_BYTE *) opj_realloc(\n                                      p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size);\n                if (! new_header_data) {\n                    opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);\n                    p_j2k->m_specific_param.m_decoder.m_header_data = NULL;\n                    p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;\n                    opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read header\\n\");\n                    return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;\n                p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;\n            }\n\n            /* Try to read the rest of the marker segment from stream and copy them into the buffer */\n            if (opj_stream_read_data(p_stream,\n                                     p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size,\n                                     p_manager) != l_marker_size) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                return OPJ_FALSE;\n            }\n\n            if (!l_marker_handler->handler) {\n                /* See issue #175 */\n                opj_event_msg(p_manager, EVT_ERROR, \"Not sure how that happened.\\n\");\n                return OPJ_FALSE;\n            }\n            /* Read the marker segment with the correct marker handler */\n            if (!(*(l_marker_handler->handler))(p_j2k,\n                                                p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size, p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Fail to read the current marker segment (%#x)\\n\", l_current_marker);\n                return OPJ_FALSE;\n            }\n\n            /* Add the marker to the codestream index*/\n            if (OPJ_FALSE == opj_j2k_add_tlmarker(p_j2k->m_current_tile_number,\n                                                  p_j2k->cstr_index,\n                                                  l_marker_handler->id,\n                                                  (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4,\n                                                  l_marker_size + 4)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add tl marker\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* Keep the position of the last SOT marker read */\n            if (l_marker_handler->id == J2K_MS_SOT) {\n                OPJ_UINT32 sot_pos = (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4\n                                     ;\n                if (sot_pos > p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos) {\n                    p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = sot_pos;\n                }\n            }\n\n            if (p_j2k->m_specific_param.m_decoder.m_skip_data) {\n                /* Skip the rest of the tile part header*/\n                if (opj_stream_skip(p_stream, p_j2k->m_specific_param.m_decoder.m_sot_length,\n                                    p_manager) != p_j2k->m_specific_param.m_decoder.m_sot_length) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                    return OPJ_FALSE;\n                }\n                l_current_marker = J2K_MS_SOD; /* Normally we reached a SOD */\n            } else {\n                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer*/\n                if (opj_stream_read_data(p_stream,\n                                         p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                    return OPJ_FALSE;\n                }\n                /* Read 2 bytes from the buffer as the new marker ID */\n                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                               &l_current_marker, 2);\n            }\n        }\n        if (opj_stream_get_number_byte_left(p_stream) == 0\n                && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC) {\n            break;\n        }\n\n        /* If we didn't skip data before, we need to read the SOD marker*/\n        if (! p_j2k->m_specific_param.m_decoder.m_skip_data) {\n            /* Try to read the SOD marker and skip data ? FIXME */\n            if (! opj_j2k_read_sod(p_j2k, p_stream, p_manager)) {\n                return OPJ_FALSE;\n            }\n            if (p_j2k->m_specific_param.m_decoder.m_can_decode &&\n                    !p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked) {\n                /* Issue 254 */\n                OPJ_BOOL l_correction_needed;\n\n                p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = 1;\n                if (!opj_j2k_need_nb_tile_parts_correction(p_stream,\n                        p_j2k->m_current_tile_number, &l_correction_needed, p_manager)) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"opj_j2k_apply_nb_tile_parts_correction error\\n\");\n                    return OPJ_FALSE;\n                }\n                if (l_correction_needed) {\n                    OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;\n                    OPJ_UINT32 l_tile_no;\n\n                    p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n                    p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction = 1;\n                    /* correct tiles */\n                    for (l_tile_no = 0U; l_tile_no < l_nb_tiles; ++l_tile_no) {\n                        if (p_j2k->m_cp.tcps[l_tile_no].m_nb_tile_parts != 0U) {\n                            p_j2k->m_cp.tcps[l_tile_no].m_nb_tile_parts += 1;\n                        }\n                    }\n                    opj_event_msg(p_manager, EVT_WARNING,\n                                  \"Non conformant codestream TPsot==TNsot.\\n\");\n                }\n            }\n            if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {\n                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n                if (opj_stream_read_data(p_stream,\n                                         p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                    return OPJ_FALSE;\n                }\n\n                /* Read 2 bytes from buffer as the new marker ID */\n                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                               &l_current_marker, 2);\n            }\n        } else {\n            /* Indicate we will try to read a new tile-part header*/\n            p_j2k->m_specific_param.m_decoder.m_skip_data = 0;\n            p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n            p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n\n            /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n            if (opj_stream_read_data(p_stream,\n                                     p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* Read 2 bytes from buffer as the new marker ID */\n            opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                           &l_current_marker, 2);\n        }\n    }\n\n    /* Current marker is the EOC marker ?*/\n    if (l_current_marker == J2K_MS_EOC) {\n        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_EOC;\n    }\n\n    /* FIXME DOC ???*/\n    if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {\n        OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n        l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;\n\n        while ((p_j2k->m_current_tile_number < l_nb_tiles) && (l_tcp->m_data == 00)) {\n            ++p_j2k->m_current_tile_number;\n            ++l_tcp;\n        }\n\n        if (p_j2k->m_current_tile_number == l_nb_tiles) {\n            *p_go_on = OPJ_FALSE;\n            return OPJ_TRUE;\n        }\n    }\n\n    if (! opj_j2k_merge_ppt(p_j2k->m_cp.tcps + p_j2k->m_current_tile_number,\n                            p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Failed to merge PPT data\\n\");\n        return OPJ_FALSE;\n    }\n    /*FIXME ???*/\n    if (! opj_tcd_init_decode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number,\n                                   p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_event_msg(p_manager, EVT_INFO, \"Header of tile %d / %d has been read.\\n\",\n                  p_j2k->m_current_tile_number + 1, (p_j2k->m_cp.th * p_j2k->m_cp.tw));\n\n    *p_tile_index = p_j2k->m_current_tile_number;\n    *p_go_on = OPJ_TRUE;\n    *p_data_size = opj_tcd_get_decoded_tile_size(p_j2k->m_tcd);\n    if (*p_data_size == UINT_MAX) {\n        return OPJ_FALSE;\n    }\n    *p_tile_x0 = p_j2k->m_tcd->tcd_image->tiles->x0;\n    *p_tile_y0 = p_j2k->m_tcd->tcd_image->tiles->y0;\n    *p_tile_x1 = p_j2k->m_tcd->tcd_image->tiles->x1;\n    *p_tile_y1 = p_j2k->m_tcd->tcd_image->tiles->y1;\n    *p_nb_comps = p_j2k->m_tcd->tcd_image->tiles->numcomps;\n\n    p_j2k->m_specific_param.m_decoder.m_state |= J2K_STATE_DATA;\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_decode_tile(opj_j2k_t * p_j2k,\n                             OPJ_UINT32 p_tile_index,\n                             OPJ_BYTE * p_data,\n                             OPJ_UINT32 p_data_size,\n                             opj_stream_private_t *p_stream,\n                             opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 l_current_marker;\n    OPJ_BYTE l_data [2];\n    opj_tcp_t * l_tcp;\n\n    /* preconditions */\n    assert(p_stream != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (!(p_j2k->m_specific_param.m_decoder.m_state & J2K_STATE_DATA)\n            || (p_tile_index != p_j2k->m_current_tile_number)) {\n        return OPJ_FALSE;\n    }\n\n    l_tcp = &(p_j2k->m_cp.tcps[p_tile_index]);\n    if (! l_tcp->m_data) {\n        opj_j2k_tcp_destroy(l_tcp);\n        return OPJ_FALSE;\n    }\n\n    if (! opj_tcd_decode_tile(p_j2k->m_tcd,\n                              l_tcp->m_data,\n                              l_tcp->m_data_size,\n                              p_tile_index,\n                              p_j2k->cstr_index, p_manager)) {\n        opj_j2k_tcp_destroy(l_tcp);\n        p_j2k->m_specific_param.m_decoder.m_state |= J2K_STATE_ERR;\n        opj_event_msg(p_manager, EVT_ERROR, \"Failed to decode.\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* p_data can be set to NULL when the call will take care of using */\n    /* itself the TCD data. This is typically the case for whole single */\n    /* tile decoding optimization. */\n    if (p_data != NULL) {\n        if (! opj_tcd_update_tile_data(p_j2k->m_tcd, p_data, p_data_size)) {\n            return OPJ_FALSE;\n        }\n\n        /* To avoid to destroy the tcp which can be useful when we try to decode a tile decoded before (cf j2k_random_tile_access)\n        * we destroy just the data which will be re-read in read_tile_header*/\n        /*opj_j2k_tcp_destroy(l_tcp);\n        p_j2k->m_tcd->tcp = 0;*/\n        opj_j2k_tcp_data_destroy(l_tcp);\n    }\n\n    p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n    p_j2k->m_specific_param.m_decoder.m_state &= (~(OPJ_UINT32)J2K_STATE_DATA);\n\n    if (opj_stream_get_number_byte_left(p_stream) == 0\n            && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC) {\n        return OPJ_TRUE;\n    }\n\n    if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_EOC) {\n        if (opj_stream_read_data(p_stream, l_data, 2, p_manager) != 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        opj_read_bytes(l_data, &l_current_marker, 2);\n\n        if (l_current_marker == J2K_MS_EOC) {\n            p_j2k->m_current_tile_number = 0;\n            p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_EOC;\n        } else if (l_current_marker != J2K_MS_SOT) {\n            if (opj_stream_get_number_byte_left(p_stream) == 0) {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                opj_event_msg(p_manager, EVT_WARNING, \"Stream does not end with EOC\\n\");\n                return OPJ_TRUE;\n            }\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short, expected SOT\\n\");\n            return OPJ_FALSE;\n        }\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t * p_tcd, OPJ_BYTE * p_data,\n        opj_image_t* p_output_image)\n{\n    OPJ_UINT32 i, j, k = 0;\n    OPJ_UINT32 l_width_src, l_height_src;\n    OPJ_UINT32 l_width_dest, l_height_dest;\n    OPJ_INT32 l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src;\n    OPJ_SIZE_T l_start_offset_src, l_line_offset_src, l_end_offset_src ;\n    OPJ_UINT32 l_start_x_dest, l_start_y_dest;\n    OPJ_UINT32 l_x0_dest, l_y0_dest, l_x1_dest, l_y1_dest;\n    OPJ_SIZE_T l_start_offset_dest, l_line_offset_dest;\n\n    opj_image_comp_t * l_img_comp_src = 00;\n    opj_image_comp_t * l_img_comp_dest = 00;\n\n    opj_tcd_tilecomp_t * l_tilec = 00;\n    opj_image_t * l_image_src = 00;\n    OPJ_UINT32 l_size_comp, l_remaining;\n    OPJ_INT32 * l_dest_ptr;\n    opj_tcd_resolution_t* l_res = 00;\n\n    l_tilec = p_tcd->tcd_image->tiles->comps;\n    l_image_src = p_tcd->image;\n    l_img_comp_src = l_image_src->comps;\n\n    l_img_comp_dest = p_output_image->comps;\n\n    for (i = 0; i < l_image_src->numcomps; i++) {\n\n        /* Allocate output component buffer if necessary */\n        if (!l_img_comp_dest->data) {\n            OPJ_SIZE_T l_width = l_img_comp_dest->w;\n            OPJ_SIZE_T l_height = l_img_comp_dest->h;\n\n            if ((l_height == 0U) || (l_width > (SIZE_MAX / l_height)) ||\n                    l_width * l_height > SIZE_MAX / sizeof(OPJ_INT32)) {\n                /* would overflow */\n                return OPJ_FALSE;\n            }\n            l_img_comp_dest->data = (OPJ_INT32*) opj_image_data_alloc(l_width * l_height *\n                                    sizeof(OPJ_INT32));\n            if (! l_img_comp_dest->data) {\n                return OPJ_FALSE;\n            }\n            /* Do we really need this memset ? */\n            memset(l_img_comp_dest->data, 0, l_width * l_height * sizeof(OPJ_INT32));\n        }\n\n        /* Copy info from decoded comp image to output image */\n        l_img_comp_dest->resno_decoded = l_img_comp_src->resno_decoded;\n\n        /*-----*/\n        /* Compute the precision of the output buffer */\n        l_size_comp = l_img_comp_src->prec >> 3; /*(/ 8)*/\n        l_remaining = l_img_comp_src->prec & 7;  /* (%8) */\n        l_res = l_tilec->resolutions + l_img_comp_src->resno_decoded;\n\n        if (l_remaining) {\n            ++l_size_comp;\n        }\n\n        if (l_size_comp == 3) {\n            l_size_comp = 4;\n        }\n        /*-----*/\n\n        /* Current tile component size*/\n        /*if (i == 0) {\n        fprintf(stdout, \"SRC: l_res_x0=%d, l_res_x1=%d, l_res_y0=%d, l_res_y1=%d\\n\",\n                        l_res->x0, l_res->x1, l_res->y0, l_res->y1);\n        }*/\n\n        l_width_src = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n        l_height_src = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n\n        /* Border of the current output component*/\n        l_x0_dest = opj_uint_ceildivpow2(l_img_comp_dest->x0, l_img_comp_dest->factor);\n        l_y0_dest = opj_uint_ceildivpow2(l_img_comp_dest->y0, l_img_comp_dest->factor);\n        l_x1_dest = l_x0_dest +\n                    l_img_comp_dest->w; /* can't overflow given that image->x1 is uint32 */\n        l_y1_dest = l_y0_dest + l_img_comp_dest->h;\n\n        /*if (i == 0) {\n        fprintf(stdout, \"DEST: l_x0_dest=%d, l_x1_dest=%d, l_y0_dest=%d, l_y1_dest=%d (%d)\\n\",\n                        l_x0_dest, l_x1_dest, l_y0_dest, l_y1_dest, l_img_comp_dest->factor );\n        }*/\n\n        /*-----*/\n        /* Compute the area (l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src)\n         * of the input buffer (decoded tile component) which will be move\n         * in the output buffer. Compute the area of the output buffer (l_start_x_dest,\n         * l_start_y_dest, l_width_dest, l_height_dest)  which will be modified\n         * by this input area.\n         * */\n        assert(l_res->x0 >= 0);\n        assert(l_res->x1 >= 0);\n        if (l_x0_dest < (OPJ_UINT32)l_res->x0) {\n            l_start_x_dest = (OPJ_UINT32)l_res->x0 - l_x0_dest;\n            l_offset_x0_src = 0;\n\n            if (l_x1_dest >= (OPJ_UINT32)l_res->x1) {\n                l_width_dest = l_width_src;\n                l_offset_x1_src = 0;\n            } else {\n                l_width_dest = l_x1_dest - (OPJ_UINT32)l_res->x0 ;\n                l_offset_x1_src = (OPJ_INT32)(l_width_src - l_width_dest);\n            }\n        } else {\n            l_start_x_dest = 0U;\n            l_offset_x0_src = (OPJ_INT32)l_x0_dest - l_res->x0;\n\n            if (l_x1_dest >= (OPJ_UINT32)l_res->x1) {\n                l_width_dest = l_width_src - (OPJ_UINT32)l_offset_x0_src;\n                l_offset_x1_src = 0;\n            } else {\n                l_width_dest = l_img_comp_dest->w ;\n                l_offset_x1_src = l_res->x1 - (OPJ_INT32)l_x1_dest;\n            }\n        }\n\n        if (l_y0_dest < (OPJ_UINT32)l_res->y0) {\n            l_start_y_dest = (OPJ_UINT32)l_res->y0 - l_y0_dest;\n            l_offset_y0_src = 0;\n\n            if (l_y1_dest >= (OPJ_UINT32)l_res->y1) {\n                l_height_dest = l_height_src;\n                l_offset_y1_src = 0;\n            } else {\n                l_height_dest = l_y1_dest - (OPJ_UINT32)l_res->y0 ;\n                l_offset_y1_src = (OPJ_INT32)(l_height_src - l_height_dest);\n            }\n        } else {\n            l_start_y_dest = 0U;\n            l_offset_y0_src = (OPJ_INT32)l_y0_dest - l_res->y0;\n\n            if (l_y1_dest >= (OPJ_UINT32)l_res->y1) {\n                l_height_dest = l_height_src - (OPJ_UINT32)l_offset_y0_src;\n                l_offset_y1_src = 0;\n            } else {\n                l_height_dest = l_img_comp_dest->h ;\n                l_offset_y1_src = l_res->y1 - (OPJ_INT32)l_y1_dest;\n            }\n        }\n\n        if ((l_offset_x0_src < 0) || (l_offset_y0_src < 0) || (l_offset_x1_src < 0) ||\n                (l_offset_y1_src < 0)) {\n            return OPJ_FALSE;\n        }\n        /* testcase 2977.pdf.asan.67.2198 */\n        if ((OPJ_INT32)l_width_dest < 0 || (OPJ_INT32)l_height_dest < 0) {\n            return OPJ_FALSE;\n        }\n        /*-----*/\n\n        /* Compute the input buffer offset */\n        l_start_offset_src = (OPJ_SIZE_T)l_offset_x0_src + (OPJ_SIZE_T)l_offset_y0_src\n                             * (OPJ_SIZE_T)l_width_src;\n        l_line_offset_src  = (OPJ_SIZE_T)l_offset_x1_src + (OPJ_SIZE_T)l_offset_x0_src;\n        l_end_offset_src   = (OPJ_SIZE_T)l_offset_y1_src * (OPJ_SIZE_T)l_width_src -\n                             (OPJ_SIZE_T)l_offset_x0_src;\n\n        /* Compute the output buffer offset */\n        l_start_offset_dest = (OPJ_SIZE_T)l_start_x_dest + (OPJ_SIZE_T)l_start_y_dest\n                              * (OPJ_SIZE_T)l_img_comp_dest->w;\n        l_line_offset_dest  = (OPJ_SIZE_T)l_img_comp_dest->w - (OPJ_SIZE_T)l_width_dest;\n\n        /* Move the output buffer to the first place where we will write*/\n        l_dest_ptr = l_img_comp_dest->data + l_start_offset_dest;\n\n        /*if (i == 0) {\n                fprintf(stdout, \"COMPO[%d]:\\n\",i);\n                fprintf(stdout, \"SRC: l_start_x_src=%d, l_start_y_src=%d, l_width_src=%d, l_height_src=%d\\n\"\n                                \"\\t tile offset:%d, %d, %d, %d\\n\"\n                                \"\\t buffer offset: %d; %d, %d\\n\",\n                                l_res->x0, l_res->y0, l_width_src, l_height_src,\n                                l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src,\n                                l_start_offset_src, l_line_offset_src, l_end_offset_src);\n\n                fprintf(stdout, \"DEST: l_start_x_dest=%d, l_start_y_dest=%d, l_width_dest=%d, l_height_dest=%d\\n\"\n                                \"\\t start offset: %d, line offset= %d\\n\",\n                                l_start_x_dest, l_start_y_dest, l_width_dest, l_height_dest, l_start_offset_dest, l_line_offset_dest);\n        }*/\n\n        switch (l_size_comp) {\n        case 1: {\n            OPJ_CHAR * l_src_ptr = (OPJ_CHAR*) p_data;\n            l_src_ptr += l_start_offset_src; /* Move to the first place where we will read*/\n\n            if (l_img_comp_src->sgnd) {\n                for (j = 0 ; j < l_height_dest ; ++j) {\n                    for (k = 0 ; k < l_width_dest ; ++k) {\n                        *(l_dest_ptr++) = (OPJ_INT32)(*\n                                                      (l_src_ptr++));  /* Copy only the data needed for the output image */\n                    }\n\n                    l_dest_ptr +=\n                        l_line_offset_dest; /* Move to the next place where we will write */\n                    l_src_ptr += l_line_offset_src ; /* Move to the next place where we will read */\n                }\n            } else {\n                for (j = 0 ; j < l_height_dest ; ++j) {\n                    for (k = 0 ; k < l_width_dest ; ++k) {\n                        *(l_dest_ptr++) = (OPJ_INT32)((*(l_src_ptr++)) & 0xff);\n                    }\n\n                    l_dest_ptr += l_line_offset_dest;\n                    l_src_ptr += l_line_offset_src;\n                }\n            }\n\n            l_src_ptr +=\n                l_end_offset_src; /* Move to the end of this component-part of the input buffer */\n            p_data = (OPJ_BYTE*)\n                     l_src_ptr; /* Keep the current position for the next component-part */\n        }\n        break;\n        case 2: {\n            OPJ_INT16 * l_src_ptr = (OPJ_INT16 *) p_data;\n            l_src_ptr += l_start_offset_src;\n\n            if (l_img_comp_src->sgnd) {\n                for (j = 0; j < l_height_dest; ++j) {\n                    for (k = 0; k < l_width_dest; ++k) {\n                        OPJ_INT16 val;\n                        memcpy(&val, l_src_ptr, sizeof(val));\n                        l_src_ptr ++;\n                        *(l_dest_ptr++) = val;\n                    }\n\n                    l_dest_ptr += l_line_offset_dest;\n                    l_src_ptr += l_line_offset_src ;\n                }\n            } else {\n                for (j = 0; j < l_height_dest; ++j) {\n                    for (k = 0; k < l_width_dest; ++k) {\n                        OPJ_INT16 val;\n                        memcpy(&val, l_src_ptr, sizeof(val));\n                        l_src_ptr ++;\n                        *(l_dest_ptr++) = val & 0xffff;\n                    }\n\n                    l_dest_ptr += l_line_offset_dest;\n                    l_src_ptr += l_line_offset_src ;\n                }\n            }\n\n            l_src_ptr += l_end_offset_src;\n            p_data = (OPJ_BYTE*) l_src_ptr;\n        }\n        break;\n        case 4: {\n            OPJ_INT32 * l_src_ptr = (OPJ_INT32 *) p_data;\n            l_src_ptr += l_start_offset_src;\n\n            for (j = 0; j < l_height_dest; ++j) {\n                memcpy(l_dest_ptr, l_src_ptr, l_width_dest * sizeof(OPJ_INT32));\n                l_dest_ptr += l_width_dest + l_line_offset_dest;\n                l_src_ptr += l_width_dest + l_line_offset_src ;\n            }\n\n            l_src_ptr += l_end_offset_src;\n            p_data = (OPJ_BYTE*) l_src_ptr;\n        }\n        break;\n        }\n\n        ++l_img_comp_dest;\n        ++l_img_comp_src;\n        ++l_tilec;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k,\n                                 opj_image_t* p_image,\n                                 OPJ_INT32 p_start_x, OPJ_INT32 p_start_y,\n                                 OPJ_INT32 p_end_x, OPJ_INT32 p_end_y,\n                                 opj_event_mgr_t * p_manager)\n{\n    opj_cp_t * l_cp = &(p_j2k->m_cp);\n    opj_image_t * l_image = p_j2k->m_private_image;\n\n    OPJ_UINT32 it_comp;\n    OPJ_INT32 l_comp_x1, l_comp_y1;\n    opj_image_comp_t* l_img_comp = NULL;\n\n    /* Check if we are read the main header */\n    if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_TPHSOT) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Need to decode the main header before begin to decode the remaining codestream\");\n        return OPJ_FALSE;\n    }\n\n    if (!p_start_x && !p_start_y && !p_end_x && !p_end_y) {\n        opj_event_msg(p_manager, EVT_INFO,\n                      \"No decoded area parameters, set the decoded area to the whole image\\n\");\n\n        p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;\n        p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;\n        p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;\n        p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;\n\n        return OPJ_TRUE;\n    }\n\n    /* ----- */\n    /* Check if the positions provided by the user are correct */\n\n    /* Left */\n    if (p_start_x < 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Left position of the decoded area (region_x0=%d) should be >= 0.\\n\",\n                      p_start_x);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_start_x > l_image->x1) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\\n\",\n                      p_start_x, l_image->x1);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_start_x < l_image->x0) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\\n\",\n                      p_start_x, l_image->x0);\n        p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;\n        p_image->x0 = l_image->x0;\n    } else {\n        p_j2k->m_specific_param.m_decoder.m_start_tile_x = ((OPJ_UINT32)p_start_x -\n                l_cp->tx0) / l_cp->tdx;\n        p_image->x0 = (OPJ_UINT32)p_start_x;\n    }\n\n    /* Up */\n    if (p_start_x < 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Up position of the decoded area (region_y0=%d) should be >= 0.\\n\",\n                      p_start_y);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_start_y > l_image->y1) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\\n\",\n                      p_start_y, l_image->y1);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_start_y < l_image->y0) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\\n\",\n                      p_start_y, l_image->y0);\n        p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;\n        p_image->y0 = l_image->y0;\n    } else {\n        p_j2k->m_specific_param.m_decoder.m_start_tile_y = ((OPJ_UINT32)p_start_y -\n                l_cp->ty0) / l_cp->tdy;\n        p_image->y0 = (OPJ_UINT32)p_start_y;\n    }\n\n    /* Right */\n    if (p_end_x <= 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Right position of the decoded area (region_x1=%d) should be > 0.\\n\",\n                      p_end_x);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_end_x < l_image->x0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\\n\",\n                      p_end_x, l_image->x0);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_end_x > l_image->x1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\\n\",\n                      p_end_x, l_image->x1);\n        p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;\n        p_image->x1 = l_image->x1;\n    } else {\n        p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32)opj_int_ceildiv(\n                    p_end_x - (OPJ_INT32)l_cp->tx0, (OPJ_INT32)l_cp->tdx);\n        p_image->x1 = (OPJ_UINT32)p_end_x;\n    }\n\n    /* Bottom */\n    if (p_end_y <= 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Bottom position of the decoded area (region_y1=%d) should be > 0.\\n\",\n                      p_end_y);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_end_y < l_image->y0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\\n\",\n                      p_end_y, l_image->y0);\n        return OPJ_FALSE;\n    }\n    if ((OPJ_UINT32)p_end_y > l_image->y1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\\n\",\n                      p_end_y, l_image->y1);\n        p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;\n        p_image->y1 = l_image->y1;\n    } else {\n        p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32)opj_int_ceildiv(\n                    p_end_y - (OPJ_INT32)l_cp->ty0, (OPJ_INT32)l_cp->tdy);\n        p_image->y1 = (OPJ_UINT32)p_end_y;\n    }\n    /* ----- */\n\n    p_j2k->m_specific_param.m_decoder.m_discard_tiles = 1;\n\n    l_img_comp = p_image->comps;\n    for (it_comp = 0; it_comp < p_image->numcomps; ++it_comp) {\n        OPJ_INT32 l_h, l_w;\n\n        l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0,\n                         (OPJ_INT32)l_img_comp->dx);\n        l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0,\n                         (OPJ_INT32)l_img_comp->dy);\n        l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);\n        l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);\n\n        l_w = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32)l_img_comp->factor)\n              - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0, (OPJ_INT32)l_img_comp->factor);\n        if (l_w < 0) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Size x of the decoded component image is incorrect (comp[%d].w=%d).\\n\",\n                          it_comp, l_w);\n            return OPJ_FALSE;\n        }\n        l_img_comp->w = (OPJ_UINT32)l_w;\n\n        l_h = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32)l_img_comp->factor)\n              - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0, (OPJ_INT32)l_img_comp->factor);\n        if (l_h < 0) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Size y of the decoded component image is incorrect (comp[%d].h=%d).\\n\",\n                          it_comp, l_h);\n            return OPJ_FALSE;\n        }\n        l_img_comp->h = (OPJ_UINT32)l_h;\n\n        l_img_comp++;\n    }\n\n    opj_event_msg(p_manager, EVT_INFO, \"Setting decoding area to %d,%d,%d,%d\\n\",\n                  p_image->x0, p_image->y0, p_image->x1, p_image->y1);\n\n    return OPJ_TRUE;\n}\n\nopj_j2k_t* opj_j2k_create_decompress(void)\n{\n    opj_j2k_t *l_j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));\n    if (!l_j2k) {\n        return 00;\n    }\n\n    l_j2k->m_is_decoder = 1;\n    l_j2k->m_cp.m_is_decoder = 1;\n    /* in the absence of JP2 boxes, consider different bit depth / sign */\n    /* per component is allowed */\n    l_j2k->m_cp.allow_different_bit_depth_sign = 1;\n\n#ifdef OPJ_DISABLE_TPSOT_FIX\n    l_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = 1;\n#endif\n\n    l_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t*) opj_calloc(1,\n            sizeof(opj_tcp_t));\n    if (!l_j2k->m_specific_param.m_decoder.m_default_tcp) {\n        opj_j2k_destroy(l_j2k);\n        return 00;\n    }\n\n    l_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *) opj_calloc(1,\n            OPJ_J2K_DEFAULT_HEADER_SIZE);\n    if (! l_j2k->m_specific_param.m_decoder.m_header_data) {\n        opj_j2k_destroy(l_j2k);\n        return 00;\n    }\n\n    l_j2k->m_specific_param.m_decoder.m_header_data_size =\n        OPJ_J2K_DEFAULT_HEADER_SIZE;\n\n    l_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = -1 ;\n\n    l_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = 0 ;\n\n    /* codestream index creation */\n    l_j2k->cstr_index = opj_j2k_create_cstr_index();\n    if (!l_j2k->cstr_index) {\n        opj_j2k_destroy(l_j2k);\n        return 00;\n    }\n\n    /* validation list creation */\n    l_j2k->m_validation_list = opj_procedure_list_create();\n    if (! l_j2k->m_validation_list) {\n        opj_j2k_destroy(l_j2k);\n        return 00;\n    }\n\n    /* execution list creation */\n    l_j2k->m_procedure_list = opj_procedure_list_create();\n    if (! l_j2k->m_procedure_list) {\n        opj_j2k_destroy(l_j2k);\n        return 00;\n    }\n\n    l_j2k->m_tp = opj_thread_pool_create(opj_j2k_get_default_thread_count());\n    if (!l_j2k->m_tp) {\n        l_j2k->m_tp = opj_thread_pool_create(0);\n    }\n    if (!l_j2k->m_tp) {\n        opj_j2k_destroy(l_j2k);\n        return NULL;\n    }\n\n    return l_j2k;\n}\n\nstatic opj_codestream_index_t* opj_j2k_create_cstr_index(void)\n{\n    opj_codestream_index_t* cstr_index = (opj_codestream_index_t*)\n                                         opj_calloc(1, sizeof(opj_codestream_index_t));\n    if (!cstr_index) {\n        return NULL;\n    }\n\n    cstr_index->maxmarknum = 100;\n    cstr_index->marknum = 0;\n    cstr_index->marker = (opj_marker_info_t*)\n                         opj_calloc(cstr_index->maxmarknum, sizeof(opj_marker_info_t));\n    if (!cstr_index-> marker) {\n        opj_free(cstr_index);\n        return NULL;\n    }\n\n    cstr_index->tile_index = NULL;\n\n    return cstr_index;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no,\n        OPJ_UINT32 p_comp_no)\n{\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp = &l_tcp->tccps[p_comp_no];\n\n    /* preconditions again */\n    assert(p_tile_no < (l_cp->tw * l_cp->th));\n    assert(p_comp_no < p_j2k->m_private_image->numcomps);\n\n    if (l_tccp->csty & J2K_CCP_CSTY_PRT) {\n        return 5 + l_tccp->numresolutions;\n    } else {\n        return 5;\n    }\n}\n\nstatic OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n    OPJ_UINT32 i;\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n    opj_tccp_t *l_tccp0 = NULL;\n    opj_tccp_t *l_tccp1 = NULL;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp0 = &l_tcp->tccps[p_first_comp_no];\n    l_tccp1 = &l_tcp->tccps[p_second_comp_no];\n\n    if (l_tccp0->numresolutions != l_tccp1->numresolutions) {\n        return OPJ_FALSE;\n    }\n    if (l_tccp0->cblkw != l_tccp1->cblkw) {\n        return OPJ_FALSE;\n    }\n    if (l_tccp0->cblkh != l_tccp1->cblkh) {\n        return OPJ_FALSE;\n    }\n    if (l_tccp0->cblksty != l_tccp1->cblksty) {\n        return OPJ_FALSE;\n    }\n    if (l_tccp0->qmfbid != l_tccp1->qmfbid) {\n        return OPJ_FALSE;\n    }\n    if ((l_tccp0->csty & J2K_CCP_CSTY_PRT) != (l_tccp1->csty & J2K_CCP_CSTY_PRT)) {\n        return OPJ_FALSE;\n    }\n\n    for (i = 0U; i < l_tccp0->numresolutions; ++i) {\n        if (l_tccp0->prcw[i] != l_tccp1->prcw[i]) {\n            return OPJ_FALSE;\n        }\n        if (l_tccp0->prch[i] != l_tccp1->prch[i]) {\n            return OPJ_FALSE;\n        }\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no,\n        OPJ_UINT32 p_comp_no,\n        OPJ_BYTE * p_data,\n        OPJ_UINT32 * p_header_size,\n        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 i;\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_header_size != 00);\n    assert(p_manager != 00);\n    assert(p_data != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp = &l_tcp->tccps[p_comp_no];\n\n    /* preconditions again */\n    assert(p_tile_no < (l_cp->tw * l_cp->th));\n    assert(p_comp_no < (p_j2k->m_private_image->numcomps));\n\n    if (*p_header_size < 5) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error writing SPCod SPCoc element\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_write_bytes(p_data, l_tccp->numresolutions - 1, 1); /* SPcoc (D) */\n    ++p_data;\n\n    opj_write_bytes(p_data, l_tccp->cblkw - 2, 1);                  /* SPcoc (E) */\n    ++p_data;\n\n    opj_write_bytes(p_data, l_tccp->cblkh - 2, 1);                  /* SPcoc (F) */\n    ++p_data;\n\n    opj_write_bytes(p_data, l_tccp->cblksty,\n                    1);                            /* SPcoc (G) */\n    ++p_data;\n\n    opj_write_bytes(p_data, l_tccp->qmfbid,\n                    1);                             /* SPcoc (H) */\n    ++p_data;\n\n    *p_header_size = *p_header_size - 5;\n\n    if (l_tccp->csty & J2K_CCP_CSTY_PRT) {\n\n        if (*p_header_size < l_tccp->numresolutions) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error writing SPCod SPCoc element\\n\");\n            return OPJ_FALSE;\n        }\n\n        for (i = 0; i < l_tccp->numresolutions; ++i) {\n            opj_write_bytes(p_data, l_tccp->prcw[i] + (l_tccp->prch[i] << 4),\n                            1);   /* SPcoc (I_i) */\n            ++p_data;\n        }\n\n        *p_header_size = *p_header_size - l_tccp->numresolutions;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 compno,\n        OPJ_BYTE * p_header_data,\n        OPJ_UINT32 * p_header_size,\n        opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i, l_tmp;\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n    opj_tccp_t *l_tccp = NULL;\n    OPJ_BYTE * l_current_ptr = NULL;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_header_data != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    /* precondition again */\n    assert(compno < p_j2k->m_private_image->numcomps);\n\n    l_tccp = &l_tcp->tccps[compno];\n    l_current_ptr = p_header_data;\n\n    /* make sure room is sufficient */\n    if (*p_header_size < 5) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(l_current_ptr, &l_tccp->numresolutions,\n                   1);              /* SPcox (D) */\n    ++l_tccp->numresolutions;                                                                               /* tccp->numresolutions = read() + 1 */\n    if (l_tccp->numresolutions > OPJ_J2K_MAXRLVLS) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\\n\",\n                      l_tccp->numresolutions, OPJ_J2K_MAXRLVLS);\n        return OPJ_FALSE;\n    }\n    ++l_current_ptr;\n\n    /* If user wants to remove more resolutions than the codestream contains, return error */\n    if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error decoding component %d.\\nThe number of resolutions to remove is higher than the number \"\n                      \"of resolutions of this component\\nModify the cp_reduce parameter.\\n\\n\",\n                      compno);\n        p_j2k->m_specific_param.m_decoder.m_state |=\n            0x8000;/* FIXME J2K_DEC_STATE_ERR;*/\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(l_current_ptr, &l_tccp->cblkw, 1);               /* SPcoc (E) */\n    ++l_current_ptr;\n    l_tccp->cblkw += 2;\n\n    opj_read_bytes(l_current_ptr, &l_tccp->cblkh, 1);               /* SPcoc (F) */\n    ++l_current_ptr;\n    l_tccp->cblkh += 2;\n\n    if ((l_tccp->cblkw > 10) || (l_tccp->cblkh > 10) ||\n            ((l_tccp->cblkw + l_tccp->cblkh) > 12)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\\n\");\n        return OPJ_FALSE;\n    }\n\n\n    opj_read_bytes(l_current_ptr, &l_tccp->cblksty, 1);             /* SPcoc (G) */\n    ++l_current_ptr;\n    if (l_tccp->cblksty & 0xC0U) { /* 2 msb are reserved, assume we can't read */\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error reading SPCod SPCoc element, Invalid code-block style found\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(l_current_ptr, &l_tccp->qmfbid, 1);              /* SPcoc (H) */\n    ++l_current_ptr;\n\n    *p_header_size = *p_header_size - 5;\n\n    /* use custom precinct size ? */\n    if (l_tccp->csty & J2K_CCP_CSTY_PRT) {\n        if (*p_header_size < l_tccp->numresolutions) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element\\n\");\n            return OPJ_FALSE;\n        }\n\n        for (i = 0; i < l_tccp->numresolutions; ++i) {\n            opj_read_bytes(l_current_ptr, &l_tmp, 1);               /* SPcoc (I_i) */\n            ++l_current_ptr;\n            /* Precinct exponent 0 is only allowed for lowest resolution level (Table A.21) */\n            if ((i != 0) && (((l_tmp & 0xf) == 0) || ((l_tmp >> 4) == 0))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Invalid precinct size\\n\");\n                return OPJ_FALSE;\n            }\n            l_tccp->prcw[i] = l_tmp & 0xf;\n            l_tccp->prch[i] = l_tmp >> 4;\n        }\n\n        *p_header_size = *p_header_size - l_tccp->numresolutions;\n    } else {\n        /* set default size for the precinct width and height */\n        for (i = 0; i < l_tccp->numresolutions; ++i) {\n            l_tccp->prcw[i] = 15;\n            l_tccp->prch[i] = 15;\n        }\n    }\n\n#ifdef WIP_REMOVE_MSD\n    /* INDEX >> */\n    if (p_j2k->cstr_info && compno == 0) {\n        OPJ_UINT32 l_data_size = l_tccp->numresolutions * sizeof(OPJ_UINT32);\n\n        p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkh =\n            l_tccp->cblkh;\n        p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkw =\n            l_tccp->cblkw;\n        p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].numresolutions\n            = l_tccp->numresolutions;\n        p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblksty =\n            l_tccp->cblksty;\n        p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].qmfbid =\n            l_tccp->qmfbid;\n\n        memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdx, l_tccp->prcw,\n               l_data_size);\n        memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdy, l_tccp->prch,\n               l_data_size);\n    }\n    /* << INDEX */\n#endif\n\n    return OPJ_TRUE;\n}\n\nstatic void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k)\n{\n    /* loop */\n    OPJ_UINT32 i;\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n    opj_tccp_t *l_ref_tccp = NULL, *l_copied_tccp = NULL;\n    OPJ_UINT32 l_prc_size;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH)\n            ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    l_ref_tccp = &l_tcp->tccps[0];\n    l_copied_tccp = l_ref_tccp + 1;\n    l_prc_size = l_ref_tccp->numresolutions * (OPJ_UINT32)sizeof(OPJ_UINT32);\n\n    for (i = 1; i < p_j2k->m_private_image->numcomps; ++i) {\n        l_copied_tccp->numresolutions = l_ref_tccp->numresolutions;\n        l_copied_tccp->cblkw = l_ref_tccp->cblkw;\n        l_copied_tccp->cblkh = l_ref_tccp->cblkh;\n        l_copied_tccp->cblksty = l_ref_tccp->cblksty;\n        l_copied_tccp->qmfbid = l_ref_tccp->qmfbid;\n        memcpy(l_copied_tccp->prcw, l_ref_tccp->prcw, l_prc_size);\n        memcpy(l_copied_tccp->prch, l_ref_tccp->prch, l_prc_size);\n        ++l_copied_tccp;\n    }\n}\n\nstatic OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no,\n        OPJ_UINT32 p_comp_no)\n{\n    OPJ_UINT32 l_num_bands;\n\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp = &l_tcp->tccps[p_comp_no];\n\n    /* preconditions again */\n    assert(p_tile_no < l_cp->tw * l_cp->th);\n    assert(p_comp_no < p_j2k->m_private_image->numcomps);\n\n    l_num_bands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 :\n                  (l_tccp->numresolutions * 3 - 2);\n\n    if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT)  {\n        return 1 + l_num_bands;\n    } else {\n        return 1 + 2 * l_num_bands;\n    }\n}\n\nstatic OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n    opj_tccp_t *l_tccp0 = NULL;\n    opj_tccp_t *l_tccp1 = NULL;\n    OPJ_UINT32 l_band_no, l_num_bands;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp0 = &l_tcp->tccps[p_first_comp_no];\n    l_tccp1 = &l_tcp->tccps[p_second_comp_no];\n\n    if (l_tccp0->qntsty != l_tccp1->qntsty) {\n        return OPJ_FALSE;\n    }\n    if (l_tccp0->numgbits != l_tccp1->numgbits) {\n        return OPJ_FALSE;\n    }\n    if (l_tccp0->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n        l_num_bands = 1U;\n    } else {\n        l_num_bands = l_tccp0->numresolutions * 3U - 2U;\n        if (l_num_bands != (l_tccp1->numresolutions * 3U - 2U)) {\n            return OPJ_FALSE;\n        }\n    }\n\n    for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n        if (l_tccp0->stepsizes[l_band_no].expn != l_tccp1->stepsizes[l_band_no].expn) {\n            return OPJ_FALSE;\n        }\n    }\n    if (l_tccp0->qntsty != J2K_CCP_QNTSTY_NOQNT) {\n        for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n            if (l_tccp0->stepsizes[l_band_no].mant != l_tccp1->stepsizes[l_band_no].mant) {\n                return OPJ_FALSE;\n            }\n        }\n    }\n    return OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 p_tile_no,\n                                        OPJ_UINT32 p_comp_no,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_header_size,\n                                        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 l_header_size;\n    OPJ_UINT32 l_band_no, l_num_bands;\n    OPJ_UINT32 l_expn, l_mant;\n\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_header_size != 00);\n    assert(p_manager != 00);\n    assert(p_data != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp = &l_tcp->tccps[p_comp_no];\n\n    /* preconditions again */\n    assert(p_tile_no < l_cp->tw * l_cp->th);\n    assert(p_comp_no < p_j2k->m_private_image->numcomps);\n\n    l_num_bands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 :\n                  (l_tccp->numresolutions * 3 - 2);\n\n    if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT)  {\n        l_header_size = 1 + l_num_bands;\n\n        if (*p_header_size < l_header_size) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error writing SQcd SQcc element\\n\");\n            return OPJ_FALSE;\n        }\n\n        opj_write_bytes(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5),\n                        1);   /* Sqcx */\n        ++p_data;\n\n        for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n            l_expn = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].expn;\n            opj_write_bytes(p_data, l_expn << 3, 1);        /* SPqcx_i */\n            ++p_data;\n        }\n    } else {\n        l_header_size = 1 + 2 * l_num_bands;\n\n        if (*p_header_size < l_header_size) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error writing SQcd SQcc element\\n\");\n            return OPJ_FALSE;\n        }\n\n        opj_write_bytes(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5),\n                        1);   /* Sqcx */\n        ++p_data;\n\n        for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n            l_expn = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].expn;\n            l_mant = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].mant;\n\n            opj_write_bytes(p_data, (l_expn << 11) + l_mant, 2);    /* SPqcx_i */\n            p_data += 2;\n        }\n    }\n\n    *p_header_size = *p_header_size - l_header_size;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k,\n                                       OPJ_UINT32 p_comp_no,\n                                       OPJ_BYTE* p_header_data,\n                                       OPJ_UINT32 * p_header_size,\n                                       opj_event_mgr_t * p_manager\n                                      )\n{\n    /* loop*/\n    OPJ_UINT32 l_band_no;\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n    OPJ_BYTE * l_current_ptr = 00;\n    OPJ_UINT32 l_tmp, l_num_band;\n\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_header_data != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    /* come from tile part header or main header ?*/\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH)\n            ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    /* precondition again*/\n    assert(p_comp_no <  p_j2k->m_private_image->numcomps);\n\n    l_tccp = &l_tcp->tccps[p_comp_no];\n    l_current_ptr = p_header_data;\n\n    if (*p_header_size < 1) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading SQcd or SQcc element\\n\");\n        return OPJ_FALSE;\n    }\n    *p_header_size -= 1;\n\n    opj_read_bytes(l_current_ptr, &l_tmp, 1);                       /* Sqcx */\n    ++l_current_ptr;\n\n    l_tccp->qntsty = l_tmp & 0x1f;\n    l_tccp->numgbits = l_tmp >> 5;\n    if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n        l_num_band = 1;\n    } else {\n        l_num_band = (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) ?\n                     (*p_header_size) :\n                     (*p_header_size) / 2;\n\n        if (l_num_band > OPJ_J2K_MAXBANDS) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"While reading CCP_QNTSTY element inside QCD or QCC marker segment, \"\n                          \"number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to \"\n                          \"OPJ_J2K_MAXBANDS (%d) and skip the rest. \\n\", l_num_band, OPJ_J2K_MAXBANDS,\n                          OPJ_J2K_MAXBANDS);\n            /*return OPJ_FALSE;*/\n        }\n    }\n\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n\n        /* if JPWL is on, we check whether there are too many subbands */\n        if (/*(l_num_band < 0) ||*/ (l_num_band >= OPJ_J2K_MAXBANDS)) {\n            opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                          \"JPWL: bad number of subbands in Sqcx (%d)\\n\",\n                          l_num_band);\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n            /* we try to correct */\n            l_num_band = 1;\n            opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust them\\n\"\n                          \"- setting number of bands to %d => HYPOTHESIS!!!\\n\",\n                          l_num_band);\n        };\n\n    };\n#endif /* USE_JPWL */\n\n    if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {\n        for (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {\n            opj_read_bytes(l_current_ptr, &l_tmp, 1);                       /* SPqcx_i */\n            ++l_current_ptr;\n            if (l_band_no < OPJ_J2K_MAXBANDS) {\n                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 3);\n                l_tccp->stepsizes[l_band_no].mant = 0;\n            }\n        }\n        *p_header_size = *p_header_size - l_num_band;\n    } else {\n        for (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {\n            opj_read_bytes(l_current_ptr, &l_tmp, 2);                       /* SPqcx_i */\n            l_current_ptr += 2;\n            if (l_band_no < OPJ_J2K_MAXBANDS) {\n                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 11);\n                l_tccp->stepsizes[l_band_no].mant = l_tmp & 0x7ff;\n            }\n        }\n        *p_header_size = *p_header_size - 2 * l_num_band;\n    }\n\n    /* Add Antonin : if scalar_derived -> compute other stepsizes */\n    if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n        for (l_band_no = 1; l_band_no < OPJ_J2K_MAXBANDS; l_band_no++) {\n            l_tccp->stepsizes[l_band_no].expn =\n                ((OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) > 0)\n                ?\n                (OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) : 0;\n            l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;\n        }\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k)\n{\n    OPJ_UINT32 i;\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n    opj_tccp_t *l_ref_tccp = NULL;\n    opj_tccp_t *l_copied_tccp = NULL;\n    OPJ_UINT32 l_size;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    l_ref_tccp = &l_tcp->tccps[0];\n    l_copied_tccp = l_ref_tccp + 1;\n    l_size = OPJ_J2K_MAXBANDS * sizeof(opj_stepsize_t);\n\n    for (i = 1; i < p_j2k->m_private_image->numcomps; ++i) {\n        l_copied_tccp->qntsty = l_ref_tccp->qntsty;\n        l_copied_tccp->numgbits = l_ref_tccp->numgbits;\n        memcpy(l_copied_tccp->stepsizes, l_ref_tccp->stepsizes, l_size);\n        ++l_copied_tccp;\n    }\n}\n\nstatic void opj_j2k_dump_tile_info(opj_tcp_t * l_default_tile,\n                                   OPJ_INT32 numcomps, FILE* out_stream)\n{\n    if (l_default_tile) {\n        OPJ_INT32 compno;\n\n        fprintf(out_stream, \"\\t default tile {\\n\");\n        fprintf(out_stream, \"\\t\\t csty=%#x\\n\", l_default_tile->csty);\n        fprintf(out_stream, \"\\t\\t prg=%#x\\n\", l_default_tile->prg);\n        fprintf(out_stream, \"\\t\\t numlayers=%d\\n\", l_default_tile->numlayers);\n        fprintf(out_stream, \"\\t\\t mct=%x\\n\", l_default_tile->mct);\n\n        for (compno = 0; compno < numcomps; compno++) {\n            opj_tccp_t *l_tccp = &(l_default_tile->tccps[compno]);\n            OPJ_UINT32 resno;\n            OPJ_INT32 bandno, numbands;\n\n            /* coding style*/\n            fprintf(out_stream, \"\\t\\t comp %d {\\n\", compno);\n            fprintf(out_stream, \"\\t\\t\\t csty=%#x\\n\", l_tccp->csty);\n            fprintf(out_stream, \"\\t\\t\\t numresolutions=%d\\n\", l_tccp->numresolutions);\n            fprintf(out_stream, \"\\t\\t\\t cblkw=2^%d\\n\", l_tccp->cblkw);\n            fprintf(out_stream, \"\\t\\t\\t cblkh=2^%d\\n\", l_tccp->cblkh);\n            fprintf(out_stream, \"\\t\\t\\t cblksty=%#x\\n\", l_tccp->cblksty);\n            fprintf(out_stream, \"\\t\\t\\t qmfbid=%d\\n\", l_tccp->qmfbid);\n\n            fprintf(out_stream, \"\\t\\t\\t preccintsize (w,h)=\");\n            for (resno = 0; resno < l_tccp->numresolutions; resno++) {\n                fprintf(out_stream, \"(%d,%d) \", l_tccp->prcw[resno], l_tccp->prch[resno]);\n            }\n            fprintf(out_stream, \"\\n\");\n\n            /* quantization style*/\n            fprintf(out_stream, \"\\t\\t\\t qntsty=%d\\n\", l_tccp->qntsty);\n            fprintf(out_stream, \"\\t\\t\\t numgbits=%d\\n\", l_tccp->numgbits);\n            fprintf(out_stream, \"\\t\\t\\t stepsizes (m,e)=\");\n            numbands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 :\n                       (OPJ_INT32)l_tccp->numresolutions * 3 - 2;\n            for (bandno = 0; bandno < numbands; bandno++) {\n                fprintf(out_stream, \"(%d,%d) \", l_tccp->stepsizes[bandno].mant,\n                        l_tccp->stepsizes[bandno].expn);\n            }\n            fprintf(out_stream, \"\\n\");\n\n            /* RGN value*/\n            fprintf(out_stream, \"\\t\\t\\t roishift=%d\\n\", l_tccp->roishift);\n\n            fprintf(out_stream, \"\\t\\t }\\n\");\n        } /*end of component of default tile*/\n        fprintf(out_stream, \"\\t }\\n\"); /*end of default tile*/\n    }\n}\n\nvoid j2k_dump(opj_j2k_t* p_j2k, OPJ_INT32 flag, FILE* out_stream)\n{\n    /* Check if the flag is compatible with j2k file*/\n    if ((flag & OPJ_JP2_INFO) || (flag & OPJ_JP2_IND)) {\n        fprintf(out_stream, \"Wrong flag\\n\");\n        return;\n    }\n\n    /* Dump the image_header */\n    if (flag & OPJ_IMG_INFO) {\n        if (p_j2k->m_private_image) {\n            j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);\n        }\n    }\n\n    /* Dump the codestream info from main header */\n    if (flag & OPJ_J2K_MH_INFO) {\n        if (p_j2k->m_private_image) {\n            opj_j2k_dump_MH_info(p_j2k, out_stream);\n        }\n    }\n    /* Dump all tile/codestream info */\n    if (flag & OPJ_J2K_TCH_INFO) {\n        OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n        OPJ_UINT32 i;\n        opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;\n        if (p_j2k->m_private_image) {\n            for (i = 0; i < l_nb_tiles; ++i) {\n                opj_j2k_dump_tile_info(l_tcp, (OPJ_INT32)p_j2k->m_private_image->numcomps,\n                                       out_stream);\n                ++l_tcp;\n            }\n        }\n    }\n\n    /* Dump the codestream info of the current tile */\n    if (flag & OPJ_J2K_TH_INFO) {\n\n    }\n\n    /* Dump the codestream index from main header */\n    if (flag & OPJ_J2K_MH_IND) {\n        opj_j2k_dump_MH_index(p_j2k, out_stream);\n    }\n\n    /* Dump the codestream index of the current tile */\n    if (flag & OPJ_J2K_TH_IND) {\n\n    }\n\n}\n\nstatic void opj_j2k_dump_MH_index(opj_j2k_t* p_j2k, FILE* out_stream)\n{\n    opj_codestream_index_t* cstr_index = p_j2k->cstr_index;\n    OPJ_UINT32 it_marker, it_tile, it_tile_part;\n\n    fprintf(out_stream, \"Codestream index from main header: {\\n\");\n\n    fprintf(out_stream, \"\\t Main header start position=%\" PRIi64 \"\\n\"\n            \"\\t Main header end position=%\" PRIi64 \"\\n\",\n            cstr_index->main_head_start, cstr_index->main_head_end);\n\n    fprintf(out_stream, \"\\t Marker list: {\\n\");\n\n    if (cstr_index->marker) {\n        for (it_marker = 0; it_marker < cstr_index->marknum ; it_marker++) {\n            fprintf(out_stream, \"\\t\\t type=%#x, pos=%\" PRIi64 \", len=%d\\n\",\n                    cstr_index->marker[it_marker].type,\n                    cstr_index->marker[it_marker].pos,\n                    cstr_index->marker[it_marker].len);\n        }\n    }\n\n    fprintf(out_stream, \"\\t }\\n\");\n\n    if (cstr_index->tile_index) {\n\n        /* Simple test to avoid to write empty information*/\n        OPJ_UINT32 l_acc_nb_of_tile_part = 0;\n        for (it_tile = 0; it_tile < cstr_index->nb_of_tiles ; it_tile++) {\n            l_acc_nb_of_tile_part += cstr_index->tile_index[it_tile].nb_tps;\n        }\n\n        if (l_acc_nb_of_tile_part) {\n            fprintf(out_stream, \"\\t Tile index: {\\n\");\n\n            for (it_tile = 0; it_tile < cstr_index->nb_of_tiles ; it_tile++) {\n                OPJ_UINT32 nb_of_tile_part = cstr_index->tile_index[it_tile].nb_tps;\n\n                fprintf(out_stream, \"\\t\\t nb of tile-part in tile [%d]=%d\\n\", it_tile,\n                        nb_of_tile_part);\n\n                if (cstr_index->tile_index[it_tile].tp_index) {\n                    for (it_tile_part = 0; it_tile_part < nb_of_tile_part; it_tile_part++) {\n                        fprintf(out_stream, \"\\t\\t\\t tile-part[%d]: star_pos=%\" PRIi64 \", end_header=%\"\n                                PRIi64 \", end_pos=%\" PRIi64 \".\\n\",\n                                it_tile_part,\n                                cstr_index->tile_index[it_tile].tp_index[it_tile_part].start_pos,\n                                cstr_index->tile_index[it_tile].tp_index[it_tile_part].end_header,\n                                cstr_index->tile_index[it_tile].tp_index[it_tile_part].end_pos);\n                    }\n                }\n\n                if (cstr_index->tile_index[it_tile].marker) {\n                    for (it_marker = 0; it_marker < cstr_index->tile_index[it_tile].marknum ;\n                            it_marker++) {\n                        fprintf(out_stream, \"\\t\\t type=%#x, pos=%\" PRIi64 \", len=%d\\n\",\n                                cstr_index->tile_index[it_tile].marker[it_marker].type,\n                                cstr_index->tile_index[it_tile].marker[it_marker].pos,\n                                cstr_index->tile_index[it_tile].marker[it_marker].len);\n                    }\n                }\n            }\n            fprintf(out_stream, \"\\t }\\n\");\n        }\n    }\n\n    fprintf(out_stream, \"}\\n\");\n\n}\n\n\nstatic void opj_j2k_dump_MH_info(opj_j2k_t* p_j2k, FILE* out_stream)\n{\n\n    fprintf(out_stream, \"Codestream info from main header: {\\n\");\n\n    fprintf(out_stream, \"\\t tx0=%d, ty0=%d\\n\", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);\n    fprintf(out_stream, \"\\t tdx=%d, tdy=%d\\n\", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);\n    fprintf(out_stream, \"\\t tw=%d, th=%d\\n\", p_j2k->m_cp.tw, p_j2k->m_cp.th);\n    opj_j2k_dump_tile_info(p_j2k->m_specific_param.m_decoder.m_default_tcp,\n                           (OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);\n    fprintf(out_stream, \"}\\n\");\n}\n\nvoid j2k_dump_image_header(opj_image_t* img_header, OPJ_BOOL dev_dump_flag,\n                           FILE* out_stream)\n{\n    char tab[2];\n\n    if (dev_dump_flag) {\n        fprintf(stdout, \"[DEV] Dump an image_header struct {\\n\");\n        tab[0] = '\\0';\n    } else {\n        fprintf(out_stream, \"Image info {\\n\");\n        tab[0] = '\\t';\n        tab[1] = '\\0';\n    }\n\n    fprintf(out_stream, \"%s x0=%d, y0=%d\\n\", tab, img_header->x0, img_header->y0);\n    fprintf(out_stream,     \"%s x1=%d, y1=%d\\n\", tab, img_header->x1,\n            img_header->y1);\n    fprintf(out_stream, \"%s numcomps=%d\\n\", tab, img_header->numcomps);\n\n    if (img_header->comps) {\n        OPJ_UINT32 compno;\n        for (compno = 0; compno < img_header->numcomps; compno++) {\n            fprintf(out_stream, \"%s\\t component %d {\\n\", tab, compno);\n            j2k_dump_image_comp_header(&(img_header->comps[compno]), dev_dump_flag,\n                                       out_stream);\n            fprintf(out_stream, \"%s}\\n\", tab);\n        }\n    }\n\n    fprintf(out_stream, \"}\\n\");\n}\n\nvoid j2k_dump_image_comp_header(opj_image_comp_t* comp_header,\n                                OPJ_BOOL dev_dump_flag, FILE* out_stream)\n{\n    char tab[3];\n\n    if (dev_dump_flag) {\n        fprintf(stdout, \"[DEV] Dump an image_comp_header struct {\\n\");\n        tab[0] = '\\0';\n    }       else {\n        tab[0] = '\\t';\n        tab[1] = '\\t';\n        tab[2] = '\\0';\n    }\n\n    fprintf(out_stream, \"%s dx=%d, dy=%d\\n\", tab, comp_header->dx, comp_header->dy);\n    fprintf(out_stream, \"%s prec=%d\\n\", tab, comp_header->prec);\n    fprintf(out_stream, \"%s sgnd=%d\\n\", tab, comp_header->sgnd);\n\n    if (dev_dump_flag) {\n        fprintf(out_stream, \"}\\n\");\n    }\n}\n\nopj_codestream_info_v2_t* j2k_get_cstr_info(opj_j2k_t* p_j2k)\n{\n    OPJ_UINT32 compno;\n    OPJ_UINT32 numcomps = p_j2k->m_private_image->numcomps;\n    opj_tcp_t *l_default_tile;\n    opj_codestream_info_v2_t* cstr_info = (opj_codestream_info_v2_t*) opj_calloc(1,\n                                          sizeof(opj_codestream_info_v2_t));\n    if (!cstr_info) {\n        return NULL;\n    }\n\n    cstr_info->nbcomps = p_j2k->m_private_image->numcomps;\n\n    cstr_info->tx0 = p_j2k->m_cp.tx0;\n    cstr_info->ty0 = p_j2k->m_cp.ty0;\n    cstr_info->tdx = p_j2k->m_cp.tdx;\n    cstr_info->tdy = p_j2k->m_cp.tdy;\n    cstr_info->tw = p_j2k->m_cp.tw;\n    cstr_info->th = p_j2k->m_cp.th;\n\n    cstr_info->tile_info = NULL; /* Not fill from the main header*/\n\n    l_default_tile = p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    cstr_info->m_default_tile_info.csty = l_default_tile->csty;\n    cstr_info->m_default_tile_info.prg = l_default_tile->prg;\n    cstr_info->m_default_tile_info.numlayers = l_default_tile->numlayers;\n    cstr_info->m_default_tile_info.mct = l_default_tile->mct;\n\n    cstr_info->m_default_tile_info.tccp_info = (opj_tccp_info_t*) opj_calloc(\n                cstr_info->nbcomps, sizeof(opj_tccp_info_t));\n    if (!cstr_info->m_default_tile_info.tccp_info) {\n        opj_destroy_cstr_info(&cstr_info);\n        return NULL;\n    }\n\n    for (compno = 0; compno < numcomps; compno++) {\n        opj_tccp_t *l_tccp = &(l_default_tile->tccps[compno]);\n        opj_tccp_info_t *l_tccp_info = &\n                                       (cstr_info->m_default_tile_info.tccp_info[compno]);\n        OPJ_INT32 bandno, numbands;\n\n        /* coding style*/\n        l_tccp_info->csty = l_tccp->csty;\n        l_tccp_info->numresolutions = l_tccp->numresolutions;\n        l_tccp_info->cblkw = l_tccp->cblkw;\n        l_tccp_info->cblkh = l_tccp->cblkh;\n        l_tccp_info->cblksty = l_tccp->cblksty;\n        l_tccp_info->qmfbid = l_tccp->qmfbid;\n        if (l_tccp->numresolutions < OPJ_J2K_MAXRLVLS) {\n            memcpy(l_tccp_info->prch, l_tccp->prch, l_tccp->numresolutions);\n            memcpy(l_tccp_info->prcw, l_tccp->prcw, l_tccp->numresolutions);\n        }\n\n        /* quantization style*/\n        l_tccp_info->qntsty = l_tccp->qntsty;\n        l_tccp_info->numgbits = l_tccp->numgbits;\n\n        numbands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 :\n                   (OPJ_INT32)l_tccp->numresolutions * 3 - 2;\n        if (numbands < OPJ_J2K_MAXBANDS) {\n            for (bandno = 0; bandno < numbands; bandno++) {\n                l_tccp_info->stepsizes_mant[bandno] = (OPJ_UINT32)\n                                                      l_tccp->stepsizes[bandno].mant;\n                l_tccp_info->stepsizes_expn[bandno] = (OPJ_UINT32)\n                                                      l_tccp->stepsizes[bandno].expn;\n            }\n        }\n\n        /* RGN value*/\n        l_tccp_info->roishift = l_tccp->roishift;\n    }\n\n    return cstr_info;\n}\n\nopj_codestream_index_t* j2k_get_cstr_index(opj_j2k_t* p_j2k)\n{\n    opj_codestream_index_t* l_cstr_index = (opj_codestream_index_t*)\n                                           opj_calloc(1, sizeof(opj_codestream_index_t));\n    if (!l_cstr_index) {\n        return NULL;\n    }\n\n    l_cstr_index->main_head_start = p_j2k->cstr_index->main_head_start;\n    l_cstr_index->main_head_end = p_j2k->cstr_index->main_head_end;\n    l_cstr_index->codestream_size = p_j2k->cstr_index->codestream_size;\n\n    l_cstr_index->marknum = p_j2k->cstr_index->marknum;\n    l_cstr_index->marker = (opj_marker_info_t*)opj_malloc(l_cstr_index->marknum *\n                           sizeof(opj_marker_info_t));\n    if (!l_cstr_index->marker) {\n        opj_free(l_cstr_index);\n        return NULL;\n    }\n\n    if (p_j2k->cstr_index->marker) {\n        memcpy(l_cstr_index->marker, p_j2k->cstr_index->marker,\n               l_cstr_index->marknum * sizeof(opj_marker_info_t));\n    } else {\n        opj_free(l_cstr_index->marker);\n        l_cstr_index->marker = NULL;\n    }\n\n    l_cstr_index->nb_of_tiles = p_j2k->cstr_index->nb_of_tiles;\n    l_cstr_index->tile_index = (opj_tile_index_t*)opj_calloc(\n                                   l_cstr_index->nb_of_tiles, sizeof(opj_tile_index_t));\n    if (!l_cstr_index->tile_index) {\n        opj_free(l_cstr_index->marker);\n        opj_free(l_cstr_index);\n        return NULL;\n    }\n\n    if (!p_j2k->cstr_index->tile_index) {\n        opj_free(l_cstr_index->tile_index);\n        l_cstr_index->tile_index = NULL;\n    } else {\n        OPJ_UINT32 it_tile = 0;\n        for (it_tile = 0; it_tile < l_cstr_index->nb_of_tiles; it_tile++) {\n\n            /* Tile Marker*/\n            l_cstr_index->tile_index[it_tile].marknum =\n                p_j2k->cstr_index->tile_index[it_tile].marknum;\n\n            l_cstr_index->tile_index[it_tile].marker =\n                (opj_marker_info_t*)opj_malloc(l_cstr_index->tile_index[it_tile].marknum *\n                                               sizeof(opj_marker_info_t));\n\n            if (!l_cstr_index->tile_index[it_tile].marker) {\n                OPJ_UINT32 it_tile_free;\n\n                for (it_tile_free = 0; it_tile_free < it_tile; it_tile_free++) {\n                    opj_free(l_cstr_index->tile_index[it_tile_free].marker);\n                }\n\n                opj_free(l_cstr_index->tile_index);\n                opj_free(l_cstr_index->marker);\n                opj_free(l_cstr_index);\n                return NULL;\n            }\n\n            if (p_j2k->cstr_index->tile_index[it_tile].marker)\n                memcpy(l_cstr_index->tile_index[it_tile].marker,\n                       p_j2k->cstr_index->tile_index[it_tile].marker,\n                       l_cstr_index->tile_index[it_tile].marknum * sizeof(opj_marker_info_t));\n            else {\n                opj_free(l_cstr_index->tile_index[it_tile].marker);\n                l_cstr_index->tile_index[it_tile].marker = NULL;\n            }\n\n            /* Tile part index*/\n            l_cstr_index->tile_index[it_tile].nb_tps =\n                p_j2k->cstr_index->tile_index[it_tile].nb_tps;\n\n            l_cstr_index->tile_index[it_tile].tp_index =\n                (opj_tp_index_t*)opj_malloc(l_cstr_index->tile_index[it_tile].nb_tps * sizeof(\n                                                opj_tp_index_t));\n\n            if (!l_cstr_index->tile_index[it_tile].tp_index) {\n                OPJ_UINT32 it_tile_free;\n\n                for (it_tile_free = 0; it_tile_free < it_tile; it_tile_free++) {\n                    opj_free(l_cstr_index->tile_index[it_tile_free].marker);\n                    opj_free(l_cstr_index->tile_index[it_tile_free].tp_index);\n                }\n\n                opj_free(l_cstr_index->tile_index);\n                opj_free(l_cstr_index->marker);\n                opj_free(l_cstr_index);\n                return NULL;\n            }\n\n            if (p_j2k->cstr_index->tile_index[it_tile].tp_index) {\n                memcpy(l_cstr_index->tile_index[it_tile].tp_index,\n                       p_j2k->cstr_index->tile_index[it_tile].tp_index,\n                       l_cstr_index->tile_index[it_tile].nb_tps * sizeof(opj_tp_index_t));\n            } else {\n                opj_free(l_cstr_index->tile_index[it_tile].tp_index);\n                l_cstr_index->tile_index[it_tile].tp_index = NULL;\n            }\n\n            /* Packet index (NOT USED)*/\n            l_cstr_index->tile_index[it_tile].nb_packet = 0;\n            l_cstr_index->tile_index[it_tile].packet_index = NULL;\n\n        }\n    }\n\n    return l_cstr_index;\n}\n\nstatic OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k)\n{\n    OPJ_UINT32 it_tile = 0;\n\n    p_j2k->cstr_index->nb_of_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;\n    p_j2k->cstr_index->tile_index = (opj_tile_index_t*)opj_calloc(\n                                        p_j2k->cstr_index->nb_of_tiles, sizeof(opj_tile_index_t));\n    if (!p_j2k->cstr_index->tile_index) {\n        return OPJ_FALSE;\n    }\n\n    for (it_tile = 0; it_tile < p_j2k->cstr_index->nb_of_tiles; it_tile++) {\n        p_j2k->cstr_index->tile_index[it_tile].maxmarknum = 100;\n        p_j2k->cstr_index->tile_index[it_tile].marknum = 0;\n        p_j2k->cstr_index->tile_index[it_tile].marker = (opj_marker_info_t*)\n                opj_calloc(p_j2k->cstr_index->tile_index[it_tile].maxmarknum,\n                           sizeof(opj_marker_info_t));\n        if (!p_j2k->cstr_index->tile_index[it_tile].marker) {\n            return OPJ_FALSE;\n        }\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k,\n                                     opj_stream_private_t *p_stream,\n                                     opj_event_mgr_t * p_manager)\n{\n    OPJ_BOOL l_go_on = OPJ_TRUE;\n    OPJ_UINT32 l_current_tile_no;\n    OPJ_UINT32 l_data_size, l_max_data_size;\n    OPJ_INT32 l_tile_x0, l_tile_y0, l_tile_x1, l_tile_y1;\n    OPJ_UINT32 l_nb_comps;\n    OPJ_BYTE * l_current_data;\n    OPJ_UINT32 nr_tiles = 0;\n\n    /* Particular case for whole single tile decoding */\n    /* We can avoid allocating intermediate tile buffers */\n    if (p_j2k->m_cp.tw == 1 && p_j2k->m_cp.th == 1 &&\n            p_j2k->m_cp.tx0 == 0 && p_j2k->m_cp.ty0 == 0 &&\n            p_j2k->m_output_image->x0 == 0 &&\n            p_j2k->m_output_image->y0 == 0 &&\n            p_j2k->m_output_image->x1 == p_j2k->m_cp.tdx &&\n            p_j2k->m_output_image->y1 == p_j2k->m_cp.tdy &&\n            p_j2k->m_output_image->comps[0].factor == 0) {\n        OPJ_UINT32 i;\n        if (! opj_j2k_read_tile_header(p_j2k,\n                                       &l_current_tile_no,\n                                       &l_data_size,\n                                       &l_tile_x0, &l_tile_y0,\n                                       &l_tile_x1, &l_tile_y1,\n                                       &l_nb_comps,\n                                       &l_go_on,\n                                       p_stream,\n                                       p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        if (! opj_j2k_decode_tile(p_j2k, l_current_tile_no, NULL, 0,\n                                  p_stream, p_manager)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Failed to decode tile 1/1\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* Transfer TCD data to output image data */\n        for (i = 0; i < p_j2k->m_output_image->numcomps; i++) {\n            opj_image_data_free(p_j2k->m_output_image->comps[i].data);\n            p_j2k->m_output_image->comps[i].data =\n                p_j2k->m_tcd->tcd_image->tiles->comps[i].data;\n            p_j2k->m_output_image->comps[i].resno_decoded =\n                p_j2k->m_tcd->image->comps[i].resno_decoded;\n            p_j2k->m_tcd->tcd_image->tiles->comps[i].data = NULL;\n        }\n\n        return OPJ_TRUE;\n    }\n\n    l_current_data = (OPJ_BYTE*)opj_malloc(1000);\n    if (! l_current_data) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tiles\\n\");\n        return OPJ_FALSE;\n    }\n    l_max_data_size = 1000;\n\n    for (;;) {\n        if (! opj_j2k_read_tile_header(p_j2k,\n                                       &l_current_tile_no,\n                                       &l_data_size,\n                                       &l_tile_x0, &l_tile_y0,\n                                       &l_tile_x1, &l_tile_y1,\n                                       &l_nb_comps,\n                                       &l_go_on,\n                                       p_stream,\n                                       p_manager)) {\n            opj_free(l_current_data);\n            return OPJ_FALSE;\n        }\n\n        if (! l_go_on) {\n            break;\n        }\n\n        if (l_data_size > l_max_data_size) {\n            OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data,\n                                           l_data_size);\n            if (! l_new_current_data) {\n                opj_free(l_current_data);\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tile %d/%d\\n\",\n                              l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n                return OPJ_FALSE;\n            }\n            l_current_data = l_new_current_data;\n            l_max_data_size = l_data_size;\n        }\n\n        if (! opj_j2k_decode_tile(p_j2k, l_current_tile_no, l_current_data, l_data_size,\n                                  p_stream, p_manager)) {\n            opj_free(l_current_data);\n            opj_event_msg(p_manager, EVT_ERROR, \"Failed to decode tile %d/%d\\n\",\n                          l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n            return OPJ_FALSE;\n        }\n        opj_event_msg(p_manager, EVT_INFO, \"Tile %d/%d has been decoded.\\n\",\n                      l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n\n        if (! opj_j2k_update_image_data(p_j2k->m_tcd, l_current_data,\n                                        p_j2k->m_output_image)) {\n            opj_free(l_current_data);\n            return OPJ_FALSE;\n        }\n        opj_event_msg(p_manager, EVT_INFO,\n                      \"Image data has been updated with tile %d.\\n\\n\", l_current_tile_no + 1);\n\n        if (opj_stream_get_number_byte_left(p_stream) == 0\n                && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC) {\n            break;\n        }\n        if (++nr_tiles ==  p_j2k->m_cp.th * p_j2k->m_cp.tw) {\n            break;\n        }\n    }\n\n    opj_free(l_current_data);\n\n    return OPJ_TRUE;\n}\n\n/**\n * Sets up the procedures to do on decoding data. Developpers wanting to extend the library can add their own reading procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_decoding(opj_j2k_t *p_j2k,\n                                       opj_event_mgr_t * p_manager)\n{\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_decode_tiles, p_manager)) {\n        return OPJ_FALSE;\n    }\n    /* DEVELOPER CORNER, add your custom procedures */\n\n    return OPJ_TRUE;\n}\n\n/*\n * Read and decode one tile.\n */\nstatic OPJ_BOOL opj_j2k_decode_one_tile(opj_j2k_t *p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager)\n{\n    OPJ_BOOL l_go_on = OPJ_TRUE;\n    OPJ_UINT32 l_current_tile_no;\n    OPJ_UINT32 l_tile_no_to_dec;\n    OPJ_UINT32 l_data_size, l_max_data_size;\n    OPJ_INT32 l_tile_x0, l_tile_y0, l_tile_x1, l_tile_y1;\n    OPJ_UINT32 l_nb_comps;\n    OPJ_BYTE * l_current_data;\n    OPJ_UINT32 l_nb_tiles;\n    OPJ_UINT32 i;\n\n    l_current_data = (OPJ_BYTE*)opj_malloc(1000);\n    if (! l_current_data) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode one tile\\n\");\n        return OPJ_FALSE;\n    }\n    l_max_data_size = 1000;\n\n    /*Allocate and initialize some elements of codestrem index if not already done*/\n    if (!p_j2k->cstr_index->tile_index) {\n        if (!opj_j2k_allocate_tile_element_cstr_index(p_j2k)) {\n            opj_free(l_current_data);\n            return OPJ_FALSE;\n        }\n    }\n    /* Move into the codestream to the first SOT used to decode the desired tile */\n    l_tile_no_to_dec = (OPJ_UINT32)\n                       p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;\n    if (p_j2k->cstr_index->tile_index)\n        if (p_j2k->cstr_index->tile_index->tp_index) {\n            if (! p_j2k->cstr_index->tile_index[l_tile_no_to_dec].nb_tps) {\n                /* the index for this tile has not been built,\n                 *  so move to the last SOT read */\n                if (!(opj_stream_read_seek(p_stream,\n                                           p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos + 2, p_manager))) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Problem with seek function\\n\");\n                    opj_free(l_current_data);\n                    return OPJ_FALSE;\n                }\n            } else {\n                if (!(opj_stream_read_seek(p_stream,\n                                           p_j2k->cstr_index->tile_index[l_tile_no_to_dec].tp_index[0].start_pos + 2,\n                                           p_manager))) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Problem with seek function\\n\");\n                    opj_free(l_current_data);\n                    return OPJ_FALSE;\n                }\n            }\n            /* Special case if we have previously read the EOC marker (if the previous tile getted is the last ) */\n            if (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_EOC) {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n            }\n        }\n\n    /* Reset current tile part number for all tiles, and not only the one */\n    /* of interest. */\n    /* Not completely sure this is always correct but required for */\n    /* ./build/bin/j2k_random_tile_access ./build/tests/tte1.j2k */\n    l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;\n    for (i = 0; i < l_nb_tiles; ++i) {\n        p_j2k->m_cp.tcps[i].m_current_tile_part_number = -1;\n    }\n\n    for (;;) {\n        if (! opj_j2k_read_tile_header(p_j2k,\n                                       &l_current_tile_no,\n                                       &l_data_size,\n                                       &l_tile_x0, &l_tile_y0,\n                                       &l_tile_x1, &l_tile_y1,\n                                       &l_nb_comps,\n                                       &l_go_on,\n                                       p_stream,\n                                       p_manager)) {\n            opj_free(l_current_data);\n            return OPJ_FALSE;\n        }\n\n        if (! l_go_on) {\n            break;\n        }\n\n        if (l_data_size > l_max_data_size) {\n            OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data,\n                                           l_data_size);\n            if (! l_new_current_data) {\n                opj_free(l_current_data);\n                l_current_data = NULL;\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tile %d/%d\\n\",\n                              l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n                return OPJ_FALSE;\n            }\n            l_current_data = l_new_current_data;\n            l_max_data_size = l_data_size;\n        }\n\n        if (! opj_j2k_decode_tile(p_j2k, l_current_tile_no, l_current_data, l_data_size,\n                                  p_stream, p_manager)) {\n            opj_free(l_current_data);\n            return OPJ_FALSE;\n        }\n        opj_event_msg(p_manager, EVT_INFO, \"Tile %d/%d has been decoded.\\n\",\n                      l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n\n        if (! opj_j2k_update_image_data(p_j2k->m_tcd, l_current_data,\n                                        p_j2k->m_output_image)) {\n            opj_free(l_current_data);\n            return OPJ_FALSE;\n        }\n        opj_event_msg(p_manager, EVT_INFO,\n                      \"Image data has been updated with tile %d.\\n\\n\", l_current_tile_no + 1);\n\n        if (l_current_tile_no == l_tile_no_to_dec) {\n            /* move into the codestream to the first SOT (FIXME or not move?)*/\n            if (!(opj_stream_read_seek(p_stream, p_j2k->cstr_index->main_head_end + 2,\n                                       p_manager))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Problem with seek function\\n\");\n                opj_free(l_current_data);\n                return OPJ_FALSE;\n            }\n            break;\n        } else {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"Tile read, decoded and updated is not the desired one (%d vs %d).\\n\",\n                          l_current_tile_no + 1, l_tile_no_to_dec + 1);\n        }\n\n    }\n\n    opj_free(l_current_data);\n\n    return OPJ_TRUE;\n}\n\n/**\n * Sets up the procedures to do on decoding one tile. Developpers wanting to extend the library can add their own reading procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_decoding_tile(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager)\n{\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_decode_one_tile, p_manager)) {\n        return OPJ_FALSE;\n    }\n    /* DEVELOPER CORNER, add your custom procedures */\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_decode(opj_j2k_t * p_j2k,\n                        opj_stream_private_t * p_stream,\n                        opj_image_t * p_image,\n                        opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 compno;\n\n    if (!p_image) {\n        return OPJ_FALSE;\n    }\n\n    p_j2k->m_output_image = opj_image_create0();\n    if (!(p_j2k->m_output_image)) {\n        return OPJ_FALSE;\n    }\n    opj_copy_image_header(p_image, p_j2k->m_output_image);\n\n    /* customization of the decoding */\n    if (!opj_j2k_setup_decoding(p_j2k, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* Decode the codestream */\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n        return OPJ_FALSE;\n    }\n\n    /* Move data and copy one information from codec to output image*/\n    for (compno = 0; compno < p_image->numcomps; compno++) {\n        p_image->comps[compno].resno_decoded =\n            p_j2k->m_output_image->comps[compno].resno_decoded;\n        p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n#if 0\n        char fn[256];\n        sprintf(fn, \"/tmp/%d.raw\", compno);\n        FILE *debug = fopen(fn, \"wb\");\n        fwrite(p_image->comps[compno].data, sizeof(OPJ_INT32),\n               p_image->comps[compno].w * p_image->comps[compno].h, debug);\n        fclose(debug);\n#endif\n        p_j2k->m_output_image->comps[compno].data = NULL;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k,\n                          opj_stream_private_t *p_stream,\n                          opj_image_t* p_image,\n                          opj_event_mgr_t * p_manager,\n                          OPJ_UINT32 tile_index)\n{\n    OPJ_UINT32 compno;\n    OPJ_UINT32 l_tile_x, l_tile_y;\n    opj_image_comp_t* l_img_comp;\n\n    if (!p_image) {\n        opj_event_msg(p_manager, EVT_ERROR, \"We need an image previously created.\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (/*(tile_index < 0) &&*/ (tile_index >= p_j2k->m_cp.tw * p_j2k->m_cp.th)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Tile index provided by the user is incorrect %d (max = %d) \\n\", tile_index,\n                      (p_j2k->m_cp.tw * p_j2k->m_cp.th) - 1);\n        return OPJ_FALSE;\n    }\n\n    /* Compute the dimension of the desired tile*/\n    l_tile_x = tile_index % p_j2k->m_cp.tw;\n    l_tile_y = tile_index / p_j2k->m_cp.tw;\n\n    p_image->x0 = l_tile_x * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;\n    if (p_image->x0 < p_j2k->m_private_image->x0) {\n        p_image->x0 = p_j2k->m_private_image->x0;\n    }\n    p_image->x1 = (l_tile_x + 1) * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;\n    if (p_image->x1 > p_j2k->m_private_image->x1) {\n        p_image->x1 = p_j2k->m_private_image->x1;\n    }\n\n    p_image->y0 = l_tile_y * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;\n    if (p_image->y0 < p_j2k->m_private_image->y0) {\n        p_image->y0 = p_j2k->m_private_image->y0;\n    }\n    p_image->y1 = (l_tile_y + 1) * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;\n    if (p_image->y1 > p_j2k->m_private_image->y1) {\n        p_image->y1 = p_j2k->m_private_image->y1;\n    }\n\n    l_img_comp = p_image->comps;\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        OPJ_INT32 l_comp_x1, l_comp_y1;\n\n        l_img_comp->factor = p_j2k->m_private_image->comps[compno].factor;\n\n        l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0,\n                         (OPJ_INT32)l_img_comp->dx);\n        l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0,\n                         (OPJ_INT32)l_img_comp->dy);\n        l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);\n        l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);\n\n        l_img_comp->w = (OPJ_UINT32)(opj_int_ceildivpow2(l_comp_x1,\n                                     (OPJ_INT32)l_img_comp->factor) - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0,\n                                             (OPJ_INT32)l_img_comp->factor));\n        l_img_comp->h = (OPJ_UINT32)(opj_int_ceildivpow2(l_comp_y1,\n                                     (OPJ_INT32)l_img_comp->factor) - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0,\n                                             (OPJ_INT32)l_img_comp->factor));\n\n        l_img_comp++;\n    }\n\n    /* Destroy the previous output image*/\n    if (p_j2k->m_output_image) {\n        opj_image_destroy(p_j2k->m_output_image);\n    }\n\n    /* Create the ouput image from the information previously computed*/\n    p_j2k->m_output_image = opj_image_create0();\n    if (!(p_j2k->m_output_image)) {\n        return OPJ_FALSE;\n    }\n    opj_copy_image_header(p_image, p_j2k->m_output_image);\n\n    p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = (OPJ_INT32)tile_index;\n\n    /* customization of the decoding */\n    if (!opj_j2k_setup_decoding_tile(p_j2k, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* Decode the codestream */\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n        return OPJ_FALSE;\n    }\n\n    /* Move data and copy one information from codec to output image*/\n    for (compno = 0; compno < p_image->numcomps; compno++) {\n        p_image->comps[compno].resno_decoded =\n            p_j2k->m_output_image->comps[compno].resno_decoded;\n\n        if (p_image->comps[compno].data) {\n            opj_image_data_free(p_image->comps[compno].data);\n        }\n\n        p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n\n        p_j2k->m_output_image->comps[compno].data = NULL;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k,\n        OPJ_UINT32 res_factor,\n        opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 it_comp;\n\n    p_j2k->m_cp.m_specific_param.m_dec.m_reduce = res_factor;\n\n    if (p_j2k->m_private_image) {\n        if (p_j2k->m_private_image->comps) {\n            if (p_j2k->m_specific_param.m_decoder.m_default_tcp) {\n                if (p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps) {\n                    for (it_comp = 0 ; it_comp < p_j2k->m_private_image->numcomps; it_comp++) {\n                        OPJ_UINT32 max_res =\n                            p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[it_comp].numresolutions;\n                        if (res_factor >= max_res) {\n                            opj_event_msg(p_manager, EVT_ERROR,\n                                          \"Resolution factor is greater than the maximum resolution in the component.\\n\");\n                            return OPJ_FALSE;\n                        }\n                        p_j2k->m_private_image->comps[it_comp].factor = res_factor;\n                    }\n                    return OPJ_TRUE;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n\nOPJ_BOOL opj_j2k_encode(opj_j2k_t * p_j2k,\n                        opj_stream_private_t *p_stream,\n                        opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i, j;\n    OPJ_UINT32 l_nb_tiles;\n    OPJ_UINT32 l_max_tile_size = 0, l_current_tile_size;\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_BOOL l_reuse_data = OPJ_FALSE;\n    opj_tcd_t* p_tcd = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    p_tcd = p_j2k->m_tcd;\n\n    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n    if (l_nb_tiles == 1) {\n        l_reuse_data = OPJ_TRUE;\n#ifdef __SSE__\n        for (j = 0; j < p_j2k->m_tcd->image->numcomps; ++j) {\n            opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;\n            if (((size_t)l_img_comp->data & 0xFU) !=\n                    0U) { /* tile data shall be aligned on 16 bytes */\n                l_reuse_data = OPJ_FALSE;\n            }\n        }\n#endif\n    }\n    for (i = 0; i < l_nb_tiles; ++i) {\n        if (! opj_j2k_pre_write_tile(p_j2k, i, p_stream, p_manager)) {\n            if (l_current_data) {\n                opj_free(l_current_data);\n            }\n            return OPJ_FALSE;\n        }\n\n        /* if we only have one tile, then simply set tile component data equal to image component data */\n        /* otherwise, allocate the data */\n        for (j = 0; j < p_j2k->m_tcd->image->numcomps; ++j) {\n            opj_tcd_tilecomp_t* l_tilec = p_tcd->tcd_image->tiles->comps + j;\n            if (l_reuse_data) {\n                opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;\n                l_tilec->data  =  l_img_comp->data;\n                l_tilec->ownsData = OPJ_FALSE;\n            } else {\n                if (! opj_alloc_tile_component_data(l_tilec)) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Error allocating tile component data.\");\n                    if (l_current_data) {\n                        opj_free(l_current_data);\n                    }\n                    return OPJ_FALSE;\n                }\n            }\n        }\n        l_current_tile_size = opj_tcd_get_encoded_tile_size(p_j2k->m_tcd);\n        if (!l_reuse_data) {\n            if (l_current_tile_size > l_max_tile_size) {\n                OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data,\n                                               l_current_tile_size);\n                if (! l_new_current_data) {\n                    if (l_current_data) {\n                        opj_free(l_current_data);\n                    }\n                    opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to encode all tiles\\n\");\n                    return OPJ_FALSE;\n                }\n                l_current_data = l_new_current_data;\n                l_max_tile_size = l_current_tile_size;\n            }\n\n            /* copy image data (32 bit) to l_current_data as contiguous, all-component, zero offset buffer */\n            /* 32 bit components @ 8 bit precision get converted to 8 bit */\n            /* 32 bit components @ 16 bit precision get converted to 16 bit */\n            opj_j2k_get_tile_data(p_j2k->m_tcd, l_current_data);\n\n            /* now copy this data into the tile component */\n            if (! opj_tcd_copy_tile_data(p_j2k->m_tcd, l_current_data,\n                                         l_current_tile_size)) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Size mismatch between tile data and sent data.\");\n                opj_free(l_current_data);\n                return OPJ_FALSE;\n            }\n        }\n\n        if (! opj_j2k_post_write_tile(p_j2k, p_stream, p_manager)) {\n            if (l_current_data) {\n                opj_free(l_current_data);\n            }\n            return OPJ_FALSE;\n        }\n    }\n\n    if (l_current_data) {\n        opj_free(l_current_data);\n    }\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k,\n                              opj_stream_private_t *p_stream,\n                              opj_event_mgr_t * p_manager)\n{\n    /* customization of the encoding */\n    if (! opj_j2k_setup_end_compress(p_j2k, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k,\n                                opj_stream_private_t *p_stream,\n                                opj_image_t * p_image,\n                                opj_event_mgr_t * p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    p_j2k->m_private_image = opj_image_create0();\n    if (! p_j2k->m_private_image) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Failed to allocate image header.\");\n        return OPJ_FALSE;\n    }\n    opj_copy_image_header(p_image, p_j2k->m_private_image);\n\n    /* TODO_MSD: Find a better way */\n    if (p_image->comps) {\n        OPJ_UINT32 it_comp;\n        for (it_comp = 0 ; it_comp < p_image->numcomps; it_comp++) {\n            if (p_image->comps[it_comp].data) {\n                p_j2k->m_private_image->comps[it_comp].data = p_image->comps[it_comp].data;\n                p_image->comps[it_comp].data = NULL;\n\n            }\n        }\n    }\n\n    /* customization of the validation */\n    if (! opj_j2k_setup_encoding_validation(p_j2k, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* validation of the parameters codec */\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* customization of the encoding */\n    if (! opj_j2k_setup_header_writing(p_j2k, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* write header */\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t * p_j2k,\n                                       OPJ_UINT32 p_tile_index,\n                                       opj_stream_private_t *p_stream,\n                                       opj_event_mgr_t * p_manager)\n{\n    (void)p_stream;\n    if (p_tile_index != p_j2k->m_current_tile_number) {\n        opj_event_msg(p_manager, EVT_ERROR, \"The given tile index does not match.\");\n        return OPJ_FALSE;\n    }\n\n    opj_event_msg(p_manager, EVT_INFO, \"tile number %d / %d\\n\",\n                  p_j2k->m_current_tile_number + 1, p_j2k->m_cp.tw * p_j2k->m_cp.th);\n\n    p_j2k->m_specific_param.m_encoder.m_current_tile_part_number = 0;\n    p_j2k->m_tcd->cur_totnum_tp = p_j2k->m_cp.tcps[p_tile_index].m_nb_tile_parts;\n    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;\n\n    /* initialisation before tile encoding  */\n    if (! opj_tcd_init_encode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number,\n                                   p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic void opj_get_tile_dimensions(opj_image_t * l_image,\n                                    opj_tcd_tilecomp_t * l_tilec,\n                                    opj_image_comp_t * l_img_comp,\n                                    OPJ_UINT32* l_size_comp,\n                                    OPJ_UINT32* l_width,\n                                    OPJ_UINT32* l_height,\n                                    OPJ_UINT32* l_offset_x,\n                                    OPJ_UINT32* l_offset_y,\n                                    OPJ_UINT32* l_image_width,\n                                    OPJ_UINT32* l_stride,\n                                    OPJ_UINT32* l_tile_offset)\n{\n    OPJ_UINT32 l_remaining;\n    *l_size_comp = l_img_comp->prec >> 3; /* (/8) */\n    l_remaining = l_img_comp->prec & 7;  /* (%8) */\n    if (l_remaining) {\n        *l_size_comp += 1;\n    }\n\n    if (*l_size_comp == 3) {\n        *l_size_comp = 4;\n    }\n\n    *l_width  = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);\n    *l_height = (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0);\n    *l_offset_x = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->x0,\n                  (OPJ_INT32)l_img_comp->dx);\n    *l_offset_y = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->y0,\n                  (OPJ_INT32)l_img_comp->dy);\n    *l_image_width = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->x1 -\n                     (OPJ_INT32)l_image->x0, (OPJ_INT32)l_img_comp->dx);\n    *l_stride = *l_image_width - *l_width;\n    *l_tile_offset = ((OPJ_UINT32)l_tilec->x0 - *l_offset_x) + ((\n                         OPJ_UINT32)l_tilec->y0 - *l_offset_y) * *l_image_width;\n}\n\nstatic void opj_j2k_get_tile_data(opj_tcd_t * p_tcd, OPJ_BYTE * p_data)\n{\n    OPJ_UINT32 i, j, k = 0;\n\n    for (i = 0; i < p_tcd->image->numcomps; ++i) {\n        opj_image_t * l_image =  p_tcd->image;\n        OPJ_INT32 * l_src_ptr;\n        opj_tcd_tilecomp_t * l_tilec = p_tcd->tcd_image->tiles->comps + i;\n        opj_image_comp_t * l_img_comp = l_image->comps + i;\n        OPJ_UINT32 l_size_comp, l_width, l_height, l_offset_x, l_offset_y,\n                   l_image_width, l_stride, l_tile_offset;\n\n        opj_get_tile_dimensions(l_image,\n                                l_tilec,\n                                l_img_comp,\n                                &l_size_comp,\n                                &l_width,\n                                &l_height,\n                                &l_offset_x,\n                                &l_offset_y,\n                                &l_image_width,\n                                &l_stride,\n                                &l_tile_offset);\n\n        l_src_ptr = l_img_comp->data + l_tile_offset;\n\n        switch (l_size_comp) {\n        case 1: {\n            OPJ_CHAR * l_dest_ptr = (OPJ_CHAR*) p_data;\n            if (l_img_comp->sgnd) {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        *(l_dest_ptr) = (OPJ_CHAR)(*l_src_ptr);\n                        ++l_dest_ptr;\n                        ++l_src_ptr;\n                    }\n                    l_src_ptr += l_stride;\n                }\n            } else {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        *(l_dest_ptr) = (OPJ_CHAR)((*l_src_ptr) & 0xff);\n                        ++l_dest_ptr;\n                        ++l_src_ptr;\n                    }\n                    l_src_ptr += l_stride;\n                }\n            }\n\n            p_data = (OPJ_BYTE*) l_dest_ptr;\n        }\n        break;\n        case 2: {\n            OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_data;\n            if (l_img_comp->sgnd) {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        *(l_dest_ptr++) = (OPJ_INT16)(*(l_src_ptr++));\n                    }\n                    l_src_ptr += l_stride;\n                }\n            } else {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        *(l_dest_ptr++) = (OPJ_INT16)((*(l_src_ptr++)) & 0xffff);\n                    }\n                    l_src_ptr += l_stride;\n                }\n            }\n\n            p_data = (OPJ_BYTE*) l_dest_ptr;\n        }\n        break;\n        case 4: {\n            OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_data;\n            for (j = 0; j < l_height; ++j) {\n                for (k = 0; k < l_width; ++k) {\n                    *(l_dest_ptr++) = *(l_src_ptr++);\n                }\n                l_src_ptr += l_stride;\n            }\n\n            p_data = (OPJ_BYTE*) l_dest_ptr;\n        }\n        break;\n        }\n    }\n}\n\nstatic OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t * p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 l_nb_bytes_written;\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_tile_size = 0;\n    OPJ_UINT32 l_available_data;\n\n    /* preconditions */\n    assert(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);\n\n    l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;\n    l_available_data = l_tile_size;\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;\n\n    l_nb_bytes_written = 0;\n    if (! opj_j2k_write_first_tile_part(p_j2k, l_current_data, &l_nb_bytes_written,\n                                        l_available_data, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n    l_current_data += l_nb_bytes_written;\n    l_available_data -= l_nb_bytes_written;\n\n    l_nb_bytes_written = 0;\n    if (! opj_j2k_write_all_tile_parts(p_j2k, l_current_data, &l_nb_bytes_written,\n                                       l_available_data, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    l_available_data -= l_nb_bytes_written;\n    l_nb_bytes_written = l_tile_size - l_available_data;\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_encoded_tile_data,\n                              l_nb_bytes_written, p_manager) != l_nb_bytes_written) {\n        return OPJ_FALSE;\n    }\n\n    ++p_j2k->m_current_tile_number;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_end_compress(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    /* DEVELOPER CORNER, insert your custom procedures */\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_eoc, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    if (OPJ_IS_CINEMA(p_j2k->m_cp.rsiz)) {\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                               (opj_procedure)opj_j2k_write_updated_tlm, p_manager)) {\n            return OPJ_FALSE;\n        }\n    }\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_epc, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_end_encoding, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_destroy_header_memory, p_manager)) {\n        return OPJ_FALSE;\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,\n                                           (opj_procedure)opj_j2k_build_encoder, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,\n                                           (opj_procedure)opj_j2k_encoding_validation, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* DEVELOPER CORNER, add your custom validation procedure */\n    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,\n                                           (opj_procedure)opj_j2k_mct_validation, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_header_writing(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_init_info, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_soc, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_siz, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_cod, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_qcd, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_all_coc, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_all_qcc, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    if (OPJ_IS_CINEMA(p_j2k->m_cp.rsiz)) {\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                               (opj_procedure)opj_j2k_write_tlm, p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        if (p_j2k->m_cp.rsiz == OPJ_PROFILE_CINEMA_4K) {\n            if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                                   (opj_procedure)opj_j2k_write_poc, p_manager)) {\n                return OPJ_FALSE;\n            }\n        }\n    }\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_regions, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    if (p_j2k->m_cp.comment != 00)  {\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                               (opj_procedure)opj_j2k_write_com, p_manager)) {\n            return OPJ_FALSE;\n        }\n    }\n\n    /* DEVELOPER CORNER, insert your custom procedures */\n    if (p_j2k->m_cp.rsiz & OPJ_EXTENSION_MCT) {\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                               (opj_procedure)opj_j2k_write_mct_data_group, p_manager)) {\n            return OPJ_FALSE;\n        }\n    }\n    /* End of Developer Corner */\n\n    if (p_j2k->cstr_index) {\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                               (opj_procedure)opj_j2k_get_end_header, p_manager)) {\n            return OPJ_FALSE;\n        }\n    }\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_create_tcd, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_update_rates, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k,\n        OPJ_BYTE * p_data,\n        OPJ_UINT32 * p_data_written,\n        OPJ_UINT32 p_total_data_size,\n        opj_stream_private_t *p_stream,\n        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 l_nb_bytes_written = 0;\n    OPJ_UINT32 l_current_nb_bytes_written;\n    OPJ_BYTE * l_begin_data = 00;\n\n    opj_tcd_t * l_tcd = 00;\n    opj_cp_t * l_cp = 00;\n\n    l_tcd = p_j2k->m_tcd;\n    l_cp = &(p_j2k->m_cp);\n\n    l_tcd->cur_pino = 0;\n\n    /*Get number of tile parts*/\n    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;\n\n    /* INDEX >> */\n    /* << INDEX */\n\n    l_current_nb_bytes_written = 0;\n    l_begin_data = p_data;\n    if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream,\n                            p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    l_nb_bytes_written += l_current_nb_bytes_written;\n    p_data += l_current_nb_bytes_written;\n    p_total_data_size -= l_current_nb_bytes_written;\n\n    if (!OPJ_IS_CINEMA(l_cp->rsiz)) {\n#if 0\n        for (compno = 1; compno < p_j2k->m_private_image->numcomps; compno++) {\n            l_current_nb_bytes_written = 0;\n            opj_j2k_write_coc_in_memory(p_j2k, compno, p_data, &l_current_nb_bytes_written,\n                                        p_manager);\n            l_nb_bytes_written += l_current_nb_bytes_written;\n            p_data += l_current_nb_bytes_written;\n            p_total_data_size -= l_current_nb_bytes_written;\n\n            l_current_nb_bytes_written = 0;\n            opj_j2k_write_qcc_in_memory(p_j2k, compno, p_data, &l_current_nb_bytes_written,\n                                        p_manager);\n            l_nb_bytes_written += l_current_nb_bytes_written;\n            p_data += l_current_nb_bytes_written;\n            p_total_data_size -= l_current_nb_bytes_written;\n        }\n#endif\n        if (l_cp->tcps[p_j2k->m_current_tile_number].numpocs) {\n            l_current_nb_bytes_written = 0;\n            opj_j2k_write_poc_in_memory(p_j2k, p_data, &l_current_nb_bytes_written,\n                                        p_manager);\n            l_nb_bytes_written += l_current_nb_bytes_written;\n            p_data += l_current_nb_bytes_written;\n            p_total_data_size -= l_current_nb_bytes_written;\n        }\n    }\n\n    l_current_nb_bytes_written = 0;\n    if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,\n                            p_total_data_size, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    l_nb_bytes_written += l_current_nb_bytes_written;\n    * p_data_written = l_nb_bytes_written;\n\n    /* Writing Psot in SOT marker */\n    opj_write_bytes(l_begin_data + 6, l_nb_bytes_written,\n                    4);                                 /* PSOT */\n\n    if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n        opj_j2k_update_tlm(p_j2k, l_nb_bytes_written);\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k,\n        OPJ_BYTE * p_data,\n        OPJ_UINT32 * p_data_written,\n        OPJ_UINT32 p_total_data_size,\n        opj_stream_private_t *p_stream,\n        struct opj_event_mgr * p_manager\n                                            )\n{\n    OPJ_UINT32 tilepartno = 0;\n    OPJ_UINT32 l_nb_bytes_written = 0;\n    OPJ_UINT32 l_current_nb_bytes_written;\n    OPJ_UINT32 l_part_tile_size;\n    OPJ_UINT32 tot_num_tp;\n    OPJ_UINT32 pino;\n\n    OPJ_BYTE * l_begin_data;\n    opj_tcp_t *l_tcp = 00;\n    opj_tcd_t * l_tcd = 00;\n    opj_cp_t * l_cp = 00;\n\n    l_tcd = p_j2k->m_tcd;\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;\n\n    /*Get number of tile parts*/\n    tot_num_tp = opj_j2k_get_num_tp(l_cp, 0, p_j2k->m_current_tile_number);\n\n    /* start writing remaining tile parts */\n    ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n    for (tilepartno = 1; tilepartno < tot_num_tp ; ++tilepartno) {\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;\n        l_current_nb_bytes_written = 0;\n        l_part_tile_size = 0;\n        l_begin_data = p_data;\n\n        if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream,\n                                p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        l_nb_bytes_written += l_current_nb_bytes_written;\n        p_data += l_current_nb_bytes_written;\n        p_total_data_size -= l_current_nb_bytes_written;\n        l_part_tile_size += l_current_nb_bytes_written;\n\n        l_current_nb_bytes_written = 0;\n        if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,\n                                p_total_data_size, p_stream, p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        p_data += l_current_nb_bytes_written;\n        l_nb_bytes_written += l_current_nb_bytes_written;\n        p_total_data_size -= l_current_nb_bytes_written;\n        l_part_tile_size += l_current_nb_bytes_written;\n\n        /* Writing Psot in SOT marker */\n        opj_write_bytes(l_begin_data + 6, l_part_tile_size,\n                        4);                                   /* PSOT */\n\n        if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n            opj_j2k_update_tlm(p_j2k, l_part_tile_size);\n        }\n\n        ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n    }\n\n    for (pino = 1; pino <= l_tcp->numpocs; ++pino) {\n        l_tcd->cur_pino = pino;\n\n        /*Get number of tile parts*/\n        tot_num_tp = opj_j2k_get_num_tp(l_cp, pino, p_j2k->m_current_tile_number);\n        for (tilepartno = 0; tilepartno < tot_num_tp ; ++tilepartno) {\n            p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;\n            l_current_nb_bytes_written = 0;\n            l_part_tile_size = 0;\n            l_begin_data = p_data;\n\n            if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream,\n                                    p_manager)) {\n                return OPJ_FALSE;\n            }\n\n            l_nb_bytes_written += l_current_nb_bytes_written;\n            p_data += l_current_nb_bytes_written;\n            p_total_data_size -= l_current_nb_bytes_written;\n            l_part_tile_size += l_current_nb_bytes_written;\n\n            l_current_nb_bytes_written = 0;\n\n            if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,\n                                    p_total_data_size, p_stream, p_manager)) {\n                return OPJ_FALSE;\n            }\n\n            l_nb_bytes_written += l_current_nb_bytes_written;\n            p_data += l_current_nb_bytes_written;\n            p_total_data_size -= l_current_nb_bytes_written;\n            l_part_tile_size += l_current_nb_bytes_written;\n\n            /* Writing Psot in SOT marker */\n            opj_write_bytes(l_begin_data + 6, l_part_tile_size,\n                            4);                                   /* PSOT */\n\n            if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n                opj_j2k_update_tlm(p_j2k, l_part_tile_size);\n            }\n\n            ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n        }\n    }\n\n    *p_data_written = l_nb_bytes_written;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k,\n        struct opj_stream_private *p_stream,\n        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 l_tlm_size;\n    OPJ_OFF_T l_tlm_position, l_current_position;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_tlm_size = 5 * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;\n    l_tlm_position = 6 + p_j2k->m_specific_param.m_encoder.m_tlm_start;\n    l_current_position = opj_stream_tell(p_stream);\n\n    if (! opj_stream_seek(p_stream, l_tlm_position, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer, l_tlm_size,\n                              p_manager) != l_tlm_size) {\n        return OPJ_FALSE;\n    }\n\n    if (! opj_stream_seek(p_stream, l_current_position, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k,\n                                     struct opj_stream_private *p_stream,\n                                     struct opj_event_mgr * p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n\n    opj_tcd_destroy(p_j2k->m_tcd);\n    p_j2k->m_tcd = 00;\n\n    if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {\n        opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);\n        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = 0;\n        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = 0;\n    }\n\n    if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {\n        opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);\n        p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = 0;\n    }\n\n    p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = 0;\n\n    return OPJ_TRUE;\n}\n\n/**\n * Destroys the memory associated with the decoding of headers.\n */\nstatic OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager\n                                             )\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n\n    if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {\n        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = 0;\n    }\n\n    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k,\n                                  struct opj_stream_private *p_stream,\n                                  struct opj_event_mgr * p_manager)\n{\n    opj_codestream_info_t * l_cstr_info = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n    (void)l_cstr_info;\n\n    OPJ_UNUSED(p_stream);\n\n    /* TODO mergeV2: check this part which use cstr_info */\n    /*l_cstr_info = p_j2k->cstr_info;\n\n    if (l_cstr_info)  {\n            OPJ_UINT32 compno;\n            l_cstr_info->tile = (opj_tile_info_t *) opj_malloc(p_j2k->m_cp.tw * p_j2k->m_cp.th * sizeof(opj_tile_info_t));\n\n            l_cstr_info->image_w = p_j2k->m_image->x1 - p_j2k->m_image->x0;\n            l_cstr_info->image_h = p_j2k->m_image->y1 - p_j2k->m_image->y0;\n\n            l_cstr_info->prog = (&p_j2k->m_cp.tcps[0])->prg;\n\n            l_cstr_info->tw = p_j2k->m_cp.tw;\n            l_cstr_info->th = p_j2k->m_cp.th;\n\n            l_cstr_info->tile_x = p_j2k->m_cp.tdx;*/        /* new version parser */\n    /*l_cstr_info->tile_y = p_j2k->m_cp.tdy;*/      /* new version parser */\n    /*l_cstr_info->tile_Ox = p_j2k->m_cp.tx0;*/     /* new version parser */\n    /*l_cstr_info->tile_Oy = p_j2k->m_cp.ty0;*/     /* new version parser */\n\n    /*l_cstr_info->numcomps = p_j2k->m_image->numcomps;\n\n    l_cstr_info->numlayers = (&p_j2k->m_cp.tcps[0])->numlayers;\n\n    l_cstr_info->numdecompos = (OPJ_INT32*) opj_malloc(p_j2k->m_image->numcomps * sizeof(OPJ_INT32));\n\n    for (compno=0; compno < p_j2k->m_image->numcomps; compno++) {\n            l_cstr_info->numdecompos[compno] = (&p_j2k->m_cp.tcps[0])->tccps->numresolutions - 1;\n    }\n\n    l_cstr_info->D_max = 0.0;       */      /* ADD Marcela */\n\n    /*l_cstr_info->main_head_start = opj_stream_tell(p_stream);*/ /* position of SOC */\n\n    /*l_cstr_info->maxmarknum = 100;\n    l_cstr_info->marker = (opj_marker_info_t *) opj_malloc(l_cstr_info->maxmarknum * sizeof(opj_marker_info_t));\n    l_cstr_info->marknum = 0;\n    }*/\n\n    return opj_j2k_calculate_tp(p_j2k, &(p_j2k->m_cp),\n                                &p_j2k->m_specific_param.m_encoder.m_total_tile_parts, p_j2k->m_private_image,\n                                p_manager);\n}\n\n/**\n * Creates a tile-coder decoder.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k,\n                                   opj_stream_private_t *p_stream,\n                                   opj_event_mgr_t * p_manager\n                                  )\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_stream);\n\n    p_j2k->m_tcd = opj_tcd_create(OPJ_FALSE);\n\n    if (! p_j2k->m_tcd) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to create Tile Coder\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (!opj_tcd_init(p_j2k->m_tcd, p_j2k->m_private_image, &p_j2k->m_cp,\n                      p_j2k->m_tp)) {\n        opj_tcd_destroy(p_j2k->m_tcd);\n        p_j2k->m_tcd = 00;\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_write_tile(opj_j2k_t * p_j2k,\n                            OPJ_UINT32 p_tile_index,\n                            OPJ_BYTE * p_data,\n                            OPJ_UINT32 p_data_size,\n                            opj_stream_private_t *p_stream,\n                            opj_event_mgr_t * p_manager)\n{\n    if (! opj_j2k_pre_write_tile(p_j2k, p_tile_index, p_stream, p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error while opj_j2k_pre_write_tile with tile index = %d\\n\", p_tile_index);\n        return OPJ_FALSE;\n    } else {\n        OPJ_UINT32 j;\n        /* Allocate data */\n        for (j = 0; j < p_j2k->m_tcd->image->numcomps; ++j) {\n            opj_tcd_tilecomp_t* l_tilec = p_j2k->m_tcd->tcd_image->tiles->comps + j;\n\n            if (! opj_alloc_tile_component_data(l_tilec)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error allocating tile component data.\");\n                return OPJ_FALSE;\n            }\n        }\n\n        /* now copy data into the tile component */\n        if (! opj_tcd_copy_tile_data(p_j2k->m_tcd, p_data, p_data_size)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Size mismatch between tile data and sent data.\");\n            return OPJ_FALSE;\n        }\n        if (! opj_j2k_post_write_tile(p_j2k, p_stream, p_manager)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Error while opj_j2k_post_write_tile with tile index = %d\\n\", p_tile_index);\n            return OPJ_FALSE;\n        }\n    }\n\n    return OPJ_TRUE;\n}\n"], "fixing_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2010-2011, Kaori Hagihara\n * Copyright (c) 2011-2012, Centre National d'Etudes Spatiales (CNES), France\n * Copyright (c) 2012, CS Systemes d'Information, France\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/** @defgroup J2K J2K - JPEG-2000 codestream reader/writer */\n/*@{*/\n\n/** @name Local static functions */\n/*@{*/\n\n#define OPJ_UNUSED(x) (void)x\n\n/**\n * Sets up the procedures to do on reading header. Developpers wanting to extend the library can add their own reading procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_header_reading(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager);\n\n/**\n * The read header procedure.\n */\nstatic OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * The default encoding validation procedure without any extension.\n *\n * @param       p_j2k                   the jpeg2000 codec to validate.\n * @param       p_stream                the input stream to validate.\n * @param       p_manager               the user event manager.\n *\n * @return true if the parameters are correct.\n */\nstatic OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * The default decoding validation procedure without any extension.\n *\n * @param       p_j2k                   the jpeg2000 codec to validate.\n * @param       p_stream                                the input stream to validate.\n * @param       p_manager               the user event manager.\n *\n * @return true if the parameters are correct.\n */\nstatic OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters\n * are valid. Developpers wanting to extend the library can add their own validation procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters\n * are valid. Developpers wanting to extend the library can add their own validation procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters\n * are valid. Developpers wanting to extend the library can add their own validation procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_end_compress(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager);\n\n/**\n * The mct encoding validation procedure.\n *\n * @param       p_j2k                   the jpeg2000 codec to validate.\n * @param       p_stream                                the input stream to validate.\n * @param       p_manager               the user event manager.\n *\n * @return true if the parameters are correct.\n */\nstatic OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t * p_j2k,\n                                       opj_stream_private_t *p_stream,\n                                       opj_event_mgr_t * p_manager);\n\n/**\n * Builds the tcd decoder to use to decode tile.\n */\nstatic OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t * p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager);\n/**\n * Builds the tcd encoder to use to encode tile.\n */\nstatic OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t * p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager);\n\n/**\n * Creates a tile-coder decoder.\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager                   the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k,\n                                   opj_stream_private_t *p_stream,\n                                   opj_event_mgr_t * p_manager);\n\n/**\n * Excutes the given procedures on the given codec.\n *\n * @param       p_procedure_list        the list of procedures to execute\n * @param       p_j2k                           the jpeg2000 codec to execute the procedures on.\n * @param       p_stream                        the stream to execute the procedures on.\n * @param       p_manager                       the user manager.\n *\n * @return      true                            if all the procedures were successfully executed.\n */\nstatic OPJ_BOOL opj_j2k_exec(opj_j2k_t * p_j2k,\n                             opj_procedure_list_t * p_procedure_list,\n                             opj_stream_private_t *p_stream,\n                             opj_event_mgr_t * p_manager);\n\n/**\n * Updates the rates of the tcp.\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k,\n                                     opj_stream_private_t *p_stream,\n                                     opj_event_mgr_t * p_manager);\n\n/**\n * Copies the decoding tile parameters onto all the tile parameters.\n * Creates also the tile decoder.\n */\nstatic OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Destroys the memory associated with the decoding of headers.\n */\nstatic OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Reads the lookup table containing all the marker, status and action, and returns the handler associated\n * with the marker value.\n * @param       p_id            Marker value to look up\n *\n * @return      the handler associated with the id.\n*/\nstatic const struct opj_dec_memory_marker_handler * opj_j2k_get_marker_handler(\n    OPJ_UINT32 p_id);\n\n/**\n * Destroys a tile coding parameter structure.\n *\n * @param       p_tcp           the tile coding parameter to destroy.\n */\nstatic void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp);\n\n/**\n * Destroys the data inside a tile coding parameter structure.\n *\n * @param       p_tcp           the tile coding parameter which contain data to destroy.\n */\nstatic void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp);\n\n/**\n * Destroys a coding parameter structure.\n *\n * @param       p_cp            the coding parameter to destroy.\n */\nstatic void opj_j2k_cp_destroy(opj_cp_t *p_cp);\n\n/**\n * Compare 2 a SPCod/ SPCoc elements, i.e. the coding style of a given component of a tile.\n *\n * @param       p_j2k            J2K codec.\n * @param       p_tile_no        Tile number\n * @param       p_first_comp_no  The 1st component number to compare.\n * @param       p_second_comp_no The 1st component number to compare.\n *\n * @return OPJ_TRUE if SPCdod are equals.\n */\nstatic OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n/**\n * Writes a SPCod or SPCoc element, i.e. the coding style of a given component of a tile.\n *\n * @param       p_j2k           J2K codec.\n * @param       p_tile_no       FIXME DOC\n * @param       p_comp_no       the component number to output.\n * @param       p_data          FIXME DOC\n * @param       p_header_size   FIXME DOC\n * @param       p_manager       the user event manager.\n *\n * @return FIXME DOC\n*/\nstatic OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no,\n        OPJ_UINT32 p_comp_no,\n        OPJ_BYTE * p_data,\n        OPJ_UINT32 * p_header_size,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Gets the size taken by writing a SPCod or SPCoc for the given tile and component.\n *\n * @param       p_j2k                   the J2K codec.\n * @param       p_tile_no               the tile index.\n * @param       p_comp_no               the component being outputted.\n *\n * @return      the number of bytes taken by the SPCod element.\n */\nstatic OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no,\n        OPJ_UINT32 p_comp_no);\n\n/**\n * Reads a SPCod or SPCoc element, i.e. the coding style of a given component of a tile.\n * @param       p_j2k           the jpeg2000 codec.\n * @param       compno          FIXME DOC\n * @param       p_header_data   the data contained in the COM box.\n * @param       p_header_size   the size of the data contained in the COM marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 compno,\n        OPJ_BYTE * p_header_data,\n        OPJ_UINT32 * p_header_size,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Gets the size taken by writing SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_tile_no               the tile index.\n * @param       p_comp_no               the component being outputted.\n * @param       p_j2k                   the J2K codec.\n *\n * @return      the number of bytes taken by the SPCod element.\n */\nstatic OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no,\n        OPJ_UINT32 p_comp_no);\n\n/**\n * Compares 2 SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_tile_no               the tile to output.\n * @param       p_first_comp_no         the first component number to compare.\n * @param       p_second_comp_no        the second component number to compare.\n *\n * @return OPJ_TRUE if equals.\n */\nstatic OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n\n/**\n * Writes a SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_tile_no               the tile to output.\n * @param       p_comp_no               the component number to output.\n * @param       p_data                  the data buffer.\n * @param       p_header_size   pointer to the size of the data buffer, it is changed by the function.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n *\n*/\nstatic OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 p_tile_no,\n                                        OPJ_UINT32 p_comp_no,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_header_size,\n                                        opj_event_mgr_t * p_manager);\n\n/**\n * Updates the Tile Length Marker.\n */\nstatic void opj_j2k_update_tlm(opj_j2k_t * p_j2k, OPJ_UINT32 p_tile_part_size);\n\n/**\n * Reads a SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_j2k           J2K codec.\n * @param       compno          the component number to output.\n * @param       p_header_data   the data buffer.\n * @param       p_header_size   pointer to the size of the data buffer, it is changed by the function.\n * @param       p_manager       the user event manager.\n *\n*/\nstatic OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k,\n                                       OPJ_UINT32 compno,\n                                       OPJ_BYTE * p_header_data,\n                                       OPJ_UINT32 * p_header_size,\n                                       opj_event_mgr_t * p_manager);\n\n/**\n * Copies the tile component parameters of all the component from the first tile component.\n *\n * @param               p_j2k           the J2k codec.\n */\nstatic void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k);\n\n/**\n * Copies the tile quantization parameters of all the component from the first tile component.\n *\n * @param               p_j2k           the J2k codec.\n */\nstatic void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k);\n\n/**\n * Reads the tiles.\n */\nstatic OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k,\n                                     opj_stream_private_t *p_stream,\n                                     opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t * p_j2k,\n                                       OPJ_UINT32 p_tile_index,\n                                       opj_stream_private_t *p_stream,\n                                       opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t * p_tcd, OPJ_BYTE * p_data,\n        opj_image_t* p_output_image);\n\nstatic void opj_get_tile_dimensions(opj_image_t * l_image,\n                                    opj_tcd_tilecomp_t * l_tilec,\n                                    opj_image_comp_t * l_img_comp,\n                                    OPJ_UINT32* l_size_comp,\n                                    OPJ_UINT32* l_width,\n                                    OPJ_UINT32* l_height,\n                                    OPJ_UINT32* l_offset_x,\n                                    OPJ_UINT32* l_offset_y,\n                                    OPJ_UINT32* l_image_width,\n                                    OPJ_UINT32* l_stride,\n                                    OPJ_UINT32* l_tile_offset);\n\nstatic void opj_j2k_get_tile_data(opj_tcd_t * p_tcd, OPJ_BYTE * p_data);\n\nstatic OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t * p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager);\n\n/**\n * Sets up the procedures to do on writing header.\n * Developers wanting to extend the library can add their own writing procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_header_writing(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k,\n        OPJ_BYTE * p_data,\n        OPJ_UINT32 * p_data_written,\n        OPJ_UINT32 p_total_data_size,\n        opj_stream_private_t *p_stream,\n        struct opj_event_mgr * p_manager);\n\nstatic OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k,\n        OPJ_BYTE * p_data,\n        OPJ_UINT32 * p_data_written,\n        OPJ_UINT32 p_total_data_size,\n        opj_stream_private_t *p_stream,\n        struct opj_event_mgr * p_manager);\n\n/**\n * Gets the offset of the header.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k,\n                                       opj_stream_private_t *p_stream,\n                                       opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k);\n\n/*\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n */\n\n/**\n * Writes the SOC marker (Start Of Codestream)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a SOC marker (Start of Codestream)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_stream        XXX needs data\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the SIZ marker (image and tile size)\n *\n * @param       p_j2k           J2K codec.\n * @param       p_stream        the stream to write data to.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a SIZ marker (image and tile size)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the SIZ box.\n * @param       p_header_size   the size of the data contained in the SIZ marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the COM marker (comment)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a COM marker (comments)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the COM box.\n * @param       p_header_size   the size of the data contained in the COM marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n/**\n * Writes the COD marker (Coding style default)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a COD marker (Coding Styke defaults)\n * @param       p_header_data   the data contained in the COD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Compares 2 COC markers (Coding style component)\n *\n * @param       p_j2k            J2K codec.\n * @param       p_first_comp_no  the index of the first component to compare.\n * @param       p_second_comp_no the index of the second component to compare.\n *\n * @return      OPJ_TRUE if equals\n */\nstatic OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k,\n                                    OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n/**\n * Writes the COC marker (Coding style component)\n *\n * @param       p_j2k       J2K codec.\n * @param       p_comp_no   the index of the component to output.\n * @param       p_stream    the stream to write data to.\n * @param       p_manager   the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k,\n                                  OPJ_UINT32 p_comp_no,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Writes the COC marker (Coding style component)\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_comp_no               the index of the component to output.\n * @param       p_data          FIXME DOC\n * @param       p_data_written  FIXME DOC\n * @param       p_manager               the user event manager.\n*/\nstatic void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 p_comp_no,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_data_written,\n                                        opj_event_mgr_t * p_manager);\n\n/**\n * Gets the maximum size taken by a coc.\n *\n * @param       p_j2k   the jpeg2000 codec to use.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k);\n\n/**\n * Reads a COC marker (Coding Style Component)\n * @param       p_header_data   the data contained in the COC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the QCD marker (quantization default)\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_stream                the stream to write data to.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a QCD marker (Quantization defaults)\n * @param       p_header_data   the data contained in the QCD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Compare QCC markers (quantization component)\n *\n * @param       p_j2k                 J2K codec.\n * @param       p_first_comp_no       the index of the first component to compare.\n * @param       p_second_comp_no      the index of the second component to compare.\n *\n * @return OPJ_TRUE if equals.\n */\nstatic OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k,\n                                    OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n/**\n * Writes the QCC marker (quantization component)\n *\n * @param       p_comp_no       the index of the component to output.\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k,\n                                  OPJ_UINT32 p_comp_no,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Writes the QCC marker (quantization component)\n *\n * @param       p_j2k           J2K codec.\n * @param       p_comp_no       the index of the component to output.\n * @param       p_data          FIXME DOC\n * @param       p_data_written  the stream to write data to.\n * @param       p_manager       the user event manager.\n*/\nstatic void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 p_comp_no,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_data_written,\n                                        opj_event_mgr_t * p_manager);\n\n/**\n * Gets the maximum size taken by a qcc.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k);\n\n/**\n * Reads a QCC marker (Quantization component)\n * @param       p_header_data   the data contained in the QCC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n/**\n * Writes the POC marker (Progression Order Change)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n/**\n * Writes the POC marker (Progression Order Change)\n *\n * @param       p_j2k          J2K codec.\n * @param       p_data         FIXME DOC\n * @param       p_data_written the stream to write data to.\n * @param       p_manager      the user event manager.\n */\nstatic void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_data_written,\n                                        opj_event_mgr_t * p_manager);\n/**\n * Gets the maximum size taken by the writing of a POC.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k);\n\n/**\n * Reads a POC marker (Progression Order Change)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Gets the maximum size taken by the toc headers of all the tile parts of any given tile.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k);\n\n/**\n * Gets the maximum size taken by the headers of the SOT.\n *\n * @param       p_j2k   the jpeg2000 codec to use.\n */\nstatic OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k);\n\n/**\n * Reads a CRG marker (Component registration)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n/**\n * Reads a TLM marker (Tile Length Marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the updated tlm.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Reads a PLM marker (Packet length, main header marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n/**\n * Reads a PLT marker (Packet length, tile-part header)\n *\n * @param       p_header_data   the data contained in the PLT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PLT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Reads a PPM marker (Packed headers, main header)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n */\n\nstatic OPJ_BOOL opj_j2k_read_ppm(\n    opj_j2k_t *p_j2k,\n    OPJ_BYTE * p_header_data,\n    OPJ_UINT32 p_header_size,\n    opj_event_mgr_t * p_manager);\n\n/**\n * Merges all PPM markers read (Packed headers, main header)\n *\n * @param       p_cp      main coding parameters.\n * @param       p_manager the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppm(opj_cp_t *p_cp, opj_event_mgr_t * p_manager);\n\n/**\n * Reads a PPT marker (Packed packet headers, tile-part header)\n *\n * @param       p_header_data   the data contained in the PPT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PPT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Merges all PPT markers read (Packed headers, tile-part header)\n *\n * @param       p_tcp   the tile.\n * @param       p_manager               the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp,\n                                  opj_event_mgr_t * p_manager);\n\n\n/**\n * Writes the TLM marker (Tile Length Marker)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Writes the SOT marker (Start of tile-part)\n *\n * @param       p_j2k            J2K codec.\n * @param       p_data           FIXME DOC\n * @param       p_data_written   FIXME DOC\n * @param       p_stream         the stream to write data to.\n * @param       p_manager        the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads values from a SOT marker (Start of tile-part)\n *\n * the j2k decoder state is not affected. No side effects, no checks except for p_header_size.\n *\n * @param       p_header_data   the data contained in the SOT marker.\n * @param       p_header_size   the size of the data contained in the SOT marker.\n * @param       p_tile_no       Isot.\n * @param       p_tot_len       Psot.\n * @param       p_current_part  TPsot.\n * @param       p_num_parts     TNsot.\n * @param       p_manager       the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *  p_header_data,\n                                       OPJ_UINT32  p_header_size,\n                                       OPJ_UINT32* p_tile_no,\n                                       OPJ_UINT32* p_tot_len,\n                                       OPJ_UINT32* p_current_part,\n                                       OPJ_UINT32* p_num_parts,\n                                       opj_event_mgr_t * p_manager);\n/**\n * Reads a SOT marker (Start of tile-part)\n *\n * @param       p_header_data   the data contained in the SOT marker.\n * @param       p_j2k           the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PPT marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n/**\n * Writes the SOD marker (Start of data)\n *\n * @param       p_j2k               J2K codec.\n * @param       p_tile_coder        FIXME DOC\n * @param       p_data              FIXME DOC\n * @param       p_data_written      FIXME DOC\n * @param       p_total_data_size   FIXME DOC\n * @param       p_stream            the stream to write data to.\n * @param       p_manager           the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,\n                                  opj_tcd_t * p_tile_coder,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  OPJ_UINT32 p_total_data_size,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a SOD marker (Start Of Data)\n *\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_stream                FIXME DOC\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 opj_event_mgr_t * p_manager);\n\nstatic void opj_j2k_update_tlm(opj_j2k_t * p_j2k, OPJ_UINT32 p_tile_part_size)\n{\n    opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,\n                    p_j2k->m_current_tile_number, 1);           /* PSOT */\n    ++p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current;\n\n    opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,\n                    p_tile_part_size, 4);                                       /* PSOT */\n    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 4;\n}\n\n/**\n * Writes the RGN marker (Region Of Interest)\n *\n * @param       p_tile_no               the tile to output\n * @param       p_comp_no               the component to output\n * @param       nb_comps                the number of components\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k,\n                                  OPJ_UINT32 p_tile_no,\n                                  OPJ_UINT32 p_comp_no,\n                                  OPJ_UINT32 nb_comps,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a RGN marker (Region Of Interest)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the EOC marker (End of Codestream)\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n#if 0\n/**\n * Reads a EOC marker (End Of Codestream)\n *\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_stream                FIXME DOC\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_eoc(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 opj_event_mgr_t * p_manager);\n#endif\n\n/**\n * Writes the CBD-MCT-MCC-MCO markers (Multi components transform)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Inits the Info\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\nAdd main header marker information\n@param cstr_index    Codestream information structure\n@param type         marker type\n@param pos          byte offset of marker segment\n@param len          length of marker segment\n */\nstatic OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index,\n                                     OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len) ;\n/**\nAdd tile header marker information\n@param tileno       tile index number\n@param cstr_index   Codestream information structure\n@param type         marker type\n@param pos          byte offset of marker segment\n@param len          length of marker segment\n */\nstatic OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno,\n                                     opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos,\n                                     OPJ_UINT32 len);\n\n/**\n * Reads an unknown marker\n *\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_stream                the stream object to read from.\n * @param       output_marker           FIXME DOC\n * @param       p_manager               the user event manager.\n *\n * @return      true                    if the marker could be deduced.\n*/\nstatic OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 OPJ_UINT32 *output_marker,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the MCT marker (Multiple Component Transform)\n *\n * @param       p_j2k           J2K codec.\n * @param       p_mct_record    FIXME DOC\n * @param       p_stream        the stream to write data to.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k,\n        opj_mct_data_t * p_mct_record,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Reads a MCT marker (Multiple Component Transform)\n *\n * @param       p_header_data   the data contained in the MCT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the MCC marker (Multiple Component Collection)\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_mcc_record            FIXME DOC\n * @param       p_stream                the stream to write data to.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k,\n        opj_simple_mcc_decorrelation_data_t * p_mcc_record,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager);\n\n/**\n * Reads a MCC marker (Multiple Component Collection)\n *\n * @param       p_header_data   the data contained in the MCC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the MCO marker (Multiple component transformation ordering)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a MCO marker (Multiple Component Transform Ordering)\n *\n * @param       p_header_data   the data contained in the MCO box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCO marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_add_mct(opj_tcp_t * p_tcp, opj_image_t * p_image,\n                                OPJ_UINT32 p_index);\n\nstatic void  opj_j2k_read_int16_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_int32_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float32_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float64_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\nstatic void  opj_j2k_read_int16_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_int32_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float32_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float64_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\nstatic void  opj_j2k_write_float_to_int16(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_write_float_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_write_float_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_write_float_to_float64(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\n/**\n * Ends the encoding, i.e. frees memory.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k,\n                                     opj_stream_private_t *p_stream,\n                                     opj_event_mgr_t * p_manager);\n\n/**\n * Writes the CBD marker (Component bit depth definition)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Reads a CBD marker (Component bit depth definition)\n * @param       p_header_data   the data contained in the CBD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the CBD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n\n/**\n * Writes COC marker for each component.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_all_coc(opj_j2k_t *p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager);\n\n/**\n * Writes QCC marker for each component.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_all_qcc(opj_j2k_t *p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager);\n\n/**\n * Writes regions of interests.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager);\n\n/**\n * Writes EPC ????\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager);\n\n/**\n * Checks the progression order changes values. Tells of the poc given as input are valid.\n * A nice message is outputted at errors.\n *\n * @param       p_pocs                  the progression order changes.\n * @param       p_nb_pocs               the number of progression order changes.\n * @param       p_nb_resolutions        the number of resolutions.\n * @param       numcomps                the number of components\n * @param       numlayers               the number of layers.\n * @param       p_manager               the user event manager.\n *\n * @return      true if the pocs are valid.\n */\nstatic OPJ_BOOL opj_j2k_check_poc_val(const opj_poc_t *p_pocs,\n                                      OPJ_UINT32 p_nb_pocs,\n                                      OPJ_UINT32 p_nb_resolutions,\n                                      OPJ_UINT32 numcomps,\n                                      OPJ_UINT32 numlayers,\n                                      opj_event_mgr_t * p_manager);\n\n/**\n * Gets the number of tile parts used for the given change of progression (if any) and the given tile.\n *\n * @param               cp                      the coding parameters.\n * @param               pino            the offset of the given poc (i.e. its position in the coding parameter).\n * @param               tileno          the given tile.\n *\n * @return              the number of tile parts.\n */\nstatic OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp, OPJ_UINT32 pino,\n                                     OPJ_UINT32 tileno);\n\n/**\n * Calculates the total number of tile parts needed by the encoder to\n * encode such an image. If not enough memory is available, then the function return false.\n *\n * @param       p_nb_tiles      pointer that will hold the number of tile parts.\n * @param       cp                      the coding parameters for the image.\n * @param       image           the image to encode.\n * @param       p_j2k                   the p_j2k encoder.\n * @param       p_manager       the user event manager.\n *\n * @return true if the function was successful, false else.\n */\nstatic OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k,\n                                     opj_cp_t *cp,\n                                     OPJ_UINT32 * p_nb_tiles,\n                                     opj_image_t *image,\n                                     opj_event_mgr_t * p_manager);\n\nstatic void opj_j2k_dump_MH_info(opj_j2k_t* p_j2k, FILE* out_stream);\n\nstatic void opj_j2k_dump_MH_index(opj_j2k_t* p_j2k, FILE* out_stream);\n\nstatic opj_codestream_index_t* opj_j2k_create_cstr_index(void);\n\nstatic OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t * p_tcp);\n\nstatic OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t * p_tcp);\n\nstatic int opj_j2k_initialise_4K_poc(opj_poc_t *POC, int numres);\n\nstatic void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,\n        opj_image_t *image, opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image, OPJ_UINT16 rsiz,\n        opj_event_mgr_t *p_manager);\n\n/**\n * Checks for invalid number of tile-parts in SOT marker (TPsot==TNsot). See issue 254.\n *\n * @param       p_stream            the stream to read data from.\n * @param       tile_no             tile number we're looking for.\n * @param       p_correction_needed output value. if true, non conformant codestream needs TNsot correction.\n * @param       p_manager       the user event manager.\n *\n * @return true if the function was successful, false else.\n */\nstatic OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t\n        *p_stream, OPJ_UINT32 tile_no, OPJ_BOOL* p_correction_needed,\n        opj_event_mgr_t * p_manager);\n\n/*@}*/\n\n/*@}*/\n\n/* ----------------------------------------------------------------------- */\ntypedef struct j2k_prog_order {\n    OPJ_PROG_ORDER enum_prog;\n    char str_prog[5];\n} j2k_prog_order_t;\n\nstatic const j2k_prog_order_t j2k_prog_order_list[] = {\n    {OPJ_CPRL, \"CPRL\"},\n    {OPJ_LRCP, \"LRCP\"},\n    {OPJ_PCRL, \"PCRL\"},\n    {OPJ_RLCP, \"RLCP\"},\n    {OPJ_RPCL, \"RPCL\"},\n    {(OPJ_PROG_ORDER) - 1, \"\"}\n};\n\n/**\n * FIXME DOC\n */\nstatic const OPJ_UINT32 MCT_ELEMENT_SIZE [] = {\n    2,\n    4,\n    4,\n    8\n};\n\ntypedef void (* opj_j2k_mct_function)(const void * p_src_data,\n                                      void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\nstatic const opj_j2k_mct_function j2k_mct_read_functions_to_float [] = {\n    opj_j2k_read_int16_to_float,\n    opj_j2k_read_int32_to_float,\n    opj_j2k_read_float32_to_float,\n    opj_j2k_read_float64_to_float\n};\n\nstatic const opj_j2k_mct_function j2k_mct_read_functions_to_int32 [] = {\n    opj_j2k_read_int16_to_int32,\n    opj_j2k_read_int32_to_int32,\n    opj_j2k_read_float32_to_int32,\n    opj_j2k_read_float64_to_int32\n};\n\nstatic const opj_j2k_mct_function j2k_mct_write_functions_from_float [] = {\n    opj_j2k_write_float_to_int16,\n    opj_j2k_write_float_to_int32,\n    opj_j2k_write_float_to_float,\n    opj_j2k_write_float_to_float64\n};\n\ntypedef struct opj_dec_memory_marker_handler {\n    /** marker value */\n    OPJ_UINT32 id;\n    /** value of the state when the marker can appear */\n    OPJ_UINT32 states;\n    /** action linked to the marker */\n    OPJ_BOOL(*handler)(opj_j2k_t *p_j2k,\n                       OPJ_BYTE * p_header_data,\n                       OPJ_UINT32 p_header_size,\n                       opj_event_mgr_t * p_manager);\n}\nopj_dec_memory_marker_handler_t;\n\nstatic const opj_dec_memory_marker_handler_t j2k_memory_marker_handler_tab [] =\n{\n    {J2K_MS_SOT, J2K_STATE_MH | J2K_STATE_TPHSOT, opj_j2k_read_sot},\n    {J2K_MS_COD, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_cod},\n    {J2K_MS_COC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_coc},\n    {J2K_MS_RGN, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_rgn},\n    {J2K_MS_QCD, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_qcd},\n    {J2K_MS_QCC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_qcc},\n    {J2K_MS_POC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_poc},\n    {J2K_MS_SIZ, J2K_STATE_MHSIZ, opj_j2k_read_siz},\n    {J2K_MS_TLM, J2K_STATE_MH, opj_j2k_read_tlm},\n    {J2K_MS_PLM, J2K_STATE_MH, opj_j2k_read_plm},\n    {J2K_MS_PLT, J2K_STATE_TPH, opj_j2k_read_plt},\n    {J2K_MS_PPM, J2K_STATE_MH, opj_j2k_read_ppm},\n    {J2K_MS_PPT, J2K_STATE_TPH, opj_j2k_read_ppt},\n    {J2K_MS_SOP, 0, 0},\n    {J2K_MS_CRG, J2K_STATE_MH, opj_j2k_read_crg},\n    {J2K_MS_COM, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_com},\n    {J2K_MS_MCT, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mct},\n    {J2K_MS_CBD, J2K_STATE_MH, opj_j2k_read_cbd},\n    {J2K_MS_MCC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mcc},\n    {J2K_MS_MCO, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mco},\n#ifdef USE_JPWL\n#ifdef TODO_MS /* remove these functions which are not commpatible with the v2 API */\n    {J2K_MS_EPC, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epc},\n    {J2K_MS_EPB, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epb},\n    {J2K_MS_ESD, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_esd},\n    {J2K_MS_RED, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_red},\n#endif\n#endif /* USE_JPWL */\n#ifdef USE_JPSEC\n    {J2K_MS_SEC, J2K_DEC_STATE_MH, j2k_read_sec},\n    {J2K_MS_INSEC, 0, j2k_read_insec}\n#endif /* USE_JPSEC */\n    {J2K_MS_UNK, J2K_STATE_MH | J2K_STATE_TPH, 0}/*opj_j2k_read_unk is directly used*/\n};\n\nstatic void  opj_j2k_read_int16_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_bytes(l_src_data, &l_temp, 2);\n\n        l_src_data += sizeof(OPJ_INT16);\n\n        *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_int32_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_bytes(l_src_data, &l_temp, 4);\n\n        l_src_data += sizeof(OPJ_INT32);\n\n        *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_float32_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_FLOAT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_float(l_src_data, &l_temp);\n\n        l_src_data += sizeof(OPJ_FLOAT32);\n\n        *(l_dest_data++) = l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_float64_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_FLOAT64 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_double(l_src_data, &l_temp);\n\n        l_src_data += sizeof(OPJ_FLOAT64);\n\n        *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_int16_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_bytes(l_src_data, &l_temp, 2);\n\n        l_src_data += sizeof(OPJ_INT16);\n\n        *(l_dest_data++) = (OPJ_INT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_int32_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_bytes(l_src_data, &l_temp, 4);\n\n        l_src_data += sizeof(OPJ_INT32);\n\n        *(l_dest_data++) = (OPJ_INT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_float32_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_FLOAT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_float(l_src_data, &l_temp);\n\n        l_src_data += sizeof(OPJ_FLOAT32);\n\n        *(l_dest_data++) = (OPJ_INT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_read_float64_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n    OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n    OPJ_UINT32 i;\n    OPJ_FLOAT64 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        opj_read_double(l_src_data, &l_temp);\n\n        l_src_data += sizeof(OPJ_FLOAT64);\n\n        *(l_dest_data++) = (OPJ_INT32) l_temp;\n    }\n}\n\nstatic void  opj_j2k_write_float_to_int16(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n    OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        l_temp = (OPJ_UINT32) * (l_src_data++);\n\n        opj_write_bytes(l_dest_data, l_temp, sizeof(OPJ_INT16));\n\n        l_dest_data += sizeof(OPJ_INT16);\n    }\n}\n\nstatic void opj_j2k_write_float_to_int32(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n    OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        l_temp = (OPJ_UINT32) * (l_src_data++);\n\n        opj_write_bytes(l_dest_data, l_temp, sizeof(OPJ_INT32));\n\n        l_dest_data += sizeof(OPJ_INT32);\n    }\n}\n\nstatic void  opj_j2k_write_float_to_float(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n    OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n    OPJ_UINT32 i;\n    OPJ_FLOAT32 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        l_temp = (OPJ_FLOAT32) * (l_src_data++);\n\n        opj_write_float(l_dest_data, l_temp);\n\n        l_dest_data += sizeof(OPJ_FLOAT32);\n    }\n}\n\nstatic void  opj_j2k_write_float_to_float64(const void * p_src_data,\n        void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n    OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n    OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n    OPJ_UINT32 i;\n    OPJ_FLOAT64 l_temp;\n\n    for (i = 0; i < p_nb_elem; ++i) {\n        l_temp = (OPJ_FLOAT64) * (l_src_data++);\n\n        opj_write_double(l_dest_data, l_temp);\n\n        l_dest_data += sizeof(OPJ_FLOAT64);\n    }\n}\n\nconst char *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order)\n{\n    const j2k_prog_order_t *po;\n    for (po = j2k_prog_order_list; po->enum_prog != -1; po++) {\n        if (po->enum_prog == prg_order) {\n            return po->str_prog;\n        }\n    }\n    return po->str_prog;\n}\n\nstatic OPJ_BOOL opj_j2k_check_poc_val(const opj_poc_t *p_pocs,\n                                      OPJ_UINT32 p_nb_pocs,\n                                      OPJ_UINT32 p_nb_resolutions,\n                                      OPJ_UINT32 p_num_comps,\n                                      OPJ_UINT32 p_num_layers,\n                                      opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32* packet_array;\n    OPJ_UINT32 index, resno, compno, layno;\n    OPJ_UINT32 i;\n    OPJ_UINT32 step_c = 1;\n    OPJ_UINT32 step_r = p_num_comps * step_c;\n    OPJ_UINT32 step_l = p_nb_resolutions * step_r;\n    OPJ_BOOL loss = OPJ_FALSE;\n    OPJ_UINT32 layno0 = 0;\n\n    packet_array = (OPJ_UINT32*) opj_calloc(step_l * p_num_layers,\n                                            sizeof(OPJ_UINT32));\n    if (packet_array == 00) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory for checking the poc values.\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (p_nb_pocs == 0) {\n        opj_free(packet_array);\n        return OPJ_TRUE;\n    }\n\n    index = step_r * p_pocs->resno0;\n    /* take each resolution for each poc */\n    for (resno = p_pocs->resno0 ; resno < p_pocs->resno1 ; ++resno) {\n        OPJ_UINT32 res_index = index + p_pocs->compno0 * step_c;\n\n        /* take each comp of each resolution for each poc */\n        for (compno = p_pocs->compno0 ; compno < p_pocs->compno1 ; ++compno) {\n            OPJ_UINT32 comp_index = res_index + layno0 * step_l;\n\n            /* and finally take each layer of each res of ... */\n            for (layno = layno0; layno < p_pocs->layno1 ; ++layno) {\n                /*index = step_r * resno + step_c * compno + step_l * layno;*/\n                packet_array[comp_index] = 1;\n                comp_index += step_l;\n            }\n\n            res_index += step_c;\n        }\n\n        index += step_r;\n    }\n    ++p_pocs;\n\n    /* iterate through all the pocs */\n    for (i = 1; i < p_nb_pocs ; ++i) {\n        OPJ_UINT32 l_last_layno1 = (p_pocs - 1)->layno1 ;\n\n        layno0 = (p_pocs->layno1 > l_last_layno1) ? l_last_layno1 : 0;\n        index = step_r * p_pocs->resno0;\n\n        /* take each resolution for each poc */\n        for (resno = p_pocs->resno0 ; resno < p_pocs->resno1 ; ++resno) {\n            OPJ_UINT32 res_index = index + p_pocs->compno0 * step_c;\n\n            /* take each comp of each resolution for each poc */\n            for (compno = p_pocs->compno0 ; compno < p_pocs->compno1 ; ++compno) {\n                OPJ_UINT32 comp_index = res_index + layno0 * step_l;\n\n                /* and finally take each layer of each res of ... */\n                for (layno = layno0; layno < p_pocs->layno1 ; ++layno) {\n                    /*index = step_r * resno + step_c * compno + step_l * layno;*/\n                    packet_array[comp_index] = 1;\n                    comp_index += step_l;\n                }\n\n                res_index += step_c;\n            }\n\n            index += step_r;\n        }\n\n        ++p_pocs;\n    }\n\n    index = 0;\n    for (layno = 0; layno < p_num_layers ; ++layno) {\n        for (resno = 0; resno < p_nb_resolutions; ++resno) {\n            for (compno = 0; compno < p_num_comps; ++compno) {\n                loss |= (packet_array[index] != 1);\n                /*index = step_r * resno + step_c * compno + step_l * layno;*/\n                index += step_c;\n            }\n        }\n    }\n\n    if (loss) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Missing packets possible loss of data\\n\");\n    }\n\n    opj_free(packet_array);\n\n    return !loss;\n}\n\n/* ----------------------------------------------------------------------- */\n\nstatic OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp, OPJ_UINT32 pino,\n                                     OPJ_UINT32 tileno)\n{\n    const OPJ_CHAR *prog = 00;\n    OPJ_INT32 i;\n    OPJ_UINT32 tpnum = 1;\n    opj_tcp_t *tcp = 00;\n    opj_poc_t * l_current_poc = 00;\n\n    /*  preconditions */\n    assert(tileno < (cp->tw * cp->th));\n    assert(pino < (cp->tcps[tileno].numpocs + 1));\n\n    /* get the given tile coding parameter */\n    tcp = &cp->tcps[tileno];\n    assert(tcp != 00);\n\n    l_current_poc = &(tcp->pocs[pino]);\n    assert(l_current_poc != 0);\n\n    /* get the progression order as a character string */\n    prog = opj_j2k_convert_progression_order(tcp->prg);\n    assert(strlen(prog) > 0);\n\n    if (cp->m_specific_param.m_enc.m_tp_on == 1) {\n        for (i = 0; i < 4; ++i) {\n            switch (prog[i]) {\n            /* component wise */\n            case 'C':\n                tpnum *= l_current_poc->compE;\n                break;\n            /* resolution wise */\n            case 'R':\n                tpnum *= l_current_poc->resE;\n                break;\n            /* precinct wise */\n            case 'P':\n                tpnum *= l_current_poc->prcE;\n                break;\n            /* layer wise */\n            case 'L':\n                tpnum *= l_current_poc->layE;\n                break;\n            }\n            /* whould we split here ? */\n            if (cp->m_specific_param.m_enc.m_tp_flag == prog[i]) {\n                cp->m_specific_param.m_enc.m_tp_pos = i;\n                break;\n            }\n        }\n    } else {\n        tpnum = 1;\n    }\n\n    return tpnum;\n}\n\nstatic OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k,\n                                     opj_cp_t *cp,\n                                     OPJ_UINT32 * p_nb_tiles,\n                                     opj_image_t *image,\n                                     opj_event_mgr_t * p_manager\n                                    )\n{\n    OPJ_UINT32 pino, tileno;\n    OPJ_UINT32 l_nb_tiles;\n    opj_tcp_t *tcp;\n\n    /* preconditions */\n    assert(p_nb_tiles != 00);\n    assert(cp != 00);\n    assert(image != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_j2k);\n    OPJ_UNUSED(p_manager);\n\n    l_nb_tiles = cp->tw * cp->th;\n    * p_nb_tiles = 0;\n    tcp = cp->tcps;\n\n    /* INDEX >> */\n    /* TODO mergeV2: check this part which use cstr_info */\n    /*if (p_j2k->cstr_info) {\n            opj_tile_info_t * l_info_tile_ptr = p_j2k->cstr_info->tile;\n\n            for (tileno = 0; tileno < l_nb_tiles; ++tileno) {\n                    OPJ_UINT32 cur_totnum_tp = 0;\n\n                    opj_pi_update_encoding_parameters(image,cp,tileno);\n\n                    for (pino = 0; pino <= tcp->numpocs; ++pino)\n                    {\n                            OPJ_UINT32 tp_num = opj_j2k_get_num_tp(cp,pino,tileno);\n\n                            *p_nb_tiles = *p_nb_tiles + tp_num;\n\n                            cur_totnum_tp += tp_num;\n                    }\n\n                    tcp->m_nb_tile_parts = cur_totnum_tp;\n\n                    l_info_tile_ptr->tp = (opj_tp_info_t *) opj_malloc(cur_totnum_tp * sizeof(opj_tp_info_t));\n                    if (l_info_tile_ptr->tp == 00) {\n                            return OPJ_FALSE;\n                    }\n\n                    memset(l_info_tile_ptr->tp,0,cur_totnum_tp * sizeof(opj_tp_info_t));\n\n                    l_info_tile_ptr->num_tps = cur_totnum_tp;\n\n                    ++l_info_tile_ptr;\n                    ++tcp;\n            }\n    }\n    else */{\n        for (tileno = 0; tileno < l_nb_tiles; ++tileno) {\n            OPJ_UINT32 cur_totnum_tp = 0;\n\n            opj_pi_update_encoding_parameters(image, cp, tileno);\n\n            for (pino = 0; pino <= tcp->numpocs; ++pino) {\n                OPJ_UINT32 tp_num = opj_j2k_get_num_tp(cp, pino, tileno);\n\n                *p_nb_tiles = *p_nb_tiles + tp_num;\n\n                cur_totnum_tp += tp_num;\n            }\n            tcp->m_nb_tile_parts = cur_totnum_tp;\n\n            ++tcp;\n        }\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager)\n{\n    /* 2 bytes will be written */\n    OPJ_BYTE * l_start_stream = 00;\n\n    /* preconditions */\n    assert(p_stream != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_start_stream = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    /* write SOC identifier */\n    opj_write_bytes(l_start_stream, J2K_MS_SOC, 2);\n\n    if (opj_stream_write_data(p_stream, l_start_stream, 2, p_manager) != 2) {\n        return OPJ_FALSE;\n    }\n\n    /* UniPG>> */\n#ifdef USE_JPWL\n    /* update markers struct */\n    /*\n            OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOC, p_stream_tell(p_stream) - 2, 2);\n    */\n    assert(0 && \"TODO\");\n#endif /* USE_JPWL */\n    /* <<UniPG */\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a SOC marker (Start of Codestream)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_stream        FIXME DOC\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_BYTE l_data [2];\n    OPJ_UINT32 l_marker;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    if (opj_stream_read_data(p_stream, l_data, 2, p_manager) != 2) {\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(l_data, &l_marker, 2);\n    if (l_marker != J2K_MS_SOC) {\n        return OPJ_FALSE;\n    }\n\n    /* Next marker should be a SIZ marker in the main header */\n    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MHSIZ;\n\n    /* FIXME move it in a index structure included in p_j2k*/\n    p_j2k->cstr_index->main_head_start = opj_stream_tell(p_stream) - 2;\n\n    opj_event_msg(p_manager, EVT_INFO, \"Start to read j2k main header (%d).\\n\",\n                  p_j2k->cstr_index->main_head_start);\n\n    /* Add the marker to the codestream index*/\n    if (OPJ_FALSE == opj_j2k_add_mhmarker(p_j2k->cstr_index, J2K_MS_SOC,\n                                          p_j2k->cstr_index->main_head_start, 2)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\");\n        return OPJ_FALSE;\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_size_len;\n    OPJ_BYTE * l_current_ptr;\n    opj_image_t * l_image = 00;\n    opj_cp_t *cp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n\n    /* preconditions */\n    assert(p_stream != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_image = p_j2k->m_private_image;\n    cp = &(p_j2k->m_cp);\n    l_size_len = 40 + 3 * l_image->numcomps;\n    l_img_comp = l_image->comps;\n\n    if (l_size_len > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_size_len);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory for the SIZ marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_size_len;\n    }\n\n    l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    /* write SOC identifier */\n    opj_write_bytes(l_current_ptr, J2K_MS_SIZ, 2);  /* SIZ */\n    l_current_ptr += 2;\n\n    opj_write_bytes(l_current_ptr, l_size_len - 2, 2); /* L_SIZ */\n    l_current_ptr += 2;\n\n    opj_write_bytes(l_current_ptr, cp->rsiz, 2);    /* Rsiz (capabilities) */\n    l_current_ptr += 2;\n\n    opj_write_bytes(l_current_ptr, l_image->x1, 4); /* Xsiz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, l_image->y1, 4); /* Ysiz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, l_image->x0, 4); /* X0siz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, l_image->y0, 4); /* Y0siz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, cp->tdx, 4);             /* XTsiz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, cp->tdy, 4);             /* YTsiz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, cp->tx0, 4);             /* XT0siz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, cp->ty0, 4);             /* YT0siz */\n    l_current_ptr += 4;\n\n    opj_write_bytes(l_current_ptr, l_image->numcomps, 2);   /* Csiz */\n    l_current_ptr += 2;\n\n    for (i = 0; i < l_image->numcomps; ++i) {\n        /* TODO here with MCT ? */\n        opj_write_bytes(l_current_ptr, l_img_comp->prec - 1 + (l_img_comp->sgnd << 7),\n                        1);      /* Ssiz_i */\n        ++l_current_ptr;\n\n        opj_write_bytes(l_current_ptr, l_img_comp->dx, 1);      /* XRsiz_i */\n        ++l_current_ptr;\n\n        opj_write_bytes(l_current_ptr, l_img_comp->dy, 1);      /* YRsiz_i */\n        ++l_current_ptr;\n\n        ++l_img_comp;\n    }\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_size_len,\n                              p_manager) != l_size_len) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a SIZ marker (image and tile size)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the SIZ box.\n * @param       p_header_size   the size of the data contained in the SIZ marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_nb_comp;\n    OPJ_UINT32 l_nb_comp_remain;\n    OPJ_UINT32 l_remaining_size;\n    OPJ_UINT32 l_nb_tiles;\n    OPJ_UINT32 l_tmp, l_tx1, l_ty1;\n    OPJ_UINT32 l_prec0, l_sgnd0;\n    opj_image_t *l_image = 00;\n    opj_cp_t *l_cp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcp_t * l_current_tile_param = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_header_data != 00);\n\n    l_image = p_j2k->m_private_image;\n    l_cp = &(p_j2k->m_cp);\n\n    /* minimum size == 39 - 3 (= minimum component parameter) */\n    if (p_header_size < 36) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker size\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_remaining_size = p_header_size - 36;\n    l_nb_comp = l_remaining_size / 3;\n    l_nb_comp_remain = l_remaining_size % 3;\n    if (l_nb_comp_remain != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker size\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_tmp,\n                   2);                                                /* Rsiz (capabilities) */\n    p_header_data += 2;\n    l_cp->rsiz = (OPJ_UINT16) l_tmp;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x1, 4);   /* Xsiz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y1, 4);   /* Ysiz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x0, 4);   /* X0siz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y0, 4);   /* Y0siz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdx,\n                   4);             /* XTsiz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdy,\n                   4);             /* YTsiz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tx0,\n                   4);             /* XT0siz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->ty0,\n                   4);             /* YT0siz */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_tmp,\n                   2);                 /* Csiz */\n    p_header_data += 2;\n    if (l_tmp < 16385) {\n        l_image->numcomps = (OPJ_UINT16) l_tmp;\n    } else {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error with SIZ marker: number of component is illegal -> %d\\n\", l_tmp);\n        return OPJ_FALSE;\n    }\n\n    if (l_image->numcomps != l_nb_comp) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\\n\",\n                      l_image->numcomps, l_nb_comp);\n        return OPJ_FALSE;\n    }\n\n    /* testcase 4035.pdf.SIGSEGV.d8b.3375 */\n    /* testcase issue427-null-image-size.jp2 */\n    if ((l_image->x0 >= l_image->x1) || (l_image->y0 >= l_image->y1)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error with SIZ marker: negative or zero image size (%\" PRId64 \" x %\" PRId64\n                      \")\\n\", (OPJ_INT64)l_image->x1 - l_image->x0,\n                      (OPJ_INT64)l_image->y1 - l_image->y0);\n        return OPJ_FALSE;\n    }\n    /* testcase 2539.pdf.SIGFPE.706.1712 (also 3622.pdf.SIGFPE.706.2916 and 4008.pdf.SIGFPE.706.3345 and maybe more) */\n    if ((l_cp->tdx == 0U) || (l_cp->tdy == 0U)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\\n\", l_cp->tdx,\n                      l_cp->tdy);\n        return OPJ_FALSE;\n    }\n\n    /* testcase 1610.pdf.SIGSEGV.59c.681 */\n    if ((0xFFFFFFFFU / l_image->x1) < l_image->y1) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Prevent buffer overflow (x1: %d, y1: %d)\\n\", l_image->x1, l_image->y1);\n        return OPJ_FALSE;\n    }\n\n    /* testcase issue427-illegal-tile-offset.jp2 */\n    l_tx1 = opj_uint_adds(l_cp->tx0, l_cp->tdx); /* manage overflow */\n    l_ty1 = opj_uint_adds(l_cp->ty0, l_cp->tdy); /* manage overflow */\n    if ((l_cp->tx0 > l_image->x0) || (l_cp->ty0 > l_image->y0) ||\n            (l_tx1 <= l_image->x0) || (l_ty1 <= l_image->y0)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error with SIZ marker: illegal tile offset\\n\");\n        return OPJ_FALSE;\n    }\n    if (!p_j2k->dump_state) {\n        OPJ_UINT32 siz_w, siz_h;\n\n        siz_w = l_image->x1 - l_image->x0;\n        siz_h = l_image->y1 - l_image->y0;\n\n        if (p_j2k->ihdr_w > 0 && p_j2k->ihdr_h > 0\n                && (p_j2k->ihdr_w != siz_w || p_j2k->ihdr_h != siz_h)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Error with SIZ marker: IHDR w(%u) h(%u) vs. SIZ w(%u) h(%u)\\n\", p_j2k->ihdr_w,\n                          p_j2k->ihdr_h, siz_w, siz_h);\n            return OPJ_FALSE;\n        }\n    }\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n        /* if JPWL is on, we check whether TX errors have damaged\n          too much the SIZ parameters */\n        if (!(l_image->x1 * l_image->y1)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"JPWL: bad image size (%d x %d)\\n\",\n                          l_image->x1, l_image->y1);\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n        }\n\n        /* FIXME check previously in the function so why keep this piece of code ? Need by the norm ?\n                if (l_image->numcomps != ((len - 38) / 3)) {\n                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                                \"JPWL: Csiz is %d => space in SIZ only for %d comps.!!!\\n\",\n                                l_image->numcomps, ((len - 38) / 3));\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n        */              /* we try to correct */\n        /*              opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\");\n                        if (l_image->numcomps < ((len - 38) / 3)) {\n                                len = 38 + 3 * l_image->numcomps;\n                                opj_event_msg(p_manager, EVT_WARNING, \"- setting Lsiz to %d => HYPOTHESIS!!!\\n\",\n                                        len);\n                        } else {\n                                l_image->numcomps = ((len - 38) / 3);\n                                opj_event_msg(p_manager, EVT_WARNING, \"- setting Csiz to %d => HYPOTHESIS!!!\\n\",\n                                        l_image->numcomps);\n                        }\n                }\n        */\n\n        /* update components number in the jpwl_exp_comps filed */\n        l_cp->exp_comps = l_image->numcomps;\n    }\n#endif /* USE_JPWL */\n\n    /* Allocate the resulting image components */\n    l_image->comps = (opj_image_comp_t*) opj_calloc(l_image->numcomps,\n                     sizeof(opj_image_comp_t));\n    if (l_image->comps == 00) {\n        l_image->numcomps = 0;\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory to take in charge SIZ marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_img_comp = l_image->comps;\n\n    l_prec0 = 0;\n    l_sgnd0 = 0;\n    /* Read the component information */\n    for (i = 0; i < l_image->numcomps; ++i) {\n        OPJ_UINT32 tmp;\n        opj_read_bytes(p_header_data, &tmp, 1); /* Ssiz_i */\n        ++p_header_data;\n        l_img_comp->prec = (tmp & 0x7f) + 1;\n        l_img_comp->sgnd = tmp >> 7;\n\n        if (p_j2k->dump_state == 0) {\n            if (i == 0) {\n                l_prec0 = l_img_comp->prec;\n                l_sgnd0 = l_img_comp->sgnd;\n            } else if (!l_cp->allow_different_bit_depth_sign\n                       && (l_img_comp->prec != l_prec0 || l_img_comp->sgnd != l_sgnd0)) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"Despite JP2 BPC!=255, precision and/or sgnd values for comp[%d] is different than comp[0]:\\n\"\n                              \"        [0] prec(%d) sgnd(%d) [%d] prec(%d) sgnd(%d)\\n\", i, l_prec0, l_sgnd0,\n                              i, l_img_comp->prec, l_img_comp->sgnd);\n            }\n            /* TODO: we should perhaps also check against JP2 BPCC values */\n        }\n        opj_read_bytes(p_header_data, &tmp, 1); /* XRsiz_i */\n        ++p_header_data;\n        l_img_comp->dx = (OPJ_UINT32)tmp; /* should be between 1 and 255 */\n        opj_read_bytes(p_header_data, &tmp, 1); /* YRsiz_i */\n        ++p_header_data;\n        l_img_comp->dy = (OPJ_UINT32)tmp; /* should be between 1 and 255 */\n        if (l_img_comp->dx < 1 || l_img_comp->dx > 255 ||\n                l_img_comp->dy < 1 || l_img_comp->dy > 255) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\\n\",\n                          i, l_img_comp->dx, l_img_comp->dy);\n            return OPJ_FALSE;\n        }\n        /* Avoids later undefined shift in computation of */\n        /* p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[i].m_dc_level_shift = 1\n                    << (l_image->comps[i].prec - 1); */\n        if (l_img_comp->prec > 31) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\\n\",\n                          i, l_img_comp->prec);\n            return OPJ_FALSE;\n        }\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n            /* if JPWL is on, we check whether TX errors have damaged\n                    too much the SIZ parameters, again */\n            if (!(l_image->comps[i].dx * l_image->comps[i].dy)) {\n                opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                              \"JPWL: bad XRsiz_%d/YRsiz_%d (%d x %d)\\n\",\n                              i, i, l_image->comps[i].dx, l_image->comps[i].dy);\n                if (!JPWL_ASSUME) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                    return OPJ_FALSE;\n                }\n                /* we try to correct */\n                opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust them\\n\");\n                if (!l_image->comps[i].dx) {\n                    l_image->comps[i].dx = 1;\n                    opj_event_msg(p_manager, EVT_WARNING,\n                                  \"- setting XRsiz_%d to %d => HYPOTHESIS!!!\\n\",\n                                  i, l_image->comps[i].dx);\n                }\n                if (!l_image->comps[i].dy) {\n                    l_image->comps[i].dy = 1;\n                    opj_event_msg(p_manager, EVT_WARNING,\n                                  \"- setting YRsiz_%d to %d => HYPOTHESIS!!!\\n\",\n                                  i, l_image->comps[i].dy);\n                }\n            }\n        }\n#endif /* USE_JPWL */\n        l_img_comp->resno_decoded =\n            0;                                                          /* number of resolution decoded */\n        l_img_comp->factor =\n            l_cp->m_specific_param.m_dec.m_reduce; /* reducing factor per component */\n        ++l_img_comp;\n    }\n\n    if (l_cp->tdx == 0 || l_cp->tdy == 0) {\n        return OPJ_FALSE;\n    }\n\n    /* Compute the number of tiles */\n    l_cp->tw = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->x1 - l_cp->tx0),\n                                           (OPJ_INT32)l_cp->tdx);\n    l_cp->th = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->y1 - l_cp->ty0),\n                                           (OPJ_INT32)l_cp->tdy);\n\n    /* Check that the number of tiles is valid */\n    if (l_cp->tw == 0 || l_cp->th == 0 || l_cp->tw > 65535 / l_cp->th) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\\n\",\n                      l_cp->tw, l_cp->th);\n        return OPJ_FALSE;\n    }\n    l_nb_tiles = l_cp->tw * l_cp->th;\n\n    /* Define the tiles which will be decoded */\n    if (p_j2k->m_specific_param.m_decoder.m_discard_tiles) {\n        p_j2k->m_specific_param.m_decoder.m_start_tile_x =\n            (p_j2k->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;\n        p_j2k->m_specific_param.m_decoder.m_start_tile_y =\n            (p_j2k->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;\n        p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32)opj_int_ceildiv((\n                    OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0),\n                (OPJ_INT32)l_cp->tdx);\n        p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32)opj_int_ceildiv((\n                    OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0),\n                (OPJ_INT32)l_cp->tdy);\n    } else {\n        p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;\n        p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;\n        p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;\n        p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;\n    }\n\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n        /* if JPWL is on, we check whether TX errors have damaged\n          too much the SIZ parameters */\n        if ((l_cp->tw < 1) || (l_cp->th < 1) || (l_cp->tw > l_cp->max_tiles) ||\n                (l_cp->th > l_cp->max_tiles)) {\n            opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                          \"JPWL: bad number of tiles (%d x %d)\\n\",\n                          l_cp->tw, l_cp->th);\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n            /* we try to correct */\n            opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust them\\n\");\n            if (l_cp->tw < 1) {\n                l_cp->tw = 1;\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"- setting %d tiles in x => HYPOTHESIS!!!\\n\",\n                              l_cp->tw);\n            }\n            if (l_cp->tw > l_cp->max_tiles) {\n                l_cp->tw = 1;\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"- too large x, increase expectance of %d\\n\"\n                              \"- setting %d tiles in x => HYPOTHESIS!!!\\n\",\n                              l_cp->max_tiles, l_cp->tw);\n            }\n            if (l_cp->th < 1) {\n                l_cp->th = 1;\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"- setting %d tiles in y => HYPOTHESIS!!!\\n\",\n                              l_cp->th);\n            }\n            if (l_cp->th > l_cp->max_tiles) {\n                l_cp->th = 1;\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"- too large y, increase expectance of %d to continue\\n\",\n                              \"- setting %d tiles in y => HYPOTHESIS!!!\\n\",\n                              l_cp->max_tiles, l_cp->th);\n            }\n        }\n    }\n#endif /* USE_JPWL */\n\n    /* memory allocations */\n    l_cp->tcps = (opj_tcp_t*) opj_calloc(l_nb_tiles, sizeof(opj_tcp_t));\n    if (l_cp->tcps == 00) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory to take in charge SIZ marker\\n\");\n        return OPJ_FALSE;\n    }\n\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n        if (!l_cp->tcps) {\n            opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                          \"JPWL: could not alloc tcps field of cp\\n\");\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n        }\n    }\n#endif /* USE_JPWL */\n\n    p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps =\n        (opj_tccp_t*) opj_calloc(l_image->numcomps, sizeof(opj_tccp_t));\n    if (p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps  == 00) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory to take in charge SIZ marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records =\n        (opj_mct_data_t*)opj_calloc(OPJ_J2K_MCT_DEFAULT_NB_RECORDS,\n                                    sizeof(opj_mct_data_t));\n\n    if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory to take in charge SIZ marker\\n\");\n        return OPJ_FALSE;\n    }\n    p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mct_records =\n        OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n\n    p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records =\n        (opj_simple_mcc_decorrelation_data_t*)\n        opj_calloc(OPJ_J2K_MCC_DEFAULT_NB_RECORDS,\n                   sizeof(opj_simple_mcc_decorrelation_data_t));\n\n    if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory to take in charge SIZ marker\\n\");\n        return OPJ_FALSE;\n    }\n    p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mcc_records =\n        OPJ_J2K_MCC_DEFAULT_NB_RECORDS;\n\n    /* set up default dc level shift */\n    for (i = 0; i < l_image->numcomps; ++i) {\n        if (! l_image->comps[i].sgnd) {\n            p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[i].m_dc_level_shift = 1\n                    << (l_image->comps[i].prec - 1);\n        }\n    }\n\n    l_current_tile_param = l_cp->tcps;\n    for (i = 0; i < l_nb_tiles; ++i) {\n        l_current_tile_param->tccps = (opj_tccp_t*) opj_calloc(l_image->numcomps,\n                                      sizeof(opj_tccp_t));\n        if (l_current_tile_param->tccps == 00) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to take in charge SIZ marker\\n\");\n            return OPJ_FALSE;\n        }\n\n        ++l_current_tile_param;\n    }\n\n    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MH;\n    opj_image_comp_header_update(l_image, l_cp);\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    OPJ_UINT32 l_comment_size;\n    OPJ_UINT32 l_total_com_size;\n    const OPJ_CHAR *l_comment;\n    OPJ_BYTE * l_current_ptr = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    l_comment = p_j2k->m_cp.comment;\n    l_comment_size = (OPJ_UINT32)strlen(l_comment);\n    l_total_com_size = l_comment_size + 6;\n\n    if (l_total_com_size >\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_total_com_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to write the COM marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_total_com_size;\n    }\n\n    l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_ptr, J2K_MS_COM, 2);  /* COM */\n    l_current_ptr += 2;\n\n    opj_write_bytes(l_current_ptr, l_total_com_size - 2, 2);        /* L_COM */\n    l_current_ptr += 2;\n\n    opj_write_bytes(l_current_ptr, 1,\n                    2);   /* General use (IS 8859-15:1999 (Latin) values) */\n    l_current_ptr += 2;\n\n    memcpy(l_current_ptr, l_comment, l_comment_size);\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_total_com_size,\n                              p_manager) != l_total_com_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a COM marker (comments)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the COM box.\n * @param       p_header_size   the size of the data contained in the COM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_header_data != 00);\n\n    OPJ_UNUSED(p_j2k);\n    OPJ_UNUSED(p_header_data);\n    OPJ_UNUSED(p_header_size);\n    OPJ_UNUSED(p_manager);\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager)\n{\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_code_size, l_remaining_size;\n    OPJ_BYTE * l_current_data = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n    l_code_size = 9 + opj_j2k_get_SPCod_SPCoc_size(p_j2k,\n                  p_j2k->m_current_tile_number, 0);\n    l_remaining_size = l_code_size;\n\n    if (l_code_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_code_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write COD marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_code_size;\n    }\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_COD, 2);           /* COD */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_code_size - 2, 2);      /* L_COD */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_tcp->csty, 1);          /* Scod */\n    ++l_current_data;\n\n    opj_write_bytes(l_current_data, (OPJ_UINT32)l_tcp->prg, 1); /* SGcod (A) */\n    ++l_current_data;\n\n    opj_write_bytes(l_current_data, l_tcp->numlayers, 2);     /* SGcod (B) */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_tcp->mct, 1);           /* SGcod (C) */\n    ++l_current_data;\n\n    l_remaining_size -= 9;\n\n    if (! opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, 0,\n                                    l_current_data, &l_remaining_size, p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error writing COD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (l_remaining_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error writing COD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_code_size,\n                              p_manager) != l_code_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a COD marker (Coding Styke defaults)\n * @param       p_header_data   the data contained in the COD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    /* loop */\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_tmp;\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_image_t *l_image = 00;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_image = p_j2k->m_private_image;\n    l_cp = &(p_j2k->m_cp);\n\n    /* If we are in the first tile-part header of the current tile */\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    /* Only one COD per tile */\n    if (l_tcp->cod) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"COD marker already read. No more than one COD marker per tile.\\n\");\n        return OPJ_FALSE;\n    }\n    l_tcp->cod = 1;\n\n    /* Make sure room is sufficient */\n    if (p_header_size < 5) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading COD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_tcp->csty, 1);         /* Scod */\n    ++p_header_data;\n    /* Make sure we know how to decode this */\n    if ((l_tcp->csty & ~(OPJ_UINT32)(J2K_CP_CSTY_PRT | J2K_CP_CSTY_SOP |\n                                     J2K_CP_CSTY_EPH)) != 0U) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Unknown Scod value in COD marker\\n\");\n        return OPJ_FALSE;\n    }\n    opj_read_bytes(p_header_data, &l_tmp, 1);                       /* SGcod (A) */\n    ++p_header_data;\n    l_tcp->prg = (OPJ_PROG_ORDER) l_tmp;\n    /* Make sure progression order is valid */\n    if (l_tcp->prg > OPJ_CPRL) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Unknown progression order in COD marker\\n\");\n        l_tcp->prg = OPJ_PROG_UNKNOWN;\n    }\n    opj_read_bytes(p_header_data, &l_tcp->numlayers, 2);    /* SGcod (B) */\n    p_header_data += 2;\n\n    if ((l_tcp->numlayers < 1U) || (l_tcp->numlayers > 65535U)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Invalid number of layers in COD marker : %d not in range [1-65535]\\n\",\n                      l_tcp->numlayers);\n        return OPJ_FALSE;\n    }\n\n    /* If user didn't set a number layer to decode take the max specify in the codestream. */\n    if (l_cp->m_specific_param.m_dec.m_layer) {\n        l_tcp->num_layers_to_decode = l_cp->m_specific_param.m_dec.m_layer;\n    } else {\n        l_tcp->num_layers_to_decode = l_tcp->numlayers;\n    }\n\n    opj_read_bytes(p_header_data, &l_tcp->mct, 1);          /* SGcod (C) */\n    ++p_header_data;\n\n    p_header_size -= 5;\n    for (i = 0; i < l_image->numcomps; ++i) {\n        l_tcp->tccps[i].csty = l_tcp->csty & J2K_CCP_CSTY_PRT;\n    }\n\n    if (! opj_j2k_read_SPCod_SPCoc(p_j2k, 0, p_header_data, &p_header_size,\n                                   p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading COD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (p_header_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading COD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* Apply the coding style to other components of the current tile or the m_default_tcp*/\n    opj_j2k_copy_tile_component_parameters(p_j2k);\n\n    /* Index */\n#ifdef WIP_REMOVE_MSD\n    if (p_j2k->cstr_info) {\n        /*opj_codestream_info_t *l_cstr_info = p_j2k->cstr_info;*/\n        p_j2k->cstr_info->prog = l_tcp->prg;\n        p_j2k->cstr_info->numlayers = l_tcp->numlayers;\n        p_j2k->cstr_info->numdecompos = (OPJ_INT32*) opj_malloc(\n                                            l_image->numcomps * sizeof(OPJ_UINT32));\n        if (!p_j2k->cstr_info->numdecompos) {\n            return OPJ_FALSE;\n        }\n        for (i = 0; i < l_image->numcomps; ++i) {\n            p_j2k->cstr_info->numdecompos[i] = l_tcp->tccps[i].numresolutions - 1;\n        }\n    }\n#endif\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k,\n                                  OPJ_UINT32 p_comp_no,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 l_coc_size, l_remaining_size;\n    OPJ_UINT32 l_comp_room;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_comp_room = (p_j2k->m_private_image->numcomps <= 256) ? 1 : 2;\n\n    l_coc_size = 5 + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(p_j2k,\n                 p_j2k->m_current_tile_number, p_comp_no);\n\n    if (l_coc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data;\n        /*p_j2k->m_specific_param.m_encoder.m_header_tile_data\n                = (OPJ_BYTE*)opj_realloc(\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data,\n                        l_coc_size);*/\n\n        new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                   p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_coc_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write COC marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_coc_size;\n    }\n\n    opj_j2k_write_coc_in_memory(p_j2k, p_comp_no,\n                                p_j2k->m_specific_param.m_encoder.m_header_tile_data, &l_remaining_size,\n                                p_manager);\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_coc_size,\n                              p_manager) != l_coc_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k,\n                                    OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n\n    if (l_tcp->tccps[p_first_comp_no].csty != l_tcp->tccps[p_second_comp_no].csty) {\n        return OPJ_FALSE;\n    }\n\n\n    return opj_j2k_compare_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number,\n                                       p_first_comp_no, p_second_comp_no);\n}\n\nstatic void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 p_comp_no,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_data_written,\n                                        opj_event_mgr_t * p_manager\n                                       )\n{\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_coc_size, l_remaining_size;\n    OPJ_BYTE * l_current_data = 00;\n    opj_image_t *l_image = 00;\n    OPJ_UINT32 l_comp_room;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n    l_image = p_j2k->m_private_image;\n    l_comp_room = (l_image->numcomps <= 256) ? 1 : 2;\n\n    l_coc_size = 5 + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(p_j2k,\n                 p_j2k->m_current_tile_number, p_comp_no);\n    l_remaining_size = l_coc_size;\n\n    l_current_data = p_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_COC,\n                    2);                         /* COC */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_coc_size - 2,\n                    2);                     /* L_COC */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, p_comp_no, l_comp_room);        /* Ccoc */\n    l_current_data += l_comp_room;\n\n    opj_write_bytes(l_current_data, l_tcp->tccps[p_comp_no].csty,\n                    1);               /* Scoc */\n    ++l_current_data;\n\n    l_remaining_size -= (5 + l_comp_room);\n    opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, 0,\n                              l_current_data, &l_remaining_size, p_manager);\n    * p_data_written = l_coc_size;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k)\n{\n    OPJ_UINT32 i, j;\n    OPJ_UINT32 l_nb_comp;\n    OPJ_UINT32 l_nb_tiles;\n    OPJ_UINT32 l_max = 0;\n\n    /* preconditions */\n\n    l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th ;\n    l_nb_comp = p_j2k->m_private_image->numcomps;\n\n    for (i = 0; i < l_nb_tiles; ++i) {\n        for (j = 0; j < l_nb_comp; ++j) {\n            l_max = opj_uint_max(l_max, opj_j2k_get_SPCod_SPCoc_size(p_j2k, i, j));\n        }\n    }\n\n    return 6 + l_max;\n}\n\n/**\n * Reads a COC marker (Coding Style Component)\n * @param       p_header_data   the data contained in the COC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n    opj_image_t *l_image = NULL;\n    OPJ_UINT32 l_comp_room;\n    OPJ_UINT32 l_comp_no;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH)\n            ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n    l_image = p_j2k->m_private_image;\n\n    l_comp_room = l_image->numcomps <= 256 ? 1 : 2;\n\n    /* make sure room is sufficient*/\n    if (p_header_size < l_comp_room + 1) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker\\n\");\n        return OPJ_FALSE;\n    }\n    p_header_size -= l_comp_room + 1;\n\n    opj_read_bytes(p_header_data, &l_comp_no,\n                   l_comp_room);                 /* Ccoc */\n    p_header_data += l_comp_room;\n    if (l_comp_no >= l_image->numcomps) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error reading COC marker (bad number of components)\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_tcp->tccps[l_comp_no].csty,\n                   1);                  /* Scoc */\n    ++p_header_data ;\n\n    if (! opj_j2k_read_SPCod_SPCoc(p_j2k, l_comp_no, p_header_data, &p_header_size,\n                                   p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (p_header_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker\\n\");\n        return OPJ_FALSE;\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    OPJ_UINT32 l_qcd_size, l_remaining_size;\n    OPJ_BYTE * l_current_data = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_qcd_size = 4 + opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number,\n                 0);\n    l_remaining_size = l_qcd_size;\n\n    if (l_qcd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcd_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write QCD marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcd_size;\n    }\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_QCD, 2);         /* QCD */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_qcd_size - 2, 2);     /* L_QCD */\n    l_current_data += 2;\n\n    l_remaining_size -= 4;\n\n    if (! opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, 0,\n                                  l_current_data, &l_remaining_size, p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error writing QCD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (l_remaining_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error writing QCD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcd_size,\n                              p_manager) != l_qcd_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a QCD marker (Quantization defaults)\n * @param       p_header_data   the data contained in the QCD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_j2k_read_SQcd_SQcc(p_j2k, 0, p_header_data, &p_header_size,\n                                 p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (p_header_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* Apply the quantization parameters to other components of the current tile or the m_default_tcp */\n    opj_j2k_copy_tile_quantization_parameters(p_j2k);\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k,\n                                  OPJ_UINT32 p_comp_no,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    OPJ_UINT32 l_qcc_size, l_remaining_size;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_qcc_size = 5 + opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number,\n                 p_comp_no);\n    l_qcc_size += p_j2k->m_private_image->numcomps <= 256 ? 0 : 1;\n    l_remaining_size = l_qcc_size;\n\n    if (l_qcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcc_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write QCC marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcc_size;\n    }\n\n    opj_j2k_write_qcc_in_memory(p_j2k, p_comp_no,\n                                p_j2k->m_specific_param.m_encoder.m_header_tile_data, &l_remaining_size,\n                                p_manager);\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcc_size,\n                              p_manager) != l_qcc_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k,\n                                    OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n    return opj_j2k_compare_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number,\n                                     p_first_comp_no, p_second_comp_no);\n}\n\nstatic void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 p_comp_no,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_data_written,\n                                        opj_event_mgr_t * p_manager\n                                       )\n{\n    OPJ_UINT32 l_qcc_size, l_remaining_size;\n    OPJ_BYTE * l_current_data = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_qcc_size = 6 + opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number,\n                 p_comp_no);\n    l_remaining_size = l_qcc_size;\n\n    l_current_data = p_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_QCC, 2);         /* QCC */\n    l_current_data += 2;\n\n    if (p_j2k->m_private_image->numcomps <= 256) {\n        --l_qcc_size;\n\n        opj_write_bytes(l_current_data, l_qcc_size - 2, 2);     /* L_QCC */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data, p_comp_no, 1);  /* Cqcc */\n        ++l_current_data;\n\n        /* in the case only one byte is sufficient the last byte allocated is useless -> still do -6 for available */\n        l_remaining_size -= 6;\n    } else {\n        opj_write_bytes(l_current_data, l_qcc_size - 2, 2);     /* L_QCC */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data, p_comp_no, 2);  /* Cqcc */\n        l_current_data += 2;\n\n        l_remaining_size -= 6;\n    }\n\n    opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, p_comp_no,\n                            l_current_data, &l_remaining_size, p_manager);\n\n    *p_data_written = l_qcc_size;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k)\n{\n    return opj_j2k_get_max_coc_size(p_j2k);\n}\n\n/**\n * Reads a QCC marker (Quantization component)\n * @param       p_header_data   the data contained in the QCC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_num_comp, l_comp_no;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_num_comp = p_j2k->m_private_image->numcomps;\n\n    if (l_num_comp <= 256) {\n        if (p_header_size < 1) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n            return OPJ_FALSE;\n        }\n        opj_read_bytes(p_header_data, &l_comp_no, 1);\n        ++p_header_data;\n        --p_header_size;\n    } else {\n        if (p_header_size < 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n            return OPJ_FALSE;\n        }\n        opj_read_bytes(p_header_data, &l_comp_no, 2);\n        p_header_data += 2;\n        p_header_size -= 2;\n    }\n\n#ifdef USE_JPWL\n    if (p_j2k->m_cp.correct) {\n\n        static OPJ_UINT32 backup_compno = 0;\n\n        /* compno is negative or larger than the number of components!!! */\n        if (/*(l_comp_no < 0) ||*/ (l_comp_no >= l_num_comp)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"JPWL: bad component number in QCC (%d out of a maximum of %d)\\n\",\n                          l_comp_no, l_num_comp);\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n            /* we try to correct */\n            l_comp_no = backup_compno % l_num_comp;\n            opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\"\n                          \"- setting component number to %d\\n\",\n                          l_comp_no);\n        }\n\n        /* keep your private count of tiles */\n        backup_compno++;\n    };\n#endif /* USE_JPWL */\n\n    if (l_comp_no >= p_j2k->m_private_image->numcomps) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Invalid component number: %d, regarding the number of components %d\\n\",\n                      l_comp_no, p_j2k->m_private_image->numcomps);\n        return OPJ_FALSE;\n    }\n\n    if (! opj_j2k_read_SQcd_SQcc(p_j2k, l_comp_no, p_header_data, &p_header_size,\n                                 p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (p_header_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    OPJ_UINT32 l_nb_comp;\n    OPJ_UINT32 l_nb_poc;\n    OPJ_UINT32 l_poc_size;\n    OPJ_UINT32 l_written_size = 0;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_poc_room;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_tcp = &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number];\n    l_nb_comp = p_j2k->m_private_image->numcomps;\n    l_nb_poc = 1 + l_tcp->numpocs;\n\n    if (l_nb_comp <= 256) {\n        l_poc_room = 1;\n    } else {\n        l_poc_room = 2;\n    }\n    l_poc_size = 4 + (5 + 2 * l_poc_room) * l_nb_poc;\n\n    if (l_poc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_poc_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write POC marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_poc_size;\n    }\n\n    opj_j2k_write_poc_in_memory(p_j2k,\n                                p_j2k->m_specific_param.m_encoder.m_header_tile_data, &l_written_size,\n                                p_manager);\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_poc_size,\n                              p_manager) != l_poc_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_data_written,\n                                        opj_event_mgr_t * p_manager\n                                       )\n{\n    OPJ_UINT32 i;\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_nb_comp;\n    OPJ_UINT32 l_nb_poc;\n    OPJ_UINT32 l_poc_size;\n    opj_image_t *l_image = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n    opj_poc_t *l_current_poc = 00;\n    OPJ_UINT32 l_poc_room;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_manager);\n\n    l_tcp = &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number];\n    l_tccp = &l_tcp->tccps[0];\n    l_image = p_j2k->m_private_image;\n    l_nb_comp = l_image->numcomps;\n    l_nb_poc = 1 + l_tcp->numpocs;\n\n    if (l_nb_comp <= 256) {\n        l_poc_room = 1;\n    } else {\n        l_poc_room = 2;\n    }\n\n    l_poc_size = 4 + (5 + 2 * l_poc_room) * l_nb_poc;\n\n    l_current_data = p_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_POC,\n                    2);                                   /* POC  */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_poc_size - 2,\n                    2);                                 /* Lpoc */\n    l_current_data += 2;\n\n    l_current_poc =  l_tcp->pocs;\n    for (i = 0; i < l_nb_poc; ++i) {\n        opj_write_bytes(l_current_data, l_current_poc->resno0,\n                        1);                                /* RSpoc_i */\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data, l_current_poc->compno0,\n                        l_poc_room);              /* CSpoc_i */\n        l_current_data += l_poc_room;\n\n        opj_write_bytes(l_current_data, l_current_poc->layno1,\n                        2);                                /* LYEpoc_i */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data, l_current_poc->resno1,\n                        1);                                /* REpoc_i */\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data, l_current_poc->compno1,\n                        l_poc_room);              /* CEpoc_i */\n        l_current_data += l_poc_room;\n\n        opj_write_bytes(l_current_data, (OPJ_UINT32)l_current_poc->prg,\n                        1);   /* Ppoc_i */\n        ++l_current_data;\n\n        /* change the value of the max layer according to the actual number of layers in the file, components and resolutions*/\n        l_current_poc->layno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)\n                                l_current_poc->layno1, (OPJ_INT32)l_tcp->numlayers);\n        l_current_poc->resno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)\n                                l_current_poc->resno1, (OPJ_INT32)l_tccp->numresolutions);\n        l_current_poc->compno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)\n                                 l_current_poc->compno1, (OPJ_INT32)l_nb_comp);\n\n        ++l_current_poc;\n    }\n\n    *p_data_written = l_poc_size;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)\n{\n    opj_tcp_t * l_tcp = 00;\n    OPJ_UINT32 l_nb_tiles = 0;\n    OPJ_UINT32 l_max_poc = 0;\n    OPJ_UINT32 i;\n\n    l_tcp = p_j2k->m_cp.tcps;\n    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n\n    for (i = 0; i < l_nb_tiles; ++i) {\n        l_max_poc = opj_uint_max(l_max_poc, l_tcp->numpocs);\n        ++l_tcp;\n    }\n\n    ++l_max_poc;\n\n    return 4 + 9 * l_max_poc;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k)\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_nb_tiles;\n    OPJ_UINT32 l_max = 0;\n    opj_tcp_t * l_tcp = 00;\n\n    l_tcp = p_j2k->m_cp.tcps;\n    l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th ;\n\n    for (i = 0; i < l_nb_tiles; ++i) {\n        l_max = opj_uint_max(l_max, l_tcp->m_nb_tile_parts);\n\n        ++l_tcp;\n    }\n\n    return 12 * l_max;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k)\n{\n    OPJ_UINT32 l_nb_bytes = 0;\n    OPJ_UINT32 l_nb_comps;\n    OPJ_UINT32 l_coc_bytes, l_qcc_bytes;\n\n    l_nb_comps = p_j2k->m_private_image->numcomps - 1;\n    l_nb_bytes += opj_j2k_get_max_toc_size(p_j2k);\n\n    if (!(OPJ_IS_CINEMA(p_j2k->m_cp.rsiz))) {\n        l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);\n        l_nb_bytes += l_nb_comps * l_coc_bytes;\n\n        l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);\n        l_nb_bytes += l_nb_comps * l_qcc_bytes;\n    }\n\n    l_nb_bytes += opj_j2k_get_max_poc_size(p_j2k);\n\n    /*** DEVELOPER CORNER, Add room for your headers ***/\n\n    return l_nb_bytes;\n}\n\n/**\n * Reads a POC marker (Progression Order Change)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 i, l_nb_comp, l_tmp;\n    opj_image_t * l_image = 00;\n    OPJ_UINT32 l_old_poc_nb, l_current_poc_nb, l_current_poc_remaining;\n    OPJ_UINT32 l_chunk_size, l_comp_room;\n\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_poc_t *l_current_poc = 00;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_image = p_j2k->m_private_image;\n    l_nb_comp = l_image->numcomps;\n    if (l_nb_comp <= 256) {\n        l_comp_room = 1;\n    } else {\n        l_comp_room = 2;\n    }\n    l_chunk_size = 5 + 2 * l_comp_room;\n    l_current_poc_nb = p_header_size / l_chunk_size;\n    l_current_poc_remaining = p_header_size % l_chunk_size;\n\n    if ((l_current_poc_nb <= 0) || (l_current_poc_remaining != 0)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading POC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n    l_old_poc_nb = l_tcp->POC ? l_tcp->numpocs + 1 : 0;\n    l_current_poc_nb += l_old_poc_nb;\n\n    if (l_current_poc_nb >= 32) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Too many POCs %d\\n\", l_current_poc_nb);\n        return OPJ_FALSE;\n    }\n    assert(l_current_poc_nb < 32);\n\n    /* now poc is in use.*/\n    l_tcp->POC = 1;\n\n    l_current_poc = &l_tcp->pocs[l_old_poc_nb];\n    for (i = l_old_poc_nb; i < l_current_poc_nb; ++i) {\n        opj_read_bytes(p_header_data, &(l_current_poc->resno0),\n                       1);                               /* RSpoc_i */\n        ++p_header_data;\n        opj_read_bytes(p_header_data, &(l_current_poc->compno0),\n                       l_comp_room);  /* CSpoc_i */\n        p_header_data += l_comp_room;\n        opj_read_bytes(p_header_data, &(l_current_poc->layno1),\n                       2);                               /* LYEpoc_i */\n        /* make sure layer end is in acceptable bounds */\n        l_current_poc->layno1 = opj_uint_min(l_current_poc->layno1, l_tcp->numlayers);\n        p_header_data += 2;\n        opj_read_bytes(p_header_data, &(l_current_poc->resno1),\n                       1);                               /* REpoc_i */\n        ++p_header_data;\n        opj_read_bytes(p_header_data, &(l_current_poc->compno1),\n                       l_comp_room);  /* CEpoc_i */\n        p_header_data += l_comp_room;\n        opj_read_bytes(p_header_data, &l_tmp,\n                       1);                                                                 /* Ppoc_i */\n        ++p_header_data;\n        l_current_poc->prg = (OPJ_PROG_ORDER) l_tmp;\n        /* make sure comp is in acceptable bounds */\n        l_current_poc->compno1 = opj_uint_min(l_current_poc->compno1, l_nb_comp);\n        ++l_current_poc;\n    }\n\n    l_tcp->numpocs = l_current_poc_nb - 1;\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a CRG marker (Component registration)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_nb_comp;\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_header_data);\n\n    l_nb_comp = p_j2k->m_private_image->numcomps;\n\n    if (p_header_size != l_nb_comp * 4) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading CRG marker\\n\");\n        return OPJ_FALSE;\n    }\n    /* Do not care of this at the moment since only local variables are set here */\n    /*\n    for\n            (i = 0; i < l_nb_comp; ++i)\n    {\n            opj_read_bytes(p_header_data,&l_Xcrg_i,2);                              // Xcrg_i\n            p_header_data+=2;\n            opj_read_bytes(p_header_data,&l_Ycrg_i,2);                              // Xcrg_i\n            p_header_data+=2;\n    }\n    */\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a TLM marker (Tile Length Marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_Ztlm, l_Stlm, l_ST, l_SP, l_tot_num_tp_remaining, l_quotient,\n               l_Ptlm_size;\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_j2k);\n\n    if (p_header_size < 2) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading TLM marker\\n\");\n        return OPJ_FALSE;\n    }\n    p_header_size -= 2;\n\n    opj_read_bytes(p_header_data, &l_Ztlm,\n                   1);                              /* Ztlm */\n    ++p_header_data;\n    opj_read_bytes(p_header_data, &l_Stlm,\n                   1);                              /* Stlm */\n    ++p_header_data;\n\n    l_ST = ((l_Stlm >> 4) & 0x3);\n    l_SP = (l_Stlm >> 6) & 0x1;\n\n    l_Ptlm_size = (l_SP + 1) * 2;\n    l_quotient = l_Ptlm_size + l_ST;\n\n    l_tot_num_tp_remaining = p_header_size % l_quotient;\n\n    if (l_tot_num_tp_remaining != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading TLM marker\\n\");\n        return OPJ_FALSE;\n    }\n    /* FIXME Do not care of this at the moment since only local variables are set here */\n    /*\n    for\n            (i = 0; i < l_tot_num_tp; ++i)\n    {\n            opj_read_bytes(p_header_data,&l_Ttlm_i,l_ST);                           // Ttlm_i\n            p_header_data += l_ST;\n            opj_read_bytes(p_header_data,&l_Ptlm_i,l_Ptlm_size);            // Ptlm_i\n            p_header_data += l_Ptlm_size;\n    }*/\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a PLM marker (Packet length, main header marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_j2k);\n    OPJ_UNUSED(p_header_data);\n\n    if (p_header_size < 1) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLM marker\\n\");\n        return OPJ_FALSE;\n    }\n    /* Do not care of this at the moment since only local variables are set here */\n    /*\n    opj_read_bytes(p_header_data,&l_Zplm,1);                                        // Zplm\n    ++p_header_data;\n    --p_header_size;\n\n    while\n            (p_header_size > 0)\n    {\n            opj_read_bytes(p_header_data,&l_Nplm,1);                                // Nplm\n            ++p_header_data;\n            p_header_size -= (1+l_Nplm);\n            if\n                    (p_header_size < 0)\n            {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLM marker\\n\");\n                    return false;\n            }\n            for\n                    (i = 0; i < l_Nplm; ++i)\n            {\n                    opj_read_bytes(p_header_data,&l_tmp,1);                         // Iplm_ij\n                    ++p_header_data;\n                    // take only the last seven bytes\n                    l_packet_len |= (l_tmp & 0x7f);\n                    if\n                            (l_tmp & 0x80)\n                    {\n                            l_packet_len <<= 7;\n                    }\n                    else\n                    {\n            // store packet length and proceed to next packet\n                            l_packet_len = 0;\n                    }\n            }\n            if\n                    (l_packet_len != 0)\n            {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLM marker\\n\");\n                    return false;\n            }\n    }\n    */\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a PLT marker (Packet length, tile-part header)\n *\n * @param       p_header_data   the data contained in the PLT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PLT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_Zplt, l_tmp, l_packet_len = 0, i;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_j2k);\n\n    if (p_header_size < 1) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_Zplt, 1);              /* Zplt */\n    ++p_header_data;\n    --p_header_size;\n\n    for (i = 0; i < p_header_size; ++i) {\n        opj_read_bytes(p_header_data, &l_tmp, 1);       /* Iplt_ij */\n        ++p_header_data;\n        /* take only the last seven bytes */\n        l_packet_len |= (l_tmp & 0x7f);\n        if (l_tmp & 0x80) {\n            l_packet_len <<= 7;\n        } else {\n            /* store packet length and proceed to next packet */\n            l_packet_len = 0;\n        }\n    }\n\n    if (l_packet_len != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a PPM marker (Packed packet headers, main header)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n */\n\nstatic OPJ_BOOL opj_j2k_read_ppm(\n    opj_j2k_t *p_j2k,\n    OPJ_BYTE * p_header_data,\n    OPJ_UINT32 p_header_size,\n    opj_event_mgr_t * p_manager)\n{\n    opj_cp_t *l_cp = 00;\n    OPJ_UINT32 l_Z_ppm;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    /* We need to have the Z_ppm element + 1 byte of Nppm/Ippm at minimum */\n    if (p_header_size < 2) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PPM marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_cp = &(p_j2k->m_cp);\n    l_cp->ppm = 1;\n\n    opj_read_bytes(p_header_data, &l_Z_ppm, 1);             /* Z_ppm */\n    ++p_header_data;\n    --p_header_size;\n\n    /* check allocation needed */\n    if (l_cp->ppm_markers == NULL) { /* first PPM marker */\n        OPJ_UINT32 l_newCount = l_Z_ppm + 1U; /* can't overflow, l_Z_ppm is UINT8 */\n        assert(l_cp->ppm_markers_count == 0U);\n\n        l_cp->ppm_markers = (opj_ppx *) opj_calloc(l_newCount, sizeof(opj_ppx));\n        if (l_cp->ppm_markers == NULL) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n            return OPJ_FALSE;\n        }\n        l_cp->ppm_markers_count = l_newCount;\n    } else if (l_cp->ppm_markers_count <= l_Z_ppm) {\n        OPJ_UINT32 l_newCount = l_Z_ppm + 1U; /* can't overflow, l_Z_ppm is UINT8 */\n        opj_ppx *new_ppm_markers;\n        new_ppm_markers = (opj_ppx *) opj_realloc(l_cp->ppm_markers,\n                          l_newCount * sizeof(opj_ppx));\n        if (new_ppm_markers == NULL) {\n            /* clean up to be done on l_cp destruction */\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n            return OPJ_FALSE;\n        }\n        l_cp->ppm_markers = new_ppm_markers;\n        memset(l_cp->ppm_markers + l_cp->ppm_markers_count, 0,\n               (l_newCount - l_cp->ppm_markers_count) * sizeof(opj_ppx));\n        l_cp->ppm_markers_count = l_newCount;\n    }\n\n    if (l_cp->ppm_markers[l_Z_ppm].m_data != NULL) {\n        /* clean up to be done on l_cp destruction */\n        opj_event_msg(p_manager, EVT_ERROR, \"Zppm %u already read\\n\", l_Z_ppm);\n        return OPJ_FALSE;\n    }\n\n    l_cp->ppm_markers[l_Z_ppm].m_data = (OPJ_BYTE *) opj_malloc(p_header_size);\n    if (l_cp->ppm_markers[l_Z_ppm].m_data == NULL) {\n        /* clean up to be done on l_cp destruction */\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n        return OPJ_FALSE;\n    }\n    l_cp->ppm_markers[l_Z_ppm].m_data_size = p_header_size;\n    memcpy(l_cp->ppm_markers[l_Z_ppm].m_data, p_header_data, p_header_size);\n\n    return OPJ_TRUE;\n}\n\n/**\n * Merges all PPM markers read (Packed headers, main header)\n *\n * @param       p_cp      main coding parameters.\n * @param       p_manager the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppm(opj_cp_t *p_cp, opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i, l_ppm_data_size, l_N_ppm_remaining;\n\n    /* preconditions */\n    assert(p_cp != 00);\n    assert(p_manager != 00);\n    assert(p_cp->ppm_buffer == NULL);\n\n    if (p_cp->ppm == 0U) {\n        return OPJ_TRUE;\n    }\n\n    l_ppm_data_size = 0U;\n    l_N_ppm_remaining = 0U;\n    for (i = 0U; i < p_cp->ppm_markers_count; ++i) {\n        if (p_cp->ppm_markers[i].m_data !=\n                NULL) { /* standard doesn't seem to require contiguous Zppm */\n            OPJ_UINT32 l_N_ppm;\n            OPJ_UINT32 l_data_size = p_cp->ppm_markers[i].m_data_size;\n            const OPJ_BYTE* l_data = p_cp->ppm_markers[i].m_data;\n\n            if (l_N_ppm_remaining >= l_data_size) {\n                l_N_ppm_remaining -= l_data_size;\n                l_data_size = 0U;\n            } else {\n                l_data += l_N_ppm_remaining;\n                l_data_size -= l_N_ppm_remaining;\n                l_N_ppm_remaining = 0U;\n            }\n\n            if (l_data_size > 0U) {\n                do {\n                    /* read Nppm */\n                    if (l_data_size < 4U) {\n                        /* clean up to be done on l_cp destruction */\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough bytes to read Nppm\\n\");\n                        return OPJ_FALSE;\n                    }\n                    opj_read_bytes(l_data, &l_N_ppm, 4);\n                    l_data += 4;\n                    l_data_size -= 4;\n                    l_ppm_data_size +=\n                        l_N_ppm; /* can't overflow, max 256 markers of max 65536 bytes, that is when PPM markers are not corrupted which is checked elsewhere */\n\n                    if (l_data_size >= l_N_ppm) {\n                        l_data_size -= l_N_ppm;\n                        l_data += l_N_ppm;\n                    } else {\n                        l_N_ppm_remaining = l_N_ppm - l_data_size;\n                        l_data_size = 0U;\n                    }\n                } while (l_data_size > 0U);\n            }\n        }\n    }\n\n    if (l_N_ppm_remaining != 0U) {\n        /* clean up to be done on l_cp destruction */\n        opj_event_msg(p_manager, EVT_ERROR, \"Corrupted PPM markers\\n\");\n        return OPJ_FALSE;\n    }\n\n    p_cp->ppm_buffer = (OPJ_BYTE *) opj_malloc(l_ppm_data_size);\n    if (p_cp->ppm_buffer == 00) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n        return OPJ_FALSE;\n    }\n    p_cp->ppm_len = l_ppm_data_size;\n    l_ppm_data_size = 0U;\n    l_N_ppm_remaining = 0U;\n    for (i = 0U; i < p_cp->ppm_markers_count; ++i) {\n        if (p_cp->ppm_markers[i].m_data !=\n                NULL) { /* standard doesn't seem to require contiguous Zppm */\n            OPJ_UINT32 l_N_ppm;\n            OPJ_UINT32 l_data_size = p_cp->ppm_markers[i].m_data_size;\n            const OPJ_BYTE* l_data = p_cp->ppm_markers[i].m_data;\n\n            if (l_N_ppm_remaining >= l_data_size) {\n                memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_data_size);\n                l_ppm_data_size += l_data_size;\n                l_N_ppm_remaining -= l_data_size;\n                l_data_size = 0U;\n            } else {\n                memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_N_ppm_remaining);\n                l_ppm_data_size += l_N_ppm_remaining;\n                l_data += l_N_ppm_remaining;\n                l_data_size -= l_N_ppm_remaining;\n                l_N_ppm_remaining = 0U;\n            }\n\n            if (l_data_size > 0U) {\n                do {\n                    /* read Nppm */\n                    if (l_data_size < 4U) {\n                        /* clean up to be done on l_cp destruction */\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough bytes to read Nppm\\n\");\n                        return OPJ_FALSE;\n                    }\n                    opj_read_bytes(l_data, &l_N_ppm, 4);\n                    l_data += 4;\n                    l_data_size -= 4;\n\n                    if (l_data_size >= l_N_ppm) {\n                        memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_N_ppm);\n                        l_ppm_data_size += l_N_ppm;\n                        l_data_size -= l_N_ppm;\n                        l_data += l_N_ppm;\n                    } else {\n                        memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_data_size);\n                        l_ppm_data_size += l_data_size;\n                        l_N_ppm_remaining = l_N_ppm - l_data_size;\n                        l_data_size = 0U;\n                    }\n                } while (l_data_size > 0U);\n            }\n            opj_free(p_cp->ppm_markers[i].m_data);\n            p_cp->ppm_markers[i].m_data = NULL;\n            p_cp->ppm_markers[i].m_data_size = 0U;\n        }\n    }\n\n    p_cp->ppm_data = p_cp->ppm_buffer;\n    p_cp->ppm_data_size = p_cp->ppm_len;\n\n    p_cp->ppm_markers_count = 0U;\n    opj_free(p_cp->ppm_markers);\n    p_cp->ppm_markers = NULL;\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a PPT marker (Packed packet headers, tile-part header)\n *\n * @param       p_header_data   the data contained in the PPT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PPT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_Z_ppt;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    /* We need to have the Z_ppt element + 1 byte of Ippt at minimum */\n    if (p_header_size < 2) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PPT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_cp = &(p_j2k->m_cp);\n    if (l_cp->ppm) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_tcp = &(l_cp->tcps[p_j2k->m_current_tile_number]);\n    l_tcp->ppt = 1;\n\n    opj_read_bytes(p_header_data, &l_Z_ppt, 1);             /* Z_ppt */\n    ++p_header_data;\n    --p_header_size;\n\n    /* check allocation needed */\n    if (l_tcp->ppt_markers == NULL) { /* first PPT marker */\n        OPJ_UINT32 l_newCount = l_Z_ppt + 1U; /* can't overflow, l_Z_ppt is UINT8 */\n        assert(l_tcp->ppt_markers_count == 0U);\n\n        l_tcp->ppt_markers = (opj_ppx *) opj_calloc(l_newCount, sizeof(opj_ppx));\n        if (l_tcp->ppt_markers == NULL) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n            return OPJ_FALSE;\n        }\n        l_tcp->ppt_markers_count = l_newCount;\n    } else if (l_tcp->ppt_markers_count <= l_Z_ppt) {\n        OPJ_UINT32 l_newCount = l_Z_ppt + 1U; /* can't overflow, l_Z_ppt is UINT8 */\n        opj_ppx *new_ppt_markers;\n        new_ppt_markers = (opj_ppx *) opj_realloc(l_tcp->ppt_markers,\n                          l_newCount * sizeof(opj_ppx));\n        if (new_ppt_markers == NULL) {\n            /* clean up to be done on l_tcp destruction */\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n            return OPJ_FALSE;\n        }\n        l_tcp->ppt_markers = new_ppt_markers;\n        memset(l_tcp->ppt_markers + l_tcp->ppt_markers_count, 0,\n               (l_newCount - l_tcp->ppt_markers_count) * sizeof(opj_ppx));\n        l_tcp->ppt_markers_count = l_newCount;\n    }\n\n    if (l_tcp->ppt_markers[l_Z_ppt].m_data != NULL) {\n        /* clean up to be done on l_tcp destruction */\n        opj_event_msg(p_manager, EVT_ERROR, \"Zppt %u already read\\n\", l_Z_ppt);\n        return OPJ_FALSE;\n    }\n\n    l_tcp->ppt_markers[l_Z_ppt].m_data = (OPJ_BYTE *) opj_malloc(p_header_size);\n    if (l_tcp->ppt_markers[l_Z_ppt].m_data == NULL) {\n        /* clean up to be done on l_tcp destruction */\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n        return OPJ_FALSE;\n    }\n    l_tcp->ppt_markers[l_Z_ppt].m_data_size = p_header_size;\n    memcpy(l_tcp->ppt_markers[l_Z_ppt].m_data, p_header_data, p_header_size);\n    return OPJ_TRUE;\n}\n\n/**\n * Merges all PPT markers read (Packed packet headers, tile-part header)\n *\n * @param       p_tcp   the tile.\n * @param       p_manager               the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp, opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i, l_ppt_data_size;\n    /* preconditions */\n    assert(p_tcp != 00);\n    assert(p_manager != 00);\n    assert(p_tcp->ppt_buffer == NULL);\n\n    if (p_tcp->ppt == 0U) {\n        return OPJ_TRUE;\n    }\n\n    l_ppt_data_size = 0U;\n    for (i = 0U; i < p_tcp->ppt_markers_count; ++i) {\n        l_ppt_data_size +=\n            p_tcp->ppt_markers[i].m_data_size; /* can't overflow, max 256 markers of max 65536 bytes */\n    }\n\n    p_tcp->ppt_buffer = (OPJ_BYTE *) opj_malloc(l_ppt_data_size);\n    if (p_tcp->ppt_buffer == 00) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n        return OPJ_FALSE;\n    }\n    p_tcp->ppt_len = l_ppt_data_size;\n    l_ppt_data_size = 0U;\n    for (i = 0U; i < p_tcp->ppt_markers_count; ++i) {\n        if (p_tcp->ppt_markers[i].m_data !=\n                NULL) { /* standard doesn't seem to require contiguous Zppt */\n            memcpy(p_tcp->ppt_buffer + l_ppt_data_size, p_tcp->ppt_markers[i].m_data,\n                   p_tcp->ppt_markers[i].m_data_size);\n            l_ppt_data_size +=\n                p_tcp->ppt_markers[i].m_data_size; /* can't overflow, max 256 markers of max 65536 bytes */\n\n            opj_free(p_tcp->ppt_markers[i].m_data);\n            p_tcp->ppt_markers[i].m_data = NULL;\n            p_tcp->ppt_markers[i].m_data_size = 0U;\n        }\n    }\n\n    p_tcp->ppt_markers_count = 0U;\n    opj_free(p_tcp->ppt_markers);\n    p_tcp->ppt_markers = NULL;\n\n    p_tcp->ppt_data = p_tcp->ppt_buffer;\n    p_tcp->ppt_data_size = p_tcp->ppt_len;\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_tlm_size;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_tlm_size = 6 + (5 * p_j2k->m_specific_param.m_encoder.m_total_tile_parts);\n\n    if (l_tlm_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_tlm_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write TLM marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_tlm_size;\n    }\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    /* change the way data is written to avoid seeking if possible */\n    /* TODO */\n    p_j2k->m_specific_param.m_encoder.m_tlm_start = opj_stream_tell(p_stream);\n\n    opj_write_bytes(l_current_data, J2K_MS_TLM,\n                    2);                                   /* TLM */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_tlm_size - 2,\n                    2);                                 /* Lpoc */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, 0,\n                    1);                                                    /* Ztlm=0*/\n    ++l_current_data;\n\n    opj_write_bytes(l_current_data, 0x50,\n                    1);                                                 /* Stlm ST=1(8bits-255 tiles max),SP=1(Ptlm=32bits) */\n    ++l_current_data;\n\n    /* do nothing on the 5 * l_j2k->m_specific_param.m_encoder.m_total_tile_parts remaining data */\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_tlm_size,\n                              p_manager) != l_tlm_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n\n    opj_write_bytes(p_data, J2K_MS_SOT,\n                    2);                                 /* SOT */\n    p_data += 2;\n\n    opj_write_bytes(p_data, 10,\n                    2);                                                   /* Lsot */\n    p_data += 2;\n\n    opj_write_bytes(p_data, p_j2k->m_current_tile_number,\n                    2);                        /* Isot */\n    p_data += 2;\n\n    /* Psot  */\n    p_data += 4;\n\n    opj_write_bytes(p_data,\n                    p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,\n                    1);                        /* TPsot */\n    ++p_data;\n\n    opj_write_bytes(p_data,\n                    p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,\n                    1);                      /* TNsot */\n    ++p_data;\n\n    /* UniPG>> */\n#ifdef USE_JPWL\n    /* update markers struct */\n    /*\n            OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOT, p_j2k->sot_start, len + 2);\n    */\n    assert(0 && \"TODO\");\n#endif /* USE_JPWL */\n\n    * p_data_written = 12;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *  p_header_data,\n                                       OPJ_UINT32  p_header_size,\n                                       OPJ_UINT32* p_tile_no,\n                                       OPJ_UINT32* p_tot_len,\n                                       OPJ_UINT32* p_current_part,\n                                       OPJ_UINT32* p_num_parts,\n                                       opj_event_mgr_t * p_manager)\n{\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_manager != 00);\n\n    /* Size of this marker is fixed = 12 (we have already read marker and its size)*/\n    if (p_header_size != 8) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading SOT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, p_tile_no, 2);    /* Isot */\n    p_header_data += 2;\n    opj_read_bytes(p_header_data, p_tot_len, 4);    /* Psot */\n    p_header_data += 4;\n    opj_read_bytes(p_header_data, p_current_part, 1); /* TPsot */\n    ++p_header_data;\n    opj_read_bytes(p_header_data, p_num_parts, 1);  /* TNsot */\n    ++p_header_data;\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager)\n{\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_tot_len, l_num_parts = 0;\n    OPJ_UINT32 l_current_part;\n    OPJ_UINT32 l_tile_x, l_tile_y;\n\n    /* preconditions */\n\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_j2k_get_sot_values(p_header_data, p_header_size,\n                                 &(p_j2k->m_current_tile_number), &l_tot_len, &l_current_part, &l_num_parts,\n                                 p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading SOT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_cp = &(p_j2k->m_cp);\n\n    /* testcase 2.pdf.SIGFPE.706.1112 */\n    if (p_j2k->m_current_tile_number >= l_cp->tw * l_cp->th) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Invalid tile number %d\\n\",\n                      p_j2k->m_current_tile_number);\n        return OPJ_FALSE;\n    }\n\n    l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n    l_tile_x = p_j2k->m_current_tile_number % l_cp->tw;\n    l_tile_y = p_j2k->m_current_tile_number / l_cp->tw;\n\n    /* Fixes issue with id_000020,sig_06,src_001958,op_flip4,pos_149 */\n    /* of https://github.com/uclouvain/openjpeg/issues/939 */\n    /* We must avoid reading twice the same tile part number for a given tile */\n    /* so as to avoid various issues, like opj_j2k_merge_ppt being called */\n    /* several times. */\n    /* ISO 15444-1 A.4.2 Start of tile-part (SOT) mandates that tile parts */\n    /* should appear in increasing order. */\n    if (l_tcp->m_current_tile_part_number + 1 != (OPJ_INT32)l_current_part) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Invalid tile part index for tile number %d. \"\n                      \"Got %d, expected %d\\n\",\n                      p_j2k->m_current_tile_number,\n                      l_current_part,\n                      l_tcp->m_current_tile_part_number + 1);\n        return OPJ_FALSE;\n    }\n    ++ l_tcp->m_current_tile_part_number;\n\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n\n        OPJ_UINT32 tileno = p_j2k->m_current_tile_number;\n        static OPJ_UINT32 backup_tileno = 0;\n\n        /* tileno is negative or larger than the number of tiles!!! */\n        if (tileno > (l_cp->tw * l_cp->th)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"JPWL: bad tile number (%d out of a maximum of %d)\\n\",\n                          tileno, (l_cp->tw * l_cp->th));\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n            /* we try to correct */\n            tileno = backup_tileno;\n            opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\"\n                          \"- setting tile number to %d\\n\",\n                          tileno);\n        }\n\n        /* keep your private count of tiles */\n        backup_tileno++;\n    };\n#endif /* USE_JPWL */\n\n    /* look for the tile in the list of already processed tile (in parts). */\n    /* Optimization possible here with a more complex data structure and with the removing of tiles */\n    /* since the time taken by this function can only grow at the time */\n\n    /* PSot should be equal to zero or >=14 or <= 2^32-1 */\n    if ((l_tot_len != 0) && (l_tot_len < 14)) {\n        if (l_tot_len ==\n                12) { /* MSD: Special case for the PHR data which are read by kakadu*/\n            opj_event_msg(p_manager, EVT_WARNING, \"Empty SOT marker detected: Psot=%d.\\n\",\n                          l_tot_len);\n        } else {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Psot value is not correct regards to the JPEG2000 norm: %d.\\n\", l_tot_len);\n            return OPJ_FALSE;\n        }\n    }\n\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n\n        /* totlen is negative or larger than the bytes left!!! */\n        if (/*(l_tot_len < 0) ||*/ (l_tot_len >\n                                    p_header_size)) {   /* FIXME it seems correct; for info in V1 -> (p_stream_numbytesleft(p_stream) + 8))) { */\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"JPWL: bad tile byte size (%d bytes against %d bytes left)\\n\",\n                          l_tot_len,\n                          p_header_size);  /* FIXME it seems correct; for info in V1 -> p_stream_numbytesleft(p_stream) + 8); */\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n            /* we try to correct */\n            l_tot_len = 0;\n            opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\"\n                          \"- setting Psot to %d => assuming it is the last tile\\n\",\n                          l_tot_len);\n        }\n    };\n#endif /* USE_JPWL */\n\n    /* Ref A.4.2: Psot could be equal zero if it is the last tile-part of the codestream.*/\n    if (!l_tot_len) {\n        opj_event_msg(p_manager, EVT_INFO,\n                      \"Psot value of the current tile-part is equal to zero, \"\n                      \"we assuming it is the last tile-part of the codestream.\\n\");\n        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n    }\n\n    if (l_tcp->m_nb_tile_parts != 0 && l_current_part >= l_tcp->m_nb_tile_parts) {\n        /* Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=2851 */\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"In SOT marker, TPSot (%d) is not valid regards to the previous \"\n                      \"number of tile-part (%d), giving up\\n\", l_current_part,\n                      l_tcp->m_nb_tile_parts);\n        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n        return OPJ_FALSE;\n    }\n\n    if (l_num_parts !=\n            0) { /* Number of tile-part header is provided by this tile-part header */\n        l_num_parts += p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction;\n        /* Useful to manage the case of textGBR.jp2 file because two values of TNSot are allowed: the correct numbers of\n         * tile-parts for that tile and zero (A.4.2 of 15444-1 : 2002). */\n        if (l_tcp->m_nb_tile_parts) {\n            if (l_current_part >= l_tcp->m_nb_tile_parts) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"In SOT marker, TPSot (%d) is not valid regards to the current \"\n                              \"number of tile-part (%d), giving up\\n\", l_current_part,\n                              l_tcp->m_nb_tile_parts);\n                p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n                return OPJ_FALSE;\n            }\n        }\n        if (l_current_part >= l_num_parts) {\n            /* testcase 451.pdf.SIGSEGV.ce9.3723 */\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"In SOT marker, TPSot (%d) is not valid regards to the current \"\n                          \"number of tile-part (header) (%d), giving up\\n\", l_current_part, l_num_parts);\n            p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n            return OPJ_FALSE;\n        }\n        l_tcp->m_nb_tile_parts = l_num_parts;\n    }\n\n    /* If know the number of tile part header we will check if we didn't read the last*/\n    if (l_tcp->m_nb_tile_parts) {\n        if (l_tcp->m_nb_tile_parts == (l_current_part + 1)) {\n            p_j2k->m_specific_param.m_decoder.m_can_decode =\n                1; /* Process the last tile-part header*/\n        }\n    }\n\n    if (!p_j2k->m_specific_param.m_decoder.m_last_tile_part) {\n        /* Keep the size of data to skip after this marker */\n        p_j2k->m_specific_param.m_decoder.m_sot_length = l_tot_len -\n                12; /* SOT_marker_size = 12 */\n    } else {\n        /* FIXME: need to be computed from the number of bytes remaining in the codestream */\n        p_j2k->m_specific_param.m_decoder.m_sot_length = 0;\n    }\n\n    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPH;\n\n    /* Check if the current tile is outside the area we want decode or not corresponding to the tile index*/\n    if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec == -1) {\n        p_j2k->m_specific_param.m_decoder.m_skip_data =\n            (l_tile_x < p_j2k->m_specific_param.m_decoder.m_start_tile_x)\n            || (l_tile_x >= p_j2k->m_specific_param.m_decoder.m_end_tile_x)\n            || (l_tile_y < p_j2k->m_specific_param.m_decoder.m_start_tile_y)\n            || (l_tile_y >= p_j2k->m_specific_param.m_decoder.m_end_tile_y);\n    } else {\n        assert(p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec >= 0);\n        p_j2k->m_specific_param.m_decoder.m_skip_data =\n            (p_j2k->m_current_tile_number != (OPJ_UINT32)\n             p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec);\n    }\n\n    /* Index */\n    if (p_j2k->cstr_index) {\n        assert(p_j2k->cstr_index->tile_index != 00);\n        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tileno =\n            p_j2k->m_current_tile_number;\n        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_tpsno =\n            l_current_part;\n\n        if (l_num_parts != 0) {\n            p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].nb_tps =\n                l_num_parts;\n            p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps =\n                l_num_parts;\n\n            if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =\n                    (opj_tp_index_t*)opj_calloc(l_num_parts, sizeof(opj_tp_index_t));\n                if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                    return OPJ_FALSE;\n                }\n            } else {\n                opj_tp_index_t *new_tp_index = (opj_tp_index_t *) opj_realloc(\n                                                   p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index,\n                                                   l_num_parts * sizeof(opj_tp_index_t));\n                if (! new_tp_index) {\n                    opj_free(p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index);\n                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = NULL;\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                    return OPJ_FALSE;\n                }\n                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =\n                    new_tp_index;\n            }\n        } else {\n            /*if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index)*/ {\n\n                if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 10;\n                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =\n                        (opj_tp_index_t*)opj_calloc(\n                            p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps,\n                            sizeof(opj_tp_index_t));\n                    if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 0;\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                      \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                        return OPJ_FALSE;\n                    }\n                }\n\n                if (l_current_part >=\n                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps) {\n                    opj_tp_index_t *new_tp_index;\n                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps =\n                        l_current_part + 1;\n                    new_tp_index = (opj_tp_index_t *) opj_realloc(\n                                       p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index,\n                                       p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps *\n                                       sizeof(opj_tp_index_t));\n                    if (! new_tp_index) {\n                        opj_free(p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index);\n                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = NULL;\n                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 0;\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                      \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                        return OPJ_FALSE;\n                    }\n                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =\n                        new_tp_index;\n                }\n            }\n\n        }\n\n    }\n\n    /* FIXME move this onto a separate method to call before reading any SOT, remove part about main_end header, use a index struct inside p_j2k */\n    /* if (p_j2k->cstr_info) {\n       if (l_tcp->first) {\n       if (tileno == 0) {\n       p_j2k->cstr_info->main_head_end = p_stream_tell(p_stream) - 13;\n       }\n\n       p_j2k->cstr_info->tile[tileno].tileno = tileno;\n       p_j2k->cstr_info->tile[tileno].start_pos = p_stream_tell(p_stream) - 12;\n       p_j2k->cstr_info->tile[tileno].end_pos = p_j2k->cstr_info->tile[tileno].start_pos + totlen - 1;\n       p_j2k->cstr_info->tile[tileno].num_tps = numparts;\n\n       if (numparts) {\n       p_j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(numparts * sizeof(opj_tp_info_t));\n       }\n       else {\n       p_j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(10 * sizeof(opj_tp_info_t)); // Fixme (10)\n       }\n       }\n       else {\n       p_j2k->cstr_info->tile[tileno].end_pos += totlen;\n       }\n\n       p_j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos = p_stream_tell(p_stream) - 12;\n       p_j2k->cstr_info->tile[tileno].tp[partno].tp_end_pos =\n       p_j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos + totlen - 1;\n       }*/\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,\n                                  opj_tcd_t * p_tile_coder,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  OPJ_UINT32 p_total_data_size,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    opj_codestream_info_t *l_cstr_info = 00;\n    OPJ_UINT32 l_remaining_data;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_stream);\n\n    opj_write_bytes(p_data, J2K_MS_SOD,\n                    2);                                 /* SOD */\n    p_data += 2;\n\n    /* make room for the EOF marker */\n    l_remaining_data =  p_total_data_size - 4;\n\n    /* update tile coder */\n    p_tile_coder->tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;\n    p_tile_coder->cur_tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n\n    /* INDEX >> */\n    /* TODO mergeV2: check this part which use cstr_info */\n    /*l_cstr_info = p_j2k->cstr_info;\n    if (l_cstr_info) {\n            if (!p_j2k->m_specific_param.m_encoder.m_current_tile_part_number ) {\n                    //TODO cstr_info->tile[p_j2k->m_current_tile_number].end_header = p_stream_tell(p_stream) + p_j2k->pos_correction - 1;\n                    l_cstr_info->tile[p_j2k->m_current_tile_number].tileno = p_j2k->m_current_tile_number;\n            }\n            else {*/\n    /*\n    TODO\n    if\n            (cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno - 1].end_pos < p_stream_tell(p_stream))\n    {\n            cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno].start_pos = p_stream_tell(p_stream);\n    }*/\n    /*}*/\n    /* UniPG>> */\n#ifdef USE_JPWL\n    /* update markers struct */\n    /*OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOD, p_j2k->sod_start, 2);\n    */\n    assert(0 && \"TODO\");\n#endif /* USE_JPWL */\n    /* <<UniPG */\n    /*}*/\n    /* << INDEX */\n\n    if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {\n        p_tile_coder->tcd_image->tiles->packno = 0;\n        if (l_cstr_info) {\n            l_cstr_info->packno = 0;\n        }\n    }\n\n    *p_data_written = 0;\n\n    if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,\n                              p_data_written, l_remaining_data, l_cstr_info,\n                              p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot encode tile\\n\");\n        return OPJ_FALSE;\n    }\n\n    *p_data_written += 2;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_SIZE_T l_current_read_size;\n    opj_codestream_index_t * l_cstr_index = 00;\n    OPJ_BYTE ** l_current_data = 00;\n    opj_tcp_t * l_tcp = 00;\n    OPJ_UINT32 * l_tile_len = 00;\n    OPJ_BOOL l_sot_length_pb_detected = OPJ_FALSE;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n\n    if (p_j2k->m_specific_param.m_decoder.m_last_tile_part) {\n        /* opj_stream_get_number_byte_left returns OPJ_OFF_T\n        // but we are in the last tile part,\n        // so its result will fit on OPJ_UINT32 unless we find\n        // a file with a single tile part of more than 4 GB...*/\n        p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32)(\n                    opj_stream_get_number_byte_left(p_stream) - 2);\n    } else {\n        /* Check to avoid pass the limit of OPJ_UINT32 */\n        if (p_j2k->m_specific_param.m_decoder.m_sot_length >= 2) {\n            p_j2k->m_specific_param.m_decoder.m_sot_length -= 2;\n        } else {\n            /* MSD: case commented to support empty SOT marker (PHR data) */\n        }\n    }\n\n    l_current_data = &(l_tcp->m_data);\n    l_tile_len = &l_tcp->m_data_size;\n\n    /* Patch to support new PHR data */\n    if (p_j2k->m_specific_param.m_decoder.m_sot_length) {\n        /* If we are here, we'll try to read the data after allocation */\n        /* Check enough bytes left in stream before allocation */\n        if ((OPJ_OFF_T)p_j2k->m_specific_param.m_decoder.m_sot_length >\n                opj_stream_get_number_byte_left(p_stream)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Tile part length size inconsistent with stream length\\n\");\n            return OPJ_FALSE;\n        }\n        if (p_j2k->m_specific_param.m_decoder.m_sot_length >\n                UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"p_j2k->m_specific_param.m_decoder.m_sot_length > \"\n                          \"UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA\");\n            return OPJ_FALSE;\n        }\n        /* Add a margin of OPJ_COMMON_CBLK_DATA_EXTRA to the allocation we */\n        /* do so that opj_mqc_init_dec_common() can safely add a synthetic */\n        /* 0xFFFF marker. */\n        if (! *l_current_data) {\n            /* LH: oddly enough, in this path, l_tile_len!=0.\n             * TODO: If this was consistent, we could simplify the code to only use realloc(), as realloc(0,...) default to malloc(0,...).\n             */\n            *l_current_data = (OPJ_BYTE*) opj_malloc(\n                                  p_j2k->m_specific_param.m_decoder.m_sot_length + OPJ_COMMON_CBLK_DATA_EXTRA);\n        } else {\n            OPJ_BYTE *l_new_current_data;\n            if (*l_tile_len > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA -\n                    p_j2k->m_specific_param.m_decoder.m_sot_length) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"*l_tile_len > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA - \"\n                              \"p_j2k->m_specific_param.m_decoder.m_sot_length\");\n                return OPJ_FALSE;\n            }\n\n            l_new_current_data = (OPJ_BYTE *) opj_realloc(*l_current_data,\n                                 *l_tile_len + p_j2k->m_specific_param.m_decoder.m_sot_length +\n                                 OPJ_COMMON_CBLK_DATA_EXTRA);\n            if (! l_new_current_data) {\n                opj_free(*l_current_data);\n                /*nothing more is done as l_current_data will be set to null, and just\n                  afterward we enter in the error path\n                  and the actual tile_len is updated (committed) at the end of the\n                  function. */\n            }\n            *l_current_data = l_new_current_data;\n        }\n\n        if (*l_current_data == 00) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tile\\n\");\n            return OPJ_FALSE;\n        }\n    } else {\n        l_sot_length_pb_detected = OPJ_TRUE;\n    }\n\n    /* Index */\n    l_cstr_index = p_j2k->cstr_index;\n    if (l_cstr_index) {\n        OPJ_OFF_T l_current_pos = opj_stream_tell(p_stream) - 2;\n\n        OPJ_UINT32 l_current_tile_part =\n            l_cstr_index->tile_index[p_j2k->m_current_tile_number].current_tpsno;\n        l_cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index[l_current_tile_part].end_header\n            =\n                l_current_pos;\n        l_cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index[l_current_tile_part].end_pos\n            =\n                l_current_pos + p_j2k->m_specific_param.m_decoder.m_sot_length + 2;\n\n        if (OPJ_FALSE == opj_j2k_add_tlmarker(p_j2k->m_current_tile_number,\n                                              l_cstr_index,\n                                              J2K_MS_SOD,\n                                              l_current_pos,\n                                              p_j2k->m_specific_param.m_decoder.m_sot_length + 2)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add tl marker\\n\");\n            return OPJ_FALSE;\n        }\n\n        /*l_cstr_index->packno = 0;*/\n    }\n\n    /* Patch to support new PHR data */\n    if (!l_sot_length_pb_detected) {\n        l_current_read_size = opj_stream_read_data(\n                                  p_stream,\n                                  *l_current_data + *l_tile_len,\n                                  p_j2k->m_specific_param.m_decoder.m_sot_length,\n                                  p_manager);\n    } else {\n        l_current_read_size = 0;\n    }\n\n    if (l_current_read_size != p_j2k->m_specific_param.m_decoder.m_sot_length) {\n        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n    } else {\n        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n    }\n\n    *l_tile_len += (OPJ_UINT32)l_current_read_size;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k,\n                                  OPJ_UINT32 p_tile_no,\n                                  OPJ_UINT32 p_comp_no,\n                                  OPJ_UINT32 nb_comps,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_rgn_size;\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n    OPJ_UINT32 l_comp_room;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp = &l_tcp->tccps[p_comp_no];\n\n    if (nb_comps <= 256) {\n        l_comp_room = 1;\n    } else {\n        l_comp_room = 2;\n    }\n\n    l_rgn_size = 6 + l_comp_room;\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_RGN,\n                    2);                                   /* RGN  */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_rgn_size - 2,\n                    2);                                 /* Lrgn */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, p_comp_no,\n                    l_comp_room);                          /* Crgn */\n    l_current_data += l_comp_room;\n\n    opj_write_bytes(l_current_data, 0,\n                    1);                                           /* Srgn */\n    ++l_current_data;\n\n    opj_write_bytes(l_current_data, (OPJ_UINT32)l_tccp->roishift,\n                    1);                            /* SPrgn */\n    ++l_current_data;\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_rgn_size,\n                              p_manager) != l_rgn_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_header_tile_data,\n                    J2K_MS_EOC, 2);                                    /* EOC */\n\n    /* UniPG>> */\n#ifdef USE_JPWL\n    /* update markers struct */\n    /*\n    OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_EOC, p_stream_tell(p_stream) - 2, 2);\n    */\n#endif /* USE_JPWL */\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, 2, p_manager) != 2) {\n        return OPJ_FALSE;\n    }\n\n    if (! opj_stream_flush(p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a RGN marker (Region Of Interest)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_nb_comp;\n    opj_image_t * l_image = 00;\n\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_comp_room, l_comp_no, l_roi_sty;\n\n    /* preconditions*/\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_image = p_j2k->m_private_image;\n    l_nb_comp = l_image->numcomps;\n\n    if (l_nb_comp <= 256) {\n        l_comp_room = 1;\n    } else {\n        l_comp_room = 2;\n    }\n\n    if (p_header_size != 2 + l_comp_room) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading RGN marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    opj_read_bytes(p_header_data, &l_comp_no, l_comp_room);         /* Crgn */\n    p_header_data += l_comp_room;\n    opj_read_bytes(p_header_data, &l_roi_sty,\n                   1);                                     /* Srgn */\n    ++p_header_data;\n\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n        /* totlen is negative or larger than the bytes left!!! */\n        if (l_comp_room >= l_nb_comp) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"JPWL: bad component number in RGN (%d when there are only %d)\\n\",\n                          l_comp_room, l_nb_comp);\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n        }\n    };\n#endif /* USE_JPWL */\n\n    /* testcase 3635.pdf.asan.77.2930 */\n    if (l_comp_no >= l_nb_comp) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"bad component number in RGN (%d when there are only %d)\\n\",\n                      l_comp_no, l_nb_comp);\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data,\n                   (OPJ_UINT32 *)(&(l_tcp->tccps[l_comp_no].roishift)), 1);  /* SPrgn */\n    ++p_header_data;\n\n    return OPJ_TRUE;\n\n}\n\nstatic OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t * p_tcp)\n{\n    return (OPJ_FLOAT32)((p_tcp->m_nb_tile_parts - 1) * 14);\n}\n\nstatic OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t * p_tcp)\n{\n    (void)p_tcp;\n    return 0;\n}\n\nstatic OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k,\n                                     opj_stream_private_t *p_stream,\n                                     opj_event_mgr_t * p_manager)\n{\n    opj_cp_t * l_cp = 00;\n    opj_image_t * l_image = 00;\n    opj_tcp_t * l_tcp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n\n    OPJ_UINT32 i, j, k;\n    OPJ_INT32 l_x0, l_y0, l_x1, l_y1;\n    OPJ_FLOAT32 * l_rates = 0;\n    OPJ_FLOAT32 l_sot_remove;\n    OPJ_UINT32 l_bits_empty, l_size_pixel;\n    OPJ_UINT32 l_tile_size = 0;\n    OPJ_UINT32 l_last_res;\n    OPJ_FLOAT32(* l_tp_stride_func)(opj_tcp_t *) = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_manager);\n\n    l_cp = &(p_j2k->m_cp);\n    l_image = p_j2k->m_private_image;\n    l_tcp = l_cp->tcps;\n\n    l_bits_empty = 8 * l_image->comps->dx * l_image->comps->dy;\n    l_size_pixel = l_image->numcomps * l_image->comps->prec;\n    l_sot_remove = (OPJ_FLOAT32) opj_stream_tell(p_stream) / (OPJ_FLOAT32)(\n                       l_cp->th * l_cp->tw);\n\n    if (l_cp->m_specific_param.m_enc.m_tp_on) {\n        l_tp_stride_func = opj_j2k_get_tp_stride;\n    } else {\n        l_tp_stride_func = opj_j2k_get_default_stride;\n    }\n\n    for (i = 0; i < l_cp->th; ++i) {\n        for (j = 0; j < l_cp->tw; ++j) {\n            OPJ_FLOAT32 l_offset = (OPJ_FLOAT32)(*l_tp_stride_func)(l_tcp) /\n                                   (OPJ_FLOAT32)l_tcp->numlayers;\n\n            /* 4 borders of the tile rescale on the image if necessary */\n            l_x0 = opj_int_max((OPJ_INT32)(l_cp->tx0 + j * l_cp->tdx),\n                               (OPJ_INT32)l_image->x0);\n            l_y0 = opj_int_max((OPJ_INT32)(l_cp->ty0 + i * l_cp->tdy),\n                               (OPJ_INT32)l_image->y0);\n            l_x1 = opj_int_min((OPJ_INT32)(l_cp->tx0 + (j + 1) * l_cp->tdx),\n                               (OPJ_INT32)l_image->x1);\n            l_y1 = opj_int_min((OPJ_INT32)(l_cp->ty0 + (i + 1) * l_cp->tdy),\n                               (OPJ_INT32)l_image->y1);\n\n            l_rates = l_tcp->rates;\n\n            /* Modification of the RATE >> */\n            if (*l_rates > 0.0f) {\n                *l_rates = (((OPJ_FLOAT32)(l_size_pixel * (OPJ_UINT32)(l_x1 - l_x0) *\n                                           (OPJ_UINT32)(l_y1 - l_y0)))\n                            /\n                            ((*l_rates) * (OPJ_FLOAT32)l_bits_empty)\n                           )\n                           -\n                           l_offset;\n            }\n\n            ++l_rates;\n\n            for (k = 1; k < l_tcp->numlayers; ++k) {\n                if (*l_rates > 0.0f) {\n                    *l_rates = (((OPJ_FLOAT32)(l_size_pixel * (OPJ_UINT32)(l_x1 - l_x0) *\n                                               (OPJ_UINT32)(l_y1 - l_y0)))\n                                /\n                                ((*l_rates) * (OPJ_FLOAT32)l_bits_empty)\n                               )\n                               -\n                               l_offset;\n                }\n\n                ++l_rates;\n            }\n\n            ++l_tcp;\n\n        }\n    }\n\n    l_tcp = l_cp->tcps;\n\n    for (i = 0; i < l_cp->th; ++i) {\n        for (j = 0; j < l_cp->tw; ++j) {\n            l_rates = l_tcp->rates;\n\n            if (*l_rates > 0.0f) {\n                *l_rates -= l_sot_remove;\n\n                if (*l_rates < 30.0f) {\n                    *l_rates = 30.0f;\n                }\n            }\n\n            ++l_rates;\n\n            l_last_res = l_tcp->numlayers - 1;\n\n            for (k = 1; k < l_last_res; ++k) {\n\n                if (*l_rates > 0.0f) {\n                    *l_rates -= l_sot_remove;\n\n                    if (*l_rates < * (l_rates - 1) + 10.0f) {\n                        *l_rates  = (*(l_rates - 1)) + 20.0f;\n                    }\n                }\n\n                ++l_rates;\n            }\n\n            if (*l_rates > 0.0f) {\n                *l_rates -= (l_sot_remove + 2.f);\n\n                if (*l_rates < * (l_rates - 1) + 10.0f) {\n                    *l_rates  = (*(l_rates - 1)) + 20.0f;\n                }\n            }\n\n            ++l_tcp;\n        }\n    }\n\n    l_img_comp = l_image->comps;\n    l_tile_size = 0;\n\n    for (i = 0; i < l_image->numcomps; ++i) {\n        l_tile_size += (opj_uint_ceildiv(l_cp->tdx, l_img_comp->dx)\n                        *\n                        opj_uint_ceildiv(l_cp->tdy, l_img_comp->dy)\n                        *\n                        l_img_comp->prec\n                       );\n\n        ++l_img_comp;\n    }\n\n    l_tile_size = (OPJ_UINT32)(l_tile_size * 0.1625);  /* 1.3/8 = 0.1625 */\n\n    l_tile_size += opj_j2k_get_specific_header_sizes(p_j2k);\n\n    p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = l_tile_size;\n    p_j2k->m_specific_param.m_encoder.m_encoded_tile_data =\n        (OPJ_BYTE *) opj_malloc(p_j2k->m_specific_param.m_encoder.m_encoded_tile_size);\n    if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data == 00) {\n        return OPJ_FALSE;\n    }\n\n    if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer =\n            (OPJ_BYTE *) opj_malloc(5 *\n                                    p_j2k->m_specific_param.m_encoder.m_total_tile_parts);\n        if (! p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {\n            return OPJ_FALSE;\n        }\n\n        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current =\n            p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer;\n    }\n\n    return OPJ_TRUE;\n}\n\n#if 0\nstatic OPJ_BOOL opj_j2k_read_eoc(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i;\n    opj_tcd_t * l_tcd = 00;\n    OPJ_UINT32 l_nb_tiles;\n    opj_tcp_t * l_tcp = 00;\n    OPJ_BOOL l_success;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n    l_tcp = p_j2k->m_cp.tcps;\n\n    l_tcd = opj_tcd_create(OPJ_TRUE);\n    if (l_tcd == 00) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n        return OPJ_FALSE;\n    }\n\n    for (i = 0; i < l_nb_tiles; ++i) {\n        if (l_tcp->m_data) {\n            if (! opj_tcd_init_decode_tile(l_tcd, i)) {\n                opj_tcd_destroy(l_tcd);\n                opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n                return OPJ_FALSE;\n            }\n\n            l_success = opj_tcd_decode_tile(l_tcd, l_tcp->m_data, l_tcp->m_data_size, i,\n                                            p_j2k->cstr_index);\n            /* cleanup */\n\n            if (! l_success) {\n                p_j2k->m_specific_param.m_decoder.m_state |= J2K_STATE_ERR;\n                break;\n            }\n        }\n\n        opj_j2k_tcp_destroy(l_tcp);\n        ++l_tcp;\n    }\n\n    opj_tcd_destroy(l_tcd);\n    return OPJ_TRUE;\n}\n#endif\n\nstatic OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k,\n                                       struct opj_stream_private *p_stream,\n                                       struct opj_event_mgr * p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_manager);\n\n    p_j2k->cstr_index->main_head_end = opj_stream_tell(p_stream);\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k,\n        struct opj_stream_private *p_stream,\n        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 i;\n    opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n    opj_mct_data_t * l_mct_record;\n    opj_tcp_t * l_tcp;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    if (! opj_j2k_write_cbd(p_j2k, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n    l_mct_record = l_tcp->m_mct_records;\n\n    for (i = 0; i < l_tcp->m_nb_mct_records; ++i) {\n\n        if (! opj_j2k_write_mct_record(p_j2k, l_mct_record, p_stream, p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        ++l_mct_record;\n    }\n\n    l_mcc_record = l_tcp->m_mcc_records;\n\n    for (i = 0; i < l_tcp->m_nb_mcc_records; ++i) {\n\n        if (! opj_j2k_write_mcc_record(p_j2k, l_mcc_record, p_stream, p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        ++l_mcc_record;\n    }\n\n    if (! opj_j2k_write_mco(p_j2k, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_all_coc(\n    opj_j2k_t *p_j2k,\n    struct opj_stream_private *p_stream,\n    struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 compno;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    for (compno = 1; compno < p_j2k->m_private_image->numcomps; ++compno) {\n        /* cod is first component of first tile */\n        if (! opj_j2k_compare_coc(p_j2k, 0, compno)) {\n            if (! opj_j2k_write_coc(p_j2k, compno, p_stream, p_manager)) {\n                return OPJ_FALSE;\n            }\n        }\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_all_qcc(\n    opj_j2k_t *p_j2k,\n    struct opj_stream_private *p_stream,\n    struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 compno;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    for (compno = 1; compno < p_j2k->m_private_image->numcomps; ++compno) {\n        /* qcd is first component of first tile */\n        if (! opj_j2k_compare_qcc(p_j2k, 0, compno)) {\n            if (! opj_j2k_write_qcc(p_j2k, compno, p_stream, p_manager)) {\n                return OPJ_FALSE;\n            }\n        }\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k,\n                                      struct opj_stream_private *p_stream,\n                                      struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 compno;\n    const opj_tccp_t *l_tccp = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_tccp = p_j2k->m_cp.tcps->tccps;\n\n    for (compno = 0; compno < p_j2k->m_private_image->numcomps; ++compno)  {\n        if (l_tccp->roishift) {\n\n            if (! opj_j2k_write_rgn(p_j2k, 0, compno, p_j2k->m_private_image->numcomps,\n                                    p_stream, p_manager)) {\n                return OPJ_FALSE;\n            }\n        }\n\n        ++l_tccp;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k,\n                                  struct opj_stream_private *p_stream,\n                                  struct opj_event_mgr * p_manager)\n{\n    opj_codestream_index_t * l_cstr_index = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_manager);\n\n    l_cstr_index = p_j2k->cstr_index;\n    if (l_cstr_index) {\n        l_cstr_index->codestream_size = (OPJ_UINT64)opj_stream_tell(p_stream);\n        /* UniPG>> */\n        /* The following adjustment is done to adjust the codestream size */\n        /* if SOD is not at 0 in the buffer. Useful in case of JP2, where */\n        /* the first bunch of bytes is not in the codestream              */\n        l_cstr_index->codestream_size -= (OPJ_UINT64)l_cstr_index->main_head_start;\n        /* <<UniPG */\n    }\n\n#ifdef USE_JPWL\n    /* preparation of JPWL marker segments */\n#if 0\n    if (cp->epc_on) {\n\n        /* encode according to JPWL */\n        jpwl_encode(p_j2k, p_stream, image);\n\n    }\n#endif\n    assert(0 && \"TODO\");\n#endif /* USE_JPWL */\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k,\n                                 opj_stream_private_t *p_stream,\n                                 OPJ_UINT32 *output_marker,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_unknown_marker;\n    const opj_dec_memory_marker_handler_t * l_marker_handler;\n    OPJ_UINT32 l_size_unk = 2;\n\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    opj_event_msg(p_manager, EVT_WARNING, \"Unknown marker\\n\");\n\n    for (;;) {\n        /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer*/\n        if (opj_stream_read_data(p_stream,\n                                 p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* read 2 bytes as the new marker ID*/\n        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                       &l_unknown_marker, 2);\n\n        if (!(l_unknown_marker < 0xff00)) {\n\n            /* Get the marker handler from the marker ID*/\n            l_marker_handler = opj_j2k_get_marker_handler(l_unknown_marker);\n\n            if (!(p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Marker is not compliant with its position\\n\");\n                return OPJ_FALSE;\n            } else {\n                if (l_marker_handler->id != J2K_MS_UNK) {\n                    /* Add the marker to the codestream index*/\n                    if (l_marker_handler->id != J2K_MS_SOT) {\n                        OPJ_BOOL res = opj_j2k_add_mhmarker(p_j2k->cstr_index, J2K_MS_UNK,\n                                                            (OPJ_UINT32) opj_stream_tell(p_stream) - l_size_unk,\n                                                            l_size_unk);\n                        if (res == OPJ_FALSE) {\n                            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\");\n                            return OPJ_FALSE;\n                        }\n                    }\n                    break; /* next marker is known and well located */\n                } else {\n                    l_size_unk += 2;\n                }\n            }\n        }\n    }\n\n    *output_marker = l_marker_handler->id ;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k,\n        opj_mct_data_t * p_mct_record,\n        struct opj_stream_private *p_stream,\n        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 l_mct_size;\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_tmp;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_mct_size = 10 + p_mct_record->m_data_size;\n\n    if (l_mct_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mct_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCT marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mct_size;\n    }\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_MCT,\n                    2);                                   /* MCT */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_mct_size - 2,\n                    2);                                 /* Lmct */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, 0,\n                    2);                                                    /* Zmct */\n    l_current_data += 2;\n\n    /* only one marker atm */\n    l_tmp = (p_mct_record->m_index & 0xff) | (p_mct_record->m_array_type << 8) |\n            (p_mct_record->m_element_type << 10);\n\n    opj_write_bytes(l_current_data, l_tmp, 2);\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, 0,\n                    2);                                                    /* Ymct */\n    l_current_data += 2;\n\n    memcpy(l_current_data, p_mct_record->m_data, p_mct_record->m_data_size);\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mct_size,\n                              p_manager) != l_mct_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a MCT marker (Multiple Component Transform)\n *\n * @param       p_header_data   the data contained in the MCT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 i;\n    opj_tcp_t *l_tcp = 00;\n    OPJ_UINT32 l_tmp;\n    OPJ_UINT32 l_indix;\n    opj_mct_data_t * l_mct_data;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n\n    l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n            &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    if (p_header_size < 2) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* first marker */\n    opj_read_bytes(p_header_data, &l_tmp, 2);                       /* Zmct */\n    p_header_data += 2;\n    if (l_tmp != 0) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Cannot take in charge mct data within multiple MCT records\\n\");\n        return OPJ_TRUE;\n    }\n\n    if (p_header_size <= 6) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCT marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* Imct -> no need for other values, take the first, type is double with decorrelation x0000 1101 0000 0000*/\n    opj_read_bytes(p_header_data, &l_tmp, 2);                       /* Imct */\n    p_header_data += 2;\n\n    l_indix = l_tmp & 0xff;\n    l_mct_data = l_tcp->m_mct_records;\n\n    for (i = 0; i < l_tcp->m_nb_mct_records; ++i) {\n        if (l_mct_data->m_index == l_indix) {\n            break;\n        }\n        ++l_mct_data;\n    }\n\n    /* NOT FOUND */\n    if (i == l_tcp->m_nb_mct_records) {\n        if (l_tcp->m_nb_mct_records == l_tcp->m_nb_max_mct_records) {\n            opj_mct_data_t *new_mct_records;\n            l_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n\n            new_mct_records = (opj_mct_data_t *) opj_realloc(l_tcp->m_mct_records,\n                              l_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));\n            if (! new_mct_records) {\n                opj_free(l_tcp->m_mct_records);\n                l_tcp->m_mct_records = NULL;\n                l_tcp->m_nb_max_mct_records = 0;\n                l_tcp->m_nb_mct_records = 0;\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read MCT marker\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* Update m_mcc_records[].m_offset_array and m_decorrelation_array\n             * to point to the new addresses */\n            if (new_mct_records != l_tcp->m_mct_records) {\n                for (i = 0; i < l_tcp->m_nb_mcc_records; ++i) {\n                    opj_simple_mcc_decorrelation_data_t* l_mcc_record =\n                        &(l_tcp->m_mcc_records[i]);\n                    if (l_mcc_record->m_decorrelation_array) {\n                        l_mcc_record->m_decorrelation_array =\n                            new_mct_records +\n                            (l_mcc_record->m_decorrelation_array -\n                             l_tcp->m_mct_records);\n                    }\n                    if (l_mcc_record->m_offset_array) {\n                        l_mcc_record->m_offset_array =\n                            new_mct_records +\n                            (l_mcc_record->m_offset_array -\n                             l_tcp->m_mct_records);\n                    }\n                }\n            }\n\n            l_tcp->m_mct_records = new_mct_records;\n            l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;\n            memset(l_mct_data, 0, (l_tcp->m_nb_max_mct_records - l_tcp->m_nb_mct_records) *\n                   sizeof(opj_mct_data_t));\n        }\n\n        l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;\n        ++l_tcp->m_nb_mct_records;\n    }\n\n    if (l_mct_data->m_data) {\n        opj_free(l_mct_data->m_data);\n        l_mct_data->m_data = 00;\n        l_mct_data->m_data_size = 0;\n    }\n\n    l_mct_data->m_index = l_indix;\n    l_mct_data->m_array_type = (J2K_MCT_ARRAY_TYPE)((l_tmp  >> 8) & 3);\n    l_mct_data->m_element_type = (J2K_MCT_ELEMENT_TYPE)((l_tmp  >> 10) & 3);\n\n    opj_read_bytes(p_header_data, &l_tmp, 2);                       /* Ymct */\n    p_header_data += 2;\n    if (l_tmp != 0) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Cannot take in charge multiple MCT markers\\n\");\n        return OPJ_TRUE;\n    }\n\n    p_header_size -= 6;\n\n    l_mct_data->m_data = (OPJ_BYTE*)opj_malloc(p_header_size);\n    if (! l_mct_data->m_data) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCT marker\\n\");\n        return OPJ_FALSE;\n    }\n    memcpy(l_mct_data->m_data, p_header_data, p_header_size);\n\n    l_mct_data->m_data_size = p_header_size;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k,\n        struct opj_simple_mcc_decorrelation_data * p_mcc_record,\n        struct opj_stream_private *p_stream,\n        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_mcc_size;\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_nb_bytes_for_comp;\n    OPJ_UINT32 l_mask;\n    OPJ_UINT32 l_tmcc;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    if (p_mcc_record->m_nb_comps > 255) {\n        l_nb_bytes_for_comp = 2;\n        l_mask = 0x8000;\n    } else {\n        l_nb_bytes_for_comp = 1;\n        l_mask = 0;\n    }\n\n    l_mcc_size = p_mcc_record->m_nb_comps * 2 * l_nb_bytes_for_comp + 19;\n    if (l_mcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mcc_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCC marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mcc_size;\n    }\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_MCC,\n                    2);                                   /* MCC */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_mcc_size - 2,\n                    2);                                 /* Lmcc */\n    l_current_data += 2;\n\n    /* first marker */\n    opj_write_bytes(l_current_data, 0,\n                    2);                                  /* Zmcc */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, p_mcc_record->m_index,\n                    1);                                        /* Imcc -> no need for other values, take the first */\n    ++l_current_data;\n\n    /* only one marker atm */\n    opj_write_bytes(l_current_data, 0,\n                    2);                                  /* Ymcc */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, 1,\n                    2);                                  /* Qmcc -> number of collections -> 1 */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, 0x1,\n                    1);                                /* Xmcci type of component transformation -> array based decorrelation */\n    ++l_current_data;\n\n    opj_write_bytes(l_current_data, p_mcc_record->m_nb_comps | l_mask,\n                    2);  /* Nmcci number of input components involved and size for each component offset = 8 bits */\n    l_current_data += 2;\n\n    for (i = 0; i < p_mcc_record->m_nb_comps; ++i) {\n        opj_write_bytes(l_current_data, i,\n                        l_nb_bytes_for_comp);                          /* Cmccij Component offset*/\n        l_current_data += l_nb_bytes_for_comp;\n    }\n\n    opj_write_bytes(l_current_data, p_mcc_record->m_nb_comps | l_mask,\n                    2);  /* Mmcci number of output components involved and size for each component offset = 8 bits */\n    l_current_data += 2;\n\n    for (i = 0; i < p_mcc_record->m_nb_comps; ++i) {\n        opj_write_bytes(l_current_data, i,\n                        l_nb_bytes_for_comp);                          /* Wmccij Component offset*/\n        l_current_data += l_nb_bytes_for_comp;\n    }\n\n    l_tmcc = ((!p_mcc_record->m_is_irreversible) & 1U) << 16;\n\n    if (p_mcc_record->m_decorrelation_array) {\n        l_tmcc |= p_mcc_record->m_decorrelation_array->m_index;\n    }\n\n    if (p_mcc_record->m_offset_array) {\n        l_tmcc |= ((p_mcc_record->m_offset_array->m_index) << 8);\n    }\n\n    opj_write_bytes(l_current_data, l_tmcc,\n                    3);     /* Tmcci : use MCT defined as number 1 and irreversible array based. */\n    l_current_data += 3;\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mcc_size,\n                              p_manager) != l_mcc_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i, j;\n    OPJ_UINT32 l_tmp;\n    OPJ_UINT32 l_indix;\n    opj_tcp_t * l_tcp;\n    opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n    opj_mct_data_t * l_mct_data;\n    OPJ_UINT32 l_nb_collections;\n    OPJ_UINT32 l_nb_comps;\n    OPJ_UINT32 l_nb_bytes_by_comp;\n    OPJ_BOOL l_new_mcc = OPJ_FALSE;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n            &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    if (p_header_size < 2) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* first marker */\n    opj_read_bytes(p_header_data, &l_tmp, 2);                       /* Zmcc */\n    p_header_data += 2;\n    if (l_tmp != 0) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Cannot take in charge multiple data spanning\\n\");\n        return OPJ_TRUE;\n    }\n\n    if (p_header_size < 7) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_indix,\n                   1); /* Imcc -> no need for other values, take the first */\n    ++p_header_data;\n\n    l_mcc_record = l_tcp->m_mcc_records;\n\n    for (i = 0; i < l_tcp->m_nb_mcc_records; ++i) {\n        if (l_mcc_record->m_index == l_indix) {\n            break;\n        }\n        ++l_mcc_record;\n    }\n\n    /** NOT FOUND */\n    if (i == l_tcp->m_nb_mcc_records) {\n        if (l_tcp->m_nb_mcc_records == l_tcp->m_nb_max_mcc_records) {\n            opj_simple_mcc_decorrelation_data_t *new_mcc_records;\n            l_tcp->m_nb_max_mcc_records += OPJ_J2K_MCC_DEFAULT_NB_RECORDS;\n\n            new_mcc_records = (opj_simple_mcc_decorrelation_data_t *) opj_realloc(\n                                  l_tcp->m_mcc_records, l_tcp->m_nb_max_mcc_records * sizeof(\n                                      opj_simple_mcc_decorrelation_data_t));\n            if (! new_mcc_records) {\n                opj_free(l_tcp->m_mcc_records);\n                l_tcp->m_mcc_records = NULL;\n                l_tcp->m_nb_max_mcc_records = 0;\n                l_tcp->m_nb_mcc_records = 0;\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read MCC marker\\n\");\n                return OPJ_FALSE;\n            }\n            l_tcp->m_mcc_records = new_mcc_records;\n            l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;\n            memset(l_mcc_record, 0, (l_tcp->m_nb_max_mcc_records - l_tcp->m_nb_mcc_records)\n                   * sizeof(opj_simple_mcc_decorrelation_data_t));\n        }\n        l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;\n        l_new_mcc = OPJ_TRUE;\n    }\n    l_mcc_record->m_index = l_indix;\n\n    /* only one marker atm */\n    opj_read_bytes(p_header_data, &l_tmp, 2);                       /* Ymcc */\n    p_header_data += 2;\n    if (l_tmp != 0) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Cannot take in charge multiple data spanning\\n\");\n        return OPJ_TRUE;\n    }\n\n    opj_read_bytes(p_header_data, &l_nb_collections,\n                   2);                              /* Qmcc -> number of collections -> 1 */\n    p_header_data += 2;\n\n    if (l_nb_collections > 1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Cannot take in charge multiple collections\\n\");\n        return OPJ_TRUE;\n    }\n\n    p_header_size -= 7;\n\n    for (i = 0; i < l_nb_collections; ++i) {\n        if (p_header_size < 3) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n            return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data, &l_tmp,\n                       1); /* Xmcci type of component transformation -> array based decorrelation */\n        ++p_header_data;\n\n        if (l_tmp != 1) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"Cannot take in charge collections other than array decorrelation\\n\");\n            return OPJ_TRUE;\n        }\n\n        opj_read_bytes(p_header_data, &l_nb_comps, 2);\n\n        p_header_data += 2;\n        p_header_size -= 3;\n\n        l_nb_bytes_by_comp = 1 + (l_nb_comps >> 15);\n        l_mcc_record->m_nb_comps = l_nb_comps & 0x7fff;\n\n        if (p_header_size < (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n            return OPJ_FALSE;\n        }\n\n        p_header_size -= (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2);\n\n        for (j = 0; j < l_mcc_record->m_nb_comps; ++j) {\n            opj_read_bytes(p_header_data, &l_tmp,\n                           l_nb_bytes_by_comp);      /* Cmccij Component offset*/\n            p_header_data += l_nb_bytes_by_comp;\n\n            if (l_tmp != j) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"Cannot take in charge collections with indix shuffle\\n\");\n                return OPJ_TRUE;\n            }\n        }\n\n        opj_read_bytes(p_header_data, &l_nb_comps, 2);\n        p_header_data += 2;\n\n        l_nb_bytes_by_comp = 1 + (l_nb_comps >> 15);\n        l_nb_comps &= 0x7fff;\n\n        if (l_nb_comps != l_mcc_record->m_nb_comps) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"Cannot take in charge collections without same number of indixes\\n\");\n            return OPJ_TRUE;\n        }\n\n        if (p_header_size < (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n            return OPJ_FALSE;\n        }\n\n        p_header_size -= (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3);\n\n        for (j = 0; j < l_mcc_record->m_nb_comps; ++j) {\n            opj_read_bytes(p_header_data, &l_tmp,\n                           l_nb_bytes_by_comp);      /* Wmccij Component offset*/\n            p_header_data += l_nb_bytes_by_comp;\n\n            if (l_tmp != j) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"Cannot take in charge collections with indix shuffle\\n\");\n                return OPJ_TRUE;\n            }\n        }\n\n        opj_read_bytes(p_header_data, &l_tmp, 3); /* Wmccij Component offset*/\n        p_header_data += 3;\n\n        l_mcc_record->m_is_irreversible = !((l_tmp >> 16) & 1);\n        l_mcc_record->m_decorrelation_array = 00;\n        l_mcc_record->m_offset_array = 00;\n\n        l_indix = l_tmp & 0xff;\n        if (l_indix != 0) {\n            l_mct_data = l_tcp->m_mct_records;\n            for (j = 0; j < l_tcp->m_nb_mct_records; ++j) {\n                if (l_mct_data->m_index == l_indix) {\n                    l_mcc_record->m_decorrelation_array = l_mct_data;\n                    break;\n                }\n                ++l_mct_data;\n            }\n\n            if (l_mcc_record->m_decorrelation_array == 00) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                return OPJ_FALSE;\n            }\n        }\n\n        l_indix = (l_tmp >> 8) & 0xff;\n        if (l_indix != 0) {\n            l_mct_data = l_tcp->m_mct_records;\n            for (j = 0; j < l_tcp->m_nb_mct_records; ++j) {\n                if (l_mct_data->m_index == l_indix) {\n                    l_mcc_record->m_offset_array = l_mct_data;\n                    break;\n                }\n                ++l_mct_data;\n            }\n\n            if (l_mcc_record->m_offset_array == 00) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                return OPJ_FALSE;\n            }\n        }\n    }\n\n    if (p_header_size != 0) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (l_new_mcc) {\n        ++l_tcp->m_nb_mcc_records;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k,\n                                  struct opj_stream_private *p_stream,\n                                  struct opj_event_mgr * p_manager\n                                 )\n{\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_mco_size;\n    opj_tcp_t * l_tcp = 00;\n    opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n    OPJ_UINT32 i;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n\n    l_mco_size = 5 + l_tcp->m_nb_mcc_records;\n    if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCO marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;\n    }\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n\n    opj_write_bytes(l_current_data, J2K_MS_MCO, 2);                 /* MCO */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_mco_size - 2, 2);             /* Lmco */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_tcp->m_nb_mcc_records,\n                    1);    /* Nmco : only one transform stage*/\n    ++l_current_data;\n\n    l_mcc_record = l_tcp->m_mcc_records;\n    for (i = 0; i < l_tcp->m_nb_mcc_records; ++i) {\n        opj_write_bytes(l_current_data, l_mcc_record->m_index,\n                        1); /* Imco -> use the mcc indicated by 1*/\n        ++l_current_data;\n        ++l_mcc_record;\n    }\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size,\n                              p_manager) != l_mco_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a MCO marker (Multiple Component Transform Ordering)\n *\n * @param       p_header_data   the data contained in the MCO box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCO marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_tmp, i;\n    OPJ_UINT32 l_nb_stages;\n    opj_tcp_t * l_tcp;\n    opj_tccp_t * l_tccp;\n    opj_image_t * l_image;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_image = p_j2k->m_private_image;\n    l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n            &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    if (p_header_size < 1) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCO marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_nb_stages,\n                   1);                         /* Nmco : only one transform stage*/\n    ++p_header_data;\n\n    if (l_nb_stages > 1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Cannot take in charge multiple transformation stages.\\n\");\n        return OPJ_TRUE;\n    }\n\n    if (p_header_size != l_nb_stages + 1) {\n        opj_event_msg(p_manager, EVT_WARNING, \"Error reading MCO marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_tccp = l_tcp->tccps;\n\n    for (i = 0; i < l_image->numcomps; ++i) {\n        l_tccp->m_dc_level_shift = 0;\n        ++l_tccp;\n    }\n\n    if (l_tcp->m_mct_decoding_matrix) {\n        opj_free(l_tcp->m_mct_decoding_matrix);\n        l_tcp->m_mct_decoding_matrix = 00;\n    }\n\n    for (i = 0; i < l_nb_stages; ++i) {\n        opj_read_bytes(p_header_data, &l_tmp, 1);\n        ++p_header_data;\n\n        if (! opj_j2k_add_mct(l_tcp, p_j2k->m_private_image, l_tmp)) {\n            return OPJ_FALSE;\n        }\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_add_mct(opj_tcp_t * p_tcp, opj_image_t * p_image,\n                                OPJ_UINT32 p_index)\n{\n    OPJ_UINT32 i;\n    opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n    opj_mct_data_t * l_deco_array, * l_offset_array;\n    OPJ_UINT32 l_data_size, l_mct_size, l_offset_size;\n    OPJ_UINT32 l_nb_elem;\n    OPJ_UINT32 * l_offset_data, * l_current_offset_data;\n    opj_tccp_t * l_tccp;\n\n    /* preconditions */\n    assert(p_tcp != 00);\n\n    l_mcc_record = p_tcp->m_mcc_records;\n\n    for (i = 0; i < p_tcp->m_nb_mcc_records; ++i) {\n        if (l_mcc_record->m_index == p_index) {\n            break;\n        }\n    }\n\n    if (i == p_tcp->m_nb_mcc_records) {\n        /** element discarded **/\n        return OPJ_TRUE;\n    }\n\n    if (l_mcc_record->m_nb_comps != p_image->numcomps) {\n        /** do not support number of comps != image */\n        return OPJ_TRUE;\n    }\n\n    l_deco_array = l_mcc_record->m_decorrelation_array;\n\n    if (l_deco_array) {\n        l_data_size = MCT_ELEMENT_SIZE[l_deco_array->m_element_type] * p_image->numcomps\n                      * p_image->numcomps;\n        if (l_deco_array->m_data_size != l_data_size) {\n            return OPJ_FALSE;\n        }\n\n        l_nb_elem = p_image->numcomps * p_image->numcomps;\n        l_mct_size = l_nb_elem * (OPJ_UINT32)sizeof(OPJ_FLOAT32);\n        p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(l_mct_size);\n\n        if (! p_tcp->m_mct_decoding_matrix) {\n            return OPJ_FALSE;\n        }\n\n        j2k_mct_read_functions_to_float[l_deco_array->m_element_type](\n            l_deco_array->m_data, p_tcp->m_mct_decoding_matrix, l_nb_elem);\n    }\n\n    l_offset_array = l_mcc_record->m_offset_array;\n\n    if (l_offset_array) {\n        l_data_size = MCT_ELEMENT_SIZE[l_offset_array->m_element_type] *\n                      p_image->numcomps;\n        if (l_offset_array->m_data_size != l_data_size) {\n            return OPJ_FALSE;\n        }\n\n        l_nb_elem = p_image->numcomps;\n        l_offset_size = l_nb_elem * (OPJ_UINT32)sizeof(OPJ_UINT32);\n        l_offset_data = (OPJ_UINT32*)opj_malloc(l_offset_size);\n\n        if (! l_offset_data) {\n            return OPJ_FALSE;\n        }\n\n        j2k_mct_read_functions_to_int32[l_offset_array->m_element_type](\n            l_offset_array->m_data, l_offset_data, l_nb_elem);\n\n        l_tccp = p_tcp->tccps;\n        l_current_offset_data = l_offset_data;\n\n        for (i = 0; i < p_image->numcomps; ++i) {\n            l_tccp->m_dc_level_shift = (OPJ_INT32) * (l_current_offset_data++);\n            ++l_tccp;\n        }\n\n        opj_free(l_offset_data);\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k,\n                                  struct opj_stream_private *p_stream,\n                                  struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_cbd_size;\n    OPJ_BYTE * l_current_data = 00;\n    opj_image_t *l_image = 00;\n    opj_image_comp_t * l_comp = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_image = p_j2k->m_private_image;\n    l_cbd_size = 6 + p_j2k->m_private_image->numcomps;\n\n    if (l_cbd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(\n                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_cbd_size);\n        if (! new_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write CBD marker\\n\");\n            return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;\n    }\n\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n    opj_write_bytes(l_current_data, J2K_MS_CBD, 2);                 /* CBD */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_cbd_size - 2, 2);             /* L_CBD */\n    l_current_data += 2;\n\n    opj_write_bytes(l_current_data, l_image->numcomps, 2);          /* Ncbd */\n    l_current_data += 2;\n\n    l_comp = l_image->comps;\n\n    for (i = 0; i < l_image->numcomps; ++i) {\n        opj_write_bytes(l_current_data, (l_comp->sgnd << 7) | (l_comp->prec - 1),\n                        1);           /* Component bit depth */\n        ++l_current_data;\n\n        ++l_comp;\n    }\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_cbd_size,\n                              p_manager) != l_cbd_size) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\n/**\n * Reads a CBD marker (Component bit depth definition)\n * @param       p_header_data   the data contained in the CBD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the CBD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                )\n{\n    OPJ_UINT32 l_nb_comp, l_num_comp;\n    OPJ_UINT32 l_comp_def;\n    OPJ_UINT32 i;\n    opj_image_comp_t * l_comp = 00;\n\n    /* preconditions */\n    assert(p_header_data != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    l_num_comp = p_j2k->m_private_image->numcomps;\n\n    if (p_header_size != (p_j2k->m_private_image->numcomps + 2)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Crror reading CBD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(p_header_data, &l_nb_comp,\n                   2);                           /* Ncbd */\n    p_header_data += 2;\n\n    if (l_nb_comp != l_num_comp) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Crror reading CBD marker\\n\");\n        return OPJ_FALSE;\n    }\n\n    l_comp = p_j2k->m_private_image->comps;\n    for (i = 0; i < l_num_comp; ++i) {\n        opj_read_bytes(p_header_data, &l_comp_def,\n                       1);                  /* Component bit depth */\n        ++p_header_data;\n        l_comp->sgnd = (l_comp_def >> 7) & 1;\n        l_comp->prec = (l_comp_def & 0x7f) + 1;\n\n        if (l_comp->prec > 31) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\\n\",\n                          i, l_comp->prec);\n            return OPJ_FALSE;\n        }\n        ++l_comp;\n    }\n\n    return OPJ_TRUE;\n}\n\n/* ----------------------------------------------------------------------- */\n/* J2K / JPT decoder interface                                             */\n/* ----------------------------------------------------------------------- */\n\nvoid opj_j2k_setup_decoder(opj_j2k_t *j2k, opj_dparameters_t *parameters)\n{\n    if (j2k && parameters) {\n        j2k->m_cp.m_specific_param.m_dec.m_layer = parameters->cp_layer;\n        j2k->m_cp.m_specific_param.m_dec.m_reduce = parameters->cp_reduce;\n\n        j2k->dump_state = (parameters->flags & OPJ_DPARAMETERS_DUMP_FLAG);\n#ifdef USE_JPWL\n        j2k->m_cp.correct = parameters->jpwl_correct;\n        j2k->m_cp.exp_comps = parameters->jpwl_exp_comps;\n        j2k->m_cp.max_tiles = parameters->jpwl_max_tiles;\n#endif /* USE_JPWL */\n    }\n}\n\nOPJ_BOOL opj_j2k_set_threads(opj_j2k_t *j2k, OPJ_UINT32 num_threads)\n{\n    if (opj_has_thread_support()) {\n        opj_thread_pool_destroy(j2k->m_tp);\n        j2k->m_tp = NULL;\n        if (num_threads <= (OPJ_UINT32)INT_MAX) {\n            j2k->m_tp = opj_thread_pool_create((int)num_threads);\n        }\n        if (j2k->m_tp == NULL) {\n            j2k->m_tp = opj_thread_pool_create(0);\n            return OPJ_FALSE;\n        }\n        return OPJ_TRUE;\n    }\n    return OPJ_FALSE;\n}\n\nstatic int opj_j2k_get_default_thread_count()\n{\n    const char* num_threads = getenv(\"OPJ_NUM_THREADS\");\n    if (num_threads == NULL || !opj_has_thread_support()) {\n        return 0;\n    }\n    if (strcmp(num_threads, \"ALL_CPUS\") == 0) {\n        return opj_get_num_cpus();\n    }\n    return atoi(num_threads);\n}\n\n/* ----------------------------------------------------------------------- */\n/* J2K encoder interface                                                       */\n/* ----------------------------------------------------------------------- */\n\nopj_j2k_t* opj_j2k_create_compress(void)\n{\n    opj_j2k_t *l_j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));\n    if (!l_j2k) {\n        return NULL;\n    }\n\n\n    l_j2k->m_is_decoder = 0;\n    l_j2k->m_cp.m_is_decoder = 0;\n\n    l_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *) opj_malloc(\n                OPJ_J2K_DEFAULT_HEADER_SIZE);\n    if (! l_j2k->m_specific_param.m_encoder.m_header_tile_data) {\n        opj_j2k_destroy(l_j2k);\n        return NULL;\n    }\n\n    l_j2k->m_specific_param.m_encoder.m_header_tile_data_size =\n        OPJ_J2K_DEFAULT_HEADER_SIZE;\n\n    /* validation list creation*/\n    l_j2k->m_validation_list = opj_procedure_list_create();\n    if (! l_j2k->m_validation_list) {\n        opj_j2k_destroy(l_j2k);\n        return NULL;\n    }\n\n    /* execution list creation*/\n    l_j2k->m_procedure_list = opj_procedure_list_create();\n    if (! l_j2k->m_procedure_list) {\n        opj_j2k_destroy(l_j2k);\n        return NULL;\n    }\n\n    l_j2k->m_tp = opj_thread_pool_create(opj_j2k_get_default_thread_count());\n    if (!l_j2k->m_tp) {\n        l_j2k->m_tp = opj_thread_pool_create(0);\n    }\n    if (!l_j2k->m_tp) {\n        opj_j2k_destroy(l_j2k);\n        return NULL;\n    }\n\n    return l_j2k;\n}\n\nstatic int opj_j2k_initialise_4K_poc(opj_poc_t *POC, int numres)\n{\n    POC[0].tile  = 1;\n    POC[0].resno0  = 0;\n    POC[0].compno0 = 0;\n    POC[0].layno1  = 1;\n    POC[0].resno1  = (OPJ_UINT32)(numres - 1);\n    POC[0].compno1 = 3;\n    POC[0].prg1 = OPJ_CPRL;\n    POC[1].tile  = 1;\n    POC[1].resno0  = (OPJ_UINT32)(numres - 1);\n    POC[1].compno0 = 0;\n    POC[1].layno1  = 1;\n    POC[1].resno1  = (OPJ_UINT32)numres;\n    POC[1].compno1 = 3;\n    POC[1].prg1 = OPJ_CPRL;\n    return 2;\n}\n\nstatic void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,\n        opj_image_t *image, opj_event_mgr_t *p_manager)\n{\n    /* Configure cinema parameters */\n    int i;\n\n    /* No tiling */\n    parameters->tile_size_on = OPJ_FALSE;\n    parameters->cp_tdx = 1;\n    parameters->cp_tdy = 1;\n\n    /* One tile part for each component */\n    parameters->tp_flag = 'C';\n    parameters->tp_on = 1;\n\n    /* Tile and Image shall be at (0,0) */\n    parameters->cp_tx0 = 0;\n    parameters->cp_ty0 = 0;\n    parameters->image_offset_x0 = 0;\n    parameters->image_offset_y0 = 0;\n\n    /* Codeblock size= 32*32 */\n    parameters->cblockw_init = 32;\n    parameters->cblockh_init = 32;\n\n    /* Codeblock style: no mode switch enabled */\n    parameters->mode = 0;\n\n    /* No ROI */\n    parameters->roi_compno = -1;\n\n    /* No subsampling */\n    parameters->subsampling_dx = 1;\n    parameters->subsampling_dy = 1;\n\n    /* 9-7 transform */\n    parameters->irreversible = 1;\n\n    /* Number of layers */\n    if (parameters->tcp_numlayers > 1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"1 single quality layer\"\n                      \"-> Number of layers forced to 1 (rather than %d)\\n\"\n                      \"-> Rate of the last layer (%3.1f) will be used\",\n                      parameters->tcp_numlayers,\n                      parameters->tcp_rates[parameters->tcp_numlayers - 1]);\n        parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];\n        parameters->tcp_numlayers = 1;\n    }\n\n    /* Resolution levels */\n    switch (parameters->rsiz) {\n    case OPJ_PROFILE_CINEMA_2K:\n        if (parameters->numresolution > 6) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                          \"Number of decomposition levels <= 5\\n\"\n                          \"-> Number of decomposition levels forced to 5 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 6;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if (parameters->numresolution < 2) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 1 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 1;\n        } else if (parameters->numresolution > 7) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"Number of decomposition levels >= 1 && <= 6\\n\"\n                          \"-> Number of decomposition levels forced to 6 (rather than %d)\\n\",\n                          parameters->numresolution + 1);\n            parameters->numresolution = 7;\n        }\n        break;\n    default :\n        break;\n    }\n\n    /* Precincts */\n    parameters->csty |= 0x01;\n    if (parameters->numresolution == 1) {\n        parameters->res_spec = 1;\n        parameters->prcw_init[0] = 128;\n        parameters->prch_init[0] = 128;\n    } else {\n        parameters->res_spec = parameters->numresolution - 1;\n        for (i = 0; i < parameters->res_spec; i++) {\n            parameters->prcw_init[i] = 256;\n            parameters->prch_init[i] = 256;\n        }\n    }\n\n    /* The progression order shall be CPRL */\n    parameters->prog_order = OPJ_CPRL;\n\n    /* Progression order changes for 4K, disallowed for 2K */\n    if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {\n        parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,\n                              parameters->numresolution);\n    } else {\n        parameters->numpocs = 0;\n    }\n\n    /* Limited bit-rate */\n    parameters->cp_disto_alloc = 1;\n    if (parameters->max_cs_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\\n\");\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n    }\n\n    if (parameters->max_comp_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\\n\");\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n    }\n\n    parameters->tcp_rates[0] = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *\n                               image->comps[0].h * image->comps[0].prec) /\n                               (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *\n                                       image->comps[0].dy);\n\n}\n\nstatic OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image, OPJ_UINT16 rsiz,\n        opj_event_mgr_t *p_manager)\n{\n    OPJ_UINT32 i;\n\n    /* Number of components */\n    if (image->numcomps != 3) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                      \"3 components\"\n                      \"-> Number of components of input image (%d) is not compliant\\n\"\n                      \"-> Non-profile-3 codestream will be generated\\n\",\n                      image->numcomps);\n        return OPJ_FALSE;\n    }\n\n    /* Bitdepth */\n    for (i = 0; i < image->numcomps; i++) {\n        if ((image->comps[i].bpp != 12) | (image->comps[i].sgnd)) {\n            char signed_str[] = \"signed\";\n            char unsigned_str[] = \"unsigned\";\n            char *tmp_str = image->comps[i].sgnd ? signed_str : unsigned_str;\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                          \"Precision of each component shall be 12 bits unsigned\"\n                          \"-> At least component %d of input image (%d bits, %s) is not compliant\\n\"\n                          \"-> Non-profile-3 codestream will be generated\\n\",\n                          i, image->comps[i].bpp, tmp_str);\n            return OPJ_FALSE;\n        }\n    }\n\n    /* Image size */\n    switch (rsiz) {\n    case OPJ_PROFILE_CINEMA_2K:\n        if (((image->comps[0].w > 2048) | (image->comps[0].h > 1080))) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                          \"width <= 2048 and height <= 1080\\n\"\n                          \"-> Input image size %d x %d is not compliant\\n\"\n                          \"-> Non-profile-3 codestream will be generated\\n\",\n                          image->comps[0].w, image->comps[0].h);\n            return OPJ_FALSE;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if (((image->comps[0].w > 4096) | (image->comps[0].h > 2160))) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                          \"width <= 4096 and height <= 2160\\n\"\n                          \"-> Image size %d x %d is not compliant\\n\"\n                          \"-> Non-profile-4 codestream will be generated\\n\",\n                          image->comps[0].w, image->comps[0].h);\n            return OPJ_FALSE;\n        }\n        break;\n    default :\n        break;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k,\n                               opj_cparameters_t *parameters,\n                               opj_image_t *image,\n                               opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i, j, tileno, numpocs_tile;\n    opj_cp_t *cp = 00;\n\n    if (!p_j2k || !parameters || ! image) {\n        return OPJ_FALSE;\n    }\n\n    if ((parameters->numresolution <= 0) ||\n            (parameters->numresolution > OPJ_J2K_MAXRLVLS)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Invalid number of resolutions : %d not in range [1,%d]\\n\",\n                      parameters->numresolution, OPJ_J2K_MAXRLVLS);\n        return OPJ_FALSE;\n    }\n\n    /* keep a link to cp so that we can destroy it later in j2k_destroy_compress */\n    cp = &(p_j2k->m_cp);\n\n    /* set default values for cp */\n    cp->tw = 1;\n    cp->th = 1;\n\n    /* FIXME ADE: to be removed once deprecated cp_cinema and cp_rsiz have been removed */\n    if (parameters->rsiz ==\n            OPJ_PROFILE_NONE) { /* consider deprecated fields only if RSIZ has not been set */\n        OPJ_BOOL deprecated_used = OPJ_FALSE;\n        switch (parameters->cp_cinema) {\n        case OPJ_CINEMA2K_24:\n            parameters->rsiz = OPJ_PROFILE_CINEMA_2K;\n            parameters->max_cs_size = OPJ_CINEMA_24_CS;\n            parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n            deprecated_used = OPJ_TRUE;\n            break;\n        case OPJ_CINEMA2K_48:\n            parameters->rsiz = OPJ_PROFILE_CINEMA_2K;\n            parameters->max_cs_size = OPJ_CINEMA_48_CS;\n            parameters->max_comp_size = OPJ_CINEMA_48_COMP;\n            deprecated_used = OPJ_TRUE;\n            break;\n        case OPJ_CINEMA4K_24:\n            parameters->rsiz = OPJ_PROFILE_CINEMA_4K;\n            parameters->max_cs_size = OPJ_CINEMA_24_CS;\n            parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n            deprecated_used = OPJ_TRUE;\n            break;\n        case OPJ_OFF:\n        default:\n            break;\n        }\n        switch (parameters->cp_rsiz) {\n        case OPJ_CINEMA2K:\n            parameters->rsiz = OPJ_PROFILE_CINEMA_2K;\n            deprecated_used = OPJ_TRUE;\n            break;\n        case OPJ_CINEMA4K:\n            parameters->rsiz = OPJ_PROFILE_CINEMA_4K;\n            deprecated_used = OPJ_TRUE;\n            break;\n        case OPJ_MCT:\n            parameters->rsiz = OPJ_PROFILE_PART2 | OPJ_EXTENSION_MCT;\n            deprecated_used = OPJ_TRUE;\n        case OPJ_STD_RSIZ:\n        default:\n            break;\n        }\n        if (deprecated_used) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"Deprecated fields cp_cinema or cp_rsiz are used\\n\"\n                          \"Please consider using only the rsiz field\\n\"\n                          \"See openjpeg.h documentation for more details\\n\");\n        }\n    }\n\n    /* If no explicit layers are provided, use lossless settings */\n    if (parameters->tcp_numlayers == 0) {\n        parameters->tcp_numlayers = 1;\n        parameters->cp_disto_alloc = 1;\n        parameters->tcp_rates[0] = 0;\n    }\n\n    /* see if max_codestream_size does limit input rate */\n    if (parameters->max_cs_size <= 0) {\n        if (parameters->tcp_rates[parameters->tcp_numlayers - 1] > 0) {\n            OPJ_FLOAT32 temp_size;\n            temp_size = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *\n                                      image->comps[0].h * image->comps[0].prec) /\n                        (parameters->tcp_rates[parameters->tcp_numlayers - 1] * 8 *\n                         (OPJ_FLOAT32)image->comps[0].dx * (OPJ_FLOAT32)image->comps[0].dy);\n            parameters->max_cs_size = (int) floor(temp_size);\n        } else {\n            parameters->max_cs_size = 0;\n        }\n    } else {\n        OPJ_FLOAT32 temp_rate;\n        OPJ_BOOL cap = OPJ_FALSE;\n        temp_rate = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *\n                                  image->comps[0].h * image->comps[0].prec) /\n                    (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *\n                                  image->comps[0].dy);\n        for (i = 0; i < (OPJ_UINT32) parameters->tcp_numlayers; i++) {\n            if (parameters->tcp_rates[i] < temp_rate) {\n                parameters->tcp_rates[i] = temp_rate;\n                cap = OPJ_TRUE;\n            }\n        }\n        if (cap) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"The desired maximum codestream size has limited\\n\"\n                          \"at least one of the desired quality layers\\n\");\n        }\n    }\n\n    /* Manage profiles and applications and set RSIZ */\n    /* set cinema parameters if required */\n    if (OPJ_IS_CINEMA(parameters->rsiz)) {\n        if ((parameters->rsiz == OPJ_PROFILE_CINEMA_S2K)\n                || (parameters->rsiz == OPJ_PROFILE_CINEMA_S4K)) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Scalable Digital Cinema profiles not yet supported\\n\");\n            parameters->rsiz = OPJ_PROFILE_NONE;\n        } else {\n            opj_j2k_set_cinema_parameters(parameters, image, p_manager);\n            if (!opj_j2k_is_cinema_compliant(image, parameters->rsiz, p_manager)) {\n                parameters->rsiz = OPJ_PROFILE_NONE;\n            }\n        }\n    } else if (OPJ_IS_STORAGE(parameters->rsiz)) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Long Term Storage profile not yet supported\\n\");\n        parameters->rsiz = OPJ_PROFILE_NONE;\n    } else if (OPJ_IS_BROADCAST(parameters->rsiz)) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Broadcast profiles not yet supported\\n\");\n        parameters->rsiz = OPJ_PROFILE_NONE;\n    } else if (OPJ_IS_IMF(parameters->rsiz)) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 IMF profiles not yet supported\\n\");\n        parameters->rsiz = OPJ_PROFILE_NONE;\n    } else if (OPJ_IS_PART2(parameters->rsiz)) {\n        if (parameters->rsiz == ((OPJ_PROFILE_PART2) | (OPJ_EXTENSION_NONE))) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"JPEG 2000 Part-2 profile defined\\n\"\n                          \"but no Part-2 extension enabled.\\n\"\n                          \"Profile set to NONE.\\n\");\n            parameters->rsiz = OPJ_PROFILE_NONE;\n        } else if (parameters->rsiz != ((OPJ_PROFILE_PART2) | (OPJ_EXTENSION_MCT))) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"Unsupported Part-2 extension enabled\\n\"\n                          \"Profile set to NONE.\\n\");\n            parameters->rsiz = OPJ_PROFILE_NONE;\n        }\n    }\n\n    /*\n    copy user encoding parameters\n    */\n    cp->m_specific_param.m_enc.m_max_comp_size = (OPJ_UINT32)\n            parameters->max_comp_size;\n    cp->rsiz = parameters->rsiz;\n    cp->m_specific_param.m_enc.m_disto_alloc = (OPJ_UINT32)\n            parameters->cp_disto_alloc & 1u;\n    cp->m_specific_param.m_enc.m_fixed_alloc = (OPJ_UINT32)\n            parameters->cp_fixed_alloc & 1u;\n    cp->m_specific_param.m_enc.m_fixed_quality = (OPJ_UINT32)\n            parameters->cp_fixed_quality & 1u;\n\n    /* mod fixed_quality */\n    if (parameters->cp_fixed_alloc && parameters->cp_matrice) {\n        size_t array_size = (size_t)parameters->tcp_numlayers *\n                            (size_t)parameters->numresolution * 3 * sizeof(OPJ_INT32);\n        cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *) opj_malloc(array_size);\n        if (!cp->m_specific_param.m_enc.m_matrice) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to allocate copy of user encoding parameters matrix \\n\");\n            return OPJ_FALSE;\n        }\n        memcpy(cp->m_specific_param.m_enc.m_matrice, parameters->cp_matrice,\n               array_size);\n    }\n\n    /* tiles */\n    cp->tdx = (OPJ_UINT32)parameters->cp_tdx;\n    cp->tdy = (OPJ_UINT32)parameters->cp_tdy;\n\n    /* tile offset */\n    cp->tx0 = (OPJ_UINT32)parameters->cp_tx0;\n    cp->ty0 = (OPJ_UINT32)parameters->cp_ty0;\n\n    /* comment string */\n    if (parameters->cp_comment) {\n        cp->comment = (char*)opj_malloc(strlen(parameters->cp_comment) + 1U);\n        if (!cp->comment) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to allocate copy of comment string\\n\");\n            return OPJ_FALSE;\n        }\n        strcpy(cp->comment, parameters->cp_comment);\n    } else {\n        /* Create default comment for codestream */\n        const char comment[] = \"Created by OpenJPEG version \";\n        const size_t clen = strlen(comment);\n        const char *version = opj_version();\n\n        /* UniPG>> */\n#ifdef USE_JPWL\n        cp->comment = (char*)opj_malloc(clen + strlen(version) + 11);\n        if (!cp->comment) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to allocate comment string\\n\");\n            return OPJ_FALSE;\n        }\n        sprintf(cp->comment, \"%s%s with JPWL\", comment, version);\n#else\n        cp->comment = (char*)opj_malloc(clen + strlen(version) + 1);\n        if (!cp->comment) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to allocate comment string\\n\");\n            return OPJ_FALSE;\n        }\n        sprintf(cp->comment, \"%s%s\", comment, version);\n#endif\n        /* <<UniPG */\n    }\n\n    /*\n    calculate other encoding parameters\n    */\n\n    if (parameters->tile_size_on) {\n        cp->tw = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(image->x1 - cp->tx0),\n                                             (OPJ_INT32)cp->tdx);\n        cp->th = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(image->y1 - cp->ty0),\n                                             (OPJ_INT32)cp->tdy);\n    } else {\n        cp->tdx = image->x1 - cp->tx0;\n        cp->tdy = image->y1 - cp->ty0;\n    }\n\n    if (parameters->tp_on) {\n        cp->m_specific_param.m_enc.m_tp_flag = (OPJ_BYTE)parameters->tp_flag;\n        cp->m_specific_param.m_enc.m_tp_on = 1;\n    }\n\n#ifdef USE_JPWL\n    /*\n    calculate JPWL encoding parameters\n    */\n\n    if (parameters->jpwl_epc_on) {\n        OPJ_INT32 i;\n\n        /* set JPWL on */\n        cp->epc_on = OPJ_TRUE;\n        cp->info_on = OPJ_FALSE; /* no informative technique */\n\n        /* set EPB on */\n        if ((parameters->jpwl_hprot_MH > 0) || (parameters->jpwl_hprot_TPH[0] > 0)) {\n            cp->epb_on = OPJ_TRUE;\n\n            cp->hprot_MH = parameters->jpwl_hprot_MH;\n            for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {\n                cp->hprot_TPH_tileno[i] = parameters->jpwl_hprot_TPH_tileno[i];\n                cp->hprot_TPH[i] = parameters->jpwl_hprot_TPH[i];\n            }\n            /* if tile specs are not specified, copy MH specs */\n            if (cp->hprot_TPH[0] == -1) {\n                cp->hprot_TPH_tileno[0] = 0;\n                cp->hprot_TPH[0] = parameters->jpwl_hprot_MH;\n            }\n            for (i = 0; i < JPWL_MAX_NO_PACKSPECS; i++) {\n                cp->pprot_tileno[i] = parameters->jpwl_pprot_tileno[i];\n                cp->pprot_packno[i] = parameters->jpwl_pprot_packno[i];\n                cp->pprot[i] = parameters->jpwl_pprot[i];\n            }\n        }\n\n        /* set ESD writing */\n        if ((parameters->jpwl_sens_size == 1) || (parameters->jpwl_sens_size == 2)) {\n            cp->esd_on = OPJ_TRUE;\n\n            cp->sens_size = parameters->jpwl_sens_size;\n            cp->sens_addr = parameters->jpwl_sens_addr;\n            cp->sens_range = parameters->jpwl_sens_range;\n\n            cp->sens_MH = parameters->jpwl_sens_MH;\n            for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {\n                cp->sens_TPH_tileno[i] = parameters->jpwl_sens_TPH_tileno[i];\n                cp->sens_TPH[i] = parameters->jpwl_sens_TPH[i];\n            }\n        }\n\n        /* always set RED writing to false: we are at the encoder */\n        cp->red_on = OPJ_FALSE;\n\n    } else {\n        cp->epc_on = OPJ_FALSE;\n    }\n#endif /* USE_JPWL */\n\n    /* initialize the mutiple tiles */\n    /* ---------------------------- */\n    cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));\n    if (!cp->tcps) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough memory to allocate tile coding parameters\\n\");\n        return OPJ_FALSE;\n    }\n    if (parameters->numpocs) {\n        /* initialisation of POC */\n        opj_j2k_check_poc_val(parameters->POC, parameters->numpocs,\n                              (OPJ_UINT32)parameters->numresolution, image->numcomps,\n                              (OPJ_UINT32)parameters->tcp_numlayers, p_manager);\n        /* TODO MSD use the return value*/\n    }\n\n    for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {\n        opj_tcp_t *tcp = &cp->tcps[tileno];\n        tcp->numlayers = (OPJ_UINT32)parameters->tcp_numlayers;\n\n        for (j = 0; j < tcp->numlayers; j++) {\n            if (OPJ_IS_CINEMA(cp->rsiz)) {\n                if (cp->m_specific_param.m_enc.m_fixed_quality) {\n                    tcp->distoratio[j] = parameters->tcp_distoratio[j];\n                }\n                tcp->rates[j] = parameters->tcp_rates[j];\n            } else {\n                if (cp->m_specific_param.m_enc.m_fixed_quality) {       /* add fixed_quality */\n                    tcp->distoratio[j] = parameters->tcp_distoratio[j];\n                } else {\n                    tcp->rates[j] = parameters->tcp_rates[j];\n                }\n            }\n        }\n\n        tcp->csty = (OPJ_UINT32)parameters->csty;\n        tcp->prg = parameters->prog_order;\n        tcp->mct = (OPJ_UINT32)parameters->tcp_mct;\n\n        numpocs_tile = 0;\n        tcp->POC = 0;\n\n        if (parameters->numpocs) {\n            /* initialisation of POC */\n            tcp->POC = 1;\n            for (i = 0; i < parameters->numpocs; i++) {\n                if (tileno + 1 == parameters->POC[i].tile)  {\n                    opj_poc_t *tcp_poc = &tcp->pocs[numpocs_tile];\n\n                    tcp_poc->resno0         = parameters->POC[numpocs_tile].resno0;\n                    tcp_poc->compno0        = parameters->POC[numpocs_tile].compno0;\n                    tcp_poc->layno1         = parameters->POC[numpocs_tile].layno1;\n                    tcp_poc->resno1         = parameters->POC[numpocs_tile].resno1;\n                    tcp_poc->compno1        = parameters->POC[numpocs_tile].compno1;\n                    tcp_poc->prg1           = parameters->POC[numpocs_tile].prg1;\n                    tcp_poc->tile           = parameters->POC[numpocs_tile].tile;\n\n                    numpocs_tile++;\n                }\n            }\n\n            tcp->numpocs = numpocs_tile - 1 ;\n        } else {\n            tcp->numpocs = 0;\n        }\n\n        tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));\n        if (!tcp->tccps) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Not enough memory to allocate tile component coding parameters\\n\");\n            return OPJ_FALSE;\n        }\n        if (parameters->mct_data) {\n\n            OPJ_UINT32 lMctSize = image->numcomps * image->numcomps * (OPJ_UINT32)sizeof(\n                                      OPJ_FLOAT32);\n            OPJ_FLOAT32 * lTmpBuf = (OPJ_FLOAT32*)opj_malloc(lMctSize);\n            OPJ_INT32 * l_dc_shift = (OPJ_INT32 *)((OPJ_BYTE *) parameters->mct_data +\n                                                   lMctSize);\n\n            if (!lTmpBuf) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Not enough memory to allocate temp buffer\\n\");\n                return OPJ_FALSE;\n            }\n\n            tcp->mct = 2;\n            tcp->m_mct_coding_matrix = (OPJ_FLOAT32*)opj_malloc(lMctSize);\n            if (! tcp->m_mct_coding_matrix) {\n                opj_free(lTmpBuf);\n                lTmpBuf = NULL;\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Not enough memory to allocate encoder MCT coding matrix \\n\");\n                return OPJ_FALSE;\n            }\n            memcpy(tcp->m_mct_coding_matrix, parameters->mct_data, lMctSize);\n            memcpy(lTmpBuf, parameters->mct_data, lMctSize);\n\n            tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(lMctSize);\n            if (! tcp->m_mct_decoding_matrix) {\n                opj_free(lTmpBuf);\n                lTmpBuf = NULL;\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Not enough memory to allocate encoder MCT decoding matrix \\n\");\n                return OPJ_FALSE;\n            }\n            if (opj_matrix_inversion_f(lTmpBuf, (tcp->m_mct_decoding_matrix),\n                                       image->numcomps) == OPJ_FALSE) {\n                opj_free(lTmpBuf);\n                lTmpBuf = NULL;\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Failed to inverse encoder MCT decoding matrix \\n\");\n                return OPJ_FALSE;\n            }\n\n            tcp->mct_norms = (OPJ_FLOAT64*)\n                             opj_malloc(image->numcomps * sizeof(OPJ_FLOAT64));\n            if (! tcp->mct_norms) {\n                opj_free(lTmpBuf);\n                lTmpBuf = NULL;\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Not enough memory to allocate encoder MCT norms \\n\");\n                return OPJ_FALSE;\n            }\n            opj_calculate_norms(tcp->mct_norms, image->numcomps,\n                                tcp->m_mct_decoding_matrix);\n            opj_free(lTmpBuf);\n\n            for (i = 0; i < image->numcomps; i++) {\n                opj_tccp_t *tccp = &tcp->tccps[i];\n                tccp->m_dc_level_shift = l_dc_shift[i];\n            }\n\n            if (opj_j2k_setup_mct_encoding(tcp, image) == OPJ_FALSE) {\n                /* free will be handled by opj_j2k_destroy */\n                opj_event_msg(p_manager, EVT_ERROR, \"Failed to setup j2k mct encoding\\n\");\n                return OPJ_FALSE;\n            }\n        } else {\n            if (tcp->mct == 1 && image->numcomps >= 3) { /* RGB->YCC MCT is enabled */\n                if ((image->comps[0].dx != image->comps[1].dx) ||\n                        (image->comps[0].dx != image->comps[2].dx) ||\n                        (image->comps[0].dy != image->comps[1].dy) ||\n                        (image->comps[0].dy != image->comps[2].dy)) {\n                    opj_event_msg(p_manager, EVT_WARNING,\n                                  \"Cannot perform MCT on components with different sizes. Disabling MCT.\\n\");\n                    tcp->mct = 0;\n                }\n            }\n            for (i = 0; i < image->numcomps; i++) {\n                opj_tccp_t *tccp = &tcp->tccps[i];\n                opj_image_comp_t * l_comp = &(image->comps[i]);\n\n                if (! l_comp->sgnd) {\n                    tccp->m_dc_level_shift = 1 << (l_comp->prec - 1);\n                }\n            }\n        }\n\n        for (i = 0; i < image->numcomps; i++) {\n            opj_tccp_t *tccp = &tcp->tccps[i];\n\n            tccp->csty = parameters->csty &\n                         0x01;   /* 0 => one precinct || 1 => custom precinct  */\n            tccp->numresolutions = (OPJ_UINT32)parameters->numresolution;\n            tccp->cblkw = (OPJ_UINT32)opj_int_floorlog2(parameters->cblockw_init);\n            tccp->cblkh = (OPJ_UINT32)opj_int_floorlog2(parameters->cblockh_init);\n            tccp->cblksty = (OPJ_UINT32)parameters->mode;\n            tccp->qmfbid = parameters->irreversible ? 0 : 1;\n            tccp->qntsty = parameters->irreversible ? J2K_CCP_QNTSTY_SEQNT :\n                           J2K_CCP_QNTSTY_NOQNT;\n            tccp->numgbits = 2;\n\n            if ((OPJ_INT32)i == parameters->roi_compno) {\n                tccp->roishift = parameters->roi_shift;\n            } else {\n                tccp->roishift = 0;\n            }\n\n            if (parameters->csty & J2K_CCP_CSTY_PRT) {\n                OPJ_INT32 p = 0, it_res;\n                assert(tccp->numresolutions > 0);\n                for (it_res = (OPJ_INT32)tccp->numresolutions - 1; it_res >= 0; it_res--) {\n                    if (p < parameters->res_spec) {\n\n                        if (parameters->prcw_init[p] < 1) {\n                            tccp->prcw[it_res] = 1;\n                        } else {\n                            tccp->prcw[it_res] = (OPJ_UINT32)opj_int_floorlog2(parameters->prcw_init[p]);\n                        }\n\n                        if (parameters->prch_init[p] < 1) {\n                            tccp->prch[it_res] = 1;\n                        } else {\n                            tccp->prch[it_res] = (OPJ_UINT32)opj_int_floorlog2(parameters->prch_init[p]);\n                        }\n\n                    } else {\n                        OPJ_INT32 res_spec = parameters->res_spec;\n                        OPJ_INT32 size_prcw = 0;\n                        OPJ_INT32 size_prch = 0;\n\n                        assert(res_spec > 0); /* issue 189 */\n                        size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));\n                        size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));\n\n\n                        if (size_prcw < 1) {\n                            tccp->prcw[it_res] = 1;\n                        } else {\n                            tccp->prcw[it_res] = (OPJ_UINT32)opj_int_floorlog2(size_prcw);\n                        }\n\n                        if (size_prch < 1) {\n                            tccp->prch[it_res] = 1;\n                        } else {\n                            tccp->prch[it_res] = (OPJ_UINT32)opj_int_floorlog2(size_prch);\n                        }\n                    }\n                    p++;\n                    /*printf(\"\\nsize precinct for level %d : %d,%d\\n\", it_res,tccp->prcw[it_res], tccp->prch[it_res]); */\n                }       /*end for*/\n            } else {\n                for (j = 0; j < tccp->numresolutions; j++) {\n                    tccp->prcw[j] = 15;\n                    tccp->prch[j] = 15;\n                }\n            }\n\n            opj_dwt_calc_explicit_stepsizes(tccp, image->comps[i].prec);\n        }\n    }\n\n    if (parameters->mct_data) {\n        opj_free(parameters->mct_data);\n        parameters->mct_data = 00;\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index,\n                                     OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len)\n{\n    assert(cstr_index != 00);\n\n    /* expand the list? */\n    if ((cstr_index->marknum + 1) > cstr_index->maxmarknum) {\n        opj_marker_info_t *new_marker;\n        cstr_index->maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32)\n                                              cstr_index->maxmarknum);\n        new_marker = (opj_marker_info_t *) opj_realloc(cstr_index->marker,\n                     cstr_index->maxmarknum * sizeof(opj_marker_info_t));\n        if (! new_marker) {\n            opj_free(cstr_index->marker);\n            cstr_index->marker = NULL;\n            cstr_index->maxmarknum = 0;\n            cstr_index->marknum = 0;\n            /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\"); */\n            return OPJ_FALSE;\n        }\n        cstr_index->marker = new_marker;\n    }\n\n    /* add the marker */\n    cstr_index->marker[cstr_index->marknum].type = (OPJ_UINT16)type;\n    cstr_index->marker[cstr_index->marknum].pos = (OPJ_INT32)pos;\n    cstr_index->marker[cstr_index->marknum].len = (OPJ_INT32)len;\n    cstr_index->marknum++;\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno,\n                                     opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos,\n                                     OPJ_UINT32 len)\n{\n    assert(cstr_index != 00);\n    assert(cstr_index->tile_index != 00);\n\n    /* expand the list? */\n    if ((cstr_index->tile_index[tileno].marknum + 1) >\n            cstr_index->tile_index[tileno].maxmarknum) {\n        opj_marker_info_t *new_marker;\n        cstr_index->tile_index[tileno].maxmarknum = (OPJ_UINT32)(100 +\n                (OPJ_FLOAT32) cstr_index->tile_index[tileno].maxmarknum);\n        new_marker = (opj_marker_info_t *) opj_realloc(\n                         cstr_index->tile_index[tileno].marker,\n                         cstr_index->tile_index[tileno].maxmarknum * sizeof(opj_marker_info_t));\n        if (! new_marker) {\n            opj_free(cstr_index->tile_index[tileno].marker);\n            cstr_index->tile_index[tileno].marker = NULL;\n            cstr_index->tile_index[tileno].maxmarknum = 0;\n            cstr_index->tile_index[tileno].marknum = 0;\n            /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add tl marker\\n\"); */\n            return OPJ_FALSE;\n        }\n        cstr_index->tile_index[tileno].marker = new_marker;\n    }\n\n    /* add the marker */\n    cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].type\n        = (OPJ_UINT16)type;\n    cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].pos\n        = (OPJ_INT32)pos;\n    cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].len\n        = (OPJ_INT32)len;\n    cstr_index->tile_index[tileno].marknum++;\n\n    if (type == J2K_MS_SOT) {\n        OPJ_UINT32 l_current_tile_part = cstr_index->tile_index[tileno].current_tpsno;\n\n        if (cstr_index->tile_index[tileno].tp_index) {\n            cstr_index->tile_index[tileno].tp_index[l_current_tile_part].start_pos = pos;\n        }\n\n    }\n    return OPJ_TRUE;\n}\n\n/*\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n */\n\nOPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k,\n                                opj_stream_private_t *p_stream,\n                                opj_event_mgr_t * p_manager\n                               )\n{\n    (void)p_j2k;\n    (void)p_stream;\n    (void)p_manager;\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream,\n                             opj_j2k_t* p_j2k,\n                             opj_image_t** p_image,\n                             opj_event_mgr_t* p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    /* create an empty image header */\n    p_j2k->m_private_image = opj_image_create0();\n    if (! p_j2k->m_private_image) {\n        return OPJ_FALSE;\n    }\n\n    /* customization of the validation */\n    if (! opj_j2k_setup_decoding_validation(p_j2k, p_manager)) {\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n        return OPJ_FALSE;\n    }\n\n    /* validation of the parameters codec */\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager)) {\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n        return OPJ_FALSE;\n    }\n\n    /* customization of the encoding */\n    if (! opj_j2k_setup_header_reading(p_j2k, p_manager)) {\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n        return OPJ_FALSE;\n    }\n\n    /* read header */\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n        return OPJ_FALSE;\n    }\n\n    *p_image = opj_image_create0();\n    if (!(*p_image)) {\n        return OPJ_FALSE;\n    }\n\n    /* Copy codestream image information to the output image */\n    opj_copy_image_header(p_j2k->m_private_image, *p_image);\n\n    /*Allocate and initialize some elements of codestrem index*/\n    if (!opj_j2k_allocate_tile_element_cstr_index(p_j2k)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_header_reading(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager)\n{\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_read_header_procedure, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* DEVELOPER CORNER, add your custom procedures */\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_copy_default_tcp_and_create_tcd, p_manager))  {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager)\n{\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,\n                                           (opj_procedure)opj_j2k_build_decoder, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,\n                                           (opj_procedure)opj_j2k_decoding_validation, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* DEVELOPER CORNER, add your custom validation procedure */\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t * p_j2k,\n                                       opj_stream_private_t *p_stream,\n                                       opj_event_mgr_t * p_manager)\n{\n    OPJ_BOOL l_is_valid = OPJ_TRUE;\n    OPJ_UINT32 i, j;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n\n    if ((p_j2k->m_cp.rsiz & 0x8200) == 0x8200) {\n        OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n        opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;\n\n        for (i = 0; i < l_nb_tiles; ++i) {\n            if (l_tcp->mct == 2) {\n                opj_tccp_t * l_tccp = l_tcp->tccps;\n                l_is_valid &= (l_tcp->m_mct_coding_matrix != 00);\n\n                for (j = 0; j < p_j2k->m_private_image->numcomps; ++j) {\n                    l_is_valid &= !(l_tccp->qmfbid & 1);\n                    ++l_tccp;\n                }\n            }\n            ++l_tcp;\n        }\n    }\n\n    return l_is_valid;\n}\n\nOPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t * p_tcp, opj_image_t * p_image)\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_indix = 1;\n    opj_mct_data_t * l_mct_deco_data = 00, * l_mct_offset_data = 00;\n    opj_simple_mcc_decorrelation_data_t * l_mcc_data;\n    OPJ_UINT32 l_mct_size, l_nb_elem;\n    OPJ_FLOAT32 * l_data, * l_current_data;\n    opj_tccp_t * l_tccp;\n\n    /* preconditions */\n    assert(p_tcp != 00);\n\n    if (p_tcp->mct != 2) {\n        return OPJ_TRUE;\n    }\n\n    if (p_tcp->m_mct_decoding_matrix) {\n        if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {\n            opj_mct_data_t *new_mct_records;\n            p_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n\n            new_mct_records = (opj_mct_data_t *) opj_realloc(p_tcp->m_mct_records,\n                              p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));\n            if (! new_mct_records) {\n                opj_free(p_tcp->m_mct_records);\n                p_tcp->m_mct_records = NULL;\n                p_tcp->m_nb_max_mct_records = 0;\n                p_tcp->m_nb_mct_records = 0;\n                /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to setup mct encoding\\n\"); */\n                return OPJ_FALSE;\n            }\n            p_tcp->m_mct_records = new_mct_records;\n            l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n            memset(l_mct_deco_data, 0,\n                   (p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(\n                       opj_mct_data_t));\n        }\n        l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n        if (l_mct_deco_data->m_data) {\n            opj_free(l_mct_deco_data->m_data);\n            l_mct_deco_data->m_data = 00;\n        }\n\n        l_mct_deco_data->m_index = l_indix++;\n        l_mct_deco_data->m_array_type = MCT_TYPE_DECORRELATION;\n        l_mct_deco_data->m_element_type = MCT_TYPE_FLOAT;\n        l_nb_elem = p_image->numcomps * p_image->numcomps;\n        l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_deco_data->m_element_type];\n        l_mct_deco_data->m_data = (OPJ_BYTE*)opj_malloc(l_mct_size);\n\n        if (! l_mct_deco_data->m_data) {\n            return OPJ_FALSE;\n        }\n\n        j2k_mct_write_functions_from_float[l_mct_deco_data->m_element_type](\n            p_tcp->m_mct_decoding_matrix, l_mct_deco_data->m_data, l_nb_elem);\n\n        l_mct_deco_data->m_data_size = l_mct_size;\n        ++p_tcp->m_nb_mct_records;\n    }\n\n    if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {\n        opj_mct_data_t *new_mct_records;\n        p_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n        new_mct_records = (opj_mct_data_t *) opj_realloc(p_tcp->m_mct_records,\n                          p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));\n        if (! new_mct_records) {\n            opj_free(p_tcp->m_mct_records);\n            p_tcp->m_mct_records = NULL;\n            p_tcp->m_nb_max_mct_records = 0;\n            p_tcp->m_nb_mct_records = 0;\n            /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to setup mct encoding\\n\"); */\n            return OPJ_FALSE;\n        }\n        p_tcp->m_mct_records = new_mct_records;\n        l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n        memset(l_mct_offset_data, 0,\n               (p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(\n                   opj_mct_data_t));\n\n        if (l_mct_deco_data) {\n            l_mct_deco_data = l_mct_offset_data - 1;\n        }\n    }\n\n    l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n    if (l_mct_offset_data->m_data) {\n        opj_free(l_mct_offset_data->m_data);\n        l_mct_offset_data->m_data = 00;\n    }\n\n    l_mct_offset_data->m_index = l_indix++;\n    l_mct_offset_data->m_array_type = MCT_TYPE_OFFSET;\n    l_mct_offset_data->m_element_type = MCT_TYPE_FLOAT;\n    l_nb_elem = p_image->numcomps;\n    l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_offset_data->m_element_type];\n    l_mct_offset_data->m_data = (OPJ_BYTE*)opj_malloc(l_mct_size);\n\n    if (! l_mct_offset_data->m_data) {\n        return OPJ_FALSE;\n    }\n\n    l_data = (OPJ_FLOAT32*)opj_malloc(l_nb_elem * sizeof(OPJ_FLOAT32));\n    if (! l_data) {\n        opj_free(l_mct_offset_data->m_data);\n        l_mct_offset_data->m_data = 00;\n        return OPJ_FALSE;\n    }\n\n    l_tccp = p_tcp->tccps;\n    l_current_data = l_data;\n\n    for (i = 0; i < l_nb_elem; ++i) {\n        *(l_current_data++) = (OPJ_FLOAT32)(l_tccp->m_dc_level_shift);\n        ++l_tccp;\n    }\n\n    j2k_mct_write_functions_from_float[l_mct_offset_data->m_element_type](l_data,\n            l_mct_offset_data->m_data, l_nb_elem);\n\n    opj_free(l_data);\n\n    l_mct_offset_data->m_data_size = l_mct_size;\n\n    ++p_tcp->m_nb_mct_records;\n\n    if (p_tcp->m_nb_mcc_records == p_tcp->m_nb_max_mcc_records) {\n        opj_simple_mcc_decorrelation_data_t *new_mcc_records;\n        p_tcp->m_nb_max_mcc_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n        new_mcc_records = (opj_simple_mcc_decorrelation_data_t *) opj_realloc(\n                              p_tcp->m_mcc_records, p_tcp->m_nb_max_mcc_records * sizeof(\n                                  opj_simple_mcc_decorrelation_data_t));\n        if (! new_mcc_records) {\n            opj_free(p_tcp->m_mcc_records);\n            p_tcp->m_mcc_records = NULL;\n            p_tcp->m_nb_max_mcc_records = 0;\n            p_tcp->m_nb_mcc_records = 0;\n            /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to setup mct encoding\\n\"); */\n            return OPJ_FALSE;\n        }\n        p_tcp->m_mcc_records = new_mcc_records;\n        l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;\n        memset(l_mcc_data, 0, (p_tcp->m_nb_max_mcc_records - p_tcp->m_nb_mcc_records) *\n               sizeof(opj_simple_mcc_decorrelation_data_t));\n\n    }\n\n    l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;\n    l_mcc_data->m_decorrelation_array = l_mct_deco_data;\n    l_mcc_data->m_is_irreversible = 1;\n    l_mcc_data->m_nb_comps = p_image->numcomps;\n    l_mcc_data->m_index = l_indix++;\n    l_mcc_data->m_offset_array = l_mct_offset_data;\n    ++p_tcp->m_nb_mcc_records;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t * p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager)\n{\n    /* add here initialization of cp\n       copy paste of setup_decoder */\n    (void)p_j2k;\n    (void)p_stream;\n    (void)p_manager;\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t * p_j2k,\n                                      opj_stream_private_t *p_stream,\n                                      opj_event_mgr_t * p_manager)\n{\n    /* add here initialization of cp\n       copy paste of setup_encoder */\n    (void)p_j2k;\n    (void)p_stream;\n    (void)p_manager;\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager)\n{\n    OPJ_BOOL l_is_valid = OPJ_TRUE;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_stream);\n\n    /* STATE checking */\n    /* make sure the state is at 0 */\n    l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NONE);\n\n    /* POINTER validation */\n    /* make sure a p_j2k codec is present */\n    l_is_valid &= (p_j2k->m_procedure_list != 00);\n    /* make sure a validation list is present */\n    l_is_valid &= (p_j2k->m_validation_list != 00);\n\n    /* ISO 15444-1:2004 states between 1 & 33 (0 -> 32) */\n    /* 33 (32) would always fail the check below (if a cast to 64bits was done) */\n    /* FIXME Shall we change OPJ_J2K_MAXRLVLS to 32 ? */\n    if ((p_j2k->m_cp.tcps->tccps->numresolutions <= 0) ||\n            (p_j2k->m_cp.tcps->tccps->numresolutions > 32)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n        return OPJ_FALSE;\n    }\n\n    if ((p_j2k->m_cp.tdx) < (OPJ_UINT32)(1 <<\n                                         (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n        return OPJ_FALSE;\n    }\n\n    if ((p_j2k->m_cp.tdy) < (OPJ_UINT32)(1 <<\n                                         (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* PARAMETER VALIDATION */\n    return l_is_valid;\n}\n\nstatic OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager\n                                           )\n{\n    OPJ_BOOL l_is_valid = OPJ_TRUE;\n\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n\n    /* STATE checking */\n    /* make sure the state is at 0 */\n#ifdef TODO_MSD\n    l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_DEC_STATE_NONE);\n#endif\n    l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == 0x0000);\n\n    /* POINTER validation */\n    /* make sure a p_j2k codec is present */\n    /* make sure a procedure list is present */\n    l_is_valid &= (p_j2k->m_procedure_list != 00);\n    /* make sure a validation list is present */\n    l_is_valid &= (p_j2k->m_validation_list != 00);\n\n    /* PARAMETER VALIDATION */\n    return l_is_valid;\n}\n\nstatic OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 l_current_marker;\n    OPJ_UINT32 l_marker_size;\n    const opj_dec_memory_marker_handler_t * l_marker_handler = 00;\n    OPJ_BOOL l_has_siz = 0;\n    OPJ_BOOL l_has_cod = 0;\n    OPJ_BOOL l_has_qcd = 0;\n\n    /* preconditions */\n    assert(p_stream != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    /*  We enter in the main header */\n    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MHSOC;\n\n    /* Try to read the SOC marker, the codestream must begin with SOC marker */\n    if (! opj_j2k_read_soc(p_j2k, p_stream, p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Expected a SOC marker \\n\");\n        return OPJ_FALSE;\n    }\n\n    /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n    if (opj_stream_read_data(p_stream,\n                             p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* Read 2 bytes as the new marker ID */\n    opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                   &l_current_marker, 2);\n\n    /* Try to read until the SOT is detected */\n    while (l_current_marker != J2K_MS_SOT) {\n\n        /* Check if the current marker ID is valid */\n        if (l_current_marker < 0xff00) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"A marker ID was expected (0xff--) instead of %.8x\\n\", l_current_marker);\n            return OPJ_FALSE;\n        }\n\n        /* Get the marker handler from the marker ID */\n        l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);\n\n        /* Manage case where marker is unknown */\n        if (l_marker_handler->id == J2K_MS_UNK) {\n            if (! opj_j2k_read_unk(p_j2k, p_stream, &l_current_marker, p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Unknow marker have been detected and generated error.\\n\");\n                return OPJ_FALSE;\n            }\n\n            if (l_current_marker == J2K_MS_SOT) {\n                break;    /* SOT marker is detected main header is completely read */\n            } else { /* Get the marker handler from the marker ID */\n                l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);\n            }\n        }\n\n        if (l_marker_handler->id == J2K_MS_SIZ) {\n            /* Mark required SIZ marker as found */\n            l_has_siz = 1;\n        }\n        if (l_marker_handler->id == J2K_MS_COD) {\n            /* Mark required COD marker as found */\n            l_has_cod = 1;\n        }\n        if (l_marker_handler->id == J2K_MS_QCD) {\n            /* Mark required QCD marker as found */\n            l_has_qcd = 1;\n        }\n\n        /* Check if the marker is known and if it is the right place to find it */\n        if (!(p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Marker is not compliant with its position\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */\n        if (opj_stream_read_data(p_stream,\n                                 p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* read 2 bytes as the marker size */\n        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data, &l_marker_size,\n                       2);\n        if (l_marker_size < 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Invalid marker size\\n\");\n            return OPJ_FALSE;\n        }\n        l_marker_size -= 2; /* Subtract the size of the marker ID already read */\n\n        /* Check if the marker size is compatible with the header data size */\n        if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {\n            OPJ_BYTE *new_header_data = (OPJ_BYTE *) opj_realloc(\n                                            p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size);\n            if (! new_header_data) {\n                opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);\n                p_j2k->m_specific_param.m_decoder.m_header_data = NULL;\n                p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read header\\n\");\n                return OPJ_FALSE;\n            }\n            p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;\n            p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;\n        }\n\n        /* Try to read the rest of the marker segment from stream and copy them into the buffer */\n        if (opj_stream_read_data(p_stream,\n                                 p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size,\n                                 p_manager) != l_marker_size) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* Read the marker segment with the correct marker handler */\n        if (!(*(l_marker_handler->handler))(p_j2k,\n                                            p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size, p_manager)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Marker handler function failed to read the marker segment\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* Add the marker to the codestream index*/\n        if (OPJ_FALSE == opj_j2k_add_mhmarker(\n                    p_j2k->cstr_index,\n                    l_marker_handler->id,\n                    (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4,\n                    l_marker_size + 4)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n        if (opj_stream_read_data(p_stream,\n                                 p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* read 2 bytes as the new marker ID */\n        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                       &l_current_marker, 2);\n    }\n\n    if (l_has_siz == 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"required SIZ marker not found in main header\\n\");\n        return OPJ_FALSE;\n    }\n    if (l_has_cod == 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"required COD marker not found in main header\\n\");\n        return OPJ_FALSE;\n    }\n    if (l_has_qcd == 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"required QCD marker not found in main header\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (! opj_j2k_merge_ppm(&(p_j2k->m_cp), p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Failed to merge PPM data\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_event_msg(p_manager, EVT_INFO, \"Main header has been correctly decoded.\\n\");\n\n    /* Position of the last element if the main header */\n    p_j2k->cstr_index->main_head_end = (OPJ_UINT32) opj_stream_tell(p_stream) - 2;\n\n    /* Next step: read a tile-part header */\n    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_exec(opj_j2k_t * p_j2k,\n                             opj_procedure_list_t * p_procedure_list,\n                             opj_stream_private_t *p_stream,\n                             opj_event_mgr_t * p_manager)\n{\n    OPJ_BOOL(** l_procedure)(opj_j2k_t *, opj_stream_private_t *,\n                             opj_event_mgr_t *) = 00;\n    OPJ_BOOL l_result = OPJ_TRUE;\n    OPJ_UINT32 l_nb_proc, i;\n\n    /* preconditions*/\n    assert(p_procedure_list != 00);\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);\n    l_procedure = (OPJ_BOOL(**)(opj_j2k_t *, opj_stream_private_t *,\n                                opj_event_mgr_t *)) opj_procedure_list_get_first_procedure(p_procedure_list);\n\n    for (i = 0; i < l_nb_proc; ++i) {\n        l_result = l_result && ((*l_procedure)(p_j2k, p_stream, p_manager));\n        ++l_procedure;\n    }\n\n    /* and clear the procedure list at the end.*/\n    opj_procedure_list_clear(p_procedure_list);\n    return l_result;\n}\n\n/* FIXME DOC*/\nstatic OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager\n                                                       )\n{\n    opj_tcp_t * l_tcp = 00;\n    opj_tcp_t * l_default_tcp = 00;\n    OPJ_UINT32 l_nb_tiles;\n    OPJ_UINT32 i, j;\n    opj_tccp_t *l_current_tccp = 00;\n    OPJ_UINT32 l_tccp_size;\n    OPJ_UINT32 l_mct_size;\n    opj_image_t * l_image;\n    OPJ_UINT32 l_mcc_records_size, l_mct_records_size;\n    opj_mct_data_t * l_src_mct_rec, *l_dest_mct_rec;\n    opj_simple_mcc_decorrelation_data_t * l_src_mcc_rec, *l_dest_mcc_rec;\n    OPJ_UINT32 l_offset;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_stream);\n\n    l_image = p_j2k->m_private_image;\n    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n    l_tcp = p_j2k->m_cp.tcps;\n    l_tccp_size = l_image->numcomps * (OPJ_UINT32)sizeof(opj_tccp_t);\n    l_default_tcp = p_j2k->m_specific_param.m_decoder.m_default_tcp;\n    l_mct_size = l_image->numcomps * l_image->numcomps * (OPJ_UINT32)sizeof(\n                     OPJ_FLOAT32);\n\n    /* For each tile */\n    for (i = 0; i < l_nb_tiles; ++i) {\n        /* keep the tile-compo coding parameters pointer of the current tile coding parameters*/\n        l_current_tccp = l_tcp->tccps;\n        /*Copy default coding parameters into the current tile coding parameters*/\n        memcpy(l_tcp, l_default_tcp, sizeof(opj_tcp_t));\n        /* Initialize some values of the current tile coding parameters*/\n        l_tcp->cod = 0;\n        l_tcp->ppt = 0;\n        l_tcp->ppt_data = 00;\n        l_tcp->m_current_tile_part_number = -1;\n        /* Remove memory not owned by this tile in case of early error return. */\n        l_tcp->m_mct_decoding_matrix = 00;\n        l_tcp->m_nb_max_mct_records = 0;\n        l_tcp->m_mct_records = 00;\n        l_tcp->m_nb_max_mcc_records = 0;\n        l_tcp->m_mcc_records = 00;\n        /* Reconnect the tile-compo coding parameters pointer to the current tile coding parameters*/\n        l_tcp->tccps = l_current_tccp;\n\n        /* Get the mct_decoding_matrix of the dflt_tile_cp and copy them into the current tile cp*/\n        if (l_default_tcp->m_mct_decoding_matrix) {\n            l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(l_mct_size);\n            if (! l_tcp->m_mct_decoding_matrix) {\n                return OPJ_FALSE;\n            }\n            memcpy(l_tcp->m_mct_decoding_matrix, l_default_tcp->m_mct_decoding_matrix,\n                   l_mct_size);\n        }\n\n        /* Get the mct_record of the dflt_tile_cp and copy them into the current tile cp*/\n        l_mct_records_size = l_default_tcp->m_nb_max_mct_records * (OPJ_UINT32)sizeof(\n                                 opj_mct_data_t);\n        l_tcp->m_mct_records = (opj_mct_data_t*)opj_malloc(l_mct_records_size);\n        if (! l_tcp->m_mct_records) {\n            return OPJ_FALSE;\n        }\n        memcpy(l_tcp->m_mct_records, l_default_tcp->m_mct_records, l_mct_records_size);\n\n        /* Copy the mct record data from dflt_tile_cp to the current tile*/\n        l_src_mct_rec = l_default_tcp->m_mct_records;\n        l_dest_mct_rec = l_tcp->m_mct_records;\n\n        for (j = 0; j < l_default_tcp->m_nb_mct_records; ++j) {\n\n            if (l_src_mct_rec->m_data) {\n\n                l_dest_mct_rec->m_data = (OPJ_BYTE*) opj_malloc(l_src_mct_rec->m_data_size);\n                if (! l_dest_mct_rec->m_data) {\n                    return OPJ_FALSE;\n                }\n                memcpy(l_dest_mct_rec->m_data, l_src_mct_rec->m_data,\n                       l_src_mct_rec->m_data_size);\n            }\n\n            ++l_src_mct_rec;\n            ++l_dest_mct_rec;\n            /* Update with each pass to free exactly what has been allocated on early return. */\n            l_tcp->m_nb_max_mct_records += 1;\n        }\n\n        /* Get the mcc_record of the dflt_tile_cp and copy them into the current tile cp*/\n        l_mcc_records_size = l_default_tcp->m_nb_max_mcc_records * (OPJ_UINT32)sizeof(\n                                 opj_simple_mcc_decorrelation_data_t);\n        l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t*) opj_malloc(\n                                   l_mcc_records_size);\n        if (! l_tcp->m_mcc_records) {\n            return OPJ_FALSE;\n        }\n        memcpy(l_tcp->m_mcc_records, l_default_tcp->m_mcc_records, l_mcc_records_size);\n        l_tcp->m_nb_max_mcc_records = l_default_tcp->m_nb_max_mcc_records;\n\n        /* Copy the mcc record data from dflt_tile_cp to the current tile*/\n        l_src_mcc_rec = l_default_tcp->m_mcc_records;\n        l_dest_mcc_rec = l_tcp->m_mcc_records;\n\n        for (j = 0; j < l_default_tcp->m_nb_max_mcc_records; ++j) {\n\n            if (l_src_mcc_rec->m_decorrelation_array) {\n                l_offset = (OPJ_UINT32)(l_src_mcc_rec->m_decorrelation_array -\n                                        l_default_tcp->m_mct_records);\n                l_dest_mcc_rec->m_decorrelation_array = l_tcp->m_mct_records + l_offset;\n            }\n\n            if (l_src_mcc_rec->m_offset_array) {\n                l_offset = (OPJ_UINT32)(l_src_mcc_rec->m_offset_array -\n                                        l_default_tcp->m_mct_records);\n                l_dest_mcc_rec->m_offset_array = l_tcp->m_mct_records + l_offset;\n            }\n\n            ++l_src_mcc_rec;\n            ++l_dest_mcc_rec;\n        }\n\n        /* Copy all the dflt_tile_compo_cp to the current tile cp */\n        memcpy(l_current_tccp, l_default_tcp->tccps, l_tccp_size);\n\n        /* Move to next tile cp*/\n        ++l_tcp;\n    }\n\n    /* Create the current tile decoder*/\n    p_j2k->m_tcd = (opj_tcd_t*)opj_tcd_create(OPJ_TRUE); /* FIXME why a cast ? */\n    if (! p_j2k->m_tcd) {\n        return OPJ_FALSE;\n    }\n\n    if (!opj_tcd_init(p_j2k->m_tcd, l_image, &(p_j2k->m_cp), p_j2k->m_tp)) {\n        opj_tcd_destroy(p_j2k->m_tcd);\n        p_j2k->m_tcd = 00;\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic const opj_dec_memory_marker_handler_t * opj_j2k_get_marker_handler(\n    OPJ_UINT32 p_id)\n{\n    const opj_dec_memory_marker_handler_t *e;\n    for (e = j2k_memory_marker_handler_tab; e->id != 0; ++e) {\n        if (e->id == p_id) {\n            break; /* we find a handler corresponding to the marker ID*/\n        }\n    }\n    return e;\n}\n\nvoid opj_j2k_destroy(opj_j2k_t *p_j2k)\n{\n    if (p_j2k == 00) {\n        return;\n    }\n\n    if (p_j2k->m_is_decoder) {\n\n        if (p_j2k->m_specific_param.m_decoder.m_default_tcp != 00) {\n            opj_j2k_tcp_destroy(p_j2k->m_specific_param.m_decoder.m_default_tcp);\n            opj_free(p_j2k->m_specific_param.m_decoder.m_default_tcp);\n            p_j2k->m_specific_param.m_decoder.m_default_tcp = 00;\n        }\n\n        if (p_j2k->m_specific_param.m_decoder.m_header_data != 00) {\n            opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);\n            p_j2k->m_specific_param.m_decoder.m_header_data = 00;\n            p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;\n        }\n    } else {\n\n        if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = 00;\n        }\n\n        if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);\n            p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = 00;\n            p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = 00;\n        }\n\n        if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {\n            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data = 00;\n            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n        }\n    }\n\n    opj_tcd_destroy(p_j2k->m_tcd);\n\n    opj_j2k_cp_destroy(&(p_j2k->m_cp));\n    memset(&(p_j2k->m_cp), 0, sizeof(opj_cp_t));\n\n    opj_procedure_list_destroy(p_j2k->m_procedure_list);\n    p_j2k->m_procedure_list = 00;\n\n    opj_procedure_list_destroy(p_j2k->m_validation_list);\n    p_j2k->m_procedure_list = 00;\n\n    j2k_destroy_cstr_index(p_j2k->cstr_index);\n    p_j2k->cstr_index = NULL;\n\n    opj_image_destroy(p_j2k->m_private_image);\n    p_j2k->m_private_image = NULL;\n\n    opj_image_destroy(p_j2k->m_output_image);\n    p_j2k->m_output_image = NULL;\n\n    opj_thread_pool_destroy(p_j2k->m_tp);\n    p_j2k->m_tp = NULL;\n\n    opj_free(p_j2k);\n}\n\nvoid j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind)\n{\n    if (p_cstr_ind) {\n\n        if (p_cstr_ind->marker) {\n            opj_free(p_cstr_ind->marker);\n            p_cstr_ind->marker = NULL;\n        }\n\n        if (p_cstr_ind->tile_index) {\n            OPJ_UINT32 it_tile = 0;\n\n            for (it_tile = 0; it_tile < p_cstr_ind->nb_of_tiles; it_tile++) {\n\n                if (p_cstr_ind->tile_index[it_tile].packet_index) {\n                    opj_free(p_cstr_ind->tile_index[it_tile].packet_index);\n                    p_cstr_ind->tile_index[it_tile].packet_index = NULL;\n                }\n\n                if (p_cstr_ind->tile_index[it_tile].tp_index) {\n                    opj_free(p_cstr_ind->tile_index[it_tile].tp_index);\n                    p_cstr_ind->tile_index[it_tile].tp_index = NULL;\n                }\n\n                if (p_cstr_ind->tile_index[it_tile].marker) {\n                    opj_free(p_cstr_ind->tile_index[it_tile].marker);\n                    p_cstr_ind->tile_index[it_tile].marker = NULL;\n\n                }\n            }\n\n            opj_free(p_cstr_ind->tile_index);\n            p_cstr_ind->tile_index = NULL;\n        }\n\n        opj_free(p_cstr_ind);\n    }\n}\n\nstatic void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp)\n{\n    if (p_tcp == 00) {\n        return;\n    }\n\n    if (p_tcp->ppt_markers != 00) {\n        OPJ_UINT32 i;\n        for (i = 0U; i < p_tcp->ppt_markers_count; ++i) {\n            if (p_tcp->ppt_markers[i].m_data != NULL) {\n                opj_free(p_tcp->ppt_markers[i].m_data);\n            }\n        }\n        p_tcp->ppt_markers_count = 0U;\n        opj_free(p_tcp->ppt_markers);\n        p_tcp->ppt_markers = NULL;\n    }\n\n    if (p_tcp->ppt_buffer != 00) {\n        opj_free(p_tcp->ppt_buffer);\n        p_tcp->ppt_buffer = 00;\n    }\n\n    if (p_tcp->tccps != 00) {\n        opj_free(p_tcp->tccps);\n        p_tcp->tccps = 00;\n    }\n\n    if (p_tcp->m_mct_coding_matrix != 00) {\n        opj_free(p_tcp->m_mct_coding_matrix);\n        p_tcp->m_mct_coding_matrix = 00;\n    }\n\n    if (p_tcp->m_mct_decoding_matrix != 00) {\n        opj_free(p_tcp->m_mct_decoding_matrix);\n        p_tcp->m_mct_decoding_matrix = 00;\n    }\n\n    if (p_tcp->m_mcc_records) {\n        opj_free(p_tcp->m_mcc_records);\n        p_tcp->m_mcc_records = 00;\n        p_tcp->m_nb_max_mcc_records = 0;\n        p_tcp->m_nb_mcc_records = 0;\n    }\n\n    if (p_tcp->m_mct_records) {\n        opj_mct_data_t * l_mct_data = p_tcp->m_mct_records;\n        OPJ_UINT32 i;\n\n        for (i = 0; i < p_tcp->m_nb_mct_records; ++i) {\n            if (l_mct_data->m_data) {\n                opj_free(l_mct_data->m_data);\n                l_mct_data->m_data = 00;\n            }\n\n            ++l_mct_data;\n        }\n\n        opj_free(p_tcp->m_mct_records);\n        p_tcp->m_mct_records = 00;\n    }\n\n    if (p_tcp->mct_norms != 00) {\n        opj_free(p_tcp->mct_norms);\n        p_tcp->mct_norms = 00;\n    }\n\n    opj_j2k_tcp_data_destroy(p_tcp);\n\n}\n\nstatic void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp)\n{\n    if (p_tcp->m_data) {\n        opj_free(p_tcp->m_data);\n        p_tcp->m_data = NULL;\n        p_tcp->m_data_size = 0;\n    }\n}\n\nstatic void opj_j2k_cp_destroy(opj_cp_t *p_cp)\n{\n    OPJ_UINT32 l_nb_tiles;\n    opj_tcp_t * l_current_tile = 00;\n\n    if (p_cp == 00) {\n        return;\n    }\n    if (p_cp->tcps != 00) {\n        OPJ_UINT32 i;\n        l_current_tile = p_cp->tcps;\n        l_nb_tiles = p_cp->th * p_cp->tw;\n\n        for (i = 0U; i < l_nb_tiles; ++i) {\n            opj_j2k_tcp_destroy(l_current_tile);\n            ++l_current_tile;\n        }\n        opj_free(p_cp->tcps);\n        p_cp->tcps = 00;\n    }\n    if (p_cp->ppm_markers != 00) {\n        OPJ_UINT32 i;\n        for (i = 0U; i < p_cp->ppm_markers_count; ++i) {\n            if (p_cp->ppm_markers[i].m_data != NULL) {\n                opj_free(p_cp->ppm_markers[i].m_data);\n            }\n        }\n        p_cp->ppm_markers_count = 0U;\n        opj_free(p_cp->ppm_markers);\n        p_cp->ppm_markers = NULL;\n    }\n    opj_free(p_cp->ppm_buffer);\n    p_cp->ppm_buffer = 00;\n    p_cp->ppm_data =\n        NULL; /* ppm_data belongs to the allocated buffer pointed by ppm_buffer */\n    opj_free(p_cp->comment);\n    p_cp->comment = 00;\n    if (! p_cp->m_is_decoder) {\n        opj_free(p_cp->m_specific_param.m_enc.m_matrice);\n        p_cp->m_specific_param.m_enc.m_matrice = 00;\n    }\n}\n\nstatic OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t\n        *p_stream, OPJ_UINT32 tile_no, OPJ_BOOL* p_correction_needed,\n        opj_event_mgr_t * p_manager)\n{\n    OPJ_BYTE   l_header_data[10];\n    OPJ_OFF_T  l_stream_pos_backup;\n    OPJ_UINT32 l_current_marker;\n    OPJ_UINT32 l_marker_size;\n    OPJ_UINT32 l_tile_no, l_tot_len, l_current_part, l_num_parts;\n\n    /* initialize to no correction needed */\n    *p_correction_needed = OPJ_FALSE;\n\n    if (!opj_stream_has_seek(p_stream)) {\n        /* We can't do much in this case, seek is needed */\n        return OPJ_TRUE;\n    }\n\n    l_stream_pos_backup = opj_stream_tell(p_stream);\n    if (l_stream_pos_backup == -1) {\n        /* let's do nothing */\n        return OPJ_TRUE;\n    }\n\n    for (;;) {\n        /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n        if (opj_stream_read_data(p_stream, l_header_data, 2, p_manager) != 2) {\n            /* assume all is OK */\n            if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n                return OPJ_FALSE;\n            }\n            return OPJ_TRUE;\n        }\n\n        /* Read 2 bytes from buffer as the new marker ID */\n        opj_read_bytes(l_header_data, &l_current_marker, 2);\n\n        if (l_current_marker != J2K_MS_SOT) {\n            /* assume all is OK */\n            if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n                return OPJ_FALSE;\n            }\n            return OPJ_TRUE;\n        }\n\n        /* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */\n        if (opj_stream_read_data(p_stream, l_header_data, 2, p_manager) != 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* Read 2 bytes from the buffer as the marker size */\n        opj_read_bytes(l_header_data, &l_marker_size, 2);\n\n        /* Check marker size for SOT Marker */\n        if (l_marker_size != 10) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Inconsistent marker size\\n\");\n            return OPJ_FALSE;\n        }\n        l_marker_size -= 2;\n\n        if (opj_stream_read_data(p_stream, l_header_data, l_marker_size,\n                                 p_manager) != l_marker_size) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        if (! opj_j2k_get_sot_values(l_header_data, l_marker_size, &l_tile_no,\n                                     &l_tot_len, &l_current_part, &l_num_parts, p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        if (l_tile_no == tile_no) {\n            /* we found what we were looking for */\n            break;\n        }\n\n        if ((l_tot_len == 0U) || (l_tot_len < 14U)) {\n            /* last SOT until EOC or invalid Psot value */\n            /* assume all is OK */\n            if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n                return OPJ_FALSE;\n            }\n            return OPJ_TRUE;\n        }\n        l_tot_len -= 12U;\n        /* look for next SOT marker */\n        if (opj_stream_skip(p_stream, (OPJ_OFF_T)(l_tot_len),\n                            p_manager) != (OPJ_OFF_T)(l_tot_len)) {\n            /* assume all is OK */\n            if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n                return OPJ_FALSE;\n            }\n            return OPJ_TRUE;\n        }\n    }\n\n    /* check for correction */\n    if (l_current_part == l_num_parts) {\n        *p_correction_needed = OPJ_TRUE;\n    }\n\n    if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n        return OPJ_FALSE;\n    }\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t * p_j2k,\n                                  OPJ_UINT32 * p_tile_index,\n                                  OPJ_UINT32 * p_data_size,\n                                  OPJ_INT32 * p_tile_x0, OPJ_INT32 * p_tile_y0,\n                                  OPJ_INT32 * p_tile_x1, OPJ_INT32 * p_tile_y1,\n                                  OPJ_UINT32 * p_nb_comps,\n                                  OPJ_BOOL * p_go_on,\n                                  opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 l_current_marker = J2K_MS_SOT;\n    OPJ_UINT32 l_marker_size;\n    const opj_dec_memory_marker_handler_t * l_marker_handler = 00;\n    opj_tcp_t * l_tcp = NULL;\n\n    /* preconditions */\n    assert(p_stream != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    /* Reach the End Of Codestream ?*/\n    if (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_EOC) {\n        l_current_marker = J2K_MS_EOC;\n    }\n    /* We need to encounter a SOT marker (a new tile-part header) */\n    else if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_TPHSOT) {\n        return OPJ_FALSE;\n    }\n\n    /* Read into the codestream until reach the EOC or ! can_decode ??? FIXME */\n    while ((!p_j2k->m_specific_param.m_decoder.m_can_decode) &&\n            (l_current_marker != J2K_MS_EOC)) {\n\n        /* Try to read until the Start Of Data is detected */\n        while (l_current_marker != J2K_MS_SOD) {\n\n            if (opj_stream_get_number_byte_left(p_stream) == 0) {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                break;\n            }\n\n            /* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */\n            if (opj_stream_read_data(p_stream,\n                                     p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* Read 2 bytes from the buffer as the marker size */\n            opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data, &l_marker_size,\n                           2);\n\n            /* Check marker size (does not include marker ID but includes marker size) */\n            if (l_marker_size < 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Inconsistent marker size\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* cf. https://code.google.com/p/openjpeg/issues/detail?id=226 */\n            if (l_current_marker == 0x8080 &&\n                    opj_stream_get_number_byte_left(p_stream) == 0) {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                break;\n            }\n\n            /* Why this condition? FIXME */\n            if (p_j2k->m_specific_param.m_decoder.m_state & J2K_STATE_TPH) {\n                p_j2k->m_specific_param.m_decoder.m_sot_length -= (l_marker_size + 2);\n            }\n            l_marker_size -= 2; /* Subtract the size of the marker ID already read */\n\n            /* Get the marker handler from the marker ID */\n            l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);\n\n            /* Check if the marker is known and if it is the right place to find it */\n            if (!(p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Marker is not compliant with its position\\n\");\n                return OPJ_FALSE;\n            }\n            /* FIXME manage case of unknown marker as in the main header ? */\n\n            /* Check if the marker size is compatible with the header data size */\n            if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {\n                OPJ_BYTE *new_header_data = NULL;\n                /* If we are here, this means we consider this marker as known & we will read it */\n                /* Check enough bytes left in stream before allocation */\n                if ((OPJ_OFF_T)l_marker_size >  opj_stream_get_number_byte_left(p_stream)) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"Marker size inconsistent with stream length\\n\");\n                    return OPJ_FALSE;\n                }\n                new_header_data = (OPJ_BYTE *) opj_realloc(\n                                      p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size);\n                if (! new_header_data) {\n                    opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);\n                    p_j2k->m_specific_param.m_decoder.m_header_data = NULL;\n                    p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;\n                    opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read header\\n\");\n                    return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;\n                p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;\n            }\n\n            /* Try to read the rest of the marker segment from stream and copy them into the buffer */\n            if (opj_stream_read_data(p_stream,\n                                     p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size,\n                                     p_manager) != l_marker_size) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                return OPJ_FALSE;\n            }\n\n            if (!l_marker_handler->handler) {\n                /* See issue #175 */\n                opj_event_msg(p_manager, EVT_ERROR, \"Not sure how that happened.\\n\");\n                return OPJ_FALSE;\n            }\n            /* Read the marker segment with the correct marker handler */\n            if (!(*(l_marker_handler->handler))(p_j2k,\n                                                p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size, p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Fail to read the current marker segment (%#x)\\n\", l_current_marker);\n                return OPJ_FALSE;\n            }\n\n            /* Add the marker to the codestream index*/\n            if (OPJ_FALSE == opj_j2k_add_tlmarker(p_j2k->m_current_tile_number,\n                                                  p_j2k->cstr_index,\n                                                  l_marker_handler->id,\n                                                  (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4,\n                                                  l_marker_size + 4)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add tl marker\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* Keep the position of the last SOT marker read */\n            if (l_marker_handler->id == J2K_MS_SOT) {\n                OPJ_UINT32 sot_pos = (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4\n                                     ;\n                if (sot_pos > p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos) {\n                    p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = sot_pos;\n                }\n            }\n\n            if (p_j2k->m_specific_param.m_decoder.m_skip_data) {\n                /* Skip the rest of the tile part header*/\n                if (opj_stream_skip(p_stream, p_j2k->m_specific_param.m_decoder.m_sot_length,\n                                    p_manager) != p_j2k->m_specific_param.m_decoder.m_sot_length) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                    return OPJ_FALSE;\n                }\n                l_current_marker = J2K_MS_SOD; /* Normally we reached a SOD */\n            } else {\n                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer*/\n                if (opj_stream_read_data(p_stream,\n                                         p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                    return OPJ_FALSE;\n                }\n                /* Read 2 bytes from the buffer as the new marker ID */\n                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                               &l_current_marker, 2);\n            }\n        }\n        if (opj_stream_get_number_byte_left(p_stream) == 0\n                && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC) {\n            break;\n        }\n\n        /* If we didn't skip data before, we need to read the SOD marker*/\n        if (! p_j2k->m_specific_param.m_decoder.m_skip_data) {\n            /* Try to read the SOD marker and skip data ? FIXME */\n            if (! opj_j2k_read_sod(p_j2k, p_stream, p_manager)) {\n                return OPJ_FALSE;\n            }\n            if (p_j2k->m_specific_param.m_decoder.m_can_decode &&\n                    !p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked) {\n                /* Issue 254 */\n                OPJ_BOOL l_correction_needed;\n\n                p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = 1;\n                if (!opj_j2k_need_nb_tile_parts_correction(p_stream,\n                        p_j2k->m_current_tile_number, &l_correction_needed, p_manager)) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"opj_j2k_apply_nb_tile_parts_correction error\\n\");\n                    return OPJ_FALSE;\n                }\n                if (l_correction_needed) {\n                    OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;\n                    OPJ_UINT32 l_tile_no;\n\n                    p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n                    p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction = 1;\n                    /* correct tiles */\n                    for (l_tile_no = 0U; l_tile_no < l_nb_tiles; ++l_tile_no) {\n                        if (p_j2k->m_cp.tcps[l_tile_no].m_nb_tile_parts != 0U) {\n                            p_j2k->m_cp.tcps[l_tile_no].m_nb_tile_parts += 1;\n                        }\n                    }\n                    opj_event_msg(p_manager, EVT_WARNING,\n                                  \"Non conformant codestream TPsot==TNsot.\\n\");\n                }\n            }\n            if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {\n                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n                if (opj_stream_read_data(p_stream,\n                                         p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                    return OPJ_FALSE;\n                }\n\n                /* Read 2 bytes from buffer as the new marker ID */\n                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                               &l_current_marker, 2);\n            }\n        } else {\n            /* Indicate we will try to read a new tile-part header*/\n            p_j2k->m_specific_param.m_decoder.m_skip_data = 0;\n            p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n            p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n\n            /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n            if (opj_stream_read_data(p_stream,\n                                     p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                return OPJ_FALSE;\n            }\n\n            /* Read 2 bytes from buffer as the new marker ID */\n            opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,\n                           &l_current_marker, 2);\n        }\n    }\n\n    /* Current marker is the EOC marker ?*/\n    if (l_current_marker == J2K_MS_EOC) {\n        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_EOC;\n    }\n\n    /* FIXME DOC ???*/\n    if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {\n        OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n        l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;\n\n        while ((p_j2k->m_current_tile_number < l_nb_tiles) && (l_tcp->m_data == 00)) {\n            ++p_j2k->m_current_tile_number;\n            ++l_tcp;\n        }\n\n        if (p_j2k->m_current_tile_number == l_nb_tiles) {\n            *p_go_on = OPJ_FALSE;\n            return OPJ_TRUE;\n        }\n    }\n\n    if (! opj_j2k_merge_ppt(p_j2k->m_cp.tcps + p_j2k->m_current_tile_number,\n                            p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Failed to merge PPT data\\n\");\n        return OPJ_FALSE;\n    }\n    /*FIXME ???*/\n    if (! opj_tcd_init_decode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number,\n                                   p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_event_msg(p_manager, EVT_INFO, \"Header of tile %d / %d has been read.\\n\",\n                  p_j2k->m_current_tile_number + 1, (p_j2k->m_cp.th * p_j2k->m_cp.tw));\n\n    *p_tile_index = p_j2k->m_current_tile_number;\n    *p_go_on = OPJ_TRUE;\n    *p_data_size = opj_tcd_get_decoded_tile_size(p_j2k->m_tcd);\n    if (*p_data_size == UINT_MAX) {\n        return OPJ_FALSE;\n    }\n    *p_tile_x0 = p_j2k->m_tcd->tcd_image->tiles->x0;\n    *p_tile_y0 = p_j2k->m_tcd->tcd_image->tiles->y0;\n    *p_tile_x1 = p_j2k->m_tcd->tcd_image->tiles->x1;\n    *p_tile_y1 = p_j2k->m_tcd->tcd_image->tiles->y1;\n    *p_nb_comps = p_j2k->m_tcd->tcd_image->tiles->numcomps;\n\n    p_j2k->m_specific_param.m_decoder.m_state |= J2K_STATE_DATA;\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_decode_tile(opj_j2k_t * p_j2k,\n                             OPJ_UINT32 p_tile_index,\n                             OPJ_BYTE * p_data,\n                             OPJ_UINT32 p_data_size,\n                             opj_stream_private_t *p_stream,\n                             opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 l_current_marker;\n    OPJ_BYTE l_data [2];\n    opj_tcp_t * l_tcp;\n\n    /* preconditions */\n    assert(p_stream != 00);\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (!(p_j2k->m_specific_param.m_decoder.m_state & J2K_STATE_DATA)\n            || (p_tile_index != p_j2k->m_current_tile_number)) {\n        return OPJ_FALSE;\n    }\n\n    l_tcp = &(p_j2k->m_cp.tcps[p_tile_index]);\n    if (! l_tcp->m_data) {\n        opj_j2k_tcp_destroy(l_tcp);\n        return OPJ_FALSE;\n    }\n\n    if (! opj_tcd_decode_tile(p_j2k->m_tcd,\n                              l_tcp->m_data,\n                              l_tcp->m_data_size,\n                              p_tile_index,\n                              p_j2k->cstr_index, p_manager)) {\n        opj_j2k_tcp_destroy(l_tcp);\n        p_j2k->m_specific_param.m_decoder.m_state |= J2K_STATE_ERR;\n        opj_event_msg(p_manager, EVT_ERROR, \"Failed to decode.\\n\");\n        return OPJ_FALSE;\n    }\n\n    /* p_data can be set to NULL when the call will take care of using */\n    /* itself the TCD data. This is typically the case for whole single */\n    /* tile decoding optimization. */\n    if (p_data != NULL) {\n        if (! opj_tcd_update_tile_data(p_j2k->m_tcd, p_data, p_data_size)) {\n            return OPJ_FALSE;\n        }\n\n        /* To avoid to destroy the tcp which can be useful when we try to decode a tile decoded before (cf j2k_random_tile_access)\n        * we destroy just the data which will be re-read in read_tile_header*/\n        /*opj_j2k_tcp_destroy(l_tcp);\n        p_j2k->m_tcd->tcp = 0;*/\n        opj_j2k_tcp_data_destroy(l_tcp);\n    }\n\n    p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n    p_j2k->m_specific_param.m_decoder.m_state &= (~(OPJ_UINT32)J2K_STATE_DATA);\n\n    if (opj_stream_get_number_byte_left(p_stream) == 0\n            && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC) {\n        return OPJ_TRUE;\n    }\n\n    if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_EOC) {\n        if (opj_stream_read_data(p_stream, l_data, 2, p_manager) != 2) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n            return OPJ_FALSE;\n        }\n\n        opj_read_bytes(l_data, &l_current_marker, 2);\n\n        if (l_current_marker == J2K_MS_EOC) {\n            p_j2k->m_current_tile_number = 0;\n            p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_EOC;\n        } else if (l_current_marker != J2K_MS_SOT) {\n            if (opj_stream_get_number_byte_left(p_stream) == 0) {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                opj_event_msg(p_manager, EVT_WARNING, \"Stream does not end with EOC\\n\");\n                return OPJ_TRUE;\n            }\n            opj_event_msg(p_manager, EVT_ERROR, \"Stream too short, expected SOT\\n\");\n            return OPJ_FALSE;\n        }\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t * p_tcd, OPJ_BYTE * p_data,\n        opj_image_t* p_output_image)\n{\n    OPJ_UINT32 i, j, k = 0;\n    OPJ_UINT32 l_width_src, l_height_src;\n    OPJ_UINT32 l_width_dest, l_height_dest;\n    OPJ_INT32 l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src;\n    OPJ_SIZE_T l_start_offset_src, l_line_offset_src, l_end_offset_src ;\n    OPJ_UINT32 l_start_x_dest, l_start_y_dest;\n    OPJ_UINT32 l_x0_dest, l_y0_dest, l_x1_dest, l_y1_dest;\n    OPJ_SIZE_T l_start_offset_dest, l_line_offset_dest;\n\n    opj_image_comp_t * l_img_comp_src = 00;\n    opj_image_comp_t * l_img_comp_dest = 00;\n\n    opj_tcd_tilecomp_t * l_tilec = 00;\n    opj_image_t * l_image_src = 00;\n    OPJ_UINT32 l_size_comp, l_remaining;\n    OPJ_INT32 * l_dest_ptr;\n    opj_tcd_resolution_t* l_res = 00;\n\n    l_tilec = p_tcd->tcd_image->tiles->comps;\n    l_image_src = p_tcd->image;\n    l_img_comp_src = l_image_src->comps;\n\n    l_img_comp_dest = p_output_image->comps;\n\n    for (i = 0; i < l_image_src->numcomps; i++) {\n\n        /* Allocate output component buffer if necessary */\n        if (!l_img_comp_dest->data) {\n            OPJ_SIZE_T l_width = l_img_comp_dest->w;\n            OPJ_SIZE_T l_height = l_img_comp_dest->h;\n\n            if ((l_height == 0U) || (l_width > (SIZE_MAX / l_height)) ||\n                    l_width * l_height > SIZE_MAX / sizeof(OPJ_INT32)) {\n                /* would overflow */\n                return OPJ_FALSE;\n            }\n            l_img_comp_dest->data = (OPJ_INT32*) opj_image_data_alloc(l_width * l_height *\n                                    sizeof(OPJ_INT32));\n            if (! l_img_comp_dest->data) {\n                return OPJ_FALSE;\n            }\n            /* Do we really need this memset ? */\n            memset(l_img_comp_dest->data, 0, l_width * l_height * sizeof(OPJ_INT32));\n        }\n\n        /* Copy info from decoded comp image to output image */\n        l_img_comp_dest->resno_decoded = l_img_comp_src->resno_decoded;\n\n        /*-----*/\n        /* Compute the precision of the output buffer */\n        l_size_comp = l_img_comp_src->prec >> 3; /*(/ 8)*/\n        l_remaining = l_img_comp_src->prec & 7;  /* (%8) */\n        l_res = l_tilec->resolutions + l_img_comp_src->resno_decoded;\n\n        if (l_remaining) {\n            ++l_size_comp;\n        }\n\n        if (l_size_comp == 3) {\n            l_size_comp = 4;\n        }\n        /*-----*/\n\n        /* Current tile component size*/\n        /*if (i == 0) {\n        fprintf(stdout, \"SRC: l_res_x0=%d, l_res_x1=%d, l_res_y0=%d, l_res_y1=%d\\n\",\n                        l_res->x0, l_res->x1, l_res->y0, l_res->y1);\n        }*/\n\n        l_width_src = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n        l_height_src = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n\n        /* Border of the current output component*/\n        l_x0_dest = opj_uint_ceildivpow2(l_img_comp_dest->x0, l_img_comp_dest->factor);\n        l_y0_dest = opj_uint_ceildivpow2(l_img_comp_dest->y0, l_img_comp_dest->factor);\n        l_x1_dest = l_x0_dest +\n                    l_img_comp_dest->w; /* can't overflow given that image->x1 is uint32 */\n        l_y1_dest = l_y0_dest + l_img_comp_dest->h;\n\n        /*if (i == 0) {\n        fprintf(stdout, \"DEST: l_x0_dest=%d, l_x1_dest=%d, l_y0_dest=%d, l_y1_dest=%d (%d)\\n\",\n                        l_x0_dest, l_x1_dest, l_y0_dest, l_y1_dest, l_img_comp_dest->factor );\n        }*/\n\n        /*-----*/\n        /* Compute the area (l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src)\n         * of the input buffer (decoded tile component) which will be move\n         * in the output buffer. Compute the area of the output buffer (l_start_x_dest,\n         * l_start_y_dest, l_width_dest, l_height_dest)  which will be modified\n         * by this input area.\n         * */\n        assert(l_res->x0 >= 0);\n        assert(l_res->x1 >= 0);\n        if (l_x0_dest < (OPJ_UINT32)l_res->x0) {\n            l_start_x_dest = (OPJ_UINT32)l_res->x0 - l_x0_dest;\n            l_offset_x0_src = 0;\n\n            if (l_x1_dest >= (OPJ_UINT32)l_res->x1) {\n                l_width_dest = l_width_src;\n                l_offset_x1_src = 0;\n            } else {\n                l_width_dest = l_x1_dest - (OPJ_UINT32)l_res->x0 ;\n                l_offset_x1_src = (OPJ_INT32)(l_width_src - l_width_dest);\n            }\n        } else {\n            l_start_x_dest = 0U;\n            l_offset_x0_src = (OPJ_INT32)l_x0_dest - l_res->x0;\n\n            if (l_x1_dest >= (OPJ_UINT32)l_res->x1) {\n                l_width_dest = l_width_src - (OPJ_UINT32)l_offset_x0_src;\n                l_offset_x1_src = 0;\n            } else {\n                l_width_dest = l_img_comp_dest->w ;\n                l_offset_x1_src = l_res->x1 - (OPJ_INT32)l_x1_dest;\n            }\n        }\n\n        if (l_y0_dest < (OPJ_UINT32)l_res->y0) {\n            l_start_y_dest = (OPJ_UINT32)l_res->y0 - l_y0_dest;\n            l_offset_y0_src = 0;\n\n            if (l_y1_dest >= (OPJ_UINT32)l_res->y1) {\n                l_height_dest = l_height_src;\n                l_offset_y1_src = 0;\n            } else {\n                l_height_dest = l_y1_dest - (OPJ_UINT32)l_res->y0 ;\n                l_offset_y1_src = (OPJ_INT32)(l_height_src - l_height_dest);\n            }\n        } else {\n            l_start_y_dest = 0U;\n            l_offset_y0_src = (OPJ_INT32)l_y0_dest - l_res->y0;\n\n            if (l_y1_dest >= (OPJ_UINT32)l_res->y1) {\n                l_height_dest = l_height_src - (OPJ_UINT32)l_offset_y0_src;\n                l_offset_y1_src = 0;\n            } else {\n                l_height_dest = l_img_comp_dest->h ;\n                l_offset_y1_src = l_res->y1 - (OPJ_INT32)l_y1_dest;\n            }\n        }\n\n        if ((l_offset_x0_src < 0) || (l_offset_y0_src < 0) || (l_offset_x1_src < 0) ||\n                (l_offset_y1_src < 0)) {\n            return OPJ_FALSE;\n        }\n        /* testcase 2977.pdf.asan.67.2198 */\n        if ((OPJ_INT32)l_width_dest < 0 || (OPJ_INT32)l_height_dest < 0) {\n            return OPJ_FALSE;\n        }\n        /*-----*/\n\n        /* Compute the input buffer offset */\n        l_start_offset_src = (OPJ_SIZE_T)l_offset_x0_src + (OPJ_SIZE_T)l_offset_y0_src\n                             * (OPJ_SIZE_T)l_width_src;\n        l_line_offset_src  = (OPJ_SIZE_T)l_offset_x1_src + (OPJ_SIZE_T)l_offset_x0_src;\n        l_end_offset_src   = (OPJ_SIZE_T)l_offset_y1_src * (OPJ_SIZE_T)l_width_src -\n                             (OPJ_SIZE_T)l_offset_x0_src;\n\n        /* Compute the output buffer offset */\n        l_start_offset_dest = (OPJ_SIZE_T)l_start_x_dest + (OPJ_SIZE_T)l_start_y_dest\n                              * (OPJ_SIZE_T)l_img_comp_dest->w;\n        l_line_offset_dest  = (OPJ_SIZE_T)l_img_comp_dest->w - (OPJ_SIZE_T)l_width_dest;\n\n        /* Move the output buffer to the first place where we will write*/\n        l_dest_ptr = l_img_comp_dest->data + l_start_offset_dest;\n\n        /*if (i == 0) {\n                fprintf(stdout, \"COMPO[%d]:\\n\",i);\n                fprintf(stdout, \"SRC: l_start_x_src=%d, l_start_y_src=%d, l_width_src=%d, l_height_src=%d\\n\"\n                                \"\\t tile offset:%d, %d, %d, %d\\n\"\n                                \"\\t buffer offset: %d; %d, %d\\n\",\n                                l_res->x0, l_res->y0, l_width_src, l_height_src,\n                                l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src,\n                                l_start_offset_src, l_line_offset_src, l_end_offset_src);\n\n                fprintf(stdout, \"DEST: l_start_x_dest=%d, l_start_y_dest=%d, l_width_dest=%d, l_height_dest=%d\\n\"\n                                \"\\t start offset: %d, line offset= %d\\n\",\n                                l_start_x_dest, l_start_y_dest, l_width_dest, l_height_dest, l_start_offset_dest, l_line_offset_dest);\n        }*/\n\n        switch (l_size_comp) {\n        case 1: {\n            OPJ_CHAR * l_src_ptr = (OPJ_CHAR*) p_data;\n            l_src_ptr += l_start_offset_src; /* Move to the first place where we will read*/\n\n            if (l_img_comp_src->sgnd) {\n                for (j = 0 ; j < l_height_dest ; ++j) {\n                    for (k = 0 ; k < l_width_dest ; ++k) {\n                        *(l_dest_ptr++) = (OPJ_INT32)(*\n                                                      (l_src_ptr++));  /* Copy only the data needed for the output image */\n                    }\n\n                    l_dest_ptr +=\n                        l_line_offset_dest; /* Move to the next place where we will write */\n                    l_src_ptr += l_line_offset_src ; /* Move to the next place where we will read */\n                }\n            } else {\n                for (j = 0 ; j < l_height_dest ; ++j) {\n                    for (k = 0 ; k < l_width_dest ; ++k) {\n                        *(l_dest_ptr++) = (OPJ_INT32)((*(l_src_ptr++)) & 0xff);\n                    }\n\n                    l_dest_ptr += l_line_offset_dest;\n                    l_src_ptr += l_line_offset_src;\n                }\n            }\n\n            l_src_ptr +=\n                l_end_offset_src; /* Move to the end of this component-part of the input buffer */\n            p_data = (OPJ_BYTE*)\n                     l_src_ptr; /* Keep the current position for the next component-part */\n        }\n        break;\n        case 2: {\n            OPJ_INT16 * l_src_ptr = (OPJ_INT16 *) p_data;\n            l_src_ptr += l_start_offset_src;\n\n            if (l_img_comp_src->sgnd) {\n                for (j = 0; j < l_height_dest; ++j) {\n                    for (k = 0; k < l_width_dest; ++k) {\n                        OPJ_INT16 val;\n                        memcpy(&val, l_src_ptr, sizeof(val));\n                        l_src_ptr ++;\n                        *(l_dest_ptr++) = val;\n                    }\n\n                    l_dest_ptr += l_line_offset_dest;\n                    l_src_ptr += l_line_offset_src ;\n                }\n            } else {\n                for (j = 0; j < l_height_dest; ++j) {\n                    for (k = 0; k < l_width_dest; ++k) {\n                        OPJ_INT16 val;\n                        memcpy(&val, l_src_ptr, sizeof(val));\n                        l_src_ptr ++;\n                        *(l_dest_ptr++) = val & 0xffff;\n                    }\n\n                    l_dest_ptr += l_line_offset_dest;\n                    l_src_ptr += l_line_offset_src ;\n                }\n            }\n\n            l_src_ptr += l_end_offset_src;\n            p_data = (OPJ_BYTE*) l_src_ptr;\n        }\n        break;\n        case 4: {\n            OPJ_INT32 * l_src_ptr = (OPJ_INT32 *) p_data;\n            l_src_ptr += l_start_offset_src;\n\n            for (j = 0; j < l_height_dest; ++j) {\n                memcpy(l_dest_ptr, l_src_ptr, l_width_dest * sizeof(OPJ_INT32));\n                l_dest_ptr += l_width_dest + l_line_offset_dest;\n                l_src_ptr += l_width_dest + l_line_offset_src ;\n            }\n\n            l_src_ptr += l_end_offset_src;\n            p_data = (OPJ_BYTE*) l_src_ptr;\n        }\n        break;\n        }\n\n        ++l_img_comp_dest;\n        ++l_img_comp_src;\n        ++l_tilec;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k,\n                                 opj_image_t* p_image,\n                                 OPJ_INT32 p_start_x, OPJ_INT32 p_start_y,\n                                 OPJ_INT32 p_end_x, OPJ_INT32 p_end_y,\n                                 opj_event_mgr_t * p_manager)\n{\n    opj_cp_t * l_cp = &(p_j2k->m_cp);\n    opj_image_t * l_image = p_j2k->m_private_image;\n\n    OPJ_UINT32 it_comp;\n    OPJ_INT32 l_comp_x1, l_comp_y1;\n    opj_image_comp_t* l_img_comp = NULL;\n\n    /* Check if we are read the main header */\n    if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_TPHSOT) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Need to decode the main header before begin to decode the remaining codestream\");\n        return OPJ_FALSE;\n    }\n\n    if (!p_start_x && !p_start_y && !p_end_x && !p_end_y) {\n        opj_event_msg(p_manager, EVT_INFO,\n                      \"No decoded area parameters, set the decoded area to the whole image\\n\");\n\n        p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;\n        p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;\n        p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;\n        p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;\n\n        return OPJ_TRUE;\n    }\n\n    /* ----- */\n    /* Check if the positions provided by the user are correct */\n\n    /* Left */\n    if (p_start_x < 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Left position of the decoded area (region_x0=%d) should be >= 0.\\n\",\n                      p_start_x);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_start_x > l_image->x1) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\\n\",\n                      p_start_x, l_image->x1);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_start_x < l_image->x0) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\\n\",\n                      p_start_x, l_image->x0);\n        p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;\n        p_image->x0 = l_image->x0;\n    } else {\n        p_j2k->m_specific_param.m_decoder.m_start_tile_x = ((OPJ_UINT32)p_start_x -\n                l_cp->tx0) / l_cp->tdx;\n        p_image->x0 = (OPJ_UINT32)p_start_x;\n    }\n\n    /* Up */\n    if (p_start_x < 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Up position of the decoded area (region_y0=%d) should be >= 0.\\n\",\n                      p_start_y);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_start_y > l_image->y1) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\\n\",\n                      p_start_y, l_image->y1);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_start_y < l_image->y0) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\\n\",\n                      p_start_y, l_image->y0);\n        p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;\n        p_image->y0 = l_image->y0;\n    } else {\n        p_j2k->m_specific_param.m_decoder.m_start_tile_y = ((OPJ_UINT32)p_start_y -\n                l_cp->ty0) / l_cp->tdy;\n        p_image->y0 = (OPJ_UINT32)p_start_y;\n    }\n\n    /* Right */\n    if (p_end_x <= 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Right position of the decoded area (region_x1=%d) should be > 0.\\n\",\n                      p_end_x);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_end_x < l_image->x0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\\n\",\n                      p_end_x, l_image->x0);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_end_x > l_image->x1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\\n\",\n                      p_end_x, l_image->x1);\n        p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;\n        p_image->x1 = l_image->x1;\n    } else {\n        p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32)opj_int_ceildiv(\n                    p_end_x - (OPJ_INT32)l_cp->tx0, (OPJ_INT32)l_cp->tdx);\n        p_image->x1 = (OPJ_UINT32)p_end_x;\n    }\n\n    /* Bottom */\n    if (p_end_y <= 0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Bottom position of the decoded area (region_y1=%d) should be > 0.\\n\",\n                      p_end_y);\n        return OPJ_FALSE;\n    } else if ((OPJ_UINT32)p_end_y < l_image->y0) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\\n\",\n                      p_end_y, l_image->y0);\n        return OPJ_FALSE;\n    }\n    if ((OPJ_UINT32)p_end_y > l_image->y1) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\\n\",\n                      p_end_y, l_image->y1);\n        p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;\n        p_image->y1 = l_image->y1;\n    } else {\n        p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32)opj_int_ceildiv(\n                    p_end_y - (OPJ_INT32)l_cp->ty0, (OPJ_INT32)l_cp->tdy);\n        p_image->y1 = (OPJ_UINT32)p_end_y;\n    }\n    /* ----- */\n\n    p_j2k->m_specific_param.m_decoder.m_discard_tiles = 1;\n\n    l_img_comp = p_image->comps;\n    for (it_comp = 0; it_comp < p_image->numcomps; ++it_comp) {\n        OPJ_INT32 l_h, l_w;\n\n        l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0,\n                         (OPJ_INT32)l_img_comp->dx);\n        l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0,\n                         (OPJ_INT32)l_img_comp->dy);\n        l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);\n        l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);\n\n        l_w = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32)l_img_comp->factor)\n              - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0, (OPJ_INT32)l_img_comp->factor);\n        if (l_w < 0) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Size x of the decoded component image is incorrect (comp[%d].w=%d).\\n\",\n                          it_comp, l_w);\n            return OPJ_FALSE;\n        }\n        l_img_comp->w = (OPJ_UINT32)l_w;\n\n        l_h = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32)l_img_comp->factor)\n              - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0, (OPJ_INT32)l_img_comp->factor);\n        if (l_h < 0) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Size y of the decoded component image is incorrect (comp[%d].h=%d).\\n\",\n                          it_comp, l_h);\n            return OPJ_FALSE;\n        }\n        l_img_comp->h = (OPJ_UINT32)l_h;\n\n        l_img_comp++;\n    }\n\n    opj_event_msg(p_manager, EVT_INFO, \"Setting decoding area to %d,%d,%d,%d\\n\",\n                  p_image->x0, p_image->y0, p_image->x1, p_image->y1);\n\n    return OPJ_TRUE;\n}\n\nopj_j2k_t* opj_j2k_create_decompress(void)\n{\n    opj_j2k_t *l_j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));\n    if (!l_j2k) {\n        return 00;\n    }\n\n    l_j2k->m_is_decoder = 1;\n    l_j2k->m_cp.m_is_decoder = 1;\n    /* in the absence of JP2 boxes, consider different bit depth / sign */\n    /* per component is allowed */\n    l_j2k->m_cp.allow_different_bit_depth_sign = 1;\n\n#ifdef OPJ_DISABLE_TPSOT_FIX\n    l_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = 1;\n#endif\n\n    l_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t*) opj_calloc(1,\n            sizeof(opj_tcp_t));\n    if (!l_j2k->m_specific_param.m_decoder.m_default_tcp) {\n        opj_j2k_destroy(l_j2k);\n        return 00;\n    }\n\n    l_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *) opj_calloc(1,\n            OPJ_J2K_DEFAULT_HEADER_SIZE);\n    if (! l_j2k->m_specific_param.m_decoder.m_header_data) {\n        opj_j2k_destroy(l_j2k);\n        return 00;\n    }\n\n    l_j2k->m_specific_param.m_decoder.m_header_data_size =\n        OPJ_J2K_DEFAULT_HEADER_SIZE;\n\n    l_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = -1 ;\n\n    l_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = 0 ;\n\n    /* codestream index creation */\n    l_j2k->cstr_index = opj_j2k_create_cstr_index();\n    if (!l_j2k->cstr_index) {\n        opj_j2k_destroy(l_j2k);\n        return 00;\n    }\n\n    /* validation list creation */\n    l_j2k->m_validation_list = opj_procedure_list_create();\n    if (! l_j2k->m_validation_list) {\n        opj_j2k_destroy(l_j2k);\n        return 00;\n    }\n\n    /* execution list creation */\n    l_j2k->m_procedure_list = opj_procedure_list_create();\n    if (! l_j2k->m_procedure_list) {\n        opj_j2k_destroy(l_j2k);\n        return 00;\n    }\n\n    l_j2k->m_tp = opj_thread_pool_create(opj_j2k_get_default_thread_count());\n    if (!l_j2k->m_tp) {\n        l_j2k->m_tp = opj_thread_pool_create(0);\n    }\n    if (!l_j2k->m_tp) {\n        opj_j2k_destroy(l_j2k);\n        return NULL;\n    }\n\n    return l_j2k;\n}\n\nstatic opj_codestream_index_t* opj_j2k_create_cstr_index(void)\n{\n    opj_codestream_index_t* cstr_index = (opj_codestream_index_t*)\n                                         opj_calloc(1, sizeof(opj_codestream_index_t));\n    if (!cstr_index) {\n        return NULL;\n    }\n\n    cstr_index->maxmarknum = 100;\n    cstr_index->marknum = 0;\n    cstr_index->marker = (opj_marker_info_t*)\n                         opj_calloc(cstr_index->maxmarknum, sizeof(opj_marker_info_t));\n    if (!cstr_index-> marker) {\n        opj_free(cstr_index);\n        return NULL;\n    }\n\n    cstr_index->tile_index = NULL;\n\n    return cstr_index;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no,\n        OPJ_UINT32 p_comp_no)\n{\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp = &l_tcp->tccps[p_comp_no];\n\n    /* preconditions again */\n    assert(p_tile_no < (l_cp->tw * l_cp->th));\n    assert(p_comp_no < p_j2k->m_private_image->numcomps);\n\n    if (l_tccp->csty & J2K_CCP_CSTY_PRT) {\n        return 5 + l_tccp->numresolutions;\n    } else {\n        return 5;\n    }\n}\n\nstatic OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n    OPJ_UINT32 i;\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n    opj_tccp_t *l_tccp0 = NULL;\n    opj_tccp_t *l_tccp1 = NULL;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp0 = &l_tcp->tccps[p_first_comp_no];\n    l_tccp1 = &l_tcp->tccps[p_second_comp_no];\n\n    if (l_tccp0->numresolutions != l_tccp1->numresolutions) {\n        return OPJ_FALSE;\n    }\n    if (l_tccp0->cblkw != l_tccp1->cblkw) {\n        return OPJ_FALSE;\n    }\n    if (l_tccp0->cblkh != l_tccp1->cblkh) {\n        return OPJ_FALSE;\n    }\n    if (l_tccp0->cblksty != l_tccp1->cblksty) {\n        return OPJ_FALSE;\n    }\n    if (l_tccp0->qmfbid != l_tccp1->qmfbid) {\n        return OPJ_FALSE;\n    }\n    if ((l_tccp0->csty & J2K_CCP_CSTY_PRT) != (l_tccp1->csty & J2K_CCP_CSTY_PRT)) {\n        return OPJ_FALSE;\n    }\n\n    for (i = 0U; i < l_tccp0->numresolutions; ++i) {\n        if (l_tccp0->prcw[i] != l_tccp1->prcw[i]) {\n            return OPJ_FALSE;\n        }\n        if (l_tccp0->prch[i] != l_tccp1->prch[i]) {\n            return OPJ_FALSE;\n        }\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no,\n        OPJ_UINT32 p_comp_no,\n        OPJ_BYTE * p_data,\n        OPJ_UINT32 * p_header_size,\n        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 i;\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_header_size != 00);\n    assert(p_manager != 00);\n    assert(p_data != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp = &l_tcp->tccps[p_comp_no];\n\n    /* preconditions again */\n    assert(p_tile_no < (l_cp->tw * l_cp->th));\n    assert(p_comp_no < (p_j2k->m_private_image->numcomps));\n\n    if (*p_header_size < 5) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error writing SPCod SPCoc element\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_write_bytes(p_data, l_tccp->numresolutions - 1, 1); /* SPcoc (D) */\n    ++p_data;\n\n    opj_write_bytes(p_data, l_tccp->cblkw - 2, 1);                  /* SPcoc (E) */\n    ++p_data;\n\n    opj_write_bytes(p_data, l_tccp->cblkh - 2, 1);                  /* SPcoc (F) */\n    ++p_data;\n\n    opj_write_bytes(p_data, l_tccp->cblksty,\n                    1);                            /* SPcoc (G) */\n    ++p_data;\n\n    opj_write_bytes(p_data, l_tccp->qmfbid,\n                    1);                             /* SPcoc (H) */\n    ++p_data;\n\n    *p_header_size = *p_header_size - 5;\n\n    if (l_tccp->csty & J2K_CCP_CSTY_PRT) {\n\n        if (*p_header_size < l_tccp->numresolutions) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error writing SPCod SPCoc element\\n\");\n            return OPJ_FALSE;\n        }\n\n        for (i = 0; i < l_tccp->numresolutions; ++i) {\n            opj_write_bytes(p_data, l_tccp->prcw[i] + (l_tccp->prch[i] << 4),\n                            1);   /* SPcoc (I_i) */\n            ++p_data;\n        }\n\n        *p_header_size = *p_header_size - l_tccp->numresolutions;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 compno,\n        OPJ_BYTE * p_header_data,\n        OPJ_UINT32 * p_header_size,\n        opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i, l_tmp;\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n    opj_tccp_t *l_tccp = NULL;\n    OPJ_BYTE * l_current_ptr = NULL;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_header_data != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    /* precondition again */\n    assert(compno < p_j2k->m_private_image->numcomps);\n\n    l_tccp = &l_tcp->tccps[compno];\n    l_current_ptr = p_header_data;\n\n    /* make sure room is sufficient */\n    if (*p_header_size < 5) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(l_current_ptr, &l_tccp->numresolutions,\n                   1);              /* SPcox (D) */\n    ++l_tccp->numresolutions;                                                                               /* tccp->numresolutions = read() + 1 */\n    if (l_tccp->numresolutions > OPJ_J2K_MAXRLVLS) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\\n\",\n                      l_tccp->numresolutions, OPJ_J2K_MAXRLVLS);\n        return OPJ_FALSE;\n    }\n    ++l_current_ptr;\n\n    /* If user wants to remove more resolutions than the codestream contains, return error */\n    if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error decoding component %d.\\nThe number of resolutions to remove is higher than the number \"\n                      \"of resolutions of this component\\nModify the cp_reduce parameter.\\n\\n\",\n                      compno);\n        p_j2k->m_specific_param.m_decoder.m_state |=\n            0x8000;/* FIXME J2K_DEC_STATE_ERR;*/\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(l_current_ptr, &l_tccp->cblkw, 1);               /* SPcoc (E) */\n    ++l_current_ptr;\n    l_tccp->cblkw += 2;\n\n    opj_read_bytes(l_current_ptr, &l_tccp->cblkh, 1);               /* SPcoc (F) */\n    ++l_current_ptr;\n    l_tccp->cblkh += 2;\n\n    if ((l_tccp->cblkw > 10) || (l_tccp->cblkh > 10) ||\n            ((l_tccp->cblkw + l_tccp->cblkh) > 12)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\\n\");\n        return OPJ_FALSE;\n    }\n\n\n    opj_read_bytes(l_current_ptr, &l_tccp->cblksty, 1);             /* SPcoc (G) */\n    ++l_current_ptr;\n    if (l_tccp->cblksty & 0xC0U) { /* 2 msb are reserved, assume we can't read */\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error reading SPCod SPCoc element, Invalid code-block style found\\n\");\n        return OPJ_FALSE;\n    }\n\n    opj_read_bytes(l_current_ptr, &l_tccp->qmfbid, 1);              /* SPcoc (H) */\n    ++l_current_ptr;\n\n    *p_header_size = *p_header_size - 5;\n\n    /* use custom precinct size ? */\n    if (l_tccp->csty & J2K_CCP_CSTY_PRT) {\n        if (*p_header_size < l_tccp->numresolutions) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element\\n\");\n            return OPJ_FALSE;\n        }\n\n        for (i = 0; i < l_tccp->numresolutions; ++i) {\n            opj_read_bytes(l_current_ptr, &l_tmp, 1);               /* SPcoc (I_i) */\n            ++l_current_ptr;\n            /* Precinct exponent 0 is only allowed for lowest resolution level (Table A.21) */\n            if ((i != 0) && (((l_tmp & 0xf) == 0) || ((l_tmp >> 4) == 0))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Invalid precinct size\\n\");\n                return OPJ_FALSE;\n            }\n            l_tccp->prcw[i] = l_tmp & 0xf;\n            l_tccp->prch[i] = l_tmp >> 4;\n        }\n\n        *p_header_size = *p_header_size - l_tccp->numresolutions;\n    } else {\n        /* set default size for the precinct width and height */\n        for (i = 0; i < l_tccp->numresolutions; ++i) {\n            l_tccp->prcw[i] = 15;\n            l_tccp->prch[i] = 15;\n        }\n    }\n\n#ifdef WIP_REMOVE_MSD\n    /* INDEX >> */\n    if (p_j2k->cstr_info && compno == 0) {\n        OPJ_UINT32 l_data_size = l_tccp->numresolutions * sizeof(OPJ_UINT32);\n\n        p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkh =\n            l_tccp->cblkh;\n        p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkw =\n            l_tccp->cblkw;\n        p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].numresolutions\n            = l_tccp->numresolutions;\n        p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblksty =\n            l_tccp->cblksty;\n        p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].qmfbid =\n            l_tccp->qmfbid;\n\n        memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdx, l_tccp->prcw,\n               l_data_size);\n        memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdy, l_tccp->prch,\n               l_data_size);\n    }\n    /* << INDEX */\n#endif\n\n    return OPJ_TRUE;\n}\n\nstatic void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k)\n{\n    /* loop */\n    OPJ_UINT32 i;\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n    opj_tccp_t *l_ref_tccp = NULL, *l_copied_tccp = NULL;\n    OPJ_UINT32 l_prc_size;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH)\n            ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    l_ref_tccp = &l_tcp->tccps[0];\n    l_copied_tccp = l_ref_tccp + 1;\n    l_prc_size = l_ref_tccp->numresolutions * (OPJ_UINT32)sizeof(OPJ_UINT32);\n\n    for (i = 1; i < p_j2k->m_private_image->numcomps; ++i) {\n        l_copied_tccp->numresolutions = l_ref_tccp->numresolutions;\n        l_copied_tccp->cblkw = l_ref_tccp->cblkw;\n        l_copied_tccp->cblkh = l_ref_tccp->cblkh;\n        l_copied_tccp->cblksty = l_ref_tccp->cblksty;\n        l_copied_tccp->qmfbid = l_ref_tccp->qmfbid;\n        memcpy(l_copied_tccp->prcw, l_ref_tccp->prcw, l_prc_size);\n        memcpy(l_copied_tccp->prch, l_ref_tccp->prch, l_prc_size);\n        ++l_copied_tccp;\n    }\n}\n\nstatic OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no,\n        OPJ_UINT32 p_comp_no)\n{\n    OPJ_UINT32 l_num_bands;\n\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp = &l_tcp->tccps[p_comp_no];\n\n    /* preconditions again */\n    assert(p_tile_no < l_cp->tw * l_cp->th);\n    assert(p_comp_no < p_j2k->m_private_image->numcomps);\n\n    l_num_bands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 :\n                  (l_tccp->numresolutions * 3 - 2);\n\n    if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT)  {\n        return 1 + l_num_bands;\n    } else {\n        return 1 + 2 * l_num_bands;\n    }\n}\n\nstatic OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k,\n        OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n    opj_tccp_t *l_tccp0 = NULL;\n    opj_tccp_t *l_tccp1 = NULL;\n    OPJ_UINT32 l_band_no, l_num_bands;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp0 = &l_tcp->tccps[p_first_comp_no];\n    l_tccp1 = &l_tcp->tccps[p_second_comp_no];\n\n    if (l_tccp0->qntsty != l_tccp1->qntsty) {\n        return OPJ_FALSE;\n    }\n    if (l_tccp0->numgbits != l_tccp1->numgbits) {\n        return OPJ_FALSE;\n    }\n    if (l_tccp0->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n        l_num_bands = 1U;\n    } else {\n        l_num_bands = l_tccp0->numresolutions * 3U - 2U;\n        if (l_num_bands != (l_tccp1->numresolutions * 3U - 2U)) {\n            return OPJ_FALSE;\n        }\n    }\n\n    for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n        if (l_tccp0->stepsizes[l_band_no].expn != l_tccp1->stepsizes[l_band_no].expn) {\n            return OPJ_FALSE;\n        }\n    }\n    if (l_tccp0->qntsty != J2K_CCP_QNTSTY_NOQNT) {\n        for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n            if (l_tccp0->stepsizes[l_band_no].mant != l_tccp1->stepsizes[l_band_no].mant) {\n                return OPJ_FALSE;\n            }\n        }\n    }\n    return OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 p_tile_no,\n                                        OPJ_UINT32 p_comp_no,\n                                        OPJ_BYTE * p_data,\n                                        OPJ_UINT32 * p_header_size,\n                                        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 l_header_size;\n    OPJ_UINT32 l_band_no, l_num_bands;\n    OPJ_UINT32 l_expn, l_mant;\n\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_header_size != 00);\n    assert(p_manager != 00);\n    assert(p_data != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = &l_cp->tcps[p_tile_no];\n    l_tccp = &l_tcp->tccps[p_comp_no];\n\n    /* preconditions again */\n    assert(p_tile_no < l_cp->tw * l_cp->th);\n    assert(p_comp_no < p_j2k->m_private_image->numcomps);\n\n    l_num_bands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 :\n                  (l_tccp->numresolutions * 3 - 2);\n\n    if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT)  {\n        l_header_size = 1 + l_num_bands;\n\n        if (*p_header_size < l_header_size) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error writing SQcd SQcc element\\n\");\n            return OPJ_FALSE;\n        }\n\n        opj_write_bytes(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5),\n                        1);   /* Sqcx */\n        ++p_data;\n\n        for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n            l_expn = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].expn;\n            opj_write_bytes(p_data, l_expn << 3, 1);        /* SPqcx_i */\n            ++p_data;\n        }\n    } else {\n        l_header_size = 1 + 2 * l_num_bands;\n\n        if (*p_header_size < l_header_size) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Error writing SQcd SQcc element\\n\");\n            return OPJ_FALSE;\n        }\n\n        opj_write_bytes(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5),\n                        1);   /* Sqcx */\n        ++p_data;\n\n        for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n            l_expn = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].expn;\n            l_mant = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].mant;\n\n            opj_write_bytes(p_data, (l_expn << 11) + l_mant, 2);    /* SPqcx_i */\n            p_data += 2;\n        }\n    }\n\n    *p_header_size = *p_header_size - l_header_size;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k,\n                                       OPJ_UINT32 p_comp_no,\n                                       OPJ_BYTE* p_header_data,\n                                       OPJ_UINT32 * p_header_size,\n                                       opj_event_mgr_t * p_manager\n                                      )\n{\n    /* loop*/\n    OPJ_UINT32 l_band_no;\n    opj_cp_t *l_cp = 00;\n    opj_tcp_t *l_tcp = 00;\n    opj_tccp_t *l_tccp = 00;\n    OPJ_BYTE * l_current_ptr = 00;\n    OPJ_UINT32 l_tmp, l_num_band;\n\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_header_data != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    /* come from tile part header or main header ?*/\n    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH)\n            ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    /* precondition again*/\n    assert(p_comp_no <  p_j2k->m_private_image->numcomps);\n\n    l_tccp = &l_tcp->tccps[p_comp_no];\n    l_current_ptr = p_header_data;\n\n    if (*p_header_size < 1) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Error reading SQcd or SQcc element\\n\");\n        return OPJ_FALSE;\n    }\n    *p_header_size -= 1;\n\n    opj_read_bytes(l_current_ptr, &l_tmp, 1);                       /* Sqcx */\n    ++l_current_ptr;\n\n    l_tccp->qntsty = l_tmp & 0x1f;\n    l_tccp->numgbits = l_tmp >> 5;\n    if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n        l_num_band = 1;\n    } else {\n        l_num_band = (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) ?\n                     (*p_header_size) :\n                     (*p_header_size) / 2;\n\n        if (l_num_band > OPJ_J2K_MAXBANDS) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"While reading CCP_QNTSTY element inside QCD or QCC marker segment, \"\n                          \"number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to \"\n                          \"OPJ_J2K_MAXBANDS (%d) and skip the rest. \\n\", l_num_band, OPJ_J2K_MAXBANDS,\n                          OPJ_J2K_MAXBANDS);\n            /*return OPJ_FALSE;*/\n        }\n    }\n\n#ifdef USE_JPWL\n    if (l_cp->correct) {\n\n        /* if JPWL is on, we check whether there are too many subbands */\n        if (/*(l_num_band < 0) ||*/ (l_num_band >= OPJ_J2K_MAXBANDS)) {\n            opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                          \"JPWL: bad number of subbands in Sqcx (%d)\\n\",\n                          l_num_band);\n            if (!JPWL_ASSUME) {\n                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                return OPJ_FALSE;\n            }\n            /* we try to correct */\n            l_num_band = 1;\n            opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust them\\n\"\n                          \"- setting number of bands to %d => HYPOTHESIS!!!\\n\",\n                          l_num_band);\n        };\n\n    };\n#endif /* USE_JPWL */\n\n    if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {\n        for (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {\n            opj_read_bytes(l_current_ptr, &l_tmp, 1);                       /* SPqcx_i */\n            ++l_current_ptr;\n            if (l_band_no < OPJ_J2K_MAXBANDS) {\n                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 3);\n                l_tccp->stepsizes[l_band_no].mant = 0;\n            }\n        }\n        *p_header_size = *p_header_size - l_num_band;\n    } else {\n        for (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {\n            opj_read_bytes(l_current_ptr, &l_tmp, 2);                       /* SPqcx_i */\n            l_current_ptr += 2;\n            if (l_band_no < OPJ_J2K_MAXBANDS) {\n                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 11);\n                l_tccp->stepsizes[l_band_no].mant = l_tmp & 0x7ff;\n            }\n        }\n        *p_header_size = *p_header_size - 2 * l_num_band;\n    }\n\n    /* Add Antonin : if scalar_derived -> compute other stepsizes */\n    if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n        for (l_band_no = 1; l_band_no < OPJ_J2K_MAXBANDS; l_band_no++) {\n            l_tccp->stepsizes[l_band_no].expn =\n                ((OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) > 0)\n                ?\n                (OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) : 0;\n            l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;\n        }\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k)\n{\n    OPJ_UINT32 i;\n    opj_cp_t *l_cp = NULL;\n    opj_tcp_t *l_tcp = NULL;\n    opj_tccp_t *l_ref_tccp = NULL;\n    opj_tccp_t *l_copied_tccp = NULL;\n    OPJ_UINT32 l_size;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n            &l_cp->tcps[p_j2k->m_current_tile_number] :\n            p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    l_ref_tccp = &l_tcp->tccps[0];\n    l_copied_tccp = l_ref_tccp + 1;\n    l_size = OPJ_J2K_MAXBANDS * sizeof(opj_stepsize_t);\n\n    for (i = 1; i < p_j2k->m_private_image->numcomps; ++i) {\n        l_copied_tccp->qntsty = l_ref_tccp->qntsty;\n        l_copied_tccp->numgbits = l_ref_tccp->numgbits;\n        memcpy(l_copied_tccp->stepsizes, l_ref_tccp->stepsizes, l_size);\n        ++l_copied_tccp;\n    }\n}\n\nstatic void opj_j2k_dump_tile_info(opj_tcp_t * l_default_tile,\n                                   OPJ_INT32 numcomps, FILE* out_stream)\n{\n    if (l_default_tile) {\n        OPJ_INT32 compno;\n\n        fprintf(out_stream, \"\\t default tile {\\n\");\n        fprintf(out_stream, \"\\t\\t csty=%#x\\n\", l_default_tile->csty);\n        fprintf(out_stream, \"\\t\\t prg=%#x\\n\", l_default_tile->prg);\n        fprintf(out_stream, \"\\t\\t numlayers=%d\\n\", l_default_tile->numlayers);\n        fprintf(out_stream, \"\\t\\t mct=%x\\n\", l_default_tile->mct);\n\n        for (compno = 0; compno < numcomps; compno++) {\n            opj_tccp_t *l_tccp = &(l_default_tile->tccps[compno]);\n            OPJ_UINT32 resno;\n            OPJ_INT32 bandno, numbands;\n\n            /* coding style*/\n            fprintf(out_stream, \"\\t\\t comp %d {\\n\", compno);\n            fprintf(out_stream, \"\\t\\t\\t csty=%#x\\n\", l_tccp->csty);\n            fprintf(out_stream, \"\\t\\t\\t numresolutions=%d\\n\", l_tccp->numresolutions);\n            fprintf(out_stream, \"\\t\\t\\t cblkw=2^%d\\n\", l_tccp->cblkw);\n            fprintf(out_stream, \"\\t\\t\\t cblkh=2^%d\\n\", l_tccp->cblkh);\n            fprintf(out_stream, \"\\t\\t\\t cblksty=%#x\\n\", l_tccp->cblksty);\n            fprintf(out_stream, \"\\t\\t\\t qmfbid=%d\\n\", l_tccp->qmfbid);\n\n            fprintf(out_stream, \"\\t\\t\\t preccintsize (w,h)=\");\n            for (resno = 0; resno < l_tccp->numresolutions; resno++) {\n                fprintf(out_stream, \"(%d,%d) \", l_tccp->prcw[resno], l_tccp->prch[resno]);\n            }\n            fprintf(out_stream, \"\\n\");\n\n            /* quantization style*/\n            fprintf(out_stream, \"\\t\\t\\t qntsty=%d\\n\", l_tccp->qntsty);\n            fprintf(out_stream, \"\\t\\t\\t numgbits=%d\\n\", l_tccp->numgbits);\n            fprintf(out_stream, \"\\t\\t\\t stepsizes (m,e)=\");\n            numbands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 :\n                       (OPJ_INT32)l_tccp->numresolutions * 3 - 2;\n            for (bandno = 0; bandno < numbands; bandno++) {\n                fprintf(out_stream, \"(%d,%d) \", l_tccp->stepsizes[bandno].mant,\n                        l_tccp->stepsizes[bandno].expn);\n            }\n            fprintf(out_stream, \"\\n\");\n\n            /* RGN value*/\n            fprintf(out_stream, \"\\t\\t\\t roishift=%d\\n\", l_tccp->roishift);\n\n            fprintf(out_stream, \"\\t\\t }\\n\");\n        } /*end of component of default tile*/\n        fprintf(out_stream, \"\\t }\\n\"); /*end of default tile*/\n    }\n}\n\nvoid j2k_dump(opj_j2k_t* p_j2k, OPJ_INT32 flag, FILE* out_stream)\n{\n    /* Check if the flag is compatible with j2k file*/\n    if ((flag & OPJ_JP2_INFO) || (flag & OPJ_JP2_IND)) {\n        fprintf(out_stream, \"Wrong flag\\n\");\n        return;\n    }\n\n    /* Dump the image_header */\n    if (flag & OPJ_IMG_INFO) {\n        if (p_j2k->m_private_image) {\n            j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);\n        }\n    }\n\n    /* Dump the codestream info from main header */\n    if (flag & OPJ_J2K_MH_INFO) {\n        if (p_j2k->m_private_image) {\n            opj_j2k_dump_MH_info(p_j2k, out_stream);\n        }\n    }\n    /* Dump all tile/codestream info */\n    if (flag & OPJ_J2K_TCH_INFO) {\n        OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n        OPJ_UINT32 i;\n        opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;\n        if (p_j2k->m_private_image) {\n            for (i = 0; i < l_nb_tiles; ++i) {\n                opj_j2k_dump_tile_info(l_tcp, (OPJ_INT32)p_j2k->m_private_image->numcomps,\n                                       out_stream);\n                ++l_tcp;\n            }\n        }\n    }\n\n    /* Dump the codestream info of the current tile */\n    if (flag & OPJ_J2K_TH_INFO) {\n\n    }\n\n    /* Dump the codestream index from main header */\n    if (flag & OPJ_J2K_MH_IND) {\n        opj_j2k_dump_MH_index(p_j2k, out_stream);\n    }\n\n    /* Dump the codestream index of the current tile */\n    if (flag & OPJ_J2K_TH_IND) {\n\n    }\n\n}\n\nstatic void opj_j2k_dump_MH_index(opj_j2k_t* p_j2k, FILE* out_stream)\n{\n    opj_codestream_index_t* cstr_index = p_j2k->cstr_index;\n    OPJ_UINT32 it_marker, it_tile, it_tile_part;\n\n    fprintf(out_stream, \"Codestream index from main header: {\\n\");\n\n    fprintf(out_stream, \"\\t Main header start position=%\" PRIi64 \"\\n\"\n            \"\\t Main header end position=%\" PRIi64 \"\\n\",\n            cstr_index->main_head_start, cstr_index->main_head_end);\n\n    fprintf(out_stream, \"\\t Marker list: {\\n\");\n\n    if (cstr_index->marker) {\n        for (it_marker = 0; it_marker < cstr_index->marknum ; it_marker++) {\n            fprintf(out_stream, \"\\t\\t type=%#x, pos=%\" PRIi64 \", len=%d\\n\",\n                    cstr_index->marker[it_marker].type,\n                    cstr_index->marker[it_marker].pos,\n                    cstr_index->marker[it_marker].len);\n        }\n    }\n\n    fprintf(out_stream, \"\\t }\\n\");\n\n    if (cstr_index->tile_index) {\n\n        /* Simple test to avoid to write empty information*/\n        OPJ_UINT32 l_acc_nb_of_tile_part = 0;\n        for (it_tile = 0; it_tile < cstr_index->nb_of_tiles ; it_tile++) {\n            l_acc_nb_of_tile_part += cstr_index->tile_index[it_tile].nb_tps;\n        }\n\n        if (l_acc_nb_of_tile_part) {\n            fprintf(out_stream, \"\\t Tile index: {\\n\");\n\n            for (it_tile = 0; it_tile < cstr_index->nb_of_tiles ; it_tile++) {\n                OPJ_UINT32 nb_of_tile_part = cstr_index->tile_index[it_tile].nb_tps;\n\n                fprintf(out_stream, \"\\t\\t nb of tile-part in tile [%d]=%d\\n\", it_tile,\n                        nb_of_tile_part);\n\n                if (cstr_index->tile_index[it_tile].tp_index) {\n                    for (it_tile_part = 0; it_tile_part < nb_of_tile_part; it_tile_part++) {\n                        fprintf(out_stream, \"\\t\\t\\t tile-part[%d]: star_pos=%\" PRIi64 \", end_header=%\"\n                                PRIi64 \", end_pos=%\" PRIi64 \".\\n\",\n                                it_tile_part,\n                                cstr_index->tile_index[it_tile].tp_index[it_tile_part].start_pos,\n                                cstr_index->tile_index[it_tile].tp_index[it_tile_part].end_header,\n                                cstr_index->tile_index[it_tile].tp_index[it_tile_part].end_pos);\n                    }\n                }\n\n                if (cstr_index->tile_index[it_tile].marker) {\n                    for (it_marker = 0; it_marker < cstr_index->tile_index[it_tile].marknum ;\n                            it_marker++) {\n                        fprintf(out_stream, \"\\t\\t type=%#x, pos=%\" PRIi64 \", len=%d\\n\",\n                                cstr_index->tile_index[it_tile].marker[it_marker].type,\n                                cstr_index->tile_index[it_tile].marker[it_marker].pos,\n                                cstr_index->tile_index[it_tile].marker[it_marker].len);\n                    }\n                }\n            }\n            fprintf(out_stream, \"\\t }\\n\");\n        }\n    }\n\n    fprintf(out_stream, \"}\\n\");\n\n}\n\n\nstatic void opj_j2k_dump_MH_info(opj_j2k_t* p_j2k, FILE* out_stream)\n{\n\n    fprintf(out_stream, \"Codestream info from main header: {\\n\");\n\n    fprintf(out_stream, \"\\t tx0=%d, ty0=%d\\n\", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);\n    fprintf(out_stream, \"\\t tdx=%d, tdy=%d\\n\", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);\n    fprintf(out_stream, \"\\t tw=%d, th=%d\\n\", p_j2k->m_cp.tw, p_j2k->m_cp.th);\n    opj_j2k_dump_tile_info(p_j2k->m_specific_param.m_decoder.m_default_tcp,\n                           (OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);\n    fprintf(out_stream, \"}\\n\");\n}\n\nvoid j2k_dump_image_header(opj_image_t* img_header, OPJ_BOOL dev_dump_flag,\n                           FILE* out_stream)\n{\n    char tab[2];\n\n    if (dev_dump_flag) {\n        fprintf(stdout, \"[DEV] Dump an image_header struct {\\n\");\n        tab[0] = '\\0';\n    } else {\n        fprintf(out_stream, \"Image info {\\n\");\n        tab[0] = '\\t';\n        tab[1] = '\\0';\n    }\n\n    fprintf(out_stream, \"%s x0=%d, y0=%d\\n\", tab, img_header->x0, img_header->y0);\n    fprintf(out_stream,     \"%s x1=%d, y1=%d\\n\", tab, img_header->x1,\n            img_header->y1);\n    fprintf(out_stream, \"%s numcomps=%d\\n\", tab, img_header->numcomps);\n\n    if (img_header->comps) {\n        OPJ_UINT32 compno;\n        for (compno = 0; compno < img_header->numcomps; compno++) {\n            fprintf(out_stream, \"%s\\t component %d {\\n\", tab, compno);\n            j2k_dump_image_comp_header(&(img_header->comps[compno]), dev_dump_flag,\n                                       out_stream);\n            fprintf(out_stream, \"%s}\\n\", tab);\n        }\n    }\n\n    fprintf(out_stream, \"}\\n\");\n}\n\nvoid j2k_dump_image_comp_header(opj_image_comp_t* comp_header,\n                                OPJ_BOOL dev_dump_flag, FILE* out_stream)\n{\n    char tab[3];\n\n    if (dev_dump_flag) {\n        fprintf(stdout, \"[DEV] Dump an image_comp_header struct {\\n\");\n        tab[0] = '\\0';\n    }       else {\n        tab[0] = '\\t';\n        tab[1] = '\\t';\n        tab[2] = '\\0';\n    }\n\n    fprintf(out_stream, \"%s dx=%d, dy=%d\\n\", tab, comp_header->dx, comp_header->dy);\n    fprintf(out_stream, \"%s prec=%d\\n\", tab, comp_header->prec);\n    fprintf(out_stream, \"%s sgnd=%d\\n\", tab, comp_header->sgnd);\n\n    if (dev_dump_flag) {\n        fprintf(out_stream, \"}\\n\");\n    }\n}\n\nopj_codestream_info_v2_t* j2k_get_cstr_info(opj_j2k_t* p_j2k)\n{\n    OPJ_UINT32 compno;\n    OPJ_UINT32 numcomps = p_j2k->m_private_image->numcomps;\n    opj_tcp_t *l_default_tile;\n    opj_codestream_info_v2_t* cstr_info = (opj_codestream_info_v2_t*) opj_calloc(1,\n                                          sizeof(opj_codestream_info_v2_t));\n    if (!cstr_info) {\n        return NULL;\n    }\n\n    cstr_info->nbcomps = p_j2k->m_private_image->numcomps;\n\n    cstr_info->tx0 = p_j2k->m_cp.tx0;\n    cstr_info->ty0 = p_j2k->m_cp.ty0;\n    cstr_info->tdx = p_j2k->m_cp.tdx;\n    cstr_info->tdy = p_j2k->m_cp.tdy;\n    cstr_info->tw = p_j2k->m_cp.tw;\n    cstr_info->th = p_j2k->m_cp.th;\n\n    cstr_info->tile_info = NULL; /* Not fill from the main header*/\n\n    l_default_tile = p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n    cstr_info->m_default_tile_info.csty = l_default_tile->csty;\n    cstr_info->m_default_tile_info.prg = l_default_tile->prg;\n    cstr_info->m_default_tile_info.numlayers = l_default_tile->numlayers;\n    cstr_info->m_default_tile_info.mct = l_default_tile->mct;\n\n    cstr_info->m_default_tile_info.tccp_info = (opj_tccp_info_t*) opj_calloc(\n                cstr_info->nbcomps, sizeof(opj_tccp_info_t));\n    if (!cstr_info->m_default_tile_info.tccp_info) {\n        opj_destroy_cstr_info(&cstr_info);\n        return NULL;\n    }\n\n    for (compno = 0; compno < numcomps; compno++) {\n        opj_tccp_t *l_tccp = &(l_default_tile->tccps[compno]);\n        opj_tccp_info_t *l_tccp_info = &\n                                       (cstr_info->m_default_tile_info.tccp_info[compno]);\n        OPJ_INT32 bandno, numbands;\n\n        /* coding style*/\n        l_tccp_info->csty = l_tccp->csty;\n        l_tccp_info->numresolutions = l_tccp->numresolutions;\n        l_tccp_info->cblkw = l_tccp->cblkw;\n        l_tccp_info->cblkh = l_tccp->cblkh;\n        l_tccp_info->cblksty = l_tccp->cblksty;\n        l_tccp_info->qmfbid = l_tccp->qmfbid;\n        if (l_tccp->numresolutions < OPJ_J2K_MAXRLVLS) {\n            memcpy(l_tccp_info->prch, l_tccp->prch, l_tccp->numresolutions);\n            memcpy(l_tccp_info->prcw, l_tccp->prcw, l_tccp->numresolutions);\n        }\n\n        /* quantization style*/\n        l_tccp_info->qntsty = l_tccp->qntsty;\n        l_tccp_info->numgbits = l_tccp->numgbits;\n\n        numbands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 :\n                   (OPJ_INT32)l_tccp->numresolutions * 3 - 2;\n        if (numbands < OPJ_J2K_MAXBANDS) {\n            for (bandno = 0; bandno < numbands; bandno++) {\n                l_tccp_info->stepsizes_mant[bandno] = (OPJ_UINT32)\n                                                      l_tccp->stepsizes[bandno].mant;\n                l_tccp_info->stepsizes_expn[bandno] = (OPJ_UINT32)\n                                                      l_tccp->stepsizes[bandno].expn;\n            }\n        }\n\n        /* RGN value*/\n        l_tccp_info->roishift = l_tccp->roishift;\n    }\n\n    return cstr_info;\n}\n\nopj_codestream_index_t* j2k_get_cstr_index(opj_j2k_t* p_j2k)\n{\n    opj_codestream_index_t* l_cstr_index = (opj_codestream_index_t*)\n                                           opj_calloc(1, sizeof(opj_codestream_index_t));\n    if (!l_cstr_index) {\n        return NULL;\n    }\n\n    l_cstr_index->main_head_start = p_j2k->cstr_index->main_head_start;\n    l_cstr_index->main_head_end = p_j2k->cstr_index->main_head_end;\n    l_cstr_index->codestream_size = p_j2k->cstr_index->codestream_size;\n\n    l_cstr_index->marknum = p_j2k->cstr_index->marknum;\n    l_cstr_index->marker = (opj_marker_info_t*)opj_malloc(l_cstr_index->marknum *\n                           sizeof(opj_marker_info_t));\n    if (!l_cstr_index->marker) {\n        opj_free(l_cstr_index);\n        return NULL;\n    }\n\n    if (p_j2k->cstr_index->marker) {\n        memcpy(l_cstr_index->marker, p_j2k->cstr_index->marker,\n               l_cstr_index->marknum * sizeof(opj_marker_info_t));\n    } else {\n        opj_free(l_cstr_index->marker);\n        l_cstr_index->marker = NULL;\n    }\n\n    l_cstr_index->nb_of_tiles = p_j2k->cstr_index->nb_of_tiles;\n    l_cstr_index->tile_index = (opj_tile_index_t*)opj_calloc(\n                                   l_cstr_index->nb_of_tiles, sizeof(opj_tile_index_t));\n    if (!l_cstr_index->tile_index) {\n        opj_free(l_cstr_index->marker);\n        opj_free(l_cstr_index);\n        return NULL;\n    }\n\n    if (!p_j2k->cstr_index->tile_index) {\n        opj_free(l_cstr_index->tile_index);\n        l_cstr_index->tile_index = NULL;\n    } else {\n        OPJ_UINT32 it_tile = 0;\n        for (it_tile = 0; it_tile < l_cstr_index->nb_of_tiles; it_tile++) {\n\n            /* Tile Marker*/\n            l_cstr_index->tile_index[it_tile].marknum =\n                p_j2k->cstr_index->tile_index[it_tile].marknum;\n\n            l_cstr_index->tile_index[it_tile].marker =\n                (opj_marker_info_t*)opj_malloc(l_cstr_index->tile_index[it_tile].marknum *\n                                               sizeof(opj_marker_info_t));\n\n            if (!l_cstr_index->tile_index[it_tile].marker) {\n                OPJ_UINT32 it_tile_free;\n\n                for (it_tile_free = 0; it_tile_free < it_tile; it_tile_free++) {\n                    opj_free(l_cstr_index->tile_index[it_tile_free].marker);\n                }\n\n                opj_free(l_cstr_index->tile_index);\n                opj_free(l_cstr_index->marker);\n                opj_free(l_cstr_index);\n                return NULL;\n            }\n\n            if (p_j2k->cstr_index->tile_index[it_tile].marker)\n                memcpy(l_cstr_index->tile_index[it_tile].marker,\n                       p_j2k->cstr_index->tile_index[it_tile].marker,\n                       l_cstr_index->tile_index[it_tile].marknum * sizeof(opj_marker_info_t));\n            else {\n                opj_free(l_cstr_index->tile_index[it_tile].marker);\n                l_cstr_index->tile_index[it_tile].marker = NULL;\n            }\n\n            /* Tile part index*/\n            l_cstr_index->tile_index[it_tile].nb_tps =\n                p_j2k->cstr_index->tile_index[it_tile].nb_tps;\n\n            l_cstr_index->tile_index[it_tile].tp_index =\n                (opj_tp_index_t*)opj_malloc(l_cstr_index->tile_index[it_tile].nb_tps * sizeof(\n                                                opj_tp_index_t));\n\n            if (!l_cstr_index->tile_index[it_tile].tp_index) {\n                OPJ_UINT32 it_tile_free;\n\n                for (it_tile_free = 0; it_tile_free < it_tile; it_tile_free++) {\n                    opj_free(l_cstr_index->tile_index[it_tile_free].marker);\n                    opj_free(l_cstr_index->tile_index[it_tile_free].tp_index);\n                }\n\n                opj_free(l_cstr_index->tile_index);\n                opj_free(l_cstr_index->marker);\n                opj_free(l_cstr_index);\n                return NULL;\n            }\n\n            if (p_j2k->cstr_index->tile_index[it_tile].tp_index) {\n                memcpy(l_cstr_index->tile_index[it_tile].tp_index,\n                       p_j2k->cstr_index->tile_index[it_tile].tp_index,\n                       l_cstr_index->tile_index[it_tile].nb_tps * sizeof(opj_tp_index_t));\n            } else {\n                opj_free(l_cstr_index->tile_index[it_tile].tp_index);\n                l_cstr_index->tile_index[it_tile].tp_index = NULL;\n            }\n\n            /* Packet index (NOT USED)*/\n            l_cstr_index->tile_index[it_tile].nb_packet = 0;\n            l_cstr_index->tile_index[it_tile].packet_index = NULL;\n\n        }\n    }\n\n    return l_cstr_index;\n}\n\nstatic OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k)\n{\n    OPJ_UINT32 it_tile = 0;\n\n    p_j2k->cstr_index->nb_of_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;\n    p_j2k->cstr_index->tile_index = (opj_tile_index_t*)opj_calloc(\n                                        p_j2k->cstr_index->nb_of_tiles, sizeof(opj_tile_index_t));\n    if (!p_j2k->cstr_index->tile_index) {\n        return OPJ_FALSE;\n    }\n\n    for (it_tile = 0; it_tile < p_j2k->cstr_index->nb_of_tiles; it_tile++) {\n        p_j2k->cstr_index->tile_index[it_tile].maxmarknum = 100;\n        p_j2k->cstr_index->tile_index[it_tile].marknum = 0;\n        p_j2k->cstr_index->tile_index[it_tile].marker = (opj_marker_info_t*)\n                opj_calloc(p_j2k->cstr_index->tile_index[it_tile].maxmarknum,\n                           sizeof(opj_marker_info_t));\n        if (!p_j2k->cstr_index->tile_index[it_tile].marker) {\n            return OPJ_FALSE;\n        }\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k,\n                                     opj_stream_private_t *p_stream,\n                                     opj_event_mgr_t * p_manager)\n{\n    OPJ_BOOL l_go_on = OPJ_TRUE;\n    OPJ_UINT32 l_current_tile_no;\n    OPJ_UINT32 l_data_size, l_max_data_size;\n    OPJ_INT32 l_tile_x0, l_tile_y0, l_tile_x1, l_tile_y1;\n    OPJ_UINT32 l_nb_comps;\n    OPJ_BYTE * l_current_data;\n    OPJ_UINT32 nr_tiles = 0;\n\n    /* Particular case for whole single tile decoding */\n    /* We can avoid allocating intermediate tile buffers */\n    if (p_j2k->m_cp.tw == 1 && p_j2k->m_cp.th == 1 &&\n            p_j2k->m_cp.tx0 == 0 && p_j2k->m_cp.ty0 == 0 &&\n            p_j2k->m_output_image->x0 == 0 &&\n            p_j2k->m_output_image->y0 == 0 &&\n            p_j2k->m_output_image->x1 == p_j2k->m_cp.tdx &&\n            p_j2k->m_output_image->y1 == p_j2k->m_cp.tdy &&\n            p_j2k->m_output_image->comps[0].factor == 0) {\n        OPJ_UINT32 i;\n        if (! opj_j2k_read_tile_header(p_j2k,\n                                       &l_current_tile_no,\n                                       &l_data_size,\n                                       &l_tile_x0, &l_tile_y0,\n                                       &l_tile_x1, &l_tile_y1,\n                                       &l_nb_comps,\n                                       &l_go_on,\n                                       p_stream,\n                                       p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        if (! opj_j2k_decode_tile(p_j2k, l_current_tile_no, NULL, 0,\n                                  p_stream, p_manager)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Failed to decode tile 1/1\\n\");\n            return OPJ_FALSE;\n        }\n\n        /* Transfer TCD data to output image data */\n        for (i = 0; i < p_j2k->m_output_image->numcomps; i++) {\n            opj_image_data_free(p_j2k->m_output_image->comps[i].data);\n            p_j2k->m_output_image->comps[i].data =\n                p_j2k->m_tcd->tcd_image->tiles->comps[i].data;\n            p_j2k->m_output_image->comps[i].resno_decoded =\n                p_j2k->m_tcd->image->comps[i].resno_decoded;\n            p_j2k->m_tcd->tcd_image->tiles->comps[i].data = NULL;\n        }\n\n        return OPJ_TRUE;\n    }\n\n    l_current_data = (OPJ_BYTE*)opj_malloc(1000);\n    if (! l_current_data) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tiles\\n\");\n        return OPJ_FALSE;\n    }\n    l_max_data_size = 1000;\n\n    for (;;) {\n        if (! opj_j2k_read_tile_header(p_j2k,\n                                       &l_current_tile_no,\n                                       &l_data_size,\n                                       &l_tile_x0, &l_tile_y0,\n                                       &l_tile_x1, &l_tile_y1,\n                                       &l_nb_comps,\n                                       &l_go_on,\n                                       p_stream,\n                                       p_manager)) {\n            opj_free(l_current_data);\n            return OPJ_FALSE;\n        }\n\n        if (! l_go_on) {\n            break;\n        }\n\n        if (l_data_size > l_max_data_size) {\n            OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data,\n                                           l_data_size);\n            if (! l_new_current_data) {\n                opj_free(l_current_data);\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tile %d/%d\\n\",\n                              l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n                return OPJ_FALSE;\n            }\n            l_current_data = l_new_current_data;\n            l_max_data_size = l_data_size;\n        }\n\n        if (! opj_j2k_decode_tile(p_j2k, l_current_tile_no, l_current_data, l_data_size,\n                                  p_stream, p_manager)) {\n            opj_free(l_current_data);\n            opj_event_msg(p_manager, EVT_ERROR, \"Failed to decode tile %d/%d\\n\",\n                          l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n            return OPJ_FALSE;\n        }\n        opj_event_msg(p_manager, EVT_INFO, \"Tile %d/%d has been decoded.\\n\",\n                      l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n\n        if (! opj_j2k_update_image_data(p_j2k->m_tcd, l_current_data,\n                                        p_j2k->m_output_image)) {\n            opj_free(l_current_data);\n            return OPJ_FALSE;\n        }\n        opj_event_msg(p_manager, EVT_INFO,\n                      \"Image data has been updated with tile %d.\\n\\n\", l_current_tile_no + 1);\n\n        if (opj_stream_get_number_byte_left(p_stream) == 0\n                && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC) {\n            break;\n        }\n        if (++nr_tiles ==  p_j2k->m_cp.th * p_j2k->m_cp.tw) {\n            break;\n        }\n    }\n\n    opj_free(l_current_data);\n\n    return OPJ_TRUE;\n}\n\n/**\n * Sets up the procedures to do on decoding data. Developpers wanting to extend the library can add their own reading procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_decoding(opj_j2k_t *p_j2k,\n                                       opj_event_mgr_t * p_manager)\n{\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_decode_tiles, p_manager)) {\n        return OPJ_FALSE;\n    }\n    /* DEVELOPER CORNER, add your custom procedures */\n\n    return OPJ_TRUE;\n}\n\n/*\n * Read and decode one tile.\n */\nstatic OPJ_BOOL opj_j2k_decode_one_tile(opj_j2k_t *p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager)\n{\n    OPJ_BOOL l_go_on = OPJ_TRUE;\n    OPJ_UINT32 l_current_tile_no;\n    OPJ_UINT32 l_tile_no_to_dec;\n    OPJ_UINT32 l_data_size, l_max_data_size;\n    OPJ_INT32 l_tile_x0, l_tile_y0, l_tile_x1, l_tile_y1;\n    OPJ_UINT32 l_nb_comps;\n    OPJ_BYTE * l_current_data;\n    OPJ_UINT32 l_nb_tiles;\n    OPJ_UINT32 i;\n\n    l_current_data = (OPJ_BYTE*)opj_malloc(1000);\n    if (! l_current_data) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode one tile\\n\");\n        return OPJ_FALSE;\n    }\n    l_max_data_size = 1000;\n\n    /*Allocate and initialize some elements of codestrem index if not already done*/\n    if (!p_j2k->cstr_index->tile_index) {\n        if (!opj_j2k_allocate_tile_element_cstr_index(p_j2k)) {\n            opj_free(l_current_data);\n            return OPJ_FALSE;\n        }\n    }\n    /* Move into the codestream to the first SOT used to decode the desired tile */\n    l_tile_no_to_dec = (OPJ_UINT32)\n                       p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;\n    if (p_j2k->cstr_index->tile_index)\n        if (p_j2k->cstr_index->tile_index->tp_index) {\n            if (! p_j2k->cstr_index->tile_index[l_tile_no_to_dec].nb_tps) {\n                /* the index for this tile has not been built,\n                 *  so move to the last SOT read */\n                if (!(opj_stream_read_seek(p_stream,\n                                           p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos + 2, p_manager))) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Problem with seek function\\n\");\n                    opj_free(l_current_data);\n                    return OPJ_FALSE;\n                }\n            } else {\n                if (!(opj_stream_read_seek(p_stream,\n                                           p_j2k->cstr_index->tile_index[l_tile_no_to_dec].tp_index[0].start_pos + 2,\n                                           p_manager))) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Problem with seek function\\n\");\n                    opj_free(l_current_data);\n                    return OPJ_FALSE;\n                }\n            }\n            /* Special case if we have previously read the EOC marker (if the previous tile getted is the last ) */\n            if (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_EOC) {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n            }\n        }\n\n    /* Reset current tile part number for all tiles, and not only the one */\n    /* of interest. */\n    /* Not completely sure this is always correct but required for */\n    /* ./build/bin/j2k_random_tile_access ./build/tests/tte1.j2k */\n    l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;\n    for (i = 0; i < l_nb_tiles; ++i) {\n        p_j2k->m_cp.tcps[i].m_current_tile_part_number = -1;\n    }\n\n    for (;;) {\n        if (! opj_j2k_read_tile_header(p_j2k,\n                                       &l_current_tile_no,\n                                       &l_data_size,\n                                       &l_tile_x0, &l_tile_y0,\n                                       &l_tile_x1, &l_tile_y1,\n                                       &l_nb_comps,\n                                       &l_go_on,\n                                       p_stream,\n                                       p_manager)) {\n            opj_free(l_current_data);\n            return OPJ_FALSE;\n        }\n\n        if (! l_go_on) {\n            break;\n        }\n\n        if (l_data_size > l_max_data_size) {\n            OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data,\n                                           l_data_size);\n            if (! l_new_current_data) {\n                opj_free(l_current_data);\n                l_current_data = NULL;\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tile %d/%d\\n\",\n                              l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n                return OPJ_FALSE;\n            }\n            l_current_data = l_new_current_data;\n            l_max_data_size = l_data_size;\n        }\n\n        if (! opj_j2k_decode_tile(p_j2k, l_current_tile_no, l_current_data, l_data_size,\n                                  p_stream, p_manager)) {\n            opj_free(l_current_data);\n            return OPJ_FALSE;\n        }\n        opj_event_msg(p_manager, EVT_INFO, \"Tile %d/%d has been decoded.\\n\",\n                      l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n\n        if (! opj_j2k_update_image_data(p_j2k->m_tcd, l_current_data,\n                                        p_j2k->m_output_image)) {\n            opj_free(l_current_data);\n            return OPJ_FALSE;\n        }\n        opj_event_msg(p_manager, EVT_INFO,\n                      \"Image data has been updated with tile %d.\\n\\n\", l_current_tile_no + 1);\n\n        if (l_current_tile_no == l_tile_no_to_dec) {\n            /* move into the codestream to the first SOT (FIXME or not move?)*/\n            if (!(opj_stream_read_seek(p_stream, p_j2k->cstr_index->main_head_end + 2,\n                                       p_manager))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Problem with seek function\\n\");\n                opj_free(l_current_data);\n                return OPJ_FALSE;\n            }\n            break;\n        } else {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"Tile read, decoded and updated is not the desired one (%d vs %d).\\n\",\n                          l_current_tile_no + 1, l_tile_no_to_dec + 1);\n        }\n\n    }\n\n    opj_free(l_current_data);\n\n    return OPJ_TRUE;\n}\n\n/**\n * Sets up the procedures to do on decoding one tile. Developpers wanting to extend the library can add their own reading procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_decoding_tile(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager)\n{\n    /* preconditions*/\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_decode_one_tile, p_manager)) {\n        return OPJ_FALSE;\n    }\n    /* DEVELOPER CORNER, add your custom procedures */\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_decode(opj_j2k_t * p_j2k,\n                        opj_stream_private_t * p_stream,\n                        opj_image_t * p_image,\n                        opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 compno;\n\n    if (!p_image) {\n        return OPJ_FALSE;\n    }\n\n    p_j2k->m_output_image = opj_image_create0();\n    if (!(p_j2k->m_output_image)) {\n        return OPJ_FALSE;\n    }\n    opj_copy_image_header(p_image, p_j2k->m_output_image);\n\n    /* customization of the decoding */\n    if (!opj_j2k_setup_decoding(p_j2k, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* Decode the codestream */\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n        return OPJ_FALSE;\n    }\n\n    /* Move data and copy one information from codec to output image*/\n    for (compno = 0; compno < p_image->numcomps; compno++) {\n        p_image->comps[compno].resno_decoded =\n            p_j2k->m_output_image->comps[compno].resno_decoded;\n        p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n#if 0\n        char fn[256];\n        sprintf(fn, \"/tmp/%d.raw\", compno);\n        FILE *debug = fopen(fn, \"wb\");\n        fwrite(p_image->comps[compno].data, sizeof(OPJ_INT32),\n               p_image->comps[compno].w * p_image->comps[compno].h, debug);\n        fclose(debug);\n#endif\n        p_j2k->m_output_image->comps[compno].data = NULL;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k,\n                          opj_stream_private_t *p_stream,\n                          opj_image_t* p_image,\n                          opj_event_mgr_t * p_manager,\n                          OPJ_UINT32 tile_index)\n{\n    OPJ_UINT32 compno;\n    OPJ_UINT32 l_tile_x, l_tile_y;\n    opj_image_comp_t* l_img_comp;\n\n    if (!p_image) {\n        opj_event_msg(p_manager, EVT_ERROR, \"We need an image previously created.\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (/*(tile_index < 0) &&*/ (tile_index >= p_j2k->m_cp.tw * p_j2k->m_cp.th)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Tile index provided by the user is incorrect %d (max = %d) \\n\", tile_index,\n                      (p_j2k->m_cp.tw * p_j2k->m_cp.th) - 1);\n        return OPJ_FALSE;\n    }\n\n    /* Compute the dimension of the desired tile*/\n    l_tile_x = tile_index % p_j2k->m_cp.tw;\n    l_tile_y = tile_index / p_j2k->m_cp.tw;\n\n    p_image->x0 = l_tile_x * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;\n    if (p_image->x0 < p_j2k->m_private_image->x0) {\n        p_image->x0 = p_j2k->m_private_image->x0;\n    }\n    p_image->x1 = (l_tile_x + 1) * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;\n    if (p_image->x1 > p_j2k->m_private_image->x1) {\n        p_image->x1 = p_j2k->m_private_image->x1;\n    }\n\n    p_image->y0 = l_tile_y * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;\n    if (p_image->y0 < p_j2k->m_private_image->y0) {\n        p_image->y0 = p_j2k->m_private_image->y0;\n    }\n    p_image->y1 = (l_tile_y + 1) * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;\n    if (p_image->y1 > p_j2k->m_private_image->y1) {\n        p_image->y1 = p_j2k->m_private_image->y1;\n    }\n\n    l_img_comp = p_image->comps;\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        OPJ_INT32 l_comp_x1, l_comp_y1;\n\n        l_img_comp->factor = p_j2k->m_private_image->comps[compno].factor;\n\n        l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0,\n                         (OPJ_INT32)l_img_comp->dx);\n        l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0,\n                         (OPJ_INT32)l_img_comp->dy);\n        l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);\n        l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);\n\n        l_img_comp->w = (OPJ_UINT32)(opj_int_ceildivpow2(l_comp_x1,\n                                     (OPJ_INT32)l_img_comp->factor) - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0,\n                                             (OPJ_INT32)l_img_comp->factor));\n        l_img_comp->h = (OPJ_UINT32)(opj_int_ceildivpow2(l_comp_y1,\n                                     (OPJ_INT32)l_img_comp->factor) - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0,\n                                             (OPJ_INT32)l_img_comp->factor));\n\n        l_img_comp++;\n    }\n\n    /* Destroy the previous output image*/\n    if (p_j2k->m_output_image) {\n        opj_image_destroy(p_j2k->m_output_image);\n    }\n\n    /* Create the ouput image from the information previously computed*/\n    p_j2k->m_output_image = opj_image_create0();\n    if (!(p_j2k->m_output_image)) {\n        return OPJ_FALSE;\n    }\n    opj_copy_image_header(p_image, p_j2k->m_output_image);\n\n    p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = (OPJ_INT32)tile_index;\n\n    /* customization of the decoding */\n    if (!opj_j2k_setup_decoding_tile(p_j2k, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* Decode the codestream */\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n        return OPJ_FALSE;\n    }\n\n    /* Move data and copy one information from codec to output image*/\n    for (compno = 0; compno < p_image->numcomps; compno++) {\n        p_image->comps[compno].resno_decoded =\n            p_j2k->m_output_image->comps[compno].resno_decoded;\n\n        if (p_image->comps[compno].data) {\n            opj_image_data_free(p_image->comps[compno].data);\n        }\n\n        p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n\n        p_j2k->m_output_image->comps[compno].data = NULL;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k,\n        OPJ_UINT32 res_factor,\n        opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 it_comp;\n\n    p_j2k->m_cp.m_specific_param.m_dec.m_reduce = res_factor;\n\n    if (p_j2k->m_private_image) {\n        if (p_j2k->m_private_image->comps) {\n            if (p_j2k->m_specific_param.m_decoder.m_default_tcp) {\n                if (p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps) {\n                    for (it_comp = 0 ; it_comp < p_j2k->m_private_image->numcomps; it_comp++) {\n                        OPJ_UINT32 max_res =\n                            p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[it_comp].numresolutions;\n                        if (res_factor >= max_res) {\n                            opj_event_msg(p_manager, EVT_ERROR,\n                                          \"Resolution factor is greater than the maximum resolution in the component.\\n\");\n                            return OPJ_FALSE;\n                        }\n                        p_j2k->m_private_image->comps[it_comp].factor = res_factor;\n                    }\n                    return OPJ_TRUE;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n\nOPJ_BOOL opj_j2k_encode(opj_j2k_t * p_j2k,\n                        opj_stream_private_t *p_stream,\n                        opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 i, j;\n    OPJ_UINT32 l_nb_tiles;\n    OPJ_UINT32 l_max_tile_size = 0, l_current_tile_size;\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_BOOL l_reuse_data = OPJ_FALSE;\n    opj_tcd_t* p_tcd = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    p_tcd = p_j2k->m_tcd;\n\n    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n    if (l_nb_tiles == 1) {\n        l_reuse_data = OPJ_TRUE;\n#ifdef __SSE__\n        for (j = 0; j < p_j2k->m_tcd->image->numcomps; ++j) {\n            opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;\n            if (((size_t)l_img_comp->data & 0xFU) !=\n                    0U) { /* tile data shall be aligned on 16 bytes */\n                l_reuse_data = OPJ_FALSE;\n            }\n        }\n#endif\n    }\n    for (i = 0; i < l_nb_tiles; ++i) {\n        if (! opj_j2k_pre_write_tile(p_j2k, i, p_stream, p_manager)) {\n            if (l_current_data) {\n                opj_free(l_current_data);\n            }\n            return OPJ_FALSE;\n        }\n\n        /* if we only have one tile, then simply set tile component data equal to image component data */\n        /* otherwise, allocate the data */\n        for (j = 0; j < p_j2k->m_tcd->image->numcomps; ++j) {\n            opj_tcd_tilecomp_t* l_tilec = p_tcd->tcd_image->tiles->comps + j;\n            if (l_reuse_data) {\n                opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;\n                l_tilec->data  =  l_img_comp->data;\n                l_tilec->ownsData = OPJ_FALSE;\n            } else {\n                if (! opj_alloc_tile_component_data(l_tilec)) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Error allocating tile component data.\");\n                    if (l_current_data) {\n                        opj_free(l_current_data);\n                    }\n                    return OPJ_FALSE;\n                }\n            }\n        }\n        l_current_tile_size = opj_tcd_get_encoded_tile_size(p_j2k->m_tcd);\n        if (!l_reuse_data) {\n            if (l_current_tile_size > l_max_tile_size) {\n                OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data,\n                                               l_current_tile_size);\n                if (! l_new_current_data) {\n                    if (l_current_data) {\n                        opj_free(l_current_data);\n                    }\n                    opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to encode all tiles\\n\");\n                    return OPJ_FALSE;\n                }\n                l_current_data = l_new_current_data;\n                l_max_tile_size = l_current_tile_size;\n            }\n\n            /* copy image data (32 bit) to l_current_data as contiguous, all-component, zero offset buffer */\n            /* 32 bit components @ 8 bit precision get converted to 8 bit */\n            /* 32 bit components @ 16 bit precision get converted to 16 bit */\n            opj_j2k_get_tile_data(p_j2k->m_tcd, l_current_data);\n\n            /* now copy this data into the tile component */\n            if (! opj_tcd_copy_tile_data(p_j2k->m_tcd, l_current_data,\n                                         l_current_tile_size)) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Size mismatch between tile data and sent data.\");\n                opj_free(l_current_data);\n                return OPJ_FALSE;\n            }\n        }\n\n        if (! opj_j2k_post_write_tile(p_j2k, p_stream, p_manager)) {\n            if (l_current_data) {\n                opj_free(l_current_data);\n            }\n            return OPJ_FALSE;\n        }\n    }\n\n    if (l_current_data) {\n        opj_free(l_current_data);\n    }\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k,\n                              opj_stream_private_t *p_stream,\n                              opj_event_mgr_t * p_manager)\n{\n    /* customization of the encoding */\n    if (! opj_j2k_setup_end_compress(p_j2k, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k,\n                                opj_stream_private_t *p_stream,\n                                opj_image_t * p_image,\n                                opj_event_mgr_t * p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    p_j2k->m_private_image = opj_image_create0();\n    if (! p_j2k->m_private_image) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Failed to allocate image header.\");\n        return OPJ_FALSE;\n    }\n    opj_copy_image_header(p_image, p_j2k->m_private_image);\n\n    /* TODO_MSD: Find a better way */\n    if (p_image->comps) {\n        OPJ_UINT32 it_comp;\n        for (it_comp = 0 ; it_comp < p_image->numcomps; it_comp++) {\n            if (p_image->comps[it_comp].data) {\n                p_j2k->m_private_image->comps[it_comp].data = p_image->comps[it_comp].data;\n                p_image->comps[it_comp].data = NULL;\n\n            }\n        }\n    }\n\n    /* customization of the validation */\n    if (! opj_j2k_setup_encoding_validation(p_j2k, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* validation of the parameters codec */\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* customization of the encoding */\n    if (! opj_j2k_setup_header_writing(p_j2k, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* write header */\n    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t * p_j2k,\n                                       OPJ_UINT32 p_tile_index,\n                                       opj_stream_private_t *p_stream,\n                                       opj_event_mgr_t * p_manager)\n{\n    (void)p_stream;\n    if (p_tile_index != p_j2k->m_current_tile_number) {\n        opj_event_msg(p_manager, EVT_ERROR, \"The given tile index does not match.\");\n        return OPJ_FALSE;\n    }\n\n    opj_event_msg(p_manager, EVT_INFO, \"tile number %d / %d\\n\",\n                  p_j2k->m_current_tile_number + 1, p_j2k->m_cp.tw * p_j2k->m_cp.th);\n\n    p_j2k->m_specific_param.m_encoder.m_current_tile_part_number = 0;\n    p_j2k->m_tcd->cur_totnum_tp = p_j2k->m_cp.tcps[p_tile_index].m_nb_tile_parts;\n    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;\n\n    /* initialisation before tile encoding  */\n    if (! opj_tcd_init_encode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number,\n                                   p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic void opj_get_tile_dimensions(opj_image_t * l_image,\n                                    opj_tcd_tilecomp_t * l_tilec,\n                                    opj_image_comp_t * l_img_comp,\n                                    OPJ_UINT32* l_size_comp,\n                                    OPJ_UINT32* l_width,\n                                    OPJ_UINT32* l_height,\n                                    OPJ_UINT32* l_offset_x,\n                                    OPJ_UINT32* l_offset_y,\n                                    OPJ_UINT32* l_image_width,\n                                    OPJ_UINT32* l_stride,\n                                    OPJ_UINT32* l_tile_offset)\n{\n    OPJ_UINT32 l_remaining;\n    *l_size_comp = l_img_comp->prec >> 3; /* (/8) */\n    l_remaining = l_img_comp->prec & 7;  /* (%8) */\n    if (l_remaining) {\n        *l_size_comp += 1;\n    }\n\n    if (*l_size_comp == 3) {\n        *l_size_comp = 4;\n    }\n\n    *l_width  = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);\n    *l_height = (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0);\n    *l_offset_x = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->x0,\n                  (OPJ_INT32)l_img_comp->dx);\n    *l_offset_y = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->y0,\n                  (OPJ_INT32)l_img_comp->dy);\n    *l_image_width = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->x1 -\n                     (OPJ_INT32)l_image->x0, (OPJ_INT32)l_img_comp->dx);\n    *l_stride = *l_image_width - *l_width;\n    *l_tile_offset = ((OPJ_UINT32)l_tilec->x0 - *l_offset_x) + ((\n                         OPJ_UINT32)l_tilec->y0 - *l_offset_y) * *l_image_width;\n}\n\nstatic void opj_j2k_get_tile_data(opj_tcd_t * p_tcd, OPJ_BYTE * p_data)\n{\n    OPJ_UINT32 i, j, k = 0;\n\n    for (i = 0; i < p_tcd->image->numcomps; ++i) {\n        opj_image_t * l_image =  p_tcd->image;\n        OPJ_INT32 * l_src_ptr;\n        opj_tcd_tilecomp_t * l_tilec = p_tcd->tcd_image->tiles->comps + i;\n        opj_image_comp_t * l_img_comp = l_image->comps + i;\n        OPJ_UINT32 l_size_comp, l_width, l_height, l_offset_x, l_offset_y,\n                   l_image_width, l_stride, l_tile_offset;\n\n        opj_get_tile_dimensions(l_image,\n                                l_tilec,\n                                l_img_comp,\n                                &l_size_comp,\n                                &l_width,\n                                &l_height,\n                                &l_offset_x,\n                                &l_offset_y,\n                                &l_image_width,\n                                &l_stride,\n                                &l_tile_offset);\n\n        l_src_ptr = l_img_comp->data + l_tile_offset;\n\n        switch (l_size_comp) {\n        case 1: {\n            OPJ_CHAR * l_dest_ptr = (OPJ_CHAR*) p_data;\n            if (l_img_comp->sgnd) {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        *(l_dest_ptr) = (OPJ_CHAR)(*l_src_ptr);\n                        ++l_dest_ptr;\n                        ++l_src_ptr;\n                    }\n                    l_src_ptr += l_stride;\n                }\n            } else {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        *(l_dest_ptr) = (OPJ_CHAR)((*l_src_ptr) & 0xff);\n                        ++l_dest_ptr;\n                        ++l_src_ptr;\n                    }\n                    l_src_ptr += l_stride;\n                }\n            }\n\n            p_data = (OPJ_BYTE*) l_dest_ptr;\n        }\n        break;\n        case 2: {\n            OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_data;\n            if (l_img_comp->sgnd) {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        *(l_dest_ptr++) = (OPJ_INT16)(*(l_src_ptr++));\n                    }\n                    l_src_ptr += l_stride;\n                }\n            } else {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        *(l_dest_ptr++) = (OPJ_INT16)((*(l_src_ptr++)) & 0xffff);\n                    }\n                    l_src_ptr += l_stride;\n                }\n            }\n\n            p_data = (OPJ_BYTE*) l_dest_ptr;\n        }\n        break;\n        case 4: {\n            OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_data;\n            for (j = 0; j < l_height; ++j) {\n                for (k = 0; k < l_width; ++k) {\n                    *(l_dest_ptr++) = *(l_src_ptr++);\n                }\n                l_src_ptr += l_stride;\n            }\n\n            p_data = (OPJ_BYTE*) l_dest_ptr;\n        }\n        break;\n        }\n    }\n}\n\nstatic OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t * p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 l_nb_bytes_written;\n    OPJ_BYTE * l_current_data = 00;\n    OPJ_UINT32 l_tile_size = 0;\n    OPJ_UINT32 l_available_data;\n\n    /* preconditions */\n    assert(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);\n\n    l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;\n    l_available_data = l_tile_size;\n    l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;\n\n    l_nb_bytes_written = 0;\n    if (! opj_j2k_write_first_tile_part(p_j2k, l_current_data, &l_nb_bytes_written,\n                                        l_available_data, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n    l_current_data += l_nb_bytes_written;\n    l_available_data -= l_nb_bytes_written;\n\n    l_nb_bytes_written = 0;\n    if (! opj_j2k_write_all_tile_parts(p_j2k, l_current_data, &l_nb_bytes_written,\n                                       l_available_data, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    l_available_data -= l_nb_bytes_written;\n    l_nb_bytes_written = l_tile_size - l_available_data;\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_encoded_tile_data,\n                              l_nb_bytes_written, p_manager) != l_nb_bytes_written) {\n        return OPJ_FALSE;\n    }\n\n    ++p_j2k->m_current_tile_number;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_end_compress(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    /* DEVELOPER CORNER, insert your custom procedures */\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_eoc, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    if (OPJ_IS_CINEMA(p_j2k->m_cp.rsiz)) {\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                               (opj_procedure)opj_j2k_write_updated_tlm, p_manager)) {\n            return OPJ_FALSE;\n        }\n    }\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_epc, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_end_encoding, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_destroy_header_memory, p_manager)) {\n        return OPJ_FALSE;\n    }\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,\n                                           (opj_procedure)opj_j2k_build_encoder, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,\n                                           (opj_procedure)opj_j2k_encoding_validation, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    /* DEVELOPER CORNER, add your custom validation procedure */\n    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,\n                                           (opj_procedure)opj_j2k_mct_validation, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_header_writing(opj_j2k_t *p_j2k,\n        opj_event_mgr_t * p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_init_info, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_soc, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_siz, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_cod, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_qcd, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_all_coc, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_all_qcc, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    if (OPJ_IS_CINEMA(p_j2k->m_cp.rsiz)) {\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                               (opj_procedure)opj_j2k_write_tlm, p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        if (p_j2k->m_cp.rsiz == OPJ_PROFILE_CINEMA_4K) {\n            if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                                   (opj_procedure)opj_j2k_write_poc, p_manager)) {\n                return OPJ_FALSE;\n            }\n        }\n    }\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_write_regions, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    if (p_j2k->m_cp.comment != 00)  {\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                               (opj_procedure)opj_j2k_write_com, p_manager)) {\n            return OPJ_FALSE;\n        }\n    }\n\n    /* DEVELOPER CORNER, insert your custom procedures */\n    if (p_j2k->m_cp.rsiz & OPJ_EXTENSION_MCT) {\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                               (opj_procedure)opj_j2k_write_mct_data_group, p_manager)) {\n            return OPJ_FALSE;\n        }\n    }\n    /* End of Developer Corner */\n\n    if (p_j2k->cstr_index) {\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                               (opj_procedure)opj_j2k_get_end_header, p_manager)) {\n            return OPJ_FALSE;\n        }\n    }\n\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_create_tcd, p_manager)) {\n        return OPJ_FALSE;\n    }\n    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,\n                                           (opj_procedure)opj_j2k_update_rates, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k,\n        OPJ_BYTE * p_data,\n        OPJ_UINT32 * p_data_written,\n        OPJ_UINT32 p_total_data_size,\n        opj_stream_private_t *p_stream,\n        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 l_nb_bytes_written = 0;\n    OPJ_UINT32 l_current_nb_bytes_written;\n    OPJ_BYTE * l_begin_data = 00;\n\n    opj_tcd_t * l_tcd = 00;\n    opj_cp_t * l_cp = 00;\n\n    l_tcd = p_j2k->m_tcd;\n    l_cp = &(p_j2k->m_cp);\n\n    l_tcd->cur_pino = 0;\n\n    /*Get number of tile parts*/\n    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;\n\n    /* INDEX >> */\n    /* << INDEX */\n\n    l_current_nb_bytes_written = 0;\n    l_begin_data = p_data;\n    if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream,\n                            p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    l_nb_bytes_written += l_current_nb_bytes_written;\n    p_data += l_current_nb_bytes_written;\n    p_total_data_size -= l_current_nb_bytes_written;\n\n    if (!OPJ_IS_CINEMA(l_cp->rsiz)) {\n#if 0\n        for (compno = 1; compno < p_j2k->m_private_image->numcomps; compno++) {\n            l_current_nb_bytes_written = 0;\n            opj_j2k_write_coc_in_memory(p_j2k, compno, p_data, &l_current_nb_bytes_written,\n                                        p_manager);\n            l_nb_bytes_written += l_current_nb_bytes_written;\n            p_data += l_current_nb_bytes_written;\n            p_total_data_size -= l_current_nb_bytes_written;\n\n            l_current_nb_bytes_written = 0;\n            opj_j2k_write_qcc_in_memory(p_j2k, compno, p_data, &l_current_nb_bytes_written,\n                                        p_manager);\n            l_nb_bytes_written += l_current_nb_bytes_written;\n            p_data += l_current_nb_bytes_written;\n            p_total_data_size -= l_current_nb_bytes_written;\n        }\n#endif\n        if (l_cp->tcps[p_j2k->m_current_tile_number].numpocs) {\n            l_current_nb_bytes_written = 0;\n            opj_j2k_write_poc_in_memory(p_j2k, p_data, &l_current_nb_bytes_written,\n                                        p_manager);\n            l_nb_bytes_written += l_current_nb_bytes_written;\n            p_data += l_current_nb_bytes_written;\n            p_total_data_size -= l_current_nb_bytes_written;\n        }\n    }\n\n    l_current_nb_bytes_written = 0;\n    if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,\n                            p_total_data_size, p_stream, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    l_nb_bytes_written += l_current_nb_bytes_written;\n    * p_data_written = l_nb_bytes_written;\n\n    /* Writing Psot in SOT marker */\n    opj_write_bytes(l_begin_data + 6, l_nb_bytes_written,\n                    4);                                 /* PSOT */\n\n    if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n        opj_j2k_update_tlm(p_j2k, l_nb_bytes_written);\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k,\n        OPJ_BYTE * p_data,\n        OPJ_UINT32 * p_data_written,\n        OPJ_UINT32 p_total_data_size,\n        opj_stream_private_t *p_stream,\n        struct opj_event_mgr * p_manager\n                                            )\n{\n    OPJ_UINT32 tilepartno = 0;\n    OPJ_UINT32 l_nb_bytes_written = 0;\n    OPJ_UINT32 l_current_nb_bytes_written;\n    OPJ_UINT32 l_part_tile_size;\n    OPJ_UINT32 tot_num_tp;\n    OPJ_UINT32 pino;\n\n    OPJ_BYTE * l_begin_data;\n    opj_tcp_t *l_tcp = 00;\n    opj_tcd_t * l_tcd = 00;\n    opj_cp_t * l_cp = 00;\n\n    l_tcd = p_j2k->m_tcd;\n    l_cp = &(p_j2k->m_cp);\n    l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;\n\n    /*Get number of tile parts*/\n    tot_num_tp = opj_j2k_get_num_tp(l_cp, 0, p_j2k->m_current_tile_number);\n\n    /* start writing remaining tile parts */\n    ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n    for (tilepartno = 1; tilepartno < tot_num_tp ; ++tilepartno) {\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;\n        l_current_nb_bytes_written = 0;\n        l_part_tile_size = 0;\n        l_begin_data = p_data;\n\n        if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream,\n                                p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        l_nb_bytes_written += l_current_nb_bytes_written;\n        p_data += l_current_nb_bytes_written;\n        p_total_data_size -= l_current_nb_bytes_written;\n        l_part_tile_size += l_current_nb_bytes_written;\n\n        l_current_nb_bytes_written = 0;\n        if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,\n                                p_total_data_size, p_stream, p_manager)) {\n            return OPJ_FALSE;\n        }\n\n        p_data += l_current_nb_bytes_written;\n        l_nb_bytes_written += l_current_nb_bytes_written;\n        p_total_data_size -= l_current_nb_bytes_written;\n        l_part_tile_size += l_current_nb_bytes_written;\n\n        /* Writing Psot in SOT marker */\n        opj_write_bytes(l_begin_data + 6, l_part_tile_size,\n                        4);                                   /* PSOT */\n\n        if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n            opj_j2k_update_tlm(p_j2k, l_part_tile_size);\n        }\n\n        ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n    }\n\n    for (pino = 1; pino <= l_tcp->numpocs; ++pino) {\n        l_tcd->cur_pino = pino;\n\n        /*Get number of tile parts*/\n        tot_num_tp = opj_j2k_get_num_tp(l_cp, pino, p_j2k->m_current_tile_number);\n        for (tilepartno = 0; tilepartno < tot_num_tp ; ++tilepartno) {\n            p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;\n            l_current_nb_bytes_written = 0;\n            l_part_tile_size = 0;\n            l_begin_data = p_data;\n\n            if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream,\n                                    p_manager)) {\n                return OPJ_FALSE;\n            }\n\n            l_nb_bytes_written += l_current_nb_bytes_written;\n            p_data += l_current_nb_bytes_written;\n            p_total_data_size -= l_current_nb_bytes_written;\n            l_part_tile_size += l_current_nb_bytes_written;\n\n            l_current_nb_bytes_written = 0;\n\n            if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,\n                                    p_total_data_size, p_stream, p_manager)) {\n                return OPJ_FALSE;\n            }\n\n            l_nb_bytes_written += l_current_nb_bytes_written;\n            p_data += l_current_nb_bytes_written;\n            p_total_data_size -= l_current_nb_bytes_written;\n            l_part_tile_size += l_current_nb_bytes_written;\n\n            /* Writing Psot in SOT marker */\n            opj_write_bytes(l_begin_data + 6, l_part_tile_size,\n                            4);                                   /* PSOT */\n\n            if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n                opj_j2k_update_tlm(p_j2k, l_part_tile_size);\n            }\n\n            ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n        }\n    }\n\n    *p_data_written = l_nb_bytes_written;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k,\n        struct opj_stream_private *p_stream,\n        struct opj_event_mgr * p_manager)\n{\n    OPJ_UINT32 l_tlm_size;\n    OPJ_OFF_T l_tlm_position, l_current_position;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    l_tlm_size = 5 * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;\n    l_tlm_position = 6 + p_j2k->m_specific_param.m_encoder.m_tlm_start;\n    l_current_position = opj_stream_tell(p_stream);\n\n    if (! opj_stream_seek(p_stream, l_tlm_position, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    if (opj_stream_write_data(p_stream,\n                              p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer, l_tlm_size,\n                              p_manager) != l_tlm_size) {\n        return OPJ_FALSE;\n    }\n\n    if (! opj_stream_seek(p_stream, l_current_position, p_manager)) {\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k,\n                                     struct opj_stream_private *p_stream,\n                                     struct opj_event_mgr * p_manager)\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n\n    opj_tcd_destroy(p_j2k->m_tcd);\n    p_j2k->m_tcd = 00;\n\n    if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {\n        opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);\n        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = 0;\n        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = 0;\n    }\n\n    if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {\n        opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);\n        p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = 0;\n    }\n\n    p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = 0;\n\n    return OPJ_TRUE;\n}\n\n/**\n * Destroys the memory associated with the decoding of headers.\n */\nstatic OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t * p_j2k,\n        opj_stream_private_t *p_stream,\n        opj_event_mgr_t * p_manager\n                                             )\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_stream != 00);\n    assert(p_manager != 00);\n\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n\n    if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {\n        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data = 0;\n    }\n\n    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k,\n                                  struct opj_stream_private *p_stream,\n                                  struct opj_event_mgr * p_manager)\n{\n    opj_codestream_info_t * l_cstr_info = 00;\n\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n    (void)l_cstr_info;\n\n    OPJ_UNUSED(p_stream);\n\n    /* TODO mergeV2: check this part which use cstr_info */\n    /*l_cstr_info = p_j2k->cstr_info;\n\n    if (l_cstr_info)  {\n            OPJ_UINT32 compno;\n            l_cstr_info->tile = (opj_tile_info_t *) opj_malloc(p_j2k->m_cp.tw * p_j2k->m_cp.th * sizeof(opj_tile_info_t));\n\n            l_cstr_info->image_w = p_j2k->m_image->x1 - p_j2k->m_image->x0;\n            l_cstr_info->image_h = p_j2k->m_image->y1 - p_j2k->m_image->y0;\n\n            l_cstr_info->prog = (&p_j2k->m_cp.tcps[0])->prg;\n\n            l_cstr_info->tw = p_j2k->m_cp.tw;\n            l_cstr_info->th = p_j2k->m_cp.th;\n\n            l_cstr_info->tile_x = p_j2k->m_cp.tdx;*/        /* new version parser */\n    /*l_cstr_info->tile_y = p_j2k->m_cp.tdy;*/      /* new version parser */\n    /*l_cstr_info->tile_Ox = p_j2k->m_cp.tx0;*/     /* new version parser */\n    /*l_cstr_info->tile_Oy = p_j2k->m_cp.ty0;*/     /* new version parser */\n\n    /*l_cstr_info->numcomps = p_j2k->m_image->numcomps;\n\n    l_cstr_info->numlayers = (&p_j2k->m_cp.tcps[0])->numlayers;\n\n    l_cstr_info->numdecompos = (OPJ_INT32*) opj_malloc(p_j2k->m_image->numcomps * sizeof(OPJ_INT32));\n\n    for (compno=0; compno < p_j2k->m_image->numcomps; compno++) {\n            l_cstr_info->numdecompos[compno] = (&p_j2k->m_cp.tcps[0])->tccps->numresolutions - 1;\n    }\n\n    l_cstr_info->D_max = 0.0;       */      /* ADD Marcela */\n\n    /*l_cstr_info->main_head_start = opj_stream_tell(p_stream);*/ /* position of SOC */\n\n    /*l_cstr_info->maxmarknum = 100;\n    l_cstr_info->marker = (opj_marker_info_t *) opj_malloc(l_cstr_info->maxmarknum * sizeof(opj_marker_info_t));\n    l_cstr_info->marknum = 0;\n    }*/\n\n    return opj_j2k_calculate_tp(p_j2k, &(p_j2k->m_cp),\n                                &p_j2k->m_specific_param.m_encoder.m_total_tile_parts, p_j2k->m_private_image,\n                                p_manager);\n}\n\n/**\n * Creates a tile-coder decoder.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k,\n                                   opj_stream_private_t *p_stream,\n                                   opj_event_mgr_t * p_manager\n                                  )\n{\n    /* preconditions */\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n\n    OPJ_UNUSED(p_stream);\n\n    p_j2k->m_tcd = opj_tcd_create(OPJ_FALSE);\n\n    if (! p_j2k->m_tcd) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to create Tile Coder\\n\");\n        return OPJ_FALSE;\n    }\n\n    if (!opj_tcd_init(p_j2k->m_tcd, p_j2k->m_private_image, &p_j2k->m_cp,\n                      p_j2k->m_tp)) {\n        opj_tcd_destroy(p_j2k->m_tcd);\n        p_j2k->m_tcd = 00;\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_write_tile(opj_j2k_t * p_j2k,\n                            OPJ_UINT32 p_tile_index,\n                            OPJ_BYTE * p_data,\n                            OPJ_UINT32 p_data_size,\n                            opj_stream_private_t *p_stream,\n                            opj_event_mgr_t * p_manager)\n{\n    if (! opj_j2k_pre_write_tile(p_j2k, p_tile_index, p_stream, p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Error while opj_j2k_pre_write_tile with tile index = %d\\n\", p_tile_index);\n        return OPJ_FALSE;\n    } else {\n        OPJ_UINT32 j;\n        /* Allocate data */\n        for (j = 0; j < p_j2k->m_tcd->image->numcomps; ++j) {\n            opj_tcd_tilecomp_t* l_tilec = p_j2k->m_tcd->tcd_image->tiles->comps + j;\n\n            if (! opj_alloc_tile_component_data(l_tilec)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error allocating tile component data.\");\n                return OPJ_FALSE;\n            }\n        }\n\n        /* now copy data into the tile component */\n        if (! opj_tcd_copy_tile_data(p_j2k->m_tcd, p_data, p_data_size)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Size mismatch between tile data and sent data.\");\n            return OPJ_FALSE;\n        }\n        if (! opj_j2k_post_write_tile(p_j2k, p_stream, p_manager)) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Error while opj_j2k_post_write_tile with tile index = %d\\n\", p_tile_index);\n            return OPJ_FALSE;\n        }\n    }\n\n    return OPJ_TRUE;\n}\n"], "filenames": ["src/lib/openjp2/j2k.c"], "buggy_code_start_loc": [6576], "buggy_code_end_loc": [6580], "fixing_code_start_loc": [6576], "fixing_code_end_loc": [6586], "type": "CWE-787", "message": "A mishandled zero case was discovered in opj_j2k_set_cinema_parameters in lib/openjp2/j2k.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service (heap-based buffer overflow affecting opj_write_bytes_LE in lib/openjp2/cio.c and opj_j2k_write_sot in lib/openjp2/j2k.c) or possibly remote code execution.", "other": {"cve": {"id": "CVE-2017-14152", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-05T16:29:00.243", "lastModified": "2021-02-02T19:51:25.413", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A mishandled zero case was discovered in opj_j2k_set_cinema_parameters in lib/openjp2/j2k.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service (heap-based buffer overflow affecting opj_write_bytes_LE in lib/openjp2/cio.c and opj_j2k_write_sot in lib/openjp2/j2k.c) or possibly remote code execution."}, {"lang": "es", "value": "Se ha descubierto un caso de un valor cero que no se maneja correctamente en opj_j2k_set_cinema_parameters en lib/openjp2/j2k.c en OpenJPEG 2.2.0. La vulnerabilidad da lugar a una escritura fuera de l\u00edmites que puede causar una denegaci\u00f3n de servicio remota (desbordamiento de b\u00fafer basado en mont\u00edculos que afecta a opj_write_bytes_LE en lib/openjp2/cio.c y a opj_j2k_write_sot en lib/openjp2/j2k.c) o una posible ejecuci\u00f3n de c\u00f3digo remota."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclouvain:openjpeg:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "1B5CD01A-5791-4D61-937C-4F3FF23C5C2C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-4013", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://blogs.gentoo.org/ago/2017/08/16/openjpeg-heap-based-buffer-overflow-in-opj_write_bytes_le-cio-c/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/uclouvain/openjpeg/commit/4241ae6fbbf1de9658764a80944dc8108f2b4154", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/985", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/uclouvain/openjpeg/commit/4241ae6fbbf1de9658764a80944dc8108f2b4154"}}