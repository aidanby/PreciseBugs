{"buggy_code": ["// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst { kHeadersList } = require('../core/symbols')\nconst { kGuard, kHeadersCaseInsensitive } = require('./symbols')\nconst { kEnumerableProperty } = require('../core/util')\nconst {\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue\n} = require('./util')\nconst { webidl } = require('./webidl')\nconst assert = require('assert')\n\nconst kHeadersMap = Symbol('headers map')\nconst kHeadersSortedMap = Symbol('headers map sorted')\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */\nfunction headerValueNormalize (potentialValue) {\n  //  To normalize a byte sequence potentialValue, remove\n  //  any leading and trailing HTTP whitespace bytes from\n  //  potentialValue.\n  return potentialValue.replace(\n    /^[\\r\\n\\t ]+|[\\r\\n\\t ]+$/g,\n    ''\n  )\n}\n\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  // 1. If object is a sequence, then for each header in object:\n  // Note: webidl conversion to array has already been done.\n  if (Array.isArray(object)) {\n    for (const header of object) {\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (header.length !== 2) {\n        throw webidl.errors.exception({\n          header: 'Headers constructor',\n          message: `expected name/value pair to be length 2, found ${header.length}.`\n        })\n      }\n\n      // 2. Append (header\u2019s first item, header\u2019s second item) to headers.\n      headers.append(header[0], header[1])\n    }\n  } else if (typeof object === 'object' && object !== null) {\n    // Note: null should throw\n\n    // 2. Otherwise, object is a record, then for each key \u2192 value in object,\n    //    append (key, value) to headers\n    for (const [key, value] of Object.entries(object)) {\n      headers.append(key, value)\n    }\n  } else {\n    throw webidl.errors.conversionFailed({\n      prefix: 'Headers constructor',\n      argument: 'Argument 1',\n      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n    })\n  }\n}\n\nclass HeadersList {\n  /** @type {[string, string][]|null} */\n  cookies = null\n\n  constructor (init) {\n    if (init instanceof HeadersList) {\n      this[kHeadersMap] = new Map(init[kHeadersMap])\n      this[kHeadersSortedMap] = init[kHeadersSortedMap]\n    } else {\n      this[kHeadersMap] = new Map(init)\n      this[kHeadersSortedMap] = null\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#header-list-contains\n  contains (name) {\n    // A header list list contains a header name name if list\n    // contains a header whose name is a byte-case-insensitive\n    // match for name.\n    name = name.toLowerCase()\n\n    return this[kHeadersMap].has(name)\n  }\n\n  clear () {\n    this[kHeadersMap].clear()\n    this[kHeadersSortedMap] = null\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-append\n  append (name, value) {\n    this[kHeadersSortedMap] = null\n\n    // 1. If list contains name, then set name to the first such\n    //    header\u2019s name.\n    const lowercaseName = name.toLowerCase()\n    const exists = this[kHeadersMap].get(lowercaseName)\n\n    // 2. Append (name, value) to list.\n    if (exists) {\n      const delimiter = lowercaseName === 'cookie' ? '; ' : ', '\n      this[kHeadersMap].set(lowercaseName, {\n        name: exists.name,\n        value: `${exists.value}${delimiter}${value}`\n      })\n    } else {\n      this[kHeadersMap].set(lowercaseName, { name, value })\n    }\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies ??= []\n      this.cookies.push(value)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-set\n  set (name, value) {\n    this[kHeadersSortedMap] = null\n    const lowercaseName = name.toLowerCase()\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies = [value]\n    }\n\n    // 1. If list contains name, then set the value of\n    //    the first such header to value and remove the\n    //    others.\n    // 2. Otherwise, append header (name, value) to list.\n    return this[kHeadersMap].set(lowercaseName, { name, value })\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-delete\n  delete (name) {\n    this[kHeadersSortedMap] = null\n\n    name = name.toLowerCase()\n\n    if (name === 'set-cookie') {\n      this.cookies = null\n    }\n\n    return this[kHeadersMap].delete(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-get\n  get (name) {\n    // 1. If list does not contain name, then return null.\n    if (!this.contains(name)) {\n      return null\n    }\n\n    // 2. Return the values of all headers in list whose name\n    //    is a byte-case-insensitive match for name,\n    //    separated from each other by 0x2C 0x20, in order.\n    return this[kHeadersMap].get(name.toLowerCase())?.value ?? null\n  }\n\n  * [Symbol.iterator] () {\n    // use the lowercased name\n    for (const [name, { value }] of this[kHeadersMap]) {\n      yield [name, value]\n    }\n  }\n\n  get [kHeadersCaseInsensitive] () {\n    /** @type {string[]} */\n    const flatList = []\n\n    for (const { name, value } of this[kHeadersMap].values()) {\n      flatList.push(name, value)\n    }\n\n    return flatList\n  }\n}\n\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n  constructor (init = undefined) {\n    this[kHeadersList] = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set this\u2019s guard to \"none\".\n    this[kGuard] = 'none'\n\n    // 2. If init is given, then fill this with init.\n    if (init !== undefined) {\n      init = webidl.converters.HeadersInit(init)\n      fill(this, init)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-append\n  append (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.append' })\n\n    name = webidl.converters.ByteString(name)\n    value = webidl.converters.ByteString(value)\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.append',\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.append',\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If headers\u2019s guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if headers\u2019s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (this[kGuard] === 'request-no-cors') {\n      // 5. Otherwise, if headers\u2019s guard is \"request-no-cors\":\n      // TODO\n    }\n\n    // 6. Otherwise, if headers\u2019s guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n\n    // 7. Append (name, value) to headers\u2019s header list.\n    // 8. If headers\u2019s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from headers\n    return this[kHeadersList].append(name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-delete\n  delete (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.delete' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.delete',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. If this\u2019s guard is \"immutable\", then throw a TypeError.\n    // 3. Otherwise, if this\u2019s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 4. Otherwise, if this\u2019s guard is \"request-no-cors\", name\n    //    is not a no-CORS-safelisted request-header name, and\n    //    name is not a privileged no-CORS request-header name,\n    //    return.\n    // 5. Otherwise, if this\u2019s guard is \"response\" and name is\n    //    a forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    }\n\n    // 6. If this\u2019s header list does not contain name, then\n    //    return.\n    if (!this[kHeadersList].contains(name)) {\n      return\n    }\n\n    // 7. Delete name from this\u2019s header list.\n    // 8. If this\u2019s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this.\n    return this[kHeadersList].delete(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-get\n  get (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.get' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.get',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return the result of getting name from this\u2019s header\n    //    list.\n    return this[kHeadersList].get(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-has\n  has (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.has' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.has',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return true if this\u2019s header list contains name;\n    //    otherwise false.\n    return this[kHeadersList].contains(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-set\n  set (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.set' })\n\n    name = webidl.converters.ByteString(name)\n    value = webidl.converters.ByteString(value)\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.set',\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.set',\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If this\u2019s guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if this\u2019s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if this\u2019s guard is \"request-no-cors\" and\n    //    name/value is not a no-CORS-safelisted request-header,\n    //    return.\n    // 6. Otherwise, if this\u2019s guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    }\n\n    // 7. Set (name, value) in this\u2019s header list.\n    // 8. If this\u2019s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this\n    return this[kHeadersList].set(name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n  getSetCookie () {\n    webidl.brandCheck(this, Headers)\n\n    // 1. If this\u2019s header list does not contain `Set-Cookie`, then return \u00ab \u00bb.\n    // 2. Return the values of all headers in this\u2019s header list whose name is\n    //    a byte-case-insensitive match for `Set-Cookie`, in order.\n\n    const list = this[kHeadersList].cookies\n\n    if (list) {\n      return [...list]\n    }\n\n    return []\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n  get [kHeadersSortedMap] () {\n    if (this[kHeadersList][kHeadersSortedMap]) {\n      return this[kHeadersList][kHeadersSortedMap]\n    }\n\n    // 1. Let headers be an empty list of headers with the key being the name\n    //    and value the value.\n    const headers = []\n\n    // 2. Let names be the result of convert header names to a sorted-lowercase\n    //    set with all the names of the headers in list.\n    const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1)\n    const cookies = this[kHeadersList].cookies\n\n    // 3. For each name of names:\n    for (const [name, value] of names) {\n      // 1. If name is `set-cookie`, then:\n      if (name === 'set-cookie') {\n        // 1. Let values be a list of all values of headers in list whose name\n        //    is a byte-case-insensitive match for name, in order.\n\n        // 2. For each value of values:\n        // 1. Append (name, value) to headers.\n        for (const value of cookies) {\n          headers.push([name, value])\n        }\n      } else {\n        // 2. Otherwise:\n\n        // 1. Let value be the result of getting name from list.\n\n        // 2. Assert: value is non-null.\n        assert(value !== null)\n\n        // 3. Append (name, value) to headers.\n        headers.push([name, value])\n      }\n    }\n\n    this[kHeadersList][kHeadersSortedMap] = headers\n\n    // 4. Return headers.\n    return headers\n  }\n\n  keys () {\n    webidl.brandCheck(this, Headers)\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'key'\n    )\n  }\n\n  values () {\n    webidl.brandCheck(this, Headers)\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'value'\n    )\n  }\n\n  entries () {\n    webidl.brandCheck(this, Headers)\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'key+value'\n    )\n  }\n\n  /**\n   * @param {(value: string, key: string, self: Headers) => void} callbackFn\n   * @param {unknown} thisArg\n   */\n  forEach (callbackFn, thisArg = globalThis) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.forEach' })\n\n    if (typeof callbackFn !== 'function') {\n      throw new TypeError(\n        \"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\"\n      )\n    }\n\n    for (const [key, value] of this) {\n      callbackFn.apply(thisArg, [value, key, this])\n    }\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    webidl.brandCheck(this, Headers)\n\n    return this[kHeadersList]\n  }\n}\n\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  keys: kEnumerableProperty,\n  values: kEnumerableProperty,\n  entries: kEnumerableProperty,\n  forEach: kEnumerableProperty,\n  [Symbol.iterator]: { enumerable: false },\n  [Symbol.toStringTag]: {\n    value: 'Headers',\n    configurable: true\n  }\n})\n\nwebidl.converters.HeadersInit = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (V[Symbol.iterator]) {\n      return webidl.converters['sequence<sequence<ByteString>>'](V)\n    }\n\n    return webidl.converters['record<ByteString, ByteString>'](V)\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix: 'Headers constructor',\n    argument: 'Argument 1',\n    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n  })\n}\n\nmodule.exports = {\n  fill,\n  Headers,\n  HeadersList\n}\n", "'use strict'\n\nconst tap = require('tap')\nconst { Headers, fill } = require('../../lib/fetch/headers')\nconst { kGuard } = require('../../lib/fetch/symbols')\n\ntap.test('Headers initialization', t => {\n  t.plan(8)\n\n  t.test('allows undefined', t => {\n    t.plan(1)\n\n    t.doesNotThrow(() => new Headers())\n  })\n\n  t.test('with array of header entries', t => {\n    t.plan(3)\n\n    t.test('fails on invalid array-based init', t => {\n      t.plan(3)\n      t.throws(\n        () => new Headers([['undici', 'fetch'], ['fetch']]),\n        TypeError('Headers constructor: expected name/value pair to be length 2, found 1.')\n      )\n      t.throws(() => new Headers(['undici', 'fetch', 'fetch']), TypeError)\n      t.throws(\n        () => new Headers([0, 1, 2]),\n        TypeError('Sequence: Value of type Number is not an Object.')\n      )\n    })\n\n    t.test('allows even length init', t => {\n      t.plan(1)\n      const init = [['undici', 'fetch'], ['fetch', 'undici']]\n      t.doesNotThrow(() => new Headers(init))\n    })\n\n    t.test('fails for event flattened init', t => {\n      t.plan(1)\n      const init = ['undici', 'fetch', 'fetch', 'undici']\n      t.throws(\n        () => new Headers(init),\n        TypeError('Sequence: Value of type String is not an Object.')\n      )\n    })\n  })\n\n  t.test('with object of header entries', t => {\n    t.plan(1)\n    const init = {\n      undici: 'fetch',\n      fetch: 'undici'\n    }\n    t.doesNotThrow(() => new Headers(init))\n  })\n\n  t.test('fails silently if a boxed primitive object is passed', t => {\n    t.plan(3)\n    /* eslint-disable no-new-wrappers */\n    t.doesNotThrow(() => new Headers(new Number()))\n    t.doesNotThrow(() => new Headers(new Boolean()))\n    t.doesNotThrow(() => new Headers(new String()))\n    /* eslint-enable no-new-wrappers */\n  })\n\n  t.test('fails if primitive is passed', t => {\n    t.plan(2)\n    const expectedTypeError = TypeError\n    t.throws(() => new Headers(1), expectedTypeError)\n    t.throws(() => new Headers('1'), expectedTypeError)\n  })\n\n  t.test('allows some weird stuff (because of webidl)', t => {\n    t.doesNotThrow(() => {\n      new Headers(function () {}) // eslint-disable-line no-new\n    })\n\n    t.doesNotThrow(() => {\n      new Headers(Function) // eslint-disable-line no-new\n    })\n\n    t.end()\n  })\n\n  t.test('allows a myriad of header values to be passed', t => {\n    t.plan(4)\n\n    // Headers constructor uses Headers.append\n\n    t.doesNotThrow(() => new Headers([\n      ['a', ['b', 'c']],\n      ['d', ['e', 'f']]\n    ]), 'allows any array values')\n    t.doesNotThrow(() => new Headers([\n      ['key', null]\n    ]), 'allows null values')\n    t.throws(() => new Headers([\n      ['key']\n    ]), 'throws when 2 arguments are not passed')\n    t.throws(() => new Headers([\n      ['key', 'value', 'value2']\n    ]), 'throws when too many arguments are passed')\n  })\n\n  t.test('accepts headers as objects with array values', t => {\n    t.plan(1)\n    const headers = new Headers({\n      c: '5',\n      b: ['3', '4'],\n      a: ['1', '2']\n    })\n\n    t.same([...headers.entries()], [\n      ['a', '1,2'],\n      ['b', '3,4'],\n      ['c', '5']\n    ])\n  })\n})\n\ntap.test('Headers append', t => {\n  t.plan(3)\n\n  t.test('adds valid header entry to instance', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    const name = 'undici'\n    const value = 'fetch'\n    t.doesNotThrow(() => headers.append(name, value))\n    t.equal(headers.get(name), value)\n  })\n\n  t.test('adds valid header to existing entry', t => {\n    t.plan(4)\n    const headers = new Headers()\n\n    const name = 'undici'\n    const value1 = 'fetch1'\n    const value2 = 'fetch2'\n    const value3 = 'fetch3'\n    headers.append(name, value1)\n    t.equal(headers.get(name), value1)\n    t.doesNotThrow(() => headers.append(name, value2))\n    t.doesNotThrow(() => headers.append(name, value3))\n    t.equal(headers.get(name), [value1, value2, value3].join(', '))\n  })\n\n  t.test('throws on invalid entry', t => {\n    t.plan(3)\n    const headers = new Headers()\n\n    t.throws(() => headers.append(), 'throws on missing name and value')\n    t.throws(() => headers.append('undici'), 'throws on missing value')\n    t.throws(() => headers.append('invalid @ header ? name', 'valid value'), 'throws on invalid name')\n  })\n})\n\ntap.test('Headers delete', t => {\n  t.plan(3)\n\n  t.test('deletes valid header entry from instance', t => {\n    t.plan(3)\n    const headers = new Headers()\n\n    const name = 'undici'\n    const value = 'fetch'\n    headers.append(name, value)\n    t.equal(headers.get(name), value)\n    t.doesNotThrow(() => headers.delete(name))\n    t.equal(headers.get(name), null)\n  })\n\n  t.test('does not mutate internal list when no match is found', t => {\n    t.plan(3)\n\n    const headers = new Headers()\n    const name = 'undici'\n    const value = 'fetch'\n    headers.append(name, value)\n    t.equal(headers.get(name), value)\n    t.doesNotThrow(() => headers.delete('not-undici'))\n    t.equal(headers.get(name), value)\n  })\n\n  t.test('throws on invalid entry', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    t.throws(() => headers.delete(), 'throws on missing namee')\n    t.throws(() => headers.delete('invalid @ header ? name'), 'throws on invalid name')\n  })\n})\n\ntap.test('Headers get', t => {\n  t.plan(3)\n\n  t.test('returns null if not found in instance', t => {\n    t.plan(1)\n    const headers = new Headers()\n    headers.append('undici', 'fetch')\n\n    t.equal(headers.get('not-undici'), null)\n  })\n\n  t.test('returns header values from valid header name', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    const name = 'undici'; const value1 = 'fetch1'; const value2 = 'fetch2'\n    headers.append(name, value1)\n    t.equal(headers.get(name), value1)\n    headers.append(name, value2)\n    t.equal(headers.get(name), [value1, value2].join(', '))\n  })\n\n  t.test('throws on invalid entry', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    t.throws(() => headers.get(), 'throws on missing name')\n    t.throws(() => headers.get('invalid @ header ? name'), 'throws on invalid name')\n  })\n})\n\ntap.test('Headers has', t => {\n  t.plan(2)\n\n  t.test('returns boolean existence for a header name', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    const name = 'undici'\n    headers.append('not-undici', 'fetch')\n    t.equal(headers.has(name), false)\n    headers.append(name, 'fetch')\n    t.equal(headers.has(name), true)\n  })\n\n  t.test('throws on invalid entry', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    t.throws(() => headers.has(), 'throws on missing name')\n    t.throws(() => headers.has('invalid @ header ? name'), 'throws on invalid name')\n  })\n})\n\ntap.test('Headers set', t => {\n  t.plan(4)\n\n  t.test('sets valid header entry to instance', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    const name = 'undici'\n    const value = 'fetch'\n    headers.append('not-undici', 'fetch')\n    t.doesNotThrow(() => headers.set(name, value))\n    t.equal(headers.get(name), value)\n  })\n\n  t.test('overwrites existing entry', t => {\n    t.plan(4)\n    const headers = new Headers()\n\n    const name = 'undici'\n    const value1 = 'fetch1'\n    const value2 = 'fetch2'\n    t.doesNotThrow(() => headers.set(name, value1))\n    t.equal(headers.get(name), value1)\n    t.doesNotThrow(() => headers.set(name, value2))\n    t.equal(headers.get(name), value2)\n  })\n\n  t.test('allows setting a myriad of values', t => {\n    t.plan(4)\n    const headers = new Headers()\n\n    t.doesNotThrow(() => headers.set('a', ['b', 'c']), 'sets array values properly')\n    t.doesNotThrow(() => headers.set('b', null), 'allows setting null values')\n    t.throws(() => headers.set('c'), 'throws when 2 arguments are not passed')\n    t.doesNotThrow(() => headers.set('c', 'd', 'e'), 'ignores extra arguments')\n  })\n\n  t.test('throws on invalid entry', t => {\n    t.plan(3)\n    const headers = new Headers()\n\n    t.throws(() => headers.set(), 'throws on missing name and value')\n    t.throws(() => headers.set('undici'), 'throws on missing value')\n    t.throws(() => headers.set('invalid @ header ? name', 'valid value'), 'throws on invalid name')\n  })\n})\n\ntap.test('Headers forEach', t => {\n  const headers = new Headers([['a', 'b'], ['c', 'd']])\n\n  t.test('standard', t => {\n    t.equal(typeof headers.forEach, 'function')\n\n    headers.forEach((value, key, headerInstance) => {\n      t.ok(value === 'b' || value === 'd')\n      t.ok(key === 'a' || key === 'c')\n      t.equal(headers, headerInstance)\n    })\n\n    t.end()\n  })\n\n  t.test('when no thisArg is set, it is globalThis', (t) => {\n    headers.forEach(function () {\n      t.equal(this, globalThis)\n    })\n\n    t.end()\n  })\n\n  t.test('with thisArg', t => {\n    const thisArg = { a: Math.random() }\n    headers.forEach(function () {\n      t.equal(this, thisArg)\n    }, thisArg)\n\n    t.end()\n  })\n\n  t.end()\n})\n\ntap.test('Headers as Iterable', t => {\n  t.plan(7)\n\n  t.test('should freeze values while iterating', t => {\n    t.plan(1)\n    const init = [\n      ['foo', '123'],\n      ['bar', '456']\n    ]\n    const expected = [\n      ['foo', '123'],\n      ['x-x-bar', '456']\n    ]\n    const headers = new Headers(init)\n    for (const [key, val] of headers) {\n      headers.delete(key)\n      headers.set(`x-${key}`, val)\n    }\n    t.strictSame([...headers], expected)\n  })\n\n  t.test('returns combined and sorted entries using .forEach()', t => {\n    t.plan(8)\n    const init = [\n      ['a', '1'],\n      ['b', '2'],\n      ['c', '3'],\n      ['abc', '4'],\n      ['b', '5']\n    ]\n    const expected = [\n      ['a', '1'],\n      ['abc', '4'],\n      ['b', '2, 5'],\n      ['c', '3']\n    ]\n    const headers = new Headers(init)\n    const that = {}\n    let i = 0\n    headers.forEach(function (value, key, _headers) {\n      t.strictSame(expected[i++], [key, value])\n      t.equal(this, that)\n    }, that)\n  })\n\n  t.test('returns combined and sorted entries using .entries()', t => {\n    t.plan(4)\n    const init = [\n      ['a', '1'],\n      ['b', '2'],\n      ['c', '3'],\n      ['abc', '4'],\n      ['b', '5']\n    ]\n    const expected = [\n      ['a', '1'],\n      ['abc', '4'],\n      ['b', '2, 5'],\n      ['c', '3']\n    ]\n    const headers = new Headers(init)\n    let i = 0\n    for (const header of headers.entries()) {\n      t.strictSame(header, expected[i++])\n    }\n  })\n\n  t.test('returns combined and sorted keys using .keys()', t => {\n    t.plan(4)\n    const init = [\n      ['a', '1'],\n      ['b', '2'],\n      ['c', '3'],\n      ['abc', '4'],\n      ['b', '5']\n    ]\n    const expected = ['a', 'abc', 'b', 'c']\n    const headers = new Headers(init)\n    let i = 0\n    for (const key of headers.keys()) {\n      t.strictSame(key, expected[i++])\n    }\n  })\n\n  t.test('returns combined and sorted values using .values()', t => {\n    t.plan(4)\n    const init = [\n      ['a', '1'],\n      ['b', '2'],\n      ['c', '3'],\n      ['abc', '4'],\n      ['b', '5']\n    ]\n    const expected = ['1', '4', '2, 5', '3']\n    const headers = new Headers(init)\n    let i = 0\n    for (const value of headers.values()) {\n      t.strictSame(value, expected[i++])\n    }\n  })\n\n  t.test('returns combined and sorted entries using for...of loop', t => {\n    t.plan(5)\n    const init = [\n      ['a', '1'],\n      ['b', '2'],\n      ['c', '3'],\n      ['abc', '4'],\n      ['b', '5'],\n      ['d', ['6', '7']]\n    ]\n    const expected = [\n      ['a', '1'],\n      ['abc', '4'],\n      ['b', '2, 5'],\n      ['c', '3'],\n      ['d', '6,7']\n    ]\n    let i = 0\n    for (const header of new Headers(init)) {\n      t.strictSame(header, expected[i++])\n    }\n  })\n\n  t.test('validate append ordering', t => {\n    t.plan(1)\n    const headers = new Headers([['b', '2'], ['c', '3'], ['e', '5']])\n    headers.append('d', '4')\n    headers.append('a', '1')\n    headers.append('f', '6')\n    headers.append('c', '7')\n    headers.append('abc', '8')\n\n    const expected = [...new Map([\n      ['a', '1'],\n      ['abc', '8'],\n      ['b', '2'],\n      ['c', '3, 7'],\n      ['d', '4'],\n      ['e', '5'],\n      ['f', '6']\n    ])]\n\n    t.same([...headers], expected)\n  })\n})\n\ntap.test('arg validation', (t) => {\n  // fill\n  t.throws(() => {\n    fill({}, 0)\n  }, TypeError)\n\n  const headers = new Headers()\n\n  // constructor\n  t.throws(() => {\n    // eslint-disable-next-line\n    new Headers(0)\n  }, TypeError)\n\n  // get [Symbol.toStringTag]\n  t.doesNotThrow(() => {\n    Object.prototype.toString.call(Headers.prototype)\n  })\n\n  // toString\n  t.doesNotThrow(() => {\n    Headers.prototype.toString.call(null)\n  })\n\n  // append\n  t.throws(() => {\n    Headers.prototype.append.call(null)\n  }, TypeError)\n  t.throws(() => {\n    headers.append()\n  }, TypeError)\n\n  // delete\n  t.throws(() => {\n    Headers.prototype.delete.call(null)\n  }, TypeError)\n  t.throws(() => {\n    headers.delete()\n  }, TypeError)\n\n  // get\n  t.throws(() => {\n    Headers.prototype.get.call(null)\n  }, TypeError)\n  t.throws(() => {\n    headers.get()\n  }, TypeError)\n\n  // has\n  t.throws(() => {\n    Headers.prototype.has.call(null)\n  }, TypeError)\n  t.throws(() => {\n    headers.has()\n  }, TypeError)\n\n  // set\n  t.throws(() => {\n    Headers.prototype.set.call(null)\n  }, TypeError)\n  t.throws(() => {\n    headers.set()\n  }, TypeError)\n\n  // forEach\n  t.throws(() => {\n    Headers.prototype.forEach.call(null)\n  }, TypeError)\n  t.throws(() => {\n    headers.forEach()\n  }, TypeError)\n  t.throws(() => {\n    headers.forEach(1)\n  }, TypeError)\n\n  // inspect\n  t.throws(() => {\n    Headers.prototype[Symbol.for('nodejs.util.inspect.custom')].call(null)\n  }, TypeError)\n\n  t.end()\n})\n\ntap.test('function signature verification', (t) => {\n  t.test('function length', (t) => {\n    t.equal(Headers.prototype.append.length, 2)\n    t.equal(Headers.prototype.constructor.length, 0)\n    t.equal(Headers.prototype.delete.length, 1)\n    t.equal(Headers.prototype.entries.length, 0)\n    t.equal(Headers.prototype.forEach.length, 1)\n    t.equal(Headers.prototype.get.length, 1)\n    t.equal(Headers.prototype.has.length, 1)\n    t.equal(Headers.prototype.keys.length, 0)\n    t.equal(Headers.prototype.set.length, 2)\n    t.equal(Headers.prototype.values.length, 0)\n    t.equal(Headers.prototype[Symbol.iterator].length, 0)\n    t.equal(Headers.prototype.toString.length, 0)\n\n    t.end()\n  })\n\n  t.test('function equality', (t) => {\n    t.equal(Headers.prototype.entries, Headers.prototype[Symbol.iterator])\n    t.equal(Headers.prototype.toString, Object.prototype.toString)\n\n    t.end()\n  })\n\n  t.test('toString and Symbol.toStringTag', (t) => {\n    t.equal(Object.prototype.toString.call(Headers.prototype), '[object Headers]')\n    t.equal(Headers.prototype[Symbol.toStringTag], 'Headers')\n    t.equal(Headers.prototype.toString.call(null), '[object Null]')\n\n    t.end()\n  })\n\n  t.end()\n})\n\ntap.test('various init paths of Headers', (t) => {\n  const h1 = new Headers()\n  const h2 = new Headers({})\n  const h3 = new Headers(undefined)\n  t.equal([...h1.entries()].length, 0)\n  t.equal([...h2.entries()].length, 0)\n  t.equal([...h3.entries()].length, 0)\n\n  t.end()\n})\n\ntap.test('immutable guard', (t) => {\n  const headers = new Headers()\n  headers.set('key', 'val')\n  headers[kGuard] = 'immutable'\n\n  t.throws(() => {\n    headers.set('asd', 'asd')\n  })\n  t.throws(() => {\n    headers.append('asd', 'asd')\n  })\n  t.throws(() => {\n    headers.delete('asd')\n  })\n  t.equal(headers.get('key'), 'val')\n  t.equal(headers.has('key'), true)\n\n  t.end()\n})\n\ntap.test('request-no-cors guard', (t) => {\n  const headers = new Headers()\n  headers[kGuard] = 'request-no-cors'\n  t.doesNotThrow(() => { headers.set('key', 'val') })\n  t.doesNotThrow(() => { headers.append('key', 'val') })\n  t.doesNotThrow(() => { headers.delete('key') })\n  t.end()\n})\n\ntap.test('invalid headers', (t) => {\n  for (const byte of ['\\r', '\\n', '\\t', ' ', String.fromCharCode(128), '']) {\n    t.throws(() => {\n      new Headers().set(byte, 'test')\n    }, TypeError, 'invalid header name')\n  }\n\n  for (const byte of [\n    '\\0',\n    '\\r',\n    '\\n'\n  ]) {\n    t.throws(() => {\n      new Headers().set('a', `a${byte}b`)\n    }, TypeError, 'not allowed at all in header value')\n  }\n\n  t.doesNotThrow(() => {\n    new Headers().set('a', '\\r')\n  })\n\n  t.doesNotThrow(() => {\n    new Headers().set('a', '\\n')\n  })\n\n  t.throws(() => {\n    new Headers().set('a', Symbol('symbol'))\n  }, TypeError, 'symbols should throw')\n\n  t.end()\n})\n\ntap.test('Headers.prototype.getSetCookie', (t) => {\n  t.test('Mutating the returned list does not affect the set-cookie list', (t) => {\n    const h = new Headers([\n      ['set-cookie', 'a=b'],\n      ['set-cookie', 'c=d']\n    ])\n\n    const old = h.getSetCookie()\n    h.getSetCookie().push('oh=no')\n    const now = h.getSetCookie()\n\n    t.same(old, now)\n    t.end()\n  })\n\n  t.end()\n})\n"], "fixing_code": ["// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst { kHeadersList } = require('../core/symbols')\nconst { kGuard, kHeadersCaseInsensitive } = require('./symbols')\nconst { kEnumerableProperty } = require('../core/util')\nconst {\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue\n} = require('./util')\nconst { webidl } = require('./webidl')\nconst assert = require('assert')\n\nconst kHeadersMap = Symbol('headers map')\nconst kHeadersSortedMap = Symbol('headers map sorted')\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */\nfunction headerValueNormalize (potentialValue) {\n  //  To normalize a byte sequence potentialValue, remove\n  //  any leading and trailing HTTP whitespace bytes from\n  //  potentialValue.\n\n  // Trimming the end with `.replace()` and a RegExp is typically subject to\n  // ReDoS. This is safer and faster.\n  let i = potentialValue.length\n  while (/[\\r\\n\\t ]/.test(potentialValue.charAt(--i)));\n  return potentialValue.slice(0, i + 1).replace(/^[\\r\\n\\t ]+/, '')\n}\n\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  // 1. If object is a sequence, then for each header in object:\n  // Note: webidl conversion to array has already been done.\n  if (Array.isArray(object)) {\n    for (const header of object) {\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (header.length !== 2) {\n        throw webidl.errors.exception({\n          header: 'Headers constructor',\n          message: `expected name/value pair to be length 2, found ${header.length}.`\n        })\n      }\n\n      // 2. Append (header\u2019s first item, header\u2019s second item) to headers.\n      headers.append(header[0], header[1])\n    }\n  } else if (typeof object === 'object' && object !== null) {\n    // Note: null should throw\n\n    // 2. Otherwise, object is a record, then for each key \u2192 value in object,\n    //    append (key, value) to headers\n    for (const [key, value] of Object.entries(object)) {\n      headers.append(key, value)\n    }\n  } else {\n    throw webidl.errors.conversionFailed({\n      prefix: 'Headers constructor',\n      argument: 'Argument 1',\n      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n    })\n  }\n}\n\nclass HeadersList {\n  /** @type {[string, string][]|null} */\n  cookies = null\n\n  constructor (init) {\n    if (init instanceof HeadersList) {\n      this[kHeadersMap] = new Map(init[kHeadersMap])\n      this[kHeadersSortedMap] = init[kHeadersSortedMap]\n    } else {\n      this[kHeadersMap] = new Map(init)\n      this[kHeadersSortedMap] = null\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#header-list-contains\n  contains (name) {\n    // A header list list contains a header name name if list\n    // contains a header whose name is a byte-case-insensitive\n    // match for name.\n    name = name.toLowerCase()\n\n    return this[kHeadersMap].has(name)\n  }\n\n  clear () {\n    this[kHeadersMap].clear()\n    this[kHeadersSortedMap] = null\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-append\n  append (name, value) {\n    this[kHeadersSortedMap] = null\n\n    // 1. If list contains name, then set name to the first such\n    //    header\u2019s name.\n    const lowercaseName = name.toLowerCase()\n    const exists = this[kHeadersMap].get(lowercaseName)\n\n    // 2. Append (name, value) to list.\n    if (exists) {\n      const delimiter = lowercaseName === 'cookie' ? '; ' : ', '\n      this[kHeadersMap].set(lowercaseName, {\n        name: exists.name,\n        value: `${exists.value}${delimiter}${value}`\n      })\n    } else {\n      this[kHeadersMap].set(lowercaseName, { name, value })\n    }\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies ??= []\n      this.cookies.push(value)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-set\n  set (name, value) {\n    this[kHeadersSortedMap] = null\n    const lowercaseName = name.toLowerCase()\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies = [value]\n    }\n\n    // 1. If list contains name, then set the value of\n    //    the first such header to value and remove the\n    //    others.\n    // 2. Otherwise, append header (name, value) to list.\n    return this[kHeadersMap].set(lowercaseName, { name, value })\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-delete\n  delete (name) {\n    this[kHeadersSortedMap] = null\n\n    name = name.toLowerCase()\n\n    if (name === 'set-cookie') {\n      this.cookies = null\n    }\n\n    return this[kHeadersMap].delete(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-get\n  get (name) {\n    // 1. If list does not contain name, then return null.\n    if (!this.contains(name)) {\n      return null\n    }\n\n    // 2. Return the values of all headers in list whose name\n    //    is a byte-case-insensitive match for name,\n    //    separated from each other by 0x2C 0x20, in order.\n    return this[kHeadersMap].get(name.toLowerCase())?.value ?? null\n  }\n\n  * [Symbol.iterator] () {\n    // use the lowercased name\n    for (const [name, { value }] of this[kHeadersMap]) {\n      yield [name, value]\n    }\n  }\n\n  get [kHeadersCaseInsensitive] () {\n    /** @type {string[]} */\n    const flatList = []\n\n    for (const { name, value } of this[kHeadersMap].values()) {\n      flatList.push(name, value)\n    }\n\n    return flatList\n  }\n}\n\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n  constructor (init = undefined) {\n    this[kHeadersList] = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set this\u2019s guard to \"none\".\n    this[kGuard] = 'none'\n\n    // 2. If init is given, then fill this with init.\n    if (init !== undefined) {\n      init = webidl.converters.HeadersInit(init)\n      fill(this, init)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-append\n  append (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.append' })\n\n    name = webidl.converters.ByteString(name)\n    value = webidl.converters.ByteString(value)\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.append',\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.append',\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If headers\u2019s guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if headers\u2019s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (this[kGuard] === 'request-no-cors') {\n      // 5. Otherwise, if headers\u2019s guard is \"request-no-cors\":\n      // TODO\n    }\n\n    // 6. Otherwise, if headers\u2019s guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n\n    // 7. Append (name, value) to headers\u2019s header list.\n    // 8. If headers\u2019s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from headers\n    return this[kHeadersList].append(name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-delete\n  delete (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.delete' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.delete',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. If this\u2019s guard is \"immutable\", then throw a TypeError.\n    // 3. Otherwise, if this\u2019s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 4. Otherwise, if this\u2019s guard is \"request-no-cors\", name\n    //    is not a no-CORS-safelisted request-header name, and\n    //    name is not a privileged no-CORS request-header name,\n    //    return.\n    // 5. Otherwise, if this\u2019s guard is \"response\" and name is\n    //    a forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    }\n\n    // 6. If this\u2019s header list does not contain name, then\n    //    return.\n    if (!this[kHeadersList].contains(name)) {\n      return\n    }\n\n    // 7. Delete name from this\u2019s header list.\n    // 8. If this\u2019s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this.\n    return this[kHeadersList].delete(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-get\n  get (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.get' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.get',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return the result of getting name from this\u2019s header\n    //    list.\n    return this[kHeadersList].get(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-has\n  has (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.has' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.has',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return true if this\u2019s header list contains name;\n    //    otherwise false.\n    return this[kHeadersList].contains(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-set\n  set (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.set' })\n\n    name = webidl.converters.ByteString(name)\n    value = webidl.converters.ByteString(value)\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.set',\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.set',\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If this\u2019s guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if this\u2019s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if this\u2019s guard is \"request-no-cors\" and\n    //    name/value is not a no-CORS-safelisted request-header,\n    //    return.\n    // 6. Otherwise, if this\u2019s guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    }\n\n    // 7. Set (name, value) in this\u2019s header list.\n    // 8. If this\u2019s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this\n    return this[kHeadersList].set(name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n  getSetCookie () {\n    webidl.brandCheck(this, Headers)\n\n    // 1. If this\u2019s header list does not contain `Set-Cookie`, then return \u00ab \u00bb.\n    // 2. Return the values of all headers in this\u2019s header list whose name is\n    //    a byte-case-insensitive match for `Set-Cookie`, in order.\n\n    const list = this[kHeadersList].cookies\n\n    if (list) {\n      return [...list]\n    }\n\n    return []\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n  get [kHeadersSortedMap] () {\n    if (this[kHeadersList][kHeadersSortedMap]) {\n      return this[kHeadersList][kHeadersSortedMap]\n    }\n\n    // 1. Let headers be an empty list of headers with the key being the name\n    //    and value the value.\n    const headers = []\n\n    // 2. Let names be the result of convert header names to a sorted-lowercase\n    //    set with all the names of the headers in list.\n    const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1)\n    const cookies = this[kHeadersList].cookies\n\n    // 3. For each name of names:\n    for (const [name, value] of names) {\n      // 1. If name is `set-cookie`, then:\n      if (name === 'set-cookie') {\n        // 1. Let values be a list of all values of headers in list whose name\n        //    is a byte-case-insensitive match for name, in order.\n\n        // 2. For each value of values:\n        // 1. Append (name, value) to headers.\n        for (const value of cookies) {\n          headers.push([name, value])\n        }\n      } else {\n        // 2. Otherwise:\n\n        // 1. Let value be the result of getting name from list.\n\n        // 2. Assert: value is non-null.\n        assert(value !== null)\n\n        // 3. Append (name, value) to headers.\n        headers.push([name, value])\n      }\n    }\n\n    this[kHeadersList][kHeadersSortedMap] = headers\n\n    // 4. Return headers.\n    return headers\n  }\n\n  keys () {\n    webidl.brandCheck(this, Headers)\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'key'\n    )\n  }\n\n  values () {\n    webidl.brandCheck(this, Headers)\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'value'\n    )\n  }\n\n  entries () {\n    webidl.brandCheck(this, Headers)\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'key+value'\n    )\n  }\n\n  /**\n   * @param {(value: string, key: string, self: Headers) => void} callbackFn\n   * @param {unknown} thisArg\n   */\n  forEach (callbackFn, thisArg = globalThis) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.forEach' })\n\n    if (typeof callbackFn !== 'function') {\n      throw new TypeError(\n        \"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\"\n      )\n    }\n\n    for (const [key, value] of this) {\n      callbackFn.apply(thisArg, [value, key, this])\n    }\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    webidl.brandCheck(this, Headers)\n\n    return this[kHeadersList]\n  }\n}\n\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  keys: kEnumerableProperty,\n  values: kEnumerableProperty,\n  entries: kEnumerableProperty,\n  forEach: kEnumerableProperty,\n  [Symbol.iterator]: { enumerable: false },\n  [Symbol.toStringTag]: {\n    value: 'Headers',\n    configurable: true\n  }\n})\n\nwebidl.converters.HeadersInit = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (V[Symbol.iterator]) {\n      return webidl.converters['sequence<sequence<ByteString>>'](V)\n    }\n\n    return webidl.converters['record<ByteString, ByteString>'](V)\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix: 'Headers constructor',\n    argument: 'Argument 1',\n    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n  })\n}\n\nmodule.exports = {\n  fill,\n  Headers,\n  HeadersList\n}\n", "'use strict'\n\nconst tap = require('tap')\nconst { Headers, fill } = require('../../lib/fetch/headers')\nconst { kGuard } = require('../../lib/fetch/symbols')\n\ntap.test('Headers initialization', t => {\n  t.plan(8)\n\n  t.test('allows undefined', t => {\n    t.plan(1)\n\n    t.doesNotThrow(() => new Headers())\n  })\n\n  t.test('with array of header entries', t => {\n    t.plan(3)\n\n    t.test('fails on invalid array-based init', t => {\n      t.plan(3)\n      t.throws(\n        () => new Headers([['undici', 'fetch'], ['fetch']]),\n        TypeError('Headers constructor: expected name/value pair to be length 2, found 1.')\n      )\n      t.throws(() => new Headers(['undici', 'fetch', 'fetch']), TypeError)\n      t.throws(\n        () => new Headers([0, 1, 2]),\n        TypeError('Sequence: Value of type Number is not an Object.')\n      )\n    })\n\n    t.test('allows even length init', t => {\n      t.plan(1)\n      const init = [['undici', 'fetch'], ['fetch', 'undici']]\n      t.doesNotThrow(() => new Headers(init))\n    })\n\n    t.test('fails for event flattened init', t => {\n      t.plan(1)\n      const init = ['undici', 'fetch', 'fetch', 'undici']\n      t.throws(\n        () => new Headers(init),\n        TypeError('Sequence: Value of type String is not an Object.')\n      )\n    })\n  })\n\n  t.test('with object of header entries', t => {\n    t.plan(1)\n    const init = {\n      undici: 'fetch',\n      fetch: 'undici'\n    }\n    t.doesNotThrow(() => new Headers(init))\n  })\n\n  t.test('fails silently if a boxed primitive object is passed', t => {\n    t.plan(3)\n    /* eslint-disable no-new-wrappers */\n    t.doesNotThrow(() => new Headers(new Number()))\n    t.doesNotThrow(() => new Headers(new Boolean()))\n    t.doesNotThrow(() => new Headers(new String()))\n    /* eslint-enable no-new-wrappers */\n  })\n\n  t.test('fails if primitive is passed', t => {\n    t.plan(2)\n    const expectedTypeError = TypeError\n    t.throws(() => new Headers(1), expectedTypeError)\n    t.throws(() => new Headers('1'), expectedTypeError)\n  })\n\n  t.test('allows some weird stuff (because of webidl)', t => {\n    t.doesNotThrow(() => {\n      new Headers(function () {}) // eslint-disable-line no-new\n    })\n\n    t.doesNotThrow(() => {\n      new Headers(Function) // eslint-disable-line no-new\n    })\n\n    t.end()\n  })\n\n  t.test('allows a myriad of header values to be passed', t => {\n    t.plan(4)\n\n    // Headers constructor uses Headers.append\n\n    t.doesNotThrow(() => new Headers([\n      ['a', ['b', 'c']],\n      ['d', ['e', 'f']]\n    ]), 'allows any array values')\n    t.doesNotThrow(() => new Headers([\n      ['key', null]\n    ]), 'allows null values')\n    t.throws(() => new Headers([\n      ['key']\n    ]), 'throws when 2 arguments are not passed')\n    t.throws(() => new Headers([\n      ['key', 'value', 'value2']\n    ]), 'throws when too many arguments are passed')\n  })\n\n  t.test('accepts headers as objects with array values', t => {\n    t.plan(1)\n    const headers = new Headers({\n      c: '5',\n      b: ['3', '4'],\n      a: ['1', '2']\n    })\n\n    t.same([...headers.entries()], [\n      ['a', '1,2'],\n      ['b', '3,4'],\n      ['c', '5']\n    ])\n  })\n})\n\ntap.test('Headers append', t => {\n  t.plan(3)\n\n  t.test('adds valid header entry to instance', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    const name = 'undici'\n    const value = 'fetch'\n    t.doesNotThrow(() => headers.append(name, value))\n    t.equal(headers.get(name), value)\n  })\n\n  t.test('adds valid header to existing entry', t => {\n    t.plan(4)\n    const headers = new Headers()\n\n    const name = 'undici'\n    const value1 = 'fetch1'\n    const value2 = 'fetch2'\n    const value3 = 'fetch3'\n    headers.append(name, value1)\n    t.equal(headers.get(name), value1)\n    t.doesNotThrow(() => headers.append(name, value2))\n    t.doesNotThrow(() => headers.append(name, value3))\n    t.equal(headers.get(name), [value1, value2, value3].join(', '))\n  })\n\n  t.test('throws on invalid entry', t => {\n    t.plan(3)\n    const headers = new Headers()\n\n    t.throws(() => headers.append(), 'throws on missing name and value')\n    t.throws(() => headers.append('undici'), 'throws on missing value')\n    t.throws(() => headers.append('invalid @ header ? name', 'valid value'), 'throws on invalid name')\n  })\n})\n\ntap.test('Headers delete', t => {\n  t.plan(3)\n\n  t.test('deletes valid header entry from instance', t => {\n    t.plan(3)\n    const headers = new Headers()\n\n    const name = 'undici'\n    const value = 'fetch'\n    headers.append(name, value)\n    t.equal(headers.get(name), value)\n    t.doesNotThrow(() => headers.delete(name))\n    t.equal(headers.get(name), null)\n  })\n\n  t.test('does not mutate internal list when no match is found', t => {\n    t.plan(3)\n\n    const headers = new Headers()\n    const name = 'undici'\n    const value = 'fetch'\n    headers.append(name, value)\n    t.equal(headers.get(name), value)\n    t.doesNotThrow(() => headers.delete('not-undici'))\n    t.equal(headers.get(name), value)\n  })\n\n  t.test('throws on invalid entry', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    t.throws(() => headers.delete(), 'throws on missing namee')\n    t.throws(() => headers.delete('invalid @ header ? name'), 'throws on invalid name')\n  })\n})\n\ntap.test('Headers get', t => {\n  t.plan(3)\n\n  t.test('returns null if not found in instance', t => {\n    t.plan(1)\n    const headers = new Headers()\n    headers.append('undici', 'fetch')\n\n    t.equal(headers.get('not-undici'), null)\n  })\n\n  t.test('returns header values from valid header name', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    const name = 'undici'; const value1 = 'fetch1'; const value2 = 'fetch2'\n    headers.append(name, value1)\n    t.equal(headers.get(name), value1)\n    headers.append(name, value2)\n    t.equal(headers.get(name), [value1, value2].join(', '))\n  })\n\n  t.test('throws on invalid entry', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    t.throws(() => headers.get(), 'throws on missing name')\n    t.throws(() => headers.get('invalid @ header ? name'), 'throws on invalid name')\n  })\n})\n\ntap.test('Headers has', t => {\n  t.plan(2)\n\n  t.test('returns boolean existence for a header name', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    const name = 'undici'\n    headers.append('not-undici', 'fetch')\n    t.equal(headers.has(name), false)\n    headers.append(name, 'fetch')\n    t.equal(headers.has(name), true)\n  })\n\n  t.test('throws on invalid entry', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    t.throws(() => headers.has(), 'throws on missing name')\n    t.throws(() => headers.has('invalid @ header ? name'), 'throws on invalid name')\n  })\n})\n\ntap.test('Headers set', t => {\n  t.plan(4)\n\n  t.test('sets valid header entry to instance', t => {\n    t.plan(2)\n    const headers = new Headers()\n\n    const name = 'undici'\n    const value = 'fetch'\n    headers.append('not-undici', 'fetch')\n    t.doesNotThrow(() => headers.set(name, value))\n    t.equal(headers.get(name), value)\n  })\n\n  t.test('overwrites existing entry', t => {\n    t.plan(4)\n    const headers = new Headers()\n\n    const name = 'undici'\n    const value1 = 'fetch1'\n    const value2 = 'fetch2'\n    t.doesNotThrow(() => headers.set(name, value1))\n    t.equal(headers.get(name), value1)\n    t.doesNotThrow(() => headers.set(name, value2))\n    t.equal(headers.get(name), value2)\n  })\n\n  t.test('allows setting a myriad of values', t => {\n    t.plan(4)\n    const headers = new Headers()\n\n    t.doesNotThrow(() => headers.set('a', ['b', 'c']), 'sets array values properly')\n    t.doesNotThrow(() => headers.set('b', null), 'allows setting null values')\n    t.throws(() => headers.set('c'), 'throws when 2 arguments are not passed')\n    t.doesNotThrow(() => headers.set('c', 'd', 'e'), 'ignores extra arguments')\n  })\n\n  t.test('throws on invalid entry', t => {\n    t.plan(3)\n    const headers = new Headers()\n\n    t.throws(() => headers.set(), 'throws on missing name and value')\n    t.throws(() => headers.set('undici'), 'throws on missing value')\n    t.throws(() => headers.set('invalid @ header ? name', 'valid value'), 'throws on invalid name')\n  })\n})\n\ntap.test('Headers forEach', t => {\n  const headers = new Headers([['a', 'b'], ['c', 'd']])\n\n  t.test('standard', t => {\n    t.equal(typeof headers.forEach, 'function')\n\n    headers.forEach((value, key, headerInstance) => {\n      t.ok(value === 'b' || value === 'd')\n      t.ok(key === 'a' || key === 'c')\n      t.equal(headers, headerInstance)\n    })\n\n    t.end()\n  })\n\n  t.test('when no thisArg is set, it is globalThis', (t) => {\n    headers.forEach(function () {\n      t.equal(this, globalThis)\n    })\n\n    t.end()\n  })\n\n  t.test('with thisArg', t => {\n    const thisArg = { a: Math.random() }\n    headers.forEach(function () {\n      t.equal(this, thisArg)\n    }, thisArg)\n\n    t.end()\n  })\n\n  t.end()\n})\n\ntap.test('Headers as Iterable', t => {\n  t.plan(7)\n\n  t.test('should freeze values while iterating', t => {\n    t.plan(1)\n    const init = [\n      ['foo', '123'],\n      ['bar', '456']\n    ]\n    const expected = [\n      ['foo', '123'],\n      ['x-x-bar', '456']\n    ]\n    const headers = new Headers(init)\n    for (const [key, val] of headers) {\n      headers.delete(key)\n      headers.set(`x-${key}`, val)\n    }\n    t.strictSame([...headers], expected)\n  })\n\n  t.test('returns combined and sorted entries using .forEach()', t => {\n    t.plan(8)\n    const init = [\n      ['a', '1'],\n      ['b', '2'],\n      ['c', '3'],\n      ['abc', '4'],\n      ['b', '5']\n    ]\n    const expected = [\n      ['a', '1'],\n      ['abc', '4'],\n      ['b', '2, 5'],\n      ['c', '3']\n    ]\n    const headers = new Headers(init)\n    const that = {}\n    let i = 0\n    headers.forEach(function (value, key, _headers) {\n      t.strictSame(expected[i++], [key, value])\n      t.equal(this, that)\n    }, that)\n  })\n\n  t.test('returns combined and sorted entries using .entries()', t => {\n    t.plan(4)\n    const init = [\n      ['a', '1'],\n      ['b', '2'],\n      ['c', '3'],\n      ['abc', '4'],\n      ['b', '5']\n    ]\n    const expected = [\n      ['a', '1'],\n      ['abc', '4'],\n      ['b', '2, 5'],\n      ['c', '3']\n    ]\n    const headers = new Headers(init)\n    let i = 0\n    for (const header of headers.entries()) {\n      t.strictSame(header, expected[i++])\n    }\n  })\n\n  t.test('returns combined and sorted keys using .keys()', t => {\n    t.plan(4)\n    const init = [\n      ['a', '1'],\n      ['b', '2'],\n      ['c', '3'],\n      ['abc', '4'],\n      ['b', '5']\n    ]\n    const expected = ['a', 'abc', 'b', 'c']\n    const headers = new Headers(init)\n    let i = 0\n    for (const key of headers.keys()) {\n      t.strictSame(key, expected[i++])\n    }\n  })\n\n  t.test('returns combined and sorted values using .values()', t => {\n    t.plan(4)\n    const init = [\n      ['a', '1'],\n      ['b', '2'],\n      ['c', '3'],\n      ['abc', '4'],\n      ['b', '5']\n    ]\n    const expected = ['1', '4', '2, 5', '3']\n    const headers = new Headers(init)\n    let i = 0\n    for (const value of headers.values()) {\n      t.strictSame(value, expected[i++])\n    }\n  })\n\n  t.test('returns combined and sorted entries using for...of loop', t => {\n    t.plan(5)\n    const init = [\n      ['a', '1'],\n      ['b', '2'],\n      ['c', '3'],\n      ['abc', '4'],\n      ['b', '5'],\n      ['d', ['6', '7']]\n    ]\n    const expected = [\n      ['a', '1'],\n      ['abc', '4'],\n      ['b', '2, 5'],\n      ['c', '3'],\n      ['d', '6,7']\n    ]\n    let i = 0\n    for (const header of new Headers(init)) {\n      t.strictSame(header, expected[i++])\n    }\n  })\n\n  t.test('validate append ordering', t => {\n    t.plan(1)\n    const headers = new Headers([['b', '2'], ['c', '3'], ['e', '5']])\n    headers.append('d', '4')\n    headers.append('a', '1')\n    headers.append('f', '6')\n    headers.append('c', '7')\n    headers.append('abc', '8')\n\n    const expected = [...new Map([\n      ['a', '1'],\n      ['abc', '8'],\n      ['b', '2'],\n      ['c', '3, 7'],\n      ['d', '4'],\n      ['e', '5'],\n      ['f', '6']\n    ])]\n\n    t.same([...headers], expected)\n  })\n})\n\ntap.test('arg validation', (t) => {\n  // fill\n  t.throws(() => {\n    fill({}, 0)\n  }, TypeError)\n\n  const headers = new Headers()\n\n  // constructor\n  t.throws(() => {\n    // eslint-disable-next-line\n    new Headers(0)\n  }, TypeError)\n\n  // get [Symbol.toStringTag]\n  t.doesNotThrow(() => {\n    Object.prototype.toString.call(Headers.prototype)\n  })\n\n  // toString\n  t.doesNotThrow(() => {\n    Headers.prototype.toString.call(null)\n  })\n\n  // append\n  t.throws(() => {\n    Headers.prototype.append.call(null)\n  }, TypeError)\n  t.throws(() => {\n    headers.append()\n  }, TypeError)\n\n  // delete\n  t.throws(() => {\n    Headers.prototype.delete.call(null)\n  }, TypeError)\n  t.throws(() => {\n    headers.delete()\n  }, TypeError)\n\n  // get\n  t.throws(() => {\n    Headers.prototype.get.call(null)\n  }, TypeError)\n  t.throws(() => {\n    headers.get()\n  }, TypeError)\n\n  // has\n  t.throws(() => {\n    Headers.prototype.has.call(null)\n  }, TypeError)\n  t.throws(() => {\n    headers.has()\n  }, TypeError)\n\n  // set\n  t.throws(() => {\n    Headers.prototype.set.call(null)\n  }, TypeError)\n  t.throws(() => {\n    headers.set()\n  }, TypeError)\n\n  // forEach\n  t.throws(() => {\n    Headers.prototype.forEach.call(null)\n  }, TypeError)\n  t.throws(() => {\n    headers.forEach()\n  }, TypeError)\n  t.throws(() => {\n    headers.forEach(1)\n  }, TypeError)\n\n  // inspect\n  t.throws(() => {\n    Headers.prototype[Symbol.for('nodejs.util.inspect.custom')].call(null)\n  }, TypeError)\n\n  t.end()\n})\n\ntap.test('function signature verification', (t) => {\n  t.test('function length', (t) => {\n    t.equal(Headers.prototype.append.length, 2)\n    t.equal(Headers.prototype.constructor.length, 0)\n    t.equal(Headers.prototype.delete.length, 1)\n    t.equal(Headers.prototype.entries.length, 0)\n    t.equal(Headers.prototype.forEach.length, 1)\n    t.equal(Headers.prototype.get.length, 1)\n    t.equal(Headers.prototype.has.length, 1)\n    t.equal(Headers.prototype.keys.length, 0)\n    t.equal(Headers.prototype.set.length, 2)\n    t.equal(Headers.prototype.values.length, 0)\n    t.equal(Headers.prototype[Symbol.iterator].length, 0)\n    t.equal(Headers.prototype.toString.length, 0)\n\n    t.end()\n  })\n\n  t.test('function equality', (t) => {\n    t.equal(Headers.prototype.entries, Headers.prototype[Symbol.iterator])\n    t.equal(Headers.prototype.toString, Object.prototype.toString)\n\n    t.end()\n  })\n\n  t.test('toString and Symbol.toStringTag', (t) => {\n    t.equal(Object.prototype.toString.call(Headers.prototype), '[object Headers]')\n    t.equal(Headers.prototype[Symbol.toStringTag], 'Headers')\n    t.equal(Headers.prototype.toString.call(null), '[object Null]')\n\n    t.end()\n  })\n\n  t.end()\n})\n\ntap.test('various init paths of Headers', (t) => {\n  const h1 = new Headers()\n  const h2 = new Headers({})\n  const h3 = new Headers(undefined)\n  t.equal([...h1.entries()].length, 0)\n  t.equal([...h2.entries()].length, 0)\n  t.equal([...h3.entries()].length, 0)\n\n  t.end()\n})\n\ntap.test('immutable guard', (t) => {\n  const headers = new Headers()\n  headers.set('key', 'val')\n  headers[kGuard] = 'immutable'\n\n  t.throws(() => {\n    headers.set('asd', 'asd')\n  })\n  t.throws(() => {\n    headers.append('asd', 'asd')\n  })\n  t.throws(() => {\n    headers.delete('asd')\n  })\n  t.equal(headers.get('key'), 'val')\n  t.equal(headers.has('key'), true)\n\n  t.end()\n})\n\ntap.test('request-no-cors guard', (t) => {\n  const headers = new Headers()\n  headers[kGuard] = 'request-no-cors'\n  t.doesNotThrow(() => { headers.set('key', 'val') })\n  t.doesNotThrow(() => { headers.append('key', 'val') })\n  t.doesNotThrow(() => { headers.delete('key') })\n  t.end()\n})\n\ntap.test('invalid headers', (t) => {\n  for (const byte of ['\\r', '\\n', '\\t', ' ', String.fromCharCode(128), '']) {\n    t.throws(() => {\n      new Headers().set(byte, 'test')\n    }, TypeError, 'invalid header name')\n  }\n\n  for (const byte of [\n    '\\0',\n    '\\r',\n    '\\n'\n  ]) {\n    t.throws(() => {\n      new Headers().set('a', `a${byte}b`)\n    }, TypeError, 'not allowed at all in header value')\n  }\n\n  t.doesNotThrow(() => {\n    new Headers().set('a', '\\r')\n  })\n\n  t.doesNotThrow(() => {\n    new Headers().set('a', '\\n')\n  })\n\n  t.throws(() => {\n    new Headers().set('a', Symbol('symbol'))\n  }, TypeError, 'symbols should throw')\n\n  t.end()\n})\n\ntap.test('headers that might cause a ReDoS', (t) => {\n  t.doesNotThrow(() => {\n    // This test will time out if the ReDoS attack is successful.\n    const headers = new Headers()\n    const attack = 'a' + '\\t'.repeat(500_000) + '\\ta'\n    headers.append('fhqwhgads', attack)\n  })\n\n  t.end()\n})\n\n\ntap.test('Headers.prototype.getSetCookie', (t) => {\n  t.test('Mutating the returned list does not affect the set-cookie list', (t) => {\n    const h = new Headers([\n      ['set-cookie', 'a=b'],\n      ['set-cookie', 'c=d']\n    ])\n\n    const old = h.getSetCookie()\n    h.getSetCookie().push('oh=no')\n    const now = h.getSetCookie()\n\n    t.same(old, now)\n    t.end()\n  })\n\n  t.end()\n})"], "filenames": ["lib/fetch/headers.js", "test/fetch/headers.js"], "buggy_code_start_loc": [27, 668], "buggy_code_end_loc": [31, 686], "fixing_code_start_loc": [27, 669], "fixing_code_end_loc": [33, 698], "type": "CWE-1333", "message": "Undici is an HTTP/1.1 client for Node.js. Prior to version 5.19.1, the `Headers.set()` and `Headers.append()` methods are vulnerable to Regular Expression Denial of Service (ReDoS) attacks when untrusted values are passed into the functions. This is due to the inefficient regular expression used to normalize the values in the `headerValueNormalize()` utility function. This vulnerability was patched in v5.19.1. No known workarounds are available.", "other": {"cve": {"id": "CVE-2023-24807", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-16T18:15:12.340", "lastModified": "2023-02-24T18:38:57.073", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Undici is an HTTP/1.1 client for Node.js. Prior to version 5.19.1, the `Headers.set()` and `Headers.append()` methods are vulnerable to Regular Expression Denial of Service (ReDoS) attacks when untrusted values are passed into the functions. This is due to the inefficient regular expression used to normalize the values in the `headerValueNormalize()` utility function. This vulnerability was patched in v5.19.1. No known workarounds are available."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:undici:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.19.1", "matchCriteriaId": "0C8DD628-9AE0-4AB8-9C30-28B60906F606"}]}]}], "references": [{"url": "https://github.com/nodejs/undici/commit/f2324e549943f0b0937b09fb1c0c16cc7c93abdf", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/nodejs/undici/releases/tag/v5.19.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/nodejs/undici/security/advisories/GHSA-r6ch-mqf9-qc9w", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://hackerone.com/bugs?report_id=1784449", "source": "security-advisories@github.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nodejs/undici/commit/f2324e549943f0b0937b09fb1c0c16cc7c93abdf"}}