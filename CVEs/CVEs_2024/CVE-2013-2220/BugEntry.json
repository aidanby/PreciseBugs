{"buggy_code": ["/*\nCopyright (c) 2003, Michael Bretterklieber <michael@bretterklieber.com>\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions \nare met:\n\n1. Redistributions of source code must retain the above copyright \n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright \n   notice, this list of conditions and the following disclaimer in the \n   documentation and/or other materials provided with the distribution.\n3. The names of the authors may not be used to endorse or promote products \n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \nIN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \nOF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING \nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, \nEVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThis code cannot simply be copied and put under the GNU Public License or \nany other GPL-like (LGPL, GPL2) License.\n\n    $Id$\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"php_ini.h\"\n#include \"php_network.h\"\n#include \"ext/standard/info.h\"\n#include \"php_radius.h\"\n#include \"radlib.h\"\n#include \"radlib_private.h\"\n\n#ifndef PHP_WIN32\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#endif\n\nvoid _radius_close(zend_rsrc_list_entry *rsrc TSRMLS_DC);\n\n/* If you declare any globals in php_radius.h uncomment this:\nZEND_DECLARE_MODULE_GLOBALS(radius)\n*/\n\n/* True global resources - no need for thread safety here */\nstatic int le_radius;\n\n/* {{{ radius_functions[]\n *\n * Every user visible function must have an entry in radius_functions[].\n */\nzend_function_entry radius_functions[] = {\n\tPHP_FE(radius_auth_open,    NULL)\n\tPHP_FE(radius_acct_open,    NULL)\n\tPHP_FE(radius_close,        NULL)\n\tPHP_FE(radius_strerror,     NULL)\n\tPHP_FE(radius_config,       NULL)\n\tPHP_FE(radius_add_server,\tNULL)\n\tPHP_FE(radius_create_request,\tNULL)\n\tPHP_FE(radius_put_string,\tNULL)\n\tPHP_FE(radius_put_int,\tNULL)\n\tPHP_FE(radius_put_attr,\tNULL)\n\tPHP_FE(radius_put_addr,\tNULL)\n\tPHP_FE(radius_put_vendor_string,\tNULL)\n\tPHP_FE(radius_put_vendor_int,\tNULL)\n\tPHP_FE(radius_put_vendor_attr,\tNULL)\n\tPHP_FE(radius_put_vendor_addr,\tNULL)\n\tPHP_FE(radius_send_request,\tNULL)\n\tPHP_FE(radius_get_attr,\tNULL)\n\tPHP_FE(radius_get_vendor_attr,\tNULL)\n\tPHP_FE(radius_cvt_addr,\tNULL)\n\tPHP_FE(radius_cvt_int,\tNULL)\n\tPHP_FE(radius_cvt_string,\tNULL)\n\tPHP_FE(radius_request_authenticator,\tNULL)\n\tPHP_FE(radius_server_secret,\tNULL)\n\tPHP_FE(radius_demangle,\tNULL)    \n\tPHP_FE(radius_demangle_mppe_key,\tNULL)    \n\t{NULL, NULL, NULL}\t/* Must be the last line in radius_functions[] */\n};\n/* }}} */\n\n/* {{{ radius_module_entry\n */\nzend_module_entry radius_module_entry = {\n#if ZEND_MODULE_API_NO >= 20010901\n\tSTANDARD_MODULE_HEADER,\n#endif\n\t\"radius\",\n\tradius_functions,\n\tPHP_MINIT(radius),\n\tPHP_MSHUTDOWN(radius),\n\tNULL,\n\tNULL,\n\tPHP_MINFO(radius),\n#if ZEND_MODULE_API_NO >= 20010901\n\tPHP_RADIUS_VERSION,\n#endif\n\tSTANDARD_MODULE_PROPERTIES\n};\n/* }}} */\n\n#ifdef COMPILE_DL_RADIUS\nZEND_GET_MODULE(radius)\n#endif\n\n/* {{{ PHP_MINIT_FUNCTION\n */\nPHP_MINIT_FUNCTION(radius)\n{\n\tle_radius = zend_register_list_destructors_ex(_radius_close, NULL, \"rad_handle\", module_number);\n#include \"radius_init_const.h\"\n\tREGISTER_LONG_CONSTANT(\"RADIUS_MPPE_KEY_LEN\", MPPE_KEY_LEN, CONST_PERSISTENT);    \n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MSHUTDOWN_FUNCTION\n */\nPHP_MSHUTDOWN_FUNCTION(radius)\n{\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MINFO_FUNCTION\n */\nPHP_MINFO_FUNCTION(radius)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"radius support\", \"enabled\");\n\tphp_info_print_table_row(2, \"version\", PHP_RADIUS_VERSION);\n\tphp_info_print_table_end();\n}\n/* }}} */\n\n/* {{{ proto ressource radius_auth_open(string arg) */\nPHP_FUNCTION(radius_auth_open)\n{\n\tradius_descriptor *raddesc;\n\n\traddesc = emalloc(sizeof(radius_descriptor));\n\traddesc->radh = rad_auth_open();\n\n\tif (raddesc->radh != NULL) {\n\t\tZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);\n\t\traddesc->id = Z_LVAL_P(return_value);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto ressource radius_acct_open(string arg) */\nPHP_FUNCTION(radius_acct_open)\n{\n\tradius_descriptor *raddesc;\n\n\traddesc = emalloc(sizeof(radius_descriptor));\n\traddesc->radh = rad_acct_open();\n\n\tif (raddesc->radh != NULL) {\n\t\tZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);\n\t\traddesc->id = Z_LVAL_P(return_value);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_close(radh) */\nPHP_FUNCTION(radius_close)\n{\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &z_radh) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\tzend_list_delete(raddesc->id);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto string radius_strerror(radh) */\nPHP_FUNCTION(radius_strerror)\n{\n\tchar *msg;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &z_radh) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\tmsg = (char *)rad_strerror(raddesc->radh);\n\tRETURN_STRINGL(msg, strlen(msg), 1);\n}\n/* }}} */\n\n/* {{{ proto bool radius_config(desc, configfile) */\nPHP_FUNCTION(radius_config)\n{\n\tchar *filename;\n\tint filename_len;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &z_radh, &filename, &filename_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_config(raddesc->radh, filename) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_add_server(desc, hostname, port, secret, timeout, maxtries) */\nPHP_FUNCTION(radius_add_server)\n{\n\tchar *hostname, *secret;\n\tint hostname_len, secret_len;\n\tlong  port, timeout, maxtries;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rslsll\", &z_radh,\n\t\t&hostname, &hostname_len,\n\t\t&port,\n\t\t&secret, &secret_len,\n\t\t&timeout, &maxtries) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_add_server(raddesc->radh, hostname, port, secret, timeout, maxtries) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_create_request(desc, code) */\nPHP_FUNCTION(radius_create_request)\n{\n\tlong code;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &z_radh, &code) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_create_request(raddesc->radh, code) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_string(desc, type, str) */\nPHP_FUNCTION(radius_put_string)\n{\n\tchar *str;\n\tint str_len;\n\tlong type;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rls\", &z_radh, &type, &str, &str_len)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_put_string(raddesc->radh, type, str) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_int(desc, type, int) */\nPHP_FUNCTION(radius_put_int)\n{\n\tlong type, val;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rll\", &z_radh, &type, &val)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_put_int(raddesc->radh, type, val) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_attr(desc, type, data) */\nPHP_FUNCTION(radius_put_attr)\n{\n\tlong type;\n\tint len;\n\tchar *data;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rls\", &z_radh, &type, &data, &len)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_put_attr(raddesc->radh, type, data, len) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_addr(desc, type, addr) */\nPHP_FUNCTION(radius_put_addr)\n{\n\tint addrlen;\n\tlong type;\n\tchar\t*addr;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\tstruct in_addr intern_addr;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rls\", &z_radh, &type, &addr, &addrlen)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (inet_aton(addr, &intern_addr) == 0) {\n\t\tzend_error(E_ERROR, \"Error converting Address\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (rad_put_addr(raddesc->radh, type, intern_addr) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_vendor_string(desc, vendor, type, str) */\nPHP_FUNCTION(radius_put_vendor_string)\n{\n\tchar *str;\n\tint str_len;\n\tlong type, vendor;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlls\", &z_radh, &vendor, &type, &str, &str_len)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_put_vendor_string(raddesc->radh, vendor, type, str) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_vendor_int(desc, vendor, type, int) */\nPHP_FUNCTION(radius_put_vendor_int)\n{\n\tlong type, vendor, val;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &z_radh, &vendor, &type, &val)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_put_vendor_int(raddesc->radh, vendor, type, val) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_vendor_attr(desc, vendor, type, data) */\nPHP_FUNCTION(radius_put_vendor_attr)\n{\n\tlong type, vendor;\n\tint len;\n\tchar *data;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlls\", &z_radh, &vendor, &type,\n\t\t&data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_put_vendor_attr(raddesc->radh, vendor, type, data, len) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_vendor_addr(desc, vendor, type, addr) */\nPHP_FUNCTION(radius_put_vendor_addr)\n{\n\tlong type, vendor;\n\tint addrlen;\n\tchar\t*addr;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\tstruct in_addr intern_addr;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlls\", &z_radh, &vendor,\n\t\t&type, &addr, &addrlen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (inet_aton(addr, &intern_addr) == 0) {\n\t\tzend_error(E_ERROR, \"Error converting Address\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (rad_put_vendor_addr(raddesc->radh, vendor, type, intern_addr) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_send_request(desc) */\nPHP_FUNCTION(radius_send_request)\n{\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\tint res;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &z_radh)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tres = rad_send_request(raddesc->radh);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_LONG(res);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string radius_get_attr(desc) */\nPHP_FUNCTION(radius_get_attr)\n{\n\tradius_descriptor *raddesc;\n\tint res;\n\tconst void *data;\n\tsize_t len;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &z_radh) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tres = rad_get_attr(raddesc->radh, &data, &len);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tif (res > 0) {\n\n\t\t\tarray_init(return_value);\n\t\t\tadd_assoc_long(return_value, \"attr\", res);\n\t\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);\n\t\t\treturn;\n\t\t}\n\t\tRETURN_LONG(res);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string radius_get_vendor_attr(data) */\nPHP_FUNCTION(radius_get_vendor_attr)\n{\n\tint res;\n\tconst void *data;\n\tint len;\n\tu_int32_t vendor;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tres = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\n\t\tarray_init(return_value);\n\t\tadd_assoc_long(return_value, \"attr\", res);\n\t\tadd_assoc_long(return_value, \"vendor\", vendor);\n\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);\n\t\treturn;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string radius_cvt_addr(data) */\nPHP_FUNCTION(radius_cvt_addr)\n{\n\tconst void *data;\n\tchar *addr_dot;\n\tint len;\n\tstruct in_addr addr;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\taddr = rad_cvt_addr(data);\n\taddr_dot = inet_ntoa(addr);\n\tRETURN_STRINGL(addr_dot, strlen(addr_dot), 1);\n}\n/* }}} */\n\n/* {{{ proto int radius_cvt_int(data) */\nPHP_FUNCTION(radius_cvt_int)\n{\n\tconst void *data;\n\tint len, val;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tval = rad_cvt_int(data);\n\tRETURN_LONG(val);\n}\n/* }}} */\n\n/* {{{ proto string radius_cvt_string(data) */\nPHP_FUNCTION(radius_cvt_string)\n{\n\tconst void *data;\n\tchar *val;\n\tint len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tval = rad_cvt_string(data, len);\n\tif (val == NULL) RETURN_FALSE;\n\tRETVAL_STRINGL(val, strlen(val), 1);\n\tfree(val);\n\treturn;\n}\n/* }}} */\n\n/* {{{ proto string radius_request_authenticator(radh) */\nPHP_FUNCTION(radius_request_authenticator)\n{\n\tradius_descriptor *raddesc;\n\tssize_t res;\n\tchar buf[LEN_AUTH];\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &z_radh) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tres = rad_request_authenticator(raddesc->radh, buf, sizeof buf);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_STRINGL(buf, res, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string radius_server_secret(radh) */\nPHP_FUNCTION(radius_server_secret)\n{\n\tchar *secret;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &z_radh) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\tsecret = (char *)rad_server_secret(raddesc->radh);\n\n\tif (secret) {\n\t\tRETURN_STRINGL(secret, strlen(secret), 1);\n\t}\n\n\tRETURN_FALSE;\n}\n/* }}} */\n\n/* {{{ proto string radius_demangle(radh, mangled) */\nPHP_FUNCTION(radius_demangle)\n{\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\tconst void *mangled;\n\tunsigned char *buf;\n\tint len, res;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &z_radh, &mangled, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tbuf = emalloc(len);\n\tres = rad_demangle(raddesc->radh, mangled, len, buf);\n\n\tif (res == -1) {\n\t\tefree(buf);\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETVAL_STRINGL((char *) buf, len, 1);\n\t\tefree(buf);\n\t\treturn;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string radius_demangle_mppe_key(radh, mangled) */\nPHP_FUNCTION(radius_demangle_mppe_key)\n{\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\tconst void *mangled;\n\tunsigned char *buf;\n\tsize_t dlen;\n\tint len, res;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &z_radh, &mangled, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tbuf = emalloc(len);\n\tres = rad_demangle_mppe_key(raddesc->radh, mangled, len, buf, &dlen);\n\tif (res == -1) {\n\t\tefree(buf);\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETVAL_STRINGL((char *) buf, dlen, 1);\n\t\tefree(buf);\n\t\treturn;\n\t}\n}\n/* }}} */\n\n/* {{{ _radius_close() */\nvoid _radius_close(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tradius_descriptor *raddesc = (radius_descriptor *)rsrc->ptr;\n\trad_close(raddesc->radh);\n\tefree(raddesc);\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=8 ts=8 fdm=marker\n * vim<600: noet sw=8 ts=8\n */\n", "/*-\n * Copyright 1998 Juniper Networks, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n *\t$FreeBSD: src/lib/libradius/radlib.c,v 1.4.2.3 2002/06/17 02:24:57 brian Exp $\n */\n\n#include <sys/types.h>\n\n#ifndef PHP_WIN32\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#else\n#include <process.h>\n#include \"win32/time.h\"\n#endif\n\n#include <errno.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifndef PHP_WIN32\n#include <unistd.h>\n#endif\n\n#include \"radlib_compat.h\"\n#include \"radlib_md5.h\"\n#include \"radlib_private.h\"\n\nstatic void\t clear_password(struct rad_handle *);\nstatic void\t generr(struct rad_handle *, const char *, ...)\n\t\t    __printflike(2, 3);\nstatic void\t insert_scrambled_password(struct rad_handle *, int);\nstatic void\t insert_request_authenticator(struct rad_handle *, int);\nstatic int\t is_valid_response(struct rad_handle *, int,\n\t\t    const struct sockaddr_in *);\nstatic int\t put_password_attr(struct rad_handle *, int,\n\t\t    const void *, size_t);\nstatic int\t put_raw_attr(struct rad_handle *, int,\n\t\t    const void *, size_t);\nstatic int\t split(char *, char *[], int, char *, size_t);\n\nstatic void\nclear_password(struct rad_handle *h)\n{\n\tif (h->pass_len != 0) {\n\t\tmemset(h->pass, 0, h->pass_len);\n\t\th->pass_len = 0;\n\t}\n\th->pass_pos = 0;\n}\n\nstatic void\ngenerr(struct rad_handle *h, const char *format, ...)\n{\n\tva_list\t\t ap;\n\n\tva_start(ap, format);\n\tvsnprintf(h->errmsg, ERRSIZE, format, ap);\n\tva_end(ap);\n}\n\nstatic void\ninsert_scrambled_password(struct rad_handle *h, int srv)\n{\n\tMD5_CTX ctx;\n\tunsigned char md5[16];\n\tconst struct rad_server *srvp;\n\tint padded_len;\n\tint pos;\n\n\tsrvp = &h->servers[srv];\n\tpadded_len = h->pass_len == 0 ? 16 : (h->pass_len+15) & ~0xf;\n\n\tmemcpy(md5, &h->request[POS_AUTH], LEN_AUTH);\n\tfor (pos = 0;  pos < padded_len;  pos += 16) {\n\t\tint i;\n\n\t\t/* Calculate the new scrambler */\n\t\tMD5Init(&ctx);\n\t\tMD5Update(&ctx, srvp->secret, strlen(srvp->secret));\n\t\tMD5Update(&ctx, md5, 16);\n\t\tMD5Final(md5, &ctx);\n\n\t\t/*\n\t\t * Mix in the current chunk of the password, and copy\n\t\t * the result into the right place in the request.  Also\n\t\t * modify the scrambler in place, since we will use this\n\t\t * in calculating the scrambler for next time.\n\t\t */\n\t\tfor (i = 0;  i < 16;  i++)\n\t\t\th->request[h->pass_pos + pos + i] =\n\t\t\t    md5[i] ^= h->pass[pos + i];\n\t}\n}\n\nstatic void\ninsert_request_authenticator(struct rad_handle *h, int srv)\n{\n\tMD5_CTX ctx;\n\tconst struct rad_server *srvp;\n\n\tsrvp = &h->servers[srv];\n\n\t/* Create the request authenticator */\n\tMD5Init(&ctx);\n\tMD5Update(&ctx, &h->request[POS_CODE], POS_AUTH - POS_CODE);\n\tMD5Update(&ctx, memset(&h->request[POS_AUTH], 0, LEN_AUTH), LEN_AUTH);\n\tMD5Update(&ctx, &h->request[POS_ATTRS], h->req_len - POS_ATTRS);\n\tMD5Update(&ctx, srvp->secret, strlen(srvp->secret));\n\tMD5Final(&h->request[POS_AUTH], &ctx);\n}\n\n/*\n * Return true if the current response is valid for a request to the\n * specified server.\n */\nstatic int\nis_valid_response(struct rad_handle *h, int srv,\n    const struct sockaddr_in *from)\n{\n\tMD5_CTX ctx;\n\tunsigned char md5[16];\n\tconst struct rad_server *srvp;\n\tint len;\n\n\tsrvp = &h->servers[srv];\n\n\t/* Check the source address */\n\tif (from->sin_family != srvp->addr.sin_family ||\n\t    from->sin_addr.s_addr != srvp->addr.sin_addr.s_addr ||\n\t    from->sin_port != srvp->addr.sin_port)\n\t\treturn 0;\n\n\t/* Check the message length */\n\tif (h->resp_len < POS_ATTRS)\n\t\treturn 0;\n\tlen = h->response[POS_LENGTH] << 8 | h->response[POS_LENGTH+1];\n\tif (len > h->resp_len)\n\t\treturn 0;\n\n\t/* Check the response authenticator */\n\tMD5Init(&ctx);\n\tMD5Update(&ctx, &h->response[POS_CODE], POS_AUTH - POS_CODE);\n\tMD5Update(&ctx, &h->request[POS_AUTH], LEN_AUTH);\n\tMD5Update(&ctx, &h->response[POS_ATTRS], len - POS_ATTRS);\n\tMD5Update(&ctx, srvp->secret, strlen(srvp->secret));\n\tMD5Final(md5, &ctx);\n\tif (memcmp(&h->response[POS_AUTH], md5, sizeof md5) != 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int\nput_password_attr(struct rad_handle *h, int type, const void *value, size_t len)\n{\n\tint padded_len;\n\tint pad_len;\n\n\tif (h->pass_pos != 0) {\n\t\tgenerr(h, \"Multiple User-Password attributes specified\");\n\t\treturn -1;\n\t}\n\tif (len > PASSSIZE)\n\t\tlen = PASSSIZE;\n\tpadded_len = len == 0 ? 16 : (len+15) & ~0xf;\n\tpad_len = padded_len - len;\n\n\t/*\n\t * Put in a place-holder attribute containing all zeros, and\n\t * remember where it is so we can fill it in later.\n\t */\n\tclear_password(h);\n\tput_raw_attr(h, type, h->pass, padded_len);\n\th->pass_pos = h->req_len - padded_len;\n\n\t/* Save the cleartext password, padded as necessary */\n\tmemcpy(h->pass, value, len);\n\th->pass_len = len;\n\tmemset(h->pass + len, 0, pad_len);\n\treturn 0;\n}\n\nstatic int\nput_raw_attr(struct rad_handle *h, int type, const void *value, size_t len)\n{\n\tif (len > 253) {\n\t\tgenerr(h, \"Attribute too long\");\n\t\treturn -1;\n\t}\n\t\n\tif (h->req_len + 2 + len > MSGSIZE) {\n\t\tgenerr(h, \"Maximum message length exceeded\");\n\t\treturn -1;\n\t}\n\th->request[h->req_len++] = type;\n\th->request[h->req_len++] = len + 2;\n\tmemcpy(&h->request[h->req_len], value, len);\n\th->req_len += len;\n\treturn 0;\n}\n\nint\nrad_add_server(struct rad_handle *h, const char *host, int port,\n    const char *secret, int timeout, int tries)\n{\n\tstruct rad_server *srvp;\n\n\tif (h->num_servers >= MAXSERVERS) {\n\t\tgenerr(h, \"Too many RADIUS servers specified\");\n\t\treturn -1;\n\t}\n\tsrvp = &h->servers[h->num_servers];\n\n\tmemset(&srvp->addr, 0, sizeof srvp->addr);\n\tsrvp->addr.sin_family = AF_INET;\n\tif (!inet_aton(host, &srvp->addr.sin_addr)) {\n\t\tstruct hostent *hent;\n\n\t\tif ((hent = gethostbyname(host)) == NULL) {\n\t\t\tgenerr(h, \"%s: host not found\", host);\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(&srvp->addr.sin_addr, hent->h_addr,\n\t\t    sizeof srvp->addr.sin_addr);\n\t}\n\tif (port != 0)\n\t\tsrvp->addr.sin_port = htons((short) port);\n\telse {\n\t\tstruct servent *sent;\n\n\t\tif (h->type == RADIUS_AUTH)\n\t\t\tsrvp->addr.sin_port =\n\t\t\t    (sent = getservbyname(\"radius\", \"udp\")) != NULL ?\n\t\t\t\tsent->s_port : htons(RADIUS_PORT);\n\t\telse\n\t\t\tsrvp->addr.sin_port =\n\t\t\t    (sent = getservbyname(\"radacct\", \"udp\")) != NULL ?\n\t\t\t\tsent->s_port : htons(RADACCT_PORT);\n\t}\n\tif ((srvp->secret = strdup(secret)) == NULL) {\n\t\tgenerr(h, \"Out of memory\");\n\t\treturn -1;\n\t}\n\tsrvp->timeout = timeout;\n\tsrvp->max_tries = tries;\n\tsrvp->num_tries = 0;\n\th->num_servers++;\n\treturn 0;\n}\n\nvoid\nrad_close(struct rad_handle *h)\n{\n\tint srv;\n\n\tif (h->fd != -1)\n\t\tclose(h->fd);\n\tfor (srv = 0;  srv < h->num_servers;  srv++) {\n\t\tmemset(h->servers[srv].secret, 0,\n\t\t    strlen(h->servers[srv].secret));\n\t\tfree(h->servers[srv].secret);\n\t}\n\tclear_password(h);\n\tfree(h);\n}\n\nint\nrad_config(struct rad_handle *h, const char *path)\n{\n\tFILE *fp;\n\tchar buf[MAXCONFLINE];\n\tint linenum;\n\tint retval;\n\n\tif (path == NULL)\n\t\tpath = PATH_RADIUS_CONF;\n\tif ((fp = fopen(path, \"r\")) == NULL) {\n\t\tgenerr(h, \"Cannot open \\\"%s\\\": %s\", path, strerror(errno));\n\t\treturn -1;\n\t}\n\tretval = 0;\n\tlinenum = 0;\n\twhile (fgets(buf, sizeof buf, fp) != NULL) {\n\t\tint len;\n\t\tchar *fields[5];\n\t\tint nfields;\n\t\tchar msg[ERRSIZE];\n\t\tchar *type;\n\t\tchar *host, *res;\n\t\tchar *port_str;\n\t\tchar *secret;\n\t\tchar *timeout_str;\n\t\tchar *maxtries_str;\n\t\tchar *end;\n\t\tchar *wanttype;\n\t\tunsigned long timeout;\n\t\tunsigned long maxtries;\n\t\tint port;\n\t\tint i;\n\n\t\tlinenum++;\n\t\tlen = strlen(buf);\n\t\t/* We know len > 0, else fgets would have returned NULL. */\n\t\tif (buf[len - 1] != '\\n' && !(buf[len - 2] != '\\r' && buf[len - 1] != '\\n')) {\n\t\t\tif (len == sizeof buf - 1)\n\t\t\t\tgenerr(h, \"%s:%d: line too long\", path,\n\t\t\t\t    linenum);\n\t\t\telse\n\t\t\t\tgenerr(h, \"%s:%d: missing newline\", path,\n\t\t\t\t    linenum);\n\t\t\tretval = -1;\n\t\t\tbreak;\n\t\t}\n\t\tbuf[len - 1] = '\\0';\n\n\t\t/* Extract the fields from the line. */\n\t\tnfields = split(buf, fields, 5, msg, sizeof msg);\n\t\tif (nfields == -1) {\n\t\t\tgenerr(h, \"%s:%d: %s\", path, linenum, msg);\n\t\t\tretval = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (nfields == 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * The first field should contain \"auth\" or \"acct\" for\n\t\t * authentication or accounting, respectively.  But older\n\t\t * versions of the file didn't have that field.  Default\n\t\t * it to \"auth\" for backward compatibility.\n\t\t */\n\t\tif (strcmp(fields[0], \"auth\") != 0 &&\n\t\t    strcmp(fields[0], \"acct\") != 0) {\n\t\t\tif (nfields >= 5) {\n\t\t\t\tgenerr(h, \"%s:%d: invalid service type\", path,\n\t\t\t\t    linenum);\n\t\t\t\tretval = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnfields++;\n\t\t\tfor (i = nfields;  --i > 0;  )\n\t\t\t\tfields[i] = fields[i - 1];\n\t\t\tfields[0] = \"auth\";\n\t\t}\n\t\tif (nfields < 3) {\n\t\t\tgenerr(h, \"%s:%d: missing shared secret\", path,\n\t\t\t    linenum);\n\t\t\tretval = -1;\n\t\t\tbreak;\n\t\t}\n\t\ttype = fields[0];\n\t\thost = fields[1];\n\t\tsecret = fields[2];\n\t\ttimeout_str = fields[3];\n\t\tmaxtries_str = fields[4];\n\n\t\t/* Ignore the line if it is for the wrong service type. */\n\t\twanttype = h->type == RADIUS_AUTH ? \"auth\" : \"acct\";\n\t\tif (strcmp(type, wanttype) != 0)\n\t\t\tcontinue;\n\n\t\t/* Parse and validate the fields. */\n\t\tres = host;\n\t\thost = strsep(&res, \":\");\n\t\tport_str = strsep(&res, \":\");\n\t\tif (port_str != NULL) {\n\t\t\tport = strtoul(port_str, &end, 10);\n\t\t\tif (*end != '\\0') {\n\t\t\t\tgenerr(h, \"%s:%d: invalid port\", path,\n\t\t\t\t    linenum);\n\t\t\t\tretval = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tport = 0;\n\t\tif (timeout_str != NULL) {\n\t\t\ttimeout = strtoul(timeout_str, &end, 10);\n\t\t\tif (*end != '\\0') {\n\t\t\t\tgenerr(h, \"%s:%d: invalid timeout\", path,\n\t\t\t\t    linenum);\n\t\t\t\tretval = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\ttimeout = TIMEOUT;\n\t\tif (maxtries_str != NULL) {\n\t\t\tmaxtries = strtoul(maxtries_str, &end, 10);\n\t\t\tif (*end != '\\0') {\n\t\t\t\tgenerr(h, \"%s:%d: invalid maxtries\", path,\n\t\t\t\t    linenum);\n\t\t\t\tretval = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tmaxtries = MAXTRIES;\n\n\t\tif (rad_add_server(h, host, port, secret, timeout, maxtries) ==\n\t\t    -1) {\n\t\t\tstrcpy(msg, h->errmsg);\n\t\t\tgenerr(h, \"%s:%d: %s\", path, linenum, msg);\n\t\t\tretval = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Clear out the buffer to wipe a possible copy of a shared secret */\n\tmemset(buf, 0, sizeof buf);\n\tfclose(fp);\n\treturn retval;\n}\n\n/*\n * rad_init_send_request() must have previously been called.\n * Returns:\n *   0     The application should select on *fd with a timeout of tv before\n *         calling rad_continue_send_request again.\n *   < 0   Failure\n *   > 0   Success\n */\nint\nrad_continue_send_request(struct rad_handle *h, int selected, int *fd,\n                          struct timeval *tv)\n{\n\tint n;\n\n\tif (selected) {\n\t\tstruct sockaddr_in from;\n\t\tint fromlen;\n\n\t\tfromlen = sizeof from;\n\t\th->resp_len = recvfrom(h->fd, h->response,\n\t\t    MSGSIZE, MSG_WAITALL, (struct sockaddr *)&from, &fromlen);\n\t\tif (h->resp_len == -1) {\n#ifdef PHP_WIN32\n\t\t\tgenerr(h, \"recfrom: %d\", WSAGetLastError());\n#else\n\t\t\tgenerr(h, \"recvfrom: %s\", strerror(errno));\n#endif\n\t\t\treturn -1;\n\t\t}\n\t\tif (is_valid_response(h, h->srv, &from)) {\n\t\t\th->resp_len = h->response[POS_LENGTH] << 8 |\n\t\t\t    h->response[POS_LENGTH+1];\n\t\t\th->resp_pos = POS_ATTRS;\n\t\t\treturn h->response[POS_CODE];\n\t\t}\n\t}\n\n\tif (h->try == h->total_tries) {\n\t\tgenerr(h, \"No valid RADIUS responses received\");\n\t\treturn -1;\n\t}\n\n\t/*\n         * Scan round-robin to the next server that has some\n         * tries left.  There is guaranteed to be one, or we\n         * would have exited this loop by now.\n\t */\n\twhile (h->servers[h->srv].num_tries >= h->servers[h->srv].max_tries)\n\t\tif (++h->srv >= h->num_servers)\n\t\t\th->srv = 0;\n\n\tif (h->request[POS_CODE] == RAD_ACCOUNTING_REQUEST)\n\t\t/* Insert the request authenticator into the request */\n\t\tinsert_request_authenticator(h, h->srv);\n\telse\n\t\t/* Insert the scrambled password into the request */\n\t\tif (h->pass_pos != 0)\n\t\t\tinsert_scrambled_password(h, h->srv);\n\n\t/* Send the request */\n\tn = sendto(h->fd, h->request, h->req_len, 0,\n\t    (const struct sockaddr *)&h->servers[h->srv].addr,\n\t    sizeof h->servers[h->srv].addr);\n\tif (n != h->req_len) {\n\t\tif (n == -1)\n#ifdef PHP_WIN32\n\t\t\tgenerr(h, \"sendto: %d\", WSAGetLastError());\n#else\n\t\t\tgenerr(h, \"sendto: %s\", strerror(errno));\n#endif\n\t\telse\n\t\t\tgenerr(h, \"sendto: short write\");\n\t\treturn -1;\n\t}\n\n\th->try++;\n\th->servers[h->srv].num_tries++;\n\ttv->tv_sec = h->servers[h->srv].timeout;\n\ttv->tv_usec = 0;\n\t*fd = h->fd;\n\n\treturn 0;\n}\n\nint\nrad_create_request(struct rad_handle *h, int code)\n{\n\tint i;\n\n\th->request[POS_CODE] = code;\n\th->request[POS_IDENT] = ++h->ident;\n\t/* Create a random authenticator */\n\tfor (i = 0;  i < LEN_AUTH;  i += 2) {\n\t\tlong r;\n\t\tTSRMLS_FETCH();\n\t\tr = php_rand(TSRMLS_C);\n\t\th->request[POS_AUTH+i] = (unsigned char) r;\n\t\th->request[POS_AUTH+i+1] = (unsigned char) (r >> 8);\n\t}\n\th->req_len = POS_ATTRS;\n\th->request_created = 1;    \n\tclear_password(h);\n\treturn 0;\n}\n\nstruct in_addr\nrad_cvt_addr(const void *data)\n{\n\tstruct in_addr value;\n\n\tmemcpy(&value.s_addr, data, sizeof value.s_addr);\n\treturn value;\n}\n\nu_int32_t\nrad_cvt_int(const void *data)\n{\n\tu_int32_t value;\n\n\tmemcpy(&value, data, sizeof value);\n\treturn ntohl(value);\n}\n\nchar *\nrad_cvt_string(const void *data, size_t len)\n{\n\tchar *s;\n\n\ts = malloc(len + 1);\n\tif (s != NULL) {\n\t\tmemcpy(s, data, len);\n\t\ts[len] = '\\0';\n\t}\n\treturn s;\n}\n\n/*\n * Returns the attribute type.  If none are left, returns 0.  On failure,\n * returns -1.\n */\nint\nrad_get_attr(struct rad_handle *h, const void **value, size_t *len)\n{\n\tint type;\n\n\tif (h->resp_pos >= h->resp_len)\n\t\treturn 0;\n\tif (h->resp_pos + 2 > h->resp_len) {\n\t\tgenerr(h, \"Malformed attribute in response\");\n\t\treturn -1;\n\t}\n\ttype = h->response[h->resp_pos++];\n\t*len = h->response[h->resp_pos++] - 2;\n\tif (h->resp_pos + (int) *len > h->resp_len) {\n\t\tgenerr(h, \"Malformed attribute in response\");\n\t\treturn -1;\n\t}\n\t*value = &h->response[h->resp_pos];\n\th->resp_pos += *len;\n\treturn type;\n}\n\n/*\n * Returns -1 on error, 0 to indicate no event and >0 for success\n */\nint\nrad_init_send_request(struct rad_handle *h, int *fd, struct timeval *tv)\n{\n\tint srv;\n\n\t/* Make sure we have a socket to use */\n\tif (h->fd == -1) {\n\t\tstruct sockaddr_in sin;\n\n\t\tif ((h->fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) {\n#ifdef PHP_WIN32\n\t\t\tgenerr(h, \"Cannot create socket: %d\", WSAGetLastError());\n#else\n\t\t\tgenerr(h, \"Cannot create socket: %s\", strerror(errno));\n#endif\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(&sin, 0, sizeof sin);\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = INADDR_ANY;\n\t\tsin.sin_port = htons(0);\n\t\tif (bind(h->fd, (const struct sockaddr *)&sin,\n\t\t    sizeof sin) == -1) {\n#ifdef PHP_WIN32\n\t\t\tgenerr(h, \"bind: %d\", WSAGetLastError());\n#else\n\t\t\tgenerr(h, \"bind: %s\", strerror(errno));\n#endif\n\t\t\tclose(h->fd);\n\t\t\th->fd = -1;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (h->request[POS_CODE] == RAD_ACCOUNTING_REQUEST) {\n\t\t/* Make sure no password given */\n\t\tif (h->pass_pos || h->chap_pass) {\n\t\t\tgenerr(h, \"User or Chap Password in accounting request\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* Make sure the user gave us a password */\n\t\tif (h->pass_pos == 0 && !h->chap_pass) {\n\t\t\tgenerr(h, \"No User or Chap Password attributes given\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (h->pass_pos != 0 && h->chap_pass) {\n\t\t\tgenerr(h, \"Both User and Chap Password attributes given\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Fill in the length field in the message */\n\th->request[POS_LENGTH] = h->req_len >> 8;\n\th->request[POS_LENGTH+1] = h->req_len;\n\n\t/*\n\t * Count the total number of tries we will make, and zero the\n\t * counter for each server.\n\t */\n\th->total_tries = 0;\n\tfor (srv = 0;  srv < h->num_servers;  srv++) {\n\t\th->total_tries += h->servers[srv].max_tries;\n\t\th->servers[srv].num_tries = 0;\n\t}\n\tif (h->total_tries == 0) {\n\t\tgenerr(h, \"No RADIUS servers specified\");\n\t\treturn -1;\n\t}\n\n\th->try = h->srv = 0;\n\n\treturn rad_continue_send_request(h, 0, fd, tv);\n}\n\n/*\n * Create and initialize a rad_handle structure, and return it to the\n * caller.  Can fail only if the necessary memory cannot be allocated.\n * In that case, it returns NULL.\n */\nstruct rad_handle *\nrad_auth_open(void)\n{\n\tstruct rad_handle *h;\n\n\th = (struct rad_handle *)malloc(sizeof(struct rad_handle));\n\tif (h != NULL) {\n\t\tTSRMLS_FETCH();\n\t\tphp_srand(time(NULL) * getpid() * (unsigned long) (php_combined_lcg(TSRMLS_C) * 10000.0) TSRMLS_CC);\n\t\th->fd = -1;\n\t\th->num_servers = 0;\n\t\th->ident = php_rand(TSRMLS_C);\n\t\th->errmsg[0] = '\\0';\n\t\tmemset(h->pass, 0, sizeof h->pass);\n\t\th->pass_len = 0;\n\t\th->pass_pos = 0;\n\t\th->chap_pass = 0;\n\t\th->type = RADIUS_AUTH;\n        h->request_created = 0;        \n\t}\n\treturn h;\n}\n\nstruct rad_handle *\nrad_acct_open(void)\n{\n\tstruct rad_handle *h;\n\n\th = rad_open();\n\tif (h != NULL)\n\t        h->type = RADIUS_ACCT;\n\treturn h;\n}\n\nstruct rad_handle *\nrad_open(void)\n{\n    return rad_auth_open();\n}\n\nint\nrad_put_addr(struct rad_handle *h, int type, struct in_addr addr)\n{\n\treturn rad_put_attr(h, type, &addr.s_addr, sizeof addr.s_addr);\n}\n\nint\nrad_put_attr(struct rad_handle *h, int type, const void *value, size_t len)\n{\n\tint result;\n\n    if (!h->request_created) {\n        generr(h, \"Please call rad_create_request()\");\n        return -1;\n    }\n\n\tif (type == RAD_USER_PASSWORD)\n\t\tresult = put_password_attr(h, type, value, len);\n\telse {\n\t\tresult = put_raw_attr(h, type, value, len);\n\t\tif (result == 0 && type == RAD_CHAP_PASSWORD)\n\t\t\th->chap_pass = 1;\n\t}\n\n\treturn result;\n}\n\nint\nrad_put_int(struct rad_handle *h, int type, u_int32_t value)\n{\n\tu_int32_t nvalue;\n\n\tnvalue = htonl(value);\n\treturn rad_put_attr(h, type, &nvalue, sizeof nvalue);\n}\n\nint\nrad_put_string(struct rad_handle *h, int type, const char *str)\n{\n\treturn rad_put_attr(h, type, str, strlen(str));\n}\n\n/*\n * Returns the response type code on success, or -1 on failure.\n */\nint\nrad_send_request(struct rad_handle *h)\n{\n\tstruct timeval timelimit;\n\tstruct timeval tv;\n\tint fd;\n\tint n;\n\n\tn = rad_init_send_request(h, &fd, &tv);\n\n\tif (n != 0)\n\t\treturn n;\n\n\tgettimeofday(&timelimit, NULL);\n\ttimeradd(&tv, &timelimit, &timelimit);\n\n\tfor ( ; ; ) {\n\t\tfd_set readfds;\n\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(fd, &readfds);\n\n\t\tn = select(fd + 1, &readfds, NULL, NULL, &tv);\n\n\t\tif (n == -1) {\n\t\t\tgenerr(h, \"select: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!FD_ISSET(fd, &readfds)) {\n\t\t\t/* Compute a new timeout */\n\t\t\tgettimeofday(&tv, NULL);\n\t\t\ttimersub(&timelimit, &tv, &tv);\n\t\t\tif (tv.tv_sec > 0 || (tv.tv_sec == 0 && tv.tv_usec > 0))\n\t\t\t\t/* Continue the select */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tn = rad_continue_send_request(h, n, &fd, &tv);\n\n\t\tif (n != 0)\n\t\t\treturn n;\n\n\t\tgettimeofday(&timelimit, NULL);\n\t\ttimeradd(&tv, &timelimit, &timelimit);\n\t}\n}\n\nconst char *\nrad_strerror(struct rad_handle *h)\n{\n\treturn h->errmsg;\n}\n\n/*\n * Destructively split a string into fields separated by white space.\n * `#' at the beginning of a field begins a comment that extends to the\n * end of the string.  Fields may be quoted with `\"'.  Inside quoted\n * strings, the backslash escapes `\\\"' and `\\\\' are honored.\n *\n * Pointers to up to the first maxfields fields are stored in the fields\n * array.  Missing fields get NULL pointers.\n *\n * The return value is the actual number of fields parsed, and is always\n * <= maxfields.\n *\n * On a syntax error, places a message in the msg string, and returns -1.\n */\nstatic int\nsplit(char *str, char *fields[], int maxfields, char *msg, size_t msglen)\n{\n\tchar *p;\n\tint i;\n\tstatic const char ws[] = \" \\t\";\n\n\tfor (i = 0;  i < maxfields;  i++)\n\t\tfields[i] = NULL;\n\tp = str;\n\ti = 0;\n\twhile (*p != '\\0') {\n\t\tp += strspn(p, ws);\n\t\tif (*p == '#' || *p == '\\0')\n\t\t\tbreak;\n\t\tif (i >= maxfields) {\n\t\t\tsnprintf(msg, msglen, \"line has too many fields\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (*p == '\"') {\n\t\t\tchar *dst;\n\n\t\t\tdst = ++p;\n\t\t\tfields[i] = dst;\n\t\t\twhile (*p != '\"') {\n\t\t\t\tif (*p == '\\\\') {\n\t\t\t\t\tp++;\n\t\t\t\t\tif (*p != '\"' && *p != '\\\\' &&\n\t\t\t\t\t    *p != '\\0') {\n\t\t\t\t\t\tsnprintf(msg, msglen,\n\t\t\t\t\t\t    \"invalid `\\\\' escape\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\tsnprintf(msg, msglen,\n\t\t\t\t\t    \"unterminated quoted string\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*dst++ = *p++;\n\t\t\t}\n\t\t\t*dst = '\\0';\n\t\t\tp++;\n\t\t\tif (*fields[i] == '\\0') {\n\t\t\t\tsnprintf(msg, msglen,\n\t\t\t\t    \"empty quoted string not permitted\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (*p != '\\0' && strspn(p, ws) == 0) {\n\t\t\t\tsnprintf(msg, msglen, \"quoted string not\"\n\t\t\t\t    \" followed by white space\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tfields[i] = p;\n\t\t\tp += strcspn(p, ws);\n\t\t\tif (*p != '\\0')\n\t\t\t\t*p++ = '\\0';\n\t\t}\n\t\ti++;\n\t}\n\treturn i;\n}\n\nint\nrad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\n\treturn (attr->attrib_type);\n}\n\nint\nrad_put_vendor_addr(struct rad_handle *h, int vendor, int type,\n    struct in_addr addr)\n{\n\treturn (rad_put_vendor_attr(h, vendor, type, &addr.s_addr,\n\t    sizeof addr.s_addr));\n}\n\nint\nrad_put_vendor_attr(struct rad_handle *h, int vendor, int type,\n    const void *value, size_t len)\n{\n\tstruct vendor_attribute *attr;\n\tint res;\n    \n    if (!h->request_created) {\n        generr(h, \"Please call rad_create_request()\");\n        return -1;\n    }    \n\n\tif ((attr = malloc(len + 6)) == NULL) {\n\t\tgenerr(h, \"malloc failure (%d bytes)\", len + 6);\n\t\treturn -1;\n\t}\n\n\tattr->vendor_value = htonl(vendor);\n\tattr->attrib_type = type;\n\tattr->attrib_len = len + 2;\n\tmemcpy(attr->attrib_data, value, len);\n\n\tres = put_raw_attr(h, RAD_VENDOR_SPECIFIC, attr, len + 6);\n\tfree(attr);\n\tif (res == 0 && vendor == RAD_VENDOR_MICROSOFT\n\t    && (type == RAD_MICROSOFT_MS_CHAP_RESPONSE\n\t    || type == RAD_MICROSOFT_MS_CHAP2_RESPONSE)) {\n\t\th->chap_pass = 1;\n\t}\n\treturn (res);\n}\n\nint\nrad_put_vendor_int(struct rad_handle *h, int vendor, int type, u_int32_t i)\n{\n\tu_int32_t value;\n\n\tvalue = htonl(i);\n\treturn (rad_put_vendor_attr(h, vendor, type, &value, sizeof value));\n}\n\nint\nrad_put_vendor_string(struct rad_handle *h, int vendor, int type,\n    const char *str)\n{\n\treturn (rad_put_vendor_attr(h, vendor, type, str, strlen(str)));\n}\n\nssize_t\nrad_request_authenticator(struct rad_handle *h, char *buf, size_t len)\n{\n\tif (len < LEN_AUTH)\n\t\treturn (-1);\n\tmemcpy(buf, h->request + POS_AUTH, LEN_AUTH);\n\tif (len > LEN_AUTH)\n\t\tbuf[LEN_AUTH] = '\\0';\n\treturn (LEN_AUTH);\n}\n\nconst char *\nrad_server_secret(struct rad_handle *h)\n{\n\tif (h->srv >= h->num_servers) {\n\t\tgenerr(h, \"No RADIUS servers specified\");\n\t\treturn NULL;\n\t}\n\n\treturn (h->servers[h->srv].secret);\n}\n\nint\nrad_demangle(struct rad_handle *h, const void *mangled, size_t mlen, u_char *demangled) \n{\n\tchar R[LEN_AUTH];\n\tconst char *S;\n\tint i, Ppos;\n\tMD5_CTX Context;\n\tu_char b[16], *C;\n\n\tif ((mlen % 16 != 0) || (mlen > 128)) {\n\t\tgenerr(h, \"Cannot interpret mangled data of length %ld\", (u_long)mlen);\n\t\treturn -1;\n\t}\n\n\tC = (u_char *)mangled;\n\n\t/* We need the shared secret as Salt */\n\tS = rad_server_secret(h);\n\n\t/* We need the request authenticator */\n\tif (rad_request_authenticator(h, R, sizeof R) != LEN_AUTH) {\n\t\tgenerr(h, \"Cannot obtain the RADIUS request authenticator\");\n                return -1;\n\t}\n\n\tMD5Init(&Context);\n\tMD5Update(&Context, S, strlen(S));\n\tMD5Update(&Context, R, LEN_AUTH);\n\tMD5Final(b, &Context);\n\tPpos = 0;\n\twhile (mlen) {\n\n\t\tmlen -= 16;\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tdemangled[Ppos++] = C[i] ^ b[i];\n\n\t\tif (mlen) {\n\t\t\tMD5Init(&Context);\n\t\t\tMD5Update(&Context, S, strlen(S));\n\t\t\tMD5Update(&Context, C, 16);\n\t\t\tMD5Final(b, &Context);\n\t\t}\n\n\t\tC += 16;\n\t}\n\n\treturn 0;\n}\n\nint\nrad_demangle_mppe_key(struct rad_handle *h, const void *mangled, size_t mlen, u_char *demangled, size_t *len)\n{\n\tchar R[LEN_AUTH];    /* variable names as per rfc2548 */\n\tconst char *S;\n\tu_char b[16];\n\tconst u_char *A, *C;\n\tMD5_CTX Context;\n\tint Slen, i, Clen, Ppos;\n\tu_char *P;\n\n\tif (mlen % 16 != SALT_LEN) {\n\t\tgenerr(h, \"Cannot interpret mangled data of length %ld\", (u_long)mlen);\n\t\treturn -1;\n\t}\n\n\t/* We need the RADIUS Request-Authenticator */\n\tif (rad_request_authenticator(h, R, sizeof R) != LEN_AUTH) {\n\t\tgenerr(h, \"Cannot obtain the RADIUS request authenticator\");\n\t\treturn -1;\n\t}\n\n\tA = (const u_char *)mangled;      /* Salt comes first */\n\tC = (const u_char *)mangled + SALT_LEN;  /* Then the ciphertext */\n\tClen = mlen - SALT_LEN;\n\tS = rad_server_secret(h);    /* We need the RADIUS secret */\n\tSlen = strlen(S);\n\tP = alloca(Clen);        /* We derive our plaintext */\n\n\tMD5Init(&Context);\n\tMD5Update(&Context, S, Slen);\n\tMD5Update(&Context, R, LEN_AUTH);\n\tMD5Update(&Context, A, SALT_LEN);\n\tMD5Final(b, &Context);\n\tPpos = 0;\n\n\twhile (Clen) {\n\t\tClen -= 16;\n\n\t\tfor (i = 0; i < 16; i++)\n\t\t    P[Ppos++] = C[i] ^ b[i];\n\n\t\tif (Clen) {\n\t\t\tMD5Init(&Context);\n\t\t\tMD5Update(&Context, S, Slen);\n\t\t\tMD5Update(&Context, C, 16);\n\t\t\tMD5Final(b, &Context);\n\t\t}\n                \n\t\tC += 16;\n\t}\n\n\t/*\n\t* The resulting plain text consists of a one-byte length, the text and\n\t* maybe some padding.\n\t*/\n\t*len = *P;\n\tif (*len > mlen - 1) {\n\t\tgenerr(h, \"Mangled data seems to be garbage %d %d\", *len, mlen-1);        \n\t\treturn -1;\n\t}\n\n\tif (*len > MPPE_KEY_LEN) {\n\t\tgenerr(h, \"Key to long (%d) for me max. %d\", *len, MPPE_KEY_LEN);        \n\t\treturn -1;\n\t}\n\n\tmemcpy(demangled, P + 1, *len);\n\treturn 0;\n}\n\n/* vim: set ts=8 sw=8 noet: */\n", "/*-\n * Copyright (c) 2002-2003 Brian Somers <brian@Awfulhak.org>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * $FreeBSD: src/lib/libradius/radlib_vs.h,v 1.2.2.1 2002/06/17 02:24:57 brian Exp $\n */\n\n#ifndef _RADLIB_VS_H_\n#define _RADLIB_VS_H_\n\n#include <sys/types.h>\n#ifndef PHP_WIN32\n#include <netinet/in.h>\n#endif\n\n#include \"radlib_compat.h\"\n\n#define\tRAD_VENDOR_MICROSOFT\t311\t\t/* rfc2548 */\n\t#define\tRAD_MICROSOFT_MS_CHAP_RESPONSE\t\t\t1\n\t#define\tRAD_MICROSOFT_MS_CHAP_ERROR\t\t\t2\n\t#define\tRAD_MICROSOFT_MS_CHAP_PW_1\t\t\t3\n\t#define\tRAD_MICROSOFT_MS_CHAP_PW_2\t\t\t4\n\t#define\tRAD_MICROSOFT_MS_CHAP_LM_ENC_PW\t\t\t5\n\t#define\tRAD_MICROSOFT_MS_CHAP_NT_ENC_PW\t\t\t6\n\t#define\tRAD_MICROSOFT_MS_MPPE_ENCRYPTION_POLICY\t\t7\n\t#define\tRAD_MICROSOFT_MS_MPPE_ENCRYPTION_TYPES\t\t8\n\t#define\tRAD_MICROSOFT_MS_RAS_VENDOR\t\t\t9\n\t#define\tRAD_MICROSOFT_MS_CHAP_DOMAIN\t\t\t10\n\t#define\tRAD_MICROSOFT_MS_CHAP_CHALLENGE\t\t\t11\n\t#define\tRAD_MICROSOFT_MS_CHAP_MPPE_KEYS\t\t\t12\n\t#define\tRAD_MICROSOFT_MS_BAP_USAGE\t\t\t13\n\t#define\tRAD_MICROSOFT_MS_LINK_UTILIZATION_THRESHOLD\t14\n\t#define\tRAD_MICROSOFT_MS_LINK_DROP_TIME_LIMIT\t\t15\n\t#define\tRAD_MICROSOFT_MS_MPPE_SEND_KEY\t\t\t16\n\t#define\tRAD_MICROSOFT_MS_MPPE_RECV_KEY\t\t\t17\n\t#define\tRAD_MICROSOFT_MS_RAS_VERSION\t\t\t18\n\t#define\tRAD_MICROSOFT_MS_OLD_ARAP_PASSWORD\t\t19\n\t#define\tRAD_MICROSOFT_MS_NEW_ARAP_PASSWORD\t\t20\n\t#define\tRAD_MICROSOFT_MS_ARAP_PASSWORD_CHANGE_REASON\t21\n\t#define\tRAD_MICROSOFT_MS_FILTER\t\t\t\t22\n\t#define\tRAD_MICROSOFT_MS_ACCT_AUTH_TYPE\t\t\t23\n\t#define\tRAD_MICROSOFT_MS_ACCT_EAP_TYPE\t\t\t24\n\t#define\tRAD_MICROSOFT_MS_CHAP2_RESPONSE\t\t\t25\n\t#define\tRAD_MICROSOFT_MS_CHAP2_SUCCESS\t\t\t26\n\t#define\tRAD_MICROSOFT_MS_CHAP2_PW\t\t\t27\n\t#define\tRAD_MICROSOFT_MS_PRIMARY_DNS_SERVER\t\t28\n\t#define\tRAD_MICROSOFT_MS_SECONDARY_DNS_SERVER\t\t29\n\t#define\tRAD_MICROSOFT_MS_PRIMARY_NBNS_SERVER\t\t30\n\t#define\tRAD_MICROSOFT_MS_SECONDARY_NBNS_SERVER\t\t31\n\t#define\tRAD_MICROSOFT_MS_ARAP_CHALLENGE\t\t\t33\n\n#define SALT_LEN    2\n\nstruct rad_handle;\n\nint\trad_get_vendor_attr(u_int32_t *, const void **, size_t *);\nint\trad_put_vendor_addr(struct rad_handle *, int, int, struct in_addr);\nint\trad_put_vendor_attr(struct rad_handle *, int, int, const void *,\n\t    size_t);\nint\trad_put_vendor_int(struct rad_handle *, int, int, u_int32_t);\nint\trad_put_vendor_string(struct rad_handle *, int, int, const char *);\nint\trad_demangle_mppe_key(struct rad_handle *, const void *, size_t, u_char *, size_t *);\n\n#endif /* _RADLIB_VS_H_ */\n\n/* vim: set ts=8 sw=8 noet: */\n"], "fixing_code": ["/*\nCopyright (c) 2003, Michael Bretterklieber <michael@bretterklieber.com>\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions \nare met:\n\n1. Redistributions of source code must retain the above copyright \n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright \n   notice, this list of conditions and the following disclaimer in the \n   documentation and/or other materials provided with the distribution.\n3. The names of the authors may not be used to endorse or promote products \n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \nIN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, \nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY \nOF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING \nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, \nEVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThis code cannot simply be copied and put under the GNU Public License or \nany other GPL-like (LGPL, GPL2) License.\n\n    $Id$\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"php_ini.h\"\n#include \"php_network.h\"\n#include \"ext/standard/info.h\"\n#include \"php_radius.h\"\n#include \"radlib.h\"\n#include \"radlib_private.h\"\n\n#ifndef PHP_WIN32\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#endif\n\nvoid _radius_close(zend_rsrc_list_entry *rsrc TSRMLS_DC);\n\n/* If you declare any globals in php_radius.h uncomment this:\nZEND_DECLARE_MODULE_GLOBALS(radius)\n*/\n\n/* True global resources - no need for thread safety here */\nstatic int le_radius;\n\n/* {{{ radius_functions[]\n *\n * Every user visible function must have an entry in radius_functions[].\n */\nzend_function_entry radius_functions[] = {\n\tPHP_FE(radius_auth_open,    NULL)\n\tPHP_FE(radius_acct_open,    NULL)\n\tPHP_FE(radius_close,        NULL)\n\tPHP_FE(radius_strerror,     NULL)\n\tPHP_FE(radius_config,       NULL)\n\tPHP_FE(radius_add_server,\tNULL)\n\tPHP_FE(radius_create_request,\tNULL)\n\tPHP_FE(radius_put_string,\tNULL)\n\tPHP_FE(radius_put_int,\tNULL)\n\tPHP_FE(radius_put_attr,\tNULL)\n\tPHP_FE(radius_put_addr,\tNULL)\n\tPHP_FE(radius_put_vendor_string,\tNULL)\n\tPHP_FE(radius_put_vendor_int,\tNULL)\n\tPHP_FE(radius_put_vendor_attr,\tNULL)\n\tPHP_FE(radius_put_vendor_addr,\tNULL)\n\tPHP_FE(radius_send_request,\tNULL)\n\tPHP_FE(radius_get_attr,\tNULL)\n\tPHP_FE(radius_get_vendor_attr,\tNULL)\n\tPHP_FE(radius_cvt_addr,\tNULL)\n\tPHP_FE(radius_cvt_int,\tNULL)\n\tPHP_FE(radius_cvt_string,\tNULL)\n\tPHP_FE(radius_request_authenticator,\tNULL)\n\tPHP_FE(radius_server_secret,\tNULL)\n\tPHP_FE(radius_demangle,\tNULL)    \n\tPHP_FE(radius_demangle_mppe_key,\tNULL)    \n\t{NULL, NULL, NULL}\t/* Must be the last line in radius_functions[] */\n};\n/* }}} */\n\n/* {{{ radius_module_entry\n */\nzend_module_entry radius_module_entry = {\n#if ZEND_MODULE_API_NO >= 20010901\n\tSTANDARD_MODULE_HEADER,\n#endif\n\t\"radius\",\n\tradius_functions,\n\tPHP_MINIT(radius),\n\tPHP_MSHUTDOWN(radius),\n\tNULL,\n\tNULL,\n\tPHP_MINFO(radius),\n#if ZEND_MODULE_API_NO >= 20010901\n\tPHP_RADIUS_VERSION,\n#endif\n\tSTANDARD_MODULE_PROPERTIES\n};\n/* }}} */\n\n#ifdef COMPILE_DL_RADIUS\nZEND_GET_MODULE(radius)\n#endif\n\n/* {{{ PHP_MINIT_FUNCTION\n */\nPHP_MINIT_FUNCTION(radius)\n{\n\tle_radius = zend_register_list_destructors_ex(_radius_close, NULL, \"rad_handle\", module_number);\n#include \"radius_init_const.h\"\n\tREGISTER_LONG_CONSTANT(\"RADIUS_MPPE_KEY_LEN\", MPPE_KEY_LEN, CONST_PERSISTENT);    \n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MSHUTDOWN_FUNCTION\n */\nPHP_MSHUTDOWN_FUNCTION(radius)\n{\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MINFO_FUNCTION\n */\nPHP_MINFO_FUNCTION(radius)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"radius support\", \"enabled\");\n\tphp_info_print_table_row(2, \"version\", PHP_RADIUS_VERSION);\n\tphp_info_print_table_end();\n}\n/* }}} */\n\n/* {{{ proto ressource radius_auth_open(string arg) */\nPHP_FUNCTION(radius_auth_open)\n{\n\tradius_descriptor *raddesc;\n\n\traddesc = emalloc(sizeof(radius_descriptor));\n\traddesc->radh = rad_auth_open();\n\n\tif (raddesc->radh != NULL) {\n\t\tZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);\n\t\traddesc->id = Z_LVAL_P(return_value);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto ressource radius_acct_open(string arg) */\nPHP_FUNCTION(radius_acct_open)\n{\n\tradius_descriptor *raddesc;\n\n\traddesc = emalloc(sizeof(radius_descriptor));\n\traddesc->radh = rad_acct_open();\n\n\tif (raddesc->radh != NULL) {\n\t\tZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);\n\t\traddesc->id = Z_LVAL_P(return_value);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_close(radh) */\nPHP_FUNCTION(radius_close)\n{\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &z_radh) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\tzend_list_delete(raddesc->id);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto string radius_strerror(radh) */\nPHP_FUNCTION(radius_strerror)\n{\n\tchar *msg;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &z_radh) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\tmsg = (char *)rad_strerror(raddesc->radh);\n\tRETURN_STRINGL(msg, strlen(msg), 1);\n}\n/* }}} */\n\n/* {{{ proto bool radius_config(desc, configfile) */\nPHP_FUNCTION(radius_config)\n{\n\tchar *filename;\n\tint filename_len;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &z_radh, &filename, &filename_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_config(raddesc->radh, filename) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_add_server(desc, hostname, port, secret, timeout, maxtries) */\nPHP_FUNCTION(radius_add_server)\n{\n\tchar *hostname, *secret;\n\tint hostname_len, secret_len;\n\tlong  port, timeout, maxtries;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rslsll\", &z_radh,\n\t\t&hostname, &hostname_len,\n\t\t&port,\n\t\t&secret, &secret_len,\n\t\t&timeout, &maxtries) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_add_server(raddesc->radh, hostname, port, secret, timeout, maxtries) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_create_request(desc, code) */\nPHP_FUNCTION(radius_create_request)\n{\n\tlong code;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &z_radh, &code) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_create_request(raddesc->radh, code) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_string(desc, type, str) */\nPHP_FUNCTION(radius_put_string)\n{\n\tchar *str;\n\tint str_len;\n\tlong type;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rls\", &z_radh, &type, &str, &str_len)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_put_string(raddesc->radh, type, str) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_int(desc, type, int) */\nPHP_FUNCTION(radius_put_int)\n{\n\tlong type, val;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rll\", &z_radh, &type, &val)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_put_int(raddesc->radh, type, val) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_attr(desc, type, data) */\nPHP_FUNCTION(radius_put_attr)\n{\n\tlong type;\n\tint len;\n\tchar *data;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rls\", &z_radh, &type, &data, &len)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_put_attr(raddesc->radh, type, data, len) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_addr(desc, type, addr) */\nPHP_FUNCTION(radius_put_addr)\n{\n\tint addrlen;\n\tlong type;\n\tchar\t*addr;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\tstruct in_addr intern_addr;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rls\", &z_radh, &type, &addr, &addrlen)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (inet_aton(addr, &intern_addr) == 0) {\n\t\tzend_error(E_ERROR, \"Error converting Address\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (rad_put_addr(raddesc->radh, type, intern_addr) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_vendor_string(desc, vendor, type, str) */\nPHP_FUNCTION(radius_put_vendor_string)\n{\n\tchar *str;\n\tint str_len;\n\tlong type, vendor;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlls\", &z_radh, &vendor, &type, &str, &str_len)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_put_vendor_string(raddesc->radh, vendor, type, str) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_vendor_int(desc, vendor, type, int) */\nPHP_FUNCTION(radius_put_vendor_int)\n{\n\tlong type, vendor, val;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &z_radh, &vendor, &type, &val)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_put_vendor_int(raddesc->radh, vendor, type, val) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_vendor_attr(desc, vendor, type, data) */\nPHP_FUNCTION(radius_put_vendor_attr)\n{\n\tlong type, vendor;\n\tint len;\n\tchar *data;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlls\", &z_radh, &vendor, &type,\n\t\t&data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (rad_put_vendor_attr(raddesc->radh, vendor, type, data, len) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_put_vendor_addr(desc, vendor, type, addr) */\nPHP_FUNCTION(radius_put_vendor_addr)\n{\n\tlong type, vendor;\n\tint addrlen;\n\tchar\t*addr;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\tstruct in_addr intern_addr;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlls\", &z_radh, &vendor,\n\t\t&type, &addr, &addrlen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tif (inet_aton(addr, &intern_addr) == 0) {\n\t\tzend_error(E_ERROR, \"Error converting Address\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (rad_put_vendor_addr(raddesc->radh, vendor, type, intern_addr) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool radius_send_request(desc) */\nPHP_FUNCTION(radius_send_request)\n{\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\tint res;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &z_radh)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tres = rad_send_request(raddesc->radh);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_LONG(res);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string radius_get_attr(desc) */\nPHP_FUNCTION(radius_get_attr)\n{\n\tradius_descriptor *raddesc;\n\tint res;\n\tconst void *data;\n\tsize_t len;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &z_radh) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tres = rad_get_attr(raddesc->radh, &data, &len);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tif (res > 0) {\n\n\t\t\tarray_init(return_value);\n\t\t\tadd_assoc_long(return_value, \"attr\", res);\n\t\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);\n\t\t\treturn;\n\t\t}\n\t\tRETURN_LONG(res);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string radius_get_vendor_attr(data) */\nPHP_FUNCTION(radius_get_vendor_attr)\n{\n\tconst void *data, *raw;\n\tint len;\n\tu_int32_t vendor;\n\tunsigned char type;\n\tsize_t data_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &raw, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (rad_get_vendor_attr(&vendor, &type, &data, &data_len, raw, len) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\n\t\tarray_init(return_value);\n\t\tadd_assoc_long(return_value, \"attr\", type);\n\t\tadd_assoc_long(return_value, \"vendor\", vendor);\n\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, data_len, 1);\n\t\treturn;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string radius_cvt_addr(data) */\nPHP_FUNCTION(radius_cvt_addr)\n{\n\tconst void *data;\n\tchar *addr_dot;\n\tint len;\n\tstruct in_addr addr;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\taddr = rad_cvt_addr(data);\n\taddr_dot = inet_ntoa(addr);\n\tRETURN_STRINGL(addr_dot, strlen(addr_dot), 1);\n}\n/* }}} */\n\n/* {{{ proto int radius_cvt_int(data) */\nPHP_FUNCTION(radius_cvt_int)\n{\n\tconst void *data;\n\tint len, val;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tval = rad_cvt_int(data);\n\tRETURN_LONG(val);\n}\n/* }}} */\n\n/* {{{ proto string radius_cvt_string(data) */\nPHP_FUNCTION(radius_cvt_string)\n{\n\tconst void *data;\n\tchar *val;\n\tint len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len)\n\t\t== FAILURE) {\n\t\treturn;\n\t}\n\n\tval = rad_cvt_string(data, len);\n\tif (val == NULL) RETURN_FALSE;\n\tRETVAL_STRINGL(val, strlen(val), 1);\n\tfree(val);\n\treturn;\n}\n/* }}} */\n\n/* {{{ proto string radius_request_authenticator(radh) */\nPHP_FUNCTION(radius_request_authenticator)\n{\n\tradius_descriptor *raddesc;\n\tssize_t res;\n\tchar buf[LEN_AUTH];\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &z_radh) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tres = rad_request_authenticator(raddesc->radh, buf, sizeof buf);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_STRINGL(buf, res, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string radius_server_secret(radh) */\nPHP_FUNCTION(radius_server_secret)\n{\n\tchar *secret;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &z_radh) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\tsecret = (char *)rad_server_secret(raddesc->radh);\n\n\tif (secret) {\n\t\tRETURN_STRINGL(secret, strlen(secret), 1);\n\t}\n\n\tRETURN_FALSE;\n}\n/* }}} */\n\n/* {{{ proto string radius_demangle(radh, mangled) */\nPHP_FUNCTION(radius_demangle)\n{\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\tconst void *mangled;\n\tunsigned char *buf;\n\tint len, res;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &z_radh, &mangled, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tbuf = emalloc(len);\n\tres = rad_demangle(raddesc->radh, mangled, len, buf);\n\n\tif (res == -1) {\n\t\tefree(buf);\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETVAL_STRINGL((char *) buf, len, 1);\n\t\tefree(buf);\n\t\treturn;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string radius_demangle_mppe_key(radh, mangled) */\nPHP_FUNCTION(radius_demangle_mppe_key)\n{\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\tconst void *mangled;\n\tunsigned char *buf;\n\tsize_t dlen;\n\tint len, res;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &z_radh, &mangled, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"rad_handle\", le_radius);\n\n\tbuf = emalloc(len);\n\tres = rad_demangle_mppe_key(raddesc->radh, mangled, len, buf, &dlen);\n\tif (res == -1) {\n\t\tefree(buf);\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETVAL_STRINGL((char *) buf, dlen, 1);\n\t\tefree(buf);\n\t\treturn;\n\t}\n}\n/* }}} */\n\n/* {{{ _radius_close() */\nvoid _radius_close(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tradius_descriptor *raddesc = (radius_descriptor *)rsrc->ptr;\n\trad_close(raddesc->radh);\n\tefree(raddesc);\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=8 ts=8 fdm=marker\n * vim<600: noet sw=8 ts=8\n */\n", "/*-\n * Copyright 1998 Juniper Networks, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n *\t$FreeBSD: src/lib/libradius/radlib.c,v 1.4.2.3 2002/06/17 02:24:57 brian Exp $\n */\n\n#include <sys/types.h>\n\n#ifndef PHP_WIN32\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#else\n#include <process.h>\n#include \"win32/time.h\"\n#endif\n\n#include <errno.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifndef PHP_WIN32\n#include <unistd.h>\n#endif\n\n#include \"radlib_compat.h\"\n#include \"radlib_md5.h\"\n#include \"radlib_private.h\"\n\nstatic void\t clear_password(struct rad_handle *);\nstatic void\t generr(struct rad_handle *, const char *, ...)\n\t\t    __printflike(2, 3);\nstatic void\t insert_scrambled_password(struct rad_handle *, int);\nstatic void\t insert_request_authenticator(struct rad_handle *, int);\nstatic int\t is_valid_response(struct rad_handle *, int,\n\t\t    const struct sockaddr_in *);\nstatic int\t put_password_attr(struct rad_handle *, int,\n\t\t    const void *, size_t);\nstatic int\t put_raw_attr(struct rad_handle *, int,\n\t\t    const void *, size_t);\nstatic int\t split(char *, char *[], int, char *, size_t);\n\nstatic void\nclear_password(struct rad_handle *h)\n{\n\tif (h->pass_len != 0) {\n\t\tmemset(h->pass, 0, h->pass_len);\n\t\th->pass_len = 0;\n\t}\n\th->pass_pos = 0;\n}\n\nstatic void\ngenerr(struct rad_handle *h, const char *format, ...)\n{\n\tva_list\t\t ap;\n\n\tva_start(ap, format);\n\tvsnprintf(h->errmsg, ERRSIZE, format, ap);\n\tva_end(ap);\n}\n\nstatic void\ninsert_scrambled_password(struct rad_handle *h, int srv)\n{\n\tMD5_CTX ctx;\n\tunsigned char md5[16];\n\tconst struct rad_server *srvp;\n\tint padded_len;\n\tint pos;\n\n\tsrvp = &h->servers[srv];\n\tpadded_len = h->pass_len == 0 ? 16 : (h->pass_len+15) & ~0xf;\n\n\tmemcpy(md5, &h->request[POS_AUTH], LEN_AUTH);\n\tfor (pos = 0;  pos < padded_len;  pos += 16) {\n\t\tint i;\n\n\t\t/* Calculate the new scrambler */\n\t\tMD5Init(&ctx);\n\t\tMD5Update(&ctx, srvp->secret, strlen(srvp->secret));\n\t\tMD5Update(&ctx, md5, 16);\n\t\tMD5Final(md5, &ctx);\n\n\t\t/*\n\t\t * Mix in the current chunk of the password, and copy\n\t\t * the result into the right place in the request.  Also\n\t\t * modify the scrambler in place, since we will use this\n\t\t * in calculating the scrambler for next time.\n\t\t */\n\t\tfor (i = 0;  i < 16;  i++)\n\t\t\th->request[h->pass_pos + pos + i] =\n\t\t\t    md5[i] ^= h->pass[pos + i];\n\t}\n}\n\nstatic void\ninsert_request_authenticator(struct rad_handle *h, int srv)\n{\n\tMD5_CTX ctx;\n\tconst struct rad_server *srvp;\n\n\tsrvp = &h->servers[srv];\n\n\t/* Create the request authenticator */\n\tMD5Init(&ctx);\n\tMD5Update(&ctx, &h->request[POS_CODE], POS_AUTH - POS_CODE);\n\tMD5Update(&ctx, memset(&h->request[POS_AUTH], 0, LEN_AUTH), LEN_AUTH);\n\tMD5Update(&ctx, &h->request[POS_ATTRS], h->req_len - POS_ATTRS);\n\tMD5Update(&ctx, srvp->secret, strlen(srvp->secret));\n\tMD5Final(&h->request[POS_AUTH], &ctx);\n}\n\n/*\n * Return true if the current response is valid for a request to the\n * specified server.\n */\nstatic int\nis_valid_response(struct rad_handle *h, int srv,\n    const struct sockaddr_in *from)\n{\n\tMD5_CTX ctx;\n\tunsigned char md5[16];\n\tconst struct rad_server *srvp;\n\tint len;\n\n\tsrvp = &h->servers[srv];\n\n\t/* Check the source address */\n\tif (from->sin_family != srvp->addr.sin_family ||\n\t    from->sin_addr.s_addr != srvp->addr.sin_addr.s_addr ||\n\t    from->sin_port != srvp->addr.sin_port)\n\t\treturn 0;\n\n\t/* Check the message length */\n\tif (h->resp_len < POS_ATTRS)\n\t\treturn 0;\n\tlen = h->response[POS_LENGTH] << 8 | h->response[POS_LENGTH+1];\n\tif (len > h->resp_len)\n\t\treturn 0;\n\n\t/* Check the response authenticator */\n\tMD5Init(&ctx);\n\tMD5Update(&ctx, &h->response[POS_CODE], POS_AUTH - POS_CODE);\n\tMD5Update(&ctx, &h->request[POS_AUTH], LEN_AUTH);\n\tMD5Update(&ctx, &h->response[POS_ATTRS], len - POS_ATTRS);\n\tMD5Update(&ctx, srvp->secret, strlen(srvp->secret));\n\tMD5Final(md5, &ctx);\n\tif (memcmp(&h->response[POS_AUTH], md5, sizeof md5) != 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int\nput_password_attr(struct rad_handle *h, int type, const void *value, size_t len)\n{\n\tint padded_len;\n\tint pad_len;\n\n\tif (h->pass_pos != 0) {\n\t\tgenerr(h, \"Multiple User-Password attributes specified\");\n\t\treturn -1;\n\t}\n\tif (len > PASSSIZE)\n\t\tlen = PASSSIZE;\n\tpadded_len = len == 0 ? 16 : (len+15) & ~0xf;\n\tpad_len = padded_len - len;\n\n\t/*\n\t * Put in a place-holder attribute containing all zeros, and\n\t * remember where it is so we can fill it in later.\n\t */\n\tclear_password(h);\n\tput_raw_attr(h, type, h->pass, padded_len);\n\th->pass_pos = h->req_len - padded_len;\n\n\t/* Save the cleartext password, padded as necessary */\n\tmemcpy(h->pass, value, len);\n\th->pass_len = len;\n\tmemset(h->pass + len, 0, pad_len);\n\treturn 0;\n}\n\nstatic int\nput_raw_attr(struct rad_handle *h, int type, const void *value, size_t len)\n{\n\tif (len > 253) {\n\t\tgenerr(h, \"Attribute too long\");\n\t\treturn -1;\n\t}\n\t\n\tif (h->req_len + 2 + len > MSGSIZE) {\n\t\tgenerr(h, \"Maximum message length exceeded\");\n\t\treturn -1;\n\t}\n\th->request[h->req_len++] = type;\n\th->request[h->req_len++] = len + 2;\n\tmemcpy(&h->request[h->req_len], value, len);\n\th->req_len += len;\n\treturn 0;\n}\n\nint\nrad_add_server(struct rad_handle *h, const char *host, int port,\n    const char *secret, int timeout, int tries)\n{\n\tstruct rad_server *srvp;\n\n\tif (h->num_servers >= MAXSERVERS) {\n\t\tgenerr(h, \"Too many RADIUS servers specified\");\n\t\treturn -1;\n\t}\n\tsrvp = &h->servers[h->num_servers];\n\n\tmemset(&srvp->addr, 0, sizeof srvp->addr);\n\tsrvp->addr.sin_family = AF_INET;\n\tif (!inet_aton(host, &srvp->addr.sin_addr)) {\n\t\tstruct hostent *hent;\n\n\t\tif ((hent = gethostbyname(host)) == NULL) {\n\t\t\tgenerr(h, \"%s: host not found\", host);\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(&srvp->addr.sin_addr, hent->h_addr,\n\t\t    sizeof srvp->addr.sin_addr);\n\t}\n\tif (port != 0)\n\t\tsrvp->addr.sin_port = htons((short) port);\n\telse {\n\t\tstruct servent *sent;\n\n\t\tif (h->type == RADIUS_AUTH)\n\t\t\tsrvp->addr.sin_port =\n\t\t\t    (sent = getservbyname(\"radius\", \"udp\")) != NULL ?\n\t\t\t\tsent->s_port : htons(RADIUS_PORT);\n\t\telse\n\t\t\tsrvp->addr.sin_port =\n\t\t\t    (sent = getservbyname(\"radacct\", \"udp\")) != NULL ?\n\t\t\t\tsent->s_port : htons(RADACCT_PORT);\n\t}\n\tif ((srvp->secret = strdup(secret)) == NULL) {\n\t\tgenerr(h, \"Out of memory\");\n\t\treturn -1;\n\t}\n\tsrvp->timeout = timeout;\n\tsrvp->max_tries = tries;\n\tsrvp->num_tries = 0;\n\th->num_servers++;\n\treturn 0;\n}\n\nvoid\nrad_close(struct rad_handle *h)\n{\n\tint srv;\n\n\tif (h->fd != -1)\n\t\tclose(h->fd);\n\tfor (srv = 0;  srv < h->num_servers;  srv++) {\n\t\tmemset(h->servers[srv].secret, 0,\n\t\t    strlen(h->servers[srv].secret));\n\t\tfree(h->servers[srv].secret);\n\t}\n\tclear_password(h);\n\tfree(h);\n}\n\nint\nrad_config(struct rad_handle *h, const char *path)\n{\n\tFILE *fp;\n\tchar buf[MAXCONFLINE];\n\tint linenum;\n\tint retval;\n\n\tif (path == NULL)\n\t\tpath = PATH_RADIUS_CONF;\n\tif ((fp = fopen(path, \"r\")) == NULL) {\n\t\tgenerr(h, \"Cannot open \\\"%s\\\": %s\", path, strerror(errno));\n\t\treturn -1;\n\t}\n\tretval = 0;\n\tlinenum = 0;\n\twhile (fgets(buf, sizeof buf, fp) != NULL) {\n\t\tint len;\n\t\tchar *fields[5];\n\t\tint nfields;\n\t\tchar msg[ERRSIZE];\n\t\tchar *type;\n\t\tchar *host, *res;\n\t\tchar *port_str;\n\t\tchar *secret;\n\t\tchar *timeout_str;\n\t\tchar *maxtries_str;\n\t\tchar *end;\n\t\tchar *wanttype;\n\t\tunsigned long timeout;\n\t\tunsigned long maxtries;\n\t\tint port;\n\t\tint i;\n\n\t\tlinenum++;\n\t\tlen = strlen(buf);\n\t\t/* We know len > 0, else fgets would have returned NULL. */\n\t\tif (buf[len - 1] != '\\n' && !(buf[len - 2] != '\\r' && buf[len - 1] != '\\n')) {\n\t\t\tif (len == sizeof buf - 1)\n\t\t\t\tgenerr(h, \"%s:%d: line too long\", path,\n\t\t\t\t    linenum);\n\t\t\telse\n\t\t\t\tgenerr(h, \"%s:%d: missing newline\", path,\n\t\t\t\t    linenum);\n\t\t\tretval = -1;\n\t\t\tbreak;\n\t\t}\n\t\tbuf[len - 1] = '\\0';\n\n\t\t/* Extract the fields from the line. */\n\t\tnfields = split(buf, fields, 5, msg, sizeof msg);\n\t\tif (nfields == -1) {\n\t\t\tgenerr(h, \"%s:%d: %s\", path, linenum, msg);\n\t\t\tretval = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (nfields == 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * The first field should contain \"auth\" or \"acct\" for\n\t\t * authentication or accounting, respectively.  But older\n\t\t * versions of the file didn't have that field.  Default\n\t\t * it to \"auth\" for backward compatibility.\n\t\t */\n\t\tif (strcmp(fields[0], \"auth\") != 0 &&\n\t\t    strcmp(fields[0], \"acct\") != 0) {\n\t\t\tif (nfields >= 5) {\n\t\t\t\tgenerr(h, \"%s:%d: invalid service type\", path,\n\t\t\t\t    linenum);\n\t\t\t\tretval = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnfields++;\n\t\t\tfor (i = nfields;  --i > 0;  )\n\t\t\t\tfields[i] = fields[i - 1];\n\t\t\tfields[0] = \"auth\";\n\t\t}\n\t\tif (nfields < 3) {\n\t\t\tgenerr(h, \"%s:%d: missing shared secret\", path,\n\t\t\t    linenum);\n\t\t\tretval = -1;\n\t\t\tbreak;\n\t\t}\n\t\ttype = fields[0];\n\t\thost = fields[1];\n\t\tsecret = fields[2];\n\t\ttimeout_str = fields[3];\n\t\tmaxtries_str = fields[4];\n\n\t\t/* Ignore the line if it is for the wrong service type. */\n\t\twanttype = h->type == RADIUS_AUTH ? \"auth\" : \"acct\";\n\t\tif (strcmp(type, wanttype) != 0)\n\t\t\tcontinue;\n\n\t\t/* Parse and validate the fields. */\n\t\tres = host;\n\t\thost = strsep(&res, \":\");\n\t\tport_str = strsep(&res, \":\");\n\t\tif (port_str != NULL) {\n\t\t\tport = strtoul(port_str, &end, 10);\n\t\t\tif (*end != '\\0') {\n\t\t\t\tgenerr(h, \"%s:%d: invalid port\", path,\n\t\t\t\t    linenum);\n\t\t\t\tretval = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tport = 0;\n\t\tif (timeout_str != NULL) {\n\t\t\ttimeout = strtoul(timeout_str, &end, 10);\n\t\t\tif (*end != '\\0') {\n\t\t\t\tgenerr(h, \"%s:%d: invalid timeout\", path,\n\t\t\t\t    linenum);\n\t\t\t\tretval = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\ttimeout = TIMEOUT;\n\t\tif (maxtries_str != NULL) {\n\t\t\tmaxtries = strtoul(maxtries_str, &end, 10);\n\t\t\tif (*end != '\\0') {\n\t\t\t\tgenerr(h, \"%s:%d: invalid maxtries\", path,\n\t\t\t\t    linenum);\n\t\t\t\tretval = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tmaxtries = MAXTRIES;\n\n\t\tif (rad_add_server(h, host, port, secret, timeout, maxtries) ==\n\t\t    -1) {\n\t\t\tstrcpy(msg, h->errmsg);\n\t\t\tgenerr(h, \"%s:%d: %s\", path, linenum, msg);\n\t\t\tretval = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Clear out the buffer to wipe a possible copy of a shared secret */\n\tmemset(buf, 0, sizeof buf);\n\tfclose(fp);\n\treturn retval;\n}\n\n/*\n * rad_init_send_request() must have previously been called.\n * Returns:\n *   0     The application should select on *fd with a timeout of tv before\n *         calling rad_continue_send_request again.\n *   < 0   Failure\n *   > 0   Success\n */\nint\nrad_continue_send_request(struct rad_handle *h, int selected, int *fd,\n                          struct timeval *tv)\n{\n\tint n;\n\n\tif (selected) {\n\t\tstruct sockaddr_in from;\n\t\tint fromlen;\n\n\t\tfromlen = sizeof from;\n\t\th->resp_len = recvfrom(h->fd, h->response,\n\t\t    MSGSIZE, MSG_WAITALL, (struct sockaddr *)&from, &fromlen);\n\t\tif (h->resp_len == -1) {\n#ifdef PHP_WIN32\n\t\t\tgenerr(h, \"recfrom: %d\", WSAGetLastError());\n#else\n\t\t\tgenerr(h, \"recvfrom: %s\", strerror(errno));\n#endif\n\t\t\treturn -1;\n\t\t}\n\t\tif (is_valid_response(h, h->srv, &from)) {\n\t\t\th->resp_len = h->response[POS_LENGTH] << 8 |\n\t\t\t    h->response[POS_LENGTH+1];\n\t\t\th->resp_pos = POS_ATTRS;\n\t\t\treturn h->response[POS_CODE];\n\t\t}\n\t}\n\n\tif (h->try == h->total_tries) {\n\t\tgenerr(h, \"No valid RADIUS responses received\");\n\t\treturn -1;\n\t}\n\n\t/*\n         * Scan round-robin to the next server that has some\n         * tries left.  There is guaranteed to be one, or we\n         * would have exited this loop by now.\n\t */\n\twhile (h->servers[h->srv].num_tries >= h->servers[h->srv].max_tries)\n\t\tif (++h->srv >= h->num_servers)\n\t\t\th->srv = 0;\n\n\tif (h->request[POS_CODE] == RAD_ACCOUNTING_REQUEST)\n\t\t/* Insert the request authenticator into the request */\n\t\tinsert_request_authenticator(h, h->srv);\n\telse\n\t\t/* Insert the scrambled password into the request */\n\t\tif (h->pass_pos != 0)\n\t\t\tinsert_scrambled_password(h, h->srv);\n\n\t/* Send the request */\n\tn = sendto(h->fd, h->request, h->req_len, 0,\n\t    (const struct sockaddr *)&h->servers[h->srv].addr,\n\t    sizeof h->servers[h->srv].addr);\n\tif (n != h->req_len) {\n\t\tif (n == -1)\n#ifdef PHP_WIN32\n\t\t\tgenerr(h, \"sendto: %d\", WSAGetLastError());\n#else\n\t\t\tgenerr(h, \"sendto: %s\", strerror(errno));\n#endif\n\t\telse\n\t\t\tgenerr(h, \"sendto: short write\");\n\t\treturn -1;\n\t}\n\n\th->try++;\n\th->servers[h->srv].num_tries++;\n\ttv->tv_sec = h->servers[h->srv].timeout;\n\ttv->tv_usec = 0;\n\t*fd = h->fd;\n\n\treturn 0;\n}\n\nint\nrad_create_request(struct rad_handle *h, int code)\n{\n\tint i;\n\n\th->request[POS_CODE] = code;\n\th->request[POS_IDENT] = ++h->ident;\n\t/* Create a random authenticator */\n\tfor (i = 0;  i < LEN_AUTH;  i += 2) {\n\t\tlong r;\n\t\tTSRMLS_FETCH();\n\t\tr = php_rand(TSRMLS_C);\n\t\th->request[POS_AUTH+i] = (unsigned char) r;\n\t\th->request[POS_AUTH+i+1] = (unsigned char) (r >> 8);\n\t}\n\th->req_len = POS_ATTRS;\n\th->request_created = 1;    \n\tclear_password(h);\n\treturn 0;\n}\n\nstruct in_addr\nrad_cvt_addr(const void *data)\n{\n\tstruct in_addr value;\n\n\tmemcpy(&value.s_addr, data, sizeof value.s_addr);\n\treturn value;\n}\n\nu_int32_t\nrad_cvt_int(const void *data)\n{\n\tu_int32_t value;\n\n\tmemcpy(&value, data, sizeof value);\n\treturn ntohl(value);\n}\n\nchar *\nrad_cvt_string(const void *data, size_t len)\n{\n\tchar *s;\n\n\ts = malloc(len + 1);\n\tif (s != NULL) {\n\t\tmemcpy(s, data, len);\n\t\ts[len] = '\\0';\n\t}\n\treturn s;\n}\n\n/*\n * Returns the attribute type.  If none are left, returns 0.  On failure,\n * returns -1.\n */\nint\nrad_get_attr(struct rad_handle *h, const void **value, size_t *len)\n{\n\tint type;\n\n\tif (h->resp_pos >= h->resp_len)\n\t\treturn 0;\n\tif (h->resp_pos + 2 > h->resp_len) {\n\t\tgenerr(h, \"Malformed attribute in response\");\n\t\treturn -1;\n\t}\n\ttype = h->response[h->resp_pos++];\n\t*len = h->response[h->resp_pos++] - 2;\n\tif (h->resp_pos + (int) *len > h->resp_len) {\n\t\tgenerr(h, \"Malformed attribute in response\");\n\t\treturn -1;\n\t}\n\t*value = &h->response[h->resp_pos];\n\th->resp_pos += *len;\n\treturn type;\n}\n\n/*\n * Returns -1 on error, 0 to indicate no event and >0 for success\n */\nint\nrad_init_send_request(struct rad_handle *h, int *fd, struct timeval *tv)\n{\n\tint srv;\n\n\t/* Make sure we have a socket to use */\n\tif (h->fd == -1) {\n\t\tstruct sockaddr_in sin;\n\n\t\tif ((h->fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) {\n#ifdef PHP_WIN32\n\t\t\tgenerr(h, \"Cannot create socket: %d\", WSAGetLastError());\n#else\n\t\t\tgenerr(h, \"Cannot create socket: %s\", strerror(errno));\n#endif\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(&sin, 0, sizeof sin);\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = INADDR_ANY;\n\t\tsin.sin_port = htons(0);\n\t\tif (bind(h->fd, (const struct sockaddr *)&sin,\n\t\t    sizeof sin) == -1) {\n#ifdef PHP_WIN32\n\t\t\tgenerr(h, \"bind: %d\", WSAGetLastError());\n#else\n\t\t\tgenerr(h, \"bind: %s\", strerror(errno));\n#endif\n\t\t\tclose(h->fd);\n\t\t\th->fd = -1;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (h->request[POS_CODE] == RAD_ACCOUNTING_REQUEST) {\n\t\t/* Make sure no password given */\n\t\tif (h->pass_pos || h->chap_pass) {\n\t\t\tgenerr(h, \"User or Chap Password in accounting request\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* Make sure the user gave us a password */\n\t\tif (h->pass_pos == 0 && !h->chap_pass) {\n\t\t\tgenerr(h, \"No User or Chap Password attributes given\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (h->pass_pos != 0 && h->chap_pass) {\n\t\t\tgenerr(h, \"Both User and Chap Password attributes given\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Fill in the length field in the message */\n\th->request[POS_LENGTH] = h->req_len >> 8;\n\th->request[POS_LENGTH+1] = h->req_len;\n\n\t/*\n\t * Count the total number of tries we will make, and zero the\n\t * counter for each server.\n\t */\n\th->total_tries = 0;\n\tfor (srv = 0;  srv < h->num_servers;  srv++) {\n\t\th->total_tries += h->servers[srv].max_tries;\n\t\th->servers[srv].num_tries = 0;\n\t}\n\tif (h->total_tries == 0) {\n\t\tgenerr(h, \"No RADIUS servers specified\");\n\t\treturn -1;\n\t}\n\n\th->try = h->srv = 0;\n\n\treturn rad_continue_send_request(h, 0, fd, tv);\n}\n\n/*\n * Create and initialize a rad_handle structure, and return it to the\n * caller.  Can fail only if the necessary memory cannot be allocated.\n * In that case, it returns NULL.\n */\nstruct rad_handle *\nrad_auth_open(void)\n{\n\tstruct rad_handle *h;\n\n\th = (struct rad_handle *)malloc(sizeof(struct rad_handle));\n\tif (h != NULL) {\n\t\tTSRMLS_FETCH();\n\t\tphp_srand(time(NULL) * getpid() * (unsigned long) (php_combined_lcg(TSRMLS_C) * 10000.0) TSRMLS_CC);\n\t\th->fd = -1;\n\t\th->num_servers = 0;\n\t\th->ident = php_rand(TSRMLS_C);\n\t\th->errmsg[0] = '\\0';\n\t\tmemset(h->pass, 0, sizeof h->pass);\n\t\th->pass_len = 0;\n\t\th->pass_pos = 0;\n\t\th->chap_pass = 0;\n\t\th->type = RADIUS_AUTH;\n        h->request_created = 0;        \n\t}\n\treturn h;\n}\n\nstruct rad_handle *\nrad_acct_open(void)\n{\n\tstruct rad_handle *h;\n\n\th = rad_open();\n\tif (h != NULL)\n\t        h->type = RADIUS_ACCT;\n\treturn h;\n}\n\nstruct rad_handle *\nrad_open(void)\n{\n    return rad_auth_open();\n}\n\nint\nrad_put_addr(struct rad_handle *h, int type, struct in_addr addr)\n{\n\treturn rad_put_attr(h, type, &addr.s_addr, sizeof addr.s_addr);\n}\n\nint\nrad_put_attr(struct rad_handle *h, int type, const void *value, size_t len)\n{\n\tint result;\n\n    if (!h->request_created) {\n        generr(h, \"Please call rad_create_request()\");\n        return -1;\n    }\n\n\tif (type == RAD_USER_PASSWORD)\n\t\tresult = put_password_attr(h, type, value, len);\n\telse {\n\t\tresult = put_raw_attr(h, type, value, len);\n\t\tif (result == 0 && type == RAD_CHAP_PASSWORD)\n\t\t\th->chap_pass = 1;\n\t}\n\n\treturn result;\n}\n\nint\nrad_put_int(struct rad_handle *h, int type, u_int32_t value)\n{\n\tu_int32_t nvalue;\n\n\tnvalue = htonl(value);\n\treturn rad_put_attr(h, type, &nvalue, sizeof nvalue);\n}\n\nint\nrad_put_string(struct rad_handle *h, int type, const char *str)\n{\n\treturn rad_put_attr(h, type, str, strlen(str));\n}\n\n/*\n * Returns the response type code on success, or -1 on failure.\n */\nint\nrad_send_request(struct rad_handle *h)\n{\n\tstruct timeval timelimit;\n\tstruct timeval tv;\n\tint fd;\n\tint n;\n\n\tn = rad_init_send_request(h, &fd, &tv);\n\n\tif (n != 0)\n\t\treturn n;\n\n\tgettimeofday(&timelimit, NULL);\n\ttimeradd(&tv, &timelimit, &timelimit);\n\n\tfor ( ; ; ) {\n\t\tfd_set readfds;\n\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(fd, &readfds);\n\n\t\tn = select(fd + 1, &readfds, NULL, NULL, &tv);\n\n\t\tif (n == -1) {\n\t\t\tgenerr(h, \"select: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!FD_ISSET(fd, &readfds)) {\n\t\t\t/* Compute a new timeout */\n\t\t\tgettimeofday(&tv, NULL);\n\t\t\ttimersub(&timelimit, &tv, &tv);\n\t\t\tif (tv.tv_sec > 0 || (tv.tv_sec == 0 && tv.tv_usec > 0))\n\t\t\t\t/* Continue the select */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tn = rad_continue_send_request(h, n, &fd, &tv);\n\n\t\tif (n != 0)\n\t\t\treturn n;\n\n\t\tgettimeofday(&timelimit, NULL);\n\t\ttimeradd(&tv, &timelimit, &timelimit);\n\t}\n}\n\nconst char *\nrad_strerror(struct rad_handle *h)\n{\n\treturn h->errmsg;\n}\n\n/*\n * Destructively split a string into fields separated by white space.\n * `#' at the beginning of a field begins a comment that extends to the\n * end of the string.  Fields may be quoted with `\"'.  Inside quoted\n * strings, the backslash escapes `\\\"' and `\\\\' are honored.\n *\n * Pointers to up to the first maxfields fields are stored in the fields\n * array.  Missing fields get NULL pointers.\n *\n * The return value is the actual number of fields parsed, and is always\n * <= maxfields.\n *\n * On a syntax error, places a message in the msg string, and returns -1.\n */\nstatic int\nsplit(char *str, char *fields[], int maxfields, char *msg, size_t msglen)\n{\n\tchar *p;\n\tint i;\n\tstatic const char ws[] = \" \\t\";\n\n\tfor (i = 0;  i < maxfields;  i++)\n\t\tfields[i] = NULL;\n\tp = str;\n\ti = 0;\n\twhile (*p != '\\0') {\n\t\tp += strspn(p, ws);\n\t\tif (*p == '#' || *p == '\\0')\n\t\t\tbreak;\n\t\tif (i >= maxfields) {\n\t\t\tsnprintf(msg, msglen, \"line has too many fields\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (*p == '\"') {\n\t\t\tchar *dst;\n\n\t\t\tdst = ++p;\n\t\t\tfields[i] = dst;\n\t\t\twhile (*p != '\"') {\n\t\t\t\tif (*p == '\\\\') {\n\t\t\t\t\tp++;\n\t\t\t\t\tif (*p != '\"' && *p != '\\\\' &&\n\t\t\t\t\t    *p != '\\0') {\n\t\t\t\t\t\tsnprintf(msg, msglen,\n\t\t\t\t\t\t    \"invalid `\\\\' escape\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\tsnprintf(msg, msglen,\n\t\t\t\t\t    \"unterminated quoted string\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*dst++ = *p++;\n\t\t\t}\n\t\t\t*dst = '\\0';\n\t\t\tp++;\n\t\t\tif (*fields[i] == '\\0') {\n\t\t\t\tsnprintf(msg, msglen,\n\t\t\t\t    \"empty quoted string not permitted\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (*p != '\\0' && strspn(p, ws) == 0) {\n\t\t\t\tsnprintf(msg, msglen, \"quoted string not\"\n\t\t\t\t    \" followed by white space\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tfields[i] = p;\n\t\t\tp += strcspn(p, ws);\n\t\t\tif (*p != '\\0')\n\t\t\t\t*p++ = '\\0';\n\t\t}\n\t\ti++;\n\t}\n\treturn i;\n}\n\nint\nrad_get_vendor_attr(u_int32_t *vendor, unsigned char *type, const void **data, size_t *len, const void *raw, size_t raw_len)\n{\n\tstruct vendor_attribute *attr;\n\n\tif (raw_len < sizeof(struct vendor_attribute)) {\n\t\treturn -1;\n\t}\n\n\tattr = (struct vendor_attribute *) raw;\n\t*vendor = ntohl(attr->vendor_value);\n\t*type = attr->attrib_type;\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\n\tif ((attr->attrib_len + 4) > raw_len) {\n\t\treturn -1;\n\t}\n\n\treturn (attr->attrib_type);\n}\n\nint\nrad_put_vendor_addr(struct rad_handle *h, int vendor, int type,\n    struct in_addr addr)\n{\n\treturn (rad_put_vendor_attr(h, vendor, type, &addr.s_addr,\n\t    sizeof addr.s_addr));\n}\n\nint\nrad_put_vendor_attr(struct rad_handle *h, int vendor, int type,\n    const void *value, size_t len)\n{\n\tstruct vendor_attribute *attr;\n\tint res;\n    \n    if (!h->request_created) {\n        generr(h, \"Please call rad_create_request()\");\n        return -1;\n    }    \n\n\tif ((attr = malloc(len + 6)) == NULL) {\n\t\tgenerr(h, \"malloc failure (%d bytes)\", len + 6);\n\t\treturn -1;\n\t}\n\n\tattr->vendor_value = htonl(vendor);\n\tattr->attrib_type = type;\n\tattr->attrib_len = len + 2;\n\tmemcpy(attr->attrib_data, value, len);\n\n\tres = put_raw_attr(h, RAD_VENDOR_SPECIFIC, attr, len + 6);\n\tfree(attr);\n\tif (res == 0 && vendor == RAD_VENDOR_MICROSOFT\n\t    && (type == RAD_MICROSOFT_MS_CHAP_RESPONSE\n\t    || type == RAD_MICROSOFT_MS_CHAP2_RESPONSE)) {\n\t\th->chap_pass = 1;\n\t}\n\treturn (res);\n}\n\nint\nrad_put_vendor_int(struct rad_handle *h, int vendor, int type, u_int32_t i)\n{\n\tu_int32_t value;\n\n\tvalue = htonl(i);\n\treturn (rad_put_vendor_attr(h, vendor, type, &value, sizeof value));\n}\n\nint\nrad_put_vendor_string(struct rad_handle *h, int vendor, int type,\n    const char *str)\n{\n\treturn (rad_put_vendor_attr(h, vendor, type, str, strlen(str)));\n}\n\nssize_t\nrad_request_authenticator(struct rad_handle *h, char *buf, size_t len)\n{\n\tif (len < LEN_AUTH)\n\t\treturn (-1);\n\tmemcpy(buf, h->request + POS_AUTH, LEN_AUTH);\n\tif (len > LEN_AUTH)\n\t\tbuf[LEN_AUTH] = '\\0';\n\treturn (LEN_AUTH);\n}\n\nconst char *\nrad_server_secret(struct rad_handle *h)\n{\n\tif (h->srv >= h->num_servers) {\n\t\tgenerr(h, \"No RADIUS servers specified\");\n\t\treturn NULL;\n\t}\n\n\treturn (h->servers[h->srv].secret);\n}\n\nint\nrad_demangle(struct rad_handle *h, const void *mangled, size_t mlen, u_char *demangled) \n{\n\tchar R[LEN_AUTH];\n\tconst char *S;\n\tint i, Ppos;\n\tMD5_CTX Context;\n\tu_char b[16], *C;\n\n\tif ((mlen % 16 != 0) || (mlen > 128)) {\n\t\tgenerr(h, \"Cannot interpret mangled data of length %ld\", (u_long)mlen);\n\t\treturn -1;\n\t}\n\n\tC = (u_char *)mangled;\n\n\t/* We need the shared secret as Salt */\n\tS = rad_server_secret(h);\n\n\t/* We need the request authenticator */\n\tif (rad_request_authenticator(h, R, sizeof R) != LEN_AUTH) {\n\t\tgenerr(h, \"Cannot obtain the RADIUS request authenticator\");\n                return -1;\n\t}\n\n\tMD5Init(&Context);\n\tMD5Update(&Context, S, strlen(S));\n\tMD5Update(&Context, R, LEN_AUTH);\n\tMD5Final(b, &Context);\n\tPpos = 0;\n\twhile (mlen) {\n\n\t\tmlen -= 16;\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tdemangled[Ppos++] = C[i] ^ b[i];\n\n\t\tif (mlen) {\n\t\t\tMD5Init(&Context);\n\t\t\tMD5Update(&Context, S, strlen(S));\n\t\t\tMD5Update(&Context, C, 16);\n\t\t\tMD5Final(b, &Context);\n\t\t}\n\n\t\tC += 16;\n\t}\n\n\treturn 0;\n}\n\nint\nrad_demangle_mppe_key(struct rad_handle *h, const void *mangled, size_t mlen, u_char *demangled, size_t *len)\n{\n\tchar R[LEN_AUTH];    /* variable names as per rfc2548 */\n\tconst char *S;\n\tu_char b[16];\n\tconst u_char *A, *C;\n\tMD5_CTX Context;\n\tint Slen, i, Clen, Ppos;\n\tu_char *P;\n\n\tif (mlen % 16 != SALT_LEN) {\n\t\tgenerr(h, \"Cannot interpret mangled data of length %ld\", (u_long)mlen);\n\t\treturn -1;\n\t}\n\n\t/* We need the RADIUS Request-Authenticator */\n\tif (rad_request_authenticator(h, R, sizeof R) != LEN_AUTH) {\n\t\tgenerr(h, \"Cannot obtain the RADIUS request authenticator\");\n\t\treturn -1;\n\t}\n\n\tA = (const u_char *)mangled;      /* Salt comes first */\n\tC = (const u_char *)mangled + SALT_LEN;  /* Then the ciphertext */\n\tClen = mlen - SALT_LEN;\n\tS = rad_server_secret(h);    /* We need the RADIUS secret */\n\tSlen = strlen(S);\n\tP = alloca(Clen);        /* We derive our plaintext */\n\n\tMD5Init(&Context);\n\tMD5Update(&Context, S, Slen);\n\tMD5Update(&Context, R, LEN_AUTH);\n\tMD5Update(&Context, A, SALT_LEN);\n\tMD5Final(b, &Context);\n\tPpos = 0;\n\n\twhile (Clen) {\n\t\tClen -= 16;\n\n\t\tfor (i = 0; i < 16; i++)\n\t\t    P[Ppos++] = C[i] ^ b[i];\n\n\t\tif (Clen) {\n\t\t\tMD5Init(&Context);\n\t\t\tMD5Update(&Context, S, Slen);\n\t\t\tMD5Update(&Context, C, 16);\n\t\t\tMD5Final(b, &Context);\n\t\t}\n                \n\t\tC += 16;\n\t}\n\n\t/*\n\t* The resulting plain text consists of a one-byte length, the text and\n\t* maybe some padding.\n\t*/\n\t*len = *P;\n\tif (*len > mlen - 1) {\n\t\tgenerr(h, \"Mangled data seems to be garbage %d %d\", *len, mlen-1);        \n\t\treturn -1;\n\t}\n\n\tif (*len > MPPE_KEY_LEN) {\n\t\tgenerr(h, \"Key to long (%d) for me max. %d\", *len, MPPE_KEY_LEN);        \n\t\treturn -1;\n\t}\n\n\tmemcpy(demangled, P + 1, *len);\n\treturn 0;\n}\n\n/* vim: set ts=8 sw=8 noet: */\n", "/*-\n * Copyright (c) 2002-2003 Brian Somers <brian@Awfulhak.org>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * $FreeBSD: src/lib/libradius/radlib_vs.h,v 1.2.2.1 2002/06/17 02:24:57 brian Exp $\n */\n\n#ifndef _RADLIB_VS_H_\n#define _RADLIB_VS_H_\n\n#include <sys/types.h>\n#ifndef PHP_WIN32\n#include <netinet/in.h>\n#endif\n\n#include \"radlib_compat.h\"\n\n#define\tRAD_VENDOR_MICROSOFT\t311\t\t/* rfc2548 */\n\t#define\tRAD_MICROSOFT_MS_CHAP_RESPONSE\t\t\t1\n\t#define\tRAD_MICROSOFT_MS_CHAP_ERROR\t\t\t2\n\t#define\tRAD_MICROSOFT_MS_CHAP_PW_1\t\t\t3\n\t#define\tRAD_MICROSOFT_MS_CHAP_PW_2\t\t\t4\n\t#define\tRAD_MICROSOFT_MS_CHAP_LM_ENC_PW\t\t\t5\n\t#define\tRAD_MICROSOFT_MS_CHAP_NT_ENC_PW\t\t\t6\n\t#define\tRAD_MICROSOFT_MS_MPPE_ENCRYPTION_POLICY\t\t7\n\t#define\tRAD_MICROSOFT_MS_MPPE_ENCRYPTION_TYPES\t\t8\n\t#define\tRAD_MICROSOFT_MS_RAS_VENDOR\t\t\t9\n\t#define\tRAD_MICROSOFT_MS_CHAP_DOMAIN\t\t\t10\n\t#define\tRAD_MICROSOFT_MS_CHAP_CHALLENGE\t\t\t11\n\t#define\tRAD_MICROSOFT_MS_CHAP_MPPE_KEYS\t\t\t12\n\t#define\tRAD_MICROSOFT_MS_BAP_USAGE\t\t\t13\n\t#define\tRAD_MICROSOFT_MS_LINK_UTILIZATION_THRESHOLD\t14\n\t#define\tRAD_MICROSOFT_MS_LINK_DROP_TIME_LIMIT\t\t15\n\t#define\tRAD_MICROSOFT_MS_MPPE_SEND_KEY\t\t\t16\n\t#define\tRAD_MICROSOFT_MS_MPPE_RECV_KEY\t\t\t17\n\t#define\tRAD_MICROSOFT_MS_RAS_VERSION\t\t\t18\n\t#define\tRAD_MICROSOFT_MS_OLD_ARAP_PASSWORD\t\t19\n\t#define\tRAD_MICROSOFT_MS_NEW_ARAP_PASSWORD\t\t20\n\t#define\tRAD_MICROSOFT_MS_ARAP_PASSWORD_CHANGE_REASON\t21\n\t#define\tRAD_MICROSOFT_MS_FILTER\t\t\t\t22\n\t#define\tRAD_MICROSOFT_MS_ACCT_AUTH_TYPE\t\t\t23\n\t#define\tRAD_MICROSOFT_MS_ACCT_EAP_TYPE\t\t\t24\n\t#define\tRAD_MICROSOFT_MS_CHAP2_RESPONSE\t\t\t25\n\t#define\tRAD_MICROSOFT_MS_CHAP2_SUCCESS\t\t\t26\n\t#define\tRAD_MICROSOFT_MS_CHAP2_PW\t\t\t27\n\t#define\tRAD_MICROSOFT_MS_PRIMARY_DNS_SERVER\t\t28\n\t#define\tRAD_MICROSOFT_MS_SECONDARY_DNS_SERVER\t\t29\n\t#define\tRAD_MICROSOFT_MS_PRIMARY_NBNS_SERVER\t\t30\n\t#define\tRAD_MICROSOFT_MS_SECONDARY_NBNS_SERVER\t\t31\n\t#define\tRAD_MICROSOFT_MS_ARAP_CHALLENGE\t\t\t33\n\n#define SALT_LEN    2\n\nstruct rad_handle;\n\nint\trad_get_vendor_attr(u_int32_t *, unsigned char *, const void **, size_t *, const void *, size_t);\nint\trad_put_vendor_addr(struct rad_handle *, int, int, struct in_addr);\nint\trad_put_vendor_attr(struct rad_handle *, int, int, const void *,\n\t    size_t);\nint\trad_put_vendor_int(struct rad_handle *, int, int, u_int32_t);\nint\trad_put_vendor_string(struct rad_handle *, int, int, const char *);\nint\trad_demangle_mppe_key(struct rad_handle *, const void *, size_t, u_char *, size_t *);\n\n#endif /* _RADLIB_VS_H_ */\n\n/* vim: set ts=8 sw=8 noet: */\n"], "filenames": ["radius.c", "radlib.c", "radlib_vs.h"], "buggy_code_start_loc": [544, 901, 77], "buggy_code_end_loc": [562, 908, 78], "fixing_code_start_loc": [544, 901, 77], "fixing_code_end_loc": [562, 918, 78], "type": "CWE-119", "message": "Buffer overflow in the radius_get_vendor_attr function in the Radius extension before 1.2.7 for PHP allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large Vendor Specific Attributes (VSA) length value.", "other": {"cve": {"id": "CVE-2013-2220", "sourceIdentifier": "secalert@redhat.com", "published": "2013-07-31T13:20:27.423", "lastModified": "2013-07-31T13:20:27.423", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer overflow in the radius_get_vendor_attr function in the Radius extension before 1.2.7 for PHP allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large Vendor Specific Attributes (VSA) length value."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer en la funci\u00f3n radius_get_vendor_attr en la extensi\u00f3n Radius anterior a 1.2.7 para PHP, permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda) y posiblemente la ejecuci\u00f3n de c\u00f3digo arbitraria a trav\u00e9s de un valor alto en Vendor Specific Attributes (VSA)."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radius_extension_project:radius:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.6", "matchCriteriaId": "24180799-F1E3-4CED-8E56-8D61A853E613"}, {"vulnerable": true, "criteria": "cpe:2.3:a:radius_extension_project:radius:1.1:*:*:*:*:*:*:*", "matchCriteriaId": "8510CB61-6237-4771-AA4C-1432670100B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:radius_extension_project:radius:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "58E5F87B-D749-4444-A50B-EF757F7D46D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:radius_extension_project:radius:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "7EF9F81D-6338-4535-A652-CD43A3DE4462"}, {"vulnerable": true, "criteria": "cpe:2.3:a:radius_extension_project:radius:1.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "D6050AA4-E64C-4885-9192-2C7C556A729D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:radius_extension_project:radius:1.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "40531DA1-C74E-464F-A16E-ED903445E527"}, {"vulnerable": true, "criteria": "cpe:2.3:a:radius_extension_project:radius:1.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "76D949BF-4709-4810-84DD-FB583284637B"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "matchCriteriaId": "58A8B39D-57DF-4D71-BBCA-1D5A19E0A1B9"}]}]}], "references": [{"url": "http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=714362", "source": "secalert@redhat.com"}, {"url": "http://pecl.php.net/package/radius/1.2.7", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2013/dsa-2726", "source": "secalert@redhat.com"}, {"url": "https://github.com/LawnGnome/php-radius/commit/13c149b051f82b709e8d7cc32111e84b49d57234", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/LawnGnome/php-radius/commit/13c149b051f82b709e8d7cc32111e84b49d57234"}}