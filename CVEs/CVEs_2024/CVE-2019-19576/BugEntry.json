{"buggy_code": ["<?php\n// +------------------------------------------------------------------------+\n// | class.upload.php                                                       |\n// +------------------------------------------------------------------------+\n// | Copyright (c) Colin Verot 2003-2014. All rights reserved.              |\n// | Email         colin@verot.net                                          |\n// | Web           http://www.verot.net                                     |\n// +------------------------------------------------------------------------+\n// | This program is free software; you can redistribute it and/or modify   |\n// | it under the terms of the GNU General Public License version 2 as      |\n// | published by the Free Software Foundation.                             |\n// |                                                                        |\n// | This program is distributed in the hope that it will be useful,        |\n// | but WITHOUT ANY WARRANTY; without even the implied warranty of         |\n// | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          |\n// | GNU General Public License for more details.                           |\n// |                                                                        |\n// | You should have received a copy of the GNU General Public License      |\n// | along with this program; if not, write to the                          |\n// |   Free Software Foundation, Inc., 59 Temple Place, Suite 330,          |\n// |   Boston, MA 02111-1307 USA                                            |\n// |                                                                        |\n// | Please give credit on sites that use class.upload and submit changes   |\n// | of the script so other people can use them as well.                    |\n// | This script is free to use, don't abuse.                               |\n// +------------------------------------------------------------------------+\n\n\n/**\n * Class upload\n *\n * @author    Colin Verot <colin@verot.net>\n * @license   http://opensource.org/licenses/gpl-license.php GNU Public License\n * @copyright Colin Verot\n */\nclass upload {\n\n\n    /**\n     * Class version\n     *\n     * @access public\n     * @var string\n     */\n    var $version;\n\n    /**\n     * Uploaded file name\n     *\n     * @access public\n     * @var string\n     */\n    var $file_src_name;\n\n    /**\n     * Uploaded file name body (i.e. without extension)\n     *\n     * @access public\n     * @var string\n     */\n    var $file_src_name_body;\n\n    /**\n     * Uploaded file name extension\n     *\n     * @access public\n     * @var string\n     */\n    var $file_src_name_ext;\n\n    /**\n     * Uploaded file MIME type\n     *\n     * @access public\n     * @var string\n     */\n    var $file_src_mime;\n\n    /**\n     * Uploaded file size, in bytes\n     *\n     * @access public\n     * @var double\n     */\n    var $file_src_size;\n\n    /**\n     * Holds eventual PHP error code from $_FILES\n     *\n     * @access public\n     * @var string\n     */\n    var $file_src_error;\n\n    /**\n     * Uloaded file name, including server path\n     *\n     * @access public\n     * @var string\n     */\n    var $file_src_pathname;\n\n    /**\n     * Uloaded file name temporary copy\n     *\n     * @access private\n     * @var string\n     */\n    var $file_src_temp;\n\n    /**\n     * Destination file name\n     *\n     * @access public\n     * @var string\n     */\n    var $file_dst_path;\n\n    /**\n     * Destination file name\n     *\n     * @access public\n     * @var string\n     */\n    var $file_dst_name;\n\n    /**\n     * Destination file name body (i.e. without extension)\n     *\n     * @access public\n     * @var string\n     */\n    var $file_dst_name_body;\n\n    /**\n     * Destination file extension\n     *\n     * @access public\n     * @var string\n     */\n    var $file_dst_name_ext;\n\n    /**\n     * Destination file name, including path\n     *\n     * @access public\n     * @var string\n     */\n    var $file_dst_pathname;\n\n    /**\n     * Source image width\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_src_x;\n\n    /**\n     * Source image height\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_src_y;\n\n    /**\n     * Source image color depth\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_src_bits;\n\n    /**\n     * Number of pixels\n     *\n     * @access public\n     * @var long\n     */\n    var $image_src_pixels;\n\n    /**\n     * Type of image (png, gif, jpg or bmp)\n     *\n     * @access public\n     * @var string\n     */\n    var $image_src_type;\n\n    /**\n     * Destination image width\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_dst_x;\n\n    /**\n     * Destination image height\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_dst_y;\n\n    /**\n     * Destination image type (png, gif, jpg or bmp)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_dst_type;\n\n    /**\n     * Supported image formats\n     *\n     * @access private\n     * @var array\n     */\n    var $image_supported;\n\n    /**\n     * Flag to determine if the source file is an image\n     *\n     * @access public\n     * @var boolean\n     */\n    var $file_is_image;\n\n    /**\n     * Flag set after instanciating the class\n     *\n     * Indicates if the file has been uploaded properly\n     *\n     * @access public\n     * @var bool\n     */\n    var $uploaded;\n\n    /**\n     * Flag stopping PHP upload checks\n     *\n     * Indicates whether we instanciated the class with a filename, in which case\n     * we will not check on the validity of the PHP *upload*\n     *\n     * This flag is automatically set to true when working on a local file\n     *\n     * Warning: for uploads, this flag MUST be set to false for security reason\n     *\n     * @access public\n     * @var bool\n     */\n    var $no_upload_check;\n\n    /**\n     * Flag set after calling a process\n     *\n     * Indicates if the processing, and copy of the resulting file went OK\n     *\n     * @access public\n     * @var bool\n     */\n    var $processed;\n\n    /**\n     * Holds eventual error message in plain english\n     *\n     * @access public\n     * @var string\n     */\n    var $error;\n\n    /**\n     * Holds an HTML formatted log\n     *\n     * @access public\n     * @var string\n     */\n    var $log;\n\n\n    // overiddable processing variables\n\n\n    /**\n     * Set this variable to replace the name body (i.e. without extension)\n     *\n     * @access public\n     * @var string\n     */\n    var $file_new_name_body;\n\n    /**\n     * Set this variable to append a string to the file name body\n     *\n     * @access public\n     * @var string\n     */\n    var $file_name_body_add;\n\n    /**\n     * Set this variable to prepend a string to the file name body\n     *\n     * @access public\n     * @var string\n     */\n    var $file_name_body_pre;\n\n    /**\n     * Set this variable to change the file extension\n     *\n     * @access public\n     * @var string\n     */\n    var $file_new_name_ext;\n\n    /**\n     * Set this variable to format the filename (spaces changed to _)\n     *\n     * @access public\n     * @var boolean\n     */\n    var $file_safe_name;\n\n    /**\n     * Forces an extension if the source file doesn't have one\n     *\n     * If the file is an image, then the correct extension will be added\n     * Otherwise, a .txt extension will be chosen\n     *\n     * @access public\n     * @var boolean\n     */\n    var $file_force_extension;\n\n    /**\n     * Set this variable to false if you don't want to check the MIME against the allowed list\n     *\n     * This variable is set to true by default for security reason\n     *\n     * @access public\n     * @var boolean\n     */\n    var $mime_check;\n\n    /**\n     * Set this variable to false in the init() function if you don't want to check the MIME\n     * with Fileinfo PECL extension. On some systems, Fileinfo is known to be buggy, and you\n     * may want to deactivate it in the class code directly.\n     *\n     * You can also set it with the path of the magic database file.\n     * If set to true, the class will try to read the MAGIC environment variable\n     *   and if it is empty, will default to the system's default\n     * If set to an empty string, it will call finfo_open without the path argument\n     *\n     * This variable is set to true by default for security reason\n     *\n     * @access public\n     * @var boolean\n     */\n    var $mime_fileinfo;\n\n    /**\n     * Set this variable to false in the init() function if you don't want to check the MIME\n     * with UNIX file() command\n     *\n     * This variable is set to true by default for security reason\n     *\n     * @access public\n     * @var boolean\n     */\n    var $mime_file;\n\n    /**\n     * Set this variable to false in the init() function if you don't want to check the MIME\n     * with the magic.mime file\n     *\n     * The function mime_content_type() will be deprecated,\n     * and this variable will be set to false in a future release\n     *\n     * This variable is set to true by default for security reason\n     *\n     * @access public\n     * @var boolean\n     */\n    var $mime_magic;\n\n    /**\n     * Set this variable to false in the init() function if you don't want to check the MIME\n     * with getimagesize()\n     *\n     * The class tries to get a MIME type from getimagesize()\n     * If no MIME is returned, it tries to guess the MIME type from the file type\n     *\n     * This variable is set to true by default for security reason\n     *\n     * @access public\n     * @var boolean\n     */\n    var $mime_getimagesize;\n\n    /**\n     * Set this variable to false if you don't want to turn dangerous scripts into simple text files\n     *\n     * @access public\n     * @var boolean\n     */\n    var $no_script;\n\n    /**\n     * Set this variable to true to allow automatic renaming of the file\n     * if the file already exists\n     *\n     * Default value is true\n     *\n     * For instance, on uploading foo.ext,<br>\n     * if foo.ext already exists, upload will be renamed foo_1.ext<br>\n     * and if foo_1.ext already exists, upload will be renamed foo_2.ext<br>\n     *\n     * Note that this option doesn't have any effect if {@link file_overwrite} is true\n     *\n     * @access public\n     * @var bool\n     */\n    var $file_auto_rename;\n\n    /**\n     * Set this variable to true to allow automatic creation of the destination\n     * directory if it is missing (works recursively)\n     *\n     * Default value is true\n     *\n     * @access public\n     * @var bool\n     */\n    var $dir_auto_create;\n\n    /**\n     * Set this variable to true to allow automatic chmod of the destination\n     * directory if it is not writeable\n     *\n     * Default value is true\n     *\n     * @access public\n     * @var bool\n     */\n    var $dir_auto_chmod;\n\n    /**\n     * Set this variable to the default chmod you want the class to use\n     * when creating directories, or attempting to write in a directory\n     *\n     * Default value is 0755 (without quotes)\n     *\n     * @access public\n     * @var bool\n     */\n    var $dir_chmod;\n\n    /**\n     * Set this variable tu true to allow overwriting of an existing file\n     *\n     * Default value is false, so no files will be overwritten\n     *\n     * @access public\n     * @var bool\n     */\n    var $file_overwrite;\n\n    /**\n     * Set this variable to change the maximum size in bytes for an uploaded file\n     *\n     * Default value is the value <i>upload_max_filesize</i> from php.ini\n     *\n     * Value in bytes (integer) or shorthand byte values (string) is allowed.\n     * The available options are K (for Kilobytes), M (for Megabytes) and G (for Gigabytes)\n     *\n     * @access public\n     * @var double\n     */\n    var $file_max_size;\n\n    /**\n     * Set this variable to true to resize the file if it is an image\n     *\n     * You will probably want to set {@link image_x} and {@link image_y}, and maybe one of the ratio variables\n     *\n     * Default value is false (no resizing)\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_resize;\n\n    /**\n     * Set this variable to convert the file if it is an image\n     *\n     * Possibles values are : ''; 'png'; 'jpeg'; 'gif'; 'bmp'\n     *\n     * Default value is '' (no conversion)<br>\n     * If {@link resize} is true, {@link convert} will be set to the source file extension\n     *\n     * @access public\n     * @var string\n     */\n    var $image_convert;\n\n    /**\n     * Set this variable to the wanted (or maximum/minimum) width for the processed image, in pixels\n     *\n     * Default value is 150\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_x;\n\n    /**\n     * Set this variable to the wanted (or maximum/minimum) height for the processed image, in pixels\n     *\n     * Default value is 150\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_y;\n\n    /**\n     * Set this variable to keep the original size ratio to fit within {@link image_x} x {@link image_y}\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_ratio;\n\n    /**\n     * Set this variable to keep the original size ratio to fit within {@link image_x} x {@link image_y}\n     *\n     * The image will be resized as to fill the whole space, and excedent will be cropped\n     *\n     * Value can also be a string, one or more character from 'TBLR' (top, bottom, left and right)\n     * If set as a string, it determines which side of the image is kept while cropping.\n     * By default, the part of the image kept is in the center, i.e. it crops equally on both sides\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var mixed\n     */\n    var $image_ratio_crop;\n\n    /**\n     * Set this variable to keep the original size ratio to fit within {@link image_x} x {@link image_y}\n     *\n     * The image will be resized to fit entirely in the space, and the rest will be colored.\n     * The default color is white, but can be set with {@link image_default_color}\n     *\n     * Value can also be a string, one or more character from 'TBLR' (top, bottom, left and right)\n     * If set as a string, it determines in which side of the space the image is displayed.\n     * By default, the image is displayed in the center, i.e. it fills the remaining space equally on both sides\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var mixed\n     */\n    var $image_ratio_fill;\n\n    /**\n     * Set this variable to a number of pixels so that {@link image_x} and {@link image_y} are the best match possible\n     *\n     * The image will be resized to have approximatively the number of pixels\n     * The aspect ratio wil be conserved\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var mixed\n     */\n    var $image_ratio_pixels;\n\n    /**\n     * Set this variable to calculate {@link image_x} automatically , using {@link image_y} and conserving ratio\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_ratio_x;\n\n    /**\n     * Set this variable to calculate {@link image_y} automatically , using {@link image_x} and conserving ratio\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_ratio_y;\n\n    /**\n     * (deprecated) Set this variable to keep the original size ratio to fit within {@link image_x} x {@link image_y},\n     * but only if original image is bigger\n     *\n     * This setting is soon to be deprecated. Instead, use {@link image_ratio} and {@link image_no_enlarging}\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_ratio_no_zoom_in;\n\n    /**\n     * (deprecated) Set this variable to keep the original size ratio to fit within {@link image_x} x {@link image_y},\n     * but only if original image is smaller\n     *\n     * Default value is false\n     *\n     * This setting is soon to be deprecated. Instead, use {@link image_ratio} and {@link image_no_shrinking}\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_ratio_no_zoom_out;\n\n    /**\n     * Cancel resizing if the resized image is bigger than the original image, to prevent enlarging\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_no_enlarging;\n\n    /**\n     * Cancel resizing if the resized image is smaller than the original image, to prevent shrinking\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_no_shrinking;\n\n    /**\n     * Set this variable to set a maximum image width, above which the upload will be invalid\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_max_width;\n\n    /**\n     * Set this variable to set a maximum image height, above which the upload will be invalid\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_max_height;\n\n    /**\n     * Set this variable to set a maximum number of pixels for an image, above which the upload will be invalid\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var long\n     */\n    var $image_max_pixels;\n\n    /**\n     * Set this variable to set a maximum image aspect ratio, above which the upload will be invalid\n     *\n     * Note that ratio = width / height\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var float\n     */\n    var $image_max_ratio;\n\n    /**\n     * Set this variable to set a minimum image width, below which the upload will be invalid\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_min_width;\n\n    /**\n     * Set this variable to set a minimum image height, below which the upload will be invalid\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_min_height;\n\n    /**\n     * Set this variable to set a minimum number of pixels for an image, below which the upload will be invalid\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var long\n     */\n    var $image_min_pixels;\n\n    /**\n     * Set this variable to set a minimum image aspect ratio, below which the upload will be invalid\n     *\n     * Note that ratio = width / height\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var float\n     */\n    var $image_min_ratio;\n\n    /**\n     * Compression level for PNG images\n     *\n     * Between 1 (fast but large files) and 9 (slow but smaller files)\n     *\n     * Default value is null (Zlib default)\n     *\n     * @access public\n     * @var integer\n     */\n    var $png_compression;\n\n    /**\n     * Quality of JPEG created/converted destination image\n     *\n     * Default value is 85\n     *\n     * @access public\n     * @var integer\n     */\n    var $jpeg_quality;\n\n    /**\n     * Determines the quality of the JPG image to fit a desired file size\n     *\n     * The JPG quality will be set between 1 and 100%\n     * The calculations are approximations.\n     *\n     * Value in bytes (integer) or shorthand byte values (string) is allowed.\n     * The available options are K (for Kilobytes), M (for Megabytes) and G (for Gigabytes)\n     *\n     * Default value is null (no calculations)\n     *\n     * @access public\n     * @var integer\n     */\n    var $jpeg_size;\n\n    /**\n     * Turns the interlace bit on\n     *\n     * This is actually used only for JPEG images, and defaults to false\n     *\n     * @access public\n     * @var boolean\n     */\n    var $image_interlace;\n\n    /**\n     * Flag set to true when the image is transparent\n     *\n     * This is actually used only for transparent GIFs\n     *\n     * @access public\n     * @var boolean\n     */\n    var $image_is_transparent;\n\n    /**\n     * Transparent color in a palette\n     *\n     * This is actually used only for transparent GIFs\n     *\n     * @access public\n     * @var boolean\n     */\n    var $image_transparent_color;\n\n    /**\n     * Background color, used to paint transparent areas with\n     *\n     * If set, it will forcibly remove transparency by painting transparent areas with the color\n     * This setting will fill in all transparent areas in PNG and GIF, as opposed to {@link image_default_color}\n     * which will do so only in BMP, JPEG, and alpha transparent areas in transparent GIFs\n     * This setting overrides {@link image_default_color}\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var string\n     */\n    var $image_background_color;\n\n    /**\n     * Default color for non alpha-transparent images\n     *\n     * This setting is to be used to define a background color for semi transparent areas\n     * of an alpha transparent when the output format doesn't support alpha transparency\n     * This is useful when, from an alpha transparent PNG image, or an image with alpha transparent features\n     * if you want to output it as a transparent GIFs for instance, you can set a blending color for transparent areas\n     * If you output in JPEG or BMP, this color will be used to fill in the previously transparent areas\n     *\n     * The default color white\n     *\n     * @access public\n     * @var boolean\n     */\n    var $image_default_color;\n\n    /**\n     * Flag set to true when the image is not true color\n     *\n     * @access public\n     * @var boolean\n     */\n    var $image_is_palette;\n\n    /**\n     * Corrects the image brightness\n     *\n     * Value can range between -127 and 127\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_brightness;\n\n    /**\n     * Corrects the image contrast\n     *\n     * Value can range between -127 and 127\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_contrast;\n\n    /**\n     * Changes the image opacity\n     *\n     * Value can range between 0 and 100\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_opacity;\n\n    /**\n     * Applies threshold filter\n     *\n     * Value can range between -127 and 127\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_threshold;\n\n    /**\n     * Applies a tint on the image\n     *\n     * Value is an hexadecimal color, such as #FFFFFF\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_tint_color;\n\n    /**\n     * Applies a colored overlay on the image\n     *\n     * Value is an hexadecimal color, such as #FFFFFF\n     *\n     * To use with {@link image_overlay_opacity}\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_overlay_color;\n\n    /**\n     * Sets the opacity for the colored overlay\n     *\n     * Value is a percentage, as an integer between 0 (transparent) and 100 (opaque)\n     *\n     * Unless used with {@link image_overlay_color}, this setting has no effect\n     *\n     * Default value is 50\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_overlay_opacity;\n\n    /**\n     * Inverts the color of an image\n     *\n     * Default value is FALSE\n     *\n     * @access public\n     * @var boolean;\n     */\n    var $image_negative;\n\n    /**\n     * Turns the image into greyscale\n     *\n     * Default value is FALSE\n     *\n     * @access public\n     * @var boolean;\n     */\n    var $image_greyscale;\n\n    /**\n     * Pixelate an image\n     *\n     * Value is integer, represents the block size\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer;\n     */\n    var $image_pixelate;\n\n    /**\n     * Applies an unsharp mask, with alpha transparency support\n     *\n     * Beware that this unsharp mask is quite resource-intensive\n     *\n     * Default value is FALSE\n     *\n     * @access public\n     * @var boolean;\n     */\n    var $image_unsharp;\n\n    /**\n     * Sets the unsharp mask amount\n     *\n     * Value is an integer between 0 and 500, typically between 50 and 200\n     *\n     * Unless used with {@link image_unsharp}, this setting has no effect\n     *\n     * Default value is 80\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_unsharp_amount;\n\n    /**\n     * Sets the unsharp mask radius\n     *\n     * Value is an integer between 0 and 50, typically between 0.5 and 1\n     * It is not recommended to change it, the default works best\n     *\n     * Unless used with {@link image_unsharp}, this setting has no effect\n     *\n     * From PHP 5.1, imageconvolution is used, and this setting has no effect\n     *\n     * Default value is 0.5\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_unsharp_radius;\n\n    /**\n     * Sets the unsharp mask threshold\n     *\n     * Value is an integer between 0 and 255, typically between 0 and 5\n     *\n     * Unless used with {@link image_unsharp}, this setting has no effect\n     *\n     * Default value is 1\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_unsharp_threshold;\n\n    /**\n     * Adds a text label on the image\n     *\n     * Value is a string, any text. Text will not word-wrap, although you can use breaklines in your text \"\\n\"\n     *\n     * If set, this setting allow the use of all other settings starting with image_text_\n     *\n     * Replacement tokens can be used in the string:\n     * <pre>\n     * gd_version    src_name       src_name_body src_name_ext\n     * src_pathname  src_mime       src_x         src_y\n     * src_type      src_bits       src_pixels\n     * src_size      src_size_kb    src_size_mb   src_size_human\n     * dst_path      dst_name_body  dst_pathname\n     * dst_name      dst_name_ext   dst_x         dst_y\n     * date          time           host          server        ip\n     * </pre>\n     * The tokens must be enclosed in square brackets: [dst_x] will be replaced by the width of the picture\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_text;\n\n    /**\n     * Sets the text direction for the text label\n     *\n     * Value is either 'h' or 'v', as in horizontal and vertical\n     *\n     * Note that if you use a TrueType font, you can use {@link image_text_angle} instead\n     *\n     * Default value is h (horizontal)\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_text_direction;\n\n    /**\n     * Sets the text color for the text label\n     *\n     * Value is an hexadecimal color, such as #FFFFFF\n     *\n     * Default value is #FFFFFF (white)\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_text_color;\n\n    /**\n     * Sets the text opacity in the text label\n     *\n     * Value is a percentage, as an integer between 0 (transparent) and 100 (opaque)\n     *\n     * Default value is 100\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_opacity;\n\n    /**\n     * Sets the text background color for the text label\n     *\n     * Value is an hexadecimal color, such as #FFFFFF\n     *\n     * Default value is null (no background)\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_text_background;\n\n    /**\n     * Sets the text background opacity in the text label\n     *\n     * Value is a percentage, as an integer between 0 (transparent) and 100 (opaque)\n     *\n     * Default value is 100\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_background_opacity;\n\n    /**\n     * Sets the text font in the text label\n     *\n     * Value is a an integer between 1 and 5 for GD built-in fonts. 1 is the smallest font, 5 the biggest\n     * Value can also be a string, which represents the path to a GDF or TTF font (TrueType).\n     *\n     * Default value is 5\n     *\n     * @access public\n     * @var mixed;\n     */\n    var $image_text_font;\n\n    /**\n     * Sets the text font size for TrueType fonts\n     *\n     * Value is a an integer, and represents the font size in pixels (GD1) or points (GD1)\n     *\n     * Note that this setting is only applicable to TrueType fonts, and has no effects with GD fonts\n     *\n     * Default value is 16\n     *\n     * @access public\n     * @var integer;\n     */\n    var $image_text_size;\n\n    /**\n     * Sets the text angle for TrueType fonts\n     *\n     * Value is a an integer between 0 and 360, in degrees, with 0 degrees being left-to-right reading text.\n     *\n     * Note that this setting is only applicable to TrueType fonts, and has no effects with GD fonts\n     * For GD fonts, you can use {@link image_text_direction} instead\n     *\n     * Default value is null (so it is determined by the value of {@link image_text_direction})\n     *\n     * @access public\n     * @var integer;\n     */\n    var $image_text_angle;\n\n    /**\n     * Sets the text label position within the image\n     *\n     * Value is one or two out of 'TBLR' (top, bottom, left, right)\n     *\n     * The positions are as following:\n     * <pre>\n     *                        TL  T  TR\n     *                        L       R\n     *                        BL  B  BR\n     * </pre>\n     *\n     * Default value is null (centered, horizontal and vertical)\n     *\n     * Note that is {@link image_text_x} and {@link image_text_y} are used, this setting has no effect\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_text_position;\n\n    /**\n     * Sets the text label absolute X position within the image\n     *\n     * Value is in pixels, representing the distance between the left of the image and the label\n     * If a negative value is used, it will represent the distance between the right of the image and the label\n     *\n     * Default value is null (so {@link image_text_position} is used)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_x;\n\n    /**\n     * Sets the text label absolute Y position within the image\n     *\n     * Value is in pixels, representing the distance between the top of the image and the label\n     * If a negative value is used, it will represent the distance between the bottom of the image and the label\n     *\n     * Default value is null (so {@link image_text_position} is used)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_y;\n\n    /**\n     * Sets the text label padding\n     *\n     * Value is in pixels, representing the distance between the text and the label background border\n     *\n     * Default value is 0\n     *\n     * This setting can be overriden by {@link image_text_padding_x} and {@link image_text_padding_y}\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_padding;\n\n    /**\n     * Sets the text label horizontal padding\n     *\n     * Value is in pixels, representing the distance between the text and the left and right label background borders\n     *\n     * Default value is null\n     *\n     * If set, this setting overrides the horizontal part of {@link image_text_padding}\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_padding_x;\n\n    /**\n     * Sets the text label vertical padding\n     *\n     * Value is in pixels, representing the distance between the text and the top and bottom label background borders\n     *\n     * Default value is null\n     *\n     * If set, his setting overrides the vertical part of {@link image_text_padding}\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_padding_y;\n\n    /**\n     * Sets the text alignment\n     *\n     * Value is a string, which can be either 'L', 'C' or 'R'\n     *\n     * Default value is 'C'\n     *\n     * This setting is relevant only if the text has several lines.\n     *\n     * Note that this setting is only applicable to GD fonts, and has no effects with TrueType fonts\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_text_alignment;\n\n    /**\n     * Sets the text line spacing\n     *\n     * Value is an integer, in pixels\n     *\n     * Default value is 0\n     *\n     * This setting is relevant only if the text has several lines.\n     *\n     * Note that this setting is only applicable to GD fonts, and has no effects with TrueType fonts\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_line_spacing;\n\n    /**\n     * Sets the height of the reflection\n     *\n     * Value is an integer in pixels, or a string which format can be in pixels or percentage.\n     * For instance, values can be : 40, '40', '40px' or '40%'\n     *\n     * Default value is null, no reflection\n     *\n     * @access public\n     * @var mixed;\n     */\n    var $image_reflection_height;\n\n    /**\n     * Sets the space between the source image and its relection\n     *\n     * Value is an integer in pixels, which can be negative\n     *\n     * Default value is 2\n     *\n     * This setting is relevant only if {@link image_reflection_height} is set\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_reflection_space;\n\n    /**\n     * Sets the initial opacity of the reflection\n     *\n     * Value is an integer between 0 (no opacity) and 100 (full opacity).\n     * The reflection will start from {@link image_reflection_opacity} and end up at 0\n     *\n     * Default value is 60\n     *\n     * This setting is relevant only if {@link image_reflection_height} is set\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_reflection_opacity;\n\n    /**\n     * Automatically rotates the image according to EXIF data (JPEG only)\n     *\n     * Default value is true\n     *\n     * @access public\n     * @var boolean;\n     */\n    var $image_auto_rotate;\n\n    /**\n     * Flips the image vertically or horizontally\n     *\n     * Value is either 'h' or 'v', as in horizontal and vertical\n     *\n     * Default value is null (no flip)\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_flip;\n\n    /**\n     * Rotates the image by increments of 45 degrees\n     *\n     * Value is either 90, 180 or 270\n     *\n     * Default value is null (no rotation)\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_rotate;\n\n    /**\n     * Crops an image\n     *\n     * Values are four dimensions, or two, or one (CSS style)\n     * They represent the amount cropped top, right, bottom and left.\n     * These values can either be in an array, or a space separated string.\n     * Each value can be in pixels (with or without 'px'), or percentage (of the source image)\n     *\n     * For instance, are valid:\n     * <pre>\n     * $foo->image_crop = 20                  OR array(20);\n     * $foo->image_crop = '20px'              OR array('20px');\n     * $foo->image_crop = '20 40'             OR array('20', 40);\n     * $foo->image_crop = '-20 25%'           OR array(-20, '25%');\n     * $foo->image_crop = '20px 25%'          OR array('20px', '25%');\n     * $foo->image_crop = '20% 25%'           OR array('20%', '25%');\n     * $foo->image_crop = '20% 25% 10% 30%'   OR array('20%', '25%', '10%', '30%');\n     * $foo->image_crop = '20px 25px 2px 2px' OR array('20px', '25%px', '2px', '2px');\n     * $foo->image_crop = '20 25% 40px 10%'   OR array(20, '25%', '40px', '10%');\n     * </pre>\n     *\n     * If a value is negative, the image will be expanded, and the extra parts will be filled with black\n     *\n     * Default value is null (no cropping)\n     *\n     * @access public\n     * @var string OR array;\n     */\n    var $image_crop;\n\n    /**\n     * Crops an image, before an eventual resizing\n     *\n     * See {@link image_crop} for valid formats\n     *\n     * Default value is null (no cropping)\n     *\n     * @access public\n     * @var string OR array;\n     */\n    var $image_precrop;\n\n    /**\n     * Adds a bevel border on the image\n     *\n     * Value is a positive integer, representing the thickness of the bevel\n     *\n     * If the bevel colors are the same as the background, it makes a fade out effect\n     *\n     * Default value is null (no bevel)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_bevel;\n\n    /**\n     * Top and left bevel color\n     *\n     * Value is a color, in hexadecimal format\n     * This setting is used only if {@link image_bevel} is set\n     *\n     * Default value is #FFFFFF\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_bevel_color1;\n\n    /**\n     * Right and bottom bevel color\n     *\n     * Value is a color, in hexadecimal format\n     * This setting is used only if {@link image_bevel} is set\n     *\n     * Default value is #000000\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_bevel_color2;\n\n    /**\n     * Adds a single-color border on the outer of the image\n     *\n     * Values are four dimensions, or two, or one (CSS style)\n     * They represent the border thickness top, right, bottom and left.\n     * These values can either be in an array, or a space separated string.\n     * Each value can be in pixels (with or without 'px'), or percentage (of the source image)\n     *\n     * See {@link image_crop} for valid formats\n     *\n     * If a value is negative, the image will be cropped.\n     * Note that the dimensions of the picture will be increased by the borders' thickness\n     *\n     * Default value is null (no border)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_border;\n\n    /**\n     * Border color\n     *\n     * Value is a color, in hexadecimal format.\n     * This setting is used only if {@link image_border} is set\n     *\n     * Default value is #FFFFFF\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_border_color;\n\n    /**\n     * Sets the opacity for the borders\n     *\n     * Value is a percentage, as an integer between 0 (transparent) and 100 (opaque)\n     *\n     * Unless used with {@link image_border}, this setting has no effect\n     *\n     * Default value is 100\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_border_opacity;\n\n    /**\n     * Adds a fading-to-transparent border on the image\n     *\n     * Values are four dimensions, or two, or one (CSS style)\n     * They represent the border thickness top, right, bottom and left.\n     * These values can either be in an array, or a space separated string.\n     * Each value can be in pixels (with or without 'px'), or percentage (of the source image)\n     *\n     * See {@link image_crop} for valid formats\n     *\n     * Note that the dimensions of the picture will not be increased by the borders' thickness\n     *\n     * Default value is null (no border)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_border_transparent;\n\n    /**\n     * Adds a multi-color frame on the outer of the image\n     *\n     * Value is an integer. Two values are possible for now:\n     * 1 for flat border, meaning that the frame is mirrored horizontally and vertically\n     * 2 for crossed border, meaning that the frame will be inversed, as in a bevel effect\n     *\n     * The frame will be composed of colored lines set in {@link image_frame_colors}\n     *\n     * Note that the dimensions of the picture will be increased by the borders' thickness\n     *\n     * Default value is null (no frame)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_frame;\n\n    /**\n     * Sets the colors used to draw a frame\n     *\n     * Values is a list of n colors in hexadecimal format.\n     * These values can either be in an array, or a space separated string.\n     *\n     * The colors are listed in the following order: from the outset of the image to its center\n     *\n     * For instance, are valid:\n     * <pre>\n     * $foo->image_frame_colors = '#FFFFFF #999999 #666666 #000000';\n     * $foo->image_frame_colors = array('#FFFFFF', '#999999', '#666666', '#000000');\n     * </pre>\n     *\n     * This setting is used only if {@link image_frame} is set\n     *\n     * Default value is '#FFFFFF #999999 #666666 #000000'\n     *\n     * @access public\n     * @var string OR array;\n     */\n    var $image_frame_colors;\n\n    /**\n     * Sets the opacity for the frame\n     *\n     * Value is a percentage, as an integer between 0 (transparent) and 100 (opaque)\n     *\n     * Unless used with {@link image_frame}, this setting has no effect\n     *\n     * Default value is 100\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_frame_opacity;\n\n    /**\n     * Adds a watermark on the image\n     *\n     * Value is a local image filename, relative or absolute. GIF, JPG, BMP and PNG are supported, as well as PNG alpha.\n     *\n     * If set, this setting allow the use of all other settings starting with image_watermark_\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_watermark;\n\n    /**\n     * Sets the watermarkposition within the image\n     *\n     * Value is one or two out of 'TBLR' (top, bottom, left, right)\n     *\n     * The positions are as following:   TL  T  TR\n     *                                   L       R\n     *                                   BL  B  BR\n     *\n     * Default value is null (centered, horizontal and vertical)\n     *\n     * Note that is {@link image_watermark_x} and {@link image_watermark_y} are used, this setting has no effect\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_watermark_position;\n\n    /**\n     * Sets the watermark absolute X position within the image\n     *\n     * Value is in pixels, representing the distance between the top of the image and the watermark\n     * If a negative value is used, it will represent the distance between the bottom of the image and the watermark\n     *\n     * Default value is null (so {@link image_watermark_position} is used)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_watermark_x;\n\n    /**\n     * Sets the twatermark absolute Y position within the image\n     *\n     * Value is in pixels, representing the distance between the left of the image and the watermark\n     * If a negative value is used, it will represent the distance between the right of the image and the watermark\n     *\n     * Default value is null (so {@link image_watermark_position} is used)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_watermark_y;\n\n    /**\n     * Prevents the watermark to be resized up if it is smaller than the image\n     *\n     * If the watermark if smaller than the destination image, taking in account the desired watermark position\n     * then it will be resized up to fill in the image (minus the {@link image_watermark_x} or {@link image_watermark_y} values)\n     *\n     * If you don't want your watermark to be resized in any way, then\n     * set {@link image_watermark_no_zoom_in} and {@link image_watermark_no_zoom_out} to true\n     * If you want your watermark to be resized up or doan to fill in the image better, then\n     * set {@link image_watermark_no_zoom_in} and {@link image_watermark_no_zoom_out} to false\n     *\n     * Default value is true (so the watermark will not be resized up, which is the behaviour most people expect)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_watermark_no_zoom_in;\n\n    /**\n     * Prevents the watermark to be resized down if it is bigger than the image\n     *\n     * If the watermark if bigger than the destination image, taking in account the desired watermark position\n     * then it will be resized down to fit in the image (minus the {@link image_watermark_x} or {@link image_watermark_y} values)\n     *\n     * If you don't want your watermark to be resized in any way, then\n     * set {@link image_watermark_no_zoom_in} and {@link image_watermark_no_zoom_out} to true\n     * If you want your watermark to be resized up or doan to fill in the image better, then\n     * set {@link image_watermark_no_zoom_in} and {@link image_watermark_no_zoom_out} to false\n     *\n     * Default value is false (so the watermark may be shrinked to fit in the image)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_watermark_no_zoom_out;\n\n    /**\n     * List of MIME types per extension\n     *\n     * @access private\n     * @var array\n     */\n    var $mime_types;\n\n    /**\n     * Allowed MIME types\n     *\n     * Default is a selection of safe mime-types, but you might want to change it\n     *\n     * Simple wildcards are allowed, such as image/* or application/*\n     * If there is only one MIME type allowed, then it can be a string instead of an array\n     *\n     * @access public\n     * @var array OR string\n     */\n    var $allowed;\n\n    /**\n     * Forbidden MIME types\n     *\n     * Default is a selection of safe mime-types, but you might want to change it\n     * To only check for forbidden MIME types, and allow everything else, set {@link allowed} to array('* / *') without the spaces\n     *\n     * Simple wildcards are allowed, such as image/* or application/*\n     * If there is only one MIME type forbidden, then it can be a string instead of an array\n     *\n     * @access public\n     * @var array OR string\n     */\n    var $forbidden;\n\n    /**\n     * Array of translated error messages\n     *\n     * By default, the language is english (en_GB)\n     * Translations can be in separate files, in a lang/ subdirectory\n     *\n     * @access public\n     * @var array\n     */\n    var $translation;\n\n    /**\n     * Language selected for the translations\n     *\n     * By default, the language is english (\"en_GB\")\n     *\n     * @access public\n     * @var array\n     */\n    var $lang;\n\n    /**\n     * Init or re-init all the processing variables to their default values\n     *\n     * This function is called in the constructor, and after each call of {@link process}\n     *\n     * @access private\n     */\n    function init() {\n\n        // overiddable variables\n        $this->file_new_name_body       = null;     // replace the name body\n        $this->file_name_body_add       = null;     // append to the name body\n        $this->file_name_body_pre       = null;     // prepend to the name body\n        $this->file_new_name_ext        = null;     // replace the file extension\n        $this->file_safe_name           = true;     // format safely the filename\n        $this->file_force_extension     = true;     // forces extension if there isn't one\n        $this->file_overwrite           = false;    // allows overwritting if the file already exists\n        $this->file_auto_rename         = true;     // auto-rename if the file already exists\n        $this->dir_auto_create          = true;     // auto-creates directory if missing\n        $this->dir_auto_chmod           = true;     // auto-chmod directory if not writeable\n        $this->dir_chmod                = 0755;     // default chmod to use\n\n        $this->no_script                = true;     // turns scripts into test files\n        $this->mime_check               = true;     // checks the mime type against the allowed list\n\n        // these are the different MIME detection methods. if one of these method doesn't work on your\n        // system, you can deactivate it here; just set it to false\n        $this->mime_fileinfo            = true;     // MIME detection with Fileinfo PECL extension\n        $this->mime_file                = true;     // MIME detection with UNIX file() command\n        $this->mime_magic               = true;     // MIME detection with mime_magic (mime_content_type())\n        $this->mime_getimagesize        = true;     // MIME detection with getimagesize()\n\n        // get the default max size from php.ini\n        $this->file_max_size_raw = trim(ini_get('upload_max_filesize'));\n        $this->file_max_size = $this->getsize($this->file_max_size_raw);\n\n        $this->image_resize             = false;    // resize the image\n        $this->image_convert            = '';       // convert. values :''; 'png'; 'jpeg'; 'gif'; 'bmp'\n\n        $this->image_x                  = 150;\n        $this->image_y                  = 150;\n        $this->image_ratio              = false;    // keeps aspect ratio with x and y dimensions\n        $this->image_ratio_crop         = false;    // keeps aspect ratio with x and y dimensions, filling the space\n        $this->image_ratio_fill         = false;    // keeps aspect ratio with x and y dimensions, fitting the image in the space, and coloring the rest\n        $this->image_ratio_pixels       = false;    // keeps aspect ratio, calculating x and y so that the image is approx the set number of pixels\n        $this->image_ratio_x            = false;    // calculate the $image_x if true\n        $this->image_ratio_y            = false;    // calculate the $image_y if true\n        $this->image_ratio_no_zoom_in   = false;\n        $this->image_ratio_no_zoom_out  = false;\n        $this->image_no_enlarging       = false;\n        $this->image_no_shrinking       = false;\n\n        $this->png_compression          = null;\n        $this->jpeg_quality             = 85;\n        $this->jpeg_size                = null;\n        $this->image_interlace          = false;\n        $this->image_is_transparent     = false;\n        $this->image_transparent_color  = null;\n        $this->image_background_color   = null;\n        $this->image_default_color      = '#ffffff';\n        $this->image_is_palette         = false;\n\n        $this->image_max_width          = null;\n        $this->image_max_height         = null;\n        $this->image_max_pixels         = null;\n        $this->image_max_ratio          = null;\n        $this->image_min_width          = null;\n        $this->image_min_height         = null;\n        $this->image_min_pixels         = null;\n        $this->image_min_ratio          = null;\n\n        $this->image_brightness         = null;\n        $this->image_contrast           = null;\n        $this->image_opacity            = null;\n        $this->image_threshold          = null;\n        $this->image_tint_color         = null;\n        $this->image_overlay_color      = null;\n        $this->image_overlay_opacity    = null;\n        $this->image_negative           = false;\n        $this->image_greyscale          = false;\n        $this->image_pixelate           = null;\n        $this->image_unsharp            = false;\n        $this->image_unsharp_amount     = 80;\n        $this->image_unsharp_radius     = 0.5;\n        $this->image_unsharp_threshold  = 1;\n\n        $this->image_text               = null;\n        $this->image_text_direction     = null;\n        $this->image_text_color         = '#FFFFFF';\n        $this->image_text_opacity       = 100;\n        $this->image_text_background    = null;\n        $this->image_text_background_opacity = 100;\n        $this->image_text_font          = 5;\n        $this->image_text_size          = 16;\n        $this->image_text_angle         = null;\n        $this->image_text_x             = null;\n        $this->image_text_y             = null;\n        $this->image_text_position      = null;\n        $this->image_text_padding       = 0;\n        $this->image_text_padding_x     = null;\n        $this->image_text_padding_y     = null;\n        $this->image_text_alignment     = 'C';\n        $this->image_text_line_spacing  = 0;\n\n        $this->image_reflection_height  = null;\n        $this->image_reflection_space   = 2;\n        $this->image_reflection_opacity = 60;\n\n        $this->image_watermark          = null;\n        $this->image_watermark_x        = null;\n        $this->image_watermark_y        = null;\n        $this->image_watermark_position = null;\n        $this->image_watermark_no_zoom_in  = true;\n        $this->image_watermark_no_zoom_out = false;\n\n        $this->image_flip               = null;\n        $this->image_auto_rotate        = true;\n        $this->image_rotate             = null;\n        $this->image_crop               = null;\n        $this->image_precrop            = null;\n\n        $this->image_bevel              = null;\n        $this->image_bevel_color1       = '#FFFFFF';\n        $this->image_bevel_color2       = '#000000';\n        $this->image_border             = null;\n        $this->image_border_color       = '#FFFFFF';\n        $this->image_border_opacity     = 100;\n        $this->image_border_transparent = null;\n        $this->image_frame              = null;\n        $this->image_frame_colors       = '#FFFFFF #999999 #666666 #000000';\n        $this->image_frame_opacity      = 100;\n\n        $this->forbidden = array();\n        $this->allowed = array(\n            'application/arj',\n            'application/excel',\n            'application/gnutar',\n            'application/mspowerpoint',\n            'application/msword',\n            'application/octet-stream',\n            'application/onenote',\n            'application/pdf',\n            'application/plain',\n            'application/postscript',\n            'application/powerpoint',\n            'application/rar',\n            'application/rtf',\n            'application/vnd.ms-excel',\n            'application/vnd.ms-excel.addin.macroEnabled.12',\n            'application/vnd.ms-excel.sheet.binary.macroEnabled.12',\n            'application/vnd.ms-excel.sheet.macroEnabled.12',\n            'application/vnd.ms-excel.template.macroEnabled.12',\n            'application/vnd.ms-office',\n            'application/vnd.ms-officetheme',\n            'application/vnd.ms-powerpoint',\n            'application/vnd.ms-powerpoint.addin.macroEnabled.12',\n            'application/vnd.ms-powerpoint.presentation.macroEnabled.12',\n            'application/vnd.ms-powerpoint.slide.macroEnabled.12',\n            'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',\n            'application/vnd.ms-powerpoint.template.macroEnabled.12',\n            'application/vnd.ms-word',\n            'application/vnd.ms-word.document.macroEnabled.12',\n            'application/vnd.ms-word.template.macroEnabled.12',\n            'application/vnd.oasis.opendocument.chart',\n            'application/vnd.oasis.opendocument.database',\n            'application/vnd.oasis.opendocument.formula',\n            'application/vnd.oasis.opendocument.graphics',\n            'application/vnd.oasis.opendocument.graphics-template',\n            'application/vnd.oasis.opendocument.image',\n            'application/vnd.oasis.opendocument.presentation',\n            'application/vnd.oasis.opendocument.presentation-template',\n            'application/vnd.oasis.opendocument.spreadsheet',\n            'application/vnd.oasis.opendocument.spreadsheet-template',\n            'application/vnd.oasis.opendocument.text',\n            'application/vnd.oasis.opendocument.text-master',\n            'application/vnd.oasis.opendocument.text-template',\n            'application/vnd.oasis.opendocument.text-web',\n            'application/vnd.openofficeorg.extension',\n            'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n            'application/vnd.openxmlformats-officedocument.presentationml.slide',\n            'application/vnd.openxmlformats-officedocument.presentationml.slideshow',\n            'application/vnd.openxmlformats-officedocument.presentationml.template',\n            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            'application/vnd.openxmlformats-officedocument.spreadsheetml.template',\n            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            'application/vnd.openxmlformats-officedocument.wordprocessingml.template',\n            'application/vocaltec-media-file',\n            'application/wordperfect',\n            'application/x-bittorrent',\n            'application/x-bzip',\n            'application/x-bzip2',\n            'application/x-compressed',\n            'application/x-excel',\n            'application/x-gzip',\n            'application/x-latex',\n            'application/x-midi',\n            'application/xml',\n            'application/x-msexcel',\n            'application/x-rar',\n            'application/x-rar-compressed',\n            'application/x-rtf',\n            'application/x-shockwave-flash',\n            'application/x-sit',\n            'application/x-stuffit',\n            'application/x-troff-msvideo',\n            'application/x-zip',\n            'application/x-zip-compressed',\n            'application/zip',\n            'audio/*',\n            'image/*',\n            'multipart/x-gzip',\n            'multipart/x-zip',\n            'text/plain',\n            'text/rtf',\n            'text/richtext',\n            'text/xml',\n            'video/*',\n            'text/csv'\n        );\n\n        $this->mime_types = array(\n            'jpg' => 'image/jpeg',\n            'jpeg' => 'image/jpeg',\n            'jpe' => 'image/jpeg',\n            'gif' => 'image/gif',\n            'png' => 'image/png',\n            'bmp' => 'image/bmp',\n            'flif' => 'image/flif',\n            'flv' => 'video/x-flv',\n            'js' => 'application/x-javascript',\n            'json' => 'application/json',\n            'tiff' => 'image/tiff',\n            'css' => 'text/css',\n            'xml' => 'application/xml',\n            'doc' => 'application/msword',\n            'xls' => 'application/vnd.ms-excel',\n            'xlt' => 'application/vnd.ms-excel',\n            'xlm' => 'application/vnd.ms-excel',\n            'xld' => 'application/vnd.ms-excel',\n            'xla' => 'application/vnd.ms-excel',\n            'xlc' => 'application/vnd.ms-excel',\n            'xlw' => 'application/vnd.ms-excel',\n            'xll' => 'application/vnd.ms-excel',\n            'ppt' => 'application/vnd.ms-powerpoint',\n            'pps' => 'application/vnd.ms-powerpoint',\n            'rtf' => 'application/rtf',\n            'pdf' => 'application/pdf',\n            'html' => 'text/html',\n            'htm' => 'text/html',\n            'php' => 'text/html',\n            'txt' => 'text/plain',\n            'mpeg' => 'video/mpeg',\n            'mpg' => 'video/mpeg',\n            'mpe' => 'video/mpeg',\n            'mp3' => 'audio/mpeg3',\n            'wav' => 'audio/wav',\n            'aiff' => 'audio/aiff',\n            'aif' => 'audio/aiff',\n            'avi' => 'video/msvideo',\n            'wmv' => 'video/x-ms-wmv',\n            'mov' => 'video/quicktime',\n            'zip' => 'application/zip',\n            'tar' => 'application/x-tar',\n            'swf' => 'application/x-shockwave-flash',\n            'odt' => 'application/vnd.oasis.opendocument.text',\n            'ott' => 'application/vnd.oasis.opendocument.text-template',\n            'oth' => 'application/vnd.oasis.opendocument.text-web',\n            'odm' => 'application/vnd.oasis.opendocument.text-master',\n            'odg' => 'application/vnd.oasis.opendocument.graphics',\n            'otg' => 'application/vnd.oasis.opendocument.graphics-template',\n            'odp' => 'application/vnd.oasis.opendocument.presentation',\n            'otp' => 'application/vnd.oasis.opendocument.presentation-template',\n            'ods' => 'application/vnd.oasis.opendocument.spreadsheet',\n            'ots' => 'application/vnd.oasis.opendocument.spreadsheet-template',\n            'odc' => 'application/vnd.oasis.opendocument.chart',\n            'odf' => 'application/vnd.oasis.opendocument.formula',\n            'odb' => 'application/vnd.oasis.opendocument.database',\n            'odi' => 'application/vnd.oasis.opendocument.image',\n            'oxt' => 'application/vnd.openofficeorg.extension',\n            'docx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            'docm' => 'application/vnd.ms-word.document.macroEnabled.12',\n            'dotx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',\n            'dotm' => 'application/vnd.ms-word.template.macroEnabled.12',\n            'xlsx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            'xlsm' => 'application/vnd.ms-excel.sheet.macroEnabled.12',\n            'xltx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',\n            'xltm' => 'application/vnd.ms-excel.template.macroEnabled.12',\n            'xlsb' => 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',\n            'xlam' => 'application/vnd.ms-excel.addin.macroEnabled.12',\n            'pptx' => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n            'pptm' => 'application/vnd.ms-powerpoint.presentation.macroEnabled.12',\n            'ppsx' => 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',\n            'ppsm' => 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',\n            'potx' => 'application/vnd.openxmlformats-officedocument.presentationml.template',\n            'potm' => 'application/vnd.ms-powerpoint.template.macroEnabled.12',\n            'ppam' => 'application/vnd.ms-powerpoint.addin.macroEnabled.12',\n            'sldx' => 'application/vnd.openxmlformats-officedocument.presentationml.slide',\n            'sldm' => 'application/vnd.ms-powerpoint.slide.macroEnabled.12',\n            'thmx' => 'application/vnd.ms-officetheme',\n            'onetoc' => 'application/onenote',\n            'onetoc2' => 'application/onenote',\n            'onetmp' => 'application/onenote',\n            'onepkg' => 'application/onenote',\n            'csv' => 'text/csv',\n        );\n\n    }\n\n    /**\n     * Constructor, for PHP5+\n     */\n    function  __construct($file, $lang = 'en_GB')  {\n        $this->upload($file, $lang);\n    }\n\n    /**\n     * Constructor, for PHP4. Checks if the file has been uploaded\n     *\n     * The constructor takes $_FILES['form_field'] array as argument\n     * where form_field is the form field name\n     *\n     * The constructor will check if the file has been uploaded in its temporary location, and\n     * accordingly will set {@link uploaded} (and {@link error} is an error occurred)\n     *\n     * If the file has been uploaded, the constructor will populate all the variables holding the upload\n     * information (none of the processing class variables are used here).\n     * You can have access to information about the file (name, size, MIME type...).\n     *\n     *\n     * Alternatively, you can set the first argument to be a local filename (string)\n     * This allows processing of a local file, as if the file was uploaded\n     *\n     * The optional second argument allows you to set the language for the error messages\n     *\n     * @access private\n     * @param  array  $file $_FILES['form_field']\n     *    or   string $file Local filename\n     * @param  string $lang Optional language code\n     */\n    function upload($file, $lang = 'en_GB') {\n\n        $this->version            = '0.34dev';\n\n        $this->file_src_name      = '';\n        $this->file_src_name_body = '';\n        $this->file_src_name_ext  = '';\n        $this->file_src_mime      = '';\n        $this->file_src_size      = '';\n        $this->file_src_error     = '';\n        $this->file_src_pathname  = '';\n        $this->file_src_temp      = '';\n\n        $this->file_dst_path      = '';\n        $this->file_dst_name      = '';\n        $this->file_dst_name_body = '';\n        $this->file_dst_name_ext  = '';\n        $this->file_dst_pathname  = '';\n\n        $this->image_src_x        = null;\n        $this->image_src_y        = null;\n        $this->image_src_bits     = null;\n        $this->image_src_type     = null;\n        $this->image_src_pixels   = null;\n        $this->image_dst_x        = 0;\n        $this->image_dst_y        = 0;\n        $this->image_dst_type     = '';\n\n        $this->uploaded           = true;\n        $this->no_upload_check    = false;\n        $this->processed          = false;\n        $this->error              = '';\n        $this->log                = '';\n        $this->allowed            = array();\n        $this->forbidden          = array();\n        $this->file_is_image      = false;\n        $this->init();\n        $info                     = null;\n        $mime_from_browser        = null;\n\n        // sets default language\n        $this->translation        = array();\n        $this->translation['file_error']                  = 'File error. Please try again.';\n        $this->translation['local_file_missing']          = 'Local file doesn\\'t exist.';\n        $this->translation['local_file_not_readable']     = 'Local file is not readable.';\n        $this->translation['uploaded_too_big_ini']        = 'File upload error (the uploaded file exceeds the upload_max_filesize directive in php.ini).';\n        $this->translation['uploaded_too_big_html']       = 'File upload error (the uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the html form).';\n        $this->translation['uploaded_partial']            = 'File upload error (the uploaded file was only partially uploaded).';\n        $this->translation['uploaded_missing']            = 'File upload error (no file was uploaded).';\n        $this->translation['uploaded_no_tmp_dir']         = 'File upload error (missing a temporary folder).';\n        $this->translation['uploaded_cant_write']         = 'File upload error (failed to write file to disk).';\n        $this->translation['uploaded_err_extension']      = 'File upload error (file upload stopped by extension).';\n        $this->translation['uploaded_unknown']            = 'File upload error (unknown error code).';\n        $this->translation['try_again']                   = 'File upload error. Please try again.';\n        $this->translation['file_too_big']                = 'File too big.';\n        $this->translation['no_mime']                     = 'MIME type can\\'t be detected.';\n        $this->translation['incorrect_file']              = 'Incorrect type of file.';\n        $this->translation['image_too_wide']              = 'Image too wide.';\n        $this->translation['image_too_narrow']            = 'Image too narrow.';\n        $this->translation['image_too_high']              = 'Image too tall.';\n        $this->translation['image_too_short']             = 'Image too short.';\n        $this->translation['ratio_too_high']              = 'Image ratio too high (image too wide).';\n        $this->translation['ratio_too_low']               = 'Image ratio too low (image too high).';\n        $this->translation['too_many_pixels']             = 'Image has too many pixels.';\n        $this->translation['not_enough_pixels']           = 'Image has not enough pixels.';\n        $this->translation['file_not_uploaded']           = 'File not uploaded. Can\\'t carry on a process.';\n        $this->translation['already_exists']              = '%s already exists. Please change the file name.';\n        $this->translation['temp_file_missing']           = 'No correct temp source file. Can\\'t carry on a process.';\n        $this->translation['source_missing']              = 'No correct uploaded source file. Can\\'t carry on a process.';\n        $this->translation['destination_dir']             = 'Destination directory can\\'t be created. Can\\'t carry on a process.';\n        $this->translation['destination_dir_missing']     = 'Destination directory doesn\\'t exist. Can\\'t carry on a process.';\n        $this->translation['destination_path_not_dir']    = 'Destination path is not a directory. Can\\'t carry on a process.';\n        $this->translation['destination_dir_write']       = 'Destination directory can\\'t be made writeable. Can\\'t carry on a process.';\n        $this->translation['destination_path_write']      = 'Destination path is not a writeable. Can\\'t carry on a process.';\n        $this->translation['temp_file']                   = 'Can\\'t create the temporary file. Can\\'t carry on a process.';\n        $this->translation['source_not_readable']         = 'Source file is not readable. Can\\'t carry on a process.';\n        $this->translation['no_create_support']           = 'No create from %s support.';\n        $this->translation['create_error']                = 'Error in creating %s image from source.';\n        $this->translation['source_invalid']              = 'Can\\'t read image source. Not an image?.';\n        $this->translation['gd_missing']                  = 'GD doesn\\'t seem to be present.';\n        $this->translation['watermark_no_create_support'] = 'No create from %s support, can\\'t read watermark.';\n        $this->translation['watermark_create_error']      = 'No %s read support, can\\'t create watermark.';\n        $this->translation['watermark_invalid']           = 'Unknown image format, can\\'t read watermark.';\n        $this->translation['file_create']                 = 'No %s create support.';\n        $this->translation['no_conversion_type']          = 'No conversion type defined.';\n        $this->translation['copy_failed']                 = 'Error copying file on the server. copy() failed.';\n        $this->translation['reading_failed']              = 'Error reading the file.';\n\n        // determines the language\n        $this->lang               = $lang;\n        if ($this->lang != 'en_GB' && file_exists(dirname(__FILE__).'/lang') && file_exists(dirname(__FILE__).'/lang/class.upload.' . $lang . '.php')) {\n            $translation = null;\n            include(dirname(__FILE__).'/lang/class.upload.' . $lang . '.php');\n            if (is_array($translation)) {\n                $this->translation = array_merge($this->translation, $translation);\n            } else {\n                $this->lang = 'en_GB';\n            }\n        }\n\n\n        // determines the supported MIME types, and matching image format\n        $this->image_supported = array();\n        if ($this->gdversion()) {\n            if (imagetypes() & IMG_GIF) {\n                $this->image_supported['image/gif'] = 'gif';\n            }\n            if (imagetypes() & IMG_JPG) {\n                $this->image_supported['image/jpg'] = 'jpg';\n                $this->image_supported['image/jpeg'] = 'jpg';\n                $this->image_supported['image/pjpeg'] = 'jpg';\n            }\n            if (imagetypes() & IMG_PNG) {\n                $this->image_supported['image/png'] = 'png';\n                $this->image_supported['image/x-png'] = 'png';\n            }\n            if (imagetypes() & IMG_WBMP) {\n                $this->image_supported['image/bmp'] = 'bmp';\n                $this->image_supported['image/x-ms-bmp'] = 'bmp';\n                $this->image_supported['image/x-windows-bmp'] = 'bmp';\n            }\n        }\n\n        // display some system information\n        if (empty($this->log)) {\n            $this->log .= '<b>system information</b><br />';\n            if ($this->function_enabled('ini_get_all')) {\n                $inis = ini_get_all();\n                $open_basedir = (array_key_exists('open_basedir', $inis) && array_key_exists('local_value', $inis['open_basedir']) && !empty($inis['open_basedir']['local_value'])) ? $inis['open_basedir']['local_value'] : false;\n            } else {\n                $open_basedir = false;\n            }\n            $gd           = $this->gdversion() ? $this->gdversion(true) : 'GD not present';\n            $supported    = trim((in_array('png', $this->image_supported) ? 'png' : '') . ' ' . (in_array('jpg', $this->image_supported) ? 'jpg' : '') . ' ' . (in_array('gif', $this->image_supported) ? 'gif' : '') . ' ' . (in_array('bmp', $this->image_supported) ? 'bmp' : ''));\n            $this->log .= '-&nbsp;class version           : ' . $this->version . '<br />';\n            $this->log .= '-&nbsp;operating system        : ' . PHP_OS . '<br />';\n            $this->log .= '-&nbsp;PHP version             : ' . PHP_VERSION . '<br />';\n            $this->log .= '-&nbsp;GD version              : ' . $gd . '<br />';\n            $this->log .= '-&nbsp;supported image types   : ' . (!empty($supported) ? $supported : 'none') . '<br />';\n            $this->log .= '-&nbsp;open_basedir            : ' . (!empty($open_basedir) ? $open_basedir : 'no restriction') . '<br />';\n            $this->log .= '-&nbsp;upload_max_filesize     : ' . $this->file_max_size_raw . ' (' . $this->file_max_size . ' bytes)<br />';\n            $this->log .= '-&nbsp;language                : ' . $this->lang . '<br />';\n        }\n\n        if (!$file) {\n            $this->uploaded = false;\n            $this->error = $this->translate('file_error');\n        }\n\n        // check if we sent a local filename or a PHP stream rather than a $_FILE element\n        if (!is_array($file)) {\n            if (empty($file)) {\n                $this->uploaded = false;\n                $this->error = $this->translate('file_error');\n            } else {\n                if (substr($file, 0, 4) == 'php:' || substr($file, 0, 5) == 'data:' || substr($file, 0, 7) == 'base64:') {\n                    $data = null;\n\n                    // this is a PHP stream, i.e.not uploaded\n                    if (substr($file, 0, 4) == 'php:') {\n                        $file = preg_replace('/^php:(.*)/i', '$1', $file);\n                        if (!$file) $file = $_SERVER['HTTP_X_FILE_NAME'];\n                        if (!$file) $file = 'unknown';\n                        $data = file_get_contents('php://input');\n                        $this->log .= '<b>source is a PHP stream ' . $file . ' of length ' . strlen($data) . '</b><br />';\n\n                    // this is the raw file data, i.e.not uploaded\n                    } else if (substr($file, 0, 5) == 'data:') {\n                        $data = preg_replace('/^data:(.*)/i', '$1', $file);\n                        $file = 'data';\n                        $this->log .= '<b>source is a data string of length ' . strlen($data) . '</b><br />';\n\n                    // this is the raw file data, base64-encoded, i.e.not uploaded\n                    } else if (substr($file, 0, 7) == 'base64:') {\n                        $data = base64_decode(preg_replace('/^base64:(?:.*base64,)?(.*)/i', '$1', $file));\n                        $file = 'base64';\n                        $this->log .= '<b>source is a base64 data string of length ' . strlen($data) . '</b><br />';\n                    }\n\n                    if (!$data) {\n                        $this->log .= '- source is empty!<br />';\n                        $this->uploaded = false;\n                        $this->error = $this->translate('source_invalid');\n                    }\n\n                    $this->no_upload_check = TRUE;\n\n                    if ($this->uploaded) {\n                        $this->log .= '- requires a temp file ... ';\n                        $hash = $this->temp_dir() . md5($file . rand(1, 1000));\n                        if ($data && file_put_contents($hash, $data)) {\n                            $this->file_src_pathname = $hash;\n                            $this->log .= ' file created<br />';\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;temp file is: ' . $this->file_src_pathname . '<br />';\n                        } else {\n                            $this->log .= ' failed<br />';\n                            $this->uploaded = false;\n                            $this->error = $this->translate('temp_file');\n                        }\n                    }\n\n                    if ($this->uploaded) {\n                        $this->file_src_name       = $file;\n                        $this->log .= '- local file OK<br />';\n                        preg_match('/\\.([^\\.]*$)/', $this->file_src_name, $extension);\n                        if (is_array($extension) && sizeof($extension) > 0) {\n                            $this->file_src_name_ext      = strtolower($extension[1]);\n                            $this->file_src_name_body     = substr($this->file_src_name, 0, ((strlen($this->file_src_name) - strlen($this->file_src_name_ext)))-1);\n                        } else {\n                            $this->file_src_name_ext      = '';\n                            $this->file_src_name_body     = $this->file_src_name;\n                        }\n                        $this->file_src_size = (file_exists($this->file_src_pathname) ? filesize($this->file_src_pathname) : 0);\n                    }\n                    $this->file_src_error = 0;\n\n                } else {\n                    // this is a local filename, i.e.not uploaded\n                    $this->log .= '<b>source is a local file ' . $file . '</b><br />';\n                    $this->no_upload_check = TRUE;\n\n                    if ($this->uploaded && !file_exists($file)) {\n                        $this->uploaded = false;\n                        $this->error = $this->translate('local_file_missing');\n                    }\n\n                    if ($this->uploaded && !is_readable($file)) {\n                        $this->uploaded = false;\n                        $this->error = $this->translate('local_file_not_readable');\n                    }\n\n                    if ($this->uploaded) {\n                        $this->file_src_pathname   = $file;\n                        $this->file_src_name       = basename($file);\n                        $this->log .= '- local file OK<br />';\n                        preg_match('/\\.([^\\.]*$)/', $this->file_src_name, $extension);\n                        if (is_array($extension) && sizeof($extension) > 0) {\n                            $this->file_src_name_ext      = strtolower($extension[1]);\n                            $this->file_src_name_body     = substr($this->file_src_name, 0, ((strlen($this->file_src_name) - strlen($this->file_src_name_ext)))-1);\n                        } else {\n                            $this->file_src_name_ext      = '';\n                            $this->file_src_name_body     = $this->file_src_name;\n                        }\n                        $this->file_src_size = (file_exists($this->file_src_pathname) ? filesize($this->file_src_pathname) : 0);\n                    }\n                    $this->file_src_error = 0;\n                }\n            }\n        } else {\n            // this is an element from $_FILE, i.e. an uploaded file\n            $this->log .= '<b>source is an uploaded file</b><br />';\n            if ($this->uploaded) {\n                $this->file_src_error         = trim($file['error']);\n                switch($this->file_src_error) {\n                    case UPLOAD_ERR_OK:\n                        // all is OK\n                        $this->log .= '- upload OK<br />';\n                        break;\n                    case UPLOAD_ERR_INI_SIZE:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_too_big_ini');\n                        break;\n                    case UPLOAD_ERR_FORM_SIZE:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_too_big_html');\n                        break;\n                    case UPLOAD_ERR_PARTIAL:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_partial');\n                        break;\n                    case UPLOAD_ERR_NO_FILE:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_missing');\n                        break;\n                    case @UPLOAD_ERR_NO_TMP_DIR:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_no_tmp_dir');\n                        break;\n                    case @UPLOAD_ERR_CANT_WRITE:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_cant_write');\n                        break;\n                    case @UPLOAD_ERR_EXTENSION:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_err_extension');\n                        break;\n                    default:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_unknown') . ' ('.$this->file_src_error.')';\n                }\n            }\n\n            if ($this->uploaded) {\n                $this->file_src_pathname   = $file['tmp_name'];\n                $this->file_src_name       = $file['name'];\n                if ($this->file_src_name == '') {\n                    $this->uploaded = false;\n                    $this->error = $this->translate('try_again');\n                }\n            }\n\n            if ($this->uploaded) {\n                $this->log .= '- file name OK<br />';\n                preg_match('/\\.([^\\.]*$)/', $this->file_src_name, $extension);\n                if (is_array($extension) && sizeof($extension) > 0) {\n                    $this->file_src_name_ext      = strtolower($extension[1]);\n                    $this->file_src_name_body     = substr($this->file_src_name, 0, ((strlen($this->file_src_name) - strlen($this->file_src_name_ext)))-1);\n                } else {\n                    $this->file_src_name_ext      = '';\n                    $this->file_src_name_body     = $this->file_src_name;\n                }\n                $this->file_src_size = $file['size'];\n                $mime_from_browser = $file['type'];\n            }\n        }\n\n        if ($this->uploaded) {\n            $this->log .= '<b>determining MIME type</b><br />';\n            $this->file_src_mime = null;\n\n            // checks MIME type with Fileinfo PECL extension\n            if (!$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime) || strpos($this->file_src_mime, '/') === FALSE) {\n                if ($this->mime_fileinfo) {\n                    $this->log .= '- Checking MIME type with Fileinfo PECL extension<br />';\n                    if ($this->function_enabled('finfo_open')) {\n                        $path = null;\n                        if ($this->mime_fileinfo !== '') {\n                            if ($this->mime_fileinfo === true) {\n                                if (getenv('MAGIC') === FALSE) {\n                                    if (substr(PHP_OS, 0, 3) == 'WIN') {\n                                        $path = realpath(ini_get('extension_dir') . '/../') . '/extras/magic';\n                                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MAGIC path defaults to ' . $path . '<br />';\n                                    }\n                                } else {\n                                    $path = getenv('MAGIC');\n                                    $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MAGIC path is set to ' . $path . ' from MAGIC variable<br />';\n                                }\n                            } else {\n                                $path = $this->mime_fileinfo;\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MAGIC path is set to ' . $path . '<br />';\n                            }\n                        }\n                        if ($path) {\n                            $f = @finfo_open(FILEINFO_MIME, $path);\n                        } else {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MAGIC path will not be used<br />';\n                            $f = @finfo_open(FILEINFO_MIME);\n                        }\n                        if (is_resource($f)) {\n                            $mime = finfo_file($f, realpath($this->file_src_pathname));\n                            finfo_close($f);\n                            $this->file_src_mime = $mime;\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MIME type detected as ' . $this->file_src_mime . ' by Fileinfo PECL extension<br />';\n                            if (preg_match(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", $this->file_src_mime)) {\n                                $this->file_src_mime = preg_replace(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", '$1/$2', $this->file_src_mime);\n                                $this->log .= '-&nbsp;MIME validated as ' . $this->file_src_mime . '<br />';\n                            } else {\n                                $this->file_src_mime = null;\n                            }\n                        } else {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;Fileinfo PECL extension failed (finfo_open)<br />';\n                        }\n                    } elseif (@class_exists('finfo')) {\n                        $f = new finfo( FILEINFO_MIME );\n                        if ($f) {\n                            $this->file_src_mime = $f->file(realpath($this->file_src_pathname));\n                            $this->log .= '- MIME type detected as ' . $this->file_src_mime . ' by Fileinfo PECL extension<br />';\n                            if (preg_match(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", $this->file_src_mime)) {\n                                $this->file_src_mime = preg_replace(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", '$1/$2', $this->file_src_mime);\n                                $this->log .= '-&nbsp;MIME validated as ' . $this->file_src_mime . '<br />';\n                            } else {\n                                $this->file_src_mime = null;\n                            }\n                        } else {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;Fileinfo PECL extension failed (finfo)<br />';\n                        }\n                    } else {\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;Fileinfo PECL extension not available<br />';\n                    }\n                } else {\n                    $this->log .= '- Fileinfo PECL extension deactivated<br />';\n                }\n            }\n\n            // checks MIME type with shell if unix access is authorized\n            if (!$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime) || strpos($this->file_src_mime, '/') === FALSE) {\n                if ($this->mime_file) {\n                    $this->log .= '- Checking MIME type with UNIX file() command<br />';\n                    if (substr(PHP_OS, 0, 3) != 'WIN') {\n                        if ($this->function_enabled('exec') && $this->function_enabled('escapeshellarg')) {\n                            if (strlen($mime = @exec(\"file -bi \".escapeshellarg($this->file_src_pathname))) != 0) {\n                                $this->file_src_mime = trim($mime);\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MIME type detected as ' . $this->file_src_mime . ' by UNIX file() command<br />';\n                                if (preg_match(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", $this->file_src_mime)) {\n                                    $this->file_src_mime = preg_replace(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", '$1/$2', $this->file_src_mime);\n                                    $this->log .= '-&nbsp;MIME validated as ' . $this->file_src_mime . '<br />';\n                                } else {\n                                    $this->file_src_mime = null;\n                                }\n                            } else {\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;UNIX file() command failed<br />';\n                            }\n                        } else {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;PHP exec() function is disabled<br />';\n                        }\n                    } else {\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;UNIX file() command not availabled<br />';\n                    }\n                } else {\n                    $this->log .= '- UNIX file() command is deactivated<br />';\n                }\n            }\n\n            // checks MIME type with mime_magic\n            if (!$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime) || strpos($this->file_src_mime, '/') === FALSE) {\n                if ($this->mime_magic) {\n                    $this->log .= '- Checking MIME type with mime.magic file (mime_content_type())<br />';\n                    if ($this->function_enabled('mime_content_type')) {\n                        $this->file_src_mime = mime_content_type($this->file_src_pathname);\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MIME type detected as ' . $this->file_src_mime . ' by mime_content_type()<br />';\n                        if (preg_match(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", $this->file_src_mime)) {\n                            $this->file_src_mime = preg_replace(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", '$1/$2', $this->file_src_mime);\n                            $this->log .= '-&nbsp;MIME validated as ' . $this->file_src_mime . '<br />';\n                        } else {\n                            $this->file_src_mime = null;\n                        }\n                    } else {\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;mime_content_type() is not available<br />';\n                    }\n                } else {\n                    $this->log .= '- mime.magic file (mime_content_type()) is deactivated<br />';\n                }\n            }\n\n            // checks MIME type with getimagesize()\n            if (!$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime) || strpos($this->file_src_mime, '/') === FALSE) {\n                if ($this->mime_getimagesize) {\n                    $this->log .= '- Checking MIME type with getimagesize()<br />';\n                    $info = getimagesize($this->file_src_pathname);\n                    if (is_array($info) && array_key_exists('mime', $info)) {\n                        $this->file_src_mime = trim($info['mime']);\n                        if (empty($this->file_src_mime)) {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MIME empty, guessing from type<br />';\n                            $mime = (is_array($info) && array_key_exists(2, $info) ? $info[2] : null); // 1 = GIF, 2 = JPG, 3 = PNG\n                            $this->file_src_mime = ($mime==IMAGETYPE_GIF ? 'image/gif' : ($mime==IMAGETYPE_JPEG ? 'image/jpeg' : ($mime==IMAGETYPE_PNG ? 'image/png' : ($mime==IMAGETYPE_BMP ? 'image/bmp' : null))));\n                        }\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MIME type detected as ' . $this->file_src_mime . ' by PHP getimagesize() function<br />';\n                        if (preg_match(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", $this->file_src_mime)) {\n                            $this->file_src_mime = preg_replace(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", '$1/$2', $this->file_src_mime);\n                            $this->log .= '-&nbsp;MIME validated as ' . $this->file_src_mime . '<br />';\n                        } else {\n                            $this->file_src_mime = null;\n                        }\n                    } else {\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;getimagesize() failed<br />';\n                    }\n                } else {\n                    $this->log .= '- getimagesize() is deactivated<br />';\n                }\n            }\n\n            // default to MIME from browser (or Flash)\n            if (!empty($mime_from_browser) && !$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime)) {\n                $this->file_src_mime =$mime_from_browser;\n                $this->log .= '- MIME type detected as ' . $this->file_src_mime . ' by browser<br />';\n                if (preg_match(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", $this->file_src_mime)) {\n                    $this->file_src_mime = preg_replace(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", '$1/$2', $this->file_src_mime);\n                    $this->log .= '-&nbsp;MIME validated as ' . $this->file_src_mime . '<br />';\n                } else {\n                    $this->file_src_mime = null;\n                }\n            }\n\n            // we need to work some magic if we upload via Flash\n            if ($this->file_src_mime == 'application/octet-stream' || !$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime) || strpos($this->file_src_mime, '/') === FALSE) {\n                if ($this->file_src_mime == 'application/octet-stream') $this->log .= '- Flash may be rewriting MIME as application/octet-stream<br />';\n                $this->log .= '- Try to guess MIME type from file extension (' . $this->file_src_name_ext . '): ';\n                if (array_key_exists($this->file_src_name_ext, $this->mime_types)) $this->file_src_mime = $this->mime_types[$this->file_src_name_ext];\n                if ($this->file_src_mime == 'application/octet-stream') {\n                    $this->log .= 'doesn\\'t look like anything known<br />';\n                } else {\n                    $this->log .= 'MIME type set to ' . $this->file_src_mime . '<br />';\n                }\n            }\n\n            if (!$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime) || strpos($this->file_src_mime, '/') === FALSE) {\n                $this->log .= '- MIME type couldn\\'t be detected! (' . (string) $this->file_src_mime . ')<br />';\n            }\n\n            // determine whether the file is an image\n            if ($this->file_src_mime && is_string($this->file_src_mime) && !empty($this->file_src_mime) && array_key_exists($this->file_src_mime, $this->image_supported)) {\n                $this->file_is_image = true;\n                $this->image_src_type = $this->image_supported[$this->file_src_mime];\n            }\n\n            // if the file is an image, we gather some useful data\n            if ($this->file_is_image) {\n                if ($h = fopen($this->file_src_pathname, 'r')) {\n                    fclose($h);\n                    $info = getimagesize($this->file_src_pathname);\n                    if (is_array($info)) {\n                        $this->image_src_x    = $info[0];\n                        $this->image_src_y    = $info[1];\n                        $this->image_dst_x    = $this->image_src_x;\n                        $this->image_dst_y    = $this->image_src_y;\n                        $this->image_src_pixels = $this->image_src_x * $this->image_src_y;\n                        $this->image_src_bits = array_key_exists('bits', $info) ? $info['bits'] : null;\n                    } else {\n                        $this->file_is_image = false;\n                        $this->uploaded = false;\n                        $this->log .= '- can\\'t retrieve image information, image may have been tampered with<br />';\n                        $this->error = $this->translate('source_invalid');\n                    }\n                } else {\n                    $this->log .= '- can\\'t read source file directly. open_basedir restriction in place?<br />';\n                }\n            }\n\n            $this->log .= '<b>source variables</b><br />';\n            $this->log .= '- You can use all these before calling process()<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_name         : ' . $this->file_src_name . '<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_name_body    : ' . $this->file_src_name_body . '<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_name_ext     : ' . $this->file_src_name_ext . '<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_pathname     : ' . $this->file_src_pathname . '<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_mime         : ' . $this->file_src_mime . '<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_size         : ' . $this->file_src_size . ' (max= ' . $this->file_max_size . ')<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_error        : ' . $this->file_src_error . '<br />';\n\n            if ($this->file_is_image) {\n                $this->log .= '- source file is an image<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_src_x           : ' . $this->image_src_x . '<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_src_y           : ' . $this->image_src_y . '<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_src_pixels      : ' . $this->image_src_pixels . '<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_src_type        : ' . $this->image_src_type . '<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_src_bits        : ' . $this->image_src_bits . '<br />';\n            }\n        }\n\n    }\n\n    /**\n     * Returns the version of GD\n     *\n     * @access public\n     * @param  boolean  $full Optional flag to get precise version\n     * @return float GD version\n     */\n    function gdversion($full = false) {\n        static $gd_version = null;\n        static $gd_full_version = null;\n        if ($gd_version === null) {\n            if ($this->function_enabled('gd_info')) {\n                $gd = gd_info();\n                $gd = $gd[\"GD Version\"];\n                $regex = \"/([\\d\\.]+)/i\";\n            } else {\n                ob_start();\n                phpinfo(8);\n                $gd = ob_get_contents();\n                ob_end_clean();\n                $regex = \"/\\bgd\\s+version\\b[^\\d\\n\\r]+?([\\d\\.]+)/i\";\n            }\n            if (preg_match($regex, $gd, $m)) {\n                $gd_full_version = (string) $m[1];\n                $gd_version = (float) $m[1];\n            } else {\n                $gd_full_version = 'none';\n                $gd_version = 0;\n            }\n        }\n        if ($full) {\n            return $gd_full_version;\n        } else {\n            return $gd_version;\n        }\n    }\n\n    /**\n     * Checks if a function is available\n     *\n     * @access private\n     * @param  string  $func Function name\n     * @return boolean Success\n     */\n    function function_enabled($func) {\n        // cache the list of disabled functions\n        static $disabled = null;\n        if ($disabled === null) $disabled = array_map('trim', array_map('strtolower', explode(',', ini_get('disable_functions'))));\n        // cache the list of functions blacklisted by suhosin\n        static $blacklist = null;\n        if ($blacklist === null) $blacklist = extension_loaded('suhosin') ? array_map('trim', array_map('strtolower', explode(',', ini_get('  suhosin.executor.func.blacklist')))) : array();\n        // checks if the function is really enabled\n        return (function_exists($func) && !in_array($func, $disabled) && !in_array($func, $blacklist));\n    }\n\n    /**\n     * Creates directories recursively\n     *\n     * @access private\n     * @param  string  $path Path to create\n     * @param  integer $mode Optional permissions\n     * @return boolean Success\n     */\n    function rmkdir($path, $mode = 0755) {\n        return is_dir($path) || ( $this->rmkdir(dirname($path), $mode) && $this->_mkdir($path, $mode) );\n    }\n\n    /**\n     * Creates directory\n     *\n     * @access private\n     * @param  string  $path Path to create\n     * @param  integer $mode Optional permissions\n     * @return boolean Success\n     */\n    function _mkdir($path, $mode = 0755) {\n        $old = umask(0);\n        $res = @mkdir($path, $mode);\n        umask($old);\n        return $res;\n    }\n\n    /**\n     * Translate error messages\n     *\n     * @access private\n     * @param  string  $str    Message to translate\n     * @param  array   $tokens Optional token values\n     * @return string Translated string\n     */\n    function translate($str, $tokens = array()) {\n        if (array_key_exists($str, $this->translation)) $str = $this->translation[$str];\n        if (is_array($tokens) && sizeof($tokens) > 0)   $str = vsprintf($str, $tokens);\n        return $str;\n    }\n\n    /**\n     * Returns the temp directory\n     *\n     * @access private\n     * @return string Temp directory string\n     */\n    function temp_dir() {\n        $dir = '';\n        if ($this->function_enabled('sys_get_temp_dir')) $dir = sys_get_temp_dir();\n        if (!$dir && $tmp=getenv('TMP'))    $dir = $tmp;\n        if (!$dir && $tmp=getenv('TEMP'))   $dir = $tmp;\n        if (!$dir && $tmp=getenv('TMPDIR')) $dir = $tmp;\n        if (!$dir) {\n            $tmp = tempnam(__FILE__,'');\n            if (file_exists($tmp)) {\n                unlink($tmp);\n                $dir = dirname($tmp);\n            }\n        }\n        if (!$dir) return '';\n        $slash = (strtolower(substr(PHP_OS, 0, 3)) === 'win' ? '\\\\' : '/');\n        if (substr($dir, -1) != $slash) $dir = $dir . $slash;\n        return $dir;\n    }\n\n    /**\n     * Decodes colors\n     *\n     * @access private\n     * @param  string  $color  Color string\n     * @return array RGB colors\n     */\n    function getcolors($color) {\n        $color = str_replace('#', '', $color);\n        if (strlen($color) == 3) $color = str_repeat(substr($color, 0, 1), 2) . str_repeat(substr($color, 1, 1), 2) . str_repeat(substr($color, 2, 1), 2);\n        $r = sscanf($color, \"%2x%2x%2x\");\n        $red   = (is_array($r) && array_key_exists(0, $r) && is_numeric($r[0]) ? $r[0] : 0);\n        $green = (is_array($r) && array_key_exists(1, $r) && is_numeric($r[1]) ? $r[1] : 0);\n        $blue  = (is_array($r) && array_key_exists(2, $r) && is_numeric($r[2]) ? $r[2] : 0);\n        return array($red, $green, $blue);\n    }\n\n    /**\n     * Decodes sizes\n     *\n     * @access private\n     * @param  string  $size  Size in bytes, or shorthand byte options\n     * @return integer Size in bytes\n     */\n    function getsize($size) {\n        if ($size === null) return null;\n        $last = strtolower($size{strlen($size)-1});\n        $size = (int) $size;\n        switch($last) {\n            case 'g':\n                $size *= 1024;\n            case 'm':\n                $size *= 1024;\n            case 'k':\n                $size *= 1024;\n        }\n        return $size;\n    }\n\n    /**\n     * Decodes offsets\n     *\n     * @access private\n     * @param  misc    $offsets  Offsets, as an integer, a string or an array\n     * @param  integer $x        Reference picture width\n     * @param  integer $y        Reference picture height\n     * @param  boolean $round    Round offsets before returning them\n     * @param  boolean $negative Allow negative offsets to be returned\n     * @return array Array of four offsets (TRBL)\n     */\n    function getoffsets($offsets, $x, $y, $round = true, $negative = true) {\n        if (!is_array($offsets)) $offsets = explode(' ', $offsets);\n        if (sizeof($offsets) == 4) {\n             $ct = $offsets[0]; $cr = $offsets[1]; $cb = $offsets[2]; $cl = $offsets[3];\n        } else if (sizeof($offsets) == 2) {\n            $ct = $offsets[0]; $cr = $offsets[1]; $cb = $offsets[0]; $cl = $offsets[1];\n        } else {\n            $ct = $offsets[0]; $cr = $offsets[0]; $cb = $offsets[0]; $cl = $offsets[0];\n        }\n        if (strpos($ct, '%')>0) $ct = $y * (str_replace('%','',$ct) / 100);\n        if (strpos($cr, '%')>0) $cr = $x * (str_replace('%','',$cr) / 100);\n        if (strpos($cb, '%')>0) $cb = $y * (str_replace('%','',$cb) / 100);\n        if (strpos($cl, '%')>0) $cl = $x * (str_replace('%','',$cl) / 100);\n        if (strpos($ct, 'px')>0) $ct = str_replace('px','',$ct);\n        if (strpos($cr, 'px')>0) $cr = str_replace('px','',$cr);\n        if (strpos($cb, 'px')>0) $cb = str_replace('px','',$cb);\n        if (strpos($cl, 'px')>0) $cl = str_replace('px','',$cl);\n        $ct = (int) $ct; $cr = (int) $cr; $cb = (int) $cb; $cl = (int) $cl;\n        if ($round) {\n            $ct = round($ct);\n            $cr = round($cr);\n            $cb = round($cb);\n            $cl = round($cl);\n        }\n        if (!$negative) {\n            if ($ct < 0) $ct = 0;\n            if ($cr < 0) $cr = 0;\n            if ($cb < 0) $cb = 0;\n            if ($cl < 0) $cl = 0;\n        }\n        return array($ct, $cr, $cb, $cl);\n    }\n\n    /**\n     * Creates a container image\n     *\n     * @access private\n     * @param  integer  $x    Width\n     * @param  integer  $y    Height\n     * @param  boolean  $fill Optional flag to draw the background color or not\n     * @param  boolean  $trsp Optional flag to set the background to be transparent\n     * @return resource Container image\n     */\n    function imagecreatenew($x, $y, $fill = true, $trsp = false) {\n        if ($x < 1) $x = 1; if ($y < 1) $y = 1;\n        if ($this->gdversion() >= 2 && !$this->image_is_palette) {\n            // create a true color image\n            $dst_im = imagecreatetruecolor($x, $y);\n            // this preserves transparency in PNGs, in true color\n            if (empty($this->image_background_color) || $trsp) {\n                imagealphablending($dst_im, false );\n                imagefilledrectangle($dst_im, 0, 0, $x, $y, imagecolorallocatealpha($dst_im, 0, 0, 0, 127));\n            }\n        } else {\n            // creates a palette image\n            $dst_im = imagecreate($x, $y);\n            // preserves transparency for palette images, if the original image has transparency\n            if (($fill && $this->image_is_transparent && empty($this->image_background_color)) || $trsp) {\n                imagefilledrectangle($dst_im, 0, 0, $x, $y, $this->image_transparent_color);\n                imagecolortransparent($dst_im, $this->image_transparent_color);\n            }\n        }\n        // fills with background color if any is set\n        if ($fill && !empty($this->image_background_color) && !$trsp) {\n            list($red, $green, $blue) = $this->getcolors($this->image_background_color);\n            $background_color = imagecolorallocate($dst_im, $red, $green, $blue);\n            imagefilledrectangle($dst_im, 0, 0, $x, $y, $background_color);\n        }\n        return $dst_im;\n    }\n\n\n    /**\n     * Transfers an image from the container to the destination image\n     *\n     * @access private\n     * @param  resource $src_im Container image\n     * @param  resource $dst_im Destination image\n     * @return resource Destination image\n     */\n    function imagetransfer($src_im, $dst_im) {\n        if (is_resource($dst_im)) imagedestroy($dst_im);\n        $dst_im = & $src_im;\n        return $dst_im;\n    }\n\n    /**\n     * Merges two images\n     *\n     * If the output format is PNG, then we do it pixel per pixel to retain the alpha channel\n     *\n     * @access private\n     * @param  resource $dst_img Destination image\n     * @param  resource $src_img Overlay image\n     * @param  int      $dst_x   x-coordinate of destination point\n     * @param  int      $dst_y   y-coordinate of destination point\n     * @param  int      $src_x   x-coordinate of source point\n     * @param  int      $src_y   y-coordinate of source point\n     * @param  int      $src_w   Source width\n     * @param  int      $src_h   Source height\n     * @param  int      $pct     Optional percentage of the overlay, between 0 and 100 (default: 100)\n     * @return resource Destination image\n     */\n    function imagecopymergealpha(&$dst_im, &$src_im, $dst_x, $dst_y, $src_x, $src_y, $src_w, $src_h, $pct = 0) {\n        $dst_x = (int) $dst_x;\n        $dst_y = (int) $dst_y;\n        $src_x = (int) $src_x;\n        $src_y = (int) $src_y;\n        $src_w = (int) $src_w;\n        $src_h = (int) $src_h;\n        $pct   = (int) $pct;\n        $dst_w = imagesx($dst_im);\n        $dst_h = imagesy($dst_im);\n\n        for ($y = $src_y; $y < $src_h; $y++) {\n            for ($x = $src_x; $x < $src_w; $x++) {\n\n                if ($x + $dst_x >= 0 && $x + $dst_x < $dst_w && $x + $src_x >= 0 && $x + $src_x < $src_w\n                 && $y + $dst_y >= 0 && $y + $dst_y < $dst_h && $y + $src_y >= 0 && $y + $src_y < $src_h) {\n\n                    $dst_pixel = imagecolorsforindex($dst_im, imagecolorat($dst_im, $x + $dst_x, $y + $dst_y));\n                    $src_pixel = imagecolorsforindex($src_im, imagecolorat($src_im, $x + $src_x, $y + $src_y));\n\n                    $src_alpha = 1 - ($src_pixel['alpha'] / 127);\n                    $dst_alpha = 1 - ($dst_pixel['alpha'] / 127);\n                    $opacity = $src_alpha * $pct / 100;\n                    if ($dst_alpha >= $opacity) $alpha = $dst_alpha;\n                    if ($dst_alpha < $opacity)  $alpha = $opacity;\n                    if ($alpha > 1) $alpha = 1;\n\n                    if ($opacity > 0) {\n                        $dst_red   = round(( ($dst_pixel['red']   * $dst_alpha * (1 - $opacity)) ) );\n                        $dst_green = round(( ($dst_pixel['green'] * $dst_alpha * (1 - $opacity)) ) );\n                        $dst_blue  = round(( ($dst_pixel['blue']  * $dst_alpha * (1 - $opacity)) ) );\n                        $src_red   = round((($src_pixel['red']   * $opacity)) );\n                        $src_green = round((($src_pixel['green'] * $opacity)) );\n                        $src_blue  = round((($src_pixel['blue']  * $opacity)) );\n                        $red   = round(($dst_red   + $src_red  ) / ($dst_alpha * (1 - $opacity) + $opacity));\n                        $green = round(($dst_green + $src_green) / ($dst_alpha * (1 - $opacity) + $opacity));\n                        $blue  = round(($dst_blue  + $src_blue ) / ($dst_alpha * (1 - $opacity) + $opacity));\n                        if ($red   > 255) $red   = 255;\n                        if ($green > 255) $green = 255;\n                        if ($blue  > 255) $blue  = 255;\n                        $alpha =  round((1 - $alpha) * 127);\n                        $color = imagecolorallocatealpha($dst_im, $red, $green, $blue, $alpha);\n                        imagesetpixel($dst_im, $x + $dst_x, $y + $dst_y, $color);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n\n\n    /**\n     * Actually uploads the file, and act on it according to the set processing class variables\n     *\n     * This function copies the uploaded file to the given location, eventually performing actions on it.\n     * Typically, you can call {@link process} several times for the same file,\n     * for instance to create a resized image and a thumbnail of the same file.\n     * The original uploaded file remains intact in its temporary location, so you can use {@link process} several times.\n     * You will be able to delete the uploaded file with {@link clean} when you have finished all your {@link process} calls.\n     *\n     * According to the processing class variables set in the calling file, the file can be renamed,\n     * and if it is an image, can be resized or converted.\n     *\n     * When the processing is completed, and the file copied to its new location, the\n     * processing class variables will be reset to their default value.\n     * This allows you to set new properties, and perform another {@link process} on the same uploaded file\n     *\n     * If the function is called with a null or empty argument, then it will return the content of the picture\n     *\n     * It will set {@link processed} (and {@link error} is an error occurred)\n     *\n     * @access public\n     * @param  string $server_path Optional path location of the uploaded file, with an ending slash\n     * @return string Optional content of the image\n     */\n    function process($server_path = null) {\n        $this->error        = '';\n        $this->processed    = true;\n        $return_mode        = false;\n        $return_content     = null;\n\n        // clean up dst variables\n        $this->file_dst_path        = '';\n        $this->file_dst_pathname    = '';\n        $this->file_dst_name        = '';\n        $this->file_dst_name_body   = '';\n        $this->file_dst_name_ext    = '';\n\n        // clean up some parameters\n        $this->file_max_size = $this->getsize($this->file_max_size);\n        $this->jpeg_size = $this->getsize($this->jpeg_size);\n\n        // copy some variables as we need to keep them clean\n        $file_src_name = $this->file_src_name;\n        $file_src_name_body = $this->file_src_name_body;\n        $file_src_name_ext = $this->file_src_name_ext;\n\n        if (!$this->uploaded) {\n            $this->error = $this->translate('file_not_uploaded');\n            $this->processed = false;\n        }\n\n        if ($this->processed) {\n            if (empty($server_path) || is_null($server_path)) {\n                $this->log .= '<b>process file and return the content</b><br />';\n                $return_mode = true;\n            } else {\n                if(strtolower(substr(PHP_OS, 0, 3)) === 'win') {\n                    if (substr($server_path, -1, 1) != '\\\\') $server_path = $server_path . '\\\\';\n                } else {\n                    if (substr($server_path, -1, 1) != '/') $server_path = $server_path . '/';\n                }\n                $this->log .= '<b>process file to '  . $server_path . '</b><br />';\n            }\n        }\n\n        if ($this->processed) {\n            // checks file max size\n            if ($this->file_src_size > $this->file_max_size) {\n                $this->processed = false;\n                $this->error = $this->translate('file_too_big') . ' : ' . $this->file_src_size . ' > ' . $this->file_max_size;\n            } else {\n                $this->log .= '- file size OK<br />';\n            }\n        }\n\n        if ($this->processed) {\n            // if we have an image without extension, set it\n            if ($this->file_force_extension && $this->file_is_image && !$this->file_src_name_ext) $file_src_name_ext = $this->image_src_type;\n            // turn dangerous scripts into text files\n            if ($this->no_script) {\n                // if the file has no extension, we try to guess it from the MIME type\n                if ($this->file_force_extension && empty($file_src_name_ext)) {\n                    if ($key = array_search($this->file_src_mime, $this->mime_types)) {\n                        $file_src_name_ext = $key;\n                        $file_src_name = $file_src_name_body . '.' . $file_src_name_ext;\n                        $this->log .= '- file renamed as ' . $file_src_name_body . '.' . $file_src_name_ext . '!<br />';\n                    }\n                }\n                // if the file is text based, or has a dangerous extension, we rename it as .txt\n                if ((((substr($this->file_src_mime, 0, 5) == 'text/' && $this->file_src_mime != 'text/rtf') || strpos($this->file_src_mime, 'javascript') !== false)  && (substr($file_src_name, -4) != '.txt'))\n                    || preg_match('/\\.(php|php5|php4|php3|phtml|pl|py|cgi|asp|js)$/i', $this->file_src_name)\n                    || $this->file_force_extension && empty($file_src_name_ext)) {\n                    $this->file_src_mime = 'text/plain';\n                    if ($this->file_src_name_ext) $file_src_name_body = $file_src_name_body . '.' . $this->file_src_name_ext;\n                    $file_src_name_ext = 'txt';\n                    $file_src_name = $file_src_name_body . '.' . $file_src_name_ext;\n                    $this->log .= '- script renamed as ' . $file_src_name_body . '.' . $file_src_name_ext . '!<br />';\n                }\n            }\n\n            if ($this->mime_check && empty($this->file_src_mime)) {\n                $this->processed = false;\n                $this->error = $this->translate('no_mime');\n            } else if ($this->mime_check && !empty($this->file_src_mime) && strpos($this->file_src_mime, '/') !== false) {\n                list($m1, $m2) = explode('/', $this->file_src_mime);\n                $allowed = false;\n                // check wether the mime type is allowed\n                if (!is_array($this->allowed)) $this->allowed = array($this->allowed);\n                foreach($this->allowed as $k => $v) {\n                    list($v1, $v2) = explode('/', $v);\n                    if (($v1 == '*' && $v2 == '*') || ($v1 == $m1 && ($v2 == $m2 || $v2 == '*'))) {\n                        $allowed = true;\n                        break;\n                    }\n                }\n                // check wether the mime type is forbidden\n                if (!is_array($this->forbidden)) $this->forbidden = array($this->forbidden);\n                foreach($this->forbidden as $k => $v) {\n                    list($v1, $v2) = explode('/', $v);\n                    if (($v1 == '*' && $v2 == '*') || ($v1 == $m1 && ($v2 == $m2 || $v2 == '*'))) {\n                        $allowed = false;\n                        break;\n                    }\n                }\n                if (!$allowed) {\n                    $this->processed = false;\n                    $this->error = $this->translate('incorrect_file');\n                } else {\n                    $this->log .= '- file mime OK : ' . $this->file_src_mime . '<br />';\n                }\n            } else {\n                $this->log .= '- file mime (not checked) : ' . $this->file_src_mime . '<br />';\n            }\n\n            // if the file is an image, we can check on its dimensions\n            // these checks are not available if open_basedir restrictions are in place\n            if ($this->file_is_image) {\n                if (is_numeric($this->image_src_x) && is_numeric($this->image_src_y)) {\n                    $ratio = $this->image_src_x / $this->image_src_y;\n                    if (!is_null($this->image_max_width) && $this->image_src_x > $this->image_max_width) {\n                        $this->processed = false;\n                        $this->error = $this->translate('image_too_wide');\n                    }\n                    if (!is_null($this->image_min_width) && $this->image_src_x < $this->image_min_width) {\n                        $this->processed = false;\n                        $this->error = $this->translate('image_too_narrow');\n                    }\n                    if (!is_null($this->image_max_height) && $this->image_src_y > $this->image_max_height) {\n                        $this->processed = false;\n                        $this->error = $this->translate('image_too_high');\n                    }\n                    if (!is_null($this->image_min_height) && $this->image_src_y < $this->image_min_height) {\n                        $this->processed = false;\n                        $this->error = $this->translate('image_too_short');\n                    }\n                    if (!is_null($this->image_max_ratio) && $ratio > $this->image_max_ratio) {\n                        $this->processed = false;\n                        $this->error = $this->translate('ratio_too_high');\n                    }\n                    if (!is_null($this->image_min_ratio) && $ratio < $this->image_min_ratio) {\n                        $this->processed = false;\n                        $this->error = $this->translate('ratio_too_low');\n                    }\n                    if (!is_null($this->image_max_pixels) && $this->image_src_pixels > $this->image_max_pixels) {\n                        $this->processed = false;\n                        $this->error = $this->translate('too_many_pixels');\n                    }\n                    if (!is_null($this->image_min_pixels) && $this->image_src_pixels < $this->image_min_pixels) {\n                        $this->processed = false;\n                        $this->error = $this->translate('not_enough_pixels');\n                    }\n                } else {\n                    $this->log .= '- no image properties available, can\\'t enforce dimension checks : ' . $this->file_src_mime . '<br />';\n                }\n            }\n        }\n\n        if ($this->processed) {\n            $this->file_dst_path        = $server_path;\n\n            // repopulate dst variables from src\n            $this->file_dst_name        = $file_src_name;\n            $this->file_dst_name_body   = $file_src_name_body;\n            $this->file_dst_name_ext    = $file_src_name_ext;\n            if ($this->file_overwrite) $this->file_auto_rename = false;\n\n            if ($this->image_convert && $this->file_is_image) { // if we convert as an image\n                if ($this->file_src_name_ext) $this->file_dst_name_ext  = $this->image_convert;\n                $this->log .= '- new file name ext : ' . $this->image_convert . '<br />';\n            }\n            if (!is_null($this->file_new_name_body)) { // rename file body\n                $this->file_dst_name_body = $this->file_new_name_body;\n                $this->log .= '- new file name body : ' . $this->file_new_name_body . '<br />';\n            }\n            if (!is_null($this->file_new_name_ext)) { // rename file ext\n                $this->file_dst_name_ext  = $this->file_new_name_ext;\n                $this->log .= '- new file name ext : ' . $this->file_new_name_ext . '<br />';\n            }\n            if (!is_null($this->file_name_body_add)) { // append a string to the name\n                $this->file_dst_name_body  = $this->file_dst_name_body . $this->file_name_body_add;\n                $this->log .= '- file name body append : ' . $this->file_name_body_add . '<br />';\n            }\n            if (!is_null($this->file_name_body_pre)) { // prepend a string to the name\n                $this->file_dst_name_body  = $this->file_name_body_pre . $this->file_dst_name_body;\n                $this->log .= '- file name body prepend : ' . $this->file_name_body_pre . '<br />';\n            }\n            if ($this->file_safe_name) { // formats the name\n\t            $this->file_dst_name_body = trim(preg_replace(array('/[^\\p{L}\\p{N}\\p{P}\\p{M}\\-_]/u', '/\\.[\\.]+/', \"/(\\\"|\\'|\\\u201c|\\\u201d)+/\"), array('_', '.', '_'), $this->file_dst_name_body)); // Much better!\n\t            //$this->file_dst_name_body = utf8_encode(strtr(utf8_decode($this->file_dst_name_body), utf8_decode('\u0160\u017d\u0161\u017e\u0178\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff'), 'SZszYAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy'));\n\t            //$this->file_dst_name_body = strtr($this->file_dst_name_body, array('\u00de' => 'TH', '\u00fe' => 'th', '\u00d0' => 'DH', '\u00f0' => 'dh', '\u00df' => 'ss', '\u0152' => 'OE', '\u0153' => 'oe', '\u00c6' => 'AE', '\u00e6' => 'ae', '\u00b5' => 'u'));\n\t            //$this->file_dst_name_body = preg_replace(array('/\\s/', '/\\.[\\.]+/', '/[^\\w_\\.\\-]/'), array('_', '.', ''), $this->file_dst_name_body);\n                $this->log .= '- file name safe format<br />';\n            }\n\n            $this->log .= '- destination variables<br />';\n            if (empty($this->file_dst_path) || is_null($this->file_dst_path)) {\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_dst_path         : n/a<br />';\n            } else {\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_dst_path         : ' . $this->file_dst_path . '<br />';\n            }\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_dst_name_body    : ' . $this->file_dst_name_body . '<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_dst_name_ext     : ' . $this->file_dst_name_ext . '<br />';\n\n            // set the destination file name\n            $this->file_dst_name = $this->file_dst_name_body . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : '');\n\n            if (!$return_mode) {\n                if (!$this->file_auto_rename) {\n                    $this->log .= '- no auto_rename if same filename exists<br />';\n                    $this->file_dst_pathname = $this->file_dst_path . $this->file_dst_name;\n                } else {\n                    $this->log .= '- checking for auto_rename<br />';\n                    $this->file_dst_pathname = $this->file_dst_path . $this->file_dst_name;\n                    $body = $this->file_dst_name_body;\n                    $ext = '';\n                    // if we have changed the extension, then we add our increment before\n                    if ($file_src_name_ext != $this->file_src_name_ext) {\n                        if (substr($this->file_dst_name_body, -1 - strlen($this->file_src_name_ext)) == '.' . $this->file_src_name_ext) {\n                            $body = substr($this->file_dst_name_body, 0, strlen($this->file_dst_name_body) - 1 - strlen($this->file_src_name_ext));\n                            $ext = '.' . $this->file_src_name_ext;\n                        }\n                    }\n                    $cpt = 1;\n                    while (@file_exists($this->file_dst_pathname)) {\n                        $this->file_dst_name_body = $body . '_' . $cpt . $ext;\n                        $this->file_dst_name = $this->file_dst_name_body . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : '');\n                        $cpt++;\n                        $this->file_dst_pathname = $this->file_dst_path . $this->file_dst_name;\n                    }\n                    if ($cpt>1) $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;auto_rename to ' . $this->file_dst_name . '<br />';\n                }\n\n                $this->log .= '- destination file details<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_dst_name         : ' . $this->file_dst_name . '<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_dst_pathname     : ' . $this->file_dst_pathname . '<br />';\n\n                if ($this->file_overwrite) {\n                     $this->log .= '- no overwrite checking<br />';\n                } else {\n                    if (@file_exists($this->file_dst_pathname)) {\n                        $this->processed = false;\n                        $this->error = $this->translate('already_exists', array($this->file_dst_name));\n                    } else {\n                        $this->log .= '- ' . $this->file_dst_name . ' doesn\\'t exist already<br />';\n                    }\n                }\n            }\n        }\n\n        if ($this->processed) {\n            // if we have already moved the uploaded file, we use the temporary copy as source file, and check if it exists\n            if (!empty($this->file_src_temp)) {\n                $this->log .= '- use the temp file instead of the original file since it is a second process<br />';\n                $this->file_src_pathname   = $this->file_src_temp;\n                if (!file_exists($this->file_src_pathname)) {\n                    $this->processed = false;\n                    $this->error = $this->translate('temp_file_missing');\n                }\n            // if we haven't a temp file, and that we do check on uploads, we use is_uploaded_file()\n            } else if (!$this->no_upload_check) {\n                if (!is_uploaded_file($this->file_src_pathname)) {\n                    $this->processed = false;\n                    $this->error = $this->translate('source_missing');\n                }\n            // otherwise, if we don't check on uploaded files (local file for instance), we use file_exists()\n            } else {\n                if (!file_exists($this->file_src_pathname)) {\n                    $this->processed = false;\n                    $this->error = $this->translate('source_missing');\n                }\n            }\n\n            // checks if the destination directory exists, and attempt to create it\n            if (!$return_mode) {\n                if ($this->processed && !file_exists($this->file_dst_path)) {\n                    if ($this->dir_auto_create) {\n                        $this->log .= '- ' . $this->file_dst_path . ' doesn\\'t exist. Attempting creation:';\n                        if (!$this->rmkdir($this->file_dst_path, $this->dir_chmod)) {\n                            $this->log .= ' failed<br />';\n                            $this->processed = false;\n                            $this->error = $this->translate('destination_dir');\n                        } else {\n                            $this->log .= ' success<br />';\n                        }\n                    } else {\n                        $this->error = $this->translate('destination_dir_missing');\n                    }\n                }\n\n                if ($this->processed && !is_dir($this->file_dst_path)) {\n                    $this->processed = false;\n                    $this->error = $this->translate('destination_path_not_dir');\n                }\n\n                // checks if the destination directory is writeable, and attempt to make it writeable\n                $hash = md5($this->file_dst_name_body . rand(1, 1000));\n                if ($this->processed && !($f = @fopen($this->file_dst_path . $hash . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : ''), 'a+'))) {\n                    if ($this->dir_auto_chmod) {\n                        $this->log .= '- ' . $this->file_dst_path . ' is not writeable. Attempting chmod:';\n                        if (!@chmod($this->file_dst_path, $this->dir_chmod)) {\n                            $this->log .= ' failed<br />';\n                            $this->processed = false;\n                            $this->error = $this->translate('destination_dir_write');\n                        } else {\n                            $this->log .= ' success<br />';\n                            if (!($f = @fopen($this->file_dst_path . $hash . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : ''), 'a+'))) { // we re-check\n                                $this->processed = false;\n                                $this->error = $this->translate('destination_dir_write');\n                            } else {\n                                @fclose($f);\n                            }\n                        }\n                    } else {\n                        $this->processed = false;\n                        $this->error = $this->translate('destination_path_write');\n                    }\n                } else {\n                    if ($this->processed) @fclose($f);\n                    @unlink($this->file_dst_path . $hash . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : ''));\n                }\n\n\n                // if we have an uploaded file, and if it is the first process, and if we can't access the file directly (open_basedir restriction)\n                // then we create a temp file that will be used as the source file in subsequent processes\n                // the third condition is there to check if the file is not accessible *directly* (it already has positively gone through is_uploaded_file(), so it exists)\n                if (!$this->no_upload_check && empty($this->file_src_temp) && !@file_exists($this->file_src_pathname)) {\n                    $this->log .= '- attempting to use a temp file:';\n                    $hash = md5($this->file_dst_name_body . rand(1, 1000));\n                    if (move_uploaded_file($this->file_src_pathname, $this->file_dst_path . $hash . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : ''))) {\n                        $this->file_src_pathname = $this->file_dst_path . $hash . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : '');\n                        $this->file_src_temp = $this->file_src_pathname;\n                        $this->log .= ' file created<br />';\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;temp file is: ' . $this->file_src_temp . '<br />';\n                    } else {\n                        $this->log .= ' failed<br />';\n                        $this->processed = false;\n                        $this->error = $this->translate('temp_file');\n                    }\n                }\n            }\n        }\n\n        if ($this->processed) {\n\n            // check if we need to autorotate, to automatically pre-rotates the image according to EXIF data (JPEG only)\n            $auto_flip = false;\n            $auto_rotate = 0;\n            if ($this->file_is_image && $this->image_auto_rotate && $this->image_src_type == 'jpg' && $this->function_enabled('exif_read_data')) {\n                $exif = @exif_read_data($this->file_src_pathname);\n                if (is_array($exif) && isset($exif['Orientation'])) {\n                    $orientation = $exif['Orientation'];\n                    switch($orientation) {\n                      case 1:\n                        $this->log .= '- EXIF orientation = 1 : default<br />';\n                        break;\n                      case 2:\n                        $auto_flip = 'v';\n                        $this->log .= '- EXIF orientation = 2 : vertical flip<br />';\n                        break;\n                      case 3:\n                        $auto_rotate = 180;\n                        $this->log .= '- EXIF orientation = 3 : 180 rotate left<br />';\n                        break;\n                      case 4:\n                        $auto_flip = 'h';\n                        $this->log .= '- EXIF orientation = 4 : horizontal flip<br />';\n                        break;\n                      case 5:\n                        $auto_flip = 'h';\n                        $auto_rotate = 90;\n                        $this->log .= '- EXIF orientation = 5 : horizontal flip + 90 rotate right<br />';\n                        break;\n                      case 6:\n                        $auto_rotate = 90;\n                        $this->log .= '- EXIF orientation = 6 : 90 rotate right<br />';\n                        break;\n                      case 7:\n                        $auto_flip = 'v';\n                        $auto_rotate = 90;\n                        $this->log .= '- EXIF orientation = 7 : vertical flip + 90 rotate right<br />';\n                        break;\n                      case 8:\n                        $auto_rotate = 270;\n                        $this->log .= '- EXIF orientation = 8 : 90 rotate left<br />';\n                        break;\n                      default:\n                        $this->log .= '- EXIF orientation = '.$orientation.' : unknown<br />';\n                        break;\n                    }\n                } else {\n                    $this->log .= '- EXIF data is invalid or missing<br />';\n                }\n            } else {\n                if (!$this->image_auto_rotate) {\n                    $this->log .= '- auto-rotate deactivated<br />';\n                } else if (!$this->image_src_type == 'jpg') {\n                    $this->log .= '- auto-rotate applies only to JPEG images<br />';\n                } else if (!$this->function_enabled('exif_read_data')) {\n                    $this->log .= '- auto-rotate requires function exif_read_data to be enabled<br />';\n                }\n            }\n\n            // do we do some image manipulation?\n            $image_manipulation  = ($this->file_is_image && (\n                                    $this->image_resize\n                                 || $this->image_convert != ''\n                                 || is_numeric($this->image_brightness)\n                                 || is_numeric($this->image_contrast)\n                                 || is_numeric($this->image_opacity)\n                                 || is_numeric($this->image_threshold)\n                                 || !empty($this->image_tint_color)\n                                 || !empty($this->image_overlay_color)\n                                 || $this->image_pixelate\n                                 || $this->image_unsharp\n                                 || !empty($this->image_text)\n                                 || $this->image_greyscale\n                                 || $this->image_negative\n                                 || !empty($this->image_watermark)\n                                 || $auto_rotate || $auto_flip\n                                 || is_numeric($this->image_rotate)\n                                 || is_numeric($this->jpeg_size)\n                                 || !empty($this->image_flip)\n                                 || !empty($this->image_crop)\n                                 || !empty($this->image_precrop)\n                                 || !empty($this->image_border)\n                                 || !empty($this->image_border_transparent)\n                                 || $this->image_frame > 0\n                                 || $this->image_bevel > 0\n                                 || $this->image_reflection_height));\n\n            // we do a quick check to ensure the file is really an image\n            // we can do this only now, as it would have failed before in case of open_basedir\n            if ($image_manipulation && !@getimagesize($this->file_src_pathname)) {\n                $this->log .= '- the file is not an image!<br />';\n                $image_manipulation = false;\n            }\n\n            if ($image_manipulation) {\n\n                // make sure GD doesn't complain too much\n                @ini_set(\"gd.jpeg_ignore_warning\", 1);\n\n                // checks if the source file is readable\n                if ($this->processed && !($f = @fopen($this->file_src_pathname, 'r'))) {\n                    $this->processed = false;\n                    $this->error = $this->translate('source_not_readable');\n                } else {\n                    @fclose($f);\n                }\n\n                // we now do all the image manipulations\n                $this->log .= '- image resizing or conversion wanted<br />';\n                if ($this->gdversion()) {\n                    switch($this->image_src_type) {\n                        case 'jpg':\n                            if (!$this->function_enabled('imagecreatefromjpeg')) {\n                                $this->processed = false;\n                                $this->error = $this->translate('no_create_support', array('JPEG'));\n                            } else {\n                                $image_src = @imagecreatefromjpeg($this->file_src_pathname);\n                                if (!$image_src) {\n                                    $this->processed = false;\n                                    $this->error = $this->translate('create_error', array('JPEG'));\n                                } else {\n                                    $this->log .= '- source image is JPEG<br />';\n                                }\n                            }\n                            break;\n                        case 'png':\n                            if (!$this->function_enabled('imagecreatefrompng')) {\n                                $this->processed = false;\n                                $this->error = $this->translate('no_create_support', array('PNG'));\n                            } else {\n                                $image_src = @imagecreatefrompng($this->file_src_pathname);\n                                if (!$image_src) {\n                                    $this->processed = false;\n                                    $this->error = $this->translate('create_error', array('PNG'));\n                                } else {\n                                    $this->log .= '- source image is PNG<br />';\n                                }\n                            }\n                            break;\n                        case 'gif':\n                            if (!$this->function_enabled('imagecreatefromgif')) {\n                                $this->processed = false;\n                                $this->error = $this->translate('no_create_support', array('GIF'));\n                            } else {\n                                $image_src = @imagecreatefromgif($this->file_src_pathname);\n                                if (!$image_src) {\n                                    $this->processed = false;\n                                    $this->error = $this->translate('create_error', array('GIF'));\n                                } else {\n                                    $this->log .= '- source image is GIF<br />';\n                                }\n                            }\n                            break;\n                        case 'bmp':\n                            if (!method_exists($this, 'imagecreatefrombmp')) {\n                                $this->processed = false;\n                                $this->error = $this->translate('no_create_support', array('BMP'));\n                            } else {\n                                $image_src = @$this->imagecreatefrombmp($this->file_src_pathname);\n                                if (!$image_src) {\n                                    $this->processed = false;\n                                    $this->error = $this->translate('create_error', array('BMP'));\n                                } else {\n                                    $this->log .= '- source image is BMP<br />';\n                                }\n                            }\n                            break;\n                        default:\n                            $this->processed = false;\n                            $this->error = $this->translate('source_invalid');\n                    }\n                } else {\n                    $this->processed = false;\n                    $this->error = $this->translate('gd_missing');\n                }\n\n                if ($this->processed && $image_src) {\n\n                    // we have to set image_convert if it is not already\n                    if (empty($this->image_convert)) {\n                        $this->log .= '- setting destination file type to ' . $this->image_src_type . '<br />';\n                        $this->image_convert = $this->image_src_type;\n                    }\n\n                    if (!in_array($this->image_convert, $this->image_supported)) {\n                        $this->image_convert = 'jpg';\n                    }\n\n                    // we set the default color to be the background color if we don't output in a transparent format\n                    if ($this->image_convert != 'png' && $this->image_convert != 'gif' && !empty($this->image_default_color) && empty($this->image_background_color)) $this->image_background_color = $this->image_default_color;\n                    if (!empty($this->image_background_color)) $this->image_default_color = $this->image_background_color;\n                    if (empty($this->image_default_color)) $this->image_default_color = '#FFFFFF';\n\n                    $this->image_src_x = imagesx($image_src);\n                    $this->image_src_y = imagesy($image_src);\n                    $gd_version = $this->gdversion();\n                    $ratio_crop = null;\n\n                    if (!imageistruecolor($image_src)) {  // $this->image_src_type == 'gif'\n                        $this->log .= '- image is detected as having a palette<br />';\n                        $this->image_is_palette = true;\n                        $this->image_transparent_color = imagecolortransparent($image_src);\n                        if ($this->image_transparent_color >= 0 && imagecolorstotal($image_src) > $this->image_transparent_color) {\n                            $this->image_is_transparent = true;\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;palette image is detected as transparent<br />';\n                        }\n                        // if the image has a palette (GIF), we convert it to true color, preserving transparency\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;convert palette image to true color<br />';\n                        $true_color = imagecreatetruecolor($this->image_src_x, $this->image_src_y);\n                        imagealphablending($true_color, false);\n                        imagesavealpha($true_color, true);\n                        for ($x = 0; $x < $this->image_src_x; $x++) {\n                            for ($y = 0; $y < $this->image_src_y; $y++) {\n                                if ($this->image_transparent_color >= 0 && imagecolorat($image_src, $x, $y) == $this->image_transparent_color) {\n                                    imagesetpixel($true_color, $x, $y, 127 << 24);\n                                } else {\n                                    $rgb = imagecolorsforindex($image_src, imagecolorat($image_src, $x, $y));\n                                    imagesetpixel($true_color, $x, $y, ($rgb['alpha'] << 24) | ($rgb['red'] << 16) | ($rgb['green'] << 8) | $rgb['blue']);\n                                }\n                            }\n                        }\n                        $image_src = $this->imagetransfer($true_color, $image_src);\n                        imagealphablending($image_src, false);\n                        imagesavealpha($image_src, true);\n                        $this->image_is_palette = false;\n                    }\n\n                    $image_dst = & $image_src;\n\n                    // auto-flip image, according to EXIF data (JPEG only)\n                    if ($gd_version >= 2 && !empty($auto_flip)) {\n                        $this->log .= '- auto-flip image : ' . ($auto_flip == 'v' ? 'vertical' : 'horizontal') . '<br />';\n                        $tmp = $this->imagecreatenew($this->image_src_x, $this->image_src_y);\n                        for ($x = 0; $x < $this->image_src_x; $x++) {\n                            for ($y = 0; $y < $this->image_src_y; $y++){\n                                if (strpos($auto_flip, 'v') !== false) {\n                                    imagecopy($tmp, $image_dst, $this->image_src_x - $x - 1, $y, $x, $y, 1, 1);\n                                } else {\n                                    imagecopy($tmp, $image_dst, $x, $this->image_src_y - $y - 1, $x, $y, 1, 1);\n                                }\n                            }\n                        }\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // auto-rotate image, according to EXIF data (JPEG only)\n                    if ($gd_version >= 2 && is_numeric($auto_rotate)) {\n                        if (!in_array($auto_rotate, array(0, 90, 180, 270))) $auto_rotate = 0;\n                        if ($auto_rotate != 0) {\n                            if ($auto_rotate == 90 || $auto_rotate == 270) {\n                                $tmp = $this->imagecreatenew($this->image_src_y, $this->image_src_x);\n                            } else {\n                                $tmp = $this->imagecreatenew($this->image_src_x, $this->image_src_y);\n                            }\n                            $this->log .= '- auto-rotate image : ' . $auto_rotate . '<br />';\n                            for ($x = 0; $x < $this->image_src_x; $x++) {\n                                for ($y = 0; $y < $this->image_src_y; $y++){\n                                    if ($auto_rotate == 90) {\n                                        imagecopy($tmp, $image_dst, $y, $x, $x, $this->image_src_y - $y - 1, 1, 1);\n                                    } else if ($auto_rotate == 180) {\n                                        imagecopy($tmp, $image_dst, $x, $y, $this->image_src_x - $x - 1, $this->image_src_y - $y - 1, 1, 1);\n                                    } else if ($auto_rotate == 270) {\n                                        imagecopy($tmp, $image_dst, $y, $x, $this->image_src_x - $x - 1, $y, 1, 1);\n                                    } else {\n                                        imagecopy($tmp, $image_dst, $x, $y, $x, $y, 1, 1);\n                                    }\n                                }\n                            }\n                            if ($auto_rotate == 90 || $auto_rotate == 270) {\n                                $t = $this->image_src_y;\n                                $this->image_src_y = $this->image_src_x;\n                                $this->image_src_x = $t;\n                            }\n                            // we transfert tmp into image_dst\n                            $image_dst = $this->imagetransfer($tmp, $image_dst);\n                        }\n                    }\n\n                    // pre-crop image, before resizing\n                    if ((!empty($this->image_precrop))) {\n                        list($ct, $cr, $cb, $cl) = $this->getoffsets($this->image_precrop, $this->image_src_x, $this->image_src_y, true, true);\n                        $this->log .= '- pre-crop image : ' . $ct . ' ' . $cr . ' ' . $cb . ' ' . $cl . ' <br />';\n                        $this->image_src_x = $this->image_src_x - $cl - $cr;\n                        $this->image_src_y = $this->image_src_y - $ct - $cb;\n                        if ($this->image_src_x < 1) $this->image_src_x = 1;\n                        if ($this->image_src_y < 1) $this->image_src_y = 1;\n                        $tmp = $this->imagecreatenew($this->image_src_x, $this->image_src_y);\n\n                        // we copy the image into the recieving image\n                        imagecopy($tmp, $image_dst, 0, 0, $cl, $ct, $this->image_src_x, $this->image_src_y);\n\n                        // if we crop with negative margins, we have to make sure the extra bits are the right color, or transparent\n                        if ($ct < 0 || $cr < 0 || $cb < 0 || $cl < 0 ) {\n                            // use the background color if present\n                            if (!empty($this->image_background_color)) {\n                                list($red, $green, $blue) = $this->getcolors($this->image_background_color);\n                                $fill = imagecolorallocate($tmp, $red, $green, $blue);\n                            } else {\n                                $fill = imagecolorallocatealpha($tmp, 0, 0, 0, 127);\n                            }\n                            // fills eventual negative margins\n                            if ($ct < 0) imagefilledrectangle($tmp, 0, 0, $this->image_src_x, -$ct, $fill);\n                            if ($cr < 0) imagefilledrectangle($tmp, $this->image_src_x + $cr, 0, $this->image_src_x, $this->image_src_y, $fill);\n                            if ($cb < 0) imagefilledrectangle($tmp, 0, $this->image_src_y + $cb, $this->image_src_x, $this->image_src_y, $fill);\n                            if ($cl < 0) imagefilledrectangle($tmp, 0, 0, -$cl, $this->image_src_y, $fill);\n                        }\n\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // resize image (and move image_src_x, image_src_y dimensions into image_dst_x, image_dst_y)\n                    if ($this->image_resize) {\n                        $this->log .= '- resizing...<br />';\n                        $this->image_dst_x = $this->image_x;\n                        $this->image_dst_y = $this->image_y;\n\n                        // backward compatibility for soon to be deprecated settings\n                        if ($this->image_ratio_no_zoom_in) {\n                            $this->image_ratio = true;\n                            $this->image_no_enlarging = true;\n                        } else if ($this->image_ratio_no_zoom_out) {\n                            $this->image_ratio = true;\n                            $this->image_no_shrinking = true;\n                        }\n\n                        // keeps aspect ratio with x calculated from y\n                        if ($this->image_ratio_x) {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;calculate x size<br />';\n                            $this->image_dst_x = round(($this->image_src_x * $this->image_y) / $this->image_src_y);\n                            $this->image_dst_y = $this->image_y;\n\n                        // keeps aspect ratio with y calculated from x\n                        } else if ($this->image_ratio_y) {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;calculate y size<br />';\n                            $this->image_dst_x = $this->image_x;\n                            $this->image_dst_y = round(($this->image_src_y * $this->image_x) / $this->image_src_x);\n\n                        // keeps aspect ratio, calculating x and y so that the image is approx the set number of pixels\n                        } else if (is_numeric($this->image_ratio_pixels)) {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;calculate x/y size to match a number of pixels<br />';\n                            $pixels = $this->image_src_y * $this->image_src_x;\n                            $diff = sqrt($this->image_ratio_pixels / $pixels);\n                            $this->image_dst_x = round($this->image_src_x * $diff);\n                            $this->image_dst_y = round($this->image_src_y * $diff);\n\n                        // keeps aspect ratio with x and y dimensions, filling the space\n                        } else if ($this->image_ratio_crop) {\n                            if (!is_string($this->image_ratio_crop)) $this->image_ratio_crop = '';\n                            $this->image_ratio_crop = strtolower($this->image_ratio_crop);\n                            if (($this->image_src_x/$this->image_x) > ($this->image_src_y/$this->image_y)) {\n                                $this->image_dst_y = $this->image_y;\n                                $this->image_dst_x = intval($this->image_src_x*($this->image_y / $this->image_src_y));\n                                $ratio_crop = array();\n                                $ratio_crop['x'] = $this->image_dst_x - $this->image_x;\n                                if (strpos($this->image_ratio_crop, 'l') !== false) {\n                                    $ratio_crop['l'] = 0;\n                                    $ratio_crop['r'] = $ratio_crop['x'];\n                                } else if (strpos($this->image_ratio_crop, 'r') !== false) {\n                                    $ratio_crop['l'] = $ratio_crop['x'];\n                                    $ratio_crop['r'] = 0;\n                                } else {\n                                    $ratio_crop['l'] = round($ratio_crop['x']/2);\n                                    $ratio_crop['r'] = $ratio_crop['x'] - $ratio_crop['l'];\n                                }\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;ratio_crop_x         : ' . $ratio_crop['x'] . ' (' . $ratio_crop['l'] . ';' . $ratio_crop['r'] . ')<br />';\n                                if (is_null($this->image_crop)) $this->image_crop = array(0, 0, 0, 0);\n                            } else {\n                                $this->image_dst_x = $this->image_x;\n                                $this->image_dst_y = intval($this->image_src_y*($this->image_x / $this->image_src_x));\n                                $ratio_crop = array();\n                                $ratio_crop['y'] = $this->image_dst_y - $this->image_y;\n                                if (strpos($this->image_ratio_crop, 't') !== false) {\n                                    $ratio_crop['t'] = 0;\n                                    $ratio_crop['b'] = $ratio_crop['y'];\n                                } else if (strpos($this->image_ratio_crop, 'b') !== false) {\n                                    $ratio_crop['t'] = $ratio_crop['y'];\n                                    $ratio_crop['b'] = 0;\n                                } else {\n                                    $ratio_crop['t'] = round($ratio_crop['y']/2);\n                                    $ratio_crop['b'] = $ratio_crop['y'] - $ratio_crop['t'];\n                                }\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;ratio_crop_y         : ' . $ratio_crop['y'] . ' (' . $ratio_crop['t'] . ';' . $ratio_crop['b'] . ')<br />';\n                                if (is_null($this->image_crop)) $this->image_crop = array(0, 0, 0, 0);\n                            }\n\n                        // keeps aspect ratio with x and y dimensions, fitting the image in the space, and coloring the rest\n                        } else if ($this->image_ratio_fill) {\n                            if (!is_string($this->image_ratio_fill)) $this->image_ratio_fill = '';\n                            $this->image_ratio_fill = strtolower($this->image_ratio_fill);\n                            if (($this->image_src_x/$this->image_x) < ($this->image_src_y/$this->image_y)) {\n                                $this->image_dst_y = $this->image_y;\n                                $this->image_dst_x = intval($this->image_src_x*($this->image_y / $this->image_src_y));\n                                $ratio_crop = array();\n                                $ratio_crop['x'] = $this->image_dst_x - $this->image_x;\n                                if (strpos($this->image_ratio_fill, 'l') !== false) {\n                                    $ratio_crop['l'] = 0;\n                                    $ratio_crop['r'] = $ratio_crop['x'];\n                                } else if (strpos($this->image_ratio_fill, 'r') !== false) {\n                                    $ratio_crop['l'] = $ratio_crop['x'];\n                                    $ratio_crop['r'] = 0;\n                                } else {\n                                    $ratio_crop['l'] = round($ratio_crop['x']/2);\n                                    $ratio_crop['r'] = $ratio_crop['x'] - $ratio_crop['l'];\n                                }\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;ratio_fill_x         : ' . $ratio_crop['x'] . ' (' . $ratio_crop['l'] . ';' . $ratio_crop['r'] . ')<br />';\n                                if (is_null($this->image_crop)) $this->image_crop = array(0, 0, 0, 0);\n                            } else {\n                                $this->image_dst_x = $this->image_x;\n                                $this->image_dst_y = intval($this->image_src_y*($this->image_x / $this->image_src_x));\n                                $ratio_crop = array();\n                                $ratio_crop['y'] = $this->image_dst_y - $this->image_y;\n                                if (strpos($this->image_ratio_fill, 't') !== false) {\n                                    $ratio_crop['t'] = 0;\n                                    $ratio_crop['b'] = $ratio_crop['y'];\n                                } else if (strpos($this->image_ratio_fill, 'b') !== false) {\n                                    $ratio_crop['t'] = $ratio_crop['y'];\n                                    $ratio_crop['b'] = 0;\n                                } else {\n                                    $ratio_crop['t'] = round($ratio_crop['y']/2);\n                                    $ratio_crop['b'] = $ratio_crop['y'] - $ratio_crop['t'];\n                                }\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;ratio_fill_y         : ' . $ratio_crop['y'] . ' (' . $ratio_crop['t'] . ';' . $ratio_crop['b'] . ')<br />';\n                                if (is_null($this->image_crop)) $this->image_crop = array(0, 0, 0, 0);\n                            }\n\n                        // keeps aspect ratio with x and y dimensions\n                        } else if ($this->image_ratio) {\n                            if (($this->image_src_x/$this->image_x) > ($this->image_src_y/$this->image_y)) {\n                                $this->image_dst_x = $this->image_x;\n                                $this->image_dst_y = intval($this->image_src_y*($this->image_x / $this->image_src_x));\n                            } else {\n                                $this->image_dst_y = $this->image_y;\n                                $this->image_dst_x = intval($this->image_src_x*($this->image_y / $this->image_src_y));\n                            }\n\n                        // resize to provided exact dimensions\n                        } else {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;use plain sizes<br />';\n                            $this->image_dst_x = $this->image_x;\n                            $this->image_dst_y = $this->image_y;\n                        }\n\n                        if ($this->image_dst_x < 1) $this->image_dst_x = 1;\n                        if ($this->image_dst_y < 1) $this->image_dst_y = 1;\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_src_x y        : ' . $this->image_src_x . ' x ' . $this->image_src_y . '<br />';\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_dst_x y        : ' . $this->image_dst_x . ' x ' . $this->image_dst_y . '<br />';\n\n                        // make sure we don't enlarge the image if we don't want to\n                        if ($this->image_no_enlarging && ($this->image_src_x < $this->image_dst_x || $this->image_src_y < $this->image_dst_y)) {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;cancel resizing, as it would enlarge the image!<br />';\n                            $this->image_dst_x = $this->image_src_x;\n                            $this->image_dst_y = $this->image_src_y;\n                        }\n\n                        // make sure we don't shrink the image if we don't want to\n                        if ($this->image_no_shrinking && ($this->image_src_x > $this->image_dst_x || $this->image_src_y > $this->image_dst_y)) {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;cancel resizing, as it would shrink the image!<br />';\n                            $this->image_dst_x = $this->image_src_x;\n                            $this->image_dst_y = $this->image_src_y;\n                        }\n\n                        // resize the image\n                        if ($this->image_dst_x != $this->image_src_x && $this->image_dst_y != $this->image_src_y) {\n                            $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n\n                            if ($gd_version >= 2) {\n                                $res = imagecopyresampled($tmp, $image_src, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, $this->image_src_x, $this->image_src_y);\n                            } else {\n                                $res = imagecopyresized($tmp, $image_src, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, $this->image_src_x, $this->image_src_y);\n                            }\n\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;resized image object created<br />';\n                             // we transfert tmp into image_dst\n                            $image_dst = $this->imagetransfer($tmp, $image_dst);\n                        }\n\n                    } else {\n                        $this->image_dst_x = $this->image_src_x;\n                        $this->image_dst_y = $this->image_src_y;\n                    }\n\n                    // crop image (and also crops if image_ratio_crop is used)\n                    if ((!empty($this->image_crop) || !is_null($ratio_crop))) {\n                        list($ct, $cr, $cb, $cl) = $this->getoffsets($this->image_crop, $this->image_dst_x, $this->image_dst_y, true, true);\n                        // we adjust the cropping if we use image_ratio_crop\n                        if (!is_null($ratio_crop)) {\n                            if (array_key_exists('t', $ratio_crop)) $ct += $ratio_crop['t'];\n                            if (array_key_exists('r', $ratio_crop)) $cr += $ratio_crop['r'];\n                            if (array_key_exists('b', $ratio_crop)) $cb += $ratio_crop['b'];\n                            if (array_key_exists('l', $ratio_crop)) $cl += $ratio_crop['l'];\n                        }\n                        $this->log .= '- crop image : ' . $ct . ' ' . $cr . ' ' . $cb . ' ' . $cl . ' <br />';\n                        $this->image_dst_x = $this->image_dst_x - $cl - $cr;\n                        $this->image_dst_y = $this->image_dst_y - $ct - $cb;\n                        if ($this->image_dst_x < 1) $this->image_dst_x = 1;\n                        if ($this->image_dst_y < 1) $this->image_dst_y = 1;\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n\n                        // we copy the image into the recieving image\n                        imagecopy($tmp, $image_dst, 0, 0, $cl, $ct, $this->image_dst_x, $this->image_dst_y);\n\n                        // if we crop with negative margins, we have to make sure the extra bits are the right color, or transparent\n                        if ($ct < 0 || $cr < 0 || $cb < 0 || $cl < 0 ) {\n                            // use the background color if present\n                            if (!empty($this->image_background_color)) {\n                                list($red, $green, $blue) = $this->getcolors($this->image_background_color);\n                                $fill = imagecolorallocate($tmp, $red, $green, $blue);\n                            } else {\n                                $fill = imagecolorallocatealpha($tmp, 0, 0, 0, 127);\n                            }\n                            // fills eventual negative margins\n                            if ($ct < 0) imagefilledrectangle($tmp, 0, 0, $this->image_dst_x, -$ct-1, $fill);\n                            if ($cr < 0) imagefilledrectangle($tmp, $this->image_dst_x + $cr, 0, $this->image_dst_x, $this->image_dst_y, $fill);\n                            if ($cb < 0) imagefilledrectangle($tmp, 0, $this->image_dst_y + $cb, $this->image_dst_x, $this->image_dst_y, $fill);\n                            if ($cl < 0) imagefilledrectangle($tmp, 0, 0, -$cl-1, $this->image_dst_y, $fill);\n                        }\n\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // flip image\n                    if ($gd_version >= 2 && !empty($this->image_flip)) {\n                        $this->image_flip = strtolower($this->image_flip);\n                        $this->log .= '- flip image : ' . $this->image_flip . '<br />';\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                        for ($x = 0; $x < $this->image_dst_x; $x++) {\n                            for ($y = 0; $y < $this->image_dst_y; $y++){\n                                if (strpos($this->image_flip, 'v') !== false) {\n                                    imagecopy($tmp, $image_dst, $this->image_dst_x - $x - 1, $y, $x, $y, 1, 1);\n                                } else {\n                                    imagecopy($tmp, $image_dst, $x, $this->image_dst_y - $y - 1, $x, $y, 1, 1);\n                                }\n                            }\n                        }\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // rotate image\n                    if ($gd_version >= 2 && is_numeric($this->image_rotate)) {\n                        if (!in_array($this->image_rotate, array(0, 90, 180, 270))) $this->image_rotate = 0;\n                        if ($this->image_rotate != 0) {\n                            if ($this->image_rotate == 90 || $this->image_rotate == 270) {\n                                $tmp = $this->imagecreatenew($this->image_dst_y, $this->image_dst_x);\n                            } else {\n                                $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                            }\n                            $this->log .= '- rotate image : ' . $this->image_rotate . '<br />';\n                            for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                for ($y = 0; $y < $this->image_dst_y; $y++){\n                                    if ($this->image_rotate == 90) {\n                                        imagecopy($tmp, $image_dst, $y, $x, $x, $this->image_dst_y - $y - 1, 1, 1);\n                                    } else if ($this->image_rotate == 180) {\n                                        imagecopy($tmp, $image_dst, $x, $y, $this->image_dst_x - $x - 1, $this->image_dst_y - $y - 1, 1, 1);\n                                    } else if ($this->image_rotate == 270) {\n                                        imagecopy($tmp, $image_dst, $y, $x, $this->image_dst_x - $x - 1, $y, 1, 1);\n                                    } else {\n                                        imagecopy($tmp, $image_dst, $x, $y, $x, $y, 1, 1);\n                                    }\n                                }\n                            }\n                            if ($this->image_rotate == 90 || $this->image_rotate == 270) {\n                                $t = $this->image_dst_y;\n                                $this->image_dst_y = $this->image_dst_x;\n                                $this->image_dst_x = $t;\n                            }\n                            // we transfert tmp into image_dst\n                            $image_dst = $this->imagetransfer($tmp, $image_dst);\n                        }\n                    }\n\n                    // pixelate image\n                    if ((is_numeric($this->image_pixelate) && $this->image_pixelate > 0)) {\n                        $this->log .= '- pixelate image (' . $this->image_pixelate . 'px)<br />';\n                        $filter = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                        if ($gd_version >= 2) {\n                            imagecopyresampled($filter, $image_dst, 0, 0, 0, 0, round($this->image_dst_x / $this->image_pixelate), round($this->image_dst_y / $this->image_pixelate), $this->image_dst_x, $this->image_dst_y);\n                            imagecopyresampled($image_dst, $filter, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, round($this->image_dst_x / $this->image_pixelate), round($this->image_dst_y / $this->image_pixelate));\n                        } else {\n                            imagecopyresized($filter, $image_dst, 0, 0, 0, 0, round($this->image_dst_x / $this->image_pixelate), round($this->image_dst_y / $this->image_pixelate), $this->image_dst_x, $this->image_dst_y);\n                            imagecopyresized($image_dst, $filter, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, round($this->image_dst_x / $this->image_pixelate), round($this->image_dst_y / $this->image_pixelate));\n                        }\n                        imagedestroy($filter);\n                    }\n\n                    // unsharp mask\n                    if ($gd_version >= 2 && $this->image_unsharp && is_numeric($this->image_unsharp_amount) && is_numeric($this->image_unsharp_radius) && is_numeric($this->image_unsharp_threshold)) {\n                        // Unsharp Mask for PHP - version 2.1.1\n                        // Unsharp mask algorithm by Torstein H\u00f8nsi 2003-07.\n                        // Used with permission\n                        // Modified to support alpha transparency\n                        if ($this->image_unsharp_amount > 500)    $this->image_unsharp_amount = 500;\n                        $this->image_unsharp_amount = $this->image_unsharp_amount * 0.016;\n                        if ($this->image_unsharp_radius > 50)    $this->image_unsharp_radius = 50;\n                        $this->image_unsharp_radius = $this->image_unsharp_radius * 2;\n                        if ($this->image_unsharp_threshold > 255)    $this->image_unsharp_threshold = 255;\n                        $this->image_unsharp_radius = abs(round($this->image_unsharp_radius));\n                        if ($this->image_unsharp_radius != 0) {\n                            $this->image_dst_x = imagesx($image_dst); $this->image_dst_y = imagesy($image_dst);\n                            $canvas = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y, false, true);\n                            $blur = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y, false, true);\n                            if ($this->function_enabled('imageconvolution')) { // PHP >= 5.1\n                                $matrix = array(array( 1, 2, 1 ), array( 2, 4, 2 ), array( 1, 2, 1 ));\n                                imagecopy($blur, $image_dst, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y);\n                                imageconvolution($blur, $matrix, 16, 0);\n                            } else {\n                                for ($i = 0; $i < $this->image_unsharp_radius; $i++) {\n                                    imagecopy($blur, $image_dst, 0, 0, 1, 0, $this->image_dst_x - 1, $this->image_dst_y); // left\n                                    $this->imagecopymergealpha($blur, $image_dst, 1, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, 50); // right\n                                    $this->imagecopymergealpha($blur, $image_dst, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, 50); // center\n                                    imagecopy($canvas, $blur, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y);\n                                    $this->imagecopymergealpha($blur, $canvas, 0, 0, 0, 1, $this->image_dst_x, $this->image_dst_y - 1, 33.33333 ); // up\n                                    $this->imagecopymergealpha($blur, $canvas, 0, 1, 0, 0, $this->image_dst_x, $this->image_dst_y, 25); // down\n                                }\n                            }\n                            $p_new = array();\n                            if($this->image_unsharp_threshold>0) {\n                                for ($x = 0; $x < $this->image_dst_x-1; $x++) {\n                                    for ($y = 0; $y < $this->image_dst_y; $y++) {\n                                        $p_orig = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                        $p_blur = imagecolorsforindex($blur, imagecolorat($blur, $x, $y));\n                                        $p_new['red'] = (abs($p_orig['red'] - $p_blur['red']) >= $this->image_unsharp_threshold) ? max(0, min(255, ($this->image_unsharp_amount * ($p_orig['red'] - $p_blur['red'])) + $p_orig['red'])) : $p_orig['red'];\n                                        $p_new['green'] = (abs($p_orig['green'] - $p_blur['green']) >= $this->image_unsharp_threshold) ? max(0, min(255, ($this->image_unsharp_amount * ($p_orig['green'] - $p_blur['green'])) + $p_orig['green'])) : $p_orig['green'];\n                                        $p_new['blue'] = (abs($p_orig['blue'] - $p_blur['blue']) >= $this->image_unsharp_threshold) ? max(0, min(255, ($this->image_unsharp_amount * ($p_orig['blue'] - $p_blur['blue'])) + $p_orig['blue'])) : $p_orig['blue'];\n                                        if (($p_orig['red'] != $p_new['red']) || ($p_orig['green'] != $p_new['green']) || ($p_orig['blue'] != $p_new['blue'])) {\n                                            $color = imagecolorallocatealpha($image_dst, $p_new['red'], $p_new['green'], $p_new['blue'], $p_orig['alpha']);\n                                            imagesetpixel($image_dst, $x, $y, $color);\n                                        }\n                                    }\n                                }\n                            } else {\n                                for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                    for ($y = 0; $y < $this->image_dst_y; $y++) {\n                                        $p_orig = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                        $p_blur = imagecolorsforindex($blur, imagecolorat($blur, $x, $y));\n                                        $p_new['red'] = ($this->image_unsharp_amount * ($p_orig['red'] - $p_blur['red'])) + $p_orig['red'];\n                                        if ($p_new['red']>255) { $p_new['red']=255; } elseif ($p_new['red']<0) { $p_new['red']=0; }\n                                        $p_new['green'] = ($this->image_unsharp_amount * ($p_orig['green'] - $p_blur['green'])) + $p_orig['green'];\n                                        if ($p_new['green']>255) { $p_new['green']=255; }  elseif ($p_new['green']<0) { $p_new['green']=0; }\n                                        $p_new['blue'] = ($this->image_unsharp_amount * ($p_orig['blue'] - $p_blur['blue'])) + $p_orig['blue'];\n                                        if ($p_new['blue']>255) { $p_new['blue']=255; } elseif ($p_new['blue']<0) { $p_new['blue']=0; }\n                                        $color = imagecolorallocatealpha($image_dst, $p_new['red'], $p_new['green'], $p_new['blue'], $p_orig['alpha']);\n                                        imagesetpixel($image_dst, $x, $y, $color);\n                                    }\n                                }\n                            }\n                            imagedestroy($canvas);\n                            imagedestroy($blur);\n                        }\n                    }\n\n                    // add color overlay\n                    if ($gd_version >= 2 && (is_numeric($this->image_overlay_opacity) && $this->image_overlay_opacity > 0 && !empty($this->image_overlay_color))) {\n                        $this->log .= '- apply color overlay<br />';\n                        list($red, $green, $blue) = $this->getcolors($this->image_overlay_color);\n                        $filter = imagecreatetruecolor($this->image_dst_x, $this->image_dst_y);\n                        $color = imagecolorallocate($filter, $red, $green, $blue);\n                        imagefilledrectangle($filter, 0, 0, $this->image_dst_x, $this->image_dst_y, $color);\n                        $this->imagecopymergealpha($image_dst, $filter, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, $this->image_overlay_opacity);\n                        imagedestroy($filter);\n                    }\n\n                    // add brightness, contrast and tint, turns to greyscale and inverts colors\n                    if ($gd_version >= 2 && ($this->image_negative || $this->image_greyscale || is_numeric($this->image_threshold)|| is_numeric($this->image_brightness) || is_numeric($this->image_contrast) || !empty($this->image_tint_color))) {\n                        $this->log .= '- apply tint, light, contrast correction, negative, greyscale and threshold<br />';\n                        if (!empty($this->image_tint_color)) list($tint_red, $tint_green, $tint_blue) = $this->getcolors($this->image_tint_color);\n                        //imagealphablending($image_dst, true);\n                        for($y=0; $y < $this->image_dst_y; $y++) {\n                            for($x=0; $x < $this->image_dst_x; $x++) {\n                                if ($this->image_greyscale) {\n                                    $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    $r = $g = $b = round((0.2125 * $pixel['red']) + (0.7154 * $pixel['green']) + (0.0721 * $pixel['blue']));\n                                    $color = imagecolorallocatealpha($image_dst, $r, $g, $b, $pixel['alpha']);\n                                    imagesetpixel($image_dst, $x, $y, $color);\n                                    unset($color); unset($pixel);\n                                }\n                                if (is_numeric($this->image_threshold)) {\n                                    $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    $c = (round($pixel['red'] + $pixel['green'] + $pixel['blue']) / 3) - 127;\n                                    $r = $g = $b = ($c > $this->image_threshold ? 255 : 0);\n                                    $color = imagecolorallocatealpha($image_dst, $r, $g, $b, $pixel['alpha']);\n                                    imagesetpixel($image_dst, $x, $y, $color);\n                                    unset($color); unset($pixel);\n                                }\n                                if (is_numeric($this->image_brightness)) {\n                                    $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    $r = max(min(round($pixel['red'] + (($this->image_brightness * 2))), 255), 0);\n                                    $g = max(min(round($pixel['green'] + (($this->image_brightness * 2))), 255), 0);\n                                    $b = max(min(round($pixel['blue'] + (($this->image_brightness * 2))), 255), 0);\n                                    $color = imagecolorallocatealpha($image_dst, $r, $g, $b, $pixel['alpha']);\n                                    imagesetpixel($image_dst, $x, $y, $color);\n                                    unset($color); unset($pixel);\n                                }\n                                if (is_numeric($this->image_contrast)) {\n                                    $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    $r = max(min(round(($this->image_contrast + 128) * $pixel['red'] / 128), 255), 0);\n                                    $g = max(min(round(($this->image_contrast + 128) * $pixel['green'] / 128), 255), 0);\n                                    $b = max(min(round(($this->image_contrast + 128) * $pixel['blue'] / 128), 255), 0);\n                                    $color = imagecolorallocatealpha($image_dst, $r, $g, $b, $pixel['alpha']);\n                                    imagesetpixel($image_dst, $x, $y, $color);\n                                    unset($color); unset($pixel);\n                                }\n                                if (!empty($this->image_tint_color)) {\n                                    $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    $r = min(round($tint_red * $pixel['red'] / 169), 255);\n                                    $g = min(round($tint_green * $pixel['green'] / 169), 255);\n                                    $b = min(round($tint_blue * $pixel['blue'] / 169), 255);\n                                    $color = imagecolorallocatealpha($image_dst, $r, $g, $b, $pixel['alpha']);\n                                    imagesetpixel($image_dst, $x, $y, $color);\n                                    unset($color); unset($pixel);\n                                }\n                                if (!empty($this->image_negative)) {\n                                    $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    $r = round(255 - $pixel['red']);\n                                    $g = round(255 - $pixel['green']);\n                                    $b = round(255 - $pixel['blue']);\n                                    $color = imagecolorallocatealpha($image_dst, $r, $g, $b, $pixel['alpha']);\n                                    imagesetpixel($image_dst, $x, $y, $color);\n                                    unset($color); unset($pixel);\n                                }\n                            }\n                        }\n                    }\n\n                    // adds a border\n                    if ($gd_version >= 2 && !empty($this->image_border)) {\n                        list($ct, $cr, $cb, $cl) = $this->getoffsets($this->image_border, $this->image_dst_x, $this->image_dst_y, true, false);\n                        $this->log .= '- add border : ' . $ct . ' ' . $cr . ' ' . $cb . ' ' . $cl . '<br />';\n                        $this->image_dst_x = $this->image_dst_x + $cl + $cr;\n                        $this->image_dst_y = $this->image_dst_y + $ct + $cb;\n                        if (!empty($this->image_border_color)) list($red, $green, $blue) = $this->getcolors($this->image_border_color);\n                        $opacity = (is_numeric($this->image_border_opacity) ? (int) (127 - $this->image_border_opacity / 100 * 127): 0);\n                        // we now create an image, that we fill with the border color\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                        $background = imagecolorallocatealpha($tmp, $red, $green, $blue, $opacity);\n                        imagefilledrectangle($tmp, 0, 0, $this->image_dst_x, $this->image_dst_y, $background);\n                        // we then copy the source image into the new image, without merging so that only the border is actually kept\n                        imagecopy($tmp, $image_dst, $cl, $ct, 0, 0, $this->image_dst_x - $cr - $cl, $this->image_dst_y - $cb - $ct);\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // adds a fading-to-transparent border\n                    if ($gd_version >= 2 && !empty($this->image_border_transparent)) {\n                        list($ct, $cr, $cb, $cl) = $this->getoffsets($this->image_border_transparent, $this->image_dst_x, $this->image_dst_y, true, false);\n                        $this->log .= '- add transparent border : ' . $ct . ' ' . $cr . ' ' . $cb . ' ' . $cl . '<br />';\n                        // we now create an image, that we fill with the border color\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                        // we then copy the source image into the new image, without the borders\n                        imagecopy($tmp, $image_dst, $cl, $ct, $cl, $ct, $this->image_dst_x - $cr - $cl, $this->image_dst_y - $cb - $ct);\n                        // we now add the top border\n                        $opacity = 100;\n                        for ($y = $ct - 1; $y >= 0; $y--) {\n                            $il = (int) ($ct > 0 ? ($cl * ($y / $ct)) : 0);\n                            $ir = (int) ($ct > 0 ? ($cr * ($y / $ct)) : 0);\n                            for ($x = $il; $x < $this->image_dst_x - $ir; $x++) {\n                                $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                $alpha = (1 - ($pixel['alpha'] / 127)) * $opacity / 100;\n                                if ($alpha > 0) {\n                                    if ($alpha > 1) $alpha = 1;\n                                    $color = imagecolorallocatealpha($tmp, $pixel['red'] , $pixel['green'], $pixel['blue'],  round((1 - $alpha) * 127));\n                                    imagesetpixel($tmp, $x, $y, $color);\n                                }\n                            }\n                            if ($opacity > 0) $opacity = $opacity - (100 / $ct);\n                        }\n                        // we now add the right border\n                        $opacity = 100;\n                        for ($x = $this->image_dst_x - $cr; $x < $this->image_dst_x; $x++) {\n                            $it = (int) ($cr > 0 ? ($ct * (($this->image_dst_x - $x - 1) / $cr)) : 0);\n                            $ib = (int) ($cr > 0 ? ($cb * (($this->image_dst_x - $x - 1) / $cr)) : 0);\n                            for ($y = $it; $y < $this->image_dst_y - $ib; $y++) {\n                                $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                $alpha = (1 - ($pixel['alpha'] / 127)) * $opacity / 100;\n                                if ($alpha > 0) {\n                                    if ($alpha > 1) $alpha = 1;\n                                    $color = imagecolorallocatealpha($tmp, $pixel['red'] , $pixel['green'], $pixel['blue'],  round((1 - $alpha) * 127));\n                                    imagesetpixel($tmp, $x, $y, $color);\n                                }\n                            }\n                            if ($opacity > 0) $opacity = $opacity - (100 / $cr);\n                        }\n                        // we now add the bottom border\n                        $opacity = 100;\n                        for ($y = $this->image_dst_y - $cb; $y < $this->image_dst_y; $y++) {\n                            $il = (int) ($cb > 0 ? ($cl * (($this->image_dst_y - $y - 1) / $cb)) : 0);\n                            $ir = (int) ($cb > 0 ? ($cr * (($this->image_dst_y - $y - 1) / $cb)) : 0);\n                            for ($x = $il; $x < $this->image_dst_x - $ir; $x++) {\n                                $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                $alpha = (1 - ($pixel['alpha'] / 127)) * $opacity / 100;\n                                if ($alpha > 0) {\n                                    if ($alpha > 1) $alpha = 1;\n                                    $color = imagecolorallocatealpha($tmp, $pixel['red'] , $pixel['green'], $pixel['blue'],  round((1 - $alpha) * 127));\n                                    imagesetpixel($tmp, $x, $y, $color);\n                                }\n                            }\n                            if ($opacity > 0) $opacity = $opacity - (100 / $cb);\n                        }\n                        // we now add the left border\n                        $opacity = 100;\n                        for ($x = $cl - 1; $x >= 0; $x--) {\n                            $it = (int) ($cl > 0 ? ($ct * ($x / $cl)) : 0);\n                            $ib = (int) ($cl > 0 ? ($cb * ($x / $cl)) : 0);\n                            for ($y = $it; $y < $this->image_dst_y - $ib; $y++) {\n                                $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                $alpha = (1 - ($pixel['alpha'] / 127)) * $opacity / 100;\n                                if ($alpha > 0) {\n                                    if ($alpha > 1) $alpha = 1;\n                                    $color = imagecolorallocatealpha($tmp, $pixel['red'] , $pixel['green'], $pixel['blue'],  round((1 - $alpha) * 127));\n                                    imagesetpixel($tmp, $x, $y, $color);\n                                }\n                            }\n                            if ($opacity > 0) $opacity = $opacity - (100 / $cl);\n                        }\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // add frame border\n                    if ($gd_version >= 2 && is_numeric($this->image_frame)) {\n                        if (is_array($this->image_frame_colors)) {\n                            $vars = $this->image_frame_colors;\n                            $this->log .= '- add frame : ' . implode(' ', $this->image_frame_colors) . '<br />';\n                        } else {\n                            $this->log .= '- add frame : ' . $this->image_frame_colors . '<br />';\n                            $vars = explode(' ', $this->image_frame_colors);\n                        }\n                        $nb = sizeof($vars);\n                        $this->image_dst_x = $this->image_dst_x + ($nb * 2);\n                        $this->image_dst_y = $this->image_dst_y + ($nb * 2);\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                        imagecopy($tmp, $image_dst, $nb, $nb, 0, 0, $this->image_dst_x - ($nb * 2), $this->image_dst_y - ($nb * 2));\n                        $opacity = (is_numeric($this->image_frame_opacity) ? (int) (127 - $this->image_frame_opacity / 100 * 127): 0);\n                        for ($i=0; $i<$nb; $i++) {\n                            list($red, $green, $blue) = $this->getcolors($vars[$i]);\n                            $c = imagecolorallocatealpha($tmp, $red, $green, $blue, $opacity);\n                            if ($this->image_frame == 1) {\n                                imageline($tmp, $i, $i, $this->image_dst_x - $i -1, $i, $c);\n                                imageline($tmp, $this->image_dst_x - $i -1, $this->image_dst_y - $i -1, $this->image_dst_x - $i -1, $i, $c);\n                                imageline($tmp, $this->image_dst_x - $i -1, $this->image_dst_y - $i -1, $i, $this->image_dst_y - $i -1, $c);\n                                imageline($tmp, $i, $i, $i, $this->image_dst_y - $i -1, $c);\n                            } else {\n                                imageline($tmp, $i, $i, $this->image_dst_x - $i -1, $i, $c);\n                                imageline($tmp, $this->image_dst_x - $nb + $i, $this->image_dst_y - $nb + $i, $this->image_dst_x - $nb + $i, $nb - $i, $c);\n                                imageline($tmp, $this->image_dst_x - $nb + $i, $this->image_dst_y - $nb + $i, $nb - $i, $this->image_dst_y - $nb + $i, $c);\n                                imageline($tmp, $i, $i, $i, $this->image_dst_y - $i -1, $c);\n                            }\n                        }\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // add bevel border\n                    if ($gd_version >= 2 && $this->image_bevel > 0) {\n                        if (empty($this->image_bevel_color1)) $this->image_bevel_color1 = '#FFFFFF';\n                        if (empty($this->image_bevel_color2)) $this->image_bevel_color2 = '#000000';\n                        list($red1, $green1, $blue1) = $this->getcolors($this->image_bevel_color1);\n                        list($red2, $green2, $blue2) = $this->getcolors($this->image_bevel_color2);\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                        imagecopy($tmp, $image_dst, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y);\n                        imagealphablending($tmp, true);\n                        for ($i=0; $i<$this->image_bevel; $i++) {\n                            $alpha = round(($i / $this->image_bevel) * 127);\n                            $c1 = imagecolorallocatealpha($tmp, $red1, $green1, $blue1, $alpha);\n                            $c2 = imagecolorallocatealpha($tmp, $red2, $green2, $blue2, $alpha);\n                            imageline($tmp, $i, $i, $this->image_dst_x - $i -1, $i, $c1);\n                            imageline($tmp, $this->image_dst_x - $i -1, $this->image_dst_y - $i, $this->image_dst_x - $i -1, $i, $c2);\n                            imageline($tmp, $this->image_dst_x - $i -1, $this->image_dst_y - $i -1, $i, $this->image_dst_y - $i -1, $c2);\n                            imageline($tmp, $i, $i, $i, $this->image_dst_y - $i -1, $c1);\n                        }\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // add watermark image\n                    if ($this->image_watermark!='' && file_exists($this->image_watermark)) {\n                        $this->log .= '- add watermark<br />';\n                        $this->image_watermark_position = strtolower($this->image_watermark_position);\n                        $watermark_info = getimagesize($this->image_watermark);\n                        $watermark_type = (array_key_exists(2, $watermark_info) ? $watermark_info[2] : null); // 1 = GIF, 2 = JPG, 3 = PNG\n                        $watermark_checked = false;\n                        if ($watermark_type == IMAGETYPE_GIF) {\n                            if (!$this->function_enabled('imagecreatefromgif')) {\n                                $this->error = $this->translate('watermark_no_create_support', array('GIF'));\n                            } else {\n                                $filter = @imagecreatefromgif($this->image_watermark);\n                                if (!$filter) {\n                                    $this->error = $this->translate('watermark_create_error', array('GIF'));\n                                } else {\n                                    $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;watermark source image is GIF<br />';\n                                    $watermark_checked = true;\n                                }\n                            }\n                        } else if ($watermark_type == IMAGETYPE_JPEG) {\n                            if (!$this->function_enabled('imagecreatefromjpeg')) {\n                                $this->error = $this->translate('watermark_no_create_support', array('JPEG'));\n                            } else {\n                                $filter = @imagecreatefromjpeg($this->image_watermark);\n                                if (!$filter) {\n                                    $this->error = $this->translate('watermark_create_error', array('JPEG'));\n                                } else {\n                                    $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;watermark source image is JPEG<br />';\n                                    $watermark_checked = true;\n                                }\n                            }\n                        } else if ($watermark_type == IMAGETYPE_PNG) {\n                            if (!$this->function_enabled('imagecreatefrompng')) {\n                                $this->error = $this->translate('watermark_no_create_support', array('PNG'));\n                            } else {\n                                $filter = @imagecreatefrompng($this->image_watermark);\n                                if (!$filter) {\n                                    $this->error = $this->translate('watermark_create_error', array('PNG'));\n                                } else {\n                                    $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;watermark source image is PNG<br />';\n                                    $watermark_checked = true;\n                                }\n                            }\n                        } else if ($watermark_type == IMAGETYPE_BMP) {\n                            if (!method_exists($this, 'imagecreatefrombmp')) {\n                                $this->error = $this->translate('watermark_no_create_support', array('BMP'));\n                            } else {\n                                $filter = @$this->imagecreatefrombmp($this->image_watermark);\n                                if (!$filter) {\n                                    $this->error = $this->translate('watermark_create_error', array('BMP'));\n                                } else {\n                                    $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;watermark source image is BMP<br />';\n                                    $watermark_checked = true;\n                                }\n                            }\n                        } else {\n                            $this->error = $this->translate('watermark_invalid');\n                        }\n                        if ($watermark_checked) {\n                            $watermark_dst_width  = $watermark_src_width  = imagesx($filter);\n                            $watermark_dst_height = $watermark_src_height = imagesy($filter);\n\n                            // if watermark is too large/tall, resize it first\n                            if ((!$this->image_watermark_no_zoom_out && ($watermark_dst_width > $this->image_dst_x || $watermark_dst_height > $this->image_dst_y))\n                             || (!$this->image_watermark_no_zoom_in && $watermark_dst_width < $this->image_dst_x && $watermark_dst_height < $this->image_dst_y)) {\n                                $canvas_width  = $this->image_dst_x - abs($this->image_watermark_x);\n                                $canvas_height = $this->image_dst_y - abs($this->image_watermark_y);\n                                if (($watermark_src_width/$canvas_width) > ($watermark_src_height/$canvas_height)) {\n                                    $watermark_dst_width = $canvas_width;\n                                    $watermark_dst_height = intval($watermark_src_height*($canvas_width / $watermark_src_width));\n                                } else {\n                                    $watermark_dst_height = $canvas_height;\n                                    $watermark_dst_width = intval($watermark_src_width*($canvas_height / $watermark_src_height));\n                                }\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;watermark resized from '.$watermark_src_width.'x'.$watermark_src_height.' to '.$watermark_dst_width.'x'.$watermark_dst_height.'<br />';\n\n                            }\n                            // determine watermark position\n                            $watermark_x = 0;\n                            $watermark_y = 0;\n                            if (is_numeric($this->image_watermark_x)) {\n                                if ($this->image_watermark_x < 0) {\n                                    $watermark_x = $this->image_dst_x - $watermark_dst_width + $this->image_watermark_x;\n                                } else {\n                                    $watermark_x = $this->image_watermark_x;\n                                }\n                            } else {\n                                if (strpos($this->image_watermark_position, 'r') !== false) {\n                                    $watermark_x = $this->image_dst_x - $watermark_dst_width;\n                                } else if (strpos($this->image_watermark_position, 'l') !== false) {\n                                    $watermark_x = 0;\n                                } else {\n                                    $watermark_x = ($this->image_dst_x - $watermark_dst_width) / 2;\n                                }\n                            }\n                            if (is_numeric($this->image_watermark_y)) {\n                                if ($this->image_watermark_y < 0) {\n                                    $watermark_y = $this->image_dst_y - $watermark_dst_height + $this->image_watermark_y;\n                                } else {\n                                    $watermark_y = $this->image_watermark_y;\n                                }\n                            } else {\n                                if (strpos($this->image_watermark_position, 'b') !== false) {\n                                    $watermark_y = $this->image_dst_y - $watermark_dst_height;\n                                } else if (strpos($this->image_watermark_position, 't') !== false) {\n                                    $watermark_y = 0;\n                                } else {\n                                    $watermark_y = ($this->image_dst_y - $watermark_dst_height) / 2;\n                                }\n                            }\n                            imagealphablending($image_dst, true);\n                            imagecopyresampled($image_dst, $filter, $watermark_x, $watermark_y, 0, 0, $watermark_dst_width, $watermark_dst_height, $watermark_src_width, $watermark_src_height);\n                        } else {\n                            $this->error = $this->translate('watermark_invalid');\n                        }\n                    }\n\n                    // add text\n                    if (!empty($this->image_text)) {\n                        $this->log .= '- add text<br />';\n\n                        // calculate sizes in human readable format\n                        $src_size       = $this->file_src_size / 1024;\n                        $src_size_mb    = number_format($src_size / 1024, 1, \".\", \" \");\n                        $src_size_kb    = number_format($src_size, 1, \".\", \" \");\n                        $src_size_human = ($src_size > 1024 ? $src_size_mb . \" MB\" : $src_size_kb . \" kb\");\n\n                        $this->image_text = str_replace(\n                            array('[src_name]',\n                                  '[src_name_body]',\n                                  '[src_name_ext]',\n                                  '[src_pathname]',\n                                  '[src_mime]',\n                                  '[src_size]',\n                                  '[src_size_kb]',\n                                  '[src_size_mb]',\n                                  '[src_size_human]',\n                                  '[src_x]',\n                                  '[src_y]',\n                                  '[src_pixels]',\n                                  '[src_type]',\n                                  '[src_bits]',\n                                  '[dst_path]',\n                                  '[dst_name_body]',\n                                  '[dst_name_ext]',\n                                  '[dst_name]',\n                                  '[dst_pathname]',\n                                  '[dst_x]',\n                                  '[dst_y]',\n                                  '[date]',\n                                  '[time]',\n                                  '[host]',\n                                  '[server]',\n                                  '[ip]',\n                                  '[gd_version]'),\n                            array($this->file_src_name,\n                                  $this->file_src_name_body,\n                                  $this->file_src_name_ext,\n                                  $this->file_src_pathname,\n                                  $this->file_src_mime,\n                                  $this->file_src_size,\n                                  $src_size_kb,\n                                  $src_size_mb,\n                                  $src_size_human,\n                                  $this->image_src_x,\n                                  $this->image_src_y,\n                                  $this->image_src_pixels,\n                                  $this->image_src_type,\n                                  $this->image_src_bits,\n                                  $this->file_dst_path,\n                                  $this->file_dst_name_body,\n                                  $this->file_dst_name_ext,\n                                  $this->file_dst_name,\n                                  $this->file_dst_pathname,\n                                  $this->image_dst_x,\n                                  $this->image_dst_y,\n                                  date('Y-m-d'),\n                                  date('H:i:s'),\n                                  (isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : 'n/a'),\n                                  (isset($_SERVER['SERVER_NAME']) ? $_SERVER['SERVER_NAME'] : 'n/a'),\n                                  (isset($_SERVER['REMOTE_ADDR']) ? $_SERVER['REMOTE_ADDR'] : 'n/a'),\n                                  $this->gdversion(true)),\n                            $this->image_text);\n\n                        if (!is_numeric($this->image_text_padding)) $this->image_text_padding = 0;\n                        if (!is_numeric($this->image_text_line_spacing)) $this->image_text_line_spacing = 0;\n                        if (!is_numeric($this->image_text_padding_x)) $this->image_text_padding_x = $this->image_text_padding;\n                        if (!is_numeric($this->image_text_padding_y)) $this->image_text_padding_y = $this->image_text_padding;\n                        $this->image_text_position = strtolower($this->image_text_position);\n                        $this->image_text_direction = strtolower($this->image_text_direction);\n                        $this->image_text_alignment = strtolower($this->image_text_alignment);\n\n                        $font_type = 'gd';\n\n                        // if the font is a string with a GDF font path, we assume that we might want to load a font\n                        if (!is_numeric($this->image_text_font) && strlen($this->image_text_font) > 4 && substr(strtolower($this->image_text_font), -4) == '.gdf') {\n                            if (strpos($this->image_text_font, '/') === false) $this->image_text_font = \"./\" . $this->image_text_font;\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;try to load font ' . $this->image_text_font . '... ';\n                            if ($this->image_text_font = @imageloadfont($this->image_text_font)) {\n                                $this->log .=  'success<br />';\n                            } else {\n                                $this->log .=  'error<br />';\n                                $this->image_text_font = 5;\n                            }\n                        }\n\n                        // if the font is a string with a TTF font path, we check if we can access the font file\n                        if (!is_numeric($this->image_text_font) && strlen($this->image_text_font) > 4 && substr(strtolower($this->image_text_font), -4) == '.ttf') {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;try to load font ' . $this->image_text_font . '... ';\n                            if (strpos($this->image_text_font, '/') === false) $this->image_text_font = \"./\" . $this->image_text_font;\n                            if (file_exists($this->image_text_font) && is_readable($this->image_text_font)) {\n                                $this->log .=  'success<br />';\n                                $font_type = 'tt';\n                            } else {\n                                $this->log .=  'error<br />';\n                                $this->image_text_font = 5;\n                            }\n                        }\n\n                        // get the text bounding box (GD fonts)\n                        if ($font_type == 'gd') {\n                            $text = explode(\"\\n\", $this->image_text);\n                            $char_width = imagefontwidth($this->image_text_font);\n                            $char_height = imagefontheight($this->image_text_font);\n                            $text_height = 0;\n                            $text_width = 0;\n                            $line_height = 0;\n                            $line_width = 0;\n                            foreach ($text as $k => $v) {\n                                if ($this->image_text_direction == 'v') {\n                                    $h = ($char_width * strlen($v));\n                                    if ($h > $text_height) $text_height = $h;\n                                    $line_width = $char_height;\n                                    $text_width += $line_width + ($k < (sizeof($text)-1) ? $this->image_text_line_spacing : 0);\n                                } else {\n                                    $w = ($char_width * strlen($v));\n                                    if ($w > $text_width) $text_width = $w;\n                                    $line_height = $char_height;\n                                    $text_height += $line_height + ($k < (sizeof($text)-1) ? $this->image_text_line_spacing : 0);\n                                }\n                            }\n                            $text_width  += (2 * $this->image_text_padding_x);\n                            $text_height += (2 * $this->image_text_padding_y);\n\n                        // get the text bounding box (TrueType fonts)\n                        } else if ($font_type == 'tt') {\n                            $text = $this->image_text;\n                            if (!$this->image_text_angle) $this->image_text_angle = $this->image_text_direction == 'v' ? 90 : 0;\n                            $text_height = 0;\n                            $text_width = 0;\n                            $text_offset_x = 0;\n                            $text_offset_y = 0;\n                            $rect = imagettfbbox($this->image_text_size, $this->image_text_angle, $this->image_text_font, $text );\n                            if ($rect) {\n                                $minX = min(array($rect[0],$rect[2],$rect[4],$rect[6]));\n                                $maxX = max(array($rect[0],$rect[2],$rect[4],$rect[6]));\n                                $minY = min(array($rect[1],$rect[3],$rect[5],$rect[7]));\n                                $maxY = max(array($rect[1],$rect[3],$rect[5],$rect[7]));\n                                $text_offset_x = abs($minX) - 1;\n                                $text_offset_y = abs($minY) - 1;\n                                $text_width = $maxX - $minX + (2 * $this->image_text_padding_x);\n                                $text_height = $maxY - $minY + (2 * $this->image_text_padding_y);\n                            }\n                        }\n\n                        // position the text block\n                        $text_x = 0;\n                        $text_y = 0;\n                        if (is_numeric($this->image_text_x)) {\n                            if ($this->image_text_x < 0) {\n                                $text_x = $this->image_dst_x - $text_width + $this->image_text_x;\n                            } else {\n                                $text_x = $this->image_text_x;\n                            }\n                        } else {\n                            if (strpos($this->image_text_position, 'r') !== false) {\n                                $text_x = $this->image_dst_x - $text_width;\n                            } else if (strpos($this->image_text_position, 'l') !== false) {\n                                $text_x = 0;\n                            } else {\n                                $text_x = ($this->image_dst_x - $text_width) / 2;\n                            }\n                        }\n                        if (is_numeric($this->image_text_y)) {\n                            if ($this->image_text_y < 0) {\n                                $text_y = $this->image_dst_y - $text_height + $this->image_text_y;\n                            } else {\n                                $text_y = $this->image_text_y;\n                            }\n                        } else {\n                            if (strpos($this->image_text_position, 'b') !== false) {\n                                $text_y = $this->image_dst_y - $text_height;\n                            } else if (strpos($this->image_text_position, 't') !== false) {\n                                $text_y = 0;\n                            } else {\n                                $text_y = ($this->image_dst_y - $text_height) / 2;\n                            }\n                        }\n\n                        // add a background, maybe transparent\n                        if (!empty($this->image_text_background)) {\n                            list($red, $green, $blue) = $this->getcolors($this->image_text_background);\n                            if ($gd_version >= 2 && (is_numeric($this->image_text_background_opacity)) && $this->image_text_background_opacity >= 0 && $this->image_text_background_opacity <= 100) {\n                                $filter = imagecreatetruecolor($text_width, $text_height);\n                                $background_color = imagecolorallocate($filter, $red, $green, $blue);\n                                imagefilledrectangle($filter, 0, 0, $text_width, $text_height, $background_color);\n                                $this->imagecopymergealpha($image_dst, $filter, $text_x, $text_y, 0, 0, $text_width, $text_height, $this->image_text_background_opacity);\n                                imagedestroy($filter);\n                            } else {\n                                $background_color = imagecolorallocate($image_dst ,$red, $green, $blue);\n                                imagefilledrectangle($image_dst, $text_x, $text_y, $text_x + $text_width, $text_y + $text_height, $background_color);\n                            }\n                        }\n\n                        $text_x += $this->image_text_padding_x;\n                        $text_y += $this->image_text_padding_y;\n                        $t_width = $text_width - (2 * $this->image_text_padding_x);\n                        $t_height = $text_height - (2 * $this->image_text_padding_y);\n                        list($red, $green, $blue) = $this->getcolors($this->image_text_color);\n\n                        // add the text, maybe transparent\n                        if ($gd_version >= 2 && (is_numeric($this->image_text_opacity)) && $this->image_text_opacity >= 0 && $this->image_text_opacity <= 100) {\n                            if ($t_width < 0) $t_width = 0;\n                            if ($t_height < 0) $t_height = 0;\n                            $filter = $this->imagecreatenew($t_width, $t_height, false, true);\n                            $text_color = imagecolorallocate($filter ,$red, $green, $blue);\n\n                            if ($font_type == 'gd') {\n                                foreach ($text as $k => $v) {\n                                    if ($this->image_text_direction == 'v') {\n                                        imagestringup($filter,\n                                                      $this->image_text_font,\n                                                      $k * ($line_width  + ($k > 0 && $k < (sizeof($text)) ? $this->image_text_line_spacing : 0)),\n                                                      $text_height - (2 * $this->image_text_padding_y) - ($this->image_text_alignment == 'l' ? 0 : (($t_height - strlen($v) * $char_width) / ($this->image_text_alignment == 'r' ? 1 : 2))) ,\n                                                      $v,\n                                                      $text_color);\n                                    } else {\n                                        imagestring($filter,\n                                                    $this->image_text_font,\n                                                    ($this->image_text_alignment == 'l' ? 0 : (($t_width - strlen($v) * $char_width) / ($this->image_text_alignment == 'r' ? 1 : 2))),\n                                                    $k * ($line_height  + ($k > 0 && $k < (sizeof($text)) ? $this->image_text_line_spacing : 0)),\n                                                    $v,\n                                                    $text_color);\n                                    }\n                                }\n                            } else if ($font_type == 'tt') {\n                                imagettftext($filter,\n                                             $this->image_text_size,\n                                             $this->image_text_angle,\n                                             $text_offset_x,\n                                             $text_offset_y,\n                                             $text_color,\n                                             $this->image_text_font,\n                                             $text);\n                            }\n                            $this->imagecopymergealpha($image_dst, $filter, $text_x, $text_y, 0, 0, $t_width, $t_height, $this->image_text_opacity);\n                            imagedestroy($filter);\n\n                        } else {\n                            $text_color = imagecolorallocate($image_dst ,$red, $green, $blue);\n                            if ($font_type == 'gd') {\n                                foreach ($text as $k => $v) {\n                                    if ($this->image_text_direction == 'v') {\n                                        imagestringup($image_dst,\n                                                      $this->image_text_font,\n                                                      $text_x + $k * ($line_width  + ($k > 0 && $k < (sizeof($text)) ? $this->image_text_line_spacing : 0)),\n                                                      $text_y + $text_height - (2 * $this->image_text_padding_y) - ($this->image_text_alignment == 'l' ? 0 : (($t_height - strlen($v) * $char_width) / ($this->image_text_alignment == 'r' ? 1 : 2))),\n                                                      $v,\n                                                      $text_color);\n                                    } else {\n                                        imagestring($image_dst,\n                                                    $this->image_text_font,\n                                                    $text_x + ($this->image_text_alignment == 'l' ? 0 : (($t_width - strlen($v) * $char_width) / ($this->image_text_alignment == 'r' ? 1 : 2))),\n                                                    $text_y + $k * ($line_height  + ($k > 0 && $k < (sizeof($text)) ? $this->image_text_line_spacing : 0)),\n                                                    $v,\n                                                    $text_color);\n                                    }\n                                }\n                            } else if ($font_type == 'tt') {\n                                imagettftext($image_dst,\n                                             $this->image_text_size,\n                                             $this->image_text_angle,\n                                             $text_offset_x + ($this->image_dst_x / 2) - ($text_width / 2) + $this->image_text_padding_x,\n                                             $text_offset_y + ($this->image_dst_y / 2) - ($text_height / 2) + $this->image_text_padding_y,\n                                             $text_color,\n                                             $this->image_text_font,\n                                             $text);\n                            }\n                        }\n                    }\n\n                    // add a reflection\n                    if ($this->image_reflection_height) {\n                        $this->log .= '- add reflection : ' . $this->image_reflection_height . '<br />';\n                        // we decode image_reflection_height, which can be a integer, a string in pixels or percentage\n                        $image_reflection_height = $this->image_reflection_height;\n                        if (strpos($image_reflection_height, '%')>0) $image_reflection_height = $this->image_dst_y * (str_replace('%','',$image_reflection_height / 100));\n                        if (strpos($image_reflection_height, 'px')>0) $image_reflection_height = str_replace('px','',$image_reflection_height);\n                        $image_reflection_height = (int) $image_reflection_height;\n                        if ($image_reflection_height > $this->image_dst_y) $image_reflection_height = $this->image_dst_y;\n                        if (empty($this->image_reflection_opacity)) $this->image_reflection_opacity = 60;\n                        // create the new destination image\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y + $image_reflection_height + $this->image_reflection_space, true);\n                        $transparency = $this->image_reflection_opacity;\n\n                        // copy the original image\n                        imagecopy($tmp, $image_dst, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y + ($this->image_reflection_space < 0 ? $this->image_reflection_space : 0));\n\n                        // we have to make sure the extra bit is the right color, or transparent\n                        if ($image_reflection_height + $this->image_reflection_space > 0) {\n                            // use the background color if present\n                            if (!empty($this->image_background_color)) {\n                                list($red, $green, $blue) = $this->getcolors($this->image_background_color);\n                                $fill = imagecolorallocate($tmp, $red, $green, $blue);\n                            } else {\n                                $fill = imagecolorallocatealpha($tmp, 0, 0, 0, 127);\n                            }\n                            // fill in from the edge of the extra bit\n                            imagefill($tmp, round($this->image_dst_x / 2), $this->image_dst_y + $image_reflection_height + $this->image_reflection_space - 1, $fill);\n                        }\n\n                        // copy the reflection\n                        for ($y = 0; $y < $image_reflection_height; $y++) {\n                            for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                $pixel_b = imagecolorsforindex($tmp, imagecolorat($tmp, $x, $y + $this->image_dst_y + $this->image_reflection_space));\n                                $pixel_o = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $this->image_dst_y - $y - 1 + ($this->image_reflection_space < 0 ? $this->image_reflection_space : 0)));\n                                $alpha_o = 1 - ($pixel_o['alpha'] / 127);\n                                $alpha_b = 1 - ($pixel_b['alpha'] / 127);\n                                $opacity = $alpha_o * $transparency / 100;\n                                if ($opacity > 0) {\n                                    $red   = round((($pixel_o['red']   * $opacity) + ($pixel_b['red']  ) * $alpha_b) / ($alpha_b + $opacity));\n                                    $green = round((($pixel_o['green'] * $opacity) + ($pixel_b['green']) * $alpha_b) / ($alpha_b + $opacity));\n                                    $blue  = round((($pixel_o['blue']  * $opacity) + ($pixel_b['blue'] ) * $alpha_b) / ($alpha_b + $opacity));\n                                    $alpha = ($opacity + $alpha_b);\n                                    if ($alpha > 1) $alpha = 1;\n                                    $alpha =  round((1 - $alpha) * 127);\n                                    $color = imagecolorallocatealpha($tmp, $red, $green, $blue, $alpha);\n                                    imagesetpixel($tmp, $x, $y + $this->image_dst_y + $this->image_reflection_space, $color);\n                                }\n                            }\n                            if ($transparency > 0) $transparency = $transparency - ($this->image_reflection_opacity / $image_reflection_height);\n                        }\n\n                        // copy the resulting image into the destination image\n                        $this->image_dst_y = $this->image_dst_y + $image_reflection_height + $this->image_reflection_space;\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // change opacity\n                    if ($gd_version >= 2 && is_numeric($this->image_opacity) && $this->image_opacity < 100) {\n                        $this->log .= '- change opacity<br />';\n                        // create the new destination image\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y, true);\n                        for($y=0; $y < $this->image_dst_y; $y++) {\n                            for($x=0; $x < $this->image_dst_x; $x++) {\n                                $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                $alpha = $pixel['alpha'] + round((127 - $pixel['alpha']) * (100 - $this->image_opacity) / 100);\n                                if ($alpha > 127) $alpha = 127;\n                                if ($alpha > 0) {\n                                    $color = imagecolorallocatealpha($tmp, $pixel['red'] , $pixel['green'], $pixel['blue'], $alpha);\n                                    imagesetpixel($tmp, $x, $y, $color);\n                                }\n                            }\n                        }\n                        // copy the resulting image into the destination image\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // reduce the JPEG image to a set desired size\n                    if (is_numeric($this->jpeg_size) && $this->jpeg_size > 0 && ($this->image_convert == 'jpeg' || $this->image_convert == 'jpg')) {\n                        // inspired by: JPEGReducer class version 1, 25 November 2004, Author: Huda M ElMatsani, justhuda at netscape dot net\n                        $this->log .= '- JPEG desired file size : ' . $this->jpeg_size . '<br />';\n                        // calculate size of each image. 75%, 50%, and 25% quality\n                        ob_start(); imagejpeg($image_dst,null,75);  $buffer = ob_get_contents(); ob_end_clean();\n                        $size75 = strlen($buffer);\n                        ob_start(); imagejpeg($image_dst,null,50);  $buffer = ob_get_contents(); ob_end_clean();\n                        $size50 = strlen($buffer);\n                        ob_start(); imagejpeg($image_dst,null,25);  $buffer = ob_get_contents(); ob_end_clean();\n                        $size25 = strlen($buffer);\n\n                        // make sure we won't divide by 0\n                        if ($size50 == $size25) $size50++;\n                        if ($size75 == $size50 || $size75 == $size25) $size75++;\n\n                        // calculate gradient of size reduction by quality\n                        $mgrad1 = 25 / ($size50-$size25);\n                        $mgrad2 = 25 / ($size75-$size50);\n                        $mgrad3 = 50 / ($size75-$size25);\n                        $mgrad  = ($mgrad1 + $mgrad2 + $mgrad3) / 3;\n                        // result of approx. quality factor for expected size\n                        $q_factor = round($mgrad * ($this->jpeg_size - $size50) + 50);\n\n                        if ($q_factor<1) {\n                            $this->jpeg_quality=1;\n                        } elseif ($q_factor>100) {\n                            $this->jpeg_quality=100;\n                        } else {\n                            $this->jpeg_quality=$q_factor;\n                        }\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;JPEG quality factor set to ' . $this->jpeg_quality . '<br />';\n                    }\n\n                    // converts image from true color, and fix transparency if needed\n                    $this->log .= '- converting...<br />';\n                    $this->image_dst_type = $this->image_convert;\n                    switch($this->image_convert) {\n                        case 'gif':\n                            // if the image is true color, we convert it to a palette\n                            if (imageistruecolor($image_dst)) {\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;true color to palette<br />';\n                                // creates a black and white mask\n                                $mask = array(array());\n                                for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                    for ($y = 0; $y < $this->image_dst_y; $y++) {\n                                        $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                        $mask[$x][$y] = $pixel['alpha'];\n                                    }\n                                }\n                                list($red, $green, $blue) = $this->getcolors($this->image_default_color);\n                                // first, we merge the image with the background color, so we know which colors we will have\n                                for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                    for ($y = 0; $y < $this->image_dst_y; $y++) {\n                                        if ($mask[$x][$y] > 0){\n                                            // we have some transparency. we combine the color with the default color\n                                            $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                            $alpha = ($mask[$x][$y] / 127);\n                                            $pixel['red'] = round(($pixel['red'] * (1 -$alpha) + $red * ($alpha)));\n                                            $pixel['green'] = round(($pixel['green'] * (1 -$alpha) + $green * ($alpha)));\n                                            $pixel['blue'] = round(($pixel['blue'] * (1 -$alpha) + $blue * ($alpha)));\n                                            $color = imagecolorallocate($image_dst, $pixel['red'], $pixel['green'], $pixel['blue']);\n                                            imagesetpixel($image_dst, $x, $y, $color);\n                                        }\n                                    }\n                                }\n                                // transforms the true color image into palette, with its merged default color\n                                if (empty($this->image_background_color)) {\n                                    imagetruecolortopalette($image_dst, true, 255);\n                                    $transparency = imagecolorallocate($image_dst, 254, 1, 253);\n                                    imagecolortransparent($image_dst, $transparency);\n                                    // make the transparent areas transparent\n                                    for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                        for ($y = 0; $y < $this->image_dst_y; $y++) {\n                                            // we test wether we have enough opacity to justify keeping the color\n                                            if ($mask[$x][$y] > 120) imagesetpixel($image_dst, $x, $y, $transparency);\n                                        }\n                                    }\n                                }\n                                unset($mask);\n                            }\n                            break;\n                        case 'jpg':\n                        case 'bmp':\n                            // if the image doesn't support any transparency, then we merge it with the default color\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;fills in transparency with default color<br />';\n                            list($red, $green, $blue) = $this->getcolors($this->image_default_color);\n                            $transparency = imagecolorallocate($image_dst, $red, $green, $blue);\n                            // make the transaparent areas transparent\n                            for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                for ($y = 0; $y < $this->image_dst_y; $y++) {\n                                    // we test wether we have some transparency, in which case we will merge the colors\n                                    if (imageistruecolor($image_dst)) {\n                                        $rgba = imagecolorat($image_dst, $x, $y);\n                                        $pixel = array('red' => ($rgba >> 16) & 0xFF,\n                                                       'green' => ($rgba >> 8) & 0xFF,\n                                                       'blue' => $rgba & 0xFF,\n                                                       'alpha' => ($rgba & 0x7F000000) >> 24);\n                                    } else {\n                                        $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    }\n                                    if ($pixel['alpha'] == 127) {\n                                        // we have full transparency. we make the pixel transparent\n                                        imagesetpixel($image_dst, $x, $y, $transparency);\n                                    } else if ($pixel['alpha'] > 0) {\n                                        // we have some transparency. we combine the color with the default color\n                                        $alpha = ($pixel['alpha'] / 127);\n                                        $pixel['red'] = round(($pixel['red'] * (1 -$alpha) + $red * ($alpha)));\n                                        $pixel['green'] = round(($pixel['green'] * (1 -$alpha) + $green * ($alpha)));\n                                        $pixel['blue'] = round(($pixel['blue'] * (1 -$alpha) + $blue * ($alpha)));\n                                        $color = imagecolorclosest($image_dst, $pixel['red'], $pixel['green'], $pixel['blue']);\n                                        imagesetpixel($image_dst, $x, $y, $color);\n                                    }\n                                }\n                            }\n\n                            break;\n                        default:\n                            break;\n                    }\n\n                    // interlace options\n                    if($this->image_interlace) imageinterlace($image_dst, true);\n\n                    // outputs image\n                    $this->log .= '- saving image...<br />';\n                    switch($this->image_convert) {\n                        case 'jpeg':\n                        case 'jpg':\n                            if (!$return_mode) {\n                                $result = @imagejpeg($image_dst, $this->file_dst_pathname, $this->jpeg_quality);\n                            } else {\n                                ob_start();\n                                $result = @imagejpeg($image_dst, null, $this->jpeg_quality);\n                                $return_content = ob_get_contents();\n                                ob_end_clean();\n                            }\n                            if (!$result) {\n                                $this->processed = false;\n                                $this->error = $this->translate('file_create', array('JPEG'));\n                            } else {\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;JPEG image created<br />';\n                            }\n                            break;\n                        case 'png':\n                            imagealphablending( $image_dst, false );\n                            imagesavealpha( $image_dst, true );\n                            if (!$return_mode) {\n                                if (is_numeric($this->png_compression) && version_compare(PHP_VERSION, '5.1.2') >= 0) {\n                                    $result = @imagepng($image_dst, $this->file_dst_pathname, $this->png_compression);\n                                } else {\n                                    $result = @imagepng($image_dst, $this->file_dst_pathname);\n                                }\n                            } else {\n                                ob_start();\n                                if (is_numeric($this->png_compression) && version_compare(PHP_VERSION, '5.1.2') >= 0) {\n                                    $result = @imagepng($image_dst, null, $this->png_compression);\n                                } else {\n                                    $result = @imagepng($image_dst);\n                                }\n                                $return_content = ob_get_contents();\n                                ob_end_clean();\n                            }\n                            if (!$result) {\n                                $this->processed = false;\n                                $this->error = $this->translate('file_create', array('PNG'));\n                            } else {\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;PNG image created<br />';\n                            }\n                            break;\n                        case 'gif':\n                            if (!$return_mode) {\n                                $result = @imagegif($image_dst, $this->file_dst_pathname);\n                            } else {\n                                ob_start();\n                                $result = @imagegif($image_dst);\n                                $return_content = ob_get_contents();\n                                ob_end_clean();\n                            }\n                            if (!$result) {\n                                $this->processed = false;\n                                $this->error = $this->translate('file_create', array('GIF'));\n                            } else {\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;GIF image created<br />';\n                            }\n                            break;\n                        case 'bmp':\n                            if (!$return_mode) {\n                                $result = $this->imagebmp($image_dst, $this->file_dst_pathname);\n                            } else {\n                                ob_start();\n                                $result = $this->imagebmp($image_dst);\n                                $return_content = ob_get_contents();\n                                ob_end_clean();\n                            }\n                            if (!$result) {\n                                $this->processed = false;\n                                $this->error = $this->translate('file_create', array('BMP'));\n                            } else {\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;BMP image created<br />';\n                            }\n                            break;\n\n                        default:\n                            $this->processed = false;\n                            $this->error = $this->translate('no_conversion_type');\n                    }\n                    if ($this->processed) {\n                        if (is_resource($image_src)) imagedestroy($image_src);\n                        if (is_resource($image_dst)) imagedestroy($image_dst);\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image objects destroyed<br />';\n                    }\n                }\n\n            } else {\n                $this->log .= '- no image processing wanted<br />';\n\n                if (!$return_mode) {\n                    // copy the file to its final destination. we don't use move_uploaded_file here\n                    // if we happen to have open_basedir restrictions, it is a temp file that we copy, not the original uploaded file\n                    if (!copy($this->file_src_pathname, $this->file_dst_pathname)) {\n                        $this->processed = false;\n                        $this->error = $this->translate('copy_failed');\n                    }\n                } else {\n                    // returns the file, so that its content can be received by the caller\n                    $return_content = @file_get_contents($this->file_src_pathname);\n                    if ($return_content === FALSE) {\n                        $this->processed = false;\n                        $this->error = $this->translate('reading_failed');\n                    }\n                }\n            }\n        }\n\n        if ($this->processed) {\n            $this->log .= '- <b>process OK</b><br />';\n        } else {\n            $this->log .= '- <b>error</b>: ' . $this->error . '<br />';\n        }\n\n        // we reinit all the vars\n        $this->init();\n\n        // we may return the image content\n        if ($return_mode) return $return_content;\n\n    }\n\n    /**\n     * Deletes the uploaded file from its temporary location\n     *\n     * When PHP uploads a file, it stores it in a temporary location.\n     * When you {@link process} the file, you actually copy the resulting file to the given location, it doesn't alter the original file.\n     * Once you have processed the file as many times as you wanted, you can delete the uploaded file.\n     * If there is open_basedir restrictions, the uploaded file is in fact a temporary file\n     *\n     * You might want not to use this function if you work on local files, as it will delete the source file\n     *\n     * @access public\n     */\n    function clean() {\n        $this->log .= '<b>cleanup</b><br />';\n        $this->log .= '- delete temp file '  . $this->file_src_pathname . '<br />';\n        @unlink($this->file_src_pathname);\n    }\n\n\n    /**\n     * Opens a BMP image\n     *\n     * This function has been written by DHKold, and is used with permission of the author\n     *\n     * @access public\n     */\n    function imagecreatefrombmp($filename) {\n        if (! $f1 = fopen($filename,\"rb\")) return false;\n\n        $file = unpack(\"vfile_type/Vfile_size/Vreserved/Vbitmap_offset\", fread($f1,14));\n        if ($file['file_type'] != 19778) return false;\n\n        $bmp = unpack('Vheader_size/Vwidth/Vheight/vplanes/vbits_per_pixel'.\n                      '/Vcompression/Vsize_bitmap/Vhoriz_resolution'.\n                      '/Vvert_resolution/Vcolors_used/Vcolors_important', fread($f1,40));\n        $bmp['colors'] = pow(2,$bmp['bits_per_pixel']);\n        if ($bmp['size_bitmap'] == 0) $bmp['size_bitmap'] = $file['file_size'] - $file['bitmap_offset'];\n        $bmp['bytes_per_pixel'] = $bmp['bits_per_pixel']/8;\n        $bmp['bytes_per_pixel2'] = ceil($bmp['bytes_per_pixel']);\n        $bmp['decal'] = ($bmp['width']*$bmp['bytes_per_pixel']/4);\n        $bmp['decal'] -= floor($bmp['width']*$bmp['bytes_per_pixel']/4);\n        $bmp['decal'] = 4-(4*$bmp['decal']);\n        if ($bmp['decal'] == 4) $bmp['decal'] = 0;\n\n        $palette = array();\n        if ($bmp['colors'] < 16777216) {\n            $palette = unpack('V'.$bmp['colors'], fread($f1,$bmp['colors']*4));\n        }\n\n        $im = fread($f1,$bmp['size_bitmap']);\n        $vide = chr(0);\n\n        $res = imagecreatetruecolor($bmp['width'],$bmp['height']);\n        $P = 0;\n        $Y = $bmp['height']-1;\n        while ($Y >= 0) {\n            $X=0;\n            while ($X < $bmp['width']) {\n                if ($bmp['bits_per_pixel'] == 24)\n                    $color = unpack(\"V\",substr($im,$P,3).$vide);\n                elseif ($bmp['bits_per_pixel'] == 16) {\n                    $color = unpack(\"n\",substr($im,$P,2));\n                    $color[1] = $palette[$color[1]+1];\n                } elseif ($bmp['bits_per_pixel'] == 8) {\n                    $color = unpack(\"n\",$vide.substr($im,$P,1));\n                    $color[1] = $palette[$color[1]+1];\n                } elseif ($bmp['bits_per_pixel'] == 4) {\n                    $color = unpack(\"n\",$vide.substr($im,floor($P),1));\n                    if (($P*2)%2 == 0) $color[1] = ($color[1] >> 4) ; else $color[1] = ($color[1] & 0x0F);\n                    $color[1] = $palette[$color[1]+1];\n                } elseif ($bmp['bits_per_pixel'] == 1)  {\n                    $color = unpack(\"n\",$vide.substr($im,floor($P),1));\n                    if     (($P*8)%8 == 0) $color[1] =  $color[1]        >>7;\n                    elseif (($P*8)%8 == 1) $color[1] = ($color[1] & 0x40)>>6;\n                    elseif (($P*8)%8 == 2) $color[1] = ($color[1] & 0x20)>>5;\n                    elseif (($P*8)%8 == 3) $color[1] = ($color[1] & 0x10)>>4;\n                    elseif (($P*8)%8 == 4) $color[1] = ($color[1] & 0x8)>>3;\n                    elseif (($P*8)%8 == 5) $color[1] = ($color[1] & 0x4)>>2;\n                    elseif (($P*8)%8 == 6) $color[1] = ($color[1] & 0x2)>>1;\n                    elseif (($P*8)%8 == 7) $color[1] = ($color[1] & 0x1);\n                    $color[1] = $palette[$color[1]+1];\n                } else\n                    return FALSE;\n                imagesetpixel($res,$X,$Y,$color[1]);\n                $X++;\n                $P += $bmp['bytes_per_pixel'];\n            }\n            $Y--;\n            $P+=$bmp['decal'];\n        }\n        fclose($f1);\n        return $res;\n    }\n\n    /**\n     * Saves a BMP image\n     *\n     * This function has been published on the PHP website, and can be used freely\n     *\n     * @access public\n     */\n    function imagebmp(&$im, $filename = \"\") {\n\n        if (!$im) return false;\n        $w = imagesx($im);\n        $h = imagesy($im);\n        $result = '';\n\n        // if the image is not true color, we convert it first\n        if (!imageistruecolor($im)) {\n            $tmp = imagecreatetruecolor($w, $h);\n            imagecopy($tmp, $im, 0, 0, 0, 0, $w, $h);\n            imagedestroy($im);\n            $im = & $tmp;\n        }\n\n        $biBPLine = $w * 3;\n        $biStride = ($biBPLine + 3) & ~3;\n        $biSizeImage = $biStride * $h;\n        $bfOffBits = 54;\n        $bfSize = $bfOffBits + $biSizeImage;\n\n        $result .= substr('BM', 0, 2);\n        $result .=  pack ('VvvV', $bfSize, 0, 0, $bfOffBits);\n        $result .= pack ('VVVvvVVVVVV', 40, $w, $h, 1, 24, 0, $biSizeImage, 0, 0, 0, 0);\n\n        $numpad = $biStride - $biBPLine;\n        for ($y = $h - 1; $y >= 0; --$y) {\n            for ($x = 0; $x < $w; ++$x) {\n                $col = imagecolorat ($im, $x, $y);\n                $result .=  substr(pack ('V', $col), 0, 3);\n            }\n            for ($i = 0; $i < $numpad; ++$i)\n                $result .= pack ('C', 0);\n        }\n\n        if($filename==\"\"){\n            echo $result;\n        } else {\n            $file = fopen($filename, \"wb\");\n            fwrite($file, $result);\n            fclose($file);\n        }\n        return true;\n    }\n}\n\n?>\n"], "fixing_code": ["<?php\n// +------------------------------------------------------------------------+\n// | class.upload.php                                                       |\n// +------------------------------------------------------------------------+\n// | Copyright (c) Colin Verot 2003-2014. All rights reserved.              |\n// | Email         colin@verot.net                                          |\n// | Web           http://www.verot.net                                     |\n// +------------------------------------------------------------------------+\n// | This program is free software; you can redistribute it and/or modify   |\n// | it under the terms of the GNU General Public License version 2 as      |\n// | published by the Free Software Foundation.                             |\n// |                                                                        |\n// | This program is distributed in the hope that it will be useful,        |\n// | but WITHOUT ANY WARRANTY; without even the implied warranty of         |\n// | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          |\n// | GNU General Public License for more details.                           |\n// |                                                                        |\n// | You should have received a copy of the GNU General Public License      |\n// | along with this program; if not, write to the                          |\n// |   Free Software Foundation, Inc., 59 Temple Place, Suite 330,          |\n// |   Boston, MA 02111-1307 USA                                            |\n// |                                                                        |\n// | Please give credit on sites that use class.upload and submit changes   |\n// | of the script so other people can use them as well.                    |\n// | This script is free to use, don't abuse.                               |\n// +------------------------------------------------------------------------+\n\n\n/**\n * Class upload\n *\n * @author    Colin Verot <colin@verot.net>\n * @license   http://opensource.org/licenses/gpl-license.php GNU Public License\n * @copyright Colin Verot\n */\nclass upload {\n\n\n    /**\n     * Class version\n     *\n     * @access public\n     * @var string\n     */\n    var $version;\n\n    /**\n     * Uploaded file name\n     *\n     * @access public\n     * @var string\n     */\n    var $file_src_name;\n\n    /**\n     * Uploaded file name body (i.e. without extension)\n     *\n     * @access public\n     * @var string\n     */\n    var $file_src_name_body;\n\n    /**\n     * Uploaded file name extension\n     *\n     * @access public\n     * @var string\n     */\n    var $file_src_name_ext;\n\n    /**\n     * Uploaded file MIME type\n     *\n     * @access public\n     * @var string\n     */\n    var $file_src_mime;\n\n    /**\n     * Uploaded file size, in bytes\n     *\n     * @access public\n     * @var double\n     */\n    var $file_src_size;\n\n    /**\n     * Holds eventual PHP error code from $_FILES\n     *\n     * @access public\n     * @var string\n     */\n    var $file_src_error;\n\n    /**\n     * Uloaded file name, including server path\n     *\n     * @access public\n     * @var string\n     */\n    var $file_src_pathname;\n\n    /**\n     * Uloaded file name temporary copy\n     *\n     * @access private\n     * @var string\n     */\n    var $file_src_temp;\n\n    /**\n     * Destination file name\n     *\n     * @access public\n     * @var string\n     */\n    var $file_dst_path;\n\n    /**\n     * Destination file name\n     *\n     * @access public\n     * @var string\n     */\n    var $file_dst_name;\n\n    /**\n     * Destination file name body (i.e. without extension)\n     *\n     * @access public\n     * @var string\n     */\n    var $file_dst_name_body;\n\n    /**\n     * Destination file extension\n     *\n     * @access public\n     * @var string\n     */\n    var $file_dst_name_ext;\n\n    /**\n     * Destination file name, including path\n     *\n     * @access public\n     * @var string\n     */\n    var $file_dst_pathname;\n\n    /**\n     * Source image width\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_src_x;\n\n    /**\n     * Source image height\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_src_y;\n\n    /**\n     * Source image color depth\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_src_bits;\n\n    /**\n     * Number of pixels\n     *\n     * @access public\n     * @var long\n     */\n    var $image_src_pixels;\n\n    /**\n     * Type of image (png, gif, jpg or bmp)\n     *\n     * @access public\n     * @var string\n     */\n    var $image_src_type;\n\n    /**\n     * Destination image width\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_dst_x;\n\n    /**\n     * Destination image height\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_dst_y;\n\n    /**\n     * Destination image type (png, gif, jpg or bmp)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_dst_type;\n\n    /**\n     * Supported image formats\n     *\n     * @access private\n     * @var array\n     */\n    var $image_supported;\n\n    /**\n     * Flag to determine if the source file is an image\n     *\n     * @access public\n     * @var boolean\n     */\n    var $file_is_image;\n\n    /**\n     * Flag set after instanciating the class\n     *\n     * Indicates if the file has been uploaded properly\n     *\n     * @access public\n     * @var bool\n     */\n    var $uploaded;\n\n    /**\n     * Flag stopping PHP upload checks\n     *\n     * Indicates whether we instanciated the class with a filename, in which case\n     * we will not check on the validity of the PHP *upload*\n     *\n     * This flag is automatically set to true when working on a local file\n     *\n     * Warning: for uploads, this flag MUST be set to false for security reason\n     *\n     * @access public\n     * @var bool\n     */\n    var $no_upload_check;\n\n    /**\n     * Flag set after calling a process\n     *\n     * Indicates if the processing, and copy of the resulting file went OK\n     *\n     * @access public\n     * @var bool\n     */\n    var $processed;\n\n    /**\n     * Holds eventual error message in plain english\n     *\n     * @access public\n     * @var string\n     */\n    var $error;\n\n    /**\n     * Holds an HTML formatted log\n     *\n     * @access public\n     * @var string\n     */\n    var $log;\n\n\n    // overiddable processing variables\n\n\n    /**\n     * Set this variable to replace the name body (i.e. without extension)\n     *\n     * @access public\n     * @var string\n     */\n    var $file_new_name_body;\n\n    /**\n     * Set this variable to append a string to the file name body\n     *\n     * @access public\n     * @var string\n     */\n    var $file_name_body_add;\n\n    /**\n     * Set this variable to prepend a string to the file name body\n     *\n     * @access public\n     * @var string\n     */\n    var $file_name_body_pre;\n\n    /**\n     * Set this variable to change the file extension\n     *\n     * @access public\n     * @var string\n     */\n    var $file_new_name_ext;\n\n    /**\n     * Set this variable to format the filename (spaces changed to _)\n     *\n     * @access public\n     * @var boolean\n     */\n    var $file_safe_name;\n\n    /**\n     * Forces an extension if the source file doesn't have one\n     *\n     * If the file is an image, then the correct extension will be added\n     * Otherwise, a .txt extension will be chosen\n     *\n     * @access public\n     * @var boolean\n     */\n    var $file_force_extension;\n\n    /**\n     * Set this variable to false if you don't want to check the MIME against the allowed list\n     *\n     * This variable is set to true by default for security reason\n     *\n     * @access public\n     * @var boolean\n     */\n    var $mime_check;\n\n    /**\n     * Set this variable to false in the init() function if you don't want to check the MIME\n     * with Fileinfo PECL extension. On some systems, Fileinfo is known to be buggy, and you\n     * may want to deactivate it in the class code directly.\n     *\n     * You can also set it with the path of the magic database file.\n     * If set to true, the class will try to read the MAGIC environment variable\n     *   and if it is empty, will default to the system's default\n     * If set to an empty string, it will call finfo_open without the path argument\n     *\n     * This variable is set to true by default for security reason\n     *\n     * @access public\n     * @var boolean\n     */\n    var $mime_fileinfo;\n\n    /**\n     * Set this variable to false in the init() function if you don't want to check the MIME\n     * with UNIX file() command\n     *\n     * This variable is set to true by default for security reason\n     *\n     * @access public\n     * @var boolean\n     */\n    var $mime_file;\n\n    /**\n     * Set this variable to false in the init() function if you don't want to check the MIME\n     * with the magic.mime file\n     *\n     * The function mime_content_type() will be deprecated,\n     * and this variable will be set to false in a future release\n     *\n     * This variable is set to true by default for security reason\n     *\n     * @access public\n     * @var boolean\n     */\n    var $mime_magic;\n\n    /**\n     * Set this variable to false in the init() function if you don't want to check the MIME\n     * with getimagesize()\n     *\n     * The class tries to get a MIME type from getimagesize()\n     * If no MIME is returned, it tries to guess the MIME type from the file type\n     *\n     * This variable is set to true by default for security reason\n     *\n     * @access public\n     * @var boolean\n     */\n    var $mime_getimagesize;\n\n    /**\n     * Set this variable to false if you don't want to turn dangerous scripts into simple text files\n     *\n     * @access public\n     * @var boolean\n     */\n    var $no_script;\n\n    /**\n     * Set this variable to true to allow automatic renaming of the file\n     * if the file already exists\n     *\n     * Default value is true\n     *\n     * For instance, on uploading foo.ext,<br>\n     * if foo.ext already exists, upload will be renamed foo_1.ext<br>\n     * and if foo_1.ext already exists, upload will be renamed foo_2.ext<br>\n     *\n     * Note that this option doesn't have any effect if {@link file_overwrite} is true\n     *\n     * @access public\n     * @var bool\n     */\n    var $file_auto_rename;\n\n    /**\n     * Set this variable to true to allow automatic creation of the destination\n     * directory if it is missing (works recursively)\n     *\n     * Default value is true\n     *\n     * @access public\n     * @var bool\n     */\n    var $dir_auto_create;\n\n    /**\n     * Set this variable to true to allow automatic chmod of the destination\n     * directory if it is not writeable\n     *\n     * Default value is true\n     *\n     * @access public\n     * @var bool\n     */\n    var $dir_auto_chmod;\n\n    /**\n     * Set this variable to the default chmod you want the class to use\n     * when creating directories, or attempting to write in a directory\n     *\n     * Default value is 0755 (without quotes)\n     *\n     * @access public\n     * @var bool\n     */\n    var $dir_chmod;\n\n    /**\n     * Set this variable tu true to allow overwriting of an existing file\n     *\n     * Default value is false, so no files will be overwritten\n     *\n     * @access public\n     * @var bool\n     */\n    var $file_overwrite;\n\n    /**\n     * Set this variable to change the maximum size in bytes for an uploaded file\n     *\n     * Default value is the value <i>upload_max_filesize</i> from php.ini\n     *\n     * Value in bytes (integer) or shorthand byte values (string) is allowed.\n     * The available options are K (for Kilobytes), M (for Megabytes) and G (for Gigabytes)\n     *\n     * @access public\n     * @var double\n     */\n    var $file_max_size;\n\n    /**\n     * Set this variable to true to resize the file if it is an image\n     *\n     * You will probably want to set {@link image_x} and {@link image_y}, and maybe one of the ratio variables\n     *\n     * Default value is false (no resizing)\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_resize;\n\n    /**\n     * Set this variable to convert the file if it is an image\n     *\n     * Possibles values are : ''; 'png'; 'jpeg'; 'gif'; 'bmp'\n     *\n     * Default value is '' (no conversion)<br>\n     * If {@link resize} is true, {@link convert} will be set to the source file extension\n     *\n     * @access public\n     * @var string\n     */\n    var $image_convert;\n\n    /**\n     * Set this variable to the wanted (or maximum/minimum) width for the processed image, in pixels\n     *\n     * Default value is 150\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_x;\n\n    /**\n     * Set this variable to the wanted (or maximum/minimum) height for the processed image, in pixels\n     *\n     * Default value is 150\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_y;\n\n    /**\n     * Set this variable to keep the original size ratio to fit within {@link image_x} x {@link image_y}\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_ratio;\n\n    /**\n     * Set this variable to keep the original size ratio to fit within {@link image_x} x {@link image_y}\n     *\n     * The image will be resized as to fill the whole space, and excedent will be cropped\n     *\n     * Value can also be a string, one or more character from 'TBLR' (top, bottom, left and right)\n     * If set as a string, it determines which side of the image is kept while cropping.\n     * By default, the part of the image kept is in the center, i.e. it crops equally on both sides\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var mixed\n     */\n    var $image_ratio_crop;\n\n    /**\n     * Set this variable to keep the original size ratio to fit within {@link image_x} x {@link image_y}\n     *\n     * The image will be resized to fit entirely in the space, and the rest will be colored.\n     * The default color is white, but can be set with {@link image_default_color}\n     *\n     * Value can also be a string, one or more character from 'TBLR' (top, bottom, left and right)\n     * If set as a string, it determines in which side of the space the image is displayed.\n     * By default, the image is displayed in the center, i.e. it fills the remaining space equally on both sides\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var mixed\n     */\n    var $image_ratio_fill;\n\n    /**\n     * Set this variable to a number of pixels so that {@link image_x} and {@link image_y} are the best match possible\n     *\n     * The image will be resized to have approximatively the number of pixels\n     * The aspect ratio wil be conserved\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var mixed\n     */\n    var $image_ratio_pixels;\n\n    /**\n     * Set this variable to calculate {@link image_x} automatically , using {@link image_y} and conserving ratio\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_ratio_x;\n\n    /**\n     * Set this variable to calculate {@link image_y} automatically , using {@link image_x} and conserving ratio\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_ratio_y;\n\n    /**\n     * (deprecated) Set this variable to keep the original size ratio to fit within {@link image_x} x {@link image_y},\n     * but only if original image is bigger\n     *\n     * This setting is soon to be deprecated. Instead, use {@link image_ratio} and {@link image_no_enlarging}\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_ratio_no_zoom_in;\n\n    /**\n     * (deprecated) Set this variable to keep the original size ratio to fit within {@link image_x} x {@link image_y},\n     * but only if original image is smaller\n     *\n     * Default value is false\n     *\n     * This setting is soon to be deprecated. Instead, use {@link image_ratio} and {@link image_no_shrinking}\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_ratio_no_zoom_out;\n\n    /**\n     * Cancel resizing if the resized image is bigger than the original image, to prevent enlarging\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_no_enlarging;\n\n    /**\n     * Cancel resizing if the resized image is smaller than the original image, to prevent shrinking\n     *\n     * Default value is false\n     *\n     * @access public\n     * @var bool\n     */\n    var $image_no_shrinking;\n\n    /**\n     * Set this variable to set a maximum image width, above which the upload will be invalid\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_max_width;\n\n    /**\n     * Set this variable to set a maximum image height, above which the upload will be invalid\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_max_height;\n\n    /**\n     * Set this variable to set a maximum number of pixels for an image, above which the upload will be invalid\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var long\n     */\n    var $image_max_pixels;\n\n    /**\n     * Set this variable to set a maximum image aspect ratio, above which the upload will be invalid\n     *\n     * Note that ratio = width / height\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var float\n     */\n    var $image_max_ratio;\n\n    /**\n     * Set this variable to set a minimum image width, below which the upload will be invalid\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_min_width;\n\n    /**\n     * Set this variable to set a minimum image height, below which the upload will be invalid\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_min_height;\n\n    /**\n     * Set this variable to set a minimum number of pixels for an image, below which the upload will be invalid\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var long\n     */\n    var $image_min_pixels;\n\n    /**\n     * Set this variable to set a minimum image aspect ratio, below which the upload will be invalid\n     *\n     * Note that ratio = width / height\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var float\n     */\n    var $image_min_ratio;\n\n    /**\n     * Compression level for PNG images\n     *\n     * Between 1 (fast but large files) and 9 (slow but smaller files)\n     *\n     * Default value is null (Zlib default)\n     *\n     * @access public\n     * @var integer\n     */\n    var $png_compression;\n\n    /**\n     * Quality of JPEG created/converted destination image\n     *\n     * Default value is 85\n     *\n     * @access public\n     * @var integer\n     */\n    var $jpeg_quality;\n\n    /**\n     * Determines the quality of the JPG image to fit a desired file size\n     *\n     * The JPG quality will be set between 1 and 100%\n     * The calculations are approximations.\n     *\n     * Value in bytes (integer) or shorthand byte values (string) is allowed.\n     * The available options are K (for Kilobytes), M (for Megabytes) and G (for Gigabytes)\n     *\n     * Default value is null (no calculations)\n     *\n     * @access public\n     * @var integer\n     */\n    var $jpeg_size;\n\n    /**\n     * Turns the interlace bit on\n     *\n     * This is actually used only for JPEG images, and defaults to false\n     *\n     * @access public\n     * @var boolean\n     */\n    var $image_interlace;\n\n    /**\n     * Flag set to true when the image is transparent\n     *\n     * This is actually used only for transparent GIFs\n     *\n     * @access public\n     * @var boolean\n     */\n    var $image_is_transparent;\n\n    /**\n     * Transparent color in a palette\n     *\n     * This is actually used only for transparent GIFs\n     *\n     * @access public\n     * @var boolean\n     */\n    var $image_transparent_color;\n\n    /**\n     * Background color, used to paint transparent areas with\n     *\n     * If set, it will forcibly remove transparency by painting transparent areas with the color\n     * This setting will fill in all transparent areas in PNG and GIF, as opposed to {@link image_default_color}\n     * which will do so only in BMP, JPEG, and alpha transparent areas in transparent GIFs\n     * This setting overrides {@link image_default_color}\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var string\n     */\n    var $image_background_color;\n\n    /**\n     * Default color for non alpha-transparent images\n     *\n     * This setting is to be used to define a background color for semi transparent areas\n     * of an alpha transparent when the output format doesn't support alpha transparency\n     * This is useful when, from an alpha transparent PNG image, or an image with alpha transparent features\n     * if you want to output it as a transparent GIFs for instance, you can set a blending color for transparent areas\n     * If you output in JPEG or BMP, this color will be used to fill in the previously transparent areas\n     *\n     * The default color white\n     *\n     * @access public\n     * @var boolean\n     */\n    var $image_default_color;\n\n    /**\n     * Flag set to true when the image is not true color\n     *\n     * @access public\n     * @var boolean\n     */\n    var $image_is_palette;\n\n    /**\n     * Corrects the image brightness\n     *\n     * Value can range between -127 and 127\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_brightness;\n\n    /**\n     * Corrects the image contrast\n     *\n     * Value can range between -127 and 127\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_contrast;\n\n    /**\n     * Changes the image opacity\n     *\n     * Value can range between 0 and 100\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_opacity;\n\n    /**\n     * Applies threshold filter\n     *\n     * Value can range between -127 and 127\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_threshold;\n\n    /**\n     * Applies a tint on the image\n     *\n     * Value is an hexadecimal color, such as #FFFFFF\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_tint_color;\n\n    /**\n     * Applies a colored overlay on the image\n     *\n     * Value is an hexadecimal color, such as #FFFFFF\n     *\n     * To use with {@link image_overlay_opacity}\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_overlay_color;\n\n    /**\n     * Sets the opacity for the colored overlay\n     *\n     * Value is a percentage, as an integer between 0 (transparent) and 100 (opaque)\n     *\n     * Unless used with {@link image_overlay_color}, this setting has no effect\n     *\n     * Default value is 50\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_overlay_opacity;\n\n    /**\n     * Inverts the color of an image\n     *\n     * Default value is FALSE\n     *\n     * @access public\n     * @var boolean;\n     */\n    var $image_negative;\n\n    /**\n     * Turns the image into greyscale\n     *\n     * Default value is FALSE\n     *\n     * @access public\n     * @var boolean;\n     */\n    var $image_greyscale;\n\n    /**\n     * Pixelate an image\n     *\n     * Value is integer, represents the block size\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var integer;\n     */\n    var $image_pixelate;\n\n    /**\n     * Applies an unsharp mask, with alpha transparency support\n     *\n     * Beware that this unsharp mask is quite resource-intensive\n     *\n     * Default value is FALSE\n     *\n     * @access public\n     * @var boolean;\n     */\n    var $image_unsharp;\n\n    /**\n     * Sets the unsharp mask amount\n     *\n     * Value is an integer between 0 and 500, typically between 50 and 200\n     *\n     * Unless used with {@link image_unsharp}, this setting has no effect\n     *\n     * Default value is 80\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_unsharp_amount;\n\n    /**\n     * Sets the unsharp mask radius\n     *\n     * Value is an integer between 0 and 50, typically between 0.5 and 1\n     * It is not recommended to change it, the default works best\n     *\n     * Unless used with {@link image_unsharp}, this setting has no effect\n     *\n     * From PHP 5.1, imageconvolution is used, and this setting has no effect\n     *\n     * Default value is 0.5\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_unsharp_radius;\n\n    /**\n     * Sets the unsharp mask threshold\n     *\n     * Value is an integer between 0 and 255, typically between 0 and 5\n     *\n     * Unless used with {@link image_unsharp}, this setting has no effect\n     *\n     * Default value is 1\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_unsharp_threshold;\n\n    /**\n     * Adds a text label on the image\n     *\n     * Value is a string, any text. Text will not word-wrap, although you can use breaklines in your text \"\\n\"\n     *\n     * If set, this setting allow the use of all other settings starting with image_text_\n     *\n     * Replacement tokens can be used in the string:\n     * <pre>\n     * gd_version    src_name       src_name_body src_name_ext\n     * src_pathname  src_mime       src_x         src_y\n     * src_type      src_bits       src_pixels\n     * src_size      src_size_kb    src_size_mb   src_size_human\n     * dst_path      dst_name_body  dst_pathname\n     * dst_name      dst_name_ext   dst_x         dst_y\n     * date          time           host          server        ip\n     * </pre>\n     * The tokens must be enclosed in square brackets: [dst_x] will be replaced by the width of the picture\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_text;\n\n    /**\n     * Sets the text direction for the text label\n     *\n     * Value is either 'h' or 'v', as in horizontal and vertical\n     *\n     * Note that if you use a TrueType font, you can use {@link image_text_angle} instead\n     *\n     * Default value is h (horizontal)\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_text_direction;\n\n    /**\n     * Sets the text color for the text label\n     *\n     * Value is an hexadecimal color, such as #FFFFFF\n     *\n     * Default value is #FFFFFF (white)\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_text_color;\n\n    /**\n     * Sets the text opacity in the text label\n     *\n     * Value is a percentage, as an integer between 0 (transparent) and 100 (opaque)\n     *\n     * Default value is 100\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_opacity;\n\n    /**\n     * Sets the text background color for the text label\n     *\n     * Value is an hexadecimal color, such as #FFFFFF\n     *\n     * Default value is null (no background)\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_text_background;\n\n    /**\n     * Sets the text background opacity in the text label\n     *\n     * Value is a percentage, as an integer between 0 (transparent) and 100 (opaque)\n     *\n     * Default value is 100\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_background_opacity;\n\n    /**\n     * Sets the text font in the text label\n     *\n     * Value is a an integer between 1 and 5 for GD built-in fonts. 1 is the smallest font, 5 the biggest\n     * Value can also be a string, which represents the path to a GDF or TTF font (TrueType).\n     *\n     * Default value is 5\n     *\n     * @access public\n     * @var mixed;\n     */\n    var $image_text_font;\n\n    /**\n     * Sets the text font size for TrueType fonts\n     *\n     * Value is a an integer, and represents the font size in pixels (GD1) or points (GD1)\n     *\n     * Note that this setting is only applicable to TrueType fonts, and has no effects with GD fonts\n     *\n     * Default value is 16\n     *\n     * @access public\n     * @var integer;\n     */\n    var $image_text_size;\n\n    /**\n     * Sets the text angle for TrueType fonts\n     *\n     * Value is a an integer between 0 and 360, in degrees, with 0 degrees being left-to-right reading text.\n     *\n     * Note that this setting is only applicable to TrueType fonts, and has no effects with GD fonts\n     * For GD fonts, you can use {@link image_text_direction} instead\n     *\n     * Default value is null (so it is determined by the value of {@link image_text_direction})\n     *\n     * @access public\n     * @var integer;\n     */\n    var $image_text_angle;\n\n    /**\n     * Sets the text label position within the image\n     *\n     * Value is one or two out of 'TBLR' (top, bottom, left, right)\n     *\n     * The positions are as following:\n     * <pre>\n     *                        TL  T  TR\n     *                        L       R\n     *                        BL  B  BR\n     * </pre>\n     *\n     * Default value is null (centered, horizontal and vertical)\n     *\n     * Note that is {@link image_text_x} and {@link image_text_y} are used, this setting has no effect\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_text_position;\n\n    /**\n     * Sets the text label absolute X position within the image\n     *\n     * Value is in pixels, representing the distance between the left of the image and the label\n     * If a negative value is used, it will represent the distance between the right of the image and the label\n     *\n     * Default value is null (so {@link image_text_position} is used)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_x;\n\n    /**\n     * Sets the text label absolute Y position within the image\n     *\n     * Value is in pixels, representing the distance between the top of the image and the label\n     * If a negative value is used, it will represent the distance between the bottom of the image and the label\n     *\n     * Default value is null (so {@link image_text_position} is used)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_y;\n\n    /**\n     * Sets the text label padding\n     *\n     * Value is in pixels, representing the distance between the text and the label background border\n     *\n     * Default value is 0\n     *\n     * This setting can be overriden by {@link image_text_padding_x} and {@link image_text_padding_y}\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_padding;\n\n    /**\n     * Sets the text label horizontal padding\n     *\n     * Value is in pixels, representing the distance between the text and the left and right label background borders\n     *\n     * Default value is null\n     *\n     * If set, this setting overrides the horizontal part of {@link image_text_padding}\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_padding_x;\n\n    /**\n     * Sets the text label vertical padding\n     *\n     * Value is in pixels, representing the distance between the text and the top and bottom label background borders\n     *\n     * Default value is null\n     *\n     * If set, his setting overrides the vertical part of {@link image_text_padding}\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_padding_y;\n\n    /**\n     * Sets the text alignment\n     *\n     * Value is a string, which can be either 'L', 'C' or 'R'\n     *\n     * Default value is 'C'\n     *\n     * This setting is relevant only if the text has several lines.\n     *\n     * Note that this setting is only applicable to GD fonts, and has no effects with TrueType fonts\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_text_alignment;\n\n    /**\n     * Sets the text line spacing\n     *\n     * Value is an integer, in pixels\n     *\n     * Default value is 0\n     *\n     * This setting is relevant only if the text has several lines.\n     *\n     * Note that this setting is only applicable to GD fonts, and has no effects with TrueType fonts\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_text_line_spacing;\n\n    /**\n     * Sets the height of the reflection\n     *\n     * Value is an integer in pixels, or a string which format can be in pixels or percentage.\n     * For instance, values can be : 40, '40', '40px' or '40%'\n     *\n     * Default value is null, no reflection\n     *\n     * @access public\n     * @var mixed;\n     */\n    var $image_reflection_height;\n\n    /**\n     * Sets the space between the source image and its relection\n     *\n     * Value is an integer in pixels, which can be negative\n     *\n     * Default value is 2\n     *\n     * This setting is relevant only if {@link image_reflection_height} is set\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_reflection_space;\n\n    /**\n     * Sets the initial opacity of the reflection\n     *\n     * Value is an integer between 0 (no opacity) and 100 (full opacity).\n     * The reflection will start from {@link image_reflection_opacity} and end up at 0\n     *\n     * Default value is 60\n     *\n     * This setting is relevant only if {@link image_reflection_height} is set\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_reflection_opacity;\n\n    /**\n     * Automatically rotates the image according to EXIF data (JPEG only)\n     *\n     * Default value is true\n     *\n     * @access public\n     * @var boolean;\n     */\n    var $image_auto_rotate;\n\n    /**\n     * Flips the image vertically or horizontally\n     *\n     * Value is either 'h' or 'v', as in horizontal and vertical\n     *\n     * Default value is null (no flip)\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_flip;\n\n    /**\n     * Rotates the image by increments of 45 degrees\n     *\n     * Value is either 90, 180 or 270\n     *\n     * Default value is null (no rotation)\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_rotate;\n\n    /**\n     * Crops an image\n     *\n     * Values are four dimensions, or two, or one (CSS style)\n     * They represent the amount cropped top, right, bottom and left.\n     * These values can either be in an array, or a space separated string.\n     * Each value can be in pixels (with or without 'px'), or percentage (of the source image)\n     *\n     * For instance, are valid:\n     * <pre>\n     * $foo->image_crop = 20                  OR array(20);\n     * $foo->image_crop = '20px'              OR array('20px');\n     * $foo->image_crop = '20 40'             OR array('20', 40);\n     * $foo->image_crop = '-20 25%'           OR array(-20, '25%');\n     * $foo->image_crop = '20px 25%'          OR array('20px', '25%');\n     * $foo->image_crop = '20% 25%'           OR array('20%', '25%');\n     * $foo->image_crop = '20% 25% 10% 30%'   OR array('20%', '25%', '10%', '30%');\n     * $foo->image_crop = '20px 25px 2px 2px' OR array('20px', '25%px', '2px', '2px');\n     * $foo->image_crop = '20 25% 40px 10%'   OR array(20, '25%', '40px', '10%');\n     * </pre>\n     *\n     * If a value is negative, the image will be expanded, and the extra parts will be filled with black\n     *\n     * Default value is null (no cropping)\n     *\n     * @access public\n     * @var string OR array;\n     */\n    var $image_crop;\n\n    /**\n     * Crops an image, before an eventual resizing\n     *\n     * See {@link image_crop} for valid formats\n     *\n     * Default value is null (no cropping)\n     *\n     * @access public\n     * @var string OR array;\n     */\n    var $image_precrop;\n\n    /**\n     * Adds a bevel border on the image\n     *\n     * Value is a positive integer, representing the thickness of the bevel\n     *\n     * If the bevel colors are the same as the background, it makes a fade out effect\n     *\n     * Default value is null (no bevel)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_bevel;\n\n    /**\n     * Top and left bevel color\n     *\n     * Value is a color, in hexadecimal format\n     * This setting is used only if {@link image_bevel} is set\n     *\n     * Default value is #FFFFFF\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_bevel_color1;\n\n    /**\n     * Right and bottom bevel color\n     *\n     * Value is a color, in hexadecimal format\n     * This setting is used only if {@link image_bevel} is set\n     *\n     * Default value is #000000\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_bevel_color2;\n\n    /**\n     * Adds a single-color border on the outer of the image\n     *\n     * Values are four dimensions, or two, or one (CSS style)\n     * They represent the border thickness top, right, bottom and left.\n     * These values can either be in an array, or a space separated string.\n     * Each value can be in pixels (with or without 'px'), or percentage (of the source image)\n     *\n     * See {@link image_crop} for valid formats\n     *\n     * If a value is negative, the image will be cropped.\n     * Note that the dimensions of the picture will be increased by the borders' thickness\n     *\n     * Default value is null (no border)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_border;\n\n    /**\n     * Border color\n     *\n     * Value is a color, in hexadecimal format.\n     * This setting is used only if {@link image_border} is set\n     *\n     * Default value is #FFFFFF\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_border_color;\n\n    /**\n     * Sets the opacity for the borders\n     *\n     * Value is a percentage, as an integer between 0 (transparent) and 100 (opaque)\n     *\n     * Unless used with {@link image_border}, this setting has no effect\n     *\n     * Default value is 100\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_border_opacity;\n\n    /**\n     * Adds a fading-to-transparent border on the image\n     *\n     * Values are four dimensions, or two, or one (CSS style)\n     * They represent the border thickness top, right, bottom and left.\n     * These values can either be in an array, or a space separated string.\n     * Each value can be in pixels (with or without 'px'), or percentage (of the source image)\n     *\n     * See {@link image_crop} for valid formats\n     *\n     * Note that the dimensions of the picture will not be increased by the borders' thickness\n     *\n     * Default value is null (no border)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_border_transparent;\n\n    /**\n     * Adds a multi-color frame on the outer of the image\n     *\n     * Value is an integer. Two values are possible for now:\n     * 1 for flat border, meaning that the frame is mirrored horizontally and vertically\n     * 2 for crossed border, meaning that the frame will be inversed, as in a bevel effect\n     *\n     * The frame will be composed of colored lines set in {@link image_frame_colors}\n     *\n     * Note that the dimensions of the picture will be increased by the borders' thickness\n     *\n     * Default value is null (no frame)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_frame;\n\n    /**\n     * Sets the colors used to draw a frame\n     *\n     * Values is a list of n colors in hexadecimal format.\n     * These values can either be in an array, or a space separated string.\n     *\n     * The colors are listed in the following order: from the outset of the image to its center\n     *\n     * For instance, are valid:\n     * <pre>\n     * $foo->image_frame_colors = '#FFFFFF #999999 #666666 #000000';\n     * $foo->image_frame_colors = array('#FFFFFF', '#999999', '#666666', '#000000');\n     * </pre>\n     *\n     * This setting is used only if {@link image_frame} is set\n     *\n     * Default value is '#FFFFFF #999999 #666666 #000000'\n     *\n     * @access public\n     * @var string OR array;\n     */\n    var $image_frame_colors;\n\n    /**\n     * Sets the opacity for the frame\n     *\n     * Value is a percentage, as an integer between 0 (transparent) and 100 (opaque)\n     *\n     * Unless used with {@link image_frame}, this setting has no effect\n     *\n     * Default value is 100\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_frame_opacity;\n\n    /**\n     * Adds a watermark on the image\n     *\n     * Value is a local image filename, relative or absolute. GIF, JPG, BMP and PNG are supported, as well as PNG alpha.\n     *\n     * If set, this setting allow the use of all other settings starting with image_watermark_\n     *\n     * Default value is null\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_watermark;\n\n    /**\n     * Sets the watermarkposition within the image\n     *\n     * Value is one or two out of 'TBLR' (top, bottom, left, right)\n     *\n     * The positions are as following:   TL  T  TR\n     *                                   L       R\n     *                                   BL  B  BR\n     *\n     * Default value is null (centered, horizontal and vertical)\n     *\n     * Note that is {@link image_watermark_x} and {@link image_watermark_y} are used, this setting has no effect\n     *\n     * @access public\n     * @var string;\n     */\n    var $image_watermark_position;\n\n    /**\n     * Sets the watermark absolute X position within the image\n     *\n     * Value is in pixels, representing the distance between the top of the image and the watermark\n     * If a negative value is used, it will represent the distance between the bottom of the image and the watermark\n     *\n     * Default value is null (so {@link image_watermark_position} is used)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_watermark_x;\n\n    /**\n     * Sets the twatermark absolute Y position within the image\n     *\n     * Value is in pixels, representing the distance between the left of the image and the watermark\n     * If a negative value is used, it will represent the distance between the right of the image and the watermark\n     *\n     * Default value is null (so {@link image_watermark_position} is used)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_watermark_y;\n\n    /**\n     * Prevents the watermark to be resized up if it is smaller than the image\n     *\n     * If the watermark if smaller than the destination image, taking in account the desired watermark position\n     * then it will be resized up to fill in the image (minus the {@link image_watermark_x} or {@link image_watermark_y} values)\n     *\n     * If you don't want your watermark to be resized in any way, then\n     * set {@link image_watermark_no_zoom_in} and {@link image_watermark_no_zoom_out} to true\n     * If you want your watermark to be resized up or doan to fill in the image better, then\n     * set {@link image_watermark_no_zoom_in} and {@link image_watermark_no_zoom_out} to false\n     *\n     * Default value is true (so the watermark will not be resized up, which is the behaviour most people expect)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_watermark_no_zoom_in;\n\n    /**\n     * Prevents the watermark to be resized down if it is bigger than the image\n     *\n     * If the watermark if bigger than the destination image, taking in account the desired watermark position\n     * then it will be resized down to fit in the image (minus the {@link image_watermark_x} or {@link image_watermark_y} values)\n     *\n     * If you don't want your watermark to be resized in any way, then\n     * set {@link image_watermark_no_zoom_in} and {@link image_watermark_no_zoom_out} to true\n     * If you want your watermark to be resized up or doan to fill in the image better, then\n     * set {@link image_watermark_no_zoom_in} and {@link image_watermark_no_zoom_out} to false\n     *\n     * Default value is false (so the watermark may be shrinked to fit in the image)\n     *\n     * @access public\n     * @var integer\n     */\n    var $image_watermark_no_zoom_out;\n\n    /**\n     * List of MIME types per extension\n     *\n     * @access private\n     * @var array\n     */\n    var $mime_types;\n\n    /**\n     * Allowed MIME types\n     *\n     * Default is a selection of safe mime-types, but you might want to change it\n     *\n     * Simple wildcards are allowed, such as image/* or application/*\n     * If there is only one MIME type allowed, then it can be a string instead of an array\n     *\n     * @access public\n     * @var array OR string\n     */\n    var $allowed;\n\n    /**\n     * Forbidden MIME types\n     *\n     * Default is a selection of safe mime-types, but you might want to change it\n     * To only check for forbidden MIME types, and allow everything else, set {@link allowed} to array('* / *') without the spaces\n     *\n     * Simple wildcards are allowed, such as image/* or application/*\n     * If there is only one MIME type forbidden, then it can be a string instead of an array\n     *\n     * @access public\n     * @var array OR string\n     */\n    var $forbidden;\n\n    /**\n     * Array of translated error messages\n     *\n     * By default, the language is english (en_GB)\n     * Translations can be in separate files, in a lang/ subdirectory\n     *\n     * @access public\n     * @var array\n     */\n    var $translation;\n\n    /**\n     * Language selected for the translations\n     *\n     * By default, the language is english (\"en_GB\")\n     *\n     * @access public\n     * @var array\n     */\n    var $lang;\n\n    /**\n     * Init or re-init all the processing variables to their default values\n     *\n     * This function is called in the constructor, and after each call of {@link process}\n     *\n     * @access private\n     */\n    function init() {\n\n        // overiddable variables\n        $this->file_new_name_body       = null;     // replace the name body\n        $this->file_name_body_add       = null;     // append to the name body\n        $this->file_name_body_pre       = null;     // prepend to the name body\n        $this->file_new_name_ext        = null;     // replace the file extension\n        $this->file_safe_name           = true;     // format safely the filename\n        $this->file_force_extension     = true;     // forces extension if there isn't one\n        $this->file_overwrite           = false;    // allows overwritting if the file already exists\n        $this->file_auto_rename         = true;     // auto-rename if the file already exists\n        $this->dir_auto_create          = true;     // auto-creates directory if missing\n        $this->dir_auto_chmod           = true;     // auto-chmod directory if not writeable\n        $this->dir_chmod                = 0755;     // default chmod to use\n\n        $this->no_script                = true;     // turns scripts into test files\n        $this->mime_check               = true;     // checks the mime type against the allowed list\n\n        // these are the different MIME detection methods. if one of these method doesn't work on your\n        // system, you can deactivate it here; just set it to false\n        $this->mime_fileinfo            = true;     // MIME detection with Fileinfo PECL extension\n        $this->mime_file                = true;     // MIME detection with UNIX file() command\n        $this->mime_magic               = true;     // MIME detection with mime_magic (mime_content_type())\n        $this->mime_getimagesize        = true;     // MIME detection with getimagesize()\n\n        // get the default max size from php.ini\n        $this->file_max_size_raw = trim(ini_get('upload_max_filesize'));\n        $this->file_max_size = $this->getsize($this->file_max_size_raw);\n\n        $this->image_resize             = false;    // resize the image\n        $this->image_convert            = '';       // convert. values :''; 'png'; 'jpeg'; 'gif'; 'bmp'\n\n        $this->image_x                  = 150;\n        $this->image_y                  = 150;\n        $this->image_ratio              = false;    // keeps aspect ratio with x and y dimensions\n        $this->image_ratio_crop         = false;    // keeps aspect ratio with x and y dimensions, filling the space\n        $this->image_ratio_fill         = false;    // keeps aspect ratio with x and y dimensions, fitting the image in the space, and coloring the rest\n        $this->image_ratio_pixels       = false;    // keeps aspect ratio, calculating x and y so that the image is approx the set number of pixels\n        $this->image_ratio_x            = false;    // calculate the $image_x if true\n        $this->image_ratio_y            = false;    // calculate the $image_y if true\n        $this->image_ratio_no_zoom_in   = false;\n        $this->image_ratio_no_zoom_out  = false;\n        $this->image_no_enlarging       = false;\n        $this->image_no_shrinking       = false;\n\n        $this->png_compression          = null;\n        $this->jpeg_quality             = 85;\n        $this->jpeg_size                = null;\n        $this->image_interlace          = false;\n        $this->image_is_transparent     = false;\n        $this->image_transparent_color  = null;\n        $this->image_background_color   = null;\n        $this->image_default_color      = '#ffffff';\n        $this->image_is_palette         = false;\n\n        $this->image_max_width          = null;\n        $this->image_max_height         = null;\n        $this->image_max_pixels         = null;\n        $this->image_max_ratio          = null;\n        $this->image_min_width          = null;\n        $this->image_min_height         = null;\n        $this->image_min_pixels         = null;\n        $this->image_min_ratio          = null;\n\n        $this->image_brightness         = null;\n        $this->image_contrast           = null;\n        $this->image_opacity            = null;\n        $this->image_threshold          = null;\n        $this->image_tint_color         = null;\n        $this->image_overlay_color      = null;\n        $this->image_overlay_opacity    = null;\n        $this->image_negative           = false;\n        $this->image_greyscale          = false;\n        $this->image_pixelate           = null;\n        $this->image_unsharp            = false;\n        $this->image_unsharp_amount     = 80;\n        $this->image_unsharp_radius     = 0.5;\n        $this->image_unsharp_threshold  = 1;\n\n        $this->image_text               = null;\n        $this->image_text_direction     = null;\n        $this->image_text_color         = '#FFFFFF';\n        $this->image_text_opacity       = 100;\n        $this->image_text_background    = null;\n        $this->image_text_background_opacity = 100;\n        $this->image_text_font          = 5;\n        $this->image_text_size          = 16;\n        $this->image_text_angle         = null;\n        $this->image_text_x             = null;\n        $this->image_text_y             = null;\n        $this->image_text_position      = null;\n        $this->image_text_padding       = 0;\n        $this->image_text_padding_x     = null;\n        $this->image_text_padding_y     = null;\n        $this->image_text_alignment     = 'C';\n        $this->image_text_line_spacing  = 0;\n\n        $this->image_reflection_height  = null;\n        $this->image_reflection_space   = 2;\n        $this->image_reflection_opacity = 60;\n\n        $this->image_watermark          = null;\n        $this->image_watermark_x        = null;\n        $this->image_watermark_y        = null;\n        $this->image_watermark_position = null;\n        $this->image_watermark_no_zoom_in  = true;\n        $this->image_watermark_no_zoom_out = false;\n\n        $this->image_flip               = null;\n        $this->image_auto_rotate        = true;\n        $this->image_rotate             = null;\n        $this->image_crop               = null;\n        $this->image_precrop            = null;\n\n        $this->image_bevel              = null;\n        $this->image_bevel_color1       = '#FFFFFF';\n        $this->image_bevel_color2       = '#000000';\n        $this->image_border             = null;\n        $this->image_border_color       = '#FFFFFF';\n        $this->image_border_opacity     = 100;\n        $this->image_border_transparent = null;\n        $this->image_frame              = null;\n        $this->image_frame_colors       = '#FFFFFF #999999 #666666 #000000';\n        $this->image_frame_opacity      = 100;\n\n        $this->forbidden = array();\n        $this->allowed = array(\n            'application/arj',\n            'application/excel',\n            'application/gnutar',\n            'application/mspowerpoint',\n            'application/msword',\n            'application/octet-stream',\n            'application/onenote',\n            'application/pdf',\n            'application/plain',\n            'application/postscript',\n            'application/powerpoint',\n            'application/rar',\n            'application/rtf',\n            'application/vnd.ms-excel',\n            'application/vnd.ms-excel.addin.macroEnabled.12',\n            'application/vnd.ms-excel.sheet.binary.macroEnabled.12',\n            'application/vnd.ms-excel.sheet.macroEnabled.12',\n            'application/vnd.ms-excel.template.macroEnabled.12',\n            'application/vnd.ms-office',\n            'application/vnd.ms-officetheme',\n            'application/vnd.ms-powerpoint',\n            'application/vnd.ms-powerpoint.addin.macroEnabled.12',\n            'application/vnd.ms-powerpoint.presentation.macroEnabled.12',\n            'application/vnd.ms-powerpoint.slide.macroEnabled.12',\n            'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',\n            'application/vnd.ms-powerpoint.template.macroEnabled.12',\n            'application/vnd.ms-word',\n            'application/vnd.ms-word.document.macroEnabled.12',\n            'application/vnd.ms-word.template.macroEnabled.12',\n            'application/vnd.oasis.opendocument.chart',\n            'application/vnd.oasis.opendocument.database',\n            'application/vnd.oasis.opendocument.formula',\n            'application/vnd.oasis.opendocument.graphics',\n            'application/vnd.oasis.opendocument.graphics-template',\n            'application/vnd.oasis.opendocument.image',\n            'application/vnd.oasis.opendocument.presentation',\n            'application/vnd.oasis.opendocument.presentation-template',\n            'application/vnd.oasis.opendocument.spreadsheet',\n            'application/vnd.oasis.opendocument.spreadsheet-template',\n            'application/vnd.oasis.opendocument.text',\n            'application/vnd.oasis.opendocument.text-master',\n            'application/vnd.oasis.opendocument.text-template',\n            'application/vnd.oasis.opendocument.text-web',\n            'application/vnd.openofficeorg.extension',\n            'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n            'application/vnd.openxmlformats-officedocument.presentationml.slide',\n            'application/vnd.openxmlformats-officedocument.presentationml.slideshow',\n            'application/vnd.openxmlformats-officedocument.presentationml.template',\n            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            'application/vnd.openxmlformats-officedocument.spreadsheetml.template',\n            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            'application/vnd.openxmlformats-officedocument.wordprocessingml.template',\n            'application/vocaltec-media-file',\n            'application/wordperfect',\n            'application/x-bittorrent',\n            'application/x-bzip',\n            'application/x-bzip2',\n            'application/x-compressed',\n            'application/x-excel',\n            'application/x-gzip',\n            'application/x-latex',\n            'application/x-midi',\n            'application/xml',\n            'application/x-msexcel',\n            'application/x-rar',\n            'application/x-rar-compressed',\n            'application/x-rtf',\n            'application/x-shockwave-flash',\n            'application/x-sit',\n            'application/x-stuffit',\n            'application/x-troff-msvideo',\n            'application/x-zip',\n            'application/x-zip-compressed',\n            'application/zip',\n            'audio/*',\n            'image/*',\n            'multipart/x-gzip',\n            'multipart/x-zip',\n            'text/plain',\n            'text/rtf',\n            'text/richtext',\n            'text/xml',\n            'video/*',\n            'text/csv'\n        );\n\n        $this->mime_types = array(\n            'jpg' => 'image/jpeg',\n            'jpeg' => 'image/jpeg',\n            'jpe' => 'image/jpeg',\n            'gif' => 'image/gif',\n            'png' => 'image/png',\n            'bmp' => 'image/bmp',\n            'flif' => 'image/flif',\n            'flv' => 'video/x-flv',\n            'js' => 'application/x-javascript',\n            'json' => 'application/json',\n            'tiff' => 'image/tiff',\n            'css' => 'text/css',\n            'xml' => 'application/xml',\n            'doc' => 'application/msword',\n            'xls' => 'application/vnd.ms-excel',\n            'xlt' => 'application/vnd.ms-excel',\n            'xlm' => 'application/vnd.ms-excel',\n            'xld' => 'application/vnd.ms-excel',\n            'xla' => 'application/vnd.ms-excel',\n            'xlc' => 'application/vnd.ms-excel',\n            'xlw' => 'application/vnd.ms-excel',\n            'xll' => 'application/vnd.ms-excel',\n            'ppt' => 'application/vnd.ms-powerpoint',\n            'pps' => 'application/vnd.ms-powerpoint',\n            'rtf' => 'application/rtf',\n            'pdf' => 'application/pdf',\n            'html' => 'text/html',\n            'htm' => 'text/html',\n            'php' => 'text/html',\n            'txt' => 'text/plain',\n            'mpeg' => 'video/mpeg',\n            'mpg' => 'video/mpeg',\n            'mpe' => 'video/mpeg',\n            'mp3' => 'audio/mpeg3',\n            'wav' => 'audio/wav',\n            'aiff' => 'audio/aiff',\n            'aif' => 'audio/aiff',\n            'avi' => 'video/msvideo',\n            'wmv' => 'video/x-ms-wmv',\n            'mov' => 'video/quicktime',\n            'zip' => 'application/zip',\n            'tar' => 'application/x-tar',\n            'swf' => 'application/x-shockwave-flash',\n            'odt' => 'application/vnd.oasis.opendocument.text',\n            'ott' => 'application/vnd.oasis.opendocument.text-template',\n            'oth' => 'application/vnd.oasis.opendocument.text-web',\n            'odm' => 'application/vnd.oasis.opendocument.text-master',\n            'odg' => 'application/vnd.oasis.opendocument.graphics',\n            'otg' => 'application/vnd.oasis.opendocument.graphics-template',\n            'odp' => 'application/vnd.oasis.opendocument.presentation',\n            'otp' => 'application/vnd.oasis.opendocument.presentation-template',\n            'ods' => 'application/vnd.oasis.opendocument.spreadsheet',\n            'ots' => 'application/vnd.oasis.opendocument.spreadsheet-template',\n            'odc' => 'application/vnd.oasis.opendocument.chart',\n            'odf' => 'application/vnd.oasis.opendocument.formula',\n            'odb' => 'application/vnd.oasis.opendocument.database',\n            'odi' => 'application/vnd.oasis.opendocument.image',\n            'oxt' => 'application/vnd.openofficeorg.extension',\n            'docx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            'docm' => 'application/vnd.ms-word.document.macroEnabled.12',\n            'dotx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',\n            'dotm' => 'application/vnd.ms-word.template.macroEnabled.12',\n            'xlsx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            'xlsm' => 'application/vnd.ms-excel.sheet.macroEnabled.12',\n            'xltx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',\n            'xltm' => 'application/vnd.ms-excel.template.macroEnabled.12',\n            'xlsb' => 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',\n            'xlam' => 'application/vnd.ms-excel.addin.macroEnabled.12',\n            'pptx' => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n            'pptm' => 'application/vnd.ms-powerpoint.presentation.macroEnabled.12',\n            'ppsx' => 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',\n            'ppsm' => 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',\n            'potx' => 'application/vnd.openxmlformats-officedocument.presentationml.template',\n            'potm' => 'application/vnd.ms-powerpoint.template.macroEnabled.12',\n            'ppam' => 'application/vnd.ms-powerpoint.addin.macroEnabled.12',\n            'sldx' => 'application/vnd.openxmlformats-officedocument.presentationml.slide',\n            'sldm' => 'application/vnd.ms-powerpoint.slide.macroEnabled.12',\n            'thmx' => 'application/vnd.ms-officetheme',\n            'onetoc' => 'application/onenote',\n            'onetoc2' => 'application/onenote',\n            'onetmp' => 'application/onenote',\n            'onepkg' => 'application/onenote',\n            'csv' => 'text/csv',\n        );\n\n    }\n\n    /**\n     * Constructor, for PHP5+\n     */\n    function  __construct($file, $lang = 'en_GB')  {\n        $this->upload($file, $lang);\n    }\n\n    /**\n     * Constructor, for PHP4. Checks if the file has been uploaded\n     *\n     * The constructor takes $_FILES['form_field'] array as argument\n     * where form_field is the form field name\n     *\n     * The constructor will check if the file has been uploaded in its temporary location, and\n     * accordingly will set {@link uploaded} (and {@link error} is an error occurred)\n     *\n     * If the file has been uploaded, the constructor will populate all the variables holding the upload\n     * information (none of the processing class variables are used here).\n     * You can have access to information about the file (name, size, MIME type...).\n     *\n     *\n     * Alternatively, you can set the first argument to be a local filename (string)\n     * This allows processing of a local file, as if the file was uploaded\n     *\n     * The optional second argument allows you to set the language for the error messages\n     *\n     * @access private\n     * @param  array  $file $_FILES['form_field']\n     *    or   string $file Local filename\n     * @param  string $lang Optional language code\n     */\n    function upload($file, $lang = 'en_GB') {\n\n        $this->version            = '0.34dev';\n\n        $this->file_src_name      = '';\n        $this->file_src_name_body = '';\n        $this->file_src_name_ext  = '';\n        $this->file_src_mime      = '';\n        $this->file_src_size      = '';\n        $this->file_src_error     = '';\n        $this->file_src_pathname  = '';\n        $this->file_src_temp      = '';\n\n        $this->file_dst_path      = '';\n        $this->file_dst_name      = '';\n        $this->file_dst_name_body = '';\n        $this->file_dst_name_ext  = '';\n        $this->file_dst_pathname  = '';\n\n        $this->image_src_x        = null;\n        $this->image_src_y        = null;\n        $this->image_src_bits     = null;\n        $this->image_src_type     = null;\n        $this->image_src_pixels   = null;\n        $this->image_dst_x        = 0;\n        $this->image_dst_y        = 0;\n        $this->image_dst_type     = '';\n\n        $this->uploaded           = true;\n        $this->no_upload_check    = false;\n        $this->processed          = false;\n        $this->error              = '';\n        $this->log                = '';\n        $this->allowed            = array();\n        $this->forbidden          = array();\n        $this->file_is_image      = false;\n        $this->init();\n        $info                     = null;\n        $mime_from_browser        = null;\n\n        // sets default language\n        $this->translation        = array();\n        $this->translation['file_error']                  = 'File error. Please try again.';\n        $this->translation['local_file_missing']          = 'Local file doesn\\'t exist.';\n        $this->translation['local_file_not_readable']     = 'Local file is not readable.';\n        $this->translation['uploaded_too_big_ini']        = 'File upload error (the uploaded file exceeds the upload_max_filesize directive in php.ini).';\n        $this->translation['uploaded_too_big_html']       = 'File upload error (the uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the html form).';\n        $this->translation['uploaded_partial']            = 'File upload error (the uploaded file was only partially uploaded).';\n        $this->translation['uploaded_missing']            = 'File upload error (no file was uploaded).';\n        $this->translation['uploaded_no_tmp_dir']         = 'File upload error (missing a temporary folder).';\n        $this->translation['uploaded_cant_write']         = 'File upload error (failed to write file to disk).';\n        $this->translation['uploaded_err_extension']      = 'File upload error (file upload stopped by extension).';\n        $this->translation['uploaded_unknown']            = 'File upload error (unknown error code).';\n        $this->translation['try_again']                   = 'File upload error. Please try again.';\n        $this->translation['file_too_big']                = 'File too big.';\n        $this->translation['no_mime']                     = 'MIME type can\\'t be detected.';\n        $this->translation['incorrect_file']              = 'Incorrect type of file.';\n        $this->translation['image_too_wide']              = 'Image too wide.';\n        $this->translation['image_too_narrow']            = 'Image too narrow.';\n        $this->translation['image_too_high']              = 'Image too tall.';\n        $this->translation['image_too_short']             = 'Image too short.';\n        $this->translation['ratio_too_high']              = 'Image ratio too high (image too wide).';\n        $this->translation['ratio_too_low']               = 'Image ratio too low (image too high).';\n        $this->translation['too_many_pixels']             = 'Image has too many pixels.';\n        $this->translation['not_enough_pixels']           = 'Image has not enough pixels.';\n        $this->translation['file_not_uploaded']           = 'File not uploaded. Can\\'t carry on a process.';\n        $this->translation['already_exists']              = '%s already exists. Please change the file name.';\n        $this->translation['temp_file_missing']           = 'No correct temp source file. Can\\'t carry on a process.';\n        $this->translation['source_missing']              = 'No correct uploaded source file. Can\\'t carry on a process.';\n        $this->translation['destination_dir']             = 'Destination directory can\\'t be created. Can\\'t carry on a process.';\n        $this->translation['destination_dir_missing']     = 'Destination directory doesn\\'t exist. Can\\'t carry on a process.';\n        $this->translation['destination_path_not_dir']    = 'Destination path is not a directory. Can\\'t carry on a process.';\n        $this->translation['destination_dir_write']       = 'Destination directory can\\'t be made writeable. Can\\'t carry on a process.';\n        $this->translation['destination_path_write']      = 'Destination path is not a writeable. Can\\'t carry on a process.';\n        $this->translation['temp_file']                   = 'Can\\'t create the temporary file. Can\\'t carry on a process.';\n        $this->translation['source_not_readable']         = 'Source file is not readable. Can\\'t carry on a process.';\n        $this->translation['no_create_support']           = 'No create from %s support.';\n        $this->translation['create_error']                = 'Error in creating %s image from source.';\n        $this->translation['source_invalid']              = 'Can\\'t read image source. Not an image?.';\n        $this->translation['gd_missing']                  = 'GD doesn\\'t seem to be present.';\n        $this->translation['watermark_no_create_support'] = 'No create from %s support, can\\'t read watermark.';\n        $this->translation['watermark_create_error']      = 'No %s read support, can\\'t create watermark.';\n        $this->translation['watermark_invalid']           = 'Unknown image format, can\\'t read watermark.';\n        $this->translation['file_create']                 = 'No %s create support.';\n        $this->translation['no_conversion_type']          = 'No conversion type defined.';\n        $this->translation['copy_failed']                 = 'Error copying file on the server. copy() failed.';\n        $this->translation['reading_failed']              = 'Error reading the file.';\n\n        // determines the language\n        $this->lang               = $lang;\n        if ($this->lang != 'en_GB' && file_exists(dirname(__FILE__).'/lang') && file_exists(dirname(__FILE__).'/lang/class.upload.' . $lang . '.php')) {\n            $translation = null;\n            include(dirname(__FILE__).'/lang/class.upload.' . $lang . '.php');\n            if (is_array($translation)) {\n                $this->translation = array_merge($this->translation, $translation);\n            } else {\n                $this->lang = 'en_GB';\n            }\n        }\n\n\n        // determines the supported MIME types, and matching image format\n        $this->image_supported = array();\n        if ($this->gdversion()) {\n            if (imagetypes() & IMG_GIF) {\n                $this->image_supported['image/gif'] = 'gif';\n            }\n            if (imagetypes() & IMG_JPG) {\n                $this->image_supported['image/jpg'] = 'jpg';\n                $this->image_supported['image/jpeg'] = 'jpg';\n                $this->image_supported['image/pjpeg'] = 'jpg';\n            }\n            if (imagetypes() & IMG_PNG) {\n                $this->image_supported['image/png'] = 'png';\n                $this->image_supported['image/x-png'] = 'png';\n            }\n            if (imagetypes() & IMG_WBMP) {\n                $this->image_supported['image/bmp'] = 'bmp';\n                $this->image_supported['image/x-ms-bmp'] = 'bmp';\n                $this->image_supported['image/x-windows-bmp'] = 'bmp';\n            }\n        }\n\n        // display some system information\n        if (empty($this->log)) {\n            $this->log .= '<b>system information</b><br />';\n            if ($this->function_enabled('ini_get_all')) {\n                $inis = ini_get_all();\n                $open_basedir = (array_key_exists('open_basedir', $inis) && array_key_exists('local_value', $inis['open_basedir']) && !empty($inis['open_basedir']['local_value'])) ? $inis['open_basedir']['local_value'] : false;\n            } else {\n                $open_basedir = false;\n            }\n            $gd           = $this->gdversion() ? $this->gdversion(true) : 'GD not present';\n            $supported    = trim((in_array('png', $this->image_supported) ? 'png' : '') . ' ' . (in_array('jpg', $this->image_supported) ? 'jpg' : '') . ' ' . (in_array('gif', $this->image_supported) ? 'gif' : '') . ' ' . (in_array('bmp', $this->image_supported) ? 'bmp' : ''));\n            $this->log .= '-&nbsp;class version           : ' . $this->version . '<br />';\n            $this->log .= '-&nbsp;operating system        : ' . PHP_OS . '<br />';\n            $this->log .= '-&nbsp;PHP version             : ' . PHP_VERSION . '<br />';\n            $this->log .= '-&nbsp;GD version              : ' . $gd . '<br />';\n            $this->log .= '-&nbsp;supported image types   : ' . (!empty($supported) ? $supported : 'none') . '<br />';\n            $this->log .= '-&nbsp;open_basedir            : ' . (!empty($open_basedir) ? $open_basedir : 'no restriction') . '<br />';\n            $this->log .= '-&nbsp;upload_max_filesize     : ' . $this->file_max_size_raw . ' (' . $this->file_max_size . ' bytes)<br />';\n            $this->log .= '-&nbsp;language                : ' . $this->lang . '<br />';\n        }\n\n        if (!$file) {\n            $this->uploaded = false;\n            $this->error = $this->translate('file_error');\n        }\n\n        // check if we sent a local filename or a PHP stream rather than a $_FILE element\n        if (!is_array($file)) {\n            if (empty($file)) {\n                $this->uploaded = false;\n                $this->error = $this->translate('file_error');\n            } else {\n                if (substr($file, 0, 4) == 'php:' || substr($file, 0, 5) == 'data:' || substr($file, 0, 7) == 'base64:') {\n                    $data = null;\n\n                    // this is a PHP stream, i.e.not uploaded\n                    if (substr($file, 0, 4) == 'php:') {\n                        $file = preg_replace('/^php:(.*)/i', '$1', $file);\n                        if (!$file) $file = $_SERVER['HTTP_X_FILE_NAME'];\n                        if (!$file) $file = 'unknown';\n                        $data = file_get_contents('php://input');\n                        $this->log .= '<b>source is a PHP stream ' . $file . ' of length ' . strlen($data) . '</b><br />';\n\n                    // this is the raw file data, i.e.not uploaded\n                    } else if (substr($file, 0, 5) == 'data:') {\n                        $data = preg_replace('/^data:(.*)/i', '$1', $file);\n                        $file = 'data';\n                        $this->log .= '<b>source is a data string of length ' . strlen($data) . '</b><br />';\n\n                    // this is the raw file data, base64-encoded, i.e.not uploaded\n                    } else if (substr($file, 0, 7) == 'base64:') {\n                        $data = base64_decode(preg_replace('/^base64:(?:.*base64,)?(.*)/i', '$1', $file));\n                        $file = 'base64';\n                        $this->log .= '<b>source is a base64 data string of length ' . strlen($data) . '</b><br />';\n                    }\n\n                    if (!$data) {\n                        $this->log .= '- source is empty!<br />';\n                        $this->uploaded = false;\n                        $this->error = $this->translate('source_invalid');\n                    }\n\n                    $this->no_upload_check = TRUE;\n\n                    if ($this->uploaded) {\n                        $this->log .= '- requires a temp file ... ';\n                        $hash = $this->temp_dir() . md5($file . rand(1, 1000));\n                        if ($data && file_put_contents($hash, $data)) {\n                            $this->file_src_pathname = $hash;\n                            $this->log .= ' file created<br />';\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;temp file is: ' . $this->file_src_pathname . '<br />';\n                        } else {\n                            $this->log .= ' failed<br />';\n                            $this->uploaded = false;\n                            $this->error = $this->translate('temp_file');\n                        }\n                    }\n\n                    if ($this->uploaded) {\n                        $this->file_src_name       = $file;\n                        $this->log .= '- local file OK<br />';\n                        preg_match('/\\.([^\\.]*$)/', $this->file_src_name, $extension);\n                        if (is_array($extension) && sizeof($extension) > 0) {\n                            $this->file_src_name_ext      = strtolower($extension[1]);\n                            $this->file_src_name_body     = substr($this->file_src_name, 0, ((strlen($this->file_src_name) - strlen($this->file_src_name_ext)))-1);\n                        } else {\n                            $this->file_src_name_ext      = '';\n                            $this->file_src_name_body     = $this->file_src_name;\n                        }\n                        $this->file_src_size = (file_exists($this->file_src_pathname) ? filesize($this->file_src_pathname) : 0);\n                    }\n                    $this->file_src_error = 0;\n\n                } else {\n                    // this is a local filename, i.e.not uploaded\n                    $this->log .= '<b>source is a local file ' . $file . '</b><br />';\n                    $this->no_upload_check = TRUE;\n\n                    if ($this->uploaded && !file_exists($file)) {\n                        $this->uploaded = false;\n                        $this->error = $this->translate('local_file_missing');\n                    }\n\n                    if ($this->uploaded && !is_readable($file)) {\n                        $this->uploaded = false;\n                        $this->error = $this->translate('local_file_not_readable');\n                    }\n\n                    if ($this->uploaded) {\n                        $this->file_src_pathname   = $file;\n                        $this->file_src_name       = basename($file);\n                        $this->log .= '- local file OK<br />';\n                        preg_match('/\\.([^\\.]*$)/', $this->file_src_name, $extension);\n                        if (is_array($extension) && sizeof($extension) > 0) {\n                            $this->file_src_name_ext      = strtolower($extension[1]);\n                            $this->file_src_name_body     = substr($this->file_src_name, 0, ((strlen($this->file_src_name) - strlen($this->file_src_name_ext)))-1);\n                        } else {\n                            $this->file_src_name_ext      = '';\n                            $this->file_src_name_body     = $this->file_src_name;\n                        }\n                        $this->file_src_size = (file_exists($this->file_src_pathname) ? filesize($this->file_src_pathname) : 0);\n                    }\n                    $this->file_src_error = 0;\n                }\n            }\n        } else {\n            // this is an element from $_FILE, i.e. an uploaded file\n            $this->log .= '<b>source is an uploaded file</b><br />';\n            if ($this->uploaded) {\n                $this->file_src_error         = trim($file['error']);\n                switch($this->file_src_error) {\n                    case UPLOAD_ERR_OK:\n                        // all is OK\n                        $this->log .= '- upload OK<br />';\n                        break;\n                    case UPLOAD_ERR_INI_SIZE:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_too_big_ini');\n                        break;\n                    case UPLOAD_ERR_FORM_SIZE:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_too_big_html');\n                        break;\n                    case UPLOAD_ERR_PARTIAL:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_partial');\n                        break;\n                    case UPLOAD_ERR_NO_FILE:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_missing');\n                        break;\n                    case @UPLOAD_ERR_NO_TMP_DIR:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_no_tmp_dir');\n                        break;\n                    case @UPLOAD_ERR_CANT_WRITE:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_cant_write');\n                        break;\n                    case @UPLOAD_ERR_EXTENSION:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_err_extension');\n                        break;\n                    default:\n                        $this->uploaded = false;\n                        $this->error = $this->translate('uploaded_unknown') . ' ('.$this->file_src_error.')';\n                }\n            }\n\n            if ($this->uploaded) {\n                $this->file_src_pathname   = $file['tmp_name'];\n                $this->file_src_name       = $file['name'];\n                if ($this->file_src_name == '') {\n                    $this->uploaded = false;\n                    $this->error = $this->translate('try_again');\n                }\n            }\n\n            if ($this->uploaded) {\n                $this->log .= '- file name OK<br />';\n                preg_match('/\\.([^\\.]*$)/', $this->file_src_name, $extension);\n                if (is_array($extension) && sizeof($extension) > 0) {\n                    $this->file_src_name_ext      = strtolower($extension[1]);\n                    $this->file_src_name_body     = substr($this->file_src_name, 0, ((strlen($this->file_src_name) - strlen($this->file_src_name_ext)))-1);\n                } else {\n                    $this->file_src_name_ext      = '';\n                    $this->file_src_name_body     = $this->file_src_name;\n                }\n                $this->file_src_size = $file['size'];\n                $mime_from_browser = $file['type'];\n            }\n        }\n\n        if ($this->uploaded) {\n            $this->log .= '<b>determining MIME type</b><br />';\n            $this->file_src_mime = null;\n\n            // checks MIME type with Fileinfo PECL extension\n            if (!$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime) || strpos($this->file_src_mime, '/') === FALSE) {\n                if ($this->mime_fileinfo) {\n                    $this->log .= '- Checking MIME type with Fileinfo PECL extension<br />';\n                    if ($this->function_enabled('finfo_open')) {\n                        $path = null;\n                        if ($this->mime_fileinfo !== '') {\n                            if ($this->mime_fileinfo === true) {\n                                if (getenv('MAGIC') === FALSE) {\n                                    if (substr(PHP_OS, 0, 3) == 'WIN') {\n                                        $path = realpath(ini_get('extension_dir') . '/../') . '/extras/magic';\n                                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MAGIC path defaults to ' . $path . '<br />';\n                                    }\n                                } else {\n                                    $path = getenv('MAGIC');\n                                    $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MAGIC path is set to ' . $path . ' from MAGIC variable<br />';\n                                }\n                            } else {\n                                $path = $this->mime_fileinfo;\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MAGIC path is set to ' . $path . '<br />';\n                            }\n                        }\n                        if ($path) {\n                            $f = @finfo_open(FILEINFO_MIME, $path);\n                        } else {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MAGIC path will not be used<br />';\n                            $f = @finfo_open(FILEINFO_MIME);\n                        }\n                        if (is_resource($f)) {\n                            $mime = finfo_file($f, realpath($this->file_src_pathname));\n                            finfo_close($f);\n                            $this->file_src_mime = $mime;\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MIME type detected as ' . $this->file_src_mime . ' by Fileinfo PECL extension<br />';\n                            if (preg_match(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", $this->file_src_mime)) {\n                                $this->file_src_mime = preg_replace(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", '$1/$2', $this->file_src_mime);\n                                $this->log .= '-&nbsp;MIME validated as ' . $this->file_src_mime . '<br />';\n                            } else {\n                                $this->file_src_mime = null;\n                            }\n                        } else {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;Fileinfo PECL extension failed (finfo_open)<br />';\n                        }\n                    } elseif (@class_exists('finfo')) {\n                        $f = new finfo( FILEINFO_MIME );\n                        if ($f) {\n                            $this->file_src_mime = $f->file(realpath($this->file_src_pathname));\n                            $this->log .= '- MIME type detected as ' . $this->file_src_mime . ' by Fileinfo PECL extension<br />';\n                            if (preg_match(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", $this->file_src_mime)) {\n                                $this->file_src_mime = preg_replace(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", '$1/$2', $this->file_src_mime);\n                                $this->log .= '-&nbsp;MIME validated as ' . $this->file_src_mime . '<br />';\n                            } else {\n                                $this->file_src_mime = null;\n                            }\n                        } else {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;Fileinfo PECL extension failed (finfo)<br />';\n                        }\n                    } else {\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;Fileinfo PECL extension not available<br />';\n                    }\n                } else {\n                    $this->log .= '- Fileinfo PECL extension deactivated<br />';\n                }\n            }\n\n            // checks MIME type with shell if unix access is authorized\n            if (!$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime) || strpos($this->file_src_mime, '/') === FALSE) {\n                if ($this->mime_file) {\n                    $this->log .= '- Checking MIME type with UNIX file() command<br />';\n                    if (substr(PHP_OS, 0, 3) != 'WIN') {\n                        if ($this->function_enabled('exec') && $this->function_enabled('escapeshellarg')) {\n                            if (strlen($mime = @exec(\"file -bi \".escapeshellarg($this->file_src_pathname))) != 0) {\n                                $this->file_src_mime = trim($mime);\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MIME type detected as ' . $this->file_src_mime . ' by UNIX file() command<br />';\n                                if (preg_match(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", $this->file_src_mime)) {\n                                    $this->file_src_mime = preg_replace(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", '$1/$2', $this->file_src_mime);\n                                    $this->log .= '-&nbsp;MIME validated as ' . $this->file_src_mime . '<br />';\n                                } else {\n                                    $this->file_src_mime = null;\n                                }\n                            } else {\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;UNIX file() command failed<br />';\n                            }\n                        } else {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;PHP exec() function is disabled<br />';\n                        }\n                    } else {\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;UNIX file() command not availabled<br />';\n                    }\n                } else {\n                    $this->log .= '- UNIX file() command is deactivated<br />';\n                }\n            }\n\n            // checks MIME type with mime_magic\n            if (!$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime) || strpos($this->file_src_mime, '/') === FALSE) {\n                if ($this->mime_magic) {\n                    $this->log .= '- Checking MIME type with mime.magic file (mime_content_type())<br />';\n                    if ($this->function_enabled('mime_content_type')) {\n                        $this->file_src_mime = mime_content_type($this->file_src_pathname);\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MIME type detected as ' . $this->file_src_mime . ' by mime_content_type()<br />';\n                        if (preg_match(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", $this->file_src_mime)) {\n                            $this->file_src_mime = preg_replace(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", '$1/$2', $this->file_src_mime);\n                            $this->log .= '-&nbsp;MIME validated as ' . $this->file_src_mime . '<br />';\n                        } else {\n                            $this->file_src_mime = null;\n                        }\n                    } else {\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;mime_content_type() is not available<br />';\n                    }\n                } else {\n                    $this->log .= '- mime.magic file (mime_content_type()) is deactivated<br />';\n                }\n            }\n\n            // checks MIME type with getimagesize()\n            if (!$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime) || strpos($this->file_src_mime, '/') === FALSE) {\n                if ($this->mime_getimagesize) {\n                    $this->log .= '- Checking MIME type with getimagesize()<br />';\n                    $info = getimagesize($this->file_src_pathname);\n                    if (is_array($info) && array_key_exists('mime', $info)) {\n                        $this->file_src_mime = trim($info['mime']);\n                        if (empty($this->file_src_mime)) {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MIME empty, guessing from type<br />';\n                            $mime = (is_array($info) && array_key_exists(2, $info) ? $info[2] : null); // 1 = GIF, 2 = JPG, 3 = PNG\n                            $this->file_src_mime = ($mime==IMAGETYPE_GIF ? 'image/gif' : ($mime==IMAGETYPE_JPEG ? 'image/jpeg' : ($mime==IMAGETYPE_PNG ? 'image/png' : ($mime==IMAGETYPE_BMP ? 'image/bmp' : null))));\n                        }\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;MIME type detected as ' . $this->file_src_mime . ' by PHP getimagesize() function<br />';\n                        if (preg_match(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", $this->file_src_mime)) {\n                            $this->file_src_mime = preg_replace(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", '$1/$2', $this->file_src_mime);\n                            $this->log .= '-&nbsp;MIME validated as ' . $this->file_src_mime . '<br />';\n                        } else {\n                            $this->file_src_mime = null;\n                        }\n                    } else {\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;getimagesize() failed<br />';\n                    }\n                } else {\n                    $this->log .= '- getimagesize() is deactivated<br />';\n                }\n            }\n\n            // default to MIME from browser (or Flash)\n            if (!empty($mime_from_browser) && !$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime)) {\n                $this->file_src_mime =$mime_from_browser;\n                $this->log .= '- MIME type detected as ' . $this->file_src_mime . ' by browser<br />';\n                if (preg_match(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", $this->file_src_mime)) {\n                    $this->file_src_mime = preg_replace(\"/^([\\.\\w-]+)\\/([\\.\\w-]+)(.*)$/i\", '$1/$2', $this->file_src_mime);\n                    $this->log .= '-&nbsp;MIME validated as ' . $this->file_src_mime . '<br />';\n                } else {\n                    $this->file_src_mime = null;\n                }\n            }\n\n            // we need to work some magic if we upload via Flash\n            if ($this->file_src_mime == 'application/octet-stream' || !$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime) || strpos($this->file_src_mime, '/') === FALSE) {\n                if ($this->file_src_mime == 'application/octet-stream') $this->log .= '- Flash may be rewriting MIME as application/octet-stream<br />';\n                $this->log .= '- Try to guess MIME type from file extension (' . $this->file_src_name_ext . '): ';\n                if (array_key_exists($this->file_src_name_ext, $this->mime_types)) $this->file_src_mime = $this->mime_types[$this->file_src_name_ext];\n                if ($this->file_src_mime == 'application/octet-stream') {\n                    $this->log .= 'doesn\\'t look like anything known<br />';\n                } else {\n                    $this->log .= 'MIME type set to ' . $this->file_src_mime . '<br />';\n                }\n            }\n\n            if (!$this->file_src_mime || !is_string($this->file_src_mime) || empty($this->file_src_mime) || strpos($this->file_src_mime, '/') === FALSE) {\n                $this->log .= '- MIME type couldn\\'t be detected! (' . (string) $this->file_src_mime . ')<br />';\n            }\n\n            // determine whether the file is an image\n            if ($this->file_src_mime && is_string($this->file_src_mime) && !empty($this->file_src_mime) && array_key_exists($this->file_src_mime, $this->image_supported)) {\n                $this->file_is_image = true;\n                $this->image_src_type = $this->image_supported[$this->file_src_mime];\n            }\n\n            // if the file is an image, we gather some useful data\n            if ($this->file_is_image) {\n                if ($h = fopen($this->file_src_pathname, 'r')) {\n                    fclose($h);\n                    $info = getimagesize($this->file_src_pathname);\n                    if (is_array($info)) {\n                        $this->image_src_x    = $info[0];\n                        $this->image_src_y    = $info[1];\n                        $this->image_dst_x    = $this->image_src_x;\n                        $this->image_dst_y    = $this->image_src_y;\n                        $this->image_src_pixels = $this->image_src_x * $this->image_src_y;\n                        $this->image_src_bits = array_key_exists('bits', $info) ? $info['bits'] : null;\n                    } else {\n                        $this->file_is_image = false;\n                        $this->uploaded = false;\n                        $this->log .= '- can\\'t retrieve image information, image may have been tampered with<br />';\n                        $this->error = $this->translate('source_invalid');\n                    }\n                } else {\n                    $this->log .= '- can\\'t read source file directly. open_basedir restriction in place?<br />';\n                }\n            }\n\n            $this->log .= '<b>source variables</b><br />';\n            $this->log .= '- You can use all these before calling process()<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_name         : ' . $this->file_src_name . '<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_name_body    : ' . $this->file_src_name_body . '<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_name_ext     : ' . $this->file_src_name_ext . '<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_pathname     : ' . $this->file_src_pathname . '<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_mime         : ' . $this->file_src_mime . '<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_size         : ' . $this->file_src_size . ' (max= ' . $this->file_max_size . ')<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_src_error        : ' . $this->file_src_error . '<br />';\n\n            if ($this->file_is_image) {\n                $this->log .= '- source file is an image<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_src_x           : ' . $this->image_src_x . '<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_src_y           : ' . $this->image_src_y . '<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_src_pixels      : ' . $this->image_src_pixels . '<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_src_type        : ' . $this->image_src_type . '<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_src_bits        : ' . $this->image_src_bits . '<br />';\n            }\n        }\n\n    }\n\n    /**\n     * Returns the version of GD\n     *\n     * @access public\n     * @param  boolean  $full Optional flag to get precise version\n     * @return float GD version\n     */\n    function gdversion($full = false) {\n        static $gd_version = null;\n        static $gd_full_version = null;\n        if ($gd_version === null) {\n            if ($this->function_enabled('gd_info')) {\n                $gd = gd_info();\n                $gd = $gd[\"GD Version\"];\n                $regex = \"/([\\d\\.]+)/i\";\n            } else {\n                ob_start();\n                phpinfo(8);\n                $gd = ob_get_contents();\n                ob_end_clean();\n                $regex = \"/\\bgd\\s+version\\b[^\\d\\n\\r]+?([\\d\\.]+)/i\";\n            }\n            if (preg_match($regex, $gd, $m)) {\n                $gd_full_version = (string) $m[1];\n                $gd_version = (float) $m[1];\n            } else {\n                $gd_full_version = 'none';\n                $gd_version = 0;\n            }\n        }\n        if ($full) {\n            return $gd_full_version;\n        } else {\n            return $gd_version;\n        }\n    }\n\n    /**\n     * Checks if a function is available\n     *\n     * @access private\n     * @param  string  $func Function name\n     * @return boolean Success\n     */\n    function function_enabled($func) {\n        // cache the list of disabled functions\n        static $disabled = null;\n        if ($disabled === null) $disabled = array_map('trim', array_map('strtolower', explode(',', ini_get('disable_functions'))));\n        // cache the list of functions blacklisted by suhosin\n        static $blacklist = null;\n        if ($blacklist === null) $blacklist = extension_loaded('suhosin') ? array_map('trim', array_map('strtolower', explode(',', ini_get('  suhosin.executor.func.blacklist')))) : array();\n        // checks if the function is really enabled\n        return (function_exists($func) && !in_array($func, $disabled) && !in_array($func, $blacklist));\n    }\n\n    /**\n     * Creates directories recursively\n     *\n     * @access private\n     * @param  string  $path Path to create\n     * @param  integer $mode Optional permissions\n     * @return boolean Success\n     */\n    function rmkdir($path, $mode = 0755) {\n        return is_dir($path) || ( $this->rmkdir(dirname($path), $mode) && $this->_mkdir($path, $mode) );\n    }\n\n    /**\n     * Creates directory\n     *\n     * @access private\n     * @param  string  $path Path to create\n     * @param  integer $mode Optional permissions\n     * @return boolean Success\n     */\n    function _mkdir($path, $mode = 0755) {\n        $old = umask(0);\n        $res = @mkdir($path, $mode);\n        umask($old);\n        return $res;\n    }\n\n    /**\n     * Translate error messages\n     *\n     * @access private\n     * @param  string  $str    Message to translate\n     * @param  array   $tokens Optional token values\n     * @return string Translated string\n     */\n    function translate($str, $tokens = array()) {\n        if (array_key_exists($str, $this->translation)) $str = $this->translation[$str];\n        if (is_array($tokens) && sizeof($tokens) > 0)   $str = vsprintf($str, $tokens);\n        return $str;\n    }\n\n    /**\n     * Returns the temp directory\n     *\n     * @access private\n     * @return string Temp directory string\n     */\n    function temp_dir() {\n        $dir = '';\n        if ($this->function_enabled('sys_get_temp_dir')) $dir = sys_get_temp_dir();\n        if (!$dir && $tmp=getenv('TMP'))    $dir = $tmp;\n        if (!$dir && $tmp=getenv('TEMP'))   $dir = $tmp;\n        if (!$dir && $tmp=getenv('TMPDIR')) $dir = $tmp;\n        if (!$dir) {\n            $tmp = tempnam(__FILE__,'');\n            if (file_exists($tmp)) {\n                unlink($tmp);\n                $dir = dirname($tmp);\n            }\n        }\n        if (!$dir) return '';\n        $slash = (strtolower(substr(PHP_OS, 0, 3)) === 'win' ? '\\\\' : '/');\n        if (substr($dir, -1) != $slash) $dir = $dir . $slash;\n        return $dir;\n    }\n\n    /**\n     * Decodes colors\n     *\n     * @access private\n     * @param  string  $color  Color string\n     * @return array RGB colors\n     */\n    function getcolors($color) {\n        $color = str_replace('#', '', $color);\n        if (strlen($color) == 3) $color = str_repeat(substr($color, 0, 1), 2) . str_repeat(substr($color, 1, 1), 2) . str_repeat(substr($color, 2, 1), 2);\n        $r = sscanf($color, \"%2x%2x%2x\");\n        $red   = (is_array($r) && array_key_exists(0, $r) && is_numeric($r[0]) ? $r[0] : 0);\n        $green = (is_array($r) && array_key_exists(1, $r) && is_numeric($r[1]) ? $r[1] : 0);\n        $blue  = (is_array($r) && array_key_exists(2, $r) && is_numeric($r[2]) ? $r[2] : 0);\n        return array($red, $green, $blue);\n    }\n\n    /**\n     * Decodes sizes\n     *\n     * @access private\n     * @param  string  $size  Size in bytes, or shorthand byte options\n     * @return integer Size in bytes\n     */\n    function getsize($size) {\n        if ($size === null) return null;\n        $last = strtolower($size{strlen($size)-1});\n        $size = (int) $size;\n        switch($last) {\n            case 'g':\n                $size *= 1024;\n            case 'm':\n                $size *= 1024;\n            case 'k':\n                $size *= 1024;\n        }\n        return $size;\n    }\n\n    /**\n     * Decodes offsets\n     *\n     * @access private\n     * @param  misc    $offsets  Offsets, as an integer, a string or an array\n     * @param  integer $x        Reference picture width\n     * @param  integer $y        Reference picture height\n     * @param  boolean $round    Round offsets before returning them\n     * @param  boolean $negative Allow negative offsets to be returned\n     * @return array Array of four offsets (TRBL)\n     */\n    function getoffsets($offsets, $x, $y, $round = true, $negative = true) {\n        if (!is_array($offsets)) $offsets = explode(' ', $offsets);\n        if (sizeof($offsets) == 4) {\n             $ct = $offsets[0]; $cr = $offsets[1]; $cb = $offsets[2]; $cl = $offsets[3];\n        } else if (sizeof($offsets) == 2) {\n            $ct = $offsets[0]; $cr = $offsets[1]; $cb = $offsets[0]; $cl = $offsets[1];\n        } else {\n            $ct = $offsets[0]; $cr = $offsets[0]; $cb = $offsets[0]; $cl = $offsets[0];\n        }\n        if (strpos($ct, '%')>0) $ct = $y * (str_replace('%','',$ct) / 100);\n        if (strpos($cr, '%')>0) $cr = $x * (str_replace('%','',$cr) / 100);\n        if (strpos($cb, '%')>0) $cb = $y * (str_replace('%','',$cb) / 100);\n        if (strpos($cl, '%')>0) $cl = $x * (str_replace('%','',$cl) / 100);\n        if (strpos($ct, 'px')>0) $ct = str_replace('px','',$ct);\n        if (strpos($cr, 'px')>0) $cr = str_replace('px','',$cr);\n        if (strpos($cb, 'px')>0) $cb = str_replace('px','',$cb);\n        if (strpos($cl, 'px')>0) $cl = str_replace('px','',$cl);\n        $ct = (int) $ct; $cr = (int) $cr; $cb = (int) $cb; $cl = (int) $cl;\n        if ($round) {\n            $ct = round($ct);\n            $cr = round($cr);\n            $cb = round($cb);\n            $cl = round($cl);\n        }\n        if (!$negative) {\n            if ($ct < 0) $ct = 0;\n            if ($cr < 0) $cr = 0;\n            if ($cb < 0) $cb = 0;\n            if ($cl < 0) $cl = 0;\n        }\n        return array($ct, $cr, $cb, $cl);\n    }\n\n    /**\n     * Creates a container image\n     *\n     * @access private\n     * @param  integer  $x    Width\n     * @param  integer  $y    Height\n     * @param  boolean  $fill Optional flag to draw the background color or not\n     * @param  boolean  $trsp Optional flag to set the background to be transparent\n     * @return resource Container image\n     */\n    function imagecreatenew($x, $y, $fill = true, $trsp = false) {\n        if ($x < 1) $x = 1; if ($y < 1) $y = 1;\n        if ($this->gdversion() >= 2 && !$this->image_is_palette) {\n            // create a true color image\n            $dst_im = imagecreatetruecolor($x, $y);\n            // this preserves transparency in PNGs, in true color\n            if (empty($this->image_background_color) || $trsp) {\n                imagealphablending($dst_im, false );\n                imagefilledrectangle($dst_im, 0, 0, $x, $y, imagecolorallocatealpha($dst_im, 0, 0, 0, 127));\n            }\n        } else {\n            // creates a palette image\n            $dst_im = imagecreate($x, $y);\n            // preserves transparency for palette images, if the original image has transparency\n            if (($fill && $this->image_is_transparent && empty($this->image_background_color)) || $trsp) {\n                imagefilledrectangle($dst_im, 0, 0, $x, $y, $this->image_transparent_color);\n                imagecolortransparent($dst_im, $this->image_transparent_color);\n            }\n        }\n        // fills with background color if any is set\n        if ($fill && !empty($this->image_background_color) && !$trsp) {\n            list($red, $green, $blue) = $this->getcolors($this->image_background_color);\n            $background_color = imagecolorallocate($dst_im, $red, $green, $blue);\n            imagefilledrectangle($dst_im, 0, 0, $x, $y, $background_color);\n        }\n        return $dst_im;\n    }\n\n\n    /**\n     * Transfers an image from the container to the destination image\n     *\n     * @access private\n     * @param  resource $src_im Container image\n     * @param  resource $dst_im Destination image\n     * @return resource Destination image\n     */\n    function imagetransfer($src_im, $dst_im) {\n        if (is_resource($dst_im)) imagedestroy($dst_im);\n        $dst_im = & $src_im;\n        return $dst_im;\n    }\n\n    /**\n     * Merges two images\n     *\n     * If the output format is PNG, then we do it pixel per pixel to retain the alpha channel\n     *\n     * @access private\n     * @param  resource $dst_img Destination image\n     * @param  resource $src_img Overlay image\n     * @param  int      $dst_x   x-coordinate of destination point\n     * @param  int      $dst_y   y-coordinate of destination point\n     * @param  int      $src_x   x-coordinate of source point\n     * @param  int      $src_y   y-coordinate of source point\n     * @param  int      $src_w   Source width\n     * @param  int      $src_h   Source height\n     * @param  int      $pct     Optional percentage of the overlay, between 0 and 100 (default: 100)\n     * @return resource Destination image\n     */\n    function imagecopymergealpha(&$dst_im, &$src_im, $dst_x, $dst_y, $src_x, $src_y, $src_w, $src_h, $pct = 0) {\n        $dst_x = (int) $dst_x;\n        $dst_y = (int) $dst_y;\n        $src_x = (int) $src_x;\n        $src_y = (int) $src_y;\n        $src_w = (int) $src_w;\n        $src_h = (int) $src_h;\n        $pct   = (int) $pct;\n        $dst_w = imagesx($dst_im);\n        $dst_h = imagesy($dst_im);\n\n        for ($y = $src_y; $y < $src_h; $y++) {\n            for ($x = $src_x; $x < $src_w; $x++) {\n\n                if ($x + $dst_x >= 0 && $x + $dst_x < $dst_w && $x + $src_x >= 0 && $x + $src_x < $src_w\n                 && $y + $dst_y >= 0 && $y + $dst_y < $dst_h && $y + $src_y >= 0 && $y + $src_y < $src_h) {\n\n                    $dst_pixel = imagecolorsforindex($dst_im, imagecolorat($dst_im, $x + $dst_x, $y + $dst_y));\n                    $src_pixel = imagecolorsforindex($src_im, imagecolorat($src_im, $x + $src_x, $y + $src_y));\n\n                    $src_alpha = 1 - ($src_pixel['alpha'] / 127);\n                    $dst_alpha = 1 - ($dst_pixel['alpha'] / 127);\n                    $opacity = $src_alpha * $pct / 100;\n                    if ($dst_alpha >= $opacity) $alpha = $dst_alpha;\n                    if ($dst_alpha < $opacity)  $alpha = $opacity;\n                    if ($alpha > 1) $alpha = 1;\n\n                    if ($opacity > 0) {\n                        $dst_red   = round(( ($dst_pixel['red']   * $dst_alpha * (1 - $opacity)) ) );\n                        $dst_green = round(( ($dst_pixel['green'] * $dst_alpha * (1 - $opacity)) ) );\n                        $dst_blue  = round(( ($dst_pixel['blue']  * $dst_alpha * (1 - $opacity)) ) );\n                        $src_red   = round((($src_pixel['red']   * $opacity)) );\n                        $src_green = round((($src_pixel['green'] * $opacity)) );\n                        $src_blue  = round((($src_pixel['blue']  * $opacity)) );\n                        $red   = round(($dst_red   + $src_red  ) / ($dst_alpha * (1 - $opacity) + $opacity));\n                        $green = round(($dst_green + $src_green) / ($dst_alpha * (1 - $opacity) + $opacity));\n                        $blue  = round(($dst_blue  + $src_blue ) / ($dst_alpha * (1 - $opacity) + $opacity));\n                        if ($red   > 255) $red   = 255;\n                        if ($green > 255) $green = 255;\n                        if ($blue  > 255) $blue  = 255;\n                        $alpha =  round((1 - $alpha) * 127);\n                        $color = imagecolorallocatealpha($dst_im, $red, $green, $blue, $alpha);\n                        imagesetpixel($dst_im, $x + $dst_x, $y + $dst_y, $color);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n\n\n    /**\n     * Actually uploads the file, and act on it according to the set processing class variables\n     *\n     * This function copies the uploaded file to the given location, eventually performing actions on it.\n     * Typically, you can call {@link process} several times for the same file,\n     * for instance to create a resized image and a thumbnail of the same file.\n     * The original uploaded file remains intact in its temporary location, so you can use {@link process} several times.\n     * You will be able to delete the uploaded file with {@link clean} when you have finished all your {@link process} calls.\n     *\n     * According to the processing class variables set in the calling file, the file can be renamed,\n     * and if it is an image, can be resized or converted.\n     *\n     * When the processing is completed, and the file copied to its new location, the\n     * processing class variables will be reset to their default value.\n     * This allows you to set new properties, and perform another {@link process} on the same uploaded file\n     *\n     * If the function is called with a null or empty argument, then it will return the content of the picture\n     *\n     * It will set {@link processed} (and {@link error} is an error occurred)\n     *\n     * @access public\n     * @param  string $server_path Optional path location of the uploaded file, with an ending slash\n     * @return string Optional content of the image\n     */\n    function process($server_path = null) {\n        $this->error        = '';\n        $this->processed    = true;\n        $return_mode        = false;\n        $return_content     = null;\n\n        // clean up dst variables\n        $this->file_dst_path        = '';\n        $this->file_dst_pathname    = '';\n        $this->file_dst_name        = '';\n        $this->file_dst_name_body   = '';\n        $this->file_dst_name_ext    = '';\n\n        // clean up some parameters\n        $this->file_max_size = $this->getsize($this->file_max_size);\n        $this->jpeg_size = $this->getsize($this->jpeg_size);\n\n        // copy some variables as we need to keep them clean\n        $file_src_name = $this->file_src_name;\n        $file_src_name_body = $this->file_src_name_body;\n        $file_src_name_ext = $this->file_src_name_ext;\n\n        if (!$this->uploaded) {\n            $this->error = $this->translate('file_not_uploaded');\n            $this->processed = false;\n        }\n\n        if ($this->processed) {\n            if (empty($server_path) || is_null($server_path)) {\n                $this->log .= '<b>process file and return the content</b><br />';\n                $return_mode = true;\n            } else {\n                if(strtolower(substr(PHP_OS, 0, 3)) === 'win') {\n                    if (substr($server_path, -1, 1) != '\\\\') $server_path = $server_path . '\\\\';\n                } else {\n                    if (substr($server_path, -1, 1) != '/') $server_path = $server_path . '/';\n                }\n                $this->log .= '<b>process file to '  . $server_path . '</b><br />';\n            }\n        }\n\n        if ($this->processed) {\n            // checks file max size\n            if ($this->file_src_size > $this->file_max_size) {\n                $this->processed = false;\n                $this->error = $this->translate('file_too_big') . ' : ' . $this->file_src_size . ' > ' . $this->file_max_size;\n            } else {\n                $this->log .= '- file size OK<br />';\n            }\n        }\n\n        if ($this->processed) {\n            // if we have an image without extension, set it\n            if ($this->file_force_extension && $this->file_is_image && !$this->file_src_name_ext) $file_src_name_ext = $this->image_src_type;\n            // turn dangerous scripts into text files\n            if ($this->no_script) {\n                // if the file has no extension, we try to guess it from the MIME type\n                if ($this->file_force_extension && empty($file_src_name_ext)) {\n                    if ($key = array_search($this->file_src_mime, $this->mime_types)) {\n                        $file_src_name_ext = $key;\n                        $file_src_name = $file_src_name_body . '.' . $file_src_name_ext;\n                        $this->log .= '- file renamed as ' . $file_src_name_body . '.' . $file_src_name_ext . '!<br />';\n                    }\n                }\n                // if the file is text based, or has a dangerous extension, we rename it as .txt\n                if ((((substr($this->file_src_mime, 0, 5) == 'text/' && $this->file_src_mime != 'text/rtf') || strpos($this->file_src_mime, 'javascript') !== false)  && (substr($file_src_name, -4) != '.txt'))\n                    || preg_match('/\\.(asp|cgi|js|ph3|ph4|ph5|ph7|phar|php|php3|php4|php5|php7|phps|phtml|pl|py)$/i', $this->file_src_name)\n                    || $this->file_force_extension && empty($file_src_name_ext)) {\n                    $this->file_src_mime = 'text/plain';\n                    if ($this->file_src_name_ext) $file_src_name_body = $file_src_name_body . '.' . $this->file_src_name_ext;\n                    $file_src_name_ext = 'txt';\n                    $file_src_name = $file_src_name_body . '.' . $file_src_name_ext;\n                    $this->log .= '- script renamed as ' . $file_src_name_body . '.' . $file_src_name_ext . '!<br />';\n                }\n            }\n\n            if ($this->mime_check && empty($this->file_src_mime)) {\n                $this->processed = false;\n                $this->error = $this->translate('no_mime');\n            } else if ($this->mime_check && !empty($this->file_src_mime) && strpos($this->file_src_mime, '/') !== false) {\n                list($m1, $m2) = explode('/', $this->file_src_mime);\n                $allowed = false;\n                // check wether the mime type is allowed\n                if (!is_array($this->allowed)) $this->allowed = array($this->allowed);\n                foreach($this->allowed as $k => $v) {\n                    list($v1, $v2) = explode('/', $v);\n                    if (($v1 == '*' && $v2 == '*') || ($v1 == $m1 && ($v2 == $m2 || $v2 == '*'))) {\n                        $allowed = true;\n                        break;\n                    }\n                }\n                // check wether the mime type is forbidden\n                if (!is_array($this->forbidden)) $this->forbidden = array($this->forbidden);\n                foreach($this->forbidden as $k => $v) {\n                    list($v1, $v2) = explode('/', $v);\n                    if (($v1 == '*' && $v2 == '*') || ($v1 == $m1 && ($v2 == $m2 || $v2 == '*'))) {\n                        $allowed = false;\n                        break;\n                    }\n                }\n                if (!$allowed) {\n                    $this->processed = false;\n                    $this->error = $this->translate('incorrect_file');\n                } else {\n                    $this->log .= '- file mime OK : ' . $this->file_src_mime . '<br />';\n                }\n            } else {\n                $this->log .= '- file mime (not checked) : ' . $this->file_src_mime . '<br />';\n            }\n\n            // if the file is an image, we can check on its dimensions\n            // these checks are not available if open_basedir restrictions are in place\n            if ($this->file_is_image) {\n                if (is_numeric($this->image_src_x) && is_numeric($this->image_src_y)) {\n                    $ratio = $this->image_src_x / $this->image_src_y;\n                    if (!is_null($this->image_max_width) && $this->image_src_x > $this->image_max_width) {\n                        $this->processed = false;\n                        $this->error = $this->translate('image_too_wide');\n                    }\n                    if (!is_null($this->image_min_width) && $this->image_src_x < $this->image_min_width) {\n                        $this->processed = false;\n                        $this->error = $this->translate('image_too_narrow');\n                    }\n                    if (!is_null($this->image_max_height) && $this->image_src_y > $this->image_max_height) {\n                        $this->processed = false;\n                        $this->error = $this->translate('image_too_high');\n                    }\n                    if (!is_null($this->image_min_height) && $this->image_src_y < $this->image_min_height) {\n                        $this->processed = false;\n                        $this->error = $this->translate('image_too_short');\n                    }\n                    if (!is_null($this->image_max_ratio) && $ratio > $this->image_max_ratio) {\n                        $this->processed = false;\n                        $this->error = $this->translate('ratio_too_high');\n                    }\n                    if (!is_null($this->image_min_ratio) && $ratio < $this->image_min_ratio) {\n                        $this->processed = false;\n                        $this->error = $this->translate('ratio_too_low');\n                    }\n                    if (!is_null($this->image_max_pixels) && $this->image_src_pixels > $this->image_max_pixels) {\n                        $this->processed = false;\n                        $this->error = $this->translate('too_many_pixels');\n                    }\n                    if (!is_null($this->image_min_pixels) && $this->image_src_pixels < $this->image_min_pixels) {\n                        $this->processed = false;\n                        $this->error = $this->translate('not_enough_pixels');\n                    }\n                } else {\n                    $this->log .= '- no image properties available, can\\'t enforce dimension checks : ' . $this->file_src_mime . '<br />';\n                }\n            }\n        }\n\n        if ($this->processed) {\n            $this->file_dst_path        = $server_path;\n\n            // repopulate dst variables from src\n            $this->file_dst_name        = $file_src_name;\n            $this->file_dst_name_body   = $file_src_name_body;\n            $this->file_dst_name_ext    = $file_src_name_ext;\n            if ($this->file_overwrite) $this->file_auto_rename = false;\n\n            if ($this->image_convert && $this->file_is_image) { // if we convert as an image\n                if ($this->file_src_name_ext) $this->file_dst_name_ext  = $this->image_convert;\n                $this->log .= '- new file name ext : ' . $this->image_convert . '<br />';\n            }\n            if (!is_null($this->file_new_name_body)) { // rename file body\n                $this->file_dst_name_body = $this->file_new_name_body;\n                $this->log .= '- new file name body : ' . $this->file_new_name_body . '<br />';\n            }\n            if (!is_null($this->file_new_name_ext)) { // rename file ext\n                $this->file_dst_name_ext  = $this->file_new_name_ext;\n                $this->log .= '- new file name ext : ' . $this->file_new_name_ext . '<br />';\n            }\n            if (!is_null($this->file_name_body_add)) { // append a string to the name\n                $this->file_dst_name_body  = $this->file_dst_name_body . $this->file_name_body_add;\n                $this->log .= '- file name body append : ' . $this->file_name_body_add . '<br />';\n            }\n            if (!is_null($this->file_name_body_pre)) { // prepend a string to the name\n                $this->file_dst_name_body  = $this->file_name_body_pre . $this->file_dst_name_body;\n                $this->log .= '- file name body prepend : ' . $this->file_name_body_pre . '<br />';\n            }\n            if ($this->file_safe_name) { // formats the name\n\t            $this->file_dst_name_body = trim(preg_replace(array('/[^\\p{L}\\p{N}\\p{P}\\p{M}\\-_]/u', '/\\.[\\.]+/', \"/(\\\"|\\'|\\\u201c|\\\u201d)+/\"), array('_', '.', '_'), $this->file_dst_name_body)); // Much better!\n\t            //$this->file_dst_name_body = utf8_encode(strtr(utf8_decode($this->file_dst_name_body), utf8_decode('\u0160\u017d\u0161\u017e\u0178\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff'), 'SZszYAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy'));\n\t            //$this->file_dst_name_body = strtr($this->file_dst_name_body, array('\u00de' => 'TH', '\u00fe' => 'th', '\u00d0' => 'DH', '\u00f0' => 'dh', '\u00df' => 'ss', '\u0152' => 'OE', '\u0153' => 'oe', '\u00c6' => 'AE', '\u00e6' => 'ae', '\u00b5' => 'u'));\n\t            //$this->file_dst_name_body = preg_replace(array('/\\s/', '/\\.[\\.]+/', '/[^\\w_\\.\\-]/'), array('_', '.', ''), $this->file_dst_name_body);\n                $this->log .= '- file name safe format<br />';\n            }\n\n            $this->log .= '- destination variables<br />';\n            if (empty($this->file_dst_path) || is_null($this->file_dst_path)) {\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_dst_path         : n/a<br />';\n            } else {\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_dst_path         : ' . $this->file_dst_path . '<br />';\n            }\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_dst_name_body    : ' . $this->file_dst_name_body . '<br />';\n            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_dst_name_ext     : ' . $this->file_dst_name_ext . '<br />';\n\n            // set the destination file name\n            $this->file_dst_name = $this->file_dst_name_body . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : '');\n\n            if (!$return_mode) {\n                if (!$this->file_auto_rename) {\n                    $this->log .= '- no auto_rename if same filename exists<br />';\n                    $this->file_dst_pathname = $this->file_dst_path . $this->file_dst_name;\n                } else {\n                    $this->log .= '- checking for auto_rename<br />';\n                    $this->file_dst_pathname = $this->file_dst_path . $this->file_dst_name;\n                    $body = $this->file_dst_name_body;\n                    $ext = '';\n                    // if we have changed the extension, then we add our increment before\n                    if ($file_src_name_ext != $this->file_src_name_ext) {\n                        if (substr($this->file_dst_name_body, -1 - strlen($this->file_src_name_ext)) == '.' . $this->file_src_name_ext) {\n                            $body = substr($this->file_dst_name_body, 0, strlen($this->file_dst_name_body) - 1 - strlen($this->file_src_name_ext));\n                            $ext = '.' . $this->file_src_name_ext;\n                        }\n                    }\n                    $cpt = 1;\n                    while (@file_exists($this->file_dst_pathname)) {\n                        $this->file_dst_name_body = $body . '_' . $cpt . $ext;\n                        $this->file_dst_name = $this->file_dst_name_body . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : '');\n                        $cpt++;\n                        $this->file_dst_pathname = $this->file_dst_path . $this->file_dst_name;\n                    }\n                    if ($cpt>1) $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;auto_rename to ' . $this->file_dst_name . '<br />';\n                }\n\n                $this->log .= '- destination file details<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_dst_name         : ' . $this->file_dst_name . '<br />';\n                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;file_dst_pathname     : ' . $this->file_dst_pathname . '<br />';\n\n                if ($this->file_overwrite) {\n                     $this->log .= '- no overwrite checking<br />';\n                } else {\n                    if (@file_exists($this->file_dst_pathname)) {\n                        $this->processed = false;\n                        $this->error = $this->translate('already_exists', array($this->file_dst_name));\n                    } else {\n                        $this->log .= '- ' . $this->file_dst_name . ' doesn\\'t exist already<br />';\n                    }\n                }\n            }\n        }\n\n        if ($this->processed) {\n            // if we have already moved the uploaded file, we use the temporary copy as source file, and check if it exists\n            if (!empty($this->file_src_temp)) {\n                $this->log .= '- use the temp file instead of the original file since it is a second process<br />';\n                $this->file_src_pathname   = $this->file_src_temp;\n                if (!file_exists($this->file_src_pathname)) {\n                    $this->processed = false;\n                    $this->error = $this->translate('temp_file_missing');\n                }\n            // if we haven't a temp file, and that we do check on uploads, we use is_uploaded_file()\n            } else if (!$this->no_upload_check) {\n                if (!is_uploaded_file($this->file_src_pathname)) {\n                    $this->processed = false;\n                    $this->error = $this->translate('source_missing');\n                }\n            // otherwise, if we don't check on uploaded files (local file for instance), we use file_exists()\n            } else {\n                if (!file_exists($this->file_src_pathname)) {\n                    $this->processed = false;\n                    $this->error = $this->translate('source_missing');\n                }\n            }\n\n            // checks if the destination directory exists, and attempt to create it\n            if (!$return_mode) {\n                if ($this->processed && !file_exists($this->file_dst_path)) {\n                    if ($this->dir_auto_create) {\n                        $this->log .= '- ' . $this->file_dst_path . ' doesn\\'t exist. Attempting creation:';\n                        if (!$this->rmkdir($this->file_dst_path, $this->dir_chmod)) {\n                            $this->log .= ' failed<br />';\n                            $this->processed = false;\n                            $this->error = $this->translate('destination_dir');\n                        } else {\n                            $this->log .= ' success<br />';\n                        }\n                    } else {\n                        $this->error = $this->translate('destination_dir_missing');\n                    }\n                }\n\n                if ($this->processed && !is_dir($this->file_dst_path)) {\n                    $this->processed = false;\n                    $this->error = $this->translate('destination_path_not_dir');\n                }\n\n                // checks if the destination directory is writeable, and attempt to make it writeable\n                $hash = md5($this->file_dst_name_body . rand(1, 1000));\n                if ($this->processed && !($f = @fopen($this->file_dst_path . $hash . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : ''), 'a+'))) {\n                    if ($this->dir_auto_chmod) {\n                        $this->log .= '- ' . $this->file_dst_path . ' is not writeable. Attempting chmod:';\n                        if (!@chmod($this->file_dst_path, $this->dir_chmod)) {\n                            $this->log .= ' failed<br />';\n                            $this->processed = false;\n                            $this->error = $this->translate('destination_dir_write');\n                        } else {\n                            $this->log .= ' success<br />';\n                            if (!($f = @fopen($this->file_dst_path . $hash . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : ''), 'a+'))) { // we re-check\n                                $this->processed = false;\n                                $this->error = $this->translate('destination_dir_write');\n                            } else {\n                                @fclose($f);\n                            }\n                        }\n                    } else {\n                        $this->processed = false;\n                        $this->error = $this->translate('destination_path_write');\n                    }\n                } else {\n                    if ($this->processed) @fclose($f);\n                    @unlink($this->file_dst_path . $hash . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : ''));\n                }\n\n\n                // if we have an uploaded file, and if it is the first process, and if we can't access the file directly (open_basedir restriction)\n                // then we create a temp file that will be used as the source file in subsequent processes\n                // the third condition is there to check if the file is not accessible *directly* (it already has positively gone through is_uploaded_file(), so it exists)\n                if (!$this->no_upload_check && empty($this->file_src_temp) && !@file_exists($this->file_src_pathname)) {\n                    $this->log .= '- attempting to use a temp file:';\n                    $hash = md5($this->file_dst_name_body . rand(1, 1000));\n                    if (move_uploaded_file($this->file_src_pathname, $this->file_dst_path . $hash . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : ''))) {\n                        $this->file_src_pathname = $this->file_dst_path . $hash . (!empty($this->file_dst_name_ext) ? '.' . $this->file_dst_name_ext : '');\n                        $this->file_src_temp = $this->file_src_pathname;\n                        $this->log .= ' file created<br />';\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;temp file is: ' . $this->file_src_temp . '<br />';\n                    } else {\n                        $this->log .= ' failed<br />';\n                        $this->processed = false;\n                        $this->error = $this->translate('temp_file');\n                    }\n                }\n            }\n        }\n\n        if ($this->processed) {\n\n            // check if we need to autorotate, to automatically pre-rotates the image according to EXIF data (JPEG only)\n            $auto_flip = false;\n            $auto_rotate = 0;\n            if ($this->file_is_image && $this->image_auto_rotate && $this->image_src_type == 'jpg' && $this->function_enabled('exif_read_data')) {\n                $exif = @exif_read_data($this->file_src_pathname);\n                if (is_array($exif) && isset($exif['Orientation'])) {\n                    $orientation = $exif['Orientation'];\n                    switch($orientation) {\n                      case 1:\n                        $this->log .= '- EXIF orientation = 1 : default<br />';\n                        break;\n                      case 2:\n                        $auto_flip = 'v';\n                        $this->log .= '- EXIF orientation = 2 : vertical flip<br />';\n                        break;\n                      case 3:\n                        $auto_rotate = 180;\n                        $this->log .= '- EXIF orientation = 3 : 180 rotate left<br />';\n                        break;\n                      case 4:\n                        $auto_flip = 'h';\n                        $this->log .= '- EXIF orientation = 4 : horizontal flip<br />';\n                        break;\n                      case 5:\n                        $auto_flip = 'h';\n                        $auto_rotate = 90;\n                        $this->log .= '- EXIF orientation = 5 : horizontal flip + 90 rotate right<br />';\n                        break;\n                      case 6:\n                        $auto_rotate = 90;\n                        $this->log .= '- EXIF orientation = 6 : 90 rotate right<br />';\n                        break;\n                      case 7:\n                        $auto_flip = 'v';\n                        $auto_rotate = 90;\n                        $this->log .= '- EXIF orientation = 7 : vertical flip + 90 rotate right<br />';\n                        break;\n                      case 8:\n                        $auto_rotate = 270;\n                        $this->log .= '- EXIF orientation = 8 : 90 rotate left<br />';\n                        break;\n                      default:\n                        $this->log .= '- EXIF orientation = '.$orientation.' : unknown<br />';\n                        break;\n                    }\n                } else {\n                    $this->log .= '- EXIF data is invalid or missing<br />';\n                }\n            } else {\n                if (!$this->image_auto_rotate) {\n                    $this->log .= '- auto-rotate deactivated<br />';\n                } else if (!$this->image_src_type == 'jpg') {\n                    $this->log .= '- auto-rotate applies only to JPEG images<br />';\n                } else if (!$this->function_enabled('exif_read_data')) {\n                    $this->log .= '- auto-rotate requires function exif_read_data to be enabled<br />';\n                }\n            }\n\n            // do we do some image manipulation?\n            $image_manipulation  = ($this->file_is_image && (\n                                    $this->image_resize\n                                 || $this->image_convert != ''\n                                 || is_numeric($this->image_brightness)\n                                 || is_numeric($this->image_contrast)\n                                 || is_numeric($this->image_opacity)\n                                 || is_numeric($this->image_threshold)\n                                 || !empty($this->image_tint_color)\n                                 || !empty($this->image_overlay_color)\n                                 || $this->image_pixelate\n                                 || $this->image_unsharp\n                                 || !empty($this->image_text)\n                                 || $this->image_greyscale\n                                 || $this->image_negative\n                                 || !empty($this->image_watermark)\n                                 || $auto_rotate || $auto_flip\n                                 || is_numeric($this->image_rotate)\n                                 || is_numeric($this->jpeg_size)\n                                 || !empty($this->image_flip)\n                                 || !empty($this->image_crop)\n                                 || !empty($this->image_precrop)\n                                 || !empty($this->image_border)\n                                 || !empty($this->image_border_transparent)\n                                 || $this->image_frame > 0\n                                 || $this->image_bevel > 0\n                                 || $this->image_reflection_height));\n\n            // we do a quick check to ensure the file is really an image\n            // we can do this only now, as it would have failed before in case of open_basedir\n            if ($image_manipulation && !@getimagesize($this->file_src_pathname)) {\n                $this->log .= '- the file is not an image!<br />';\n                $image_manipulation = false;\n            }\n\n            if ($image_manipulation) {\n\n                // make sure GD doesn't complain too much\n                @ini_set(\"gd.jpeg_ignore_warning\", 1);\n\n                // checks if the source file is readable\n                if ($this->processed && !($f = @fopen($this->file_src_pathname, 'r'))) {\n                    $this->processed = false;\n                    $this->error = $this->translate('source_not_readable');\n                } else {\n                    @fclose($f);\n                }\n\n                // we now do all the image manipulations\n                $this->log .= '- image resizing or conversion wanted<br />';\n                if ($this->gdversion()) {\n                    switch($this->image_src_type) {\n                        case 'jpg':\n                            if (!$this->function_enabled('imagecreatefromjpeg')) {\n                                $this->processed = false;\n                                $this->error = $this->translate('no_create_support', array('JPEG'));\n                            } else {\n                                $image_src = @imagecreatefromjpeg($this->file_src_pathname);\n                                if (!$image_src) {\n                                    $this->processed = false;\n                                    $this->error = $this->translate('create_error', array('JPEG'));\n                                } else {\n                                    $this->log .= '- source image is JPEG<br />';\n                                }\n                            }\n                            break;\n                        case 'png':\n                            if (!$this->function_enabled('imagecreatefrompng')) {\n                                $this->processed = false;\n                                $this->error = $this->translate('no_create_support', array('PNG'));\n                            } else {\n                                $image_src = @imagecreatefrompng($this->file_src_pathname);\n                                if (!$image_src) {\n                                    $this->processed = false;\n                                    $this->error = $this->translate('create_error', array('PNG'));\n                                } else {\n                                    $this->log .= '- source image is PNG<br />';\n                                }\n                            }\n                            break;\n                        case 'gif':\n                            if (!$this->function_enabled('imagecreatefromgif')) {\n                                $this->processed = false;\n                                $this->error = $this->translate('no_create_support', array('GIF'));\n                            } else {\n                                $image_src = @imagecreatefromgif($this->file_src_pathname);\n                                if (!$image_src) {\n                                    $this->processed = false;\n                                    $this->error = $this->translate('create_error', array('GIF'));\n                                } else {\n                                    $this->log .= '- source image is GIF<br />';\n                                }\n                            }\n                            break;\n                        case 'bmp':\n                            if (!method_exists($this, 'imagecreatefrombmp')) {\n                                $this->processed = false;\n                                $this->error = $this->translate('no_create_support', array('BMP'));\n                            } else {\n                                $image_src = @$this->imagecreatefrombmp($this->file_src_pathname);\n                                if (!$image_src) {\n                                    $this->processed = false;\n                                    $this->error = $this->translate('create_error', array('BMP'));\n                                } else {\n                                    $this->log .= '- source image is BMP<br />';\n                                }\n                            }\n                            break;\n                        default:\n                            $this->processed = false;\n                            $this->error = $this->translate('source_invalid');\n                    }\n                } else {\n                    $this->processed = false;\n                    $this->error = $this->translate('gd_missing');\n                }\n\n                if ($this->processed && $image_src) {\n\n                    // we have to set image_convert if it is not already\n                    if (empty($this->image_convert)) {\n                        $this->log .= '- setting destination file type to ' . $this->image_src_type . '<br />';\n                        $this->image_convert = $this->image_src_type;\n                    }\n\n                    if (!in_array($this->image_convert, $this->image_supported)) {\n                        $this->image_convert = 'jpg';\n                    }\n\n                    // we set the default color to be the background color if we don't output in a transparent format\n                    if ($this->image_convert != 'png' && $this->image_convert != 'gif' && !empty($this->image_default_color) && empty($this->image_background_color)) $this->image_background_color = $this->image_default_color;\n                    if (!empty($this->image_background_color)) $this->image_default_color = $this->image_background_color;\n                    if (empty($this->image_default_color)) $this->image_default_color = '#FFFFFF';\n\n                    $this->image_src_x = imagesx($image_src);\n                    $this->image_src_y = imagesy($image_src);\n                    $gd_version = $this->gdversion();\n                    $ratio_crop = null;\n\n                    if (!imageistruecolor($image_src)) {  // $this->image_src_type == 'gif'\n                        $this->log .= '- image is detected as having a palette<br />';\n                        $this->image_is_palette = true;\n                        $this->image_transparent_color = imagecolortransparent($image_src);\n                        if ($this->image_transparent_color >= 0 && imagecolorstotal($image_src) > $this->image_transparent_color) {\n                            $this->image_is_transparent = true;\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;palette image is detected as transparent<br />';\n                        }\n                        // if the image has a palette (GIF), we convert it to true color, preserving transparency\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;convert palette image to true color<br />';\n                        $true_color = imagecreatetruecolor($this->image_src_x, $this->image_src_y);\n                        imagealphablending($true_color, false);\n                        imagesavealpha($true_color, true);\n                        for ($x = 0; $x < $this->image_src_x; $x++) {\n                            for ($y = 0; $y < $this->image_src_y; $y++) {\n                                if ($this->image_transparent_color >= 0 && imagecolorat($image_src, $x, $y) == $this->image_transparent_color) {\n                                    imagesetpixel($true_color, $x, $y, 127 << 24);\n                                } else {\n                                    $rgb = imagecolorsforindex($image_src, imagecolorat($image_src, $x, $y));\n                                    imagesetpixel($true_color, $x, $y, ($rgb['alpha'] << 24) | ($rgb['red'] << 16) | ($rgb['green'] << 8) | $rgb['blue']);\n                                }\n                            }\n                        }\n                        $image_src = $this->imagetransfer($true_color, $image_src);\n                        imagealphablending($image_src, false);\n                        imagesavealpha($image_src, true);\n                        $this->image_is_palette = false;\n                    }\n\n                    $image_dst = & $image_src;\n\n                    // auto-flip image, according to EXIF data (JPEG only)\n                    if ($gd_version >= 2 && !empty($auto_flip)) {\n                        $this->log .= '- auto-flip image : ' . ($auto_flip == 'v' ? 'vertical' : 'horizontal') . '<br />';\n                        $tmp = $this->imagecreatenew($this->image_src_x, $this->image_src_y);\n                        for ($x = 0; $x < $this->image_src_x; $x++) {\n                            for ($y = 0; $y < $this->image_src_y; $y++){\n                                if (strpos($auto_flip, 'v') !== false) {\n                                    imagecopy($tmp, $image_dst, $this->image_src_x - $x - 1, $y, $x, $y, 1, 1);\n                                } else {\n                                    imagecopy($tmp, $image_dst, $x, $this->image_src_y - $y - 1, $x, $y, 1, 1);\n                                }\n                            }\n                        }\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // auto-rotate image, according to EXIF data (JPEG only)\n                    if ($gd_version >= 2 && is_numeric($auto_rotate)) {\n                        if (!in_array($auto_rotate, array(0, 90, 180, 270))) $auto_rotate = 0;\n                        if ($auto_rotate != 0) {\n                            if ($auto_rotate == 90 || $auto_rotate == 270) {\n                                $tmp = $this->imagecreatenew($this->image_src_y, $this->image_src_x);\n                            } else {\n                                $tmp = $this->imagecreatenew($this->image_src_x, $this->image_src_y);\n                            }\n                            $this->log .= '- auto-rotate image : ' . $auto_rotate . '<br />';\n                            for ($x = 0; $x < $this->image_src_x; $x++) {\n                                for ($y = 0; $y < $this->image_src_y; $y++){\n                                    if ($auto_rotate == 90) {\n                                        imagecopy($tmp, $image_dst, $y, $x, $x, $this->image_src_y - $y - 1, 1, 1);\n                                    } else if ($auto_rotate == 180) {\n                                        imagecopy($tmp, $image_dst, $x, $y, $this->image_src_x - $x - 1, $this->image_src_y - $y - 1, 1, 1);\n                                    } else if ($auto_rotate == 270) {\n                                        imagecopy($tmp, $image_dst, $y, $x, $this->image_src_x - $x - 1, $y, 1, 1);\n                                    } else {\n                                        imagecopy($tmp, $image_dst, $x, $y, $x, $y, 1, 1);\n                                    }\n                                }\n                            }\n                            if ($auto_rotate == 90 || $auto_rotate == 270) {\n                                $t = $this->image_src_y;\n                                $this->image_src_y = $this->image_src_x;\n                                $this->image_src_x = $t;\n                            }\n                            // we transfert tmp into image_dst\n                            $image_dst = $this->imagetransfer($tmp, $image_dst);\n                        }\n                    }\n\n                    // pre-crop image, before resizing\n                    if ((!empty($this->image_precrop))) {\n                        list($ct, $cr, $cb, $cl) = $this->getoffsets($this->image_precrop, $this->image_src_x, $this->image_src_y, true, true);\n                        $this->log .= '- pre-crop image : ' . $ct . ' ' . $cr . ' ' . $cb . ' ' . $cl . ' <br />';\n                        $this->image_src_x = $this->image_src_x - $cl - $cr;\n                        $this->image_src_y = $this->image_src_y - $ct - $cb;\n                        if ($this->image_src_x < 1) $this->image_src_x = 1;\n                        if ($this->image_src_y < 1) $this->image_src_y = 1;\n                        $tmp = $this->imagecreatenew($this->image_src_x, $this->image_src_y);\n\n                        // we copy the image into the recieving image\n                        imagecopy($tmp, $image_dst, 0, 0, $cl, $ct, $this->image_src_x, $this->image_src_y);\n\n                        // if we crop with negative margins, we have to make sure the extra bits are the right color, or transparent\n                        if ($ct < 0 || $cr < 0 || $cb < 0 || $cl < 0 ) {\n                            // use the background color if present\n                            if (!empty($this->image_background_color)) {\n                                list($red, $green, $blue) = $this->getcolors($this->image_background_color);\n                                $fill = imagecolorallocate($tmp, $red, $green, $blue);\n                            } else {\n                                $fill = imagecolorallocatealpha($tmp, 0, 0, 0, 127);\n                            }\n                            // fills eventual negative margins\n                            if ($ct < 0) imagefilledrectangle($tmp, 0, 0, $this->image_src_x, -$ct, $fill);\n                            if ($cr < 0) imagefilledrectangle($tmp, $this->image_src_x + $cr, 0, $this->image_src_x, $this->image_src_y, $fill);\n                            if ($cb < 0) imagefilledrectangle($tmp, 0, $this->image_src_y + $cb, $this->image_src_x, $this->image_src_y, $fill);\n                            if ($cl < 0) imagefilledrectangle($tmp, 0, 0, -$cl, $this->image_src_y, $fill);\n                        }\n\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // resize image (and move image_src_x, image_src_y dimensions into image_dst_x, image_dst_y)\n                    if ($this->image_resize) {\n                        $this->log .= '- resizing...<br />';\n                        $this->image_dst_x = $this->image_x;\n                        $this->image_dst_y = $this->image_y;\n\n                        // backward compatibility for soon to be deprecated settings\n                        if ($this->image_ratio_no_zoom_in) {\n                            $this->image_ratio = true;\n                            $this->image_no_enlarging = true;\n                        } else if ($this->image_ratio_no_zoom_out) {\n                            $this->image_ratio = true;\n                            $this->image_no_shrinking = true;\n                        }\n\n                        // keeps aspect ratio with x calculated from y\n                        if ($this->image_ratio_x) {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;calculate x size<br />';\n                            $this->image_dst_x = round(($this->image_src_x * $this->image_y) / $this->image_src_y);\n                            $this->image_dst_y = $this->image_y;\n\n                        // keeps aspect ratio with y calculated from x\n                        } else if ($this->image_ratio_y) {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;calculate y size<br />';\n                            $this->image_dst_x = $this->image_x;\n                            $this->image_dst_y = round(($this->image_src_y * $this->image_x) / $this->image_src_x);\n\n                        // keeps aspect ratio, calculating x and y so that the image is approx the set number of pixels\n                        } else if (is_numeric($this->image_ratio_pixels)) {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;calculate x/y size to match a number of pixels<br />';\n                            $pixels = $this->image_src_y * $this->image_src_x;\n                            $diff = sqrt($this->image_ratio_pixels / $pixels);\n                            $this->image_dst_x = round($this->image_src_x * $diff);\n                            $this->image_dst_y = round($this->image_src_y * $diff);\n\n                        // keeps aspect ratio with x and y dimensions, filling the space\n                        } else if ($this->image_ratio_crop) {\n                            if (!is_string($this->image_ratio_crop)) $this->image_ratio_crop = '';\n                            $this->image_ratio_crop = strtolower($this->image_ratio_crop);\n                            if (($this->image_src_x/$this->image_x) > ($this->image_src_y/$this->image_y)) {\n                                $this->image_dst_y = $this->image_y;\n                                $this->image_dst_x = intval($this->image_src_x*($this->image_y / $this->image_src_y));\n                                $ratio_crop = array();\n                                $ratio_crop['x'] = $this->image_dst_x - $this->image_x;\n                                if (strpos($this->image_ratio_crop, 'l') !== false) {\n                                    $ratio_crop['l'] = 0;\n                                    $ratio_crop['r'] = $ratio_crop['x'];\n                                } else if (strpos($this->image_ratio_crop, 'r') !== false) {\n                                    $ratio_crop['l'] = $ratio_crop['x'];\n                                    $ratio_crop['r'] = 0;\n                                } else {\n                                    $ratio_crop['l'] = round($ratio_crop['x']/2);\n                                    $ratio_crop['r'] = $ratio_crop['x'] - $ratio_crop['l'];\n                                }\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;ratio_crop_x         : ' . $ratio_crop['x'] . ' (' . $ratio_crop['l'] . ';' . $ratio_crop['r'] . ')<br />';\n                                if (is_null($this->image_crop)) $this->image_crop = array(0, 0, 0, 0);\n                            } else {\n                                $this->image_dst_x = $this->image_x;\n                                $this->image_dst_y = intval($this->image_src_y*($this->image_x / $this->image_src_x));\n                                $ratio_crop = array();\n                                $ratio_crop['y'] = $this->image_dst_y - $this->image_y;\n                                if (strpos($this->image_ratio_crop, 't') !== false) {\n                                    $ratio_crop['t'] = 0;\n                                    $ratio_crop['b'] = $ratio_crop['y'];\n                                } else if (strpos($this->image_ratio_crop, 'b') !== false) {\n                                    $ratio_crop['t'] = $ratio_crop['y'];\n                                    $ratio_crop['b'] = 0;\n                                } else {\n                                    $ratio_crop['t'] = round($ratio_crop['y']/2);\n                                    $ratio_crop['b'] = $ratio_crop['y'] - $ratio_crop['t'];\n                                }\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;ratio_crop_y         : ' . $ratio_crop['y'] . ' (' . $ratio_crop['t'] . ';' . $ratio_crop['b'] . ')<br />';\n                                if (is_null($this->image_crop)) $this->image_crop = array(0, 0, 0, 0);\n                            }\n\n                        // keeps aspect ratio with x and y dimensions, fitting the image in the space, and coloring the rest\n                        } else if ($this->image_ratio_fill) {\n                            if (!is_string($this->image_ratio_fill)) $this->image_ratio_fill = '';\n                            $this->image_ratio_fill = strtolower($this->image_ratio_fill);\n                            if (($this->image_src_x/$this->image_x) < ($this->image_src_y/$this->image_y)) {\n                                $this->image_dst_y = $this->image_y;\n                                $this->image_dst_x = intval($this->image_src_x*($this->image_y / $this->image_src_y));\n                                $ratio_crop = array();\n                                $ratio_crop['x'] = $this->image_dst_x - $this->image_x;\n                                if (strpos($this->image_ratio_fill, 'l') !== false) {\n                                    $ratio_crop['l'] = 0;\n                                    $ratio_crop['r'] = $ratio_crop['x'];\n                                } else if (strpos($this->image_ratio_fill, 'r') !== false) {\n                                    $ratio_crop['l'] = $ratio_crop['x'];\n                                    $ratio_crop['r'] = 0;\n                                } else {\n                                    $ratio_crop['l'] = round($ratio_crop['x']/2);\n                                    $ratio_crop['r'] = $ratio_crop['x'] - $ratio_crop['l'];\n                                }\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;ratio_fill_x         : ' . $ratio_crop['x'] . ' (' . $ratio_crop['l'] . ';' . $ratio_crop['r'] . ')<br />';\n                                if (is_null($this->image_crop)) $this->image_crop = array(0, 0, 0, 0);\n                            } else {\n                                $this->image_dst_x = $this->image_x;\n                                $this->image_dst_y = intval($this->image_src_y*($this->image_x / $this->image_src_x));\n                                $ratio_crop = array();\n                                $ratio_crop['y'] = $this->image_dst_y - $this->image_y;\n                                if (strpos($this->image_ratio_fill, 't') !== false) {\n                                    $ratio_crop['t'] = 0;\n                                    $ratio_crop['b'] = $ratio_crop['y'];\n                                } else if (strpos($this->image_ratio_fill, 'b') !== false) {\n                                    $ratio_crop['t'] = $ratio_crop['y'];\n                                    $ratio_crop['b'] = 0;\n                                } else {\n                                    $ratio_crop['t'] = round($ratio_crop['y']/2);\n                                    $ratio_crop['b'] = $ratio_crop['y'] - $ratio_crop['t'];\n                                }\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;ratio_fill_y         : ' . $ratio_crop['y'] . ' (' . $ratio_crop['t'] . ';' . $ratio_crop['b'] . ')<br />';\n                                if (is_null($this->image_crop)) $this->image_crop = array(0, 0, 0, 0);\n                            }\n\n                        // keeps aspect ratio with x and y dimensions\n                        } else if ($this->image_ratio) {\n                            if (($this->image_src_x/$this->image_x) > ($this->image_src_y/$this->image_y)) {\n                                $this->image_dst_x = $this->image_x;\n                                $this->image_dst_y = intval($this->image_src_y*($this->image_x / $this->image_src_x));\n                            } else {\n                                $this->image_dst_y = $this->image_y;\n                                $this->image_dst_x = intval($this->image_src_x*($this->image_y / $this->image_src_y));\n                            }\n\n                        // resize to provided exact dimensions\n                        } else {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;use plain sizes<br />';\n                            $this->image_dst_x = $this->image_x;\n                            $this->image_dst_y = $this->image_y;\n                        }\n\n                        if ($this->image_dst_x < 1) $this->image_dst_x = 1;\n                        if ($this->image_dst_y < 1) $this->image_dst_y = 1;\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_src_x y        : ' . $this->image_src_x . ' x ' . $this->image_src_y . '<br />';\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image_dst_x y        : ' . $this->image_dst_x . ' x ' . $this->image_dst_y . '<br />';\n\n                        // make sure we don't enlarge the image if we don't want to\n                        if ($this->image_no_enlarging && ($this->image_src_x < $this->image_dst_x || $this->image_src_y < $this->image_dst_y)) {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;cancel resizing, as it would enlarge the image!<br />';\n                            $this->image_dst_x = $this->image_src_x;\n                            $this->image_dst_y = $this->image_src_y;\n                        }\n\n                        // make sure we don't shrink the image if we don't want to\n                        if ($this->image_no_shrinking && ($this->image_src_x > $this->image_dst_x || $this->image_src_y > $this->image_dst_y)) {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;cancel resizing, as it would shrink the image!<br />';\n                            $this->image_dst_x = $this->image_src_x;\n                            $this->image_dst_y = $this->image_src_y;\n                        }\n\n                        // resize the image\n                        if ($this->image_dst_x != $this->image_src_x && $this->image_dst_y != $this->image_src_y) {\n                            $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n\n                            if ($gd_version >= 2) {\n                                $res = imagecopyresampled($tmp, $image_src, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, $this->image_src_x, $this->image_src_y);\n                            } else {\n                                $res = imagecopyresized($tmp, $image_src, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, $this->image_src_x, $this->image_src_y);\n                            }\n\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;resized image object created<br />';\n                             // we transfert tmp into image_dst\n                            $image_dst = $this->imagetransfer($tmp, $image_dst);\n                        }\n\n                    } else {\n                        $this->image_dst_x = $this->image_src_x;\n                        $this->image_dst_y = $this->image_src_y;\n                    }\n\n                    // crop image (and also crops if image_ratio_crop is used)\n                    if ((!empty($this->image_crop) || !is_null($ratio_crop))) {\n                        list($ct, $cr, $cb, $cl) = $this->getoffsets($this->image_crop, $this->image_dst_x, $this->image_dst_y, true, true);\n                        // we adjust the cropping if we use image_ratio_crop\n                        if (!is_null($ratio_crop)) {\n                            if (array_key_exists('t', $ratio_crop)) $ct += $ratio_crop['t'];\n                            if (array_key_exists('r', $ratio_crop)) $cr += $ratio_crop['r'];\n                            if (array_key_exists('b', $ratio_crop)) $cb += $ratio_crop['b'];\n                            if (array_key_exists('l', $ratio_crop)) $cl += $ratio_crop['l'];\n                        }\n                        $this->log .= '- crop image : ' . $ct . ' ' . $cr . ' ' . $cb . ' ' . $cl . ' <br />';\n                        $this->image_dst_x = $this->image_dst_x - $cl - $cr;\n                        $this->image_dst_y = $this->image_dst_y - $ct - $cb;\n                        if ($this->image_dst_x < 1) $this->image_dst_x = 1;\n                        if ($this->image_dst_y < 1) $this->image_dst_y = 1;\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n\n                        // we copy the image into the recieving image\n                        imagecopy($tmp, $image_dst, 0, 0, $cl, $ct, $this->image_dst_x, $this->image_dst_y);\n\n                        // if we crop with negative margins, we have to make sure the extra bits are the right color, or transparent\n                        if ($ct < 0 || $cr < 0 || $cb < 0 || $cl < 0 ) {\n                            // use the background color if present\n                            if (!empty($this->image_background_color)) {\n                                list($red, $green, $blue) = $this->getcolors($this->image_background_color);\n                                $fill = imagecolorallocate($tmp, $red, $green, $blue);\n                            } else {\n                                $fill = imagecolorallocatealpha($tmp, 0, 0, 0, 127);\n                            }\n                            // fills eventual negative margins\n                            if ($ct < 0) imagefilledrectangle($tmp, 0, 0, $this->image_dst_x, -$ct-1, $fill);\n                            if ($cr < 0) imagefilledrectangle($tmp, $this->image_dst_x + $cr, 0, $this->image_dst_x, $this->image_dst_y, $fill);\n                            if ($cb < 0) imagefilledrectangle($tmp, 0, $this->image_dst_y + $cb, $this->image_dst_x, $this->image_dst_y, $fill);\n                            if ($cl < 0) imagefilledrectangle($tmp, 0, 0, -$cl-1, $this->image_dst_y, $fill);\n                        }\n\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // flip image\n                    if ($gd_version >= 2 && !empty($this->image_flip)) {\n                        $this->image_flip = strtolower($this->image_flip);\n                        $this->log .= '- flip image : ' . $this->image_flip . '<br />';\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                        for ($x = 0; $x < $this->image_dst_x; $x++) {\n                            for ($y = 0; $y < $this->image_dst_y; $y++){\n                                if (strpos($this->image_flip, 'v') !== false) {\n                                    imagecopy($tmp, $image_dst, $this->image_dst_x - $x - 1, $y, $x, $y, 1, 1);\n                                } else {\n                                    imagecopy($tmp, $image_dst, $x, $this->image_dst_y - $y - 1, $x, $y, 1, 1);\n                                }\n                            }\n                        }\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // rotate image\n                    if ($gd_version >= 2 && is_numeric($this->image_rotate)) {\n                        if (!in_array($this->image_rotate, array(0, 90, 180, 270))) $this->image_rotate = 0;\n                        if ($this->image_rotate != 0) {\n                            if ($this->image_rotate == 90 || $this->image_rotate == 270) {\n                                $tmp = $this->imagecreatenew($this->image_dst_y, $this->image_dst_x);\n                            } else {\n                                $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                            }\n                            $this->log .= '- rotate image : ' . $this->image_rotate . '<br />';\n                            for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                for ($y = 0; $y < $this->image_dst_y; $y++){\n                                    if ($this->image_rotate == 90) {\n                                        imagecopy($tmp, $image_dst, $y, $x, $x, $this->image_dst_y - $y - 1, 1, 1);\n                                    } else if ($this->image_rotate == 180) {\n                                        imagecopy($tmp, $image_dst, $x, $y, $this->image_dst_x - $x - 1, $this->image_dst_y - $y - 1, 1, 1);\n                                    } else if ($this->image_rotate == 270) {\n                                        imagecopy($tmp, $image_dst, $y, $x, $this->image_dst_x - $x - 1, $y, 1, 1);\n                                    } else {\n                                        imagecopy($tmp, $image_dst, $x, $y, $x, $y, 1, 1);\n                                    }\n                                }\n                            }\n                            if ($this->image_rotate == 90 || $this->image_rotate == 270) {\n                                $t = $this->image_dst_y;\n                                $this->image_dst_y = $this->image_dst_x;\n                                $this->image_dst_x = $t;\n                            }\n                            // we transfert tmp into image_dst\n                            $image_dst = $this->imagetransfer($tmp, $image_dst);\n                        }\n                    }\n\n                    // pixelate image\n                    if ((is_numeric($this->image_pixelate) && $this->image_pixelate > 0)) {\n                        $this->log .= '- pixelate image (' . $this->image_pixelate . 'px)<br />';\n                        $filter = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                        if ($gd_version >= 2) {\n                            imagecopyresampled($filter, $image_dst, 0, 0, 0, 0, round($this->image_dst_x / $this->image_pixelate), round($this->image_dst_y / $this->image_pixelate), $this->image_dst_x, $this->image_dst_y);\n                            imagecopyresampled($image_dst, $filter, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, round($this->image_dst_x / $this->image_pixelate), round($this->image_dst_y / $this->image_pixelate));\n                        } else {\n                            imagecopyresized($filter, $image_dst, 0, 0, 0, 0, round($this->image_dst_x / $this->image_pixelate), round($this->image_dst_y / $this->image_pixelate), $this->image_dst_x, $this->image_dst_y);\n                            imagecopyresized($image_dst, $filter, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, round($this->image_dst_x / $this->image_pixelate), round($this->image_dst_y / $this->image_pixelate));\n                        }\n                        imagedestroy($filter);\n                    }\n\n                    // unsharp mask\n                    if ($gd_version >= 2 && $this->image_unsharp && is_numeric($this->image_unsharp_amount) && is_numeric($this->image_unsharp_radius) && is_numeric($this->image_unsharp_threshold)) {\n                        // Unsharp Mask for PHP - version 2.1.1\n                        // Unsharp mask algorithm by Torstein H\u00f8nsi 2003-07.\n                        // Used with permission\n                        // Modified to support alpha transparency\n                        if ($this->image_unsharp_amount > 500)    $this->image_unsharp_amount = 500;\n                        $this->image_unsharp_amount = $this->image_unsharp_amount * 0.016;\n                        if ($this->image_unsharp_radius > 50)    $this->image_unsharp_radius = 50;\n                        $this->image_unsharp_radius = $this->image_unsharp_radius * 2;\n                        if ($this->image_unsharp_threshold > 255)    $this->image_unsharp_threshold = 255;\n                        $this->image_unsharp_radius = abs(round($this->image_unsharp_radius));\n                        if ($this->image_unsharp_radius != 0) {\n                            $this->image_dst_x = imagesx($image_dst); $this->image_dst_y = imagesy($image_dst);\n                            $canvas = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y, false, true);\n                            $blur = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y, false, true);\n                            if ($this->function_enabled('imageconvolution')) { // PHP >= 5.1\n                                $matrix = array(array( 1, 2, 1 ), array( 2, 4, 2 ), array( 1, 2, 1 ));\n                                imagecopy($blur, $image_dst, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y);\n                                imageconvolution($blur, $matrix, 16, 0);\n                            } else {\n                                for ($i = 0; $i < $this->image_unsharp_radius; $i++) {\n                                    imagecopy($blur, $image_dst, 0, 0, 1, 0, $this->image_dst_x - 1, $this->image_dst_y); // left\n                                    $this->imagecopymergealpha($blur, $image_dst, 1, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, 50); // right\n                                    $this->imagecopymergealpha($blur, $image_dst, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, 50); // center\n                                    imagecopy($canvas, $blur, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y);\n                                    $this->imagecopymergealpha($blur, $canvas, 0, 0, 0, 1, $this->image_dst_x, $this->image_dst_y - 1, 33.33333 ); // up\n                                    $this->imagecopymergealpha($blur, $canvas, 0, 1, 0, 0, $this->image_dst_x, $this->image_dst_y, 25); // down\n                                }\n                            }\n                            $p_new = array();\n                            if($this->image_unsharp_threshold>0) {\n                                for ($x = 0; $x < $this->image_dst_x-1; $x++) {\n                                    for ($y = 0; $y < $this->image_dst_y; $y++) {\n                                        $p_orig = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                        $p_blur = imagecolorsforindex($blur, imagecolorat($blur, $x, $y));\n                                        $p_new['red'] = (abs($p_orig['red'] - $p_blur['red']) >= $this->image_unsharp_threshold) ? max(0, min(255, ($this->image_unsharp_amount * ($p_orig['red'] - $p_blur['red'])) + $p_orig['red'])) : $p_orig['red'];\n                                        $p_new['green'] = (abs($p_orig['green'] - $p_blur['green']) >= $this->image_unsharp_threshold) ? max(0, min(255, ($this->image_unsharp_amount * ($p_orig['green'] - $p_blur['green'])) + $p_orig['green'])) : $p_orig['green'];\n                                        $p_new['blue'] = (abs($p_orig['blue'] - $p_blur['blue']) >= $this->image_unsharp_threshold) ? max(0, min(255, ($this->image_unsharp_amount * ($p_orig['blue'] - $p_blur['blue'])) + $p_orig['blue'])) : $p_orig['blue'];\n                                        if (($p_orig['red'] != $p_new['red']) || ($p_orig['green'] != $p_new['green']) || ($p_orig['blue'] != $p_new['blue'])) {\n                                            $color = imagecolorallocatealpha($image_dst, $p_new['red'], $p_new['green'], $p_new['blue'], $p_orig['alpha']);\n                                            imagesetpixel($image_dst, $x, $y, $color);\n                                        }\n                                    }\n                                }\n                            } else {\n                                for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                    for ($y = 0; $y < $this->image_dst_y; $y++) {\n                                        $p_orig = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                        $p_blur = imagecolorsforindex($blur, imagecolorat($blur, $x, $y));\n                                        $p_new['red'] = ($this->image_unsharp_amount * ($p_orig['red'] - $p_blur['red'])) + $p_orig['red'];\n                                        if ($p_new['red']>255) { $p_new['red']=255; } elseif ($p_new['red']<0) { $p_new['red']=0; }\n                                        $p_new['green'] = ($this->image_unsharp_amount * ($p_orig['green'] - $p_blur['green'])) + $p_orig['green'];\n                                        if ($p_new['green']>255) { $p_new['green']=255; }  elseif ($p_new['green']<0) { $p_new['green']=0; }\n                                        $p_new['blue'] = ($this->image_unsharp_amount * ($p_orig['blue'] - $p_blur['blue'])) + $p_orig['blue'];\n                                        if ($p_new['blue']>255) { $p_new['blue']=255; } elseif ($p_new['blue']<0) { $p_new['blue']=0; }\n                                        $color = imagecolorallocatealpha($image_dst, $p_new['red'], $p_new['green'], $p_new['blue'], $p_orig['alpha']);\n                                        imagesetpixel($image_dst, $x, $y, $color);\n                                    }\n                                }\n                            }\n                            imagedestroy($canvas);\n                            imagedestroy($blur);\n                        }\n                    }\n\n                    // add color overlay\n                    if ($gd_version >= 2 && (is_numeric($this->image_overlay_opacity) && $this->image_overlay_opacity > 0 && !empty($this->image_overlay_color))) {\n                        $this->log .= '- apply color overlay<br />';\n                        list($red, $green, $blue) = $this->getcolors($this->image_overlay_color);\n                        $filter = imagecreatetruecolor($this->image_dst_x, $this->image_dst_y);\n                        $color = imagecolorallocate($filter, $red, $green, $blue);\n                        imagefilledrectangle($filter, 0, 0, $this->image_dst_x, $this->image_dst_y, $color);\n                        $this->imagecopymergealpha($image_dst, $filter, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y, $this->image_overlay_opacity);\n                        imagedestroy($filter);\n                    }\n\n                    // add brightness, contrast and tint, turns to greyscale and inverts colors\n                    if ($gd_version >= 2 && ($this->image_negative || $this->image_greyscale || is_numeric($this->image_threshold)|| is_numeric($this->image_brightness) || is_numeric($this->image_contrast) || !empty($this->image_tint_color))) {\n                        $this->log .= '- apply tint, light, contrast correction, negative, greyscale and threshold<br />';\n                        if (!empty($this->image_tint_color)) list($tint_red, $tint_green, $tint_blue) = $this->getcolors($this->image_tint_color);\n                        //imagealphablending($image_dst, true);\n                        for($y=0; $y < $this->image_dst_y; $y++) {\n                            for($x=0; $x < $this->image_dst_x; $x++) {\n                                if ($this->image_greyscale) {\n                                    $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    $r = $g = $b = round((0.2125 * $pixel['red']) + (0.7154 * $pixel['green']) + (0.0721 * $pixel['blue']));\n                                    $color = imagecolorallocatealpha($image_dst, $r, $g, $b, $pixel['alpha']);\n                                    imagesetpixel($image_dst, $x, $y, $color);\n                                    unset($color); unset($pixel);\n                                }\n                                if (is_numeric($this->image_threshold)) {\n                                    $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    $c = (round($pixel['red'] + $pixel['green'] + $pixel['blue']) / 3) - 127;\n                                    $r = $g = $b = ($c > $this->image_threshold ? 255 : 0);\n                                    $color = imagecolorallocatealpha($image_dst, $r, $g, $b, $pixel['alpha']);\n                                    imagesetpixel($image_dst, $x, $y, $color);\n                                    unset($color); unset($pixel);\n                                }\n                                if (is_numeric($this->image_brightness)) {\n                                    $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    $r = max(min(round($pixel['red'] + (($this->image_brightness * 2))), 255), 0);\n                                    $g = max(min(round($pixel['green'] + (($this->image_brightness * 2))), 255), 0);\n                                    $b = max(min(round($pixel['blue'] + (($this->image_brightness * 2))), 255), 0);\n                                    $color = imagecolorallocatealpha($image_dst, $r, $g, $b, $pixel['alpha']);\n                                    imagesetpixel($image_dst, $x, $y, $color);\n                                    unset($color); unset($pixel);\n                                }\n                                if (is_numeric($this->image_contrast)) {\n                                    $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    $r = max(min(round(($this->image_contrast + 128) * $pixel['red'] / 128), 255), 0);\n                                    $g = max(min(round(($this->image_contrast + 128) * $pixel['green'] / 128), 255), 0);\n                                    $b = max(min(round(($this->image_contrast + 128) * $pixel['blue'] / 128), 255), 0);\n                                    $color = imagecolorallocatealpha($image_dst, $r, $g, $b, $pixel['alpha']);\n                                    imagesetpixel($image_dst, $x, $y, $color);\n                                    unset($color); unset($pixel);\n                                }\n                                if (!empty($this->image_tint_color)) {\n                                    $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    $r = min(round($tint_red * $pixel['red'] / 169), 255);\n                                    $g = min(round($tint_green * $pixel['green'] / 169), 255);\n                                    $b = min(round($tint_blue * $pixel['blue'] / 169), 255);\n                                    $color = imagecolorallocatealpha($image_dst, $r, $g, $b, $pixel['alpha']);\n                                    imagesetpixel($image_dst, $x, $y, $color);\n                                    unset($color); unset($pixel);\n                                }\n                                if (!empty($this->image_negative)) {\n                                    $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    $r = round(255 - $pixel['red']);\n                                    $g = round(255 - $pixel['green']);\n                                    $b = round(255 - $pixel['blue']);\n                                    $color = imagecolorallocatealpha($image_dst, $r, $g, $b, $pixel['alpha']);\n                                    imagesetpixel($image_dst, $x, $y, $color);\n                                    unset($color); unset($pixel);\n                                }\n                            }\n                        }\n                    }\n\n                    // adds a border\n                    if ($gd_version >= 2 && !empty($this->image_border)) {\n                        list($ct, $cr, $cb, $cl) = $this->getoffsets($this->image_border, $this->image_dst_x, $this->image_dst_y, true, false);\n                        $this->log .= '- add border : ' . $ct . ' ' . $cr . ' ' . $cb . ' ' . $cl . '<br />';\n                        $this->image_dst_x = $this->image_dst_x + $cl + $cr;\n                        $this->image_dst_y = $this->image_dst_y + $ct + $cb;\n                        if (!empty($this->image_border_color)) list($red, $green, $blue) = $this->getcolors($this->image_border_color);\n                        $opacity = (is_numeric($this->image_border_opacity) ? (int) (127 - $this->image_border_opacity / 100 * 127): 0);\n                        // we now create an image, that we fill with the border color\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                        $background = imagecolorallocatealpha($tmp, $red, $green, $blue, $opacity);\n                        imagefilledrectangle($tmp, 0, 0, $this->image_dst_x, $this->image_dst_y, $background);\n                        // we then copy the source image into the new image, without merging so that only the border is actually kept\n                        imagecopy($tmp, $image_dst, $cl, $ct, 0, 0, $this->image_dst_x - $cr - $cl, $this->image_dst_y - $cb - $ct);\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // adds a fading-to-transparent border\n                    if ($gd_version >= 2 && !empty($this->image_border_transparent)) {\n                        list($ct, $cr, $cb, $cl) = $this->getoffsets($this->image_border_transparent, $this->image_dst_x, $this->image_dst_y, true, false);\n                        $this->log .= '- add transparent border : ' . $ct . ' ' . $cr . ' ' . $cb . ' ' . $cl . '<br />';\n                        // we now create an image, that we fill with the border color\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                        // we then copy the source image into the new image, without the borders\n                        imagecopy($tmp, $image_dst, $cl, $ct, $cl, $ct, $this->image_dst_x - $cr - $cl, $this->image_dst_y - $cb - $ct);\n                        // we now add the top border\n                        $opacity = 100;\n                        for ($y = $ct - 1; $y >= 0; $y--) {\n                            $il = (int) ($ct > 0 ? ($cl * ($y / $ct)) : 0);\n                            $ir = (int) ($ct > 0 ? ($cr * ($y / $ct)) : 0);\n                            for ($x = $il; $x < $this->image_dst_x - $ir; $x++) {\n                                $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                $alpha = (1 - ($pixel['alpha'] / 127)) * $opacity / 100;\n                                if ($alpha > 0) {\n                                    if ($alpha > 1) $alpha = 1;\n                                    $color = imagecolorallocatealpha($tmp, $pixel['red'] , $pixel['green'], $pixel['blue'],  round((1 - $alpha) * 127));\n                                    imagesetpixel($tmp, $x, $y, $color);\n                                }\n                            }\n                            if ($opacity > 0) $opacity = $opacity - (100 / $ct);\n                        }\n                        // we now add the right border\n                        $opacity = 100;\n                        for ($x = $this->image_dst_x - $cr; $x < $this->image_dst_x; $x++) {\n                            $it = (int) ($cr > 0 ? ($ct * (($this->image_dst_x - $x - 1) / $cr)) : 0);\n                            $ib = (int) ($cr > 0 ? ($cb * (($this->image_dst_x - $x - 1) / $cr)) : 0);\n                            for ($y = $it; $y < $this->image_dst_y - $ib; $y++) {\n                                $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                $alpha = (1 - ($pixel['alpha'] / 127)) * $opacity / 100;\n                                if ($alpha > 0) {\n                                    if ($alpha > 1) $alpha = 1;\n                                    $color = imagecolorallocatealpha($tmp, $pixel['red'] , $pixel['green'], $pixel['blue'],  round((1 - $alpha) * 127));\n                                    imagesetpixel($tmp, $x, $y, $color);\n                                }\n                            }\n                            if ($opacity > 0) $opacity = $opacity - (100 / $cr);\n                        }\n                        // we now add the bottom border\n                        $opacity = 100;\n                        for ($y = $this->image_dst_y - $cb; $y < $this->image_dst_y; $y++) {\n                            $il = (int) ($cb > 0 ? ($cl * (($this->image_dst_y - $y - 1) / $cb)) : 0);\n                            $ir = (int) ($cb > 0 ? ($cr * (($this->image_dst_y - $y - 1) / $cb)) : 0);\n                            for ($x = $il; $x < $this->image_dst_x - $ir; $x++) {\n                                $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                $alpha = (1 - ($pixel['alpha'] / 127)) * $opacity / 100;\n                                if ($alpha > 0) {\n                                    if ($alpha > 1) $alpha = 1;\n                                    $color = imagecolorallocatealpha($tmp, $pixel['red'] , $pixel['green'], $pixel['blue'],  round((1 - $alpha) * 127));\n                                    imagesetpixel($tmp, $x, $y, $color);\n                                }\n                            }\n                            if ($opacity > 0) $opacity = $opacity - (100 / $cb);\n                        }\n                        // we now add the left border\n                        $opacity = 100;\n                        for ($x = $cl - 1; $x >= 0; $x--) {\n                            $it = (int) ($cl > 0 ? ($ct * ($x / $cl)) : 0);\n                            $ib = (int) ($cl > 0 ? ($cb * ($x / $cl)) : 0);\n                            for ($y = $it; $y < $this->image_dst_y - $ib; $y++) {\n                                $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                $alpha = (1 - ($pixel['alpha'] / 127)) * $opacity / 100;\n                                if ($alpha > 0) {\n                                    if ($alpha > 1) $alpha = 1;\n                                    $color = imagecolorallocatealpha($tmp, $pixel['red'] , $pixel['green'], $pixel['blue'],  round((1 - $alpha) * 127));\n                                    imagesetpixel($tmp, $x, $y, $color);\n                                }\n                            }\n                            if ($opacity > 0) $opacity = $opacity - (100 / $cl);\n                        }\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // add frame border\n                    if ($gd_version >= 2 && is_numeric($this->image_frame)) {\n                        if (is_array($this->image_frame_colors)) {\n                            $vars = $this->image_frame_colors;\n                            $this->log .= '- add frame : ' . implode(' ', $this->image_frame_colors) . '<br />';\n                        } else {\n                            $this->log .= '- add frame : ' . $this->image_frame_colors . '<br />';\n                            $vars = explode(' ', $this->image_frame_colors);\n                        }\n                        $nb = sizeof($vars);\n                        $this->image_dst_x = $this->image_dst_x + ($nb * 2);\n                        $this->image_dst_y = $this->image_dst_y + ($nb * 2);\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                        imagecopy($tmp, $image_dst, $nb, $nb, 0, 0, $this->image_dst_x - ($nb * 2), $this->image_dst_y - ($nb * 2));\n                        $opacity = (is_numeric($this->image_frame_opacity) ? (int) (127 - $this->image_frame_opacity / 100 * 127): 0);\n                        for ($i=0; $i<$nb; $i++) {\n                            list($red, $green, $blue) = $this->getcolors($vars[$i]);\n                            $c = imagecolorallocatealpha($tmp, $red, $green, $blue, $opacity);\n                            if ($this->image_frame == 1) {\n                                imageline($tmp, $i, $i, $this->image_dst_x - $i -1, $i, $c);\n                                imageline($tmp, $this->image_dst_x - $i -1, $this->image_dst_y - $i -1, $this->image_dst_x - $i -1, $i, $c);\n                                imageline($tmp, $this->image_dst_x - $i -1, $this->image_dst_y - $i -1, $i, $this->image_dst_y - $i -1, $c);\n                                imageline($tmp, $i, $i, $i, $this->image_dst_y - $i -1, $c);\n                            } else {\n                                imageline($tmp, $i, $i, $this->image_dst_x - $i -1, $i, $c);\n                                imageline($tmp, $this->image_dst_x - $nb + $i, $this->image_dst_y - $nb + $i, $this->image_dst_x - $nb + $i, $nb - $i, $c);\n                                imageline($tmp, $this->image_dst_x - $nb + $i, $this->image_dst_y - $nb + $i, $nb - $i, $this->image_dst_y - $nb + $i, $c);\n                                imageline($tmp, $i, $i, $i, $this->image_dst_y - $i -1, $c);\n                            }\n                        }\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // add bevel border\n                    if ($gd_version >= 2 && $this->image_bevel > 0) {\n                        if (empty($this->image_bevel_color1)) $this->image_bevel_color1 = '#FFFFFF';\n                        if (empty($this->image_bevel_color2)) $this->image_bevel_color2 = '#000000';\n                        list($red1, $green1, $blue1) = $this->getcolors($this->image_bevel_color1);\n                        list($red2, $green2, $blue2) = $this->getcolors($this->image_bevel_color2);\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y);\n                        imagecopy($tmp, $image_dst, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y);\n                        imagealphablending($tmp, true);\n                        for ($i=0; $i<$this->image_bevel; $i++) {\n                            $alpha = round(($i / $this->image_bevel) * 127);\n                            $c1 = imagecolorallocatealpha($tmp, $red1, $green1, $blue1, $alpha);\n                            $c2 = imagecolorallocatealpha($tmp, $red2, $green2, $blue2, $alpha);\n                            imageline($tmp, $i, $i, $this->image_dst_x - $i -1, $i, $c1);\n                            imageline($tmp, $this->image_dst_x - $i -1, $this->image_dst_y - $i, $this->image_dst_x - $i -1, $i, $c2);\n                            imageline($tmp, $this->image_dst_x - $i -1, $this->image_dst_y - $i -1, $i, $this->image_dst_y - $i -1, $c2);\n                            imageline($tmp, $i, $i, $i, $this->image_dst_y - $i -1, $c1);\n                        }\n                        // we transfert tmp into image_dst\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // add watermark image\n                    if ($this->image_watermark!='' && file_exists($this->image_watermark)) {\n                        $this->log .= '- add watermark<br />';\n                        $this->image_watermark_position = strtolower($this->image_watermark_position);\n                        $watermark_info = getimagesize($this->image_watermark);\n                        $watermark_type = (array_key_exists(2, $watermark_info) ? $watermark_info[2] : null); // 1 = GIF, 2 = JPG, 3 = PNG\n                        $watermark_checked = false;\n                        if ($watermark_type == IMAGETYPE_GIF) {\n                            if (!$this->function_enabled('imagecreatefromgif')) {\n                                $this->error = $this->translate('watermark_no_create_support', array('GIF'));\n                            } else {\n                                $filter = @imagecreatefromgif($this->image_watermark);\n                                if (!$filter) {\n                                    $this->error = $this->translate('watermark_create_error', array('GIF'));\n                                } else {\n                                    $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;watermark source image is GIF<br />';\n                                    $watermark_checked = true;\n                                }\n                            }\n                        } else if ($watermark_type == IMAGETYPE_JPEG) {\n                            if (!$this->function_enabled('imagecreatefromjpeg')) {\n                                $this->error = $this->translate('watermark_no_create_support', array('JPEG'));\n                            } else {\n                                $filter = @imagecreatefromjpeg($this->image_watermark);\n                                if (!$filter) {\n                                    $this->error = $this->translate('watermark_create_error', array('JPEG'));\n                                } else {\n                                    $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;watermark source image is JPEG<br />';\n                                    $watermark_checked = true;\n                                }\n                            }\n                        } else if ($watermark_type == IMAGETYPE_PNG) {\n                            if (!$this->function_enabled('imagecreatefrompng')) {\n                                $this->error = $this->translate('watermark_no_create_support', array('PNG'));\n                            } else {\n                                $filter = @imagecreatefrompng($this->image_watermark);\n                                if (!$filter) {\n                                    $this->error = $this->translate('watermark_create_error', array('PNG'));\n                                } else {\n                                    $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;watermark source image is PNG<br />';\n                                    $watermark_checked = true;\n                                }\n                            }\n                        } else if ($watermark_type == IMAGETYPE_BMP) {\n                            if (!method_exists($this, 'imagecreatefrombmp')) {\n                                $this->error = $this->translate('watermark_no_create_support', array('BMP'));\n                            } else {\n                                $filter = @$this->imagecreatefrombmp($this->image_watermark);\n                                if (!$filter) {\n                                    $this->error = $this->translate('watermark_create_error', array('BMP'));\n                                } else {\n                                    $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;watermark source image is BMP<br />';\n                                    $watermark_checked = true;\n                                }\n                            }\n                        } else {\n                            $this->error = $this->translate('watermark_invalid');\n                        }\n                        if ($watermark_checked) {\n                            $watermark_dst_width  = $watermark_src_width  = imagesx($filter);\n                            $watermark_dst_height = $watermark_src_height = imagesy($filter);\n\n                            // if watermark is too large/tall, resize it first\n                            if ((!$this->image_watermark_no_zoom_out && ($watermark_dst_width > $this->image_dst_x || $watermark_dst_height > $this->image_dst_y))\n                             || (!$this->image_watermark_no_zoom_in && $watermark_dst_width < $this->image_dst_x && $watermark_dst_height < $this->image_dst_y)) {\n                                $canvas_width  = $this->image_dst_x - abs($this->image_watermark_x);\n                                $canvas_height = $this->image_dst_y - abs($this->image_watermark_y);\n                                if (($watermark_src_width/$canvas_width) > ($watermark_src_height/$canvas_height)) {\n                                    $watermark_dst_width = $canvas_width;\n                                    $watermark_dst_height = intval($watermark_src_height*($canvas_width / $watermark_src_width));\n                                } else {\n                                    $watermark_dst_height = $canvas_height;\n                                    $watermark_dst_width = intval($watermark_src_width*($canvas_height / $watermark_src_height));\n                                }\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;watermark resized from '.$watermark_src_width.'x'.$watermark_src_height.' to '.$watermark_dst_width.'x'.$watermark_dst_height.'<br />';\n\n                            }\n                            // determine watermark position\n                            $watermark_x = 0;\n                            $watermark_y = 0;\n                            if (is_numeric($this->image_watermark_x)) {\n                                if ($this->image_watermark_x < 0) {\n                                    $watermark_x = $this->image_dst_x - $watermark_dst_width + $this->image_watermark_x;\n                                } else {\n                                    $watermark_x = $this->image_watermark_x;\n                                }\n                            } else {\n                                if (strpos($this->image_watermark_position, 'r') !== false) {\n                                    $watermark_x = $this->image_dst_x - $watermark_dst_width;\n                                } else if (strpos($this->image_watermark_position, 'l') !== false) {\n                                    $watermark_x = 0;\n                                } else {\n                                    $watermark_x = ($this->image_dst_x - $watermark_dst_width) / 2;\n                                }\n                            }\n                            if (is_numeric($this->image_watermark_y)) {\n                                if ($this->image_watermark_y < 0) {\n                                    $watermark_y = $this->image_dst_y - $watermark_dst_height + $this->image_watermark_y;\n                                } else {\n                                    $watermark_y = $this->image_watermark_y;\n                                }\n                            } else {\n                                if (strpos($this->image_watermark_position, 'b') !== false) {\n                                    $watermark_y = $this->image_dst_y - $watermark_dst_height;\n                                } else if (strpos($this->image_watermark_position, 't') !== false) {\n                                    $watermark_y = 0;\n                                } else {\n                                    $watermark_y = ($this->image_dst_y - $watermark_dst_height) / 2;\n                                }\n                            }\n                            imagealphablending($image_dst, true);\n                            imagecopyresampled($image_dst, $filter, $watermark_x, $watermark_y, 0, 0, $watermark_dst_width, $watermark_dst_height, $watermark_src_width, $watermark_src_height);\n                        } else {\n                            $this->error = $this->translate('watermark_invalid');\n                        }\n                    }\n\n                    // add text\n                    if (!empty($this->image_text)) {\n                        $this->log .= '- add text<br />';\n\n                        // calculate sizes in human readable format\n                        $src_size       = $this->file_src_size / 1024;\n                        $src_size_mb    = number_format($src_size / 1024, 1, \".\", \" \");\n                        $src_size_kb    = number_format($src_size, 1, \".\", \" \");\n                        $src_size_human = ($src_size > 1024 ? $src_size_mb . \" MB\" : $src_size_kb . \" kb\");\n\n                        $this->image_text = str_replace(\n                            array('[src_name]',\n                                  '[src_name_body]',\n                                  '[src_name_ext]',\n                                  '[src_pathname]',\n                                  '[src_mime]',\n                                  '[src_size]',\n                                  '[src_size_kb]',\n                                  '[src_size_mb]',\n                                  '[src_size_human]',\n                                  '[src_x]',\n                                  '[src_y]',\n                                  '[src_pixels]',\n                                  '[src_type]',\n                                  '[src_bits]',\n                                  '[dst_path]',\n                                  '[dst_name_body]',\n                                  '[dst_name_ext]',\n                                  '[dst_name]',\n                                  '[dst_pathname]',\n                                  '[dst_x]',\n                                  '[dst_y]',\n                                  '[date]',\n                                  '[time]',\n                                  '[host]',\n                                  '[server]',\n                                  '[ip]',\n                                  '[gd_version]'),\n                            array($this->file_src_name,\n                                  $this->file_src_name_body,\n                                  $this->file_src_name_ext,\n                                  $this->file_src_pathname,\n                                  $this->file_src_mime,\n                                  $this->file_src_size,\n                                  $src_size_kb,\n                                  $src_size_mb,\n                                  $src_size_human,\n                                  $this->image_src_x,\n                                  $this->image_src_y,\n                                  $this->image_src_pixels,\n                                  $this->image_src_type,\n                                  $this->image_src_bits,\n                                  $this->file_dst_path,\n                                  $this->file_dst_name_body,\n                                  $this->file_dst_name_ext,\n                                  $this->file_dst_name,\n                                  $this->file_dst_pathname,\n                                  $this->image_dst_x,\n                                  $this->image_dst_y,\n                                  date('Y-m-d'),\n                                  date('H:i:s'),\n                                  (isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : 'n/a'),\n                                  (isset($_SERVER['SERVER_NAME']) ? $_SERVER['SERVER_NAME'] : 'n/a'),\n                                  (isset($_SERVER['REMOTE_ADDR']) ? $_SERVER['REMOTE_ADDR'] : 'n/a'),\n                                  $this->gdversion(true)),\n                            $this->image_text);\n\n                        if (!is_numeric($this->image_text_padding)) $this->image_text_padding = 0;\n                        if (!is_numeric($this->image_text_line_spacing)) $this->image_text_line_spacing = 0;\n                        if (!is_numeric($this->image_text_padding_x)) $this->image_text_padding_x = $this->image_text_padding;\n                        if (!is_numeric($this->image_text_padding_y)) $this->image_text_padding_y = $this->image_text_padding;\n                        $this->image_text_position = strtolower($this->image_text_position);\n                        $this->image_text_direction = strtolower($this->image_text_direction);\n                        $this->image_text_alignment = strtolower($this->image_text_alignment);\n\n                        $font_type = 'gd';\n\n                        // if the font is a string with a GDF font path, we assume that we might want to load a font\n                        if (!is_numeric($this->image_text_font) && strlen($this->image_text_font) > 4 && substr(strtolower($this->image_text_font), -4) == '.gdf') {\n                            if (strpos($this->image_text_font, '/') === false) $this->image_text_font = \"./\" . $this->image_text_font;\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;try to load font ' . $this->image_text_font . '... ';\n                            if ($this->image_text_font = @imageloadfont($this->image_text_font)) {\n                                $this->log .=  'success<br />';\n                            } else {\n                                $this->log .=  'error<br />';\n                                $this->image_text_font = 5;\n                            }\n                        }\n\n                        // if the font is a string with a TTF font path, we check if we can access the font file\n                        if (!is_numeric($this->image_text_font) && strlen($this->image_text_font) > 4 && substr(strtolower($this->image_text_font), -4) == '.ttf') {\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;try to load font ' . $this->image_text_font . '... ';\n                            if (strpos($this->image_text_font, '/') === false) $this->image_text_font = \"./\" . $this->image_text_font;\n                            if (file_exists($this->image_text_font) && is_readable($this->image_text_font)) {\n                                $this->log .=  'success<br />';\n                                $font_type = 'tt';\n                            } else {\n                                $this->log .=  'error<br />';\n                                $this->image_text_font = 5;\n                            }\n                        }\n\n                        // get the text bounding box (GD fonts)\n                        if ($font_type == 'gd') {\n                            $text = explode(\"\\n\", $this->image_text);\n                            $char_width = imagefontwidth($this->image_text_font);\n                            $char_height = imagefontheight($this->image_text_font);\n                            $text_height = 0;\n                            $text_width = 0;\n                            $line_height = 0;\n                            $line_width = 0;\n                            foreach ($text as $k => $v) {\n                                if ($this->image_text_direction == 'v') {\n                                    $h = ($char_width * strlen($v));\n                                    if ($h > $text_height) $text_height = $h;\n                                    $line_width = $char_height;\n                                    $text_width += $line_width + ($k < (sizeof($text)-1) ? $this->image_text_line_spacing : 0);\n                                } else {\n                                    $w = ($char_width * strlen($v));\n                                    if ($w > $text_width) $text_width = $w;\n                                    $line_height = $char_height;\n                                    $text_height += $line_height + ($k < (sizeof($text)-1) ? $this->image_text_line_spacing : 0);\n                                }\n                            }\n                            $text_width  += (2 * $this->image_text_padding_x);\n                            $text_height += (2 * $this->image_text_padding_y);\n\n                        // get the text bounding box (TrueType fonts)\n                        } else if ($font_type == 'tt') {\n                            $text = $this->image_text;\n                            if (!$this->image_text_angle) $this->image_text_angle = $this->image_text_direction == 'v' ? 90 : 0;\n                            $text_height = 0;\n                            $text_width = 0;\n                            $text_offset_x = 0;\n                            $text_offset_y = 0;\n                            $rect = imagettfbbox($this->image_text_size, $this->image_text_angle, $this->image_text_font, $text );\n                            if ($rect) {\n                                $minX = min(array($rect[0],$rect[2],$rect[4],$rect[6]));\n                                $maxX = max(array($rect[0],$rect[2],$rect[4],$rect[6]));\n                                $minY = min(array($rect[1],$rect[3],$rect[5],$rect[7]));\n                                $maxY = max(array($rect[1],$rect[3],$rect[5],$rect[7]));\n                                $text_offset_x = abs($minX) - 1;\n                                $text_offset_y = abs($minY) - 1;\n                                $text_width = $maxX - $minX + (2 * $this->image_text_padding_x);\n                                $text_height = $maxY - $minY + (2 * $this->image_text_padding_y);\n                            }\n                        }\n\n                        // position the text block\n                        $text_x = 0;\n                        $text_y = 0;\n                        if (is_numeric($this->image_text_x)) {\n                            if ($this->image_text_x < 0) {\n                                $text_x = $this->image_dst_x - $text_width + $this->image_text_x;\n                            } else {\n                                $text_x = $this->image_text_x;\n                            }\n                        } else {\n                            if (strpos($this->image_text_position, 'r') !== false) {\n                                $text_x = $this->image_dst_x - $text_width;\n                            } else if (strpos($this->image_text_position, 'l') !== false) {\n                                $text_x = 0;\n                            } else {\n                                $text_x = ($this->image_dst_x - $text_width) / 2;\n                            }\n                        }\n                        if (is_numeric($this->image_text_y)) {\n                            if ($this->image_text_y < 0) {\n                                $text_y = $this->image_dst_y - $text_height + $this->image_text_y;\n                            } else {\n                                $text_y = $this->image_text_y;\n                            }\n                        } else {\n                            if (strpos($this->image_text_position, 'b') !== false) {\n                                $text_y = $this->image_dst_y - $text_height;\n                            } else if (strpos($this->image_text_position, 't') !== false) {\n                                $text_y = 0;\n                            } else {\n                                $text_y = ($this->image_dst_y - $text_height) / 2;\n                            }\n                        }\n\n                        // add a background, maybe transparent\n                        if (!empty($this->image_text_background)) {\n                            list($red, $green, $blue) = $this->getcolors($this->image_text_background);\n                            if ($gd_version >= 2 && (is_numeric($this->image_text_background_opacity)) && $this->image_text_background_opacity >= 0 && $this->image_text_background_opacity <= 100) {\n                                $filter = imagecreatetruecolor($text_width, $text_height);\n                                $background_color = imagecolorallocate($filter, $red, $green, $blue);\n                                imagefilledrectangle($filter, 0, 0, $text_width, $text_height, $background_color);\n                                $this->imagecopymergealpha($image_dst, $filter, $text_x, $text_y, 0, 0, $text_width, $text_height, $this->image_text_background_opacity);\n                                imagedestroy($filter);\n                            } else {\n                                $background_color = imagecolorallocate($image_dst ,$red, $green, $blue);\n                                imagefilledrectangle($image_dst, $text_x, $text_y, $text_x + $text_width, $text_y + $text_height, $background_color);\n                            }\n                        }\n\n                        $text_x += $this->image_text_padding_x;\n                        $text_y += $this->image_text_padding_y;\n                        $t_width = $text_width - (2 * $this->image_text_padding_x);\n                        $t_height = $text_height - (2 * $this->image_text_padding_y);\n                        list($red, $green, $blue) = $this->getcolors($this->image_text_color);\n\n                        // add the text, maybe transparent\n                        if ($gd_version >= 2 && (is_numeric($this->image_text_opacity)) && $this->image_text_opacity >= 0 && $this->image_text_opacity <= 100) {\n                            if ($t_width < 0) $t_width = 0;\n                            if ($t_height < 0) $t_height = 0;\n                            $filter = $this->imagecreatenew($t_width, $t_height, false, true);\n                            $text_color = imagecolorallocate($filter ,$red, $green, $blue);\n\n                            if ($font_type == 'gd') {\n                                foreach ($text as $k => $v) {\n                                    if ($this->image_text_direction == 'v') {\n                                        imagestringup($filter,\n                                                      $this->image_text_font,\n                                                      $k * ($line_width  + ($k > 0 && $k < (sizeof($text)) ? $this->image_text_line_spacing : 0)),\n                                                      $text_height - (2 * $this->image_text_padding_y) - ($this->image_text_alignment == 'l' ? 0 : (($t_height - strlen($v) * $char_width) / ($this->image_text_alignment == 'r' ? 1 : 2))) ,\n                                                      $v,\n                                                      $text_color);\n                                    } else {\n                                        imagestring($filter,\n                                                    $this->image_text_font,\n                                                    ($this->image_text_alignment == 'l' ? 0 : (($t_width - strlen($v) * $char_width) / ($this->image_text_alignment == 'r' ? 1 : 2))),\n                                                    $k * ($line_height  + ($k > 0 && $k < (sizeof($text)) ? $this->image_text_line_spacing : 0)),\n                                                    $v,\n                                                    $text_color);\n                                    }\n                                }\n                            } else if ($font_type == 'tt') {\n                                imagettftext($filter,\n                                             $this->image_text_size,\n                                             $this->image_text_angle,\n                                             $text_offset_x,\n                                             $text_offset_y,\n                                             $text_color,\n                                             $this->image_text_font,\n                                             $text);\n                            }\n                            $this->imagecopymergealpha($image_dst, $filter, $text_x, $text_y, 0, 0, $t_width, $t_height, $this->image_text_opacity);\n                            imagedestroy($filter);\n\n                        } else {\n                            $text_color = imagecolorallocate($image_dst ,$red, $green, $blue);\n                            if ($font_type == 'gd') {\n                                foreach ($text as $k => $v) {\n                                    if ($this->image_text_direction == 'v') {\n                                        imagestringup($image_dst,\n                                                      $this->image_text_font,\n                                                      $text_x + $k * ($line_width  + ($k > 0 && $k < (sizeof($text)) ? $this->image_text_line_spacing : 0)),\n                                                      $text_y + $text_height - (2 * $this->image_text_padding_y) - ($this->image_text_alignment == 'l' ? 0 : (($t_height - strlen($v) * $char_width) / ($this->image_text_alignment == 'r' ? 1 : 2))),\n                                                      $v,\n                                                      $text_color);\n                                    } else {\n                                        imagestring($image_dst,\n                                                    $this->image_text_font,\n                                                    $text_x + ($this->image_text_alignment == 'l' ? 0 : (($t_width - strlen($v) * $char_width) / ($this->image_text_alignment == 'r' ? 1 : 2))),\n                                                    $text_y + $k * ($line_height  + ($k > 0 && $k < (sizeof($text)) ? $this->image_text_line_spacing : 0)),\n                                                    $v,\n                                                    $text_color);\n                                    }\n                                }\n                            } else if ($font_type == 'tt') {\n                                imagettftext($image_dst,\n                                             $this->image_text_size,\n                                             $this->image_text_angle,\n                                             $text_offset_x + ($this->image_dst_x / 2) - ($text_width / 2) + $this->image_text_padding_x,\n                                             $text_offset_y + ($this->image_dst_y / 2) - ($text_height / 2) + $this->image_text_padding_y,\n                                             $text_color,\n                                             $this->image_text_font,\n                                             $text);\n                            }\n                        }\n                    }\n\n                    // add a reflection\n                    if ($this->image_reflection_height) {\n                        $this->log .= '- add reflection : ' . $this->image_reflection_height . '<br />';\n                        // we decode image_reflection_height, which can be a integer, a string in pixels or percentage\n                        $image_reflection_height = $this->image_reflection_height;\n                        if (strpos($image_reflection_height, '%')>0) $image_reflection_height = $this->image_dst_y * (str_replace('%','',$image_reflection_height / 100));\n                        if (strpos($image_reflection_height, 'px')>0) $image_reflection_height = str_replace('px','',$image_reflection_height);\n                        $image_reflection_height = (int) $image_reflection_height;\n                        if ($image_reflection_height > $this->image_dst_y) $image_reflection_height = $this->image_dst_y;\n                        if (empty($this->image_reflection_opacity)) $this->image_reflection_opacity = 60;\n                        // create the new destination image\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y + $image_reflection_height + $this->image_reflection_space, true);\n                        $transparency = $this->image_reflection_opacity;\n\n                        // copy the original image\n                        imagecopy($tmp, $image_dst, 0, 0, 0, 0, $this->image_dst_x, $this->image_dst_y + ($this->image_reflection_space < 0 ? $this->image_reflection_space : 0));\n\n                        // we have to make sure the extra bit is the right color, or transparent\n                        if ($image_reflection_height + $this->image_reflection_space > 0) {\n                            // use the background color if present\n                            if (!empty($this->image_background_color)) {\n                                list($red, $green, $blue) = $this->getcolors($this->image_background_color);\n                                $fill = imagecolorallocate($tmp, $red, $green, $blue);\n                            } else {\n                                $fill = imagecolorallocatealpha($tmp, 0, 0, 0, 127);\n                            }\n                            // fill in from the edge of the extra bit\n                            imagefill($tmp, round($this->image_dst_x / 2), $this->image_dst_y + $image_reflection_height + $this->image_reflection_space - 1, $fill);\n                        }\n\n                        // copy the reflection\n                        for ($y = 0; $y < $image_reflection_height; $y++) {\n                            for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                $pixel_b = imagecolorsforindex($tmp, imagecolorat($tmp, $x, $y + $this->image_dst_y + $this->image_reflection_space));\n                                $pixel_o = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $this->image_dst_y - $y - 1 + ($this->image_reflection_space < 0 ? $this->image_reflection_space : 0)));\n                                $alpha_o = 1 - ($pixel_o['alpha'] / 127);\n                                $alpha_b = 1 - ($pixel_b['alpha'] / 127);\n                                $opacity = $alpha_o * $transparency / 100;\n                                if ($opacity > 0) {\n                                    $red   = round((($pixel_o['red']   * $opacity) + ($pixel_b['red']  ) * $alpha_b) / ($alpha_b + $opacity));\n                                    $green = round((($pixel_o['green'] * $opacity) + ($pixel_b['green']) * $alpha_b) / ($alpha_b + $opacity));\n                                    $blue  = round((($pixel_o['blue']  * $opacity) + ($pixel_b['blue'] ) * $alpha_b) / ($alpha_b + $opacity));\n                                    $alpha = ($opacity + $alpha_b);\n                                    if ($alpha > 1) $alpha = 1;\n                                    $alpha =  round((1 - $alpha) * 127);\n                                    $color = imagecolorallocatealpha($tmp, $red, $green, $blue, $alpha);\n                                    imagesetpixel($tmp, $x, $y + $this->image_dst_y + $this->image_reflection_space, $color);\n                                }\n                            }\n                            if ($transparency > 0) $transparency = $transparency - ($this->image_reflection_opacity / $image_reflection_height);\n                        }\n\n                        // copy the resulting image into the destination image\n                        $this->image_dst_y = $this->image_dst_y + $image_reflection_height + $this->image_reflection_space;\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // change opacity\n                    if ($gd_version >= 2 && is_numeric($this->image_opacity) && $this->image_opacity < 100) {\n                        $this->log .= '- change opacity<br />';\n                        // create the new destination image\n                        $tmp = $this->imagecreatenew($this->image_dst_x, $this->image_dst_y, true);\n                        for($y=0; $y < $this->image_dst_y; $y++) {\n                            for($x=0; $x < $this->image_dst_x; $x++) {\n                                $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                $alpha = $pixel['alpha'] + round((127 - $pixel['alpha']) * (100 - $this->image_opacity) / 100);\n                                if ($alpha > 127) $alpha = 127;\n                                if ($alpha > 0) {\n                                    $color = imagecolorallocatealpha($tmp, $pixel['red'] , $pixel['green'], $pixel['blue'], $alpha);\n                                    imagesetpixel($tmp, $x, $y, $color);\n                                }\n                            }\n                        }\n                        // copy the resulting image into the destination image\n                        $image_dst = $this->imagetransfer($tmp, $image_dst);\n                    }\n\n                    // reduce the JPEG image to a set desired size\n                    if (is_numeric($this->jpeg_size) && $this->jpeg_size > 0 && ($this->image_convert == 'jpeg' || $this->image_convert == 'jpg')) {\n                        // inspired by: JPEGReducer class version 1, 25 November 2004, Author: Huda M ElMatsani, justhuda at netscape dot net\n                        $this->log .= '- JPEG desired file size : ' . $this->jpeg_size . '<br />';\n                        // calculate size of each image. 75%, 50%, and 25% quality\n                        ob_start(); imagejpeg($image_dst,null,75);  $buffer = ob_get_contents(); ob_end_clean();\n                        $size75 = strlen($buffer);\n                        ob_start(); imagejpeg($image_dst,null,50);  $buffer = ob_get_contents(); ob_end_clean();\n                        $size50 = strlen($buffer);\n                        ob_start(); imagejpeg($image_dst,null,25);  $buffer = ob_get_contents(); ob_end_clean();\n                        $size25 = strlen($buffer);\n\n                        // make sure we won't divide by 0\n                        if ($size50 == $size25) $size50++;\n                        if ($size75 == $size50 || $size75 == $size25) $size75++;\n\n                        // calculate gradient of size reduction by quality\n                        $mgrad1 = 25 / ($size50-$size25);\n                        $mgrad2 = 25 / ($size75-$size50);\n                        $mgrad3 = 50 / ($size75-$size25);\n                        $mgrad  = ($mgrad1 + $mgrad2 + $mgrad3) / 3;\n                        // result of approx. quality factor for expected size\n                        $q_factor = round($mgrad * ($this->jpeg_size - $size50) + 50);\n\n                        if ($q_factor<1) {\n                            $this->jpeg_quality=1;\n                        } elseif ($q_factor>100) {\n                            $this->jpeg_quality=100;\n                        } else {\n                            $this->jpeg_quality=$q_factor;\n                        }\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;JPEG quality factor set to ' . $this->jpeg_quality . '<br />';\n                    }\n\n                    // converts image from true color, and fix transparency if needed\n                    $this->log .= '- converting...<br />';\n                    $this->image_dst_type = $this->image_convert;\n                    switch($this->image_convert) {\n                        case 'gif':\n                            // if the image is true color, we convert it to a palette\n                            if (imageistruecolor($image_dst)) {\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;true color to palette<br />';\n                                // creates a black and white mask\n                                $mask = array(array());\n                                for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                    for ($y = 0; $y < $this->image_dst_y; $y++) {\n                                        $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                        $mask[$x][$y] = $pixel['alpha'];\n                                    }\n                                }\n                                list($red, $green, $blue) = $this->getcolors($this->image_default_color);\n                                // first, we merge the image with the background color, so we know which colors we will have\n                                for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                    for ($y = 0; $y < $this->image_dst_y; $y++) {\n                                        if ($mask[$x][$y] > 0){\n                                            // we have some transparency. we combine the color with the default color\n                                            $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                            $alpha = ($mask[$x][$y] / 127);\n                                            $pixel['red'] = round(($pixel['red'] * (1 -$alpha) + $red * ($alpha)));\n                                            $pixel['green'] = round(($pixel['green'] * (1 -$alpha) + $green * ($alpha)));\n                                            $pixel['blue'] = round(($pixel['blue'] * (1 -$alpha) + $blue * ($alpha)));\n                                            $color = imagecolorallocate($image_dst, $pixel['red'], $pixel['green'], $pixel['blue']);\n                                            imagesetpixel($image_dst, $x, $y, $color);\n                                        }\n                                    }\n                                }\n                                // transforms the true color image into palette, with its merged default color\n                                if (empty($this->image_background_color)) {\n                                    imagetruecolortopalette($image_dst, true, 255);\n                                    $transparency = imagecolorallocate($image_dst, 254, 1, 253);\n                                    imagecolortransparent($image_dst, $transparency);\n                                    // make the transparent areas transparent\n                                    for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                        for ($y = 0; $y < $this->image_dst_y; $y++) {\n                                            // we test wether we have enough opacity to justify keeping the color\n                                            if ($mask[$x][$y] > 120) imagesetpixel($image_dst, $x, $y, $transparency);\n                                        }\n                                    }\n                                }\n                                unset($mask);\n                            }\n                            break;\n                        case 'jpg':\n                        case 'bmp':\n                            // if the image doesn't support any transparency, then we merge it with the default color\n                            $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;fills in transparency with default color<br />';\n                            list($red, $green, $blue) = $this->getcolors($this->image_default_color);\n                            $transparency = imagecolorallocate($image_dst, $red, $green, $blue);\n                            // make the transaparent areas transparent\n                            for ($x = 0; $x < $this->image_dst_x; $x++) {\n                                for ($y = 0; $y < $this->image_dst_y; $y++) {\n                                    // we test wether we have some transparency, in which case we will merge the colors\n                                    if (imageistruecolor($image_dst)) {\n                                        $rgba = imagecolorat($image_dst, $x, $y);\n                                        $pixel = array('red' => ($rgba >> 16) & 0xFF,\n                                                       'green' => ($rgba >> 8) & 0xFF,\n                                                       'blue' => $rgba & 0xFF,\n                                                       'alpha' => ($rgba & 0x7F000000) >> 24);\n                                    } else {\n                                        $pixel = imagecolorsforindex($image_dst, imagecolorat($image_dst, $x, $y));\n                                    }\n                                    if ($pixel['alpha'] == 127) {\n                                        // we have full transparency. we make the pixel transparent\n                                        imagesetpixel($image_dst, $x, $y, $transparency);\n                                    } else if ($pixel['alpha'] > 0) {\n                                        // we have some transparency. we combine the color with the default color\n                                        $alpha = ($pixel['alpha'] / 127);\n                                        $pixel['red'] = round(($pixel['red'] * (1 -$alpha) + $red * ($alpha)));\n                                        $pixel['green'] = round(($pixel['green'] * (1 -$alpha) + $green * ($alpha)));\n                                        $pixel['blue'] = round(($pixel['blue'] * (1 -$alpha) + $blue * ($alpha)));\n                                        $color = imagecolorclosest($image_dst, $pixel['red'], $pixel['green'], $pixel['blue']);\n                                        imagesetpixel($image_dst, $x, $y, $color);\n                                    }\n                                }\n                            }\n\n                            break;\n                        default:\n                            break;\n                    }\n\n                    // interlace options\n                    if($this->image_interlace) imageinterlace($image_dst, true);\n\n                    // outputs image\n                    $this->log .= '- saving image...<br />';\n                    switch($this->image_convert) {\n                        case 'jpeg':\n                        case 'jpg':\n                            if (!$return_mode) {\n                                $result = @imagejpeg($image_dst, $this->file_dst_pathname, $this->jpeg_quality);\n                            } else {\n                                ob_start();\n                                $result = @imagejpeg($image_dst, null, $this->jpeg_quality);\n                                $return_content = ob_get_contents();\n                                ob_end_clean();\n                            }\n                            if (!$result) {\n                                $this->processed = false;\n                                $this->error = $this->translate('file_create', array('JPEG'));\n                            } else {\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;JPEG image created<br />';\n                            }\n                            break;\n                        case 'png':\n                            imagealphablending( $image_dst, false );\n                            imagesavealpha( $image_dst, true );\n                            if (!$return_mode) {\n                                if (is_numeric($this->png_compression) && version_compare(PHP_VERSION, '5.1.2') >= 0) {\n                                    $result = @imagepng($image_dst, $this->file_dst_pathname, $this->png_compression);\n                                } else {\n                                    $result = @imagepng($image_dst, $this->file_dst_pathname);\n                                }\n                            } else {\n                                ob_start();\n                                if (is_numeric($this->png_compression) && version_compare(PHP_VERSION, '5.1.2') >= 0) {\n                                    $result = @imagepng($image_dst, null, $this->png_compression);\n                                } else {\n                                    $result = @imagepng($image_dst);\n                                }\n                                $return_content = ob_get_contents();\n                                ob_end_clean();\n                            }\n                            if (!$result) {\n                                $this->processed = false;\n                                $this->error = $this->translate('file_create', array('PNG'));\n                            } else {\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;PNG image created<br />';\n                            }\n                            break;\n                        case 'gif':\n                            if (!$return_mode) {\n                                $result = @imagegif($image_dst, $this->file_dst_pathname);\n                            } else {\n                                ob_start();\n                                $result = @imagegif($image_dst);\n                                $return_content = ob_get_contents();\n                                ob_end_clean();\n                            }\n                            if (!$result) {\n                                $this->processed = false;\n                                $this->error = $this->translate('file_create', array('GIF'));\n                            } else {\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;GIF image created<br />';\n                            }\n                            break;\n                        case 'bmp':\n                            if (!$return_mode) {\n                                $result = $this->imagebmp($image_dst, $this->file_dst_pathname);\n                            } else {\n                                ob_start();\n                                $result = $this->imagebmp($image_dst);\n                                $return_content = ob_get_contents();\n                                ob_end_clean();\n                            }\n                            if (!$result) {\n                                $this->processed = false;\n                                $this->error = $this->translate('file_create', array('BMP'));\n                            } else {\n                                $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;BMP image created<br />';\n                            }\n                            break;\n\n                        default:\n                            $this->processed = false;\n                            $this->error = $this->translate('no_conversion_type');\n                    }\n                    if ($this->processed) {\n                        if (is_resource($image_src)) imagedestroy($image_src);\n                        if (is_resource($image_dst)) imagedestroy($image_dst);\n                        $this->log .= '&nbsp;&nbsp;&nbsp;&nbsp;image objects destroyed<br />';\n                    }\n                }\n\n            } else {\n                $this->log .= '- no image processing wanted<br />';\n\n                if (!$return_mode) {\n                    // copy the file to its final destination. we don't use move_uploaded_file here\n                    // if we happen to have open_basedir restrictions, it is a temp file that we copy, not the original uploaded file\n                    if (!copy($this->file_src_pathname, $this->file_dst_pathname)) {\n                        $this->processed = false;\n                        $this->error = $this->translate('copy_failed');\n                    }\n                } else {\n                    // returns the file, so that its content can be received by the caller\n                    $return_content = @file_get_contents($this->file_src_pathname);\n                    if ($return_content === FALSE) {\n                        $this->processed = false;\n                        $this->error = $this->translate('reading_failed');\n                    }\n                }\n            }\n        }\n\n        if ($this->processed) {\n            $this->log .= '- <b>process OK</b><br />';\n        } else {\n            $this->log .= '- <b>error</b>: ' . $this->error . '<br />';\n        }\n\n        // we reinit all the vars\n        $this->init();\n\n        // we may return the image content\n        if ($return_mode) return $return_content;\n\n    }\n\n    /**\n     * Deletes the uploaded file from its temporary location\n     *\n     * When PHP uploads a file, it stores it in a temporary location.\n     * When you {@link process} the file, you actually copy the resulting file to the given location, it doesn't alter the original file.\n     * Once you have processed the file as many times as you wanted, you can delete the uploaded file.\n     * If there is open_basedir restrictions, the uploaded file is in fact a temporary file\n     *\n     * You might want not to use this function if you work on local files, as it will delete the source file\n     *\n     * @access public\n     */\n    function clean() {\n        $this->log .= '<b>cleanup</b><br />';\n        $this->log .= '- delete temp file '  . $this->file_src_pathname . '<br />';\n        @unlink($this->file_src_pathname);\n    }\n\n\n    /**\n     * Opens a BMP image\n     *\n     * This function has been written by DHKold, and is used with permission of the author\n     *\n     * @access public\n     */\n    function imagecreatefrombmp($filename) {\n        if (! $f1 = fopen($filename,\"rb\")) return false;\n\n        $file = unpack(\"vfile_type/Vfile_size/Vreserved/Vbitmap_offset\", fread($f1,14));\n        if ($file['file_type'] != 19778) return false;\n\n        $bmp = unpack('Vheader_size/Vwidth/Vheight/vplanes/vbits_per_pixel'.\n                      '/Vcompression/Vsize_bitmap/Vhoriz_resolution'.\n                      '/Vvert_resolution/Vcolors_used/Vcolors_important', fread($f1,40));\n        $bmp['colors'] = pow(2,$bmp['bits_per_pixel']);\n        if ($bmp['size_bitmap'] == 0) $bmp['size_bitmap'] = $file['file_size'] - $file['bitmap_offset'];\n        $bmp['bytes_per_pixel'] = $bmp['bits_per_pixel']/8;\n        $bmp['bytes_per_pixel2'] = ceil($bmp['bytes_per_pixel']);\n        $bmp['decal'] = ($bmp['width']*$bmp['bytes_per_pixel']/4);\n        $bmp['decal'] -= floor($bmp['width']*$bmp['bytes_per_pixel']/4);\n        $bmp['decal'] = 4-(4*$bmp['decal']);\n        if ($bmp['decal'] == 4) $bmp['decal'] = 0;\n\n        $palette = array();\n        if ($bmp['colors'] < 16777216) {\n            $palette = unpack('V'.$bmp['colors'], fread($f1,$bmp['colors']*4));\n        }\n\n        $im = fread($f1,$bmp['size_bitmap']);\n        $vide = chr(0);\n\n        $res = imagecreatetruecolor($bmp['width'],$bmp['height']);\n        $P = 0;\n        $Y = $bmp['height']-1;\n        while ($Y >= 0) {\n            $X=0;\n            while ($X < $bmp['width']) {\n                if ($bmp['bits_per_pixel'] == 24)\n                    $color = unpack(\"V\",substr($im,$P,3).$vide);\n                elseif ($bmp['bits_per_pixel'] == 16) {\n                    $color = unpack(\"n\",substr($im,$P,2));\n                    $color[1] = $palette[$color[1]+1];\n                } elseif ($bmp['bits_per_pixel'] == 8) {\n                    $color = unpack(\"n\",$vide.substr($im,$P,1));\n                    $color[1] = $palette[$color[1]+1];\n                } elseif ($bmp['bits_per_pixel'] == 4) {\n                    $color = unpack(\"n\",$vide.substr($im,floor($P),1));\n                    if (($P*2)%2 == 0) $color[1] = ($color[1] >> 4) ; else $color[1] = ($color[1] & 0x0F);\n                    $color[1] = $palette[$color[1]+1];\n                } elseif ($bmp['bits_per_pixel'] == 1)  {\n                    $color = unpack(\"n\",$vide.substr($im,floor($P),1));\n                    if     (($P*8)%8 == 0) $color[1] =  $color[1]        >>7;\n                    elseif (($P*8)%8 == 1) $color[1] = ($color[1] & 0x40)>>6;\n                    elseif (($P*8)%8 == 2) $color[1] = ($color[1] & 0x20)>>5;\n                    elseif (($P*8)%8 == 3) $color[1] = ($color[1] & 0x10)>>4;\n                    elseif (($P*8)%8 == 4) $color[1] = ($color[1] & 0x8)>>3;\n                    elseif (($P*8)%8 == 5) $color[1] = ($color[1] & 0x4)>>2;\n                    elseif (($P*8)%8 == 6) $color[1] = ($color[1] & 0x2)>>1;\n                    elseif (($P*8)%8 == 7) $color[1] = ($color[1] & 0x1);\n                    $color[1] = $palette[$color[1]+1];\n                } else\n                    return FALSE;\n                imagesetpixel($res,$X,$Y,$color[1]);\n                $X++;\n                $P += $bmp['bytes_per_pixel'];\n            }\n            $Y--;\n            $P+=$bmp['decal'];\n        }\n        fclose($f1);\n        return $res;\n    }\n\n    /**\n     * Saves a BMP image\n     *\n     * This function has been published on the PHP website, and can be used freely\n     *\n     * @access public\n     */\n    function imagebmp(&$im, $filename = \"\") {\n\n        if (!$im) return false;\n        $w = imagesx($im);\n        $h = imagesy($im);\n        $result = '';\n\n        // if the image is not true color, we convert it first\n        if (!imageistruecolor($im)) {\n            $tmp = imagecreatetruecolor($w, $h);\n            imagecopy($tmp, $im, 0, 0, 0, 0, $w, $h);\n            imagedestroy($im);\n            $im = & $tmp;\n        }\n\n        $biBPLine = $w * 3;\n        $biStride = ($biBPLine + 3) & ~3;\n        $biSizeImage = $biStride * $h;\n        $bfOffBits = 54;\n        $bfSize = $bfOffBits + $biSizeImage;\n\n        $result .= substr('BM', 0, 2);\n        $result .=  pack ('VvvV', $bfSize, 0, 0, $bfOffBits);\n        $result .= pack ('VVVvvVVVVVV', 40, $w, $h, 1, 24, 0, $biSizeImage, 0, 0, 0, 0);\n\n        $numpad = $biStride - $biBPLine;\n        for ($y = $h - 1; $y >= 0; --$y) {\n            for ($x = 0; $x < $w; ++$x) {\n                $col = imagecolorat ($im, $x, $y);\n                $result .=  substr(pack ('V', $col), 0, 3);\n            }\n            for ($i = 0; $i < $numpad; ++$i)\n                $result .= pack ('C', 0);\n        }\n\n        if($filename==\"\"){\n            echo $result;\n        } else {\n            $file = fopen($filename, \"wb\");\n            fwrite($file, $result);\n            fclose($file);\n        }\n        return true;\n    }\n}\n\n?>\n"], "filenames": ["media/k2/assets/vendors/verot/class.upload.php/src/class.upload.php"], "buggy_code_start_loc": [2995], "buggy_code_end_loc": [2996], "fixing_code_start_loc": [2995], "fixing_code_end_loc": [2996], "type": "CWE-434", "message": "class.upload.php in verot.net class.upload before 1.0.3 and 2.x before 2.0.4, as used in the K2 extension for Joomla! and other products, omits .phar from the set of dangerous file extensions.", "other": {"cve": {"id": "CVE-2019-19576", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-04T18:15:16.353", "lastModified": "2019-12-18T20:20:12.210", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "class.upload.php in verot.net class.upload before 1.0.3 and 2.x before 2.0.4, as used in the K2 extension for Joomla! and other products, omits .phar from the set of dangerous file extensions."}, {"lang": "es", "value": "El archivo class.upload.php en verot.net class.upload versiones anteriores a la versi\u00f3n  1.0.3 y versiones 2.x anteriores a la versi\u00f3n  2.0.4, como es usado en la extensi\u00f3n K2 para Joomla! y otros productos, omite .phar del conjunto de extensiones de archivos peligrosos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:verot_project:verot:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.3", "matchCriteriaId": "A8F26FB9-CDF6-483C-9E4C-501DA3FC14F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:verot_project:verot:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.4", "matchCriteriaId": "496BFED6-1C37-4826-B1B9-6CA8F7E034FF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:getk2:k2:*:*:*:*:*:joomla\\!:*:*", "versionEndIncluding": "2.10.1", "matchCriteriaId": "A358C664-C94F-4BBD-BCEE-A4E22B9FB018"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/155577/Verot-2.0.3-Remote-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/getk2/k2/commit/d1344706c4b74c2ae7659b286b5a066117155124", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jra89/CVE-2019-19576", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/verot/class.upload.php/commit/5a7505ddec956fdc9e9c071ae5089865559174f1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/verot/class.upload.php/commit/db1b4fe50c1754696970d8b437f07e7b94a7ebf2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/verot/class.upload.php/compare/1.0.2...1.0.3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/verot/class.upload.php/compare/2.0.3...2.0.4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://medium.com/@jra8908/cve-2019-19576-e9da712b779", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.verot.net", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://www.verot.net/php_class_upload.htm", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/getk2/k2/commit/d1344706c4b74c2ae7659b286b5a066117155124"}}