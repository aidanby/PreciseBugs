{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * buffer.c: functions for dealing with the buffer structure\n */\n\n/*\n * The buffer list is a double linked list of all buffers.\n * Each buffer can be in one of these states:\n * never loaded: BF_NEVERLOADED is set, only the file name is valid\n *   not loaded: b_ml.ml_mfp == NULL, no memfile allocated\n *\t hidden: b_nwindows == 0, loaded but not displayed in a window\n *\t normal: loaded and displayed in a window\n *\n * Instead of storing file names all over the place, each file name is\n * stored in the buffer list. It can be referenced by a number.\n *\n * The current implementation remembers all file names ever used.\n */\n\n#include \"vim.h\"\n\n\n#ifdef FEAT_EVAL\n// Determines how deeply nested %{} blocks will be evaluated in statusline.\n# define MAX_STL_EVAL_DEPTH 100\n#endif\n\nstatic void\tenter_buffer(buf_T *buf);\nstatic void\tbuflist_getfpos(void);\nstatic char_u\t*buflist_match(regmatch_T *rmp, buf_T *buf, int ignore_case);\nstatic char_u\t*fname_match(regmatch_T *rmp, char_u *name, int ignore_case);\n#ifdef UNIX\nstatic buf_T\t*buflist_findname_stat(char_u *ffname, stat_T *st);\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname, stat_T *stp);\nstatic int\tbuf_same_ino(buf_T *buf, stat_T *stp);\n#else\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname);\n#endif\nstatic int\tvalue_changed(char_u *str, char_u **last);\nstatic int\tappend_arg_number(win_T *wp, char_u *buf, int buflen, int add_file);\nstatic void\tfree_buffer(buf_T *);\nstatic void\tfree_buffer_stuff(buf_T *buf, int free_options);\nstatic void\tclear_wininfo(buf_T *buf);\n\n#ifdef UNIX\n# define dev_T dev_t\n#else\n# define dev_T unsigned\n#endif\n\n#define FOR_ALL_BUFS_FROM_LAST(buf) \\\n    for ((buf) = lastbuf; (buf) != NULL; (buf) = (buf)->b_prev)\n\n#if defined(FEAT_QUICKFIX)\nstatic char *msg_loclist = N_(\"[Location List]\");\nstatic char *msg_qflist = N_(\"[Quickfix List]\");\n#endif\n\n// Number of times free_buffer() was called.\nstatic int\tbuf_free_count = 0;\n\nstatic int\ttop_file_num = 1;\t// highest file number\nstatic garray_T buf_reuse = GA_EMPTY;\t// file numbers to recycle\n\n/*\n * Return the highest possible buffer number.\n */\n    int\nget_highest_fnum(void)\n{\n    return top_file_num - 1;\n}\n\n/*\n * Read data from buffer for retrying.\n */\n    static int\nread_buffer(\n    int\t\tread_stdin,\t    // read file from stdin, otherwise fifo\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags)\t\t    // extra flags for readfile()\n{\n    int\t\tretval = OK;\n    linenr_T\tline_count;\n\n    // Read from the buffer which the text is already filled in and append at\n    // the end.  This makes it possible to retry when 'fileformat' or\n    // 'fileencoding' was guessed wrong.\n    line_count = curbuf->b_ml.ml_line_count;\n    retval = readfile(\n\t    read_stdin ? NULL : curbuf->b_ffname,\n\t    read_stdin ? NULL : curbuf->b_fname,\n\t    line_count, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t    flags | READ_BUFFER);\n    if (retval == OK)\n    {\n\t// Delete the binary lines.\n\twhile (--line_count >= 0)\n\t    ml_delete((linenr_T)1);\n    }\n    else\n    {\n\t// Delete the converted lines.\n\twhile (curbuf->b_ml.ml_line_count > line_count)\n\t    ml_delete(line_count);\n    }\n    // Put the cursor on the first line.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n\n    if (read_stdin)\n    {\n\t// Set or reset 'modified' before executing autocommands, so that\n\t// it can be changed there.\n\tif (!readonlymode && !BUFEMPTY())\n\t    changed();\n\telse if (retval == OK)\n\t    unchanged(curbuf, FALSE, TRUE);\n\n\tif (retval == OK)\n\t{\n#ifdef FEAT_EVAL\n\t    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t    apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);\n#endif\n\t}\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Ensure buffer \"buf\" is loaded.  Does not trigger the swap-exists action.\n */\n    void\nbuffer_ensure_loaded(buf_T *buf)\n{\n    if (buf->b_ml.ml_mfp == NULL)\n    {\n\taco_save_T\taco;\n\n\taucmd_prepbuf(&aco, buf);\n\tswap_exists_action = SEA_NONE;\n\topen_buffer(FALSE, NULL, 0);\n\taucmd_restbuf(&aco);\n    }\n}\n#endif\n\n/*\n * Open current buffer, that is: open the memfile and read the file into\n * memory.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nopen_buffer(\n    int\t\tread_stdin,\t    // read file from stdin\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags)\t\t    // extra flags for readfile()\n{\n    int\t\tretval = OK;\n    bufref_T\told_curbuf;\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    int\t\tread_fifo = FALSE;\n\n    // The 'readonly' flag is only set when BF_NEVERLOADED is being reset.\n    // When re-entering the same buffer, it should not change, because the\n    // user may have reset the flag by hand.\n    if (readonlymode && curbuf->b_ffname != NULL\n\t\t\t\t\t&& (curbuf->b_flags & BF_NEVERLOADED))\n\tcurbuf->b_p_ro = TRUE;\n\n    if (ml_open(curbuf) == FAIL)\n    {\n\t// There MUST be a memfile, otherwise we can't do anything\n\t// If we can't create one for the current buffer, take another buffer\n\tclose_buffer(NULL, curbuf, 0, FALSE, FALSE);\n\tFOR_ALL_BUFFERS(curbuf)\n\t    if (curbuf->b_ml.ml_mfp != NULL)\n\t\tbreak;\n\t// If there is no memfile at all, exit.\n\t// This is OK, since there are no changes to lose.\n\tif (curbuf == NULL)\n\t{\n\t    emsg(_(e_cannot_allocate_any_buffer_exiting));\n\n\t    // Don't try to do any saving, with \"curbuf\" NULL almost nothing\n\t    // will work.\n\t    v_dying = 2;\n\t    getout(2);\n\t}\n\n\temsg(_(e_cannot_allocate_buffer_using_other_one));\n\tenter_buffer(curbuf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n\treturn FAIL;\n    }\n\n    // The autocommands in readfile() may change the buffer, but only AFTER\n    // reading the file.\n    set_bufref(&old_curbuf, curbuf);\n    modified_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    if (curbuf->b_ffname != NULL\n#ifdef FEAT_NETBEANS_INTG\n\t    && netbeansReadFile\n#endif\n       )\n    {\n\tint old_msg_silent = msg_silent;\n#ifdef UNIX\n\tint save_bin = curbuf->b_p_bin;\n\tint perm;\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\tint oldFire = netbeansFireChanges;\n\n\tnetbeansFireChanges = 0;\n#endif\n#ifdef UNIX\n\tperm = mch_getperm(curbuf->b_ffname);\n\tif (perm >= 0 && (S_ISFIFO(perm)\n\t\t      || S_ISSOCK(perm)\n# ifdef OPEN_CHR_FILES\n\t\t      || (S_ISCHR(perm) && is_dev_fd_file(curbuf->b_ffname))\n# endif\n\t\t    ))\n\t\tread_fifo = TRUE;\n\tif (read_fifo)\n\t    curbuf->b_p_bin = TRUE;\n#endif\n\tif (shortmess(SHM_FILEINFO))\n\t    msg_silent = 1;\n\tretval = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t\t  flags | READ_NEW | (read_fifo ? READ_FIFO : 0));\n#ifdef UNIX\n\tif (read_fifo)\n\t{\n\t    curbuf->b_p_bin = save_bin;\n\t    if (retval == OK)\n\t\tretval = read_buffer(FALSE, eap, flags);\n\t}\n#endif\n\tmsg_silent = old_msg_silent;\n#ifdef FEAT_NETBEANS_INTG\n\tnetbeansFireChanges = oldFire;\n#endif\n\t// Help buffer is filtered.\n\tif (bt_help(curbuf))\n\t    fix_help_buffer();\n    }\n    else if (read_stdin)\n    {\n\tint\tsave_bin = curbuf->b_p_bin;\n\n\t// First read the text in binary mode into the buffer.\n\t// Then read from that same buffer and append at the end.  This makes\n\t// it possible to retry when 'fileformat' or 'fileencoding' was\n\t// guessed wrong.\n\tcurbuf->b_p_bin = TRUE;\n\tretval = readfile(NULL, NULL, (linenr_T)0,\n\t\t  (linenr_T)0, (linenr_T)MAXLNUM, NULL,\n\t\t  flags | (READ_NEW + READ_STDIN));\n\tcurbuf->b_p_bin = save_bin;\n\tif (retval == OK)\n\t    retval = read_buffer(TRUE, eap, flags);\n    }\n\n    // if first time loading this buffer, init b_chartab[]\n    if (curbuf->b_flags & BF_NEVERLOADED)\n    {\n\t(void)buf_init_chartab(curbuf, FALSE);\n#ifdef FEAT_CINDENT\n\tparse_cino(curbuf);\n#endif\n    }\n\n    // Set/reset the Changed flag first, autocmds may change the buffer.\n    // Apply the automatic commands, before processing the modelines.\n    // So the modelines have priority over autocommands.\n    //\n    // When reading stdin, the buffer contents always needs writing, so set\n    // the changed flag.  Unless in readonly mode: \"ls | gview -\".\n    // When interrupted and 'cpoptions' contains 'i' set changed flag.\n    if ((got_int && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n\t\t|| modified_was_set\t// \":set modified\" used in autocmd\n#ifdef FEAT_EVAL\n\t\t|| (aborting() && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n#endif\n       )\n\tchanged();\n    else if (retval == OK && !read_stdin && !read_fifo)\n\tunchanged(curbuf, FALSE, TRUE);\n    save_file_ff(curbuf);\t\t// keep this fileformat\n\n    // Set last_changedtick to avoid triggering a TextChanged autocommand right\n    // after it was added.\n    curbuf->b_last_changedtick = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_pum = CHANGEDTICK(curbuf);\n\n    // require \"!\" to overwrite the file, because it wasn't read completely\n#ifdef FEAT_EVAL\n    if (aborting())\n#else\n    if (got_int)\n#endif\n\tcurbuf->b_flags |= BF_READERR;\n\n#ifdef FEAT_FOLDING\n    // Need to update automatic folding.  Do this before the autocommands,\n    // they may use the fold info.\n    foldUpdateAll(curwin);\n#endif\n\n    // need to set w_topline, unless some autocommand already did that.\n    if (!(curwin->w_valid & VALID_TOPLINE))\n    {\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n    }\n#ifdef FEAT_EVAL\n    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf, &retval);\n#else\n    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n    if (retval == OK)\n    {\n\t// The autocommands may have changed the current buffer.  Apply the\n\t// modelines to the correct buffer, if it still exists and is loaded.\n\tif (bufref_valid(&old_curbuf) && old_curbuf.br_buf->b_ml.ml_mfp != NULL)\n\t{\n\t    aco_save_T\taco;\n\n\t    // Go to the buffer that was opened.\n\t    aucmd_prepbuf(&aco, old_curbuf.br_buf);\n\t    do_modelines(0);\n\t    curbuf->b_flags &= ~(BF_CHECK_RO | BF_NEVERLOADED);\n\n\t    if ((flags & READ_NOWINENTER) == 0)\n#ifdef FEAT_EVAL\n\t\tapply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n\t    // restore curwin/curbuf and a few other things\n\t    aucmd_restbuf(&aco);\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Store \"buf\" in \"bufref\" and set the free count.\n */\n    void\nset_bufref(bufref_T *bufref, buf_T *buf)\n{\n    bufref->br_buf = buf;\n    bufref->br_fnum = buf == NULL ? 0 : buf->b_fnum;\n    bufref->br_buf_free_count = buf_free_count;\n}\n\n/*\n * Return TRUE if \"bufref->br_buf\" points to the same buffer as when\n * set_bufref() was called and it is a valid buffer.\n * Only goes through the buffer list if buf_free_count changed.\n * Also checks if b_fnum is still the same, a :bwipe followed by :new might get\n * the same allocated memory, but it's a different buffer.\n */\n    int\nbufref_valid(bufref_T *bufref)\n{\n    return bufref->br_buf_free_count == buf_free_count\n\t? TRUE : buf_valid(bufref->br_buf)\n\t\t\t\t  && bufref->br_fnum == bufref->br_buf->b_fnum;\n}\n\n/*\n * Return TRUE if \"buf\" points to a valid buffer (in the buffer list).\n * This can be slow if there are many buffers, prefer using bufref_valid().\n */\n    int\nbuf_valid(buf_T *buf)\n{\n    buf_T\t*bp;\n\n    // Assume that we more often have a recent buffer, start with the last\n    // one.\n    FOR_ALL_BUFS_FROM_LAST(bp)\n\tif (bp == buf)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * A hash table used to quickly lookup a buffer by its number.\n */\nstatic hashtab_T buf_hashtab;\n\n    static void\nbuf_hashtab_add(buf_T *buf)\n{\n    sprintf((char *)buf->b_key, \"%x\", buf->b_fnum);\n    if (hash_add(&buf_hashtab, buf->b_key) == FAIL)\n\temsg(_(e_buffer_cannot_be_registered));\n}\n\n    static void\nbuf_hashtab_remove(buf_T *buf)\n{\n    hashitem_T *hi = hash_find(&buf_hashtab, buf->b_key);\n\n    if (!HASHITEM_EMPTY(hi))\n\thash_remove(&buf_hashtab, hi);\n}\n\n/*\n * Return TRUE when buffer \"buf\" can be unloaded.\n * Give an error message and return FALSE when the buffer is locked or the\n * screen is being redrawn and the buffer is in a window.\n */\n    static int\ncan_unload_buffer(buf_T *buf)\n{\n    int\t    can_unload = !buf->b_locked;\n\n    if (can_unload && updating_screen)\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str), buf->b_fname);\n    return can_unload;\n}\n\n/*\n * Close the link to a buffer.\n * \"action\" is used when there is no longer a window for the buffer.\n * It can be:\n * 0\t\t\tbuffer becomes hidden\n * DOBUF_UNLOAD\t\tbuffer is unloaded\n * DOBUF_DELETE\t\tbuffer is unloaded and removed from buffer list\n * DOBUF_WIPE\t\tbuffer is unloaded and really deleted\n * DOBUF_WIPE_REUSE\tidem, and add to buf_reuse list\n * When doing all but the first one on the current buffer, the caller should\n * get a new buffer very soon!\n *\n * The 'bufhidden' option can force freeing and deleting.\n *\n * When \"abort_if_last\" is TRUE then do not close the buffer if autocommands\n * cause there to be only one window with this buffer.  e.g. when \":quit\" is\n * supposed to close the window but autocommands close all other windows.\n *\n * When \"ignore_abort\" is TRUE don't abort even when aborting() returns TRUE.\n *\n * Return TRUE when we got to the end and b_nwindows was decremented.\n */\n    int\nclose_buffer(\n    win_T\t*win,\t\t// if not NULL, set b_last_cursor\n    buf_T\t*buf,\n    int\t\taction,\n    int\t\tabort_if_last,\n    int\t\tignore_abort)\n{\n    int\t\tis_curbuf;\n    int\t\tnwindows;\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n    int\t\tunload_buf = (action != 0);\n    int\t\twipe_buf = (action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n    int\t\tdel_buf = (action == DOBUF_DEL || wipe_buf);\n\n    CHECK_CURBUF;\n\n    // Force unloading or deleting when 'bufhidden' says so.\n    // The caller must take care of NOT deleting/freeing when 'bufhidden' is\n    // \"hide\" (otherwise we could never free or delete a buffer).\n    if (buf->b_p_bh[0] == 'd')\t\t// 'bufhidden' == \"delete\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'w')\t// 'bufhidden' == \"wipe\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n\twipe_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'u')\t// 'bufhidden' == \"unload\"\n\tunload_buf = TRUE;\n\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(buf) && (buf->b_nwindows == 1 || del_buf))\n    {\n\tCHECK_CURBUF;\n\tif (term_job_running(buf->b_term))\n\t{\n\t    if (wipe_buf || unload_buf)\n\t    {\n\t\tif (!can_unload_buffer(buf))\n\t\t    return FALSE;\n\n\t\t// Wiping out or unloading a terminal buffer kills the job.\n\t\tfree_terminal(buf);\n\t    }\n\t    else\n\t    {\n\t\t// The job keeps running, hide the buffer.\n\t\tdel_buf = FALSE;\n\t\tunload_buf = FALSE;\n\t    }\n\t}\n\telse if (buf->b_p_bh[0] == 'h' && !del_buf)\n\t{\n\t    // Hide a terminal buffer.\n\t    unload_buf = FALSE;\n\t}\n\telse\n\t{\n\t    // A terminal buffer is wiped out if the job has finished.\n\t    del_buf = TRUE;\n\t    unload_buf = TRUE;\n\t    wipe_buf = TRUE;\n\t}\n\tCHECK_CURBUF;\n    }\n#endif\n\n    // Disallow deleting the buffer when it is locked (already being closed or\n    // halfway a command that relies on it). Unloading is allowed.\n    if ((del_buf || wipe_buf) && !can_unload_buffer(buf))\n\treturn FALSE;\n\n    // check no autocommands closed the window\n    if (win != NULL && win_valid_any_tab(win))\n    {\n\t// Set b_last_cursor when closing the last window for the buffer.\n\t// Remember the last cursor position and window options of the buffer.\n\t// This used to be only for the current window, but then options like\n\t// 'foldmethod' may be lost with a \":only\" command.\n\tif (buf->b_nwindows == 1)\n\t    set_last_cursor(win);\n\tbuflist_setfpos(buf, win,\n\t\t    win->w_cursor.lnum == 1 ? 0 : win->w_cursor.lnum,\n\t\t    win->w_cursor.col, TRUE);\n    }\n\n    set_bufref(&bufref, buf);\n\n    // When the buffer is no longer in a window, trigger BufWinLeave\n    if (buf->b_nwindows == 1)\n    {\n\t++buf->b_locked;\n\t++buf->b_locked_split;\n\tif (apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t{\n\t    // Autocommands deleted the buffer.\naucmd_abort:\n\t    emsg(_(e_autocommands_caused_command_to_abort));\n\t    return FALSE;\n\t}\n\t--buf->b_locked;\n\t--buf->b_locked_split;\n\tif (abort_if_last && one_window())\n\t    // Autocommands made this the only window.\n\t    goto aucmd_abort;\n\n\t// When the buffer becomes hidden, but is not unloaded, trigger\n\t// BufHidden\n\tif (!unload_buf)\n\t{\n\t    ++buf->b_locked;\n\t    ++buf->b_locked_split;\n\t    if (apply_autocmds(EVENT_BUFHIDDEN, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\t// Autocommands deleted the buffer.\n\t\tgoto aucmd_abort;\n\t    --buf->b_locked;\n\t    --buf->b_locked_split;\n\t    if (abort_if_last && one_window())\n\t\t// Autocommands made this the only window.\n\t\tgoto aucmd_abort;\n\t}\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (!ignore_abort && aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n    nwindows = buf->b_nwindows;\n\n    // decrease the link count from windows (unless not in any window)\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n#ifdef FEAT_DIFF\n    if (diffopt_hiddenoff() && !unload_buf && buf->b_nwindows == 0)\n\tdiff_buf_delete(buf);\t// Clear 'diff' for hidden buffer.\n#endif\n\n    // Return when a window is displaying the buffer or when it's not\n    // unloaded.\n    if (buf->b_nwindows > 0 || !unload_buf)\n\treturn FALSE;\n\n    // Always remove the buffer when there is no file name.\n    if (buf->b_ffname == NULL)\n\tdel_buf = TRUE;\n\n    // When closing the current buffer stop Visual mode before freeing\n    // anything.\n    if (buf == curbuf && VIsual_active\n#if defined(EXITFREE)\n\t    && !entered_free_all_mem\n#endif\n\t    )\n\tend_visual_mode();\n\n    // Free all things allocated for this buffer.\n    // Also calls the \"BufDelete\" autocommands when del_buf is TRUE.\n    //\n    // Remember if we are closing the current buffer.  Restore the number of\n    // windows, so that autocommands in buf_freeall() don't get confused.\n    is_curbuf = (buf == curbuf);\n    buf->b_nwindows = nwindows;\n\n    buf_freeall(buf, (del_buf ? BFA_DEL : 0)\n\t\t   + (wipe_buf ? BFA_WIPE : 0)\n\t\t   + (ignore_abort ? BFA_IGNORE_ABORT : 0));\n\n    // Autocommands may have deleted the buffer.\n    if (!bufref_valid(&bufref))\n\treturn FALSE;\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if (!ignore_abort && aborting())\n\treturn FALSE;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause the previous curbuf to be deleted unexpectedly.  But\n    // in some cases it's OK to delete the curbuf, because a new one is\n    // obtained anyway.  Therefore only return if curbuf changed to the\n    // deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn FALSE;\n\n    if (win_valid_any_tab(win) && win->w_buffer == buf)\n\twin->w_buffer = NULL;  // make sure we don't use the buffer now\n\n    // Autocommands may have opened or closed windows for this buffer.\n    // Decrement the count for the close we do here.\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n    /*\n     * Remove the buffer from the list.\n     */\n    if (wipe_buf)\n    {\n\tif (action == DOBUF_WIPE_REUSE)\n\t{\n\t    // we can re-use this buffer number, store it\n\t    if (buf_reuse.ga_itemsize == 0)\n\t\tga_init2(&buf_reuse, sizeof(int), 50);\n\t    if (ga_grow(&buf_reuse, 1) == OK)\n\t\t((int *)buf_reuse.ga_data)[buf_reuse.ga_len++] = buf->b_fnum;\n\t}\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf->b_prev == NULL)\n\t    firstbuf = buf->b_next;\n\telse\n\t    buf->b_prev->b_next = buf->b_next;\n\tif (buf->b_next == NULL)\n\t    lastbuf = buf->b_prev;\n\telse\n\t    buf->b_next->b_prev = buf->b_prev;\n\tfree_buffer(buf);\n    }\n    else\n    {\n\tif (del_buf)\n\t{\n\t    // Free all internal variables and reset option values, to make\n\t    // \":bdel\" compatible with Vim 5.7.\n\t    free_buffer_stuff(buf, TRUE);\n\n\t    // Make it look like a new buffer.\n\t    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n\n\t    // Init the options when loaded again.\n\t    buf->b_p_initialized = FALSE;\n\t}\n\tbuf_clear_file(buf);\n\tif (del_buf)\n\t    buf->b_p_bl = FALSE;\n    }\n    // NOTE: at this point \"curbuf\" may be invalid!\n    return TRUE;\n}\n\n/*\n * Make buffer not contain a file.\n */\n    void\nbuf_clear_file(buf_T *buf)\n{\n    buf->b_ml.ml_line_count = 1;\n    unchanged(buf, TRUE, TRUE);\n    buf->b_shortname = FALSE;\n    buf->b_p_eol = TRUE;\n    buf->b_start_eol = TRUE;\n    buf->b_p_bomb = FALSE;\n    buf->b_start_bomb = FALSE;\n    buf->b_ml.ml_mfp = NULL;\n    buf->b_ml.ml_flags = ML_EMPTY;\t\t// empty buffer\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_deleted_all_lines(buf);\n#endif\n}\n\n/*\n * buf_freeall() - free all things allocated for a buffer that are related to\n * the file.  Careful: get here with \"curwin\" NULL when exiting.\n * flags:\n * BFA_DEL\t     buffer is going to be deleted\n * BFA_WIPE\t     buffer is going to be wiped out\n * BFA_KEEP_UNDO     do not free undo information\n * BFA_IGNORE_ABORT  don't abort even when aborting() returns TRUE\n */\n    void\nbuf_freeall(buf_T *buf, int flags)\n{\n    int\t\tis_curbuf = (buf == curbuf);\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n\n    // Make sure the buffer isn't closed by autocommands.\n    ++buf->b_locked;\n    ++buf->b_locked_split;\n    set_bufref(&bufref, buf);\n    if (buf->b_ml.ml_mfp != NULL)\n    {\n\tif (apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if ((flags & BFA_DEL) && buf->b_p_bl)\n    {\n\tif (apply_autocmds(EVENT_BUFDELETE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t   FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if (flags & BFA_WIPE)\n    {\n\tif (apply_autocmds(EVENT_BUFWIPEOUT, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    --buf->b_locked;\n    --buf->b_locked_split;\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if ((flags & BFA_IGNORE_ABORT) == 0 && aborting())\n\treturn;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause curbuf to be deleted unexpectedly.  But in some cases\n    // it's OK to delete the curbuf, because a new one is obtained anyway.\n    // Therefore only return if curbuf changed to the deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn;\n#ifdef FEAT_DIFF\n    diff_buf_delete(buf);\t    // Can't use 'diff' for unloaded buffer.\n#endif\n#ifdef FEAT_SYN_HL\n    // Remove any ownsyntax, unless exiting.\n    if (curwin != NULL && curwin->w_buffer == buf)\n\treset_synblock(curwin);\n#endif\n\n#ifdef FEAT_FOLDING\n    // No folds in an empty buffer.\n    {\n\twin_T\t\t*win;\n\ttabpage_T\t*tp;\n\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t    if (win->w_buffer == buf)\n\t\tclearFolding(win);\n    }\n#endif\n\n#ifdef FEAT_TCL\n    tcl_buffer_free(buf);\n#endif\n    ml_close(buf, TRUE);\t    // close and delete the memline/memfile\n    buf->b_ml.ml_line_count = 0;    // no lines in buffer\n    if ((flags & BFA_KEEP_UNDO) == 0)\n    {\n\tu_blockfree(buf);\t    // free the memory allocated for undo\n\tu_clearall(buf);\t    // reset all undo information\n    }\n#ifdef FEAT_SYN_HL\n    syntax_clear(&buf->b_s);\t    // reset syntax info\n#endif\n#ifdef FEAT_PROP_POPUP\n    clear_buf_prop_types(buf);\n#endif\n    buf->b_flags &= ~BF_READERR;    // a read error is no longer relevant\n}\n\n/*\n * Free a buffer structure and the things it contains related to the buffer\n * itself (not the file, that must have been done already).\n */\n    static void\nfree_buffer(buf_T *buf)\n{\n    ++buf_free_count;\n    free_buffer_stuff(buf, TRUE);\n#ifdef FEAT_EVAL\n    // b:changedtick uses an item in buf_T, remove it now\n    dictitem_remove(buf->b_vars, (dictitem_T *)&buf->b_ct_di);\n    unref_var_dict(buf->b_vars);\n    remove_listeners(buf);\n#endif\n#ifdef FEAT_LUA\n    lua_buffer_free(buf);\n#endif\n#ifdef FEAT_MZSCHEME\n    mzscheme_buffer_free(buf);\n#endif\n#ifdef FEAT_PERL\n    perl_buf_free(buf);\n#endif\n#ifdef FEAT_PYTHON\n    python_buffer_free(buf);\n#endif\n#ifdef FEAT_PYTHON3\n    python3_buffer_free(buf);\n#endif\n#ifdef FEAT_RUBY\n    ruby_buffer_free(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    channel_buffer_free(buf);\n#endif\n#ifdef FEAT_TERMINAL\n    free_terminal(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    vim_free(buf->b_prompt_text);\n    free_callback(&buf->b_prompt_callback);\n    free_callback(&buf->b_prompt_interrupt);\n#endif\n\n    buf_hashtab_remove(buf);\n\n    aubuflocal_remove(buf);\n\n    if (autocmd_busy)\n    {\n\t// Do not free the buffer structure while autocommands are executing,\n\t// it's still needed. Free it when autocmd_busy is reset.\n\tbuf->b_next = au_pending_free_buf;\n\tau_pending_free_buf = buf;\n    }\n    else\n    {\n\tvim_free(buf);\n\tif (curbuf == buf)\n\t    curbuf = NULL;  // make clear it's not to be used\n    }\n}\n\n/*\n * Initializes b:changedtick.\n */\n    static void\ninit_changedtick(buf_T *buf)\n{\n    dictitem_T *di = (dictitem_T *)&buf->b_ct_di;\n\n    di->di_flags = DI_FLAGS_FIX | DI_FLAGS_RO;\n    di->di_tv.v_type = VAR_NUMBER;\n    di->di_tv.v_lock = VAR_FIXED;\n    di->di_tv.vval.v_number = 0;\n\n#ifdef FEAT_EVAL\n    STRCPY(buf->b_ct_di.di_key, \"changedtick\");\n    (void)dict_add(buf->b_vars, di);\n#endif\n}\n\n/*\n * Free stuff in the buffer for \":bdel\" and when wiping out the buffer.\n */\n    static void\nfree_buffer_stuff(\n    buf_T\t*buf,\n    int\t\tfree_options)\t\t// free options as well\n{\n    if (free_options)\n    {\n\tclear_wininfo(buf);\t\t// including window-local options\n\tfree_buf_options(buf, TRUE);\n#ifdef FEAT_SPELL\n\tga_clear(&buf->b_s.b_langp);\n#endif\n    }\n#ifdef FEAT_EVAL\n    {\n\tvarnumber_T tick = CHANGEDTICK(buf);\n\n\tvars_clear(&buf->b_vars->dv_hashtab); // free all buffer variables\n\thash_init(&buf->b_vars->dv_hashtab);\n\tinit_changedtick(buf);\n\tCHANGEDTICK(buf) = tick;\n\tremove_listeners(buf);\n    }\n#endif\n    uc_clear(&buf->b_ucmds);\t\t// clear local user commands\n#ifdef FEAT_SIGNS\n    buf_delete_signs(buf, (char_u *)\"*\");\t// delete any signs\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_file_killed(buf);\n#endif\n    map_clear_int(buf, MAP_ALL_MODES, TRUE, FALSE);  // clear local mappings\n    map_clear_int(buf, MAP_ALL_MODES, TRUE, TRUE);   // clear local abbrevs\n    VIM_CLEAR(buf->b_start_fenc);\n}\n\n/*\n * Free one wininfo_T.\n */\n    void\nfree_wininfo(wininfo_T *wip)\n{\n    if (wip->wi_optset)\n    {\n\tclear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\tdeleteFoldRecurse(&wip->wi_folds);\n#endif\n    }\n    vim_free(wip);\n}\n\n/*\n * Free the b_wininfo list for buffer \"buf\".\n */\n    static void\nclear_wininfo(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    while (buf->b_wininfo != NULL)\n    {\n\twip = buf->b_wininfo;\n\tbuf->b_wininfo = wip->wi_next;\n\tfree_wininfo(wip);\n    }\n}\n\n/*\n * Go to another buffer.  Handles the result of the ATTENTION dialog.\n */\n    void\ngoto_buffer(\n    exarg_T\t*eap,\n    int\t\tstart,\n    int\t\tdir,\n    int\t\tcount)\n{\n    bufref_T\told_curbuf;\n\n    set_bufref(&old_curbuf, curbuf);\n\n    swap_exists_action = SEA_DIALOG;\n    (void)do_buffer(*eap->cmd == 's' ? DOBUF_SPLIT : DOBUF_GOTO,\n\t\t\t\t\t     start, dir, count, eap->forceit);\n    if (swap_exists_action == SEA_QUIT && *eap->cmd == 's')\n    {\n#if defined(FEAT_EVAL)\n\tcleanup_T   cs;\n\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a window.\n\tenter_cleanup(&cs);\n#endif\n\n\t// Quitting means closing the split window, nothing else.\n\twin_close(curwin, TRUE);\n\tswap_exists_action = SEA_NONE;\n\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else\n\thandle_swap_exists(&old_curbuf);\n}\n\n/*\n * Handle the situation of swap_exists_action being set.\n * It is allowed for \"old_curbuf\" to be NULL or invalid.\n */\n    void\nhandle_swap_exists(bufref_T *old_curbuf)\n{\n#if defined(FEAT_EVAL)\n    cleanup_T\tcs;\n#endif\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    buf_T\t*buf;\n\n    if (swap_exists_action == SEA_QUIT)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Quit at ATTENTION prompt.  Go back to previous\n\t// buffer.  If that buffer is gone or the same as the current one,\n\t// open a new, empty buffer.\n\tswap_exists_action = SEA_NONE;\t// don't want it again\n\tswap_exists_did_quit = TRUE;\n\tclose_buffer(curwin, curbuf, DOBUF_UNLOAD, FALSE, FALSE);\n\tif (old_curbuf == NULL || !bufref_valid(old_curbuf)\n\t\t\t\t\t      || old_curbuf->br_buf == curbuf)\n\t{\n\t    // Block autocommands here because curwin->w_buffer is NULL.\n\t    block_autocmds();\n\t    buf = buflist_new(NULL, NULL, 1L, BLN_CURBUF | BLN_LISTED);\n\t    unblock_autocmds();\n\t}\n\telse\n\t    buf = old_curbuf->br_buf;\n\tif (buf != NULL)\n\t{\n\t    int old_msg_silent = msg_silent;\n\n\t    if (shortmess(SHM_FILEINFO))\n\t\tmsg_silent = 1;  // prevent fileinfo message\n\t    enter_buffer(buf);\n\t    // restore msg_silent, so that the command line will be shown\n\t    msg_silent = old_msg_silent;\n\n#ifdef FEAT_SYN_HL\n\t    if (old_tw != curbuf->b_p_tw)\n\t\tcheck_colorcolumn(curwin);\n#endif\n\t}\n\t// If \"old_curbuf\" is NULL we are in big trouble here...\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else if (swap_exists_action == SEA_RECOVER)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Recover at ATTENTION prompt.\n\tmsg_scroll = TRUE;\n\tml_recover(FALSE);\n\tmsg_puts(\"\\n\");\t// don't overwrite the last message\n\tcmdline_row = msg_row;\n\tdo_modelines(0);\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    swap_exists_action = SEA_NONE;\n}\n\n/*\n * Make the current buffer empty.\n * Used when it is wiped out and it's the last buffer.\n */\n    static int\nempty_curbuf(\n    int close_others,\n    int forceit,\n    int action)\n{\n    int\t    retval;\n    buf_T   *buf = curbuf;\n    bufref_T bufref;\n\n    if (action == DOBUF_UNLOAD)\n    {\n\temsg(_(e_cannot_unload_last_buffer));\n\treturn FAIL;\n    }\n\n    set_bufref(&bufref, buf);\n    if (close_others)\n\t// Close any other windows on this buffer, then make it empty.\n\tclose_windows(buf, TRUE);\n\n    setpcmark();\n    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,\n\t\t\t\t\t  forceit ? ECMD_FORCEIT : 0, curwin);\n\n    // do_ecmd() may create a new buffer, then we have to delete\n    // the old one.  But do_ecmd() may have done that already, check\n    // if the buffer still exists.\n    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows == 0)\n\tclose_buffer(NULL, buf, action, FALSE, FALSE);\n    if (!close_others)\n\tneed_fileinfo = FALSE;\n    return retval;\n}\n\n/*\n * Implementation of the commands for the buffer list.\n *\n * action == DOBUF_GOTO\t    go to specified buffer\n * action == DOBUF_SPLIT    split window and go to specified buffer\n * action == DOBUF_UNLOAD   unload specified buffer(s)\n * action == DOBUF_DEL\t    delete specified buffer(s) from buffer list\n * action == DOBUF_WIPE\t    delete specified buffer(s) really\n * action == DOBUF_WIPE_REUSE idem, and add number to \"buf_reuse\"\n *\n * start == DOBUF_CURRENT   go to \"count\" buffer from current buffer\n * start == DOBUF_FIRST\t    go to \"count\" buffer from first buffer\n * start == DOBUF_LAST\t    go to \"count\" buffer from last buffer\n * start == DOBUF_MOD\t    go to \"count\" modified buffer from current buffer\n *\n * Return FAIL or OK.\n */\n    static int\ndo_buffer_ext(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tflags)\t\t// DOBUF_FORCEIT etc.\n{\n    buf_T\t*buf;\n    buf_T\t*bp;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n\n    switch (start)\n    {\n\tcase DOBUF_FIRST:   buf = firstbuf; break;\n\tcase DOBUF_LAST:    buf = lastbuf;  break;\n\tdefault:\t    buf = curbuf;   break;\n    }\n    if (start == DOBUF_MOD)\t    // find next modified buffer\n    {\n\twhile (count-- > 0)\n\t{\n\t    do\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    while (buf != curbuf && !bufIsChanged(buf));\n\t}\n\tif (!bufIsChanged(buf))\n\t{\n\t    emsg(_(e_no_modified_buffer_found));\n\t    return FAIL;\n\t}\n    }\n    else if (start == DOBUF_FIRST && count) // find specified buffer number\n    {\n\twhile (buf != NULL && buf->b_fnum != count)\n\t    buf = buf->b_next;\n    }\n    else\n    {\n\tbp = NULL;\n\twhile (count > 0 || (!unload && !buf->b_p_bl && bp != buf))\n\t{\n\t    // remember the buffer where we start, we come back there when all\n\t    // buffers are unlisted.\n\t    if (bp == NULL)\n\t\tbp = buf;\n\t    if (dir == FORWARD)\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    else\n\t    {\n\t\tbuf = buf->b_prev;\n\t\tif (buf == NULL)\n\t\t    buf = lastbuf;\n\t    }\n\t    // don't count unlisted buffers\n\t    if (unload || buf->b_p_bl)\n\t    {\n\t\t --count;\n\t\t bp = NULL;\t// use this buffer as new starting point\n\t    }\n\t    if (bp == buf)\n\t    {\n\t\t// back where we started, didn't find anything.\n\t\temsg(_(e_there_is_no_listed_buffer));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n\n    if (buf == NULL)\t    // could not find it\n    {\n\tif (start == DOBUF_FIRST)\n\t{\n\t    // don't warn when deleting\n\t    if (!unload)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\t}\n\telse if (dir == FORWARD)\n\t    emsg(_(e_cannot_go_beyond_last_buffer));\n\telse\n\t    emsg(_(e_cannot_go_before_first_buffer));\n\treturn FAIL;\n    }\n#ifdef FEAT_PROP_POPUP\n    if ((flags & DOBUF_NOPOPUP) && bt_popup(buf)\n# ifdef FEAT_TERMINAL\n\t\t\t\t&& !bt_terminal(buf)\n#endif\n       )\n\treturn OK;\n#endif\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * delete buffer \"buf\" from memory and/or the list\n     */\n    if (unload)\n    {\n\tint\tforward;\n\tbufref_T bufref;\n\n\tif (!can_unload_buffer(buf))\n\t    return FAIL;\n\n\tset_bufref(&bufref, buf);\n\n\t// When unloading or deleting a buffer that's already unloaded and\n\t// unlisted: fail silently.\n\tif (action != DOBUF_WIPE && action != DOBUF_WIPE_REUSE\n\t\t\t\t   && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl)\n\t    return FAIL;\n\n\tif ((flags & DOBUF_FORCEIT) == 0 && bufIsChanged(buf))\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n\t\tdialog_changed(buf, FALSE);\n\t\tif (!bufref_valid(&bufref))\n\t\t    // Autocommand deleted buffer, oops!  It's not changed\n\t\t    // now.\n\t\t    return FAIL;\n\t\t// If it's still changed fail silently, the dialog already\n\t\t// mentioned why it fails.\n\t\tif (bufIsChanged(buf))\n\t\t    return FAIL;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tsemsg(_(e_no_write_since_last_change_for_buffer_nr_add_bang_to_override),\n\t\t\t\t\t\t\t\t buf->b_fnum);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// When closing the current buffer stop Visual mode.\n\tif (buf == curbuf && VIsual_active)\n\t    end_visual_mode();\n\n\t// If deleting the last (listed) buffer, make it empty.\n\t// The last (listed) buffer cannot be unloaded.\n\tFOR_ALL_BUFFERS(bp)\n\t    if (bp->b_p_bl && bp != buf)\n\t\tbreak;\n\tif (bp == NULL && buf == curbuf)\n\t    return empty_curbuf(TRUE, (flags & DOBUF_FORCEIT), action);\n\n\t// If the deleted buffer is the current one, close the current window\n\t// (unless it's the only window).  Repeat this so long as we end up in\n\t// a window with this buffer.\n\twhile (buf == curbuf\n\t\t   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n\t\t   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))\n\t{\n\t    if (win_close(curwin, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\n\t// If the buffer to be deleted is not the current one, delete it here.\n\tif (buf != curbuf)\n\t{\n\t    close_windows(buf, FALSE);\n\t    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)\n\t\t    close_buffer(NULL, buf, action, FALSE, FALSE);\n\t    return OK;\n\t}\n\n\t/*\n\t * Deleting the current buffer: Need to find another buffer to go to.\n\t * There should be another, otherwise it would have been handled\n\t * above.  However, autocommands may have deleted all buffers.\n\t * First use au_new_curbuf.br_buf, if it is valid.\n\t * Then prefer the buffer we most recently visited.\n\t * Else try to find one that is loaded, after the current buffer,\n\t * then before the current buffer.\n\t * Finally use any buffer.\n\t */\n\tbuf = NULL;\t// selected buffer\n\tbp = NULL;\t// used when no loaded buffer found\n\tif (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf))\n\t    buf = au_new_curbuf.br_buf;\n\telse if (curwin->w_jumplistlen > 0)\n\t{\n\t    int     jumpidx;\n\n\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    if (buf == curbuf || !buf->b_p_bl)\n\t\t\tbuf = NULL;\t// skip current and unlisted bufs\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t\t// advance to older entry in jump list\n\t\tif (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t\t    break;\n\t\tif (--jumpidx < 0)\n\t\t    jumpidx = curwin->w_jumplistlen - 1;\n\t\tif (jumpidx == forward)\t\t// List exhausted for sure\n\t\t    break;\n\t    }\n\t}\n\n\tif (buf == NULL)\t// No previous buffer, Try 2'nd approach\n\t{\n\t    forward = TRUE;\n\t    buf = curbuf->b_next;\n\t    for (;;)\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl)\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf)\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n\n    /*\n     * make \"buf\" the current buffer\n     */\n    if (action == DOBUF_SPLIT)\t    // split window first\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))\n\t    return OK;\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))\n\t    return OK;\n\tif (win_split(0, 0) == FAIL)\n\t    return FAIL;\n    }\n\n    // go to current buffer - nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    // Check if the current buffer may be abandoned.\n    if (action == DOBUF_GOTO && !can_abandon(curbuf, (flags & DOBUF_FORCEIT)))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(curbuf, FALSE);\n\t    if (!bufref_valid(&bufref))\n\t\t// Autocommand deleted buffer, oops!\n\t\treturn FAIL;\n\t}\n\tif (bufIsChanged(curbuf))\n#endif\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n    }\n\n    // Go to the other buffer.\n    set_curbuf(buf, action);\n\n    if (action == DOBUF_SPLIT)\n\tRESET_BINDING(curwin);\t// reset 'scrollbind' and 'cursorbind'\n\n#if defined(FEAT_EVAL)\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n\n    return OK;\n}\n\n    int\ndo_buffer(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tforceit)\t// TRUE when using !\n{\n    return do_buffer_ext(action, start, dir, count,\n\t\t\t\t\t\t  forceit ? DOBUF_FORCEIT : 0);\n}\n\n/*\n * do_bufdel() - delete or unload buffer(s)\n *\n * addr_count == 0: \":bdel\" - delete current buffer\n * addr_count == 1: \":N bdel\" or \":bdel N [N ..]\" - first delete\n *\t\t    buffer \"end_bnr\", then any other arguments.\n * addr_count == 2: \":N,N bdel\" - delete buffers in range\n *\n * command can be DOBUF_UNLOAD (\":bunload\"), DOBUF_WIPE (\":bwipeout\") or\n * DOBUF_DEL (\":bdel\")\n *\n * Returns error message or NULL\n */\n    char *\ndo_bufdel(\n    int\t\tcommand,\n    char_u\t*arg,\t\t// pointer to extra arguments\n    int\t\taddr_count,\n    int\t\tstart_bnr,\t// first buffer number in a range\n    int\t\tend_bnr,\t// buffer nr or last buffer nr in a range\n    int\t\tforceit)\n{\n    int\t\tdo_current = 0;\t// delete current buffer?\n    int\t\tdeleted = 0;\t// number of buffers deleted\n    char\t*errormsg = NULL; // return value\n    int\t\tbnr;\t\t// buffer number\n    char_u\t*p;\n\n    if (addr_count == 0)\n    {\n\t(void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);\n    }\n    else\n    {\n\tif (addr_count == 2)\n\t{\n\t    if (*arg)\t\t// both range and argument is not allowed\n\t\treturn ex_errmsg(e_trailing_characters_str, arg);\n\t    bnr = start_bnr;\n\t}\n\telse\t// addr_count == 1\n\t    bnr = end_bnr;\n\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    // Delete the current buffer last, otherwise when the\n\t    // current buffer is deleted, the next buffer becomes\n\t    // the current one and will be loaded, which may then\n\t    // also be deleted, etc.\n\t    if (bnr == curbuf->b_fnum)\n\t\tdo_current = bnr;\n\t    else if (do_buffer_ext(command, DOBUF_FIRST, FORWARD, bnr,\n\t\t\t  DOBUF_NOPOPUP | (forceit ? DOBUF_FORCEIT : 0)) == OK)\n\t\t++deleted;\n\n\t    // find next buffer number to delete/unload\n\t    if (addr_count == 2)\n\t    {\n\t\tif (++bnr > end_bnr)\n\t\t    break;\n\t    }\n\t    else    // addr_count == 1\n\t    {\n\t\targ = skipwhite(arg);\n\t\tif (*arg == NUL)\n\t\t    break;\n\t\tif (!VIM_ISDIGIT(*arg))\n\t\t{\n\t\t    p = skiptowhite_esc(arg);\n\t\t    bnr = buflist_findpat(arg, p,\n\t\t\t  command == DOBUF_WIPE || command == DOBUF_WIPE_REUSE,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t    if (bnr < 0)\t    // failed\n\t\t\tbreak;\n\t\t    arg = p;\n\t\t}\n\t\telse\n\t\t    bnr = getdigits(&arg);\n\t    }\n\t}\n\tif (!got_int && do_current && do_buffer(command, DOBUF_FIRST,\n\t\t\t\t\t  FORWARD, do_current, forceit) == OK)\n\t    ++deleted;\n\n\tif (deleted == 0)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_unloaded));\n\t    else if (command == DOBUF_DEL)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_deleted));\n\t    else\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_wiped_out));\n\t    errormsg = (char *)IObuff;\n\t}\n\telse if (deleted >= p_report)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tsmsg(NGETTEXT(\"%d buffer unloaded\",\n\t\t\t    \"%d buffers unloaded\", deleted), deleted);\n\t    else if (command == DOBUF_DEL)\n\t\tsmsg(NGETTEXT(\"%d buffer deleted\",\n\t\t\t    \"%d buffers deleted\", deleted), deleted);\n\t    else\n\t\tsmsg(NGETTEXT(\"%d buffer wiped out\",\n\t\t\t    \"%d buffers wiped out\", deleted), deleted);\n\t}\n    }\n\n\n    return errormsg;\n}\n\n/*\n * Set current buffer to \"buf\".  Executes autocommands and closes current\n * buffer.  \"action\" tells how to close the current buffer:\n * DOBUF_GOTO\t    free or hide it\n * DOBUF_SPLIT\t    nothing\n * DOBUF_UNLOAD\t    unload it\n * DOBUF_DEL\t    delete it\n * DOBUF_WIPE\t    wipe it out\n * DOBUF_WIPE_REUSE wipe it out and add to \"buf_reuse\"\n */\n    void\nset_curbuf(buf_T *buf, int action)\n{\n    buf_T\t*prevbuf;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    bufref_T\tnewbufref;\n    bufref_T\tprevbufref;\n\n    setpcmark();\n    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = curbuf->b_fnum; // remember alternate file\n    buflist_altfpos(curwin);\t\t\t // remember curpos\n\n    // Don't restart Select mode after switching to another buffer.\n    VIsual_reselect = FALSE;\n\n    // close_windows() or apply_autocmds() may change curbuf and wipe out \"buf\"\n    prevbuf = curbuf;\n    set_bufref(&prevbufref, prevbuf);\n    set_bufref(&newbufref, buf);\n\n    // Autocommands may delete the current buffer and/or the buffer we want to\n    // go to.  In those cases don't close the buffer.\n    if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf)\n\t    || (bufref_valid(&prevbufref)\n\t\t&& bufref_valid(&newbufref)\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t       ))\n    {\n#ifdef FEAT_SYN_HL\n\tif (prevbuf == curwin->w_buffer)\n\t    reset_synblock(curwin);\n#endif\n\tif (unload)\n\t    close_windows(prevbuf, FALSE);\n#if defined(FEAT_EVAL)\n\tif (bufref_valid(&prevbufref) && !aborting())\n#else\n\tif (bufref_valid(&prevbufref))\n#endif\n\t{\n\t    win_T  *previouswin = curwin;\n\n\t    // Do not sync when in Insert mode and the buffer is open in\n\t    // another window, might be a timer doing something in another\n\t    // window.\n\t    if (prevbuf == curbuf\n\t\t\t && ((State & INSERT) == 0 || curbuf->b_nwindows <= 1))\n\t\tu_sync(FALSE);\n\t    close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL, prevbuf,\n\t\t    unload ? action : (action == DOBUF_GOTO\n\t\t\t&& !buf_hide(prevbuf)\n\t\t\t&& !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0,\n\t\t    FALSE, FALSE);\n\t    if (curwin != previouswin && win_valid(previouswin))\n\t      // autocommands changed curwin, Grr!\n\t      curwin = previouswin;\n\t}\n    }\n    // An autocommand may have deleted \"buf\", already entered it (e.g., when\n    // it did \":bunload\") or aborted the script processing.\n    // If curwin->w_buffer is null, enter_buffer() will make it valid again\n    if ((buf_valid(buf) && buf != curbuf\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t) || curwin->w_buffer == NULL)\n    {\n\tenter_buffer(buf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n    }\n}\n\n/*\n * Enter a new current buffer.\n * Old curbuf must have been abandoned already!  This also means \"curbuf\" may\n * be pointing to freed memory.\n */\n    static void\nenter_buffer(buf_T *buf)\n{\n    // Get the buffer in the current window.\n    curwin->w_buffer = buf;\n    curbuf = buf;\n    ++curbuf->b_nwindows;\n\n    // Copy buffer and window local option values.  Not for a help buffer.\n    buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);\n    if (!buf->b_help)\n\tget_winopts(buf);\n#ifdef FEAT_FOLDING\n    else\n\t// Remove all folds in the window.\n\tclearFolding(curwin);\n    foldUpdateAll(curwin);\t// update folds (later).\n#endif\n\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff)\n\tdiff_buf_add(curbuf);\n#endif\n\n#ifdef FEAT_SYN_HL\n    curwin->w_s = &(curbuf->b_s);\n#endif\n\n    // Cursor on first line by default.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_set_curswant = TRUE;\n    curwin->w_topline_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    buflist_setfpos(curbuf, curwin, curbuf->b_last_cursor.lnum,\n\t\t\t\t\t      curbuf->b_last_cursor.col, TRUE);\n\n    // Make sure the buffer is loaded.\n    if (curbuf->b_ml.ml_mfp == NULL)\t// need to load the file\n    {\n\t// If there is no filetype, allow for detecting one.  Esp. useful for\n\t// \":ball\" used in an autocommand.  If there already is a filetype we\n\t// might prefer to keep it.\n\tif (*curbuf->b_p_ft == NUL)\n\t    did_filetype = FALSE;\n\n\topen_buffer(FALSE, NULL, 0);\n    }\n    else\n    {\n\tif (!msg_silent && !shortmess(SHM_FILEINFO))\n\t    need_fileinfo = TRUE;\t// display file info after redraw\n\n\t// check if file changed\n\t(void)buf_check_timestamp(curbuf, FALSE);\n\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n\tapply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    // If autocommands did not change the cursor position, restore cursor lnum\n    // and possibly cursor col.\n    if (curwin->w_cursor.lnum == 1 && inindent(0))\n\tbuflist_getfpos();\n\n    check_arg_idx(curwin);\t\t// check for valid arg_idx\n    maketitle();\n\t// when autocmds didn't change it\n    if (curwin->w_topline == 1 && !curwin->w_topline_was_set)\n\tscroll_cursor_halfway(FALSE);\t// redisplay at correct position\n\n#ifdef FEAT_NETBEANS_INTG\n    // Send fileOpened event because we've changed buffers.\n    netbeans_file_activated(curbuf);\n#endif\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n#ifdef FEAT_SPELL\n    // May need to set the spell language.  Can only do this after the buffer\n    // has been properly setup.\n    if (!curbuf->b_help && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)did_set_spelllang(curwin);\n#endif\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    redraw_later(NOT_VALID);\n}\n\n#if defined(FEAT_AUTOCHDIR) || defined(PROTO)\n/*\n * Change to the directory of the current buffer.\n * Don't do this while still starting up.\n */\n    void\ndo_autochdir(void)\n{\n    if ((starting == 0 || test_autochdir)\n\t    && curbuf->b_ffname != NULL\n\t    && vim_chdirfile(curbuf->b_ffname, \"auto\") == OK)\n    {\n\tshorten_fnames(TRUE);\n\tlast_chdir_reason = \"autochdir\";\n    }\n}\n#endif\n\n    void\nno_write_message(void)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(curbuf->b_term))\n\temsg(_(e_job_still_running_add_bang_to_end_the_job));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change_add_bang_to_override));\n}\n\n    void\nno_write_message_nobang(buf_T *buf UNUSED)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(buf->b_term))\n\temsg(_(e_job_still_running));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change));\n}\n\n/*\n * functions for dealing with the buffer list\n */\n\n/*\n * Return TRUE if the current buffer is empty, unnamed, unmodified and used in\n * only one window.  That means it can be re-used.\n */\n    int\ncurbuf_reusable(void)\n{\n    return (curbuf != NULL\n\t&& curbuf->b_ffname == NULL\n\t&& curbuf->b_nwindows <= 1\n\t&& (curbuf->b_ml.ml_mfp == NULL || BUFEMPTY())\n#if defined(FEAT_QUICKFIX)\n\t&& !bt_quickfix(curbuf)\n#endif\n\t&& !curbufIsChanged());\n}\n\n/*\n * Add a file name to the buffer list.  Return a pointer to the buffer.\n * If the same file name already exists return a pointer to that buffer.\n * If it does not exist, or if fname == NULL, a new entry is created.\n * If (flags & BLN_CURBUF) is TRUE, may use current buffer.\n * If (flags & BLN_LISTED) is TRUE, add new buffer to buffer list.\n * If (flags & BLN_DUMMY) is TRUE, don't count it as a real buffer.\n * If (flags & BLN_NEW) is TRUE, don't use an existing buffer.\n * If (flags & BLN_NOOPT) is TRUE, don't copy options from the current buffer\n *\t\t\t\t    if the buffer already exists.\n * If (flags & BLN_REUSE) is TRUE, may use buffer number from \"buf_reuse\".\n * This is the ONLY way to create a new buffer.\n */\n    buf_T *\nbuflist_new(\n    char_u\t*ffname_arg,\t// full path of fname or relative\n    char_u\t*sfname_arg,\t// short fname or NULL\n    linenr_T\tlnum,\t\t// preferred cursor line\n    int\t\tflags)\t\t// BLN_ defines\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*buf;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (top_file_num == 1)\n\thash_init(&buf_hashtab);\n\n    fname_expand(curbuf, &ffname, &sfname);\t// will allocate ffname\n\n    /*\n     * If the file name already exists in the list, update the entry.\n     */\n#ifdef UNIX\n    // On Unix we can use inode numbers when the file exists.  Works better\n    // for hard links.\n    if (sfname == NULL || mch_stat((char *)sfname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n#endif\n    if (ffname != NULL && !(flags & (BLN_DUMMY | BLN_NEW)) && (buf =\n#ifdef UNIX\n\t\tbuflist_findname_stat(ffname, &st)\n#else\n\t\tbuflist_findname(ffname)\n#endif\n\t\t) != NULL)\n    {\n\tvim_free(ffname);\n\tif (lnum != 0)\n\t    buflist_setfpos(buf, (flags & BLN_NOCURWIN) ? NULL : curwin,\n\t\t\t\t\t\t      lnum, (colnr_T)0, FALSE);\n\n\tif ((flags & BLN_NOOPT) == 0)\n\t    // copy the options now, if 'cpo' doesn't have 's' and not done\n\t    // already\n\t    buf_copy_options(buf, 0);\n\n\tif ((flags & BLN_LISTED) && !buf->b_p_bl)\n\t{\n\t    bufref_T bufref;\n\n\t    buf->b_p_bl = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    if (!(flags & BLN_DUMMY))\n\t    {\n\t\tif (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t\t&& !bufref_valid(&bufref))\n\t\t    return NULL;\n\t    }\n\t}\n\treturn buf;\n    }\n\n    /*\n     * If the current buffer has no name and no contents, use the current\n     * buffer.\tOtherwise: Need to allocate a new buffer structure.\n     *\n     * This is the ONLY place where a new buffer structure is allocated!\n     * (A spell file buffer is allocated in spell.c, but that's not a normal\n     * buffer.)\n     */\n    buf = NULL;\n    if ((flags & BLN_CURBUF) && curbuf_reusable())\n    {\n\tbuf = curbuf;\n\t// It's like this buffer is deleted.  Watch out for autocommands that\n\t// change curbuf!  If that happens, allocate a new buffer anyway.\n\tif (curbuf->b_p_bl)\n\t    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);\n\tif (buf == curbuf)\n\t    apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#endif\n\tif (buf == curbuf)\n\t{\n\t    // Make sure 'bufhidden' and 'buftype' are empty\n\t    clear_string_option(&buf->b_p_bh);\n\t    clear_string_option(&buf->b_p_bt);\n\t}\n    }\n    if (buf != curbuf || curbuf == NULL)\n    {\n\tbuf = ALLOC_CLEAR_ONE(buf_T);\n\tif (buf == NULL)\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#ifdef FEAT_EVAL\n\t// init b: variables\n\tbuf->b_vars = dict_alloc();\n\tif (buf->b_vars == NULL)\n\t{\n\t    vim_free(ffname);\n\t    vim_free(buf);\n\t    return NULL;\n\t}\n\tinit_var_dict(buf->b_vars, &buf->b_bufvar, VAR_SCOPE);\n#endif\n\tinit_changedtick(buf);\n    }\n\n    if (ffname != NULL)\n    {\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = vim_strsave(sfname);\n    }\n\n    clear_wininfo(buf);\n    buf->b_wininfo = ALLOC_CLEAR_ONE(wininfo_T);\n\n    if ((ffname != NULL && (buf->b_ffname == NULL || buf->b_sfname == NULL))\n\t    || buf->b_wininfo == NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf != curbuf)\n\t    free_buffer(buf);\n\treturn NULL;\n    }\n\n    if (buf == curbuf)\n    {\n\t// free all things allocated for this buffer\n\tbuf_freeall(buf, 0);\n\tif (buf != curbuf)\t // autocommands deleted the buffer!\n\t    return NULL;\n#if defined(FEAT_EVAL)\n\tif (aborting())\t\t// autocmds may abort script processing\n\t    return NULL;\n#endif\n\tfree_buffer_stuff(buf, FALSE);\t// delete local variables et al.\n\n\t// Init the options.\n\tbuf->b_p_initialized = FALSE;\n\tbuf_copy_options(buf, BCO_ENTER);\n\n#ifdef FEAT_KEYMAP\n\t// need to reload lmaps and set b:keymap_name\n\tcurbuf->b_kmap_state |= KEYMAP_INIT;\n#endif\n    }\n    else\n    {\n\t// put the new buffer at the end of the buffer list\n\tbuf->b_next = NULL;\n\tif (firstbuf == NULL)\t\t// buffer list is empty\n\t{\n\t    buf->b_prev = NULL;\n\t    firstbuf = buf;\n\t}\n\telse\t\t\t\t// append new buffer at end of list\n\t{\n\t    lastbuf->b_next = buf;\n\t    buf->b_prev = lastbuf;\n\t}\n\tlastbuf = buf;\n\n\tif ((flags & BLN_REUSE) && buf_reuse.ga_len > 0)\n\t{\n\t    // Recycle a previously used buffer number.  Used for buffers which\n\t    // are normally hidden, e.g. in a popup window.  Avoids that the\n\t    // buffer number grows rapidly.\n\t    --buf_reuse.ga_len;\n\t    buf->b_fnum = ((int *)buf_reuse.ga_data)[buf_reuse.ga_len];\n\n\t    // Move buffer to the right place in the buffer list.\n\t    while (buf->b_prev != NULL && buf->b_fnum < buf->b_prev->b_fnum)\n\t    {\n\t\tbuf_T\t*prev = buf->b_prev;\n\n\t\tprev->b_next = buf->b_next;\n\t\tif (prev->b_next != NULL)\n\t\t    prev->b_next->b_prev = prev;\n\t\tbuf->b_next = prev;\n\t\tbuf->b_prev = prev->b_prev;\n\t\tif (buf->b_prev != NULL)\n\t\t    buf->b_prev->b_next = buf;\n\t\tprev->b_prev = buf;\n\t\tif (lastbuf == buf)\n\t\t    lastbuf = prev;\n\t\tif (firstbuf == prev)\n\t\t    firstbuf = buf;\n\t    }\n\t}\n\telse\n\t    buf->b_fnum = top_file_num++;\n\tif (top_file_num < 0)\t\t// wrap around (may cause duplicates)\n\t{\n\t    emsg(_(\"W14: Warning: List of file names overflow\"));\n\t    if (emsg_silent == 0 && !in_assert_fails)\n\t    {\n\t\tout_flush();\n\t\tui_delay(3001L, TRUE);\t// make sure it is noticed\n\t    }\n\t    top_file_num = 1;\n\t}\n\tbuf_hashtab_add(buf);\n\n\t// Always copy the options from the current buffer.\n\tbuf_copy_options(buf, BCO_ALWAYS);\n    }\n\n    buf->b_wininfo->wi_fpos.lnum = lnum;\n    buf->b_wininfo->wi_win = curwin;\n\n#ifdef FEAT_SYN_HL\n    hash_init(&buf->b_s.b_keywtab);\n    hash_init(&buf->b_s.b_keywtab_ic);\n#endif\n\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n    buf->b_u_synced = TRUE;\n    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n    if (flags & BLN_DUMMY)\n\tbuf->b_flags |= BF_DUMMY;\n    buf_clear_file(buf);\n    clrallmarks(buf);\t\t\t// clear marks\n    fmarks_check_names(buf);\t\t// check file marks for this file\n    buf->b_p_bl = (flags & BLN_LISTED) ? TRUE : FALSE;\t// init 'buflisted'\n    if (!(flags & BLN_DUMMY))\n    {\n\tbufref_T bufref;\n\n\t// Tricky: these autocommands may change the buffer list.  They could\n\t// also split the window with re-using the one empty buffer. This may\n\t// result in unexpectedly losing the empty buffer.\n\tset_bufref(&bufref, buf);\n\tif (apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    return NULL;\n\tif (flags & BLN_LISTED)\n\t{\n\t    if (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\treturn NULL;\n\t}\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t    return NULL;\n#endif\n    }\n\n    return buf;\n}\n\n/*\n * Free the memory for the options of a buffer.\n * If \"free_p_ff\" is TRUE also free 'fileformat', 'buftype' and\n * 'fileencoding'.\n */\n    void\nfree_buf_options(\n    buf_T\t*buf,\n    int\t\tfree_p_ff)\n{\n    if (free_p_ff)\n    {\n\tclear_string_option(&buf->b_p_fenc);\n\tclear_string_option(&buf->b_p_ff);\n\tclear_string_option(&buf->b_p_bh);\n\tclear_string_option(&buf->b_p_bt);\n    }\n#ifdef FEAT_FIND_ID\n    clear_string_option(&buf->b_p_def);\n    clear_string_option(&buf->b_p_inc);\n# ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_inde);\n    clear_string_option(&buf->b_p_indk);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n    clear_string_option(&buf->b_p_cm);\n#endif\n    clear_string_option(&buf->b_p_fp);\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n# ifdef FEAT_SODIUM\n    if ((buf->b_p_key != NULL) && (*buf->b_p_key != NUL) &&\n\t\t\t\t(crypt_get_method_nr(buf) == CRYPT_M_SOD))\n\tcrypt_sodium_munlock(buf->b_p_key, STRLEN(buf->b_p_key));\n# endif\n    clear_string_option(&buf->b_p_key);\n#endif\n    clear_string_option(&buf->b_p_kp);\n    clear_string_option(&buf->b_p_mps);\n    clear_string_option(&buf->b_p_fo);\n    clear_string_option(&buf->b_p_flp);\n    clear_string_option(&buf->b_p_isk);\n#ifdef FEAT_VARTABS\n    clear_string_option(&buf->b_p_vsts);\n    vim_free(buf->b_p_vsts_nopaste);\n    buf->b_p_vsts_nopaste = NULL;\n    vim_free(buf->b_p_vsts_array);\n    buf->b_p_vsts_array = NULL;\n    clear_string_option(&buf->b_p_vts);\n    VIM_CLEAR(buf->b_p_vts_array);\n#endif\n#ifdef FEAT_KEYMAP\n    clear_string_option(&buf->b_p_keymap);\n    keymap_clear(&buf->b_kmap_ga);\n    ga_clear(&buf->b_kmap_ga);\n#endif\n    clear_string_option(&buf->b_p_com);\n#ifdef FEAT_FOLDING\n    clear_string_option(&buf->b_p_cms);\n#endif\n    clear_string_option(&buf->b_p_nf);\n#ifdef FEAT_SYN_HL\n    clear_string_option(&buf->b_p_syn);\n    clear_string_option(&buf->b_s.b_syn_isk);\n#endif\n#ifdef FEAT_SPELL\n    clear_string_option(&buf->b_s.b_p_spc);\n    clear_string_option(&buf->b_s.b_p_spf);\n    vim_regfree(buf->b_s.b_cap_prog);\n    buf->b_s.b_cap_prog = NULL;\n    clear_string_option(&buf->b_s.b_p_spl);\n    clear_string_option(&buf->b_s.b_p_spo);\n#endif\n#ifdef FEAT_SEARCHPATH\n    clear_string_option(&buf->b_p_sua);\n#endif\n    clear_string_option(&buf->b_p_ft);\n#ifdef FEAT_CINDENT\n    clear_string_option(&buf->b_p_cink);\n    clear_string_option(&buf->b_p_cino);\n#endif\n#if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)\n    clear_string_option(&buf->b_p_cinw);\n#endif\n    clear_string_option(&buf->b_p_cpt);\n#ifdef FEAT_COMPL_FUNC\n    clear_string_option(&buf->b_p_cfu);\n    free_callback(&buf->b_cfu_cb);\n    clear_string_option(&buf->b_p_ofu);\n    free_callback(&buf->b_ofu_cb);\n    clear_string_option(&buf->b_p_tsrfu);\n    free_callback(&buf->b_tsrfu_cb);\n#endif\n#ifdef FEAT_QUICKFIX\n    clear_string_option(&buf->b_p_gp);\n    clear_string_option(&buf->b_p_mp);\n    clear_string_option(&buf->b_p_efm);\n#endif\n    clear_string_option(&buf->b_p_ep);\n    clear_string_option(&buf->b_p_path);\n    clear_string_option(&buf->b_p_tags);\n    clear_string_option(&buf->b_p_tc);\n#ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_tfu);\n    free_callback(&buf->b_tfu_cb);\n#endif\n    clear_string_option(&buf->b_p_dict);\n    clear_string_option(&buf->b_p_tsr);\n#ifdef FEAT_TEXTOBJ\n    clear_string_option(&buf->b_p_qe);\n#endif\n    buf->b_p_ar = -1;\n    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n#ifdef FEAT_LISP\n    clear_string_option(&buf->b_p_lw);\n#endif\n    clear_string_option(&buf->b_p_bkc);\n    clear_string_option(&buf->b_p_menc);\n}\n\n/*\n * Get alternate file \"n\".\n * Set linenr to \"lnum\" or altfpos.lnum if \"lnum\" == 0.\n *\tAlso set cursor column to altfpos.col if 'startofline' is not set.\n * if (options & GETF_SETMARK) call setpcmark()\n * if (options & GETF_ALT) we are jumping to an alternate file.\n * if (options & GETF_SWITCH) respect 'switchbuf' settings when jumping\n *\n * Return FAIL for failure, OK for success.\n */\n    int\nbuflist_getfile(\n    int\t\tn,\n    linenr_T\tlnum,\n    int\t\toptions,\n    int\t\tforceit)\n{\n    buf_T\t*buf;\n    win_T\t*wp = NULL;\n    pos_T\t*fpos;\n    colnr_T\tcol;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n    {\n\tif ((options & GETF_ALT) && n == 0)\n\t    emsg(_(e_no_alternate_file));\n\telse\n\t    semsg(_(e_buffer_nr_not_found), n);\n\treturn FAIL;\n    }\n\n    // if alternate file is the current buffer, nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn FAIL;\n    }\n    if (curbuf_locked())\n\treturn FAIL;\n\n    // altfpos may be changed by getfile(), get it now\n    if (lnum == 0)\n    {\n\tfpos = buflist_findfpos(buf);\n\tlnum = fpos->lnum;\n\tcol = fpos->col;\n    }\n    else\n\tcol = 0;\n\n    if (options & GETF_SWITCH)\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif (swb_flags & SWB_USEOPEN)\n\t    wp = buf_jump_open_win(buf);\n\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif (wp == NULL && (swb_flags & SWB_USETAB))\n\t    wp = buf_jump_open_tab(buf);\n\n\t// If 'switchbuf' contains \"split\", \"vsplit\" or \"newtab\" and the\n\t// current buffer isn't empty: open new tab or window\n\tif (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))\n\t\t\t\t\t\t\t       && !BUFEMPTY())\n\t{\n\t    if (swb_flags & SWB_NEWTAB)\n\t\ttabpage_new();\n\t    else if (win_split(0, (swb_flags & SWB_VSPLIT) ? WSP_VERT : 0)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t    RESET_BINDING(curwin);\n\t}\n    }\n\n    ++RedrawingDisabled;\n    if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL,\n\t\t\t\t     (options & GETF_SETMARK), lnum, forceit)))\n    {\n\t--RedrawingDisabled;\n\n\t// cursor is at to BOL and w_cursor.lnum is checked due to getfile()\n\tif (!p_sol && col != 0)\n\t{\n\t    curwin->w_cursor.col = col;\n\t    check_cursor_col();\n\t    curwin->w_cursor.coladd = 0;\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\treturn OK;\n    }\n    --RedrawingDisabled;\n    return FAIL;\n}\n\n/*\n * go to the last know line number for the current buffer\n */\n    static void\nbuflist_getfpos(void)\n{\n    pos_T\t*fpos;\n\n    fpos = buflist_findfpos(curbuf);\n\n    curwin->w_cursor.lnum = fpos->lnum;\n    check_cursor_lnum();\n\n    if (p_sol)\n\tcurwin->w_cursor.col = 0;\n    else\n    {\n\tcurwin->w_cursor.col = fpos->col;\n\tcheck_cursor_col();\n\tcurwin->w_cursor.coladd = 0;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n#if defined(FEAT_QUICKFIX) || defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname_exp(char_u *fname)\n{\n    char_u\t*ffname;\n    buf_T\t*buf = NULL;\n\n    // First make the name into a full path name\n    ffname = FullName_save(fname,\n#ifdef UNIX\n\t    TRUE\t    // force expansion, get rid of symbolic links\n#else\n\t    FALSE\n#endif\n\t    );\n    if (ffname != NULL)\n    {\n\tbuf = buflist_findname(ffname);\n\tvim_free(ffname);\n    }\n    return buf;\n}\n#endif\n\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * \"ffname\" must have a full path.\n * Skips dummy buffers.\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname(char_u *ffname)\n{\n#ifdef UNIX\n    stat_T\tst;\n\n    if (mch_stat((char *)ffname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n    return buflist_findname_stat(ffname, &st);\n}\n\n/*\n * Same as buflist_findname(), but pass the stat structure to avoid getting it\n * twice for the same file.\n * Returns NULL if not found.\n */\n    static buf_T *\nbuflist_findname_stat(\n    char_u\t*ffname,\n    stat_T\t*stp)\n{\n#endif\n    buf_T\t*buf;\n\n    // Start at the last buffer, expect to find a match sooner.\n    FOR_ALL_BUFS_FROM_LAST(buf)\n\tif ((buf->b_flags & BF_DUMMY) == 0 && !otherfile_buf(buf, ffname\n#ifdef UNIX\n\t\t    , stp\n#endif\n\t\t    ))\n\t    return buf;\n    return NULL;\n}\n\n/*\n * Find file in buffer list by a regexp pattern.\n * Return fnum of the found buffer.\n * Return < 0 for error.\n */\n    int\nbuflist_findpat(\n    char_u\t*pattern,\n    char_u\t*pattern_end,\t// pointer to first char after pattern\n    int\t\tunlisted,\t// find unlisted buffers\n    int\t\tdiffmode UNUSED, // find diff-mode buffers only\n    int\t\tcurtab_only)\t// find buffers in current tab only\n{\n    buf_T\t*buf;\n    int\t\tmatch = -1;\n    int\t\tfind_listed;\n    char_u\t*pat;\n    char_u\t*patend;\n    int\t\tattempt;\n    char_u\t*p;\n    int\t\ttoggledollar;\n\n    // \"%\" is current file, \"%%\" or \"#\" is alternate file\n    if ((pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))\n\t    || (in_vim9script() && pattern_end == pattern + 2\n\t\t\t\t    && pattern[0] == '%' && pattern[1] == '%'))\n    {\n\tif (*pattern == '#' || pattern_end == pattern + 2)\n\t    match = curwin->w_alt_fnum;\n\telse\n\t    match = curbuf->b_fnum;\n#ifdef FEAT_DIFF\n\tif (diffmode && !diff_mode_buf(buflist_findnr(match)))\n\t    match = -1;\n#endif\n    }\n\n    /*\n     * Try four ways of matching a listed buffer:\n     * attempt == 0: without '^' or '$' (at any position)\n     * attempt == 1: with '^' at start (only at position 0)\n     * attempt == 2: with '$' at end (only match at end)\n     * attempt == 3: with '^' at start and '$' at end (only full match)\n     * Repeat this for finding an unlisted buffer if there was no matching\n     * listed buffer.\n     */\n    else\n    {\n\tpat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);\n\tif (pat == NULL)\n\t    return -1;\n\tpatend = pat + STRLEN(pat) - 1;\n\ttoggledollar = (patend > pat && *patend == '$');\n\n\t// First try finding a listed buffer.  If not found and \"unlisted\"\n\t// is TRUE, try finding an unlisted buffer.\n\tfind_listed = TRUE;\n\tfor (;;)\n\t{\n\t    for (attempt = 0; attempt <= 3; ++attempt)\n\t    {\n\t\tregmatch_T\tregmatch;\n\n\t\t// may add '^' and '$'\n\t\tif (toggledollar)\n\t\t    *patend = (attempt < 2) ? NUL : '$'; // add/remove '$'\n\t\tp = pat;\n\t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n\t\t    ++p;\n\t\tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t\tif (regmatch.regprog == NULL)\n\t\t{\n\t\t    vim_free(pat);\n\t\t    return -1;\n\t\t}\n\n\t\tFOR_ALL_BUFS_FROM_LAST(buf)\n\t\t    if (buf->b_p_bl == find_listed\n#ifdef FEAT_DIFF\n\t\t\t    && (!diffmode || diff_mode_buf(buf))\n#endif\n\t\t\t    && buflist_match(&regmatch, buf, FALSE) != NULL)\n\t\t    {\n\t\t\tif (curtab_only)\n\t\t\t{\n\t\t\t    // Ignore the match if the buffer is not open in\n\t\t\t    // the current tab.\n\t\t\t    win_T\t*wp;\n\n\t\t\t    FOR_ALL_WINDOWS(wp)\n\t\t\t\tif (wp->w_buffer == buf)\n\t\t\t\t    break;\n\t\t\t    if (wp == NULL)\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match >= 0)\t\t// already found a match\n\t\t\t{\n\t\t\t    match = -2;\n\t\t\t    break;\n\t\t\t}\n\t\t\tmatch = buf->b_fnum;\t// remember first match\n\t\t    }\n\n\t\tvim_regfree(regmatch.regprog);\n\t\tif (match >= 0)\t\t\t// found one match\n\t\t    break;\n\t    }\n\n\t    // Only search for unlisted buffers if there was no match with\n\t    // a listed buffer.\n\t    if (!unlisted || !find_listed || match != -1)\n\t\tbreak;\n\t    find_listed = FALSE;\n\t}\n\n\tvim_free(pat);\n    }\n\n    if (match == -2)\n\tsemsg(_(e_more_than_one_match_for_str), pattern);\n    else if (match < 0)\n\tsemsg(_(e_no_matching_buffer_for_str), pattern);\n    return match;\n}\n\n#ifdef FEAT_VIMINFO\ntypedef struct {\n    buf_T   *buf;\n    char_u  *match;\n} bufmatch_T;\n#endif\n\n/*\n * Find all buffer names that match.\n * For command line expansion of \":buf\" and \":sbuf\".\n * Return OK if matches found, FAIL otherwise.\n */\n    int\nExpandBufnames(\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file,\n    int\t\toptions)\n{\n    int\t\tcount = 0;\n    buf_T\t*buf;\n    int\t\tround;\n    char_u\t*p;\n    int\t\tattempt;\n    char_u\t*patc;\n#ifdef FEAT_VIMINFO\n    bufmatch_T\t*matches = NULL;\n#endif\n\n    *num_file = 0;\t\t    // return values in case of FAIL\n    *file = NULL;\n\n#ifdef FEAT_DIFF\n    if ((options & BUF_DIFF_FILTER) && !curwin->w_p_diff)\n\treturn FAIL;\n#endif\n\n    // Make a copy of \"pat\" and change \"^\" to \"\\(^\\|[\\/]\\)\".\n    if (*pat == '^')\n    {\n\tpatc = alloc(STRLEN(pat) + 11);\n\tif (patc == NULL)\n\t    return FAIL;\n\tSTRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");\n\tSTRCPY(patc + 11, pat + 1);\n    }\n    else\n\tpatc = pat;\n\n    // attempt == 0: try match with    '\\<', match at start of word\n    // attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= 1; ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\n\tif (attempt > 0 && patc == pat)\n\t    break;\t// there was no anchor, no need to try again\n\tregmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\tif (regmatch.regprog == NULL)\n\t{\n\t    if (patc != pat)\n\t\tvim_free(patc);\n\t    return FAIL;\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tp = buflist_match(&regmatch, buf, p_wic);\n\t\tif (p != NULL)\n\t\t{\n\t\t    if (round == 1)\n\t\t\t++count;\n\t\t    else\n\t\t    {\n\t\t\tif (options & WILD_HOME_REPLACE)\n\t\t\t    p = home_replace_save(buf, p);\n\t\t\telse\n\t\t\t    p = vim_strsave(p);\n#ifdef FEAT_VIMINFO\n\t\t\tif (matches != NULL)\n\t\t\t{\n\t\t\t    matches[count].buf = buf;\n\t\t\t    matches[count].match = p;\n\t\t\t    count++;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    (*file)[count++] = p;\n\t\t    }\n\t\t}\n\t    }\n\t    if (count == 0)\t// no match found, break here\n\t\tbreak;\n\t    if (round == 1)\n\t    {\n\t\t*file = ALLOC_MULT(char_u *, count);\n\t\tif (*file == NULL)\n\t\t{\n\t\t    vim_regfree(regmatch.regprog);\n\t\t    if (patc != pat)\n\t\t\tvim_free(patc);\n\t\t    return FAIL;\n\t\t}\n#ifdef FEAT_VIMINFO\n\t\tif (options & WILD_BUFLASTUSED)\n\t\t    matches = ALLOC_MULT(bufmatch_T, count);\n#endif\n\t    }\n\t}\n\tvim_regfree(regmatch.regprog);\n\tif (count)\t\t// match(es) found, break here\n\t    break;\n    }\n\n    if (patc != pat)\n\tvim_free(patc);\n\n#ifdef FEAT_VIMINFO\n    if (matches != NULL)\n    {\n\tint i;\n\tif (count > 1)\n\t    qsort(matches, count, sizeof(bufmatch_T), buf_compare);\n\t// if the current buffer is first in the list, place it at the end\n\tif (matches[0].buf == curbuf)\n\t{\n\t    for (i = 1; i < count; i++)\n\t\t(*file)[i-1] = matches[i].match;\n\t    (*file)[count-1] = matches[0].match;\n\t}\n\telse\n\t{\n\t    for (i = 0; i < count; i++)\n\t\t(*file)[i] = matches[i].match;\n\t}\n\tvim_free(matches);\n    }\n#endif\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}\n\n/*\n * Check for a match on the file name for buffer \"buf\" with regprog \"prog\".\n */\n    static char_u *\nbuflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match;\n\n    // First try the short file name, then the long file name.\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n\n    return match;\n}\n\n/*\n * Try matching the regexp in \"prog\" with file name \"name\".\n * Return \"name\" when there is a match, NULL when not.\n */\n    static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}\n\n/*\n * Find a file in the buffer list by buffer number.\n */\n    buf_T *\nbuflist_findnr(int nr)\n{\n    char_u\tkey[VIM_SIZEOF_INT * 2 + 1];\n    hashitem_T\t*hi;\n\n    if (nr == 0)\n\tnr = curwin->w_alt_fnum;\n    sprintf((char *)key, \"%x\", nr);\n    hi = hash_find(&buf_hashtab, key);\n\n    if (!HASHITEM_EMPTY(hi))\n\treturn (buf_T *)(hi->hi_key\n\t\t\t     - ((unsigned)(curbuf->b_key - (char_u *)curbuf)));\n    return NULL;\n}\n\n/*\n * Get name of file 'n' in the buffer list.\n * When the file has no name an empty string is returned.\n * home_replace() is used to shorten the file name (used for marks).\n * Returns a pointer to allocated memory, of NULL when failed.\n */\n    char_u *\nbuflist_nr2name(\n    int\t\tn,\n    int\t\tfullname,\n    int\t\thelptail)\t// for help buffers return tail only\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n\treturn NULL;\n    return home_replace_save(helptail ? buf : NULL,\n\t\t\t\t     fullname ? buf->b_ffname : buf->b_fname);\n}\n\n/*\n * Set the \"lnum\" and \"col\" for the buffer \"buf\" and the current window.\n * When \"copy_options\" is TRUE save the local window option values.\n * When \"lnum\" is 0 only do the options.\n */\n    void\nbuflist_setfpos(\n    buf_T\t*buf,\n    win_T\t*win,\t\t// may be NULL when using :badd\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    int\t\tcopy_options)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == win)\n\t    break;\n    if (wip == NULL)\n    {\n\t// allocate a new entry\n\twip = ALLOC_CLEAR_ONE(wininfo_T);\n\tif (wip == NULL)\n\t    return;\n\twip->wi_win = win;\n\tif (lnum == 0)\t\t// set lnum even when it's 0\n\t    lnum = 1;\n    }\n    else\n    {\n\t// remove the entry from the list\n\tif (wip->wi_prev)\n\t    wip->wi_prev->wi_next = wip->wi_next;\n\telse\n\t    buf->b_wininfo = wip->wi_next;\n\tif (wip->wi_next)\n\t    wip->wi_next->wi_prev = wip->wi_prev;\n\tif (copy_options && wip->wi_optset)\n\t{\n\t    clear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\t    deleteFoldRecurse(&wip->wi_folds);\n#endif\n\t}\n    }\n    if (lnum != 0)\n    {\n\twip->wi_fpos.lnum = lnum;\n\twip->wi_fpos.col = col;\n    }\n    if (copy_options && win != NULL)\n    {\n\t// Save the window-specific option values.\n\tcopy_winopt(&win->w_onebuf_opt, &wip->wi_opt);\n#ifdef FEAT_FOLDING\n\twip->wi_fold_manual = win->w_fold_manual;\n\tcloneFoldGrowArray(&win->w_folds, &wip->wi_folds);\n#endif\n\twip->wi_optset = TRUE;\n    }\n\n    // insert the entry in front of the list\n    wip->wi_next = buf->b_wininfo;\n    buf->b_wininfo = wip;\n    wip->wi_prev = NULL;\n    if (wip->wi_next)\n\twip->wi_next->wi_prev = wip;\n}\n\n#ifdef FEAT_DIFF\n/*\n * Return TRUE when \"wip\" has 'diff' set and the diff is only for another tab\n * page.  That's because a diff is local to a tab page.\n */\n    static int\nwininfo_other_tab_diff(wininfo_T *wip)\n{\n    win_T\t*wp;\n\n    if (wip->wi_opt.wo_diff)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    // return FALSE when it's a window in the current tab page, thus\n\t    // the buffer was in diff mode here\n\t    if (wip->wi_win == wp)\n\t\treturn FALSE;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Find info for the current window in buffer \"buf\".\n * If not found, return the info for the most recently used window.\n * When \"need_options\" is TRUE skip entries where wi_optset is FALSE.\n * When \"skip_diff_buffer\" is TRUE avoid windows with 'diff' set that is in\n * another tab page.\n * Returns NULL when there isn't any info.\n */\n    static wininfo_T *\nfind_wininfo(\n    buf_T\t*buf,\n    int\t\tneed_options,\n    int\t\tskip_diff_buffer UNUSED)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == curwin\n#ifdef FEAT_DIFF\n\t\t&& (!skip_diff_buffer || !wininfo_other_tab_diff(wip))\n#endif\n\n\t\t&& (!need_options || wip->wi_optset))\n\t    break;\n\n    // If no wininfo for curwin, use the first in the list (that doesn't have\n    // 'diff' set and is in another tab page).\n    // If \"need_options\" is TRUE skip entries that don't have options set,\n    // unless the window is editing \"buf\", so we can copy from the window\n    // itself.\n    if (wip == NULL)\n    {\n#ifdef FEAT_DIFF\n\tif (skip_diff_buffer)\n\t{\n\t    FOR_ALL_BUF_WININFO(buf, wip)\n\t\tif (!wininfo_other_tab_diff(wip)\n\t\t\t&& (!need_options || wip->wi_optset\n\t\t\t    || (wip->wi_win != NULL\n\t\t\t\t\t     && wip->wi_win->w_buffer == buf)))\n\t\t    break;\n\t}\n\telse\n#endif\n\t    wip = buf->b_wininfo;\n    }\n    return wip;\n}\n\n/*\n * Reset the local window options to the values last used in this window.\n * If the buffer wasn't used in this window before, use the values from\n * the most recently used window.  If the values were never set, use the\n * global values for the window.\n */\n    void\nget_winopts(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    clear_winopt(&curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n    clearFolding(curwin);\n#endif\n\n    wip = find_wininfo(buf, TRUE, TRUE);\n    if (wip != NULL && wip->wi_win != NULL\n\t    && wip->wi_win != curwin && wip->wi_win->w_buffer == buf)\n    {\n\t// The buffer is currently displayed in the window: use the actual\n\t// option values instead of the saved (possibly outdated) values.\n\twin_T *wp = wip->wi_win;\n\n\tcopy_winopt(&wp->w_onebuf_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wp->w_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wp->w_folds, &curwin->w_folds);\n#endif\n    }\n    else if (wip != NULL && wip->wi_optset)\n    {\n\t// the buffer was displayed in the current window earlier\n\tcopy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wip->wi_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wip->wi_folds, &curwin->w_folds);\n#endif\n    }\n    else\n\tcopy_winopt(&curwin->w_allbuf_opt, &curwin->w_onebuf_opt);\n\n#ifdef FEAT_FOLDING\n    // Set 'foldlevel' to 'foldlevelstart' if it's not negative.\n    if (p_fdls >= 0)\n\tcurwin->w_p_fdl = p_fdls;\n#endif\n    after_copy_winopt(curwin);\n}\n\n/*\n * Find the position (lnum and col) for the buffer 'buf' for the current\n * window.\n * Returns a pointer to no_position if no position is found.\n */\n    pos_T *\nbuflist_findfpos(buf_T *buf)\n{\n    wininfo_T\t*wip;\n    static pos_T no_position = {1, 0, 0};\n\n    wip = find_wininfo(buf, FALSE, FALSE);\n    if (wip != NULL)\n\treturn &(wip->wi_fpos);\n    else\n\treturn &no_position;\n}\n\n/*\n * Find the lnum for the buffer 'buf' for the current window.\n */\n    linenr_T\nbuflist_findlnum(buf_T *buf)\n{\n    return buflist_findfpos(buf)->lnum;\n}\n\n/*\n * List all known file names (for :files and :buffers command).\n */\n    void\nbuflist_list(exarg_T *eap)\n{\n    buf_T\t*buf = firstbuf;\n    int\t\tlen;\n    int\t\ti;\n    int\t\tro_char;\n    int\t\tchanged_char;\n#ifdef FEAT_TERMINAL\n    int\t\tjob_running;\n    int\t\tjob_none_open;\n#endif\n\n#ifdef FEAT_VIMINFO\n    garray_T\tbuflist;\n    buf_T\t**buflist_data = NULL, **p;\n\n    if (vim_strchr(eap->arg, 't'))\n    {\n\tga_init2(&buflist, sizeof(buf_T *), 50);\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    if (ga_grow(&buflist, 1) == OK)\n\t\t((buf_T **)buflist.ga_data)[buflist.ga_len++] = buf;\n\t}\n\n\tqsort(buflist.ga_data, (size_t)buflist.ga_len,\n\t\tsizeof(buf_T *), buf_compare);\n\n\tbuflist_data = (buf_T **)buflist.ga_data;\n\tbuf = *buflist_data;\n    }\n    p = buflist_data;\n\n    for (; buf != NULL && !got_int; buf = buflist_data != NULL\n\t    ? (++p < buflist_data + buflist.ga_len ? *p : NULL)\n\t    : buf->b_next)\n#else\n    for (buf = firstbuf; buf != NULL && !got_int; buf = buf->b_next)\n#endif\n    {\n#ifdef FEAT_TERMINAL\n\tjob_running = term_job_running(buf->b_term);\n\tjob_none_open = job_running && term_none_open(buf->b_term);\n#endif\n\t// skip unlisted buffers, unless ! was used\n\tif ((!buf->b_p_bl && !eap->forceit && !vim_strchr(eap->arg, 'u'))\n\t\t|| (vim_strchr(eap->arg, 'u') && buf->b_p_bl)\n\t\t|| (vim_strchr(eap->arg, '+')\n\t\t\t&& ((buf->b_flags & BF_READERR) || !bufIsChanged(buf)))\n\t\t|| (vim_strchr(eap->arg, 'a')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows == 0))\n\t\t|| (vim_strchr(eap->arg, 'h')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows != 0))\n#ifdef FEAT_TERMINAL\n\t\t|| (vim_strchr(eap->arg, 'R')\n\t\t\t&& (!job_running || (job_running && job_none_open)))\n\t\t|| (vim_strchr(eap->arg, '?')\n\t\t\t&& (!job_running || (job_running && !job_none_open)))\n\t\t|| (vim_strchr(eap->arg, 'F')\n\t\t\t&& (job_running || buf->b_term == NULL))\n#endif\n\t\t|| (vim_strchr(eap->arg, '-') && buf->b_p_ma)\n\t\t|| (vim_strchr(eap->arg, '=') && !buf->b_p_ro)\n\t\t|| (vim_strchr(eap->arg, 'x') && !(buf->b_flags & BF_READERR))\n\t\t|| (vim_strchr(eap->arg, '%') && buf != curbuf)\n\t\t|| (vim_strchr(eap->arg, '#')\n\t\t      && (buf == curbuf || curwin->w_alt_fnum != buf->b_fnum)))\n\t    continue;\n\tif (buf_spname(buf) != NULL)\n\t    vim_strncpy(NameBuff, buf_spname(buf), MAXPATHL - 1);\n\telse\n\t    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);\n\tif (message_filtered(NameBuff))\n\t    continue;\n\n\tchanged_char = (buf->b_flags & BF_READERR) ? 'x'\n\t\t\t\t\t     : (bufIsChanged(buf) ? '+' : ' ');\n#ifdef FEAT_TERMINAL\n\tif (term_job_running(buf->b_term))\n\t{\n\t    if (term_none_open(buf->b_term))\n\t\tro_char = '?';\n\t    else\n\t\tro_char = 'R';\n\t    changed_char = ' ';  // bufIsChanged() returns TRUE to avoid\n\t\t\t\t // closing, but it's not actually changed.\n\t}\n\telse if (buf->b_term != NULL)\n\t    ro_char = 'F';\n\telse\n#endif\n\t    ro_char = !buf->b_p_ma ? '-' : (buf->b_p_ro ? '=' : ' ');\n\n\tmsg_putchar('\\n');\n\tlen = vim_snprintf((char *)IObuff, IOSIZE - 20, \"%3d%c%c%c%c%c \\\"%s\\\"\",\n\t\tbuf->b_fnum,\n\t\tbuf->b_p_bl ? ' ' : 'u',\n\t\tbuf == curbuf ? '%' :\n\t\t\t(curwin->w_alt_fnum == buf->b_fnum ? '#' : ' '),\n\t\tbuf->b_ml.ml_mfp == NULL ? ' ' :\n\t\t\t(buf->b_nwindows == 0 ? 'h' : 'a'),\n\t\tro_char,\n\t\tchanged_char,\n\t\tNameBuff);\n\tif (len > IOSIZE - 20)\n\t    len = IOSIZE - 20;\n\n\t// put \"line 999\" in column 40 or after the file name\n\ti = 40 - vim_strsize(IObuff);\n\tdo\n\t    IObuff[len++] = ' ';\n\twhile (--i > 0 && len < IOSIZE - 18);\n#ifdef FEAT_VIMINFO\n\tif (vim_strchr(eap->arg, 't') && buf->b_last_used)\n\t    add_time(IObuff + len, (size_t)(IOSIZE - len), buf->b_last_used);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),\n\t\t    _(\"line %ld\"), buf == curbuf ? curwin->w_cursor.lnum\n\t\t\t\t\t       : (long)buflist_findlnum(buf));\n\tmsg_outtrans(IObuff);\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n    }\n\n#ifdef FEAT_VIMINFO\n    if (buflist_data)\n\tga_clear(&buflist);\n#endif\n}\n\n/*\n * Get file name and line number for file 'fnum'.\n * Used by DoOneCmd() for translating '%' and '#'.\n * Used by insert_reg() and cmdline_paste() for '#' register.\n * Return FAIL if not found, OK for success.\n */\n    int\nbuflist_name_nr(\n    int\t\tfnum,\n    char_u\t**fname,\n    linenr_T\t*lnum)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf == NULL || buf->b_fname == NULL)\n\treturn FAIL;\n\n    *fname = buf->b_fname;\n    *lnum = buflist_findlnum(buf);\n\n    return OK;\n}\n\n/*\n * Set the file name for \"buf\"' to \"ffname_arg\", short file name to\n * \"sfname_arg\".\n * The file name with the full path is also remembered, for when :cd is used.\n * Returns FAIL for failure (file name already in use by other buffer)\n *\tOK otherwise.\n */\n    int\nsetfname(\n    buf_T\t*buf,\n    char_u\t*ffname_arg,\n    char_u\t*sfname_arg,\n    int\t\tmessage)\t// give message when buffer already exists\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*obuf = NULL;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (ffname == NULL || *ffname == NUL)\n    {\n\t// Removing the name.\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n#ifdef UNIX\n\tst.st_dev = (dev_T)-1;\n#endif\n    }\n    else\n    {\n\tfname_expand(buf, &ffname, &sfname); // will allocate ffname\n\tif (ffname == NULL)\t\t    // out of memory\n\t    return FAIL;\n\n\t/*\n\t * If the file name is already used in another buffer:\n\t * - if the buffer is loaded, fail\n\t * - if the buffer is not loaded, delete it from the list\n\t */\n#ifdef UNIX\n\tif (mch_stat((char *)ffname, &st) < 0)\n\t    st.st_dev = (dev_T)-1;\n#endif\n\tif (!(buf->b_flags & BF_DUMMY))\n#ifdef UNIX\n\t    obuf = buflist_findname_stat(ffname, &st);\n#else\n\t    obuf = buflist_findname(ffname);\n#endif\n\tif (obuf != NULL && obuf != buf)\n\t{\n\t    win_T\t*win;\n\t    tabpage_T   *tab;\n\t    int\t\tin_use = FALSE;\n\n\t    // during startup a window may use a buffer that is not loaded yet\n\t    FOR_ALL_TAB_WINDOWS(tab, win)\n\t\tif (win->w_buffer == obuf)\n\t\t    in_use = TRUE;\n\n\t    // it's loaded or used in a window, fail\n\t    if (obuf->b_ml.ml_mfp != NULL || in_use)\n\t    {\n\t\tif (message)\n\t\t    emsg(_(e_buffer_with_this_name_already_exists));\n\t\tvim_free(ffname);\n\t\treturn FAIL;\n\t    }\n\t    // delete from the list\n\t    close_buffer(NULL, obuf, DOBUF_WIPE, FALSE, FALSE);\n\t}\n\tsfname = vim_strsave(sfname);\n\tif (ffname == NULL || sfname == NULL)\n\t{\n\t    vim_free(sfname);\n\t    vim_free(ffname);\n\t    return FAIL;\n\t}\n#ifdef USE_FNAME_CASE\n\tfname_case(sfname, 0);    // set correct case for short file name\n#endif\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = sfname;\n    }\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n\n    buf->b_shortname = FALSE;\n\n    buf_name_changed(buf);\n    return OK;\n}\n\n/*\n * Crude way of changing the name of a buffer.  Use with care!\n * The name should be relative to the current directory.\n */\n    void\nbuf_set_name(int fnum, char_u *name)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf != NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = vim_strsave(name);\n\tbuf->b_sfname = NULL;\n\t// Allocate ffname and expand into full path.  Also resolves .lnk\n\t// files on Win32.\n\tfname_expand(buf, &buf->b_ffname, &buf->b_sfname);\n\tbuf->b_fname = buf->b_sfname;\n    }\n}\n\n/*\n * Take care of what needs to be done when the name of buffer \"buf\" has\n * changed.\n */\n    void\nbuf_name_changed(buf_T *buf)\n{\n    /*\n     * If the file name changed, also change the name of the swapfile\n     */\n    if (buf->b_ml.ml_mfp != NULL)\n\tml_setname(buf);\n\n#ifdef FEAT_TERMINAL\n    if (buf->b_term != NULL)\n\tterm_clear_status_text(buf->b_term);\n#endif\n\n    if (curwin->w_buffer == buf)\n\tcheck_arg_idx(curwin);\t// check file name for arg list\n    maketitle();\t\t// set window title\n    status_redraw_all();\t// status lines need to be redrawn\n    fmarks_check_names(buf);\t// check named file marks\n    ml_timestamp(buf);\t\t// reset timestamp\n}\n\n/*\n * set alternate file name for current window\n *\n * Used by do_one_cmd(), do_write() and do_ecmd().\n * Return the buffer.\n */\n    buf_T *\nsetaltfname(\n    char_u\t*ffname,\n    char_u\t*sfname,\n    linenr_T\tlnum)\n{\n    buf_T\t*buf;\n\n    // Create a buffer.  'buflisted' is not set if it's a new buffer\n    buf = buflist_new(ffname, sfname, lnum, 0);\n    if (buf != NULL && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = buf->b_fnum;\n    return buf;\n}\n\n/*\n * Get alternate file name for current window.\n * Return NULL if there isn't any, and give error message if requested.\n */\n    char_u  *\ngetaltfname(\n    int\t\terrmsg)\t\t// give error message\n{\n    char_u\t*fname;\n    linenr_T\tdummy;\n\n    if (buflist_name_nr(0, &fname, &dummy) == FAIL)\n    {\n\tif (errmsg)\n\t    emsg(_(e_no_alternate_file));\n\treturn NULL;\n    }\n    return fname;\n}\n\n/*\n * Add a file name to the buflist and return its number.\n * Uses same flags as buflist_new(), except BLN_DUMMY.\n *\n * used by qf_init(), main() and doarglist()\n */\n    int\nbuflist_add(char_u *fname, int flags)\n{\n    buf_T\t*buf;\n\n    buf = buflist_new(fname, NULL, (linenr_T)0, flags);\n    if (buf != NULL)\n\treturn buf->b_fnum;\n    return 0;\n}\n\n#if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)\n/*\n * Adjust slashes in file names.  Called after 'shellslash' was set.\n */\n    void\nbuflist_slash_adjust(void)\n{\n    buf_T\t*bp;\n\n    FOR_ALL_BUFFERS(bp)\n    {\n\tif (bp->b_ffname != NULL)\n\t    slash_adjust(bp->b_ffname);\n\tif (bp->b_sfname != NULL)\n\t    slash_adjust(bp->b_sfname);\n    }\n}\n#endif\n\n/*\n * Set alternate cursor position for the current buffer and window \"win\".\n * Also save the local window option values.\n */\n    void\nbuflist_altfpos(win_T *win)\n{\n    buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);\n}\n\n/*\n * Return TRUE if 'ffname' is not the same file as current file.\n * Fname must have a full path (expanded by mch_FullName()).\n */\n    int\notherfile(char_u *ffname)\n{\n    return otherfile_buf(curbuf, ffname\n#ifdef UNIX\n\t    , NULL\n#endif\n\t    );\n}\n\n    static int\notherfile_buf(\n    buf_T\t\t*buf,\n    char_u\t\t*ffname\n#ifdef UNIX\n    , stat_T\t\t*stp\n#endif\n    )\n{\n    // no name is different\n    if (ffname == NULL || *ffname == NUL || buf->b_ffname == NULL)\n\treturn TRUE;\n    if (fnamecmp(ffname, buf->b_ffname) == 0)\n\treturn FALSE;\n#ifdef UNIX\n    {\n\tstat_T\t    st;\n\n\t// If no stat_T given, get it now\n\tif (stp == NULL)\n\t{\n\t    if (!buf->b_dev_valid || mch_stat((char *)ffname, &st) < 0)\n\t\tst.st_dev = (dev_T)-1;\n\t    stp = &st;\n\t}\n\t// Use dev/ino to check if the files are the same, even when the names\n\t// are different (possible with links).  Still need to compare the\n\t// name above, for when the file doesn't exist yet.\n\t// Problem: The dev/ino changes when a file is deleted (and created\n\t// again) and remains the same when renamed/moved.  We don't want to\n\t// mch_stat() each buffer each time, that would be too slow.  Get the\n\t// dev/ino again when they appear to match, but not when they appear\n\t// to be different: Could skip a buffer when it's actually the same\n\t// file.\n\tif (buf_same_ino(buf, stp))\n\t{\n\t    buf_setino(buf);\n\t    if (buf_same_ino(buf, stp))\n\t\treturn FALSE;\n\t}\n    }\n#endif\n    return TRUE;\n}\n\n#if defined(UNIX) || defined(PROTO)\n/*\n * Set inode and device number for a buffer.\n * Must always be called when b_fname is changed!.\n */\n    void\nbuf_setino(buf_T *buf)\n{\n    stat_T\tst;\n\n    if (buf->b_fname != NULL && mch_stat((char *)buf->b_fname, &st) >= 0)\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n    else\n\tbuf->b_dev_valid = FALSE;\n}\n\n/*\n * Return TRUE if dev/ino in buffer \"buf\" matches with \"stp\".\n */\n    static int\nbuf_same_ino(\n    buf_T\t*buf,\n    stat_T\t*stp)\n{\n    return (buf->b_dev_valid\n\t    && stp->st_dev == buf->b_dev\n\t    && stp->st_ino == buf->b_ino);\n}\n#endif\n\n/*\n * Print info about the current buffer.\n */\n    void\nfileinfo(\n    int fullname,\t    // when non-zero print full path\n    int shorthelp,\n    int\tdont_truncate)\n{\n    char_u\t*name;\n    int\t\tn;\n    char\t*p;\n    char\t*buffer;\n    size_t\tlen;\n\n    buffer = alloc(IOSIZE);\n    if (buffer == NULL)\n\treturn;\n\n    if (fullname > 1)\t    // 2 CTRL-G: include buffer number\n    {\n\tvim_snprintf(buffer, IOSIZE, \"buf %d: \", curbuf->b_fnum);\n\tp = buffer + STRLEN(buffer);\n    }\n    else\n\tp = buffer;\n\n    *p++ = '\"';\n    if (buf_spname(curbuf) != NULL)\n\tvim_strncpy((char_u *)p, buf_spname(curbuf), IOSIZE - (p - buffer) - 1);\n    else\n    {\n\tif (!fullname && curbuf->b_fname != NULL)\n\t    name = curbuf->b_fname;\n\telse\n\t    name = curbuf->b_ffname;\n\thome_replace(shorthelp ? curbuf : NULL, name, (char_u *)p,\n\t\t\t\t\t  (int)(IOSIZE - (p - buffer)), TRUE);\n    }\n\n    vim_snprintf_add(buffer, IOSIZE, \"\\\"%s%s%s%s%s%s\",\n\t    curbufIsChanged() ? (shortmess(SHM_MOD)\n\t\t\t\t\t  ?  \" [+]\" : _(\" [Modified]\")) : \" \",\n\t    (curbuf->b_flags & BF_NOTEDITED)\n#ifdef FEAT_QUICKFIX\n\t\t    && !bt_dontwrite(curbuf)\n#endif\n\t\t\t\t\t? _(\"[Not edited]\") : \"\",\n\t    (curbuf->b_flags & BF_NEW)\n#ifdef FEAT_QUICKFIX\n\t\t    && !bt_dontwrite(curbuf)\n#endif\n\t\t\t\t\t   ? new_file_message() : \"\",\n\t    (curbuf->b_flags & BF_READERR) ? _(\"[Read errors]\") : \"\",\n\t    curbuf->b_p_ro ? (shortmess(SHM_RO) ? _(\"[RO]\")\n\t\t\t\t\t\t      : _(\"[readonly]\")) : \"\",\n\t    (curbufIsChanged() || (curbuf->b_flags & BF_WRITE_MASK)\n\t\t\t\t\t\t\t  || curbuf->b_p_ro) ?\n\t\t\t\t\t\t\t\t    \" \" : \"\");\n    // With 32 bit longs and more than 21,474,836 lines multiplying by 100\n    // causes an overflow, thus for large numbers divide instead.\n    if (curwin->w_cursor.lnum > 1000000L)\n\tn = (int)(((long)curwin->w_cursor.lnum) /\n\t\t\t\t   ((long)curbuf->b_ml.ml_line_count / 100L));\n    else\n\tn = (int)(((long)curwin->w_cursor.lnum * 100L) /\n\t\t\t\t\t    (long)curbuf->b_ml.ml_line_count);\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tvim_snprintf_add(buffer, IOSIZE, \"%s\", _(no_lines_msg));\n#ifdef FEAT_CMDL_INFO\n    else if (p_ru)\n\t// Current line and column are already on the screen -- webb\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\tNGETTEXT(\"%ld line --%d%%--\", \"%ld lines --%d%%--\",\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count),\n\t\t(long)curbuf->b_ml.ml_line_count, n);\n#endif\n    else\n    {\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\t_(\"line %ld of %ld --%d%%-- col \"),\n\t\t(long)curwin->w_cursor.lnum,\n\t\t(long)curbuf->b_ml.ml_line_count,\n\t\tn);\n\tvalidate_virtcol();\n\tlen = STRLEN(buffer);\n\tcol_print((char_u *)buffer + len, IOSIZE - len,\n\t\t   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);\n    }\n\n    (void)append_arg_number(curwin, (char_u *)buffer, IOSIZE,\n\t\t\t\t\t\t\t !shortmess(SHM_FILE));\n\n    if (dont_truncate)\n    {\n\t// Temporarily set msg_scroll to avoid the message being truncated.\n\t// First call msg_start() to get the message in the right place.\n\tmsg_start();\n\tn = msg_scroll;\n\tmsg_scroll = TRUE;\n\tmsg(buffer);\n\tmsg_scroll = n;\n    }\n    else\n    {\n\tp = msg_trunc_attr(buffer, FALSE, 0);\n\tif (restart_edit != 0 || (msg_scrolled && !need_wait_return))\n\t    // Need to repeat the message after redrawing when:\n\t    // - When restart_edit is set (otherwise there will be a delay\n\t    //   before redrawing).\n\t    // - When the screen was scrolled but there is no wait-return\n\t    //   prompt.\n\t    set_keep_msg((char_u *)p, 0);\n    }\n\n    vim_free(buffer);\n}\n\n    void\ncol_print(\n    char_u  *buf,\n    size_t  buflen,\n    int\t    col,\n    int\t    vcol)\n{\n    if (col == vcol)\n\tvim_snprintf((char *)buf, buflen, \"%d\", col);\n    else\n\tvim_snprintf((char *)buf, buflen, \"%d-%d\", col, vcol);\n}\n\nstatic char_u *lasttitle = NULL;\nstatic char_u *lasticon = NULL;\n\n/*\n * Put the file name in the title bar and icon of the window.\n */\n    void\nmaketitle(void)\n{\n    char_u\t*p;\n    char_u\t*title_str = NULL;\n    char_u\t*icon_str = NULL;\n    int\t\tmaxlen = 0;\n    int\t\tlen;\n    int\t\tmustset;\n    char_u\tbuf[IOSIZE];\n    int\t\toff;\n\n    if (!redrawing())\n    {\n\t// Postpone updating the title when 'lazyredraw' is set.\n\tneed_maketitle = TRUE;\n\treturn;\n    }\n\n    need_maketitle = FALSE;\n    if (!p_title && !p_icon && lasttitle == NULL && lasticon == NULL)\n\treturn;  // nothing to do\n\n    if (p_title)\n    {\n\tif (p_titlelen > 0)\n\t{\n\t    maxlen = p_titlelen * Columns / 100;\n\t    if (maxlen < 10)\n\t\tmaxlen = 10;\n\t}\n\n\ttitle_str = buf;\n\tif (*p_titlestring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_TITLE)\n\t    {\n\t\tint\tuse_sandbox = FALSE;\n\t\tint\tcalled_emsg_before = called_emsg;\n\n# ifdef FEAT_EVAL\n\t\tuse_sandbox = was_set_insecurely((char_u *)\"titlestring\", 0);\n# endif\n\t\tbuild_stl_str_hl(curwin, title_str, sizeof(buf),\n\t\t\t\t\t      p_titlestring, use_sandbox,\n\t\t\t\t\t      0, maxlen, NULL, NULL);\n\t\tif (called_emsg > called_emsg_before)\n\t\t    set_string_option_direct((char_u *)\"titlestring\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\t    }\n\t    else\n#endif\n\t\ttitle_str = p_titlestring;\n\t}\n\telse\n\t{\n\t    // format: \"fname + (path) (1 of 2) - VIM\"\n\n#define SPACE_FOR_FNAME (IOSIZE - 100)\n#define SPACE_FOR_DIR   (IOSIZE - 20)\n#define SPACE_FOR_ARGNR (IOSIZE - 10)  // at least room for \" - VIM\"\n\t    if (curbuf->b_fname == NULL)\n\t\tvim_strncpy(buf, (char_u *)_(\"[No Name]\"), SPACE_FOR_FNAME);\n#ifdef FEAT_TERMINAL\n\t    else if (curbuf->b_term != NULL)\n\t    {\n\t\tvim_strncpy(buf, term_get_status_text(curbuf->b_term),\n\t\t\t\t\t\t\t      SPACE_FOR_FNAME);\n\t    }\n#endif\n\t    else\n\t    {\n\t\tp = transstr(gettail(curbuf->b_fname));\n\t\tvim_strncpy(buf, p, SPACE_FOR_FNAME);\n\t\tvim_free(p);\n\t    }\n\n#ifdef FEAT_TERMINAL\n\t    if (curbuf->b_term == NULL)\n#endif\n\t\tswitch (bufIsChanged(curbuf)\n\t\t\t+ (curbuf->b_p_ro * 2)\n\t\t\t+ (!curbuf->b_p_ma * 4))\n\t\t{\n\t\t    case 1: STRCAT(buf, \" +\"); break;\n\t\t    case 2: STRCAT(buf, \" =\"); break;\n\t\t    case 3: STRCAT(buf, \" =+\"); break;\n\t\t    case 4:\n\t\t    case 6: STRCAT(buf, \" -\"); break;\n\t\t    case 5:\n\t\t    case 7: STRCAT(buf, \" -+\"); break;\n\t\t}\n\n\t    if (curbuf->b_fname != NULL\n#ifdef FEAT_TERMINAL\n\t\t    && curbuf->b_term == NULL\n#endif\n\t\t    )\n\t    {\n\t\t// Get path of file, replace home dir with ~\n\t\toff = (int)STRLEN(buf);\n\t\tbuf[off++] = ' ';\n\t\tbuf[off++] = '(';\n\t\thome_replace(curbuf, curbuf->b_ffname,\n\t\t\t\t\tbuf + off, SPACE_FOR_DIR - off, TRUE);\n#ifdef BACKSLASH_IN_FILENAME\n\t\t// avoid \"c:/name\" to be reduced to \"c\"\n\t\tif (isalpha(buf[off]) && buf[off + 1] == ':')\n\t\t    off += 2;\n#endif\n\t\t// remove the file name\n\t\tp = gettail_sep(buf + off);\n\t\tif (p == buf + off)\n\t\t{\n\t\t    // must be a help buffer\n\t\t    vim_strncpy(buf + off, (char_u *)_(\"help\"),\n\t\t\t\t\t   (size_t)(SPACE_FOR_DIR - off - 1));\n\t\t}\n\t\telse\n\t\t    *p = NUL;\n\n\t\t// Translate unprintable chars and concatenate.  Keep some\n\t\t// room for the server name.  When there is no room (very long\n\t\t// file name) use (...).\n\t\tif (off < SPACE_FOR_DIR)\n\t\t{\n\t\t    p = transstr(buf + off);\n\t\t    vim_strncpy(buf + off, p, (size_t)(SPACE_FOR_DIR - off));\n\t\t    vim_free(p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    vim_strncpy(buf + off, (char_u *)\"...\",\n\t\t\t\t\t     (size_t)(SPACE_FOR_ARGNR - off));\n\t\t}\n\t\tSTRCAT(buf, \")\");\n\t    }\n\n\t    append_arg_number(curwin, buf, SPACE_FOR_ARGNR, FALSE);\n\n#if defined(FEAT_CLIENTSERVER)\n\t    if (serverName != NULL)\n\t    {\n\t\tSTRCAT(buf, \" - \");\n\t\tvim_strcat(buf, serverName, IOSIZE);\n\t    }\n\t    else\n#endif\n\t\tSTRCAT(buf, \" - VIM\");\n\n\t    if (maxlen > 0)\n\t    {\n\t\t// make it shorter by removing a bit in the middle\n\t\tif (vim_strsize(buf) > maxlen)\n\t\t    trunc_string(buf, buf, maxlen, IOSIZE);\n\t    }\n\t}\n    }\n    mustset = value_changed(title_str, &lasttitle);\n\n    if (p_icon)\n    {\n\ticon_str = buf;\n\tif (*p_iconstring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_ICON)\n\t    {\n\t\tint\tuse_sandbox = FALSE;\n\t\tint\tcalled_emsg_before = called_emsg;\n\n# ifdef FEAT_EVAL\n\t\tuse_sandbox = was_set_insecurely((char_u *)\"iconstring\", 0);\n# endif\n\t\tbuild_stl_str_hl(curwin, icon_str, sizeof(buf),\n\t\t\t\t\t\t    p_iconstring, use_sandbox,\n\t\t\t\t\t\t    0, 0, NULL, NULL);\n\t\tif (called_emsg > called_emsg_before)\n\t\t    set_string_option_direct((char_u *)\"iconstring\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\t    }\n\t    else\n#endif\n\t\ticon_str = p_iconstring;\n\t}\n\telse\n\t{\n\t    if (buf_spname(curbuf) != NULL)\n\t\tp = buf_spname(curbuf);\n\t    else\t\t    // use file name only in icon\n\t\tp = gettail(curbuf->b_ffname);\n\t    *icon_str = NUL;\n\t    // Truncate name at 100 bytes.\n\t    len = (int)STRLEN(p);\n\t    if (len > 100)\n\t    {\n\t\tlen -= 100;\n\t\tif (has_mbyte)\n\t\t    len += (*mb_tail_off)(p, p + len) + 1;\n\t\tp += len;\n\t    }\n\t    STRCPY(icon_str, p);\n\t    trans_characters(icon_str, IOSIZE);\n\t}\n    }\n\n    mustset |= value_changed(icon_str, &lasticon);\n\n    if (mustset)\n\tresettitle();\n}\n\n/*\n * Used for title and icon: Check if \"str\" differs from \"*last\".  Set \"*last\"\n * from \"str\" if it does.\n * Return TRUE if resettitle() is to be called.\n */\n    static int\nvalue_changed(char_u *str, char_u **last)\n{\n    if ((str == NULL) != (*last == NULL)\n\t    || (str != NULL && *last != NULL && STRCMP(str, *last) != 0))\n    {\n\tvim_free(*last);\n\tif (str == NULL)\n\t{\n\t    *last = NULL;\n\t    mch_restore_title(\n\t\t  last == &lasttitle ? SAVE_RESTORE_TITLE : SAVE_RESTORE_ICON);\n\t}\n\telse\n\t{\n\t    *last = vim_strsave(str);\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Put current window title back (used after calling a shell)\n */\n    void\nresettitle(void)\n{\n    mch_settitle(lasttitle, lasticon);\n}\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_titles(void)\n{\n    vim_free(lasttitle);\n    vim_free(lasticon);\n}\n# endif\n\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n\n/*\n * Used for building in the status line.\n */\ntypedef struct\n{\n    char_u\t*stl_start;\n    int\t\tstl_minwid;\n    int\t\tstl_maxwid;\n    enum {\n\tNormal,\n\tEmpty,\n\tGroup,\n\tMiddle,\n\tHighlight,\n\tTabPage,\n\tTrunc\n    }\t\tstl_type;\n} stl_item_T;\n\nstatic size_t\t\tstl_items_len = 20; // Initial value, grows as needed.\nstatic stl_item_T      *stl_items = NULL;\nstatic int\t       *stl_groupitem = NULL;\nstatic stl_hlrec_T     *stl_hltab = NULL;\nstatic stl_hlrec_T     *stl_tabtab = NULL;\n\n/*\n * Build a string from the status line items in \"fmt\".\n * Return length of string in screen cells.\n *\n * Normally works for window \"wp\", except when working for 'tabline' then it\n * is \"curwin\".\n *\n * Items are drawn interspersed with the text that surrounds it\n * Specials: %-<wid>(xxx%) => group, %= => middle marker, %< => truncation\n * Item: %-<minwid>.<maxwid><itemch> All but <itemch> are optional\n *\n * If maxwidth is not zero, the string will be filled at any middle marker\n * or truncated if too long, fillchar is used for all whitespace.\n */\n    int\nbuild_stl_str_hl(\n    win_T\t*wp,\n    char_u\t*out,\t\t// buffer to write into != NameBuff\n    size_t\toutlen,\t\t// length of out[]\n    char_u\t*fmt,\n    int\t\tuse_sandbox UNUSED, // \"fmt\" was set insecurely, use sandbox\n    int\t\tfillchar,\n    int\t\tmaxwidth,\n    stl_hlrec_T **hltab,\t// return: HL attributes (can be NULL)\n    stl_hlrec_T **tabtab)\t// return: tab page nrs (can be NULL)\n{\n    linenr_T\tlnum;\n    size_t\tlen;\n    char_u\t*p;\n    char_u\t*s;\n    char_u\t*t;\n    int\t\tbyteval;\n#ifdef FEAT_EVAL\n    win_T\t*save_curwin;\n    buf_T\t*save_curbuf;\n    int\t\tsave_VIsual_active;\n#endif\n    int\t\tempty_line;\n    colnr_T\tvirtcol;\n    long\tl;\n    long\tn;\n    int\t\tprevchar_isflag;\n    int\t\tprevchar_isitem;\n    int\t\titemisflag;\n    int\t\tfillable;\n    char_u\t*str;\n    long\tnum;\n    int\t\twidth;\n    int\t\titemcnt;\n    int\t\tcuritem;\n    int\t\tgroup_end_userhl;\n    int\t\tgroup_start_userhl;\n    int\t\tgroupdepth;\n#ifdef FEAT_EVAL\n    int\t\tevaldepth;\n#endif\n    int\t\tminwid;\n    int\t\tmaxwid;\n    int\t\tzeropad;\n    char_u\tbase;\n    char_u\topt;\n#define TMPLEN 70\n    char_u\tbuf_tmp[TMPLEN];\n    char_u\twin_tmp[TMPLEN];\n    char_u\t*usefmt = fmt;\n    stl_hlrec_T *sp;\n    int\t\tsave_must_redraw = must_redraw;\n    int\t\tsave_redr_type = curwin->w_redr_type;\n\n    if (stl_items == NULL)\n    {\n\tstl_items = ALLOC_MULT(stl_item_T, stl_items_len);\n\tstl_groupitem = ALLOC_MULT(int, stl_items_len);\n\tstl_hltab  = ALLOC_MULT(stl_hlrec_T, stl_items_len);\n\tstl_tabtab = ALLOC_MULT(stl_hlrec_T, stl_items_len);\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * When the format starts with \"%!\" then evaluate it as an expression and\n     * use the result as the actual format string.\n     */\n    if (fmt[0] == '%' && fmt[1] == '!')\n    {\n\ttypval_T\ttv;\n\n\ttv.v_type = VAR_NUMBER;\n\ttv.vval.v_number = wp->w_id;\n\tset_var((char_u *)\"g:statusline_winid\", &tv, FALSE);\n\n\tusefmt = eval_to_string_safe(fmt + 2, use_sandbox, FALSE);\n\tif (usefmt == NULL)\n\t    usefmt = fmt;\n\n\tdo_unlet((char_u *)\"g:statusline_winid\", TRUE);\n    }\n#endif\n\n    if (fillchar == 0)\n\tfillchar = ' ';\n\n    // The cursor in windows other than the current one isn't always\n    // up-to-date, esp. because of autocommands and timers.\n    lnum = wp->w_cursor.lnum;\n    if (lnum > wp->w_buffer->b_ml.ml_line_count)\n    {\n\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\twp->w_cursor.lnum = lnum;\n    }\n\n    // Get line & check if empty (cursorpos will show \"0-1\").  Note that\n    // p will become invalid when getting another buffer line.\n    p = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    empty_line = (*p == NUL);\n\n    // Get the byte value now, in case we need it below. This is more efficient\n    // than making a copy of the line.\n    len = STRLEN(p);\n    if (wp->w_cursor.col > (colnr_T)len)\n    {\n\t// Line may have changed since checking the cursor column, or the lnum\n\t// was adjusted above.\n\twp->w_cursor.col = (colnr_T)len;\n\twp->w_cursor.coladd = 0;\n\tbyteval = 0;\n    }\n    else\n\tbyteval = (*mb_ptr2char)(p + wp->w_cursor.col);\n\n    groupdepth = 0;\n#ifdef FEAT_EVAL\n    evaldepth = 0;\n#endif\n    p = out;\n    curitem = 0;\n    prevchar_isflag = TRUE;\n    prevchar_isitem = FALSE;\n    for (s = usefmt; *s; )\n    {\n\tif (curitem == (int)stl_items_len)\n\t{\n\t    size_t\tnew_len = stl_items_len * 3 / 2;\n\t    stl_item_T\t*new_items;\n\t    int\t\t*new_groupitem;\n\t    stl_hlrec_T\t*new_hlrec;\n\n\t    new_items = vim_realloc(stl_items, sizeof(stl_item_T) * new_len);\n\t    if (new_items == NULL)\n\t\tbreak;\n\t    stl_items = new_items;\n\t    new_groupitem = vim_realloc(stl_groupitem, sizeof(int) * new_len);\n\t    if (new_groupitem == NULL)\n\t\tbreak;\n\t    stl_groupitem = new_groupitem;\n\t    new_hlrec = vim_realloc(stl_hltab, sizeof(stl_hlrec_T) * new_len);\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_hltab = new_hlrec;\n\t    new_hlrec = vim_realloc(stl_tabtab, sizeof(stl_hlrec_T) * new_len);\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_tabtab = new_hlrec;\n\t    stl_items_len = new_len;\n\t}\n\n\tif (*s != NUL && *s != '%')\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\n\t/*\n\t * Handle up to the next '%' or the end.\n\t */\n\twhile (*s != NUL && *s != '%' && p + 1 < out + outlen)\n\t    *p++ = *s++;\n\tif (*s == NUL || p + 1 >= out + outlen)\n\t    break;\n\n\t/*\n\t * Handle one '%' item.\n\t */\n\ts++;\n\tif (*s == NUL)  // ignore trailing %\n\t    break;\n\tif (*s == '%')\n\t{\n\t    if (p + 1 >= out + outlen)\n\t\tbreak;\n\t    *p++ = *s++;\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\t    continue;\n\t}\n\tif (*s == STL_MIDDLEMARK)\n\t{\n\t    s++;\n\t    if (groupdepth > 0)\n\t\tcontinue;\n\t    stl_items[curitem].stl_type = Middle;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == STL_TRUNCMARK)\n\t{\n\t    s++;\n\t    stl_items[curitem].stl_type = Trunc;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == ')')\n\t{\n\t    s++;\n\t    if (groupdepth < 1)\n\t\tcontinue;\n\t    groupdepth--;\n\n\t    t = stl_items[stl_groupitem[groupdepth]].stl_start;\n\t    *p = NUL;\n\t    l = vim_strsize(t);\n\t    if (curitem > stl_groupitem[groupdepth] + 1\n\t\t    && stl_items[stl_groupitem[groupdepth]].stl_minwid == 0)\n\t    {\n\t\t// remove group if all items are empty and highlight group\n\t\t// doesn't change\n\t\tgroup_start_userhl = group_end_userhl = 0;\n\t\tfor (n = stl_groupitem[groupdepth] - 1; n >= 0; n--)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t    {\n\t\t\tgroup_start_userhl = group_end_userhl =\n\t\t\t\t\t\t       stl_items[n].stl_minwid;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tfor (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Normal)\n\t\t\tbreak;\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t\tgroup_end_userhl = stl_items[n].stl_minwid;\n\t\t}\n\t\tif (n == curitem && group_start_userhl == group_end_userhl)\n\t\t{\n\t\t    // empty group\n\t\t    p = t;\n\t\t    l = 0;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t    {\n\t\t\t// do not use the highlighting from the removed group\n\t\t\tif (stl_items[n].stl_type == Highlight)\n\t\t\t    stl_items[n].stl_type = Empty;\n\t\t\t// adjust the start position of TabPage to the next\n\t\t\t// item position\n\t\t\tif (stl_items[n].stl_type == TabPage)\n\t\t\t    stl_items[n].stl_start = p;\n\t\t    }\n\t\t}\n\t    }\n\t    if (l > stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t    {\n\t\t// truncate, remove n bytes of text at the start\n\t\tif (has_mbyte)\n\t\t{\n\t\t    // Find the first character that should be included.\n\t\t    n = 0;\n\t\t    while (l >= stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t\t    {\n\t\t\tl -= ptr2cells(t + n);\n\t\t\tn += (*mb_ptr2len)(t + n);\n\t\t    }\n\t\t}\n\t\telse\n\t\t    n = (long)(p - t) - stl_items[stl_groupitem[groupdepth]]\n\t\t\t\t\t\t\t       .stl_maxwid + 1;\n\n\t\t*t = '<';\n\t\tmch_memmove(t + 1, t + n, (size_t)(p - (t + n)));\n\t\tp = p - n + 1;\n\n\t\t// Fill up space left over by half a double-wide char.\n\t\twhile (++l < stl_items[stl_groupitem[groupdepth]].stl_minwid)\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\n\t\t// correct the start of the items for the truncation\n\t\tfor (l = stl_groupitem[groupdepth] + 1; l < curitem; l++)\n\t\t{\n\t\t    stl_items[l].stl_start -= n;\n\t\t    if (stl_items[l].stl_start < t)\n\t\t\tstl_items[l].stl_start = t;\n\t\t}\n\t    }\n\t    else if (abs(stl_items[stl_groupitem[groupdepth]].stl_minwid) > l)\n\t    {\n\t\t// fill\n\t\tn = stl_items[stl_groupitem[groupdepth]].stl_minwid;\n\t\tif (n < 0)\n\t\t{\n\t\t    // fill by appending characters\n\t\t    n = 0 - n;\n\t\t    while (l++ < n && p + 1 < out + outlen)\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // fill by inserting characters\n\t\t    l = (n - l) * MB_CHAR2LEN(fillchar);\n\t\t    mch_memmove(t + l, t, (size_t)(p - t));\n\t\t    if (p + l >= out + outlen)\n\t\t\tl = (long)((out + outlen) - p - 1);\n\t\t    p += l;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t\tstl_items[n].stl_start += l;\n\t\t    for ( ; l > 0; l--)\n\t\t\tMB_CHAR2BYTES(fillchar, t);\n\t\t}\n\t    }\n\t    continue;\n\t}\n\tminwid = 0;\n\tmaxwid = 9999;\n\tzeropad = FALSE;\n\tl = 1;\n\tif (*s == '0')\n\t{\n\t    s++;\n\t    zeropad = TRUE;\n\t}\n\tif (*s == '-')\n\t{\n\t    s++;\n\t    l = -1;\n\t}\n\tif (VIM_ISDIGIT(*s))\n\t{\n\t    minwid = (int)getdigits(&s);\n\t    if (minwid < 0)\t// overflow\n\t\tminwid = 0;\n\t}\n\tif (*s == STL_USER_HL)\n\t{\n\t    stl_items[curitem].stl_type = Highlight;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid > 9 ? 1 : minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == STL_TABPAGENR || *s == STL_TABCLOSENR)\n\t{\n\t    if (*s == STL_TABCLOSENR)\n\t    {\n\t\tif (minwid == 0)\n\t\t{\n\t\t    // %X ends the close label, go back to the previously\n\t\t    // define tab label nr.\n\t\t    for (n = curitem - 1; n >= 0; --n)\n\t\t\tif (stl_items[n].stl_type == TabPage\n\t\t\t\t\t       && stl_items[n].stl_minwid >= 0)\n\t\t\t{\n\t\t\t    minwid = stl_items[n].stl_minwid;\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t    // close nrs are stored as negative values\n\t\t    minwid = - minwid;\n\t    }\n\t    stl_items[curitem].stl_type = TabPage;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == '.')\n\t{\n\t    s++;\n\t    if (VIM_ISDIGIT(*s))\n\t    {\n\t\tmaxwid = (int)getdigits(&s);\n\t\tif (maxwid <= 0)\t// overflow\n\t\t    maxwid = 50;\n\t    }\n\t}\n\tminwid = (minwid > 50 ? 50 : minwid) * l;\n\tif (*s == '(')\n\t{\n\t    stl_groupitem[groupdepth++] = curitem;\n\t    stl_items[curitem].stl_type = Group;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    stl_items[curitem].stl_maxwid = maxwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n#ifdef FEAT_EVAL\n\t// Denotes end of expanded %{} block\n\tif (*s == '}' && evaldepth > 0)\n\t{\n\t    s++;\n\t    evaldepth--;\n\t    continue;\n\t}\n#endif\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    s++;\n\t    continue;\n\t}\n\topt = *s++;\n\n\t// OK - now for the real work\n\tbase = 'D';\n\titemisflag = FALSE;\n\tfillable = TRUE;\n\tnum = -1;\n\tstr = NULL;\n\tswitch (opt)\n\t{\n\tcase STL_FILEPATH:\n\tcase STL_FULLPATH:\n\tcase STL_FILENAME:\n\t    fillable = FALSE;\t// don't change ' ' to fillchar\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(NameBuff, buf_spname(wp->w_buffer), MAXPATHL - 1);\n\t    else\n\t    {\n\t\tt = (opt == STL_FULLPATH) ? wp->w_buffer->b_ffname\n\t\t\t\t\t  : wp->w_buffer->b_fname;\n\t\thome_replace(wp->w_buffer, t, NameBuff, MAXPATHL, TRUE);\n\t    }\n\t    trans_characters(NameBuff, MAXPATHL);\n\t    if (opt != STL_FILENAME)\n\t\tstr = NameBuff;\n\t    else\n\t\tstr = gettail(NameBuff);\n\t    break;\n\n\tcase STL_VIM_EXPR: // '{'\n\t{\n#ifdef FEAT_EVAL\n\t    char_u *block_start = s - 1;\n#endif\n\t    int reevaluate = (*s == '%');\n\n\t    if (reevaluate)\n\t\ts++;\n\t    itemisflag = TRUE;\n\t    t = p;\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%'))\n\t\t\t\t\t  && *s != NUL && p + 1 < out + outlen)\n\t\t*p++ = *s++;\n\t    if (*s != '}')\t// missing '}' or out of space\n\t\tbreak;\n\t    s++;\n\t    if (reevaluate)\n\t\tp[-1] = 0; // remove the % at the end of %{% expr %}\n\t    else\n\t\t*p = 0;\n\t    p = t;\n#ifdef FEAT_EVAL\n\t    vim_snprintf((char *)buf_tmp, sizeof(buf_tmp),\n\t\t\t\t\t\t\t \"%d\", curbuf->b_fnum);\n\t    set_internal_string_var((char_u *)\"g:actual_curbuf\", buf_tmp);\n\t    vim_snprintf((char *)win_tmp, sizeof(win_tmp), \"%d\", curwin->w_id);\n\t    set_internal_string_var((char_u *)\"g:actual_curwin\", win_tmp);\n\n\t    save_curbuf = curbuf;\n\t    save_curwin = curwin;\n\t    save_VIsual_active = VIsual_active;\n\t    curwin = wp;\n\t    curbuf = wp->w_buffer;\n\t    // Visual mode is only valid in the current window.\n\t    if (curwin != save_curwin)\n\t\tVIsual_active = FALSE;\n\n\t    str = eval_to_string_safe(p, use_sandbox, FALSE);\n\n\t    curwin = save_curwin;\n\t    curbuf = save_curbuf;\n\t    VIsual_active = save_VIsual_active;\n\t    do_unlet((char_u *)\"g:actual_curbuf\", TRUE);\n\t    do_unlet((char_u *)\"g:actual_curwin\", TRUE);\n\n\t    if (str != NULL && *str != 0)\n\t    {\n\t\tif (*skipdigits(str) == NUL)\n\t\t{\n\t\t    num = atoi((char *)str);\n\t\t    VIM_CLEAR(str);\n\t\t    itemisflag = FALSE;\n\t\t}\n\t    }\n\n\t    // If the output of the expression needs to be evaluated\n\t    // replace the %{} block with the result of evaluation\n\t    if (reevaluate && str != NULL && *str != 0\n\t\t    && strchr((const char *)str, '%') != NULL\n\t\t    && evaldepth < MAX_STL_EVAL_DEPTH)\n\t    {\n\t\tsize_t parsed_usefmt = (size_t)(block_start - usefmt);\n\t\tsize_t str_length = strlen((const char *)str);\n\t\tsize_t fmt_length = strlen((const char *)s);\n\t\tsize_t new_fmt_len = parsed_usefmt\n\t\t\t\t\t\t + str_length + fmt_length + 3;\n\t\tchar_u *new_fmt = (char_u *)alloc(new_fmt_len * sizeof(char_u));\n\t\tchar_u *new_fmt_p = new_fmt;\n\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, usefmt, parsed_usefmt)\n\t\t\t\t\t\t\t       + parsed_usefmt;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , str, str_length)\n\t\t\t\t\t\t\t\t  + str_length;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, \"%}\", 2) + 2;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , s, fmt_length)\n\t\t\t\t\t\t\t\t  + fmt_length;\n\t\t*new_fmt_p = 0;\n\t\tnew_fmt_p = NULL;\n\n\t\tif (usefmt != fmt)\n\t\t    vim_free(usefmt);\n\t\tVIM_CLEAR(str);\n\t\tusefmt = new_fmt;\n\t\ts = usefmt + parsed_usefmt;\n\t\tevaldepth++;\n\t\tcontinue;\n\t    }\n#endif\n\t    break;\n\t}\n\tcase STL_LINE:\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY)\n\t\t  ? 0L : (long)(wp->w_cursor.lnum);\n\t    break;\n\n\tcase STL_NUMLINES:\n\t    num = wp->w_buffer->b_ml.ml_line_count;\n\t    break;\n\n\tcase STL_COLUMN:\n\t    num = !(State & INSERT) && empty_line\n\t\t  ? 0 : (int)wp->w_cursor.col + 1;\n\t    break;\n\n\tcase STL_VIRTCOL:\n\tcase STL_VIRTCOL_ALT:\n\t    virtcol = wp->w_virtcol + 1;\n\t    // Don't display %V if it's the same as %c.\n\t    if (opt == STL_VIRTCOL_ALT\n\t\t    && (virtcol == (colnr_T)(!(State & INSERT) && empty_line\n\t\t\t    ? 0 : (int)wp->w_cursor.col + 1)))\n\t\tbreak;\n\t    num = (long)virtcol;\n\t    break;\n\n\tcase STL_PERCENTAGE:\n\t    num = (int)(((long)wp->w_cursor.lnum * 100L) /\n\t\t\t(long)wp->w_buffer->b_ml.ml_line_count);\n\t    break;\n\n\tcase STL_ALTPERCENT:\n\t    str = buf_tmp;\n\t    get_rel_pos(wp, str, TMPLEN);\n\t    break;\n\n\tcase STL_ARGLISTSTAT:\n\t    fillable = FALSE;\n\t    buf_tmp[0] = 0;\n\t    if (append_arg_number(wp, buf_tmp, (int)sizeof(buf_tmp), FALSE))\n\t\tstr = buf_tmp;\n\t    break;\n\n\tcase STL_KEYMAP:\n\t    fillable = FALSE;\n\t    if (get_keymap_str(wp, (char_u *)\"<%s>\", buf_tmp, TMPLEN))\n\t\tstr = buf_tmp;\n\t    break;\n\tcase STL_PAGENUM:\n#if defined(FEAT_PRINTER) || defined(FEAT_GUI_TABLINE)\n\t    num = printer_page_num;\n#else\n\t    num = 0;\n#endif\n\t    break;\n\n\tcase STL_BUFNO:\n\t    num = wp->w_buffer->b_fnum;\n\t    break;\n\n\tcase STL_OFFSET_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_OFFSET:\n#ifdef FEAT_BYTEOFF\n\t    l = ml_find_line_or_offset(wp->w_buffer, wp->w_cursor.lnum, NULL);\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) || l < 0 ?\n\t\t  0L : l + 1 + (!(State & INSERT) && empty_line ?\n\t\t\t\t0 : (int)wp->w_cursor.col);\n#endif\n\t    break;\n\n\tcase STL_BYTEVAL_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_BYTEVAL:\n\t    num = byteval;\n\t    if (num == NL)\n\t\tnum = 0;\n\t    else if (num == CAR && get_fileformat(wp->w_buffer) == EOL_MAC)\n\t\tnum = NL;\n\t    break;\n\n\tcase STL_ROFLAG:\n\tcase STL_ROFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_p_ro)\n\t\tstr = (char_u *)((opt == STL_ROFLAG_ALT) ? \",RO\" : _(\"[RO]\"));\n\t    break;\n\n\tcase STL_HELPFLAG:\n\tcase STL_HELPFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_help)\n\t\tstr = (char_u *)((opt == STL_HELPFLAG_ALT) ? \",HLP\"\n\t\t\t\t\t\t\t       : _(\"[Help]\"));\n\t    break;\n\n\tcase STL_FILETYPE:\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 3)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \"[%s]\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n\tcase STL_FILETYPE_ALT:\n\t    itemisflag = TRUE;\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 2)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \",%s\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tfor (t = buf_tmp; *t != 0; t++)\n\t\t    *t = TOUPPER_LOC(*t);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n#if defined(FEAT_QUICKFIX)\n\tcase STL_PREVIEWFLAG:\n\tcase STL_PREVIEWFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_p_pvw)\n\t\tstr = (char_u *)((opt == STL_PREVIEWFLAG_ALT) ? \",PRV\"\n\t\t\t\t\t\t\t    : _(\"[Preview]\"));\n\t    break;\n\n\tcase STL_QUICKFIX:\n\t    if (bt_quickfix(wp->w_buffer))\n\t\tstr = (char_u *)(wp->w_llist_ref\n\t\t\t    ? _(msg_loclist)\n\t\t\t    : _(msg_qflist));\n\t    break;\n#endif\n\n\tcase STL_MODIFIED:\n\tcase STL_MODIFIED_ALT:\n\t    itemisflag = TRUE;\n\t    switch ((opt == STL_MODIFIED_ALT)\n\t\t    + bufIsChanged(wp->w_buffer) * 2\n\t\t    + (!wp->w_buffer->b_p_ma) * 4)\n\t    {\n\t\tcase 2: str = (char_u *)\"[+]\"; break;\n\t\tcase 3: str = (char_u *)\",+\"; break;\n\t\tcase 4: str = (char_u *)\"[-]\"; break;\n\t\tcase 5: str = (char_u *)\",-\"; break;\n\t\tcase 6: str = (char_u *)\"[+-]\"; break;\n\t\tcase 7: str = (char_u *)\",+-\"; break;\n\t    }\n\t    break;\n\n\tcase STL_HIGHLIGHT:\n\t    t = s;\n\t    while (*s != '#' && *s != NUL)\n\t\t++s;\n\t    if (*s == '#')\n\t    {\n\t\tstl_items[curitem].stl_type = Highlight;\n\t\tstl_items[curitem].stl_start = p;\n\t\tstl_items[curitem].stl_minwid = -syn_namen2id(t, (int)(s - t));\n\t\tcuritem++;\n\t    }\n\t    if (*s != NUL)\n\t\t++s;\n\t    continue;\n\t}\n\n\tstl_items[curitem].stl_start = p;\n\tstl_items[curitem].stl_type = Normal;\n\tif (str != NULL && *str)\n\t{\n\t    t = str;\n\t    if (itemisflag)\n\t    {\n\t\tif ((t[0] && t[1])\n\t\t\t&& ((!prevchar_isitem && *t == ',')\n\t\t\t      || (prevchar_isflag && *t == ' ')))\n\t\t    t++;\n\t\tprevchar_isflag = TRUE;\n\t    }\n\t    l = vim_strsize(t);\n\t    if (l > 0)\n\t\tprevchar_isitem = TRUE;\n\t    if (l > maxwid)\n\t    {\n\t\twhile (l >= maxwid)\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tl -= ptr2cells(t);\n\t\t\tt += (*mb_ptr2len)(t);\n\t\t    }\n\t\t    else\n\t\t\tl -= byte2cells(*t++);\n\t\tif (p + 1 >= out + outlen)\n\t\t    break;\n\t\t*p++ = '<';\n\t    }\n\t    if (minwid > 0)\n\t    {\n\t\tfor (; l < minwid && p + 1 < out + outlen; l++)\n\t\t{\n\t\t    // Don't put a \"-\" in front of a digit.\n\t\t    if (l + 1 == minwid && fillchar == '-' && VIM_ISDIGIT(*t))\n\t\t\t*p++ = ' ';\n\t\t    else\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\tminwid = 0;\n\t    }\n\t    else\n\t\tminwid *= -1;\n\t    for (; *t && p + 1 < out + outlen; t++)\n\t    {\n\t\t// Change a space by fillchar, unless fillchar is '-' and a\n\t\t// digit follows.\n\t\tif (fillable && *t == ' '\n\t\t\t\t&& (!VIM_ISDIGIT(*(t + 1)) || fillchar != '-'))\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\t\telse\n\t\t    *p++ = *t;\n\t    }\n\t    for (; l < minwid && p + 1 < out + outlen; l++)\n\t\tMB_CHAR2BYTES(fillchar, p);\n\t}\n\telse if (num >= 0)\n\t{\n\t    int nbase = (base == 'D' ? 10 : (base == 'O' ? 8 : 16));\n\t    char_u nstr[20];\n\n\t    if (p + 20 >= out + outlen)\n\t\tbreak;\t\t// not sufficient space\n\t    prevchar_isitem = TRUE;\n\t    t = nstr;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t    {\n\t\t*t++ = '-';\n\t\tminwid--;\n\t    }\n\t    *t++ = '%';\n\t    if (zeropad)\n\t\t*t++ = '0';\n\t    *t++ = '*';\n\t    *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');\n\t    *t = 0;\n\n\t    for (n = num, l = 1; n >= nbase; n /= nbase)\n\t\tl++;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t\tl++;\n\t    if (l > maxwid)\n\t    {\n\t\tl += 2;\n\t\tn = l - maxwid;\n\t\twhile (l-- > maxwid)\n\t\t    num /= nbase;\n\t\t*t++ = '>';\n\t\t*t++ = '%';\n\t\t*t = t[-3];\n\t\t*++t = 0;\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t   0, num, n);\n\t    }\n\t    else\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t minwid, num);\n\t    p += STRLEN(p);\n\t}\n\telse\n\t    stl_items[curitem].stl_type = Empty;\n\n\tif (opt == STL_VIM_EXPR)\n\t    vim_free(str);\n\n\tif (num >= 0 || (!itemisflag && str && *str))\n\t    prevchar_isflag = FALSE;\t    // Item not NULL, but not a flag\n\tcuritem++;\n    }\n    *p = NUL;\n    itemcnt = curitem;\n\n#ifdef FEAT_EVAL\n    if (usefmt != fmt)\n\tvim_free(usefmt);\n#endif\n\n    width = vim_strsize(out);\n    if (maxwidth > 0 && width > maxwidth)\n    {\n\t// Result is too long, must truncate somewhere.\n\tl = 0;\n\tif (itemcnt == 0)\n\t    s = out;\n\telse\n\t{\n\t    for ( ; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_type == Trunc)\n\t\t{\n\t\t    // Truncate at %< item.\n\t\t    s = stl_items[l].stl_start;\n\t\t    break;\n\t\t}\n\t    if (l == itemcnt)\n\t    {\n\t\t// No %< item, truncate first item.\n\t\ts = stl_items[0].stl_start;\n\t\tl = 0;\n\t    }\n\t}\n\n\tif (width - vim_strsize(s) >= maxwidth)\n\t{\n\t    // Truncation mark is beyond max length\n\t    if (has_mbyte)\n\t    {\n\t\ts = out;\n\t\twidth = 0;\n\t\tfor (;;)\n\t\t{\n\t\t    width += ptr2cells(s);\n\t\t    if (width >= maxwidth)\n\t\t\tbreak;\n\t\t    s += (*mb_ptr2len)(s);\n\t\t}\n\t\t// Fill up for half a double-wide character.\n\t\twhile (++width < maxwidth)\n\t\t    MB_CHAR2BYTES(fillchar, s);\n\t    }\n\t    else\n\t\ts = out + maxwidth - 1;\n\t    for (l = 0; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_start > s)\n\t\t    break;\n\t    itemcnt = l;\n\t    *s++ = '>';\n\t    *s = 0;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tn = 0;\n\t\twhile (width >= maxwidth)\n\t\t{\n\t\t    width -= ptr2cells(s + n);\n\t\t    n += (*mb_ptr2len)(s + n);\n\t\t}\n\t    }\n\t    else\n\t\tn = width - maxwidth + 1;\n\t    p = s + n;\n\t    STRMOVE(s + 1, p);\n\t    *s = '<';\n\n\t    // Fill up for half a double-wide character.\n\t    while (++width < maxwidth)\n\t    {\n\t\ts = s + STRLEN(s);\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t\t*s = NUL;\n\t    }\n\n\t    --n;\t// count the '<'\n\t    for (; l < itemcnt; l++)\n\t    {\n\t\tif (stl_items[l].stl_start - n >= s)\n\t\t    stl_items[l].stl_start -= n;\n\t\telse\n\t\t    stl_items[l].stl_start = s;\n\t    }\n\t}\n\twidth = maxwidth;\n    }\n    else if (width < maxwidth && STRLEN(out) + maxwidth - width + 1 < outlen)\n    {\n\t// Apply STL_MIDDLE if any\n\tfor (l = 0; l < itemcnt; l++)\n\t    if (stl_items[l].stl_type == Middle)\n\t\tbreak;\n\tif (l < itemcnt)\n\t{\n\t    int middlelength = (maxwidth - width) * MB_CHAR2LEN(fillchar);\n\t    p = stl_items[l].stl_start + middlelength;\n\t    STRMOVE(p, stl_items[l].stl_start);\n\t    for (s = stl_items[l].stl_start; s < p;)\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t    for (l++; l < itemcnt; l++)\n\t\tstl_items[l].stl_start += middlelength;\n\t    width = maxwidth;\n\t}\n    }\n\n    // Store the info about highlighting.\n    if (hltab != NULL)\n    {\n\t*hltab = stl_hltab;\n\tsp = stl_hltab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == Highlight)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    // Store the info about tab pages labels.\n    if (tabtab != NULL)\n    {\n\t*tabtab = stl_tabtab;\n\tsp = stl_tabtab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == TabPage)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    // When inside update_screen we do not want redrawing a statusline, ruler,\n    // title, etc. to trigger another redraw, it may cause an endless loop.\n    if (updating_screen)\n    {\n\tmust_redraw = save_must_redraw;\n\tcurwin->w_redr_type = save_redr_type;\n    }\n\n    return width;\n}\n#endif // FEAT_STL_OPT\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_CMDL_INFO) \\\n\t    || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Get relative cursor position in window into \"buf[buflen]\", in the form 99%,\n * using \"Top\", \"Bot\" or \"All\" when appropriate.\n */\n    void\nget_rel_pos(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    long\tabove; // number of lines above window\n    long\tbelow; // number of lines below window\n\n    if (buflen < 3) // need at least 3 chars for writing\n\treturn;\n    above = wp->w_topline - 1;\n#ifdef FEAT_DIFF\n    above += diff_check_fill(wp, wp->w_topline) - wp->w_topfill;\n    if (wp->w_topline == 1 && wp->w_topfill >= 1)\n\tabove = 0;  // All buffer lines are displayed and there is an\n\t\t    // indication of filler lines, that can be considered\n\t\t    // seeing all lines.\n#endif\n    below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;\n    if (below <= 0)\n\tvim_strncpy(buf, (char_u *)(above == 0 ? _(\"All\") : _(\"Bot\")),\n\t\t\t\t\t\t\t(size_t)(buflen - 1));\n    else if (above <= 0)\n\tvim_strncpy(buf, (char_u *)_(\"Top\"), (size_t)(buflen - 1));\n    else\n\tvim_snprintf((char *)buf, (size_t)buflen, \"%2d%%\", above > 1000000L\n\t\t\t\t    ? (int)(above / ((above + below) / 100L))\n\t\t\t\t    : (int)(above * 100L / (above + below)));\n}\n#endif\n\n/*\n * Append (file 2 of 8) to \"buf[buflen]\", if editing more than one file.\n * Return TRUE if it was appended.\n */\n    static int\nappend_arg_number(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen,\n    int\t\tadd_file)\t// Add \"file\" before the arg number\n{\n    char_u\t*p;\n\n    if (ARGCOUNT <= 1)\t\t// nothing to do\n\treturn FALSE;\n\n    p = buf + STRLEN(buf);\t// go to the end of the buffer\n    if (p - buf + 35 >= buflen)\t// getting too long\n\treturn FALSE;\n    *p++ = ' ';\n    *p++ = '(';\n    if (add_file)\n    {\n\tSTRCPY(p, \"file \");\n\tp += 5;\n    }\n    vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),\n\t\twp->w_arg_idx_invalid ? \"(%d) of %d)\"\n\t\t\t\t  : \"%d of %d)\", wp->w_arg_idx + 1, ARGCOUNT);\n    return TRUE;\n}\n\n/*\n * If fname is not a full path, make it a full path.\n * Returns pointer to allocated memory (NULL for failure).\n */\n    char_u  *\nfix_fname(char_u  *fname)\n{\n    /*\n     * Force expanding the path always for Unix, because symbolic links may\n     * mess up the full path name, even though it starts with a '/'.\n     * Also expand when there is \"..\" in the file name, try to remove it,\n     * because \"c:/src/../README\" is equal to \"c:/README\".\n     * Similarly \"c:/src//file\" is equal to \"c:/src/file\".\n     * For MS-Windows also expand names like \"longna~1\" to \"longname\".\n     */\n#ifdef UNIX\n    return FullName_save(fname, TRUE);\n#else\n    if (!vim_isAbsName(fname)\n\t    || strstr((char *)fname, \"..\") != NULL\n\t    || strstr((char *)fname, \"//\") != NULL\n# ifdef BACKSLASH_IN_FILENAME\n\t    || strstr((char *)fname, \"\\\\\\\\\") != NULL\n# endif\n# if defined(MSWIN)\n\t    || vim_strchr(fname, '~') != NULL\n# endif\n\t    )\n\treturn FullName_save(fname, FALSE);\n\n    fname = vim_strsave(fname);\n\n# ifdef USE_FNAME_CASE\n    if (fname != NULL)\n\tfname_case(fname, 0);\t// set correct case for file name\n# endif\n\n    return fname;\n#endif\n}\n\n/*\n * Make \"*ffname\" a full file name, set \"*sfname\" to \"*ffname\" if not NULL.\n * \"*ffname\" becomes a pointer to allocated memory (or NULL).\n * When resolving a link both \"*sfname\" and \"*ffname\" will point to the same\n * allocated memory.\n * The \"*ffname\" and \"*sfname\" pointer values on call will not be freed.\n * Note that the resulting \"*ffname\" pointer should be considered not allocated.\n */\n    void\nfname_expand(\n    buf_T\t*buf UNUSED,\n    char_u\t**ffname,\n    char_u\t**sfname)\n{\n    if (*ffname == NULL)\t    // no file name given, nothing to do\n\treturn;\n    if (*sfname == NULL)\t    // no short file name given, use ffname\n\t*sfname = *ffname;\n    *ffname = fix_fname(*ffname);   // expand to full path\n\n#ifdef FEAT_SHORTCUT\n    if (!buf->b_p_bin)\n    {\n\tchar_u  *rfname;\n\n\t// If the file name is a shortcut file, use the file it links to.\n\trfname = mch_resolve_path(*ffname, FALSE);\n\tif (rfname != NULL)\n\t{\n\t    vim_free(*ffname);\n\t    *ffname = rfname;\n\t    *sfname = rfname;\n\t}\n    }\n#endif\n}\n\n/*\n * Open a window for a number of buffers.\n */\n    void\nex_buffer_all(exarg_T *eap)\n{\n    buf_T\t*buf;\n    win_T\t*wp, *wpnext;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    int\t\topen_wins = 0;\n    int\t\tr;\n    int\t\tcount;\t\t// Maximum number of windows to open.\n    int\t\tall;\t\t// When TRUE also load inactive buffers.\n    int\t\thad_tab = cmdmod.cmod_tab;\n    tabpage_T\t*tpnext;\n\n    if (eap->addr_count == 0)\t// make as many windows as possible\n\tcount = 9999;\n    else\n\tcount = eap->line2;\t// make as many windows as specified\n    if (eap->cmdidx == CMD_unhide || eap->cmdidx == CMD_sunhide)\n\tall = FALSE;\n    else\n\tall = TRUE;\n\n    setpcmark();\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * Close superfluous windows (two windows for the same buffer).\n     * Also close windows that are not full-width.\n     */\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    if ((wp->w_buffer->b_nwindows > 1\n\t\t    || ((cmdmod.cmod_split & WSP_VERT)\n\t\t\t? wp->w_height + wp->w_status_height < Rows - p_ch\n\t\t\t\t\t\t\t    - tabline_height()\n\t\t\t: wp->w_width != Columns)\n\t\t    || (had_tab > 0 && wp != firstwin)) && !ONE_WINDOW\n\t\t\t     && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t    {\n\t\twin_close(wp, FALSE);\n\t\twpnext = firstwin;\t// just in case an autocommand does\n\t\t\t\t\t// something strange with windows\n\t\ttpnext = first_tabpage;\t// start all over...\n\t\topen_wins = 0;\n\t    }\n\t    else\n\t\t++open_wins;\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    /*\n     * Go through the buffer list.  When a buffer doesn't have a window yet,\n     * open one.  Otherwise move the window to the right position.\n     * Watch out for autocommands that delete buffers or windows!\n     */\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    win_enter(lastwin, FALSE);\n    ++autocmd_no_leave;\n    for (buf = firstbuf; buf != NULL && open_wins < count; buf = buf->b_next)\n    {\n\t// Check if this buffer needs a window\n\tif ((!all && buf->b_ml.ml_mfp == NULL) || !buf->b_p_bl)\n\t    continue;\n\n\tif (had_tab != 0)\n\t{\n\t    // With the \":tab\" modifier don't move the window.\n\t    if (buf->b_nwindows > 0)\n\t\twp = lastwin;\t    // buffer has a window, skip it\n\t    else\n\t\twp = NULL;\n\t}\n\telse\n\t{\n\t    // Check if this buffer already has a window\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    // If the buffer already has a window, move it\n\t    if (wp != NULL)\n\t\twin_move_after(wp, curwin);\n\t}\n\n\tif (wp == NULL && split_ret == OK)\n\t{\n\t    bufref_T\tbufref;\n\n\t    set_bufref(&bufref, buf);\n\n\t    // Split the window and put the buffer in it\n\t    p_ea_save = p_ea;\n\t    p_ea = TRUE;\t\t// use space from all windows\n\t    split_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t    ++open_wins;\n\t    p_ea = p_ea_save;\n\t    if (split_ret == FAIL)\n\t\tcontinue;\n\n\t    // Open the buffer in this window.\n\t    swap_exists_action = SEA_DIALOG;\n\t    set_curbuf(buf, DOBUF_GOTO);\n\t    if (!bufref_valid(&bufref))\n\t    {\n\t\t// autocommands deleted the buffer!!!\n\t\tswap_exists_action = SEA_NONE;\n\t\tbreak;\n\t    }\n\t    if (swap_exists_action == SEA_QUIT)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tcleanup_T   cs;\n\n\t\t// Reset the error/interrupt/exception state here so that\n\t\t// aborting() returns FALSE when closing a window.\n\t\tenter_cleanup(&cs);\n#endif\n\n\t\t// User selected Quit at ATTENTION prompt; close this window.\n\t\twin_close(curwin, TRUE);\n\t\t--open_wins;\n\t\tswap_exists_action = SEA_NONE;\n\t\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t\t// Restore the error/interrupt/exception state if not\n\t\t// discarded by a new aborting error, interrupt, or uncaught\n\t\t// exception.\n\t\tleave_cleanup(&cs);\n#endif\n\t    }\n\t    else\n\t\thandle_swap_exists(NULL);\n\t}\n\n\tui_breakcheck();\n\tif (got_int)\n\t{\n\t    (void)vgetc();\t// only break the file loading, not the rest\n\t    break;\n\t}\n#ifdef FEAT_EVAL\n\t// Autocommands deleted the buffer or aborted script processing!!!\n\tif (aborting())\n\t    break;\n#endif\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n    --autocmd_no_enter;\n    win_enter(firstwin, FALSE);\t\t// back to first window\n    --autocmd_no_leave;\n\n    /*\n     * Close superfluous windows.\n     */\n    for (wp = lastwin; open_wins > count; )\n    {\n\tr = (buf_hide(wp->w_buffer) || !bufIsChanged(wp->w_buffer)\n\t\t\t\t     || autowrite(wp->w_buffer, FALSE) == OK);\n\tif (!win_valid(wp))\n\t{\n\t    // BufWrite Autocommands made the window invalid, start over\n\t    wp = lastwin;\n\t}\n\telse if (r)\n\t{\n\t    win_close(wp, !buf_hide(wp->w_buffer));\n\t    --open_wins;\n\t    wp = lastwin;\n\t}\n\telse\n\t{\n\t    wp = wp->w_prev;\n\t    if (wp == NULL)\n\t\tbreak;\n\t}\n    }\n}\n\n\nstatic int  chk_modeline(linenr_T, int);\n\n/*\n * do_modelines() - process mode lines for the current file\n *\n * \"flags\" can be:\n * OPT_WINONLY\t    only set options local to window\n * OPT_NOWIN\t    don't set options local to window\n *\n * Returns immediately if the \"ml\" option isn't set.\n */\n    void\ndo_modelines(int flags)\n{\n    linenr_T\tlnum;\n    int\t\tnmlines;\n    static int\tentered = 0;\n\n    if (!curbuf->b_p_ml || (nmlines = (int)p_mls) == 0)\n\treturn;\n\n    // Disallow recursive entry here.  Can happen when executing a modeline\n    // triggers an autocommand, which reloads modelines with a \":do\".\n    if (entered)\n\treturn;\n\n    ++entered;\n    for (lnum = 1; curbuf->b_p_ml && lnum <= curbuf->b_ml.ml_line_count && lnum <= nmlines;\n\t\t\t\t\t\t\t\t       ++lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n\n    for (lnum = curbuf->b_ml.ml_line_count; curbuf->b_p_ml && lnum > 0 && lnum > nmlines\n\t\t       && lnum > curbuf->b_ml.ml_line_count - nmlines; --lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n    --entered;\n}\n\n#include \"version.h\"\t\t// for version number\n\n/*\n * chk_modeline() - check a single line for a mode string\n * Return FAIL if an error encountered.\n */\n    static int\nchk_modeline(\n    linenr_T\tlnum,\n    int\t\tflags)\t\t// Same as for do_modelines().\n{\n    char_u\t*s;\n    char_u\t*e;\n    char_u\t*linecopy;\t\t// local copy of any modeline found\n    int\t\tprev;\n    int\t\tvers;\n    int\t\tend;\n    int\t\tretval = OK;\n    sctx_T\tsave_current_sctx;\n\n    ESTACK_CHECK_DECLARATION\n\n    prev = -1;\n    for (s = ml_get(lnum); *s != NUL; ++s)\n    {\n\tif (prev == -1 || vim_isspace(prev))\n\t{\n\t    if ((prev != -1 && STRNCMP(s, \"ex:\", (size_t)3) == 0)\n\t\t    || STRNCMP(s, \"vi:\", (size_t)3) == 0)\n\t\tbreak;\n\t    // Accept both \"vim\" and \"Vim\".\n\t    if ((s[0] == 'v' || s[0] == 'V') && s[1] == 'i' && s[2] == 'm')\n\t    {\n\t\tif (s[3] == '<' || s[3] == '=' || s[3] == '>')\n\t\t    e = s + 4;\n\t\telse\n\t\t    e = s + 3;\n\t\tvers = getdigits(&e);\n\t\tif (*e == ':'\n\t\t\t&& (s[0] != 'V'\n\t\t\t\t  || STRNCMP(skipwhite(e + 1), \"set\", 3) == 0)\n\t\t\t&& (s[3] == ':'\n\t\t\t    || (VIM_VERSION_100 >= vers && isdigit(s[3]))\n\t\t\t    || (VIM_VERSION_100 < vers && s[3] == '<')\n\t\t\t    || (VIM_VERSION_100 > vers && s[3] == '>')\n\t\t\t    || (VIM_VERSION_100 == vers && s[3] == '=')))\n\t\t    break;\n\t    }\n\t}\n\tprev = *s;\n    }\n\n    if (*s)\n    {\n\tdo\t\t\t\t// skip over \"ex:\", \"vi:\" or \"vim:\"\n\t    ++s;\n\twhile (s[-1] != ':');\n\n\ts = linecopy = vim_strsave(s);\t// copy the line, it will change\n\tif (linecopy == NULL)\n\t    return FAIL;\n\n\t// prepare for emsg()\n\testack_push(ETYPE_MODELINE, (char_u *)\"modelines\", lnum);\n\tESTACK_CHECK_SETUP\n\n\tend = FALSE;\n\twhile (end == FALSE)\n\t{\n\t    s = skipwhite(s);\n\t    if (*s == NUL)\n\t\tbreak;\n\n\t    /*\n\t     * Find end of set command: ':' or end of line.\n\t     * Skip over \"\\:\", replacing it with \":\".\n\t     */\n\t    for (e = s; *e != ':' && *e != NUL; ++e)\n\t\tif (e[0] == '\\\\' && e[1] == ':')\n\t\t    STRMOVE(e, e + 1);\n\t    if (*e == NUL)\n\t\tend = TRUE;\n\n\t    /*\n\t     * If there is a \"set\" command, require a terminating ':' and\n\t     * ignore the stuff after the ':'.\n\t     * \"vi:set opt opt opt: foo\" -- foo not interpreted\n\t     * \"vi:opt opt opt: foo\" -- foo interpreted\n\t     * Accept \"se\" for compatibility with Elvis.\n\t     */\n\t    if (STRNCMP(s, \"set \", (size_t)4) == 0\n\t\t    || STRNCMP(s, \"se \", (size_t)3) == 0)\n\t    {\n\t\tif (*e != ':')\t\t// no terminating ':'?\n\t\t    break;\n\t\tend = TRUE;\n\t\ts = vim_strchr(s, ' ') + 1;\n\t    }\n\t    *e = NUL;\t\t\t// truncate the set command\n\n\t    if (*s != NUL)\t\t// skip over an empty \"::\"\n\t    {\n\t\tint secure_save = secure;\n\n\t\tsave_current_sctx = current_sctx;\n\t\tcurrent_sctx.sc_version = 1;\n#ifdef FEAT_EVAL\n\t\tcurrent_sctx.sc_sid = SID_MODELINE;\n\t\tcurrent_sctx.sc_seq = 0;\n\t\tcurrent_sctx.sc_lnum = lnum;\n#endif\n\n\t\t// Make sure no risky things are executed as a side effect.\n\t\tsecure = 1;\n\n\t\tretval = do_set(s, OPT_MODELINE | OPT_LOCAL | flags);\n\n\t\tsecure = secure_save;\n\t\tcurrent_sctx = save_current_sctx;\n\t\tif (retval == FAIL)\t\t// stop if error found\n\t\t    break;\n\t    }\n\t    s = e + 1;\t\t\t// advance to next part\n\t}\n\n\tESTACK_CHECK_NOW\n\testack_pop();\n\tvim_free(linecopy);\n    }\n    return retval;\n}\n\n/*\n * Return TRUE if \"buf\" is a normal buffer, 'buftype' is empty.\n */\n    int\nbt_normal(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == NUL;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is the quickfix buffer.\n */\n    int\nbt_quickfix(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'q';\n}\n#endif\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is a terminal buffer.\n */\n    int\nbt_terminal(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 't';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a help buffer.\n */\n    int\nbt_help(buf_T *buf)\n{\n    return buf != NULL && buf->b_help;\n}\n\n/*\n * Return TRUE if \"buf\" is a prompt buffer.\n */\n    int\nbt_prompt(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'r';\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is a buffer for a popup window.\n */\n    int\nbt_popup(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt != NULL\n\t&& buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'o';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nofile\", \"acwrite\", \"terminal\" or \"prompt\"\n * buffer.  This means the buffer name is not a file name.\n */\n    int\nbt_nofilename(buf_T *buf)\n{\n    return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')\n\t    || buf->b_p_bt[0] == 'a'\n\t    || buf->b_p_bt[0] == 't'\n\t    || buf->b_p_bt[0] == 'p');\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" has 'buftype' set to \"nofile\".\n */\n    int\nbt_nofile(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nowrite\", \"nofile\", \"terminal\" or \"prompt\"\n * buffer.\n */\n    int\nbt_dontwrite(buf_T *buf)\n{\n    return buf != NULL && (buf->b_p_bt[0] == 'n'\n\t\t || buf->b_p_bt[0] == 't'\n\t\t || buf->b_p_bt[0] == 'p');\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    int\nbt_dontwrite_msg(buf_T *buf)\n{\n    if (bt_dontwrite(buf))\n    {\n\temsg(_(e_cannot_write_buftype_option_is_set));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Return TRUE if the buffer should be hidden, according to 'hidden', \":hide\"\n * and 'bufhidden'.\n */\n    int\nbuf_hide(buf_T *buf)\n{\n    // 'bufhidden' overrules 'hidden' and \":hide\", check it first\n    switch (buf->b_p_bh[0])\n    {\n\tcase 'u':\t\t    // \"unload\"\n\tcase 'w':\t\t    // \"wipe\"\n\tcase 'd': return FALSE;\t    // \"delete\"\n\tcase 'h': return TRUE;\t    // \"hide\"\n    }\n    return (p_hid || (cmdmod.cmod_flags & CMOD_HIDE));\n}\n\n/*\n * Return special buffer name.\n * Returns NULL when the buffer has a normal file name.\n */\n    char_u *\nbuf_spname(buf_T *buf)\n{\n#if defined(FEAT_QUICKFIX)\n    if (bt_quickfix(buf))\n    {\n\t/*\n\t * Differentiate between the quickfix and location list buffers using\n\t * the buffer number stored in the global quickfix stack.\n\t */\n\tif (buf->b_fnum == qf_stack_get_bufnr())\n\t    return (char_u *)_(msg_qflist);\n\telse\n\t    return (char_u *)_(msg_loclist);\n    }\n#endif\n\n    // There is no _file_ when 'buftype' is \"nofile\", b_sfname\n    // contains the name as specified by the user.\n    if (bt_nofilename(buf))\n    {\n#ifdef FEAT_TERMINAL\n\tif (buf->b_term != NULL)\n\t    return term_get_status_text(buf->b_term);\n#endif\n\tif (buf->b_fname != NULL)\n\t    return buf->b_fname;\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(buf))\n\t    return (char_u *)_(\"[Prompt]\");\n#endif\n#ifdef FEAT_PROP_POPUP\n\tif (bt_popup(buf))\n\t    return (char_u *)_(\"[Popup]\");\n#endif\n\treturn (char_u *)_(\"[Scratch]\");\n    }\n\n    if (buf->b_fname == NULL)\n\treturn buf_get_fname(buf);\n    return NULL;\n}\n\n/*\n * Get \"buf->b_fname\", use \"[No Name]\" if it is NULL.\n */\n    char_u *\nbuf_get_fname(buf_T *buf)\n{\n    if (buf->b_fname == NULL)\n\treturn (char_u *)_(\"[No Name]\");\n    return buf->b_fname;\n}\n\n/*\n * Set 'buflisted' for curbuf to \"on\" and trigger autocommands if it changed.\n */\n    void\nset_buflisted(int on)\n{\n    if (on != curbuf->b_p_bl)\n    {\n\tcurbuf->b_p_bl = on;\n\tif (on)\n\t    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);\n\telse\n\t    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);\n    }\n}\n\n/*\n * Read the file for \"buf\" again and check if the contents changed.\n * Return TRUE if it changed or this could not be checked.\n */\n    int\nbuf_contents_changed(buf_T *buf)\n{\n    buf_T\t*newbuf;\n    int\t\tdiffer = TRUE;\n    linenr_T\tlnum;\n    aco_save_T\taco;\n    exarg_T\tea;\n\n    // Allocate a buffer without putting it in the buffer list.\n    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    if (newbuf == NULL)\n\treturn TRUE;\n\n    // Force the 'fileencoding' and 'fileformat' to be equal.\n    if (prep_exarg(&ea, buf) == FAIL)\n    {\n\twipe_buffer(newbuf, FALSE);\n\treturn TRUE;\n    }\n\n    // set curwin/curbuf to buf and save a few things\n    aucmd_prepbuf(&aco, newbuf);\n\n    if (ml_open(curbuf) == OK\n\t    && readfile(buf->b_ffname, buf->b_fname,\n\t\t\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t    &ea, READ_NEW | READ_DUMMY) == OK)\n    {\n\t// compare the two files line by line\n\tif (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count)\n\t{\n\t    differ = FALSE;\n\t    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t\tif (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0)\n\t\t{\n\t\t    differ = TRUE;\n\t\t    break;\n\t\t}\n\t}\n    }\n    vim_free(ea.cmd);\n\n    // restore curwin/curbuf and a few other things\n    aucmd_restbuf(&aco);\n\n    if (curbuf != newbuf)\t// safety check\n\twipe_buffer(newbuf, FALSE);\n\n    return differ;\n}\n\n/*\n * Wipe out a buffer and decrement the last buffer number if it was used for\n * this buffer.  Call this to wipe out a temp buffer that does not contain any\n * marks.\n */\n    void\nwipe_buffer(\n    buf_T\t*buf,\n    int\t\taucmd)\t    // When TRUE trigger autocommands.\n{\n    if (buf->b_fnum == top_file_num - 1)\n\t--top_file_num;\n\n    if (!aucmd)\t\t    // Don't trigger BufDelete autocommands here.\n\tblock_autocmds();\n\n    close_buffer(NULL, buf, DOBUF_WIPE, FALSE, TRUE);\n\n    if (!aucmd)\n\tunblock_autocmds();\n}\n", "\" Test for the quickfix feature.\n\nsource check.vim\nimport './vim9.vim' as v9\nCheckFeature quickfix\n\nsource screendump.vim\n\nset encoding=utf-8\n\nfunc s:setup_commands(cchar)\n  if a:cchar == 'c'\n    command! -nargs=* -bang Xlist <mods>clist<bang> <args>\n    command! -nargs=* Xgetexpr <mods>cgetexpr <args>\n    command! -nargs=* Xaddexpr <mods>caddexpr <args>\n    command! -nargs=* -count Xolder <mods><count>colder <args>\n    command! -nargs=* Xnewer <mods>cnewer <args>\n    command! -nargs=* Xopen <mods> copen <args>\n    command! -nargs=* Xwindow <mods>cwindow <args>\n    command! -nargs=* Xbottom <mods>cbottom <args>\n    command! -nargs=* Xclose <mods>cclose <args>\n    command! -nargs=* -bang Xfile <mods>cfile<bang> <args>\n    command! -nargs=* Xgetfile <mods>cgetfile <args>\n    command! -nargs=* Xaddfile <mods>caddfile <args>\n    command! -nargs=* -bang Xbuffer <mods>cbuffer<bang> <args>\n    command! -nargs=* Xgetbuffer <mods>cgetbuffer <args>\n    command! -nargs=* Xaddbuffer <mods>caddbuffer <args>\n    command! -nargs=* Xrewind <mods>crewind <args>\n    command! -count -nargs=* -bang Xnext <mods><count>cnext<bang> <args>\n    command! -count -nargs=* -bang Xprev <mods><count>cprev<bang> <args>\n    command! -nargs=* -bang Xfirst <mods>cfirst<bang> <args>\n    command! -nargs=* -bang Xlast <mods>clast<bang> <args>\n    command! -count -nargs=* -bang Xnfile <mods><count>cnfile<bang> <args>\n    command! -nargs=* -bang Xpfile <mods>cpfile<bang> <args>\n    command! -nargs=* Xexpr <mods>cexpr <args>\n    command! -count=999 -nargs=* Xvimgrep <mods> <count>vimgrep <args>\n    command! -nargs=* Xvimgrepadd <mods> vimgrepadd <args>\n    command! -nargs=* Xgrep <mods> grep <args>\n    command! -nargs=* Xgrepadd <mods> grepadd <args>\n    command! -nargs=* Xhelpgrep helpgrep <args>\n    command! -nargs=0 -count Xcc <count>cc\n    command! -count=1 -nargs=0 Xbelow <mods><count>cbelow\n    command! -count=1 -nargs=0 Xabove <mods><count>cabove\n    command! -count=1 -nargs=0 Xbefore <mods><count>cbefore\n    command! -count=1 -nargs=0 Xafter <mods><count>cafter\n    let g:Xgetlist = function('getqflist')\n    let g:Xsetlist = function('setqflist')\n    call setqflist([], 'f')\n  else\n    command! -nargs=* -bang Xlist <mods>llist<bang> <args>\n    command! -nargs=* Xgetexpr <mods>lgetexpr <args>\n    command! -nargs=* Xaddexpr <mods>laddexpr <args>\n    command! -nargs=* -count Xolder <mods><count>lolder <args>\n    command! -nargs=* Xnewer <mods>lnewer <args>\n    command! -nargs=* Xopen <mods> lopen <args>\n    command! -nargs=* Xwindow <mods>lwindow <args>\n    command! -nargs=* Xbottom <mods>lbottom <args>\n    command! -nargs=* Xclose <mods>lclose <args>\n    command! -nargs=* -bang Xfile <mods>lfile<bang> <args>\n    command! -nargs=* Xgetfile <mods>lgetfile <args>\n    command! -nargs=* Xaddfile <mods>laddfile <args>\n    command! -nargs=* -bang Xbuffer <mods>lbuffer<bang> <args>\n    command! -nargs=* Xgetbuffer <mods>lgetbuffer <args>\n    command! -nargs=* Xaddbuffer <mods>laddbuffer <args>\n    command! -nargs=* Xrewind <mods>lrewind <args>\n    command! -count -nargs=* -bang Xnext <mods><count>lnext<bang> <args>\n    command! -count -nargs=* -bang Xprev <mods><count>lprev<bang> <args>\n    command! -nargs=* -bang Xfirst <mods>lfirst<bang> <args>\n    command! -nargs=* -bang Xlast <mods>llast<bang> <args>\n    command! -count -nargs=* -bang Xnfile <mods><count>lnfile<bang> <args>\n    command! -nargs=* -bang Xpfile <mods>lpfile<bang> <args>\n    command! -nargs=* Xexpr <mods>lexpr <args>\n    command! -count=999 -nargs=* Xvimgrep <mods> <count>lvimgrep <args>\n    command! -nargs=* Xvimgrepadd <mods> lvimgrepadd <args>\n    command! -nargs=* Xgrep <mods> lgrep <args>\n    command! -nargs=* Xgrepadd <mods> lgrepadd <args>\n    command! -nargs=* Xhelpgrep lhelpgrep <args>\n    command! -nargs=0 -count Xcc <count>ll\n    command! -count=1 -nargs=0 Xbelow <mods><count>lbelow\n    command! -count=1 -nargs=0 Xabove <mods><count>labove\n    command! -count=1 -nargs=0 Xbefore <mods><count>lbefore\n    command! -count=1 -nargs=0 Xafter <mods><count>lafter\n    let g:Xgetlist = function('getloclist', [0])\n    let g:Xsetlist = function('setloclist', [0])\n    call setloclist(0, [], 'f')\n  endif\nendfunc\n\n\" This must be run before any error lists are created.\nfunc Test_AA_cc_no_errors()\n  call assert_fails('cc', 'E42:')\n  call assert_fails('ll', 'E42:')\nendfunc\n\n\" Tests for the :clist and :llist commands\nfunc XlistTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  if a:cchar == 'l'\n      call assert_fails('llist', 'E776:')\n  endif\n  \" With an empty list, command should return error\n  Xgetexpr []\n  silent! Xlist\n  call assert_true(v:errmsg ==# 'E42: No Errors')\n\n  \" Populate the list and then try\n  Xgetexpr ['non-error 1', 'Xtestfile1:1:3:Line1',\n\t\t  \\ 'non-error 2', 'Xtestfile2:2:2:Line2',\n\t\t  \\ 'non-error| 3', 'Xtestfile3:3:1:Line3']\n\n  \" List only valid entries\n  let l = split(execute('Xlist', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 4 Xtestfile2:2 col 2: Line2',\n\t\t   \\ ' 6 Xtestfile3:3 col 1: Line3'], l)\n\n  \" List all the entries\n  let l = split(execute('Xlist!', ''), \"\\n\")\n  call assert_equal([' 1: non-error 1', ' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2',\n\t\t   \\ ' 5: non-error| 3', ' 6 Xtestfile3:3 col 1: Line3'], l)\n\n  \" List a range of errors\n  let l = split(execute('Xlist 3,6', ''), \"\\n\")\n  call assert_equal([' 4 Xtestfile2:2 col 2: Line2',\n\t\t   \\ ' 6 Xtestfile3:3 col 1: Line3'], l)\n\n  let l = split(execute('Xlist! 3,4', ''), \"\\n\")\n  call assert_equal([' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)\n\n  let l = split(execute('Xlist -6,-4', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1'], l)\n\n  let l = split(execute('Xlist! -5,-3', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)\n\n  \" Test for '+'\n  let l = split(execute('Xlist! +2', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)\n\n  \" Ranged entries\n  call g:Xsetlist([{'lnum':10,'text':'Line1'},\n\t      \\ {'lnum':20,'col':10,'text':'Line2'},\n\t      \\ {'lnum':30,'col':15,'end_col':20,'text':'Line3'},\n\t      \\ {'lnum':40,'end_lnum':45,'text':'Line4'},\n\t      \\ {'lnum':50,'end_lnum':55,'col':15,'text':'Line5'},\n\t      \\ {'lnum':60,'end_lnum':65,'col':25,'end_col':35,'text':'Line6'}])\n  let l = split(execute('Xlist', \"\"), \"\\n\")\n  call assert_equal([' 1:10: Line1',\n\t      \\ ' 2:20 col 10: Line2',\n\t      \\ ' 3:30 col 15-20: Line3',\n\t      \\ ' 4:40-45: Line4',\n\t      \\ ' 5:50-55 col 15: Line5',\n\t      \\ ' 6:60-65 col 25-35: Line6'], l)\n\n  \" Different types of errors\n  call g:Xsetlist([{'lnum':10,'col':5,'type':'W', 'text':'Warning','nr':11},\n\t      \\ {'lnum':20,'col':10,'type':'e','text':'Error','nr':22},\n\t      \\ {'lnum':30,'col':15,'type':'i','text':'Info','nr':33},\n\t      \\ {'lnum':40,'col':20,'type':'x', 'text':'Other','nr':44},\n\t      \\ {'lnum':50,'col':25,'type':\"\\<C-A>\",'text':'one','nr':55}])\n  let l = split(execute('Xlist', \"\"), \"\\n\")\n  call assert_equal([' 1:10 col 5 warning  11: Warning',\n\t      \\ ' 2:20 col 10 error  22: Error',\n\t      \\ ' 3:30 col 15 info  33: Info',\n\t      \\ ' 4:40 col 20 x  44: Other',\n\t      \\ ' 5:50 col 25  55: one'], l)\n\n  \" Test for module names, one needs to explicitly set `'valid':v:true` so\n  call g:Xsetlist([\n\t\\ {'lnum':10,'col':5,'type':'W','module':'Data.Text','text':'ModuleWarning','nr':11,'valid':v:true},\n\t\\ {'lnum':20,'col':10,'type':'W','module':'Data.Text','filename':'Data/Text.hs','text':'ModuleWarning','nr':22,'valid':v:true},\n\t\\ {'lnum':30,'col':15,'type':'W','filename':'Data/Text.hs','text':'FileWarning','nr':33,'valid':v:true}])\n  let l = split(execute('Xlist', \"\"), \"\\n\")\n  call assert_equal([' 1 Data.Text:10 col 5 warning  11: ModuleWarning',\n\t\\ ' 2 Data.Text:20 col 10 warning  22: ModuleWarning',\n\t\\ ' 3 Data/Text.hs:30 col 15 warning  33: FileWarning'], l)\n\n  \" For help entries in the quickfix list, only the filename without directory\n  \" should be displayed\n  Xhelpgrep setqflist()\n  let l = split(execute('Xlist 1', ''), \"\\n\")\n  call assert_match('^ 1 [^\\\\/]\\{-}:', l[0])\n\n  \" Error cases\n  call assert_fails('Xlist abc', 'E488:')\nendfunc\n\nfunc Test_clist()\n  call XlistTests('c')\n  call XlistTests('l')\nendfunc\n\n\" Tests for the :colder, :cnewer, :lolder and :lnewer commands\n\" Note that this test assumes that a quickfix/location list is\n\" already set by the caller.\nfunc XageTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  if a:cchar == 'l'\n    \" No location list for the current window\n    call assert_fails('lolder', 'E776:')\n    call assert_fails('lnewer', 'E776:')\n  endif\n\n  let list = [{'bufnr': bufnr('%'), 'lnum': 1}]\n  call g:Xsetlist(list)\n\n  \" Jumping to a non existent list should return error\n  silent! Xolder 99\n  call assert_true(v:errmsg ==# 'E380: At bottom of quickfix stack')\n\n  silent! Xnewer 99\n  call assert_true(v:errmsg ==# 'E381: At top of quickfix stack')\n\n  \" Add three quickfix/location lists\n  Xgetexpr ['Xtestfile1:1:3:Line1']\n  Xgetexpr ['Xtestfile2:2:2:Line2']\n  Xgetexpr ['Xtestfile3:3:1:Line3']\n\n  \" Go back two lists\n  Xolder\n  let l = g:Xgetlist()\n  call assert_equal('Line2', l[0].text)\n\n  \" Go forward two lists\n  Xnewer\n  let l = g:Xgetlist()\n  call assert_equal('Line3', l[0].text)\n\n  \" Test for the optional count argument\n  Xolder 2\n  let l = g:Xgetlist()\n  call assert_equal('Line1', l[0].text)\n\n  Xnewer 2\n  let l = g:Xgetlist()\n  call assert_equal('Line3', l[0].text)\nendfunc\n\nfunc Test_cage()\n  call XageTests('c')\n  call XageTests('l')\nendfunc\n\n\" Tests for the :cwindow, :lwindow :cclose, :lclose, :copen and :lopen\n\" commands\nfunc XwindowTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Opening the location list window without any errors should fail\n  if a:cchar == 'l'\n      call assert_fails('lopen', 'E776:')\n  endif\n\n  \" Create a list with no valid entries\n  Xgetexpr ['non-error 1', 'non-error 2', 'non-error 3']\n\n  \" Quickfix/Location window should not open with no valid errors\n  Xwindow\n  call assert_true(winnr('$') == 1)\n\n  \" Create a list with valid entries\n  Xgetexpr ['Xtestfile1:1:3:Line1', 'Xtestfile2:2:2:Line2',\n\t\t  \\ 'Xtestfile3:3:1:Line3']\n\n  \" Open the window\n  Xwindow\n  call assert_true(winnr('$') == 2 && winnr() == 2 &&\n\t\\ getline('.') ==# 'Xtestfile1|1 col 3| Line1')\n  redraw!\n\n  \" Close the window\n  Xclose\n  call assert_true(winnr('$') == 1)\n\n  \" Create a list with no valid entries\n  Xgetexpr ['non-error 1', 'non-error 2', 'non-error 3']\n\n  \" Open the window\n  Xopen 5\n  call assert_true(winnr('$') == 2 && getline('.') ==# '|| non-error 1'\n\t\t      \\  && winheight(0) == 5)\n\n  \" Opening the window again, should move the cursor to that window\n  wincmd t\n  Xopen 7\n  call assert_true(winnr('$') == 2 && winnr() == 2 &&\n\t\\ winheight(0) == 7 &&\n\t\\ getline('.') ==# '|| non-error 1')\n\n  \" :cnext in quickfix window should move to the next entry\n  Xnext\n  call assert_equal(2, g:Xgetlist({'idx' : 0}).idx)\n\n  \" Calling cwindow should close the quickfix window with no valid errors\n  Xwindow\n  call assert_true(winnr('$') == 1)\n\n  \" Specifying the width should adjust the width for a vertically split\n  \" quickfix window.\n  vert Xopen\n  call assert_equal(10, winwidth(0))\n  vert Xopen 12\n  call assert_equal(12, winwidth(0))\n  Xclose\n\n  \" Horizontally or vertically splitting the quickfix window should create a\n  \" normal window/buffer\n  Xopen\n  wincmd s\n  call assert_equal(0, getwininfo(win_getid())[0].quickfix)\n  call assert_equal(0, getwininfo(win_getid())[0].loclist)\n  call assert_notequal('quickfix', &buftype)\n  close\n  Xopen\n  wincmd v\n  call assert_equal(0, getwininfo(win_getid())[0].quickfix)\n  call assert_equal(0, getwininfo(win_getid())[0].loclist)\n  call assert_notequal('quickfix', &buftype)\n  close\n  Xopen\n  Xclose\n\n  if a:cchar == 'c'\n      \" Opening the quickfix window in multiple tab pages should reuse the\n      \" quickfix buffer\n      Xgetexpr ['Xtestfile1:1:3:Line1', 'Xtestfile2:2:2:Line2',\n\t\t  \\ 'Xtestfile3:3:1:Line3']\n      Xopen\n      let qfbufnum = bufnr('%')\n      tabnew\n      Xopen\n      call assert_equal(qfbufnum, bufnr('%'))\n      new | only | tabonly\n  endif\nendfunc\n\nfunc Test_cwindow()\n  call XwindowTests('c')\n  call XwindowTests('l')\nendfunc\n\nfunc Test_copenHeight()\n  copen\n  wincmd H\n  let height = winheight(0)\n  copen 10\n  call assert_equal(height, winheight(0))\n  quit\nendfunc\n\nfunc Test_copenHeight_tabline()\n  set tabline=foo showtabline=2\n  copen\n  wincmd H\n  let height = winheight(0)\n  copen 10\n  call assert_equal(height, winheight(0))\n  quit\n  set tabline& showtabline&\nendfunc\n\n\n\" Tests for the :cfile, :lfile, :caddfile, :laddfile, :cgetfile and :lgetfile\n\" commands.\nfunc XfileTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call writefile(['Xtestfile1:700:10:Line 700',\n\t\\ 'Xtestfile2:800:15:Line 800'], 'Xqftestfile1')\n\n  enew!\n  Xfile Xqftestfile1\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 700 && l[0].col == 10 && l[0].text ==# 'Line 700' &&\n\t\\ l[1].lnum == 800 && l[1].col == 15 && l[1].text ==# 'Line 800')\n\n  \" Test with a non existent file\n  call assert_fails('Xfile non_existent_file', 'E40:')\n\n  \" Run cfile/lfile from a modified buffer\n  enew!\n  silent! put ='Quickfix'\n  silent! Xfile Xqftestfile1\n  call assert_true(v:errmsg ==# 'E37: No write since last change (add ! to override)')\n\n  call writefile(['Xtestfile3:900:30:Line 900'], 'Xqftestfile1')\n  Xaddfile Xqftestfile1\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 3 &&\n\t\\ l[2].lnum == 900 && l[2].col == 30 && l[2].text ==# 'Line 900')\n\n  call writefile(['Xtestfile1:222:77:Line 222',\n\t\\ 'Xtestfile2:333:88:Line 333'], 'Xqftestfile1')\n\n  enew!\n  Xgetfile Xqftestfile1\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 222 && l[0].col == 77 && l[0].text ==# 'Line 222' &&\n\t\\ l[1].lnum == 333 && l[1].col == 88 && l[1].text ==# 'Line 333')\n\n  \" Test for a file with a long line and without a newline at the end\n  let text = repeat('x', 1024)\n  let t = 'a.txt:18:' . text\n  call writefile([t], 'Xqftestfile1', 'b')\n  silent! Xfile Xqftestfile1\n  call assert_equal(text, g:Xgetlist()[0].text)\n\n  call delete('Xqftestfile1')\nendfunc\n\nfunc Test_cfile()\n  call XfileTests('c')\n  call XfileTests('l')\nendfunc\n\n\" Tests for the :cbuffer, :lbuffer, :caddbuffer, :laddbuffer, :cgetbuffer and\n\" :lgetbuffer commands.\nfunc XbufferTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  enew!\n  silent! call setline(1, ['Xtestfile7:700:10:Line 700',\n\t\\ 'Xtestfile8:800:15:Line 800'])\n  Xbuffer!\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 700 && l[0].col == 10 && l[0].text ==# 'Line 700' &&\n\t\\ l[1].lnum == 800 && l[1].col == 15 && l[1].text ==# 'Line 800')\n\n  enew!\n  silent! call setline(1, ['Xtestfile9:900:55:Line 900',\n\t\\ 'Xtestfile10:950:66:Line 950'])\n  Xgetbuffer\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 900 && l[0].col == 55 && l[0].text ==# 'Line 900' &&\n\t\\ l[1].lnum == 950 && l[1].col == 66 && l[1].text ==# 'Line 950')\n\n  enew!\n  silent! call setline(1, ['Xtestfile11:700:20:Line 700',\n\t\\ 'Xtestfile12:750:25:Line 750'])\n  Xaddbuffer\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 4 &&\n\t\\ l[1].lnum == 950 && l[1].col == 66 && l[1].text ==# 'Line 950' &&\n\t\\ l[2].lnum == 700 && l[2].col == 20 && l[2].text ==# 'Line 700' &&\n\t\\ l[3].lnum == 750 && l[3].col == 25 && l[3].text ==# 'Line 750')\n  enew!\n\n  \" Check for invalid buffer\n  call assert_fails('Xbuffer 199', 'E474:')\n\n  \" Check for unloaded buffer\n  edit Xtestfile1\n  let bnr = bufnr('%')\n  enew!\n  call assert_fails('Xbuffer ' . bnr, 'E681:')\n\n  \" Check for invalid range\n  \" Using Xbuffer will not run the range check in the cbuffer/lbuffer\n  \" commands. So directly call the commands.\n  if (a:cchar == 'c')\n      call assert_fails('900,999cbuffer', 'E16:')\n  else\n      call assert_fails('900,999lbuffer', 'E16:')\n  endif\nendfunc\n\nfunc Test_cbuffer()\n  call XbufferTests('c')\n  call XbufferTests('l')\nendfunc\n\nfunc XexprTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call assert_fails('Xexpr 10', 'E777:')\nendfunc\n\nfunc Test_cexpr()\n  call XexprTests('c')\n  call XexprTests('l')\nendfunc\n\n\" Tests for :cnext, :cprev, :cfirst, :clast commands\nfunc Xtest_browse(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  \" Jumping to first or next location list entry without any error should\n  \" result in failure\n  if a:cchar == 'c'\n    let err = 'E42:'\n    let cmd = '$cc'\n  else\n    let err = 'E776:'\n    let cmd = '$ll'\n  endif\n  call assert_fails('Xnext', err)\n  call assert_fails('Xprev', err)\n  call assert_fails('Xnfile', err)\n  call assert_fails('Xpfile', err)\n  call assert_fails(cmd, err)\n\n  Xexpr ''\n  call assert_fails(cmd, 'E42:')\n\n  call s:create_test_file('Xqftestfile1')\n  call s:create_test_file('Xqftestfile2')\n\n  Xgetexpr ['Xqftestfile1:5:Line5',\n\t\t\\ 'Xqftestfile1:6:Line6',\n\t\t\\ 'Xqftestfile2:10:Line10',\n\t\t\\ 'Xqftestfile2:11:Line11',\n\t\t\\ 'RegularLine1',\n\t\t\\ 'RegularLine2']\n\n  Xfirst\n  call assert_fails('-5Xcc', 'E16:')\n  call assert_fails('Xprev', 'E553:')\n  call assert_fails('Xpfile', 'E553:')\n  Xnfile\n  call assert_equal('Xqftestfile2', @%)\n  call assert_equal(10, line('.'))\n  Xpfile\n  call assert_equal('Xqftestfile1', @%)\n  call assert_equal(6, line('.'))\n  5Xcc\n  call assert_equal(5, g:Xgetlist({'idx':0}).idx)\n  2Xcc\n  call assert_equal(2, g:Xgetlist({'idx':0}).idx)\n  if a:cchar == 'c'\n    cc\n  else\n    ll\n  endif\n  call assert_equal(2, g:Xgetlist({'idx':0}).idx)\n  10Xcc\n  call assert_equal(6, g:Xgetlist({'idx':0}).idx)\n  Xlast\n  Xprev\n  call assert_equal('Xqftestfile2', @%)\n  call assert_equal(11, line('.'))\n  call assert_fails('Xnext', 'E553:')\n  call assert_fails('Xnfile', 'E553:')\n  \" To process the range using quickfix list entries, directly use the\n  \" quickfix commands (don't use the user defined commands)\n  if a:cchar == 'c'\n    $cc\n  else\n    $ll\n  endif\n  call assert_equal(6, g:Xgetlist({'idx':0}).idx)\n  Xrewind\n  call assert_equal('Xqftestfile1', @%)\n  call assert_equal(5, line('.'))\n\n  10Xnext\n  call assert_equal('Xqftestfile2', @%)\n  call assert_equal(11, line('.'))\n  10Xprev\n  call assert_equal('Xqftestfile1', @%)\n  call assert_equal(5, line('.'))\n\n  \" Jumping to an error from the error window using cc command\n  Xgetexpr ['Xqftestfile1:5:Line5',\n\t\t\\ 'Xqftestfile1:6:Line6',\n\t\t\\ 'Xqftestfile2:10:Line10',\n\t\t\\ 'Xqftestfile2:11:Line11']\n  Xopen\n  10Xcc\n  call assert_equal(11, line('.'))\n  call assert_equal('Xqftestfile2', @%)\n  Xopen\n  call cursor(2, 1)\n  if a:cchar == 'c'\n    .cc\n  else\n    .ll\n  endif\n  call assert_equal(6, line('.'))\n  call assert_equal('Xqftestfile1', @%)\n\n  \" Jumping to an error from the error window (when only the error window is\n  \" present)\n  Xopen | only\n  Xlast 1\n  call assert_equal(5, line('.'))\n  call assert_equal('Xqftestfile1', @%)\n\n  Xexpr \"\"\n  call assert_fails('Xnext', 'E42:')\n\n  call delete('Xqftestfile1')\n  call delete('Xqftestfile2')\n\n  \" Should be able to use next/prev with invalid entries\n  Xexpr \"\"\n  call assert_equal(0, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal(0, g:Xgetlist({'size' : 0}).size)\n  Xaddexpr ['foo', 'bar', 'baz', 'quux', 'sh|moo']\n  call assert_equal(5, g:Xgetlist({'size' : 0}).size)\n  Xlast\n  call assert_equal(5, g:Xgetlist({'idx' : 0}).idx)\n  Xfirst\n  call assert_equal(1, g:Xgetlist({'idx' : 0}).idx)\n  2Xnext\n  call assert_equal(3, g:Xgetlist({'idx' : 0}).idx)\nendfunc\n\nfunc Test_browse()\n  call Xtest_browse('c')\n  call Xtest_browse('l')\nendfunc\n\nfunc Test_nomem()\n  call test_alloc_fail(GetAllocId('qf_dirname_start'), 0, 0)\n  call assert_fails('vimgrep vim runtest.vim', 'E342:')\n\n  call GetAllocId('qf_dirname_now')->test_alloc_fail(0, 0)\n  call assert_fails('vimgrep vim runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_namebuf'), 0, 0)\n  call assert_fails('cfile runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_errmsg'), 0, 0)\n  call assert_fails('cfile runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_pattern'), 0, 0)\n  call assert_fails('cfile runtest.vim', 'E342:')\n\nendfunc\n\nfunc s:test_xhelpgrep(cchar)\n  call s:setup_commands(a:cchar)\n  Xhelpgrep quickfix\n  Xopen\n  if a:cchar == 'c'\n    let title_text = ':helpgrep quickfix'\n  else\n    let title_text = ':lhelpgrep quickfix'\n  endif\n  call assert_true(w:quickfix_title =~ title_text, w:quickfix_title)\n\n  \" Jumping to a help topic should open the help window\n  only\n  Xnext\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr('$') == 2)\n  \" Jumping to the next match should reuse the help window\n  Xnext\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr() == 1)\n  call assert_true(winnr('$') == 2)\n  \" Jumping to the next match from the quickfix window should reuse the help\n  \" window\n  Xopen\n  Xnext\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr() == 1)\n  call assert_true(winnr('$') == 2)\n  call assert_match('|\\d\\+ col \\d\\+-\\d\\+|', getbufline(winbufnr(2), 1)[0])\n\n  \" This wipes out the buffer, make sure that doesn't cause trouble.\n  Xclose\n\n  \" When the current window is vertically split, jumping to a help match\n  \" should open the help window at the top.\n  only | enew\n  let w1 = win_getid()\n  vert new\n  let w2 = win_getid()\n  Xnext\n  let w3 = win_getid()\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr() == 1)\n  \" See jump_to_help_window() for details\n  let w2_width = winwidth(w2)\n  if w2_width != &columns && w2_width < 80\n    call assert_equal(['col', [['leaf', w3],\n          \\ ['row', [['leaf', w2], ['leaf', w1]]]]], winlayout())\n  else\n    call assert_equal(['row', [['col', [['leaf', w3], ['leaf', w2]]],\n          \\ ['leaf', w1]]] , winlayout())\n  endif\n\n  new | only\n  set buftype=help\n  set modified\n  call assert_fails('Xnext', 'E37:')\n  set nomodified\n  new | only\n\n  if a:cchar == 'l'\n      \" When a help window is present, running :lhelpgrep should reuse the\n      \" help window and not the current window\n      new | only\n      call g:Xsetlist([], 'f')\n      help index.txt\n      wincmd w\n      lhelpgrep quickfix\n      call assert_equal(1, winnr())\n      call assert_notequal([], getloclist(1))\n      call assert_equal([], getloclist(2))\n  endif\n\n  new | only\n\n  \" Search for non existing help string\n  call assert_fails('Xhelpgrep a1b2c3', 'E480:')\n  \" Invalid regular expression\n  call assert_fails('Xhelpgrep \\@<!', 'E866:')\nendfunc\n\nfunc Test_helpgrep()\n  call s:test_xhelpgrep('c')\n  helpclose\n  call s:test_xhelpgrep('l')\nendfunc\n\ndef Test_helpgrep_vim9_restore_cpo()\n  assert_equal('aABceFs', &cpo)\n\n  var rtp_save = &rtp\n  var dir = 'Xruntime/after'\n  &rtp ..= ',' .. dir\n  mkdir(dir .. '/ftplugin', 'p')\n  writefile(['vim9script'], dir .. '/ftplugin/qf.vim')\n  filetype plugin on\n  silent helpgrep grail\n  cwindow\n  silent helpgrep grail\n\n  assert_equal('aABceFs', &cpo)\n  delete(dir, 'rf')\n  &rtp = rtp_save\n  cclose\n  helpclose\nenddef\n\ndef Test_vim9_cexpr()\n  var text = 'somefile:95:error'\n  cexpr text\n  var l = getqflist()\n  assert_equal(1, l->len())\n  assert_equal(95, l[0].lnum)\n  assert_equal('error', l[0].text)\n\n  text = 'somefile:77:warning'\n  caddexpr text\n  l = getqflist()\n  assert_equal(2, l->len())\n  assert_equal(77, l[1].lnum)\n  assert_equal('warning', l[1].text)\nenddef\n\nfunc Test_errortitle()\n  augroup QfBufWinEnter\n    au!\n    au BufWinEnter * :let g:a=get(w:, 'quickfix_title', 'NONE')\n  augroup END\n  copen\n  let a=[{'lnum': 308, 'bufnr': bufnr(''), 'col': 58, 'valid': 1, 'vcol': 0, 'nr': 0, 'type': '', 'pattern': '', 'text': '    au BufWinEnter * :let g:a=get(w:, ''quickfix_title'', ''NONE'')'}]\n  call setqflist(a)\n  call assert_equal(':setqflist()', g:a)\n  augroup QfBufWinEnter\n    au!\n  augroup END\n  augroup! QfBufWinEnter\nendfunc\n\nfunc Test_vimgreptitle()\n  augroup QfBufWinEnter\n    au!\n    au BufWinEnter * :let g:a=get(w:, 'quickfix_title', 'NONE')\n  augroup END\n  try\n    vimgrep /pattern/j file\n  catch /E480/\n  endtry\n  copen\n  call assert_equal(':    vimgrep /pattern/j file', g:a)\n  augroup QfBufWinEnter\n    au!\n  augroup END\n  augroup! QfBufWinEnter\nendfunc\n\nfunc Test_bufwinenter_once()\n  augroup QfBufWinEnter\n    au!\n    au BufWinEnter * let g:got_afile ..= 'got ' .. expand('<afile>')\n  augroup END\n  let g:got_afile = ''\n  copen\n  call assert_equal('got quickfix', g:got_afile)\n\n  cclose\n  unlet g:got_afile\n  augroup QfBufWinEnter\n    au!\n  augroup END\n  augroup! QfBufWinEnter\nendfunc\n\nfunc XqfTitleTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xgetexpr ['file:1:1:message']\n  let l = g:Xgetlist()\n  if a:cchar == 'c'\n    call setqflist(l, 'r')\n  else\n    call setloclist(0, l, 'r')\n  endif\n\n  Xopen\n  if a:cchar == 'c'\n    let title = ':setqflist()'\n  else\n    let title = ':setloclist()'\n  endif\n  call assert_equal(title, w:quickfix_title)\n  Xclose\nendfunc\n\n\" Tests for quickfix window's title\nfunc Test_qf_title()\n  call XqfTitleTests('c')\n  call XqfTitleTests('l')\nendfunc\n\n\" Tests for 'errorformat'\nfunc Test_efm()\n  let save_efm = &efm\n  set efm=%EEEE%m,%WWWW%m,%+CCCC%.%#,%-GGGG%.%#\n  cgetexpr ['WWWW', 'EEEE', 'CCCC']\n  let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))\n  call assert_equal(\"[['W', 1], ['E^@CCCC', 1]]\", l)\n  cgetexpr ['WWWW', 'GGGG', 'EEEE', 'CCCC']\n  let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))\n  call assert_equal(\"[['W', 1], ['E^@CCCC', 1]]\", l)\n  cgetexpr ['WWWW', 'GGGG', 'ZZZZ', 'EEEE', 'CCCC', 'YYYY']\n  let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))\n  call assert_equal(\"[['W', 1], ['ZZZZ', 0], ['E^@CCCC', 1], ['YYYY', 0]]\", l)\n  let &efm = save_efm\nendfunc\n\n\" This will test for problems in quickfix:\n\" A. incorrectly copying location lists which caused the location list to show\n\"    a different name than the file that was actually being displayed.\n\" B. not reusing the window for which the location list window is opened but\n\"    instead creating new windows.\n\" C. make sure that the location list window is not reused instead of the\n\"    window it belongs to.\n\"\n\" Set up the test environment:\nfunc ReadTestProtocol(name)\n  let base = substitute(a:name, '\\v^test://(.*)%(\\.[^.]+)?', '\\1', '')\n  let word = substitute(base, '\\v(.*)\\..*', '\\1', '')\n\n  setl modifiable\n  setl noreadonly\n  setl noswapfile\n  setl bufhidden=delete\n  %del _\n  \" For problem 2:\n  \" 'buftype' has to be set to reproduce the constant opening of new windows\n  setl buftype=nofile\n\n  call setline(1, word)\n\n  setl nomodified\n  setl nomodifiable\n  setl readonly\n  exe 'doautocmd BufRead ' . substitute(a:name, '\\v^test://(.*)', '\\1', '')\nendfunc\n\nfunc Test_locationlist()\n  enew\n\n  augroup testgroup\n    au!\n    autocmd BufReadCmd test://* call ReadTestProtocol(expand(\"<amatch>\"))\n  augroup END\n\n  let words = [ \"foo\", \"bar\", \"baz\", \"quux\", \"shmoo\", \"spam\", \"eggs\" ]\n\n  let qflist = []\n  for word in words\n    call add(qflist, {'filename': 'test://' . word . '.txt', 'text': 'file ' . word . '.txt', })\n    \" NOTE: problem 1:\n    \" intentionally not setting 'lnum' so that the quickfix entries are not\n    \" valid\n    eval qflist->setloclist(0, ' ')\n  endfor\n\n  \" Test A\n  lrewind\n  enew\n  lopen\n  4lnext\n  vert split\n  wincmd L\n  lopen\n  wincmd p\n  lnext\n  let fileName = expand(\"%\")\n  wincmd p\n  let locationListFileName = substitute(getline(line('.')), '\\([^|]*\\)|.*', '\\1', '')\n  let fileName = substitute(fileName, '\\\\', '/', 'g')\n  let locationListFileName = substitute(locationListFileName, '\\\\', '/', 'g')\n  call assert_equal(\"test://bar.txt\", fileName)\n  call assert_equal(\"test://bar.txt\", locationListFileName)\n\n  wincmd n | only\n\n  \" Test B:\n  lrewind\n  lopen\n  2\n  exe \"normal \\<CR>\"\n  wincmd p\n  3\n  exe \"normal \\<CR>\"\n  wincmd p\n  4\n  exe \"normal \\<CR>\"\n  call assert_equal(2, winnr('$'))\n  wincmd n | only\n\n  \" Test C:\n  lrewind\n  lopen\n  \" Let's move the location list window to the top to check whether it (the\n  \" first window found) will be reused when we try to open new windows:\n  wincmd K\n  2\n  exe \"normal \\<CR>\"\n  wincmd p\n  3\n  exe \"normal \\<CR>\"\n  wincmd p\n  4\n  exe \"normal \\<CR>\"\n  1wincmd w\n  call assert_equal('quickfix', &buftype)\n  2wincmd w\n  let bufferName = expand(\"%\")\n  let bufferName = substitute(bufferName, '\\\\', '/', 'g')\n  call assert_equal('test://quux.txt', bufferName)\n\n  wincmd n | only\n\n  augroup! testgroup\nendfunc\n\nfunc Test_locationlist_curwin_was_closed()\n  augroup testgroup\n    au!\n    autocmd BufReadCmd test_curwin.txt call R(expand(\"<amatch>\"))\n  augroup END\n\n  func! R(n)\n    quit\n  endfunc\n\n  new\n  let q = []\n  call add(q, {'filename': 'test_curwin.txt' })\n  call setloclist(0, q)\n  call assert_fails('lrewind', 'E924:')\n\n  augroup! testgroup\nendfunc\n\nfunc Test_locationlist_cross_tab_jump()\n  call writefile(['loclistfoo'], 'loclistfoo')\n  call writefile(['loclistbar'], 'loclistbar')\n  set switchbuf=usetab\n\n  edit loclistfoo\n  tabedit loclistbar\n  silent lgrep loclistfoo loclist*\n  call assert_equal(1, tabpagenr())\n\n  enew | only | tabonly\n  set switchbuf&vim\n  call delete('loclistfoo')\n  call delete('loclistbar')\nendfunc\n\n\" More tests for 'errorformat'\nfunc Test_efm1()\n  \" The 'errorformat' setting is different on non-Unix systems.\n  \" This test works only on Unix-like systems.\n  CheckUnix\n\n  let l =<< trim [DATA]\n    \"Xtestfile\", line 4.12: 1506-045 (S) Undeclared identifier fd_set.\n    \ufeff\"Xtestfile\", line 6 col 19; this is an error\n    gcc -c -DHAVE_CONFIsing-prototypes -I/usr/X11R6/include  version.c\n    Xtestfile:9: parse error before `asd'\n    make: *** [vim] Error 1\n    in file \"Xtestfile\" linenr 10: there is an error\n\n    2 returned\n    \"Xtestfile\", line 11 col 1; this is an error\n    \"Xtestfile\", line 12 col 2; this is another error\n    \"Xtestfile\", line 14:10; this is an error in column 10\n    =Xtestfile=, line 15:10; this is another error, but in vcol 10 this time\n    \"Xtestfile\", linenr 16: yet another problem\n    Error in \"Xtestfile\" at line 17:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 17\n                ^\n    Error in \"Xtestfile\" at line 18:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 18\n    .............^\n    Error in \"Xtestfile\" at line 19:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 19\n    --------------^\n    Error in \"Xtestfile\" at line 20:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 20\n    \t       ^\n\n    Does anyone know what is the problem and how to correction it?\n    \"Xtestfile\", line 21 col 9: What is the title of the quickfix window?\n    \"Xtestfile\", line 22 col 9: What is the title of the quickfix window?\n  [DATA]\n\n  call writefile(l, 'Xerrorfile1')\n  call writefile(l[:-2], 'Xerrorfile2')\n\n  let m =<< [DATA]\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  2\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  3\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  4\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  5\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  6\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  7\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  8\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  9\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 10\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 11\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 12\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 13\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 14\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 15\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 16\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 17\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 18\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 19\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 20\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 21\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 22\n[DATA]\n  call writefile(m, 'Xtestfile')\n\n  let save_efm = &efm\n  set efm+==%f=\\\\,\\ line\\ %l%*\\\\D%v%*[^\\ ]\\ %m\n  set efm^=%AError\\ in\\ \\\"%f\\\"\\ at\\ line\\ %l:,%Z%p^,%C%m\n\n  exe 'cf Xerrorfile2'\n  clast\n  copen\n  call assert_equal(':cf Xerrorfile2', w:quickfix_title)\n  wincmd p\n\n  exe 'cf Xerrorfile1'\n  call assert_equal([4, 12], [line('.'), col('.')])\n  cn\n  call assert_equal([6, 19], [line('.'), col('.')])\n  cn\n  call assert_equal([9, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([10, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([11, 1], [line('.'), col('.')])\n  cn\n  call assert_equal([12, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([14, 10], [line('.'), col('.')])\n  cn\n  call assert_equal([15, 3, 10], [line('.'), col('.'), virtcol('.')])\n  cn\n  call assert_equal([16, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([17, 6], [line('.'), col('.')])\n  cn\n  call assert_equal([18, 7], [line('.'), col('.')])\n  cn\n  call assert_equal([19, 8], [line('.'), col('.')])\n  cn\n  call assert_equal([20, 9], [line('.'), col('.')])\n  clast\n  cprev\n  cprev\n  wincmd w\n  call assert_equal(':cf Xerrorfile1', w:quickfix_title)\n  wincmd p\n\n  let &efm = save_efm\n  call delete('Xerrorfile1')\n  call delete('Xerrorfile2')\n  call delete('Xtestfile')\nendfunc\n\n\" Test for quickfix directory stack support\nfunc s:dir_stack_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let save_efm=&efm\n  set efm=%DEntering\\ dir\\ '%f',%f:%l:%m,%XLeaving\\ dir\\ '%f'\n\n  let lines = [\"Entering dir 'dir1/a'\",\n\t\t\\ 'habits2.txt:1:Nine Healthy Habits',\n\t\t\\ \"Entering dir 'b'\",\n\t\t\\ 'habits3.txt:2:0 Hours of television',\n\t\t\\ 'habits2.txt:7:5 Small meals',\n\t\t\\ \"Entering dir 'dir1/c'\",\n\t\t\\ 'habits4.txt:3:1 Hour of exercise',\n\t\t\\ \"Leaving dir 'dir1/c'\",\n\t\t\\ \"Leaving dir 'dir1/a'\",\n\t\t\\ 'habits1.txt:4:2 Liters of water',\n\t\t\\ \"Entering dir 'dir2'\",\n\t\t\\ 'habits5.txt:5:3 Cups of hot green tea',\n\t\t\\ \"Leaving dir 'dir2'\"\n\t\t\\]\n\n  Xexpr \"\"\n  for l in lines\n      Xaddexpr l\n  endfor\n\n  let qf = g:Xgetlist()\n\n  call assert_equal('dir1/a/habits2.txt', bufname(qf[1].bufnr))\n  call assert_equal(1, qf[1].lnum)\n  call assert_equal('dir1/a/b/habits3.txt', bufname(qf[3].bufnr))\n  call assert_equal(2, qf[3].lnum)\n  call assert_equal('dir1/a/habits2.txt', bufname(qf[4].bufnr))\n  call assert_equal(7, qf[4].lnum)\n  call assert_equal('dir1/c/habits4.txt', bufname(qf[6].bufnr))\n  call assert_equal(3, qf[6].lnum)\n  call assert_equal('habits1.txt', bufname(qf[9].bufnr))\n  call assert_equal(4, qf[9].lnum)\n  call assert_equal('dir2/habits5.txt', bufname(qf[11].bufnr))\n  call assert_equal(5, qf[11].lnum)\n\n  let &efm=save_efm\nendfunc\n\n\" Tests for %D and %X errorformat options\nfunc Test_efm_dirstack()\n  \" Create the directory stack and files\n  call mkdir('dir1')\n  call mkdir('dir1/a')\n  call mkdir('dir1/a/b')\n  call mkdir('dir1/c')\n  call mkdir('dir2')\n\n  let lines = [\"Nine Healthy Habits\",\n\t\t\\ \"0 Hours of television\",\n\t\t\\ \"1 Hour of exercise\",\n\t\t\\ \"2 Liters of water\",\n\t\t\\ \"3 Cups of hot green tea\",\n\t\t\\ \"4 Short mental breaks\",\n\t\t\\ \"5 Small meals\",\n\t\t\\ \"6 AM wake up time\",\n\t\t\\ \"7 Minutes of laughter\",\n\t\t\\ \"8 Hours of sleep (at least)\",\n\t\t\\ \"9 PM end of the day and off to bed\"\n\t\t\\ ]\n  call writefile(lines, 'habits1.txt')\n  call writefile(lines, 'dir1/a/habits2.txt')\n  call writefile(lines, 'dir1/a/b/habits3.txt')\n  call writefile(lines, 'dir1/c/habits4.txt')\n  call writefile(lines, 'dir2/habits5.txt')\n\n  call s:dir_stack_tests('c')\n  call s:dir_stack_tests('l')\n\n  call delete('dir1', 'rf')\n  call delete('dir2', 'rf')\n  call delete('habits1.txt')\nendfunc\n\n\" Test for resync after continuing an ignored message\nfunc Xefm_ignore_continuations(cchar)\n  call s:setup_commands(a:cchar)\n\n  let save_efm = &efm\n\n  let &efm =\n\t\\ '%Eerror %m %l,' .\n\t\\ '%-Wignored %m %l,' .\n\t\\ '%+Cmore ignored %m %l,' .\n\t\\ '%Zignored end'\n  Xgetexpr ['ignored warning 1', 'more ignored continuation 2', 'ignored end', 'error resync 4']\n  let l = map(g:Xgetlist(), '[v:val.text, v:val.valid, v:val.lnum, v:val.type]')\n  call assert_equal([['resync', 1, 4, 'E']], l)\n\n  let &efm = save_efm\nendfunc\n\nfunc Test_efm_ignore_continuations()\n  call Xefm_ignore_continuations('c')\n  call Xefm_ignore_continuations('l')\nendfunc\n\n\" Tests for invalid error format specifies\nfunc Xinvalid_efm_Tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let save_efm = &efm\n\n  set efm=%f:%l:%m,%f:%f:%l:%m\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E372:')\n\n  set efm=%f:%l:%m,%f:%l:%r:%m\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E373:')\n\n  set efm=%f:%l:%m,%O:%f:%l:%m\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E373:')\n\n  set efm=%f:%l:%m,%f:%l:%*[^a-z\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E374:')\n\n  set efm=%f:%l:%m,%f:%l:%*c\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E375:')\n\n  set efm=%f:%l:%m,%L%M%N\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E376:')\n\n  set efm=%f:%l:%m,%f:%l:%m:%R\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E377:')\n\n  \" Invalid regular expression\n  set efm=%\\\\%%k\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E867:')\n\n  set efm=\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E378:')\n\n  set efm=%DEntering\\ dir\\ abc,%f:%l:%m\n  call assert_fails('Xexpr [\"Entering dir abc\", \"abc.txt:1:Hello world\"]', 'E379:')\n\n  let &efm = save_efm\nendfunc\n\nfunc Test_invalid_efm()\n  call Xinvalid_efm_Tests('c')\n  call Xinvalid_efm_Tests('l')\nendfunc\n\n\" TODO:\n\" Add tests for the following formats in 'errorformat'\n\"\t%r  %O\nfunc Test_efm2()\n  let save_efm = &efm\n\n  \" Test for %s format in efm\n  set efm=%f:%s\n  cexpr 'Xtestfile:Line search text'\n  let l = getqflist()\n  call assert_equal('^\\VLine search text\\$', l[0].pattern)\n  call assert_equal(0, l[0].lnum)\n\n  let l = split(execute('clist', ''), \"\\n\")\n  call assert_equal([' 1 Xtestfile:^\\VLine search text\\$:  '], l)\n\n  \" Test for a long line\n  cexpr 'Xtestfile:' . repeat('a', 1026)\n  let l = getqflist()\n  call assert_equal('^\\V' . repeat('a', 1019) . '\\$', l[0].pattern)\n\n  \" Test for %P, %Q and %t format specifiers\n  let lines =<< trim [DATA]\n    [Xtestfile1]\n    (1,17)  error: ';' missing\n    (21,2)  warning: variable 'z' not defined\n    (67,3)  error: end of file found before string ended\n    --\n\n    [Xtestfile2]\n    --\n\n    [Xtestfile3]\n    NEW compiler v1.1\n    (2,2)   warning: variable 'x' not defined\n    (67,3)  warning: 's' already defined\n    --\n  [DATA]\n\n  set efm=%+P[%f]%r,(%l\\\\,%c)%*[\\ ]%t%*[^:]:\\ %m,%+Q--%r\n  \" To exercise the push/pop file functionality in quickfix, the test files\n  \" need to be created.\n  call writefile(['Line1'], 'Xtestfile1')\n  call writefile(['Line2'], 'Xtestfile2')\n  call writefile(['Line3'], 'Xtestfile3')\n  cexpr \"\"\n  for l in lines\n      caddexpr l\n  endfor\n  let l = getqflist()\n  call assert_equal(12, len(l))\n  call assert_equal(21, l[2].lnum)\n  call assert_equal(2, l[2].col)\n  call assert_equal('w', l[2].type)\n  call assert_equal('e', l[3].type)\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\n  call delete('Xtestfile3')\n\n  \" Test for %P, %Q with non-existing files\n  cexpr lines\n  let l = getqflist()\n  call assert_equal(14, len(l))\n  call assert_equal('[Xtestfile1]', l[0].text)\n  call assert_equal('[Xtestfile2]', l[6].text)\n  call assert_equal('[Xtestfile3]', l[9].text)\n\n  \" Tests for %E, %C and %Z format specifiers\n  let lines =<< trim [DATA]\n    Error 275\n    line 42\n    column 3\n    ' ' expected after '--'\n  [DATA]\n\n  set efm=%EError\\ %n,%Cline\\ %l,%Ccolumn\\ %c,%Z%m\n  cgetexpr lines\n  let l = getqflist()\n  call assert_equal(275, l[0].nr)\n  call assert_equal(42, l[0].lnum)\n  call assert_equal(3, l[0].col)\n  call assert_equal('E', l[0].type)\n  call assert_equal(\"\\n' ' expected after '--'\", l[0].text)\n\n  \" Test for %>\n  let lines =<< trim [DATA]\n    Error in line 147 of foo.c:\n    unknown variable 'i'\n  [DATA]\n\n  set efm=unknown\\ variable\\ %m,%E%>Error\\ in\\ line\\ %l\\ of\\ %f:,%Z%m\n  cgetexpr lines\n  let l = getqflist()\n  call assert_equal(147, l[0].lnum)\n  call assert_equal('E', l[0].type)\n  call assert_equal(\"\\nunknown variable 'i'\", l[0].text)\n\n  \" Test for %A, %C and other formats\n  let lines =<< trim [DATA]\n    ==============================================================\n    FAIL: testGetTypeIdCachesResult (dbfacadeTest.DjsDBFacadeTest)\n    --------------------------------------------------------------\n    Traceback (most recent call last):\n      File \"unittests/dbfacadeTest.py\", line 89, in testFoo\n        self.assertEquals(34, dtid)\n      File \"/usr/lib/python2.2/unittest.py\", line 286, in\n     failUnlessEqual\n        raise self.failureException, \\\\\n    W:AssertionError: 34 != 33\n  \n    --------------------------------------------------------------\n    Ran 27 tests in 0.063s\n  [DATA]\n\n  set efm=%C\\ %.%#,%A\\ \\ File\\ \\\"%f\\\"\\\\,\\ line\\ %l%.%#,%Z%[%^\\ ]%\\\\@=%t:%m\n  cgetexpr lines\n  let l = getqflist()\n  call assert_equal(8, len(l))\n  call assert_equal(89, l[4].lnum)\n  call assert_equal(1, l[4].valid)\n  call assert_equal('unittests/dbfacadeTest.py', bufname(l[4].bufnr))\n  call assert_equal('W', l[4].type)\n\n  \" Test for %o\n  set efm=%f(%o):%l\\ %m\n  cgetexpr ['Xotestfile(Language.PureScript.Types):20 Error']\n  call writefile(['Line1'], 'Xotestfile')\n  let l = getqflist()\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('Language.PureScript.Types', l[0].module)\n  copen\n  call assert_equal('Language.PureScript.Types|20| Error', getline(1))\n  call feedkeys(\"\\<CR>\", 'xn')\n  call assert_equal('Xotestfile', expand('%:t'))\n  cclose\n  bd\n  call delete(\"Xotestfile\")\n\n  \" Test for a long module name\n  cexpr 'Xtest(' . repeat('m', 1026) . '):15 message'\n  let l = getqflist()\n  call assert_equal(repeat('m', 1024), l[0].module)\n  call assert_equal(15, l[0].lnum)\n  call assert_equal('message', l[0].text)\n\n  \" The following sequence of commands used to crash Vim\n  set efm=%W%m\n  cgetexpr ['msg1']\n  let l = getqflist()\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('msg1', l[0].text)\n  set efm=%C%m\n  lexpr 'msg2'\n  let l = getloclist(0)\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('msg2', l[0].text)\n  lopen\n  call setqflist([], 'r')\n  caddbuf\n  let l = getqflist()\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('|| msg2', l[0].text)\n\n  \" When matching error lines, case should be ignored. Test for this.\n  set noignorecase\n  let l=getqflist({'lines' : ['Xtest:FOO10:Line 20'], 'efm':'%f:foo%l:%m'})\n  call assert_equal(10, l.items[0].lnum)\n  call assert_equal('Line 20', l.items[0].text)\n  set ignorecase&\n\n  new | only\n  let &efm = save_efm\nendfunc\n\n\" Test for '%t' (error type) field in 'efm'\nfunc Test_efm_error_type()\n  let save_efm = &efm\n\n  \" error type\n  set efm=%f:%l:%t:%m\n  cexpr [\"Xfile1:10:E:msg1\", \"Xfile1:20:W:msg2\", \"Xfile1:30:I:msg3\",\n        \\ \"Xfile1:40:N:msg4\", \"Xfile1:50:R:msg5\"]\n  let output = split(execute('clist'), \"\\n\")\n  call assert_equal([\n        \\ ' 1 Xfile1:10 error: msg1',\n        \\ ' 2 Xfile1:20 warning: msg2',\n        \\ ' 3 Xfile1:30 info: msg3',\n        \\ ' 4 Xfile1:40 note: msg4',\n        \\ ' 5 Xfile1:50 R: msg5'], output)\n\n  \" error type and a error number\n  set efm=%f:%l:%t:%n:%m\n  cexpr [\"Xfile1:10:E:2:msg1\", \"Xfile1:20:W:4:msg2\", \"Xfile1:30:I:6:msg3\",\n        \\ \"Xfile1:40:N:8:msg4\", \"Xfile1:50:R:3:msg5\"]\n  let output = split(execute('clist'), \"\\n\")\n  call assert_equal([\n        \\ ' 1 Xfile1:10 error   2: msg1',\n        \\ ' 2 Xfile1:20 warning   4: msg2',\n        \\ ' 3 Xfile1:30 info   6: msg3',\n        \\ ' 4 Xfile1:40 note   8: msg4',\n        \\ ' 5 Xfile1:50 R   3: msg5'], output)\n  let &efm = save_efm\nendfunc\n\nfunc XquickfixChangedByAutocmd(cchar)\n  call s:setup_commands(a:cchar)\n  if a:cchar == 'c'\n    let ErrorNr = 'E925'\n    func! ReadFunc()\n      colder\n      cgetexpr []\n    endfunc\n  else\n    let ErrorNr = 'E926'\n    func! ReadFunc()\n      lolder\n      lgetexpr []\n    endfunc\n  endif\n\n  augroup testgroup\n    au!\n    autocmd BufReadCmd test_changed.txt call ReadFunc()\n  augroup END\n\n  new | only\n  let words = [ \"a\", \"b\" ]\n  let qflist = []\n  for word in words\n    call add(qflist, {'filename': 'test_changed.txt'})\n    call g:Xsetlist(qflist, ' ')\n  endfor\n  call assert_fails('Xrewind', ErrorNr . ':')\n\n  augroup! testgroup\nendfunc\n\nfunc Test_quickfix_was_changed_by_autocmd()\n  call XquickfixChangedByAutocmd('c')\n  call XquickfixChangedByAutocmd('l')\nendfunc\n\nfunc Test_setloclist_in_autocommand()\n  call writefile(['test1', 'test2'], 'Xfile')\n  edit Xfile\n  let s:bufnr = bufnr()\n  call setloclist(1,\n        \\ [{'bufnr' : s:bufnr, 'lnum' : 1, 'text' : 'test1'},\n        \\  {'bufnr' : s:bufnr, 'lnum' : 2, 'text' : 'test2'}])\n\n  augroup Test_LocList\n    au!\n    autocmd BufEnter * call setloclist(1,\n          \\ [{'bufnr' : s:bufnr, 'lnum' : 1, 'text' : 'test1'},\n          \\  {'bufnr' : s:bufnr, 'lnum' : 2, 'text' : 'test2'}], 'r')\n  augroup END\n\n  lopen\n  call assert_fails('exe \"normal j\\<CR>\"', 'E926:')\n\n  augroup Test_LocList\n    au!\n  augroup END\n  call delete('Xfile')\nendfunc\n\nfunc Test_caddbuffer_to_empty()\n  helpgr quickfix\n  call setqflist([], 'r')\n  cad\n  try\n    cn\n  catch\n    \" number of matches is unknown\n    call assert_true(v:exception =~ 'E553:')\n  endtry\n  quit!\nendfunc\n\nfunc Test_cgetexpr_works()\n  \" this must not crash Vim\n  cgetexpr [$x]\n  lgetexpr [$x]\nendfunc\n\n\" Tests for the setqflist() and setloclist() functions\nfunc SetXlistTests(cchar, bnum)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 1},\n\t      \\  {'bufnr': a:bnum, 'lnum': 2, 'end_lnum': 3, 'col': 4, 'end_col': 5}])\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal(2, l[1].lnum)\n  call assert_equal(3, l[1].end_lnum)\n  call assert_equal(4, l[1].col)\n  call assert_equal(5, l[1].end_col)\n\n  Xnext\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 3}], 'a')\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  Xnext\n  call assert_equal(3, line('.'))\n\n  \" Appending entries to the list should not change the cursor position\n  \" in the quickfix window\n  Xwindow\n  1\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 4},\n\t      \\  {'bufnr': a:bnum, 'lnum': 5}], 'a')\n  call assert_equal(1, line('.'))\n  close\n\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 3},\n\t      \\  {'bufnr': a:bnum, 'lnum': 4},\n\t      \\  {'bufnr': a:bnum, 'lnum': 5}], 'r')\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  call assert_equal(5, l[2].lnum)\n\n  call g:Xsetlist([])\n  let l = g:Xgetlist()\n  call assert_equal(0, len(l))\n\n  \" Tests for setting the 'valid' flag\n  call g:Xsetlist([{'bufnr':a:bnum, 'lnum':4, 'valid':0}])\n  Xwindow\n  call assert_equal(1, winnr('$'))\n  let l = g:Xgetlist()\n  call g:Xsetlist(l)\n  call assert_equal(0, g:Xgetlist()[0].valid)\n  \" Adding a non-valid entry should not mark the list as having valid entries\n  call g:Xsetlist([{'bufnr':a:bnum, 'lnum':5, 'valid':0}], 'a')\n  Xwindow\n  call assert_equal(1, winnr('$'))\n\n  \" :cnext/:cprev should still work even with invalid entries in the list\n  let l = [{'bufnr' : a:bnum, 'lnum' : 1, 'text' : '1', 'valid' : 0},\n\t      \\ {'bufnr' : a:bnum, 'lnum' : 2, 'text' : '2', 'valid' : 0}]\n  call g:Xsetlist(l)\n  Xnext\n  call assert_equal(2, g:Xgetlist({'idx' : 0}).idx)\n  Xprev\n  call assert_equal(1, g:Xgetlist({'idx' : 0}).idx)\n  \" :cnext/:cprev should still work after appending invalid entries to an\n  \" empty list\n  call g:Xsetlist([])\n  call g:Xsetlist(l, 'a')\n  Xnext\n  call assert_equal(2, g:Xgetlist({'idx' : 0}).idx)\n  Xprev\n  call assert_equal(1, g:Xgetlist({'idx' : 0}).idx)\n\n  call g:Xsetlist([{'text':'Text1', 'valid':1}])\n  Xwindow\n  call assert_equal(2, winnr('$'))\n  Xclose\n  let save_efm = &efm\n  set efm=%m\n  Xgetexpr 'TestMessage'\n  let l = g:Xgetlist()\n  call g:Xsetlist(l)\n  call assert_equal(1, g:Xgetlist()[0].valid)\n  let &efm = save_efm\n\n  \" Error cases:\n  \" Refer to a non-existing buffer and pass a non-dictionary type\n  call assert_fails(\"call g:Xsetlist([{'bufnr':998, 'lnum':4},\" .\n\t      \\ \" {'bufnr':999, 'lnum':5}])\", 'E92:')\n  call g:Xsetlist([[1, 2,3]])\n  call assert_equal(0, len(g:Xgetlist()))\n  call assert_fails('call g:Xsetlist([], [])', 'E928:')\nendfunc\n\nfunc Test_setqflist()\n  new Xtestfile | only\n  let bnum = bufnr('%')\n  call setline(1, range(1,5))\n\n  call SetXlistTests('c', bnum)\n  call SetXlistTests('l', bnum)\n\n  enew!\n  call delete('Xtestfile')\nendfunc\n\nfunc Xlist_empty_middle(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" create three quickfix lists\n  let @/ = 'Test_'\n  Xvimgrep // test_quickfix.vim\n  let testlen = len(g:Xgetlist())\n  call assert_true(testlen > 0)\n  Xvimgrep empty test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) > 0)\n  Xvimgrep matches test_quickfix.vim\n  let matchlen = len(g:Xgetlist())\n  call assert_true(matchlen > 0)\n  Xolder\n  \" make the middle list empty\n  call g:Xsetlist([], 'r')\n  call assert_true(len(g:Xgetlist()) == 0)\n  Xolder\n  call assert_equal(testlen, len(g:Xgetlist()))\n  Xnewer\n  Xnewer\n  call assert_equal(matchlen, len(g:Xgetlist()))\nendfunc\n\nfunc Test_setqflist_empty_middle()\n  call Xlist_empty_middle('c')\n  call Xlist_empty_middle('l')\nendfunc\n\nfunc Xlist_empty_older(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" create three quickfix lists\n  Xvimgrep one test_quickfix.vim\n  let onelen = len(g:Xgetlist())\n  call assert_true(onelen > 0)\n  Xvimgrep two test_quickfix.vim\n  let twolen = len(g:Xgetlist())\n  call assert_true(twolen > 0)\n  Xvimgrep three test_quickfix.vim\n  let threelen = len(g:Xgetlist())\n  call assert_true(threelen > 0)\n  Xolder 2\n  \" make the first list empty, check the others didn't change\n  call g:Xsetlist([], 'r')\n  call assert_true(len(g:Xgetlist()) == 0)\n  Xnewer\n  call assert_equal(twolen, len(g:Xgetlist()))\n  Xnewer\n  call assert_equal(threelen, len(g:Xgetlist()))\nendfunc\n\nfunc Test_setqflist_empty_older()\n  call Xlist_empty_older('c')\n  call Xlist_empty_older('l')\nendfunc\n\nfunc XquickfixSetListWithAct(cchar)\n  call s:setup_commands(a:cchar)\n\n  let list1 = [{'filename': 'fnameA', 'text': 'A'},\n          \\    {'filename': 'fnameB', 'text': 'B'}]\n  let list2 = [{'filename': 'fnameC', 'text': 'C'},\n          \\    {'filename': 'fnameD', 'text': 'D'},\n          \\    {'filename': 'fnameE', 'text': 'E'}]\n\n  \" {action} is unspecified.  Same as specifying ' '.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2)\n  let li = g:Xgetlist()\n  call assert_equal(3, len(li))\n  call assert_equal('C', li[0]['text'])\n  call assert_equal('D', li[1]['text'])\n  call assert_equal('E', li[2]['text'])\n  silent! Xolder\n  let li = g:Xgetlist()\n  call assert_equal(2, len(li))\n  call assert_equal('A', li[0]['text'])\n  call assert_equal('B', li[1]['text'])\n\n  \" {action} is specified ' '.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2, ' ')\n  let li = g:Xgetlist()\n  call assert_equal(3, len(li))\n  call assert_equal('C', li[0]['text'])\n  call assert_equal('D', li[1]['text'])\n  call assert_equal('E', li[2]['text'])\n  silent! Xolder\n  let li = g:Xgetlist()\n  call assert_equal(2, len(li))\n  call assert_equal('A', li[0]['text'])\n  call assert_equal('B', li[1]['text'])\n\n  \" {action} is specified 'a'.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2, 'a')\n  let li = g:Xgetlist()\n  call assert_equal(5, len(li))\n  call assert_equal('A', li[0]['text'])\n  call assert_equal('B', li[1]['text'])\n  call assert_equal('C', li[2]['text'])\n  call assert_equal('D', li[3]['text'])\n  call assert_equal('E', li[4]['text'])\n\n  \" {action} is specified 'r'.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2, 'r')\n  let li = g:Xgetlist()\n  call assert_equal(3, len(li))\n  call assert_equal('C', li[0]['text'])\n  call assert_equal('D', li[1]['text'])\n  call assert_equal('E', li[2]['text'])\n\n  \" Test for wrong value.\n  new | only\n  call assert_fails(\"call g:Xsetlist(0)\", 'E714:')\n  call assert_fails(\"call g:Xsetlist(list1, '')\", 'E927:')\n  call assert_fails(\"call g:Xsetlist(list1, 'aa')\", 'E927:')\n  call assert_fails(\"call g:Xsetlist(list1, ' a')\", 'E927:')\n  call assert_fails(\"call g:Xsetlist(list1, 0)\", 'E928:')\nendfunc\n\nfunc Test_setqflist_invalid_nr()\n  \" The following command used to crash Vim\n  eval []->setqflist(' ', {'nr' : $XXX_DOES_NOT_EXIST})\nendfunc\n\nfunc Test_setqflist_user_sets_buftype()\n  call setqflist([{'text': 'foo'}, {'text': 'bar'}])\n  set buftype=quickfix\n  call setqflist([], 'a')\n  enew\nendfunc\n\nfunc Test_quickfix_set_list_with_act()\n  call XquickfixSetListWithAct('c')\n  call XquickfixSetListWithAct('l')\nendfunc\n\nfunc XLongLinesTests(cchar)\n  let l = g:Xgetlist()\n\n  call assert_equal(4, len(l))\n  call assert_equal(1, l[0].lnum)\n  call assert_equal(1, l[0].col)\n  call assert_equal(1975, len(l[0].text))\n  call assert_equal(2, l[1].lnum)\n  call assert_equal(1, l[1].col)\n  call assert_equal(4070, len(l[1].text))\n  call assert_equal(3, l[2].lnum)\n  call assert_equal(1, l[2].col)\n  call assert_equal(4070, len(l[2].text))\n  call assert_equal(4, l[3].lnum)\n  call assert_equal(1, l[3].col)\n  call assert_equal(10, len(l[3].text))\n\n  call g:Xsetlist([], 'r')\nendfunc\n\nfunc s:long_lines_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let testfile = 'samples/quickfix.txt'\n\n  \" file\n  exe 'Xgetfile' testfile\n  call XLongLinesTests(a:cchar)\n\n  \" list\n  Xexpr readfile(testfile)\n  call XLongLinesTests(a:cchar)\n\n  \" string\n  Xexpr join(readfile(testfile), \"\\n\")\n  call XLongLinesTests(a:cchar)\n\n  \" buffer\n  exe 'edit' testfile\n  exe 'Xbuffer' bufnr('%')\n  call XLongLinesTests(a:cchar)\nendfunc\n\nfunc Test_long_lines()\n  call s:long_lines_tests('c')\n  call s:long_lines_tests('l')\nendfunc\n\nfunc Test_cgetfile_on_long_lines()\n  \" Problematic values if the line is longer than 4096 bytes.  Then 1024 bytes\n  \" are read at a time.\n  for len in [4078, 4079, 4080, 5102, 5103, 5104, 6126, 6127, 6128, 7150, 7151, 7152]\n    let lines = [\n      \\ '/tmp/file1:1:1:aaa',\n      \\ '/tmp/file2:1:1:%s',\n      \\ '/tmp/file3:1:1:bbb',\n      \\ '/tmp/file4:1:1:ccc',\n      \\ ]\n    let lines[1] = substitute(lines[1], '%s', repeat('x', len), '')\n    call writefile(lines, 'Xcqetfile.txt')\n    cgetfile Xcqetfile.txt\n    call assert_equal(4, getqflist(#{size: v:true}).size, 'with length ' .. len)\n  endfor\n  call delete('Xcqetfile.txt')\nendfunc\n\nfunc s:create_test_file(filename)\n  let l = []\n  for i in range(1, 20)\n      call add(l, 'Line' . i)\n  endfor\n  call writefile(l, a:filename)\nendfunc\n\nfunc Test_switchbuf()\n  call s:create_test_file('Xqftestfile1')\n  call s:create_test_file('Xqftestfile2')\n  call s:create_test_file('Xqftestfile3')\n\n  new | only\n  edit Xqftestfile1\n  let file1_winid = win_getid()\n  new Xqftestfile2\n  let file2_winid = win_getid()\n  cgetexpr ['Xqftestfile1:5:Line5',\n\t\t\\ 'Xqftestfile1:6:Line6',\n\t\t\\ 'Xqftestfile2:10:Line10',\n\t\t\\ 'Xqftestfile2:11:Line11',\n\t\t\\ 'Xqftestfile3:15:Line15',\n\t\t\\ 'Xqftestfile3:16:Line16']\n\n  new\n  let winid = win_getid()\n  cfirst | cnext\n  call assert_equal(winid, win_getid())\n  2cnext\n  call assert_equal(winid, win_getid())\n  2cnext\n  call assert_equal(winid, win_getid())\n\n  \" Test for 'switchbuf' set to search for files in windows in the current\n  \" tabpage and jump to an existing window (if present)\n  set switchbuf=useopen\n  enew\n  cfirst | cnext\n  call assert_equal(file1_winid, win_getid())\n  2cnext\n  call assert_equal(file2_winid, win_getid())\n  2cnext\n  call assert_equal(file2_winid, win_getid())\n\n  \" Test for 'switchbuf' set to search for files in tabpages and jump to an\n  \" existing tabpage (if present)\n  enew | only\n  set switchbuf=usetab\n  tabedit Xqftestfile1\n  tabedit Xqftestfile2\n  tabedit Xqftestfile3\n  tabfirst\n  cfirst | cnext\n  call assert_equal(2, tabpagenr())\n  2cnext\n  call assert_equal(3, tabpagenr())\n  6cnext\n  call assert_equal(4, tabpagenr())\n  2cpfile\n  call assert_equal(2, tabpagenr())\n  2cnfile\n  call assert_equal(4, tabpagenr())\n  tabfirst | tabonly | enew\n\n  \" Test for 'switchbuf' set to open a new window for every file\n  set switchbuf=split\n  cfirst | cnext\n  call assert_equal(1, winnr('$'))\n  cnext | cnext\n  call assert_equal(2, winnr('$'))\n  cnext | cnext\n  call assert_equal(3, winnr('$'))\n\n  \" Test for 'switchbuf' set to open a new tabpage for every file\n  set switchbuf=newtab\n  enew | only\n  cfirst | cnext\n  call assert_equal(1, tabpagenr('$'))\n  cnext | cnext\n  call assert_equal(2, tabpagenr('$'))\n  cnext | cnext\n  call assert_equal(3, tabpagenr('$'))\n  tabfirst | enew | tabonly | only\n\n  set switchbuf=uselast\n  split\n  let last_winid = win_getid()\n  copen\n  exe \"normal 1G\\<CR>\"\n  call assert_equal(last_winid, win_getid())\n  enew | only\n\n  \" With an empty 'switchbuf', jumping to a quickfix entry should open the\n  \" file in an existing window (if present)\n  set switchbuf=\n  edit Xqftestfile1\n  let file1_winid = win_getid()\n  new Xqftestfile2\n  let file2_winid = win_getid()\n  copen\n  exe \"normal 1G\\<CR>\"\n  call assert_equal(file1_winid, win_getid())\n  copen\n  exe \"normal 3G\\<CR>\"\n  call assert_equal(file2_winid, win_getid())\n  copen | only\n  exe \"normal 5G\\<CR>\"\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, bufwinnr('Xqftestfile3'))\n\n  \" If only quickfix window is open in the current tabpage, jumping to an\n  \" entry with 'switchbuf' set to 'usetab' should search in other tabpages.\n  enew | only\n  set switchbuf=usetab\n  tabedit Xqftestfile1\n  tabedit Xqftestfile2\n  tabedit Xqftestfile3\n  tabfirst\n  copen | only\n  clast\n  call assert_equal(4, tabpagenr())\n  tabfirst | tabonly | enew | only\n\n  \" Jumping to a file that is not present in any of the tabpages and the\n  \" current tabpage doesn't have any usable windows, should open it in a new\n  \" window in the current tabpage.\n  copen | only\n  cfirst\n  call assert_equal(1, tabpagenr())\n  call assert_equal('Xqftestfile1', @%)\n\n  \" If opening a file changes 'switchbuf', then the new value should be\n  \" retained.\n  set modeline&vim\n  call writefile([\"vim: switchbuf=split\"], 'Xqftestfile1')\n  enew | only\n  set switchbuf&vim\n  cexpr \"Xqftestfile1:1:10\"\n  call assert_equal('split', &switchbuf)\n  call writefile([\"vim: switchbuf=usetab\"], 'Xqftestfile1')\n  enew | only\n  set switchbuf=useopen\n  cexpr \"Xqftestfile1:1:10\"\n  call assert_equal('usetab', &switchbuf)\n  call writefile([\"vim: switchbuf&vim\"], 'Xqftestfile1')\n  enew | only\n  set switchbuf=useopen\n  cexpr \"Xqftestfile1:1:10\"\n  call assert_equal('', &switchbuf)\n\n  call delete('Xqftestfile1')\n  call delete('Xqftestfile2')\n  call delete('Xqftestfile3')\n  set switchbuf&vim\n\n  enew | only\nendfunc\n\nfunc Xadjust_qflnum(cchar)\n  call s:setup_commands(a:cchar)\n\n  enew | only\n\n  let fname = 'Xqftestfile' . a:cchar\n  call s:create_test_file(fname)\n  exe 'edit ' . fname\n\n  Xgetexpr [fname . ':5:Line5',\n\t      \\ fname . ':10:Line10',\n\t      \\ fname . ':15:Line15',\n\t      \\ fname . ':20:Line20']\n\n  6,14delete\n  call append(6, ['Buffer', 'Window'])\n\n  let l = g:Xgetlist()\n  call assert_equal(5, l[0].lnum)\n  call assert_equal(6, l[2].lnum)\n  call assert_equal(13, l[3].lnum)\n\n  \" If a file doesn't have any quickfix entries, then deleting lines in the\n  \" file should not update the quickfix list\n  call g:Xsetlist([], 'f')\n  1,2delete\n  call assert_equal([], g:Xgetlist())\n\n  enew!\n  call delete(fname)\nendfunc\n\nfunc Test_adjust_lnum()\n  call setloclist(0, [])\n  call Xadjust_qflnum('c')\n  call setqflist([])\n  call Xadjust_qflnum('l')\nendfunc\n\n\" Tests for the :grep/:lgrep and :grepadd/:lgrepadd commands\nfunc s:test_xgrep(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" The following lines are used for the grep test. Don't remove.\n  \" Grep_Test_Text: Match 1\n  \" Grep_Test_Text: Match 2\n  \" GrepAdd_Test_Text: Match 1\n  \" GrepAdd_Test_Text: Match 2\n  enew! | only\n  set makeef&vim\n  silent Xgrep Grep_Test_Text: test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) == 5)\n  Xopen\n  call assert_true(w:quickfix_title =~ '^:grep')\n  Xclose\n  enew\n  set makeef=Temp_File_##\n  silent Xgrepadd GrepAdd_Test_Text: test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) == 9)\n\n  \" Try with 'grepprg' set to 'internal'\n  set grepprg=internal\n  silent Xgrep Grep_Test_Text: test_quickfix.vim\n  silent Xgrepadd GrepAdd_Test_Text: test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) == 9)\n  set grepprg&vim\n\n  call writefile(['Vim'], 'XtestTempFile')\n  set makeef=XtestTempFile\n  silent Xgrep Grep_Test_Text: test_quickfix.vim\n  call assert_equal(5, len(g:Xgetlist()))\n  call assert_false(filereadable('XtestTempFile'))\n  set makeef&vim\nendfunc\n\nfunc Test_grep()\n  \" The grepprg may not be set on non-Unix systems\n  CheckUnix\n\n  call s:test_xgrep('c')\n  call s:test_xgrep('l')\nendfunc\n\nfunc Test_two_windows()\n  \" Use one 'errorformat' for two windows.  Add an expression to each of them,\n  \" make sure they each keep their own state.\n  set efm=%DEntering\\ dir\\ '%f',%f:%l:%m,%XLeaving\\ dir\\ '%f'\n  call mkdir('Xone/a', 'p')\n  call mkdir('Xtwo/a', 'p')\n  let lines = ['1', '2', 'one one one', '4', 'two two two', '6', '7']\n  call writefile(lines, 'Xone/a/one.txt')\n  call writefile(lines, 'Xtwo/a/two.txt')\n\n  new one\n  let one_id = win_getid()\n  lexpr \"\"\n  new two\n  let two_id = win_getid()\n  lexpr \"\"\n\n  laddexpr \"Entering dir 'Xtwo/a'\"\n  call win_gotoid(one_id)\n  laddexpr \"Entering dir 'Xone/a'\"\n  call win_gotoid(two_id)\n  laddexpr 'two.txt:5:two two two'\n  call win_gotoid(one_id)\n  laddexpr 'one.txt:3:one one one'\n\n  let loc_one = getloclist(one_id)\n  call assert_equal('Xone/a/one.txt', bufname(loc_one[1].bufnr))\n  call assert_equal(3, loc_one[1].lnum)\n\n  let loc_two = getloclist(two_id)\n  call assert_equal('Xtwo/a/two.txt', bufname(loc_two[1].bufnr))\n  call assert_equal(5, loc_two[1].lnum)\n\n  call win_gotoid(one_id)\n  bwipe!\n  call win_gotoid(two_id)\n  bwipe!\n  call delete('Xone', 'rf')\n  call delete('Xtwo', 'rf')\nendfunc\n\nfunc XbottomTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Calling lbottom without any errors should fail\n  if a:cchar == 'l'\n      call assert_fails('lbottom', 'E776:')\n  endif\n\n  call g:Xsetlist([{'filename': 'foo', 'lnum': 42}])\n  Xopen\n  let wid = win_getid()\n  call assert_equal(1, line('.'))\n  wincmd w\n  call g:Xsetlist([{'filename': 'var', 'lnum': 24}], 'a')\n  Xbottom\n  call win_gotoid(wid)\n  call assert_equal(2, line('.'))\n  Xclose\nendfunc\n\n\" Tests for the :cbottom and :lbottom commands\nfunc Test_cbottom()\n  call XbottomTests('c')\n  call XbottomTests('l')\nendfunc\n\nfunc HistoryTest(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" clear all lists after the first one, then replace the first one.\n  call g:Xsetlist([])\n  call assert_fails('Xolder 99', 'E380:')\n  let entry = {'filename': 'foo', 'lnum': 42}\n  call g:Xsetlist([entry], 'r')\n  call g:Xsetlist([entry, entry])\n  call g:Xsetlist([entry, entry, entry])\n  let res = split(execute(a:cchar . 'hist'), \"\\n\")\n  call assert_equal(3, len(res))\n  let common = 'errors     :set' . (a:cchar == 'c' ? 'qf' : 'loc') . 'list()'\n  call assert_equal('  error list 1 of 3; 1 ' . common, res[0])\n  call assert_equal('  error list 2 of 3; 2 ' . common, res[1])\n  call assert_equal('> error list 3 of 3; 3 ' . common, res[2])\n\n  \" Test for changing the quickfix lists\n  call assert_equal(3, g:Xgetlist({'nr' : 0}).nr)\n  exe '1' . a:cchar . 'hist'\n  call assert_equal(1, g:Xgetlist({'nr' : 0}).nr)\n  exe '3' . a:cchar . 'hist'\n  call assert_equal(3, g:Xgetlist({'nr' : 0}).nr)\n  call assert_fails('-2' . a:cchar . 'hist', 'E16:')\n  call assert_fails('4' . a:cchar . 'hist', 'E16:')\n\n  call g:Xsetlist([], 'f')\n  let l = split(execute(a:cchar . 'hist'), \"\\n\")\n  call assert_equal('No entries', l[0])\n  if a:cchar == 'c'\n    call assert_fails('4chist', 'E16:')\n  else\n    call assert_fails('4lhist', 'E776:')\n  endif\n\n  \" An empty list should still show the stack history\n  call g:Xsetlist([])\n  let res = split(execute(a:cchar . 'hist'), \"\\n\")\n  call assert_equal('> error list 1 of 1; 0 ' . common, res[0])\n\n  call g:Xsetlist([], 'f')\nendfunc\n\nfunc Test_history()\n  call HistoryTest('c')\n  call HistoryTest('l')\nendfunc\n\nfunc Test_duplicate_buf()\n  \" make sure we can get the highest buffer number\n  edit DoesNotExist\n  edit DoesNotExist2\n  let last_buffer = bufnr(\"$\")\n\n  \" make sure only one buffer is created\n  call writefile(['this one', 'that one'], 'Xgrepthis')\n  vimgrep one Xgrepthis\n  vimgrep one Xgrepthis\n  call assert_equal(last_buffer + 1, bufnr(\"$\"))\n\n  call delete('Xgrepthis')\nendfunc\n\n\" Quickfix/Location list set/get properties tests\nfunc Xproperty_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Error cases\n  call assert_fails('call g:Xgetlist(99)', 'E715:')\n  call assert_fails('call g:Xsetlist(99)', 'E714:')\n  call assert_fails('call g:Xsetlist([], \"a\", [])', 'E715:')\n\n  \" Set and get the title\n  call g:Xsetlist([])\n  Xopen\n  wincmd p\n  call g:Xsetlist([{'filename':'foo', 'lnum':27}])\n  let s = g:Xsetlist([], 'a', {'title' : 'Sample'})\n  call assert_equal(0, s)\n  let d = g:Xgetlist({\"title\":1})\n  call assert_equal('Sample', d.title)\n  \" Try setting title to a non-string value\n  call assert_equal(-1, g:Xsetlist([], 'a', {'title' : ['Test']}))\n  call assert_equal('Sample', g:Xgetlist({\"title\":1}).title)\n\n  Xopen\n  call assert_equal('Sample', w:quickfix_title)\n  Xclose\n\n  \" Tests for action argument\n  silent! Xolder 999\n  let qfnr = g:Xgetlist({'all':1}).nr\n  call g:Xsetlist([], 'r', {'title' : 'N1'})\n  call assert_equal('N1', g:Xgetlist({'all':1}).title)\n  call g:Xsetlist([], ' ', {'title' : 'N2'})\n  call assert_equal(qfnr + 1, g:Xgetlist({'all':1}).nr)\n\n  let res = g:Xgetlist({'nr': 0})\n  call assert_equal(qfnr + 1, res.nr)\n  call assert_equal(['nr'], keys(res))\n\n  call g:Xsetlist([], ' ', {'title' : 'N3'})\n  call assert_equal('N2', g:Xgetlist({'nr':2, 'title':1}).title)\n\n  \" Changing the title of an earlier quickfix list\n  call g:Xsetlist([], 'r', {'title' : 'NewTitle', 'nr' : 2})\n  call assert_equal('NewTitle', g:Xgetlist({'nr':2, 'title':1}).title)\n\n  \" Changing the title of an invalid quickfix list\n  call assert_equal(-1, g:Xsetlist([], ' ',\n        \\ {'title' : 'SomeTitle', 'nr' : 99}))\n  call assert_equal(-1, g:Xsetlist([], ' ',\n        \\ {'title' : 'SomeTitle', 'nr' : 'abc'}))\n\n  if a:cchar == 'c'\n    copen\n    call assert_equal({'winid':win_getid()}, getqflist({'winid':1}))\n    cclose\n  endif\n\n  \" Invalid arguments\n  call assert_fails('call g:Xgetlist([])', 'E715:')\n  call assert_fails('call g:Xsetlist([], \"a\", [])', 'E715:')\n  let s = g:Xsetlist([], 'a', {'abc':1})\n  call assert_equal(-1, s)\n\n  call assert_equal({}, g:Xgetlist({'abc':1}))\n  call assert_equal('', g:Xgetlist({'nr':99, 'title':1}).title)\n  call assert_equal('', g:Xgetlist({'nr':[], 'title':1}).title)\n\n  if a:cchar == 'l'\n    call assert_equal({}, getloclist(99, {'title': 1}))\n  endif\n\n  \" Context related tests\n  let s = g:Xsetlist([], 'a', {'context':[1,2,3]})\n  call assert_equal(0, s)\n  call test_garbagecollect_now()\n  let d = g:Xgetlist({'context':1})\n  call assert_equal([1,2,3], d.context)\n  call g:Xsetlist([], 'a', {'context':{'color':'green'}})\n  let d = g:Xgetlist({'context':1})\n  call assert_equal({'color':'green'}, d.context)\n  call g:Xsetlist([], 'a', {'context':\"Context info\"})\n  let d = g:Xgetlist({'context':1})\n  call assert_equal(\"Context info\", d.context)\n  call g:Xsetlist([], 'a', {'context':246})\n  let d = g:Xgetlist({'context':1})\n  call assert_equal(246, d.context)\n  \" set other Vim data types as context\n  call g:Xsetlist([], 'a', {'context' : test_null_blob()})\n  if has('channel')\n    call g:Xsetlist([], 'a', {'context' : test_null_channel()})\n  endif\n  if has('job')\n    call g:Xsetlist([], 'a', {'context' : test_null_job()})\n  endif\n  call g:Xsetlist([], 'a', {'context' : test_null_function()})\n  call g:Xsetlist([], 'a', {'context' : test_null_partial()})\n  call g:Xsetlist([], 'a', {'context' : ''})\n  call test_garbagecollect_now()\n  if a:cchar == 'l'\n    \" Test for copying context across two different location lists\n    new | only\n    let w1_id = win_getid()\n    let l = [1]\n    call setloclist(0, [], 'a', {'context':l})\n    new\n    let w2_id = win_getid()\n    call add(l, 2)\n    call assert_equal([1, 2], getloclist(w1_id, {'context':1}).context)\n    call assert_equal([1, 2], getloclist(w2_id, {'context':1}).context)\n    unlet! l\n    call assert_equal([1, 2], getloclist(w2_id, {'context':1}).context)\n    only\n    call setloclist(0, [], 'f')\n    call assert_equal('', getloclist(0, {'context':1}).context)\n  endif\n\n  \" Test for changing the context of previous quickfix lists\n  call g:Xsetlist([], 'f')\n  Xexpr \"One\"\n  Xexpr \"Two\"\n  Xexpr \"Three\"\n  call g:Xsetlist([], 'r', {'context' : [1], 'nr' : 1})\n  call g:Xsetlist([], 'a', {'context' : [2], 'nr' : 2})\n  \" Also, check for setting the context using quickfix list number zero.\n  call g:Xsetlist([], 'r', {'context' : [3], 'nr' : 0})\n  call test_garbagecollect_now()\n  let l = g:Xgetlist({'nr' : 1, 'context' : 1})\n  call assert_equal([1], l.context)\n  let l = g:Xgetlist({'nr' : 2, 'context' : 1})\n  call assert_equal([2], l.context)\n  let l = g:Xgetlist({'nr' : 3, 'context' : 1})\n  call assert_equal([3], l.context)\n\n  \" Test for changing the context through reference and for garbage\n  \" collection of quickfix context\n  let l = [\"red\"]\n  call g:Xsetlist([], ' ', {'context' : l})\n  call add(l, \"blue\")\n  let x = g:Xgetlist({'context' : 1})\n  call add(x.context, \"green\")\n  call assert_equal([\"red\", \"blue\", \"green\"], l)\n  call assert_equal([\"red\", \"blue\", \"green\"], x.context)\n  unlet l\n  call test_garbagecollect_now()\n  let m = g:Xgetlist({'context' : 1})\n  call assert_equal([\"red\", \"blue\", \"green\"], m.context)\n\n  \" Test for setting/getting items\n  Xexpr \"\"\n  let qfprev = g:Xgetlist({'nr':0})\n  let s = g:Xsetlist([], ' ', {'title':'Green',\n        \\ 'items' : [{'filename':'F1', 'lnum':10}]})\n  call assert_equal(0, s)\n  let qfcur = g:Xgetlist({'nr':0})\n  call assert_true(qfcur.nr == qfprev.nr + 1)\n  let l = g:Xgetlist({'items':1})\n  call assert_equal('F1', bufname(l.items[0].bufnr))\n  call assert_equal(10, l.items[0].lnum)\n  call g:Xsetlist([], 'a', {'items' : [{'filename':'F2', 'lnum':20},\n        \\  {'filename':'F2', 'lnum':30}]})\n  let l = g:Xgetlist({'items':1})\n  call assert_equal('F2', bufname(l.items[2].bufnr))\n  call assert_equal(30, l.items[2].lnum)\n  call g:Xsetlist([], 'r', {'items' : [{'filename':'F3', 'lnum':40}]})\n  let l = g:Xgetlist({'items':1})\n  call assert_equal('F3', bufname(l.items[0].bufnr))\n  call assert_equal(40, l.items[0].lnum)\n  call g:Xsetlist([], 'r', {'items' : []})\n  let l = g:Xgetlist({'items':1})\n  call assert_equal(0, len(l.items))\n\n  call g:Xsetlist([], 'r', {'title' : 'TestTitle'})\n  call g:Xsetlist([], 'r', {'items' : [{'filename' : 'F1', 'lnum' : 10, 'text' : 'L10'}]})\n  call g:Xsetlist([], 'r', {'items' : [{'filename' : 'F1', 'lnum' : 10, 'text' : 'L10'}]})\n  call assert_equal('TestTitle', g:Xgetlist({'title' : 1}).title)\n\n  \" Test for getting id of window associated with a location list window\n  if a:cchar == 'l'\n    only\n    call assert_equal(0, g:Xgetlist({'all' : 1}).filewinid)\n    let wid = win_getid()\n    Xopen\n    call assert_equal(wid, g:Xgetlist({'filewinid' : 1}).filewinid)\n    wincmd w\n    call assert_equal(0, g:Xgetlist({'filewinid' : 1}).filewinid)\n    only\n  endif\n\n  \" The following used to crash Vim with address sanitizer\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], 'a', {'items' : [{'filename':'F1', 'lnum':10}]})\n  call assert_equal(10, g:Xgetlist({'items':1}).items[0].lnum)\n\n  \" Try setting the items using a string\n  call assert_equal(-1, g:Xsetlist([], ' ', {'items' : 'Test'}))\n\n  \" Save and restore the quickfix stack\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'nr':'$'}).nr)\n  Xexpr \"File1:10:Line1\"\n  Xexpr \"File2:20:Line2\"\n  Xexpr \"File3:30:Line3\"\n  let last_qf = g:Xgetlist({'nr':'$'}).nr\n  call assert_equal(3, last_qf)\n  let qstack = []\n  for i in range(1, last_qf)\n    let qstack = add(qstack, g:Xgetlist({'nr':i, 'all':1}))\n  endfor\n  call g:Xsetlist([], 'f')\n  for i in range(len(qstack))\n    call g:Xsetlist([], ' ', qstack[i])\n  endfor\n  call assert_equal(3, g:Xgetlist({'nr':'$'}).nr)\n  call assert_equal(10, g:Xgetlist({'nr':1, 'items':1}).items[0].lnum)\n  call assert_equal(20, g:Xgetlist({'nr':2, 'items':1}).items[0].lnum)\n  call assert_equal(30, g:Xgetlist({'nr':3, 'items':1}).items[0].lnum)\n  call g:Xsetlist([], 'f')\n\n  \" Swap two quickfix lists\n  Xexpr \"File1:10:Line10\"\n  Xexpr \"File2:20:Line20\"\n  Xexpr \"File3:30:Line30\"\n  call g:Xsetlist([], 'r', {'nr':1,'title':'Colors','context':['Colors']})\n  call g:Xsetlist([], 'r', {'nr':2,'title':'Fruits','context':['Fruits']})\n  let l1=g:Xgetlist({'nr':1,'all':1})\n  let l2=g:Xgetlist({'nr':2,'all':1})\n  let save_id = l1.id\n  let l1.id=l2.id\n  let l2.id=save_id\n  call g:Xsetlist([], 'r', l1)\n  call g:Xsetlist([], 'r', l2)\n  let newl1=g:Xgetlist({'nr':1,'all':1})\n  let newl2=g:Xgetlist({'nr':2,'all':1})\n  call assert_equal('Fruits', newl1.title)\n  call assert_equal(['Fruits'], newl1.context)\n  call assert_equal('Line20', newl1.items[0].text)\n  call assert_equal('Colors', newl2.title)\n  call assert_equal(['Colors'], newl2.context)\n  call assert_equal('Line10', newl2.items[0].text)\n  call g:Xsetlist([], 'f')\n\n  \" Cannot specify both a non-empty list argument and a dict argument\n  call assert_fails(\"call g:Xsetlist([{}], ' ', {})\", 'E475:')\nendfunc\n\nfunc Test_qf_property()\n  call Xproperty_tests('c')\n  call Xproperty_tests('l')\nendfunc\n\n\" Test for setting the current index in the location/quickfix list\nfunc Xtest_setqfidx(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xgetexpr \"F1:10:1:Line1\\nF2:20:2:Line2\\nF3:30:3:Line3\"\n  Xgetexpr \"F4:10:1:Line1\\nF5:20:2:Line2\\nF6:30:3:Line3\"\n  Xgetexpr \"F7:10:1:Line1\\nF8:20:2:Line2\\nF9:30:3:Line3\"\n\n  call g:Xsetlist([], 'a', {'nr' : 3, 'idx' : 2})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'idx' : 2})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 3})\n  Xolder 2\n  Xopen\n  call assert_equal(3, line('.'))\n  Xnewer\n  call assert_equal(2, line('.'))\n  Xnewer\n  call assert_equal(2, line('.'))\n  \" Update the current index with the quickfix window open\n  wincmd w\n  call g:Xsetlist([], 'a', {'nr' : 3, 'idx' : 3})\n  Xopen\n  call assert_equal(3, line('.'))\n  Xclose\n\n  \" Set the current index to the last entry\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : '$'})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  \" A large value should set the index to the last index\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 1})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 999})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  \" Invalid index values\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : -1})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 0})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 'xx'})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  call assert_fails(\"call g:Xsetlist([], 'a', {'nr':1, 'idx':[]})\", 'E745:')\n\n  call g:Xsetlist([], 'f')\n  new | only\nendfunc\n\nfunc Test_setqfidx()\n  call Xtest_setqfidx('c')\n  call Xtest_setqfidx('l')\nendfunc\n\n\" Tests for the QuickFixCmdPre/QuickFixCmdPost autocommands\nfunc QfAutoCmdHandler(loc, cmd)\n  call add(g:acmds, a:loc . a:cmd)\nendfunc\n\nfunc Test_Autocmd()\n  autocmd QuickFixCmdPre * call QfAutoCmdHandler('pre', expand('<amatch>'))\n  autocmd QuickFixCmdPost * call QfAutoCmdHandler('post', expand('<amatch>'))\n\n  let g:acmds = []\n  cexpr \"F1:10:Line 10\"\n  caddexpr \"F1:20:Line 20\"\n  cgetexpr \"F1:30:Line 30\"\n  cexpr \"\"\n  caddexpr \"\"\n  cgetexpr \"\"\n  silent! cexpr non_existing_func()\n  silent! caddexpr non_existing_func()\n  silent! cgetexpr non_existing_func()\n  let l = ['precexpr',\n\t      \\ 'postcexpr',\n\t      \\ 'precaddexpr',\n\t      \\ 'postcaddexpr',\n\t      \\ 'precgetexpr',\n\t      \\ 'postcgetexpr',\n\t      \\ 'precexpr',\n\t      \\ 'postcexpr',\n\t      \\ 'precaddexpr',\n\t      \\ 'postcaddexpr',\n\t      \\ 'precgetexpr',\n\t      \\ 'postcgetexpr',\n\t      \\ 'precexpr',\n\t      \\ 'precaddexpr',\n\t      \\ 'precgetexpr']\n  call assert_equal(l, g:acmds)\n\n  let g:acmds = []\n  enew! | call append(0, \"F2:10:Line 10\")\n  cbuffer!\n  enew! | call append(0, \"F2:20:Line 20\")\n  cgetbuffer\n  enew! | call append(0, \"F2:30:Line 30\")\n  caddbuffer\n  new\n  let bnum = bufnr('%')\n  bunload\n  exe 'silent! cbuffer! ' . bnum\n  exe 'silent! cgetbuffer ' . bnum\n  exe 'silent! caddbuffer ' . bnum\n  enew!\n  let l = ['precbuffer',\n\t      \\ 'postcbuffer',\n\t      \\ 'precgetbuffer',\n\t      \\ 'postcgetbuffer',\n\t      \\ 'precaddbuffer',\n\t      \\ 'postcaddbuffer',\n\t      \\ 'precbuffer',\n\t      \\ 'precgetbuffer',\n\t      \\ 'precaddbuffer']\n  call assert_equal(l, g:acmds)\n\n  call writefile(['Xtest:1:Line1'], 'Xtest')\n  call writefile([], 'Xempty')\n  let g:acmds = []\n  cfile Xtest\n  caddfile Xtest\n  cgetfile Xtest\n  cfile Xempty\n  caddfile Xempty\n  cgetfile Xempty\n  silent! cfile do_not_exist\n  silent! caddfile do_not_exist\n  silent! cgetfile do_not_exist\n  let l = ['precfile',\n\t      \\ 'postcfile',\n\t      \\ 'precaddfile',\n\t      \\ 'postcaddfile',\n\t      \\ 'precgetfile',\n\t      \\ 'postcgetfile',\n\t      \\ 'precfile',\n\t      \\ 'postcfile',\n\t      \\ 'precaddfile',\n\t      \\ 'postcaddfile',\n\t      \\ 'precgetfile',\n\t      \\ 'postcgetfile',\n\t      \\ 'precfile',\n\t      \\ 'postcfile',\n\t      \\ 'precaddfile',\n\t      \\ 'postcaddfile',\n\t      \\ 'precgetfile',\n\t      \\ 'postcgetfile']\n  call assert_equal(l, g:acmds)\n\n  let g:acmds = []\n  helpgrep quickfix\n  silent! helpgrep non_existing_help_topic\n  vimgrep test Xtest\n  vimgrepadd test Xtest\n  silent! vimgrep non_existing_test Xtest\n  silent! vimgrepadd non_existing_test Xtest\n  set makeprg=\n  silent! make\n  set makeprg&\n  let l = ['prehelpgrep',\n\t      \\ 'posthelpgrep',\n\t      \\ 'prehelpgrep',\n\t      \\ 'posthelpgrep',\n\t      \\ 'previmgrep',\n\t      \\ 'postvimgrep',\n\t      \\ 'previmgrepadd',\n\t      \\ 'postvimgrepadd',\n\t      \\ 'previmgrep',\n\t      \\ 'postvimgrep',\n\t      \\ 'previmgrepadd',\n\t      \\ 'postvimgrepadd',\n\t      \\ 'premake',\n\t      \\ 'postmake']\n  call assert_equal(l, g:acmds)\n\n  if has('unix')\n    \" Run this test only on Unix-like systems. The grepprg may not be set on\n    \" non-Unix systems.\n    \" The following lines are used for the grep test. Don't remove.\n    \" Grep_Autocmd_Text: Match 1\n    \" GrepAdd_Autocmd_Text: Match 2\n    let g:acmds = []\n    silent grep Grep_Autocmd_Text test_quickfix.vim\n    silent grepadd GrepAdd_Autocmd_Text test_quickfix.vim\n    silent grep abc123def Xtest\n    silent grepadd abc123def Xtest\n    set grepprg=internal\n    silent grep Grep_Autocmd_Text test_quickfix.vim\n    silent grepadd GrepAdd_Autocmd_Text test_quickfix.vim\n    silent lgrep Grep_Autocmd_Text test_quickfix.vim\n    silent lgrepadd GrepAdd_Autocmd_Text test_quickfix.vim\n    set grepprg&vim\n    let l = ['pregrep',\n\t\t\\ 'postgrep',\n\t\t\\ 'pregrepadd',\n\t\t\\ 'postgrepadd',\n\t\t\\ 'pregrep',\n\t\t\\ 'postgrep',\n\t\t\\ 'pregrepadd',\n\t\t\\ 'postgrepadd',\n\t\t\\ 'pregrep',\n\t\t\\ 'postgrep',\n\t\t\\ 'pregrepadd',\n\t\t\\ 'postgrepadd',\n\t\t\\ 'prelgrep',\n\t\t\\ 'postlgrep',\n\t\t\\ 'prelgrepadd',\n\t\t\\ 'postlgrepadd']\n    call assert_equal(l, g:acmds)\n  endif\n\n  call delete('Xtest')\n  call delete('Xempty')\n  au! QuickFixCmdPre\n  au! QuickFixCmdPost\nendfunc\n\nfunc Test_Autocmd_Exception()\n  set efm=%m\n  lgetexpr '?'\n\n  try\n    call DoesNotExit()\n  catch\n    lgetexpr '1'\n  finally\n    lgetexpr '1'\n  endtry\n\n  call assert_equal('1', getloclist(0)[0].text)\n\n  set efm&vim\nendfunc\n\nfunc Test_caddbuffer_wrong()\n  \" This used to cause a memory access in freed memory.\n  let save_efm = &efm\n  set efm=%EEEE%m,%WWWW,%+CCCC%>%#,%GGGG%.#\n  cgetexpr ['WWWW', 'EEEE', 'CCCC']\n  let &efm = save_efm\n  caddbuffer\n  bwipe!\nendfunc\n\nfunc Test_caddexpr_wrong()\n  \" This used to cause a memory access in freed memory.\n  cbuffer\n  cbuffer\n  copen\n  let save_efm = &efm\n  set efm=%\n  call assert_fails('caddexpr \"\"', 'E376:')\n  let &efm = save_efm\nendfunc\n\nfunc Test_dirstack_cleanup()\n  \" This used to cause a memory access in freed memory.\n  let save_efm = &efm\n  lexpr '0'\n  lopen\n  fun X(c)\n    let save_efm=&efm\n    set efm=%D%f\n    if a:c == 'c'\n      caddexpr '::'\n    else\n      laddexpr ':0:0'\n    endif\n    let &efm=save_efm\n  endfun\n  call X('c')\n  call X('l')\n  call setqflist([], 'r')\n  caddbuffer\n  let &efm = save_efm\nendfunc\n\n\" Tests for jumping to entries from the location list window and quickfix\n\" window\nfunc Test_cwindow_jump()\n  set efm=%f%%%l%%%m\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen | only\n  lfirst\n  call assert_true(winnr('$') == 2)\n  call assert_true(winnr() == 1)\n  \" Location list for the new window should be set\n  call assert_true(getloclist(0)[2].text == 'Line 30')\n\n  \" Open a scratch buffer\n  \" Open a new window and create a location list\n  \" Open the location list window and close the other window\n  \" Jump to an entry.\n  \" Should create a new window and jump to the entry. The scratch buffer\n  \" should not be used.\n  enew | only\n  set buftype=nofile\n  below new\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen\n  2wincmd c\n  lnext\n  call assert_true(winnr('$') == 3)\n  call assert_true(winnr() == 2)\n\n  \" Open two windows with two different location lists\n  \" Open the location list window and close the previous window\n  \" Jump to an entry in the location list window\n  \" Should open the file in the first window and not set the location list.\n  enew | only\n  lgetexpr [\"F1%5%Line 5\"]\n  below new\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen\n  2wincmd c\n  lnext\n  call assert_true(winnr() == 1)\n  call assert_true(getloclist(0)[0].text == 'Line 5')\n\n  enew | only\n  cgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  copen\n  cnext\n  call assert_true(winnr('$') == 2)\n  call assert_true(winnr() == 1)\n\n  \" open the quickfix buffer in two windows and jump to an entry. Should open\n  \" the file in the first quickfix window.\n  enew | only\n  copen\n  let bnum = bufnr('')\n  exe 'sbuffer ' . bnum\n  wincmd b\n  cfirst\n  call assert_equal(2, winnr())\n  call assert_equal('F1', @%)\n  enew | only\n  exe 'sb' bnum\n  exe 'botright sb' bnum\n  wincmd t\n  clast\n  call assert_equal(2, winnr())\n  call assert_equal('quickfix', getwinvar(1, '&buftype'))\n  call assert_equal('quickfix', getwinvar(3, '&buftype'))\n\n  \" Jumping to a file from the location list window should find a usable\n  \" window by wrapping around the window list.\n  enew | only\n  call setloclist(0, [], 'f')\n  new | new\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen\n  1close\n  call assert_equal(0, getloclist(3, {'id' : 0}).id)\n  lnext\n  call assert_equal(3, winnr())\n  call assert_equal(getloclist(1, {'id' : 0}).id, getloclist(3, {'id' : 0}).id)\n\n  enew | only\n  set efm&vim\nendfunc\n\nfunc Test_cwindow_highlight()\n  CheckScreendump\n\n  let lines =<< trim END\n\tcall setline(1, ['some', 'text', 'with', 'matches'])\n\twrite XCwindow\n\tvimgrep e XCwindow\n\tredraw\n\tcwindow 4\n  END\n  call writefile(lines, 'XtestCwindow')\n  let buf = RunVimInTerminal('-S XtestCwindow', #{rows: 12})\n  call VerifyScreenDump(buf, 'Test_quickfix_cwindow_1', {})\n\n  call term_sendkeys(buf, \":cnext\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_quickfix_cwindow_2', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XtestCwindow')\n  call delete('XCwindow')\nendfunc\n\nfunc XvimgrepTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call writefile(['Editor:VIM vim',\n\t      \\ 'Editor:Emacs EmAcS',\n\t      \\ 'Editor:Notepad NOTEPAD'], 'Xtestfile1')\n  call writefile(['Linux', 'macOS', 'MS-Windows'], 'Xtestfile2')\n\n  \" Error cases\n  call assert_fails('Xvimgrep /abc *', 'E682:')\n\n  let @/=''\n  call assert_fails('Xvimgrep // *', 'E35:')\n\n  call assert_fails('Xvimgrep abc', 'E683:')\n  call assert_fails('Xvimgrep a1b2c3 Xtestfile1', 'E480:')\n  call assert_fails('Xvimgrep pat Xa1b2c3', 'E480:')\n\n  Xexpr \"\"\n  Xvimgrepadd Notepad Xtestfile1\n  Xvimgrepadd macOS Xtestfile2\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal('Editor:Notepad NOTEPAD', l[0].text)\n\n  10Xvimgrep #\\cvim#g Xtestfile?\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal(8, l[0].col)\n  call assert_equal(11, l[0].end_col)\n  call assert_equal(12, l[1].col)\n  call assert_equal(15, l[1].end_col)\n\n  1Xvimgrep ?Editor? Xtestfile*\n  let l = g:Xgetlist()\n  call assert_equal(1, len(l))\n  call assert_equal('Editor:VIM vim', l[0].text)\n\n  edit +3 Xtestfile2\n  Xvimgrep +\\cemacs+j Xtestfile1\n  let l = g:Xgetlist()\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal('Editor:Emacs EmAcS', l[0].text)\n\n  \" Test for unloading a buffer after vimgrep searched the buffer\n  %bwipe\n  Xvimgrep /Editor/j Xtestfile*\n  call assert_equal(0, getbufinfo('Xtestfile1')[0].loaded)\n  call assert_equal([], getbufinfo('Xtestfile2'))\n\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\n\" Tests for the :vimgrep command\nfunc Test_vimgrep()\n  call XvimgrepTests('c')\n  call XvimgrepTests('l')\nendfunc\n\nfunc Test_vimgrep_wildcards_expanded_once()\n  new X[id-01] file.txt\n  call setline(1, 'some text to search for')\n  vimgrep text %\n  bwipe!\nendfunc\n\n\" Test for incsearch highlighting of the :vimgrep pattern\n\" This test used to cause \"E315: ml_get: invalid lnum\" errors.\nfunc Test_vimgrep_incsearch()\n  enew\n  set incsearch\n  call test_override(\"char_avail\", 1)\n\n  call feedkeys(\":2vimgrep assert test_quickfix.vim test_cdo.vim\\<CR>\", \"ntx\")\n  let l = getqflist()\n  call assert_equal(2, len(l))\n\n  call test_override(\"ALL\", 0)\n  set noincsearch\nendfunc\n\n\" Test vimgrep with the last search pattern not set\nfunc Test_vimgrep_with_no_last_search_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails('vimgrep // *', 'E35:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test vimgrep without swap file\nfunc Test_vimgrep_without_swap_file()\n  let lines =<< trim [SCRIPT]\n    vimgrep grep test_c*\n    call writefile(['done'], 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -n -S Xscript Xscript')\n    call assert_equal(['done'], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\nfunc Test_vimgrep_existing_swapfile()\n  call writefile(['match apple with apple'], 'Xapple')\n  call writefile(['swapfile'], '.Xapple.swp')\n  let g:foundSwap = 0\n  let g:ignoreSwapExists = 1\n  augroup grep\n    au SwapExists * let foundSwap = 1 | let v:swapchoice = 'e'\n  augroup END\n  vimgrep apple Xapple\n  call assert_equal(1, g:foundSwap)\n  call assert_match('.Xapple.swo', swapname(''))\n\n  call delete('Xapple')\n  call delete('.Xapple.swp')\n  augroup grep\n    au! SwapExists\n  augroup END\n  unlet g:ignoreSwapExists\nendfunc\n\nfunc XfreeTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  enew | only\n\n  \" Deleting the quickfix stack should work even When the current list is\n  \" somewhere in the middle of the stack\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']\n  Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']\n  Xolder\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, len(g:Xgetlist()))\n\n  \" After deleting the stack, adding a new list should create a stack with a\n  \" single list.\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  call assert_equal(1, g:Xgetlist({'all':1}).nr)\n\n  \" Deleting the stack from a quickfix window should update/clear the\n  \" quickfix/location list window.\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']\n  Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']\n  Xolder\n  Xwindow\n  call g:Xsetlist([], 'f')\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, line('$'))\n  Xclose\n\n  \" Deleting the stack from a non-quickfix window should update/clear the\n  \" quickfix/location list window.\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']\n  Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']\n  Xolder\n  Xwindow\n  wincmd p\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, len(g:Xgetlist()))\n  wincmd p\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, line('$'))\n\n  \" After deleting the location list stack, if the location list window is\n  \" opened, then a new location list should be created. So opening the\n  \" location list window again should not create a new window.\n  if a:cchar == 'l'\n      lexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n      wincmd p\n      lopen\n      call assert_equal(2, winnr('$'))\n  endif\n  Xclose\nendfunc\n\n\" Tests for the quickfix free functionality\nfunc Test_qf_free()\n  call XfreeTests('c')\n  call XfreeTests('l')\nendfunc\n\n\" Test for buffer overflow when parsing lines and adding new entries to\n\" the quickfix list.\nfunc Test_bufoverflow()\n  set efm=%f:%l:%m\n  cgetexpr ['File1:100:' . repeat('x', 1025)]\n\n  set efm=%+GCompiler:\\ %.%#,%f:%l:%m\n  cgetexpr ['Compiler: ' . repeat('a', 1015), 'File1:10:Hello World']\n\n  set efm=%DEntering\\ directory\\ %f,%f:%l:%m\n  cgetexpr ['Entering directory ' . repeat('a', 1006),\n\t      \\ 'File1:10:Hello World']\n  set efm&vim\nendfunc\n\n\" Tests for getting the quickfix stack size\nfunc XsizeTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'nr':'$'}).nr)\n  call assert_equal('', g:Xgetlist({'nr':'$', 'all':1}).title)\n  call assert_equal(0, g:Xgetlist({'nr':0}).nr)\n\n  Xexpr \"File1:10:Line1\"\n  Xexpr \"File2:20:Line2\"\n  Xexpr \"File3:30:Line3\"\n  Xolder | Xolder\n  call assert_equal(3, g:Xgetlist({'nr':'$'}).nr)\n  call g:Xsetlist([], 'f')\n\n  Xexpr \"File1:10:Line1\"\n  Xexpr \"File2:20:Line2\"\n  Xexpr \"File3:30:Line3\"\n  Xolder | Xolder\n  call g:Xsetlist([], 'a', {'nr':'$', 'title':'Compiler'})\n  call assert_equal('Compiler', g:Xgetlist({'nr':3, 'all':1}).title)\nendfunc\n\nfunc Test_Qf_Size()\n  call XsizeTests('c')\n  call XsizeTests('l')\nendfunc\n\nfunc Test_cclose_from_copen()\n    augroup QF_Test\n\tau!\n        au FileType qf :call assert_fails(':cclose', 'E788:')\n    augroup END\n    copen\n    augroup QF_Test\n\tau!\n    augroup END\n    augroup! QF_Test\nendfunc\n\nfunc Test_cclose_in_autocmd()\n  \" Problem is only triggered if \"starting\" is zero, so that the OptionsSet\n  \" event will be triggered.\n  call test_override('starting', 1)\n  augroup QF_Test\n    au!\n    au FileType qf :call assert_fails(':cclose', 'E788:')\n  augroup END\n  copen\n  augroup QF_Test\n    au!\n  augroup END\n  augroup! QF_Test\n  call test_override('starting', 0)\nendfunc\n\n\" Check that \":file\" without an argument is possible even when \"curbuf_lock\"\n\" is set.\nfunc Test_file_from_copen()\n  \" Works without argument.\n  augroup QF_Test\n    au!\n    au FileType qf file\n  augroup END\n  copen\n\n  augroup QF_Test\n    au!\n  augroup END\n  cclose\n\n  \" Fails with argument.\n  augroup QF_Test\n    au!\n    au FileType qf call assert_fails(':file foo', 'E788:')\n  augroup END\n  copen\n  augroup QF_Test\n    au!\n  augroup END\n  cclose\n\n  augroup! QF_Test\nendfunc\n\nfunc Test_resize_from_copen()\n  augroup QF_Test\n    au!\n    au FileType qf resize 5\n  augroup END\n  try\n    \" This should succeed without any exception.  No other buffers are\n    \" involved in the autocmd.\n    copen\n  finally\n    augroup QF_Test\n      au!\n    augroup END\n    augroup! QF_Test\n  endtry\nendfunc\n\nfunc Test_vimgrep_with_textlock()\n  new\n\n  \" Simple way to execute something with \"textwinlock\" set.\n  \" Check that vimgrep without jumping can be executed.\n  au InsertCharPre * vimgrep /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getqflist()\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setqflist([], 'r')\n  au! InsertCharPre\n\n  \" Check that vimgrepadd without jumping can be executed.\n  au InsertCharPre * vimgrepadd /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getqflist()\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setqflist([], 'r')\n  au! InsertCharPre\n\n  \" Check that lvimgrep without jumping can be executed.\n  au InsertCharPre * lvimgrep /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getloclist(0)\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setloclist(0, [], 'r')\n  au! InsertCharPre\n\n  \" Check that lvimgrepadd without jumping can be executed.\n  au InsertCharPre * lvimgrepadd /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getloclist(0)\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setloclist(0, [], 'r')\n  au! InsertCharPre\n\n  \" trying to jump will give an error\n  au InsertCharPre * vimgrep /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  au InsertCharPre * vimgrepadd /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  au InsertCharPre * lvimgrep /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  au InsertCharPre * lvimgrepadd /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  bwipe!\nendfunc\n\n\" Tests for the quickfix buffer b:changedtick variable\nfunc Xchangedtick_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  new | only\n\n  Xexpr \"\" | Xexpr \"\" | Xexpr \"\"\n\n  Xopen\n  Xolder\n  Xolder\n  Xaddexpr \"F1:10:Line10\"\n  Xaddexpr \"F2:20:Line20\"\n  call g:Xsetlist([{\"filename\":\"F3\", \"lnum\":30, \"text\":\"Line30\"}], 'a')\n  call g:Xsetlist([], 'f')\n  call assert_equal(8, getbufvar('%', 'changedtick'))\n  Xclose\nendfunc\n\nfunc Test_changedtick()\n  call Xchangedtick_tests('c')\n  call Xchangedtick_tests('l')\nendfunc\n\n\" Tests for parsing an expression using setqflist()\nfunc Xsetexpr_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let t = [\"File1:10:Line10\", \"File1:20:Line20\"]\n  call g:Xsetlist([], ' ', {'lines' : t})\n  call g:Xsetlist([], 'a', {'lines' : [\"File1:30:Line30\"]})\n\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  call assert_equal(20, l[1].lnum)\n  call assert_equal('Line30', l[2].text)\n  call g:Xsetlist([], 'r', {'lines' : [\"File2:5:Line5\"]})\n  let l = g:Xgetlist()\n  call assert_equal(1, len(l))\n  call assert_equal('Line5', l[0].text)\n  call assert_equal(-1, g:Xsetlist([], 'a', {'lines' : 10}))\n  call assert_equal(-1, g:Xsetlist([], 'a', {'lines' : \"F1:10:L10\"}))\n\n  call g:Xsetlist([], 'f')\n  \" Add entries to multiple lists\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"File1:10:Line10\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"File2:20:Line20\"]})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"File1:15:Line15\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"File2:25:Line25\"]})\n  call assert_equal('Line15', g:Xgetlist({'nr':1, 'items':1}).items[1].text)\n  call assert_equal('Line25', g:Xgetlist({'nr':2, 'items':1}).items[1].text)\n\n  \" Adding entries using a custom efm\n  set efm&\n  call g:Xsetlist([], ' ', {'efm' : '%f#%l#%m',\n\t\t\t\t\\ 'lines' : [\"F1#10#L10\", \"F2#20#L20\"]})\n  call assert_equal(20, g:Xgetlist({'items':1}).items[1].lnum)\n  call g:Xsetlist([], 'a', {'efm' : '%f#%l#%m', 'lines' : [\"F3:30:L30\"]})\n  call assert_equal('F3:30:L30', g:Xgetlist({'items':1}).items[2].text)\n  call assert_equal(20, g:Xgetlist({'items':1}).items[1].lnum)\n  call assert_equal(-1, g:Xsetlist([], 'a', {'efm' : [],\n\t\t\t\t\\ 'lines' : ['F1:10:L10']}))\nendfunc\n\nfunc Test_setexpr()\n  call Xsetexpr_tests('c')\n  call Xsetexpr_tests('l')\nendfunc\n\n\" Tests for per quickfix/location list directory stack\nfunc Xmultidirstack_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  Xexpr \"\" | Xexpr \"\"\n\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"Entering dir 'Xone/a'\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"Entering dir 'Xtwo/a'\"]})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"one.txt:3:one one one\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"two.txt:5:two two two\"]})\n\n  let l1 = g:Xgetlist({'nr':1, 'items':1})\n  let l2 = g:Xgetlist({'nr':2, 'items':1})\n  call assert_equal('Xone/a/one.txt', bufname(l1.items[1].bufnr))\n  call assert_equal(3, l1.items[1].lnum)\n  call assert_equal('Xtwo/a/two.txt', bufname(l2.items[1].bufnr))\n  call assert_equal(5, l2.items[1].lnum)\nendfunc\n\nfunc Test_multidirstack()\n  call mkdir('Xone/a', 'p')\n  call mkdir('Xtwo/a', 'p')\n  let lines = ['1', '2', 'one one one', '4', 'two two two', '6', '7']\n  call writefile(lines, 'Xone/a/one.txt')\n  call writefile(lines, 'Xtwo/a/two.txt')\n  let save_efm = &efm\n  set efm=%DEntering\\ dir\\ '%f',%f:%l:%m,%XLeaving\\ dir\\ '%f'\n\n  call Xmultidirstack_tests('c')\n  call Xmultidirstack_tests('l')\n\n  let &efm = save_efm\n  call delete('Xone', 'rf')\n  call delete('Xtwo', 'rf')\nendfunc\n\n\" Tests for per quickfix/location list file stack\nfunc Xmultifilestack_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  Xexpr \"\" | Xexpr \"\"\n\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"[one.txt]\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"[two.txt]\"]})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"(3,5) one one one\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"(5,9) two two two\"]})\n\n  let l1 = g:Xgetlist({'nr':1, 'items':1})\n  let l2 = g:Xgetlist({'nr':2, 'items':1})\n  call assert_equal('one.txt', bufname(l1.items[1].bufnr))\n  call assert_equal(3, l1.items[1].lnum)\n  call assert_equal('two.txt', bufname(l2.items[1].bufnr))\n  call assert_equal(5, l2.items[1].lnum)\n\n  \" Test for start of a new error line in the same line where a previous\n  \" error line ends with a file stack.\n  let efm_val = 'Error\\ l%l\\ in\\ %f,'\n  let efm_val .= '%-P%>(%f%r,Error\\ l%l\\ in\\ %m,%-Q)%r'\n  let l = g:Xgetlist({'lines' : [\n\t      \\ '(one.txt',\n\t      \\ 'Error l4 in one.txt',\n\t      \\ ') (two.txt',\n\t      \\ 'Error l6 in two.txt',\n\t      \\ ')',\n\t      \\ 'Error l8 in one.txt'\n\t      \\ ], 'efm' : efm_val})\n  call assert_equal(3, len(l.items))\n  call assert_equal('one.txt', bufname(l.items[0].bufnr))\n  call assert_equal(4, l.items[0].lnum)\n  call assert_equal('one.txt', l.items[0].text)\n  call assert_equal('two.txt', bufname(l.items[1].bufnr))\n  call assert_equal(6, l.items[1].lnum)\n  call assert_equal('two.txt', l.items[1].text)\n  call assert_equal('one.txt', bufname(l.items[2].bufnr))\n  call assert_equal(8, l.items[2].lnum)\n  call assert_equal('', l.items[2].text)\nendfunc\n\nfunc Test_multifilestack()\n  let lines = ['1', '2', 'one one one', '4', 'two two two', '6', '7']\n  call writefile(lines, 'one.txt')\n  call writefile(lines, 'two.txt')\n  let save_efm = &efm\n  set efm=%+P[%f],(%l\\\\,%c)\\ %m,%-Q\n\n  call Xmultifilestack_tests('c')\n  call Xmultifilestack_tests('l')\n\n  let &efm = save_efm\n  call delete('one.txt')\n  call delete('two.txt')\nendfunc\n\n\" Tests for per buffer 'efm' setting\nfunc Test_perbuf_efm()\n  call writefile([\"File1-10-Line10\"], 'one.txt')\n  call writefile([\"File2#20#Line20\"], 'two.txt')\n  set efm=%f#%l#%m\n  new | only\n  new\n  setlocal efm=%f-%l-%m\n  cfile one.txt\n  wincmd w\n  caddfile two.txt\n\n  let l = getqflist()\n  call assert_equal(10, l[0].lnum)\n  call assert_equal('Line20', l[1].text)\n\n  set efm&\n  new | only\n  call delete('one.txt')\n  call delete('two.txt')\nendfunc\n\n\" Open multiple help windows using \":lhelpgrep\n\" This test used to crash Vim\nfunc Test_Multi_LL_Help()\n  new | only\n  lhelpgrep window\n  lopen\n  e#\n  lhelpgrep buffer\n  call assert_equal(3, winnr('$'))\n  call assert_true(len(getloclist(1)) != 0)\n  call assert_true(len(getloclist(2)) != 0)\n  new | only\nendfunc\n\n\" Tests for adding new quickfix lists using setqflist()\nfunc XaddQf_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Create a new list using ' ' for action\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], ' ', {'title' : 'Test1'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test1', l.title)\n\n  \" Create a new list using ' ' for action and '$' for 'nr'\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], ' ', {'title' : 'Test2', 'nr' : '$'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test2', l.title)\n\n  \" Create a new list using 'a' for action\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], 'a', {'title' : 'Test3'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test3', l.title)\n\n  \" Create a new list using 'a' for action and '$' for 'nr'\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], 'a', {'title' : 'Test3', 'nr' : '$'})\n  call g:Xsetlist([], 'a', {'title' : 'Test4'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test4', l.title)\n\n  \" Adding a quickfix list should remove all the lists following the current\n  \" list.\n  Xexpr \"\" | Xexpr \"\" | Xexpr \"\"\n  silent! 10Xolder\n  call g:Xsetlist([], ' ', {'title' : 'Test5'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(2, l.nr)\n  call assert_equal('Test5', l.title)\n\n  \" Add a quickfix list using '$' as the list number.\n  let lastqf = g:Xgetlist({'nr':'$'}).nr\n  silent! 99Xolder\n  call g:Xsetlist([], ' ', {'nr' : '$', 'title' : 'Test6'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(lastqf + 1, l.nr)\n  call assert_equal('Test6', l.title)\n\n  \" Add a quickfix list using 'nr' set to one more than the quickfix\n  \" list size.\n  let lastqf = g:Xgetlist({'nr':'$'}).nr\n  silent! 99Xolder\n  call g:Xsetlist([], ' ', {'nr' : lastqf + 1, 'title' : 'Test7'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(lastqf + 1, l.nr)\n  call assert_equal('Test7', l.title)\n\n  \" Add a quickfix list to a stack with 10 lists using 'nr' set to '$'\n  exe repeat('Xexpr \"\" |', 9) . 'Xexpr \"\"'\n  silent! 99Xolder\n  call g:Xsetlist([], ' ', {'nr' : '$', 'title' : 'Test8'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(10, l.nr)\n  call assert_equal('Test8', l.title)\n\n  \" Add a quickfix list using 'nr' set to a value greater than 10\n  call assert_equal(-1, g:Xsetlist([], ' ', {'nr' : 12, 'title' : 'Test9'}))\n\n  \" Try adding a quickfix list with 'nr' set to a value greater than the\n  \" quickfix list size but less than 10.\n  call g:Xsetlist([], 'f')\n  Xexpr \"\" | Xexpr \"\" | Xexpr \"\"\n  silent! 99Xolder\n  call assert_equal(-1, g:Xsetlist([], ' ', {'nr' : 8, 'title' : 'Test10'}))\n\n  \" Add a quickfix list using 'nr' set to a some string or list\n  call assert_equal(-1, g:Xsetlist([], ' ', {'nr' : [1,2], 'title' : 'Test11'}))\nendfunc\n\nfunc Test_add_qf()\n  call XaddQf_tests('c')\n  call XaddQf_tests('l')\nendfunc\n\n\" Test for getting the quickfix list items from some text without modifying\n\" the quickfix stack\nfunc XgetListFromLines(cchar)\n  call s:setup_commands(a:cchar)\n  call g:Xsetlist([], 'f')\n\n  let l = g:Xgetlist({'lines' : [\"File2:20:Line20\", \"File2:30:Line30\"]}).items\n  call assert_equal(2, len(l))\n  call assert_equal(30, l[1].lnum)\n\n  call assert_equal({}, g:Xgetlist({'lines' : 10}))\n  call assert_equal({}, g:Xgetlist({'lines' : 'File1:10:Line10'}))\n  call assert_equal([], g:Xgetlist({'lines' : []}).items)\n  call assert_equal([], g:Xgetlist({'lines' : [10, 20]}).items)\n\n  \" Parse text using a custom efm\n  set efm&\n  let l = g:Xgetlist({'lines':['File3#30#Line30'], 'efm' : '%f#%l#%m'}).items\n  call assert_equal('Line30', l[0].text)\n  let l = g:Xgetlist({'lines':['File3:30:Line30'], 'efm' : '%f-%l-%m'}).items\n  call assert_equal('File3:30:Line30', l[0].text)\n  let l = g:Xgetlist({'lines':['File3:30:Line30'], 'efm' : [1,2]})\n  call assert_equal({}, l)\n  call assert_fails(\"call g:Xgetlist({'lines':['abc'], 'efm':'%2'})\", 'E376:')\n  call assert_fails(\"call g:Xgetlist({'lines':['abc'], 'efm':''})\", 'E378:')\n\n  \" Make sure that the quickfix stack is not modified\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\nendfunc\n\nfunc Test_get_list_from_lines()\n  call XgetListFromLines('c')\n  call XgetListFromLines('l')\nendfunc\n\n\" Tests for the quickfix list id\nfunc Xqfid_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'id':0}).id)\n  Xexpr ''\n  let start_id = g:Xgetlist({'id' : 0}).id\n  Xexpr '' | Xexpr ''\n  Xolder\n  call assert_equal(start_id, g:Xgetlist({'id':0, 'nr':1}).id)\n  call assert_equal(start_id + 1, g:Xgetlist({'id':0, 'nr':0}).id)\n  call assert_equal(start_id + 2, g:Xgetlist({'id':0, 'nr':'$'}).id)\n  call assert_equal(0, g:Xgetlist({'id':0, 'nr':99}).id)\n  call assert_equal(2, g:Xgetlist({'id':start_id + 1, 'nr':0}).nr)\n  call assert_equal(0, g:Xgetlist({'id':99, 'nr':0}).id)\n  call assert_equal(0, g:Xgetlist({'id':\"abc\", 'nr':0}).id)\n\n  call g:Xsetlist([], 'a', {'id':start_id, 'context':[1,2]})\n  call assert_equal([1,2], g:Xgetlist({'nr':1, 'context':1}).context)\n  call g:Xsetlist([], 'a', {'id':start_id+1, 'lines':['F1:10:L10']})\n  call assert_equal('L10', g:Xgetlist({'nr':2, 'items':1}).items[0].text)\n  call assert_equal(-1, g:Xsetlist([], 'a', {'id':999, 'title':'Vim'}))\n  call assert_equal(-1, g:Xsetlist([], 'a', {'id':'abc', 'title':'Vim'}))\n\n  let qfid = g:Xgetlist({'id':0, 'nr':0})\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'id':qfid, 'nr':0}).id)\nendfunc\n\nfunc Test_qf_id()\n  call Xqfid_tests('c')\n  call Xqfid_tests('l')\nendfunc\n\nfunc Xqfjump_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call writefile([\"Line1\\tFoo\", \"Line2\"], 'F1')\n  call writefile([\"Line1\\tBar\", \"Line2\"], 'F2')\n  call writefile([\"Line1\\tBaz\", \"Line2\"], 'F3')\n\n  call g:Xsetlist([], 'f')\n\n  \" Tests for\n  \"   Jumping to a line using a pattern\n  \"   Jumping to a column greater than the last column in a line\n  \"   Jumping to a line greater than the last line in the file\n  let l = []\n  for i in range(1, 7)\n    call add(l, {})\n  endfor\n  let l[0].filename='F1'\n  let l[0].pattern='Line1'\n  let l[1].filename='F2'\n  let l[1].pattern='Line1'\n  let l[2].filename='F3'\n  let l[2].pattern='Line1'\n  let l[3].filename='F3'\n  let l[3].lnum=1\n  let l[3].col=9\n  let l[3].vcol=1\n  let l[4].filename='F3'\n  let l[4].lnum=99\n  let l[5].filename='F3'\n  let l[5].lnum=1\n  let l[5].col=99\n  let l[5].vcol=1\n  let l[6].filename='F3'\n  let l[6].pattern='abcxyz'\n\n  call g:Xsetlist([], ' ', {'items' : l})\n  Xopen | only\n  2Xnext\n  call assert_equal(3, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal('F3', @%)\n  Xnext\n  call assert_equal(7, col('.'))\n  Xnext\n  call assert_equal(2, line('.'))\n  Xnext\n  call assert_equal(9, col('.'))\n  2\n  Xnext\n  call assert_equal(2, line('.'))\n\n  if a:cchar == 'l'\n    \" When jumping to a location list entry in the location list window and\n    \" no usable windows are available, then a new window should be opened.\n    enew! | new | only\n    call g:Xsetlist([], 'f')\n    setlocal buftype=nofile\n    new\n    call g:Xsetlist([], ' ', {'lines' : ['F1:1:1:Line1', 'F1:2:2:Line2', 'F2:1:1:Line1', 'F2:2:2:Line2', 'F3:1:1:Line1', 'F3:2:2:Line2']})\n    Xopen\n    let winid = win_getid()\n    wincmd p\n    close\n    call win_gotoid(winid)\n    Xnext\n    call assert_equal(3, winnr('$'))\n    call assert_equal(1, winnr())\n    call assert_equal(2, line('.'))\n\n    \" When jumping to an entry in the location list window and the window\n    \" associated with the location list is not present and a window containing\n    \" the file is already present, then that window should be used.\n    close\n    belowright new\n    call g:Xsetlist([], 'f')\n    edit F3\n    call win_gotoid(winid)\n    Xlast\n    call assert_equal(3, winnr())\n    call assert_equal(6, g:Xgetlist({'size' : 1}).size)\n    call assert_equal(winid, g:Xgetlist({'winid' : 1}).winid)\n  endif\n\n  \" Cleanup\n  enew!\n  new | only\n\n  call delete('F1')\n  call delete('F2')\n  call delete('F3')\nendfunc\n\nfunc Test_qfjump()\n  call Xqfjump_tests('c')\n  call Xqfjump_tests('l')\nendfunc\n\n\" Tests for the getqflist() and getloclist() functions when the list is not\n\" present or is empty\nfunc Xgetlist_empty_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Empty quickfix stack\n  call g:Xsetlist([], 'f')\n  call assert_equal('', g:Xgetlist({'context' : 0}).context)\n  call assert_equal(0, g:Xgetlist({'id' : 0}).id)\n  call assert_equal(0, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'items' : 0}).items)\n  call assert_equal(0, g:Xgetlist({'nr' : 0}).nr)\n  call assert_equal(0, g:Xgetlist({'size' : 0}).size)\n  call assert_equal('', g:Xgetlist({'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'winid' : 0}).winid)\n  call assert_equal(0, g:Xgetlist({'changedtick' : 0}).changedtick)\n  if a:cchar == 'c'\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0,\n\t\t  \\ 'items' : [], 'nr' : 0, 'size' : 0, 'qfbufnr' : 0,\n\t\t  \\ 'title' : '', 'winid' : 0, 'changedtick': 0,\n                  \\ 'quickfixtextfunc' : ''}, g:Xgetlist({'all' : 0}))\n  else\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0,\n\t\t\\ 'items' : [], 'nr' : 0, 'size' : 0, 'title' : '',\n\t\t\\ 'winid' : 0, 'changedtick': 0, 'filewinid' : 0,\n\t\t\\ 'qfbufnr' : 0, 'quickfixtextfunc' : ''},\n\t\t\\ g:Xgetlist({'all' : 0}))\n  endif\n\n  \" Quickfix window with empty stack\n  silent! Xopen\n  let qfwinid = (a:cchar == 'c') ? win_getid() : 0\n  let qfbufnr = (a:cchar == 'c') ? bufnr('') : 0\n  call assert_equal(qfwinid, g:Xgetlist({'winid' : 0}).winid)\n  Xclose\n\n  \" Empty quickfix list\n  Xexpr \"\"\n  call assert_equal('', g:Xgetlist({'context' : 0}).context)\n  call assert_notequal(0, g:Xgetlist({'id' : 0}).id)\n  call assert_equal(0, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'items' : 0}).items)\n  call assert_notequal(0, g:Xgetlist({'nr' : 0}).nr)\n  call assert_equal(0, g:Xgetlist({'size' : 0}).size)\n  call assert_notequal('', g:Xgetlist({'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'winid' : 0}).winid)\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  let qfid = g:Xgetlist({'id' : 0}).id\n  call g:Xsetlist([], 'f')\n\n  \" Non-existing quickfix identifier\n  call assert_equal('', g:Xgetlist({'id' : qfid, 'context' : 0}).context)\n  call assert_equal(0, g:Xgetlist({'id' : qfid}).id)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'id' : qfid, 'items' : 0}).items)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'nr' : 0}).nr)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'size' : 0}).size)\n  call assert_equal('', g:Xgetlist({'id' : qfid, 'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'winid' : 0}).winid)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'changedtick' : 0}).changedtick)\n  if a:cchar == 'c'\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'qfbufnr' : qfbufnr, 'quickfixtextfunc' : '',\n\t\t\\ 'changedtick' : 0}, g:Xgetlist({'id' : qfid, 'all' : 0}))\n  else\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'changedtick' : 0, 'filewinid' : 0, 'qfbufnr' : 0,\n                \\ 'quickfixtextfunc' : ''},\n\t\t\\ g:Xgetlist({'id' : qfid, 'all' : 0}))\n  endif\n\n  \" Non-existing quickfix list number\n  call assert_equal('', g:Xgetlist({'nr' : 5, 'context' : 0}).context)\n  call assert_equal(0, g:Xgetlist({'nr' : 5}).nr)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'nr' : 5, 'items' : 0}).items)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'id' : 0}).id)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'size' : 0}).size)\n  call assert_equal('', g:Xgetlist({'nr' : 5, 'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'winid' : 0}).winid)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'changedtick' : 0}).changedtick)\n  if a:cchar == 'c'\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'changedtick' : 0, 'qfbufnr' : qfbufnr,\n                \\ 'quickfixtextfunc' : ''}, g:Xgetlist({'nr' : 5, 'all' : 0}))\n  else\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'changedtick' : 0, 'filewinid' : 0, 'qfbufnr' : 0,\n                \\ 'quickfixtextfunc' : ''}, g:Xgetlist({'nr' : 5, 'all' : 0}))\n  endif\nendfunc\n\nfunc Test_getqflist()\n  call Xgetlist_empty_tests('c')\n  call Xgetlist_empty_tests('l')\nendfunc\n\nfunc Test_getqflist_invalid_nr()\n  \" The following commands used to crash Vim\n  cexpr \"\"\n  call getqflist({'nr' : $XXX_DOES_NOT_EXIST_XXX})\n\n  \" Cleanup\n  call setqflist([], 'r')\nendfunc\n\n\" Tests for the quickfix/location list changedtick\nfunc Xqftick_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n\n  Xexpr \"F1:10:Line10\"\n  let qfid = g:Xgetlist({'id' : 0}).id\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  Xaddexpr \"F2:20:Line20\\nF2:21:Line21\"\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([], 'a', {'lines' : [\"F3:30:Line30\", \"F3:31:Line31\"]})\n  call assert_equal(3, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([], 'r', {'lines' : [\"F4:40:Line40\"]})\n  call assert_equal(4, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([], 'a', {'title' : 'New Title'})\n  call assert_equal(5, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  enew!\n  call append(0, [\"F5:50:L50\", \"F6:60:L60\"])\n  Xaddbuffer\n  call assert_equal(6, g:Xgetlist({'changedtick' : 0}).changedtick)\n  enew!\n\n  call g:Xsetlist([], 'a', {'context' : {'bus' : 'pci'}})\n  call assert_equal(7, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([{'filename' : 'F7', 'lnum' : 10, 'text' : 'L7'},\n\t      \\ {'filename' : 'F7', 'lnum' : 11, 'text' : 'L11'}], 'a')\n  call assert_equal(8, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([{'filename' : 'F7', 'lnum' : 10, 'text' : 'L7'},\n\t      \\ {'filename' : 'F7', 'lnum' : 11, 'text' : 'L11'}], ' ')\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([{'filename' : 'F7', 'lnum' : 10, 'text' : 'L7'},\n\t      \\ {'filename' : 'F7', 'lnum' : 11, 'text' : 'L11'}], 'r')\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  call writefile([\"F8:80:L80\", \"F8:81:L81\"], \"Xone\")\n  Xfile Xone\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  Xaddfile Xone\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  \" Test case for updating a non-current quickfix list\n  call g:Xsetlist([], 'f')\n  Xexpr \"F1:1:L1\"\n  Xexpr \"F2:2:L2\"\n  call g:Xsetlist([], 'a', {'nr' : 1, \"lines\" : [\"F10:10:L10\"]})\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call assert_equal(2, g:Xgetlist({'nr' : 1, 'changedtick' : 0}).changedtick)\n\n  call delete(\"Xone\")\nendfunc\n\nfunc Test_qf_tick()\n  call Xqftick_tests('c')\n  call Xqftick_tests('l')\nendfunc\n\n\" Test helpgrep with lang specifier\nfunc Xtest_helpgrep_with_lang_specifier(cchar)\n  call s:setup_commands(a:cchar)\n  Xhelpgrep Vim@en\n  call assert_equal('help', &filetype)\n  call assert_notequal(0, g:Xgetlist({'nr' : '$'}).nr)\n  new | only\nendfunc\n\nfunc Test_helpgrep_with_lang_specifier()\n  call Xtest_helpgrep_with_lang_specifier('c')\n  call Xtest_helpgrep_with_lang_specifier('l')\nendfunc\n\n\" The following test used to crash Vim.\n\" Open the location list window and close the regular window associated with\n\" the location list. When the garbage collection runs now, it incorrectly\n\" marks the location list context as not in use and frees the context.\nfunc Test_ll_window_ctx()\n  call setloclist(0, [], 'f')\n  call setloclist(0, [], 'a', {'context' : []})\n  lopen | only\n  call test_garbagecollect_now()\n  echo getloclist(0, {'context' : 1}).context\n  enew | only\nendfunc\n\n\" The following test used to crash vim\nfunc Test_lfile_crash()\n  sp Xtest\n  au QuickFixCmdPre * bw\n  call assert_fails('lfile', 'E40:')\n  au! QuickFixCmdPre\nendfunc\n\n\" The following test used to crash vim\nfunc Test_lbuffer_crash()\n  sv Xtest\n  augroup QF_Test\n    au!\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * bw\n  augroup END\n  lbuffer\n  augroup QF_Test\n    au!\n  augroup END\nendfunc\n\n\" The following test used to crash vim\nfunc Test_lexpr_crash()\n  augroup QF_Test\n    au!\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * call setloclist(0, [], 'f')\n  augroup END\n  lexpr \"\"\n  augroup QF_Test\n    au!\n  augroup END\n\n  enew | only\n  augroup QF_Test\n    au!\n    au BufNew * call setloclist(0, [], 'f')\n  augroup END\n  lexpr 'x:1:x'\n  augroup QF_Test\n    au!\n  augroup END\n\n  enew | only\n  lexpr ''\n  lopen\n  augroup QF_Test\n    au!\n    au FileType * call setloclist(0, [], 'f')\n  augroup END\n  lexpr ''\n  augroup QF_Test\n    au!\n  augroup END\nendfunc\n\n\" The following test used to crash Vim\nfunc Test_lvimgrep_crash()\n  sv Xtest\n  augroup QF_Test\n    au!\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * call setloclist(0, [], 'f')\n  augroup END\n  lvimgrep quickfix test_quickfix.vim\n  augroup QF_Test\n    au!\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setloclist(0, [], 'r')\n  augroup END\n  call assert_fails('lvimgrep Test_lvimgrep_crash *', 'E926:')\n  augroup QF_Test\n    au!\n  augroup END\n\n  enew | only\nendfunc\n\nfunc Test_lvimgrep_crash2()\n  au BufNewFile x sfind\n  call assert_fails('lvimgrep x x', 'E471:')\n  call assert_fails('lvimgrep x x x', 'E471:')\n\n  au! BufNewFile\nendfunc\n\n\" Test for the position of the quickfix and location list window\nfunc Test_qfwin_pos()\n  \" Open two windows\n  new | only\n  new\n  cexpr ['F1:10:L10']\n  copen\n  \" Quickfix window should be the bottom most window\n  call assert_equal(3, winnr())\n  close\n  \" Open at the very top\n  wincmd t\n  topleft copen\n  call assert_equal(1, winnr())\n  close\n  \" open left of the current window\n  wincmd t\n  below new\n  leftabove copen\n  call assert_equal(2, winnr())\n  close\n  \" open right of the current window\n  rightbelow copen\n  call assert_equal(3, winnr())\n  close\nendfunc\n\n\" Tests for quickfix/location lists changed by autocommands when\n\" :vimgrep/:lvimgrep commands are running.\nfunc Test_vimgrep_autocmd()\n  call setqflist([], 'f')\n  call writefile(['stars'], 'Xtest1.txt')\n  call writefile(['stars'], 'Xtest2.txt')\n\n  \" Test 1:\n  \" When searching for a pattern using :vimgrep, if the quickfix list is\n  \" changed by an autocmd, the results should be added to the correct quickfix\n  \" list.\n  autocmd BufRead Xtest2.txt cexpr '' | cexpr ''\n  silent vimgrep stars Xtest*.txt\n  call assert_equal(1, getqflist({'nr' : 0}).nr)\n  call assert_equal(3, getqflist({'nr' : '$'}).nr)\n  call assert_equal('Xtest2.txt', bufname(getqflist()[1].bufnr))\n  au! BufRead Xtest2.txt\n\n  \" Test 2:\n  \" When searching for a pattern using :vimgrep, if the quickfix list is\n  \" freed, then a error should be given.\n  silent! %bwipe!\n  call setqflist([], 'f')\n  autocmd BufRead Xtest2.txt for i in range(10) | cexpr '' | endfor\n  call assert_fails('vimgrep stars Xtest*.txt', 'E925:')\n  au! BufRead Xtest2.txt\n\n  \" Test 3:\n  \" When searching for a pattern using :lvimgrep, if the location list is\n  \" freed, then the command should error out.\n  silent! %bwipe!\n  let g:save_winid = win_getid()\n  autocmd BufRead Xtest2.txt call setloclist(g:save_winid, [], 'f')\n  call assert_fails('lvimgrep stars Xtest*.txt', 'E926:')\n  au! BufRead Xtest2.txt\n\n  call delete('Xtest1.txt')\n  call delete('Xtest2.txt')\n  call setqflist([], 'f')\nendfunc\n\n\" Test for an autocmd changing the current directory when running vimgrep\nfunc Xvimgrep_autocmd_cd(cchar)\n  call s:setup_commands(a:cchar)\n\n  %bwipe\n  let save_cwd = getcwd()\n\n  augroup QF_Test\n    au!\n    autocmd BufRead * silent cd %:p:h\n  augroup END\n\n  10Xvimgrep /vim/ Xdir/**\n  let l = g:Xgetlist()\n  call assert_equal('f1.txt', bufname(l[0].bufnr))\n  call assert_equal('f2.txt', fnamemodify(bufname(l[2].bufnr), ':t'))\n\n  augroup QF_Test\n    au!\n  augroup END\n\n  exe 'cd ' . save_cwd\nendfunc\n\nfunc Test_vimgrep_autocmd_cd()\n  call mkdir('Xdir/a', 'p')\n  call mkdir('Xdir/b', 'p')\n  call writefile(['a_L1_vim', 'a_L2_vim'], 'Xdir/a/f1.txt')\n  call writefile(['b_L1_vim', 'b_L2_vim'], 'Xdir/b/f2.txt')\n  call Xvimgrep_autocmd_cd('c')\n  call Xvimgrep_autocmd_cd('l')\n  %bwipe\n  call delete('Xdir', 'rf')\nendfunc\n\n\" The following test used to crash Vim\nfunc Test_lhelpgrep_autocmd()\n  lhelpgrep quickfix\n  autocmd QuickFixCmdPost * call setloclist(0, [], 'f')\n  lhelpgrep buffer\n  call assert_equal('help', &filetype)\n  call assert_equal(0, getloclist(0, {'nr' : '$'}).nr)\n  lhelpgrep tabpage\n  call assert_equal('help', &filetype)\n  call assert_equal(1, getloclist(0, {'nr' : '$'}).nr)\n  au! QuickFixCmdPost\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setqflist([], 'f')\n  augroup END\n  call assert_fails('helpgrep quickfix', 'E925:')\n  \" run the test with a help window already open\n  help\n  wincmd w\n  call assert_fails('helpgrep quickfix', 'E925:')\n  augroup QF_Test\n    au! BufEnter\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setqflist([], 'r')\n  augroup END\n  call assert_fails('helpgrep quickfix', 'E925:')\n  augroup QF_Test\n    au! BufEnter\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setloclist(0, [], 'r')\n  augroup END\n  call assert_fails('lhelpgrep quickfix', 'E926:')\n  augroup QF_Test\n    au! BufEnter\n  augroup END\n\n  new | only\nendfunc\n\n\" Test for shortening/simplifying the file name when opening the\n\" quickfix window or when displaying the quickfix list\nfunc Test_shorten_fname()\n  CheckUnix\n  %bwipe\n  \" Create a quickfix list with an absolute path filename\n  let fname = getcwd() . '/test_quickfix.vim'\n  call setqflist([], ' ', {'lines':[fname . \":20:Line20\"], 'efm':'%f:%l:%m'})\n  call assert_equal(fname, bufname('test_quickfix.vim'))\n  \" Opening the quickfix window should simplify the file path\n  cwindow\n  call assert_equal('test_quickfix.vim', bufname('test_quickfix.vim'))\n  cclose\n  %bwipe\n  \" Create a quickfix list with an absolute path filename\n  call setqflist([], ' ', {'lines':[fname . \":20:Line20\"], 'efm':'%f:%l:%m'})\n  call assert_equal(fname, bufname('test_quickfix.vim'))\n  \" Displaying the quickfix list should simplify the file path\n  silent! clist\n  call assert_equal('test_quickfix.vim', bufname('test_quickfix.vim'))\n  \" Add a few entries for the same file with different paths and check whether\n  \" the buffer name is shortened\n  %bwipe\n  call setqflist([], 'f')\n  call setqflist([{'filename' : 'test_quickfix.vim', 'lnum' : 10},\n        \\ {'filename' : '../testdir/test_quickfix.vim', 'lnum' : 20},\n        \\ {'filename' : fname, 'lnum' : 30}], ' ')\n  copen\n  call assert_equal(['test_quickfix.vim|10| ',\n        \\ 'test_quickfix.vim|20| ',\n        \\ 'test_quickfix.vim|30| '], getline(1, '$'))\n  cclose\nendfunc\n\n\" Quickfix title tests\n\" In the below tests, 'exe \"cmd\"' is used to invoke the quickfix commands.\n\" Otherwise due to indentation, the title is set with spaces at the beginning\n\" of the command.\nfunc Test_qftitle()\n  call writefile([\"F1:1:Line1\"], 'Xerr')\n\n  \" :cexpr\n  exe \"cexpr readfile('Xerr')\"\n  call assert_equal(\":cexpr readfile('Xerr')\", getqflist({'title' : 1}).title)\n\n  \" :cgetexpr\n  exe \"cgetexpr readfile('Xerr')\"\n  call assert_equal(\":cgetexpr readfile('Xerr')\",\n\t\t\t\t\t\\ getqflist({'title' : 1}).title)\n\n  \" :caddexpr\n  call setqflist([], 'f')\n  exe \"caddexpr readfile('Xerr')\"\n  call assert_equal(\":caddexpr readfile('Xerr')\",\n\t\t\t\t\t\\ getqflist({'title' : 1}).title)\n\n  \" :cbuffer\n  new Xerr\n  exe \"cbuffer\"\n  call assert_equal(':cbuffer (Xerr)', getqflist({'title' : 1}).title)\n\n  \" :cgetbuffer\n  edit Xerr\n  exe \"cgetbuffer\"\n  call assert_equal(':cgetbuffer (Xerr)', getqflist({'title' : 1}).title)\n\n  \" :caddbuffer\n  call setqflist([], 'f')\n  edit Xerr\n  exe \"caddbuffer\"\n  call assert_equal(':caddbuffer (Xerr)', getqflist({'title' : 1}).title)\n\n  \" :cfile\n  exe \"cfile Xerr\"\n  call assert_equal(':cfile Xerr', getqflist({'title' : 1}).title)\n\n  \" :cgetfile\n  exe \"cgetfile Xerr\"\n  call assert_equal(':cgetfile Xerr', getqflist({'title' : 1}).title)\n\n  \" :caddfile\n  call setqflist([], 'f')\n  exe \"caddfile Xerr\"\n  call assert_equal(':caddfile Xerr', getqflist({'title' : 1}).title)\n\n  \" :grep\n  set grepprg=internal\n  exe \"grep F1 Xerr\"\n  call assert_equal(':grep F1 Xerr', getqflist({'title' : 1}).title)\n\n  \" :grepadd\n  call setqflist([], 'f')\n  exe \"grepadd F1 Xerr\"\n  call assert_equal(':grepadd F1 Xerr', getqflist({'title' : 1}).title)\n  set grepprg&vim\n\n  \" :vimgrep\n  exe \"vimgrep F1 Xerr\"\n  call assert_equal(':vimgrep F1 Xerr', getqflist({'title' : 1}).title)\n\n  \" :vimgrepadd\n  call setqflist([], 'f')\n  exe \"vimgrepadd F1 Xerr\"\n  call assert_equal(':vimgrepadd F1 Xerr', getqflist({'title' : 1}).title)\n\n  call setqflist(['F1:10:L10'], ' ')\n  call assert_equal(':setqflist()', getqflist({'title' : 1}).title)\n\n  call setqflist([], 'f')\n  call setqflist(['F1:10:L10'], 'a')\n  call assert_equal(':setqflist()', getqflist({'title' : 1}).title)\n\n  call setqflist([], 'f')\n  call setqflist(['F1:10:L10'], 'r')\n  call assert_equal(':setqflist()', getqflist({'title' : 1}).title)\n\n  close\n  call delete('Xerr')\n\n  call setqflist([], ' ', {'title' : 'Errors'})\n  copen\n  call assert_equal('Errors', w:quickfix_title)\n  call setqflist([], 'r', {'items' : [{'filename' : 'a.c', 'lnum' : 10}]})\n  call assert_equal('Errors', w:quickfix_title)\n  cclose\n\n  \" Switching to another quickfix list in one tab page should update the\n  \" quickfix window title and statusline in all the other tab pages also\n  call setqflist([], 'f')\n  %bw!\n  cgetexpr ['file_one:1:1: error in the first quickfix list']\n  call setqflist([], 'a', {'title': 'first quickfix list'})\n  cgetexpr ['file_two:2:1: error in the second quickfix list']\n  call setqflist([], 'a', {'title': 'second quickfix list'})\n  copen\n  wincmd t\n  tabnew two\n  copen\n  wincmd t\n  colder\n  call assert_equal('first quickfix list', gettabwinvar(1, 2, 'quickfix_title'))\n  call assert_equal('first quickfix list', gettabwinvar(2, 2, 'quickfix_title'))\n  call assert_equal(1, tabpagewinnr(1))\n  call assert_equal(1, tabpagewinnr(2))\n  tabnew\n  call setqflist([], 'a', {'title': 'new quickfix title'})\n  call assert_equal('new quickfix title', gettabwinvar(1, 2, 'quickfix_title'))\n  call assert_equal('new quickfix title', gettabwinvar(2, 2, 'quickfix_title'))\n  %bw!\nendfunc\n\nfunc Test_lbuffer_with_bwipe()\n  new\n  new\n  augroup nasty\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * bwipe\n  augroup END\n  lbuffer\n  augroup nasty\n    au!\n  augroup END\nendfunc\n\n\" Test for an autocmd freeing the quickfix/location list when cexpr/lexpr is\n\" running\nfunc Xexpr_acmd_freelist(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" This was using freed memory (but with what events?)\n  augroup nasty\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * call g:Xsetlist([], 'f')\n  augroup END\n  Xexpr \"x\"\n  augroup nasty\n    au!\n  augroup END\nendfunc\n\nfunc Test_cexpr_acmd_freelist()\n  call Xexpr_acmd_freelist('c')\n  call Xexpr_acmd_freelist('l')\nendfunc\n\n\" Test for commands that create a new quickfix/location list and jump to the\n\" first error automatically.\nfunc Xjumpto_first_error_test(cchar)\n  call s:setup_commands(a:cchar)\n\n  call s:create_test_file('Xtestfile1')\n  call s:create_test_file('Xtestfile2')\n  let l = ['Xtestfile1:2:Line2', 'Xtestfile2:4:Line4']\n\n  \" Test for cexpr/lexpr\n  enew\n  Xexpr l\n  call assert_equal('Xtestfile1', @%)\n  call assert_equal(2, line('.'))\n\n  \" Test for cfile/lfile\n  enew\n  call writefile(l, 'Xerr')\n  Xfile Xerr\n  call assert_equal('Xtestfile1', @%)\n  call assert_equal(2, line('.'))\n\n  \" Test for cbuffer/lbuffer\n  edit Xerr\n  Xbuffer\n  call assert_equal('Xtestfile1', @%)\n  call assert_equal(2, line('.'))\n\n  call delete('Xerr')\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\nfunc Test_jumpto_first_error()\n  call Xjumpto_first_error_test('c')\n  call Xjumpto_first_error_test('l')\nendfunc\n\n\" Test for a quickfix autocmd changing the quickfix/location list before\n\" jumping to the first error in the new list.\nfunc Xautocmd_changelist(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Test for cfile/lfile\n  call s:create_test_file('Xtestfile1')\n  call s:create_test_file('Xtestfile2')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  call writefile(['Xtestfile2:4:Line4'], 'Xerr')\n  Xfile Xerr\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(4, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" Test for cbuffer/lbuffer\n  call g:Xsetlist([], 'f')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  call writefile(['Xtestfile2:4:Line4'], 'Xerr')\n  edit Xerr\n  Xbuffer\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(4, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" Test for cexpr/lexpr\n  call g:Xsetlist([], 'f')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  Xexpr 'Xtestfile2:4:Line4'\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(4, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" The grepprg may not be set on non-Unix systems\n  if has('unix')\n    \" Test for grep/lgrep\n    call g:Xsetlist([], 'f')\n    Xexpr 'Xtestfile1:2:Line2'\n    autocmd QuickFixCmdPost * Xolder\n    silent Xgrep Line5 Xtestfile2\n    call assert_equal('Xtestfile2', @%)\n    call assert_equal(5, line('.'))\n    autocmd! QuickFixCmdPost\n  endif\n\n  \" Test for vimgrep/lvimgrep\n  call g:Xsetlist([], 'f')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  silent Xvimgrep Line5 Xtestfile2\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(5, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" Test for autocommands clearing the quickfix list before jumping to the\n  \" first error. This should not result in an error\n  autocmd QuickFixCmdPost * call g:Xsetlist([], 'r')\n  let v:errmsg = ''\n  \" Test for cfile/lfile\n  Xfile Xerr\n  call assert_true(v:errmsg !~# 'E42:')\n  \" Test for cbuffer/lbuffer\n  edit Xerr\n  Xbuffer\n  call assert_true(v:errmsg !~# 'E42:')\n  \" Test for cexpr/lexpr\n  Xexpr 'Xtestfile2:4:Line4'\n  call assert_true(v:errmsg !~# 'E42:')\n  \" Test for grep/lgrep\n  \" The grepprg may not be set on non-Unix systems\n  if has('unix')\n    silent Xgrep Line5 Xtestfile2\n    call assert_true(v:errmsg !~# 'E42:')\n  endif\n  \" Test for vimgrep/lvimgrep\n  call assert_fails('silent Xvimgrep Line5 Xtestfile2', 'E480:')\n  autocmd! QuickFixCmdPost\n\n  call delete('Xerr')\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\nfunc Test_autocmd_changelist()\n  call Xautocmd_changelist('c')\n  call Xautocmd_changelist('l')\nendfunc\n\n\" Tests for the ':filter /pat/ clist' command\nfunc Test_filter_clist()\n  cexpr ['Xfile1:10:10:Line 10', 'Xfile2:15:15:Line 15']\n  call assert_equal([' 2 Xfile2:15 col 15: Line 15'],\n\t\t\t\\ split(execute('filter /Line 15/ clist'), \"\\n\"))\n  call assert_equal([' 1 Xfile1:10 col 10: Line 10'],\n\t\t\t\\ split(execute('filter /Xfile1/ clist'), \"\\n\"))\n  call assert_equal([], split(execute('filter /abc/ clist'), \"\\n\"))\n\n  call setqflist([{'module' : 'abc', 'pattern' : 'pat1'},\n\t\t\t\\ {'module' : 'pqr', 'pattern' : 'pat2'}], ' ')\n  call assert_equal([' 2 pqr:pat2:  '],\n\t\t\t\\ split(execute('filter /pqr/ clist'), \"\\n\"))\n  call assert_equal([' 1 abc:pat1:  '],\n\t\t\t\\ split(execute('filter /pat1/ clist'), \"\\n\"))\nendfunc\n\n\" Tests for the \"CTRL-W <CR>\" command.\nfunc Xview_result_split_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Test that \"CTRL-W <CR>\" in a qf/ll window fails with empty list.\n  call g:Xsetlist([])\n  Xopen\n  let l:win_count = winnr('$')\n  call assert_fails('execute \"normal! \\<C-W>\\<CR>\"', 'E42:')\n  call assert_equal(l:win_count, winnr('$'))\n  Xclose\nendfunc\n\nfunc Test_view_result_split()\n  call Xview_result_split_tests('c')\n  call Xview_result_split_tests('l')\nendfunc\n\n\" Test that :cc sets curswant\nfunc Test_curswant()\n  helpgrep quickfix\n  normal! llll\n  1cc\n  call assert_equal(getcurpos()[4], virtcol('.'))\n  cclose | helpclose\nendfunc\n\n\" Test for opening a file from the quickfix window using CTRL-W <Enter>\n\" doesn't leave an empty buffer around.\nfunc Test_splitview()\n  call s:create_test_file('Xtestfile1')\n  call s:create_test_file('Xtestfile2')\n  new | only\n  let last_bufnr = bufnr('Test_sv_1', 1)\n  let l = ['Xtestfile1:2:Line2', 'Xtestfile2:4:Line4']\n  cgetexpr l\n  copen\n  let numbufs = len(getbufinfo())\n  exe \"normal \\<C-W>\\<CR>\"\n  copen\n  exe \"normal j\\<C-W>\\<CR>\"\n  \" Make sure new empty buffers are not created\n  call assert_equal(numbufs, len(getbufinfo()))\n  \" Creating a new buffer should use the next available buffer number\n  call assert_equal(last_bufnr + 4, bufnr(\"Test_sv_2\", 1))\n  bwipe Test_sv_1\n  bwipe Test_sv_2\n  new | only\n\n  \" When split opening files from location list window, make sure that two\n  \" windows doesn't refer to the same location list\n  lgetexpr l\n  let locid = getloclist(0, {'id' : 0}).id\n  lopen\n  exe \"normal \\<C-W>\\<CR>\"\n  call assert_notequal(locid, getloclist(0, {'id' : 0}).id)\n  call assert_equal(0, getloclist(0, {'winid' : 0}).winid)\n  new | only\n\n  \" When split opening files from a helpgrep location list window, a new help\n  \" window should be opened with a copy of the location list.\n  lhelpgrep window\n  let locid = getloclist(0, {'id' : 0}).id\n  lwindow\n  exe \"normal j\\<C-W>\\<CR>\"\n  call assert_notequal(locid, getloclist(0, {'id' : 0}).id)\n  call assert_equal(0, getloclist(0, {'winid' : 0}).winid)\n  new | only\n\n  \" Using :split or :vsplit from a quickfix window should behave like a :new\n  \" or a :vnew command\n  copen\n  split\n  call assert_equal(3, winnr('$'))\n  let l = getwininfo()\n  call assert_equal([0, 0, 1], [l[0].quickfix, l[1].quickfix, l[2].quickfix])\n  close\n  copen\n  vsplit\n  let l = getwininfo()\n  call assert_equal([0, 0, 1], [l[0].quickfix, l[1].quickfix, l[2].quickfix])\n  new | only\n\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\n\" Test for parsing entries using visual screen column\nfunc Test_viscol()\n  enew\n  call writefile([\"Col1\\tCol2\\tCol3\"], 'Xfile1')\n  edit Xfile1\n\n  \" Use byte offset for column number\n  set efm&\n  cexpr \"Xfile1:1:5:XX\\nXfile1:1:9:YY\\nXfile1:1:20:ZZ\"\n  call assert_equal([5, 8], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([9, 12], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([14, 20], [col('.'), virtcol('.')])\n\n  \" Use screen column offset for column number\n  set efm=%f:%l:%v:%m\n  cexpr \"Xfile1:1:8:XX\\nXfile1:1:12:YY\\nXfile1:1:20:ZZ\"\n  call assert_equal([5, 8], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([9, 12], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([14, 20], [col('.'), virtcol('.')])\n  cexpr \"Xfile1:1:6:XX\\nXfile1:1:15:YY\\nXfile1:1:24:ZZ\"\n  call assert_equal([5, 8], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([10, 16], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([14, 20], [col('.'), virtcol('.')])\n\n  enew\n  call writefile([\"Col1\\t\u00e4\u00fc\\t\u00f6\u00df\\tCol4\"], 'Xfile1')\n\n  \" Use byte offset for column number\n  set efm&\n  cexpr \"Xfile1:1:8:XX\\nXfile1:1:11:YY\\nXfile1:1:16:ZZ\"\n  call assert_equal([8, 10], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([11, 17], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([16, 25], [col('.'), virtcol('.')])\n\n  \" Use screen column offset for column number\n  set efm=%f:%l:%v:%m\n  cexpr \"Xfile1:1:10:XX\\nXfile1:1:17:YY\\nXfile1:1:25:ZZ\"\n  call assert_equal([8, 10], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([11, 17], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([16, 25], [col('.'), virtcol('.')])\n\n  \" Use screen column number with a multi-line error message\n  enew\n  call writefile([\"\u00e0 test\"], 'Xfile1')\n  set efm=%E===\\ %f\\ ===,%C%l:%v,%Z%m\n  cexpr [\"=== Xfile1 ===\", \"1:3\", \"errormsg\"]\n  call assert_equal('Xfile1', @%)\n  call assert_equal([0, 1, 4, 0], getpos('.'))\n\n  \" Repeat previous test with byte offset %c: ensure that fix to issue #7145\n  \" does not break this\n  set efm=%E===\\ %f\\ ===,%C%l:%c,%Z%m\n  cexpr [\"=== Xfile1 ===\", \"1:3\", \"errormsg\"]\n  call assert_equal('Xfile1', @%)\n  call assert_equal([0, 1, 3, 0], getpos('.'))\n\n  enew | only\n  set efm&\n  call delete('Xfile1')\nendfunc\n\n\" Test for the quickfix window buffer\nfunc Xqfbuf_test(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Quickfix buffer should be reused across closing and opening a quickfix\n  \" window\n  Xexpr \"F1:10:Line10\"\n  Xopen\n  let qfbnum = bufnr('')\n  Xclose\n  \" Even after the quickfix window is closed, the buffer should be loaded\n  call assert_true(bufloaded(qfbnum))\n  call assert_true(qfbnum, g:Xgetlist({'qfbufnr' : 0}).qfbufnr)\n  Xopen\n  \" Buffer should be reused when opening the window again\n  call assert_equal(qfbnum, bufnr(''))\n  Xclose\n\n  \" When quickfix buffer is wiped out, getqflist() should return 0\n  %bw!\n  Xexpr \"\"\n  Xopen\n  bw!\n  call assert_equal(0, g:Xgetlist({'qfbufnr': 0}).qfbufnr)\n\n  if a:cchar == 'l'\n    %bwipe\n    \" For a location list, when both the file window and the location list\n    \" window for the list are closed, then the buffer should be freed.\n    new | only\n    lexpr \"F1:10:Line10\"\n    let wid = win_getid()\n    lopen\n    let qfbnum = bufnr('')\n    call assert_match(qfbnum . ' %a-  \"\\[Location List]\"', execute('ls'))\n    close\n    \" When the location list window is closed, the buffer name should not\n    \" change to 'Quickfix List'\n    call assert_match(qfbnum . 'u h-  \"\\[Location List]\"', execute('ls!'))\n    call assert_true(bufloaded(qfbnum))\n\n    \" After deleting a location list buffer using \":bdelete\", opening the\n    \" location list window should mark the buffer as a location list buffer.\n    exe \"bdelete \" . qfbnum\n    lopen\n    call assert_equal(\"quickfix\", &buftype)\n    call assert_equal(1, getwininfo(win_getid(winnr()))[0].loclist)\n    call assert_equal(wid, getloclist(0, {'filewinid' : 0}).filewinid)\n    call assert_false(&swapfile)\n    lclose\n\n    \" When the location list is cleared for the window, the buffer should be\n    \" removed\n    call setloclist(0, [], 'f')\n    call assert_false(bufexists(qfbnum))\n    call assert_equal(0, getloclist(0, {'qfbufnr' : 0}).qfbufnr)\n\n    \" When the location list is freed with the location list window open, the\n    \" location list buffer should not be lost. It should be reused when the\n    \" location list is again populated.\n    lexpr \"F1:10:Line10\"\n    lopen\n    let wid = win_getid()\n    let qfbnum = bufnr('')\n    wincmd p\n    call setloclist(0, [], 'f')\n    lexpr \"F1:10:Line10\"\n    lopen\n    call assert_equal(wid, win_getid())\n    call assert_equal(qfbnum, bufnr(''))\n    lclose\n\n    \" When the window with the location list is closed, the buffer should be\n    \" removed\n    new | only\n    call assert_false(bufexists(qfbnum))\n  endif\nendfunc\n\nfunc Test_qfbuf()\n  call Xqfbuf_test('c')\n  call Xqfbuf_test('l')\nendfunc\n\n\" If there is an autocmd to use only one window, then opening the location\n\" list window used to crash Vim.\nfunc Test_winonly_autocmd()\n  call s:create_test_file('Xtest1')\n  \" Autocmd to show only one Vim window at a time\n  autocmd WinEnter * only\n  new\n  \" Load the location list\n  lexpr \"Xtest1:5:Line5\\nXtest1:10:Line10\\nXtest1:15:Line15\"\n  let loclistid = getloclist(0, {'id' : 0}).id\n  \" Open the location list window. Only this window will be shown and the file\n  \" window is closed.\n  lopen\n  call assert_equal(loclistid, getloclist(0, {'id' : 0}).id)\n  \" Jump to an entry in the location list and make sure that the cursor is\n  \" positioned correctly.\n  ll 3\n  call assert_equal(loclistid, getloclist(0, {'id' : 0}).id)\n  call assert_equal('Xtest1', @%)\n  call assert_equal(15, line('.'))\n  \" Cleanup\n  autocmd! WinEnter\n  new | only\n  call delete('Xtest1')\nendfunc\n\n\" Test to make sure that an empty quickfix buffer is not reused for loading\n\" a normal buffer.\nfunc Test_empty_qfbuf()\n  enew | only\n  call writefile([\"Test\"], 'Xfile1')\n  call setqflist([], 'f')\n  copen | only\n  let qfbuf = bufnr('')\n  edit Xfile1\n  call assert_notequal(qfbuf, bufnr(''))\n  enew\n  call delete('Xfile1')\nendfunc\n\n\" Test for the :cbelow, :cabove, :lbelow and :labove commands.\n\" And for the :cafter, :cbefore, :lafter and :lbefore commands.\nfunc Xtest_below(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" No quickfix/location list\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n\n  \" Empty quickfix/location list\n  call g:Xsetlist([])\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n\n  call s:create_test_file('X1')\n  call s:create_test_file('X2')\n  call s:create_test_file('X3')\n  call s:create_test_file('X4')\n\n  \" Invalid entries\n  edit X1\n  call g:Xsetlist([\"E1\", \"E2\"])\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('3Xbelow', 'E42:')\n  call assert_fails('4Xabove', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n  call assert_fails('3Xbefore', 'E42:')\n  call assert_fails('4Xafter', 'E42:')\n\n  \" Test the commands with various arguments\n  Xexpr [\"X1:5:3:L5\", \"X2:5:2:L5\", \"X2:10:3:L10\", \"X2:15:4:L15\", \"X3:3:5:L3\"]\n  edit +7 X2\n  Xabove\n  call assert_equal(['X2', 5], [@%, line('.')])\n  call assert_fails('Xabove', 'E553:')\n  normal 7G\n  Xbefore\n  call assert_equal(['X2', 5, 2], [@%, line('.'), col('.')])\n  call assert_fails('Xbefore', 'E553:')\n\n  normal 2j\n  Xbelow\n  call assert_equal(['X2', 10], [@%, line('.')])\n  normal 7G\n  Xafter\n  call assert_equal(['X2', 10, 3], [@%, line('.'), col('.')])\n\n  \" Last error in this file\n  Xbelow 99\n  call assert_equal(['X2', 15], [@%, line('.')])\n  call assert_fails('Xbelow', 'E553:')\n  normal gg\n  Xafter 99\n  call assert_equal(['X2', 15, 4], [@%, line('.'), col('.')])\n  call assert_fails('Xafter', 'E553:')\n\n  \" First error in this file\n  Xabove 99\n  call assert_equal(['X2', 5], [@%, line('.')])\n  call assert_fails('Xabove', 'E553:')\n  normal G\n  Xbefore 99\n  call assert_equal(['X2', 5, 2], [@%, line('.'), col('.')])\n  call assert_fails('Xbefore', 'E553:')\n\n  normal gg\n  Xbelow 2\n  call assert_equal(['X2', 10], [@%, line('.')])\n  normal gg\n  Xafter 2\n  call assert_equal(['X2', 10, 3], [@%, line('.'), col('.')])\n\n  normal G\n  Xabove 2\n  call assert_equal(['X2', 10], [@%, line('.')])\n  normal G\n  Xbefore 2\n  call assert_equal(['X2', 10, 3], [@%, line('.'), col('.')])\n\n  edit X4\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n  if a:cchar == 'l'\n    \" If a buffer has location list entries from some other window but not\n    \" from the current window, then the commands should fail.\n    edit X1 | split | call setloclist(0, [], 'f')\n    call assert_fails('Xabove', 'E776:')\n    call assert_fails('Xbelow', 'E776:')\n    call assert_fails('Xbefore', 'E776:')\n    call assert_fails('Xafter', 'E776:')\n    close\n  endif\n\n  \" Test for lines with multiple quickfix entries\n  Xexpr [\"X1:5:L5\", \"X2:5:1:L5_1\", \"X2:5:2:L5_2\", \"X2:5:3:L5_3\",\n\t      \\ \"X2:10:1:L10_1\", \"X2:10:2:L10_2\", \"X2:10:3:L10_3\",\n\t      \\ \"X2:15:1:L15_1\", \"X2:15:2:L15_2\", \"X2:15:3:L15_3\", \"X3:3:L3\"]\n  edit +1 X2\n  Xbelow 2\n  call assert_equal(['X2', 10, 1], [@%, line('.'), col('.')])\n  normal 1G\n  Xafter 2\n  call assert_equal(['X2', 5, 2], [@%, line('.'), col('.')])\n\n  normal gg\n  Xbelow 99\n  call assert_equal(['X2', 15, 1], [@%, line('.'), col('.')])\n  normal gg\n  Xafter 99\n  call assert_equal(['X2', 15, 3], [@%, line('.'), col('.')])\n\n  normal G\n  Xabove 2\n  call assert_equal(['X2', 10, 1], [@%, line('.'), col('.')])\n  normal G\n  Xbefore 2\n  call assert_equal(['X2', 15, 2], [@%, line('.'), col('.')])\n\n  normal G\n  Xabove 99\n  call assert_equal(['X2', 5, 1], [@%, line('.'), col('.')])\n  normal G\n  Xbefore 99\n  call assert_equal(['X2', 5, 1], [@%, line('.'), col('.')])\n\n  normal 10G\n  Xabove\n  call assert_equal(['X2', 5, 1], [@%, line('.'), col('.')])\n  normal 10G$\n  2Xbefore\n  call assert_equal(['X2', 10, 2], [@%, line('.'), col('.')])\n\n  normal 10G\n  Xbelow\n  call assert_equal(['X2', 15, 1], [@%, line('.'), col('.')])\n  normal 9G\n  5Xafter\n  call assert_equal(['X2', 15, 2], [@%, line('.'), col('.')])\n\n  \" Invalid range\n  if a:cchar == 'c'\n    call assert_fails('-2cbelow', 'E16:')\n    call assert_fails('-2cafter', 'E16:')\n  else\n    call assert_fails('-2lbelow', 'E16:')\n    call assert_fails('-2lafter', 'E16:')\n  endif\n\n  call delete('X1')\n  call delete('X2')\n  call delete('X3')\n  call delete('X4')\nendfunc\n\nfunc Test_cbelow()\n  call Xtest_below('c')\n  call Xtest_below('l')\nendfunc\n\nfunc Test_quickfix_count()\n  let commands = [\n\t\\ 'cNext',\n\t\\ 'cNfile',\n\t\\ 'cabove',\n\t\\ 'cbelow',\n\t\\ 'cfirst',\n\t\\ 'clast',\n\t\\ 'cnewer',\n\t\\ 'cnext',\n\t\\ 'cnfile',\n\t\\ 'colder',\n\t\\ 'cprevious',\n\t\\ 'crewind',\n\t\\\n\t\\ 'lNext',\n\t\\ 'lNfile',\n\t\\ 'labove',\n\t\\ 'lbelow',\n\t\\ 'lfirst',\n\t\\ 'llast',\n\t\\ 'lnewer',\n\t\\ 'lnext',\n\t\\ 'lnfile',\n\t\\ 'lolder',\n\t\\ 'lprevious',\n\t\\ 'lrewind',\n\t\\ ]\n  for cmd in commands\n    call assert_fails('-1' .. cmd, 'E16:')\n    call assert_fails('.' .. cmd, 'E16:')\n    call assert_fails('%' .. cmd, 'E16:')\n    call assert_fails('$' .. cmd, 'E16:')\n  endfor\nendfunc\n\n\" Test for aborting quickfix commands using QuickFixCmdPre\nfunc Xtest_qfcmd_abort(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n\n  \" cexpr/lexpr\n  let e = ''\n  try\n    Xexpr [\"F1:10:Line10\", \"F2:20:Line20\"]\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n\n  \" cfile/lfile\n  call writefile([\"F1:10:Line10\", \"F2:20:Line20\"], 'Xfile1')\n  let e = ''\n  try\n    Xfile Xfile1\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n  call delete('Xfile1')\n\n  \" cgetbuffer/lgetbuffer\n  enew!\n  call append(0, [\"F1:10:Line10\", \"F2:20:Line20\"])\n  let e = ''\n  try\n    Xgetbuffer\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n  enew!\n\n  \" vimgrep/lvimgrep\n  let e = ''\n  try\n    Xvimgrep /func/ test_quickfix.vim\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n\n  \" helpgrep/lhelpgrep\n  let e = ''\n  try\n    Xhelpgrep quickfix\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n\n  \" grep/lgrep\n  if has('unix')\n    let e = ''\n    try\n      silent Xgrep func test_quickfix.vim\n    catch /.*/\n      let e = v:exception\n    endtry\n    call assert_equal('AbortCmd', e)\n    call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n  endif\nendfunc\n\nfunc Test_qfcmd_abort()\n  augroup QF_Test\n    au!\n    autocmd  QuickFixCmdPre * throw \"AbortCmd\"\n  augroup END\n\n  call Xtest_qfcmd_abort('c')\n  call Xtest_qfcmd_abort('l')\n\n  augroup QF_Test\n    au!\n  augroup END\nendfunc\n\n\" Test for using a file in one of the parent directories.\nfunc Test_search_in_dirstack()\n  call mkdir('Xtestdir/a/b/c', 'p')\n  let save_cwd = getcwd()\n  call writefile([\"X1_L1\", \"X1_L2\"], 'Xtestdir/Xfile1')\n  call writefile([\"X2_L1\", \"X2_L2\"], 'Xtestdir/a/Xfile2')\n  call writefile([\"X3_L1\", \"X3_L2\"], 'Xtestdir/a/b/Xfile3')\n  call writefile([\"X4_L1\", \"X4_L2\"], 'Xtestdir/a/b/c/Xfile4')\n\n  let lines = \"Entering dir Xtestdir\\n\" .\n\t      \\ \"Entering dir a\\n\" .\n\t      \\ \"Entering dir b\\n\" .\n\t      \\ \"Xfile2:2:X2_L2\\n\" .\n\t      \\ \"Leaving dir a\\n\" .\n\t      \\ \"Xfile1:2:X1_L2\\n\" .\n\t      \\ \"Xfile3:1:X3_L1\\n\" .\n\t      \\ \"Entering dir c\\n\" .\n\t      \\ \"Xfile4:2:X4_L2\\n\" .\n\t      \\ \"Leaving dir c\\n\"\n  set efm=%DEntering\\ dir\\ %f,%XLeaving\\ dir\\ %f,%f:%l:%m\n  cexpr lines .. \"Leaving dir Xtestdir|\\n\" | let next = 1\n  call assert_equal(11, getqflist({'size' : 0}).size)\n  call assert_equal(4, getqflist({'idx' : 0}).idx)\n  call assert_equal('X2_L2', getline('.'))\n  call assert_equal(1, next)\n  cnext\n  call assert_equal(6, getqflist({'idx' : 0}).idx)\n  call assert_equal('X1_L2', getline('.'))\n  cnext\n  call assert_equal(7, getqflist({'idx' : 0}).idx)\n  call assert_equal(1, line('$'))\n  call assert_equal('', getline(1))\n  cnext\n  call assert_equal(9, getqflist({'idx' : 0}).idx)\n  call assert_equal(1, line('$'))\n  call assert_equal('', getline(1))\n\n  set efm&\n  exe 'cd ' . save_cwd\n  call delete('Xtestdir', 'rf')\nendfunc\n\n\" Test for :cquit\nfunc Test_cquit()\n  \" Exit Vim with a non-zero value\n  if RunVim([], [\"cquit 7\"], '')\n    call assert_equal(7, v:shell_error)\n  endif\n\n  if RunVim([], [\"50cquit\"], '')\n    call assert_equal(50, v:shell_error)\n  endif\n\n  \" Exit Vim with default value\n  if RunVim([], [\"cquit\"], '')\n    call assert_equal(1, v:shell_error)\n  endif\n\n  \" Exit Vim with zero value\n  if RunVim([], [\"cquit 0\"], '')\n    call assert_equal(0, v:shell_error)\n  endif\n\n  \" Exit Vim with negative value\n  call assert_fails('-3cquit', 'E16:')\nendfunc\n\n\" Test for getting a specific item from a quickfix list\nfunc Xtest_getqflist_by_idx(cchar)\n  call s:setup_commands(a:cchar)\n  \" Empty list\n  call assert_equal([], g:Xgetlist({'idx' : 1, 'items' : 0}).items)\n  Xexpr ['F1:10:L10', 'F1:20:L20']\n  let l = g:Xgetlist({'idx' : 2, 'items' : 0}).items\n  call assert_equal(bufnr('F1'), l[0].bufnr)\n  call assert_equal(20, l[0].lnum)\n  call assert_equal('L20', l[0].text)\n  call assert_equal([], g:Xgetlist({'idx' : -1, 'items' : 0}).items)\n  call assert_equal([], g:Xgetlist({'idx' : 3, 'items' : 0}).items)\n  %bwipe!\nendfunc\n\nfunc Test_getqflist_by_idx()\n  call Xtest_getqflist_by_idx('c')\n  call Xtest_getqflist_by_idx('l')\nendfunc\n\n\" Test for the 'quickfixtextfunc' setting\nfunc Tqfexpr(info)\n  if a:info.quickfix\n    let qfl = getqflist({'id' : a:info.id, 'items' : 1}).items\n  else\n    let qfl = getloclist(a:info.winid, {'id' : a:info.id, 'items' : 1}).items\n  endif\n\n  let l = []\n  for idx in range(a:info.start_idx - 1, a:info.end_idx - 1)\n    let e = qfl[idx]\n    let s = ''\n    if e.bufnr != 0\n      let bname = bufname(e.bufnr)\n      let s ..= fnamemodify(bname, ':.')\n    endif\n    let s ..= '-'\n    let s ..= 'L' .. string(e.lnum) .. 'C' .. string(e.col) .. '-'\n    let s ..= e.text\n    call add(l, s)\n  endfor\n\n  return l\nendfunc\n\nfunc Xtest_qftextfunc(cchar)\n  call s:setup_commands(a:cchar)\n\n  set efm=%f:%l:%c:%m\n  set quickfixtextfunc=Tqfexpr\n  call assert_equal('Tqfexpr', &quickfixtextfunc)\n  call assert_equal('',\n        \\ g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc)\n  call g:Xsetlist([\n        \\ { 'filename': 'F1', 'lnum': 10, 'col': 2,\n        \\   'end_col': 7, 'text': 'green'},\n        \\ { 'filename': 'F1', 'lnum': 20, 'end_lnum': 25, 'col': 4,\n        \\   'end_col': 8, 'text': 'blue'},\n        \\ ])\n\n  Xwindow\n  call assert_equal('F1-L10C2-green', getline(1))\n  call assert_equal('F1-L20C4-blue', getline(2))\n  Xclose\n  set quickfixtextfunc&vim\n  Xwindow\n  call assert_equal('F1|10 col 2-7| green', getline(1))\n  call assert_equal('F1|20-25 col 4-8| blue', getline(2))\n  Xclose\n  set efm&\n  set quickfixtextfunc&\n\n  \" Test for per list 'quickfixtextfunc' setting\n  func PerQfText(info)\n    if a:info.quickfix\n      let qfl = getqflist({'id' : a:info.id, 'items' : 1}).items\n    else\n      let qfl = getloclist(a:info.winid, {'id' : a:info.id, 'items' : 1}).items\n    endif\n    if empty(qfl)\n      return []\n    endif\n    let l = []\n    for idx in range(a:info.start_idx - 1, a:info.end_idx - 1)\n      call add(l, 'Line ' .. qfl[idx].lnum .. ', Col ' .. qfl[idx].col)\n    endfor\n    return l\n  endfunc\n  set quickfixtextfunc=Tqfexpr\n  call g:Xsetlist([], ' ', {'quickfixtextfunc' : \"PerQfText\"})\n  Xaddexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal('Line 10, Col 2', getline(1))\n  call assert_equal('Line 20, Col 4', getline(2))\n  Xclose\n  call assert_equal(function('PerQfText'),\n        \\ g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc)\n  \" Add entries to the list when the quickfix buffer is hidden\n  Xaddexpr ['F1:30:6:red']\n  Xwindow\n  call assert_equal('Line 30, Col 6', getline(3))\n  Xclose\n  call g:Xsetlist([], 'r', {'quickfixtextfunc' : ''})\n  call assert_equal('', g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc)\n  set quickfixtextfunc&\n  delfunc PerQfText\n\n  \" Non-existing function\n  set quickfixtextfunc=Tabc\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue']\", 'E117:')\n  call assert_fails(\"Xwindow\", 'E117:')\n  Xclose\n  set quickfixtextfunc&\n\n  \" set option to a non-function\n  set quickfixtextfunc=[10,\\ 20]\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue']\", 'E117:')\n  call assert_fails(\"Xwindow\", 'E117:')\n  Xclose\n  set quickfixtextfunc&\n\n  \" set option to a function with different set of arguments\n  func Xqftext(a, b, c)\n    return a:a .. a:b .. a:c\n  endfunc\n  set quickfixtextfunc=Xqftext\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue']\", 'E119:')\n  call assert_fails(\"Xwindow\", 'E119:')\n  Xclose\n\n  \" set option to a function that returns a list with non-strings\n  func Xqftext2(d)\n    return ['one', [], 'two']\n  endfunc\n  set quickfixtextfunc=Xqftext2\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue', 'F1:30:6:red']\",\n                                                                  \\ 'E730:')\n  call assert_fails('Xwindow', 'E730:')\n  call assert_equal(['one', 'F1|20 col 4| blue', 'F1|30 col 6| red'],\n        \\ getline(1, '$'))\n  Xclose\n\n  set quickfixtextfunc&\n  delfunc Xqftext\n  delfunc Xqftext2\n\n  \" set the global option to a lambda function\n  set quickfixtextfunc={d\\ ->\\ map(g:Xgetlist({'id'\\ :\\ d.id,\\ 'items'\\ :\\ 1}).items[d.start_idx-1:d.end_idx-1],\\ 'v:val.text')}\n  Xexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal(['green', 'blue'], getline(1, '$'))\n  Xclose\n  call assert_equal(\"{d -> map(g:Xgetlist({'id' : d.id, 'items' : 1}).items[d.start_idx-1:d.end_idx-1], 'v:val.text')}\", &quickfixtextfunc)\n  set quickfixtextfunc&\n\n  \" use a lambda function that returns an empty list\n  set quickfixtextfunc={d\\ ->\\ []}\n  Xexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal(['F1|10 col 2| green', 'F1|20 col 4| blue'],\n        \\ getline(1, '$'))\n  Xclose\n  set quickfixtextfunc&\n\n  \" use a lambda function that returns a list with empty strings\n  set quickfixtextfunc={d\\ ->\\ ['',\\ '']}\n  Xexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal(['F1|10 col 2| green', 'F1|20 col 4| blue'],\n        \\ getline(1, '$'))\n  Xclose\n  set quickfixtextfunc&\n\n  \" set the per-quickfix list text function to a lambda function\n  call g:Xsetlist([], ' ',\n        \\ {'quickfixtextfunc' :\n        \\   {d -> map(g:Xgetlist({'id' : d.id, 'items' : 1}).items[d.start_idx-1:d.end_idx-1],\n        \\ \"'Line ' .. v:val.lnum .. ', Col ' .. v:val.col\")}})\n  Xaddexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal('Line 10, Col 2', getline(1))\n  call assert_equal('Line 20, Col 4', getline(2))\n  Xclose\n  call assert_match(\"function('<lambda>\\\\d\\\\+')\", string(g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc))\n  call g:Xsetlist([], 'f')\nendfunc\n\nfunc Test_qftextfunc()\n  call Xtest_qftextfunc('c')\n  call Xtest_qftextfunc('l')\nendfunc\n\nfunc Test_qftextfunc_callback()\n  let lines =<< trim END\n    set efm=%f:%l:%c:%m\n\n    #\" Test for using a function name\n    LET &qftf = 'g:Tqfexpr'\n    cexpr \"F0:0:0:L0\"\n    copen\n    call assert_equal('F0-L0C0-L0', getline(1))\n    cclose\n\n    #\" Test for using a function()\n    set qftf=function('g:Tqfexpr')\n    cexpr \"F1:1:1:L1\"\n    copen\n    call assert_equal('F1-L1C1-L1', getline(1))\n    cclose\n\n    #\" Using a funcref variable to set 'quickfixtextfunc'\n    VAR Fn = function('g:Tqfexpr')\n    LET &qftf = Fn\n    cexpr \"F2:2:2:L2\"\n    copen\n    call assert_equal('F2-L2C2-L2', getline(1))\n    cclose\n\n    #\" Using string(funcref_variable) to set 'quickfixtextfunc'\n    LET Fn = function('g:Tqfexpr')\n    LET &qftf = string(Fn)\n    cexpr \"F3:3:3:L3\"\n    copen\n    call assert_equal('F3-L3C3-L3', getline(1))\n    cclose\n\n    #\" Test for using a funcref()\n    set qftf=funcref('g:Tqfexpr')\n    cexpr \"F4:4:4:L4\"\n    copen\n    call assert_equal('F4-L4C4-L4', getline(1))\n    cclose\n\n    #\" Using a funcref variable to set 'quickfixtextfunc'\n    LET Fn = funcref('g:Tqfexpr')\n    LET &qftf = Fn\n    cexpr \"F5:5:5:L5\"\n    copen\n    call assert_equal('F5-L5C5-L5', getline(1))\n    cclose\n\n    #\" Using a string(funcref_variable) to set 'quickfixtextfunc'\n    LET Fn = funcref('g:Tqfexpr')\n    LET &qftf = string(Fn)\n    cexpr \"F5:5:5:L5\"\n    copen\n    call assert_equal('F5-L5C5-L5', getline(1))\n    cclose\n\n    #\" Test for using a lambda function with set\n    VAR optval = \"LSTART a LMIDDLE g:Tqfexpr(a) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set qftf=\" .. optval\n    cexpr \"F6:6:6:L6\"\n    copen\n    call assert_equal('F6-L6C6-L6', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to a lambda expression\n    LET &qftf = LSTART a LMIDDLE g:Tqfexpr(a) LEND\n    cexpr \"F7:7:7:L7\"\n    copen\n    call assert_equal('F7-L7C7-L7', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to string(lambda_expression)\n    LET &qftf = \"LSTART a LMIDDLE g:Tqfexpr(a) LEND\"\n    cexpr \"F8:8:8:L8\"\n    copen\n    call assert_equal('F8-L8C8-L8', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a LMIDDLE g:Tqfexpr(a) LEND\n    LET &qftf = Lambda\n    cexpr \"F9:9:9:L9\"\n    copen\n    call assert_equal('F9-L9C9-L9', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a LMIDDLE g:Tqfexpr(a) LEND\n    LET &qftf = string(Lambda)\n    cexpr \"F9:9:9:L9\"\n    copen\n    call assert_equal('F9-L9C9-L9', getline(1))\n    cclose\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:TqfFunc2(info)\n    let g:TqfFunc2Args = [a:info.start_idx, a:info.end_idx]\n    return ''\n  endfunc\n  let g:TqfFunc2Args = []\n  set quickfixtextfunc=s:TqfFunc2\n  cexpr \"F10:10:10:L10\"\n  cclose\n  call assert_equal([1, 1], g:TqfFunc2Args)\n\n  let &quickfixtextfunc = 's:TqfFunc2'\n  cexpr \"F11:11:11:L11\"\n  cclose\n  call assert_equal([1, 1], g:TqfFunc2Args)\n  delfunc s:TqfFunc2\n\n  \" set 'quickfixtextfunc' to a partial with dict. This used to cause a crash.\n  func SetQftfFunc()\n    let params = {'qftf': function('g:DictQftfFunc')}\n    let &quickfixtextfunc = params.qftf\n  endfunc\n  func g:DictQftfFunc(_) dict\n  endfunc\n  call SetQftfFunc()\n  new\n  call SetQftfFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set qftf=\n  wincmd w\n  set qftf=\n  :%bw!\n\n  \" set per-quickfix list 'quickfixtextfunc' to a partial with dict. This used\n  \" to cause a crash.\n  let &qftf = ''\n  func SetLocalQftfFunc()\n    let params = {'qftf': function('g:DictQftfFunc')}\n    call setqflist([], 'a', {'quickfixtextfunc' : params.qftf})\n  endfunc\n  call SetLocalQftfFunc()\n  call test_garbagecollect_now()\n  call setqflist([], 'a', {'quickfixtextfunc' : ''})\n  delfunc g:DictQftfFunc\n  delfunc SetQftfFunc\n  delfunc SetLocalQftfFunc\n  set efm&\nendfunc\n\n\" Test for updating a location list for some other window and check that\n\" 'qftextfunc' uses the correct location list.\nfunc Test_qftextfunc_other_loclist()\n  %bw!\n  call setloclist(0, [], 'f')\n\n  \" create a window and a location list for it and open the location list\n  \" window\n  lexpr ['F1:10:12:one', 'F1:20:14:two']\n  let w1_id = win_getid()\n  call setloclist(0, [], ' ',\n        \\ {'lines': ['F1:10:12:one', 'F1:20:14:two'],\n        \\  'quickfixtextfunc':\n        \\    {d -> map(getloclist(d.winid, {'id' : d.id,\n        \\                'items' : 1}).items[d.start_idx-1:d.end_idx-1],\n        \\          \"'Line ' .. v:val.lnum .. ', Col ' .. v:val.col\")}})\n  lwindow\n  let w2_id = win_getid()\n\n  \" create another window and a location list for it and open the location\n  \" list window\n  topleft new\n  let w3_id = win_getid()\n  call setloclist(0, [], ' ',\n        \\ {'lines': ['F2:30:32:eleven', 'F2:40:34:twelve'],\n        \\  'quickfixtextfunc':\n        \\    {d -> map(getloclist(d.winid, {'id' : d.id,\n        \\                'items' : 1}).items[d.start_idx-1:d.end_idx-1],\n        \\          \"'Ligne ' .. v:val.lnum .. ', Colonne ' .. v:val.col\")}})\n  lwindow\n  let w4_id = win_getid()\n\n  topleft new\n  lexpr ['F3:50:52:green', 'F3:60:54:blue']\n  let w5_id = win_getid()\n\n  \" change the location list for some other window\n  call setloclist(0, [], 'r', {'lines': ['F3:55:56:aaa', 'F3:57:58:bbb']})\n  call setloclist(w1_id, [], 'r', {'lines': ['F1:62:63:bbb', 'F1:64:65:ccc']})\n  call setloclist(w3_id, [], 'r', {'lines': ['F2:76:77:ddd', 'F2:78:79:eee']})\n  call assert_equal(['Line 62, Col 63', 'Line 64, Col 65'],\n        \\ getbufline(winbufnr(w2_id), 1, '$'))\n  call assert_equal(['Ligne 76, Colonne 77', 'Ligne 78, Colonne 79'],\n        \\ getbufline(winbufnr(w4_id), 1, '$'))\n  call setloclist(w2_id, [], 'r', {'lines': ['F1:32:33:fff', 'F1:34:35:ggg']})\n  call setloclist(w4_id, [], 'r', {'lines': ['F2:46:47:hhh', 'F2:48:49:jjj']})\n  call assert_equal(['Line 32, Col 33', 'Line 34, Col 35'],\n        \\ getbufline(winbufnr(w2_id), 1, '$'))\n  call assert_equal(['Ligne 46, Colonne 47', 'Ligne 48, Colonne 49'],\n        \\ getbufline(winbufnr(w4_id), 1, '$'))\n\n  call win_gotoid(w5_id)\n  lwindow\n  call assert_equal(['F3|55 col 56| aaa', 'F3|57 col 58| bbb'],\n        \\ getline(1, '$'))\n  %bw!\nendfunc\n\n\" Running :lhelpgrep command more than once in a help window, doesn't jump to\n\" the help topic\nfunc Test_lhelpgrep_from_help_window()\n  call mkdir('Xtestdir/doc', 'p')\n  call writefile(['window'], 'Xtestdir/doc/a.txt')\n  call writefile(['buffer'], 'Xtestdir/doc/b.txt')\n  let save_rtp = &rtp\n  let &rtp = 'Xtestdir'\n  lhelpgrep window\n  lhelpgrep buffer\n  call assert_equal('b.txt', fnamemodify(@%, \":p:t\"))\n  lhelpgrep window\n  call assert_equal('a.txt', fnamemodify(@%, \":p:t\"))\n  let &rtp = save_rtp\n  call delete('Xtestdir', 'rf')\n  new | only!\nendfunc\n\n\" Test for the crash fixed by 7.3.715\nfunc Test_setloclist_crash()\n  %bw!\n  let g:BufNum = bufnr()\n  augroup QF_Test\n    au!\n    au BufUnload * call setloclist(0, [{'bufnr':g:BufNum, 'lnum':1, 'col':1, 'text': 'tango down'}])\n  augroup END\n\n  try\n    lvimgrep /.*/ *.mak\n  catch /E926:/\n  endtry\n  call assert_equal('tango down', getloclist(0, {'items' : 0}).items[0].text)\n  call assert_equal(1, getloclist(0, {'size' : 0}).size)\n\n  augroup QF_Test\n    au!\n  augroup END\n  unlet g:BufNum\n  %bw!\nendfunc\n\n\" Test for adding an invalid entry with the quickfix window open and making\n\" sure that the window contents are not changed\nfunc Test_add_invalid_entry_with_qf_window()\n  call setqflist([], 'f')\n  cexpr \"Xfile1:10:aa\"\n  copen\n  call setqflist(['bb'], 'a')\n  call assert_equal(1, line('$'))\n  call assert_equal(['Xfile1|10| aa'], getline(1, '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                                          , 'bufnr': bufnr('Xfile1') , 'col': 0                     , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10| aa']               , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10| aa']               , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10| aa']               , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10 col 666| aa']       , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10 col 666| aa']       , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10 col 666-222| aa']   , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': 6 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10-6 col 666-222| aa'] , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 6 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n  cclose\nendfunc\n\n\" Test for very weird problem: autocommand causes a failure, resulting opening\n\" the quickfix window to fail. This still splits the window, but otherwise\n\" should not mess up buffers.\nfunc Test_quickfix_window_fails_to_open()\n  CheckScreendump\n\n  let lines =<< trim END\n      anything\n      try\n        anything\n      endtry\n  END\n  call writefile(lines, 'XquickfixFails')\n\n  let lines =<< trim END\n      split XquickfixFails\n      silent vimgrep anything %\n      normal o\n      au BufLeave * ++once source XquickfixFails\n      \" This will trigger the autocommand, which causes an error, what follows\n      \" is aborted but the window was already split.\n      silent! cwindow\n  END\n  call writefile(lines, 'XtestWinFails')\n  let buf = RunVimInTerminal('-S XtestWinFails', #{rows: 13})\n  call VerifyScreenDump(buf, 'Test_quickfix_window_fails', {})\n\n  \" clean up\n  call term_sendkeys(buf, \":bwipe!\\<CR>\")\n  call term_wait(buf)\n  call StopVimInTerminal(buf)\n  call delete('XtestWinFails')\n  call delete('XquickfixFails')\nendfunc\n\n\" Test for updating the quickfix buffer whenever the associated quickfix list\n\" is changed.\nfunc Xqfbuf_update(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xexpr \"F1:1:line1\"\n  Xopen\n  call assert_equal(['F1|1| line1'], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  \" Test setqflist() using the 'lines' key in 'what'\n  \" add a new entry\n  call g:Xsetlist([], 'a', {'lines' : ['F2:2: line2']})\n  call assert_equal(['F1|1| line1', 'F2|2| line2'], getline(1, '$'))\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" replace all the entries with a single entry\n  call g:Xsetlist([], 'r', {'lines' : ['F3:3: line3']})\n  call assert_equal(['F3|3| line3'], getline(1, '$'))\n  call assert_equal(3, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" remove all the entries\n  call g:Xsetlist([], 'r', {'lines' : []})\n  call assert_equal([''], getline(1, '$'))\n  call assert_equal(4, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" add a new list\n  call g:Xsetlist([], ' ', {'lines' : ['F4:4: line4']})\n  call assert_equal(['F4|4| line4'], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  \" Test setqflist() using the 'items' key in 'what'\n  \" add a new entry\n  call g:Xsetlist([], 'a', {'items' : [{'filename' : 'F5', 'lnum' : 5, 'text' : 'line5'}]})\n  call assert_equal(['F4|4| line4', 'F5|5| line5'], getline(1, '$'))\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" replace all the entries with a single entry\n  call g:Xsetlist([], 'r', {'items' : [{'filename' : 'F6', 'lnum' : 6, 'text' : 'line6'}]})\n  call assert_equal(['F6|6| line6'], getline(1, '$'))\n  call assert_equal(3, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" remove all the entries\n  call g:Xsetlist([], 'r', {'items' : []})\n  call assert_equal([''], getline(1, '$'))\n  call assert_equal(4, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" add a new list\n  call g:Xsetlist([], ' ', {'items' : [{'filename' : 'F7', 'lnum' : 7, 'text' : 'line7'}]})\n  call assert_equal(['F7|7| line7'], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  call g:Xsetlist([], ' ', {})\n  call assert_equal([''], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  Xclose\nendfunc\n\nfunc Test_qfbuf_update()\n  call Xqfbuf_update('c')\n  call Xqfbuf_update('l')\nendfunc\n\nfunc Test_vimgrep_noswapfile()\n  set noswapfile\n  call writefile(['one', 'two', 'three'], 'Xgreppie')\n  vimgrep two Xgreppie\n  call assert_equal('two', getline('.'))\n\n  call delete('Xgreppie')\n  set swapfile\nendfunc\n\n\" Test for the :vimgrep 'f' flag (fuzzy match)\nfunc Xvimgrep_fuzzy_match(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xvimgrep /three one/f Xfile*\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal(['Xfile1', 1, 9, 'one two three'],\n        \\ [bufname(l[0].bufnr), l[0].lnum, l[0].col, l[0].text])\n  call assert_equal(['Xfile2', 2, 1, 'three one two'],\n        \\ [bufname(l[1].bufnr), l[1].lnum, l[1].col, l[1].text])\n\n  Xvimgrep /the/f Xfile*\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  call assert_equal(['Xfile1', 1, 9, 'one two three'],\n        \\ [bufname(l[0].bufnr), l[0].lnum, l[0].col, l[0].text])\n  call assert_equal(['Xfile2', 2, 1, 'three one two'],\n        \\ [bufname(l[1].bufnr), l[1].lnum, l[1].col, l[1].text])\n  call assert_equal(['Xfile2', 4, 4, 'aaathreeaaa'],\n        \\ [bufname(l[2].bufnr), l[2].lnum, l[2].col, l[2].text])\n\n  Xvimgrep /aaa/fg Xfile*\n  let l = g:Xgetlist()\n  call assert_equal(4, len(l))\n  call assert_equal(['Xfile1', 2, 1, 'aaaaaa'],\n        \\ [bufname(l[0].bufnr), l[0].lnum, l[0].col, l[0].text])\n  call assert_equal(['Xfile1', 2, 4, 'aaaaaa'],\n        \\ [bufname(l[1].bufnr), l[1].lnum, l[1].col, l[1].text])\n  call assert_equal(['Xfile2', 4, 1, 'aaathreeaaa'],\n        \\ [bufname(l[2].bufnr), l[2].lnum, l[2].col, l[2].text])\n  call assert_equal(['Xfile2', 4, 9, 'aaathreeaaa'],\n        \\ [bufname(l[3].bufnr), l[3].lnum, l[3].col, l[3].text])\n\n  call assert_fails('Xvimgrep /xyz/fg Xfile*', 'E480:')\nendfunc\n\nfunc Test_vimgrep_fuzzy_match()\n  call writefile(['one two three', 'aaaaaa'], 'Xfile1')\n  call writefile(['one', 'three one two', 'two', 'aaathreeaaa'], 'Xfile2')\n  call Xvimgrep_fuzzy_match('c')\n  call Xvimgrep_fuzzy_match('l')\n  call delete('Xfile1')\n  call delete('Xfile2')\nendfunc\n\nfunc Test_locationlist_open_in_newtab()\n  call s:create_test_file('Xqftestfile1')\n  call s:create_test_file('Xqftestfile2')\n  call s:create_test_file('Xqftestfile3')\n\n  %bwipe!\n\n  lgetexpr ['Xqftestfile1:5:Line5',\n\t\t\\ 'Xqftestfile2:10:Line10',\n\t\t\\ 'Xqftestfile3:16:Line16']\n\n  silent! llast\n  call assert_equal(1, tabpagenr('$'))\n  call assert_equal('Xqftestfile3', bufname())\n\n  set switchbuf=newtab\n\n  silent! lfirst\n  call assert_equal(2, tabpagenr('$'))\n  call assert_equal('Xqftestfile1', bufname())\n\n  silent! lnext\n  call assert_equal(3, tabpagenr('$'))\n  call assert_equal('Xqftestfile2', bufname())\n\n  call delete('Xqftestfile1')\n  call delete('Xqftestfile2')\n  call delete('Xqftestfile3')\n  set switchbuf&vim\n\n  %bwipe!\nendfunc\n\n\" Test for win_gettype() in quickfix and location list windows\nfunc Test_win_gettype()\n  copen\n  call assert_equal(\"quickfix\", win_gettype())\n  let wid = win_getid()\n  wincmd p\n  call assert_equal(\"quickfix\", win_gettype(wid))\n  cclose\n  lexpr ''\n  lopen\n  call assert_equal(\"loclist\", win_gettype())\n  let wid = win_getid()\n  wincmd p\n  call assert_equal(\"loclist\", win_gettype(wid))\n  lclose\nendfunc\n\nfun Test_vimgrep_nomatch()\n  call XexprTests('c')\n  call g:Xsetlist([{'lnum':10,'text':'Line1'}])\n  copen\n  if has(\"win32\")\n    call assert_fails('vimgrep foo *.zzz', 'E479:')\n    let expected = [{'lnum': 10, 'bufnr': 0, 'end_lnum': 0, 'pattern': '', 'valid': 0, 'vcol': 0, 'nr': 0, 'module': '', 'type': '', 'end_col': 0, 'col': 0, 'text': 'Line1'}]\n  else\n    call assert_fails('vimgrep foo *.zzz', 'E480:')\n    let expected = []\n  endif\n  call assert_equal(expected, getqflist())\n  cclose\nendfunc\n\n\" Test for opening the quickfix window in two tab pages and then closing one\n\" of the quickfix windows. This should not make the quickfix buffer unlisted.\n\" (github issue #9300).\nfunc Test_two_qf_windows()\n  cexpr \"F1:1:line1\"\n  copen\n  tabnew\n  copen\n  call assert_true(&buflisted)\n  cclose\n  tabfirst\n  call assert_true(&buflisted)\n  let bnum = bufnr()\n  cclose\n  \" if all the quickfix windows are closed, then buffer should be unlisted.\n  call assert_false(buflisted(bnum))\n  %bw!\n\n  \" Repeat the test for a location list\n  lexpr \"F2:2:line2\"\n  lopen\n  let bnum = bufnr()\n  tabnew\n  exe \"buffer\" bnum\n  tabfirst\n  lclose\n  tablast\n  call assert_true(buflisted(bnum))\n  tabclose\n  lopen\n  call assert_true(buflisted(bnum))\n  lclose\n  call assert_false(buflisted(bnum))\n  %bw!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * buffer.c: functions for dealing with the buffer structure\n */\n\n/*\n * The buffer list is a double linked list of all buffers.\n * Each buffer can be in one of these states:\n * never loaded: BF_NEVERLOADED is set, only the file name is valid\n *   not loaded: b_ml.ml_mfp == NULL, no memfile allocated\n *\t hidden: b_nwindows == 0, loaded but not displayed in a window\n *\t normal: loaded and displayed in a window\n *\n * Instead of storing file names all over the place, each file name is\n * stored in the buffer list. It can be referenced by a number.\n *\n * The current implementation remembers all file names ever used.\n */\n\n#include \"vim.h\"\n\n\n#ifdef FEAT_EVAL\n// Determines how deeply nested %{} blocks will be evaluated in statusline.\n# define MAX_STL_EVAL_DEPTH 100\n#endif\n\nstatic void\tenter_buffer(buf_T *buf);\nstatic void\tbuflist_getfpos(void);\nstatic char_u\t*buflist_match(regmatch_T *rmp, buf_T *buf, int ignore_case);\nstatic char_u\t*fname_match(regmatch_T *rmp, char_u *name, int ignore_case);\n#ifdef UNIX\nstatic buf_T\t*buflist_findname_stat(char_u *ffname, stat_T *st);\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname, stat_T *stp);\nstatic int\tbuf_same_ino(buf_T *buf, stat_T *stp);\n#else\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname);\n#endif\nstatic int\tvalue_changed(char_u *str, char_u **last);\nstatic int\tappend_arg_number(win_T *wp, char_u *buf, int buflen, int add_file);\nstatic void\tfree_buffer(buf_T *);\nstatic void\tfree_buffer_stuff(buf_T *buf, int free_options);\nstatic void\tclear_wininfo(buf_T *buf);\n\n#ifdef UNIX\n# define dev_T dev_t\n#else\n# define dev_T unsigned\n#endif\n\n#define FOR_ALL_BUFS_FROM_LAST(buf) \\\n    for ((buf) = lastbuf; (buf) != NULL; (buf) = (buf)->b_prev)\n\n#if defined(FEAT_QUICKFIX)\nstatic char *msg_loclist = N_(\"[Location List]\");\nstatic char *msg_qflist = N_(\"[Quickfix List]\");\n#endif\n\n// Number of times free_buffer() was called.\nstatic int\tbuf_free_count = 0;\n\nstatic int\ttop_file_num = 1;\t// highest file number\nstatic garray_T buf_reuse = GA_EMPTY;\t// file numbers to recycle\n\n/*\n * Return the highest possible buffer number.\n */\n    int\nget_highest_fnum(void)\n{\n    return top_file_num - 1;\n}\n\n/*\n * Read data from buffer for retrying.\n */\n    static int\nread_buffer(\n    int\t\tread_stdin,\t    // read file from stdin, otherwise fifo\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags)\t\t    // extra flags for readfile()\n{\n    int\t\tretval = OK;\n    linenr_T\tline_count;\n\n    // Read from the buffer which the text is already filled in and append at\n    // the end.  This makes it possible to retry when 'fileformat' or\n    // 'fileencoding' was guessed wrong.\n    line_count = curbuf->b_ml.ml_line_count;\n    retval = readfile(\n\t    read_stdin ? NULL : curbuf->b_ffname,\n\t    read_stdin ? NULL : curbuf->b_fname,\n\t    line_count, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t    flags | READ_BUFFER);\n    if (retval == OK)\n    {\n\t// Delete the binary lines.\n\twhile (--line_count >= 0)\n\t    ml_delete((linenr_T)1);\n    }\n    else\n    {\n\t// Delete the converted lines.\n\twhile (curbuf->b_ml.ml_line_count > line_count)\n\t    ml_delete(line_count);\n    }\n    // Put the cursor on the first line.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n\n    if (read_stdin)\n    {\n\t// Set or reset 'modified' before executing autocommands, so that\n\t// it can be changed there.\n\tif (!readonlymode && !BUFEMPTY())\n\t    changed();\n\telse if (retval == OK)\n\t    unchanged(curbuf, FALSE, TRUE);\n\n\tif (retval == OK)\n\t{\n#ifdef FEAT_EVAL\n\t    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t    apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);\n#endif\n\t}\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Ensure buffer \"buf\" is loaded.  Does not trigger the swap-exists action.\n */\n    void\nbuffer_ensure_loaded(buf_T *buf)\n{\n    if (buf->b_ml.ml_mfp == NULL)\n    {\n\taco_save_T\taco;\n\n\taucmd_prepbuf(&aco, buf);\n\tswap_exists_action = SEA_NONE;\n\topen_buffer(FALSE, NULL, 0);\n\taucmd_restbuf(&aco);\n    }\n}\n#endif\n\n/*\n * Open current buffer, that is: open the memfile and read the file into\n * memory.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nopen_buffer(\n    int\t\tread_stdin,\t    // read file from stdin\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags)\t\t    // extra flags for readfile()\n{\n    int\t\tretval = OK;\n    bufref_T\told_curbuf;\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    int\t\tread_fifo = FALSE;\n\n    // The 'readonly' flag is only set when BF_NEVERLOADED is being reset.\n    // When re-entering the same buffer, it should not change, because the\n    // user may have reset the flag by hand.\n    if (readonlymode && curbuf->b_ffname != NULL\n\t\t\t\t\t&& (curbuf->b_flags & BF_NEVERLOADED))\n\tcurbuf->b_p_ro = TRUE;\n\n    if (ml_open(curbuf) == FAIL)\n    {\n\t// There MUST be a memfile, otherwise we can't do anything\n\t// If we can't create one for the current buffer, take another buffer\n\tclose_buffer(NULL, curbuf, 0, FALSE, FALSE);\n\tFOR_ALL_BUFFERS(curbuf)\n\t    if (curbuf->b_ml.ml_mfp != NULL)\n\t\tbreak;\n\t// If there is no memfile at all, exit.\n\t// This is OK, since there are no changes to lose.\n\tif (curbuf == NULL)\n\t{\n\t    emsg(_(e_cannot_allocate_any_buffer_exiting));\n\n\t    // Don't try to do any saving, with \"curbuf\" NULL almost nothing\n\t    // will work.\n\t    v_dying = 2;\n\t    getout(2);\n\t}\n\n\temsg(_(e_cannot_allocate_buffer_using_other_one));\n\tenter_buffer(curbuf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n\treturn FAIL;\n    }\n\n    // The autocommands in readfile() may change the buffer, but only AFTER\n    // reading the file.\n    set_bufref(&old_curbuf, curbuf);\n    modified_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    if (curbuf->b_ffname != NULL\n#ifdef FEAT_NETBEANS_INTG\n\t    && netbeansReadFile\n#endif\n       )\n    {\n\tint old_msg_silent = msg_silent;\n#ifdef UNIX\n\tint save_bin = curbuf->b_p_bin;\n\tint perm;\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\tint oldFire = netbeansFireChanges;\n\n\tnetbeansFireChanges = 0;\n#endif\n#ifdef UNIX\n\tperm = mch_getperm(curbuf->b_ffname);\n\tif (perm >= 0 && (S_ISFIFO(perm)\n\t\t      || S_ISSOCK(perm)\n# ifdef OPEN_CHR_FILES\n\t\t      || (S_ISCHR(perm) && is_dev_fd_file(curbuf->b_ffname))\n# endif\n\t\t    ))\n\t\tread_fifo = TRUE;\n\tif (read_fifo)\n\t    curbuf->b_p_bin = TRUE;\n#endif\n\tif (shortmess(SHM_FILEINFO))\n\t    msg_silent = 1;\n\tretval = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t\t  flags | READ_NEW | (read_fifo ? READ_FIFO : 0));\n#ifdef UNIX\n\tif (read_fifo)\n\t{\n\t    curbuf->b_p_bin = save_bin;\n\t    if (retval == OK)\n\t\tretval = read_buffer(FALSE, eap, flags);\n\t}\n#endif\n\tmsg_silent = old_msg_silent;\n#ifdef FEAT_NETBEANS_INTG\n\tnetbeansFireChanges = oldFire;\n#endif\n\t// Help buffer is filtered.\n\tif (bt_help(curbuf))\n\t    fix_help_buffer();\n    }\n    else if (read_stdin)\n    {\n\tint\tsave_bin = curbuf->b_p_bin;\n\n\t// First read the text in binary mode into the buffer.\n\t// Then read from that same buffer and append at the end.  This makes\n\t// it possible to retry when 'fileformat' or 'fileencoding' was\n\t// guessed wrong.\n\tcurbuf->b_p_bin = TRUE;\n\tretval = readfile(NULL, NULL, (linenr_T)0,\n\t\t  (linenr_T)0, (linenr_T)MAXLNUM, NULL,\n\t\t  flags | (READ_NEW + READ_STDIN));\n\tcurbuf->b_p_bin = save_bin;\n\tif (retval == OK)\n\t    retval = read_buffer(TRUE, eap, flags);\n    }\n\n    // if first time loading this buffer, init b_chartab[]\n    if (curbuf->b_flags & BF_NEVERLOADED)\n    {\n\t(void)buf_init_chartab(curbuf, FALSE);\n#ifdef FEAT_CINDENT\n\tparse_cino(curbuf);\n#endif\n    }\n\n    // Set/reset the Changed flag first, autocmds may change the buffer.\n    // Apply the automatic commands, before processing the modelines.\n    // So the modelines have priority over autocommands.\n    //\n    // When reading stdin, the buffer contents always needs writing, so set\n    // the changed flag.  Unless in readonly mode: \"ls | gview -\".\n    // When interrupted and 'cpoptions' contains 'i' set changed flag.\n    if ((got_int && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n\t\t|| modified_was_set\t// \":set modified\" used in autocmd\n#ifdef FEAT_EVAL\n\t\t|| (aborting() && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n#endif\n       )\n\tchanged();\n    else if (retval == OK && !read_stdin && !read_fifo)\n\tunchanged(curbuf, FALSE, TRUE);\n    save_file_ff(curbuf);\t\t// keep this fileformat\n\n    // Set last_changedtick to avoid triggering a TextChanged autocommand right\n    // after it was added.\n    curbuf->b_last_changedtick = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_pum = CHANGEDTICK(curbuf);\n\n    // require \"!\" to overwrite the file, because it wasn't read completely\n#ifdef FEAT_EVAL\n    if (aborting())\n#else\n    if (got_int)\n#endif\n\tcurbuf->b_flags |= BF_READERR;\n\n#ifdef FEAT_FOLDING\n    // Need to update automatic folding.  Do this before the autocommands,\n    // they may use the fold info.\n    foldUpdateAll(curwin);\n#endif\n\n    // need to set w_topline, unless some autocommand already did that.\n    if (!(curwin->w_valid & VALID_TOPLINE))\n    {\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n    }\n#ifdef FEAT_EVAL\n    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf, &retval);\n#else\n    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n    if (retval == OK)\n    {\n\t// The autocommands may have changed the current buffer.  Apply the\n\t// modelines to the correct buffer, if it still exists and is loaded.\n\tif (bufref_valid(&old_curbuf) && old_curbuf.br_buf->b_ml.ml_mfp != NULL)\n\t{\n\t    aco_save_T\taco;\n\n\t    // Go to the buffer that was opened.\n\t    aucmd_prepbuf(&aco, old_curbuf.br_buf);\n\t    do_modelines(0);\n\t    curbuf->b_flags &= ~(BF_CHECK_RO | BF_NEVERLOADED);\n\n\t    if ((flags & READ_NOWINENTER) == 0)\n#ifdef FEAT_EVAL\n\t\tapply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n\t    // restore curwin/curbuf and a few other things\n\t    aucmd_restbuf(&aco);\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Store \"buf\" in \"bufref\" and set the free count.\n */\n    void\nset_bufref(bufref_T *bufref, buf_T *buf)\n{\n    bufref->br_buf = buf;\n    bufref->br_fnum = buf == NULL ? 0 : buf->b_fnum;\n    bufref->br_buf_free_count = buf_free_count;\n}\n\n/*\n * Return TRUE if \"bufref->br_buf\" points to the same buffer as when\n * set_bufref() was called and it is a valid buffer.\n * Only goes through the buffer list if buf_free_count changed.\n * Also checks if b_fnum is still the same, a :bwipe followed by :new might get\n * the same allocated memory, but it's a different buffer.\n */\n    int\nbufref_valid(bufref_T *bufref)\n{\n    return bufref->br_buf_free_count == buf_free_count\n\t? TRUE : buf_valid(bufref->br_buf)\n\t\t\t\t  && bufref->br_fnum == bufref->br_buf->b_fnum;\n}\n\n/*\n * Return TRUE if \"buf\" points to a valid buffer (in the buffer list).\n * This can be slow if there are many buffers, prefer using bufref_valid().\n */\n    int\nbuf_valid(buf_T *buf)\n{\n    buf_T\t*bp;\n\n    // Assume that we more often have a recent buffer, start with the last\n    // one.\n    FOR_ALL_BUFS_FROM_LAST(bp)\n\tif (bp == buf)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * A hash table used to quickly lookup a buffer by its number.\n */\nstatic hashtab_T buf_hashtab;\n\n    static void\nbuf_hashtab_add(buf_T *buf)\n{\n    sprintf((char *)buf->b_key, \"%x\", buf->b_fnum);\n    if (hash_add(&buf_hashtab, buf->b_key) == FAIL)\n\temsg(_(e_buffer_cannot_be_registered));\n}\n\n    static void\nbuf_hashtab_remove(buf_T *buf)\n{\n    hashitem_T *hi = hash_find(&buf_hashtab, buf->b_key);\n\n    if (!HASHITEM_EMPTY(hi))\n\thash_remove(&buf_hashtab, hi);\n}\n\n/*\n * Return TRUE when buffer \"buf\" can be unloaded.\n * Give an error message and return FALSE when the buffer is locked or the\n * screen is being redrawn and the buffer is in a window.\n */\n    static int\ncan_unload_buffer(buf_T *buf)\n{\n    int\t    can_unload = !buf->b_locked;\n\n    if (can_unload && updating_screen)\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str), buf->b_fname);\n    return can_unload;\n}\n\n/*\n * Close the link to a buffer.\n * \"action\" is used when there is no longer a window for the buffer.\n * It can be:\n * 0\t\t\tbuffer becomes hidden\n * DOBUF_UNLOAD\t\tbuffer is unloaded\n * DOBUF_DELETE\t\tbuffer is unloaded and removed from buffer list\n * DOBUF_WIPE\t\tbuffer is unloaded and really deleted\n * DOBUF_WIPE_REUSE\tidem, and add to buf_reuse list\n * When doing all but the first one on the current buffer, the caller should\n * get a new buffer very soon!\n *\n * The 'bufhidden' option can force freeing and deleting.\n *\n * When \"abort_if_last\" is TRUE then do not close the buffer if autocommands\n * cause there to be only one window with this buffer.  e.g. when \":quit\" is\n * supposed to close the window but autocommands close all other windows.\n *\n * When \"ignore_abort\" is TRUE don't abort even when aborting() returns TRUE.\n *\n * Return TRUE when we got to the end and b_nwindows was decremented.\n */\n    int\nclose_buffer(\n    win_T\t*win,\t\t// if not NULL, set b_last_cursor\n    buf_T\t*buf,\n    int\t\taction,\n    int\t\tabort_if_last,\n    int\t\tignore_abort)\n{\n    int\t\tis_curbuf;\n    int\t\tnwindows;\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n    int\t\tunload_buf = (action != 0);\n    int\t\twipe_buf = (action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n    int\t\tdel_buf = (action == DOBUF_DEL || wipe_buf);\n\n    CHECK_CURBUF;\n\n    // Force unloading or deleting when 'bufhidden' says so.\n    // The caller must take care of NOT deleting/freeing when 'bufhidden' is\n    // \"hide\" (otherwise we could never free or delete a buffer).\n    if (buf->b_p_bh[0] == 'd')\t\t// 'bufhidden' == \"delete\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'w')\t// 'bufhidden' == \"wipe\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n\twipe_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'u')\t// 'bufhidden' == \"unload\"\n\tunload_buf = TRUE;\n\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(buf) && (buf->b_nwindows == 1 || del_buf))\n    {\n\tCHECK_CURBUF;\n\tif (term_job_running(buf->b_term))\n\t{\n\t    if (wipe_buf || unload_buf)\n\t    {\n\t\tif (!can_unload_buffer(buf))\n\t\t    return FALSE;\n\n\t\t// Wiping out or unloading a terminal buffer kills the job.\n\t\tfree_terminal(buf);\n\t    }\n\t    else\n\t    {\n\t\t// The job keeps running, hide the buffer.\n\t\tdel_buf = FALSE;\n\t\tunload_buf = FALSE;\n\t    }\n\t}\n\telse if (buf->b_p_bh[0] == 'h' && !del_buf)\n\t{\n\t    // Hide a terminal buffer.\n\t    unload_buf = FALSE;\n\t}\n\telse\n\t{\n\t    // A terminal buffer is wiped out if the job has finished.\n\t    del_buf = TRUE;\n\t    unload_buf = TRUE;\n\t    wipe_buf = TRUE;\n\t}\n\tCHECK_CURBUF;\n    }\n#endif\n\n    // Disallow deleting the buffer when it is locked (already being closed or\n    // halfway a command that relies on it). Unloading is allowed.\n    if ((del_buf || wipe_buf) && !can_unload_buffer(buf))\n\treturn FALSE;\n\n    // check no autocommands closed the window\n    if (win != NULL && win_valid_any_tab(win))\n    {\n\t// Set b_last_cursor when closing the last window for the buffer.\n\t// Remember the last cursor position and window options of the buffer.\n\t// This used to be only for the current window, but then options like\n\t// 'foldmethod' may be lost with a \":only\" command.\n\tif (buf->b_nwindows == 1)\n\t    set_last_cursor(win);\n\tbuflist_setfpos(buf, win,\n\t\t    win->w_cursor.lnum == 1 ? 0 : win->w_cursor.lnum,\n\t\t    win->w_cursor.col, TRUE);\n    }\n\n    set_bufref(&bufref, buf);\n\n    // When the buffer is no longer in a window, trigger BufWinLeave\n    if (buf->b_nwindows == 1)\n    {\n\t++buf->b_locked;\n\t++buf->b_locked_split;\n\tif (apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t{\n\t    // Autocommands deleted the buffer.\naucmd_abort:\n\t    emsg(_(e_autocommands_caused_command_to_abort));\n\t    return FALSE;\n\t}\n\t--buf->b_locked;\n\t--buf->b_locked_split;\n\tif (abort_if_last && one_window())\n\t    // Autocommands made this the only window.\n\t    goto aucmd_abort;\n\n\t// When the buffer becomes hidden, but is not unloaded, trigger\n\t// BufHidden\n\tif (!unload_buf)\n\t{\n\t    ++buf->b_locked;\n\t    ++buf->b_locked_split;\n\t    if (apply_autocmds(EVENT_BUFHIDDEN, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\t// Autocommands deleted the buffer.\n\t\tgoto aucmd_abort;\n\t    --buf->b_locked;\n\t    --buf->b_locked_split;\n\t    if (abort_if_last && one_window())\n\t\t// Autocommands made this the only window.\n\t\tgoto aucmd_abort;\n\t}\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (!ignore_abort && aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n    nwindows = buf->b_nwindows;\n\n    // decrease the link count from windows (unless not in any window)\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n#ifdef FEAT_DIFF\n    if (diffopt_hiddenoff() && !unload_buf && buf->b_nwindows == 0)\n\tdiff_buf_delete(buf);\t// Clear 'diff' for hidden buffer.\n#endif\n\n    // Return when a window is displaying the buffer or when it's not\n    // unloaded.\n    if (buf->b_nwindows > 0 || !unload_buf)\n\treturn FALSE;\n\n    // Always remove the buffer when there is no file name.\n    if (buf->b_ffname == NULL)\n\tdel_buf = TRUE;\n\n    // When closing the current buffer stop Visual mode before freeing\n    // anything.\n    if (buf == curbuf && VIsual_active\n#if defined(EXITFREE)\n\t    && !entered_free_all_mem\n#endif\n\t    )\n\tend_visual_mode();\n\n    // Free all things allocated for this buffer.\n    // Also calls the \"BufDelete\" autocommands when del_buf is TRUE.\n    //\n    // Remember if we are closing the current buffer.  Restore the number of\n    // windows, so that autocommands in buf_freeall() don't get confused.\n    is_curbuf = (buf == curbuf);\n    buf->b_nwindows = nwindows;\n\n    buf_freeall(buf, (del_buf ? BFA_DEL : 0)\n\t\t   + (wipe_buf ? BFA_WIPE : 0)\n\t\t   + (ignore_abort ? BFA_IGNORE_ABORT : 0));\n\n    // Autocommands may have deleted the buffer.\n    if (!bufref_valid(&bufref))\n\treturn FALSE;\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if (!ignore_abort && aborting())\n\treturn FALSE;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause the previous curbuf to be deleted unexpectedly.  But\n    // in some cases it's OK to delete the curbuf, because a new one is\n    // obtained anyway.  Therefore only return if curbuf changed to the\n    // deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn FALSE;\n\n    if (win_valid_any_tab(win) && win->w_buffer == buf)\n\twin->w_buffer = NULL;  // make sure we don't use the buffer now\n\n    // Autocommands may have opened or closed windows for this buffer.\n    // Decrement the count for the close we do here.\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n    /*\n     * Remove the buffer from the list.\n     */\n    if (wipe_buf)\n    {\n\tif (action == DOBUF_WIPE_REUSE)\n\t{\n\t    // we can re-use this buffer number, store it\n\t    if (buf_reuse.ga_itemsize == 0)\n\t\tga_init2(&buf_reuse, sizeof(int), 50);\n\t    if (ga_grow(&buf_reuse, 1) == OK)\n\t\t((int *)buf_reuse.ga_data)[buf_reuse.ga_len++] = buf->b_fnum;\n\t}\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf->b_prev == NULL)\n\t    firstbuf = buf->b_next;\n\telse\n\t    buf->b_prev->b_next = buf->b_next;\n\tif (buf->b_next == NULL)\n\t    lastbuf = buf->b_prev;\n\telse\n\t    buf->b_next->b_prev = buf->b_prev;\n\tfree_buffer(buf);\n    }\n    else\n    {\n\tif (del_buf)\n\t{\n\t    // Free all internal variables and reset option values, to make\n\t    // \":bdel\" compatible with Vim 5.7.\n\t    free_buffer_stuff(buf, TRUE);\n\n\t    // Make it look like a new buffer.\n\t    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n\n\t    // Init the options when loaded again.\n\t    buf->b_p_initialized = FALSE;\n\t}\n\tbuf_clear_file(buf);\n\tif (del_buf)\n\t    buf->b_p_bl = FALSE;\n    }\n    // NOTE: at this point \"curbuf\" may be invalid!\n    return TRUE;\n}\n\n/*\n * Make buffer not contain a file.\n */\n    void\nbuf_clear_file(buf_T *buf)\n{\n    buf->b_ml.ml_line_count = 1;\n    unchanged(buf, TRUE, TRUE);\n    buf->b_shortname = FALSE;\n    buf->b_p_eol = TRUE;\n    buf->b_start_eol = TRUE;\n    buf->b_p_bomb = FALSE;\n    buf->b_start_bomb = FALSE;\n    buf->b_ml.ml_mfp = NULL;\n    buf->b_ml.ml_flags = ML_EMPTY;\t\t// empty buffer\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_deleted_all_lines(buf);\n#endif\n}\n\n/*\n * buf_freeall() - free all things allocated for a buffer that are related to\n * the file.  Careful: get here with \"curwin\" NULL when exiting.\n * flags:\n * BFA_DEL\t     buffer is going to be deleted\n * BFA_WIPE\t     buffer is going to be wiped out\n * BFA_KEEP_UNDO     do not free undo information\n * BFA_IGNORE_ABORT  don't abort even when aborting() returns TRUE\n */\n    void\nbuf_freeall(buf_T *buf, int flags)\n{\n    int\t\tis_curbuf = (buf == curbuf);\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n\n    // Make sure the buffer isn't closed by autocommands.\n    ++buf->b_locked;\n    ++buf->b_locked_split;\n    set_bufref(&bufref, buf);\n    if (buf->b_ml.ml_mfp != NULL)\n    {\n\tif (apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if ((flags & BFA_DEL) && buf->b_p_bl)\n    {\n\tif (apply_autocmds(EVENT_BUFDELETE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t   FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if (flags & BFA_WIPE)\n    {\n\tif (apply_autocmds(EVENT_BUFWIPEOUT, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    --buf->b_locked;\n    --buf->b_locked_split;\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if ((flags & BFA_IGNORE_ABORT) == 0 && aborting())\n\treturn;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause curbuf to be deleted unexpectedly.  But in some cases\n    // it's OK to delete the curbuf, because a new one is obtained anyway.\n    // Therefore only return if curbuf changed to the deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn;\n#ifdef FEAT_DIFF\n    diff_buf_delete(buf);\t    // Can't use 'diff' for unloaded buffer.\n#endif\n#ifdef FEAT_SYN_HL\n    // Remove any ownsyntax, unless exiting.\n    if (curwin != NULL && curwin->w_buffer == buf)\n\treset_synblock(curwin);\n#endif\n\n#ifdef FEAT_FOLDING\n    // No folds in an empty buffer.\n    {\n\twin_T\t\t*win;\n\ttabpage_T\t*tp;\n\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t    if (win->w_buffer == buf)\n\t\tclearFolding(win);\n    }\n#endif\n\n#ifdef FEAT_TCL\n    tcl_buffer_free(buf);\n#endif\n    ml_close(buf, TRUE);\t    // close and delete the memline/memfile\n    buf->b_ml.ml_line_count = 0;    // no lines in buffer\n    if ((flags & BFA_KEEP_UNDO) == 0)\n    {\n\tu_blockfree(buf);\t    // free the memory allocated for undo\n\tu_clearall(buf);\t    // reset all undo information\n    }\n#ifdef FEAT_SYN_HL\n    syntax_clear(&buf->b_s);\t    // reset syntax info\n#endif\n#ifdef FEAT_PROP_POPUP\n    clear_buf_prop_types(buf);\n#endif\n    buf->b_flags &= ~BF_READERR;    // a read error is no longer relevant\n}\n\n/*\n * Free a buffer structure and the things it contains related to the buffer\n * itself (not the file, that must have been done already).\n */\n    static void\nfree_buffer(buf_T *buf)\n{\n    ++buf_free_count;\n    free_buffer_stuff(buf, TRUE);\n#ifdef FEAT_EVAL\n    // b:changedtick uses an item in buf_T, remove it now\n    dictitem_remove(buf->b_vars, (dictitem_T *)&buf->b_ct_di);\n    unref_var_dict(buf->b_vars);\n    remove_listeners(buf);\n#endif\n#ifdef FEAT_LUA\n    lua_buffer_free(buf);\n#endif\n#ifdef FEAT_MZSCHEME\n    mzscheme_buffer_free(buf);\n#endif\n#ifdef FEAT_PERL\n    perl_buf_free(buf);\n#endif\n#ifdef FEAT_PYTHON\n    python_buffer_free(buf);\n#endif\n#ifdef FEAT_PYTHON3\n    python3_buffer_free(buf);\n#endif\n#ifdef FEAT_RUBY\n    ruby_buffer_free(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    channel_buffer_free(buf);\n#endif\n#ifdef FEAT_TERMINAL\n    free_terminal(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    vim_free(buf->b_prompt_text);\n    free_callback(&buf->b_prompt_callback);\n    free_callback(&buf->b_prompt_interrupt);\n#endif\n\n    buf_hashtab_remove(buf);\n\n    aubuflocal_remove(buf);\n\n    if (autocmd_busy)\n    {\n\t// Do not free the buffer structure while autocommands are executing,\n\t// it's still needed. Free it when autocmd_busy is reset.\n\tbuf->b_next = au_pending_free_buf;\n\tau_pending_free_buf = buf;\n    }\n    else\n    {\n\tvim_free(buf);\n\tif (curbuf == buf)\n\t    curbuf = NULL;  // make clear it's not to be used\n    }\n}\n\n/*\n * Initializes b:changedtick.\n */\n    static void\ninit_changedtick(buf_T *buf)\n{\n    dictitem_T *di = (dictitem_T *)&buf->b_ct_di;\n\n    di->di_flags = DI_FLAGS_FIX | DI_FLAGS_RO;\n    di->di_tv.v_type = VAR_NUMBER;\n    di->di_tv.v_lock = VAR_FIXED;\n    di->di_tv.vval.v_number = 0;\n\n#ifdef FEAT_EVAL\n    STRCPY(buf->b_ct_di.di_key, \"changedtick\");\n    (void)dict_add(buf->b_vars, di);\n#endif\n}\n\n/*\n * Free stuff in the buffer for \":bdel\" and when wiping out the buffer.\n */\n    static void\nfree_buffer_stuff(\n    buf_T\t*buf,\n    int\t\tfree_options)\t\t// free options as well\n{\n    if (free_options)\n    {\n\tclear_wininfo(buf);\t\t// including window-local options\n\tfree_buf_options(buf, TRUE);\n#ifdef FEAT_SPELL\n\tga_clear(&buf->b_s.b_langp);\n#endif\n    }\n#ifdef FEAT_EVAL\n    {\n\tvarnumber_T tick = CHANGEDTICK(buf);\n\n\tvars_clear(&buf->b_vars->dv_hashtab); // free all buffer variables\n\thash_init(&buf->b_vars->dv_hashtab);\n\tinit_changedtick(buf);\n\tCHANGEDTICK(buf) = tick;\n\tremove_listeners(buf);\n    }\n#endif\n    uc_clear(&buf->b_ucmds);\t\t// clear local user commands\n#ifdef FEAT_SIGNS\n    buf_delete_signs(buf, (char_u *)\"*\");\t// delete any signs\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_file_killed(buf);\n#endif\n    map_clear_int(buf, MAP_ALL_MODES, TRUE, FALSE);  // clear local mappings\n    map_clear_int(buf, MAP_ALL_MODES, TRUE, TRUE);   // clear local abbrevs\n    VIM_CLEAR(buf->b_start_fenc);\n}\n\n/*\n * Free one wininfo_T.\n */\n    void\nfree_wininfo(wininfo_T *wip)\n{\n    if (wip->wi_optset)\n    {\n\tclear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\tdeleteFoldRecurse(&wip->wi_folds);\n#endif\n    }\n    vim_free(wip);\n}\n\n/*\n * Free the b_wininfo list for buffer \"buf\".\n */\n    static void\nclear_wininfo(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    while (buf->b_wininfo != NULL)\n    {\n\twip = buf->b_wininfo;\n\tbuf->b_wininfo = wip->wi_next;\n\tfree_wininfo(wip);\n    }\n}\n\n/*\n * Go to another buffer.  Handles the result of the ATTENTION dialog.\n */\n    void\ngoto_buffer(\n    exarg_T\t*eap,\n    int\t\tstart,\n    int\t\tdir,\n    int\t\tcount)\n{\n    bufref_T\told_curbuf;\n\n    set_bufref(&old_curbuf, curbuf);\n\n    swap_exists_action = SEA_DIALOG;\n    (void)do_buffer(*eap->cmd == 's' ? DOBUF_SPLIT : DOBUF_GOTO,\n\t\t\t\t\t     start, dir, count, eap->forceit);\n    if (swap_exists_action == SEA_QUIT && *eap->cmd == 's')\n    {\n#if defined(FEAT_EVAL)\n\tcleanup_T   cs;\n\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a window.\n\tenter_cleanup(&cs);\n#endif\n\n\t// Quitting means closing the split window, nothing else.\n\twin_close(curwin, TRUE);\n\tswap_exists_action = SEA_NONE;\n\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else\n\thandle_swap_exists(&old_curbuf);\n}\n\n/*\n * Handle the situation of swap_exists_action being set.\n * It is allowed for \"old_curbuf\" to be NULL or invalid.\n */\n    void\nhandle_swap_exists(bufref_T *old_curbuf)\n{\n#if defined(FEAT_EVAL)\n    cleanup_T\tcs;\n#endif\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    buf_T\t*buf;\n\n    if (swap_exists_action == SEA_QUIT)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Quit at ATTENTION prompt.  Go back to previous\n\t// buffer.  If that buffer is gone or the same as the current one,\n\t// open a new, empty buffer.\n\tswap_exists_action = SEA_NONE;\t// don't want it again\n\tswap_exists_did_quit = TRUE;\n\tclose_buffer(curwin, curbuf, DOBUF_UNLOAD, FALSE, FALSE);\n\tif (old_curbuf == NULL || !bufref_valid(old_curbuf)\n\t\t\t\t\t      || old_curbuf->br_buf == curbuf)\n\t{\n\t    // Block autocommands here because curwin->w_buffer is NULL.\n\t    block_autocmds();\n\t    buf = buflist_new(NULL, NULL, 1L, BLN_CURBUF | BLN_LISTED);\n\t    unblock_autocmds();\n\t}\n\telse\n\t    buf = old_curbuf->br_buf;\n\tif (buf != NULL)\n\t{\n\t    int old_msg_silent = msg_silent;\n\n\t    if (shortmess(SHM_FILEINFO))\n\t\tmsg_silent = 1;  // prevent fileinfo message\n\t    enter_buffer(buf);\n\t    // restore msg_silent, so that the command line will be shown\n\t    msg_silent = old_msg_silent;\n\n#ifdef FEAT_SYN_HL\n\t    if (old_tw != curbuf->b_p_tw)\n\t\tcheck_colorcolumn(curwin);\n#endif\n\t}\n\t// If \"old_curbuf\" is NULL we are in big trouble here...\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else if (swap_exists_action == SEA_RECOVER)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Recover at ATTENTION prompt.\n\tmsg_scroll = TRUE;\n\tml_recover(FALSE);\n\tmsg_puts(\"\\n\");\t// don't overwrite the last message\n\tcmdline_row = msg_row;\n\tdo_modelines(0);\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    swap_exists_action = SEA_NONE;\n}\n\n/*\n * Make the current buffer empty.\n * Used when it is wiped out and it's the last buffer.\n */\n    static int\nempty_curbuf(\n    int close_others,\n    int forceit,\n    int action)\n{\n    int\t    retval;\n    buf_T   *buf = curbuf;\n    bufref_T bufref;\n\n    if (action == DOBUF_UNLOAD)\n    {\n\temsg(_(e_cannot_unload_last_buffer));\n\treturn FAIL;\n    }\n\n    set_bufref(&bufref, buf);\n    if (close_others)\n\t// Close any other windows on this buffer, then make it empty.\n\tclose_windows(buf, TRUE);\n\n    setpcmark();\n    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,\n\t\t\t\t\t  forceit ? ECMD_FORCEIT : 0, curwin);\n\n    // do_ecmd() may create a new buffer, then we have to delete\n    // the old one.  But do_ecmd() may have done that already, check\n    // if the buffer still exists.\n    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows == 0)\n\tclose_buffer(NULL, buf, action, FALSE, FALSE);\n    if (!close_others)\n\tneed_fileinfo = FALSE;\n    return retval;\n}\n\n/*\n * Implementation of the commands for the buffer list.\n *\n * action == DOBUF_GOTO\t    go to specified buffer\n * action == DOBUF_SPLIT    split window and go to specified buffer\n * action == DOBUF_UNLOAD   unload specified buffer(s)\n * action == DOBUF_DEL\t    delete specified buffer(s) from buffer list\n * action == DOBUF_WIPE\t    delete specified buffer(s) really\n * action == DOBUF_WIPE_REUSE idem, and add number to \"buf_reuse\"\n *\n * start == DOBUF_CURRENT   go to \"count\" buffer from current buffer\n * start == DOBUF_FIRST\t    go to \"count\" buffer from first buffer\n * start == DOBUF_LAST\t    go to \"count\" buffer from last buffer\n * start == DOBUF_MOD\t    go to \"count\" modified buffer from current buffer\n *\n * Return FAIL or OK.\n */\n    static int\ndo_buffer_ext(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tflags)\t\t// DOBUF_FORCEIT etc.\n{\n    buf_T\t*buf;\n    buf_T\t*bp;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n\n    switch (start)\n    {\n\tcase DOBUF_FIRST:   buf = firstbuf; break;\n\tcase DOBUF_LAST:    buf = lastbuf;  break;\n\tdefault:\t    buf = curbuf;   break;\n    }\n    if (start == DOBUF_MOD)\t    // find next modified buffer\n    {\n\twhile (count-- > 0)\n\t{\n\t    do\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    while (buf != curbuf && !bufIsChanged(buf));\n\t}\n\tif (!bufIsChanged(buf))\n\t{\n\t    emsg(_(e_no_modified_buffer_found));\n\t    return FAIL;\n\t}\n    }\n    else if (start == DOBUF_FIRST && count) // find specified buffer number\n    {\n\twhile (buf != NULL && buf->b_fnum != count)\n\t    buf = buf->b_next;\n    }\n    else\n    {\n\tbp = NULL;\n\twhile (count > 0 || (!unload && !buf->b_p_bl && bp != buf))\n\t{\n\t    // remember the buffer where we start, we come back there when all\n\t    // buffers are unlisted.\n\t    if (bp == NULL)\n\t\tbp = buf;\n\t    if (dir == FORWARD)\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    else\n\t    {\n\t\tbuf = buf->b_prev;\n\t\tif (buf == NULL)\n\t\t    buf = lastbuf;\n\t    }\n\t    // don't count unlisted buffers\n\t    if (unload || buf->b_p_bl)\n\t    {\n\t\t --count;\n\t\t bp = NULL;\t// use this buffer as new starting point\n\t    }\n\t    if (bp == buf)\n\t    {\n\t\t// back where we started, didn't find anything.\n\t\temsg(_(e_there_is_no_listed_buffer));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n\n    if (buf == NULL)\t    // could not find it\n    {\n\tif (start == DOBUF_FIRST)\n\t{\n\t    // don't warn when deleting\n\t    if (!unload)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\t}\n\telse if (dir == FORWARD)\n\t    emsg(_(e_cannot_go_beyond_last_buffer));\n\telse\n\t    emsg(_(e_cannot_go_before_first_buffer));\n\treturn FAIL;\n    }\n#ifdef FEAT_PROP_POPUP\n    if ((flags & DOBUF_NOPOPUP) && bt_popup(buf)\n# ifdef FEAT_TERMINAL\n\t\t\t\t&& !bt_terminal(buf)\n#endif\n       )\n\treturn OK;\n#endif\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * delete buffer \"buf\" from memory and/or the list\n     */\n    if (unload)\n    {\n\tint\tforward;\n\tbufref_T bufref;\n\n\tif (!can_unload_buffer(buf))\n\t    return FAIL;\n\n\tset_bufref(&bufref, buf);\n\n\t// When unloading or deleting a buffer that's already unloaded and\n\t// unlisted: fail silently.\n\tif (action != DOBUF_WIPE && action != DOBUF_WIPE_REUSE\n\t\t\t\t   && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl)\n\t    return FAIL;\n\n\tif ((flags & DOBUF_FORCEIT) == 0 && bufIsChanged(buf))\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n\t\tdialog_changed(buf, FALSE);\n\t\tif (!bufref_valid(&bufref))\n\t\t    // Autocommand deleted buffer, oops!  It's not changed\n\t\t    // now.\n\t\t    return FAIL;\n\t\t// If it's still changed fail silently, the dialog already\n\t\t// mentioned why it fails.\n\t\tif (bufIsChanged(buf))\n\t\t    return FAIL;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tsemsg(_(e_no_write_since_last_change_for_buffer_nr_add_bang_to_override),\n\t\t\t\t\t\t\t\t buf->b_fnum);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// When closing the current buffer stop Visual mode.\n\tif (buf == curbuf && VIsual_active)\n\t    end_visual_mode();\n\n\t// If deleting the last (listed) buffer, make it empty.\n\t// The last (listed) buffer cannot be unloaded.\n\tFOR_ALL_BUFFERS(bp)\n\t    if (bp->b_p_bl && bp != buf)\n\t\tbreak;\n\tif (bp == NULL && buf == curbuf)\n\t    return empty_curbuf(TRUE, (flags & DOBUF_FORCEIT), action);\n\n\t// If the deleted buffer is the current one, close the current window\n\t// (unless it's the only window).  Repeat this so long as we end up in\n\t// a window with this buffer.\n\twhile (buf == curbuf\n\t\t   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n\t\t   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))\n\t{\n\t    if (win_close(curwin, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\n\t// If the buffer to be deleted is not the current one, delete it here.\n\tif (buf != curbuf)\n\t{\n\t    close_windows(buf, FALSE);\n\t    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)\n\t\t    close_buffer(NULL, buf, action, FALSE, FALSE);\n\t    return OK;\n\t}\n\n\t/*\n\t * Deleting the current buffer: Need to find another buffer to go to.\n\t * There should be another, otherwise it would have been handled\n\t * above.  However, autocommands may have deleted all buffers.\n\t * First use au_new_curbuf.br_buf, if it is valid.\n\t * Then prefer the buffer we most recently visited.\n\t * Else try to find one that is loaded, after the current buffer,\n\t * then before the current buffer.\n\t * Finally use any buffer.\n\t */\n\tbuf = NULL;\t// selected buffer\n\tbp = NULL;\t// used when no loaded buffer found\n\tif (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf))\n\t    buf = au_new_curbuf.br_buf;\n\telse if (curwin->w_jumplistlen > 0)\n\t{\n\t    int     jumpidx;\n\n\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    if (buf == curbuf || !buf->b_p_bl)\n\t\t\tbuf = NULL;\t// skip current and unlisted bufs\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t\t// advance to older entry in jump list\n\t\tif (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t\t    break;\n\t\tif (--jumpidx < 0)\n\t\t    jumpidx = curwin->w_jumplistlen - 1;\n\t\tif (jumpidx == forward)\t\t// List exhausted for sure\n\t\t    break;\n\t    }\n\t}\n\n\tif (buf == NULL)\t// No previous buffer, Try 2'nd approach\n\t{\n\t    forward = TRUE;\n\t    buf = curbuf->b_next;\n\t    for (;;)\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl)\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf)\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n\n    /*\n     * make \"buf\" the current buffer\n     */\n    if (action == DOBUF_SPLIT)\t    // split window first\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))\n\t    return OK;\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))\n\t    return OK;\n\tif (win_split(0, 0) == FAIL)\n\t    return FAIL;\n    }\n\n    // go to current buffer - nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    // Check if the current buffer may be abandoned.\n    if (action == DOBUF_GOTO && !can_abandon(curbuf, (flags & DOBUF_FORCEIT)))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(curbuf, FALSE);\n\t    if (!bufref_valid(&bufref))\n\t\t// Autocommand deleted buffer, oops!\n\t\treturn FAIL;\n\t}\n\tif (bufIsChanged(curbuf))\n#endif\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n    }\n\n    // Go to the other buffer.\n    set_curbuf(buf, action);\n\n    if (action == DOBUF_SPLIT)\n\tRESET_BINDING(curwin);\t// reset 'scrollbind' and 'cursorbind'\n\n#if defined(FEAT_EVAL)\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n\n    return OK;\n}\n\n    int\ndo_buffer(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tforceit)\t// TRUE when using !\n{\n    return do_buffer_ext(action, start, dir, count,\n\t\t\t\t\t\t  forceit ? DOBUF_FORCEIT : 0);\n}\n\n/*\n * do_bufdel() - delete or unload buffer(s)\n *\n * addr_count == 0: \":bdel\" - delete current buffer\n * addr_count == 1: \":N bdel\" or \":bdel N [N ..]\" - first delete\n *\t\t    buffer \"end_bnr\", then any other arguments.\n * addr_count == 2: \":N,N bdel\" - delete buffers in range\n *\n * command can be DOBUF_UNLOAD (\":bunload\"), DOBUF_WIPE (\":bwipeout\") or\n * DOBUF_DEL (\":bdel\")\n *\n * Returns error message or NULL\n */\n    char *\ndo_bufdel(\n    int\t\tcommand,\n    char_u\t*arg,\t\t// pointer to extra arguments\n    int\t\taddr_count,\n    int\t\tstart_bnr,\t// first buffer number in a range\n    int\t\tend_bnr,\t// buffer nr or last buffer nr in a range\n    int\t\tforceit)\n{\n    int\t\tdo_current = 0;\t// delete current buffer?\n    int\t\tdeleted = 0;\t// number of buffers deleted\n    char\t*errormsg = NULL; // return value\n    int\t\tbnr;\t\t// buffer number\n    char_u\t*p;\n\n    if (addr_count == 0)\n    {\n\t(void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);\n    }\n    else\n    {\n\tif (addr_count == 2)\n\t{\n\t    if (*arg)\t\t// both range and argument is not allowed\n\t\treturn ex_errmsg(e_trailing_characters_str, arg);\n\t    bnr = start_bnr;\n\t}\n\telse\t// addr_count == 1\n\t    bnr = end_bnr;\n\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    // Delete the current buffer last, otherwise when the\n\t    // current buffer is deleted, the next buffer becomes\n\t    // the current one and will be loaded, which may then\n\t    // also be deleted, etc.\n\t    if (bnr == curbuf->b_fnum)\n\t\tdo_current = bnr;\n\t    else if (do_buffer_ext(command, DOBUF_FIRST, FORWARD, bnr,\n\t\t\t  DOBUF_NOPOPUP | (forceit ? DOBUF_FORCEIT : 0)) == OK)\n\t\t++deleted;\n\n\t    // find next buffer number to delete/unload\n\t    if (addr_count == 2)\n\t    {\n\t\tif (++bnr > end_bnr)\n\t\t    break;\n\t    }\n\t    else    // addr_count == 1\n\t    {\n\t\targ = skipwhite(arg);\n\t\tif (*arg == NUL)\n\t\t    break;\n\t\tif (!VIM_ISDIGIT(*arg))\n\t\t{\n\t\t    p = skiptowhite_esc(arg);\n\t\t    bnr = buflist_findpat(arg, p,\n\t\t\t  command == DOBUF_WIPE || command == DOBUF_WIPE_REUSE,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t    if (bnr < 0)\t    // failed\n\t\t\tbreak;\n\t\t    arg = p;\n\t\t}\n\t\telse\n\t\t    bnr = getdigits(&arg);\n\t    }\n\t}\n\tif (!got_int && do_current && do_buffer(command, DOBUF_FIRST,\n\t\t\t\t\t  FORWARD, do_current, forceit) == OK)\n\t    ++deleted;\n\n\tif (deleted == 0)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_unloaded));\n\t    else if (command == DOBUF_DEL)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_deleted));\n\t    else\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_wiped_out));\n\t    errormsg = (char *)IObuff;\n\t}\n\telse if (deleted >= p_report)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tsmsg(NGETTEXT(\"%d buffer unloaded\",\n\t\t\t    \"%d buffers unloaded\", deleted), deleted);\n\t    else if (command == DOBUF_DEL)\n\t\tsmsg(NGETTEXT(\"%d buffer deleted\",\n\t\t\t    \"%d buffers deleted\", deleted), deleted);\n\t    else\n\t\tsmsg(NGETTEXT(\"%d buffer wiped out\",\n\t\t\t    \"%d buffers wiped out\", deleted), deleted);\n\t}\n    }\n\n\n    return errormsg;\n}\n\n/*\n * Set current buffer to \"buf\".  Executes autocommands and closes current\n * buffer.  \"action\" tells how to close the current buffer:\n * DOBUF_GOTO\t    free or hide it\n * DOBUF_SPLIT\t    nothing\n * DOBUF_UNLOAD\t    unload it\n * DOBUF_DEL\t    delete it\n * DOBUF_WIPE\t    wipe it out\n * DOBUF_WIPE_REUSE wipe it out and add to \"buf_reuse\"\n */\n    void\nset_curbuf(buf_T *buf, int action)\n{\n    buf_T\t*prevbuf;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    bufref_T\tnewbufref;\n    bufref_T\tprevbufref;\n    int\t\tvalid;\n\n    setpcmark();\n    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = curbuf->b_fnum; // remember alternate file\n    buflist_altfpos(curwin);\t\t\t // remember curpos\n\n    // Don't restart Select mode after switching to another buffer.\n    VIsual_reselect = FALSE;\n\n    // close_windows() or apply_autocmds() may change curbuf and wipe out \"buf\"\n    prevbuf = curbuf;\n    set_bufref(&prevbufref, prevbuf);\n    set_bufref(&newbufref, buf);\n\n    // Autocommands may delete the current buffer and/or the buffer we want to\n    // go to.  In those cases don't close the buffer.\n    if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf)\n\t    || (bufref_valid(&prevbufref)\n\t\t&& bufref_valid(&newbufref)\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t       ))\n    {\n#ifdef FEAT_SYN_HL\n\tif (prevbuf == curwin->w_buffer)\n\t    reset_synblock(curwin);\n#endif\n\tif (unload)\n\t    close_windows(prevbuf, FALSE);\n#if defined(FEAT_EVAL)\n\tif (bufref_valid(&prevbufref) && !aborting())\n#else\n\tif (bufref_valid(&prevbufref))\n#endif\n\t{\n\t    win_T  *previouswin = curwin;\n\n\t    // Do not sync when in Insert mode and the buffer is open in\n\t    // another window, might be a timer doing something in another\n\t    // window.\n\t    if (prevbuf == curbuf\n\t\t\t && ((State & INSERT) == 0 || curbuf->b_nwindows <= 1))\n\t\tu_sync(FALSE);\n\t    close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL, prevbuf,\n\t\t    unload ? action : (action == DOBUF_GOTO\n\t\t\t&& !buf_hide(prevbuf)\n\t\t\t&& !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0,\n\t\t    FALSE, FALSE);\n\t    if (curwin != previouswin && win_valid(previouswin))\n\t      // autocommands changed curwin, Grr!\n\t      curwin = previouswin;\n\t}\n    }\n    // An autocommand may have deleted \"buf\", already entered it (e.g., when\n    // it did \":bunload\") or aborted the script processing.\n    // If curwin->w_buffer is null, enter_buffer() will make it valid again\n    valid = buf_valid(buf);\n    if ((valid && buf != curbuf\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t) || curwin->w_buffer == NULL)\n    {\n\t// If the buffer is not valid but curwin->w_buffer is NULL we must\n\t// enter some buffer.  Using the last one is hopefully OK.\n\tif (!valid)\n\t    enter_buffer(lastbuf);\n\telse\n\t    enter_buffer(buf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n    }\n}\n\n/*\n * Enter a new current buffer.\n * Old curbuf must have been abandoned already!  This also means \"curbuf\" may\n * be pointing to freed memory.\n */\n    static void\nenter_buffer(buf_T *buf)\n{\n    // Get the buffer in the current window.\n    curwin->w_buffer = buf;\n    curbuf = buf;\n    ++curbuf->b_nwindows;\n\n    // Copy buffer and window local option values.  Not for a help buffer.\n    buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);\n    if (!buf->b_help)\n\tget_winopts(buf);\n#ifdef FEAT_FOLDING\n    else\n\t// Remove all folds in the window.\n\tclearFolding(curwin);\n    foldUpdateAll(curwin);\t// update folds (later).\n#endif\n\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff)\n\tdiff_buf_add(curbuf);\n#endif\n\n#ifdef FEAT_SYN_HL\n    curwin->w_s = &(curbuf->b_s);\n#endif\n\n    // Cursor on first line by default.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_set_curswant = TRUE;\n    curwin->w_topline_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    buflist_setfpos(curbuf, curwin, curbuf->b_last_cursor.lnum,\n\t\t\t\t\t      curbuf->b_last_cursor.col, TRUE);\n\n    // Make sure the buffer is loaded.\n    if (curbuf->b_ml.ml_mfp == NULL)\t// need to load the file\n    {\n\t// If there is no filetype, allow for detecting one.  Esp. useful for\n\t// \":ball\" used in an autocommand.  If there already is a filetype we\n\t// might prefer to keep it.\n\tif (*curbuf->b_p_ft == NUL)\n\t    did_filetype = FALSE;\n\n\topen_buffer(FALSE, NULL, 0);\n    }\n    else\n    {\n\tif (!msg_silent && !shortmess(SHM_FILEINFO))\n\t    need_fileinfo = TRUE;\t// display file info after redraw\n\n\t// check if file changed\n\t(void)buf_check_timestamp(curbuf, FALSE);\n\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n\tapply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    // If autocommands did not change the cursor position, restore cursor lnum\n    // and possibly cursor col.\n    if (curwin->w_cursor.lnum == 1 && inindent(0))\n\tbuflist_getfpos();\n\n    check_arg_idx(curwin);\t\t// check for valid arg_idx\n    maketitle();\n\t// when autocmds didn't change it\n    if (curwin->w_topline == 1 && !curwin->w_topline_was_set)\n\tscroll_cursor_halfway(FALSE);\t// redisplay at correct position\n\n#ifdef FEAT_NETBEANS_INTG\n    // Send fileOpened event because we've changed buffers.\n    netbeans_file_activated(curbuf);\n#endif\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n#ifdef FEAT_SPELL\n    // May need to set the spell language.  Can only do this after the buffer\n    // has been properly setup.\n    if (!curbuf->b_help && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)did_set_spelllang(curwin);\n#endif\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    redraw_later(NOT_VALID);\n}\n\n#if defined(FEAT_AUTOCHDIR) || defined(PROTO)\n/*\n * Change to the directory of the current buffer.\n * Don't do this while still starting up.\n */\n    void\ndo_autochdir(void)\n{\n    if ((starting == 0 || test_autochdir)\n\t    && curbuf->b_ffname != NULL\n\t    && vim_chdirfile(curbuf->b_ffname, \"auto\") == OK)\n    {\n\tshorten_fnames(TRUE);\n\tlast_chdir_reason = \"autochdir\";\n    }\n}\n#endif\n\n    void\nno_write_message(void)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(curbuf->b_term))\n\temsg(_(e_job_still_running_add_bang_to_end_the_job));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change_add_bang_to_override));\n}\n\n    void\nno_write_message_nobang(buf_T *buf UNUSED)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(buf->b_term))\n\temsg(_(e_job_still_running));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change));\n}\n\n/*\n * functions for dealing with the buffer list\n */\n\n/*\n * Return TRUE if the current buffer is empty, unnamed, unmodified and used in\n * only one window.  That means it can be re-used.\n */\n    int\ncurbuf_reusable(void)\n{\n    return (curbuf != NULL\n\t&& curbuf->b_ffname == NULL\n\t&& curbuf->b_nwindows <= 1\n\t&& (curbuf->b_ml.ml_mfp == NULL || BUFEMPTY())\n#if defined(FEAT_QUICKFIX)\n\t&& !bt_quickfix(curbuf)\n#endif\n\t&& !curbufIsChanged());\n}\n\n/*\n * Add a file name to the buffer list.  Return a pointer to the buffer.\n * If the same file name already exists return a pointer to that buffer.\n * If it does not exist, or if fname == NULL, a new entry is created.\n * If (flags & BLN_CURBUF) is TRUE, may use current buffer.\n * If (flags & BLN_LISTED) is TRUE, add new buffer to buffer list.\n * If (flags & BLN_DUMMY) is TRUE, don't count it as a real buffer.\n * If (flags & BLN_NEW) is TRUE, don't use an existing buffer.\n * If (flags & BLN_NOOPT) is TRUE, don't copy options from the current buffer\n *\t\t\t\t    if the buffer already exists.\n * If (flags & BLN_REUSE) is TRUE, may use buffer number from \"buf_reuse\".\n * This is the ONLY way to create a new buffer.\n */\n    buf_T *\nbuflist_new(\n    char_u\t*ffname_arg,\t// full path of fname or relative\n    char_u\t*sfname_arg,\t// short fname or NULL\n    linenr_T\tlnum,\t\t// preferred cursor line\n    int\t\tflags)\t\t// BLN_ defines\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*buf;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (top_file_num == 1)\n\thash_init(&buf_hashtab);\n\n    fname_expand(curbuf, &ffname, &sfname);\t// will allocate ffname\n\n    /*\n     * If the file name already exists in the list, update the entry.\n     */\n#ifdef UNIX\n    // On Unix we can use inode numbers when the file exists.  Works better\n    // for hard links.\n    if (sfname == NULL || mch_stat((char *)sfname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n#endif\n    if (ffname != NULL && !(flags & (BLN_DUMMY | BLN_NEW)) && (buf =\n#ifdef UNIX\n\t\tbuflist_findname_stat(ffname, &st)\n#else\n\t\tbuflist_findname(ffname)\n#endif\n\t\t) != NULL)\n    {\n\tvim_free(ffname);\n\tif (lnum != 0)\n\t    buflist_setfpos(buf, (flags & BLN_NOCURWIN) ? NULL : curwin,\n\t\t\t\t\t\t      lnum, (colnr_T)0, FALSE);\n\n\tif ((flags & BLN_NOOPT) == 0)\n\t    // copy the options now, if 'cpo' doesn't have 's' and not done\n\t    // already\n\t    buf_copy_options(buf, 0);\n\n\tif ((flags & BLN_LISTED) && !buf->b_p_bl)\n\t{\n\t    bufref_T bufref;\n\n\t    buf->b_p_bl = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    if (!(flags & BLN_DUMMY))\n\t    {\n\t\tif (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t\t&& !bufref_valid(&bufref))\n\t\t    return NULL;\n\t    }\n\t}\n\treturn buf;\n    }\n\n    /*\n     * If the current buffer has no name and no contents, use the current\n     * buffer.\tOtherwise: Need to allocate a new buffer structure.\n     *\n     * This is the ONLY place where a new buffer structure is allocated!\n     * (A spell file buffer is allocated in spell.c, but that's not a normal\n     * buffer.)\n     */\n    buf = NULL;\n    if ((flags & BLN_CURBUF) && curbuf_reusable())\n    {\n\tbuf = curbuf;\n\t// It's like this buffer is deleted.  Watch out for autocommands that\n\t// change curbuf!  If that happens, allocate a new buffer anyway.\n\tif (curbuf->b_p_bl)\n\t    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);\n\tif (buf == curbuf)\n\t    apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#endif\n\tif (buf == curbuf)\n\t{\n\t    // Make sure 'bufhidden' and 'buftype' are empty\n\t    clear_string_option(&buf->b_p_bh);\n\t    clear_string_option(&buf->b_p_bt);\n\t}\n    }\n    if (buf != curbuf || curbuf == NULL)\n    {\n\tbuf = ALLOC_CLEAR_ONE(buf_T);\n\tif (buf == NULL)\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#ifdef FEAT_EVAL\n\t// init b: variables\n\tbuf->b_vars = dict_alloc();\n\tif (buf->b_vars == NULL)\n\t{\n\t    vim_free(ffname);\n\t    vim_free(buf);\n\t    return NULL;\n\t}\n\tinit_var_dict(buf->b_vars, &buf->b_bufvar, VAR_SCOPE);\n#endif\n\tinit_changedtick(buf);\n    }\n\n    if (ffname != NULL)\n    {\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = vim_strsave(sfname);\n    }\n\n    clear_wininfo(buf);\n    buf->b_wininfo = ALLOC_CLEAR_ONE(wininfo_T);\n\n    if ((ffname != NULL && (buf->b_ffname == NULL || buf->b_sfname == NULL))\n\t    || buf->b_wininfo == NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf != curbuf)\n\t    free_buffer(buf);\n\treturn NULL;\n    }\n\n    if (buf == curbuf)\n    {\n\t// free all things allocated for this buffer\n\tbuf_freeall(buf, 0);\n\tif (buf != curbuf)\t // autocommands deleted the buffer!\n\t    return NULL;\n#if defined(FEAT_EVAL)\n\tif (aborting())\t\t// autocmds may abort script processing\n\t    return NULL;\n#endif\n\tfree_buffer_stuff(buf, FALSE);\t// delete local variables et al.\n\n\t// Init the options.\n\tbuf->b_p_initialized = FALSE;\n\tbuf_copy_options(buf, BCO_ENTER);\n\n#ifdef FEAT_KEYMAP\n\t// need to reload lmaps and set b:keymap_name\n\tcurbuf->b_kmap_state |= KEYMAP_INIT;\n#endif\n    }\n    else\n    {\n\t// put the new buffer at the end of the buffer list\n\tbuf->b_next = NULL;\n\tif (firstbuf == NULL)\t\t// buffer list is empty\n\t{\n\t    buf->b_prev = NULL;\n\t    firstbuf = buf;\n\t}\n\telse\t\t\t\t// append new buffer at end of list\n\t{\n\t    lastbuf->b_next = buf;\n\t    buf->b_prev = lastbuf;\n\t}\n\tlastbuf = buf;\n\n\tif ((flags & BLN_REUSE) && buf_reuse.ga_len > 0)\n\t{\n\t    // Recycle a previously used buffer number.  Used for buffers which\n\t    // are normally hidden, e.g. in a popup window.  Avoids that the\n\t    // buffer number grows rapidly.\n\t    --buf_reuse.ga_len;\n\t    buf->b_fnum = ((int *)buf_reuse.ga_data)[buf_reuse.ga_len];\n\n\t    // Move buffer to the right place in the buffer list.\n\t    while (buf->b_prev != NULL && buf->b_fnum < buf->b_prev->b_fnum)\n\t    {\n\t\tbuf_T\t*prev = buf->b_prev;\n\n\t\tprev->b_next = buf->b_next;\n\t\tif (prev->b_next != NULL)\n\t\t    prev->b_next->b_prev = prev;\n\t\tbuf->b_next = prev;\n\t\tbuf->b_prev = prev->b_prev;\n\t\tif (buf->b_prev != NULL)\n\t\t    buf->b_prev->b_next = buf;\n\t\tprev->b_prev = buf;\n\t\tif (lastbuf == buf)\n\t\t    lastbuf = prev;\n\t\tif (firstbuf == prev)\n\t\t    firstbuf = buf;\n\t    }\n\t}\n\telse\n\t    buf->b_fnum = top_file_num++;\n\tif (top_file_num < 0)\t\t// wrap around (may cause duplicates)\n\t{\n\t    emsg(_(\"W14: Warning: List of file names overflow\"));\n\t    if (emsg_silent == 0 && !in_assert_fails)\n\t    {\n\t\tout_flush();\n\t\tui_delay(3001L, TRUE);\t// make sure it is noticed\n\t    }\n\t    top_file_num = 1;\n\t}\n\tbuf_hashtab_add(buf);\n\n\t// Always copy the options from the current buffer.\n\tbuf_copy_options(buf, BCO_ALWAYS);\n    }\n\n    buf->b_wininfo->wi_fpos.lnum = lnum;\n    buf->b_wininfo->wi_win = curwin;\n\n#ifdef FEAT_SYN_HL\n    hash_init(&buf->b_s.b_keywtab);\n    hash_init(&buf->b_s.b_keywtab_ic);\n#endif\n\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n    buf->b_u_synced = TRUE;\n    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n    if (flags & BLN_DUMMY)\n\tbuf->b_flags |= BF_DUMMY;\n    buf_clear_file(buf);\n    clrallmarks(buf);\t\t\t// clear marks\n    fmarks_check_names(buf);\t\t// check file marks for this file\n    buf->b_p_bl = (flags & BLN_LISTED) ? TRUE : FALSE;\t// init 'buflisted'\n    if (!(flags & BLN_DUMMY))\n    {\n\tbufref_T bufref;\n\n\t// Tricky: these autocommands may change the buffer list.  They could\n\t// also split the window with re-using the one empty buffer. This may\n\t// result in unexpectedly losing the empty buffer.\n\tset_bufref(&bufref, buf);\n\tif (apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    return NULL;\n\tif (flags & BLN_LISTED)\n\t{\n\t    if (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\treturn NULL;\n\t}\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t    return NULL;\n#endif\n    }\n\n    return buf;\n}\n\n/*\n * Free the memory for the options of a buffer.\n * If \"free_p_ff\" is TRUE also free 'fileformat', 'buftype' and\n * 'fileencoding'.\n */\n    void\nfree_buf_options(\n    buf_T\t*buf,\n    int\t\tfree_p_ff)\n{\n    if (free_p_ff)\n    {\n\tclear_string_option(&buf->b_p_fenc);\n\tclear_string_option(&buf->b_p_ff);\n\tclear_string_option(&buf->b_p_bh);\n\tclear_string_option(&buf->b_p_bt);\n    }\n#ifdef FEAT_FIND_ID\n    clear_string_option(&buf->b_p_def);\n    clear_string_option(&buf->b_p_inc);\n# ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_inde);\n    clear_string_option(&buf->b_p_indk);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n    clear_string_option(&buf->b_p_cm);\n#endif\n    clear_string_option(&buf->b_p_fp);\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n# ifdef FEAT_SODIUM\n    if ((buf->b_p_key != NULL) && (*buf->b_p_key != NUL) &&\n\t\t\t\t(crypt_get_method_nr(buf) == CRYPT_M_SOD))\n\tcrypt_sodium_munlock(buf->b_p_key, STRLEN(buf->b_p_key));\n# endif\n    clear_string_option(&buf->b_p_key);\n#endif\n    clear_string_option(&buf->b_p_kp);\n    clear_string_option(&buf->b_p_mps);\n    clear_string_option(&buf->b_p_fo);\n    clear_string_option(&buf->b_p_flp);\n    clear_string_option(&buf->b_p_isk);\n#ifdef FEAT_VARTABS\n    clear_string_option(&buf->b_p_vsts);\n    vim_free(buf->b_p_vsts_nopaste);\n    buf->b_p_vsts_nopaste = NULL;\n    VIM_CLEAR(buf->b_p_vsts_array);\n    clear_string_option(&buf->b_p_vts);\n    VIM_CLEAR(buf->b_p_vts_array);\n#endif\n#ifdef FEAT_KEYMAP\n    clear_string_option(&buf->b_p_keymap);\n    keymap_clear(&buf->b_kmap_ga);\n    ga_clear(&buf->b_kmap_ga);\n#endif\n    clear_string_option(&buf->b_p_com);\n#ifdef FEAT_FOLDING\n    clear_string_option(&buf->b_p_cms);\n#endif\n    clear_string_option(&buf->b_p_nf);\n#ifdef FEAT_SYN_HL\n    clear_string_option(&buf->b_p_syn);\n    clear_string_option(&buf->b_s.b_syn_isk);\n#endif\n#ifdef FEAT_SPELL\n    clear_string_option(&buf->b_s.b_p_spc);\n    clear_string_option(&buf->b_s.b_p_spf);\n    vim_regfree(buf->b_s.b_cap_prog);\n    buf->b_s.b_cap_prog = NULL;\n    clear_string_option(&buf->b_s.b_p_spl);\n    clear_string_option(&buf->b_s.b_p_spo);\n#endif\n#ifdef FEAT_SEARCHPATH\n    clear_string_option(&buf->b_p_sua);\n#endif\n    clear_string_option(&buf->b_p_ft);\n#ifdef FEAT_CINDENT\n    clear_string_option(&buf->b_p_cink);\n    clear_string_option(&buf->b_p_cino);\n#endif\n#if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)\n    clear_string_option(&buf->b_p_cinw);\n#endif\n    clear_string_option(&buf->b_p_cpt);\n#ifdef FEAT_COMPL_FUNC\n    clear_string_option(&buf->b_p_cfu);\n    free_callback(&buf->b_cfu_cb);\n    clear_string_option(&buf->b_p_ofu);\n    free_callback(&buf->b_ofu_cb);\n    clear_string_option(&buf->b_p_tsrfu);\n    free_callback(&buf->b_tsrfu_cb);\n#endif\n#ifdef FEAT_QUICKFIX\n    clear_string_option(&buf->b_p_gp);\n    clear_string_option(&buf->b_p_mp);\n    clear_string_option(&buf->b_p_efm);\n#endif\n    clear_string_option(&buf->b_p_ep);\n    clear_string_option(&buf->b_p_path);\n    clear_string_option(&buf->b_p_tags);\n    clear_string_option(&buf->b_p_tc);\n#ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_tfu);\n    free_callback(&buf->b_tfu_cb);\n#endif\n    clear_string_option(&buf->b_p_dict);\n    clear_string_option(&buf->b_p_tsr);\n#ifdef FEAT_TEXTOBJ\n    clear_string_option(&buf->b_p_qe);\n#endif\n    buf->b_p_ar = -1;\n    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n#ifdef FEAT_LISP\n    clear_string_option(&buf->b_p_lw);\n#endif\n    clear_string_option(&buf->b_p_bkc);\n    clear_string_option(&buf->b_p_menc);\n}\n\n/*\n * Get alternate file \"n\".\n * Set linenr to \"lnum\" or altfpos.lnum if \"lnum\" == 0.\n *\tAlso set cursor column to altfpos.col if 'startofline' is not set.\n * if (options & GETF_SETMARK) call setpcmark()\n * if (options & GETF_ALT) we are jumping to an alternate file.\n * if (options & GETF_SWITCH) respect 'switchbuf' settings when jumping\n *\n * Return FAIL for failure, OK for success.\n */\n    int\nbuflist_getfile(\n    int\t\tn,\n    linenr_T\tlnum,\n    int\t\toptions,\n    int\t\tforceit)\n{\n    buf_T\t*buf;\n    win_T\t*wp = NULL;\n    pos_T\t*fpos;\n    colnr_T\tcol;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n    {\n\tif ((options & GETF_ALT) && n == 0)\n\t    emsg(_(e_no_alternate_file));\n\telse\n\t    semsg(_(e_buffer_nr_not_found), n);\n\treturn FAIL;\n    }\n\n    // if alternate file is the current buffer, nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn FAIL;\n    }\n    if (curbuf_locked())\n\treturn FAIL;\n\n    // altfpos may be changed by getfile(), get it now\n    if (lnum == 0)\n    {\n\tfpos = buflist_findfpos(buf);\n\tlnum = fpos->lnum;\n\tcol = fpos->col;\n    }\n    else\n\tcol = 0;\n\n    if (options & GETF_SWITCH)\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif (swb_flags & SWB_USEOPEN)\n\t    wp = buf_jump_open_win(buf);\n\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif (wp == NULL && (swb_flags & SWB_USETAB))\n\t    wp = buf_jump_open_tab(buf);\n\n\t// If 'switchbuf' contains \"split\", \"vsplit\" or \"newtab\" and the\n\t// current buffer isn't empty: open new tab or window\n\tif (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))\n\t\t\t\t\t\t\t       && !BUFEMPTY())\n\t{\n\t    if (swb_flags & SWB_NEWTAB)\n\t\ttabpage_new();\n\t    else if (win_split(0, (swb_flags & SWB_VSPLIT) ? WSP_VERT : 0)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t    RESET_BINDING(curwin);\n\t}\n    }\n\n    ++RedrawingDisabled;\n    if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL,\n\t\t\t\t     (options & GETF_SETMARK), lnum, forceit)))\n    {\n\t--RedrawingDisabled;\n\n\t// cursor is at to BOL and w_cursor.lnum is checked due to getfile()\n\tif (!p_sol && col != 0)\n\t{\n\t    curwin->w_cursor.col = col;\n\t    check_cursor_col();\n\t    curwin->w_cursor.coladd = 0;\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\treturn OK;\n    }\n    --RedrawingDisabled;\n    return FAIL;\n}\n\n/*\n * go to the last know line number for the current buffer\n */\n    static void\nbuflist_getfpos(void)\n{\n    pos_T\t*fpos;\n\n    fpos = buflist_findfpos(curbuf);\n\n    curwin->w_cursor.lnum = fpos->lnum;\n    check_cursor_lnum();\n\n    if (p_sol)\n\tcurwin->w_cursor.col = 0;\n    else\n    {\n\tcurwin->w_cursor.col = fpos->col;\n\tcheck_cursor_col();\n\tcurwin->w_cursor.coladd = 0;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n#if defined(FEAT_QUICKFIX) || defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname_exp(char_u *fname)\n{\n    char_u\t*ffname;\n    buf_T\t*buf = NULL;\n\n    // First make the name into a full path name\n    ffname = FullName_save(fname,\n#ifdef UNIX\n\t    TRUE\t    // force expansion, get rid of symbolic links\n#else\n\t    FALSE\n#endif\n\t    );\n    if (ffname != NULL)\n    {\n\tbuf = buflist_findname(ffname);\n\tvim_free(ffname);\n    }\n    return buf;\n}\n#endif\n\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * \"ffname\" must have a full path.\n * Skips dummy buffers.\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname(char_u *ffname)\n{\n#ifdef UNIX\n    stat_T\tst;\n\n    if (mch_stat((char *)ffname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n    return buflist_findname_stat(ffname, &st);\n}\n\n/*\n * Same as buflist_findname(), but pass the stat structure to avoid getting it\n * twice for the same file.\n * Returns NULL if not found.\n */\n    static buf_T *\nbuflist_findname_stat(\n    char_u\t*ffname,\n    stat_T\t*stp)\n{\n#endif\n    buf_T\t*buf;\n\n    // Start at the last buffer, expect to find a match sooner.\n    FOR_ALL_BUFS_FROM_LAST(buf)\n\tif ((buf->b_flags & BF_DUMMY) == 0 && !otherfile_buf(buf, ffname\n#ifdef UNIX\n\t\t    , stp\n#endif\n\t\t    ))\n\t    return buf;\n    return NULL;\n}\n\n/*\n * Find file in buffer list by a regexp pattern.\n * Return fnum of the found buffer.\n * Return < 0 for error.\n */\n    int\nbuflist_findpat(\n    char_u\t*pattern,\n    char_u\t*pattern_end,\t// pointer to first char after pattern\n    int\t\tunlisted,\t// find unlisted buffers\n    int\t\tdiffmode UNUSED, // find diff-mode buffers only\n    int\t\tcurtab_only)\t// find buffers in current tab only\n{\n    buf_T\t*buf;\n    int\t\tmatch = -1;\n    int\t\tfind_listed;\n    char_u\t*pat;\n    char_u\t*patend;\n    int\t\tattempt;\n    char_u\t*p;\n    int\t\ttoggledollar;\n\n    // \"%\" is current file, \"%%\" or \"#\" is alternate file\n    if ((pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))\n\t    || (in_vim9script() && pattern_end == pattern + 2\n\t\t\t\t    && pattern[0] == '%' && pattern[1] == '%'))\n    {\n\tif (*pattern == '#' || pattern_end == pattern + 2)\n\t    match = curwin->w_alt_fnum;\n\telse\n\t    match = curbuf->b_fnum;\n#ifdef FEAT_DIFF\n\tif (diffmode && !diff_mode_buf(buflist_findnr(match)))\n\t    match = -1;\n#endif\n    }\n\n    /*\n     * Try four ways of matching a listed buffer:\n     * attempt == 0: without '^' or '$' (at any position)\n     * attempt == 1: with '^' at start (only at position 0)\n     * attempt == 2: with '$' at end (only match at end)\n     * attempt == 3: with '^' at start and '$' at end (only full match)\n     * Repeat this for finding an unlisted buffer if there was no matching\n     * listed buffer.\n     */\n    else\n    {\n\tpat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);\n\tif (pat == NULL)\n\t    return -1;\n\tpatend = pat + STRLEN(pat) - 1;\n\ttoggledollar = (patend > pat && *patend == '$');\n\n\t// First try finding a listed buffer.  If not found and \"unlisted\"\n\t// is TRUE, try finding an unlisted buffer.\n\tfind_listed = TRUE;\n\tfor (;;)\n\t{\n\t    for (attempt = 0; attempt <= 3; ++attempt)\n\t    {\n\t\tregmatch_T\tregmatch;\n\n\t\t// may add '^' and '$'\n\t\tif (toggledollar)\n\t\t    *patend = (attempt < 2) ? NUL : '$'; // add/remove '$'\n\t\tp = pat;\n\t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n\t\t    ++p;\n\t\tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t\tif (regmatch.regprog == NULL)\n\t\t{\n\t\t    vim_free(pat);\n\t\t    return -1;\n\t\t}\n\n\t\tFOR_ALL_BUFS_FROM_LAST(buf)\n\t\t    if (buf->b_p_bl == find_listed\n#ifdef FEAT_DIFF\n\t\t\t    && (!diffmode || diff_mode_buf(buf))\n#endif\n\t\t\t    && buflist_match(&regmatch, buf, FALSE) != NULL)\n\t\t    {\n\t\t\tif (curtab_only)\n\t\t\t{\n\t\t\t    // Ignore the match if the buffer is not open in\n\t\t\t    // the current tab.\n\t\t\t    win_T\t*wp;\n\n\t\t\t    FOR_ALL_WINDOWS(wp)\n\t\t\t\tif (wp->w_buffer == buf)\n\t\t\t\t    break;\n\t\t\t    if (wp == NULL)\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match >= 0)\t\t// already found a match\n\t\t\t{\n\t\t\t    match = -2;\n\t\t\t    break;\n\t\t\t}\n\t\t\tmatch = buf->b_fnum;\t// remember first match\n\t\t    }\n\n\t\tvim_regfree(regmatch.regprog);\n\t\tif (match >= 0)\t\t\t// found one match\n\t\t    break;\n\t    }\n\n\t    // Only search for unlisted buffers if there was no match with\n\t    // a listed buffer.\n\t    if (!unlisted || !find_listed || match != -1)\n\t\tbreak;\n\t    find_listed = FALSE;\n\t}\n\n\tvim_free(pat);\n    }\n\n    if (match == -2)\n\tsemsg(_(e_more_than_one_match_for_str), pattern);\n    else if (match < 0)\n\tsemsg(_(e_no_matching_buffer_for_str), pattern);\n    return match;\n}\n\n#ifdef FEAT_VIMINFO\ntypedef struct {\n    buf_T   *buf;\n    char_u  *match;\n} bufmatch_T;\n#endif\n\n/*\n * Find all buffer names that match.\n * For command line expansion of \":buf\" and \":sbuf\".\n * Return OK if matches found, FAIL otherwise.\n */\n    int\nExpandBufnames(\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file,\n    int\t\toptions)\n{\n    int\t\tcount = 0;\n    buf_T\t*buf;\n    int\t\tround;\n    char_u\t*p;\n    int\t\tattempt;\n    char_u\t*patc;\n#ifdef FEAT_VIMINFO\n    bufmatch_T\t*matches = NULL;\n#endif\n\n    *num_file = 0;\t\t    // return values in case of FAIL\n    *file = NULL;\n\n#ifdef FEAT_DIFF\n    if ((options & BUF_DIFF_FILTER) && !curwin->w_p_diff)\n\treturn FAIL;\n#endif\n\n    // Make a copy of \"pat\" and change \"^\" to \"\\(^\\|[\\/]\\)\".\n    if (*pat == '^')\n    {\n\tpatc = alloc(STRLEN(pat) + 11);\n\tif (patc == NULL)\n\t    return FAIL;\n\tSTRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");\n\tSTRCPY(patc + 11, pat + 1);\n    }\n    else\n\tpatc = pat;\n\n    // attempt == 0: try match with    '\\<', match at start of word\n    // attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= 1; ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\n\tif (attempt > 0 && patc == pat)\n\t    break;\t// there was no anchor, no need to try again\n\tregmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\tif (regmatch.regprog == NULL)\n\t{\n\t    if (patc != pat)\n\t\tvim_free(patc);\n\t    return FAIL;\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tp = buflist_match(&regmatch, buf, p_wic);\n\t\tif (p != NULL)\n\t\t{\n\t\t    if (round == 1)\n\t\t\t++count;\n\t\t    else\n\t\t    {\n\t\t\tif (options & WILD_HOME_REPLACE)\n\t\t\t    p = home_replace_save(buf, p);\n\t\t\telse\n\t\t\t    p = vim_strsave(p);\n#ifdef FEAT_VIMINFO\n\t\t\tif (matches != NULL)\n\t\t\t{\n\t\t\t    matches[count].buf = buf;\n\t\t\t    matches[count].match = p;\n\t\t\t    count++;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    (*file)[count++] = p;\n\t\t    }\n\t\t}\n\t    }\n\t    if (count == 0)\t// no match found, break here\n\t\tbreak;\n\t    if (round == 1)\n\t    {\n\t\t*file = ALLOC_MULT(char_u *, count);\n\t\tif (*file == NULL)\n\t\t{\n\t\t    vim_regfree(regmatch.regprog);\n\t\t    if (patc != pat)\n\t\t\tvim_free(patc);\n\t\t    return FAIL;\n\t\t}\n#ifdef FEAT_VIMINFO\n\t\tif (options & WILD_BUFLASTUSED)\n\t\t    matches = ALLOC_MULT(bufmatch_T, count);\n#endif\n\t    }\n\t}\n\tvim_regfree(regmatch.regprog);\n\tif (count)\t\t// match(es) found, break here\n\t    break;\n    }\n\n    if (patc != pat)\n\tvim_free(patc);\n\n#ifdef FEAT_VIMINFO\n    if (matches != NULL)\n    {\n\tint i;\n\tif (count > 1)\n\t    qsort(matches, count, sizeof(bufmatch_T), buf_compare);\n\t// if the current buffer is first in the list, place it at the end\n\tif (matches[0].buf == curbuf)\n\t{\n\t    for (i = 1; i < count; i++)\n\t\t(*file)[i-1] = matches[i].match;\n\t    (*file)[count-1] = matches[0].match;\n\t}\n\telse\n\t{\n\t    for (i = 0; i < count; i++)\n\t\t(*file)[i] = matches[i].match;\n\t}\n\tvim_free(matches);\n    }\n#endif\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}\n\n/*\n * Check for a match on the file name for buffer \"buf\" with regprog \"prog\".\n */\n    static char_u *\nbuflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match;\n\n    // First try the short file name, then the long file name.\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n\n    return match;\n}\n\n/*\n * Try matching the regexp in \"prog\" with file name \"name\".\n * Return \"name\" when there is a match, NULL when not.\n */\n    static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}\n\n/*\n * Find a file in the buffer list by buffer number.\n */\n    buf_T *\nbuflist_findnr(int nr)\n{\n    char_u\tkey[VIM_SIZEOF_INT * 2 + 1];\n    hashitem_T\t*hi;\n\n    if (nr == 0)\n\tnr = curwin->w_alt_fnum;\n    sprintf((char *)key, \"%x\", nr);\n    hi = hash_find(&buf_hashtab, key);\n\n    if (!HASHITEM_EMPTY(hi))\n\treturn (buf_T *)(hi->hi_key\n\t\t\t     - ((unsigned)(curbuf->b_key - (char_u *)curbuf)));\n    return NULL;\n}\n\n/*\n * Get name of file 'n' in the buffer list.\n * When the file has no name an empty string is returned.\n * home_replace() is used to shorten the file name (used for marks).\n * Returns a pointer to allocated memory, of NULL when failed.\n */\n    char_u *\nbuflist_nr2name(\n    int\t\tn,\n    int\t\tfullname,\n    int\t\thelptail)\t// for help buffers return tail only\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n\treturn NULL;\n    return home_replace_save(helptail ? buf : NULL,\n\t\t\t\t     fullname ? buf->b_ffname : buf->b_fname);\n}\n\n/*\n * Set the \"lnum\" and \"col\" for the buffer \"buf\" and the current window.\n * When \"copy_options\" is TRUE save the local window option values.\n * When \"lnum\" is 0 only do the options.\n */\n    void\nbuflist_setfpos(\n    buf_T\t*buf,\n    win_T\t*win,\t\t// may be NULL when using :badd\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    int\t\tcopy_options)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == win)\n\t    break;\n    if (wip == NULL)\n    {\n\t// allocate a new entry\n\twip = ALLOC_CLEAR_ONE(wininfo_T);\n\tif (wip == NULL)\n\t    return;\n\twip->wi_win = win;\n\tif (lnum == 0)\t\t// set lnum even when it's 0\n\t    lnum = 1;\n    }\n    else\n    {\n\t// remove the entry from the list\n\tif (wip->wi_prev)\n\t    wip->wi_prev->wi_next = wip->wi_next;\n\telse\n\t    buf->b_wininfo = wip->wi_next;\n\tif (wip->wi_next)\n\t    wip->wi_next->wi_prev = wip->wi_prev;\n\tif (copy_options && wip->wi_optset)\n\t{\n\t    clear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\t    deleteFoldRecurse(&wip->wi_folds);\n#endif\n\t}\n    }\n    if (lnum != 0)\n    {\n\twip->wi_fpos.lnum = lnum;\n\twip->wi_fpos.col = col;\n    }\n    if (copy_options && win != NULL)\n    {\n\t// Save the window-specific option values.\n\tcopy_winopt(&win->w_onebuf_opt, &wip->wi_opt);\n#ifdef FEAT_FOLDING\n\twip->wi_fold_manual = win->w_fold_manual;\n\tcloneFoldGrowArray(&win->w_folds, &wip->wi_folds);\n#endif\n\twip->wi_optset = TRUE;\n    }\n\n    // insert the entry in front of the list\n    wip->wi_next = buf->b_wininfo;\n    buf->b_wininfo = wip;\n    wip->wi_prev = NULL;\n    if (wip->wi_next)\n\twip->wi_next->wi_prev = wip;\n}\n\n#ifdef FEAT_DIFF\n/*\n * Return TRUE when \"wip\" has 'diff' set and the diff is only for another tab\n * page.  That's because a diff is local to a tab page.\n */\n    static int\nwininfo_other_tab_diff(wininfo_T *wip)\n{\n    win_T\t*wp;\n\n    if (wip->wi_opt.wo_diff)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    // return FALSE when it's a window in the current tab page, thus\n\t    // the buffer was in diff mode here\n\t    if (wip->wi_win == wp)\n\t\treturn FALSE;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Find info for the current window in buffer \"buf\".\n * If not found, return the info for the most recently used window.\n * When \"need_options\" is TRUE skip entries where wi_optset is FALSE.\n * When \"skip_diff_buffer\" is TRUE avoid windows with 'diff' set that is in\n * another tab page.\n * Returns NULL when there isn't any info.\n */\n    static wininfo_T *\nfind_wininfo(\n    buf_T\t*buf,\n    int\t\tneed_options,\n    int\t\tskip_diff_buffer UNUSED)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == curwin\n#ifdef FEAT_DIFF\n\t\t&& (!skip_diff_buffer || !wininfo_other_tab_diff(wip))\n#endif\n\n\t\t&& (!need_options || wip->wi_optset))\n\t    break;\n\n    // If no wininfo for curwin, use the first in the list (that doesn't have\n    // 'diff' set and is in another tab page).\n    // If \"need_options\" is TRUE skip entries that don't have options set,\n    // unless the window is editing \"buf\", so we can copy from the window\n    // itself.\n    if (wip == NULL)\n    {\n#ifdef FEAT_DIFF\n\tif (skip_diff_buffer)\n\t{\n\t    FOR_ALL_BUF_WININFO(buf, wip)\n\t\tif (!wininfo_other_tab_diff(wip)\n\t\t\t&& (!need_options || wip->wi_optset\n\t\t\t    || (wip->wi_win != NULL\n\t\t\t\t\t     && wip->wi_win->w_buffer == buf)))\n\t\t    break;\n\t}\n\telse\n#endif\n\t    wip = buf->b_wininfo;\n    }\n    return wip;\n}\n\n/*\n * Reset the local window options to the values last used in this window.\n * If the buffer wasn't used in this window before, use the values from\n * the most recently used window.  If the values were never set, use the\n * global values for the window.\n */\n    void\nget_winopts(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    clear_winopt(&curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n    clearFolding(curwin);\n#endif\n\n    wip = find_wininfo(buf, TRUE, TRUE);\n    if (wip != NULL && wip->wi_win != NULL\n\t    && wip->wi_win != curwin && wip->wi_win->w_buffer == buf)\n    {\n\t// The buffer is currently displayed in the window: use the actual\n\t// option values instead of the saved (possibly outdated) values.\n\twin_T *wp = wip->wi_win;\n\n\tcopy_winopt(&wp->w_onebuf_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wp->w_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wp->w_folds, &curwin->w_folds);\n#endif\n    }\n    else if (wip != NULL && wip->wi_optset)\n    {\n\t// the buffer was displayed in the current window earlier\n\tcopy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wip->wi_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wip->wi_folds, &curwin->w_folds);\n#endif\n    }\n    else\n\tcopy_winopt(&curwin->w_allbuf_opt, &curwin->w_onebuf_opt);\n\n#ifdef FEAT_FOLDING\n    // Set 'foldlevel' to 'foldlevelstart' if it's not negative.\n    if (p_fdls >= 0)\n\tcurwin->w_p_fdl = p_fdls;\n#endif\n    after_copy_winopt(curwin);\n}\n\n/*\n * Find the position (lnum and col) for the buffer 'buf' for the current\n * window.\n * Returns a pointer to no_position if no position is found.\n */\n    pos_T *\nbuflist_findfpos(buf_T *buf)\n{\n    wininfo_T\t*wip;\n    static pos_T no_position = {1, 0, 0};\n\n    wip = find_wininfo(buf, FALSE, FALSE);\n    if (wip != NULL)\n\treturn &(wip->wi_fpos);\n    else\n\treturn &no_position;\n}\n\n/*\n * Find the lnum for the buffer 'buf' for the current window.\n */\n    linenr_T\nbuflist_findlnum(buf_T *buf)\n{\n    return buflist_findfpos(buf)->lnum;\n}\n\n/*\n * List all known file names (for :files and :buffers command).\n */\n    void\nbuflist_list(exarg_T *eap)\n{\n    buf_T\t*buf = firstbuf;\n    int\t\tlen;\n    int\t\ti;\n    int\t\tro_char;\n    int\t\tchanged_char;\n#ifdef FEAT_TERMINAL\n    int\t\tjob_running;\n    int\t\tjob_none_open;\n#endif\n\n#ifdef FEAT_VIMINFO\n    garray_T\tbuflist;\n    buf_T\t**buflist_data = NULL, **p;\n\n    if (vim_strchr(eap->arg, 't'))\n    {\n\tga_init2(&buflist, sizeof(buf_T *), 50);\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    if (ga_grow(&buflist, 1) == OK)\n\t\t((buf_T **)buflist.ga_data)[buflist.ga_len++] = buf;\n\t}\n\n\tqsort(buflist.ga_data, (size_t)buflist.ga_len,\n\t\tsizeof(buf_T *), buf_compare);\n\n\tbuflist_data = (buf_T **)buflist.ga_data;\n\tbuf = *buflist_data;\n    }\n    p = buflist_data;\n\n    for (; buf != NULL && !got_int; buf = buflist_data != NULL\n\t    ? (++p < buflist_data + buflist.ga_len ? *p : NULL)\n\t    : buf->b_next)\n#else\n    for (buf = firstbuf; buf != NULL && !got_int; buf = buf->b_next)\n#endif\n    {\n#ifdef FEAT_TERMINAL\n\tjob_running = term_job_running(buf->b_term);\n\tjob_none_open = job_running && term_none_open(buf->b_term);\n#endif\n\t// skip unlisted buffers, unless ! was used\n\tif ((!buf->b_p_bl && !eap->forceit && !vim_strchr(eap->arg, 'u'))\n\t\t|| (vim_strchr(eap->arg, 'u') && buf->b_p_bl)\n\t\t|| (vim_strchr(eap->arg, '+')\n\t\t\t&& ((buf->b_flags & BF_READERR) || !bufIsChanged(buf)))\n\t\t|| (vim_strchr(eap->arg, 'a')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows == 0))\n\t\t|| (vim_strchr(eap->arg, 'h')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows != 0))\n#ifdef FEAT_TERMINAL\n\t\t|| (vim_strchr(eap->arg, 'R')\n\t\t\t&& (!job_running || (job_running && job_none_open)))\n\t\t|| (vim_strchr(eap->arg, '?')\n\t\t\t&& (!job_running || (job_running && !job_none_open)))\n\t\t|| (vim_strchr(eap->arg, 'F')\n\t\t\t&& (job_running || buf->b_term == NULL))\n#endif\n\t\t|| (vim_strchr(eap->arg, '-') && buf->b_p_ma)\n\t\t|| (vim_strchr(eap->arg, '=') && !buf->b_p_ro)\n\t\t|| (vim_strchr(eap->arg, 'x') && !(buf->b_flags & BF_READERR))\n\t\t|| (vim_strchr(eap->arg, '%') && buf != curbuf)\n\t\t|| (vim_strchr(eap->arg, '#')\n\t\t      && (buf == curbuf || curwin->w_alt_fnum != buf->b_fnum)))\n\t    continue;\n\tif (buf_spname(buf) != NULL)\n\t    vim_strncpy(NameBuff, buf_spname(buf), MAXPATHL - 1);\n\telse\n\t    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);\n\tif (message_filtered(NameBuff))\n\t    continue;\n\n\tchanged_char = (buf->b_flags & BF_READERR) ? 'x'\n\t\t\t\t\t     : (bufIsChanged(buf) ? '+' : ' ');\n#ifdef FEAT_TERMINAL\n\tif (term_job_running(buf->b_term))\n\t{\n\t    if (term_none_open(buf->b_term))\n\t\tro_char = '?';\n\t    else\n\t\tro_char = 'R';\n\t    changed_char = ' ';  // bufIsChanged() returns TRUE to avoid\n\t\t\t\t // closing, but it's not actually changed.\n\t}\n\telse if (buf->b_term != NULL)\n\t    ro_char = 'F';\n\telse\n#endif\n\t    ro_char = !buf->b_p_ma ? '-' : (buf->b_p_ro ? '=' : ' ');\n\n\tmsg_putchar('\\n');\n\tlen = vim_snprintf((char *)IObuff, IOSIZE - 20, \"%3d%c%c%c%c%c \\\"%s\\\"\",\n\t\tbuf->b_fnum,\n\t\tbuf->b_p_bl ? ' ' : 'u',\n\t\tbuf == curbuf ? '%' :\n\t\t\t(curwin->w_alt_fnum == buf->b_fnum ? '#' : ' '),\n\t\tbuf->b_ml.ml_mfp == NULL ? ' ' :\n\t\t\t(buf->b_nwindows == 0 ? 'h' : 'a'),\n\t\tro_char,\n\t\tchanged_char,\n\t\tNameBuff);\n\tif (len > IOSIZE - 20)\n\t    len = IOSIZE - 20;\n\n\t// put \"line 999\" in column 40 or after the file name\n\ti = 40 - vim_strsize(IObuff);\n\tdo\n\t    IObuff[len++] = ' ';\n\twhile (--i > 0 && len < IOSIZE - 18);\n#ifdef FEAT_VIMINFO\n\tif (vim_strchr(eap->arg, 't') && buf->b_last_used)\n\t    add_time(IObuff + len, (size_t)(IOSIZE - len), buf->b_last_used);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),\n\t\t    _(\"line %ld\"), buf == curbuf ? curwin->w_cursor.lnum\n\t\t\t\t\t       : (long)buflist_findlnum(buf));\n\tmsg_outtrans(IObuff);\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n    }\n\n#ifdef FEAT_VIMINFO\n    if (buflist_data)\n\tga_clear(&buflist);\n#endif\n}\n\n/*\n * Get file name and line number for file 'fnum'.\n * Used by DoOneCmd() for translating '%' and '#'.\n * Used by insert_reg() and cmdline_paste() for '#' register.\n * Return FAIL if not found, OK for success.\n */\n    int\nbuflist_name_nr(\n    int\t\tfnum,\n    char_u\t**fname,\n    linenr_T\t*lnum)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf == NULL || buf->b_fname == NULL)\n\treturn FAIL;\n\n    *fname = buf->b_fname;\n    *lnum = buflist_findlnum(buf);\n\n    return OK;\n}\n\n/*\n * Set the file name for \"buf\"' to \"ffname_arg\", short file name to\n * \"sfname_arg\".\n * The file name with the full path is also remembered, for when :cd is used.\n * Returns FAIL for failure (file name already in use by other buffer)\n *\tOK otherwise.\n */\n    int\nsetfname(\n    buf_T\t*buf,\n    char_u\t*ffname_arg,\n    char_u\t*sfname_arg,\n    int\t\tmessage)\t// give message when buffer already exists\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*obuf = NULL;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (ffname == NULL || *ffname == NUL)\n    {\n\t// Removing the name.\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n#ifdef UNIX\n\tst.st_dev = (dev_T)-1;\n#endif\n    }\n    else\n    {\n\tfname_expand(buf, &ffname, &sfname); // will allocate ffname\n\tif (ffname == NULL)\t\t    // out of memory\n\t    return FAIL;\n\n\t/*\n\t * If the file name is already used in another buffer:\n\t * - if the buffer is loaded, fail\n\t * - if the buffer is not loaded, delete it from the list\n\t */\n#ifdef UNIX\n\tif (mch_stat((char *)ffname, &st) < 0)\n\t    st.st_dev = (dev_T)-1;\n#endif\n\tif (!(buf->b_flags & BF_DUMMY))\n#ifdef UNIX\n\t    obuf = buflist_findname_stat(ffname, &st);\n#else\n\t    obuf = buflist_findname(ffname);\n#endif\n\tif (obuf != NULL && obuf != buf)\n\t{\n\t    win_T\t*win;\n\t    tabpage_T   *tab;\n\t    int\t\tin_use = FALSE;\n\n\t    // during startup a window may use a buffer that is not loaded yet\n\t    FOR_ALL_TAB_WINDOWS(tab, win)\n\t\tif (win->w_buffer == obuf)\n\t\t    in_use = TRUE;\n\n\t    // it's loaded or used in a window, fail\n\t    if (obuf->b_ml.ml_mfp != NULL || in_use)\n\t    {\n\t\tif (message)\n\t\t    emsg(_(e_buffer_with_this_name_already_exists));\n\t\tvim_free(ffname);\n\t\treturn FAIL;\n\t    }\n\t    // delete from the list\n\t    close_buffer(NULL, obuf, DOBUF_WIPE, FALSE, FALSE);\n\t}\n\tsfname = vim_strsave(sfname);\n\tif (ffname == NULL || sfname == NULL)\n\t{\n\t    vim_free(sfname);\n\t    vim_free(ffname);\n\t    return FAIL;\n\t}\n#ifdef USE_FNAME_CASE\n\tfname_case(sfname, 0);    // set correct case for short file name\n#endif\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = sfname;\n    }\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n\n    buf->b_shortname = FALSE;\n\n    buf_name_changed(buf);\n    return OK;\n}\n\n/*\n * Crude way of changing the name of a buffer.  Use with care!\n * The name should be relative to the current directory.\n */\n    void\nbuf_set_name(int fnum, char_u *name)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf != NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = vim_strsave(name);\n\tbuf->b_sfname = NULL;\n\t// Allocate ffname and expand into full path.  Also resolves .lnk\n\t// files on Win32.\n\tfname_expand(buf, &buf->b_ffname, &buf->b_sfname);\n\tbuf->b_fname = buf->b_sfname;\n    }\n}\n\n/*\n * Take care of what needs to be done when the name of buffer \"buf\" has\n * changed.\n */\n    void\nbuf_name_changed(buf_T *buf)\n{\n    /*\n     * If the file name changed, also change the name of the swapfile\n     */\n    if (buf->b_ml.ml_mfp != NULL)\n\tml_setname(buf);\n\n#ifdef FEAT_TERMINAL\n    if (buf->b_term != NULL)\n\tterm_clear_status_text(buf->b_term);\n#endif\n\n    if (curwin->w_buffer == buf)\n\tcheck_arg_idx(curwin);\t// check file name for arg list\n    maketitle();\t\t// set window title\n    status_redraw_all();\t// status lines need to be redrawn\n    fmarks_check_names(buf);\t// check named file marks\n    ml_timestamp(buf);\t\t// reset timestamp\n}\n\n/*\n * set alternate file name for current window\n *\n * Used by do_one_cmd(), do_write() and do_ecmd().\n * Return the buffer.\n */\n    buf_T *\nsetaltfname(\n    char_u\t*ffname,\n    char_u\t*sfname,\n    linenr_T\tlnum)\n{\n    buf_T\t*buf;\n\n    // Create a buffer.  'buflisted' is not set if it's a new buffer\n    buf = buflist_new(ffname, sfname, lnum, 0);\n    if (buf != NULL && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = buf->b_fnum;\n    return buf;\n}\n\n/*\n * Get alternate file name for current window.\n * Return NULL if there isn't any, and give error message if requested.\n */\n    char_u  *\ngetaltfname(\n    int\t\terrmsg)\t\t// give error message\n{\n    char_u\t*fname;\n    linenr_T\tdummy;\n\n    if (buflist_name_nr(0, &fname, &dummy) == FAIL)\n    {\n\tif (errmsg)\n\t    emsg(_(e_no_alternate_file));\n\treturn NULL;\n    }\n    return fname;\n}\n\n/*\n * Add a file name to the buflist and return its number.\n * Uses same flags as buflist_new(), except BLN_DUMMY.\n *\n * used by qf_init(), main() and doarglist()\n */\n    int\nbuflist_add(char_u *fname, int flags)\n{\n    buf_T\t*buf;\n\n    buf = buflist_new(fname, NULL, (linenr_T)0, flags);\n    if (buf != NULL)\n\treturn buf->b_fnum;\n    return 0;\n}\n\n#if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)\n/*\n * Adjust slashes in file names.  Called after 'shellslash' was set.\n */\n    void\nbuflist_slash_adjust(void)\n{\n    buf_T\t*bp;\n\n    FOR_ALL_BUFFERS(bp)\n    {\n\tif (bp->b_ffname != NULL)\n\t    slash_adjust(bp->b_ffname);\n\tif (bp->b_sfname != NULL)\n\t    slash_adjust(bp->b_sfname);\n    }\n}\n#endif\n\n/*\n * Set alternate cursor position for the current buffer and window \"win\".\n * Also save the local window option values.\n */\n    void\nbuflist_altfpos(win_T *win)\n{\n    buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);\n}\n\n/*\n * Return TRUE if 'ffname' is not the same file as current file.\n * Fname must have a full path (expanded by mch_FullName()).\n */\n    int\notherfile(char_u *ffname)\n{\n    return otherfile_buf(curbuf, ffname\n#ifdef UNIX\n\t    , NULL\n#endif\n\t    );\n}\n\n    static int\notherfile_buf(\n    buf_T\t\t*buf,\n    char_u\t\t*ffname\n#ifdef UNIX\n    , stat_T\t\t*stp\n#endif\n    )\n{\n    // no name is different\n    if (ffname == NULL || *ffname == NUL || buf->b_ffname == NULL)\n\treturn TRUE;\n    if (fnamecmp(ffname, buf->b_ffname) == 0)\n\treturn FALSE;\n#ifdef UNIX\n    {\n\tstat_T\t    st;\n\n\t// If no stat_T given, get it now\n\tif (stp == NULL)\n\t{\n\t    if (!buf->b_dev_valid || mch_stat((char *)ffname, &st) < 0)\n\t\tst.st_dev = (dev_T)-1;\n\t    stp = &st;\n\t}\n\t// Use dev/ino to check if the files are the same, even when the names\n\t// are different (possible with links).  Still need to compare the\n\t// name above, for when the file doesn't exist yet.\n\t// Problem: The dev/ino changes when a file is deleted (and created\n\t// again) and remains the same when renamed/moved.  We don't want to\n\t// mch_stat() each buffer each time, that would be too slow.  Get the\n\t// dev/ino again when they appear to match, but not when they appear\n\t// to be different: Could skip a buffer when it's actually the same\n\t// file.\n\tif (buf_same_ino(buf, stp))\n\t{\n\t    buf_setino(buf);\n\t    if (buf_same_ino(buf, stp))\n\t\treturn FALSE;\n\t}\n    }\n#endif\n    return TRUE;\n}\n\n#if defined(UNIX) || defined(PROTO)\n/*\n * Set inode and device number for a buffer.\n * Must always be called when b_fname is changed!.\n */\n    void\nbuf_setino(buf_T *buf)\n{\n    stat_T\tst;\n\n    if (buf->b_fname != NULL && mch_stat((char *)buf->b_fname, &st) >= 0)\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n    else\n\tbuf->b_dev_valid = FALSE;\n}\n\n/*\n * Return TRUE if dev/ino in buffer \"buf\" matches with \"stp\".\n */\n    static int\nbuf_same_ino(\n    buf_T\t*buf,\n    stat_T\t*stp)\n{\n    return (buf->b_dev_valid\n\t    && stp->st_dev == buf->b_dev\n\t    && stp->st_ino == buf->b_ino);\n}\n#endif\n\n/*\n * Print info about the current buffer.\n */\n    void\nfileinfo(\n    int fullname,\t    // when non-zero print full path\n    int shorthelp,\n    int\tdont_truncate)\n{\n    char_u\t*name;\n    int\t\tn;\n    char\t*p;\n    char\t*buffer;\n    size_t\tlen;\n\n    buffer = alloc(IOSIZE);\n    if (buffer == NULL)\n\treturn;\n\n    if (fullname > 1)\t    // 2 CTRL-G: include buffer number\n    {\n\tvim_snprintf(buffer, IOSIZE, \"buf %d: \", curbuf->b_fnum);\n\tp = buffer + STRLEN(buffer);\n    }\n    else\n\tp = buffer;\n\n    *p++ = '\"';\n    if (buf_spname(curbuf) != NULL)\n\tvim_strncpy((char_u *)p, buf_spname(curbuf), IOSIZE - (p - buffer) - 1);\n    else\n    {\n\tif (!fullname && curbuf->b_fname != NULL)\n\t    name = curbuf->b_fname;\n\telse\n\t    name = curbuf->b_ffname;\n\thome_replace(shorthelp ? curbuf : NULL, name, (char_u *)p,\n\t\t\t\t\t  (int)(IOSIZE - (p - buffer)), TRUE);\n    }\n\n    vim_snprintf_add(buffer, IOSIZE, \"\\\"%s%s%s%s%s%s\",\n\t    curbufIsChanged() ? (shortmess(SHM_MOD)\n\t\t\t\t\t  ?  \" [+]\" : _(\" [Modified]\")) : \" \",\n\t    (curbuf->b_flags & BF_NOTEDITED)\n#ifdef FEAT_QUICKFIX\n\t\t    && !bt_dontwrite(curbuf)\n#endif\n\t\t\t\t\t? _(\"[Not edited]\") : \"\",\n\t    (curbuf->b_flags & BF_NEW)\n#ifdef FEAT_QUICKFIX\n\t\t    && !bt_dontwrite(curbuf)\n#endif\n\t\t\t\t\t   ? new_file_message() : \"\",\n\t    (curbuf->b_flags & BF_READERR) ? _(\"[Read errors]\") : \"\",\n\t    curbuf->b_p_ro ? (shortmess(SHM_RO) ? _(\"[RO]\")\n\t\t\t\t\t\t      : _(\"[readonly]\")) : \"\",\n\t    (curbufIsChanged() || (curbuf->b_flags & BF_WRITE_MASK)\n\t\t\t\t\t\t\t  || curbuf->b_p_ro) ?\n\t\t\t\t\t\t\t\t    \" \" : \"\");\n    // With 32 bit longs and more than 21,474,836 lines multiplying by 100\n    // causes an overflow, thus for large numbers divide instead.\n    if (curwin->w_cursor.lnum > 1000000L)\n\tn = (int)(((long)curwin->w_cursor.lnum) /\n\t\t\t\t   ((long)curbuf->b_ml.ml_line_count / 100L));\n    else\n\tn = (int)(((long)curwin->w_cursor.lnum * 100L) /\n\t\t\t\t\t    (long)curbuf->b_ml.ml_line_count);\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tvim_snprintf_add(buffer, IOSIZE, \"%s\", _(no_lines_msg));\n#ifdef FEAT_CMDL_INFO\n    else if (p_ru)\n\t// Current line and column are already on the screen -- webb\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\tNGETTEXT(\"%ld line --%d%%--\", \"%ld lines --%d%%--\",\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count),\n\t\t(long)curbuf->b_ml.ml_line_count, n);\n#endif\n    else\n    {\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\t_(\"line %ld of %ld --%d%%-- col \"),\n\t\t(long)curwin->w_cursor.lnum,\n\t\t(long)curbuf->b_ml.ml_line_count,\n\t\tn);\n\tvalidate_virtcol();\n\tlen = STRLEN(buffer);\n\tcol_print((char_u *)buffer + len, IOSIZE - len,\n\t\t   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);\n    }\n\n    (void)append_arg_number(curwin, (char_u *)buffer, IOSIZE,\n\t\t\t\t\t\t\t !shortmess(SHM_FILE));\n\n    if (dont_truncate)\n    {\n\t// Temporarily set msg_scroll to avoid the message being truncated.\n\t// First call msg_start() to get the message in the right place.\n\tmsg_start();\n\tn = msg_scroll;\n\tmsg_scroll = TRUE;\n\tmsg(buffer);\n\tmsg_scroll = n;\n    }\n    else\n    {\n\tp = msg_trunc_attr(buffer, FALSE, 0);\n\tif (restart_edit != 0 || (msg_scrolled && !need_wait_return))\n\t    // Need to repeat the message after redrawing when:\n\t    // - When restart_edit is set (otherwise there will be a delay\n\t    //   before redrawing).\n\t    // - When the screen was scrolled but there is no wait-return\n\t    //   prompt.\n\t    set_keep_msg((char_u *)p, 0);\n    }\n\n    vim_free(buffer);\n}\n\n    void\ncol_print(\n    char_u  *buf,\n    size_t  buflen,\n    int\t    col,\n    int\t    vcol)\n{\n    if (col == vcol)\n\tvim_snprintf((char *)buf, buflen, \"%d\", col);\n    else\n\tvim_snprintf((char *)buf, buflen, \"%d-%d\", col, vcol);\n}\n\nstatic char_u *lasttitle = NULL;\nstatic char_u *lasticon = NULL;\n\n/*\n * Put the file name in the title bar and icon of the window.\n */\n    void\nmaketitle(void)\n{\n    char_u\t*p;\n    char_u\t*title_str = NULL;\n    char_u\t*icon_str = NULL;\n    int\t\tmaxlen = 0;\n    int\t\tlen;\n    int\t\tmustset;\n    char_u\tbuf[IOSIZE];\n    int\t\toff;\n\n    if (!redrawing())\n    {\n\t// Postpone updating the title when 'lazyredraw' is set.\n\tneed_maketitle = TRUE;\n\treturn;\n    }\n\n    need_maketitle = FALSE;\n    if (!p_title && !p_icon && lasttitle == NULL && lasticon == NULL)\n\treturn;  // nothing to do\n\n    if (p_title)\n    {\n\tif (p_titlelen > 0)\n\t{\n\t    maxlen = p_titlelen * Columns / 100;\n\t    if (maxlen < 10)\n\t\tmaxlen = 10;\n\t}\n\n\ttitle_str = buf;\n\tif (*p_titlestring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_TITLE)\n\t    {\n\t\tint\tuse_sandbox = FALSE;\n\t\tint\tcalled_emsg_before = called_emsg;\n\n# ifdef FEAT_EVAL\n\t\tuse_sandbox = was_set_insecurely((char_u *)\"titlestring\", 0);\n# endif\n\t\tbuild_stl_str_hl(curwin, title_str, sizeof(buf),\n\t\t\t\t\t      p_titlestring, use_sandbox,\n\t\t\t\t\t      0, maxlen, NULL, NULL);\n\t\tif (called_emsg > called_emsg_before)\n\t\t    set_string_option_direct((char_u *)\"titlestring\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\t    }\n\t    else\n#endif\n\t\ttitle_str = p_titlestring;\n\t}\n\telse\n\t{\n\t    // format: \"fname + (path) (1 of 2) - VIM\"\n\n#define SPACE_FOR_FNAME (IOSIZE - 100)\n#define SPACE_FOR_DIR   (IOSIZE - 20)\n#define SPACE_FOR_ARGNR (IOSIZE - 10)  // at least room for \" - VIM\"\n\t    if (curbuf->b_fname == NULL)\n\t\tvim_strncpy(buf, (char_u *)_(\"[No Name]\"), SPACE_FOR_FNAME);\n#ifdef FEAT_TERMINAL\n\t    else if (curbuf->b_term != NULL)\n\t    {\n\t\tvim_strncpy(buf, term_get_status_text(curbuf->b_term),\n\t\t\t\t\t\t\t      SPACE_FOR_FNAME);\n\t    }\n#endif\n\t    else\n\t    {\n\t\tp = transstr(gettail(curbuf->b_fname));\n\t\tvim_strncpy(buf, p, SPACE_FOR_FNAME);\n\t\tvim_free(p);\n\t    }\n\n#ifdef FEAT_TERMINAL\n\t    if (curbuf->b_term == NULL)\n#endif\n\t\tswitch (bufIsChanged(curbuf)\n\t\t\t+ (curbuf->b_p_ro * 2)\n\t\t\t+ (!curbuf->b_p_ma * 4))\n\t\t{\n\t\t    case 1: STRCAT(buf, \" +\"); break;\n\t\t    case 2: STRCAT(buf, \" =\"); break;\n\t\t    case 3: STRCAT(buf, \" =+\"); break;\n\t\t    case 4:\n\t\t    case 6: STRCAT(buf, \" -\"); break;\n\t\t    case 5:\n\t\t    case 7: STRCAT(buf, \" -+\"); break;\n\t\t}\n\n\t    if (curbuf->b_fname != NULL\n#ifdef FEAT_TERMINAL\n\t\t    && curbuf->b_term == NULL\n#endif\n\t\t    )\n\t    {\n\t\t// Get path of file, replace home dir with ~\n\t\toff = (int)STRLEN(buf);\n\t\tbuf[off++] = ' ';\n\t\tbuf[off++] = '(';\n\t\thome_replace(curbuf, curbuf->b_ffname,\n\t\t\t\t\tbuf + off, SPACE_FOR_DIR - off, TRUE);\n#ifdef BACKSLASH_IN_FILENAME\n\t\t// avoid \"c:/name\" to be reduced to \"c\"\n\t\tif (isalpha(buf[off]) && buf[off + 1] == ':')\n\t\t    off += 2;\n#endif\n\t\t// remove the file name\n\t\tp = gettail_sep(buf + off);\n\t\tif (p == buf + off)\n\t\t{\n\t\t    // must be a help buffer\n\t\t    vim_strncpy(buf + off, (char_u *)_(\"help\"),\n\t\t\t\t\t   (size_t)(SPACE_FOR_DIR - off - 1));\n\t\t}\n\t\telse\n\t\t    *p = NUL;\n\n\t\t// Translate unprintable chars and concatenate.  Keep some\n\t\t// room for the server name.  When there is no room (very long\n\t\t// file name) use (...).\n\t\tif (off < SPACE_FOR_DIR)\n\t\t{\n\t\t    p = transstr(buf + off);\n\t\t    vim_strncpy(buf + off, p, (size_t)(SPACE_FOR_DIR - off));\n\t\t    vim_free(p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    vim_strncpy(buf + off, (char_u *)\"...\",\n\t\t\t\t\t     (size_t)(SPACE_FOR_ARGNR - off));\n\t\t}\n\t\tSTRCAT(buf, \")\");\n\t    }\n\n\t    append_arg_number(curwin, buf, SPACE_FOR_ARGNR, FALSE);\n\n#if defined(FEAT_CLIENTSERVER)\n\t    if (serverName != NULL)\n\t    {\n\t\tSTRCAT(buf, \" - \");\n\t\tvim_strcat(buf, serverName, IOSIZE);\n\t    }\n\t    else\n#endif\n\t\tSTRCAT(buf, \" - VIM\");\n\n\t    if (maxlen > 0)\n\t    {\n\t\t// make it shorter by removing a bit in the middle\n\t\tif (vim_strsize(buf) > maxlen)\n\t\t    trunc_string(buf, buf, maxlen, IOSIZE);\n\t    }\n\t}\n    }\n    mustset = value_changed(title_str, &lasttitle);\n\n    if (p_icon)\n    {\n\ticon_str = buf;\n\tif (*p_iconstring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_ICON)\n\t    {\n\t\tint\tuse_sandbox = FALSE;\n\t\tint\tcalled_emsg_before = called_emsg;\n\n# ifdef FEAT_EVAL\n\t\tuse_sandbox = was_set_insecurely((char_u *)\"iconstring\", 0);\n# endif\n\t\tbuild_stl_str_hl(curwin, icon_str, sizeof(buf),\n\t\t\t\t\t\t    p_iconstring, use_sandbox,\n\t\t\t\t\t\t    0, 0, NULL, NULL);\n\t\tif (called_emsg > called_emsg_before)\n\t\t    set_string_option_direct((char_u *)\"iconstring\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\t    }\n\t    else\n#endif\n\t\ticon_str = p_iconstring;\n\t}\n\telse\n\t{\n\t    if (buf_spname(curbuf) != NULL)\n\t\tp = buf_spname(curbuf);\n\t    else\t\t    // use file name only in icon\n\t\tp = gettail(curbuf->b_ffname);\n\t    *icon_str = NUL;\n\t    // Truncate name at 100 bytes.\n\t    len = (int)STRLEN(p);\n\t    if (len > 100)\n\t    {\n\t\tlen -= 100;\n\t\tif (has_mbyte)\n\t\t    len += (*mb_tail_off)(p, p + len) + 1;\n\t\tp += len;\n\t    }\n\t    STRCPY(icon_str, p);\n\t    trans_characters(icon_str, IOSIZE);\n\t}\n    }\n\n    mustset |= value_changed(icon_str, &lasticon);\n\n    if (mustset)\n\tresettitle();\n}\n\n/*\n * Used for title and icon: Check if \"str\" differs from \"*last\".  Set \"*last\"\n * from \"str\" if it does.\n * Return TRUE if resettitle() is to be called.\n */\n    static int\nvalue_changed(char_u *str, char_u **last)\n{\n    if ((str == NULL) != (*last == NULL)\n\t    || (str != NULL && *last != NULL && STRCMP(str, *last) != 0))\n    {\n\tvim_free(*last);\n\tif (str == NULL)\n\t{\n\t    *last = NULL;\n\t    mch_restore_title(\n\t\t  last == &lasttitle ? SAVE_RESTORE_TITLE : SAVE_RESTORE_ICON);\n\t}\n\telse\n\t{\n\t    *last = vim_strsave(str);\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Put current window title back (used after calling a shell)\n */\n    void\nresettitle(void)\n{\n    mch_settitle(lasttitle, lasticon);\n}\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_titles(void)\n{\n    vim_free(lasttitle);\n    vim_free(lasticon);\n}\n# endif\n\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n\n/*\n * Used for building in the status line.\n */\ntypedef struct\n{\n    char_u\t*stl_start;\n    int\t\tstl_minwid;\n    int\t\tstl_maxwid;\n    enum {\n\tNormal,\n\tEmpty,\n\tGroup,\n\tMiddle,\n\tHighlight,\n\tTabPage,\n\tTrunc\n    }\t\tstl_type;\n} stl_item_T;\n\nstatic size_t\t\tstl_items_len = 20; // Initial value, grows as needed.\nstatic stl_item_T      *stl_items = NULL;\nstatic int\t       *stl_groupitem = NULL;\nstatic stl_hlrec_T     *stl_hltab = NULL;\nstatic stl_hlrec_T     *stl_tabtab = NULL;\n\n/*\n * Build a string from the status line items in \"fmt\".\n * Return length of string in screen cells.\n *\n * Normally works for window \"wp\", except when working for 'tabline' then it\n * is \"curwin\".\n *\n * Items are drawn interspersed with the text that surrounds it\n * Specials: %-<wid>(xxx%) => group, %= => middle marker, %< => truncation\n * Item: %-<minwid>.<maxwid><itemch> All but <itemch> are optional\n *\n * If maxwidth is not zero, the string will be filled at any middle marker\n * or truncated if too long, fillchar is used for all whitespace.\n */\n    int\nbuild_stl_str_hl(\n    win_T\t*wp,\n    char_u\t*out,\t\t// buffer to write into != NameBuff\n    size_t\toutlen,\t\t// length of out[]\n    char_u\t*fmt,\n    int\t\tuse_sandbox UNUSED, // \"fmt\" was set insecurely, use sandbox\n    int\t\tfillchar,\n    int\t\tmaxwidth,\n    stl_hlrec_T **hltab,\t// return: HL attributes (can be NULL)\n    stl_hlrec_T **tabtab)\t// return: tab page nrs (can be NULL)\n{\n    linenr_T\tlnum;\n    size_t\tlen;\n    char_u\t*p;\n    char_u\t*s;\n    char_u\t*t;\n    int\t\tbyteval;\n#ifdef FEAT_EVAL\n    win_T\t*save_curwin;\n    buf_T\t*save_curbuf;\n    int\t\tsave_VIsual_active;\n#endif\n    int\t\tempty_line;\n    colnr_T\tvirtcol;\n    long\tl;\n    long\tn;\n    int\t\tprevchar_isflag;\n    int\t\tprevchar_isitem;\n    int\t\titemisflag;\n    int\t\tfillable;\n    char_u\t*str;\n    long\tnum;\n    int\t\twidth;\n    int\t\titemcnt;\n    int\t\tcuritem;\n    int\t\tgroup_end_userhl;\n    int\t\tgroup_start_userhl;\n    int\t\tgroupdepth;\n#ifdef FEAT_EVAL\n    int\t\tevaldepth;\n#endif\n    int\t\tminwid;\n    int\t\tmaxwid;\n    int\t\tzeropad;\n    char_u\tbase;\n    char_u\topt;\n#define TMPLEN 70\n    char_u\tbuf_tmp[TMPLEN];\n    char_u\twin_tmp[TMPLEN];\n    char_u\t*usefmt = fmt;\n    stl_hlrec_T *sp;\n    int\t\tsave_must_redraw = must_redraw;\n    int\t\tsave_redr_type = curwin->w_redr_type;\n\n    if (stl_items == NULL)\n    {\n\tstl_items = ALLOC_MULT(stl_item_T, stl_items_len);\n\tstl_groupitem = ALLOC_MULT(int, stl_items_len);\n\tstl_hltab  = ALLOC_MULT(stl_hlrec_T, stl_items_len);\n\tstl_tabtab = ALLOC_MULT(stl_hlrec_T, stl_items_len);\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * When the format starts with \"%!\" then evaluate it as an expression and\n     * use the result as the actual format string.\n     */\n    if (fmt[0] == '%' && fmt[1] == '!')\n    {\n\ttypval_T\ttv;\n\n\ttv.v_type = VAR_NUMBER;\n\ttv.vval.v_number = wp->w_id;\n\tset_var((char_u *)\"g:statusline_winid\", &tv, FALSE);\n\n\tusefmt = eval_to_string_safe(fmt + 2, use_sandbox, FALSE);\n\tif (usefmt == NULL)\n\t    usefmt = fmt;\n\n\tdo_unlet((char_u *)\"g:statusline_winid\", TRUE);\n    }\n#endif\n\n    if (fillchar == 0)\n\tfillchar = ' ';\n\n    // The cursor in windows other than the current one isn't always\n    // up-to-date, esp. because of autocommands and timers.\n    lnum = wp->w_cursor.lnum;\n    if (lnum > wp->w_buffer->b_ml.ml_line_count)\n    {\n\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\twp->w_cursor.lnum = lnum;\n    }\n\n    // Get line & check if empty (cursorpos will show \"0-1\").  Note that\n    // p will become invalid when getting another buffer line.\n    p = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    empty_line = (*p == NUL);\n\n    // Get the byte value now, in case we need it below. This is more efficient\n    // than making a copy of the line.\n    len = STRLEN(p);\n    if (wp->w_cursor.col > (colnr_T)len)\n    {\n\t// Line may have changed since checking the cursor column, or the lnum\n\t// was adjusted above.\n\twp->w_cursor.col = (colnr_T)len;\n\twp->w_cursor.coladd = 0;\n\tbyteval = 0;\n    }\n    else\n\tbyteval = (*mb_ptr2char)(p + wp->w_cursor.col);\n\n    groupdepth = 0;\n#ifdef FEAT_EVAL\n    evaldepth = 0;\n#endif\n    p = out;\n    curitem = 0;\n    prevchar_isflag = TRUE;\n    prevchar_isitem = FALSE;\n    for (s = usefmt; *s; )\n    {\n\tif (curitem == (int)stl_items_len)\n\t{\n\t    size_t\tnew_len = stl_items_len * 3 / 2;\n\t    stl_item_T\t*new_items;\n\t    int\t\t*new_groupitem;\n\t    stl_hlrec_T\t*new_hlrec;\n\n\t    new_items = vim_realloc(stl_items, sizeof(stl_item_T) * new_len);\n\t    if (new_items == NULL)\n\t\tbreak;\n\t    stl_items = new_items;\n\t    new_groupitem = vim_realloc(stl_groupitem, sizeof(int) * new_len);\n\t    if (new_groupitem == NULL)\n\t\tbreak;\n\t    stl_groupitem = new_groupitem;\n\t    new_hlrec = vim_realloc(stl_hltab, sizeof(stl_hlrec_T) * new_len);\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_hltab = new_hlrec;\n\t    new_hlrec = vim_realloc(stl_tabtab, sizeof(stl_hlrec_T) * new_len);\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_tabtab = new_hlrec;\n\t    stl_items_len = new_len;\n\t}\n\n\tif (*s != NUL && *s != '%')\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\n\t/*\n\t * Handle up to the next '%' or the end.\n\t */\n\twhile (*s != NUL && *s != '%' && p + 1 < out + outlen)\n\t    *p++ = *s++;\n\tif (*s == NUL || p + 1 >= out + outlen)\n\t    break;\n\n\t/*\n\t * Handle one '%' item.\n\t */\n\ts++;\n\tif (*s == NUL)  // ignore trailing %\n\t    break;\n\tif (*s == '%')\n\t{\n\t    if (p + 1 >= out + outlen)\n\t\tbreak;\n\t    *p++ = *s++;\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\t    continue;\n\t}\n\tif (*s == STL_MIDDLEMARK)\n\t{\n\t    s++;\n\t    if (groupdepth > 0)\n\t\tcontinue;\n\t    stl_items[curitem].stl_type = Middle;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == STL_TRUNCMARK)\n\t{\n\t    s++;\n\t    stl_items[curitem].stl_type = Trunc;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == ')')\n\t{\n\t    s++;\n\t    if (groupdepth < 1)\n\t\tcontinue;\n\t    groupdepth--;\n\n\t    t = stl_items[stl_groupitem[groupdepth]].stl_start;\n\t    *p = NUL;\n\t    l = vim_strsize(t);\n\t    if (curitem > stl_groupitem[groupdepth] + 1\n\t\t    && stl_items[stl_groupitem[groupdepth]].stl_minwid == 0)\n\t    {\n\t\t// remove group if all items are empty and highlight group\n\t\t// doesn't change\n\t\tgroup_start_userhl = group_end_userhl = 0;\n\t\tfor (n = stl_groupitem[groupdepth] - 1; n >= 0; n--)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t    {\n\t\t\tgroup_start_userhl = group_end_userhl =\n\t\t\t\t\t\t       stl_items[n].stl_minwid;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tfor (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Normal)\n\t\t\tbreak;\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t\tgroup_end_userhl = stl_items[n].stl_minwid;\n\t\t}\n\t\tif (n == curitem && group_start_userhl == group_end_userhl)\n\t\t{\n\t\t    // empty group\n\t\t    p = t;\n\t\t    l = 0;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t    {\n\t\t\t// do not use the highlighting from the removed group\n\t\t\tif (stl_items[n].stl_type == Highlight)\n\t\t\t    stl_items[n].stl_type = Empty;\n\t\t\t// adjust the start position of TabPage to the next\n\t\t\t// item position\n\t\t\tif (stl_items[n].stl_type == TabPage)\n\t\t\t    stl_items[n].stl_start = p;\n\t\t    }\n\t\t}\n\t    }\n\t    if (l > stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t    {\n\t\t// truncate, remove n bytes of text at the start\n\t\tif (has_mbyte)\n\t\t{\n\t\t    // Find the first character that should be included.\n\t\t    n = 0;\n\t\t    while (l >= stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t\t    {\n\t\t\tl -= ptr2cells(t + n);\n\t\t\tn += (*mb_ptr2len)(t + n);\n\t\t    }\n\t\t}\n\t\telse\n\t\t    n = (long)(p - t) - stl_items[stl_groupitem[groupdepth]]\n\t\t\t\t\t\t\t       .stl_maxwid + 1;\n\n\t\t*t = '<';\n\t\tmch_memmove(t + 1, t + n, (size_t)(p - (t + n)));\n\t\tp = p - n + 1;\n\n\t\t// Fill up space left over by half a double-wide char.\n\t\twhile (++l < stl_items[stl_groupitem[groupdepth]].stl_minwid)\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\n\t\t// correct the start of the items for the truncation\n\t\tfor (l = stl_groupitem[groupdepth] + 1; l < curitem; l++)\n\t\t{\n\t\t    stl_items[l].stl_start -= n;\n\t\t    if (stl_items[l].stl_start < t)\n\t\t\tstl_items[l].stl_start = t;\n\t\t}\n\t    }\n\t    else if (abs(stl_items[stl_groupitem[groupdepth]].stl_minwid) > l)\n\t    {\n\t\t// fill\n\t\tn = stl_items[stl_groupitem[groupdepth]].stl_minwid;\n\t\tif (n < 0)\n\t\t{\n\t\t    // fill by appending characters\n\t\t    n = 0 - n;\n\t\t    while (l++ < n && p + 1 < out + outlen)\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // fill by inserting characters\n\t\t    l = (n - l) * MB_CHAR2LEN(fillchar);\n\t\t    mch_memmove(t + l, t, (size_t)(p - t));\n\t\t    if (p + l >= out + outlen)\n\t\t\tl = (long)((out + outlen) - p - 1);\n\t\t    p += l;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t\tstl_items[n].stl_start += l;\n\t\t    for ( ; l > 0; l--)\n\t\t\tMB_CHAR2BYTES(fillchar, t);\n\t\t}\n\t    }\n\t    continue;\n\t}\n\tminwid = 0;\n\tmaxwid = 9999;\n\tzeropad = FALSE;\n\tl = 1;\n\tif (*s == '0')\n\t{\n\t    s++;\n\t    zeropad = TRUE;\n\t}\n\tif (*s == '-')\n\t{\n\t    s++;\n\t    l = -1;\n\t}\n\tif (VIM_ISDIGIT(*s))\n\t{\n\t    minwid = (int)getdigits(&s);\n\t    if (minwid < 0)\t// overflow\n\t\tminwid = 0;\n\t}\n\tif (*s == STL_USER_HL)\n\t{\n\t    stl_items[curitem].stl_type = Highlight;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid > 9 ? 1 : minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == STL_TABPAGENR || *s == STL_TABCLOSENR)\n\t{\n\t    if (*s == STL_TABCLOSENR)\n\t    {\n\t\tif (minwid == 0)\n\t\t{\n\t\t    // %X ends the close label, go back to the previously\n\t\t    // define tab label nr.\n\t\t    for (n = curitem - 1; n >= 0; --n)\n\t\t\tif (stl_items[n].stl_type == TabPage\n\t\t\t\t\t       && stl_items[n].stl_minwid >= 0)\n\t\t\t{\n\t\t\t    minwid = stl_items[n].stl_minwid;\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t    // close nrs are stored as negative values\n\t\t    minwid = - minwid;\n\t    }\n\t    stl_items[curitem].stl_type = TabPage;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == '.')\n\t{\n\t    s++;\n\t    if (VIM_ISDIGIT(*s))\n\t    {\n\t\tmaxwid = (int)getdigits(&s);\n\t\tif (maxwid <= 0)\t// overflow\n\t\t    maxwid = 50;\n\t    }\n\t}\n\tminwid = (minwid > 50 ? 50 : minwid) * l;\n\tif (*s == '(')\n\t{\n\t    stl_groupitem[groupdepth++] = curitem;\n\t    stl_items[curitem].stl_type = Group;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    stl_items[curitem].stl_maxwid = maxwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n#ifdef FEAT_EVAL\n\t// Denotes end of expanded %{} block\n\tif (*s == '}' && evaldepth > 0)\n\t{\n\t    s++;\n\t    evaldepth--;\n\t    continue;\n\t}\n#endif\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    s++;\n\t    continue;\n\t}\n\topt = *s++;\n\n\t// OK - now for the real work\n\tbase = 'D';\n\titemisflag = FALSE;\n\tfillable = TRUE;\n\tnum = -1;\n\tstr = NULL;\n\tswitch (opt)\n\t{\n\tcase STL_FILEPATH:\n\tcase STL_FULLPATH:\n\tcase STL_FILENAME:\n\t    fillable = FALSE;\t// don't change ' ' to fillchar\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(NameBuff, buf_spname(wp->w_buffer), MAXPATHL - 1);\n\t    else\n\t    {\n\t\tt = (opt == STL_FULLPATH) ? wp->w_buffer->b_ffname\n\t\t\t\t\t  : wp->w_buffer->b_fname;\n\t\thome_replace(wp->w_buffer, t, NameBuff, MAXPATHL, TRUE);\n\t    }\n\t    trans_characters(NameBuff, MAXPATHL);\n\t    if (opt != STL_FILENAME)\n\t\tstr = NameBuff;\n\t    else\n\t\tstr = gettail(NameBuff);\n\t    break;\n\n\tcase STL_VIM_EXPR: // '{'\n\t{\n#ifdef FEAT_EVAL\n\t    char_u *block_start = s - 1;\n#endif\n\t    int reevaluate = (*s == '%');\n\n\t    if (reevaluate)\n\t\ts++;\n\t    itemisflag = TRUE;\n\t    t = p;\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%'))\n\t\t\t\t\t  && *s != NUL && p + 1 < out + outlen)\n\t\t*p++ = *s++;\n\t    if (*s != '}')\t// missing '}' or out of space\n\t\tbreak;\n\t    s++;\n\t    if (reevaluate)\n\t\tp[-1] = 0; // remove the % at the end of %{% expr %}\n\t    else\n\t\t*p = 0;\n\t    p = t;\n#ifdef FEAT_EVAL\n\t    vim_snprintf((char *)buf_tmp, sizeof(buf_tmp),\n\t\t\t\t\t\t\t \"%d\", curbuf->b_fnum);\n\t    set_internal_string_var((char_u *)\"g:actual_curbuf\", buf_tmp);\n\t    vim_snprintf((char *)win_tmp, sizeof(win_tmp), \"%d\", curwin->w_id);\n\t    set_internal_string_var((char_u *)\"g:actual_curwin\", win_tmp);\n\n\t    save_curbuf = curbuf;\n\t    save_curwin = curwin;\n\t    save_VIsual_active = VIsual_active;\n\t    curwin = wp;\n\t    curbuf = wp->w_buffer;\n\t    // Visual mode is only valid in the current window.\n\t    if (curwin != save_curwin)\n\t\tVIsual_active = FALSE;\n\n\t    str = eval_to_string_safe(p, use_sandbox, FALSE);\n\n\t    curwin = save_curwin;\n\t    curbuf = save_curbuf;\n\t    VIsual_active = save_VIsual_active;\n\t    do_unlet((char_u *)\"g:actual_curbuf\", TRUE);\n\t    do_unlet((char_u *)\"g:actual_curwin\", TRUE);\n\n\t    if (str != NULL && *str != 0)\n\t    {\n\t\tif (*skipdigits(str) == NUL)\n\t\t{\n\t\t    num = atoi((char *)str);\n\t\t    VIM_CLEAR(str);\n\t\t    itemisflag = FALSE;\n\t\t}\n\t    }\n\n\t    // If the output of the expression needs to be evaluated\n\t    // replace the %{} block with the result of evaluation\n\t    if (reevaluate && str != NULL && *str != 0\n\t\t    && strchr((const char *)str, '%') != NULL\n\t\t    && evaldepth < MAX_STL_EVAL_DEPTH)\n\t    {\n\t\tsize_t parsed_usefmt = (size_t)(block_start - usefmt);\n\t\tsize_t str_length = strlen((const char *)str);\n\t\tsize_t fmt_length = strlen((const char *)s);\n\t\tsize_t new_fmt_len = parsed_usefmt\n\t\t\t\t\t\t + str_length + fmt_length + 3;\n\t\tchar_u *new_fmt = (char_u *)alloc(new_fmt_len * sizeof(char_u));\n\t\tchar_u *new_fmt_p = new_fmt;\n\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, usefmt, parsed_usefmt)\n\t\t\t\t\t\t\t       + parsed_usefmt;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , str, str_length)\n\t\t\t\t\t\t\t\t  + str_length;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, \"%}\", 2) + 2;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , s, fmt_length)\n\t\t\t\t\t\t\t\t  + fmt_length;\n\t\t*new_fmt_p = 0;\n\t\tnew_fmt_p = NULL;\n\n\t\tif (usefmt != fmt)\n\t\t    vim_free(usefmt);\n\t\tVIM_CLEAR(str);\n\t\tusefmt = new_fmt;\n\t\ts = usefmt + parsed_usefmt;\n\t\tevaldepth++;\n\t\tcontinue;\n\t    }\n#endif\n\t    break;\n\t}\n\tcase STL_LINE:\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY)\n\t\t  ? 0L : (long)(wp->w_cursor.lnum);\n\t    break;\n\n\tcase STL_NUMLINES:\n\t    num = wp->w_buffer->b_ml.ml_line_count;\n\t    break;\n\n\tcase STL_COLUMN:\n\t    num = !(State & INSERT) && empty_line\n\t\t  ? 0 : (int)wp->w_cursor.col + 1;\n\t    break;\n\n\tcase STL_VIRTCOL:\n\tcase STL_VIRTCOL_ALT:\n\t    virtcol = wp->w_virtcol + 1;\n\t    // Don't display %V if it's the same as %c.\n\t    if (opt == STL_VIRTCOL_ALT\n\t\t    && (virtcol == (colnr_T)(!(State & INSERT) && empty_line\n\t\t\t    ? 0 : (int)wp->w_cursor.col + 1)))\n\t\tbreak;\n\t    num = (long)virtcol;\n\t    break;\n\n\tcase STL_PERCENTAGE:\n\t    num = (int)(((long)wp->w_cursor.lnum * 100L) /\n\t\t\t(long)wp->w_buffer->b_ml.ml_line_count);\n\t    break;\n\n\tcase STL_ALTPERCENT:\n\t    str = buf_tmp;\n\t    get_rel_pos(wp, str, TMPLEN);\n\t    break;\n\n\tcase STL_ARGLISTSTAT:\n\t    fillable = FALSE;\n\t    buf_tmp[0] = 0;\n\t    if (append_arg_number(wp, buf_tmp, (int)sizeof(buf_tmp), FALSE))\n\t\tstr = buf_tmp;\n\t    break;\n\n\tcase STL_KEYMAP:\n\t    fillable = FALSE;\n\t    if (get_keymap_str(wp, (char_u *)\"<%s>\", buf_tmp, TMPLEN))\n\t\tstr = buf_tmp;\n\t    break;\n\tcase STL_PAGENUM:\n#if defined(FEAT_PRINTER) || defined(FEAT_GUI_TABLINE)\n\t    num = printer_page_num;\n#else\n\t    num = 0;\n#endif\n\t    break;\n\n\tcase STL_BUFNO:\n\t    num = wp->w_buffer->b_fnum;\n\t    break;\n\n\tcase STL_OFFSET_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_OFFSET:\n#ifdef FEAT_BYTEOFF\n\t    l = ml_find_line_or_offset(wp->w_buffer, wp->w_cursor.lnum, NULL);\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) || l < 0 ?\n\t\t  0L : l + 1 + (!(State & INSERT) && empty_line ?\n\t\t\t\t0 : (int)wp->w_cursor.col);\n#endif\n\t    break;\n\n\tcase STL_BYTEVAL_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_BYTEVAL:\n\t    num = byteval;\n\t    if (num == NL)\n\t\tnum = 0;\n\t    else if (num == CAR && get_fileformat(wp->w_buffer) == EOL_MAC)\n\t\tnum = NL;\n\t    break;\n\n\tcase STL_ROFLAG:\n\tcase STL_ROFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_p_ro)\n\t\tstr = (char_u *)((opt == STL_ROFLAG_ALT) ? \",RO\" : _(\"[RO]\"));\n\t    break;\n\n\tcase STL_HELPFLAG:\n\tcase STL_HELPFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_help)\n\t\tstr = (char_u *)((opt == STL_HELPFLAG_ALT) ? \",HLP\"\n\t\t\t\t\t\t\t       : _(\"[Help]\"));\n\t    break;\n\n\tcase STL_FILETYPE:\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 3)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \"[%s]\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n\tcase STL_FILETYPE_ALT:\n\t    itemisflag = TRUE;\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 2)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \",%s\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tfor (t = buf_tmp; *t != 0; t++)\n\t\t    *t = TOUPPER_LOC(*t);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n#if defined(FEAT_QUICKFIX)\n\tcase STL_PREVIEWFLAG:\n\tcase STL_PREVIEWFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_p_pvw)\n\t\tstr = (char_u *)((opt == STL_PREVIEWFLAG_ALT) ? \",PRV\"\n\t\t\t\t\t\t\t    : _(\"[Preview]\"));\n\t    break;\n\n\tcase STL_QUICKFIX:\n\t    if (bt_quickfix(wp->w_buffer))\n\t\tstr = (char_u *)(wp->w_llist_ref\n\t\t\t    ? _(msg_loclist)\n\t\t\t    : _(msg_qflist));\n\t    break;\n#endif\n\n\tcase STL_MODIFIED:\n\tcase STL_MODIFIED_ALT:\n\t    itemisflag = TRUE;\n\t    switch ((opt == STL_MODIFIED_ALT)\n\t\t    + bufIsChanged(wp->w_buffer) * 2\n\t\t    + (!wp->w_buffer->b_p_ma) * 4)\n\t    {\n\t\tcase 2: str = (char_u *)\"[+]\"; break;\n\t\tcase 3: str = (char_u *)\",+\"; break;\n\t\tcase 4: str = (char_u *)\"[-]\"; break;\n\t\tcase 5: str = (char_u *)\",-\"; break;\n\t\tcase 6: str = (char_u *)\"[+-]\"; break;\n\t\tcase 7: str = (char_u *)\",+-\"; break;\n\t    }\n\t    break;\n\n\tcase STL_HIGHLIGHT:\n\t    t = s;\n\t    while (*s != '#' && *s != NUL)\n\t\t++s;\n\t    if (*s == '#')\n\t    {\n\t\tstl_items[curitem].stl_type = Highlight;\n\t\tstl_items[curitem].stl_start = p;\n\t\tstl_items[curitem].stl_minwid = -syn_namen2id(t, (int)(s - t));\n\t\tcuritem++;\n\t    }\n\t    if (*s != NUL)\n\t\t++s;\n\t    continue;\n\t}\n\n\tstl_items[curitem].stl_start = p;\n\tstl_items[curitem].stl_type = Normal;\n\tif (str != NULL && *str)\n\t{\n\t    t = str;\n\t    if (itemisflag)\n\t    {\n\t\tif ((t[0] && t[1])\n\t\t\t&& ((!prevchar_isitem && *t == ',')\n\t\t\t      || (prevchar_isflag && *t == ' ')))\n\t\t    t++;\n\t\tprevchar_isflag = TRUE;\n\t    }\n\t    l = vim_strsize(t);\n\t    if (l > 0)\n\t\tprevchar_isitem = TRUE;\n\t    if (l > maxwid)\n\t    {\n\t\twhile (l >= maxwid)\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tl -= ptr2cells(t);\n\t\t\tt += (*mb_ptr2len)(t);\n\t\t    }\n\t\t    else\n\t\t\tl -= byte2cells(*t++);\n\t\tif (p + 1 >= out + outlen)\n\t\t    break;\n\t\t*p++ = '<';\n\t    }\n\t    if (minwid > 0)\n\t    {\n\t\tfor (; l < minwid && p + 1 < out + outlen; l++)\n\t\t{\n\t\t    // Don't put a \"-\" in front of a digit.\n\t\t    if (l + 1 == minwid && fillchar == '-' && VIM_ISDIGIT(*t))\n\t\t\t*p++ = ' ';\n\t\t    else\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\tminwid = 0;\n\t    }\n\t    else\n\t\tminwid *= -1;\n\t    for (; *t && p + 1 < out + outlen; t++)\n\t    {\n\t\t// Change a space by fillchar, unless fillchar is '-' and a\n\t\t// digit follows.\n\t\tif (fillable && *t == ' '\n\t\t\t\t&& (!VIM_ISDIGIT(*(t + 1)) || fillchar != '-'))\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\t\telse\n\t\t    *p++ = *t;\n\t    }\n\t    for (; l < minwid && p + 1 < out + outlen; l++)\n\t\tMB_CHAR2BYTES(fillchar, p);\n\t}\n\telse if (num >= 0)\n\t{\n\t    int nbase = (base == 'D' ? 10 : (base == 'O' ? 8 : 16));\n\t    char_u nstr[20];\n\n\t    if (p + 20 >= out + outlen)\n\t\tbreak;\t\t// not sufficient space\n\t    prevchar_isitem = TRUE;\n\t    t = nstr;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t    {\n\t\t*t++ = '-';\n\t\tminwid--;\n\t    }\n\t    *t++ = '%';\n\t    if (zeropad)\n\t\t*t++ = '0';\n\t    *t++ = '*';\n\t    *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');\n\t    *t = 0;\n\n\t    for (n = num, l = 1; n >= nbase; n /= nbase)\n\t\tl++;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t\tl++;\n\t    if (l > maxwid)\n\t    {\n\t\tl += 2;\n\t\tn = l - maxwid;\n\t\twhile (l-- > maxwid)\n\t\t    num /= nbase;\n\t\t*t++ = '>';\n\t\t*t++ = '%';\n\t\t*t = t[-3];\n\t\t*++t = 0;\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t   0, num, n);\n\t    }\n\t    else\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t minwid, num);\n\t    p += STRLEN(p);\n\t}\n\telse\n\t    stl_items[curitem].stl_type = Empty;\n\n\tif (opt == STL_VIM_EXPR)\n\t    vim_free(str);\n\n\tif (num >= 0 || (!itemisflag && str && *str))\n\t    prevchar_isflag = FALSE;\t    // Item not NULL, but not a flag\n\tcuritem++;\n    }\n    *p = NUL;\n    itemcnt = curitem;\n\n#ifdef FEAT_EVAL\n    if (usefmt != fmt)\n\tvim_free(usefmt);\n#endif\n\n    width = vim_strsize(out);\n    if (maxwidth > 0 && width > maxwidth)\n    {\n\t// Result is too long, must truncate somewhere.\n\tl = 0;\n\tif (itemcnt == 0)\n\t    s = out;\n\telse\n\t{\n\t    for ( ; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_type == Trunc)\n\t\t{\n\t\t    // Truncate at %< item.\n\t\t    s = stl_items[l].stl_start;\n\t\t    break;\n\t\t}\n\t    if (l == itemcnt)\n\t    {\n\t\t// No %< item, truncate first item.\n\t\ts = stl_items[0].stl_start;\n\t\tl = 0;\n\t    }\n\t}\n\n\tif (width - vim_strsize(s) >= maxwidth)\n\t{\n\t    // Truncation mark is beyond max length\n\t    if (has_mbyte)\n\t    {\n\t\ts = out;\n\t\twidth = 0;\n\t\tfor (;;)\n\t\t{\n\t\t    width += ptr2cells(s);\n\t\t    if (width >= maxwidth)\n\t\t\tbreak;\n\t\t    s += (*mb_ptr2len)(s);\n\t\t}\n\t\t// Fill up for half a double-wide character.\n\t\twhile (++width < maxwidth)\n\t\t    MB_CHAR2BYTES(fillchar, s);\n\t    }\n\t    else\n\t\ts = out + maxwidth - 1;\n\t    for (l = 0; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_start > s)\n\t\t    break;\n\t    itemcnt = l;\n\t    *s++ = '>';\n\t    *s = 0;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tn = 0;\n\t\twhile (width >= maxwidth)\n\t\t{\n\t\t    width -= ptr2cells(s + n);\n\t\t    n += (*mb_ptr2len)(s + n);\n\t\t}\n\t    }\n\t    else\n\t\tn = width - maxwidth + 1;\n\t    p = s + n;\n\t    STRMOVE(s + 1, p);\n\t    *s = '<';\n\n\t    // Fill up for half a double-wide character.\n\t    while (++width < maxwidth)\n\t    {\n\t\ts = s + STRLEN(s);\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t\t*s = NUL;\n\t    }\n\n\t    --n;\t// count the '<'\n\t    for (; l < itemcnt; l++)\n\t    {\n\t\tif (stl_items[l].stl_start - n >= s)\n\t\t    stl_items[l].stl_start -= n;\n\t\telse\n\t\t    stl_items[l].stl_start = s;\n\t    }\n\t}\n\twidth = maxwidth;\n    }\n    else if (width < maxwidth && STRLEN(out) + maxwidth - width + 1 < outlen)\n    {\n\t// Apply STL_MIDDLE if any\n\tfor (l = 0; l < itemcnt; l++)\n\t    if (stl_items[l].stl_type == Middle)\n\t\tbreak;\n\tif (l < itemcnt)\n\t{\n\t    int middlelength = (maxwidth - width) * MB_CHAR2LEN(fillchar);\n\t    p = stl_items[l].stl_start + middlelength;\n\t    STRMOVE(p, stl_items[l].stl_start);\n\t    for (s = stl_items[l].stl_start; s < p;)\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t    for (l++; l < itemcnt; l++)\n\t\tstl_items[l].stl_start += middlelength;\n\t    width = maxwidth;\n\t}\n    }\n\n    // Store the info about highlighting.\n    if (hltab != NULL)\n    {\n\t*hltab = stl_hltab;\n\tsp = stl_hltab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == Highlight)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    // Store the info about tab pages labels.\n    if (tabtab != NULL)\n    {\n\t*tabtab = stl_tabtab;\n\tsp = stl_tabtab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == TabPage)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    // When inside update_screen we do not want redrawing a statusline, ruler,\n    // title, etc. to trigger another redraw, it may cause an endless loop.\n    if (updating_screen)\n    {\n\tmust_redraw = save_must_redraw;\n\tcurwin->w_redr_type = save_redr_type;\n    }\n\n    return width;\n}\n#endif // FEAT_STL_OPT\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_CMDL_INFO) \\\n\t    || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Get relative cursor position in window into \"buf[buflen]\", in the form 99%,\n * using \"Top\", \"Bot\" or \"All\" when appropriate.\n */\n    void\nget_rel_pos(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    long\tabove; // number of lines above window\n    long\tbelow; // number of lines below window\n\n    if (buflen < 3) // need at least 3 chars for writing\n\treturn;\n    above = wp->w_topline - 1;\n#ifdef FEAT_DIFF\n    above += diff_check_fill(wp, wp->w_topline) - wp->w_topfill;\n    if (wp->w_topline == 1 && wp->w_topfill >= 1)\n\tabove = 0;  // All buffer lines are displayed and there is an\n\t\t    // indication of filler lines, that can be considered\n\t\t    // seeing all lines.\n#endif\n    below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;\n    if (below <= 0)\n\tvim_strncpy(buf, (char_u *)(above == 0 ? _(\"All\") : _(\"Bot\")),\n\t\t\t\t\t\t\t(size_t)(buflen - 1));\n    else if (above <= 0)\n\tvim_strncpy(buf, (char_u *)_(\"Top\"), (size_t)(buflen - 1));\n    else\n\tvim_snprintf((char *)buf, (size_t)buflen, \"%2d%%\", above > 1000000L\n\t\t\t\t    ? (int)(above / ((above + below) / 100L))\n\t\t\t\t    : (int)(above * 100L / (above + below)));\n}\n#endif\n\n/*\n * Append (file 2 of 8) to \"buf[buflen]\", if editing more than one file.\n * Return TRUE if it was appended.\n */\n    static int\nappend_arg_number(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen,\n    int\t\tadd_file)\t// Add \"file\" before the arg number\n{\n    char_u\t*p;\n\n    if (ARGCOUNT <= 1)\t\t// nothing to do\n\treturn FALSE;\n\n    p = buf + STRLEN(buf);\t// go to the end of the buffer\n    if (p - buf + 35 >= buflen)\t// getting too long\n\treturn FALSE;\n    *p++ = ' ';\n    *p++ = '(';\n    if (add_file)\n    {\n\tSTRCPY(p, \"file \");\n\tp += 5;\n    }\n    vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),\n\t\twp->w_arg_idx_invalid ? \"(%d) of %d)\"\n\t\t\t\t  : \"%d of %d)\", wp->w_arg_idx + 1, ARGCOUNT);\n    return TRUE;\n}\n\n/*\n * If fname is not a full path, make it a full path.\n * Returns pointer to allocated memory (NULL for failure).\n */\n    char_u  *\nfix_fname(char_u  *fname)\n{\n    /*\n     * Force expanding the path always for Unix, because symbolic links may\n     * mess up the full path name, even though it starts with a '/'.\n     * Also expand when there is \"..\" in the file name, try to remove it,\n     * because \"c:/src/../README\" is equal to \"c:/README\".\n     * Similarly \"c:/src//file\" is equal to \"c:/src/file\".\n     * For MS-Windows also expand names like \"longna~1\" to \"longname\".\n     */\n#ifdef UNIX\n    return FullName_save(fname, TRUE);\n#else\n    if (!vim_isAbsName(fname)\n\t    || strstr((char *)fname, \"..\") != NULL\n\t    || strstr((char *)fname, \"//\") != NULL\n# ifdef BACKSLASH_IN_FILENAME\n\t    || strstr((char *)fname, \"\\\\\\\\\") != NULL\n# endif\n# if defined(MSWIN)\n\t    || vim_strchr(fname, '~') != NULL\n# endif\n\t    )\n\treturn FullName_save(fname, FALSE);\n\n    fname = vim_strsave(fname);\n\n# ifdef USE_FNAME_CASE\n    if (fname != NULL)\n\tfname_case(fname, 0);\t// set correct case for file name\n# endif\n\n    return fname;\n#endif\n}\n\n/*\n * Make \"*ffname\" a full file name, set \"*sfname\" to \"*ffname\" if not NULL.\n * \"*ffname\" becomes a pointer to allocated memory (or NULL).\n * When resolving a link both \"*sfname\" and \"*ffname\" will point to the same\n * allocated memory.\n * The \"*ffname\" and \"*sfname\" pointer values on call will not be freed.\n * Note that the resulting \"*ffname\" pointer should be considered not allocated.\n */\n    void\nfname_expand(\n    buf_T\t*buf UNUSED,\n    char_u\t**ffname,\n    char_u\t**sfname)\n{\n    if (*ffname == NULL)\t    // no file name given, nothing to do\n\treturn;\n    if (*sfname == NULL)\t    // no short file name given, use ffname\n\t*sfname = *ffname;\n    *ffname = fix_fname(*ffname);   // expand to full path\n\n#ifdef FEAT_SHORTCUT\n    if (!buf->b_p_bin)\n    {\n\tchar_u  *rfname;\n\n\t// If the file name is a shortcut file, use the file it links to.\n\trfname = mch_resolve_path(*ffname, FALSE);\n\tif (rfname != NULL)\n\t{\n\t    vim_free(*ffname);\n\t    *ffname = rfname;\n\t    *sfname = rfname;\n\t}\n    }\n#endif\n}\n\n/*\n * Open a window for a number of buffers.\n */\n    void\nex_buffer_all(exarg_T *eap)\n{\n    buf_T\t*buf;\n    win_T\t*wp, *wpnext;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    int\t\topen_wins = 0;\n    int\t\tr;\n    int\t\tcount;\t\t// Maximum number of windows to open.\n    int\t\tall;\t\t// When TRUE also load inactive buffers.\n    int\t\thad_tab = cmdmod.cmod_tab;\n    tabpage_T\t*tpnext;\n\n    if (eap->addr_count == 0)\t// make as many windows as possible\n\tcount = 9999;\n    else\n\tcount = eap->line2;\t// make as many windows as specified\n    if (eap->cmdidx == CMD_unhide || eap->cmdidx == CMD_sunhide)\n\tall = FALSE;\n    else\n\tall = TRUE;\n\n    setpcmark();\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * Close superfluous windows (two windows for the same buffer).\n     * Also close windows that are not full-width.\n     */\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    if ((wp->w_buffer->b_nwindows > 1\n\t\t    || ((cmdmod.cmod_split & WSP_VERT)\n\t\t\t? wp->w_height + wp->w_status_height < Rows - p_ch\n\t\t\t\t\t\t\t    - tabline_height()\n\t\t\t: wp->w_width != Columns)\n\t\t    || (had_tab > 0 && wp != firstwin)) && !ONE_WINDOW\n\t\t\t     && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t    {\n\t\twin_close(wp, FALSE);\n\t\twpnext = firstwin;\t// just in case an autocommand does\n\t\t\t\t\t// something strange with windows\n\t\ttpnext = first_tabpage;\t// start all over...\n\t\topen_wins = 0;\n\t    }\n\t    else\n\t\t++open_wins;\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    /*\n     * Go through the buffer list.  When a buffer doesn't have a window yet,\n     * open one.  Otherwise move the window to the right position.\n     * Watch out for autocommands that delete buffers or windows!\n     */\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    win_enter(lastwin, FALSE);\n    ++autocmd_no_leave;\n    for (buf = firstbuf; buf != NULL && open_wins < count; buf = buf->b_next)\n    {\n\t// Check if this buffer needs a window\n\tif ((!all && buf->b_ml.ml_mfp == NULL) || !buf->b_p_bl)\n\t    continue;\n\n\tif (had_tab != 0)\n\t{\n\t    // With the \":tab\" modifier don't move the window.\n\t    if (buf->b_nwindows > 0)\n\t\twp = lastwin;\t    // buffer has a window, skip it\n\t    else\n\t\twp = NULL;\n\t}\n\telse\n\t{\n\t    // Check if this buffer already has a window\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    // If the buffer already has a window, move it\n\t    if (wp != NULL)\n\t\twin_move_after(wp, curwin);\n\t}\n\n\tif (wp == NULL && split_ret == OK)\n\t{\n\t    bufref_T\tbufref;\n\n\t    set_bufref(&bufref, buf);\n\n\t    // Split the window and put the buffer in it\n\t    p_ea_save = p_ea;\n\t    p_ea = TRUE;\t\t// use space from all windows\n\t    split_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t    ++open_wins;\n\t    p_ea = p_ea_save;\n\t    if (split_ret == FAIL)\n\t\tcontinue;\n\n\t    // Open the buffer in this window.\n\t    swap_exists_action = SEA_DIALOG;\n\t    set_curbuf(buf, DOBUF_GOTO);\n\t    if (!bufref_valid(&bufref))\n\t    {\n\t\t// autocommands deleted the buffer!!!\n\t\tswap_exists_action = SEA_NONE;\n\t\tbreak;\n\t    }\n\t    if (swap_exists_action == SEA_QUIT)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tcleanup_T   cs;\n\n\t\t// Reset the error/interrupt/exception state here so that\n\t\t// aborting() returns FALSE when closing a window.\n\t\tenter_cleanup(&cs);\n#endif\n\n\t\t// User selected Quit at ATTENTION prompt; close this window.\n\t\twin_close(curwin, TRUE);\n\t\t--open_wins;\n\t\tswap_exists_action = SEA_NONE;\n\t\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t\t// Restore the error/interrupt/exception state if not\n\t\t// discarded by a new aborting error, interrupt, or uncaught\n\t\t// exception.\n\t\tleave_cleanup(&cs);\n#endif\n\t    }\n\t    else\n\t\thandle_swap_exists(NULL);\n\t}\n\n\tui_breakcheck();\n\tif (got_int)\n\t{\n\t    (void)vgetc();\t// only break the file loading, not the rest\n\t    break;\n\t}\n#ifdef FEAT_EVAL\n\t// Autocommands deleted the buffer or aborted script processing!!!\n\tif (aborting())\n\t    break;\n#endif\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n    --autocmd_no_enter;\n    win_enter(firstwin, FALSE);\t\t// back to first window\n    --autocmd_no_leave;\n\n    /*\n     * Close superfluous windows.\n     */\n    for (wp = lastwin; open_wins > count; )\n    {\n\tr = (buf_hide(wp->w_buffer) || !bufIsChanged(wp->w_buffer)\n\t\t\t\t     || autowrite(wp->w_buffer, FALSE) == OK);\n\tif (!win_valid(wp))\n\t{\n\t    // BufWrite Autocommands made the window invalid, start over\n\t    wp = lastwin;\n\t}\n\telse if (r)\n\t{\n\t    win_close(wp, !buf_hide(wp->w_buffer));\n\t    --open_wins;\n\t    wp = lastwin;\n\t}\n\telse\n\t{\n\t    wp = wp->w_prev;\n\t    if (wp == NULL)\n\t\tbreak;\n\t}\n    }\n}\n\n\nstatic int  chk_modeline(linenr_T, int);\n\n/*\n * do_modelines() - process mode lines for the current file\n *\n * \"flags\" can be:\n * OPT_WINONLY\t    only set options local to window\n * OPT_NOWIN\t    don't set options local to window\n *\n * Returns immediately if the \"ml\" option isn't set.\n */\n    void\ndo_modelines(int flags)\n{\n    linenr_T\tlnum;\n    int\t\tnmlines;\n    static int\tentered = 0;\n\n    if (!curbuf->b_p_ml || (nmlines = (int)p_mls) == 0)\n\treturn;\n\n    // Disallow recursive entry here.  Can happen when executing a modeline\n    // triggers an autocommand, which reloads modelines with a \":do\".\n    if (entered)\n\treturn;\n\n    ++entered;\n    for (lnum = 1; curbuf->b_p_ml && lnum <= curbuf->b_ml.ml_line_count && lnum <= nmlines;\n\t\t\t\t\t\t\t\t       ++lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n\n    for (lnum = curbuf->b_ml.ml_line_count; curbuf->b_p_ml && lnum > 0 && lnum > nmlines\n\t\t       && lnum > curbuf->b_ml.ml_line_count - nmlines; --lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n    --entered;\n}\n\n#include \"version.h\"\t\t// for version number\n\n/*\n * chk_modeline() - check a single line for a mode string\n * Return FAIL if an error encountered.\n */\n    static int\nchk_modeline(\n    linenr_T\tlnum,\n    int\t\tflags)\t\t// Same as for do_modelines().\n{\n    char_u\t*s;\n    char_u\t*e;\n    char_u\t*linecopy;\t\t// local copy of any modeline found\n    int\t\tprev;\n    int\t\tvers;\n    int\t\tend;\n    int\t\tretval = OK;\n    sctx_T\tsave_current_sctx;\n\n    ESTACK_CHECK_DECLARATION\n\n    prev = -1;\n    for (s = ml_get(lnum); *s != NUL; ++s)\n    {\n\tif (prev == -1 || vim_isspace(prev))\n\t{\n\t    if ((prev != -1 && STRNCMP(s, \"ex:\", (size_t)3) == 0)\n\t\t    || STRNCMP(s, \"vi:\", (size_t)3) == 0)\n\t\tbreak;\n\t    // Accept both \"vim\" and \"Vim\".\n\t    if ((s[0] == 'v' || s[0] == 'V') && s[1] == 'i' && s[2] == 'm')\n\t    {\n\t\tif (s[3] == '<' || s[3] == '=' || s[3] == '>')\n\t\t    e = s + 4;\n\t\telse\n\t\t    e = s + 3;\n\t\tvers = getdigits(&e);\n\t\tif (*e == ':'\n\t\t\t&& (s[0] != 'V'\n\t\t\t\t  || STRNCMP(skipwhite(e + 1), \"set\", 3) == 0)\n\t\t\t&& (s[3] == ':'\n\t\t\t    || (VIM_VERSION_100 >= vers && isdigit(s[3]))\n\t\t\t    || (VIM_VERSION_100 < vers && s[3] == '<')\n\t\t\t    || (VIM_VERSION_100 > vers && s[3] == '>')\n\t\t\t    || (VIM_VERSION_100 == vers && s[3] == '=')))\n\t\t    break;\n\t    }\n\t}\n\tprev = *s;\n    }\n\n    if (*s)\n    {\n\tdo\t\t\t\t// skip over \"ex:\", \"vi:\" or \"vim:\"\n\t    ++s;\n\twhile (s[-1] != ':');\n\n\ts = linecopy = vim_strsave(s);\t// copy the line, it will change\n\tif (linecopy == NULL)\n\t    return FAIL;\n\n\t// prepare for emsg()\n\testack_push(ETYPE_MODELINE, (char_u *)\"modelines\", lnum);\n\tESTACK_CHECK_SETUP\n\n\tend = FALSE;\n\twhile (end == FALSE)\n\t{\n\t    s = skipwhite(s);\n\t    if (*s == NUL)\n\t\tbreak;\n\n\t    /*\n\t     * Find end of set command: ':' or end of line.\n\t     * Skip over \"\\:\", replacing it with \":\".\n\t     */\n\t    for (e = s; *e != ':' && *e != NUL; ++e)\n\t\tif (e[0] == '\\\\' && e[1] == ':')\n\t\t    STRMOVE(e, e + 1);\n\t    if (*e == NUL)\n\t\tend = TRUE;\n\n\t    /*\n\t     * If there is a \"set\" command, require a terminating ':' and\n\t     * ignore the stuff after the ':'.\n\t     * \"vi:set opt opt opt: foo\" -- foo not interpreted\n\t     * \"vi:opt opt opt: foo\" -- foo interpreted\n\t     * Accept \"se\" for compatibility with Elvis.\n\t     */\n\t    if (STRNCMP(s, \"set \", (size_t)4) == 0\n\t\t    || STRNCMP(s, \"se \", (size_t)3) == 0)\n\t    {\n\t\tif (*e != ':')\t\t// no terminating ':'?\n\t\t    break;\n\t\tend = TRUE;\n\t\ts = vim_strchr(s, ' ') + 1;\n\t    }\n\t    *e = NUL;\t\t\t// truncate the set command\n\n\t    if (*s != NUL)\t\t// skip over an empty \"::\"\n\t    {\n\t\tint secure_save = secure;\n\n\t\tsave_current_sctx = current_sctx;\n\t\tcurrent_sctx.sc_version = 1;\n#ifdef FEAT_EVAL\n\t\tcurrent_sctx.sc_sid = SID_MODELINE;\n\t\tcurrent_sctx.sc_seq = 0;\n\t\tcurrent_sctx.sc_lnum = lnum;\n#endif\n\n\t\t// Make sure no risky things are executed as a side effect.\n\t\tsecure = 1;\n\n\t\tretval = do_set(s, OPT_MODELINE | OPT_LOCAL | flags);\n\n\t\tsecure = secure_save;\n\t\tcurrent_sctx = save_current_sctx;\n\t\tif (retval == FAIL)\t\t// stop if error found\n\t\t    break;\n\t    }\n\t    s = e + 1;\t\t\t// advance to next part\n\t}\n\n\tESTACK_CHECK_NOW\n\testack_pop();\n\tvim_free(linecopy);\n    }\n    return retval;\n}\n\n/*\n * Return TRUE if \"buf\" is a normal buffer, 'buftype' is empty.\n */\n    int\nbt_normal(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == NUL;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is the quickfix buffer.\n */\n    int\nbt_quickfix(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'q';\n}\n#endif\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is a terminal buffer.\n */\n    int\nbt_terminal(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 't';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a help buffer.\n */\n    int\nbt_help(buf_T *buf)\n{\n    return buf != NULL && buf->b_help;\n}\n\n/*\n * Return TRUE if \"buf\" is a prompt buffer.\n */\n    int\nbt_prompt(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'r';\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is a buffer for a popup window.\n */\n    int\nbt_popup(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt != NULL\n\t&& buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'o';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nofile\", \"acwrite\", \"terminal\" or \"prompt\"\n * buffer.  This means the buffer name is not a file name.\n */\n    int\nbt_nofilename(buf_T *buf)\n{\n    return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')\n\t    || buf->b_p_bt[0] == 'a'\n\t    || buf->b_p_bt[0] == 't'\n\t    || buf->b_p_bt[0] == 'p');\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" has 'buftype' set to \"nofile\".\n */\n    int\nbt_nofile(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nowrite\", \"nofile\", \"terminal\" or \"prompt\"\n * buffer.\n */\n    int\nbt_dontwrite(buf_T *buf)\n{\n    return buf != NULL && (buf->b_p_bt[0] == 'n'\n\t\t || buf->b_p_bt[0] == 't'\n\t\t || buf->b_p_bt[0] == 'p');\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    int\nbt_dontwrite_msg(buf_T *buf)\n{\n    if (bt_dontwrite(buf))\n    {\n\temsg(_(e_cannot_write_buftype_option_is_set));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Return TRUE if the buffer should be hidden, according to 'hidden', \":hide\"\n * and 'bufhidden'.\n */\n    int\nbuf_hide(buf_T *buf)\n{\n    // 'bufhidden' overrules 'hidden' and \":hide\", check it first\n    switch (buf->b_p_bh[0])\n    {\n\tcase 'u':\t\t    // \"unload\"\n\tcase 'w':\t\t    // \"wipe\"\n\tcase 'd': return FALSE;\t    // \"delete\"\n\tcase 'h': return TRUE;\t    // \"hide\"\n    }\n    return (p_hid || (cmdmod.cmod_flags & CMOD_HIDE));\n}\n\n/*\n * Return special buffer name.\n * Returns NULL when the buffer has a normal file name.\n */\n    char_u *\nbuf_spname(buf_T *buf)\n{\n#if defined(FEAT_QUICKFIX)\n    if (bt_quickfix(buf))\n    {\n\t/*\n\t * Differentiate between the quickfix and location list buffers using\n\t * the buffer number stored in the global quickfix stack.\n\t */\n\tif (buf->b_fnum == qf_stack_get_bufnr())\n\t    return (char_u *)_(msg_qflist);\n\telse\n\t    return (char_u *)_(msg_loclist);\n    }\n#endif\n\n    // There is no _file_ when 'buftype' is \"nofile\", b_sfname\n    // contains the name as specified by the user.\n    if (bt_nofilename(buf))\n    {\n#ifdef FEAT_TERMINAL\n\tif (buf->b_term != NULL)\n\t    return term_get_status_text(buf->b_term);\n#endif\n\tif (buf->b_fname != NULL)\n\t    return buf->b_fname;\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(buf))\n\t    return (char_u *)_(\"[Prompt]\");\n#endif\n#ifdef FEAT_PROP_POPUP\n\tif (bt_popup(buf))\n\t    return (char_u *)_(\"[Popup]\");\n#endif\n\treturn (char_u *)_(\"[Scratch]\");\n    }\n\n    if (buf->b_fname == NULL)\n\treturn buf_get_fname(buf);\n    return NULL;\n}\n\n/*\n * Get \"buf->b_fname\", use \"[No Name]\" if it is NULL.\n */\n    char_u *\nbuf_get_fname(buf_T *buf)\n{\n    if (buf->b_fname == NULL)\n\treturn (char_u *)_(\"[No Name]\");\n    return buf->b_fname;\n}\n\n/*\n * Set 'buflisted' for curbuf to \"on\" and trigger autocommands if it changed.\n */\n    void\nset_buflisted(int on)\n{\n    if (on != curbuf->b_p_bl)\n    {\n\tcurbuf->b_p_bl = on;\n\tif (on)\n\t    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);\n\telse\n\t    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);\n    }\n}\n\n/*\n * Read the file for \"buf\" again and check if the contents changed.\n * Return TRUE if it changed or this could not be checked.\n */\n    int\nbuf_contents_changed(buf_T *buf)\n{\n    buf_T\t*newbuf;\n    int\t\tdiffer = TRUE;\n    linenr_T\tlnum;\n    aco_save_T\taco;\n    exarg_T\tea;\n\n    // Allocate a buffer without putting it in the buffer list.\n    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    if (newbuf == NULL)\n\treturn TRUE;\n\n    // Force the 'fileencoding' and 'fileformat' to be equal.\n    if (prep_exarg(&ea, buf) == FAIL)\n    {\n\twipe_buffer(newbuf, FALSE);\n\treturn TRUE;\n    }\n\n    // set curwin/curbuf to buf and save a few things\n    aucmd_prepbuf(&aco, newbuf);\n\n    if (ml_open(curbuf) == OK\n\t    && readfile(buf->b_ffname, buf->b_fname,\n\t\t\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t    &ea, READ_NEW | READ_DUMMY) == OK)\n    {\n\t// compare the two files line by line\n\tif (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count)\n\t{\n\t    differ = FALSE;\n\t    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t\tif (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0)\n\t\t{\n\t\t    differ = TRUE;\n\t\t    break;\n\t\t}\n\t}\n    }\n    vim_free(ea.cmd);\n\n    // restore curwin/curbuf and a few other things\n    aucmd_restbuf(&aco);\n\n    if (curbuf != newbuf)\t// safety check\n\twipe_buffer(newbuf, FALSE);\n\n    return differ;\n}\n\n/*\n * Wipe out a buffer and decrement the last buffer number if it was used for\n * this buffer.  Call this to wipe out a temp buffer that does not contain any\n * marks.\n */\n    void\nwipe_buffer(\n    buf_T\t*buf,\n    int\t\taucmd)\t    // When TRUE trigger autocommands.\n{\n    if (buf->b_fnum == top_file_num - 1)\n\t--top_file_num;\n\n    if (!aucmd)\t\t    // Don't trigger BufDelete autocommands here.\n\tblock_autocmds();\n\n    close_buffer(NULL, buf, DOBUF_WIPE, FALSE, TRUE);\n\n    if (!aucmd)\n\tunblock_autocmds();\n}\n", "\" Test for the quickfix feature.\n\nsource check.vim\nimport './vim9.vim' as v9\nCheckFeature quickfix\n\nsource screendump.vim\n\nset encoding=utf-8\n\nfunc s:setup_commands(cchar)\n  if a:cchar == 'c'\n    command! -nargs=* -bang Xlist <mods>clist<bang> <args>\n    command! -nargs=* Xgetexpr <mods>cgetexpr <args>\n    command! -nargs=* Xaddexpr <mods>caddexpr <args>\n    command! -nargs=* -count Xolder <mods><count>colder <args>\n    command! -nargs=* Xnewer <mods>cnewer <args>\n    command! -nargs=* Xopen <mods> copen <args>\n    command! -nargs=* Xwindow <mods>cwindow <args>\n    command! -nargs=* Xbottom <mods>cbottom <args>\n    command! -nargs=* Xclose <mods>cclose <args>\n    command! -nargs=* -bang Xfile <mods>cfile<bang> <args>\n    command! -nargs=* Xgetfile <mods>cgetfile <args>\n    command! -nargs=* Xaddfile <mods>caddfile <args>\n    command! -nargs=* -bang Xbuffer <mods>cbuffer<bang> <args>\n    command! -nargs=* Xgetbuffer <mods>cgetbuffer <args>\n    command! -nargs=* Xaddbuffer <mods>caddbuffer <args>\n    command! -nargs=* Xrewind <mods>crewind <args>\n    command! -count -nargs=* -bang Xnext <mods><count>cnext<bang> <args>\n    command! -count -nargs=* -bang Xprev <mods><count>cprev<bang> <args>\n    command! -nargs=* -bang Xfirst <mods>cfirst<bang> <args>\n    command! -nargs=* -bang Xlast <mods>clast<bang> <args>\n    command! -count -nargs=* -bang Xnfile <mods><count>cnfile<bang> <args>\n    command! -nargs=* -bang Xpfile <mods>cpfile<bang> <args>\n    command! -nargs=* Xexpr <mods>cexpr <args>\n    command! -count=999 -nargs=* Xvimgrep <mods> <count>vimgrep <args>\n    command! -nargs=* Xvimgrepadd <mods> vimgrepadd <args>\n    command! -nargs=* Xgrep <mods> grep <args>\n    command! -nargs=* Xgrepadd <mods> grepadd <args>\n    command! -nargs=* Xhelpgrep helpgrep <args>\n    command! -nargs=0 -count Xcc <count>cc\n    command! -count=1 -nargs=0 Xbelow <mods><count>cbelow\n    command! -count=1 -nargs=0 Xabove <mods><count>cabove\n    command! -count=1 -nargs=0 Xbefore <mods><count>cbefore\n    command! -count=1 -nargs=0 Xafter <mods><count>cafter\n    let g:Xgetlist = function('getqflist')\n    let g:Xsetlist = function('setqflist')\n    call setqflist([], 'f')\n  else\n    command! -nargs=* -bang Xlist <mods>llist<bang> <args>\n    command! -nargs=* Xgetexpr <mods>lgetexpr <args>\n    command! -nargs=* Xaddexpr <mods>laddexpr <args>\n    command! -nargs=* -count Xolder <mods><count>lolder <args>\n    command! -nargs=* Xnewer <mods>lnewer <args>\n    command! -nargs=* Xopen <mods> lopen <args>\n    command! -nargs=* Xwindow <mods>lwindow <args>\n    command! -nargs=* Xbottom <mods>lbottom <args>\n    command! -nargs=* Xclose <mods>lclose <args>\n    command! -nargs=* -bang Xfile <mods>lfile<bang> <args>\n    command! -nargs=* Xgetfile <mods>lgetfile <args>\n    command! -nargs=* Xaddfile <mods>laddfile <args>\n    command! -nargs=* -bang Xbuffer <mods>lbuffer<bang> <args>\n    command! -nargs=* Xgetbuffer <mods>lgetbuffer <args>\n    command! -nargs=* Xaddbuffer <mods>laddbuffer <args>\n    command! -nargs=* Xrewind <mods>lrewind <args>\n    command! -count -nargs=* -bang Xnext <mods><count>lnext<bang> <args>\n    command! -count -nargs=* -bang Xprev <mods><count>lprev<bang> <args>\n    command! -nargs=* -bang Xfirst <mods>lfirst<bang> <args>\n    command! -nargs=* -bang Xlast <mods>llast<bang> <args>\n    command! -count -nargs=* -bang Xnfile <mods><count>lnfile<bang> <args>\n    command! -nargs=* -bang Xpfile <mods>lpfile<bang> <args>\n    command! -nargs=* Xexpr <mods>lexpr <args>\n    command! -count=999 -nargs=* Xvimgrep <mods> <count>lvimgrep <args>\n    command! -nargs=* Xvimgrepadd <mods> lvimgrepadd <args>\n    command! -nargs=* Xgrep <mods> lgrep <args>\n    command! -nargs=* Xgrepadd <mods> lgrepadd <args>\n    command! -nargs=* Xhelpgrep lhelpgrep <args>\n    command! -nargs=0 -count Xcc <count>ll\n    command! -count=1 -nargs=0 Xbelow <mods><count>lbelow\n    command! -count=1 -nargs=0 Xabove <mods><count>labove\n    command! -count=1 -nargs=0 Xbefore <mods><count>lbefore\n    command! -count=1 -nargs=0 Xafter <mods><count>lafter\n    let g:Xgetlist = function('getloclist', [0])\n    let g:Xsetlist = function('setloclist', [0])\n    call setloclist(0, [], 'f')\n  endif\nendfunc\n\n\" This must be run before any error lists are created.\nfunc Test_AA_cc_no_errors()\n  call assert_fails('cc', 'E42:')\n  call assert_fails('ll', 'E42:')\nendfunc\n\n\" Tests for the :clist and :llist commands\nfunc XlistTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  if a:cchar == 'l'\n      call assert_fails('llist', 'E776:')\n  endif\n  \" With an empty list, command should return error\n  Xgetexpr []\n  silent! Xlist\n  call assert_true(v:errmsg ==# 'E42: No Errors')\n\n  \" Populate the list and then try\n  Xgetexpr ['non-error 1', 'Xtestfile1:1:3:Line1',\n\t\t  \\ 'non-error 2', 'Xtestfile2:2:2:Line2',\n\t\t  \\ 'non-error| 3', 'Xtestfile3:3:1:Line3']\n\n  \" List only valid entries\n  let l = split(execute('Xlist', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 4 Xtestfile2:2 col 2: Line2',\n\t\t   \\ ' 6 Xtestfile3:3 col 1: Line3'], l)\n\n  \" List all the entries\n  let l = split(execute('Xlist!', ''), \"\\n\")\n  call assert_equal([' 1: non-error 1', ' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2',\n\t\t   \\ ' 5: non-error| 3', ' 6 Xtestfile3:3 col 1: Line3'], l)\n\n  \" List a range of errors\n  let l = split(execute('Xlist 3,6', ''), \"\\n\")\n  call assert_equal([' 4 Xtestfile2:2 col 2: Line2',\n\t\t   \\ ' 6 Xtestfile3:3 col 1: Line3'], l)\n\n  let l = split(execute('Xlist! 3,4', ''), \"\\n\")\n  call assert_equal([' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)\n\n  let l = split(execute('Xlist -6,-4', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1'], l)\n\n  let l = split(execute('Xlist! -5,-3', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)\n\n  \" Test for '+'\n  let l = split(execute('Xlist! +2', ''), \"\\n\")\n  call assert_equal([' 2 Xtestfile1:1 col 3: Line1',\n\t\t   \\ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)\n\n  \" Ranged entries\n  call g:Xsetlist([{'lnum':10,'text':'Line1'},\n\t      \\ {'lnum':20,'col':10,'text':'Line2'},\n\t      \\ {'lnum':30,'col':15,'end_col':20,'text':'Line3'},\n\t      \\ {'lnum':40,'end_lnum':45,'text':'Line4'},\n\t      \\ {'lnum':50,'end_lnum':55,'col':15,'text':'Line5'},\n\t      \\ {'lnum':60,'end_lnum':65,'col':25,'end_col':35,'text':'Line6'}])\n  let l = split(execute('Xlist', \"\"), \"\\n\")\n  call assert_equal([' 1:10: Line1',\n\t      \\ ' 2:20 col 10: Line2',\n\t      \\ ' 3:30 col 15-20: Line3',\n\t      \\ ' 4:40-45: Line4',\n\t      \\ ' 5:50-55 col 15: Line5',\n\t      \\ ' 6:60-65 col 25-35: Line6'], l)\n\n  \" Different types of errors\n  call g:Xsetlist([{'lnum':10,'col':5,'type':'W', 'text':'Warning','nr':11},\n\t      \\ {'lnum':20,'col':10,'type':'e','text':'Error','nr':22},\n\t      \\ {'lnum':30,'col':15,'type':'i','text':'Info','nr':33},\n\t      \\ {'lnum':40,'col':20,'type':'x', 'text':'Other','nr':44},\n\t      \\ {'lnum':50,'col':25,'type':\"\\<C-A>\",'text':'one','nr':55}])\n  let l = split(execute('Xlist', \"\"), \"\\n\")\n  call assert_equal([' 1:10 col 5 warning  11: Warning',\n\t      \\ ' 2:20 col 10 error  22: Error',\n\t      \\ ' 3:30 col 15 info  33: Info',\n\t      \\ ' 4:40 col 20 x  44: Other',\n\t      \\ ' 5:50 col 25  55: one'], l)\n\n  \" Test for module names, one needs to explicitly set `'valid':v:true` so\n  call g:Xsetlist([\n\t\\ {'lnum':10,'col':5,'type':'W','module':'Data.Text','text':'ModuleWarning','nr':11,'valid':v:true},\n\t\\ {'lnum':20,'col':10,'type':'W','module':'Data.Text','filename':'Data/Text.hs','text':'ModuleWarning','nr':22,'valid':v:true},\n\t\\ {'lnum':30,'col':15,'type':'W','filename':'Data/Text.hs','text':'FileWarning','nr':33,'valid':v:true}])\n  let l = split(execute('Xlist', \"\"), \"\\n\")\n  call assert_equal([' 1 Data.Text:10 col 5 warning  11: ModuleWarning',\n\t\\ ' 2 Data.Text:20 col 10 warning  22: ModuleWarning',\n\t\\ ' 3 Data/Text.hs:30 col 15 warning  33: FileWarning'], l)\n\n  \" For help entries in the quickfix list, only the filename without directory\n  \" should be displayed\n  Xhelpgrep setqflist()\n  let l = split(execute('Xlist 1', ''), \"\\n\")\n  call assert_match('^ 1 [^\\\\/]\\{-}:', l[0])\n\n  \" Error cases\n  call assert_fails('Xlist abc', 'E488:')\nendfunc\n\nfunc Test_clist()\n  call XlistTests('c')\n  call XlistTests('l')\nendfunc\n\n\" Tests for the :colder, :cnewer, :lolder and :lnewer commands\n\" Note that this test assumes that a quickfix/location list is\n\" already set by the caller.\nfunc XageTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  if a:cchar == 'l'\n    \" No location list for the current window\n    call assert_fails('lolder', 'E776:')\n    call assert_fails('lnewer', 'E776:')\n  endif\n\n  let list = [{'bufnr': bufnr('%'), 'lnum': 1}]\n  call g:Xsetlist(list)\n\n  \" Jumping to a non existent list should return error\n  silent! Xolder 99\n  call assert_true(v:errmsg ==# 'E380: At bottom of quickfix stack')\n\n  silent! Xnewer 99\n  call assert_true(v:errmsg ==# 'E381: At top of quickfix stack')\n\n  \" Add three quickfix/location lists\n  Xgetexpr ['Xtestfile1:1:3:Line1']\n  Xgetexpr ['Xtestfile2:2:2:Line2']\n  Xgetexpr ['Xtestfile3:3:1:Line3']\n\n  \" Go back two lists\n  Xolder\n  let l = g:Xgetlist()\n  call assert_equal('Line2', l[0].text)\n\n  \" Go forward two lists\n  Xnewer\n  let l = g:Xgetlist()\n  call assert_equal('Line3', l[0].text)\n\n  \" Test for the optional count argument\n  Xolder 2\n  let l = g:Xgetlist()\n  call assert_equal('Line1', l[0].text)\n\n  Xnewer 2\n  let l = g:Xgetlist()\n  call assert_equal('Line3', l[0].text)\nendfunc\n\nfunc Test_cage()\n  call XageTests('c')\n  call XageTests('l')\nendfunc\n\n\" Tests for the :cwindow, :lwindow :cclose, :lclose, :copen and :lopen\n\" commands\nfunc XwindowTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Opening the location list window without any errors should fail\n  if a:cchar == 'l'\n      call assert_fails('lopen', 'E776:')\n  endif\n\n  \" Create a list with no valid entries\n  Xgetexpr ['non-error 1', 'non-error 2', 'non-error 3']\n\n  \" Quickfix/Location window should not open with no valid errors\n  Xwindow\n  call assert_true(winnr('$') == 1)\n\n  \" Create a list with valid entries\n  Xgetexpr ['Xtestfile1:1:3:Line1', 'Xtestfile2:2:2:Line2',\n\t\t  \\ 'Xtestfile3:3:1:Line3']\n\n  \" Open the window\n  Xwindow\n  call assert_true(winnr('$') == 2 && winnr() == 2 &&\n\t\\ getline('.') ==# 'Xtestfile1|1 col 3| Line1')\n  redraw!\n\n  \" Close the window\n  Xclose\n  call assert_true(winnr('$') == 1)\n\n  \" Create a list with no valid entries\n  Xgetexpr ['non-error 1', 'non-error 2', 'non-error 3']\n\n  \" Open the window\n  Xopen 5\n  call assert_true(winnr('$') == 2 && getline('.') ==# '|| non-error 1'\n\t\t      \\  && winheight(0) == 5)\n\n  \" Opening the window again, should move the cursor to that window\n  wincmd t\n  Xopen 7\n  call assert_true(winnr('$') == 2 && winnr() == 2 &&\n\t\\ winheight(0) == 7 &&\n\t\\ getline('.') ==# '|| non-error 1')\n\n  \" :cnext in quickfix window should move to the next entry\n  Xnext\n  call assert_equal(2, g:Xgetlist({'idx' : 0}).idx)\n\n  \" Calling cwindow should close the quickfix window with no valid errors\n  Xwindow\n  call assert_true(winnr('$') == 1)\n\n  \" Specifying the width should adjust the width for a vertically split\n  \" quickfix window.\n  vert Xopen\n  call assert_equal(10, winwidth(0))\n  vert Xopen 12\n  call assert_equal(12, winwidth(0))\n  Xclose\n\n  \" Horizontally or vertically splitting the quickfix window should create a\n  \" normal window/buffer\n  Xopen\n  wincmd s\n  call assert_equal(0, getwininfo(win_getid())[0].quickfix)\n  call assert_equal(0, getwininfo(win_getid())[0].loclist)\n  call assert_notequal('quickfix', &buftype)\n  close\n  Xopen\n  wincmd v\n  call assert_equal(0, getwininfo(win_getid())[0].quickfix)\n  call assert_equal(0, getwininfo(win_getid())[0].loclist)\n  call assert_notequal('quickfix', &buftype)\n  close\n  Xopen\n  Xclose\n\n  if a:cchar == 'c'\n      \" Opening the quickfix window in multiple tab pages should reuse the\n      \" quickfix buffer\n      Xgetexpr ['Xtestfile1:1:3:Line1', 'Xtestfile2:2:2:Line2',\n\t\t  \\ 'Xtestfile3:3:1:Line3']\n      Xopen\n      let qfbufnum = bufnr('%')\n      tabnew\n      Xopen\n      call assert_equal(qfbufnum, bufnr('%'))\n      new | only | tabonly\n  endif\nendfunc\n\nfunc Test_cwindow()\n  call XwindowTests('c')\n  call XwindowTests('l')\nendfunc\n\nfunc Test_copenHeight()\n  copen\n  wincmd H\n  let height = winheight(0)\n  copen 10\n  call assert_equal(height, winheight(0))\n  quit\nendfunc\n\nfunc Test_copenHeight_tabline()\n  set tabline=foo showtabline=2\n  copen\n  wincmd H\n  let height = winheight(0)\n  copen 10\n  call assert_equal(height, winheight(0))\n  quit\n  set tabline& showtabline&\nendfunc\n\n\n\" Tests for the :cfile, :lfile, :caddfile, :laddfile, :cgetfile and :lgetfile\n\" commands.\nfunc XfileTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call writefile(['Xtestfile1:700:10:Line 700',\n\t\\ 'Xtestfile2:800:15:Line 800'], 'Xqftestfile1')\n\n  enew!\n  Xfile Xqftestfile1\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 700 && l[0].col == 10 && l[0].text ==# 'Line 700' &&\n\t\\ l[1].lnum == 800 && l[1].col == 15 && l[1].text ==# 'Line 800')\n\n  \" Test with a non existent file\n  call assert_fails('Xfile non_existent_file', 'E40:')\n\n  \" Run cfile/lfile from a modified buffer\n  enew!\n  silent! put ='Quickfix'\n  silent! Xfile Xqftestfile1\n  call assert_true(v:errmsg ==# 'E37: No write since last change (add ! to override)')\n\n  call writefile(['Xtestfile3:900:30:Line 900'], 'Xqftestfile1')\n  Xaddfile Xqftestfile1\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 3 &&\n\t\\ l[2].lnum == 900 && l[2].col == 30 && l[2].text ==# 'Line 900')\n\n  call writefile(['Xtestfile1:222:77:Line 222',\n\t\\ 'Xtestfile2:333:88:Line 333'], 'Xqftestfile1')\n\n  enew!\n  Xgetfile Xqftestfile1\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 222 && l[0].col == 77 && l[0].text ==# 'Line 222' &&\n\t\\ l[1].lnum == 333 && l[1].col == 88 && l[1].text ==# 'Line 333')\n\n  \" Test for a file with a long line and without a newline at the end\n  let text = repeat('x', 1024)\n  let t = 'a.txt:18:' . text\n  call writefile([t], 'Xqftestfile1', 'b')\n  silent! Xfile Xqftestfile1\n  call assert_equal(text, g:Xgetlist()[0].text)\n\n  call delete('Xqftestfile1')\nendfunc\n\nfunc Test_cfile()\n  call XfileTests('c')\n  call XfileTests('l')\nendfunc\n\n\" Tests for the :cbuffer, :lbuffer, :caddbuffer, :laddbuffer, :cgetbuffer and\n\" :lgetbuffer commands.\nfunc XbufferTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  enew!\n  silent! call setline(1, ['Xtestfile7:700:10:Line 700',\n\t\\ 'Xtestfile8:800:15:Line 800'])\n  Xbuffer!\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 700 && l[0].col == 10 && l[0].text ==# 'Line 700' &&\n\t\\ l[1].lnum == 800 && l[1].col == 15 && l[1].text ==# 'Line 800')\n\n  enew!\n  silent! call setline(1, ['Xtestfile9:900:55:Line 900',\n\t\\ 'Xtestfile10:950:66:Line 950'])\n  Xgetbuffer\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 2 &&\n\t\\ l[0].lnum == 900 && l[0].col == 55 && l[0].text ==# 'Line 900' &&\n\t\\ l[1].lnum == 950 && l[1].col == 66 && l[1].text ==# 'Line 950')\n\n  enew!\n  silent! call setline(1, ['Xtestfile11:700:20:Line 700',\n\t\\ 'Xtestfile12:750:25:Line 750'])\n  Xaddbuffer\n  let l = g:Xgetlist()\n  call assert_true(len(l) == 4 &&\n\t\\ l[1].lnum == 950 && l[1].col == 66 && l[1].text ==# 'Line 950' &&\n\t\\ l[2].lnum == 700 && l[2].col == 20 && l[2].text ==# 'Line 700' &&\n\t\\ l[3].lnum == 750 && l[3].col == 25 && l[3].text ==# 'Line 750')\n  enew!\n\n  \" Check for invalid buffer\n  call assert_fails('Xbuffer 199', 'E474:')\n\n  \" Check for unloaded buffer\n  edit Xtestfile1\n  let bnr = bufnr('%')\n  enew!\n  call assert_fails('Xbuffer ' . bnr, 'E681:')\n\n  \" Check for invalid range\n  \" Using Xbuffer will not run the range check in the cbuffer/lbuffer\n  \" commands. So directly call the commands.\n  if (a:cchar == 'c')\n      call assert_fails('900,999cbuffer', 'E16:')\n  else\n      call assert_fails('900,999lbuffer', 'E16:')\n  endif\nendfunc\n\nfunc Test_cbuffer()\n  call XbufferTests('c')\n  call XbufferTests('l')\nendfunc\n\nfunc XexprTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call assert_fails('Xexpr 10', 'E777:')\nendfunc\n\nfunc Test_cexpr()\n  call XexprTests('c')\n  call XexprTests('l')\nendfunc\n\n\" Tests for :cnext, :cprev, :cfirst, :clast commands\nfunc Xtest_browse(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  \" Jumping to first or next location list entry without any error should\n  \" result in failure\n  if a:cchar == 'c'\n    let err = 'E42:'\n    let cmd = '$cc'\n  else\n    let err = 'E776:'\n    let cmd = '$ll'\n  endif\n  call assert_fails('Xnext', err)\n  call assert_fails('Xprev', err)\n  call assert_fails('Xnfile', err)\n  call assert_fails('Xpfile', err)\n  call assert_fails(cmd, err)\n\n  Xexpr ''\n  call assert_fails(cmd, 'E42:')\n\n  call s:create_test_file('Xqftestfile1')\n  call s:create_test_file('Xqftestfile2')\n\n  Xgetexpr ['Xqftestfile1:5:Line5',\n\t\t\\ 'Xqftestfile1:6:Line6',\n\t\t\\ 'Xqftestfile2:10:Line10',\n\t\t\\ 'Xqftestfile2:11:Line11',\n\t\t\\ 'RegularLine1',\n\t\t\\ 'RegularLine2']\n\n  Xfirst\n  call assert_fails('-5Xcc', 'E16:')\n  call assert_fails('Xprev', 'E553:')\n  call assert_fails('Xpfile', 'E553:')\n  Xnfile\n  call assert_equal('Xqftestfile2', @%)\n  call assert_equal(10, line('.'))\n  Xpfile\n  call assert_equal('Xqftestfile1', @%)\n  call assert_equal(6, line('.'))\n  5Xcc\n  call assert_equal(5, g:Xgetlist({'idx':0}).idx)\n  2Xcc\n  call assert_equal(2, g:Xgetlist({'idx':0}).idx)\n  if a:cchar == 'c'\n    cc\n  else\n    ll\n  endif\n  call assert_equal(2, g:Xgetlist({'idx':0}).idx)\n  10Xcc\n  call assert_equal(6, g:Xgetlist({'idx':0}).idx)\n  Xlast\n  Xprev\n  call assert_equal('Xqftestfile2', @%)\n  call assert_equal(11, line('.'))\n  call assert_fails('Xnext', 'E553:')\n  call assert_fails('Xnfile', 'E553:')\n  \" To process the range using quickfix list entries, directly use the\n  \" quickfix commands (don't use the user defined commands)\n  if a:cchar == 'c'\n    $cc\n  else\n    $ll\n  endif\n  call assert_equal(6, g:Xgetlist({'idx':0}).idx)\n  Xrewind\n  call assert_equal('Xqftestfile1', @%)\n  call assert_equal(5, line('.'))\n\n  10Xnext\n  call assert_equal('Xqftestfile2', @%)\n  call assert_equal(11, line('.'))\n  10Xprev\n  call assert_equal('Xqftestfile1', @%)\n  call assert_equal(5, line('.'))\n\n  \" Jumping to an error from the error window using cc command\n  Xgetexpr ['Xqftestfile1:5:Line5',\n\t\t\\ 'Xqftestfile1:6:Line6',\n\t\t\\ 'Xqftestfile2:10:Line10',\n\t\t\\ 'Xqftestfile2:11:Line11']\n  Xopen\n  10Xcc\n  call assert_equal(11, line('.'))\n  call assert_equal('Xqftestfile2', @%)\n  Xopen\n  call cursor(2, 1)\n  if a:cchar == 'c'\n    .cc\n  else\n    .ll\n  endif\n  call assert_equal(6, line('.'))\n  call assert_equal('Xqftestfile1', @%)\n\n  \" Jumping to an error from the error window (when only the error window is\n  \" present)\n  Xopen | only\n  Xlast 1\n  call assert_equal(5, line('.'))\n  call assert_equal('Xqftestfile1', @%)\n\n  Xexpr \"\"\n  call assert_fails('Xnext', 'E42:')\n\n  call delete('Xqftestfile1')\n  call delete('Xqftestfile2')\n\n  \" Should be able to use next/prev with invalid entries\n  Xexpr \"\"\n  call assert_equal(0, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal(0, g:Xgetlist({'size' : 0}).size)\n  Xaddexpr ['foo', 'bar', 'baz', 'quux', 'sh|moo']\n  call assert_equal(5, g:Xgetlist({'size' : 0}).size)\n  Xlast\n  call assert_equal(5, g:Xgetlist({'idx' : 0}).idx)\n  Xfirst\n  call assert_equal(1, g:Xgetlist({'idx' : 0}).idx)\n  2Xnext\n  call assert_equal(3, g:Xgetlist({'idx' : 0}).idx)\nendfunc\n\nfunc Test_browse()\n  call Xtest_browse('c')\n  call Xtest_browse('l')\nendfunc\n\nfunc Test_nomem()\n  call test_alloc_fail(GetAllocId('qf_dirname_start'), 0, 0)\n  call assert_fails('vimgrep vim runtest.vim', 'E342:')\n\n  call GetAllocId('qf_dirname_now')->test_alloc_fail(0, 0)\n  call assert_fails('vimgrep vim runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_namebuf'), 0, 0)\n  call assert_fails('cfile runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_errmsg'), 0, 0)\n  call assert_fails('cfile runtest.vim', 'E342:')\n\n  call test_alloc_fail(GetAllocId('qf_pattern'), 0, 0)\n  call assert_fails('cfile runtest.vim', 'E342:')\n\nendfunc\n\nfunc s:test_xhelpgrep(cchar)\n  call s:setup_commands(a:cchar)\n  Xhelpgrep quickfix\n  Xopen\n  if a:cchar == 'c'\n    let title_text = ':helpgrep quickfix'\n  else\n    let title_text = ':lhelpgrep quickfix'\n  endif\n  call assert_true(w:quickfix_title =~ title_text, w:quickfix_title)\n\n  \" Jumping to a help topic should open the help window\n  only\n  Xnext\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr('$') == 2)\n  \" Jumping to the next match should reuse the help window\n  Xnext\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr() == 1)\n  call assert_true(winnr('$') == 2)\n  \" Jumping to the next match from the quickfix window should reuse the help\n  \" window\n  Xopen\n  Xnext\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr() == 1)\n  call assert_true(winnr('$') == 2)\n  call assert_match('|\\d\\+ col \\d\\+-\\d\\+|', getbufline(winbufnr(2), 1)[0])\n\n  \" This wipes out the buffer, make sure that doesn't cause trouble.\n  Xclose\n\n  \" When the current window is vertically split, jumping to a help match\n  \" should open the help window at the top.\n  only | enew\n  let w1 = win_getid()\n  vert new\n  let w2 = win_getid()\n  Xnext\n  let w3 = win_getid()\n  call assert_true(&buftype == 'help')\n  call assert_true(winnr() == 1)\n  \" See jump_to_help_window() for details\n  let w2_width = winwidth(w2)\n  if w2_width != &columns && w2_width < 80\n    call assert_equal(['col', [['leaf', w3],\n          \\ ['row', [['leaf', w2], ['leaf', w1]]]]], winlayout())\n  else\n    call assert_equal(['row', [['col', [['leaf', w3], ['leaf', w2]]],\n          \\ ['leaf', w1]]] , winlayout())\n  endif\n\n  new | only\n  set buftype=help\n  set modified\n  call assert_fails('Xnext', 'E37:')\n  set nomodified\n  new | only\n\n  if a:cchar == 'l'\n      \" When a help window is present, running :lhelpgrep should reuse the\n      \" help window and not the current window\n      new | only\n      call g:Xsetlist([], 'f')\n      help index.txt\n      wincmd w\n      lhelpgrep quickfix\n      call assert_equal(1, winnr())\n      call assert_notequal([], getloclist(1))\n      call assert_equal([], getloclist(2))\n  endif\n\n  new | only\n\n  \" Search for non existing help string\n  call assert_fails('Xhelpgrep a1b2c3', 'E480:')\n  \" Invalid regular expression\n  call assert_fails('Xhelpgrep \\@<!', 'E866:')\nendfunc\n\nfunc Test_helpgrep()\n  call s:test_xhelpgrep('c')\n  helpclose\n  call s:test_xhelpgrep('l')\nendfunc\n\ndef Test_helpgrep_vim9_restore_cpo()\n  assert_equal('aABceFs', &cpo)\n\n  var rtp_save = &rtp\n  var dir = 'Xruntime/after'\n  &rtp ..= ',' .. dir\n  mkdir(dir .. '/ftplugin', 'p')\n  writefile(['vim9script'], dir .. '/ftplugin/qf.vim')\n  filetype plugin on\n  silent helpgrep grail\n  cwindow\n  silent helpgrep grail\n\n  assert_equal('aABceFs', &cpo)\n  delete(dir, 'rf')\n  &rtp = rtp_save\n  cclose\n  helpclose\nenddef\n\ndef Test_vim9_cexpr()\n  var text = 'somefile:95:error'\n  cexpr text\n  var l = getqflist()\n  assert_equal(1, l->len())\n  assert_equal(95, l[0].lnum)\n  assert_equal('error', l[0].text)\n\n  text = 'somefile:77:warning'\n  caddexpr text\n  l = getqflist()\n  assert_equal(2, l->len())\n  assert_equal(77, l[1].lnum)\n  assert_equal('warning', l[1].text)\nenddef\n\nfunc Test_errortitle()\n  augroup QfBufWinEnter\n    au!\n    au BufWinEnter * :let g:a=get(w:, 'quickfix_title', 'NONE')\n  augroup END\n  copen\n  let a=[{'lnum': 308, 'bufnr': bufnr(''), 'col': 58, 'valid': 1, 'vcol': 0, 'nr': 0, 'type': '', 'pattern': '', 'text': '    au BufWinEnter * :let g:a=get(w:, ''quickfix_title'', ''NONE'')'}]\n  call setqflist(a)\n  call assert_equal(':setqflist()', g:a)\n  augroup QfBufWinEnter\n    au!\n  augroup END\n  augroup! QfBufWinEnter\nendfunc\n\nfunc Test_vimgreptitle()\n  augroup QfBufWinEnter\n    au!\n    au BufWinEnter * :let g:a=get(w:, 'quickfix_title', 'NONE')\n  augroup END\n  try\n    vimgrep /pattern/j file\n  catch /E480/\n  endtry\n  copen\n  call assert_equal(':    vimgrep /pattern/j file', g:a)\n  augroup QfBufWinEnter\n    au!\n  augroup END\n  augroup! QfBufWinEnter\nendfunc\n\nfunc Test_bufwinenter_once()\n  augroup QfBufWinEnter\n    au!\n    au BufWinEnter * let g:got_afile ..= 'got ' .. expand('<afile>')\n  augroup END\n  let g:got_afile = ''\n  copen\n  call assert_equal('got quickfix', g:got_afile)\n\n  cclose\n  unlet g:got_afile\n  augroup QfBufWinEnter\n    au!\n  augroup END\n  augroup! QfBufWinEnter\nendfunc\n\nfunc XqfTitleTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xgetexpr ['file:1:1:message']\n  let l = g:Xgetlist()\n  if a:cchar == 'c'\n    call setqflist(l, 'r')\n  else\n    call setloclist(0, l, 'r')\n  endif\n\n  Xopen\n  if a:cchar == 'c'\n    let title = ':setqflist()'\n  else\n    let title = ':setloclist()'\n  endif\n  call assert_equal(title, w:quickfix_title)\n  Xclose\nendfunc\n\n\" Tests for quickfix window's title\nfunc Test_qf_title()\n  call XqfTitleTests('c')\n  call XqfTitleTests('l')\nendfunc\n\n\" Tests for 'errorformat'\nfunc Test_efm()\n  let save_efm = &efm\n  set efm=%EEEE%m,%WWWW%m,%+CCCC%.%#,%-GGGG%.%#\n  cgetexpr ['WWWW', 'EEEE', 'CCCC']\n  let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))\n  call assert_equal(\"[['W', 1], ['E^@CCCC', 1]]\", l)\n  cgetexpr ['WWWW', 'GGGG', 'EEEE', 'CCCC']\n  let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))\n  call assert_equal(\"[['W', 1], ['E^@CCCC', 1]]\", l)\n  cgetexpr ['WWWW', 'GGGG', 'ZZZZ', 'EEEE', 'CCCC', 'YYYY']\n  let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))\n  call assert_equal(\"[['W', 1], ['ZZZZ', 0], ['E^@CCCC', 1], ['YYYY', 0]]\", l)\n  let &efm = save_efm\nendfunc\n\n\" This will test for problems in quickfix:\n\" A. incorrectly copying location lists which caused the location list to show\n\"    a different name than the file that was actually being displayed.\n\" B. not reusing the window for which the location list window is opened but\n\"    instead creating new windows.\n\" C. make sure that the location list window is not reused instead of the\n\"    window it belongs to.\n\"\n\" Set up the test environment:\nfunc ReadTestProtocol(name)\n  let base = substitute(a:name, '\\v^test://(.*)%(\\.[^.]+)?', '\\1', '')\n  let word = substitute(base, '\\v(.*)\\..*', '\\1', '')\n\n  setl modifiable\n  setl noreadonly\n  setl noswapfile\n  setl bufhidden=delete\n  %del _\n  \" For problem 2:\n  \" 'buftype' has to be set to reproduce the constant opening of new windows\n  setl buftype=nofile\n\n  call setline(1, word)\n\n  setl nomodified\n  setl nomodifiable\n  setl readonly\n  exe 'doautocmd BufRead ' . substitute(a:name, '\\v^test://(.*)', '\\1', '')\nendfunc\n\nfunc Test_locationlist()\n  enew\n\n  augroup testgroup\n    au!\n    autocmd BufReadCmd test://* call ReadTestProtocol(expand(\"<amatch>\"))\n  augroup END\n\n  let words = [ \"foo\", \"bar\", \"baz\", \"quux\", \"shmoo\", \"spam\", \"eggs\" ]\n\n  let qflist = []\n  for word in words\n    call add(qflist, {'filename': 'test://' . word . '.txt', 'text': 'file ' . word . '.txt', })\n    \" NOTE: problem 1:\n    \" intentionally not setting 'lnum' so that the quickfix entries are not\n    \" valid\n    eval qflist->setloclist(0, ' ')\n  endfor\n\n  \" Test A\n  lrewind\n  enew\n  lopen\n  4lnext\n  vert split\n  wincmd L\n  lopen\n  wincmd p\n  lnext\n  let fileName = expand(\"%\")\n  wincmd p\n  let locationListFileName = substitute(getline(line('.')), '\\([^|]*\\)|.*', '\\1', '')\n  let fileName = substitute(fileName, '\\\\', '/', 'g')\n  let locationListFileName = substitute(locationListFileName, '\\\\', '/', 'g')\n  call assert_equal(\"test://bar.txt\", fileName)\n  call assert_equal(\"test://bar.txt\", locationListFileName)\n\n  wincmd n | only\n\n  \" Test B:\n  lrewind\n  lopen\n  2\n  exe \"normal \\<CR>\"\n  wincmd p\n  3\n  exe \"normal \\<CR>\"\n  wincmd p\n  4\n  exe \"normal \\<CR>\"\n  call assert_equal(2, winnr('$'))\n  wincmd n | only\n\n  \" Test C:\n  lrewind\n  lopen\n  \" Let's move the location list window to the top to check whether it (the\n  \" first window found) will be reused when we try to open new windows:\n  wincmd K\n  2\n  exe \"normal \\<CR>\"\n  wincmd p\n  3\n  exe \"normal \\<CR>\"\n  wincmd p\n  4\n  exe \"normal \\<CR>\"\n  1wincmd w\n  call assert_equal('quickfix', &buftype)\n  2wincmd w\n  let bufferName = expand(\"%\")\n  let bufferName = substitute(bufferName, '\\\\', '/', 'g')\n  call assert_equal('test://quux.txt', bufferName)\n\n  wincmd n | only\n\n  augroup! testgroup\nendfunc\n\nfunc Test_locationlist_curwin_was_closed()\n  augroup testgroup\n    au!\n    autocmd BufReadCmd test_curwin.txt call R(expand(\"<amatch>\"))\n  augroup END\n\n  func! R(n)\n    quit\n  endfunc\n\n  new\n  let q = []\n  call add(q, {'filename': 'test_curwin.txt' })\n  call setloclist(0, q)\n  call assert_fails('lrewind', 'E924:')\n\n  augroup! testgroup\n  delfunc R\nendfunc\n\nfunc Test_locationlist_cross_tab_jump()\n  call writefile(['loclistfoo'], 'loclistfoo')\n  call writefile(['loclistbar'], 'loclistbar')\n  set switchbuf=usetab\n\n  edit loclistfoo\n  tabedit loclistbar\n  silent lgrep loclistfoo loclist*\n  call assert_equal(1, tabpagenr())\n\n  enew | only | tabonly\n  set switchbuf&vim\n  call delete('loclistfoo')\n  call delete('loclistbar')\nendfunc\n\n\" More tests for 'errorformat'\nfunc Test_efm1()\n  \" The 'errorformat' setting is different on non-Unix systems.\n  \" This test works only on Unix-like systems.\n  CheckUnix\n\n  let l =<< trim [DATA]\n    \"Xtestfile\", line 4.12: 1506-045 (S) Undeclared identifier fd_set.\n    \ufeff\"Xtestfile\", line 6 col 19; this is an error\n    gcc -c -DHAVE_CONFIsing-prototypes -I/usr/X11R6/include  version.c\n    Xtestfile:9: parse error before `asd'\n    make: *** [vim] Error 1\n    in file \"Xtestfile\" linenr 10: there is an error\n\n    2 returned\n    \"Xtestfile\", line 11 col 1; this is an error\n    \"Xtestfile\", line 12 col 2; this is another error\n    \"Xtestfile\", line 14:10; this is an error in column 10\n    =Xtestfile=, line 15:10; this is another error, but in vcol 10 this time\n    \"Xtestfile\", linenr 16: yet another problem\n    Error in \"Xtestfile\" at line 17:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 17\n                ^\n    Error in \"Xtestfile\" at line 18:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 18\n    .............^\n    Error in \"Xtestfile\" at line 19:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 19\n    --------------^\n    Error in \"Xtestfile\" at line 20:\n    x should be a dot\n    \txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 20\n    \t       ^\n\n    Does anyone know what is the problem and how to correction it?\n    \"Xtestfile\", line 21 col 9: What is the title of the quickfix window?\n    \"Xtestfile\", line 22 col 9: What is the title of the quickfix window?\n  [DATA]\n\n  call writefile(l, 'Xerrorfile1')\n  call writefile(l[:-2], 'Xerrorfile2')\n\n  let m =<< [DATA]\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  2\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  3\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  4\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  5\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  6\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  7\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  8\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line  9\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 10\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 11\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 12\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 13\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 14\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 15\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 16\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 17\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 18\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 19\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 20\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 21\n\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    line 22\n[DATA]\n  call writefile(m, 'Xtestfile')\n\n  let save_efm = &efm\n  set efm+==%f=\\\\,\\ line\\ %l%*\\\\D%v%*[^\\ ]\\ %m\n  set efm^=%AError\\ in\\ \\\"%f\\\"\\ at\\ line\\ %l:,%Z%p^,%C%m\n\n  exe 'cf Xerrorfile2'\n  clast\n  copen\n  call assert_equal(':cf Xerrorfile2', w:quickfix_title)\n  wincmd p\n\n  exe 'cf Xerrorfile1'\n  call assert_equal([4, 12], [line('.'), col('.')])\n  cn\n  call assert_equal([6, 19], [line('.'), col('.')])\n  cn\n  call assert_equal([9, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([10, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([11, 1], [line('.'), col('.')])\n  cn\n  call assert_equal([12, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([14, 10], [line('.'), col('.')])\n  cn\n  call assert_equal([15, 3, 10], [line('.'), col('.'), virtcol('.')])\n  cn\n  call assert_equal([16, 2], [line('.'), col('.')])\n  cn\n  call assert_equal([17, 6], [line('.'), col('.')])\n  cn\n  call assert_equal([18, 7], [line('.'), col('.')])\n  cn\n  call assert_equal([19, 8], [line('.'), col('.')])\n  cn\n  call assert_equal([20, 9], [line('.'), col('.')])\n  clast\n  cprev\n  cprev\n  wincmd w\n  call assert_equal(':cf Xerrorfile1', w:quickfix_title)\n  wincmd p\n\n  let &efm = save_efm\n  call delete('Xerrorfile1')\n  call delete('Xerrorfile2')\n  call delete('Xtestfile')\nendfunc\n\n\" Test for quickfix directory stack support\nfunc s:dir_stack_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let save_efm=&efm\n  set efm=%DEntering\\ dir\\ '%f',%f:%l:%m,%XLeaving\\ dir\\ '%f'\n\n  let lines = [\"Entering dir 'dir1/a'\",\n\t\t\\ 'habits2.txt:1:Nine Healthy Habits',\n\t\t\\ \"Entering dir 'b'\",\n\t\t\\ 'habits3.txt:2:0 Hours of television',\n\t\t\\ 'habits2.txt:7:5 Small meals',\n\t\t\\ \"Entering dir 'dir1/c'\",\n\t\t\\ 'habits4.txt:3:1 Hour of exercise',\n\t\t\\ \"Leaving dir 'dir1/c'\",\n\t\t\\ \"Leaving dir 'dir1/a'\",\n\t\t\\ 'habits1.txt:4:2 Liters of water',\n\t\t\\ \"Entering dir 'dir2'\",\n\t\t\\ 'habits5.txt:5:3 Cups of hot green tea',\n\t\t\\ \"Leaving dir 'dir2'\"\n\t\t\\]\n\n  Xexpr \"\"\n  for l in lines\n      Xaddexpr l\n  endfor\n\n  let qf = g:Xgetlist()\n\n  call assert_equal('dir1/a/habits2.txt', bufname(qf[1].bufnr))\n  call assert_equal(1, qf[1].lnum)\n  call assert_equal('dir1/a/b/habits3.txt', bufname(qf[3].bufnr))\n  call assert_equal(2, qf[3].lnum)\n  call assert_equal('dir1/a/habits2.txt', bufname(qf[4].bufnr))\n  call assert_equal(7, qf[4].lnum)\n  call assert_equal('dir1/c/habits4.txt', bufname(qf[6].bufnr))\n  call assert_equal(3, qf[6].lnum)\n  call assert_equal('habits1.txt', bufname(qf[9].bufnr))\n  call assert_equal(4, qf[9].lnum)\n  call assert_equal('dir2/habits5.txt', bufname(qf[11].bufnr))\n  call assert_equal(5, qf[11].lnum)\n\n  let &efm=save_efm\nendfunc\n\n\" Tests for %D and %X errorformat options\nfunc Test_efm_dirstack()\n  \" Create the directory stack and files\n  call mkdir('dir1')\n  call mkdir('dir1/a')\n  call mkdir('dir1/a/b')\n  call mkdir('dir1/c')\n  call mkdir('dir2')\n\n  let lines = [\"Nine Healthy Habits\",\n\t\t\\ \"0 Hours of television\",\n\t\t\\ \"1 Hour of exercise\",\n\t\t\\ \"2 Liters of water\",\n\t\t\\ \"3 Cups of hot green tea\",\n\t\t\\ \"4 Short mental breaks\",\n\t\t\\ \"5 Small meals\",\n\t\t\\ \"6 AM wake up time\",\n\t\t\\ \"7 Minutes of laughter\",\n\t\t\\ \"8 Hours of sleep (at least)\",\n\t\t\\ \"9 PM end of the day and off to bed\"\n\t\t\\ ]\n  call writefile(lines, 'habits1.txt')\n  call writefile(lines, 'dir1/a/habits2.txt')\n  call writefile(lines, 'dir1/a/b/habits3.txt')\n  call writefile(lines, 'dir1/c/habits4.txt')\n  call writefile(lines, 'dir2/habits5.txt')\n\n  call s:dir_stack_tests('c')\n  call s:dir_stack_tests('l')\n\n  call delete('dir1', 'rf')\n  call delete('dir2', 'rf')\n  call delete('habits1.txt')\nendfunc\n\n\" Test for resync after continuing an ignored message\nfunc Xefm_ignore_continuations(cchar)\n  call s:setup_commands(a:cchar)\n\n  let save_efm = &efm\n\n  let &efm =\n\t\\ '%Eerror %m %l,' .\n\t\\ '%-Wignored %m %l,' .\n\t\\ '%+Cmore ignored %m %l,' .\n\t\\ '%Zignored end'\n  Xgetexpr ['ignored warning 1', 'more ignored continuation 2', 'ignored end', 'error resync 4']\n  let l = map(g:Xgetlist(), '[v:val.text, v:val.valid, v:val.lnum, v:val.type]')\n  call assert_equal([['resync', 1, 4, 'E']], l)\n\n  let &efm = save_efm\nendfunc\n\nfunc Test_efm_ignore_continuations()\n  call Xefm_ignore_continuations('c')\n  call Xefm_ignore_continuations('l')\nendfunc\n\n\" Tests for invalid error format specifies\nfunc Xinvalid_efm_Tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let save_efm = &efm\n\n  set efm=%f:%l:%m,%f:%f:%l:%m\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E372:')\n\n  set efm=%f:%l:%m,%f:%l:%r:%m\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E373:')\n\n  set efm=%f:%l:%m,%O:%f:%l:%m\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E373:')\n\n  set efm=%f:%l:%m,%f:%l:%*[^a-z\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E374:')\n\n  set efm=%f:%l:%m,%f:%l:%*c\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E375:')\n\n  set efm=%f:%l:%m,%L%M%N\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E376:')\n\n  set efm=%f:%l:%m,%f:%l:%m:%R\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E377:')\n\n  \" Invalid regular expression\n  set efm=%\\\\%%k\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E867:')\n\n  set efm=\n  call assert_fails('Xexpr \"abc.txt:1:Hello world\"', 'E378:')\n\n  set efm=%DEntering\\ dir\\ abc,%f:%l:%m\n  call assert_fails('Xexpr [\"Entering dir abc\", \"abc.txt:1:Hello world\"]', 'E379:')\n\n  let &efm = save_efm\nendfunc\n\nfunc Test_invalid_efm()\n  call Xinvalid_efm_Tests('c')\n  call Xinvalid_efm_Tests('l')\nendfunc\n\n\" TODO:\n\" Add tests for the following formats in 'errorformat'\n\"\t%r  %O\nfunc Test_efm2()\n  let save_efm = &efm\n\n  \" Test for %s format in efm\n  set efm=%f:%s\n  cexpr 'Xtestfile:Line search text'\n  let l = getqflist()\n  call assert_equal('^\\VLine search text\\$', l[0].pattern)\n  call assert_equal(0, l[0].lnum)\n\n  let l = split(execute('clist', ''), \"\\n\")\n  call assert_equal([' 1 Xtestfile:^\\VLine search text\\$:  '], l)\n\n  \" Test for a long line\n  cexpr 'Xtestfile:' . repeat('a', 1026)\n  let l = getqflist()\n  call assert_equal('^\\V' . repeat('a', 1019) . '\\$', l[0].pattern)\n\n  \" Test for %P, %Q and %t format specifiers\n  let lines =<< trim [DATA]\n    [Xtestfile1]\n    (1,17)  error: ';' missing\n    (21,2)  warning: variable 'z' not defined\n    (67,3)  error: end of file found before string ended\n    --\n\n    [Xtestfile2]\n    --\n\n    [Xtestfile3]\n    NEW compiler v1.1\n    (2,2)   warning: variable 'x' not defined\n    (67,3)  warning: 's' already defined\n    --\n  [DATA]\n\n  set efm=%+P[%f]%r,(%l\\\\,%c)%*[\\ ]%t%*[^:]:\\ %m,%+Q--%r\n  \" To exercise the push/pop file functionality in quickfix, the test files\n  \" need to be created.\n  call writefile(['Line1'], 'Xtestfile1')\n  call writefile(['Line2'], 'Xtestfile2')\n  call writefile(['Line3'], 'Xtestfile3')\n  cexpr \"\"\n  for l in lines\n      caddexpr l\n  endfor\n  let l = getqflist()\n  call assert_equal(12, len(l))\n  call assert_equal(21, l[2].lnum)\n  call assert_equal(2, l[2].col)\n  call assert_equal('w', l[2].type)\n  call assert_equal('e', l[3].type)\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\n  call delete('Xtestfile3')\n\n  \" Test for %P, %Q with non-existing files\n  cexpr lines\n  let l = getqflist()\n  call assert_equal(14, len(l))\n  call assert_equal('[Xtestfile1]', l[0].text)\n  call assert_equal('[Xtestfile2]', l[6].text)\n  call assert_equal('[Xtestfile3]', l[9].text)\n\n  \" Tests for %E, %C and %Z format specifiers\n  let lines =<< trim [DATA]\n    Error 275\n    line 42\n    column 3\n    ' ' expected after '--'\n  [DATA]\n\n  set efm=%EError\\ %n,%Cline\\ %l,%Ccolumn\\ %c,%Z%m\n  cgetexpr lines\n  let l = getqflist()\n  call assert_equal(275, l[0].nr)\n  call assert_equal(42, l[0].lnum)\n  call assert_equal(3, l[0].col)\n  call assert_equal('E', l[0].type)\n  call assert_equal(\"\\n' ' expected after '--'\", l[0].text)\n\n  \" Test for %>\n  let lines =<< trim [DATA]\n    Error in line 147 of foo.c:\n    unknown variable 'i'\n  [DATA]\n\n  set efm=unknown\\ variable\\ %m,%E%>Error\\ in\\ line\\ %l\\ of\\ %f:,%Z%m\n  cgetexpr lines\n  let l = getqflist()\n  call assert_equal(147, l[0].lnum)\n  call assert_equal('E', l[0].type)\n  call assert_equal(\"\\nunknown variable 'i'\", l[0].text)\n\n  \" Test for %A, %C and other formats\n  let lines =<< trim [DATA]\n    ==============================================================\n    FAIL: testGetTypeIdCachesResult (dbfacadeTest.DjsDBFacadeTest)\n    --------------------------------------------------------------\n    Traceback (most recent call last):\n      File \"unittests/dbfacadeTest.py\", line 89, in testFoo\n        self.assertEquals(34, dtid)\n      File \"/usr/lib/python2.2/unittest.py\", line 286, in\n     failUnlessEqual\n        raise self.failureException, \\\\\n    W:AssertionError: 34 != 33\n  \n    --------------------------------------------------------------\n    Ran 27 tests in 0.063s\n  [DATA]\n\n  set efm=%C\\ %.%#,%A\\ \\ File\\ \\\"%f\\\"\\\\,\\ line\\ %l%.%#,%Z%[%^\\ ]%\\\\@=%t:%m\n  cgetexpr lines\n  let l = getqflist()\n  call assert_equal(8, len(l))\n  call assert_equal(89, l[4].lnum)\n  call assert_equal(1, l[4].valid)\n  call assert_equal('unittests/dbfacadeTest.py', bufname(l[4].bufnr))\n  call assert_equal('W', l[4].type)\n\n  \" Test for %o\n  set efm=%f(%o):%l\\ %m\n  cgetexpr ['Xotestfile(Language.PureScript.Types):20 Error']\n  call writefile(['Line1'], 'Xotestfile')\n  let l = getqflist()\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('Language.PureScript.Types', l[0].module)\n  copen\n  call assert_equal('Language.PureScript.Types|20| Error', getline(1))\n  call feedkeys(\"\\<CR>\", 'xn')\n  call assert_equal('Xotestfile', expand('%:t'))\n  cclose\n  bd\n  call delete(\"Xotestfile\")\n\n  \" Test for a long module name\n  cexpr 'Xtest(' . repeat('m', 1026) . '):15 message'\n  let l = getqflist()\n  call assert_equal(repeat('m', 1024), l[0].module)\n  call assert_equal(15, l[0].lnum)\n  call assert_equal('message', l[0].text)\n\n  \" The following sequence of commands used to crash Vim\n  set efm=%W%m\n  cgetexpr ['msg1']\n  let l = getqflist()\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('msg1', l[0].text)\n  set efm=%C%m\n  lexpr 'msg2'\n  let l = getloclist(0)\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('msg2', l[0].text)\n  lopen\n  call setqflist([], 'r')\n  caddbuf\n  let l = getqflist()\n  call assert_equal(1, len(l), string(l))\n  call assert_equal('|| msg2', l[0].text)\n\n  \" When matching error lines, case should be ignored. Test for this.\n  set noignorecase\n  let l=getqflist({'lines' : ['Xtest:FOO10:Line 20'], 'efm':'%f:foo%l:%m'})\n  call assert_equal(10, l.items[0].lnum)\n  call assert_equal('Line 20', l.items[0].text)\n  set ignorecase&\n\n  new | only\n  let &efm = save_efm\nendfunc\n\n\" Test for '%t' (error type) field in 'efm'\nfunc Test_efm_error_type()\n  let save_efm = &efm\n\n  \" error type\n  set efm=%f:%l:%t:%m\n  cexpr [\"Xfile1:10:E:msg1\", \"Xfile1:20:W:msg2\", \"Xfile1:30:I:msg3\",\n        \\ \"Xfile1:40:N:msg4\", \"Xfile1:50:R:msg5\"]\n  let output = split(execute('clist'), \"\\n\")\n  call assert_equal([\n        \\ ' 1 Xfile1:10 error: msg1',\n        \\ ' 2 Xfile1:20 warning: msg2',\n        \\ ' 3 Xfile1:30 info: msg3',\n        \\ ' 4 Xfile1:40 note: msg4',\n        \\ ' 5 Xfile1:50 R: msg5'], output)\n\n  \" error type and a error number\n  set efm=%f:%l:%t:%n:%m\n  cexpr [\"Xfile1:10:E:2:msg1\", \"Xfile1:20:W:4:msg2\", \"Xfile1:30:I:6:msg3\",\n        \\ \"Xfile1:40:N:8:msg4\", \"Xfile1:50:R:3:msg5\"]\n  let output = split(execute('clist'), \"\\n\")\n  call assert_equal([\n        \\ ' 1 Xfile1:10 error   2: msg1',\n        \\ ' 2 Xfile1:20 warning   4: msg2',\n        \\ ' 3 Xfile1:30 info   6: msg3',\n        \\ ' 4 Xfile1:40 note   8: msg4',\n        \\ ' 5 Xfile1:50 R   3: msg5'], output)\n  let &efm = save_efm\nendfunc\n\nfunc XquickfixChangedByAutocmd(cchar)\n  call s:setup_commands(a:cchar)\n  if a:cchar == 'c'\n    let ErrorNr = 'E925'\n    func! ReadFunc()\n      colder\n      cgetexpr []\n    endfunc\n  else\n    let ErrorNr = 'E926'\n    func! ReadFunc()\n      lolder\n      lgetexpr []\n    endfunc\n  endif\n\n  augroup testgroup\n    au!\n    autocmd BufReadCmd test_changed.txt call ReadFunc()\n  augroup END\n\n  new | only\n  let words = [ \"a\", \"b\" ]\n  let qflist = []\n  for word in words\n    call add(qflist, {'filename': 'test_changed.txt'})\n    call g:Xsetlist(qflist, ' ')\n  endfor\n  call assert_fails('Xrewind', ErrorNr . ':')\n\n  augroup! testgroup\nendfunc\n\nfunc Test_quickfix_was_changed_by_autocmd()\n  call XquickfixChangedByAutocmd('c')\n  call XquickfixChangedByAutocmd('l')\nendfunc\n\nfunc Test_setloclist_in_autocommand()\n  call writefile(['test1', 'test2'], 'Xfile')\n  edit Xfile\n  let s:bufnr = bufnr()\n  call setloclist(1,\n        \\ [{'bufnr' : s:bufnr, 'lnum' : 1, 'text' : 'test1'},\n        \\  {'bufnr' : s:bufnr, 'lnum' : 2, 'text' : 'test2'}])\n\n  augroup Test_LocList\n    au!\n    autocmd BufEnter * call setloclist(1,\n          \\ [{'bufnr' : s:bufnr, 'lnum' : 1, 'text' : 'test1'},\n          \\  {'bufnr' : s:bufnr, 'lnum' : 2, 'text' : 'test2'}], 'r')\n  augroup END\n\n  lopen\n  call assert_fails('exe \"normal j\\<CR>\"', 'E926:')\n\n  augroup Test_LocList\n    au!\n  augroup END\n  call delete('Xfile')\nendfunc\n\nfunc Test_caddbuffer_to_empty()\n  helpgr quickfix\n  call setqflist([], 'r')\n  cad\n  try\n    cn\n  catch\n    \" number of matches is unknown\n    call assert_true(v:exception =~ 'E553:')\n  endtry\n  quit!\nendfunc\n\nfunc Test_cgetexpr_works()\n  \" this must not crash Vim\n  cgetexpr [$x]\n  lgetexpr [$x]\nendfunc\n\n\" Tests for the setqflist() and setloclist() functions\nfunc SetXlistTests(cchar, bnum)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 1},\n\t      \\  {'bufnr': a:bnum, 'lnum': 2, 'end_lnum': 3, 'col': 4, 'end_col': 5}])\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal(2, l[1].lnum)\n  call assert_equal(3, l[1].end_lnum)\n  call assert_equal(4, l[1].col)\n  call assert_equal(5, l[1].end_col)\n\n  Xnext\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 3}], 'a')\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  Xnext\n  call assert_equal(3, line('.'))\n\n  \" Appending entries to the list should not change the cursor position\n  \" in the quickfix window\n  Xwindow\n  1\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 4},\n\t      \\  {'bufnr': a:bnum, 'lnum': 5}], 'a')\n  call assert_equal(1, line('.'))\n  close\n\n  call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 3},\n\t      \\  {'bufnr': a:bnum, 'lnum': 4},\n\t      \\  {'bufnr': a:bnum, 'lnum': 5}], 'r')\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  call assert_equal(5, l[2].lnum)\n\n  call g:Xsetlist([])\n  let l = g:Xgetlist()\n  call assert_equal(0, len(l))\n\n  \" Tests for setting the 'valid' flag\n  call g:Xsetlist([{'bufnr':a:bnum, 'lnum':4, 'valid':0}])\n  Xwindow\n  call assert_equal(1, winnr('$'))\n  let l = g:Xgetlist()\n  call g:Xsetlist(l)\n  call assert_equal(0, g:Xgetlist()[0].valid)\n  \" Adding a non-valid entry should not mark the list as having valid entries\n  call g:Xsetlist([{'bufnr':a:bnum, 'lnum':5, 'valid':0}], 'a')\n  Xwindow\n  call assert_equal(1, winnr('$'))\n\n  \" :cnext/:cprev should still work even with invalid entries in the list\n  let l = [{'bufnr' : a:bnum, 'lnum' : 1, 'text' : '1', 'valid' : 0},\n\t      \\ {'bufnr' : a:bnum, 'lnum' : 2, 'text' : '2', 'valid' : 0}]\n  call g:Xsetlist(l)\n  Xnext\n  call assert_equal(2, g:Xgetlist({'idx' : 0}).idx)\n  Xprev\n  call assert_equal(1, g:Xgetlist({'idx' : 0}).idx)\n  \" :cnext/:cprev should still work after appending invalid entries to an\n  \" empty list\n  call g:Xsetlist([])\n  call g:Xsetlist(l, 'a')\n  Xnext\n  call assert_equal(2, g:Xgetlist({'idx' : 0}).idx)\n  Xprev\n  call assert_equal(1, g:Xgetlist({'idx' : 0}).idx)\n\n  call g:Xsetlist([{'text':'Text1', 'valid':1}])\n  Xwindow\n  call assert_equal(2, winnr('$'))\n  Xclose\n  let save_efm = &efm\n  set efm=%m\n  Xgetexpr 'TestMessage'\n  let l = g:Xgetlist()\n  call g:Xsetlist(l)\n  call assert_equal(1, g:Xgetlist()[0].valid)\n  let &efm = save_efm\n\n  \" Error cases:\n  \" Refer to a non-existing buffer and pass a non-dictionary type\n  call assert_fails(\"call g:Xsetlist([{'bufnr':998, 'lnum':4},\" .\n\t      \\ \" {'bufnr':999, 'lnum':5}])\", 'E92:')\n  call g:Xsetlist([[1, 2,3]])\n  call assert_equal(0, len(g:Xgetlist()))\n  call assert_fails('call g:Xsetlist([], [])', 'E928:')\nendfunc\n\nfunc Test_setqflist()\n  new Xtestfile | only\n  let bnum = bufnr('%')\n  call setline(1, range(1,5))\n\n  call SetXlistTests('c', bnum)\n  call SetXlistTests('l', bnum)\n\n  enew!\n  call delete('Xtestfile')\nendfunc\n\nfunc Xlist_empty_middle(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" create three quickfix lists\n  let @/ = 'Test_'\n  Xvimgrep // test_quickfix.vim\n  let testlen = len(g:Xgetlist())\n  call assert_true(testlen > 0)\n  Xvimgrep empty test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) > 0)\n  Xvimgrep matches test_quickfix.vim\n  let matchlen = len(g:Xgetlist())\n  call assert_true(matchlen > 0)\n  Xolder\n  \" make the middle list empty\n  call g:Xsetlist([], 'r')\n  call assert_true(len(g:Xgetlist()) == 0)\n  Xolder\n  call assert_equal(testlen, len(g:Xgetlist()))\n  Xnewer\n  Xnewer\n  call assert_equal(matchlen, len(g:Xgetlist()))\nendfunc\n\nfunc Test_setqflist_empty_middle()\n  call Xlist_empty_middle('c')\n  call Xlist_empty_middle('l')\nendfunc\n\nfunc Xlist_empty_older(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" create three quickfix lists\n  Xvimgrep one test_quickfix.vim\n  let onelen = len(g:Xgetlist())\n  call assert_true(onelen > 0)\n  Xvimgrep two test_quickfix.vim\n  let twolen = len(g:Xgetlist())\n  call assert_true(twolen > 0)\n  Xvimgrep three test_quickfix.vim\n  let threelen = len(g:Xgetlist())\n  call assert_true(threelen > 0)\n  Xolder 2\n  \" make the first list empty, check the others didn't change\n  call g:Xsetlist([], 'r')\n  call assert_true(len(g:Xgetlist()) == 0)\n  Xnewer\n  call assert_equal(twolen, len(g:Xgetlist()))\n  Xnewer\n  call assert_equal(threelen, len(g:Xgetlist()))\nendfunc\n\nfunc Test_setqflist_empty_older()\n  call Xlist_empty_older('c')\n  call Xlist_empty_older('l')\nendfunc\n\nfunc XquickfixSetListWithAct(cchar)\n  call s:setup_commands(a:cchar)\n\n  let list1 = [{'filename': 'fnameA', 'text': 'A'},\n          \\    {'filename': 'fnameB', 'text': 'B'}]\n  let list2 = [{'filename': 'fnameC', 'text': 'C'},\n          \\    {'filename': 'fnameD', 'text': 'D'},\n          \\    {'filename': 'fnameE', 'text': 'E'}]\n\n  \" {action} is unspecified.  Same as specifying ' '.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2)\n  let li = g:Xgetlist()\n  call assert_equal(3, len(li))\n  call assert_equal('C', li[0]['text'])\n  call assert_equal('D', li[1]['text'])\n  call assert_equal('E', li[2]['text'])\n  silent! Xolder\n  let li = g:Xgetlist()\n  call assert_equal(2, len(li))\n  call assert_equal('A', li[0]['text'])\n  call assert_equal('B', li[1]['text'])\n\n  \" {action} is specified ' '.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2, ' ')\n  let li = g:Xgetlist()\n  call assert_equal(3, len(li))\n  call assert_equal('C', li[0]['text'])\n  call assert_equal('D', li[1]['text'])\n  call assert_equal('E', li[2]['text'])\n  silent! Xolder\n  let li = g:Xgetlist()\n  call assert_equal(2, len(li))\n  call assert_equal('A', li[0]['text'])\n  call assert_equal('B', li[1]['text'])\n\n  \" {action} is specified 'a'.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2, 'a')\n  let li = g:Xgetlist()\n  call assert_equal(5, len(li))\n  call assert_equal('A', li[0]['text'])\n  call assert_equal('B', li[1]['text'])\n  call assert_equal('C', li[2]['text'])\n  call assert_equal('D', li[3]['text'])\n  call assert_equal('E', li[4]['text'])\n\n  \" {action} is specified 'r'.\n  new | only\n  silent! Xnewer 99\n  call g:Xsetlist(list1)\n  call g:Xsetlist(list2, 'r')\n  let li = g:Xgetlist()\n  call assert_equal(3, len(li))\n  call assert_equal('C', li[0]['text'])\n  call assert_equal('D', li[1]['text'])\n  call assert_equal('E', li[2]['text'])\n\n  \" Test for wrong value.\n  new | only\n  call assert_fails(\"call g:Xsetlist(0)\", 'E714:')\n  call assert_fails(\"call g:Xsetlist(list1, '')\", 'E927:')\n  call assert_fails(\"call g:Xsetlist(list1, 'aa')\", 'E927:')\n  call assert_fails(\"call g:Xsetlist(list1, ' a')\", 'E927:')\n  call assert_fails(\"call g:Xsetlist(list1, 0)\", 'E928:')\nendfunc\n\nfunc Test_setqflist_invalid_nr()\n  \" The following command used to crash Vim\n  eval []->setqflist(' ', {'nr' : $XXX_DOES_NOT_EXIST})\nendfunc\n\nfunc Test_setqflist_user_sets_buftype()\n  call setqflist([{'text': 'foo'}, {'text': 'bar'}])\n  set buftype=quickfix\n  call setqflist([], 'a')\n  enew\nendfunc\n\nfunc Test_quickfix_set_list_with_act()\n  call XquickfixSetListWithAct('c')\n  call XquickfixSetListWithAct('l')\nendfunc\n\nfunc XLongLinesTests(cchar)\n  let l = g:Xgetlist()\n\n  call assert_equal(4, len(l))\n  call assert_equal(1, l[0].lnum)\n  call assert_equal(1, l[0].col)\n  call assert_equal(1975, len(l[0].text))\n  call assert_equal(2, l[1].lnum)\n  call assert_equal(1, l[1].col)\n  call assert_equal(4070, len(l[1].text))\n  call assert_equal(3, l[2].lnum)\n  call assert_equal(1, l[2].col)\n  call assert_equal(4070, len(l[2].text))\n  call assert_equal(4, l[3].lnum)\n  call assert_equal(1, l[3].col)\n  call assert_equal(10, len(l[3].text))\n\n  call g:Xsetlist([], 'r')\nendfunc\n\nfunc s:long_lines_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let testfile = 'samples/quickfix.txt'\n\n  \" file\n  exe 'Xgetfile' testfile\n  call XLongLinesTests(a:cchar)\n\n  \" list\n  Xexpr readfile(testfile)\n  call XLongLinesTests(a:cchar)\n\n  \" string\n  Xexpr join(readfile(testfile), \"\\n\")\n  call XLongLinesTests(a:cchar)\n\n  \" buffer\n  exe 'edit' testfile\n  exe 'Xbuffer' bufnr('%')\n  call XLongLinesTests(a:cchar)\nendfunc\n\nfunc Test_long_lines()\n  call s:long_lines_tests('c')\n  call s:long_lines_tests('l')\nendfunc\n\nfunc Test_cgetfile_on_long_lines()\n  \" Problematic values if the line is longer than 4096 bytes.  Then 1024 bytes\n  \" are read at a time.\n  for len in [4078, 4079, 4080, 5102, 5103, 5104, 6126, 6127, 6128, 7150, 7151, 7152]\n    let lines = [\n      \\ '/tmp/file1:1:1:aaa',\n      \\ '/tmp/file2:1:1:%s',\n      \\ '/tmp/file3:1:1:bbb',\n      \\ '/tmp/file4:1:1:ccc',\n      \\ ]\n    let lines[1] = substitute(lines[1], '%s', repeat('x', len), '')\n    call writefile(lines, 'Xcqetfile.txt')\n    cgetfile Xcqetfile.txt\n    call assert_equal(4, getqflist(#{size: v:true}).size, 'with length ' .. len)\n  endfor\n  call delete('Xcqetfile.txt')\nendfunc\n\nfunc s:create_test_file(filename)\n  let l = []\n  for i in range(1, 20)\n      call add(l, 'Line' . i)\n  endfor\n  call writefile(l, a:filename)\nendfunc\n\nfunc Test_switchbuf()\n  call s:create_test_file('Xqftestfile1')\n  call s:create_test_file('Xqftestfile2')\n  call s:create_test_file('Xqftestfile3')\n\n  new | only\n  edit Xqftestfile1\n  let file1_winid = win_getid()\n  new Xqftestfile2\n  let file2_winid = win_getid()\n  cgetexpr ['Xqftestfile1:5:Line5',\n\t\t\\ 'Xqftestfile1:6:Line6',\n\t\t\\ 'Xqftestfile2:10:Line10',\n\t\t\\ 'Xqftestfile2:11:Line11',\n\t\t\\ 'Xqftestfile3:15:Line15',\n\t\t\\ 'Xqftestfile3:16:Line16']\n\n  new\n  let winid = win_getid()\n  cfirst | cnext\n  call assert_equal(winid, win_getid())\n  2cnext\n  call assert_equal(winid, win_getid())\n  2cnext\n  call assert_equal(winid, win_getid())\n\n  \" Test for 'switchbuf' set to search for files in windows in the current\n  \" tabpage and jump to an existing window (if present)\n  set switchbuf=useopen\n  enew\n  cfirst | cnext\n  call assert_equal(file1_winid, win_getid())\n  2cnext\n  call assert_equal(file2_winid, win_getid())\n  2cnext\n  call assert_equal(file2_winid, win_getid())\n\n  \" Test for 'switchbuf' set to search for files in tabpages and jump to an\n  \" existing tabpage (if present)\n  enew | only\n  set switchbuf=usetab\n  tabedit Xqftestfile1\n  tabedit Xqftestfile2\n  tabedit Xqftestfile3\n  tabfirst\n  cfirst | cnext\n  call assert_equal(2, tabpagenr())\n  2cnext\n  call assert_equal(3, tabpagenr())\n  6cnext\n  call assert_equal(4, tabpagenr())\n  2cpfile\n  call assert_equal(2, tabpagenr())\n  2cnfile\n  call assert_equal(4, tabpagenr())\n  tabfirst | tabonly | enew\n\n  \" Test for 'switchbuf' set to open a new window for every file\n  set switchbuf=split\n  cfirst | cnext\n  call assert_equal(1, winnr('$'))\n  cnext | cnext\n  call assert_equal(2, winnr('$'))\n  cnext | cnext\n  call assert_equal(3, winnr('$'))\n\n  \" Test for 'switchbuf' set to open a new tabpage for every file\n  set switchbuf=newtab\n  enew | only\n  cfirst | cnext\n  call assert_equal(1, tabpagenr('$'))\n  cnext | cnext\n  call assert_equal(2, tabpagenr('$'))\n  cnext | cnext\n  call assert_equal(3, tabpagenr('$'))\n  tabfirst | enew | tabonly | only\n\n  set switchbuf=uselast\n  split\n  let last_winid = win_getid()\n  copen\n  exe \"normal 1G\\<CR>\"\n  call assert_equal(last_winid, win_getid())\n  enew | only\n\n  \" With an empty 'switchbuf', jumping to a quickfix entry should open the\n  \" file in an existing window (if present)\n  set switchbuf=\n  edit Xqftestfile1\n  let file1_winid = win_getid()\n  new Xqftestfile2\n  let file2_winid = win_getid()\n  copen\n  exe \"normal 1G\\<CR>\"\n  call assert_equal(file1_winid, win_getid())\n  copen\n  exe \"normal 3G\\<CR>\"\n  call assert_equal(file2_winid, win_getid())\n  copen | only\n  exe \"normal 5G\\<CR>\"\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, bufwinnr('Xqftestfile3'))\n\n  \" If only quickfix window is open in the current tabpage, jumping to an\n  \" entry with 'switchbuf' set to 'usetab' should search in other tabpages.\n  enew | only\n  set switchbuf=usetab\n  tabedit Xqftestfile1\n  tabedit Xqftestfile2\n  tabedit Xqftestfile3\n  tabfirst\n  copen | only\n  clast\n  call assert_equal(4, tabpagenr())\n  tabfirst | tabonly | enew | only\n\n  \" Jumping to a file that is not present in any of the tabpages and the\n  \" current tabpage doesn't have any usable windows, should open it in a new\n  \" window in the current tabpage.\n  copen | only\n  cfirst\n  call assert_equal(1, tabpagenr())\n  call assert_equal('Xqftestfile1', @%)\n\n  \" If opening a file changes 'switchbuf', then the new value should be\n  \" retained.\n  set modeline&vim\n  call writefile([\"vim: switchbuf=split\"], 'Xqftestfile1')\n  enew | only\n  set switchbuf&vim\n  cexpr \"Xqftestfile1:1:10\"\n  call assert_equal('split', &switchbuf)\n  call writefile([\"vim: switchbuf=usetab\"], 'Xqftestfile1')\n  enew | only\n  set switchbuf=useopen\n  cexpr \"Xqftestfile1:1:10\"\n  call assert_equal('usetab', &switchbuf)\n  call writefile([\"vim: switchbuf&vim\"], 'Xqftestfile1')\n  enew | only\n  set switchbuf=useopen\n  cexpr \"Xqftestfile1:1:10\"\n  call assert_equal('', &switchbuf)\n\n  call delete('Xqftestfile1')\n  call delete('Xqftestfile2')\n  call delete('Xqftestfile3')\n  set switchbuf&vim\n\n  enew | only\nendfunc\n\nfunc Xadjust_qflnum(cchar)\n  call s:setup_commands(a:cchar)\n\n  enew | only\n\n  let fname = 'Xqftestfile' . a:cchar\n  call s:create_test_file(fname)\n  exe 'edit ' . fname\n\n  Xgetexpr [fname . ':5:Line5',\n\t      \\ fname . ':10:Line10',\n\t      \\ fname . ':15:Line15',\n\t      \\ fname . ':20:Line20']\n\n  6,14delete\n  call append(6, ['Buffer', 'Window'])\n\n  let l = g:Xgetlist()\n  call assert_equal(5, l[0].lnum)\n  call assert_equal(6, l[2].lnum)\n  call assert_equal(13, l[3].lnum)\n\n  \" If a file doesn't have any quickfix entries, then deleting lines in the\n  \" file should not update the quickfix list\n  call g:Xsetlist([], 'f')\n  1,2delete\n  call assert_equal([], g:Xgetlist())\n\n  enew!\n  call delete(fname)\nendfunc\n\nfunc Test_adjust_lnum()\n  call setloclist(0, [])\n  call Xadjust_qflnum('c')\n  call setqflist([])\n  call Xadjust_qflnum('l')\nendfunc\n\n\" Tests for the :grep/:lgrep and :grepadd/:lgrepadd commands\nfunc s:test_xgrep(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" The following lines are used for the grep test. Don't remove.\n  \" Grep_Test_Text: Match 1\n  \" Grep_Test_Text: Match 2\n  \" GrepAdd_Test_Text: Match 1\n  \" GrepAdd_Test_Text: Match 2\n  enew! | only\n  set makeef&vim\n  silent Xgrep Grep_Test_Text: test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) == 5)\n  Xopen\n  call assert_true(w:quickfix_title =~ '^:grep')\n  Xclose\n  enew\n  set makeef=Temp_File_##\n  silent Xgrepadd GrepAdd_Test_Text: test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) == 9)\n\n  \" Try with 'grepprg' set to 'internal'\n  set grepprg=internal\n  silent Xgrep Grep_Test_Text: test_quickfix.vim\n  silent Xgrepadd GrepAdd_Test_Text: test_quickfix.vim\n  call assert_true(len(g:Xgetlist()) == 9)\n  set grepprg&vim\n\n  call writefile(['Vim'], 'XtestTempFile')\n  set makeef=XtestTempFile\n  silent Xgrep Grep_Test_Text: test_quickfix.vim\n  call assert_equal(5, len(g:Xgetlist()))\n  call assert_false(filereadable('XtestTempFile'))\n  set makeef&vim\nendfunc\n\nfunc Test_grep()\n  \" The grepprg may not be set on non-Unix systems\n  CheckUnix\n\n  call s:test_xgrep('c')\n  call s:test_xgrep('l')\nendfunc\n\nfunc Test_two_windows()\n  \" Use one 'errorformat' for two windows.  Add an expression to each of them,\n  \" make sure they each keep their own state.\n  set efm=%DEntering\\ dir\\ '%f',%f:%l:%m,%XLeaving\\ dir\\ '%f'\n  call mkdir('Xone/a', 'p')\n  call mkdir('Xtwo/a', 'p')\n  let lines = ['1', '2', 'one one one', '4', 'two two two', '6', '7']\n  call writefile(lines, 'Xone/a/one.txt')\n  call writefile(lines, 'Xtwo/a/two.txt')\n\n  new one\n  let one_id = win_getid()\n  lexpr \"\"\n  new two\n  let two_id = win_getid()\n  lexpr \"\"\n\n  laddexpr \"Entering dir 'Xtwo/a'\"\n  call win_gotoid(one_id)\n  laddexpr \"Entering dir 'Xone/a'\"\n  call win_gotoid(two_id)\n  laddexpr 'two.txt:5:two two two'\n  call win_gotoid(one_id)\n  laddexpr 'one.txt:3:one one one'\n\n  let loc_one = getloclist(one_id)\n  call assert_equal('Xone/a/one.txt', bufname(loc_one[1].bufnr))\n  call assert_equal(3, loc_one[1].lnum)\n\n  let loc_two = getloclist(two_id)\n  call assert_equal('Xtwo/a/two.txt', bufname(loc_two[1].bufnr))\n  call assert_equal(5, loc_two[1].lnum)\n\n  call win_gotoid(one_id)\n  bwipe!\n  call win_gotoid(two_id)\n  bwipe!\n  call delete('Xone', 'rf')\n  call delete('Xtwo', 'rf')\nendfunc\n\nfunc XbottomTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Calling lbottom without any errors should fail\n  if a:cchar == 'l'\n      call assert_fails('lbottom', 'E776:')\n  endif\n\n  call g:Xsetlist([{'filename': 'foo', 'lnum': 42}])\n  Xopen\n  let wid = win_getid()\n  call assert_equal(1, line('.'))\n  wincmd w\n  call g:Xsetlist([{'filename': 'var', 'lnum': 24}], 'a')\n  Xbottom\n  call win_gotoid(wid)\n  call assert_equal(2, line('.'))\n  Xclose\nendfunc\n\n\" Tests for the :cbottom and :lbottom commands\nfunc Test_cbottom()\n  call XbottomTests('c')\n  call XbottomTests('l')\nendfunc\n\nfunc HistoryTest(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" clear all lists after the first one, then replace the first one.\n  call g:Xsetlist([])\n  call assert_fails('Xolder 99', 'E380:')\n  let entry = {'filename': 'foo', 'lnum': 42}\n  call g:Xsetlist([entry], 'r')\n  call g:Xsetlist([entry, entry])\n  call g:Xsetlist([entry, entry, entry])\n  let res = split(execute(a:cchar . 'hist'), \"\\n\")\n  call assert_equal(3, len(res))\n  let common = 'errors     :set' . (a:cchar == 'c' ? 'qf' : 'loc') . 'list()'\n  call assert_equal('  error list 1 of 3; 1 ' . common, res[0])\n  call assert_equal('  error list 2 of 3; 2 ' . common, res[1])\n  call assert_equal('> error list 3 of 3; 3 ' . common, res[2])\n\n  \" Test for changing the quickfix lists\n  call assert_equal(3, g:Xgetlist({'nr' : 0}).nr)\n  exe '1' . a:cchar . 'hist'\n  call assert_equal(1, g:Xgetlist({'nr' : 0}).nr)\n  exe '3' . a:cchar . 'hist'\n  call assert_equal(3, g:Xgetlist({'nr' : 0}).nr)\n  call assert_fails('-2' . a:cchar . 'hist', 'E16:')\n  call assert_fails('4' . a:cchar . 'hist', 'E16:')\n\n  call g:Xsetlist([], 'f')\n  let l = split(execute(a:cchar . 'hist'), \"\\n\")\n  call assert_equal('No entries', l[0])\n  if a:cchar == 'c'\n    call assert_fails('4chist', 'E16:')\n  else\n    call assert_fails('4lhist', 'E776:')\n  endif\n\n  \" An empty list should still show the stack history\n  call g:Xsetlist([])\n  let res = split(execute(a:cchar . 'hist'), \"\\n\")\n  call assert_equal('> error list 1 of 1; 0 ' . common, res[0])\n\n  call g:Xsetlist([], 'f')\nendfunc\n\nfunc Test_history()\n  call HistoryTest('c')\n  call HistoryTest('l')\nendfunc\n\nfunc Test_duplicate_buf()\n  \" make sure we can get the highest buffer number\n  edit DoesNotExist\n  edit DoesNotExist2\n  let last_buffer = bufnr(\"$\")\n\n  \" make sure only one buffer is created\n  call writefile(['this one', 'that one'], 'Xgrepthis')\n  vimgrep one Xgrepthis\n  vimgrep one Xgrepthis\n  call assert_equal(last_buffer + 1, bufnr(\"$\"))\n\n  call delete('Xgrepthis')\nendfunc\n\n\" Quickfix/Location list set/get properties tests\nfunc Xproperty_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Error cases\n  call assert_fails('call g:Xgetlist(99)', 'E715:')\n  call assert_fails('call g:Xsetlist(99)', 'E714:')\n  call assert_fails('call g:Xsetlist([], \"a\", [])', 'E715:')\n\n  \" Set and get the title\n  call g:Xsetlist([])\n  Xopen\n  wincmd p\n  call g:Xsetlist([{'filename':'foo', 'lnum':27}])\n  let s = g:Xsetlist([], 'a', {'title' : 'Sample'})\n  call assert_equal(0, s)\n  let d = g:Xgetlist({\"title\":1})\n  call assert_equal('Sample', d.title)\n  \" Try setting title to a non-string value\n  call assert_equal(-1, g:Xsetlist([], 'a', {'title' : ['Test']}))\n  call assert_equal('Sample', g:Xgetlist({\"title\":1}).title)\n\n  Xopen\n  call assert_equal('Sample', w:quickfix_title)\n  Xclose\n\n  \" Tests for action argument\n  silent! Xolder 999\n  let qfnr = g:Xgetlist({'all':1}).nr\n  call g:Xsetlist([], 'r', {'title' : 'N1'})\n  call assert_equal('N1', g:Xgetlist({'all':1}).title)\n  call g:Xsetlist([], ' ', {'title' : 'N2'})\n  call assert_equal(qfnr + 1, g:Xgetlist({'all':1}).nr)\n\n  let res = g:Xgetlist({'nr': 0})\n  call assert_equal(qfnr + 1, res.nr)\n  call assert_equal(['nr'], keys(res))\n\n  call g:Xsetlist([], ' ', {'title' : 'N3'})\n  call assert_equal('N2', g:Xgetlist({'nr':2, 'title':1}).title)\n\n  \" Changing the title of an earlier quickfix list\n  call g:Xsetlist([], 'r', {'title' : 'NewTitle', 'nr' : 2})\n  call assert_equal('NewTitle', g:Xgetlist({'nr':2, 'title':1}).title)\n\n  \" Changing the title of an invalid quickfix list\n  call assert_equal(-1, g:Xsetlist([], ' ',\n        \\ {'title' : 'SomeTitle', 'nr' : 99}))\n  call assert_equal(-1, g:Xsetlist([], ' ',\n        \\ {'title' : 'SomeTitle', 'nr' : 'abc'}))\n\n  if a:cchar == 'c'\n    copen\n    call assert_equal({'winid':win_getid()}, getqflist({'winid':1}))\n    cclose\n  endif\n\n  \" Invalid arguments\n  call assert_fails('call g:Xgetlist([])', 'E715:')\n  call assert_fails('call g:Xsetlist([], \"a\", [])', 'E715:')\n  let s = g:Xsetlist([], 'a', {'abc':1})\n  call assert_equal(-1, s)\n\n  call assert_equal({}, g:Xgetlist({'abc':1}))\n  call assert_equal('', g:Xgetlist({'nr':99, 'title':1}).title)\n  call assert_equal('', g:Xgetlist({'nr':[], 'title':1}).title)\n\n  if a:cchar == 'l'\n    call assert_equal({}, getloclist(99, {'title': 1}))\n  endif\n\n  \" Context related tests\n  let s = g:Xsetlist([], 'a', {'context':[1,2,3]})\n  call assert_equal(0, s)\n  call test_garbagecollect_now()\n  let d = g:Xgetlist({'context':1})\n  call assert_equal([1,2,3], d.context)\n  call g:Xsetlist([], 'a', {'context':{'color':'green'}})\n  let d = g:Xgetlist({'context':1})\n  call assert_equal({'color':'green'}, d.context)\n  call g:Xsetlist([], 'a', {'context':\"Context info\"})\n  let d = g:Xgetlist({'context':1})\n  call assert_equal(\"Context info\", d.context)\n  call g:Xsetlist([], 'a', {'context':246})\n  let d = g:Xgetlist({'context':1})\n  call assert_equal(246, d.context)\n  \" set other Vim data types as context\n  call g:Xsetlist([], 'a', {'context' : test_null_blob()})\n  if has('channel')\n    call g:Xsetlist([], 'a', {'context' : test_null_channel()})\n  endif\n  if has('job')\n    call g:Xsetlist([], 'a', {'context' : test_null_job()})\n  endif\n  call g:Xsetlist([], 'a', {'context' : test_null_function()})\n  call g:Xsetlist([], 'a', {'context' : test_null_partial()})\n  call g:Xsetlist([], 'a', {'context' : ''})\n  call test_garbagecollect_now()\n  if a:cchar == 'l'\n    \" Test for copying context across two different location lists\n    new | only\n    let w1_id = win_getid()\n    let l = [1]\n    call setloclist(0, [], 'a', {'context':l})\n    new\n    let w2_id = win_getid()\n    call add(l, 2)\n    call assert_equal([1, 2], getloclist(w1_id, {'context':1}).context)\n    call assert_equal([1, 2], getloclist(w2_id, {'context':1}).context)\n    unlet! l\n    call assert_equal([1, 2], getloclist(w2_id, {'context':1}).context)\n    only\n    call setloclist(0, [], 'f')\n    call assert_equal('', getloclist(0, {'context':1}).context)\n  endif\n\n  \" Test for changing the context of previous quickfix lists\n  call g:Xsetlist([], 'f')\n  Xexpr \"One\"\n  Xexpr \"Two\"\n  Xexpr \"Three\"\n  call g:Xsetlist([], 'r', {'context' : [1], 'nr' : 1})\n  call g:Xsetlist([], 'a', {'context' : [2], 'nr' : 2})\n  \" Also, check for setting the context using quickfix list number zero.\n  call g:Xsetlist([], 'r', {'context' : [3], 'nr' : 0})\n  call test_garbagecollect_now()\n  let l = g:Xgetlist({'nr' : 1, 'context' : 1})\n  call assert_equal([1], l.context)\n  let l = g:Xgetlist({'nr' : 2, 'context' : 1})\n  call assert_equal([2], l.context)\n  let l = g:Xgetlist({'nr' : 3, 'context' : 1})\n  call assert_equal([3], l.context)\n\n  \" Test for changing the context through reference and for garbage\n  \" collection of quickfix context\n  let l = [\"red\"]\n  call g:Xsetlist([], ' ', {'context' : l})\n  call add(l, \"blue\")\n  let x = g:Xgetlist({'context' : 1})\n  call add(x.context, \"green\")\n  call assert_equal([\"red\", \"blue\", \"green\"], l)\n  call assert_equal([\"red\", \"blue\", \"green\"], x.context)\n  unlet l\n  call test_garbagecollect_now()\n  let m = g:Xgetlist({'context' : 1})\n  call assert_equal([\"red\", \"blue\", \"green\"], m.context)\n\n  \" Test for setting/getting items\n  Xexpr \"\"\n  let qfprev = g:Xgetlist({'nr':0})\n  let s = g:Xsetlist([], ' ', {'title':'Green',\n        \\ 'items' : [{'filename':'F1', 'lnum':10}]})\n  call assert_equal(0, s)\n  let qfcur = g:Xgetlist({'nr':0})\n  call assert_true(qfcur.nr == qfprev.nr + 1)\n  let l = g:Xgetlist({'items':1})\n  call assert_equal('F1', bufname(l.items[0].bufnr))\n  call assert_equal(10, l.items[0].lnum)\n  call g:Xsetlist([], 'a', {'items' : [{'filename':'F2', 'lnum':20},\n        \\  {'filename':'F2', 'lnum':30}]})\n  let l = g:Xgetlist({'items':1})\n  call assert_equal('F2', bufname(l.items[2].bufnr))\n  call assert_equal(30, l.items[2].lnum)\n  call g:Xsetlist([], 'r', {'items' : [{'filename':'F3', 'lnum':40}]})\n  let l = g:Xgetlist({'items':1})\n  call assert_equal('F3', bufname(l.items[0].bufnr))\n  call assert_equal(40, l.items[0].lnum)\n  call g:Xsetlist([], 'r', {'items' : []})\n  let l = g:Xgetlist({'items':1})\n  call assert_equal(0, len(l.items))\n\n  call g:Xsetlist([], 'r', {'title' : 'TestTitle'})\n  call g:Xsetlist([], 'r', {'items' : [{'filename' : 'F1', 'lnum' : 10, 'text' : 'L10'}]})\n  call g:Xsetlist([], 'r', {'items' : [{'filename' : 'F1', 'lnum' : 10, 'text' : 'L10'}]})\n  call assert_equal('TestTitle', g:Xgetlist({'title' : 1}).title)\n\n  \" Test for getting id of window associated with a location list window\n  if a:cchar == 'l'\n    only\n    call assert_equal(0, g:Xgetlist({'all' : 1}).filewinid)\n    let wid = win_getid()\n    Xopen\n    call assert_equal(wid, g:Xgetlist({'filewinid' : 1}).filewinid)\n    wincmd w\n    call assert_equal(0, g:Xgetlist({'filewinid' : 1}).filewinid)\n    only\n  endif\n\n  \" The following used to crash Vim with address sanitizer\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], 'a', {'items' : [{'filename':'F1', 'lnum':10}]})\n  call assert_equal(10, g:Xgetlist({'items':1}).items[0].lnum)\n\n  \" Try setting the items using a string\n  call assert_equal(-1, g:Xsetlist([], ' ', {'items' : 'Test'}))\n\n  \" Save and restore the quickfix stack\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'nr':'$'}).nr)\n  Xexpr \"File1:10:Line1\"\n  Xexpr \"File2:20:Line2\"\n  Xexpr \"File3:30:Line3\"\n  let last_qf = g:Xgetlist({'nr':'$'}).nr\n  call assert_equal(3, last_qf)\n  let qstack = []\n  for i in range(1, last_qf)\n    let qstack = add(qstack, g:Xgetlist({'nr':i, 'all':1}))\n  endfor\n  call g:Xsetlist([], 'f')\n  for i in range(len(qstack))\n    call g:Xsetlist([], ' ', qstack[i])\n  endfor\n  call assert_equal(3, g:Xgetlist({'nr':'$'}).nr)\n  call assert_equal(10, g:Xgetlist({'nr':1, 'items':1}).items[0].lnum)\n  call assert_equal(20, g:Xgetlist({'nr':2, 'items':1}).items[0].lnum)\n  call assert_equal(30, g:Xgetlist({'nr':3, 'items':1}).items[0].lnum)\n  call g:Xsetlist([], 'f')\n\n  \" Swap two quickfix lists\n  Xexpr \"File1:10:Line10\"\n  Xexpr \"File2:20:Line20\"\n  Xexpr \"File3:30:Line30\"\n  call g:Xsetlist([], 'r', {'nr':1,'title':'Colors','context':['Colors']})\n  call g:Xsetlist([], 'r', {'nr':2,'title':'Fruits','context':['Fruits']})\n  let l1=g:Xgetlist({'nr':1,'all':1})\n  let l2=g:Xgetlist({'nr':2,'all':1})\n  let save_id = l1.id\n  let l1.id=l2.id\n  let l2.id=save_id\n  call g:Xsetlist([], 'r', l1)\n  call g:Xsetlist([], 'r', l2)\n  let newl1=g:Xgetlist({'nr':1,'all':1})\n  let newl2=g:Xgetlist({'nr':2,'all':1})\n  call assert_equal('Fruits', newl1.title)\n  call assert_equal(['Fruits'], newl1.context)\n  call assert_equal('Line20', newl1.items[0].text)\n  call assert_equal('Colors', newl2.title)\n  call assert_equal(['Colors'], newl2.context)\n  call assert_equal('Line10', newl2.items[0].text)\n  call g:Xsetlist([], 'f')\n\n  \" Cannot specify both a non-empty list argument and a dict argument\n  call assert_fails(\"call g:Xsetlist([{}], ' ', {})\", 'E475:')\nendfunc\n\nfunc Test_qf_property()\n  call Xproperty_tests('c')\n  call Xproperty_tests('l')\nendfunc\n\n\" Test for setting the current index in the location/quickfix list\nfunc Xtest_setqfidx(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xgetexpr \"F1:10:1:Line1\\nF2:20:2:Line2\\nF3:30:3:Line3\"\n  Xgetexpr \"F4:10:1:Line1\\nF5:20:2:Line2\\nF6:30:3:Line3\"\n  Xgetexpr \"F7:10:1:Line1\\nF8:20:2:Line2\\nF9:30:3:Line3\"\n\n  call g:Xsetlist([], 'a', {'nr' : 3, 'idx' : 2})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'idx' : 2})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 3})\n  Xolder 2\n  Xopen\n  call assert_equal(3, line('.'))\n  Xnewer\n  call assert_equal(2, line('.'))\n  Xnewer\n  call assert_equal(2, line('.'))\n  \" Update the current index with the quickfix window open\n  wincmd w\n  call g:Xsetlist([], 'a', {'nr' : 3, 'idx' : 3})\n  Xopen\n  call assert_equal(3, line('.'))\n  Xclose\n\n  \" Set the current index to the last entry\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : '$'})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  \" A large value should set the index to the last index\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 1})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 999})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  \" Invalid index values\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : -1})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 0})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  call g:Xsetlist([], 'a', {'nr' : 1, 'idx' : 'xx'})\n  call assert_equal(3, g:Xgetlist({'nr' : 1, 'idx' : 0}).idx)\n  call assert_fails(\"call g:Xsetlist([], 'a', {'nr':1, 'idx':[]})\", 'E745:')\n\n  call g:Xsetlist([], 'f')\n  new | only\nendfunc\n\nfunc Test_setqfidx()\n  call Xtest_setqfidx('c')\n  call Xtest_setqfidx('l')\nendfunc\n\n\" Tests for the QuickFixCmdPre/QuickFixCmdPost autocommands\nfunc QfAutoCmdHandler(loc, cmd)\n  call add(g:acmds, a:loc . a:cmd)\nendfunc\n\nfunc Test_Autocmd()\n  autocmd QuickFixCmdPre * call QfAutoCmdHandler('pre', expand('<amatch>'))\n  autocmd QuickFixCmdPost * call QfAutoCmdHandler('post', expand('<amatch>'))\n\n  let g:acmds = []\n  cexpr \"F1:10:Line 10\"\n  caddexpr \"F1:20:Line 20\"\n  cgetexpr \"F1:30:Line 30\"\n  cexpr \"\"\n  caddexpr \"\"\n  cgetexpr \"\"\n  silent! cexpr non_existing_func()\n  silent! caddexpr non_existing_func()\n  silent! cgetexpr non_existing_func()\n  let l = ['precexpr',\n\t      \\ 'postcexpr',\n\t      \\ 'precaddexpr',\n\t      \\ 'postcaddexpr',\n\t      \\ 'precgetexpr',\n\t      \\ 'postcgetexpr',\n\t      \\ 'precexpr',\n\t      \\ 'postcexpr',\n\t      \\ 'precaddexpr',\n\t      \\ 'postcaddexpr',\n\t      \\ 'precgetexpr',\n\t      \\ 'postcgetexpr',\n\t      \\ 'precexpr',\n\t      \\ 'precaddexpr',\n\t      \\ 'precgetexpr']\n  call assert_equal(l, g:acmds)\n\n  let g:acmds = []\n  enew! | call append(0, \"F2:10:Line 10\")\n  cbuffer!\n  enew! | call append(0, \"F2:20:Line 20\")\n  cgetbuffer\n  enew! | call append(0, \"F2:30:Line 30\")\n  caddbuffer\n  new\n  let bnum = bufnr('%')\n  bunload\n  exe 'silent! cbuffer! ' . bnum\n  exe 'silent! cgetbuffer ' . bnum\n  exe 'silent! caddbuffer ' . bnum\n  enew!\n  let l = ['precbuffer',\n\t      \\ 'postcbuffer',\n\t      \\ 'precgetbuffer',\n\t      \\ 'postcgetbuffer',\n\t      \\ 'precaddbuffer',\n\t      \\ 'postcaddbuffer',\n\t      \\ 'precbuffer',\n\t      \\ 'precgetbuffer',\n\t      \\ 'precaddbuffer']\n  call assert_equal(l, g:acmds)\n\n  call writefile(['Xtest:1:Line1'], 'Xtest')\n  call writefile([], 'Xempty')\n  let g:acmds = []\n  cfile Xtest\n  caddfile Xtest\n  cgetfile Xtest\n  cfile Xempty\n  caddfile Xempty\n  cgetfile Xempty\n  silent! cfile do_not_exist\n  silent! caddfile do_not_exist\n  silent! cgetfile do_not_exist\n  let l = ['precfile',\n\t      \\ 'postcfile',\n\t      \\ 'precaddfile',\n\t      \\ 'postcaddfile',\n\t      \\ 'precgetfile',\n\t      \\ 'postcgetfile',\n\t      \\ 'precfile',\n\t      \\ 'postcfile',\n\t      \\ 'precaddfile',\n\t      \\ 'postcaddfile',\n\t      \\ 'precgetfile',\n\t      \\ 'postcgetfile',\n\t      \\ 'precfile',\n\t      \\ 'postcfile',\n\t      \\ 'precaddfile',\n\t      \\ 'postcaddfile',\n\t      \\ 'precgetfile',\n\t      \\ 'postcgetfile']\n  call assert_equal(l, g:acmds)\n\n  let g:acmds = []\n  helpgrep quickfix\n  silent! helpgrep non_existing_help_topic\n  vimgrep test Xtest\n  vimgrepadd test Xtest\n  silent! vimgrep non_existing_test Xtest\n  silent! vimgrepadd non_existing_test Xtest\n  set makeprg=\n  silent! make\n  set makeprg&\n  let l = ['prehelpgrep',\n\t      \\ 'posthelpgrep',\n\t      \\ 'prehelpgrep',\n\t      \\ 'posthelpgrep',\n\t      \\ 'previmgrep',\n\t      \\ 'postvimgrep',\n\t      \\ 'previmgrepadd',\n\t      \\ 'postvimgrepadd',\n\t      \\ 'previmgrep',\n\t      \\ 'postvimgrep',\n\t      \\ 'previmgrepadd',\n\t      \\ 'postvimgrepadd',\n\t      \\ 'premake',\n\t      \\ 'postmake']\n  call assert_equal(l, g:acmds)\n\n  if has('unix')\n    \" Run this test only on Unix-like systems. The grepprg may not be set on\n    \" non-Unix systems.\n    \" The following lines are used for the grep test. Don't remove.\n    \" Grep_Autocmd_Text: Match 1\n    \" GrepAdd_Autocmd_Text: Match 2\n    let g:acmds = []\n    silent grep Grep_Autocmd_Text test_quickfix.vim\n    silent grepadd GrepAdd_Autocmd_Text test_quickfix.vim\n    silent grep abc123def Xtest\n    silent grepadd abc123def Xtest\n    set grepprg=internal\n    silent grep Grep_Autocmd_Text test_quickfix.vim\n    silent grepadd GrepAdd_Autocmd_Text test_quickfix.vim\n    silent lgrep Grep_Autocmd_Text test_quickfix.vim\n    silent lgrepadd GrepAdd_Autocmd_Text test_quickfix.vim\n    set grepprg&vim\n    let l = ['pregrep',\n\t\t\\ 'postgrep',\n\t\t\\ 'pregrepadd',\n\t\t\\ 'postgrepadd',\n\t\t\\ 'pregrep',\n\t\t\\ 'postgrep',\n\t\t\\ 'pregrepadd',\n\t\t\\ 'postgrepadd',\n\t\t\\ 'pregrep',\n\t\t\\ 'postgrep',\n\t\t\\ 'pregrepadd',\n\t\t\\ 'postgrepadd',\n\t\t\\ 'prelgrep',\n\t\t\\ 'postlgrep',\n\t\t\\ 'prelgrepadd',\n\t\t\\ 'postlgrepadd']\n    call assert_equal(l, g:acmds)\n  endif\n\n  call delete('Xtest')\n  call delete('Xempty')\n  au! QuickFixCmdPre\n  au! QuickFixCmdPost\nendfunc\n\nfunc Test_Autocmd_Exception()\n  set efm=%m\n  lgetexpr '?'\n\n  try\n    call DoesNotExit()\n  catch\n    lgetexpr '1'\n  finally\n    lgetexpr '1'\n  endtry\n\n  call assert_equal('1', getloclist(0)[0].text)\n\n  set efm&vim\nendfunc\n\nfunc Test_caddbuffer_wrong()\n  \" This used to cause a memory access in freed memory.\n  let save_efm = &efm\n  set efm=%EEEE%m,%WWWW,%+CCCC%>%#,%GGGG%.#\n  cgetexpr ['WWWW', 'EEEE', 'CCCC']\n  let &efm = save_efm\n  caddbuffer\n  bwipe!\nendfunc\n\nfunc Test_caddexpr_wrong()\n  \" This used to cause a memory access in freed memory.\n  cbuffer\n  cbuffer\n  copen\n  let save_efm = &efm\n  set efm=%\n  call assert_fails('caddexpr \"\"', 'E376:')\n  let &efm = save_efm\nendfunc\n\nfunc Test_dirstack_cleanup()\n  \" This used to cause a memory access in freed memory.\n  let save_efm = &efm\n  lexpr '0'\n  lopen\n  fun X(c)\n    let save_efm=&efm\n    set efm=%D%f\n    if a:c == 'c'\n      caddexpr '::'\n    else\n      laddexpr ':0:0'\n    endif\n    let &efm=save_efm\n  endfun\n  call X('c')\n  call X('l')\n  call setqflist([], 'r')\n  caddbuffer\n  let &efm = save_efm\nendfunc\n\n\" Tests for jumping to entries from the location list window and quickfix\n\" window\nfunc Test_cwindow_jump()\n  set efm=%f%%%l%%%m\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen | only\n  lfirst\n  call assert_true(winnr('$') == 2)\n  call assert_true(winnr() == 1)\n  \" Location list for the new window should be set\n  call assert_true(getloclist(0)[2].text == 'Line 30')\n\n  \" Open a scratch buffer\n  \" Open a new window and create a location list\n  \" Open the location list window and close the other window\n  \" Jump to an entry.\n  \" Should create a new window and jump to the entry. The scratch buffer\n  \" should not be used.\n  enew | only\n  set buftype=nofile\n  below new\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen\n  2wincmd c\n  lnext\n  call assert_true(winnr('$') == 3)\n  call assert_true(winnr() == 2)\n\n  \" Open two windows with two different location lists\n  \" Open the location list window and close the previous window\n  \" Jump to an entry in the location list window\n  \" Should open the file in the first window and not set the location list.\n  enew | only\n  lgetexpr [\"F1%5%Line 5\"]\n  below new\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen\n  2wincmd c\n  lnext\n  call assert_true(winnr() == 1)\n  call assert_true(getloclist(0)[0].text == 'Line 5')\n\n  enew | only\n  cgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  copen\n  cnext\n  call assert_true(winnr('$') == 2)\n  call assert_true(winnr() == 1)\n\n  \" open the quickfix buffer in two windows and jump to an entry. Should open\n  \" the file in the first quickfix window.\n  enew | only\n  copen\n  let bnum = bufnr('')\n  exe 'sbuffer ' . bnum\n  wincmd b\n  cfirst\n  call assert_equal(2, winnr())\n  call assert_equal('F1', @%)\n  enew | only\n  exe 'sb' bnum\n  exe 'botright sb' bnum\n  wincmd t\n  clast\n  call assert_equal(2, winnr())\n  call assert_equal('quickfix', getwinvar(1, '&buftype'))\n  call assert_equal('quickfix', getwinvar(3, '&buftype'))\n\n  \" Jumping to a file from the location list window should find a usable\n  \" window by wrapping around the window list.\n  enew | only\n  call setloclist(0, [], 'f')\n  new | new\n  lgetexpr [\"F1%10%Line 10\", \"F2%20%Line 20\", \"F3%30%Line 30\"]\n  lopen\n  1close\n  call assert_equal(0, getloclist(3, {'id' : 0}).id)\n  lnext\n  call assert_equal(3, winnr())\n  call assert_equal(getloclist(1, {'id' : 0}).id, getloclist(3, {'id' : 0}).id)\n\n  enew | only\n  set efm&vim\nendfunc\n\nfunc Test_cwindow_highlight()\n  CheckScreendump\n\n  let lines =<< trim END\n\tcall setline(1, ['some', 'text', 'with', 'matches'])\n\twrite XCwindow\n\tvimgrep e XCwindow\n\tredraw\n\tcwindow 4\n  END\n  call writefile(lines, 'XtestCwindow')\n  let buf = RunVimInTerminal('-S XtestCwindow', #{rows: 12})\n  call VerifyScreenDump(buf, 'Test_quickfix_cwindow_1', {})\n\n  call term_sendkeys(buf, \":cnext\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_quickfix_cwindow_2', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XtestCwindow')\n  call delete('XCwindow')\nendfunc\n\nfunc XvimgrepTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call writefile(['Editor:VIM vim',\n\t      \\ 'Editor:Emacs EmAcS',\n\t      \\ 'Editor:Notepad NOTEPAD'], 'Xtestfile1')\n  call writefile(['Linux', 'macOS', 'MS-Windows'], 'Xtestfile2')\n\n  \" Error cases\n  call assert_fails('Xvimgrep /abc *', 'E682:')\n\n  let @/=''\n  call assert_fails('Xvimgrep // *', 'E35:')\n\n  call assert_fails('Xvimgrep abc', 'E683:')\n  call assert_fails('Xvimgrep a1b2c3 Xtestfile1', 'E480:')\n  call assert_fails('Xvimgrep pat Xa1b2c3', 'E480:')\n\n  Xexpr \"\"\n  Xvimgrepadd Notepad Xtestfile1\n  Xvimgrepadd macOS Xtestfile2\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal('Editor:Notepad NOTEPAD', l[0].text)\n\n  10Xvimgrep #\\cvim#g Xtestfile?\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal(8, l[0].col)\n  call assert_equal(11, l[0].end_col)\n  call assert_equal(12, l[1].col)\n  call assert_equal(15, l[1].end_col)\n\n  1Xvimgrep ?Editor? Xtestfile*\n  let l = g:Xgetlist()\n  call assert_equal(1, len(l))\n  call assert_equal('Editor:VIM vim', l[0].text)\n\n  edit +3 Xtestfile2\n  Xvimgrep +\\cemacs+j Xtestfile1\n  let l = g:Xgetlist()\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal('Editor:Emacs EmAcS', l[0].text)\n\n  \" Test for unloading a buffer after vimgrep searched the buffer\n  %bwipe\n  Xvimgrep /Editor/j Xtestfile*\n  call assert_equal(0, getbufinfo('Xtestfile1')[0].loaded)\n  call assert_equal([], getbufinfo('Xtestfile2'))\n\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\n\" Tests for the :vimgrep command\nfunc Test_vimgrep()\n  call XvimgrepTests('c')\n  call XvimgrepTests('l')\nendfunc\n\nfunc Test_vimgrep_wildcards_expanded_once()\n  new X[id-01] file.txt\n  call setline(1, 'some text to search for')\n  vimgrep text %\n  bwipe!\nendfunc\n\n\" Test for incsearch highlighting of the :vimgrep pattern\n\" This test used to cause \"E315: ml_get: invalid lnum\" errors.\nfunc Test_vimgrep_incsearch()\n  enew\n  set incsearch\n  call test_override(\"char_avail\", 1)\n\n  call feedkeys(\":2vimgrep assert test_quickfix.vim test_cdo.vim\\<CR>\", \"ntx\")\n  let l = getqflist()\n  call assert_equal(2, len(l))\n\n  call test_override(\"ALL\", 0)\n  set noincsearch\nendfunc\n\n\" Test vimgrep with the last search pattern not set\nfunc Test_vimgrep_with_no_last_search_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails('vimgrep // *', 'E35:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test vimgrep without swap file\nfunc Test_vimgrep_without_swap_file()\n  let lines =<< trim [SCRIPT]\n    vimgrep grep test_c*\n    call writefile(['done'], 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -n -S Xscript Xscript')\n    call assert_equal(['done'], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\nfunc Test_vimgrep_existing_swapfile()\n  call writefile(['match apple with apple'], 'Xapple')\n  call writefile(['swapfile'], '.Xapple.swp')\n  let g:foundSwap = 0\n  let g:ignoreSwapExists = 1\n  augroup grep\n    au SwapExists * let foundSwap = 1 | let v:swapchoice = 'e'\n  augroup END\n  vimgrep apple Xapple\n  call assert_equal(1, g:foundSwap)\n  call assert_match('.Xapple.swo', swapname(''))\n\n  call delete('Xapple')\n  call delete('.Xapple.swp')\n  augroup grep\n    au! SwapExists\n  augroup END\n  unlet g:ignoreSwapExists\nendfunc\n\nfunc XfreeTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  enew | only\n\n  \" Deleting the quickfix stack should work even When the current list is\n  \" somewhere in the middle of the stack\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']\n  Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']\n  Xolder\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, len(g:Xgetlist()))\n\n  \" After deleting the stack, adding a new list should create a stack with a\n  \" single list.\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  call assert_equal(1, g:Xgetlist({'all':1}).nr)\n\n  \" Deleting the stack from a quickfix window should update/clear the\n  \" quickfix/location list window.\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']\n  Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']\n  Xolder\n  Xwindow\n  call g:Xsetlist([], 'f')\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, line('$'))\n  Xclose\n\n  \" Deleting the stack from a non-quickfix window should update/clear the\n  \" quickfix/location list window.\n  Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n  Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']\n  Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']\n  Xolder\n  Xwindow\n  wincmd p\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, len(g:Xgetlist()))\n  wincmd p\n  call assert_equal(2, winnr('$'))\n  call assert_equal(1, line('$'))\n\n  \" After deleting the location list stack, if the location list window is\n  \" opened, then a new location list should be created. So opening the\n  \" location list window again should not create a new window.\n  if a:cchar == 'l'\n      lexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']\n      wincmd p\n      lopen\n      call assert_equal(2, winnr('$'))\n  endif\n  Xclose\nendfunc\n\n\" Tests for the quickfix free functionality\nfunc Test_qf_free()\n  call XfreeTests('c')\n  call XfreeTests('l')\nendfunc\n\n\" Test for buffer overflow when parsing lines and adding new entries to\n\" the quickfix list.\nfunc Test_bufoverflow()\n  set efm=%f:%l:%m\n  cgetexpr ['File1:100:' . repeat('x', 1025)]\n\n  set efm=%+GCompiler:\\ %.%#,%f:%l:%m\n  cgetexpr ['Compiler: ' . repeat('a', 1015), 'File1:10:Hello World']\n\n  set efm=%DEntering\\ directory\\ %f,%f:%l:%m\n  cgetexpr ['Entering directory ' . repeat('a', 1006),\n\t      \\ 'File1:10:Hello World']\n  set efm&vim\nendfunc\n\n\" Tests for getting the quickfix stack size\nfunc XsizeTests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'nr':'$'}).nr)\n  call assert_equal('', g:Xgetlist({'nr':'$', 'all':1}).title)\n  call assert_equal(0, g:Xgetlist({'nr':0}).nr)\n\n  Xexpr \"File1:10:Line1\"\n  Xexpr \"File2:20:Line2\"\n  Xexpr \"File3:30:Line3\"\n  Xolder | Xolder\n  call assert_equal(3, g:Xgetlist({'nr':'$'}).nr)\n  call g:Xsetlist([], 'f')\n\n  Xexpr \"File1:10:Line1\"\n  Xexpr \"File2:20:Line2\"\n  Xexpr \"File3:30:Line3\"\n  Xolder | Xolder\n  call g:Xsetlist([], 'a', {'nr':'$', 'title':'Compiler'})\n  call assert_equal('Compiler', g:Xgetlist({'nr':3, 'all':1}).title)\nendfunc\n\nfunc Test_Qf_Size()\n  call XsizeTests('c')\n  call XsizeTests('l')\nendfunc\n\nfunc Test_cclose_from_copen()\n    augroup QF_Test\n\tau!\n        au FileType qf :call assert_fails(':cclose', 'E788:')\n    augroup END\n    copen\n    augroup QF_Test\n\tau!\n    augroup END\n    augroup! QF_Test\nendfunc\n\nfunc Test_cclose_in_autocmd()\n  \" Problem is only triggered if \"starting\" is zero, so that the OptionsSet\n  \" event will be triggered.\n  call test_override('starting', 1)\n  augroup QF_Test\n    au!\n    au FileType qf :call assert_fails(':cclose', 'E788:')\n  augroup END\n  copen\n  augroup QF_Test\n    au!\n  augroup END\n  augroup! QF_Test\n  call test_override('starting', 0)\nendfunc\n\n\" Check that \":file\" without an argument is possible even when \"curbuf_lock\"\n\" is set.\nfunc Test_file_from_copen()\n  \" Works without argument.\n  augroup QF_Test\n    au!\n    au FileType qf file\n  augroup END\n  copen\n\n  augroup QF_Test\n    au!\n  augroup END\n  cclose\n\n  \" Fails with argument.\n  augroup QF_Test\n    au!\n    au FileType qf call assert_fails(':file foo', 'E788:')\n  augroup END\n  copen\n  augroup QF_Test\n    au!\n  augroup END\n  cclose\n\n  augroup! QF_Test\nendfunc\n\nfunc Test_resize_from_copen()\n  augroup QF_Test\n    au!\n    au FileType qf resize 5\n  augroup END\n  try\n    \" This should succeed without any exception.  No other buffers are\n    \" involved in the autocmd.\n    copen\n  finally\n    augroup QF_Test\n      au!\n    augroup END\n    augroup! QF_Test\n  endtry\nendfunc\n\nfunc Test_vimgrep_with_textlock()\n  new\n\n  \" Simple way to execute something with \"textwinlock\" set.\n  \" Check that vimgrep without jumping can be executed.\n  au InsertCharPre * vimgrep /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getqflist()\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setqflist([], 'r')\n  au! InsertCharPre\n\n  \" Check that vimgrepadd without jumping can be executed.\n  au InsertCharPre * vimgrepadd /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getqflist()\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setqflist([], 'r')\n  au! InsertCharPre\n\n  \" Check that lvimgrep without jumping can be executed.\n  au InsertCharPre * lvimgrep /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getloclist(0)\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setloclist(0, [], 'r')\n  au! InsertCharPre\n\n  \" Check that lvimgrepadd without jumping can be executed.\n  au InsertCharPre * lvimgrepadd /RunTheTest/j runtest.vim\n  normal ax\n  let qflist = getloclist(0)\n  call assert_true(len(qflist) > 0)\n  call assert_match('RunTheTest', qflist[0].text)\n  call setloclist(0, [], 'r')\n  au! InsertCharPre\n\n  \" trying to jump will give an error\n  au InsertCharPre * vimgrep /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  au InsertCharPre * vimgrepadd /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  au InsertCharPre * lvimgrep /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  au InsertCharPre * lvimgrepadd /RunTheTest/ runtest.vim\n  call assert_fails('normal ax', 'E565:')\n  au! InsertCharPre\n\n  bwipe!\nendfunc\n\n\" Tests for the quickfix buffer b:changedtick variable\nfunc Xchangedtick_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  new | only\n\n  Xexpr \"\" | Xexpr \"\" | Xexpr \"\"\n\n  Xopen\n  Xolder\n  Xolder\n  Xaddexpr \"F1:10:Line10\"\n  Xaddexpr \"F2:20:Line20\"\n  call g:Xsetlist([{\"filename\":\"F3\", \"lnum\":30, \"text\":\"Line30\"}], 'a')\n  call g:Xsetlist([], 'f')\n  call assert_equal(8, getbufvar('%', 'changedtick'))\n  Xclose\nendfunc\n\nfunc Test_changedtick()\n  call Xchangedtick_tests('c')\n  call Xchangedtick_tests('l')\nendfunc\n\n\" Tests for parsing an expression using setqflist()\nfunc Xsetexpr_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  let t = [\"File1:10:Line10\", \"File1:20:Line20\"]\n  call g:Xsetlist([], ' ', {'lines' : t})\n  call g:Xsetlist([], 'a', {'lines' : [\"File1:30:Line30\"]})\n\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  call assert_equal(20, l[1].lnum)\n  call assert_equal('Line30', l[2].text)\n  call g:Xsetlist([], 'r', {'lines' : [\"File2:5:Line5\"]})\n  let l = g:Xgetlist()\n  call assert_equal(1, len(l))\n  call assert_equal('Line5', l[0].text)\n  call assert_equal(-1, g:Xsetlist([], 'a', {'lines' : 10}))\n  call assert_equal(-1, g:Xsetlist([], 'a', {'lines' : \"F1:10:L10\"}))\n\n  call g:Xsetlist([], 'f')\n  \" Add entries to multiple lists\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"File1:10:Line10\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"File2:20:Line20\"]})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"File1:15:Line15\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"File2:25:Line25\"]})\n  call assert_equal('Line15', g:Xgetlist({'nr':1, 'items':1}).items[1].text)\n  call assert_equal('Line25', g:Xgetlist({'nr':2, 'items':1}).items[1].text)\n\n  \" Adding entries using a custom efm\n  set efm&\n  call g:Xsetlist([], ' ', {'efm' : '%f#%l#%m',\n\t\t\t\t\\ 'lines' : [\"F1#10#L10\", \"F2#20#L20\"]})\n  call assert_equal(20, g:Xgetlist({'items':1}).items[1].lnum)\n  call g:Xsetlist([], 'a', {'efm' : '%f#%l#%m', 'lines' : [\"F3:30:L30\"]})\n  call assert_equal('F3:30:L30', g:Xgetlist({'items':1}).items[2].text)\n  call assert_equal(20, g:Xgetlist({'items':1}).items[1].lnum)\n  call assert_equal(-1, g:Xsetlist([], 'a', {'efm' : [],\n\t\t\t\t\\ 'lines' : ['F1:10:L10']}))\nendfunc\n\nfunc Test_setexpr()\n  call Xsetexpr_tests('c')\n  call Xsetexpr_tests('l')\nendfunc\n\n\" Tests for per quickfix/location list directory stack\nfunc Xmultidirstack_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  Xexpr \"\" | Xexpr \"\"\n\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"Entering dir 'Xone/a'\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"Entering dir 'Xtwo/a'\"]})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"one.txt:3:one one one\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"two.txt:5:two two two\"]})\n\n  let l1 = g:Xgetlist({'nr':1, 'items':1})\n  let l2 = g:Xgetlist({'nr':2, 'items':1})\n  call assert_equal('Xone/a/one.txt', bufname(l1.items[1].bufnr))\n  call assert_equal(3, l1.items[1].lnum)\n  call assert_equal('Xtwo/a/two.txt', bufname(l2.items[1].bufnr))\n  call assert_equal(5, l2.items[1].lnum)\nendfunc\n\nfunc Test_multidirstack()\n  call mkdir('Xone/a', 'p')\n  call mkdir('Xtwo/a', 'p')\n  let lines = ['1', '2', 'one one one', '4', 'two two two', '6', '7']\n  call writefile(lines, 'Xone/a/one.txt')\n  call writefile(lines, 'Xtwo/a/two.txt')\n  let save_efm = &efm\n  set efm=%DEntering\\ dir\\ '%f',%f:%l:%m,%XLeaving\\ dir\\ '%f'\n\n  call Xmultidirstack_tests('c')\n  call Xmultidirstack_tests('l')\n\n  let &efm = save_efm\n  call delete('Xone', 'rf')\n  call delete('Xtwo', 'rf')\nendfunc\n\n\" Tests for per quickfix/location list file stack\nfunc Xmultifilestack_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  Xexpr \"\" | Xexpr \"\"\n\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"[one.txt]\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"[two.txt]\"]})\n  call g:Xsetlist([], 'a', {'nr' : 1, 'lines' : [\"(3,5) one one one\"]})\n  call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : [\"(5,9) two two two\"]})\n\n  let l1 = g:Xgetlist({'nr':1, 'items':1})\n  let l2 = g:Xgetlist({'nr':2, 'items':1})\n  call assert_equal('one.txt', bufname(l1.items[1].bufnr))\n  call assert_equal(3, l1.items[1].lnum)\n  call assert_equal('two.txt', bufname(l2.items[1].bufnr))\n  call assert_equal(5, l2.items[1].lnum)\n\n  \" Test for start of a new error line in the same line where a previous\n  \" error line ends with a file stack.\n  let efm_val = 'Error\\ l%l\\ in\\ %f,'\n  let efm_val .= '%-P%>(%f%r,Error\\ l%l\\ in\\ %m,%-Q)%r'\n  let l = g:Xgetlist({'lines' : [\n\t      \\ '(one.txt',\n\t      \\ 'Error l4 in one.txt',\n\t      \\ ') (two.txt',\n\t      \\ 'Error l6 in two.txt',\n\t      \\ ')',\n\t      \\ 'Error l8 in one.txt'\n\t      \\ ], 'efm' : efm_val})\n  call assert_equal(3, len(l.items))\n  call assert_equal('one.txt', bufname(l.items[0].bufnr))\n  call assert_equal(4, l.items[0].lnum)\n  call assert_equal('one.txt', l.items[0].text)\n  call assert_equal('two.txt', bufname(l.items[1].bufnr))\n  call assert_equal(6, l.items[1].lnum)\n  call assert_equal('two.txt', l.items[1].text)\n  call assert_equal('one.txt', bufname(l.items[2].bufnr))\n  call assert_equal(8, l.items[2].lnum)\n  call assert_equal('', l.items[2].text)\nendfunc\n\nfunc Test_multifilestack()\n  let lines = ['1', '2', 'one one one', '4', 'two two two', '6', '7']\n  call writefile(lines, 'one.txt')\n  call writefile(lines, 'two.txt')\n  let save_efm = &efm\n  set efm=%+P[%f],(%l\\\\,%c)\\ %m,%-Q\n\n  call Xmultifilestack_tests('c')\n  call Xmultifilestack_tests('l')\n\n  let &efm = save_efm\n  call delete('one.txt')\n  call delete('two.txt')\nendfunc\n\n\" Tests for per buffer 'efm' setting\nfunc Test_perbuf_efm()\n  call writefile([\"File1-10-Line10\"], 'one.txt')\n  call writefile([\"File2#20#Line20\"], 'two.txt')\n  set efm=%f#%l#%m\n  new | only\n  new\n  setlocal efm=%f-%l-%m\n  cfile one.txt\n  wincmd w\n  caddfile two.txt\n\n  let l = getqflist()\n  call assert_equal(10, l[0].lnum)\n  call assert_equal('Line20', l[1].text)\n\n  set efm&\n  new | only\n  call delete('one.txt')\n  call delete('two.txt')\nendfunc\n\n\" Open multiple help windows using \":lhelpgrep\n\" This test used to crash Vim\nfunc Test_Multi_LL_Help()\n  new | only\n  lhelpgrep window\n  lopen\n  e#\n  lhelpgrep buffer\n  call assert_equal(3, winnr('$'))\n  call assert_true(len(getloclist(1)) != 0)\n  call assert_true(len(getloclist(2)) != 0)\n  new | only\nendfunc\n\n\" Tests for adding new quickfix lists using setqflist()\nfunc XaddQf_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Create a new list using ' ' for action\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], ' ', {'title' : 'Test1'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test1', l.title)\n\n  \" Create a new list using ' ' for action and '$' for 'nr'\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], ' ', {'title' : 'Test2', 'nr' : '$'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test2', l.title)\n\n  \" Create a new list using 'a' for action\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], 'a', {'title' : 'Test3'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test3', l.title)\n\n  \" Create a new list using 'a' for action and '$' for 'nr'\n  call g:Xsetlist([], 'f')\n  call g:Xsetlist([], 'a', {'title' : 'Test3', 'nr' : '$'})\n  call g:Xsetlist([], 'a', {'title' : 'Test4'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(1, l.nr)\n  call assert_equal('Test4', l.title)\n\n  \" Adding a quickfix list should remove all the lists following the current\n  \" list.\n  Xexpr \"\" | Xexpr \"\" | Xexpr \"\"\n  silent! 10Xolder\n  call g:Xsetlist([], ' ', {'title' : 'Test5'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(2, l.nr)\n  call assert_equal('Test5', l.title)\n\n  \" Add a quickfix list using '$' as the list number.\n  let lastqf = g:Xgetlist({'nr':'$'}).nr\n  silent! 99Xolder\n  call g:Xsetlist([], ' ', {'nr' : '$', 'title' : 'Test6'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(lastqf + 1, l.nr)\n  call assert_equal('Test6', l.title)\n\n  \" Add a quickfix list using 'nr' set to one more than the quickfix\n  \" list size.\n  let lastqf = g:Xgetlist({'nr':'$'}).nr\n  silent! 99Xolder\n  call g:Xsetlist([], ' ', {'nr' : lastqf + 1, 'title' : 'Test7'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(lastqf + 1, l.nr)\n  call assert_equal('Test7', l.title)\n\n  \" Add a quickfix list to a stack with 10 lists using 'nr' set to '$'\n  exe repeat('Xexpr \"\" |', 9) . 'Xexpr \"\"'\n  silent! 99Xolder\n  call g:Xsetlist([], ' ', {'nr' : '$', 'title' : 'Test8'})\n  let l = g:Xgetlist({'nr' : '$', 'all' : 1})\n  call assert_equal(10, l.nr)\n  call assert_equal('Test8', l.title)\n\n  \" Add a quickfix list using 'nr' set to a value greater than 10\n  call assert_equal(-1, g:Xsetlist([], ' ', {'nr' : 12, 'title' : 'Test9'}))\n\n  \" Try adding a quickfix list with 'nr' set to a value greater than the\n  \" quickfix list size but less than 10.\n  call g:Xsetlist([], 'f')\n  Xexpr \"\" | Xexpr \"\" | Xexpr \"\"\n  silent! 99Xolder\n  call assert_equal(-1, g:Xsetlist([], ' ', {'nr' : 8, 'title' : 'Test10'}))\n\n  \" Add a quickfix list using 'nr' set to a some string or list\n  call assert_equal(-1, g:Xsetlist([], ' ', {'nr' : [1,2], 'title' : 'Test11'}))\nendfunc\n\nfunc Test_add_qf()\n  call XaddQf_tests('c')\n  call XaddQf_tests('l')\nendfunc\n\n\" Test for getting the quickfix list items from some text without modifying\n\" the quickfix stack\nfunc XgetListFromLines(cchar)\n  call s:setup_commands(a:cchar)\n  call g:Xsetlist([], 'f')\n\n  let l = g:Xgetlist({'lines' : [\"File2:20:Line20\", \"File2:30:Line30\"]}).items\n  call assert_equal(2, len(l))\n  call assert_equal(30, l[1].lnum)\n\n  call assert_equal({}, g:Xgetlist({'lines' : 10}))\n  call assert_equal({}, g:Xgetlist({'lines' : 'File1:10:Line10'}))\n  call assert_equal([], g:Xgetlist({'lines' : []}).items)\n  call assert_equal([], g:Xgetlist({'lines' : [10, 20]}).items)\n\n  \" Parse text using a custom efm\n  set efm&\n  let l = g:Xgetlist({'lines':['File3#30#Line30'], 'efm' : '%f#%l#%m'}).items\n  call assert_equal('Line30', l[0].text)\n  let l = g:Xgetlist({'lines':['File3:30:Line30'], 'efm' : '%f-%l-%m'}).items\n  call assert_equal('File3:30:Line30', l[0].text)\n  let l = g:Xgetlist({'lines':['File3:30:Line30'], 'efm' : [1,2]})\n  call assert_equal({}, l)\n  call assert_fails(\"call g:Xgetlist({'lines':['abc'], 'efm':'%2'})\", 'E376:')\n  call assert_fails(\"call g:Xgetlist({'lines':['abc'], 'efm':''})\", 'E378:')\n\n  \" Make sure that the quickfix stack is not modified\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\nendfunc\n\nfunc Test_get_list_from_lines()\n  call XgetListFromLines('c')\n  call XgetListFromLines('l')\nendfunc\n\n\" Tests for the quickfix list id\nfunc Xqfid_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'id':0}).id)\n  Xexpr ''\n  let start_id = g:Xgetlist({'id' : 0}).id\n  Xexpr '' | Xexpr ''\n  Xolder\n  call assert_equal(start_id, g:Xgetlist({'id':0, 'nr':1}).id)\n  call assert_equal(start_id + 1, g:Xgetlist({'id':0, 'nr':0}).id)\n  call assert_equal(start_id + 2, g:Xgetlist({'id':0, 'nr':'$'}).id)\n  call assert_equal(0, g:Xgetlist({'id':0, 'nr':99}).id)\n  call assert_equal(2, g:Xgetlist({'id':start_id + 1, 'nr':0}).nr)\n  call assert_equal(0, g:Xgetlist({'id':99, 'nr':0}).id)\n  call assert_equal(0, g:Xgetlist({'id':\"abc\", 'nr':0}).id)\n\n  call g:Xsetlist([], 'a', {'id':start_id, 'context':[1,2]})\n  call assert_equal([1,2], g:Xgetlist({'nr':1, 'context':1}).context)\n  call g:Xsetlist([], 'a', {'id':start_id+1, 'lines':['F1:10:L10']})\n  call assert_equal('L10', g:Xgetlist({'nr':2, 'items':1}).items[0].text)\n  call assert_equal(-1, g:Xsetlist([], 'a', {'id':999, 'title':'Vim'}))\n  call assert_equal(-1, g:Xsetlist([], 'a', {'id':'abc', 'title':'Vim'}))\n\n  let qfid = g:Xgetlist({'id':0, 'nr':0})\n  call g:Xsetlist([], 'f')\n  call assert_equal(0, g:Xgetlist({'id':qfid, 'nr':0}).id)\nendfunc\n\nfunc Test_qf_id()\n  call Xqfid_tests('c')\n  call Xqfid_tests('l')\nendfunc\n\nfunc Xqfjump_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call writefile([\"Line1\\tFoo\", \"Line2\"], 'F1')\n  call writefile([\"Line1\\tBar\", \"Line2\"], 'F2')\n  call writefile([\"Line1\\tBaz\", \"Line2\"], 'F3')\n\n  call g:Xsetlist([], 'f')\n\n  \" Tests for\n  \"   Jumping to a line using a pattern\n  \"   Jumping to a column greater than the last column in a line\n  \"   Jumping to a line greater than the last line in the file\n  let l = []\n  for i in range(1, 7)\n    call add(l, {})\n  endfor\n  let l[0].filename='F1'\n  let l[0].pattern='Line1'\n  let l[1].filename='F2'\n  let l[1].pattern='Line1'\n  let l[2].filename='F3'\n  let l[2].pattern='Line1'\n  let l[3].filename='F3'\n  let l[3].lnum=1\n  let l[3].col=9\n  let l[3].vcol=1\n  let l[4].filename='F3'\n  let l[4].lnum=99\n  let l[5].filename='F3'\n  let l[5].lnum=1\n  let l[5].col=99\n  let l[5].vcol=1\n  let l[6].filename='F3'\n  let l[6].pattern='abcxyz'\n\n  call g:Xsetlist([], ' ', {'items' : l})\n  Xopen | only\n  2Xnext\n  call assert_equal(3, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal('F3', @%)\n  Xnext\n  call assert_equal(7, col('.'))\n  Xnext\n  call assert_equal(2, line('.'))\n  Xnext\n  call assert_equal(9, col('.'))\n  2\n  Xnext\n  call assert_equal(2, line('.'))\n\n  if a:cchar == 'l'\n    \" When jumping to a location list entry in the location list window and\n    \" no usable windows are available, then a new window should be opened.\n    enew! | new | only\n    call g:Xsetlist([], 'f')\n    setlocal buftype=nofile\n    new\n    call g:Xsetlist([], ' ', {'lines' : ['F1:1:1:Line1', 'F1:2:2:Line2', 'F2:1:1:Line1', 'F2:2:2:Line2', 'F3:1:1:Line1', 'F3:2:2:Line2']})\n    Xopen\n    let winid = win_getid()\n    wincmd p\n    close\n    call win_gotoid(winid)\n    Xnext\n    call assert_equal(3, winnr('$'))\n    call assert_equal(1, winnr())\n    call assert_equal(2, line('.'))\n\n    \" When jumping to an entry in the location list window and the window\n    \" associated with the location list is not present and a window containing\n    \" the file is already present, then that window should be used.\n    close\n    belowright new\n    call g:Xsetlist([], 'f')\n    edit F3\n    call win_gotoid(winid)\n    Xlast\n    call assert_equal(3, winnr())\n    call assert_equal(6, g:Xgetlist({'size' : 1}).size)\n    call assert_equal(winid, g:Xgetlist({'winid' : 1}).winid)\n  endif\n\n  \" Cleanup\n  enew!\n  new | only\n\n  call delete('F1')\n  call delete('F2')\n  call delete('F3')\nendfunc\n\nfunc Test_qfjump()\n  call Xqfjump_tests('c')\n  call Xqfjump_tests('l')\nendfunc\n\n\" Tests for the getqflist() and getloclist() functions when the list is not\n\" present or is empty\nfunc Xgetlist_empty_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Empty quickfix stack\n  call g:Xsetlist([], 'f')\n  call assert_equal('', g:Xgetlist({'context' : 0}).context)\n  call assert_equal(0, g:Xgetlist({'id' : 0}).id)\n  call assert_equal(0, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'items' : 0}).items)\n  call assert_equal(0, g:Xgetlist({'nr' : 0}).nr)\n  call assert_equal(0, g:Xgetlist({'size' : 0}).size)\n  call assert_equal('', g:Xgetlist({'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'winid' : 0}).winid)\n  call assert_equal(0, g:Xgetlist({'changedtick' : 0}).changedtick)\n  if a:cchar == 'c'\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0,\n\t\t  \\ 'items' : [], 'nr' : 0, 'size' : 0, 'qfbufnr' : 0,\n\t\t  \\ 'title' : '', 'winid' : 0, 'changedtick': 0,\n                  \\ 'quickfixtextfunc' : ''}, g:Xgetlist({'all' : 0}))\n  else\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0,\n\t\t\\ 'items' : [], 'nr' : 0, 'size' : 0, 'title' : '',\n\t\t\\ 'winid' : 0, 'changedtick': 0, 'filewinid' : 0,\n\t\t\\ 'qfbufnr' : 0, 'quickfixtextfunc' : ''},\n\t\t\\ g:Xgetlist({'all' : 0}))\n  endif\n\n  \" Quickfix window with empty stack\n  silent! Xopen\n  let qfwinid = (a:cchar == 'c') ? win_getid() : 0\n  let qfbufnr = (a:cchar == 'c') ? bufnr('') : 0\n  call assert_equal(qfwinid, g:Xgetlist({'winid' : 0}).winid)\n  Xclose\n\n  \" Empty quickfix list\n  Xexpr \"\"\n  call assert_equal('', g:Xgetlist({'context' : 0}).context)\n  call assert_notequal(0, g:Xgetlist({'id' : 0}).id)\n  call assert_equal(0, g:Xgetlist({'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'items' : 0}).items)\n  call assert_notequal(0, g:Xgetlist({'nr' : 0}).nr)\n  call assert_equal(0, g:Xgetlist({'size' : 0}).size)\n  call assert_notequal('', g:Xgetlist({'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'winid' : 0}).winid)\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  let qfid = g:Xgetlist({'id' : 0}).id\n  call g:Xsetlist([], 'f')\n\n  \" Non-existing quickfix identifier\n  call assert_equal('', g:Xgetlist({'id' : qfid, 'context' : 0}).context)\n  call assert_equal(0, g:Xgetlist({'id' : qfid}).id)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'id' : qfid, 'items' : 0}).items)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'nr' : 0}).nr)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'size' : 0}).size)\n  call assert_equal('', g:Xgetlist({'id' : qfid, 'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'winid' : 0}).winid)\n  call assert_equal(0, g:Xgetlist({'id' : qfid, 'changedtick' : 0}).changedtick)\n  if a:cchar == 'c'\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'qfbufnr' : qfbufnr, 'quickfixtextfunc' : '',\n\t\t\\ 'changedtick' : 0}, g:Xgetlist({'id' : qfid, 'all' : 0}))\n  else\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'changedtick' : 0, 'filewinid' : 0, 'qfbufnr' : 0,\n                \\ 'quickfixtextfunc' : ''},\n\t\t\\ g:Xgetlist({'id' : qfid, 'all' : 0}))\n  endif\n\n  \" Non-existing quickfix list number\n  call assert_equal('', g:Xgetlist({'nr' : 5, 'context' : 0}).context)\n  call assert_equal(0, g:Xgetlist({'nr' : 5}).nr)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'idx' : 0}).idx)\n  call assert_equal([], g:Xgetlist({'nr' : 5, 'items' : 0}).items)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'id' : 0}).id)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'size' : 0}).size)\n  call assert_equal('', g:Xgetlist({'nr' : 5, 'title' : 0}).title)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'winid' : 0}).winid)\n  call assert_equal(0, g:Xgetlist({'nr' : 5, 'changedtick' : 0}).changedtick)\n  if a:cchar == 'c'\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'changedtick' : 0, 'qfbufnr' : qfbufnr,\n                \\ 'quickfixtextfunc' : ''}, g:Xgetlist({'nr' : 5, 'all' : 0}))\n  else\n    call assert_equal({'context' : '', 'id' : 0, 'idx' : 0, 'items' : [],\n\t\t\\ 'nr' : 0, 'size' : 0, 'title' : '', 'winid' : 0,\n\t\t\\ 'changedtick' : 0, 'filewinid' : 0, 'qfbufnr' : 0,\n                \\ 'quickfixtextfunc' : ''}, g:Xgetlist({'nr' : 5, 'all' : 0}))\n  endif\nendfunc\n\nfunc Test_getqflist()\n  call Xgetlist_empty_tests('c')\n  call Xgetlist_empty_tests('l')\nendfunc\n\nfunc Test_getqflist_invalid_nr()\n  \" The following commands used to crash Vim\n  cexpr \"\"\n  call getqflist({'nr' : $XXX_DOES_NOT_EXIST_XXX})\n\n  \" Cleanup\n  call setqflist([], 'r')\nendfunc\n\n\" Tests for the quickfix/location list changedtick\nfunc Xqftick_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n\n  Xexpr \"F1:10:Line10\"\n  let qfid = g:Xgetlist({'id' : 0}).id\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  Xaddexpr \"F2:20:Line20\\nF2:21:Line21\"\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([], 'a', {'lines' : [\"F3:30:Line30\", \"F3:31:Line31\"]})\n  call assert_equal(3, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([], 'r', {'lines' : [\"F4:40:Line40\"]})\n  call assert_equal(4, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([], 'a', {'title' : 'New Title'})\n  call assert_equal(5, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  enew!\n  call append(0, [\"F5:50:L50\", \"F6:60:L60\"])\n  Xaddbuffer\n  call assert_equal(6, g:Xgetlist({'changedtick' : 0}).changedtick)\n  enew!\n\n  call g:Xsetlist([], 'a', {'context' : {'bus' : 'pci'}})\n  call assert_equal(7, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([{'filename' : 'F7', 'lnum' : 10, 'text' : 'L7'},\n\t      \\ {'filename' : 'F7', 'lnum' : 11, 'text' : 'L11'}], 'a')\n  call assert_equal(8, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([{'filename' : 'F7', 'lnum' : 10, 'text' : 'L7'},\n\t      \\ {'filename' : 'F7', 'lnum' : 11, 'text' : 'L11'}], ' ')\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call g:Xsetlist([{'filename' : 'F7', 'lnum' : 10, 'text' : 'L7'},\n\t      \\ {'filename' : 'F7', 'lnum' : 11, 'text' : 'L11'}], 'r')\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  call writefile([\"F8:80:L80\", \"F8:81:L81\"], \"Xone\")\n  Xfile Xone\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  Xaddfile Xone\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  \" Test case for updating a non-current quickfix list\n  call g:Xsetlist([], 'f')\n  Xexpr \"F1:1:L1\"\n  Xexpr \"F2:2:L2\"\n  call g:Xsetlist([], 'a', {'nr' : 1, \"lines\" : [\"F10:10:L10\"]})\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n  call assert_equal(2, g:Xgetlist({'nr' : 1, 'changedtick' : 0}).changedtick)\n\n  call delete(\"Xone\")\nendfunc\n\nfunc Test_qf_tick()\n  call Xqftick_tests('c')\n  call Xqftick_tests('l')\nendfunc\n\n\" Test helpgrep with lang specifier\nfunc Xtest_helpgrep_with_lang_specifier(cchar)\n  call s:setup_commands(a:cchar)\n  Xhelpgrep Vim@en\n  call assert_equal('help', &filetype)\n  call assert_notequal(0, g:Xgetlist({'nr' : '$'}).nr)\n  new | only\nendfunc\n\nfunc Test_helpgrep_with_lang_specifier()\n  call Xtest_helpgrep_with_lang_specifier('c')\n  call Xtest_helpgrep_with_lang_specifier('l')\nendfunc\n\n\" The following test used to crash Vim.\n\" Open the location list window and close the regular window associated with\n\" the location list. When the garbage collection runs now, it incorrectly\n\" marks the location list context as not in use and frees the context.\nfunc Test_ll_window_ctx()\n  call setloclist(0, [], 'f')\n  call setloclist(0, [], 'a', {'context' : []})\n  lopen | only\n  call test_garbagecollect_now()\n  echo getloclist(0, {'context' : 1}).context\n  enew | only\nendfunc\n\n\" The following test used to crash vim\nfunc Test_lfile_crash()\n  sp Xtest\n  au QuickFixCmdPre * bw\n  call assert_fails('lfile', 'E40:')\n  au! QuickFixCmdPre\nendfunc\n\n\" The following test used to crash vim\nfunc Test_lbuffer_crash()\n  sv Xtest\n  augroup QF_Test\n    au!\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * bw\n  augroup END\n  lbuffer\n  augroup QF_Test\n    au!\n  augroup END\nendfunc\n\n\" The following test used to crash vim\nfunc Test_lexpr_crash()\n  augroup QF_Test\n    au!\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * call setloclist(0, [], 'f')\n  augroup END\n  lexpr \"\"\n  augroup QF_Test\n    au!\n  augroup END\n\n  enew | only\n  augroup QF_Test\n    au!\n    au BufNew * call setloclist(0, [], 'f')\n  augroup END\n  lexpr 'x:1:x'\n  augroup QF_Test\n    au!\n  augroup END\n\n  enew | only\n  lexpr ''\n  lopen\n  augroup QF_Test\n    au!\n    au FileType * call setloclist(0, [], 'f')\n  augroup END\n  lexpr ''\n  augroup QF_Test\n    au!\n  augroup END\nendfunc\n\n\" The following test used to crash Vim\nfunc Test_lvimgrep_crash()\n  sv Xtest\n  augroup QF_Test\n    au!\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * call setloclist(0, [], 'f')\n  augroup END\n  lvimgrep quickfix test_quickfix.vim\n  augroup QF_Test\n    au!\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setloclist(0, [], 'r')\n  augroup END\n  call assert_fails('lvimgrep Test_lvimgrep_crash *', 'E926:')\n  augroup QF_Test\n    au!\n  augroup END\n\n  enew | only\nendfunc\n\nfunc Test_lvimgrep_crash2()\n  au BufNewFile x sfind\n  call assert_fails('lvimgrep x x', 'E471:')\n  call assert_fails('lvimgrep x x x', 'E471:')\n\n  au! BufNewFile\nendfunc\n\n\" Test for the position of the quickfix and location list window\nfunc Test_qfwin_pos()\n  \" Open two windows\n  new | only\n  new\n  cexpr ['F1:10:L10']\n  copen\n  \" Quickfix window should be the bottom most window\n  call assert_equal(3, winnr())\n  close\n  \" Open at the very top\n  wincmd t\n  topleft copen\n  call assert_equal(1, winnr())\n  close\n  \" open left of the current window\n  wincmd t\n  below new\n  leftabove copen\n  call assert_equal(2, winnr())\n  close\n  \" open right of the current window\n  rightbelow copen\n  call assert_equal(3, winnr())\n  close\nendfunc\n\n\" Tests for quickfix/location lists changed by autocommands when\n\" :vimgrep/:lvimgrep commands are running.\nfunc Test_vimgrep_autocmd()\n  call setqflist([], 'f')\n  call writefile(['stars'], 'Xtest1.txt')\n  call writefile(['stars'], 'Xtest2.txt')\n\n  \" Test 1:\n  \" When searching for a pattern using :vimgrep, if the quickfix list is\n  \" changed by an autocmd, the results should be added to the correct quickfix\n  \" list.\n  autocmd BufRead Xtest2.txt cexpr '' | cexpr ''\n  silent vimgrep stars Xtest*.txt\n  call assert_equal(1, getqflist({'nr' : 0}).nr)\n  call assert_equal(3, getqflist({'nr' : '$'}).nr)\n  call assert_equal('Xtest2.txt', bufname(getqflist()[1].bufnr))\n  au! BufRead Xtest2.txt\n\n  \" Test 2:\n  \" When searching for a pattern using :vimgrep, if the quickfix list is\n  \" freed, then a error should be given.\n  silent! %bwipe!\n  call setqflist([], 'f')\n  autocmd BufRead Xtest2.txt for i in range(10) | cexpr '' | endfor\n  call assert_fails('vimgrep stars Xtest*.txt', 'E925:')\n  au! BufRead Xtest2.txt\n\n  \" Test 3:\n  \" When searching for a pattern using :lvimgrep, if the location list is\n  \" freed, then the command should error out.\n  silent! %bwipe!\n  let g:save_winid = win_getid()\n  autocmd BufRead Xtest2.txt call setloclist(g:save_winid, [], 'f')\n  call assert_fails('lvimgrep stars Xtest*.txt', 'E926:')\n  au! BufRead Xtest2.txt\n\n  call delete('Xtest1.txt')\n  call delete('Xtest2.txt')\n  call setqflist([], 'f')\nendfunc\n\n\" Test for an autocmd changing the current directory when running vimgrep\nfunc Xvimgrep_autocmd_cd(cchar)\n  call s:setup_commands(a:cchar)\n\n  %bwipe\n  let save_cwd = getcwd()\n\n  augroup QF_Test\n    au!\n    autocmd BufRead * silent cd %:p:h\n  augroup END\n\n  10Xvimgrep /vim/ Xdir/**\n  let l = g:Xgetlist()\n  call assert_equal('f1.txt', bufname(l[0].bufnr))\n  call assert_equal('f2.txt', fnamemodify(bufname(l[2].bufnr), ':t'))\n\n  augroup QF_Test\n    au!\n  augroup END\n\n  exe 'cd ' . save_cwd\nendfunc\n\nfunc Test_vimgrep_autocmd_cd()\n  call mkdir('Xdir/a', 'p')\n  call mkdir('Xdir/b', 'p')\n  call writefile(['a_L1_vim', 'a_L2_vim'], 'Xdir/a/f1.txt')\n  call writefile(['b_L1_vim', 'b_L2_vim'], 'Xdir/b/f2.txt')\n  call Xvimgrep_autocmd_cd('c')\n  call Xvimgrep_autocmd_cd('l')\n  %bwipe\n  call delete('Xdir', 'rf')\nendfunc\n\n\" The following test used to crash Vim\nfunc Test_lhelpgrep_autocmd()\n  lhelpgrep quickfix\n  autocmd QuickFixCmdPost * call setloclist(0, [], 'f')\n  lhelpgrep buffer\n  call assert_equal('help', &filetype)\n  call assert_equal(0, getloclist(0, {'nr' : '$'}).nr)\n  lhelpgrep tabpage\n  call assert_equal('help', &filetype)\n  call assert_equal(1, getloclist(0, {'nr' : '$'}).nr)\n  au! QuickFixCmdPost\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setqflist([], 'f')\n  augroup END\n  call assert_fails('helpgrep quickfix', 'E925:')\n  \" run the test with a help window already open\n  help\n  wincmd w\n  call assert_fails('helpgrep quickfix', 'E925:')\n  augroup QF_Test\n    au! BufEnter\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setqflist([], 'r')\n  augroup END\n  call assert_fails('helpgrep quickfix', 'E925:')\n  augroup QF_Test\n    au! BufEnter\n  augroup END\n\n  new | only\n  augroup QF_Test\n    au!\n    au BufEnter * call setloclist(0, [], 'r')\n  augroup END\n  call assert_fails('lhelpgrep quickfix', 'E926:')\n  augroup QF_Test\n    au! BufEnter\n  augroup END\n\n  new | only\nendfunc\n\n\" Test for shortening/simplifying the file name when opening the\n\" quickfix window or when displaying the quickfix list\nfunc Test_shorten_fname()\n  CheckUnix\n  %bwipe\n  \" Create a quickfix list with an absolute path filename\n  let fname = getcwd() . '/test_quickfix.vim'\n  call setqflist([], ' ', {'lines':[fname . \":20:Line20\"], 'efm':'%f:%l:%m'})\n  call assert_equal(fname, bufname('test_quickfix.vim'))\n  \" Opening the quickfix window should simplify the file path\n  cwindow\n  call assert_equal('test_quickfix.vim', bufname('test_quickfix.vim'))\n  cclose\n  %bwipe\n  \" Create a quickfix list with an absolute path filename\n  call setqflist([], ' ', {'lines':[fname . \":20:Line20\"], 'efm':'%f:%l:%m'})\n  call assert_equal(fname, bufname('test_quickfix.vim'))\n  \" Displaying the quickfix list should simplify the file path\n  silent! clist\n  call assert_equal('test_quickfix.vim', bufname('test_quickfix.vim'))\n  \" Add a few entries for the same file with different paths and check whether\n  \" the buffer name is shortened\n  %bwipe\n  call setqflist([], 'f')\n  call setqflist([{'filename' : 'test_quickfix.vim', 'lnum' : 10},\n        \\ {'filename' : '../testdir/test_quickfix.vim', 'lnum' : 20},\n        \\ {'filename' : fname, 'lnum' : 30}], ' ')\n  copen\n  call assert_equal(['test_quickfix.vim|10| ',\n        \\ 'test_quickfix.vim|20| ',\n        \\ 'test_quickfix.vim|30| '], getline(1, '$'))\n  cclose\nendfunc\n\n\" Quickfix title tests\n\" In the below tests, 'exe \"cmd\"' is used to invoke the quickfix commands.\n\" Otherwise due to indentation, the title is set with spaces at the beginning\n\" of the command.\nfunc Test_qftitle()\n  call writefile([\"F1:1:Line1\"], 'Xerr')\n\n  \" :cexpr\n  exe \"cexpr readfile('Xerr')\"\n  call assert_equal(\":cexpr readfile('Xerr')\", getqflist({'title' : 1}).title)\n\n  \" :cgetexpr\n  exe \"cgetexpr readfile('Xerr')\"\n  call assert_equal(\":cgetexpr readfile('Xerr')\",\n\t\t\t\t\t\\ getqflist({'title' : 1}).title)\n\n  \" :caddexpr\n  call setqflist([], 'f')\n  exe \"caddexpr readfile('Xerr')\"\n  call assert_equal(\":caddexpr readfile('Xerr')\",\n\t\t\t\t\t\\ getqflist({'title' : 1}).title)\n\n  \" :cbuffer\n  new Xerr\n  exe \"cbuffer\"\n  call assert_equal(':cbuffer (Xerr)', getqflist({'title' : 1}).title)\n\n  \" :cgetbuffer\n  edit Xerr\n  exe \"cgetbuffer\"\n  call assert_equal(':cgetbuffer (Xerr)', getqflist({'title' : 1}).title)\n\n  \" :caddbuffer\n  call setqflist([], 'f')\n  edit Xerr\n  exe \"caddbuffer\"\n  call assert_equal(':caddbuffer (Xerr)', getqflist({'title' : 1}).title)\n\n  \" :cfile\n  exe \"cfile Xerr\"\n  call assert_equal(':cfile Xerr', getqflist({'title' : 1}).title)\n\n  \" :cgetfile\n  exe \"cgetfile Xerr\"\n  call assert_equal(':cgetfile Xerr', getqflist({'title' : 1}).title)\n\n  \" :caddfile\n  call setqflist([], 'f')\n  exe \"caddfile Xerr\"\n  call assert_equal(':caddfile Xerr', getqflist({'title' : 1}).title)\n\n  \" :grep\n  set grepprg=internal\n  exe \"grep F1 Xerr\"\n  call assert_equal(':grep F1 Xerr', getqflist({'title' : 1}).title)\n\n  \" :grepadd\n  call setqflist([], 'f')\n  exe \"grepadd F1 Xerr\"\n  call assert_equal(':grepadd F1 Xerr', getqflist({'title' : 1}).title)\n  set grepprg&vim\n\n  \" :vimgrep\n  exe \"vimgrep F1 Xerr\"\n  call assert_equal(':vimgrep F1 Xerr', getqflist({'title' : 1}).title)\n\n  \" :vimgrepadd\n  call setqflist([], 'f')\n  exe \"vimgrepadd F1 Xerr\"\n  call assert_equal(':vimgrepadd F1 Xerr', getqflist({'title' : 1}).title)\n\n  call setqflist(['F1:10:L10'], ' ')\n  call assert_equal(':setqflist()', getqflist({'title' : 1}).title)\n\n  call setqflist([], 'f')\n  call setqflist(['F1:10:L10'], 'a')\n  call assert_equal(':setqflist()', getqflist({'title' : 1}).title)\n\n  call setqflist([], 'f')\n  call setqflist(['F1:10:L10'], 'r')\n  call assert_equal(':setqflist()', getqflist({'title' : 1}).title)\n\n  close\n  call delete('Xerr')\n\n  call setqflist([], ' ', {'title' : 'Errors'})\n  copen\n  call assert_equal('Errors', w:quickfix_title)\n  call setqflist([], 'r', {'items' : [{'filename' : 'a.c', 'lnum' : 10}]})\n  call assert_equal('Errors', w:quickfix_title)\n  cclose\n\n  \" Switching to another quickfix list in one tab page should update the\n  \" quickfix window title and statusline in all the other tab pages also\n  call setqflist([], 'f')\n  %bw!\n  cgetexpr ['file_one:1:1: error in the first quickfix list']\n  call setqflist([], 'a', {'title': 'first quickfix list'})\n  cgetexpr ['file_two:2:1: error in the second quickfix list']\n  call setqflist([], 'a', {'title': 'second quickfix list'})\n  copen\n  wincmd t\n  tabnew two\n  copen\n  wincmd t\n  colder\n  call assert_equal('first quickfix list', gettabwinvar(1, 2, 'quickfix_title'))\n  call assert_equal('first quickfix list', gettabwinvar(2, 2, 'quickfix_title'))\n  call assert_equal(1, tabpagewinnr(1))\n  call assert_equal(1, tabpagewinnr(2))\n  tabnew\n  call setqflist([], 'a', {'title': 'new quickfix title'})\n  call assert_equal('new quickfix title', gettabwinvar(1, 2, 'quickfix_title'))\n  call assert_equal('new quickfix title', gettabwinvar(2, 2, 'quickfix_title'))\n  %bw!\nendfunc\n\nfunc Test_lbuffer_with_bwipe()\n  new\n  new\n  augroup nasty\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * bwipe\n  augroup END\n  lbuffer\n  augroup nasty\n    au!\n  augroup END\nendfunc\n\n\" Test for an autocmd freeing the quickfix/location list when cexpr/lexpr is\n\" running\nfunc Xexpr_acmd_freelist(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" This was using freed memory (but with what events?)\n  augroup nasty\n    au QuickFixCmdPre,QuickFixCmdPost,BufEnter,BufLeave * call g:Xsetlist([], 'f')\n  augroup END\n  Xexpr \"x\"\n  augroup nasty\n    au!\n  augroup END\nendfunc\n\nfunc Test_cexpr_acmd_freelist()\n  call Xexpr_acmd_freelist('c')\n  call Xexpr_acmd_freelist('l')\nendfunc\n\n\" Test for commands that create a new quickfix/location list and jump to the\n\" first error automatically.\nfunc Xjumpto_first_error_test(cchar)\n  call s:setup_commands(a:cchar)\n\n  call s:create_test_file('Xtestfile1')\n  call s:create_test_file('Xtestfile2')\n  let l = ['Xtestfile1:2:Line2', 'Xtestfile2:4:Line4']\n\n  \" Test for cexpr/lexpr\n  enew\n  Xexpr l\n  call assert_equal('Xtestfile1', @%)\n  call assert_equal(2, line('.'))\n\n  \" Test for cfile/lfile\n  enew\n  call writefile(l, 'Xerr')\n  Xfile Xerr\n  call assert_equal('Xtestfile1', @%)\n  call assert_equal(2, line('.'))\n\n  \" Test for cbuffer/lbuffer\n  edit Xerr\n  Xbuffer\n  call assert_equal('Xtestfile1', @%)\n  call assert_equal(2, line('.'))\n\n  call delete('Xerr')\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\nfunc Test_jumpto_first_error()\n  call Xjumpto_first_error_test('c')\n  call Xjumpto_first_error_test('l')\nendfunc\n\n\" Test for a quickfix autocmd changing the quickfix/location list before\n\" jumping to the first error in the new list.\nfunc Xautocmd_changelist(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Test for cfile/lfile\n  call s:create_test_file('Xtestfile1')\n  call s:create_test_file('Xtestfile2')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  call writefile(['Xtestfile2:4:Line4'], 'Xerr')\n  Xfile Xerr\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(4, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" Test for cbuffer/lbuffer\n  call g:Xsetlist([], 'f')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  call writefile(['Xtestfile2:4:Line4'], 'Xerr')\n  edit Xerr\n  Xbuffer\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(4, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" Test for cexpr/lexpr\n  call g:Xsetlist([], 'f')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  Xexpr 'Xtestfile2:4:Line4'\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(4, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" The grepprg may not be set on non-Unix systems\n  if has('unix')\n    \" Test for grep/lgrep\n    call g:Xsetlist([], 'f')\n    Xexpr 'Xtestfile1:2:Line2'\n    autocmd QuickFixCmdPost * Xolder\n    silent Xgrep Line5 Xtestfile2\n    call assert_equal('Xtestfile2', @%)\n    call assert_equal(5, line('.'))\n    autocmd! QuickFixCmdPost\n  endif\n\n  \" Test for vimgrep/lvimgrep\n  call g:Xsetlist([], 'f')\n  Xexpr 'Xtestfile1:2:Line2'\n  autocmd QuickFixCmdPost * Xolder\n  silent Xvimgrep Line5 Xtestfile2\n  call assert_equal('Xtestfile2', @%)\n  call assert_equal(5, line('.'))\n  autocmd! QuickFixCmdPost\n\n  \" Test for autocommands clearing the quickfix list before jumping to the\n  \" first error. This should not result in an error\n  autocmd QuickFixCmdPost * call g:Xsetlist([], 'r')\n  let v:errmsg = ''\n  \" Test for cfile/lfile\n  Xfile Xerr\n  call assert_true(v:errmsg !~# 'E42:')\n  \" Test for cbuffer/lbuffer\n  edit Xerr\n  Xbuffer\n  call assert_true(v:errmsg !~# 'E42:')\n  \" Test for cexpr/lexpr\n  Xexpr 'Xtestfile2:4:Line4'\n  call assert_true(v:errmsg !~# 'E42:')\n  \" Test for grep/lgrep\n  \" The grepprg may not be set on non-Unix systems\n  if has('unix')\n    silent Xgrep Line5 Xtestfile2\n    call assert_true(v:errmsg !~# 'E42:')\n  endif\n  \" Test for vimgrep/lvimgrep\n  call assert_fails('silent Xvimgrep Line5 Xtestfile2', 'E480:')\n  autocmd! QuickFixCmdPost\n\n  call delete('Xerr')\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\nfunc Test_autocmd_changelist()\n  call Xautocmd_changelist('c')\n  call Xautocmd_changelist('l')\nendfunc\n\n\" Tests for the ':filter /pat/ clist' command\nfunc Test_filter_clist()\n  cexpr ['Xfile1:10:10:Line 10', 'Xfile2:15:15:Line 15']\n  call assert_equal([' 2 Xfile2:15 col 15: Line 15'],\n\t\t\t\\ split(execute('filter /Line 15/ clist'), \"\\n\"))\n  call assert_equal([' 1 Xfile1:10 col 10: Line 10'],\n\t\t\t\\ split(execute('filter /Xfile1/ clist'), \"\\n\"))\n  call assert_equal([], split(execute('filter /abc/ clist'), \"\\n\"))\n\n  call setqflist([{'module' : 'abc', 'pattern' : 'pat1'},\n\t\t\t\\ {'module' : 'pqr', 'pattern' : 'pat2'}], ' ')\n  call assert_equal([' 2 pqr:pat2:  '],\n\t\t\t\\ split(execute('filter /pqr/ clist'), \"\\n\"))\n  call assert_equal([' 1 abc:pat1:  '],\n\t\t\t\\ split(execute('filter /pat1/ clist'), \"\\n\"))\nendfunc\n\n\" Tests for the \"CTRL-W <CR>\" command.\nfunc Xview_result_split_tests(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Test that \"CTRL-W <CR>\" in a qf/ll window fails with empty list.\n  call g:Xsetlist([])\n  Xopen\n  let l:win_count = winnr('$')\n  call assert_fails('execute \"normal! \\<C-W>\\<CR>\"', 'E42:')\n  call assert_equal(l:win_count, winnr('$'))\n  Xclose\nendfunc\n\nfunc Test_view_result_split()\n  call Xview_result_split_tests('c')\n  call Xview_result_split_tests('l')\nendfunc\n\n\" Test that :cc sets curswant\nfunc Test_curswant()\n  helpgrep quickfix\n  normal! llll\n  1cc\n  call assert_equal(getcurpos()[4], virtcol('.'))\n  cclose | helpclose\nendfunc\n\n\" Test for opening a file from the quickfix window using CTRL-W <Enter>\n\" doesn't leave an empty buffer around.\nfunc Test_splitview()\n  call s:create_test_file('Xtestfile1')\n  call s:create_test_file('Xtestfile2')\n  new | only\n  let last_bufnr = bufnr('Test_sv_1', 1)\n  let l = ['Xtestfile1:2:Line2', 'Xtestfile2:4:Line4']\n  cgetexpr l\n  copen\n  let numbufs = len(getbufinfo())\n  exe \"normal \\<C-W>\\<CR>\"\n  copen\n  exe \"normal j\\<C-W>\\<CR>\"\n  \" Make sure new empty buffers are not created\n  call assert_equal(numbufs, len(getbufinfo()))\n  \" Creating a new buffer should use the next available buffer number\n  call assert_equal(last_bufnr + 4, bufnr(\"Test_sv_2\", 1))\n  bwipe Test_sv_1\n  bwipe Test_sv_2\n  new | only\n\n  \" When split opening files from location list window, make sure that two\n  \" windows doesn't refer to the same location list\n  lgetexpr l\n  let locid = getloclist(0, {'id' : 0}).id\n  lopen\n  exe \"normal \\<C-W>\\<CR>\"\n  call assert_notequal(locid, getloclist(0, {'id' : 0}).id)\n  call assert_equal(0, getloclist(0, {'winid' : 0}).winid)\n  new | only\n\n  \" When split opening files from a helpgrep location list window, a new help\n  \" window should be opened with a copy of the location list.\n  lhelpgrep window\n  let locid = getloclist(0, {'id' : 0}).id\n  lwindow\n  exe \"normal j\\<C-W>\\<CR>\"\n  call assert_notequal(locid, getloclist(0, {'id' : 0}).id)\n  call assert_equal(0, getloclist(0, {'winid' : 0}).winid)\n  new | only\n\n  \" Using :split or :vsplit from a quickfix window should behave like a :new\n  \" or a :vnew command\n  copen\n  split\n  call assert_equal(3, winnr('$'))\n  let l = getwininfo()\n  call assert_equal([0, 0, 1], [l[0].quickfix, l[1].quickfix, l[2].quickfix])\n  close\n  copen\n  vsplit\n  let l = getwininfo()\n  call assert_equal([0, 0, 1], [l[0].quickfix, l[1].quickfix, l[2].quickfix])\n  new | only\n\n  call delete('Xtestfile1')\n  call delete('Xtestfile2')\nendfunc\n\n\" Test for parsing entries using visual screen column\nfunc Test_viscol()\n  enew\n  call writefile([\"Col1\\tCol2\\tCol3\"], 'Xfile1')\n  edit Xfile1\n\n  \" Use byte offset for column number\n  set efm&\n  cexpr \"Xfile1:1:5:XX\\nXfile1:1:9:YY\\nXfile1:1:20:ZZ\"\n  call assert_equal([5, 8], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([9, 12], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([14, 20], [col('.'), virtcol('.')])\n\n  \" Use screen column offset for column number\n  set efm=%f:%l:%v:%m\n  cexpr \"Xfile1:1:8:XX\\nXfile1:1:12:YY\\nXfile1:1:20:ZZ\"\n  call assert_equal([5, 8], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([9, 12], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([14, 20], [col('.'), virtcol('.')])\n  cexpr \"Xfile1:1:6:XX\\nXfile1:1:15:YY\\nXfile1:1:24:ZZ\"\n  call assert_equal([5, 8], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([10, 16], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([14, 20], [col('.'), virtcol('.')])\n\n  enew\n  call writefile([\"Col1\\t\u00e4\u00fc\\t\u00f6\u00df\\tCol4\"], 'Xfile1')\n\n  \" Use byte offset for column number\n  set efm&\n  cexpr \"Xfile1:1:8:XX\\nXfile1:1:11:YY\\nXfile1:1:16:ZZ\"\n  call assert_equal([8, 10], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([11, 17], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([16, 25], [col('.'), virtcol('.')])\n\n  \" Use screen column offset for column number\n  set efm=%f:%l:%v:%m\n  cexpr \"Xfile1:1:10:XX\\nXfile1:1:17:YY\\nXfile1:1:25:ZZ\"\n  call assert_equal([8, 10], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([11, 17], [col('.'), virtcol('.')])\n  cnext\n  call assert_equal([16, 25], [col('.'), virtcol('.')])\n\n  \" Use screen column number with a multi-line error message\n  enew\n  call writefile([\"\u00e0 test\"], 'Xfile1')\n  set efm=%E===\\ %f\\ ===,%C%l:%v,%Z%m\n  cexpr [\"=== Xfile1 ===\", \"1:3\", \"errormsg\"]\n  call assert_equal('Xfile1', @%)\n  call assert_equal([0, 1, 4, 0], getpos('.'))\n\n  \" Repeat previous test with byte offset %c: ensure that fix to issue #7145\n  \" does not break this\n  set efm=%E===\\ %f\\ ===,%C%l:%c,%Z%m\n  cexpr [\"=== Xfile1 ===\", \"1:3\", \"errormsg\"]\n  call assert_equal('Xfile1', @%)\n  call assert_equal([0, 1, 3, 0], getpos('.'))\n\n  enew | only\n  set efm&\n  call delete('Xfile1')\nendfunc\n\n\" Test for the quickfix window buffer\nfunc Xqfbuf_test(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" Quickfix buffer should be reused across closing and opening a quickfix\n  \" window\n  Xexpr \"F1:10:Line10\"\n  Xopen\n  let qfbnum = bufnr('')\n  Xclose\n  \" Even after the quickfix window is closed, the buffer should be loaded\n  call assert_true(bufloaded(qfbnum))\n  call assert_true(qfbnum, g:Xgetlist({'qfbufnr' : 0}).qfbufnr)\n  Xopen\n  \" Buffer should be reused when opening the window again\n  call assert_equal(qfbnum, bufnr(''))\n  Xclose\n\n  \" When quickfix buffer is wiped out, getqflist() should return 0\n  %bw!\n  Xexpr \"\"\n  Xopen\n  bw!\n  call assert_equal(0, g:Xgetlist({'qfbufnr': 0}).qfbufnr)\n\n  if a:cchar == 'l'\n    %bwipe\n    \" For a location list, when both the file window and the location list\n    \" window for the list are closed, then the buffer should be freed.\n    new | only\n    lexpr \"F1:10:Line10\"\n    let wid = win_getid()\n    lopen\n    let qfbnum = bufnr('')\n    call assert_match(qfbnum . ' %a-  \"\\[Location List]\"', execute('ls'))\n    close\n    \" When the location list window is closed, the buffer name should not\n    \" change to 'Quickfix List'\n    call assert_match(qfbnum . 'u h-  \"\\[Location List]\"', execute('ls!'))\n    call assert_true(bufloaded(qfbnum))\n\n    \" After deleting a location list buffer using \":bdelete\", opening the\n    \" location list window should mark the buffer as a location list buffer.\n    exe \"bdelete \" . qfbnum\n    lopen\n    call assert_equal(\"quickfix\", &buftype)\n    call assert_equal(1, getwininfo(win_getid(winnr()))[0].loclist)\n    call assert_equal(wid, getloclist(0, {'filewinid' : 0}).filewinid)\n    call assert_false(&swapfile)\n    lclose\n\n    \" When the location list is cleared for the window, the buffer should be\n    \" removed\n    call setloclist(0, [], 'f')\n    call assert_false(bufexists(qfbnum))\n    call assert_equal(0, getloclist(0, {'qfbufnr' : 0}).qfbufnr)\n\n    \" When the location list is freed with the location list window open, the\n    \" location list buffer should not be lost. It should be reused when the\n    \" location list is again populated.\n    lexpr \"F1:10:Line10\"\n    lopen\n    let wid = win_getid()\n    let qfbnum = bufnr('')\n    wincmd p\n    call setloclist(0, [], 'f')\n    lexpr \"F1:10:Line10\"\n    lopen\n    call assert_equal(wid, win_getid())\n    call assert_equal(qfbnum, bufnr(''))\n    lclose\n\n    \" When the window with the location list is closed, the buffer should be\n    \" removed\n    new | only\n    call assert_false(bufexists(qfbnum))\n  endif\nendfunc\n\nfunc Test_qfbuf()\n  call Xqfbuf_test('c')\n  call Xqfbuf_test('l')\nendfunc\n\n\" If there is an autocmd to use only one window, then opening the location\n\" list window used to crash Vim.\nfunc Test_winonly_autocmd()\n  call s:create_test_file('Xtest1')\n  \" Autocmd to show only one Vim window at a time\n  autocmd WinEnter * only\n  new\n  \" Load the location list\n  lexpr \"Xtest1:5:Line5\\nXtest1:10:Line10\\nXtest1:15:Line15\"\n  let loclistid = getloclist(0, {'id' : 0}).id\n  \" Open the location list window. Only this window will be shown and the file\n  \" window is closed.\n  lopen\n  call assert_equal(loclistid, getloclist(0, {'id' : 0}).id)\n  \" Jump to an entry in the location list and make sure that the cursor is\n  \" positioned correctly.\n  ll 3\n  call assert_equal(loclistid, getloclist(0, {'id' : 0}).id)\n  call assert_equal('Xtest1', @%)\n  call assert_equal(15, line('.'))\n  \" Cleanup\n  autocmd! WinEnter\n  new | only\n  call delete('Xtest1')\nendfunc\n\n\" Test to make sure that an empty quickfix buffer is not reused for loading\n\" a normal buffer.\nfunc Test_empty_qfbuf()\n  enew | only\n  call writefile([\"Test\"], 'Xfile1')\n  call setqflist([], 'f')\n  copen | only\n  let qfbuf = bufnr('')\n  edit Xfile1\n  call assert_notequal(qfbuf, bufnr(''))\n  enew\n  call delete('Xfile1')\nendfunc\n\n\" Test for the :cbelow, :cabove, :lbelow and :labove commands.\n\" And for the :cafter, :cbefore, :lafter and :lbefore commands.\nfunc Xtest_below(cchar)\n  call s:setup_commands(a:cchar)\n\n  \" No quickfix/location list\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n\n  \" Empty quickfix/location list\n  call g:Xsetlist([])\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n\n  call s:create_test_file('X1')\n  call s:create_test_file('X2')\n  call s:create_test_file('X3')\n  call s:create_test_file('X4')\n\n  \" Invalid entries\n  edit X1\n  call g:Xsetlist([\"E1\", \"E2\"])\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('3Xbelow', 'E42:')\n  call assert_fails('4Xabove', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n  call assert_fails('3Xbefore', 'E42:')\n  call assert_fails('4Xafter', 'E42:')\n\n  \" Test the commands with various arguments\n  Xexpr [\"X1:5:3:L5\", \"X2:5:2:L5\", \"X2:10:3:L10\", \"X2:15:4:L15\", \"X3:3:5:L3\"]\n  edit +7 X2\n  Xabove\n  call assert_equal(['X2', 5], [@%, line('.')])\n  call assert_fails('Xabove', 'E553:')\n  normal 7G\n  Xbefore\n  call assert_equal(['X2', 5, 2], [@%, line('.'), col('.')])\n  call assert_fails('Xbefore', 'E553:')\n\n  normal 2j\n  Xbelow\n  call assert_equal(['X2', 10], [@%, line('.')])\n  normal 7G\n  Xafter\n  call assert_equal(['X2', 10, 3], [@%, line('.'), col('.')])\n\n  \" Last error in this file\n  Xbelow 99\n  call assert_equal(['X2', 15], [@%, line('.')])\n  call assert_fails('Xbelow', 'E553:')\n  normal gg\n  Xafter 99\n  call assert_equal(['X2', 15, 4], [@%, line('.'), col('.')])\n  call assert_fails('Xafter', 'E553:')\n\n  \" First error in this file\n  Xabove 99\n  call assert_equal(['X2', 5], [@%, line('.')])\n  call assert_fails('Xabove', 'E553:')\n  normal G\n  Xbefore 99\n  call assert_equal(['X2', 5, 2], [@%, line('.'), col('.')])\n  call assert_fails('Xbefore', 'E553:')\n\n  normal gg\n  Xbelow 2\n  call assert_equal(['X2', 10], [@%, line('.')])\n  normal gg\n  Xafter 2\n  call assert_equal(['X2', 10, 3], [@%, line('.'), col('.')])\n\n  normal G\n  Xabove 2\n  call assert_equal(['X2', 10], [@%, line('.')])\n  normal G\n  Xbefore 2\n  call assert_equal(['X2', 10, 3], [@%, line('.'), col('.')])\n\n  edit X4\n  call assert_fails('Xabove', 'E42:')\n  call assert_fails('Xbelow', 'E42:')\n  call assert_fails('Xbefore', 'E42:')\n  call assert_fails('Xafter', 'E42:')\n  if a:cchar == 'l'\n    \" If a buffer has location list entries from some other window but not\n    \" from the current window, then the commands should fail.\n    edit X1 | split | call setloclist(0, [], 'f')\n    call assert_fails('Xabove', 'E776:')\n    call assert_fails('Xbelow', 'E776:')\n    call assert_fails('Xbefore', 'E776:')\n    call assert_fails('Xafter', 'E776:')\n    close\n  endif\n\n  \" Test for lines with multiple quickfix entries\n  Xexpr [\"X1:5:L5\", \"X2:5:1:L5_1\", \"X2:5:2:L5_2\", \"X2:5:3:L5_3\",\n\t      \\ \"X2:10:1:L10_1\", \"X2:10:2:L10_2\", \"X2:10:3:L10_3\",\n\t      \\ \"X2:15:1:L15_1\", \"X2:15:2:L15_2\", \"X2:15:3:L15_3\", \"X3:3:L3\"]\n  edit +1 X2\n  Xbelow 2\n  call assert_equal(['X2', 10, 1], [@%, line('.'), col('.')])\n  normal 1G\n  Xafter 2\n  call assert_equal(['X2', 5, 2], [@%, line('.'), col('.')])\n\n  normal gg\n  Xbelow 99\n  call assert_equal(['X2', 15, 1], [@%, line('.'), col('.')])\n  normal gg\n  Xafter 99\n  call assert_equal(['X2', 15, 3], [@%, line('.'), col('.')])\n\n  normal G\n  Xabove 2\n  call assert_equal(['X2', 10, 1], [@%, line('.'), col('.')])\n  normal G\n  Xbefore 2\n  call assert_equal(['X2', 15, 2], [@%, line('.'), col('.')])\n\n  normal G\n  Xabove 99\n  call assert_equal(['X2', 5, 1], [@%, line('.'), col('.')])\n  normal G\n  Xbefore 99\n  call assert_equal(['X2', 5, 1], [@%, line('.'), col('.')])\n\n  normal 10G\n  Xabove\n  call assert_equal(['X2', 5, 1], [@%, line('.'), col('.')])\n  normal 10G$\n  2Xbefore\n  call assert_equal(['X2', 10, 2], [@%, line('.'), col('.')])\n\n  normal 10G\n  Xbelow\n  call assert_equal(['X2', 15, 1], [@%, line('.'), col('.')])\n  normal 9G\n  5Xafter\n  call assert_equal(['X2', 15, 2], [@%, line('.'), col('.')])\n\n  \" Invalid range\n  if a:cchar == 'c'\n    call assert_fails('-2cbelow', 'E16:')\n    call assert_fails('-2cafter', 'E16:')\n  else\n    call assert_fails('-2lbelow', 'E16:')\n    call assert_fails('-2lafter', 'E16:')\n  endif\n\n  call delete('X1')\n  call delete('X2')\n  call delete('X3')\n  call delete('X4')\nendfunc\n\nfunc Test_cbelow()\n  call Xtest_below('c')\n  call Xtest_below('l')\nendfunc\n\nfunc Test_quickfix_count()\n  let commands = [\n\t\\ 'cNext',\n\t\\ 'cNfile',\n\t\\ 'cabove',\n\t\\ 'cbelow',\n\t\\ 'cfirst',\n\t\\ 'clast',\n\t\\ 'cnewer',\n\t\\ 'cnext',\n\t\\ 'cnfile',\n\t\\ 'colder',\n\t\\ 'cprevious',\n\t\\ 'crewind',\n\t\\\n\t\\ 'lNext',\n\t\\ 'lNfile',\n\t\\ 'labove',\n\t\\ 'lbelow',\n\t\\ 'lfirst',\n\t\\ 'llast',\n\t\\ 'lnewer',\n\t\\ 'lnext',\n\t\\ 'lnfile',\n\t\\ 'lolder',\n\t\\ 'lprevious',\n\t\\ 'lrewind',\n\t\\ ]\n  for cmd in commands\n    call assert_fails('-1' .. cmd, 'E16:')\n    call assert_fails('.' .. cmd, 'E16:')\n    call assert_fails('%' .. cmd, 'E16:')\n    call assert_fails('$' .. cmd, 'E16:')\n  endfor\nendfunc\n\n\" Test for aborting quickfix commands using QuickFixCmdPre\nfunc Xtest_qfcmd_abort(cchar)\n  call s:setup_commands(a:cchar)\n\n  call g:Xsetlist([], 'f')\n\n  \" cexpr/lexpr\n  let e = ''\n  try\n    Xexpr [\"F1:10:Line10\", \"F2:20:Line20\"]\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n\n  \" cfile/lfile\n  call writefile([\"F1:10:Line10\", \"F2:20:Line20\"], 'Xfile1')\n  let e = ''\n  try\n    Xfile Xfile1\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n  call delete('Xfile1')\n\n  \" cgetbuffer/lgetbuffer\n  enew!\n  call append(0, [\"F1:10:Line10\", \"F2:20:Line20\"])\n  let e = ''\n  try\n    Xgetbuffer\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n  enew!\n\n  \" vimgrep/lvimgrep\n  let e = ''\n  try\n    Xvimgrep /func/ test_quickfix.vim\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n\n  \" helpgrep/lhelpgrep\n  let e = ''\n  try\n    Xhelpgrep quickfix\n  catch /.*/\n    let e = v:exception\n  endtry\n  call assert_equal('AbortCmd', e)\n  call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n\n  \" grep/lgrep\n  if has('unix')\n    let e = ''\n    try\n      silent Xgrep func test_quickfix.vim\n    catch /.*/\n      let e = v:exception\n    endtry\n    call assert_equal('AbortCmd', e)\n    call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)\n  endif\nendfunc\n\nfunc Test_qfcmd_abort()\n  augroup QF_Test\n    au!\n    autocmd  QuickFixCmdPre * throw \"AbortCmd\"\n  augroup END\n\n  call Xtest_qfcmd_abort('c')\n  call Xtest_qfcmd_abort('l')\n\n  augroup QF_Test\n    au!\n  augroup END\nendfunc\n\n\" Test for using a file in one of the parent directories.\nfunc Test_search_in_dirstack()\n  call mkdir('Xtestdir/a/b/c', 'p')\n  let save_cwd = getcwd()\n  call writefile([\"X1_L1\", \"X1_L2\"], 'Xtestdir/Xfile1')\n  call writefile([\"X2_L1\", \"X2_L2\"], 'Xtestdir/a/Xfile2')\n  call writefile([\"X3_L1\", \"X3_L2\"], 'Xtestdir/a/b/Xfile3')\n  call writefile([\"X4_L1\", \"X4_L2\"], 'Xtestdir/a/b/c/Xfile4')\n\n  let lines = \"Entering dir Xtestdir\\n\" .\n\t      \\ \"Entering dir a\\n\" .\n\t      \\ \"Entering dir b\\n\" .\n\t      \\ \"Xfile2:2:X2_L2\\n\" .\n\t      \\ \"Leaving dir a\\n\" .\n\t      \\ \"Xfile1:2:X1_L2\\n\" .\n\t      \\ \"Xfile3:1:X3_L1\\n\" .\n\t      \\ \"Entering dir c\\n\" .\n\t      \\ \"Xfile4:2:X4_L2\\n\" .\n\t      \\ \"Leaving dir c\\n\"\n  set efm=%DEntering\\ dir\\ %f,%XLeaving\\ dir\\ %f,%f:%l:%m\n  cexpr lines .. \"Leaving dir Xtestdir|\\n\" | let next = 1\n  call assert_equal(11, getqflist({'size' : 0}).size)\n  call assert_equal(4, getqflist({'idx' : 0}).idx)\n  call assert_equal('X2_L2', getline('.'))\n  call assert_equal(1, next)\n  cnext\n  call assert_equal(6, getqflist({'idx' : 0}).idx)\n  call assert_equal('X1_L2', getline('.'))\n  cnext\n  call assert_equal(7, getqflist({'idx' : 0}).idx)\n  call assert_equal(1, line('$'))\n  call assert_equal('', getline(1))\n  cnext\n  call assert_equal(9, getqflist({'idx' : 0}).idx)\n  call assert_equal(1, line('$'))\n  call assert_equal('', getline(1))\n\n  set efm&\n  exe 'cd ' . save_cwd\n  call delete('Xtestdir', 'rf')\nendfunc\n\n\" Test for :cquit\nfunc Test_cquit()\n  \" Exit Vim with a non-zero value\n  if RunVim([], [\"cquit 7\"], '')\n    call assert_equal(7, v:shell_error)\n  endif\n\n  if RunVim([], [\"50cquit\"], '')\n    call assert_equal(50, v:shell_error)\n  endif\n\n  \" Exit Vim with default value\n  if RunVim([], [\"cquit\"], '')\n    call assert_equal(1, v:shell_error)\n  endif\n\n  \" Exit Vim with zero value\n  if RunVim([], [\"cquit 0\"], '')\n    call assert_equal(0, v:shell_error)\n  endif\n\n  \" Exit Vim with negative value\n  call assert_fails('-3cquit', 'E16:')\nendfunc\n\n\" Test for getting a specific item from a quickfix list\nfunc Xtest_getqflist_by_idx(cchar)\n  call s:setup_commands(a:cchar)\n  \" Empty list\n  call assert_equal([], g:Xgetlist({'idx' : 1, 'items' : 0}).items)\n  Xexpr ['F1:10:L10', 'F1:20:L20']\n  let l = g:Xgetlist({'idx' : 2, 'items' : 0}).items\n  call assert_equal(bufnr('F1'), l[0].bufnr)\n  call assert_equal(20, l[0].lnum)\n  call assert_equal('L20', l[0].text)\n  call assert_equal([], g:Xgetlist({'idx' : -1, 'items' : 0}).items)\n  call assert_equal([], g:Xgetlist({'idx' : 3, 'items' : 0}).items)\n  %bwipe!\nendfunc\n\nfunc Test_getqflist_by_idx()\n  call Xtest_getqflist_by_idx('c')\n  call Xtest_getqflist_by_idx('l')\nendfunc\n\n\" Test for the 'quickfixtextfunc' setting\nfunc Tqfexpr(info)\n  if a:info.quickfix\n    let qfl = getqflist({'id' : a:info.id, 'items' : 1}).items\n  else\n    let qfl = getloclist(a:info.winid, {'id' : a:info.id, 'items' : 1}).items\n  endif\n\n  let l = []\n  for idx in range(a:info.start_idx - 1, a:info.end_idx - 1)\n    let e = qfl[idx]\n    let s = ''\n    if e.bufnr != 0\n      let bname = bufname(e.bufnr)\n      let s ..= fnamemodify(bname, ':.')\n    endif\n    let s ..= '-'\n    let s ..= 'L' .. string(e.lnum) .. 'C' .. string(e.col) .. '-'\n    let s ..= e.text\n    call add(l, s)\n  endfor\n\n  return l\nendfunc\n\nfunc Xtest_qftextfunc(cchar)\n  call s:setup_commands(a:cchar)\n\n  set efm=%f:%l:%c:%m\n  set quickfixtextfunc=Tqfexpr\n  call assert_equal('Tqfexpr', &quickfixtextfunc)\n  call assert_equal('',\n        \\ g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc)\n  call g:Xsetlist([\n        \\ { 'filename': 'F1', 'lnum': 10, 'col': 2,\n        \\   'end_col': 7, 'text': 'green'},\n        \\ { 'filename': 'F1', 'lnum': 20, 'end_lnum': 25, 'col': 4,\n        \\   'end_col': 8, 'text': 'blue'},\n        \\ ])\n\n  Xwindow\n  call assert_equal('F1-L10C2-green', getline(1))\n  call assert_equal('F1-L20C4-blue', getline(2))\n  Xclose\n  set quickfixtextfunc&vim\n  Xwindow\n  call assert_equal('F1|10 col 2-7| green', getline(1))\n  call assert_equal('F1|20-25 col 4-8| blue', getline(2))\n  Xclose\n  set efm&\n  set quickfixtextfunc&\n\n  \" Test for per list 'quickfixtextfunc' setting\n  func PerQfText(info)\n    if a:info.quickfix\n      let qfl = getqflist({'id' : a:info.id, 'items' : 1}).items\n    else\n      let qfl = getloclist(a:info.winid, {'id' : a:info.id, 'items' : 1}).items\n    endif\n    if empty(qfl)\n      return []\n    endif\n    let l = []\n    for idx in range(a:info.start_idx - 1, a:info.end_idx - 1)\n      call add(l, 'Line ' .. qfl[idx].lnum .. ', Col ' .. qfl[idx].col)\n    endfor\n    return l\n  endfunc\n  set quickfixtextfunc=Tqfexpr\n  call g:Xsetlist([], ' ', {'quickfixtextfunc' : \"PerQfText\"})\n  Xaddexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal('Line 10, Col 2', getline(1))\n  call assert_equal('Line 20, Col 4', getline(2))\n  Xclose\n  call assert_equal(function('PerQfText'),\n        \\ g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc)\n  \" Add entries to the list when the quickfix buffer is hidden\n  Xaddexpr ['F1:30:6:red']\n  Xwindow\n  call assert_equal('Line 30, Col 6', getline(3))\n  Xclose\n  call g:Xsetlist([], 'r', {'quickfixtextfunc' : ''})\n  call assert_equal('', g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc)\n  set quickfixtextfunc&\n  delfunc PerQfText\n\n  \" Non-existing function\n  set quickfixtextfunc=Tabc\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue']\", 'E117:')\n  call assert_fails(\"Xwindow\", 'E117:')\n  Xclose\n  set quickfixtextfunc&\n\n  \" set option to a non-function\n  set quickfixtextfunc=[10,\\ 20]\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue']\", 'E117:')\n  call assert_fails(\"Xwindow\", 'E117:')\n  Xclose\n  set quickfixtextfunc&\n\n  \" set option to a function with different set of arguments\n  func Xqftext(a, b, c)\n    return a:a .. a:b .. a:c\n  endfunc\n  set quickfixtextfunc=Xqftext\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue']\", 'E119:')\n  call assert_fails(\"Xwindow\", 'E119:')\n  Xclose\n\n  \" set option to a function that returns a list with non-strings\n  func Xqftext2(d)\n    return ['one', [], 'two']\n  endfunc\n  set quickfixtextfunc=Xqftext2\n  call assert_fails(\"Xexpr ['F1:10:2:green', 'F1:20:4:blue', 'F1:30:6:red']\",\n                                                                  \\ 'E730:')\n  call assert_fails('Xwindow', 'E730:')\n  call assert_equal(['one', 'F1|20 col 4| blue', 'F1|30 col 6| red'],\n        \\ getline(1, '$'))\n  Xclose\n\n  set quickfixtextfunc&\n  delfunc Xqftext\n  delfunc Xqftext2\n\n  \" set the global option to a lambda function\n  set quickfixtextfunc={d\\ ->\\ map(g:Xgetlist({'id'\\ :\\ d.id,\\ 'items'\\ :\\ 1}).items[d.start_idx-1:d.end_idx-1],\\ 'v:val.text')}\n  Xexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal(['green', 'blue'], getline(1, '$'))\n  Xclose\n  call assert_equal(\"{d -> map(g:Xgetlist({'id' : d.id, 'items' : 1}).items[d.start_idx-1:d.end_idx-1], 'v:val.text')}\", &quickfixtextfunc)\n  set quickfixtextfunc&\n\n  \" use a lambda function that returns an empty list\n  set quickfixtextfunc={d\\ ->\\ []}\n  Xexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal(['F1|10 col 2| green', 'F1|20 col 4| blue'],\n        \\ getline(1, '$'))\n  Xclose\n  set quickfixtextfunc&\n\n  \" use a lambda function that returns a list with empty strings\n  set quickfixtextfunc={d\\ ->\\ ['',\\ '']}\n  Xexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal(['F1|10 col 2| green', 'F1|20 col 4| blue'],\n        \\ getline(1, '$'))\n  Xclose\n  set quickfixtextfunc&\n\n  \" set the per-quickfix list text function to a lambda function\n  call g:Xsetlist([], ' ',\n        \\ {'quickfixtextfunc' :\n        \\   {d -> map(g:Xgetlist({'id' : d.id, 'items' : 1}).items[d.start_idx-1:d.end_idx-1],\n        \\ \"'Line ' .. v:val.lnum .. ', Col ' .. v:val.col\")}})\n  Xaddexpr ['F1:10:2:green', 'F1:20:4:blue']\n  Xwindow\n  call assert_equal('Line 10, Col 2', getline(1))\n  call assert_equal('Line 20, Col 4', getline(2))\n  Xclose\n  call assert_match(\"function('<lambda>\\\\d\\\\+')\", string(g:Xgetlist({'quickfixtextfunc' : 1}).quickfixtextfunc))\n  call g:Xsetlist([], 'f')\nendfunc\n\nfunc Test_qftextfunc()\n  call Xtest_qftextfunc('c')\n  call Xtest_qftextfunc('l')\nendfunc\n\nfunc Test_qftextfunc_callback()\n  let lines =<< trim END\n    set efm=%f:%l:%c:%m\n\n    #\" Test for using a function name\n    LET &qftf = 'g:Tqfexpr'\n    cexpr \"F0:0:0:L0\"\n    copen\n    call assert_equal('F0-L0C0-L0', getline(1))\n    cclose\n\n    #\" Test for using a function()\n    set qftf=function('g:Tqfexpr')\n    cexpr \"F1:1:1:L1\"\n    copen\n    call assert_equal('F1-L1C1-L1', getline(1))\n    cclose\n\n    #\" Using a funcref variable to set 'quickfixtextfunc'\n    VAR Fn = function('g:Tqfexpr')\n    LET &qftf = Fn\n    cexpr \"F2:2:2:L2\"\n    copen\n    call assert_equal('F2-L2C2-L2', getline(1))\n    cclose\n\n    #\" Using string(funcref_variable) to set 'quickfixtextfunc'\n    LET Fn = function('g:Tqfexpr')\n    LET &qftf = string(Fn)\n    cexpr \"F3:3:3:L3\"\n    copen\n    call assert_equal('F3-L3C3-L3', getline(1))\n    cclose\n\n    #\" Test for using a funcref()\n    set qftf=funcref('g:Tqfexpr')\n    cexpr \"F4:4:4:L4\"\n    copen\n    call assert_equal('F4-L4C4-L4', getline(1))\n    cclose\n\n    #\" Using a funcref variable to set 'quickfixtextfunc'\n    LET Fn = funcref('g:Tqfexpr')\n    LET &qftf = Fn\n    cexpr \"F5:5:5:L5\"\n    copen\n    call assert_equal('F5-L5C5-L5', getline(1))\n    cclose\n\n    #\" Using a string(funcref_variable) to set 'quickfixtextfunc'\n    LET Fn = funcref('g:Tqfexpr')\n    LET &qftf = string(Fn)\n    cexpr \"F5:5:5:L5\"\n    copen\n    call assert_equal('F5-L5C5-L5', getline(1))\n    cclose\n\n    #\" Test for using a lambda function with set\n    VAR optval = \"LSTART a LMIDDLE g:Tqfexpr(a) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set qftf=\" .. optval\n    cexpr \"F6:6:6:L6\"\n    copen\n    call assert_equal('F6-L6C6-L6', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to a lambda expression\n    LET &qftf = LSTART a LMIDDLE g:Tqfexpr(a) LEND\n    cexpr \"F7:7:7:L7\"\n    copen\n    call assert_equal('F7-L7C7-L7', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to string(lambda_expression)\n    LET &qftf = \"LSTART a LMIDDLE g:Tqfexpr(a) LEND\"\n    cexpr \"F8:8:8:L8\"\n    copen\n    call assert_equal('F8-L8C8-L8', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a LMIDDLE g:Tqfexpr(a) LEND\n    LET &qftf = Lambda\n    cexpr \"F9:9:9:L9\"\n    copen\n    call assert_equal('F9-L9C9-L9', getline(1))\n    cclose\n\n    #\" Set 'quickfixtextfunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a LMIDDLE g:Tqfexpr(a) LEND\n    LET &qftf = string(Lambda)\n    cexpr \"F9:9:9:L9\"\n    copen\n    call assert_equal('F9-L9C9-L9', getline(1))\n    cclose\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:TqfFunc2(info)\n    let g:TqfFunc2Args = [a:info.start_idx, a:info.end_idx]\n    return ''\n  endfunc\n  let g:TqfFunc2Args = []\n  set quickfixtextfunc=s:TqfFunc2\n  cexpr \"F10:10:10:L10\"\n  cclose\n  call assert_equal([1, 1], g:TqfFunc2Args)\n\n  let &quickfixtextfunc = 's:TqfFunc2'\n  cexpr \"F11:11:11:L11\"\n  cclose\n  call assert_equal([1, 1], g:TqfFunc2Args)\n  delfunc s:TqfFunc2\n\n  \" set 'quickfixtextfunc' to a partial with dict. This used to cause a crash.\n  func SetQftfFunc()\n    let params = {'qftf': function('g:DictQftfFunc')}\n    let &quickfixtextfunc = params.qftf\n  endfunc\n  func g:DictQftfFunc(_) dict\n  endfunc\n  call SetQftfFunc()\n  new\n  call SetQftfFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set qftf=\n  wincmd w\n  set qftf=\n  :%bw!\n\n  \" set per-quickfix list 'quickfixtextfunc' to a partial with dict. This used\n  \" to cause a crash.\n  let &qftf = ''\n  func SetLocalQftfFunc()\n    let params = {'qftf': function('g:DictQftfFunc')}\n    call setqflist([], 'a', {'quickfixtextfunc' : params.qftf})\n  endfunc\n  call SetLocalQftfFunc()\n  call test_garbagecollect_now()\n  call setqflist([], 'a', {'quickfixtextfunc' : ''})\n  delfunc g:DictQftfFunc\n  delfunc SetQftfFunc\n  delfunc SetLocalQftfFunc\n  set efm&\nendfunc\n\n\" Test for updating a location list for some other window and check that\n\" 'qftextfunc' uses the correct location list.\nfunc Test_qftextfunc_other_loclist()\n  %bw!\n  call setloclist(0, [], 'f')\n\n  \" create a window and a location list for it and open the location list\n  \" window\n  lexpr ['F1:10:12:one', 'F1:20:14:two']\n  let w1_id = win_getid()\n  call setloclist(0, [], ' ',\n        \\ {'lines': ['F1:10:12:one', 'F1:20:14:two'],\n        \\  'quickfixtextfunc':\n        \\    {d -> map(getloclist(d.winid, {'id' : d.id,\n        \\                'items' : 1}).items[d.start_idx-1:d.end_idx-1],\n        \\          \"'Line ' .. v:val.lnum .. ', Col ' .. v:val.col\")}})\n  lwindow\n  let w2_id = win_getid()\n\n  \" create another window and a location list for it and open the location\n  \" list window\n  topleft new\n  let w3_id = win_getid()\n  call setloclist(0, [], ' ',\n        \\ {'lines': ['F2:30:32:eleven', 'F2:40:34:twelve'],\n        \\  'quickfixtextfunc':\n        \\    {d -> map(getloclist(d.winid, {'id' : d.id,\n        \\                'items' : 1}).items[d.start_idx-1:d.end_idx-1],\n        \\          \"'Ligne ' .. v:val.lnum .. ', Colonne ' .. v:val.col\")}})\n  lwindow\n  let w4_id = win_getid()\n\n  topleft new\n  lexpr ['F3:50:52:green', 'F3:60:54:blue']\n  let w5_id = win_getid()\n\n  \" change the location list for some other window\n  call setloclist(0, [], 'r', {'lines': ['F3:55:56:aaa', 'F3:57:58:bbb']})\n  call setloclist(w1_id, [], 'r', {'lines': ['F1:62:63:bbb', 'F1:64:65:ccc']})\n  call setloclist(w3_id, [], 'r', {'lines': ['F2:76:77:ddd', 'F2:78:79:eee']})\n  call assert_equal(['Line 62, Col 63', 'Line 64, Col 65'],\n        \\ getbufline(winbufnr(w2_id), 1, '$'))\n  call assert_equal(['Ligne 76, Colonne 77', 'Ligne 78, Colonne 79'],\n        \\ getbufline(winbufnr(w4_id), 1, '$'))\n  call setloclist(w2_id, [], 'r', {'lines': ['F1:32:33:fff', 'F1:34:35:ggg']})\n  call setloclist(w4_id, [], 'r', {'lines': ['F2:46:47:hhh', 'F2:48:49:jjj']})\n  call assert_equal(['Line 32, Col 33', 'Line 34, Col 35'],\n        \\ getbufline(winbufnr(w2_id), 1, '$'))\n  call assert_equal(['Ligne 46, Colonne 47', 'Ligne 48, Colonne 49'],\n        \\ getbufline(winbufnr(w4_id), 1, '$'))\n\n  call win_gotoid(w5_id)\n  lwindow\n  call assert_equal(['F3|55 col 56| aaa', 'F3|57 col 58| bbb'],\n        \\ getline(1, '$'))\n  %bw!\nendfunc\n\n\" Running :lhelpgrep command more than once in a help window, doesn't jump to\n\" the help topic\nfunc Test_lhelpgrep_from_help_window()\n  call mkdir('Xtestdir/doc', 'p')\n  call writefile(['window'], 'Xtestdir/doc/a.txt')\n  call writefile(['buffer'], 'Xtestdir/doc/b.txt')\n  let save_rtp = &rtp\n  let &rtp = 'Xtestdir'\n  lhelpgrep window\n  lhelpgrep buffer\n  call assert_equal('b.txt', fnamemodify(@%, \":p:t\"))\n  lhelpgrep window\n  call assert_equal('a.txt', fnamemodify(@%, \":p:t\"))\n  let &rtp = save_rtp\n  call delete('Xtestdir', 'rf')\n  new | only!\nendfunc\n\n\" Test for the crash fixed by 7.3.715\nfunc Test_setloclist_crash()\n  %bw!\n  let g:BufNum = bufnr()\n  augroup QF_Test\n    au!\n    au BufUnload * call setloclist(0, [{'bufnr':g:BufNum, 'lnum':1, 'col':1, 'text': 'tango down'}])\n  augroup END\n\n  try\n    lvimgrep /.*/ *.mak\n  catch /E926:/\n  endtry\n  call assert_equal('tango down', getloclist(0, {'items' : 0}).items[0].text)\n  call assert_equal(1, getloclist(0, {'size' : 0}).size)\n\n  augroup QF_Test\n    au!\n  augroup END\n  unlet g:BufNum\n  %bw!\nendfunc\n\n\" Test for adding an invalid entry with the quickfix window open and making\n\" sure that the window contents are not changed\nfunc Test_add_invalid_entry_with_qf_window()\n  call setqflist([], 'f')\n  cexpr \"Xfile1:10:aa\"\n  copen\n  call setqflist(['bb'], 'a')\n  call assert_equal(1, line('$'))\n  call assert_equal(['Xfile1|10| aa'], getline(1, '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                                          , 'bufnr': bufnr('Xfile1') , 'col': 0                     , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10| aa']               , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10| aa']               , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 0    , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10| aa']               , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 0   , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10 col 666| aa']       , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 0    , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10 col 666| aa']       , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': -456 , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10 col 666-222| aa']   , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': -123 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n\n  call setqflist([{'lnum': 10                       , 'end_lnum': 6 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , 'r')\n  call assert_equal(1                               , line('$'))\n  call assert_equal(['Xfile1|10-6 col 666-222| aa'] , getline(1        , '$'))\n  call assert_equal([{'lnum': 10                    , 'end_lnum': 6 , 'bufnr': bufnr('Xfile1') , 'col': 666 , 'end_col': 222  , 'pattern': '' , 'valid': 1 , 'vcol': 0 , 'nr': -1 , 'type': '' , 'module': '' , 'text': 'aa'}] , getqflist())\n  cclose\nendfunc\n\n\" Test for very weird problem: autocommand causes a failure, resulting opening\n\" the quickfix window to fail. This still splits the window, but otherwise\n\" should not mess up buffers.\nfunc Test_quickfix_window_fails_to_open()\n  CheckScreendump\n\n  let lines =<< trim END\n      anything\n      try\n        anything\n      endtry\n  END\n  call writefile(lines, 'XquickfixFails')\n\n  let lines =<< trim END\n      split XquickfixFails\n      silent vimgrep anything %\n      normal o\n      au BufLeave * ++once source XquickfixFails\n      \" This will trigger the autocommand, which causes an error, what follows\n      \" is aborted but the window was already split.\n      silent! cwindow\n  END\n  call writefile(lines, 'XtestWinFails')\n  let buf = RunVimInTerminal('-S XtestWinFails', #{rows: 13})\n  call VerifyScreenDump(buf, 'Test_quickfix_window_fails', {})\n\n  \" clean up\n  call term_sendkeys(buf, \":bwipe!\\<CR>\")\n  call term_wait(buf)\n  call StopVimInTerminal(buf)\n  call delete('XtestWinFails')\n  call delete('XquickfixFails')\nendfunc\n\n\" Test for updating the quickfix buffer whenever the associated quickfix list\n\" is changed.\nfunc Xqfbuf_update(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xexpr \"F1:1:line1\"\n  Xopen\n  call assert_equal(['F1|1| line1'], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  \" Test setqflist() using the 'lines' key in 'what'\n  \" add a new entry\n  call g:Xsetlist([], 'a', {'lines' : ['F2:2: line2']})\n  call assert_equal(['F1|1| line1', 'F2|2| line2'], getline(1, '$'))\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" replace all the entries with a single entry\n  call g:Xsetlist([], 'r', {'lines' : ['F3:3: line3']})\n  call assert_equal(['F3|3| line3'], getline(1, '$'))\n  call assert_equal(3, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" remove all the entries\n  call g:Xsetlist([], 'r', {'lines' : []})\n  call assert_equal([''], getline(1, '$'))\n  call assert_equal(4, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" add a new list\n  call g:Xsetlist([], ' ', {'lines' : ['F4:4: line4']})\n  call assert_equal(['F4|4| line4'], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  \" Test setqflist() using the 'items' key in 'what'\n  \" add a new entry\n  call g:Xsetlist([], 'a', {'items' : [{'filename' : 'F5', 'lnum' : 5, 'text' : 'line5'}]})\n  call assert_equal(['F4|4| line4', 'F5|5| line5'], getline(1, '$'))\n  call assert_equal(2, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" replace all the entries with a single entry\n  call g:Xsetlist([], 'r', {'items' : [{'filename' : 'F6', 'lnum' : 6, 'text' : 'line6'}]})\n  call assert_equal(['F6|6| line6'], getline(1, '$'))\n  call assert_equal(3, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" remove all the entries\n  call g:Xsetlist([], 'r', {'items' : []})\n  call assert_equal([''], getline(1, '$'))\n  call assert_equal(4, g:Xgetlist({'changedtick' : 0}).changedtick)\n  \" add a new list\n  call g:Xsetlist([], ' ', {'items' : [{'filename' : 'F7', 'lnum' : 7, 'text' : 'line7'}]})\n  call assert_equal(['F7|7| line7'], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  call g:Xsetlist([], ' ', {})\n  call assert_equal([''], getline(1, '$'))\n  call assert_equal(1, g:Xgetlist({'changedtick' : 0}).changedtick)\n\n  Xclose\nendfunc\n\nfunc Test_qfbuf_update()\n  call Xqfbuf_update('c')\n  call Xqfbuf_update('l')\nendfunc\n\nfunc Test_vimgrep_noswapfile()\n  set noswapfile\n  call writefile(['one', 'two', 'three'], 'Xgreppie')\n  vimgrep two Xgreppie\n  call assert_equal('two', getline('.'))\n\n  call delete('Xgreppie')\n  set swapfile\nendfunc\n\n\" Test for the :vimgrep 'f' flag (fuzzy match)\nfunc Xvimgrep_fuzzy_match(cchar)\n  call s:setup_commands(a:cchar)\n\n  Xvimgrep /three one/f Xfile*\n  let l = g:Xgetlist()\n  call assert_equal(2, len(l))\n  call assert_equal(['Xfile1', 1, 9, 'one two three'],\n        \\ [bufname(l[0].bufnr), l[0].lnum, l[0].col, l[0].text])\n  call assert_equal(['Xfile2', 2, 1, 'three one two'],\n        \\ [bufname(l[1].bufnr), l[1].lnum, l[1].col, l[1].text])\n\n  Xvimgrep /the/f Xfile*\n  let l = g:Xgetlist()\n  call assert_equal(3, len(l))\n  call assert_equal(['Xfile1', 1, 9, 'one two three'],\n        \\ [bufname(l[0].bufnr), l[0].lnum, l[0].col, l[0].text])\n  call assert_equal(['Xfile2', 2, 1, 'three one two'],\n        \\ [bufname(l[1].bufnr), l[1].lnum, l[1].col, l[1].text])\n  call assert_equal(['Xfile2', 4, 4, 'aaathreeaaa'],\n        \\ [bufname(l[2].bufnr), l[2].lnum, l[2].col, l[2].text])\n\n  Xvimgrep /aaa/fg Xfile*\n  let l = g:Xgetlist()\n  call assert_equal(4, len(l))\n  call assert_equal(['Xfile1', 2, 1, 'aaaaaa'],\n        \\ [bufname(l[0].bufnr), l[0].lnum, l[0].col, l[0].text])\n  call assert_equal(['Xfile1', 2, 4, 'aaaaaa'],\n        \\ [bufname(l[1].bufnr), l[1].lnum, l[1].col, l[1].text])\n  call assert_equal(['Xfile2', 4, 1, 'aaathreeaaa'],\n        \\ [bufname(l[2].bufnr), l[2].lnum, l[2].col, l[2].text])\n  call assert_equal(['Xfile2', 4, 9, 'aaathreeaaa'],\n        \\ [bufname(l[3].bufnr), l[3].lnum, l[3].col, l[3].text])\n\n  call assert_fails('Xvimgrep /xyz/fg Xfile*', 'E480:')\nendfunc\n\nfunc Test_vimgrep_fuzzy_match()\n  call writefile(['one two three', 'aaaaaa'], 'Xfile1')\n  call writefile(['one', 'three one two', 'two', 'aaathreeaaa'], 'Xfile2')\n  call Xvimgrep_fuzzy_match('c')\n  call Xvimgrep_fuzzy_match('l')\n  call delete('Xfile1')\n  call delete('Xfile2')\nendfunc\n\nfunc Test_locationlist_open_in_newtab()\n  call s:create_test_file('Xqftestfile1')\n  call s:create_test_file('Xqftestfile2')\n  call s:create_test_file('Xqftestfile3')\n\n  %bwipe!\n\n  lgetexpr ['Xqftestfile1:5:Line5',\n\t\t\\ 'Xqftestfile2:10:Line10',\n\t\t\\ 'Xqftestfile3:16:Line16']\n\n  silent! llast\n  call assert_equal(1, tabpagenr('$'))\n  call assert_equal('Xqftestfile3', bufname())\n\n  set switchbuf=newtab\n\n  silent! lfirst\n  call assert_equal(2, tabpagenr('$'))\n  call assert_equal('Xqftestfile1', bufname())\n\n  silent! lnext\n  call assert_equal(3, tabpagenr('$'))\n  call assert_equal('Xqftestfile2', bufname())\n\n  call delete('Xqftestfile1')\n  call delete('Xqftestfile2')\n  call delete('Xqftestfile3')\n  set switchbuf&vim\n\n  %bwipe!\nendfunc\n\n\" Test for win_gettype() in quickfix and location list windows\nfunc Test_win_gettype()\n  copen\n  call assert_equal(\"quickfix\", win_gettype())\n  let wid = win_getid()\n  wincmd p\n  call assert_equal(\"quickfix\", win_gettype(wid))\n  cclose\n  lexpr ''\n  lopen\n  call assert_equal(\"loclist\", win_gettype())\n  let wid = win_getid()\n  wincmd p\n  call assert_equal(\"loclist\", win_gettype(wid))\n  lclose\nendfunc\n\nfun Test_vimgrep_nomatch()\n  call XexprTests('c')\n  call g:Xsetlist([{'lnum':10,'text':'Line1'}])\n  copen\n  if has(\"win32\")\n    call assert_fails('vimgrep foo *.zzz', 'E479:')\n    let expected = [{'lnum': 10, 'bufnr': 0, 'end_lnum': 0, 'pattern': '', 'valid': 0, 'vcol': 0, 'nr': 0, 'module': '', 'type': '', 'end_col': 0, 'col': 0, 'text': 'Line1'}]\n  else\n    call assert_fails('vimgrep foo *.zzz', 'E480:')\n    let expected = []\n  endif\n  call assert_equal(expected, getqflist())\n  cclose\nendfunc\n\n\" Test for opening the quickfix window in two tab pages and then closing one\n\" of the quickfix windows. This should not make the quickfix buffer unlisted.\n\" (github issue #9300).\nfunc Test_two_qf_windows()\n  cexpr \"F1:1:line1\"\n  copen\n  tabnew\n  copen\n  call assert_true(&buflisted)\n  cclose\n  tabfirst\n  call assert_true(&buflisted)\n  let bnum = bufnr()\n  cclose\n  \" if all the quickfix windows are closed, then buffer should be unlisted.\n  call assert_false(buflisted(bnum))\n  %bw!\n\n  \" Repeat the test for a location list\n  lexpr \"F2:2:line2\"\n  lopen\n  let bnum = bufnr()\n  tabnew\n  exe \"buffer\" bnum\n  tabfirst\n  lclose\n  tablast\n  call assert_true(buflisted(bnum))\n  tabclose\n  lopen\n  call assert_true(buflisted(bnum))\n  lclose\n  call assert_false(buflisted(bnum))\n  %bw!\nendfunc\n\n\" Weird sequence of commands that caused entering a wiped-out buffer\nfunc Test_lopen_bwipe()\n  func R()\n    silent! tab lopen\n    e x\n    silent! lfile\n  endfunc\n\n  cal R()\n  cal R()\n  cal R()\n  bw!\n  delfunc R\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/buffer.c", "src/testdir/test_quickfix.vim", "src/version.c"], "buggy_code_start_loc": [1708, 981, 748], "buggy_code_end_loc": [2293, 5837, 748], "fixing_code_start_loc": [1709, 982, 749], "fixing_code_end_loc": [2299, 5855, 751], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 8.2.", "other": {"cve": {"id": "CVE-2022-0443", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-02T21:15:07.990", "lastModified": "2022-12-13T16:57:24.153", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 8.2."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio de GitHub vim/vim de versiones anteriores a 8.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.4281", "matchCriteriaId": "394CBA8F-48EA-483E-AA5F-C7076CC00B98"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/9b4a80a66544f2782040b641498754bcb5b8d461", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/b987c8cb-bbbe-4601-8a6c-54ff907c6b51", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00022.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UFXFAILMLUIK4MBUEZO4HNBNKYZRJ5AP/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/9b4a80a66544f2782040b641498754bcb5b8d461"}}