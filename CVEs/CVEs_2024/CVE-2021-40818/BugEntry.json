{"buggy_code": ["/**\n *\n * Glewlwyd SSO Server\n *\n * Authentiation server\n * Users are authenticated via various backend available: database, ldap\n * Using various authentication methods available: password, OTP, send code, etc.\n * \n * WebAuthn scheme module\n * \n * Copyright 2019-2020 Nicolas Mora <mail@babelouest.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU GENERAL PUBLIC LICENSE\n * License as published by the Free Software Foundation;\n * version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU GENERAL PUBLIC LICENSE for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include <string.h>\n#include <gnutls/gnutls.h>\n#include <gnutls/crypto.h>\n#include <gnutls/abstract.h>\n#include <jansson.h>\n#include <cbor.h>\n#include <ldap.h>\n#include <yder.h>\n#include <orcania.h>\n#include <rhonabwy.h>\n#include \"glewlwyd-common.h\"\n\nconst char * iso_3166_list[] = {\"AF\", \"AX\", \"AL\", \"DZ\", \"AS\", \"AD\", \"AO\", \"AI\", \"AQ\", \"AG\", \"AR\", \"AM\", \"AW\", \"AU\", \"AT\", \"AZ\", \"BH\", \"BS\", \"BD\", \"BB\", \"BY\", \"BE\", \"BZ\", \"BJ\", \"BM\", \"BT\", \"BO\", \"BQ\", \"BA\", \"BW\", \"BV\", \"BR\", \"IO\", \"BN\", \"BG\", \"BF\", \"BI\", \"KH\", \"CM\", \"CA\", \"CV\", \"KY\", \"CF\", \"TD\", \"CL\", \"CN\", \"CX\", \"CC\", \"CO\", \"KM\", \"CG\", \"CD\", \"CK\", \"CR\", \"CI\", \"HR\", \"CU\", \"CW\", \"CY\", \"CZ\", \"DK\", \"DJ\", \"DM\", \"DO\", \"EC\", \"EG\", \"SV\", \"GQ\", \"ER\", \"EE\", \"ET\", \"FK\", \"FO\", \"FJ\", \"FI\", \"FR\", \"GF\", \"PF\", \"TF\", \"GA\", \"GM\", \"GE\", \"DE\", \"GH\", \"GI\", \"GR\", \"GL\", \"GD\", \"GP\", \"GU\", \"GT\", \"GG\", \"GN\", \"GW\", \"GY\", \"HT\", \"HM\", \"VA\", \"HN\", \"HK\", \"HU\", \"IS\", \"IN\", \"ID\", \"IR\", \"IQ\", \"IE\", \"IM\", \"IL\", \"IT\", \"JM\", \"JP\", \"JE\", \"JO\", \"KZ\", \"KE\", \"KI\", \"KP\", \"KR\", \"KW\", \"KG\", \"LA\", \"LV\", \"LB\", \"LS\", \"LR\", \"LY\", \"LI\", \"LT\", \"LU\", \"MO\", \"MK\", \"MG\", \"MW\", \"MY\", \"MV\", \"ML\", \"MT\", \"MH\", \"MQ\", \"MR\", \"MU\", \"YT\", \"MX\", \"FM\", \"MD\", \"MC\", \"MN\", \"ME\", \"MS\", \"MA\", \"MZ\", \"MM\", \"NA\", \"NR\", \"NP\", \"NL\", \"NC\", \"NZ\", \"NI\", \"NE\", \"NG\", \"NU\", \"NF\", \"MP\", \"NO\", \"OM\", \"PK\", \"PW\", \"PS\", \"PA\", \"PG\", \"PY\", \"PE\", \"PH\", \"PN\", \"PL\", \"PT\", \"PR\", \"QA\", \"RE\", \"RO\", \"RU\", \"RW\", \"BL\", \"SH\", \"KN\", \"LC\", \"MF\", \"PM\", \"VC\", \"WS\", \"SM\", \"ST\", \"SA\", \"SN\", \"RS\", \"SC\", \"SL\", \"SG\", \"SX\", \"SK\", \"SI\", \"SB\", \"SO\", \"ZA\", \"GS\", \"SS\", \"ES\", \"LK\", \"SD\", \"SR\", \"SJ\", \"SZ\", \"SE\", \"CH\", \"SY\", \"TW\", \"TJ\", \"TZ\", \"TH\", \"TL\", \"TG\", \"TK\", \"TO\", \"TT\", \"TN\", \"TR\", \"TM\", \"TC\", \"TV\", \"UG\", \"UA\", \"AE\", \"GB\", \"US\", \"UM\", \"UY\", \"UZ\", \"VU\", \"VE\", \"VN\", \"VG\", \"VI\", \"WF\", \"EH\", \"YE\", \"ZM\", \"ZW\", NULL};\n#define G_PACKED_CERT_O_KEY    \"O=\"\n#define G_PACKED_CERT_OU_KEY   \"OU=\"\n#define G_PACKED_CERT_C_KEY    \"C=\"\n#define G_PACKED_CERT_CN_KEY   \"CN=\"\n#define G_PACKED_CERT_OU_VALUE \"Authenticator Attestation\"\n#define G_PACKED_OID_AAGUID    \"1.3.6.1.4.1.45724.1.1.4\"\n\n#define G_TABLE_WEBAUTHN_USER       \"gs_webauthn_user\"\n#define G_TABLE_WEBAUTHN_CREDENTIAL \"gs_webauthn_credential\"\n#define G_TABLE_WEBAUTHN_ASSERTION  \"gs_webauthn_assertion\"\n\n#define SESSION_LENGTH 32\n#define USER_ID_LENGTH 32\n\n#define FLAG_USER_PRESENT 0x01\n#define FLAG_USER_VERIFY  0x04\n#define FLAG_AT           0x40\n#define FLAG_ED           0x80\n\n#define COUNTER_LEN   4\n#define AAGUID_LEN    16\n#define CRED_ID_L_LEN 2\n\n#define FLAGS_OFFSET 32\n#define COUNTER_OFFSET (FLAGS_OFFSET+1)\n#define ATTESTED_CRED_DATA_OFFSET (COUNTER_OFFSET+COUNTER_LEN)\n#define CRED_ID_L_OFFSET (ATTESTED_CRED_DATA_OFFSET+AAGUID_LEN)\n#define CREDENTIAL_ID_OFFSET (ATTESTED_CRED_DATA_OFFSET+AAGUID_LEN+CRED_ID_L_LEN)\n\n#define ECDSA256 -7\n#define ECDSA384 -35\n#define ECDSA512 -36\n\n#define SAFETYNET_ISSUED_TO \"CN=attest.android.com\"\n\nstatic json_t * get_cert_from_file_path(const char * path) {\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat = {NULL, 0}, export_dat = {NULL, 0};\n  FILE * fl;\n  size_t len, issued_for_len = 128;\n  char * cert_content, issued_for[128] = {};\n  json_t * j_return = NULL;\n  \n  fl = fopen(path, \"r\");\n  if (fl != NULL) {\n    fseek(fl, 0, SEEK_END);\n    len = ftell(fl);\n    cert_content = o_malloc(len);\n    if (cert_content != NULL) {\n      if (fseek(fl, 0, SEEK_SET) == -1) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error fseek\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      } else if (fread(cert_content, 1, len, fl) != len) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error fread\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      } else {\n        cert_dat.data = (unsigned char *)cert_content;\n        cert_dat.size = len;\n        if (!gnutls_x509_crt_init(&cert)) {\n          if (gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER) >= 0 || gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_PEM) >= 0) {\n            if (!gnutls_x509_crt_get_dn(cert, issued_for, &issued_for_len)) {\n              if (gnutls_x509_crt_export2(cert, GNUTLS_X509_FMT_PEM, &export_dat) >= 0) {\n                j_return = json_pack(\"{sis{ss%ss%}}\", \"result\", G_OK, \"certificate\", \"dn\", issued_for, issued_for_len, \"x509\", export_dat.data, export_dat.size);\n                gnutls_free(export_dat.data);\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error gnutls_x509_crt_export2\");\n                j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n              }\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error gnutls_x509_crt_get_dn\");\n              j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error gnutls_x509_crt_import\");\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error gnutls_x509_crt_init\");\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n        }\n        gnutls_x509_crt_deinit(cert);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error o_malloc cert_content\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_MEMORY);\n    }\n    o_free(cert_content);\n    fclose(fl);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error fopen %s\", path);\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\nstatic json_t * is_scheme_parameters_valid(json_t * j_params) {\n  json_t * j_return, * j_error, * j_element = NULL, * j_cert;\n  size_t index = 0;\n  json_int_t pubkey;\n  char * message;\n  \n  if (json_is_object(j_params)) {\n    j_error = json_array();\n    if (j_error != NULL) {\n      if (!json_is_boolean(json_object_get(j_params, \"session-mandatory\"))) {\n        json_array_append_new(j_error, json_string(\"session-mandatory is mandatory and must be a boolean\"));\n      }\n      if (json_object_get(j_params, \"seed\") != NULL && !json_is_string(json_object_get(j_params, \"seed\"))) {\n        json_array_append_new(j_error, json_string(\"seed is optional and must be a string\"));\n      }\n      if (json_integer_value(json_object_get(j_params, \"challenge-length\")) <= 0) {\n        json_array_append_new(j_error, json_string(\"challenge-length is mandatory and must be a positive integer\"));\n      }\n      if (json_integer_value(json_object_get(j_params, \"credential-expiration\")) <= 0) {\n        json_array_append_new(j_error, json_string(\"credential-expiration is mandatory and must be a positive integer\"));\n      }\n      if (json_integer_value(json_object_get(j_params, \"credential-assertion\")) <= 0) {\n        json_array_append_new(j_error, json_string(\"credential-assertion is mandatory and must be a positive integer\"));\n      }\n      if (!json_string_length(json_object_get(j_params, \"rp-origin\"))) {\n        json_array_append_new(j_error, json_string(\"rp-origin is mandatory and must be a non empty string\"));\n      }\n      if (!json_array_size(json_object_get(j_params, \"pubKey-cred-params\"))) {\n        json_array_append_new(j_error, json_string(\"pubKey-cred-params is mandatory and must be a non empty JSON array\"));\n      } else {\n        json_array_foreach(json_object_get(j_params, \"pubKey-cred-params\"), index, j_element) {\n          pubkey = json_integer_value(j_element);\n          //if (pubkey != -7 && pubkey != -35 && pubkey != -36 && pubkey != -257 && pubkey != -258 && pubkey != -259) {\n          if (pubkey != ECDSA256 && pubkey != ECDSA384 && pubkey != ECDSA512) {\n            //json_array_append_new(j_error, json_string(\"pubKey-cred-params elements values available are -7, -35, -36 (ECDSA) or -257, -258, -259 (RSA)\"));\n            json_array_append_new(j_error, json_string(\"pubKey-cred-params elements values available are -7, -35, -36 (ECDSA)\"));\n          }\n        }\n      }\n      if (json_object_get(j_params, \"ctsProfileMatch\") != NULL && (!json_is_integer(json_object_get(j_params, \"ctsProfileMatch\")) || json_integer_value(json_object_get(j_params, \"ctsProfileMatch\")) < -1 || json_integer_value(json_object_get(j_params, \"ctsProfileMatch\")) > 1)) {\n        json_array_append_new(j_error, json_string(\"ctsProfileMatch is optional and must be an integer between -1 and 1\"));\n      }\n      if (json_object_get(j_params, \"basicIntegrity\") != NULL && (!json_is_integer(json_object_get(j_params, \"basicIntegrity\")) || json_integer_value(json_object_get(j_params, \"basicIntegrity\")) < -1 || json_integer_value(json_object_get(j_params, \"basicIntegrity\")) > 1)) {\n        json_array_append_new(j_error, json_string(\"basicIntegrity is optional and must be an integer between -1 and 1\"));\n      }\n      if (json_object_get(j_params, \"google-root-ca-r2\") != NULL && !json_is_string(json_object_get(j_params, \"google-root-ca-r2\"))) {\n        json_array_append_new(j_error, json_string(\"google-root-ca-r2 is optional and must be a string\"));\n      } else if (json_string_length(json_object_get(j_params, \"google-root-ca-r2\"))) {\n        j_cert = get_cert_from_file_path(json_string_value(json_object_get(j_params, \"google-root-ca-r2\")));\n        if (check_result_value(j_cert, G_OK)) {\n          json_object_set(j_params, \"google-root-ca-r2-content\", json_object_get(j_cert, \"certificate\"));\n        } else {\n          message = msprintf(\"Error parsing google-root-ca-r2 certificate file %s\", json_string_value(json_object_get(j_params, \"google-root-ca-r2\")));\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n        }\n        json_decref(j_cert);\n      }\n      if (json_object_get(j_params, \"root-ca-list\") != NULL) {\n        if (!json_is_array(json_object_get(j_params, \"root-ca-list\"))) {\n          json_array_append_new(j_error, json_string(\"root-ca-list is optional and must be an array of strings\"));\n        } else {\n          json_object_set_new(j_params, \"root-ca-array\", json_array());\n          json_array_foreach(json_object_get(j_params, \"root-ca-list\"), index, j_element) {\n            if (!json_string_length(j_element)) {\n              json_array_append_new(j_error, json_string(\"root-ca-list is optional and must be an array of strings\"));\n            } else {\n              j_cert = get_cert_from_file_path(json_string_value(j_element));\n              if (check_result_value(j_cert, G_OK)) {\n                json_array_append(json_object_get(j_params, \"root-ca-array\"), json_object_get(j_cert, \"certificate\"));\n              } else {\n                message = msprintf(\"Error parsing certificate file %s\", json_string_value(j_element));\n                json_array_append_new(j_error, json_string(message));\n                o_free(message);\n              }\n              json_decref(j_cert);\n            }\n          }\n        }\n      }\n      if (json_object_get(j_params, \"force-fmt-none\") != NULL && !json_is_boolean(json_object_get(j_params, \"force-fmt-none\"))) {\n        json_array_append_new(j_error, json_string(\"allow-fmt-none is optional and must be a boolean\"));\n      }\n      if (json_object_get(j_params, \"fmt\") != NULL && (!json_is_object(json_object_get(j_params, \"fmt\")) || (json_object_get(json_object_get(j_params, \"fmt\"), \"packed\") != json_true() && json_object_get(json_object_get(j_params, \"fmt\"), \"tpm\") != json_true() && json_object_get(json_object_get(j_params, \"fmt\"), \"android-key\") != json_true() && json_object_get(json_object_get(j_params, \"fmt\"), \"android-safetynet\") != json_true() && json_object_get(json_object_get(j_params, \"fmt\"), \"fido-u2f\") != json_true() && json_object_get(json_object_get(j_params, \"fmt\"), \"none\") != json_true()))) {\n        json_array_append_new(j_error, json_string(\"fmt must be a JSON object filled with supported formats: 'packed' 'tpm', 'android-key', 'android-safetynet', 'fido-u2f', 'none'\"));\n      }\n      if (json_array_size(j_error)) {\n        j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n      } else {\n        j_return = json_pack(\"{si}\", \"result\", G_OK);\n      }\n      json_decref(j_error);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"is_scheme_parameters_valid - Error allocating resources for j_error\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n  } else {\n    j_return = json_pack(\"{sis[s]}\", \"result\", G_ERROR_PARAM, \"error\", \"parameters must be a JSON object\");\n  }\n  return j_return;\n}\n\n/**\n * Get the user_id associated with the username in the table G_TABLE_WEBAUTHN_USER\n * If user_id doesn't exist, create one, stores it, and return the new user_id\n */\nstatic json_t * get_user_id_from_username(struct config_module * config, json_t * j_param, const char * username, int create) {\n  json_t * j_query, * j_result, * j_return;\n  int res;\n  char * username_escaped, * username_clause;\n  unsigned char new_user_id[USER_ID_LENGTH] = {0}, new_user_id_b64[USER_ID_LENGTH*2] = {0};\n  size_t new_user_id_b64_len;\n  \n  username_escaped = h_escape_string_with_quotes(config->conn, username);\n  username_clause = msprintf(\" = UPPER(%s)\", username_escaped);\n  j_query = json_pack(\"{sss[s]s{s{ssss}sO}}\",\n                      \"table\",\n                      G_TABLE_WEBAUTHN_USER,\n                      \"columns\",\n                        \"gswu_user_id AS user_id\",\n                      \"where\",\n                        \"UPPER(gswu_username)\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          username_clause,\n                        \"gswu_mod_name\",\n                        json_object_get(j_param, \"mod_name\"));\n  o_free(username_clause);\n  o_free(username_escaped);\n  res = h_select(config->conn, j_query, &j_result, NULL);\n  json_decref(j_query);\n  if (res == H_OK) {\n    if (json_array_size(j_result)) {\n      j_return = json_pack(\"{siss}\", \"result\", G_OK, \"user_id\", json_string_value(json_object_get(json_array_get(j_result, 0), \"user_id\")));\n    } else if (create) {\n      // Generates a new user_id, and stores it in the database\n      gnutls_rnd(GNUTLS_RND_KEY, new_user_id, USER_ID_LENGTH);\n      if (o_base64_encode(new_user_id, USER_ID_LENGTH, new_user_id_b64, &new_user_id_b64_len)) {\n        j_query = json_pack(\"{sss{sOssss}}\",\n                            \"table\",\n                            G_TABLE_WEBAUTHN_USER,\n                            \"values\",\n                              \"gswu_mod_name\",\n                              json_object_get(j_param, \"mod_name\"),\n                              \"gswu_username\",\n                              username,\n                              \"gswu_user_id\",\n                              new_user_id_b64);\n        res = h_insert(config->conn, j_query, NULL);\n        json_decref(j_query);\n        if (res == H_OK) {\n          j_return = json_pack(\"{siss}\", \"result\", G_OK, \"user_id\", new_user_id_b64);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"get_user_id_from_username - Error executing j_query insert\");\n          config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"get_user_id_from_username - Error o_base64_encode\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    }\n    json_decref(j_result);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_user_id_from_username - Error executing j_query select\");\n    config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n  }\n  return j_return;\n}\n\nstatic json_t * get_credential_list(struct config_module * config, json_t * j_params, const char * username, int restrict_to_registered) {\n  json_t * j_query, * j_result, * j_return, * j_element = NULL;\n  int res;\n  char * username_escaped, * mod_name_escaped, * username_clause;\n  size_t index = 0;\n  \n  username_escaped = h_escape_string_with_quotes(config->conn, username);\n  mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n  username_clause = msprintf(\" = (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n  j_query = json_pack(\"{sss[ssss]s{s{ssss}}}\",\n                      \"table\",\n                      G_TABLE_WEBAUTHN_CREDENTIAL,\n                      \"columns\",\n                        \"gswc_credential_id AS credential_id\",\n                        \"gswc_name AS name\",\n                        SWITCH_DB_TYPE(config->conn->type, \"UNIX_TIMESTAMP(gswc_created_at) AS created_at\", \"strftime('%s', gswc_created_at) AS created_at\", \"EXTRACT(EPOCH FROM gswc_created_at)::integer AS created_at\"),\n                        \"gswc_status\",\n                      \"where\",\n                        \"gswu_id\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          username_clause);\n  o_free(username_clause);\n  o_free(username_escaped);\n  o_free(mod_name_escaped);\n  if (restrict_to_registered) {\n    json_object_set_new(json_object_get(j_query, \"where\"), \"gswc_status\", json_integer(1));\n  } else {\n    json_object_set_new(json_object_get(j_query, \"where\"), \"gswc_status\", json_pack(\"{ssss}\", \"operator\", \"raw\", \"value\", \" IN (1,3)\"));\n  }\n  res = h_select(config->conn, j_query, &j_result, NULL);\n  json_decref(j_query);\n  if (res == H_OK) {\n    if (json_array_size(j_result)) {\n      j_return = json_pack(\"{sis[]}\", \"result\", G_OK, \"credential\");\n      if (j_return != NULL) {\n        json_array_foreach(j_result, index, j_element) {\n          switch (json_integer_value(json_object_get(j_element, \"gswc_status\"))) {\n            case 1:\n              json_object_set_new(j_element, \"status\", json_string(\"registered\"));\n              break;\n            case 3:\n              json_object_set_new(j_element, \"status\", json_string(\"disabled\"));\n              break;\n            default:\n              break;\n          }\n          json_object_del(j_element, \"gswc_status\");\n          json_array_append(json_object_get(j_return, \"credential\"), j_element);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential_list - Error json_pack\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    }\n    json_decref(j_result);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential_list - Error executing j_query\");\n    config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n  }\n  return j_return;\n}\n\nstatic json_t * generate_new_credential(struct config_module * config, json_t * j_params, const char * username) {\n  json_t * j_query, * j_return;\n  char * username_escaped, * mod_name_escaped, * username_clause, * challenge_hash;\n  int res;\n  size_t challenge_b64_len, challenge_len = (size_t)json_integer_value(json_object_get(j_params, \"challenge-length\"));\n  unsigned char challenge_b64[challenge_len*2], challenge[challenge_len+1];\n  char session[SESSION_LENGTH+1] = {0}, * session_hash;\n  \n  gnutls_rnd(GNUTLS_RND_NONCE, challenge, challenge_len);\n  if (o_base64_encode(challenge, challenge_len, challenge_b64, &challenge_b64_len)) {\n    challenge_b64[challenge_b64_len] = '\\0';\n    if ((challenge_hash = generate_hash(config->hash_algorithm, (const char *)challenge_b64)) != NULL) {\n      rand_string(session, SESSION_LENGTH);\n      if ((session_hash = generate_hash(config->hash_algorithm, session)) != NULL) {\n        username_escaped = h_escape_string_with_quotes(config->conn, username);\n        mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n        username_clause = msprintf(\" (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n        // Disable all credential with status 0 (new) of the same user\n        j_query = json_pack(\"{sss{si}s{s{ssss+}si}}\",\n                            \"table\",\n                            G_TABLE_WEBAUTHN_CREDENTIAL,\n                            \"set\",\n                              \"gswc_status\",\n                              2,\n                            \"where\",\n                              \"gswu_id\",\n                                \"operator\",\n                                \"raw\",\n                                \"value\",\n                                \" =\",\n                                username_clause,\n                              \"gswc_status\",\n                              0);\n        res = h_update(config->conn, j_query, NULL);\n        json_decref(j_query);\n        if (res == H_OK) {\n          // Insert new credential\n          j_query = json_pack(\"{sss{s{ss}sssssi}}\",\n                              \"table\",\n                              G_TABLE_WEBAUTHN_CREDENTIAL,\n                              \"values\",\n                                \"gswu_id\",\n                                  \"raw\",\n                                  username_clause,\n                                \"gswc_session_hash\",\n                                session_hash,\n                                \"gswc_challenge_hash\",\n                                challenge_hash,\n                                \"gswc_status\",\n                                0);\n          res = h_insert(config->conn, j_query, NULL);\n          json_decref(j_query);\n          if (res == H_OK) {\n            j_return = json_pack(\"{sis{ssss}}\", \"result\", G_OK, \"credential\", \"session\", session, \"challenge\", challenge_b64);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_credential - Error executing j_query insert\");\n            config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_credential - Error executing j_query update\");\n          config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n        }\n        o_free(username_clause);\n        o_free(username_escaped);\n        o_free(mod_name_escaped);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_credential - Error generate_hash session\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      o_free(session_hash);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_credential - Error generate_hash challenge\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    o_free(challenge_hash);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_credential - Error o_base64_encode challenge\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\nstatic json_t * generate_new_assertion(struct config_module * config, json_t * j_params, const char * username, int mock) {\n  json_t * j_query, * j_return;\n  char * username_escaped, * username_clause, * mod_name_escaped, * challenge_hash;\n  int res;\n  size_t challenge_b64_len, challenge_len = (size_t)json_integer_value(json_object_get(j_params, \"challenge-length\"));\n  unsigned char challenge_b64[challenge_len*2], challenge[challenge_len+1];\n  char session[SESSION_LENGTH+1] = {0}, * session_hash;\n  \n  gnutls_rnd(GNUTLS_RND_NONCE, challenge, challenge_len);\n  if (o_base64_encode(challenge, challenge_len, challenge_b64, &challenge_b64_len)) {\n    challenge_b64[challenge_b64_len] = '\\0';\n    if ((challenge_hash = generate_hash(config->hash_algorithm, (const char *)challenge_b64)) != NULL) {\n      rand_string(session, SESSION_LENGTH);\n      if ((session_hash = generate_hash(config->hash_algorithm, session)) != NULL) {\n        if (mock < 2) {\n          username_escaped = h_escape_string_with_quotes(config->conn, username);\n          mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n          username_clause = msprintf(\" (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n          // Disable all assertions with status 0 (new) of the same user\n          j_query = json_pack(\"{sss{si}s{s{ssss+}si}}\",\n                              \"table\",\n                              G_TABLE_WEBAUTHN_ASSERTION,\n                              \"set\",\n                                \"gswa_status\",\n                                3,\n                              \"where\",\n                                \"gswu_id\",\n                                  \"operator\",\n                                  \"raw\",\n                                  \"value\",\n                                  \" =\",\n                                  username_clause,\n                                \"gswa_status\",\n                                0);\n          res = h_update(config->conn, j_query, NULL);\n          json_decref(j_query);\n          if (res == H_OK) {\n            // Insert new assertion\n            j_query = json_pack(\"{sss{s{ss}sssssisi}}\",\n                                \"table\",\n                                G_TABLE_WEBAUTHN_ASSERTION,\n                                \"values\",\n                                  \"gswu_id\",\n                                    \"raw\",\n                                    username_clause,\n                                  \"gswa_session_hash\",\n                                  session_hash,\n                                  \"gswa_challenge_hash\",\n                                  challenge_hash,\n                                  \"gswa_status\",\n                                  0,\n                                  \"gswa_mock\",\n                                  mock);\n            res = h_insert(config->conn, j_query, NULL);\n            json_decref(j_query);\n            if (res == H_OK) {\n              j_return = json_pack(\"{sis{ssss}}\", \"result\", G_OK, \"assertion\", \"session\", session, \"challenge\", challenge_b64);\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_assertion - Error executing j_query insert\");\n              config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n              j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_assertion - Error executing j_query update\");\n            config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n          }\n          o_free(username_clause);\n          o_free(mod_name_escaped);\n          o_free(username_escaped);\n        } else {\n          j_return = json_pack(\"{sis{ssss}}\", \"result\", G_OK, \"assertion\", \"session\", session, \"challenge\", challenge_b64);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_assertion - Error generate_hash session\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      o_free(session_hash);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_assertion - Error generate_hash challenge\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    o_free(challenge_hash);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_assertion - Error o_base64_encode challenge\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\nstatic json_t * get_credential_from_session(struct config_module * config, json_t * j_params, const char * username, const char * session) {\n  json_t * j_query, * j_result, * j_return;\n  char * username_escaped, * mod_name_escaped, * username_clause, * expiration_clause;\n  char * session_hash;\n  int res;\n  time_t now;\n  \n  if (o_strlen(session)) {\n    session_hash = generate_hash(config->hash_algorithm, session);\n    if (session_hash != NULL) {\n      time(&now);\n      username_escaped = h_escape_string_with_quotes(config->conn, username);\n      mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n      username_clause = msprintf(\" = (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n      if (config->conn->type==HOEL_DB_TYPE_MARIADB) {\n        expiration_clause = msprintf(\"> FROM_UNIXTIME(%u)\", (now - (unsigned int)json_integer_value(json_object_get(j_params, \"credential-expiration\"))));\n      } else if (config->conn->type==HOEL_DB_TYPE_PGSQL) {\n        expiration_clause = msprintf(\"> TO_TIMESTAMP(%u)\", (now - (unsigned int)json_integer_value(json_object_get(j_params, \"credential-expiration\"))));\n      } else { // HOEL_DB_TYPE_SQLITE\n        expiration_clause = msprintf(\"> %u\", (now - (unsigned int)json_integer_value(json_object_get(j_params, \"credential-expiration\"))));\n      }\n      j_query = json_pack(\"{sss[ssssss]s{sss{ssss}sis{ssss}}}\",\n                          \"table\",\n                          G_TABLE_WEBAUTHN_CREDENTIAL,\n                          \"columns\",\n                            \"gswc_id\",\n                            \"gswu_id\",\n                            \"gswc_session_hash AS session_hash\",\n                            \"gswc_challenge_hash AS challenge_hash\",\n                            \"gswc_credential_id AS credential_id\",\n                            \"gswc_public_key AS public_key\",\n                          \"where\",\n                            \"gswc_session_hash\",\n                            session_hash,\n                            \"gswu_id\",\n                              \"operator\",\n                              \"raw\",\n                              \"value\",\n                              username_clause,\n                            \"gswc_status\",\n                            0,\n                            \"gswc_created_at\",\n                              \"operator\",\n                              \"raw\",\n                              \"value\",\n                              expiration_clause);\n      o_free(username_clause);\n      o_free(username_escaped);\n      o_free(mod_name_escaped);\n      o_free(expiration_clause);\n      res = h_select(config->conn, j_query, &j_result, NULL);\n      json_decref(j_query);\n      if (res == H_OK) {\n        if (json_array_size(j_result)) {\n          j_return = json_pack(\"{sisO}\", \"result\", G_OK, \"credential\", json_array_get(j_result, 0));\n        } else {\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n        }\n        json_decref(j_result);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential_from_session - Error executing j_query\");\n        config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential_from_session - Error generate_hash\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    o_free(session_hash);\n  } else {\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n  }\n  return j_return;\n}\n\nstatic json_t * get_credential(struct config_module * config, json_t * j_params, const char * username, const char * credential_id) {\n  json_t * j_query, * j_result, * j_return;\n  char * username_escaped, * mod_name_escaped, * username_clause;\n  int res;\n  \n  username_escaped = h_escape_string_with_quotes(config->conn, username);\n  mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n  username_clause = msprintf(\" = (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n  j_query = json_pack(\"{sss[sss]s{sss{ssss}s{ssss}}}\",\n                      \"table\",\n                      G_TABLE_WEBAUTHN_CREDENTIAL,\n                      \"columns\",\n                        \"gswc_id\",\n                        \"gswc_public_key AS public_key\",\n                        \"gswc_counter AS counter\",\n                      \"where\",\n                        \"gswc_credential_id\",\n                        credential_id,\n                        \"gswu_id\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          username_clause,\n                        \"gswc_status\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          \" IN (1,3)\");\n  o_free(username_clause);\n  o_free(username_escaped);\n  o_free(mod_name_escaped);\n  res = h_select(config->conn, j_query, &j_result, NULL);\n  json_decref(j_query);\n  if (res == H_OK) {\n    if (json_array_size(j_result)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_OK, \"credential\", json_array_get(j_result, 0));\n    } else {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    }\n    json_decref(j_result);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential - Error executing j_query\");\n    config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n  }\n  return j_return;\n}\n\nstatic int update_credential(struct config_module * config, json_t * j_params, const char * username, const char * credential_id, int status) {\n  json_t * j_query;\n  char * username_escaped, * mod_name_escaped, * username_clause;\n  int res, ret;\n  \n  username_escaped = h_escape_string_with_quotes(config->conn, username);\n  mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n  username_clause = msprintf(\" = (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n  j_query = json_pack(\"{sss{si}s{sss{ssss}}}\",\n                      \"table\",\n                      G_TABLE_WEBAUTHN_CREDENTIAL,\n                      \"set\",\n                        \"gswc_status\",\n                        status,\n                      \"where\",\n                        \"gswc_credential_id\",\n                        credential_id,\n                        \"gswu_id\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          username_clause);\n  o_free(username_clause);\n  o_free(username_escaped);\n  o_free(mod_name_escaped);\n  res = h_update(config->conn, j_query, NULL);\n  json_decref(j_query);\n  if (res == H_OK) {\n    ret = G_OK;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential - Error executing j_query\");\n    config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n    ret = G_ERROR_DB;\n  }\n  return ret;\n}\n\nstatic int update_credential_name(struct config_module * config, json_t * j_params, const char * username, const char * credential_id, const char * name) {\n  json_t * j_query;\n  char * username_escaped, * mod_name_escaped, * username_clause;\n  int res, ret;\n  \n  username_escaped = h_escape_string_with_quotes(config->conn, username);\n  mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n  username_clause = msprintf(\" = (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n  j_query = json_pack(\"{sss{ss}s{sss{ssss}}}\",\n                      \"table\",\n                      G_TABLE_WEBAUTHN_CREDENTIAL,\n                      \"set\",\n                        \"gswc_name\",\n                        name,\n                      \"where\",\n                        \"gswc_credential_id\",\n                        credential_id,\n                        \"gswu_id\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          username_clause);\n  o_free(username_clause);\n  o_free(username_escaped);\n  o_free(mod_name_escaped);\n  res = h_update(config->conn, j_query, NULL);\n  json_decref(j_query);\n  if (res == H_OK) {\n    ret = G_OK;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential - Error executing j_query\");\n    config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n    ret = G_ERROR_DB;\n  }\n  return ret;\n}\n\nstatic json_t * get_assertion_from_session(struct config_module * config, json_t * j_params, const char * username, const char * session, int mock) {\n  json_t * j_query, * j_result, * j_return;\n  char * username_escaped, * mod_name_escaped, * username_clause, * expiration_clause;\n  char * session_hash;\n  int res;\n  time_t now;\n  \n  if (o_strlen(session)) {\n    session_hash = generate_hash(config->hash_algorithm, session);\n    if (session_hash != NULL) {\n      time(&now);\n      username_escaped = h_escape_string_with_quotes(config->conn, username);\n      mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n      username_clause = msprintf(\" = (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n      if (config->conn->type==HOEL_DB_TYPE_MARIADB) {\n        expiration_clause = msprintf(\"> FROM_UNIXTIME(%u)\", (now - (unsigned int)json_integer_value(json_object_get(j_params, \"credential-assertion\"))));\n      } else if (config->conn->type==HOEL_DB_TYPE_PGSQL) {\n        expiration_clause = msprintf(\"> TO_TIMESTAMP(%u)\", (now - (unsigned int)json_integer_value(json_object_get(j_params, \"credential-assertion\"))));\n      } else { // HOEL_DB_TYPE_SQLITE\n        expiration_clause = msprintf(\"> %u\", (now - (unsigned int)json_integer_value(json_object_get(j_params, \"credential-assertion\"))));\n      }\n      j_query = json_pack(\"{sss[ssss]s{sss{ssss}sis{ssss}si}}\",\n                          \"table\",\n                          G_TABLE_WEBAUTHN_ASSERTION,\n                          \"columns\",\n                            \"gswa_id\",\n                            \"gswu_id\",\n                            \"gswa_session_hash AS session_hash\",\n                            \"gswa_challenge_hash AS challenge_hash\",\n                          \"where\",\n                            \"gswa_session_hash\",\n                            session_hash,\n                            \"gswu_id\",\n                              \"operator\",\n                              \"raw\",\n                              \"value\",\n                              username_clause,\n                            \"gswa_status\",\n                            0,\n                            \"gswa_issued_at\",\n                              \"operator\",\n                              \"raw\",\n                              \"value\",\n                              expiration_clause,\n                            \"gswa_mock\",\n                            mock);\n      o_free(username_clause);\n      o_free(username_escaped);\n      o_free(mod_name_escaped);\n      o_free(expiration_clause);\n      res = h_select(config->conn, j_query, &j_result, NULL);\n      json_decref(j_query);\n      if (res == H_OK) {\n        if (json_array_size(j_result)) {\n          j_return = json_pack(\"{sisO}\", \"result\", G_OK, \"assertion\", json_array_get(j_result, 0));\n        } else {\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n        }\n        json_decref(j_result);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"get_assertion_from_session - Error executing j_query\");\n        config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"get_assertion_from_session - Error generate_hash\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    o_free(session_hash);\n  } else {\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n  }\n  return j_return;\n}\n\nstatic int check_certificate(struct config_module * config, json_t * j_params, const char * credential_id, json_int_t gswu_id) {\n  json_t * j_query, * j_result;\n  int res, ret;\n  char * credential_id_escaped, * mod_name_escaped, * where_clause;\n  \n  credential_id_escaped = h_escape_string_with_quotes(config->conn, credential_id);\n  mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n  where_clause = msprintf(\" IN (SELECT gswu_id FROM \" G_TABLE_WEBAUTHN_CREDENTIAL \" WHERE gswc_credential_id=%s AND gswc_status=1 AND gswu_id IN (SELECT gswu_id FROM \" G_TABLE_WEBAUTHN_USER \" WHERE gswu_mod_name=%s))\", credential_id_escaped, mod_name_escaped);\n  j_query = json_pack(\"{sss[s]s{s{ssss}si}}\",\n                      \"table\",\n                      G_TABLE_WEBAUTHN_CREDENTIAL,\n                      \"columns\",\n                        \"gswu_id\",\n                      \"where\",\n                        \"gswu_id\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          where_clause,\n                        \"gswc_status\",\n                        1);\n  o_free(where_clause);\n  o_free(mod_name_escaped);\n  o_free(credential_id_escaped);\n  res = h_select(config->conn, j_query, &j_result, NULL);\n  json_decref(j_query);\n  if (res == H_OK) {\n    if (json_array_size(j_result)) {\n      if (json_integer_value(json_object_get(json_array_get(j_result, 0), \"gswu_id\")) == gswu_id) {\n        ret = G_OK;\n      } else {\n        ret = G_ERROR_UNAUTHORIZED;\n      }\n    } else {\n      ret = G_ERROR_NOT_FOUND;\n    }\n    json_decref(j_result);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_credential_id - Error executing j_query\");\n    config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n    ret = G_ERROR_DB;\n  }\n  return ret;\n}\n\nstatic int validate_certificate_from_root(json_t * j_params, gnutls_x509_crt_t cert_leaf, cbor_item_t * x5c_array) {\n  int ret = G_ERROR_NOT_FOUND, res;\n  unsigned int result;\n  gnutls_datum_t cert_dat = {NULL, 0}, issuer_dat = {NULL, 0};\n  gnutls_x509_trust_list_t tlist = NULL;\n  gnutls_x509_crt_t cert_x509[cbor_array_size(x5c_array)+1], root_x509 = NULL;\n  json_t * j_cert = NULL;\n  cbor_item_t * cbor_cert = NULL;\n  size_t index = 0, i = 0, x5c_array_size = cbor_array_size(x5c_array);\n  char * issuer;\n  \n  for (i=0; i<x5c_array_size+1; i++) {\n    cert_x509[i] = NULL;\n  }\n  if ((res = gnutls_x509_crt_get_issuer_dn2(cert_leaf, &issuer_dat)) >= 0) {\n    issuer = o_strndup((const char *)issuer_dat.data, issuer_dat.size);\n    json_array_foreach(json_object_get(j_params, \"root-ca-array\"), index, j_cert) {\n      if (0 == o_strcmp(issuer, json_string_value(json_object_get(j_cert, \"dn\")))) {\n        cert_dat.data = (unsigned char *)json_string_value(json_object_get(j_cert, \"x509\"));\n        cert_dat.size = json_string_length(json_object_get(j_cert, \"x509\"));\n        if (!gnutls_x509_crt_init(&root_x509) && !gnutls_x509_crt_import(root_x509, &cert_dat, GNUTLS_X509_FMT_PEM)) {\n          cert_x509[0] = cert_leaf;\n          for (i=1; i<x5c_array_size; i++) {\n            cbor_cert = cbor_array_get(x5c_array, i);\n            cert_dat.data = cbor_bytestring_handle(cbor_cert);\n            cert_dat.size = cbor_bytestring_length(cbor_cert);\n            if (gnutls_x509_crt_init(&cert_x509[i]) < 0 || gnutls_x509_crt_import(cert_x509[i], &cert_dat, GNUTLS_X509_FMT_DER) < 0) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"validate_certificate_from_root - Error import chain cert at index %zu\", i);\n              ret = G_ERROR;\n            }\n            cbor_decref(&cbor_cert);\n          }\n          cert_x509[x5c_array_size] = root_x509;\n          ret = G_OK;\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"validate_certificate_from_root - Error import root cert\");\n          ret = G_ERROR;\n        }\n      }\n    }\n    o_free(issuer);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"validate_certificate_from_root - Error gnutls_x509_crt_get_issuer_dn2: %d\", res);\n    ret = G_ERROR;\n  }\n  gnutls_free(issuer_dat.data);\n  \n  if (ret == G_OK) {\n    if (!gnutls_x509_trust_list_init(&tlist, 0)) {\n      if (gnutls_x509_trust_list_add_cas(tlist, &root_x509, 1, 0) >= 0) {\n        if (gnutls_x509_trust_list_verify_crt(tlist, cert_x509, 2, 0, &result, NULL) >= 0) {\n          if (result) {\n            y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_certificate_from_root - certificate chain invalid\");\n            ret = G_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"validate_certificate_from_root - Error gnutls_x509_trust_list_verify_crt\");\n          ret = G_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"validate_certificate_from_root - Error gnutls_x509_trust_list_add_cas\");\n        ret = G_ERROR;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"validate_certificate_from_root - Error gnutls_x509_trust_list_init\");\n      ret = G_ERROR;\n    }\n  }\n  gnutls_x509_crt_deinit(root_x509);\n  for (i=1; i<x5c_array_size; i++) {\n    gnutls_x509_crt_deinit(cert_x509[i]);\n  }\n  gnutls_x509_trust_list_deinit(tlist, 0);\n  return ret;\n}\n\nstatic int validate_safetynet_ca_root(json_t * j_params, gnutls_x509_crt_t cert_leaf, json_t * j_header_x5c) {\n  gnutls_x509_crt_t cert_x509[(json_array_size(j_header_x5c)+1)], root_x509 = NULL;\n  gnutls_x509_trust_list_t tlist = NULL;\n  int ret = G_OK;\n  unsigned int result, i;\n  json_t * j_cert;\n  unsigned char * header_cert_decoded;\n  size_t header_cert_decoded_len;\n  gnutls_datum_t cert_dat;\n  \n  cert_x509[0] = cert_leaf;\n  for (i=1; i<json_array_size(j_header_x5c); i++) {\n    j_cert = json_array_get(j_header_x5c, i);\n    \n    if ((header_cert_decoded = o_malloc(json_string_length(j_cert))) != NULL) {\n      if (o_base64_decode((const unsigned char *)json_string_value(j_cert), json_string_length(j_cert), header_cert_decoded, &header_cert_decoded_len)) {\n        if (!gnutls_x509_crt_init(&cert_x509[i])) {\n          cert_dat.data = header_cert_decoded;\n          cert_dat.size = header_cert_decoded_len;\n          if ((ret = gnutls_x509_crt_import(cert_x509[i], &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error gnutls_x509_crt_import: %d\", ret);\n            ret = G_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error gnutls_x509_crt_init\");\n          ret = G_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error o_base64_decode x5c leaf\");\n        ret = G_ERROR;\n      }\n      o_free(header_cert_decoded);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error allocating resources for header_cert_decoded\");\n      ret = G_ERROR_MEMORY;\n    }\n  }\n  \n  if (ret == G_OK) {\n    cert_dat.data = (unsigned char *)json_string_value(json_object_get(json_object_get(j_params, \"google-root-ca-r2-content\"), \"x509\"));\n    cert_dat.size = json_string_length(json_object_get(json_object_get(j_params, \"google-root-ca-r2-content\"), \"x509\"));\n    if (!gnutls_x509_crt_init(&cert_x509[json_array_size(j_header_x5c)]) && \n        !gnutls_x509_crt_import(cert_x509[json_array_size(j_header_x5c)], &cert_dat, GNUTLS_X509_FMT_PEM)) {\n      if (!gnutls_x509_crt_init(&root_x509) && \n          !gnutls_x509_crt_import(root_x509, &cert_dat, GNUTLS_X509_FMT_PEM)) {\n        if (!gnutls_x509_trust_list_init(&tlist, 0)) {\n          if (gnutls_x509_trust_list_add_cas(tlist, &root_x509, 1, 0) >= 0) {\n            if (gnutls_x509_trust_list_verify_crt(tlist, cert_x509, (json_array_size(j_header_x5c)+1), 0, &result, NULL) >= 0) {\n              if (!result) {\n                ret = G_OK;\n              } else {\n                y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_safetynet_ca_root - certificate chain invalid\");\n                ret = G_ERROR;\n              }\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error gnutls_x509_trust_list_verify_crt\");\n              ret = G_ERROR;\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error gnutls_x509_trust_list_add_cas\");\n            ret = G_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error gnutls_x509_trust_list_init\");\n          ret = G_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error import root cert\");\n        ret = G_ERROR;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error import last cert\");\n      ret = G_ERROR;\n    }\n  }\n  // Clean after me\n  for (i=1; i<json_array_size(j_header_x5c); i++) {\n    gnutls_x509_crt_deinit(cert_x509[i]);\n  }\n  gnutls_x509_crt_deinit(cert_x509[json_array_size(j_header_x5c)]);\n  gnutls_x509_trust_list_deinit(tlist, 1);\n  return ret;\n}\n\nstatic int validate_packed_leaf_certificate(gnutls_x509_crt_t cert, unsigned char * aaguid) {\n  int ret = G_OK, i, c_valid = 0, o_valid = 0, ou_valid = 0, cn_valid = 0;\n  unsigned int critial = 1, ca = 1;\n  char cert_dn[128] = {0}, ** dn_exploded = NULL;\n  unsigned char aaguid_oid[32];\n  size_t cert_dn_len = 128, aaguid_oid_len = 32;\n  \n  do {\n    if (gnutls_x509_crt_get_version(cert) != 3) {\n      ret = G_ERROR_PARAM;\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Invalid certificate version\");\n      break;\n    }\n    \n    if ((ret = gnutls_x509_crt_get_dn(cert, cert_dn, &cert_dn_len)) < 0) {\n      ret = G_ERROR_PARAM;\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Error gnutls_x509_crt_get_dn\");\n      break;\n    }\n    \n    if ((dn_exploded = ldap_explode_dn(cert_dn, 0)) == NULL) {\n      ret = G_ERROR;\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Error ldap_explode_dn\");\n      break;\n    }\n    \n    for (i=0; dn_exploded[i] != NULL; i++) {\n      if (0 == o_strncasecmp(G_PACKED_CERT_C_KEY, dn_exploded[i], o_strlen(G_PACKED_CERT_C_KEY)) && string_array_has_value(iso_3166_list, dn_exploded[i]+o_strlen(G_PACKED_CERT_C_KEY))) {\n        c_valid = 1;\n      } else if (0 == o_strncasecmp(G_PACKED_CERT_O_KEY, dn_exploded[i], o_strlen(G_PACKED_CERT_O_KEY)) && o_strlen(dn_exploded[i]) > 2) {\n        o_valid = 1;\n      } else if (0 == o_strncasecmp(G_PACKED_CERT_CN_KEY, dn_exploded[i], o_strlen(G_PACKED_CERT_CN_KEY)) && o_strlen(dn_exploded[i]) > 3) {\n        cn_valid = 1;\n      } else if (0 == o_strncasecmp(G_PACKED_CERT_OU_KEY, dn_exploded[i], o_strlen(G_PACKED_CERT_OU_KEY)) && 0 == o_strcmp(G_PACKED_CERT_OU_VALUE, dn_exploded[i]+o_strlen(G_PACKED_CERT_OU_KEY))) {\n        ou_valid = 1;\n      }\n    }\n    ber_memvfree((void **)dn_exploded);\n    \n    if (!c_valid || !o_valid || !cn_valid || !ou_valid) {\n      ret = G_ERROR_PARAM;\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Invalid dn - C:%s - O:%s - OU:%s - CN:%s\", c_valid?\"valid\":\"invalid\", o_valid?\"valid\":\"invalid\", ou_valid?\"valid\":\"invalid\", cn_valid?\"valid\":\"invalid\");\n      break;\n    }\n    \n    if (gnutls_x509_crt_get_basic_constraints(cert, &critial, &ca, NULL) < 0) {\n      ret = G_ERROR;\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Error gnutls_x509_crt_get_basic_constraints\");\n      break;\n    }\n    \n    if (ca) {\n      ret = G_ERROR_PARAM;\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Error basic constraints for CA is set to true\");\n      break;\n    }\n    \n    if (gnutls_x509_crt_get_extension_by_oid(cert, G_PACKED_OID_AAGUID, 0, aaguid_oid, &aaguid_oid_len, NULL) >= 0) {\n      if (aaguid_oid_len != AAGUID_LEN+2) {\n        ret = G_ERROR_PARAM;\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Invalid aaguid_oid_len size %zu\", aaguid_oid_len);\n        break;\n      }\n      \n      if (memcmp(aaguid_oid+2, aaguid, AAGUID_LEN)) {\n        ret = G_ERROR_PARAM;\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Invalid aaguid_oid match\");\n        break;\n      }\n    }\n    \n  } while (0);\n  \n  return ret;\n}\n\n/**\n * \n * Validate the attStmt object under the packed format\n * https://w3c.github.io/webauthn/#sctn-packed-attestation\n * (Step) Hey girl, when you smile\n * You got to know that you drive me wild\n * \n */\nstatic json_t * check_attestation_packed(json_t * j_params, cbor_item_t * auth_data, cbor_item_t * att_stmt, const unsigned char * client_data, gnutls_pubkey_t g_key) {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key, * alg = NULL, * sig = NULL, * x5c_array = NULL, * cert_leaf = NULL;\n  size_t i, client_data_hash_len = 32, cert_export_len = 128, cert_export_b64_len = 0;\n  char * message;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  int ret, sig_alg = GNUTLS_SIGN_UNKNOWN;\n  unsigned char client_data_hash[32], cert_export[128], cert_export_b64[256];\n\n  data.data = NULL;\n  UNUSED(j_params);\n  \n  if (j_error != NULL) {\n    do {\n      for (i=0; i<cbor_map_size(att_stmt); i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char *)cbor_string_handle(key), \"alg\", MIN(o_strlen(\"alg\"), cbor_string_length(key))) && cbor_isa_negint(cbor_map_handle(att_stmt)[i].value)) {\n            alg = cbor_map_handle(att_stmt)[i].value;\n            if (cbor_get_int(alg) == 6) {\n              sig_alg = GNUTLS_SIGN_ECDSA_SHA256;\n            } else if (cbor_get_int(alg) == 34) {\n              sig_alg = GNUTLS_SIGN_ECDSA_SHA384;\n            } else if (cbor_get_int(alg) == 35) {\n              sig_alg = GNUTLS_SIGN_ECDSA_SHA512;\n            }\n            if (sig_alg == GNUTLS_SIGN_UNKNOWN) {\n              json_array_append_new(j_error, json_string(\"Signature algorithm not supported\"));\n              break;\n            }\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"sig\", MIN(o_strlen(\"sig\"), cbor_string_length(key))) && cbor_isa_bytestring(cbor_map_handle(att_stmt)[i].value)) {\n            sig = cbor_map_handle(att_stmt)[i].value;\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"x5c\", MIN(o_strlen(\"x5c\"), cbor_string_length(key))) && cbor_isa_array(cbor_map_handle(att_stmt)[i].value) && cbor_array_size(cbor_map_handle(att_stmt)[i].value)) {\n            x5c_array = cbor_map_handle(att_stmt)[i].value;\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"ecdaaKeyId\", MIN(o_strlen(\"ecdaaKeyId\"), cbor_string_length(key)))) {\n            json_array_append_new(j_error, json_string(\"ecdaaKeyId not supported\"));\n            break;\n          }\n        } else {\n          message = msprintf(\"attStmt map element %zu key is not a string\", i);\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          break;\n        }\n      }\n      \n      if (json_array_size(j_error)) {\n        break;\n      }\n      \n      if (alg == NULL || sig == NULL) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_packed - Error alg or sig are not mapped in att_stmt\");\n        break;\n      }\n      \n      if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Error generate_digest_raw client_data\");\n        break;\n      }\n      \n      if ((data.data = o_malloc(cbor_bytestring_length(auth_data) + client_data_hash_len)) == NULL) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Error o_malloc data.data\");\n        break;\n      }\n      \n      signature.data = cbor_bytestring_handle(sig);\n      signature.size = cbor_bytestring_length(sig);\n      \n      memcpy(data.data, cbor_bytestring_handle(auth_data), cbor_bytestring_length(auth_data));\n      memcpy(data.data + cbor_bytestring_length(auth_data), client_data_hash, client_data_hash_len);\n      data.size = cbor_bytestring_length(auth_data) + client_data_hash_len;\n        \n      // packed disable SELF attestation for now\n      if (x5c_array == NULL) {\n        if (gnutls_pubkey_verify_data2(g_key, sig_alg, 0, &data, &signature)) {\n          json_array_append_new(j_error, json_string(\"Invalid signature\"));\n          break;\n        }\n        \n        cert_export_b64_len = 0;\n        cert_export_b64[0] = '\\0';\n      } else {\n        if (gnutls_x509_crt_init(&cert)) {\n          json_array_append_new(j_error, json_string(\"check_attestation_packed - Error gnutls_x509_crt_init\"));\n          break;\n        }\n        if (gnutls_pubkey_init(&pubkey)) {\n          json_array_append_new(j_error, json_string(\"check_attestation_packed - Error gnutls_pubkey_init\"));\n          break;\n        }\n\n        cert_leaf = cbor_array_get(x5c_array, 0);\n        cert_dat.data = cbor_bytestring_handle(cert_leaf);\n        cert_dat.size = cbor_bytestring_length(cert_leaf);\n        \n        if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n          json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Error gnutls_pcert_import_x509_raw: %d\", ret);\n          break;\n        }\n        \n        if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) {\n          json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Error gnutls_pubkey_import_x509: %d\", ret);\n          break;\n        }\n        \n        if (gnutls_pubkey_verify_data2(pubkey, sig_alg, 0, &data, &signature)) {\n          json_array_append_new(j_error, json_string(\"Invalid signature\"));\n          break;\n        }\n        \n        if (validate_packed_leaf_certificate(cert, (cbor_bytestring_handle(auth_data)+ATTESTED_CRED_DATA_OFFSET)) != G_OK) {\n          json_array_append_new(j_error, json_string(\"Invalid certificate\"));\n          break;\n        }\n        \n        if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) {\n          json_array_append_new(j_error, json_string(\"Error exporting x509 certificate\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Error gnutls_x509_crt_get_key_id: %d\", ret);\n          break;\n        }\n        \n        if (json_object_get(j_params, \"root-ca-list\") != json_null() && validate_certificate_from_root(j_params, cert, x5c_array) != G_OK) {\n          json_array_append_new(j_error, json_string(\"Unrecognized certificate authority\"));\n          if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) {\n            message = msprintf(\"Unrecognized certificate autohority: %.*s\", cert_issued_by.size, cert_issued_by.data);\n            y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - %s\", message);\n            o_free(message);\n            gnutls_free(cert_issued_by.data);\n          } else {\n            y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Unrecognized certificate autohority (unable to get issuer dn)\");\n          }\n          break;\n        }\n        \n        if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) {\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Error o_base64_encode cert_export\");\n          break;\n        }\n      }\n      \n    } while (0);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_x509_crt_deinit(cert);\n    gnutls_pubkey_deinit(pubkey);\n    o_free(data.data);\n    if (cert_leaf != NULL) {\n      cbor_decref(&cert_leaf);\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_packed - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\n/**\n * \n * Validate the attStmt object under the Android SafetyNet format\n * https://w3c.github.io/webauthn/#sctn-android-safetynet-attestation\n * (step) hey girl, in your eyes\n * I see a picture of me all the time\n * \n */\nstatic json_t * check_attestation_android_safetynet(json_t * j_params, cbor_item_t * auth_data, cbor_item_t * att_stmt, const unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n  unsigned char pubkey_export[1024] = {0}, cert_export[32] = {0}, cert_export_b64[64], client_data_hash[32], * nonce_base = NULL, nonce_base_hash[32], * nonce_base_hash_b64 = NULL, * header_cert_decoded = NULL;\n  char * message = NULL, * response_token = NULL, issued_to[128] = {0}, * jwt_header = NULL;\n  size_t pubkey_export_len = 1024, cert_export_len = 32, cert_export_b64_len, issued_to_len = 128, client_data_hash_len = 32, nonce_base_hash_len = 32, nonce_base_hash_b64_len = 0, header_cert_decoded_len = 0;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  cbor_item_t * key, * response = NULL;\n  int i, ret;\n  jwt_t * j_response = NULL;\n  json_t * j_header_x5c = NULL, * j_cert = NULL, * j_header = NULL, * j_value = NULL;\n  gnutls_datum_t cert_dat;\n  int has_ver = 0;\n  \n  if (j_error != NULL) {\n    do {\n      // Step 1\n      if (!cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'attStmt' invalid format\"));\n        break;\n      }\n      for (i=0; i<2; i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char *)cbor_string_handle(key), \"ver\", MIN(o_strlen(\"ver\"), cbor_string_length(key))) && cbor_isa_string(cbor_map_handle(att_stmt)[i].value)) {\n            has_ver = 1;\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"response\", MIN(o_strlen(\"response\"), cbor_string_length(key))) && cbor_isa_bytestring(cbor_map_handle(att_stmt)[i].value)) {\n            response = cbor_map_handle(att_stmt)[i].value;\n          } else {\n            message = msprintf(\"attStmt map element %d key is not valid: '%.*s'\", i, cbor_string_length(key), cbor_string_handle(key));\n            json_array_append_new(j_error, json_string(message));\n            o_free(message);\n            break;\n          }\n        } else {\n          message = msprintf(\"attStmt map element %d key is not a string\", i);\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          break;\n        }\n      }\n      \n      if (!has_ver) {\n        json_array_append_new(j_error, json_string(\"version invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error ver missing\");\n        break;\n      }\n\n      if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error generate_digest_raw client_data\");\n        break;\n      }\n      \n      if ((nonce_base = o_malloc(32 + cbor_bytestring_length(auth_data))) == NULL) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error allocating resources for nonce_base\");\n        break;\n      }\n      memcpy(nonce_base, cbor_bytestring_handle(auth_data), cbor_bytestring_length(auth_data));\n      memcpy(nonce_base+cbor_bytestring_length(auth_data), client_data_hash, client_data_hash_len);\n      \n      if (!generate_digest_raw(digest_SHA256, nonce_base, 32 + cbor_bytestring_length(auth_data), nonce_base_hash, &nonce_base_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error generate_digest_raw nonce_base\");\n        break;\n      }\n      \n      if ((nonce_base_hash_b64 = o_malloc(64)) == NULL) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error allocating resources for nonce_base_hash_b64\");\n        break;\n      }\n\n      if (!o_base64_encode(nonce_base_hash, 32, nonce_base_hash_b64, &nonce_base_hash_b64_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error o_base64_encode for nonce_base_hash_b64\");\n        break;\n      }\n      \n      if (response == NULL) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error response missing\");\n        break;\n      }\n      \n      if ((response_token = o_strndup((const char *)cbor_bytestring_handle(response), cbor_bytestring_length(response))) == NULL) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error o_strndup for response_token\");\n        break;\n      }\n      \n      if (r_jwt_init(&j_response) != RHN_OK) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error r_jwt_init\");\n        break;\n      }\n      \n      if (r_jwt_parse(j_response, response_token, 0) != RHN_OK) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error r_jwt_parse\");\n        break;\n      }\n      \n      if (o_strcmp(r_jwt_get_claim_str_value(j_response, \"nonce\"), (const char *)nonce_base_hash_b64)) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error nonce invalid\");\n        break;\n      }\n      \n      if (json_integer_value(json_object_get(j_params, \"ctsProfileMatch\")) != -1 && json_integer_value(json_object_get(j_params, \"ctsProfileMatch\")) != ((j_value = r_jwt_get_claim_json_t_value(j_response, \"ctsProfileMatch\"))==json_true()?1:0)) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error ctsProfileMatch invalid\");\n        json_decref(j_value);\n        j_value = NULL;\n        break;\n      }\n      json_decref(j_value);\n      j_value = NULL;\n      \n      if (json_integer_value(json_object_get(j_params, \"basicIntegrity\")) != -1 && json_integer_value(json_object_get(j_params, \"basicIntegrity\")) != ((j_value = r_jwt_get_claim_json_t_value(j_response, \"basicIntegrity\"))==json_true()?1:0)) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error basicIntegrity invalid\");\n        j_value = NULL;\n        break;\n      }\n      json_decref(j_value);\n      j_value = NULL;\n      \n      if (r_jwt_verify_signature(j_response, NULL, 0) != RHN_OK) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error r_jwt_verify_signature\");\n        break;\n      }\n      \n      if ((j_header_x5c = r_jwt_get_header_json_t_value(j_response, \"x5c\")) == NULL) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error parsing x5c JSON\");\n        break;\n      }\n      \n      if (!json_is_string((j_cert = json_array_get(j_header_x5c, 0)))) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error x5c leaf not a string\");\n        break;\n      }\n      \n      if ((header_cert_decoded = o_malloc(json_string_length(j_cert))) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error allocating resources for header_cert_decoded\");\n        break;\n      }\n      \n      if (!o_base64_decode((const unsigned char *)json_string_value(j_cert), json_string_length(j_cert), header_cert_decoded, &header_cert_decoded_len)) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error o_base64_decode x5c leaf\");\n        break;\n      }\n      \n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error, json_string(\"internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error gnutls_x509_crt_init\");\n        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error, json_string(\"internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error gnutls_pubkey_init\");\n        break;\n      }\n      cert_dat.data = header_cert_decoded;\n      cert_dat.size = header_cert_decoded_len;\n      if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error gnutls_pcert_import_x509_raw: %d\", ret);\n        break;\n      }\n      if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error gnutls_pubkey_import_x509: %d\", ret);\n        break;\n      }\n      if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error exporting x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error gnutls_x509_crt_get_key_id: %d\", ret);\n        break;\n      }\n      if ((ret = gnutls_x509_crt_get_dn(cert, issued_to, &issued_to_len)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error x509 dn\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error gnutls_x509_crt_get_dn: %d\", ret);\n        break;\n      }\n      if (o_strnstr(issued_to, SAFETYNET_ISSUED_TO, issued_to_len) == NULL) {\n        json_array_append_new(j_error, json_string(\"Error x509 dn\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - safetynet certificate issued for %.*s\", issued_to_len, issued_to);\n        break;\n      }\n      if (json_object_get(j_params, \"google-root-ca-r2\") != json_null()) {\n        if ((ret = validate_safetynet_ca_root(j_params, cert, j_header_x5c)) == G_ERROR_UNAUTHORIZED) {\n          json_array_append_new(j_error, json_string(\"Error x509 certificate chain validation\"));\n          break;\n        } else if (ret != G_OK) {\n          json_array_append_new(j_error, json_string(\"response invalid\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - safetynet certificate chain certificate validation error\");\n          break;\n        }\n      }\n      if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error o_base64_encode cert_export\");\n        break;\n      }\n      if ((ret = gnutls_pubkey_export(pubkey, GNUTLS_X509_FMT_PEM, pubkey_export, &pubkey_export_len)) < 0) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error gnutls_pubkey_export: %d\", ret);\n        break;\n      }\n      \n    } while (0);\n\n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    json_decref(j_header);\n    json_decref(j_header_x5c);\n    gnutls_pubkey_deinit(pubkey);\n    gnutls_x509_crt_deinit(cert);\n    r_jwt_free(j_response);\n    o_free(nonce_base);\n    o_free(nonce_base_hash_b64);\n    o_free(response_token);\n    o_free(header_cert_decoded);\n    o_free(jwt_header);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\n/**\n * \n * Validate the attStmt object under the fido-u2f format\n * https://w3c.github.io/webauthn/#sctn-fido-u2f-attestation\n * Gonna get to you girl\n * Really want you in my world\n * \n */\nstatic json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL) {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n        break;\n      }\n      \n      // Step 1\n      if (att_stmt == NULL || !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'attStmt' invalid format\"));\n        break;\n      }\n      for (i=0; i<2; i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char *)cbor_string_handle(key), \"x5c\", MIN(o_strlen(\"x5c\"), cbor_string_length(key)))) {\n            x5c = cbor_map_handle(att_stmt)[i].value;\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"sig\", MIN(o_strlen(\"sig\"), cbor_string_length(key)))) {\n            sig = cbor_map_handle(att_stmt)[i].value;\n          } else {\n            message = msprintf(\"attStmt map element %d key is not valid: '%.*s'\", i, cbor_string_length(key), cbor_string_handle(key));\n            json_array_append_new(j_error, json_string(message));\n            o_free(message);\n            break;\n          }\n        } else {\n          message = msprintf(\"attStmt map element %d key is not a string\", i);\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          break;\n        }\n      }\n      if (x5c == NULL || !cbor_isa_array(x5c) || cbor_array_size(x5c) != 1) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'x5c' invalid format\"));\n        break;\n      }\n      att_cert = cbor_array_get(x5c, 0);\n      cert_dat.data = cbor_bytestring_handle(att_cert);\n      cert_dat.size = cbor_bytestring_length(att_cert);\n      if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d\", ret);\n        break;\n      }\n      if (json_object_get(j_params, \"root-ca-list\") != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK) {\n        json_array_append_new(j_error, json_string(\"Unrecognized certificate authority\"));\n        if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) {\n          message = msprintf(\"Unrecognized certificate autohority: %.*s\", cert_issued_by.size, cert_issued_by.data);\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - %s\", message);\n          o_free(message);\n          gnutls_free(cert_issued_by.data);\n        } else {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Unrecognized certificate autohority (unable to get issuer dn)\");\n        }\n        break;\n      }\n      if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d\", ret);\n        break;\n      }\n      if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error exporting x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d\", ret);\n        break;\n      }\n      if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error o_base64_encode cert_export\");\n        break;\n      }\n      if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig)) {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n      data_signed_offset+=client_data_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, credential_id, credential_id_len);\n      data_signed_offset+=credential_id_len;\n      \n      data_signed[data_signed_offset] = 0x04;\n      data_signed_offset++;\n      \n      memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);\n      data_signed_offset+=cert_x_len;\n      \n      memcpy(data_signed+data_signed_offset, cert_y, cert_y_len);\n      data_signed_offset+=cert_y_len;\n        \n      // Let's verify sig over data_signed\n      data.data = data_signed;\n      data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {\n      cbor_decref(&att_cert);\n    }\n    \n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\n/**\n * \n * It's like the New Kids On The Block\n * \n * You have to validate the credential by following\n * the registration procedure step by step\n * Because the w3c said so\n * https://w3c.github.io/webauthn/#registering-a-new-credential\n * \n */\nstatic json_t * register_new_attestation(struct config_module * config, json_t * j_params, json_t * j_scheme_data, json_t * j_credential) {\n  json_t * j_return, * j_client_data = NULL, * j_error, * j_result, * j_pubkey = NULL, * j_cert = NULL, * j_query, * j_element = NULL;\n  unsigned char * client_data = NULL, * challenge_b64 = NULL, * att_obj = NULL, * cbor_bs_handle = NULL, rpid_hash[32], * fmt = NULL, * credential_id_b64 = NULL, * cbor_auth_data, * cred_pub_key, cert_x[256], cert_y[256], pubkey_export[1024];\n  char * challenge_hash = NULL, * message = NULL;\n  const char * rpid = NULL;\n  size_t client_data_len = 0, challenge_b64_len = 0, att_obj_len = 0, rpid_hash_len = 32, fmt_len = 0, credential_id_len = 0, credential_id_b64_len, cbor_auth_data_len, cred_pub_key_len, cert_x_len = 0, cert_y_len = 0, pubkey_export_len = 1024, index = 0, cbor_bs_handle_len, rpid_len;\n  uint32_t counter = 0;\n  int ret = G_OK, res, status, has_x = 0, has_y = 0, key_type_valid = 0, key_alg_valid = 0;\n  unsigned int i;\n  struct cbor_load_result cbor_result;\n  cbor_item_t * item = NULL, * key = NULL, * auth_data = NULL, * att_stmt = NULL, * cbor_cose = NULL, * cbor_key, * cbor_value;\n  gnutls_pubkey_t g_key = NULL;\n  gnutls_datum_t g_x, g_y;\n  gnutls_ecc_curve_t curve = GNUTLS_ECC_CURVE_INVALID;\n  \n  if (j_scheme_data != NULL) {\n    j_error = json_array();\n    if (j_error != NULL) {\n      do {\n        if (!json_string_length(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\"))) {\n          json_array_append_new(j_error, json_string(\"rawId mandatory\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if (!json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\"))) {\n          json_array_append_new(j_error, json_string(\"clientDataJSON mandatory\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if ((client_data = o_malloc(json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\"))+1)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error allocating resources for client_data\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_MEMORY;\n          break;\n        }\n        if (!o_base64_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\")), client_data, &client_data_len)) {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error o_base64_decode client_data\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        client_data[client_data_len] = '\\0';\n        j_client_data = json_loads((const char *)client_data, JSON_DECODE_ANY, NULL);\n        if (j_client_data == NULL) {\n          json_array_append_new(j_error, json_string(\"Error parsing JSON client data\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        // Step 3\n        if (0 != o_strcmp(json_string_value(json_object_get(j_client_data, \"type\")), \"webauthn.create\")) {\n          json_array_append_new(j_error, json_string(\"clientDataJSON.type invalid\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        // Step 4\n        if (!json_string_length(json_object_get(j_client_data, \"challenge\"))) {\n          json_array_append_new(j_error, json_string(\"clientDataJSON.challenge mandatory\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if ((challenge_b64 = o_malloc(json_string_length(json_object_get(j_client_data, \"challenge\"))+3)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error allocating resources for challenge_b64\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_MEMORY;\n          break;\n        }\n        if (!o_base64url_2_base64((unsigned char *)json_string_value(json_object_get(j_client_data, \"challenge\")), json_string_length(json_object_get(j_client_data, \"challenge\")), challenge_b64, &challenge_b64_len)) {\n          json_array_append_new(j_error, json_string(\"clientDataJSON.challenge invalid format\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        challenge_b64[challenge_b64_len] = '\\0';\n        if ((challenge_hash = generate_hash(config->hash_algorithm, (const char *)challenge_b64)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error generate_hash for challenge_b64\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR;\n          break;\n        }\n        if (0 != o_strcmp(challenge_hash, json_string_value(json_object_get(j_credential, \"challenge_hash\")))) {\n          json_array_append_new(j_error, json_string(\"clientDataJSON.challenge invalid\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        // Step 5\n        if (!json_string_length(json_object_get(j_client_data, \"origin\"))) {\n          json_array_append_new(j_error, json_string(\"clientDataJSON.origin mandatory\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if (0 != o_strcmp(json_string_value(json_object_get(j_params, \"rp-origin\")), json_string_value(json_object_get(j_client_data, \"origin\")))) {\n          message = msprintf(\"clientDataJSON.origin invalid - Client send %s, required %s\", json_string_value(json_object_get(j_client_data, \"origin\")), json_string_value(json_object_get(j_params, \"rp-origin\")));\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        // Step 6 ??\n        \n        if (!json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"attestationObject\"))) {\n          json_array_append_new(j_error, json_string(\"attestationObject required\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        if ((att_obj = o_malloc(json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"attestationObject\")))) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error allocating resources for o_malloc\");\n          ret = G_ERROR_MEMORY;\n          break;\n        }\n        if (!o_base64_decode((unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"attestationObject\")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"attestationObject\")), att_obj, &att_obj_len)) {\n          json_array_append_new(j_error, json_string(\"attestationObject invalid base64\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n\n        // Step 7\n        item = cbor_load(att_obj, att_obj_len, &cbor_result);\n        if (cbor_result.error.code != CBOR_ERR_NONE) {\n          json_array_append_new(j_error, json_string(\"attestationObject invalid cbor\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if (!cbor_isa_map(item)) {\n          json_array_append_new(j_error, json_string(\"attestationObject invalid cbor item\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        // Check attestation object\n        if (cbor_map_size(item) != 3) {\n          json_array_append_new(j_error, json_string(\"attestationObject invalid cbor item\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n\n        for (i=0; i<3; i++) {\n          key = cbor_map_handle(item)[i].key;\n          if (cbor_isa_string(key)) {\n            if (0 == o_strncmp((const char *)cbor_string_handle(key), \"fmt\", MIN(o_strlen(\"fmt\"), cbor_string_length(key)))) {\n              if (!cbor_isa_string(cbor_map_handle(item)[i].value)) {\n                json_array_append_new(j_error, json_string(\"CBOR map value 'fmt' isnt't a string\"));\n                ret = G_ERROR_PARAM;\n                break;\n              } else {\n                fmt_len = cbor_string_length(cbor_map_handle(item)[i].value);\n                fmt = cbor_string_handle(cbor_map_handle(item)[i].value);\n              }\n            } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"attStmt\", MIN(o_strlen(\"attStmt\"), cbor_string_length(key)))) {\n              att_stmt = cbor_map_handle(item)[i].value;\n            } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"authData\", MIN(o_strlen(\"authData\"), cbor_string_length(key)))) {\n              auth_data = cbor_map_handle(item)[i].value;\n              if (!cbor_isa_bytestring(auth_data) || cbor_bytestring_length(auth_data) < 56 || cbor_bytestring_is_indefinite(auth_data)) {\n                json_array_append_new(j_error, json_string(\"CBOR map value 'authData' is invalid\"));\n                ret = G_ERROR_PARAM;\n                break;\n              }\n            } else {\n              message = msprintf(\"CBOR map element %d is not an expected item\", i);\n              json_array_append_new(j_error, json_string(message));\n              o_free(message);\n              ret = G_ERROR_PARAM;\n              break;\n            }\n          }\n        }\n        \n        // Step 9\n        if (auth_data == NULL) {\n          json_array_append_new(j_error, json_string(\"authData invalid\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        cbor_bs_handle = cbor_bytestring_handle(auth_data);\n        cbor_bs_handle_len = cbor_bytestring_length(auth_data);\n        if (o_strstr(json_string_value(json_object_get(j_params, \"rp-origin\")), \"://\") == NULL) {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - rp-origin invalid\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        if (o_strstr(json_string_value(json_object_get(j_params, \"rp-origin\")), \"://\") != NULL) {\n          rpid = o_strstr(json_string_value(json_object_get(j_params, \"rp-origin\")), \"://\")+3;\n        } else {\n          rpid = json_string_value(json_object_get(j_params, \"rp-origin\"));\n        }\n        if (o_strchr(rpid, ':') != NULL) {\n          rpid_len = o_strchr(rpid, ':') - rpid;\n        } else {\n          rpid_len = o_strlen(rpid);\n        }\n        \n        if (!generate_digest_raw(digest_SHA256, (unsigned char *)rpid, rpid_len, rpid_hash, &rpid_hash_len)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error generate_digest_raw\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        if (0 != memcmp(cbor_bs_handle, rpid_hash, rpid_hash_len)) {\n          json_array_append_new(j_error, json_string(\"authData.rpIdHash invalid\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        // Step 10\n        if (!(cbor_bs_handle[FLAGS_OFFSET] & FLAG_USER_PRESENT)) {\n          json_array_append_new(j_error, json_string(\"authData.userPresent not set\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if (!(cbor_bs_handle[FLAGS_OFFSET] & FLAG_AT)) {\n          json_array_append_new(j_error, json_string(\"authData.Attested credential data not set\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        // Step 11 ignored for now\n        //y_log_message(Y_LOG_LEVEL_DEBUG, \"authData.userVerified: %d\", !!(cbor_bs_handle[FLAGS_OFFSET] & FLAG_USER_VERIFY));\n        \n        // Step 12 ignored for now (no extension)\n        //y_log_message(Y_LOG_LEVEL_DEBUG, \"authData.Extension: %d\", !!(cbor_bs_handle[FLAGS_OFFSET] & FLAG_ED));\n        \n        credential_id_len = cbor_bs_handle[CRED_ID_L_OFFSET+1] | (cbor_bs_handle[CRED_ID_L_OFFSET] << 8);\n        if (cbor_bs_handle_len < CRED_ID_L_OFFSET+2+credential_id_len) {\n          json_array_append_new(j_error, json_string(\"auth_data invalid size\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        credential_id_b64 = o_malloc(credential_id_len*2);\n        if (credential_id_b64 == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error o_malloc for credential_id_b64\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        if (!o_base64_encode(cbor_bs_handle+CRED_ID_L_OFFSET+2, credential_id_len, credential_id_b64, &credential_id_b64_len)) {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error o_base64_encode for credential_id_b64\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        // Compare credential_id_b64 with rawId\n        if (memcmp(credential_id_b64, json_string_value(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\")), MIN(json_string_length(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\")), credential_id_b64_len))) {\n          json_array_append_new(j_error, json_string(\"Invalid rawId\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        // Extract public key from auth_data COSE structure\n\n        // Extract credential ID\n        cbor_auth_data_len = cbor_bytestring_length(auth_data);\n        cbor_auth_data = cbor_bytestring_handle(auth_data);\n        \n        cred_pub_key = cbor_auth_data+CREDENTIAL_ID_OFFSET+credential_id_len;\n        cred_pub_key_len = cbor_auth_data_len-CREDENTIAL_ID_OFFSET-credential_id_len;\n        cbor_cose = cbor_load(cred_pub_key, cred_pub_key_len, &cbor_result);\n        if (cbor_result.error.code != CBOR_ERR_NONE) {\n          json_array_append_new(j_error, json_string(\"Invalid COSE key\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error cbor_load cbor_cose\");\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        if (!cbor_isa_map(cbor_cose)) {\n          json_array_append_new(j_error, json_string(\"Invalid COSE key\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error cbor_cose not a map\");\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        for (i=0; i<cbor_map_size(cbor_cose); i++) {\n          cbor_key = cbor_map_handle(cbor_cose)[i].key;\n          cbor_value = cbor_map_handle(cbor_cose)[i].value;\n          if (cbor_isa_negint(cbor_key) && cbor_get_int(cbor_key) == 1 && cbor_isa_bytestring(cbor_value)) {\n            has_x = 1;\n            memcpy(cert_x, cbor_bytestring_handle(cbor_value), cbor_bytestring_length(cbor_value));\n            cert_x_len = cbor_bytestring_length(cbor_value);\n            g_x.data = cert_x;\n            g_x.size = cbor_bytestring_length(cbor_value);\n          } else if (cbor_isa_negint(cbor_key) && cbor_get_int(cbor_key) == 2 && cbor_isa_bytestring(cbor_value)) {\n            has_y = 1;\n            memcpy(cert_y, cbor_bytestring_handle(cbor_value), cbor_bytestring_length(cbor_value));\n            cert_y_len = cbor_bytestring_length(cbor_value);\n            g_y.data = cert_y;\n            g_y.size = cbor_bytestring_length(cbor_value);\n          } else if (cbor_isa_uint(cbor_key) && cbor_get_int(cbor_key) == 1 && cbor_isa_uint(cbor_value) && cbor_get_int(cbor_value) == 2) {\n            key_type_valid = 1;\n          } else if (cbor_isa_uint(cbor_key) && cbor_get_int(cbor_key) == 3 && cbor_isa_negint(cbor_value)) {\n            if (cbor_get_int(cbor_value) == 6 || cbor_get_int(cbor_value) == 34 || cbor_get_int(cbor_value) == 35) {\n              json_array_foreach(json_object_get(j_params, \"pubKey-cred-params\"), index, j_element) {\n                if (cbor_get_int(cbor_value) == 6 && json_integer_value(json_object_get(j_element, \"alg\")) == ECDSA256) {\n                  key_alg_valid = 1;\n                  curve = GNUTLS_ECC_CURVE_SECP256R1;\n                } else if (cbor_get_int(cbor_value) == 34 && json_integer_value(json_object_get(j_element, \"alg\")) == ECDSA384) {\n                  key_alg_valid = 1;\n                  curve = GNUTLS_ECC_CURVE_SECP384R1;\n                } else if (cbor_get_int(cbor_value) == 35 && json_integer_value(json_object_get(j_element, \"alg\")) == ECDSA512) {\n                  key_alg_valid = 1;\n                  curve = GNUTLS_ECC_CURVE_SECP521R1;\n                }\n              }\n            }\n          }\n        }\n        \n        if (!has_x || !has_y || !key_type_valid || !key_alg_valid) {\n          json_array_append_new(j_error, json_string(\"Invalid COSE key\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error invalid COSE key has_x %d && has_y %d && key_type_valid %d && key_alg_valid %d\", has_x, has_y, key_type_valid, key_alg_valid);\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        if (gnutls_pubkey_init(&g_key)) {\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error gnutls_pubkey_init\");\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if (gnutls_pubkey_import_ecc_raw(g_key, curve, &g_x, &g_y) < 0) {\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - error gnutls_pubkey_import_ecc_raw\");\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if ((ret = gnutls_pubkey_export(g_key, GNUTLS_X509_FMT_PEM, pubkey_export, &pubkey_export_len)) < 0) {\n          json_array_append_new(j_error, json_string(\"Error exporting pubkey\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error gnutls_pubkey_export: %d\", ret);\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        // Steps 13-14\n        if (0 == o_strncmp(\"packed\", (char *)fmt, MIN(fmt_len, o_strlen(\"packed\"))) && (json_object_get(json_object_get(j_params, \"fmt\"), \"packed\") == json_true())) {\n          j_result = check_attestation_packed(j_params, auth_data, att_stmt, client_data, g_key);\n          if (check_result_value(j_result, G_ERROR_PARAM)) {\n            json_array_extend(j_error, json_object_get(j_result, \"error\"));\n            ret = G_ERROR_PARAM;\n          } else if (!check_result_value(j_result, G_OK)) {\n            ret = G_ERROR_PARAM;\n            y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error check_attestation_packed\");\n            json_array_append_new(j_error, json_string(\"internal error\"));\n          } else {\n            j_cert = json_incref(json_object_get(json_object_get(j_result, \"data\"), \"certificate\"));\n          }\n          json_decref(j_result);\n        } else if (0 == o_strncmp(\"tpm\", (char *)fmt, MIN(fmt_len, o_strlen(\"tpm\"))) && (json_object_get(json_object_get(j_params, \"fmt\"), \"tpm\") == json_true())) {\n          json_array_append_new(j_error, json_string(\"Format 'tpm' not supported yet\"));\n          ret = G_ERROR_PARAM;\n        } else if (0 == o_strncmp(\"android-key\", (char *)fmt, MIN(fmt_len, o_strlen(\"android-key\"))) && (json_object_get(json_object_get(j_params, \"fmt\"), \"android-key\") == json_true())) {\n          json_array_append_new(j_error, json_string(\"Format 'android-key' not supported yet\"));\n          ret = G_ERROR_PARAM;\n        } else if (0 == o_strncmp(\"android-safetynet\", (char *)fmt, MIN(fmt_len, o_strlen(\"android-safetynet\"))) && (json_object_get(json_object_get(j_params, \"fmt\"), \"android-safetynet\") == json_true())) {\n          j_result = check_attestation_android_safetynet(j_params, auth_data, att_stmt, client_data);\n          if (check_result_value(j_result, G_ERROR_PARAM)) {\n            json_array_extend(j_error, json_object_get(j_result, \"error\"));\n            ret = G_ERROR_PARAM;\n          } else if (!check_result_value(j_result, G_OK)) {\n            ret = G_ERROR_PARAM;\n            y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error check_attestation_android_safetynet\");\n            json_array_append_new(j_error, json_string(\"internal error\"));\n          } else {\n            j_cert = json_incref(json_object_get(json_object_get(j_result, \"data\"), \"certificate\"));\n          }\n          json_decref(j_result);\n        } else if (0 == o_strncmp(\"fido-u2f\", (char *)fmt, MIN(fmt_len, o_strlen(\"fido-u2f\"))) && (json_object_get(json_object_get(j_params, \"fmt\"), \"fido-u2f\") == json_true())) {\n          j_result = check_attestation_fido_u2f(j_params, (cbor_auth_data+CREDENTIAL_ID_OFFSET), credential_id_len, cert_x, cert_x_len, cert_y, cert_y_len, att_stmt, rpid_hash, rpid_hash_len, client_data);\n          if (check_result_value(j_result, G_ERROR_PARAM)) {\n            json_array_extend(j_error, json_object_get(j_result, \"error\"));\n            ret = G_ERROR_PARAM;\n          } else if (!check_result_value(j_result, G_OK)) {\n            ret = G_ERROR_PARAM;\n            y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error check_attestation_fido_u2f\");\n            json_array_append_new(j_error, json_string(\"internal error\"));\n          } else {\n            j_cert = json_incref(json_object_get(json_object_get(j_result, \"data\"), \"certificate\"));\n          }\n          json_decref(j_result);\n        } else if (0 == o_strncmp(\"none\", (char *)fmt, MIN(fmt_len, o_strlen(\"none\"))) && (json_object_get(json_object_get(j_params, \"fmt\"), \"none\") == json_true() || json_object_get(j_params, \"force-fmt-none\") == json_true())) {\n          if (att_stmt != NULL && cbor_isa_map(att_stmt) && cbor_map_is_definite(att_stmt) && !cbor_map_size(att_stmt)) {\n            j_cert = json_string(\"\");\n          } else {\n            y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - response type 'none' has invalid format\");\n            json_array_append_new(j_error, json_string(\"response invalid\"));\n            ret = G_ERROR_PARAM;\n          }\n        } else {\n          message = msprintf(\"Format '%.*s' is not supported by Glewlwyd WebAuthn scheme\", fmt_len, fmt);\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          ret = G_ERROR_PARAM;\n        }\n      } while (0); // This is not a loop, but a structure where you can easily cancel the rest of the process with breaks\n      \n      if (ret != G_OK) {\n        if (json_array_size(j_error)) {\n          j_return = json_pack(\"{sisO}\", \"result\", ret, \"error\", j_error);\n        } else {\n          j_return = json_pack(\"{si}\", \"result\", ret);\n        }\n      } else {\n        if ((res = check_certificate(config, j_params, json_string_value(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\")), json_integer_value(json_object_get(j_credential, \"gswu_id\")))) == G_OK) {\n          j_return = json_pack(\"{sis[s]}\", \"result\", G_ERROR_PARAM, \"error\", \"Credential already registered\");\n          status = 2;\n        } else if (res == G_ERROR_UNAUTHORIZED) {\n          j_return = json_pack(\"{sis[s]}\", \"result\", G_ERROR_PARAM, \"error\", \"Credential unauthorized\");\n          status = 2;\n        } else if (res != G_ERROR_NOT_FOUND) {\n          j_return = json_pack(\"{sis[s]}\", \"result\", G_ERROR_PARAM, \"error\", \"Internal error\");\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error check_certificate\");\n          status = 2;\n        } else {\n          j_return = json_pack(\"{si}\", \"result\", G_OK);\n          status = 1;\n        }\n        counter = cbor_bs_handle[COUNTER_OFFSET+3] | (cbor_bs_handle[COUNTER_OFFSET+2] << 8) | (cbor_bs_handle[COUNTER_OFFSET+1] << 16) | (cbor_bs_handle[COUNTER_OFFSET] << 24);\n        // Store credential in the database\n        j_query = json_pack(\"{sss{siss%sOss%sOsi}s{sO}}\",\n                            \"table\", \n                            G_TABLE_WEBAUTHN_CREDENTIAL,\n                            \"set\",\n                              \"gswc_status\",\n                              status,\n                              \"gswc_name\",\n                              fmt,\n                              fmt_len,\n                              \"gswc_credential_id\",\n                              json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\"),\n                              \"gswc_public_key\",\n                              pubkey_export,\n                              pubkey_export_len,\n                              \"gswc_certificate\",\n                              j_cert,\n                              \"gswc_counter\",\n                              counter,\n                            \"where\",\n                              \"gswc_id\",\n                              json_object_get(j_credential, \"gswc_id\"));\n        res = h_update(config->conn, j_query, NULL);\n        json_decref(j_query);\n        if (res != H_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error h_update\");\n        }\n      }\n      json_decref(j_error);\n      json_decref(j_client_data);\n      json_decref(j_pubkey);\n      json_decref(j_cert);\n      o_free(client_data);\n      o_free(challenge_b64);\n      o_free(challenge_hash);\n      o_free(att_obj);\n      o_free(credential_id_b64);\n      gnutls_pubkey_deinit(g_key);\n      if (item != NULL) {\n        cbor_decref(&item);\n      }\n      if (cbor_cose != NULL) {\n        cbor_decref(&cbor_cose);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error allocating resources for j_error\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n  } else {\n    j_return = json_pack(\"{sis[s]}\", \"result\", G_ERROR_PARAM, \"error\", \"scheme_data mandatory\");\n  }\n  return j_return;\n}\n\n/**\n * \n */\nstatic int check_assertion(struct config_module * config, json_t * j_params, const char * username, json_t * j_scheme_data, json_t * j_assertion) {\n  int ret, res;\n  unsigned char * client_data = NULL, * challenge_b64 = NULL, * auth_data = NULL, rpid_hash[32] = {0}, * flags, cdata_hash[32] = {0}, \n                  data_signed[128] = {0}, sig[128] = {0}, * counter;\n  char * challenge_hash = NULL;\n  const char * rpid = NULL;\n  size_t client_data_len, challenge_b64_len, auth_data_len, rpid_hash_len = 32, cdata_hash_len = 32, sig_len = 128, counter_value = 0, rpid_len = 0;\n  json_t * j_client_data = NULL, * j_credential = NULL, * j_query;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_datum_t pubkey_dat, data, signature;\n  \n  if (j_scheme_data != NULL && j_assertion != NULL) {\n    do {\n      ret = G_OK;\n      \n      if (!json_is_string(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\")) || !json_string_length(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\"))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - rawId missing\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      j_credential = get_credential(config, j_params, username, json_string_value(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\")));\n      if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - credential ID not found\");\n        ret = G_ERROR_UNAUTHORIZED;\n        break;\n      }\n      if (!json_is_string(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\")) || !json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\"))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON mandatory\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      if ((client_data = o_malloc(json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\"))+1)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error allocating resources for client_data\");\n        ret = G_ERROR_MEMORY;\n        break;\n      }\n      if (!o_base64_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\")), client_data, &client_data_len)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error o_base64_decode client_data\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      client_data[client_data_len] = '\\0';\n      j_client_data = json_loads((const char *)client_data, JSON_DECODE_ANY, NULL);\n      if (j_client_data == NULL) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error parsing JSON client data %s\", client_data);\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      // Step 7\n      if (0 != o_strcmp(\"webauthn.get\", json_string_value(json_object_get(j_client_data, \"type\")))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON.type invalid\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      // Step 8\n      if (!json_string_length(json_object_get(j_client_data, \"challenge\"))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON.challenge mandatory\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      if ((challenge_b64 = o_malloc(json_string_length(json_object_get(j_client_data, \"challenge\"))+3)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error allocating resources for challenge_b64\");\n        ret = G_ERROR_MEMORY;\n        break;\n      }\n      if (!o_base64url_2_base64((unsigned char *)json_string_value(json_object_get(j_client_data, \"challenge\")), json_string_length(json_object_get(j_client_data, \"challenge\")), challenge_b64, &challenge_b64_len)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON.challenge invalid base64\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      challenge_b64[challenge_b64_len] = '\\0';\n      if ((challenge_hash = generate_hash(config->hash_algorithm, (const char *)challenge_b64)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error generate_hash for challenge_b64\");\n        ret = G_ERROR;\n        break;\n      }\n      if (0 != o_strcmp(challenge_hash, json_string_value(json_object_get(j_assertion, \"challenge_hash\")))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON.challenge invalid\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      // Step 9\n      if (!json_string_length(json_object_get(j_client_data, \"origin\"))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON.origin mandatory\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      if (0 != o_strcmp(json_string_value(json_object_get(j_params, \"rp-origin\")), json_string_value(json_object_get(j_client_data, \"origin\")))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON.origin invalid - Client send %s, required %s\", json_string_value(json_object_get(j_client_data, \"origin\")), json_string_value(json_object_get(j_params, \"rp-origin\")));\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      // Step 10 ??\n      \n      // Step 11\n      if (!json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"authenticatorData\"))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - authenticatorData mandatory\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      if ((auth_data = o_malloc(json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"authenticatorData\"))+1)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error allocating resources for auth_data\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      if (!o_base64_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"authenticatorData\")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"authenticatorData\")), auth_data, &auth_data_len)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error o_base64_decode auth_data\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      if (auth_data_len < 37) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error authenticatorData invalid\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      \n      if (o_strstr(json_string_value(json_object_get(j_params, \"rp-origin\")), \"://\") != NULL) {\n        rpid = o_strstr(json_string_value(json_object_get(j_params, \"rp-origin\")), \"://\")+3;\n      } else {\n        rpid = json_string_value(json_object_get(j_params, \"rp-origin\"));\n      }\n      if (o_strchr(rpid, ':') != NULL) {\n        rpid_len = o_strchr(rpid, ':') - rpid;\n      } else {\n        rpid_len = o_strlen(rpid);\n      }\n        \n      if (!generate_digest_raw(digest_SHA256, (unsigned char *)rpid, rpid_len, rpid_hash, &rpid_hash_len)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error generate_digest_raw for rpid_hash\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      \n      if (0 != memcmp(auth_data, rpid_hash, rpid_hash_len)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - authData.rpIdHash invalid\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      flags = auth_data + FLAGS_OFFSET;\n      \n      // Step 12\n      if (!(*flags & FLAG_USER_PRESENT)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - authData.userPresent not set\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      \n      // Step 13 ignored for now\n      //y_log_message(Y_LOG_LEVEL_DEBUG, \"authData.userVerified: %d\", !!(*flags & FLAG_USER_VERIFY));\n      \n      // Step 14 ignored for now (no extension)\n      //y_log_message(Y_LOG_LEVEL_DEBUG, \"authData.Extension: %d\", !!(*flags & FLAG_ED));\n      \n      // Step 15\n      if (!generate_digest_raw(digest_SHA256, client_data, client_data_len, cdata_hash, &cdata_hash_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error generate_digest_raw for cdata_hash\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      counter = auth_data + COUNTER_OFFSET;\n      counter_value = counter[3] | (counter[2] << 8) | (counter[1] << 16) | (counter[0] << 24);\n      \n      if (gnutls_pubkey_init(&pubkey) < 0) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error gnutls_pubkey_init\");\n        ret = G_ERROR;\n        break;\n      }\n      pubkey_dat.data = (unsigned char *)json_string_value(json_object_get(json_object_get(j_credential, \"credential\"), \"public_key\"));\n      pubkey_dat.size = json_string_length(json_object_get(json_object_get(j_credential, \"credential\"), \"public_key\"));\n      if ((ret = gnutls_pubkey_import(pubkey, &pubkey_dat, GNUTLS_X509_FMT_PEM)) < 0) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error gnutls_pubkey_import: %d\", ret);\n        ret = G_ERROR;\n        break;\n      }\n      \n      if (!o_base64url_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"signature\")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"signature\")), sig, &sig_len)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error o_base64url_decode signature\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      \n      memcpy(data_signed, auth_data, auth_data_len);\n      memcpy(data_signed+auth_data_len, cdata_hash, cdata_hash_len);\n      \n      // Let's verify sig over data_signed\n      data.data = data_signed;\n      data.size = (auth_data_len+cdata_hash_len);\n      \n      signature.data = sig;\n      signature.size = sig_len;\n      \n      if ((res = gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) < 0) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Invalid signature: %d\", res);\n        ret = G_ERROR_UNAUTHORIZED;\n        break;\n      }\n      \n      if ((json_integer_value(json_object_get(json_object_get(j_credential, \"credential\"), \"counter\")) || counter_value) && counter_value <= (size_t)json_integer_value(json_object_get(json_object_get(j_credential, \"credential\"), \"counter\"))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - counter invalid\");\n        ret = G_ERROR_UNAUTHORIZED;\n        break;\n      }\n    } while (0); // This is not a loop, but a structure where you can easily cancel the rest of the process with breaks\n    \n    if (ret == G_OK) {\n      // Update assertion\n      j_query = json_pack(\"{sss{sisi}s{sO}}\",\n                          \"table\",\n                          G_TABLE_WEBAUTHN_ASSERTION,\n                          \"set\",\n                            \"gswa_counter\",\n                            counter_value,\n                            \"gswa_status\",\n                            1,\n                          \"where\",\n                            \"gswa_id\",\n                            json_object_get(j_assertion, \"gswa_id\"));\n      res = h_update(config->conn, j_query, NULL);\n      json_decref(j_query);\n      if (res != H_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error executing j_query (1)\");\n        config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n        ret = G_ERROR_DB;\n      } else {\n        // Update counter in credential if necessary\n        if (counter) {\n          j_query = json_pack(\"{sss{si}s{sO}}\",\n                              \"table\",\n                              G_TABLE_WEBAUTHN_CREDENTIAL,\n                              \"set\",\n                                \"gswc_counter\",\n                                counter_value,\n                              \"where\",\n                                \"gswc_id\",\n                                json_object_get(json_object_get(j_credential, \"credential\"), \"gswc_id\"));\n          res = h_update(config->conn, j_query, NULL);\n          json_decref(j_query);\n          if (res != H_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error executing j_query (2)\");\n            config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n            ret = G_ERROR_DB;\n          }\n        }\n      }\n    } else if (ret == G_ERROR_PARAM) {\n      j_query = json_pack(\"{sss{sisi}s{sO}}\",\n                          \"table\",\n                          G_TABLE_WEBAUTHN_ASSERTION,\n                          \"set\",\n                            \"gswa_counter\",\n                            counter_value,\n                            \"gswa_status\",\n                            2,\n                          \"where\",\n                            \"gswa_id\",\n                            json_object_get(j_assertion, \"gswa_id\"));\n      res = h_update(config->conn, j_query, NULL);\n      json_decref(j_query);\n      if (res != H_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error executing j_query (3)\");\n        config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n        ret = G_ERROR_DB;\n      }\n    } else {\n      j_query = json_pack(\"{sss{sisi}s{sO}}\",\n                          \"table\",\n                          G_TABLE_WEBAUTHN_ASSERTION,\n                          \"set\",\n                            \"gswa_counter\",\n                            counter_value,\n                            \"gswa_status\",\n                            3,\n                          \"where\",\n                            \"gswa_id\",\n                            json_object_get(j_assertion, \"gswa_id\"));\n      res = h_update(config->conn, j_query, NULL);\n      json_decref(j_query);\n      if (res != H_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error executing j_query (4)\");\n        config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n        ret = G_ERROR_DB;\n      }\n    }\n    o_free(client_data);\n    o_free(challenge_b64);\n    o_free(challenge_hash);\n    o_free(auth_data);\n    json_decref(j_client_data);\n    json_decref(j_credential);\n    gnutls_pubkey_deinit(pubkey);\n  } else {\n    ret = G_ERROR_PARAM;\n  }\n  return ret;\n}\n\n/**\n * Generates a fake credential based on the seed\n * the fake credential has the following form:\n * {\n *   credential_id: string, base64 encoding of 64 a bytes string\n *   name: string\n *   created_at: number, epoch time\n *   status: string, always \"registered\"\n * }\n */\nstatic json_t * generate_credential_fake_from_seed(const char * seed) {\n  unsigned char credential_id[64] = {0}, credential_id_b64[129], created_at[32], name_hash[32];\n  char * seed_credential_id, * seed_name, * seed_created_at, name[32];\n  time_t created_at_t;\n  size_t credential_id_len = 64, credential_id_b64_len, name_hash_len = 32, created_at_len = 32;\n  json_t * j_return;\n  \n  if ((seed_credential_id = msprintf(\"%s-credential_id\", seed)) != NULL) {\n    if (generate_digest_raw(digest_SHA512, (unsigned char *)seed_credential_id, o_strlen(seed_credential_id), credential_id, &credential_id_len)) {\n      if (o_base64_encode(credential_id, credential_id_len, credential_id_b64, &credential_id_b64_len)) {\n        if ((seed_name = msprintf(\"%s-name\", seed)) != NULL) {\n          if (generate_digest_raw(digest_SHA256, (unsigned char *)seed_name, o_strlen(seed_name), name_hash, &name_hash_len)) {\n            if (name_hash[0]%2) {\n              o_strcpy(name, \"fido-u2f\");\n            } else {\n              o_strcpy(name, \"android-safetynet\");\n            }\n            if ((seed_created_at = msprintf(\"%s-created_at\", seed)) != NULL) {\n              if (generate_digest_raw(digest_SHA256, (unsigned char *)seed_created_at, o_strlen(seed_created_at), created_at, &created_at_len)) {\n                time(&created_at_t);\n                created_at_t -= created_at[0] - (created_at[1] << 8);\n                j_return = json_pack(\"{sis{sssssiss}}\", \n                                     \"result\", \n                                     G_OK, \n                                     \"credential\", \n                                      \"credential_id\", \n                                      credential_id_b64,\n                                      \"name\", \n                                      name,\n                                      \"created_at\",\n                                      created_at_t,\n                                      \"status\",\n                                      \"registered\");\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error generate_digest_raw for seed_created_at\");\n                j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n              }\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error allocating resources for seed_created_at\");\n              j_return = json_pack(\"{si}\", \"result\", G_ERROR_MEMORY);\n            }\n            o_free(seed_created_at);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error generate_digest_raw for seed_name\");\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error allocating resources for seed_name\");\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_MEMORY);\n        }\n        o_free(seed_name);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error o_base64_encode for seed_credential_id\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error generate_digest_raw for seed_credential_id\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error allocating resources for seed_credential_id\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_MEMORY);\n  }\n  o_free(seed_credential_id);\n  return j_return;\n}\n\n/**\n * Generates 1 to 3 random credentials using the seed and the username\n */\nstatic json_t * generate_credential_fake_list(json_t * j_params, const char * username) {\n  json_t * j_credential, * j_credential_sub, * j_return;\n  char * seed;\n  unsigned char seed_hash[32] = {0};\n  size_t seed_hash_len = 32;\n  unsigned int i;\n  \n  if ((seed = msprintf(\"%s%s0\", username, json_string_value(json_object_get(j_params, \"seed\")))) != NULL) {\n    j_credential = generate_credential_fake_from_seed(seed);\n    if (check_result_value(j_credential, G_OK)) {\n      j_return = json_pack(\"{sis[O]}\", \"result\", G_OK, \"credential\", json_object_get(j_credential, \"credential\"));\n      if (j_return != NULL) {\n        if (generate_digest_raw(digest_SHA256, (unsigned char *)seed, o_strlen(seed), seed_hash, &seed_hash_len)) {\n          for (i=0; i<seed_hash[0]%3; i++) {\n            seed[o_strlen(seed)-1]++;\n            j_credential_sub = generate_credential_fake_from_seed(seed);\n            if (check_result_value(j_credential, G_OK)) {\n              json_array_append(json_object_get(j_return, \"credential\"), json_object_get(j_credential_sub, \"credential\"));\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_list - Error generate_credential_fake_from_seed at index %u\", i);\n            }\n            json_decref(j_credential_sub);\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_list - Error generate_digest_raw\");\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_list - Error allocating resources for j_return\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_MEMORY);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_list - Error generate_credential_fake_from_seed\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_list - Error allocating resources for seed\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_MEMORY);\n  }\n  o_free(seed);\n  return j_return;\n}\n\n/**\n * Generates a fake user_id based on the username provided and the seed\n */\nstatic int generate_fake_user_id(json_t * j_params, const char * username, unsigned char * user_id) {\n  char * seed;\n  unsigned char seed_hash[32];\n  size_t seed_hash_len = 32, seed_hash_b64_len;\n  int ret;\n  \n  if ((seed = msprintf(\"%s%s-user_id\", username, json_string_value(json_object_get(j_params, \"seed\")))) != NULL) {\n    if (generate_digest_raw(digest_SHA256, (unsigned char *)seed, o_strlen(seed), seed_hash, &seed_hash_len)) {\n      if (o_base64_encode(seed_hash, seed_hash_len, user_id, &seed_hash_b64_len)) {\n        ret = G_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error o_base64_encode\");\n        ret = G_ERROR;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error generate_digest_raw\");\n      ret = G_ERROR;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error allocating resources for seed\");\n    ret = G_ERROR_MEMORY;\n  }\n  o_free(seed);\n  return ret;\n}\n\n/**\n * \n * user_auth_scheme_module_load\n * \n * Executed once when Glewlwyd service is started\n * Used to identify the module and to show its parameters on init\n * You can also use it to load resources that are required once for all\n * instance modules for example\n * \n * @return value: a json_t * value with the following pattern:\n *                {\n *                  result: number (G_OK on success, another value on error)\n *                  name: string, mandatory, name of the module, must be unique among other scheme modules\n *                  display_name: string, optional, long name of the module\n *                  description: string, optional, description for the module\n *                  parameters: object, optional, parameters description for the module\n *                }\n * \n *                Example:\n *                {\n *                  result: G_OK,\n *                  name: \"mock\",\n *                  display_name: \"Mock scheme module\",\n *                  description: \"Mock scheme module for glewlwyd tests\",\n *                  parameters: {\n *                    mock-value: {\n *                      type: \"string\",\n *                      mandatory: true\n *                    }\n *                  }\n *                }\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * \n */\njson_t * user_auth_scheme_module_load(struct config_module * config) {\n  UNUSED(config);\n  return json_pack(\"{si ss ss ss }\",\n                   \"result\", G_OK,\n                   \"name\", \"webauthn\",\n                   \"display_name\", \"WebAuthn\",\n                   \"description\", \"WebAuthn scheme module\");\n}\n\n/**\n * \n * user_auth_scheme_module_unload\n * \n * Executed once when Glewlwyd service is stopped\n * You can also use it to release resources that are required once for all\n * instance modules for example\n * \n * @return value: G_OK on success, another value on error\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * \n */\nint user_auth_scheme_module_unload(struct config_module * config) {\n  UNUSED(config);\n  return G_OK;\n}\n\n/**\n * \n * user_auth_scheme_module_init\n * \n * Initialize an instance of this module declared in Glewlwyd service.\n * If required, you must dynamically allocate a pointer to the configuration\n * for this instance and pass it to *cls\n * \n * @return value: a json_t * value with the following pattern:\n *                {\n *                  result: number (G_OK on success, G_ERROR_PARAM on input parameters error, another value on error)\n *                  error: array of strings containg the list of input errors, mandatory on result G_ERROR_PARAM, ignored otherwise\n *                }\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter j_parameters: used to initialize an instance in JSON format\n *                          The module must validate itself its parameters\n * @parameter mod_name: module name in glewlwyd service\n * @parameter cls: will contain an allocated void * pointer that will be sent back\n *                 as void * in all module functions\n * \n */\njson_t * user_auth_scheme_module_init(struct config_module * config, json_t * j_parameters, const char * mod_name, void ** cls) {\n  UNUSED(config);\n  json_t * j_result = is_scheme_parameters_valid(j_parameters), * j_element = NULL, * j_return;\n  size_t index = 0;\n  char * message;\n  \n  if (check_result_value(j_result, G_OK)) {\n    *cls = json_pack(\"{sO sO sO sO sI sI sO ss so sO sO sO sO sO ss s[]}\",\n                     \"challenge-length\", json_object_get(j_parameters, \"challenge-length\"),\n                     \"rp-origin\", json_object_get(j_parameters, \"rp-origin\"),\n                     \"credential-expiration\", json_object_get(j_parameters, \"credential-expiration\"),\n                     \"credential-assertion\", json_object_get(j_parameters, \"credential-assertion\"),\n                     \"ctsProfileMatch\", json_object_get(j_parameters, \"ctsProfileMatch\")!=NULL?json_integer_value(json_object_get(j_parameters, \"ctsProfileMatch\")):-1,\n                     \"basicIntegrity\", json_object_get(j_parameters, \"basicIntegrity\")!=NULL?json_integer_value(json_object_get(j_parameters, \"basicIntegrity\")):-1,\n                     \"session-mandatory\", json_object_get(j_parameters, \"session-mandatory\")!=NULL?json_object_get(j_parameters, \"session-mandatory\"):json_true(),\n                     \"seed\", !json_string_length(json_object_get(j_parameters, \"seed\"))?\"\":json_string_value(json_object_get(j_parameters, \"seed\")),\n                     \"fmt\", json_object_get(j_parameters, \"fmt\")!=NULL?json_deep_copy(json_object_get(j_parameters, \"fmt\")):json_pack(\"{sosososososo}\", \"packed\", json_true(), \"tpm\", json_true(), \"android-key\", json_true(), \"android-safetynet\", json_true(), \"fido-u2f\", json_true(), \"none\", json_true()),\n                     \"force-fmt-none\", json_object_get(j_parameters, \"force-fmt-none\")!=NULL?json_object_get(j_parameters, \"force-fmt-none\"):json_false(),\n                     \"google-root-ca-r2\", json_string_length(json_object_get(j_parameters, \"google-root-ca-r2\"))?json_object_get(j_parameters, \"google-root-ca-r2\"):json_null(),\n                     \"google-root-ca-r2-content\", json_object_get(j_parameters, \"google-root-ca-r2-content\")!=NULL?json_object_get(j_parameters, \"google-root-ca-r2-content\"):json_null(),\n                     \"root-ca-list\", json_array_size(json_object_get(j_parameters, \"root-ca-list\"))?json_object_get(j_parameters, \"root-ca-list\"):json_null(),\n                     \"root-ca-array\", json_object_get(j_parameters, \"root-ca-array\")!=NULL?json_object_get(j_parameters, \"root-ca-array\"):json_null(),\n                     \"mod_name\", mod_name,\n                     \"pubKey-cred-params\");\n    json_array_foreach(json_object_get(j_parameters, \"pubKey-cred-params\"), index, j_element) {\n      json_array_append_new(json_object_get((json_t *)*cls, \"pubKey-cred-params\"), json_pack(\"{sssO}\", \"type\", \"public-key\", \"alg\", j_element));\n    }\n    j_return = json_pack(\"{si}\", \"result\", G_OK);\n  } else if (check_result_value(j_result, G_ERROR_PARAM)) {\n    message = json_dumps(json_object_get(j_result, \"error\"), JSON_COMPACT);\n    y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_init webauthn - Error input parameters: %s\", message);\n    o_free(message);\n    j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", json_object_get(j_result, \"error\"));\n  } else {\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  json_decref(j_result);\n  return j_return;\n}\n\n/**\n * \n * user_auth_scheme_module_close\n * \n * Close an instance of this module declared in Glewlwyd service.\n * You must free the memory previously allocated in\n * the user_auth_scheme_module_init function as void * cls\n * \n * @return value: G_OK on success, another value on error\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\nint user_auth_scheme_module_close(struct config_module * config, void * cls) {\n  UNUSED(config);\n  json_decref((json_t *)cls);\n  return G_OK;\n}\n\n/**\n * \n * user_auth_scheme_module_can_use\n * \n * Validate if the user is allowed to use this scheme prior to the\n * authentication or registration\n * \n * @return value: GLEWLWYD_IS_REGISTERED - User can use scheme and has registered\n *                GLEWLWYD_IS_AVAILABLE - User can use scheme but hasn't registered\n *                GLEWLWYD_IS_NOT_AVAILABLE - User can't use scheme\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter username: username to identify the user\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\nint user_auth_scheme_module_can_use(struct config_module * config, const char * username, void * cls) {\n  json_t * j_user_id, * j_credential;\n  int ret;\n  \n  j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 0);\n  if (check_result_value(j_user_id, G_OK)) {\n    j_credential = get_credential_list(config, (json_t *)cls, username, 1);\n    if (check_result_value(j_credential, G_OK)) {\n      ret = GLEWLWYD_IS_REGISTERED;\n    } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n      ret = GLEWLWYD_IS_AVAILABLE;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_can_use webauthn - Error get_credential_list\");\n      ret = GLEWLWYD_IS_NOT_AVAILABLE;\n    }\n    json_decref(j_credential);\n  } else if (check_result_value(j_user_id, G_ERROR_NOT_FOUND)) {\n    ret = GLEWLWYD_IS_AVAILABLE;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_can_use webauthn - Error get_user_id_from_username\");\n    ret = GLEWLWYD_IS_NOT_AVAILABLE;\n  }\n  json_decref(j_user_id);\n  return ret;\n}\n\n/**\n * \n * user_auth_scheme_module_register\n * \n * Register the scheme for a user\n * Ex: add a certificate, add new TOTP values, etc.\n * \n * @return value: a json_t * value with the following pattern:\n *                {\n *                  result: number (G_OK on success, another value on error)\n *                  response: JSON object, optional\n *                }\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter http_request: the original struct _u_request from the HTTP API\n * @parameter username: username to identify the user\n * @parameter j_scheme_data: additional data used to register the scheme for the user\n *                           in JSON format\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\njson_t * user_auth_scheme_module_register(struct config_module * config, const struct _u_request * http_request, const char * username, json_t * j_scheme_data, void * cls) {\n  UNUSED(config);\n  UNUSED(http_request);\n  json_t * j_return, * j_result, * j_credential, * j_user_id, * j_assertion;\n  int res;\n\n  if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"new-credential\")) {\n    j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 1);\n    if (check_result_value(j_user_id, G_OK)) {\n      j_credential = generate_new_credential(config, (json_t *)cls, username);\n      if (check_result_value(j_credential, G_OK)) {\n        j_return = json_pack(\"{sis{sOsOsOsss{sOss}sO}}\",\n                              \"result\", G_OK, \n                              \"response\", \n                                \"session\", json_object_get(json_object_get(j_credential, \"credential\"), \"session\"), \n                                \"challenge\", json_object_get(json_object_get(j_credential, \"credential\"), \"challenge\"), \n                                \"pubKey-cred-params\", json_object_get((json_t *)cls, \"pubKey-cred-params\"),\n                                \"attestation-required\", json_object_get((json_t *)cls, \"force-fmt-none\")==json_true()?\"none\":\"direct\",\n                                \"user\",\n                                  \"id\", json_object_get(j_user_id, \"user_id\"),\n                                  \"name\", username,\n                                \"rpId\", json_object_get((json_t *)cls, \"rp-origin\")\n                             );\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error generate_new_credential\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      json_decref(j_credential);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_user_id_from_username\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_user_id);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"register-credential\")) {\n    j_credential = get_credential_from_session(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"session\")));\n    if (check_result_value(j_credential, G_OK)) {\n      j_result = register_new_attestation(config, (json_t *)cls, j_scheme_data, json_object_get(j_credential, \"credential\"));\n      if (check_result_value(j_result, G_OK)) {\n        j_return = json_pack(\"{si}\", \"result\", G_OK);\n      } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n        j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_UNAUTHORIZED, \"response\", json_object_get(j_result, \"error\"));\n      } else if (check_result_value(j_result, G_ERROR_PARAM)) {\n        j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"response\", json_object_get(j_result, \"error\"));\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error register_new_attestation\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      json_decref(j_result);\n    } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    } else if (check_result_value(j_credential, G_ERROR_PARAM)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential_from_session\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"remove-credential\") && json_string_length(json_object_get(j_scheme_data, \"credential_id\"))) {\n    j_credential = get_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")));\n    if (check_result_value(j_credential, G_OK)) {\n      if ((res = update_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")), 4)) == G_OK) {\n        j_return = json_pack(\"{si}\", \"result\", G_OK);\n      } else if (res == G_ERROR_PARAM) {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error update_credential\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"disable-credential\") && json_string_length(json_object_get(j_scheme_data, \"credential_id\"))) {\n    j_credential = get_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")));\n    if (check_result_value(j_credential, G_OK)) {\n      if ((res = update_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")), 3)) == G_OK) {\n        j_return = json_pack(\"{si}\", \"result\", G_OK);\n      } else if (res == G_ERROR_PARAM) {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error update_credential\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"enable-credential\") && json_string_length(json_object_get(j_scheme_data, \"credential_id\"))) {\n    j_credential = get_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")));\n    if (check_result_value(j_credential, G_OK)) {\n      if ((res = update_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")), 1)) == G_OK) {\n        j_return = json_pack(\"{si}\", \"result\", G_OK);\n      } else if (res == G_ERROR_PARAM) {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error update_credential\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"edit-credential\") && json_string_length(json_object_get(j_scheme_data, \"credential_id\")) && json_string_length(json_object_get(j_scheme_data, \"name\"))) {\n    j_credential = get_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")));\n    if (check_result_value(j_credential, G_OK)) {\n      if ((res = update_credential_name(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")), json_string_value(json_object_get(j_scheme_data, \"name\")))) == G_OK) {\n        j_return = json_pack(\"{si}\", \"result\", G_OK);\n      } else if (res == G_ERROR_PARAM) {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error update_credential_name\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"trigger-assertion\")) {\n    j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 0);\n    if (check_result_value(j_user_id, G_OK)) {\n      j_credential = get_credential_list(config, (json_t *)cls, username, 1);\n      if (check_result_value(j_credential, G_OK)) {\n        j_assertion = generate_new_assertion(config, (json_t *)cls, username, 1);\n        if (check_result_value(j_assertion, G_OK)) {\n          j_return = json_pack(\"{sis{sOsOsOs{sOss}sO}}\", \n                              \"result\", G_OK, \n                              \"response\", \n                                \"allowCredentials\", json_object_get(j_credential, \"credential\"), \n                                \"session\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"session\"), \n                                \"challenge\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"challenge\"),\n                                \"user\",\n                                  \"id\", json_object_get(j_user_id, \"user_id\"),\n                                  \"name\", username,\n                                \"rpId\", json_object_get((json_t *)cls, \"rp-origin\")\n                              );\n        } else if (check_result_value(j_assertion, G_ERROR_UNAUTHORIZED)) {\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error register_new_assertion\");\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n        }\n        json_decref(j_assertion);\n      } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error get_credential_list\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      json_decref(j_credential);\n    } else if (check_result_value(j_user_id, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_user_id_from_username\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_user_id);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"validate-assertion\")) {\n    j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 0);\n    if (check_result_value(j_user_id, G_OK)) {\n      j_assertion = get_assertion_from_session(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"session\")), 1);\n      if (check_result_value(j_assertion, G_OK)) {\n        if ((res = check_assertion(config, (json_t *)cls, username, j_scheme_data, json_object_get(j_assertion, \"assertion\"))) == G_OK) {\n          j_return = json_pack(\"{si}\", \"result\", G_OK);\n        } else if (res == G_ERROR_UNAUTHORIZED || res == G_ERROR_PARAM) {\n          j_return = json_pack(\"{si}\", \"result\", res);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error check_assertion\");\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n        }\n      } else if (check_result_value(j_assertion, G_ERROR_NOT_FOUND)) {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      json_decref(j_assertion);\n    } else if (check_result_value(j_user_id, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_validate webauthn - Error get_user_id_from_username\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_user_id);\n  } else {\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n  }\n  \n  return j_return;\n}\n\n/**\n * \n * user_auth_scheme_module_register_get\n * \n * Get the registration value(s) of the scheme for a user\n * \n * @return value: a json_t * value with the following pattern:\n *                {\n *                  result: number (G_OK on success, another value on error)\n *                  response: JSON object, optional\n *                }\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter http_request: the original struct _u_request from the API, must be casted to be available\n * @parameter username: username to identify the user\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\njson_t * user_auth_scheme_module_register_get(struct config_module * config, const struct _u_request * http_request, const char * username, void * cls) {\n  UNUSED(http_request);\n  json_t * j_return, * j_user_id, * j_credential_list;\n\n  j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 1);\n  if (check_result_value(j_user_id, G_OK)) {\n    j_credential_list = get_credential_list(config, (json_t *)cls, username, 0);\n    if (check_result_value(j_credential_list, G_OK)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_OK, \"response\", json_object_get(j_credential_list, \"credential\"));\n    } else if (check_result_value(j_credential_list, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{sis[]}\", \"result\", G_OK, \"response\");\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register_get webauthn - Error get_credential_list\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential_list);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register_get webauthn - Error get_user_id_from_username\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  json_decref(j_user_id);\n  \n  return j_return;\n}\n\n/**\n * \n * user_auth_scheme_module_deregister\n * \n * Deregister the scheme for a user\n * Ex: remove certificates, TOTP values, etc.\n * \n * @return value: G_OK on success, even if no data has been removed\n *                G_ERROR on another error\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter username: username to identify the user\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\nint user_auth_scheme_module_deregister(struct config_module * config, const char * username, void * cls) {\n  json_t * j_user_id, * j_credential_list, * j_credential, * j_element = NULL;\n  size_t index = 0;\n  int ret;\n\n  j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 1);\n  if (check_result_value(j_user_id, G_OK)) {\n    j_credential_list = get_credential_list(config, (json_t *)cls, username, 0);\n    if (check_result_value(j_credential_list, G_OK)) {\n      json_array_foreach(json_object_get(j_credential_list, \"credential\"), index, j_element) {\n        j_credential = get_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_element, \"credential_id\")));\n        if (check_result_value(j_credential, G_OK)) {\n          if (update_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_element, \"credential_id\")), 4) != G_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_deregister webauthn - Error update_credential\");\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_deregister webauthn - Error get_credential\");\n        }\n        json_decref(j_credential);\n      }\n      ret = G_OK;\n    } else if (check_result_value(j_credential_list, G_ERROR_NOT_FOUND)) {\n      ret = G_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_deregister webauthn - Error get_credential_list\");\n      ret = G_ERROR;\n    }\n    json_decref(j_credential_list);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_deregister webauthn - Error get_user_id_from_username\");\n    ret = G_ERROR;\n  }\n  json_decref(j_user_id);\n  \n  return ret;\n}\n\n/**\n * \n * user_auth_scheme_module_trigger\n * \n * Trigger the scheme for a user\n * Ex: send the code to a device, generate a challenge, etc.\n * \n * @return value: a json_t * value with the following pattern:\n *                {\n *                  result: number (G_OK on success, another value on error)\n *                  response: JSON object, optional\n *                }\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter http_request: the original struct _u_request from the API, must be casted to be available\n * @parameter username: username to identify the user\n * @parameter scheme_trigger: data sent to trigger the scheme for the user\n *                           in JSON format\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\njson_t * user_auth_scheme_module_trigger(struct config_module * config, const struct _u_request * http_request, const char * username, json_t * j_scheme_trigger, void * cls) {\n  UNUSED(j_scheme_trigger);\n  json_t * j_return = NULL, * j_session = config->glewlwyd_module_callback_check_user_session(config, http_request, username), * j_credential, * j_assertion, * j_user_id, * j_credential_fake;\n  unsigned char user_id_fake[64];\n  \n  if (check_result_value(j_session, G_OK) || json_object_get((json_t *)cls, \"session-mandatory\") == json_false()) {\n    j_credential_fake = generate_credential_fake_list((json_t *)cls, username);\n    if (check_result_value(j_credential_fake, G_OK)) {\n      j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 0);\n      if (check_result_value(j_user_id, G_OK)) {\n        j_credential = get_credential_list(config, (json_t *)cls, username, 1);\n        if (check_result_value(j_credential, G_OK)) {\n          j_assertion = generate_new_assertion(config, (json_t *)cls, username, 0);\n          if (check_result_value(j_assertion, G_OK)) {\n            j_return = json_pack(\"{sis{sOsOsOs{sOss}sOsssi}}\", \n                                \"result\", G_OK, \n                                \"response\", \n                                  \"allowCredentials\", json_object_get(j_credential, \"credential\"), \n                                  \"session\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"session\"), \n                                  \"challenge\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"challenge\"),\n                                  \"user\",\n                                    \"id\", json_object_get(j_user_id, \"user_id\"),\n                                    \"name\", username,\n                                  \"rpId\", json_object_get((json_t *)cls, \"rp-origin\"),\n                                  \"attestation-required\", json_object_get((json_t *)cls, \"force-fmt-none\")==json_true()?\"none\":\"direct\",\n                                  \"timeout\", 60000\n                                );\n            if (json_object_get((json_t *)cls, \"session-mandatory\") == json_false()) {\n              json_array_extend(json_object_get(json_object_get(j_return, \"response\"), \"allowCredentials\"), json_object_get(j_credential_fake, \"credential\"));\n            }\n          } else if (check_result_value(j_assertion, G_ERROR_UNAUTHORIZED)) {\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error register_new_assertion\");\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n          }\n          json_decref(j_assertion);\n        } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n          if (json_object_get((json_t *)cls, \"session-mandatory\") == json_false()) {\n            j_assertion = generate_new_assertion(config, (json_t *)cls, username, 2);\n            if (check_result_value(j_assertion, G_OK)) {\n              j_return = json_pack(\"{sis{sOsOsOs{sOss}sO}}\", \n                                  \"result\", G_OK, \n                                  \"response\", \n                                    \"allowCredentials\", json_object_get(j_credential_fake, \"credential\"), \n                                    \"session\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"session\"), \n                                    \"challenge\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"challenge\"),\n                                    \"user\",\n                                      \"id\", json_object_get(j_user_id, \"user_id\"),\n                                      \"name\", username,\n                                    \"rpId\", json_object_get((json_t *)cls, \"rp-origin\")\n                                  );\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error register_new_assertion\");\n              j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n            }\n            json_decref(j_assertion);\n          } else {\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error get_credential_list\");\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n        }\n        json_decref(j_credential);\n      } else if (check_result_value(j_user_id, G_ERROR_NOT_FOUND)) {\n        if (json_object_get((json_t *)cls, \"session-mandatory\") == json_false()) {\n          if (generate_fake_user_id((json_t *)cls, username, user_id_fake) == G_OK) {\n            j_assertion = generate_new_assertion(config, (json_t *)cls, username, 2);\n            if (check_result_value(j_assertion, G_OK)) {\n              j_return = json_pack(\"{sis{sOsOsOs{ssss}sO}}\", \n                                  \"result\", G_OK, \n                                  \"response\", \n                                    \"allowCredentials\", json_object_get(j_credential_fake, \"credential\"), \n                                    \"session\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"session\"), \n                                    \"challenge\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"challenge\"),\n                                    \"user\",\n                                      \"id\", user_id_fake,\n                                      \"name\", username,\n                                    \"rpId\", json_object_get((json_t *)cls, \"rp-origin\")\n                                  );\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error register_new_assertion\");\n              j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n            }\n            json_decref(j_assertion);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error generate_fake_user_id\");\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n          }\n        } else {\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_user_id_from_username\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      json_decref(j_user_id);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error generate_credential_fake\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential_fake);\n  } else if (check_result_value(j_session, G_ERROR_UNAUTHORIZED)) {\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error glewlwyd_module_callback_check_user_session\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  json_decref(j_session);\n  return j_return;\n}\n\n/**\n * \n * user_auth_scheme_module_validate\n * \n * Validate the scheme for a user\n * Ex: check the code sent to a device, verify the challenge, etc.\n * \n * @return value: G_OK on success\n *                G_ERROR_UNAUTHORIZED if validation fails\n *                G_ERROR_PARAM if error in parameters\n *                G_ERROR on another error\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter http_request: the original struct _u_request from the API, must be casted to be available\n * @parameter username: username to identify the user\n * @parameter j_scheme_data: data sent to validate the scheme for the user\n *                           in JSON format\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\nint user_auth_scheme_module_validate(struct config_module * config, const struct _u_request * http_request, const char * username, json_t * j_scheme_data, void * cls) {\n  UNUSED(http_request);\n  int ret, res;\n  json_t * j_user_id, * j_assertion;\n\n  j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 0);\n  if (check_result_value(j_user_id, G_OK)) {\n    j_assertion = get_assertion_from_session(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"session\")), 0);\n    if (check_result_value(j_assertion, G_OK)) {\n      if ((res = check_assertion(config, (json_t *)cls, username, j_scheme_data, json_object_get(j_assertion, \"assertion\"))) == G_OK) {\n        ret = G_OK;\n      } else if (res == G_ERROR_UNAUTHORIZED) {\n        ret = G_ERROR_UNAUTHORIZED;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_validate webauthn - Error check_assertion\");\n        ret = G_ERROR;\n      }\n    } else if (check_result_value(j_assertion, G_ERROR_NOT_FOUND)) {\n      ret = G_ERROR_UNAUTHORIZED;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential\");\n      ret = G_ERROR;\n    }\n    json_decref(j_assertion);\n  } else if (check_result_value(j_user_id, G_ERROR_NOT_FOUND)) {\n    ret = G_ERROR_UNAUTHORIZED;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_validate webauthn - Error get_user_id_from_username\");\n    ret = G_ERROR;\n  }\n  json_decref(j_user_id);\n  \n  return ret;\n}\n\n/**\n * \n * user_auth_scheme_module_identify\n * \n * Identify the user using the scheme without the username to be previously given\n * This functionality isn't available for all schemes, because the scheme authentification\n * must be triggered without username and the authentication result must contain the username\n * \n * @return value: a json_t * value with the following pattern:\n *                {\n *                  result: number (G_OK on success, another value on error)\n *                  username: string value of the user identified - if the function is called within /auth\n *                  response: JSON object, optional - if the function is called within /auth/scheme/trigger\n *                }\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter http_request: the original struct _u_request from the API, must be casted to be available\n * @parameter j_scheme_data: data sent to validate the scheme for the user\n *                           in JSON format\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\njson_t * user_auth_scheme_module_identify(struct config_module * config, const struct _u_request * http_request, json_t * j_scheme_data, void * cls) {\n  UNUSED(config);\n  UNUSED(http_request);\n  UNUSED(j_scheme_data);\n  UNUSED(cls);\n  return json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n}\n"], "fixing_code": ["/**\n *\n * Glewlwyd SSO Server\n *\n * Authentiation server\n * Users are authenticated via various backend available: database, ldap\n * Using various authentication methods available: password, OTP, send code, etc.\n * \n * WebAuthn scheme module\n * \n * Copyright 2019-2020 Nicolas Mora <mail@babelouest.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU GENERAL PUBLIC LICENSE\n * License as published by the Free Software Foundation;\n * version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU GENERAL PUBLIC LICENSE for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include <string.h>\n#include <gnutls/gnutls.h>\n#include <gnutls/crypto.h>\n#include <gnutls/abstract.h>\n#include <jansson.h>\n#include <cbor.h>\n#include <ldap.h>\n#include <yder.h>\n#include <orcania.h>\n#include <rhonabwy.h>\n#include \"glewlwyd-common.h\"\n\nconst char * iso_3166_list[] = {\"AF\", \"AX\", \"AL\", \"DZ\", \"AS\", \"AD\", \"AO\", \"AI\", \"AQ\", \"AG\", \"AR\", \"AM\", \"AW\", \"AU\", \"AT\", \"AZ\", \"BH\", \"BS\", \"BD\", \"BB\", \"BY\", \"BE\", \"BZ\", \"BJ\", \"BM\", \"BT\", \"BO\", \"BQ\", \"BA\", \"BW\", \"BV\", \"BR\", \"IO\", \"BN\", \"BG\", \"BF\", \"BI\", \"KH\", \"CM\", \"CA\", \"CV\", \"KY\", \"CF\", \"TD\", \"CL\", \"CN\", \"CX\", \"CC\", \"CO\", \"KM\", \"CG\", \"CD\", \"CK\", \"CR\", \"CI\", \"HR\", \"CU\", \"CW\", \"CY\", \"CZ\", \"DK\", \"DJ\", \"DM\", \"DO\", \"EC\", \"EG\", \"SV\", \"GQ\", \"ER\", \"EE\", \"ET\", \"FK\", \"FO\", \"FJ\", \"FI\", \"FR\", \"GF\", \"PF\", \"TF\", \"GA\", \"GM\", \"GE\", \"DE\", \"GH\", \"GI\", \"GR\", \"GL\", \"GD\", \"GP\", \"GU\", \"GT\", \"GG\", \"GN\", \"GW\", \"GY\", \"HT\", \"HM\", \"VA\", \"HN\", \"HK\", \"HU\", \"IS\", \"IN\", \"ID\", \"IR\", \"IQ\", \"IE\", \"IM\", \"IL\", \"IT\", \"JM\", \"JP\", \"JE\", \"JO\", \"KZ\", \"KE\", \"KI\", \"KP\", \"KR\", \"KW\", \"KG\", \"LA\", \"LV\", \"LB\", \"LS\", \"LR\", \"LY\", \"LI\", \"LT\", \"LU\", \"MO\", \"MK\", \"MG\", \"MW\", \"MY\", \"MV\", \"ML\", \"MT\", \"MH\", \"MQ\", \"MR\", \"MU\", \"YT\", \"MX\", \"FM\", \"MD\", \"MC\", \"MN\", \"ME\", \"MS\", \"MA\", \"MZ\", \"MM\", \"NA\", \"NR\", \"NP\", \"NL\", \"NC\", \"NZ\", \"NI\", \"NE\", \"NG\", \"NU\", \"NF\", \"MP\", \"NO\", \"OM\", \"PK\", \"PW\", \"PS\", \"PA\", \"PG\", \"PY\", \"PE\", \"PH\", \"PN\", \"PL\", \"PT\", \"PR\", \"QA\", \"RE\", \"RO\", \"RU\", \"RW\", \"BL\", \"SH\", \"KN\", \"LC\", \"MF\", \"PM\", \"VC\", \"WS\", \"SM\", \"ST\", \"SA\", \"SN\", \"RS\", \"SC\", \"SL\", \"SG\", \"SX\", \"SK\", \"SI\", \"SB\", \"SO\", \"ZA\", \"GS\", \"SS\", \"ES\", \"LK\", \"SD\", \"SR\", \"SJ\", \"SZ\", \"SE\", \"CH\", \"SY\", \"TW\", \"TJ\", \"TZ\", \"TH\", \"TL\", \"TG\", \"TK\", \"TO\", \"TT\", \"TN\", \"TR\", \"TM\", \"TC\", \"TV\", \"UG\", \"UA\", \"AE\", \"GB\", \"US\", \"UM\", \"UY\", \"UZ\", \"VU\", \"VE\", \"VN\", \"VG\", \"VI\", \"WF\", \"EH\", \"YE\", \"ZM\", \"ZW\", NULL};\n#define G_PACKED_CERT_O_KEY    \"O=\"\n#define G_PACKED_CERT_OU_KEY   \"OU=\"\n#define G_PACKED_CERT_C_KEY    \"C=\"\n#define G_PACKED_CERT_CN_KEY   \"CN=\"\n#define G_PACKED_CERT_OU_VALUE \"Authenticator Attestation\"\n#define G_PACKED_OID_AAGUID    \"1.3.6.1.4.1.45724.1.1.4\"\n\n#define G_TABLE_WEBAUTHN_USER       \"gs_webauthn_user\"\n#define G_TABLE_WEBAUTHN_CREDENTIAL \"gs_webauthn_credential\"\n#define G_TABLE_WEBAUTHN_ASSERTION  \"gs_webauthn_assertion\"\n\n#define SESSION_LENGTH 32\n#define USER_ID_LENGTH 32\n\n#define FLAG_USER_PRESENT 0x01\n#define FLAG_USER_VERIFY  0x04\n#define FLAG_AT           0x40\n#define FLAG_ED           0x80\n\n#define COUNTER_LEN   4\n#define AAGUID_LEN    16\n#define CRED_ID_L_LEN 2\n\n#define FLAGS_OFFSET 32\n#define COUNTER_OFFSET (FLAGS_OFFSET+1)\n#define ATTESTED_CRED_DATA_OFFSET (COUNTER_OFFSET+COUNTER_LEN)\n#define CRED_ID_L_OFFSET (ATTESTED_CRED_DATA_OFFSET+AAGUID_LEN)\n#define CREDENTIAL_ID_OFFSET (ATTESTED_CRED_DATA_OFFSET+AAGUID_LEN+CRED_ID_L_LEN)\n\n#define ECDSA256 -7\n#define ECDSA384 -35\n#define ECDSA512 -36\n\n#define SAFETYNET_ISSUED_TO \"CN=attest.android.com\"\n\nstatic json_t * get_cert_from_file_path(const char * path) {\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat = {NULL, 0}, export_dat = {NULL, 0};\n  FILE * fl;\n  size_t len, issued_for_len = 128;\n  char * cert_content, issued_for[128] = {};\n  json_t * j_return = NULL;\n  \n  fl = fopen(path, \"r\");\n  if (fl != NULL) {\n    fseek(fl, 0, SEEK_END);\n    len = ftell(fl);\n    cert_content = o_malloc(len);\n    if (cert_content != NULL) {\n      if (fseek(fl, 0, SEEK_SET) == -1) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error fseek\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      } else if (fread(cert_content, 1, len, fl) != len) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error fread\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      } else {\n        cert_dat.data = (unsigned char *)cert_content;\n        cert_dat.size = len;\n        if (!gnutls_x509_crt_init(&cert)) {\n          if (gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER) >= 0 || gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_PEM) >= 0) {\n            if (!gnutls_x509_crt_get_dn(cert, issued_for, &issued_for_len)) {\n              if (gnutls_x509_crt_export2(cert, GNUTLS_X509_FMT_PEM, &export_dat) >= 0) {\n                j_return = json_pack(\"{sis{ss%ss%}}\", \"result\", G_OK, \"certificate\", \"dn\", issued_for, issued_for_len, \"x509\", export_dat.data, export_dat.size);\n                gnutls_free(export_dat.data);\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error gnutls_x509_crt_export2\");\n                j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n              }\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error gnutls_x509_crt_get_dn\");\n              j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error gnutls_x509_crt_import\");\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error gnutls_x509_crt_init\");\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n        }\n        gnutls_x509_crt_deinit(cert);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error o_malloc cert_content\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_MEMORY);\n    }\n    o_free(cert_content);\n    fclose(fl);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_cert_from_file_path - Error fopen %s\", path);\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\nstatic json_t * is_scheme_parameters_valid(json_t * j_params) {\n  json_t * j_return, * j_error, * j_element = NULL, * j_cert;\n  size_t index = 0;\n  json_int_t pubkey;\n  char * message;\n  \n  if (json_is_object(j_params)) {\n    j_error = json_array();\n    if (j_error != NULL) {\n      if (!json_is_boolean(json_object_get(j_params, \"session-mandatory\"))) {\n        json_array_append_new(j_error, json_string(\"session-mandatory is mandatory and must be a boolean\"));\n      }\n      if (json_object_get(j_params, \"seed\") != NULL && !json_is_string(json_object_get(j_params, \"seed\"))) {\n        json_array_append_new(j_error, json_string(\"seed is optional and must be a string\"));\n      }\n      if (json_integer_value(json_object_get(j_params, \"challenge-length\")) <= 0) {\n        json_array_append_new(j_error, json_string(\"challenge-length is mandatory and must be a positive integer\"));\n      }\n      if (json_integer_value(json_object_get(j_params, \"credential-expiration\")) <= 0) {\n        json_array_append_new(j_error, json_string(\"credential-expiration is mandatory and must be a positive integer\"));\n      }\n      if (json_integer_value(json_object_get(j_params, \"credential-assertion\")) <= 0) {\n        json_array_append_new(j_error, json_string(\"credential-assertion is mandatory and must be a positive integer\"));\n      }\n      if (!json_string_length(json_object_get(j_params, \"rp-origin\"))) {\n        json_array_append_new(j_error, json_string(\"rp-origin is mandatory and must be a non empty string\"));\n      }\n      if (!json_array_size(json_object_get(j_params, \"pubKey-cred-params\"))) {\n        json_array_append_new(j_error, json_string(\"pubKey-cred-params is mandatory and must be a non empty JSON array\"));\n      } else {\n        json_array_foreach(json_object_get(j_params, \"pubKey-cred-params\"), index, j_element) {\n          pubkey = json_integer_value(j_element);\n          //if (pubkey != -7 && pubkey != -35 && pubkey != -36 && pubkey != -257 && pubkey != -258 && pubkey != -259) {\n          if (pubkey != ECDSA256 && pubkey != ECDSA384 && pubkey != ECDSA512) {\n            //json_array_append_new(j_error, json_string(\"pubKey-cred-params elements values available are -7, -35, -36 (ECDSA) or -257, -258, -259 (RSA)\"));\n            json_array_append_new(j_error, json_string(\"pubKey-cred-params elements values available are -7, -35, -36 (ECDSA)\"));\n          }\n        }\n      }\n      if (json_object_get(j_params, \"ctsProfileMatch\") != NULL && (!json_is_integer(json_object_get(j_params, \"ctsProfileMatch\")) || json_integer_value(json_object_get(j_params, \"ctsProfileMatch\")) < -1 || json_integer_value(json_object_get(j_params, \"ctsProfileMatch\")) > 1)) {\n        json_array_append_new(j_error, json_string(\"ctsProfileMatch is optional and must be an integer between -1 and 1\"));\n      }\n      if (json_object_get(j_params, \"basicIntegrity\") != NULL && (!json_is_integer(json_object_get(j_params, \"basicIntegrity\")) || json_integer_value(json_object_get(j_params, \"basicIntegrity\")) < -1 || json_integer_value(json_object_get(j_params, \"basicIntegrity\")) > 1)) {\n        json_array_append_new(j_error, json_string(\"basicIntegrity is optional and must be an integer between -1 and 1\"));\n      }\n      if (json_object_get(j_params, \"google-root-ca-r2\") != NULL && !json_is_string(json_object_get(j_params, \"google-root-ca-r2\"))) {\n        json_array_append_new(j_error, json_string(\"google-root-ca-r2 is optional and must be a string\"));\n      } else if (json_string_length(json_object_get(j_params, \"google-root-ca-r2\"))) {\n        j_cert = get_cert_from_file_path(json_string_value(json_object_get(j_params, \"google-root-ca-r2\")));\n        if (check_result_value(j_cert, G_OK)) {\n          json_object_set(j_params, \"google-root-ca-r2-content\", json_object_get(j_cert, \"certificate\"));\n        } else {\n          message = msprintf(\"Error parsing google-root-ca-r2 certificate file %s\", json_string_value(json_object_get(j_params, \"google-root-ca-r2\")));\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n        }\n        json_decref(j_cert);\n      }\n      if (json_object_get(j_params, \"root-ca-list\") != NULL) {\n        if (!json_is_array(json_object_get(j_params, \"root-ca-list\"))) {\n          json_array_append_new(j_error, json_string(\"root-ca-list is optional and must be an array of strings\"));\n        } else {\n          json_object_set_new(j_params, \"root-ca-array\", json_array());\n          json_array_foreach(json_object_get(j_params, \"root-ca-list\"), index, j_element) {\n            if (!json_string_length(j_element)) {\n              json_array_append_new(j_error, json_string(\"root-ca-list is optional and must be an array of strings\"));\n            } else {\n              j_cert = get_cert_from_file_path(json_string_value(j_element));\n              if (check_result_value(j_cert, G_OK)) {\n                json_array_append(json_object_get(j_params, \"root-ca-array\"), json_object_get(j_cert, \"certificate\"));\n              } else {\n                message = msprintf(\"Error parsing certificate file %s\", json_string_value(j_element));\n                json_array_append_new(j_error, json_string(message));\n                o_free(message);\n              }\n              json_decref(j_cert);\n            }\n          }\n        }\n      }\n      if (json_object_get(j_params, \"force-fmt-none\") != NULL && !json_is_boolean(json_object_get(j_params, \"force-fmt-none\"))) {\n        json_array_append_new(j_error, json_string(\"allow-fmt-none is optional and must be a boolean\"));\n      }\n      if (json_object_get(j_params, \"fmt\") != NULL && (!json_is_object(json_object_get(j_params, \"fmt\")) || (json_object_get(json_object_get(j_params, \"fmt\"), \"packed\") != json_true() && json_object_get(json_object_get(j_params, \"fmt\"), \"tpm\") != json_true() && json_object_get(json_object_get(j_params, \"fmt\"), \"android-key\") != json_true() && json_object_get(json_object_get(j_params, \"fmt\"), \"android-safetynet\") != json_true() && json_object_get(json_object_get(j_params, \"fmt\"), \"fido-u2f\") != json_true() && json_object_get(json_object_get(j_params, \"fmt\"), \"none\") != json_true()))) {\n        json_array_append_new(j_error, json_string(\"fmt must be a JSON object filled with supported formats: 'packed' 'tpm', 'android-key', 'android-safetynet', 'fido-u2f', 'none'\"));\n      }\n      if (json_array_size(j_error)) {\n        j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n      } else {\n        j_return = json_pack(\"{si}\", \"result\", G_OK);\n      }\n      json_decref(j_error);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"is_scheme_parameters_valid - Error allocating resources for j_error\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n  } else {\n    j_return = json_pack(\"{sis[s]}\", \"result\", G_ERROR_PARAM, \"error\", \"parameters must be a JSON object\");\n  }\n  return j_return;\n}\n\n/**\n * Get the user_id associated with the username in the table G_TABLE_WEBAUTHN_USER\n * If user_id doesn't exist, create one, stores it, and return the new user_id\n */\nstatic json_t * get_user_id_from_username(struct config_module * config, json_t * j_param, const char * username, int create) {\n  json_t * j_query, * j_result, * j_return;\n  int res;\n  char * username_escaped, * username_clause;\n  unsigned char new_user_id[USER_ID_LENGTH] = {0}, new_user_id_b64[USER_ID_LENGTH*2] = {0};\n  size_t new_user_id_b64_len;\n  \n  username_escaped = h_escape_string_with_quotes(config->conn, username);\n  username_clause = msprintf(\" = UPPER(%s)\", username_escaped);\n  j_query = json_pack(\"{sss[s]s{s{ssss}sO}}\",\n                      \"table\",\n                      G_TABLE_WEBAUTHN_USER,\n                      \"columns\",\n                        \"gswu_user_id AS user_id\",\n                      \"where\",\n                        \"UPPER(gswu_username)\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          username_clause,\n                        \"gswu_mod_name\",\n                        json_object_get(j_param, \"mod_name\"));\n  o_free(username_clause);\n  o_free(username_escaped);\n  res = h_select(config->conn, j_query, &j_result, NULL);\n  json_decref(j_query);\n  if (res == H_OK) {\n    if (json_array_size(j_result)) {\n      j_return = json_pack(\"{siss}\", \"result\", G_OK, \"user_id\", json_string_value(json_object_get(json_array_get(j_result, 0), \"user_id\")));\n    } else if (create) {\n      // Generates a new user_id, and stores it in the database\n      gnutls_rnd(GNUTLS_RND_KEY, new_user_id, USER_ID_LENGTH);\n      if (o_base64_encode(new_user_id, USER_ID_LENGTH, new_user_id_b64, &new_user_id_b64_len)) {\n        j_query = json_pack(\"{sss{sOssss}}\",\n                            \"table\",\n                            G_TABLE_WEBAUTHN_USER,\n                            \"values\",\n                              \"gswu_mod_name\",\n                              json_object_get(j_param, \"mod_name\"),\n                              \"gswu_username\",\n                              username,\n                              \"gswu_user_id\",\n                              new_user_id_b64);\n        res = h_insert(config->conn, j_query, NULL);\n        json_decref(j_query);\n        if (res == H_OK) {\n          j_return = json_pack(\"{siss}\", \"result\", G_OK, \"user_id\", new_user_id_b64);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"get_user_id_from_username - Error executing j_query insert\");\n          config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"get_user_id_from_username - Error o_base64_encode\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    }\n    json_decref(j_result);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_user_id_from_username - Error executing j_query select\");\n    config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n  }\n  return j_return;\n}\n\nstatic json_t * get_credential_list(struct config_module * config, json_t * j_params, const char * username, int restrict_to_registered) {\n  json_t * j_query, * j_result, * j_return, * j_element = NULL;\n  int res;\n  char * username_escaped, * mod_name_escaped, * username_clause;\n  size_t index = 0;\n  \n  username_escaped = h_escape_string_with_quotes(config->conn, username);\n  mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n  username_clause = msprintf(\" = (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n  j_query = json_pack(\"{sss[ssss]s{s{ssss}}}\",\n                      \"table\",\n                      G_TABLE_WEBAUTHN_CREDENTIAL,\n                      \"columns\",\n                        \"gswc_credential_id AS credential_id\",\n                        \"gswc_name AS name\",\n                        SWITCH_DB_TYPE(config->conn->type, \"UNIX_TIMESTAMP(gswc_created_at) AS created_at\", \"strftime('%s', gswc_created_at) AS created_at\", \"EXTRACT(EPOCH FROM gswc_created_at)::integer AS created_at\"),\n                        \"gswc_status\",\n                      \"where\",\n                        \"gswu_id\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          username_clause);\n  o_free(username_clause);\n  o_free(username_escaped);\n  o_free(mod_name_escaped);\n  if (restrict_to_registered) {\n    json_object_set_new(json_object_get(j_query, \"where\"), \"gswc_status\", json_integer(1));\n  } else {\n    json_object_set_new(json_object_get(j_query, \"where\"), \"gswc_status\", json_pack(\"{ssss}\", \"operator\", \"raw\", \"value\", \" IN (1,3)\"));\n  }\n  res = h_select(config->conn, j_query, &j_result, NULL);\n  json_decref(j_query);\n  if (res == H_OK) {\n    if (json_array_size(j_result)) {\n      j_return = json_pack(\"{sis[]}\", \"result\", G_OK, \"credential\");\n      if (j_return != NULL) {\n        json_array_foreach(j_result, index, j_element) {\n          switch (json_integer_value(json_object_get(j_element, \"gswc_status\"))) {\n            case 1:\n              json_object_set_new(j_element, \"status\", json_string(\"registered\"));\n              break;\n            case 3:\n              json_object_set_new(j_element, \"status\", json_string(\"disabled\"));\n              break;\n            default:\n              break;\n          }\n          json_object_del(j_element, \"gswc_status\");\n          json_array_append(json_object_get(j_return, \"credential\"), j_element);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential_list - Error json_pack\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    }\n    json_decref(j_result);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential_list - Error executing j_query\");\n    config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n  }\n  return j_return;\n}\n\nstatic json_t * generate_new_credential(struct config_module * config, json_t * j_params, const char * username) {\n  json_t * j_query, * j_return;\n  char * username_escaped, * mod_name_escaped, * username_clause, * challenge_hash;\n  int res;\n  size_t challenge_b64_len, challenge_len = (size_t)json_integer_value(json_object_get(j_params, \"challenge-length\"));\n  unsigned char challenge_b64[challenge_len*2], challenge[challenge_len+1];\n  char session[SESSION_LENGTH+1] = {0}, * session_hash;\n  \n  gnutls_rnd(GNUTLS_RND_NONCE, challenge, challenge_len);\n  if (o_base64_encode(challenge, challenge_len, challenge_b64, &challenge_b64_len)) {\n    challenge_b64[challenge_b64_len] = '\\0';\n    if ((challenge_hash = generate_hash(config->hash_algorithm, (const char *)challenge_b64)) != NULL) {\n      rand_string(session, SESSION_LENGTH);\n      if ((session_hash = generate_hash(config->hash_algorithm, session)) != NULL) {\n        username_escaped = h_escape_string_with_quotes(config->conn, username);\n        mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n        username_clause = msprintf(\" (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n        // Disable all credential with status 0 (new) of the same user\n        j_query = json_pack(\"{sss{si}s{s{ssss+}si}}\",\n                            \"table\",\n                            G_TABLE_WEBAUTHN_CREDENTIAL,\n                            \"set\",\n                              \"gswc_status\",\n                              2,\n                            \"where\",\n                              \"gswu_id\",\n                                \"operator\",\n                                \"raw\",\n                                \"value\",\n                                \" =\",\n                                username_clause,\n                              \"gswc_status\",\n                              0);\n        res = h_update(config->conn, j_query, NULL);\n        json_decref(j_query);\n        if (res == H_OK) {\n          // Insert new credential\n          j_query = json_pack(\"{sss{s{ss}sssssi}}\",\n                              \"table\",\n                              G_TABLE_WEBAUTHN_CREDENTIAL,\n                              \"values\",\n                                \"gswu_id\",\n                                  \"raw\",\n                                  username_clause,\n                                \"gswc_session_hash\",\n                                session_hash,\n                                \"gswc_challenge_hash\",\n                                challenge_hash,\n                                \"gswc_status\",\n                                0);\n          res = h_insert(config->conn, j_query, NULL);\n          json_decref(j_query);\n          if (res == H_OK) {\n            j_return = json_pack(\"{sis{ssss}}\", \"result\", G_OK, \"credential\", \"session\", session, \"challenge\", challenge_b64);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_credential - Error executing j_query insert\");\n            config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_credential - Error executing j_query update\");\n          config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n        }\n        o_free(username_clause);\n        o_free(username_escaped);\n        o_free(mod_name_escaped);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_credential - Error generate_hash session\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      o_free(session_hash);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_credential - Error generate_hash challenge\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    o_free(challenge_hash);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_credential - Error o_base64_encode challenge\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\nstatic json_t * generate_new_assertion(struct config_module * config, json_t * j_params, const char * username, int mock) {\n  json_t * j_query, * j_return;\n  char * username_escaped, * username_clause, * mod_name_escaped, * challenge_hash;\n  int res;\n  size_t challenge_b64_len, challenge_len = (size_t)json_integer_value(json_object_get(j_params, \"challenge-length\"));\n  unsigned char challenge_b64[challenge_len*2], challenge[challenge_len+1];\n  char session[SESSION_LENGTH+1] = {0}, * session_hash;\n  \n  gnutls_rnd(GNUTLS_RND_NONCE, challenge, challenge_len);\n  if (o_base64_encode(challenge, challenge_len, challenge_b64, &challenge_b64_len)) {\n    challenge_b64[challenge_b64_len] = '\\0';\n    if ((challenge_hash = generate_hash(config->hash_algorithm, (const char *)challenge_b64)) != NULL) {\n      rand_string(session, SESSION_LENGTH);\n      if ((session_hash = generate_hash(config->hash_algorithm, session)) != NULL) {\n        if (mock < 2) {\n          username_escaped = h_escape_string_with_quotes(config->conn, username);\n          mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n          username_clause = msprintf(\" (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n          // Disable all assertions with status 0 (new) of the same user\n          j_query = json_pack(\"{sss{si}s{s{ssss+}si}}\",\n                              \"table\",\n                              G_TABLE_WEBAUTHN_ASSERTION,\n                              \"set\",\n                                \"gswa_status\",\n                                3,\n                              \"where\",\n                                \"gswu_id\",\n                                  \"operator\",\n                                  \"raw\",\n                                  \"value\",\n                                  \" =\",\n                                  username_clause,\n                                \"gswa_status\",\n                                0);\n          res = h_update(config->conn, j_query, NULL);\n          json_decref(j_query);\n          if (res == H_OK) {\n            // Insert new assertion\n            j_query = json_pack(\"{sss{s{ss}sssssisi}}\",\n                                \"table\",\n                                G_TABLE_WEBAUTHN_ASSERTION,\n                                \"values\",\n                                  \"gswu_id\",\n                                    \"raw\",\n                                    username_clause,\n                                  \"gswa_session_hash\",\n                                  session_hash,\n                                  \"gswa_challenge_hash\",\n                                  challenge_hash,\n                                  \"gswa_status\",\n                                  0,\n                                  \"gswa_mock\",\n                                  mock);\n            res = h_insert(config->conn, j_query, NULL);\n            json_decref(j_query);\n            if (res == H_OK) {\n              j_return = json_pack(\"{sis{ssss}}\", \"result\", G_OK, \"assertion\", \"session\", session, \"challenge\", challenge_b64);\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_assertion - Error executing j_query insert\");\n              config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n              j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_assertion - Error executing j_query update\");\n            config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n          }\n          o_free(username_clause);\n          o_free(mod_name_escaped);\n          o_free(username_escaped);\n        } else {\n          j_return = json_pack(\"{sis{ssss}}\", \"result\", G_OK, \"assertion\", \"session\", session, \"challenge\", challenge_b64);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_assertion - Error generate_hash session\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      o_free(session_hash);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_assertion - Error generate_hash challenge\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    o_free(challenge_hash);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"generate_new_assertion - Error o_base64_encode challenge\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\nstatic json_t * get_credential_from_session(struct config_module * config, json_t * j_params, const char * username, const char * session) {\n  json_t * j_query, * j_result, * j_return;\n  char * username_escaped, * mod_name_escaped, * username_clause, * expiration_clause;\n  char * session_hash;\n  int res;\n  time_t now;\n  \n  if (o_strlen(session)) {\n    session_hash = generate_hash(config->hash_algorithm, session);\n    if (session_hash != NULL) {\n      time(&now);\n      username_escaped = h_escape_string_with_quotes(config->conn, username);\n      mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n      username_clause = msprintf(\" = (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n      if (config->conn->type==HOEL_DB_TYPE_MARIADB) {\n        expiration_clause = msprintf(\"> FROM_UNIXTIME(%u)\", (now - (unsigned int)json_integer_value(json_object_get(j_params, \"credential-expiration\"))));\n      } else if (config->conn->type==HOEL_DB_TYPE_PGSQL) {\n        expiration_clause = msprintf(\"> TO_TIMESTAMP(%u)\", (now - (unsigned int)json_integer_value(json_object_get(j_params, \"credential-expiration\"))));\n      } else { // HOEL_DB_TYPE_SQLITE\n        expiration_clause = msprintf(\"> %u\", (now - (unsigned int)json_integer_value(json_object_get(j_params, \"credential-expiration\"))));\n      }\n      j_query = json_pack(\"{sss[ssssss]s{sss{ssss}sis{ssss}}}\",\n                          \"table\",\n                          G_TABLE_WEBAUTHN_CREDENTIAL,\n                          \"columns\",\n                            \"gswc_id\",\n                            \"gswu_id\",\n                            \"gswc_session_hash AS session_hash\",\n                            \"gswc_challenge_hash AS challenge_hash\",\n                            \"gswc_credential_id AS credential_id\",\n                            \"gswc_public_key AS public_key\",\n                          \"where\",\n                            \"gswc_session_hash\",\n                            session_hash,\n                            \"gswu_id\",\n                              \"operator\",\n                              \"raw\",\n                              \"value\",\n                              username_clause,\n                            \"gswc_status\",\n                            0,\n                            \"gswc_created_at\",\n                              \"operator\",\n                              \"raw\",\n                              \"value\",\n                              expiration_clause);\n      o_free(username_clause);\n      o_free(username_escaped);\n      o_free(mod_name_escaped);\n      o_free(expiration_clause);\n      res = h_select(config->conn, j_query, &j_result, NULL);\n      json_decref(j_query);\n      if (res == H_OK) {\n        if (json_array_size(j_result)) {\n          j_return = json_pack(\"{sisO}\", \"result\", G_OK, \"credential\", json_array_get(j_result, 0));\n        } else {\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n        }\n        json_decref(j_result);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential_from_session - Error executing j_query\");\n        config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential_from_session - Error generate_hash\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    o_free(session_hash);\n  } else {\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n  }\n  return j_return;\n}\n\nstatic json_t * get_credential(struct config_module * config, json_t * j_params, const char * username, const char * credential_id) {\n  json_t * j_query, * j_result, * j_return;\n  char * username_escaped, * mod_name_escaped, * username_clause;\n  int res;\n  \n  username_escaped = h_escape_string_with_quotes(config->conn, username);\n  mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n  username_clause = msprintf(\" = (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n  j_query = json_pack(\"{sss[sss]s{sss{ssss}s{ssss}}}\",\n                      \"table\",\n                      G_TABLE_WEBAUTHN_CREDENTIAL,\n                      \"columns\",\n                        \"gswc_id\",\n                        \"gswc_public_key AS public_key\",\n                        \"gswc_counter AS counter\",\n                      \"where\",\n                        \"gswc_credential_id\",\n                        credential_id,\n                        \"gswu_id\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          username_clause,\n                        \"gswc_status\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          \" IN (1,3)\");\n  o_free(username_clause);\n  o_free(username_escaped);\n  o_free(mod_name_escaped);\n  res = h_select(config->conn, j_query, &j_result, NULL);\n  json_decref(j_query);\n  if (res == H_OK) {\n    if (json_array_size(j_result)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_OK, \"credential\", json_array_get(j_result, 0));\n    } else {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    }\n    json_decref(j_result);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential - Error executing j_query\");\n    config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n  }\n  return j_return;\n}\n\nstatic int update_credential(struct config_module * config, json_t * j_params, const char * username, const char * credential_id, int status) {\n  json_t * j_query;\n  char * username_escaped, * mod_name_escaped, * username_clause;\n  int res, ret;\n  \n  username_escaped = h_escape_string_with_quotes(config->conn, username);\n  mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n  username_clause = msprintf(\" = (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n  j_query = json_pack(\"{sss{si}s{sss{ssss}}}\",\n                      \"table\",\n                      G_TABLE_WEBAUTHN_CREDENTIAL,\n                      \"set\",\n                        \"gswc_status\",\n                        status,\n                      \"where\",\n                        \"gswc_credential_id\",\n                        credential_id,\n                        \"gswu_id\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          username_clause);\n  o_free(username_clause);\n  o_free(username_escaped);\n  o_free(mod_name_escaped);\n  res = h_update(config->conn, j_query, NULL);\n  json_decref(j_query);\n  if (res == H_OK) {\n    ret = G_OK;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential - Error executing j_query\");\n    config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n    ret = G_ERROR_DB;\n  }\n  return ret;\n}\n\nstatic int update_credential_name(struct config_module * config, json_t * j_params, const char * username, const char * credential_id, const char * name) {\n  json_t * j_query;\n  char * username_escaped, * mod_name_escaped, * username_clause;\n  int res, ret;\n  \n  username_escaped = h_escape_string_with_quotes(config->conn, username);\n  mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n  username_clause = msprintf(\" = (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n  j_query = json_pack(\"{sss{ss}s{sss{ssss}}}\",\n                      \"table\",\n                      G_TABLE_WEBAUTHN_CREDENTIAL,\n                      \"set\",\n                        \"gswc_name\",\n                        name,\n                      \"where\",\n                        \"gswc_credential_id\",\n                        credential_id,\n                        \"gswu_id\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          username_clause);\n  o_free(username_clause);\n  o_free(username_escaped);\n  o_free(mod_name_escaped);\n  res = h_update(config->conn, j_query, NULL);\n  json_decref(j_query);\n  if (res == H_OK) {\n    ret = G_OK;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_credential - Error executing j_query\");\n    config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n    ret = G_ERROR_DB;\n  }\n  return ret;\n}\n\nstatic json_t * get_assertion_from_session(struct config_module * config, json_t * j_params, const char * username, const char * session, int mock) {\n  json_t * j_query, * j_result, * j_return;\n  char * username_escaped, * mod_name_escaped, * username_clause, * expiration_clause;\n  char * session_hash;\n  int res;\n  time_t now;\n  \n  if (o_strlen(session)) {\n    session_hash = generate_hash(config->hash_algorithm, session);\n    if (session_hash != NULL) {\n      time(&now);\n      username_escaped = h_escape_string_with_quotes(config->conn, username);\n      mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n      username_clause = msprintf(\" = (SELECT gswu_id FROM \"G_TABLE_WEBAUTHN_USER\" WHERE UPPER(gswu_username) = UPPER(%s) AND gswu_mod_name = %s)\", username_escaped, mod_name_escaped);\n      if (config->conn->type==HOEL_DB_TYPE_MARIADB) {\n        expiration_clause = msprintf(\"> FROM_UNIXTIME(%u)\", (now - (unsigned int)json_integer_value(json_object_get(j_params, \"credential-assertion\"))));\n      } else if (config->conn->type==HOEL_DB_TYPE_PGSQL) {\n        expiration_clause = msprintf(\"> TO_TIMESTAMP(%u)\", (now - (unsigned int)json_integer_value(json_object_get(j_params, \"credential-assertion\"))));\n      } else { // HOEL_DB_TYPE_SQLITE\n        expiration_clause = msprintf(\"> %u\", (now - (unsigned int)json_integer_value(json_object_get(j_params, \"credential-assertion\"))));\n      }\n      j_query = json_pack(\"{sss[ssss]s{sss{ssss}sis{ssss}si}}\",\n                          \"table\",\n                          G_TABLE_WEBAUTHN_ASSERTION,\n                          \"columns\",\n                            \"gswa_id\",\n                            \"gswu_id\",\n                            \"gswa_session_hash AS session_hash\",\n                            \"gswa_challenge_hash AS challenge_hash\",\n                          \"where\",\n                            \"gswa_session_hash\",\n                            session_hash,\n                            \"gswu_id\",\n                              \"operator\",\n                              \"raw\",\n                              \"value\",\n                              username_clause,\n                            \"gswa_status\",\n                            0,\n                            \"gswa_issued_at\",\n                              \"operator\",\n                              \"raw\",\n                              \"value\",\n                              expiration_clause,\n                            \"gswa_mock\",\n                            mock);\n      o_free(username_clause);\n      o_free(username_escaped);\n      o_free(mod_name_escaped);\n      o_free(expiration_clause);\n      res = h_select(config->conn, j_query, &j_result, NULL);\n      json_decref(j_query);\n      if (res == H_OK) {\n        if (json_array_size(j_result)) {\n          j_return = json_pack(\"{sisO}\", \"result\", G_OK, \"assertion\", json_array_get(j_result, 0));\n        } else {\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n        }\n        json_decref(j_result);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"get_assertion_from_session - Error executing j_query\");\n        config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"get_assertion_from_session - Error generate_hash\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    o_free(session_hash);\n  } else {\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n  }\n  return j_return;\n}\n\nstatic int check_certificate(struct config_module * config, json_t * j_params, const char * credential_id, json_int_t gswu_id) {\n  json_t * j_query, * j_result;\n  int res, ret;\n  char * credential_id_escaped, * mod_name_escaped, * where_clause;\n  \n  credential_id_escaped = h_escape_string_with_quotes(config->conn, credential_id);\n  mod_name_escaped = h_escape_string_with_quotes(config->conn, json_string_value(json_object_get(j_params, \"mod_name\")));\n  where_clause = msprintf(\" IN (SELECT gswu_id FROM \" G_TABLE_WEBAUTHN_CREDENTIAL \" WHERE gswc_credential_id=%s AND gswc_status=1 AND gswu_id IN (SELECT gswu_id FROM \" G_TABLE_WEBAUTHN_USER \" WHERE gswu_mod_name=%s))\", credential_id_escaped, mod_name_escaped);\n  j_query = json_pack(\"{sss[s]s{s{ssss}si}}\",\n                      \"table\",\n                      G_TABLE_WEBAUTHN_CREDENTIAL,\n                      \"columns\",\n                        \"gswu_id\",\n                      \"where\",\n                        \"gswu_id\",\n                          \"operator\",\n                          \"raw\",\n                          \"value\",\n                          where_clause,\n                        \"gswc_status\",\n                        1);\n  o_free(where_clause);\n  o_free(mod_name_escaped);\n  o_free(credential_id_escaped);\n  res = h_select(config->conn, j_query, &j_result, NULL);\n  json_decref(j_query);\n  if (res == H_OK) {\n    if (json_array_size(j_result)) {\n      if (json_integer_value(json_object_get(json_array_get(j_result, 0), \"gswu_id\")) == gswu_id) {\n        ret = G_OK;\n      } else {\n        ret = G_ERROR_UNAUTHORIZED;\n      }\n    } else {\n      ret = G_ERROR_NOT_FOUND;\n    }\n    json_decref(j_result);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_credential_id - Error executing j_query\");\n    config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n    ret = G_ERROR_DB;\n  }\n  return ret;\n}\n\nstatic int validate_certificate_from_root(json_t * j_params, gnutls_x509_crt_t cert_leaf, cbor_item_t * x5c_array) {\n  int ret = G_ERROR_NOT_FOUND, res;\n  unsigned int result;\n  gnutls_datum_t cert_dat = {NULL, 0}, issuer_dat = {NULL, 0};\n  gnutls_x509_trust_list_t tlist = NULL;\n  gnutls_x509_crt_t cert_x509[cbor_array_size(x5c_array)+1], root_x509 = NULL;\n  json_t * j_cert = NULL;\n  cbor_item_t * cbor_cert = NULL;\n  size_t index = 0, i = 0, x5c_array_size = cbor_array_size(x5c_array);\n  char * issuer;\n  \n  for (i=0; i<x5c_array_size+1; i++) {\n    cert_x509[i] = NULL;\n  }\n  if ((res = gnutls_x509_crt_get_issuer_dn2(cert_leaf, &issuer_dat)) >= 0) {\n    issuer = o_strndup((const char *)issuer_dat.data, issuer_dat.size);\n    json_array_foreach(json_object_get(j_params, \"root-ca-array\"), index, j_cert) {\n      if (0 == o_strcmp(issuer, json_string_value(json_object_get(j_cert, \"dn\")))) {\n        cert_dat.data = (unsigned char *)json_string_value(json_object_get(j_cert, \"x509\"));\n        cert_dat.size = json_string_length(json_object_get(j_cert, \"x509\"));\n        if (!gnutls_x509_crt_init(&root_x509) && !gnutls_x509_crt_import(root_x509, &cert_dat, GNUTLS_X509_FMT_PEM)) {\n          cert_x509[0] = cert_leaf;\n          for (i=1; i<x5c_array_size; i++) {\n            cbor_cert = cbor_array_get(x5c_array, i);\n            cert_dat.data = cbor_bytestring_handle(cbor_cert);\n            cert_dat.size = cbor_bytestring_length(cbor_cert);\n            if (gnutls_x509_crt_init(&cert_x509[i]) < 0 || gnutls_x509_crt_import(cert_x509[i], &cert_dat, GNUTLS_X509_FMT_DER) < 0) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"validate_certificate_from_root - Error import chain cert at index %zu\", i);\n              ret = G_ERROR;\n            }\n            cbor_decref(&cbor_cert);\n          }\n          cert_x509[x5c_array_size] = root_x509;\n          ret = G_OK;\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"validate_certificate_from_root - Error import root cert\");\n          ret = G_ERROR;\n        }\n      }\n    }\n    o_free(issuer);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"validate_certificate_from_root - Error gnutls_x509_crt_get_issuer_dn2: %d\", res);\n    ret = G_ERROR;\n  }\n  gnutls_free(issuer_dat.data);\n  \n  if (ret == G_OK) {\n    if (!gnutls_x509_trust_list_init(&tlist, 0)) {\n      if (gnutls_x509_trust_list_add_cas(tlist, &root_x509, 1, 0) >= 0) {\n        if (gnutls_x509_trust_list_verify_crt(tlist, cert_x509, 2, 0, &result, NULL) >= 0) {\n          if (result) {\n            y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_certificate_from_root - certificate chain invalid\");\n            ret = G_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"validate_certificate_from_root - Error gnutls_x509_trust_list_verify_crt\");\n          ret = G_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"validate_certificate_from_root - Error gnutls_x509_trust_list_add_cas\");\n        ret = G_ERROR;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"validate_certificate_from_root - Error gnutls_x509_trust_list_init\");\n      ret = G_ERROR;\n    }\n  }\n  gnutls_x509_crt_deinit(root_x509);\n  for (i=1; i<x5c_array_size; i++) {\n    gnutls_x509_crt_deinit(cert_x509[i]);\n  }\n  gnutls_x509_trust_list_deinit(tlist, 0);\n  return ret;\n}\n\nstatic int validate_safetynet_ca_root(json_t * j_params, gnutls_x509_crt_t cert_leaf, json_t * j_header_x5c) {\n  gnutls_x509_crt_t cert_x509[(json_array_size(j_header_x5c)+1)], root_x509 = NULL;\n  gnutls_x509_trust_list_t tlist = NULL;\n  int ret = G_OK;\n  unsigned int result, i;\n  json_t * j_cert;\n  unsigned char * header_cert_decoded;\n  size_t header_cert_decoded_len;\n  gnutls_datum_t cert_dat;\n  \n  cert_x509[0] = cert_leaf;\n  for (i=1; i<json_array_size(j_header_x5c); i++) {\n    j_cert = json_array_get(j_header_x5c, i);\n    \n    if ((header_cert_decoded = o_malloc(json_string_length(j_cert))) != NULL) {\n      if (o_base64_decode((const unsigned char *)json_string_value(j_cert), json_string_length(j_cert), header_cert_decoded, &header_cert_decoded_len)) {\n        if (!gnutls_x509_crt_init(&cert_x509[i])) {\n          cert_dat.data = header_cert_decoded;\n          cert_dat.size = header_cert_decoded_len;\n          if ((ret = gnutls_x509_crt_import(cert_x509[i], &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error gnutls_x509_crt_import: %d\", ret);\n            ret = G_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error gnutls_x509_crt_init\");\n          ret = G_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error o_base64_decode x5c leaf\");\n        ret = G_ERROR;\n      }\n      o_free(header_cert_decoded);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error allocating resources for header_cert_decoded\");\n      ret = G_ERROR_MEMORY;\n    }\n  }\n  \n  if (ret == G_OK) {\n    cert_dat.data = (unsigned char *)json_string_value(json_object_get(json_object_get(j_params, \"google-root-ca-r2-content\"), \"x509\"));\n    cert_dat.size = json_string_length(json_object_get(json_object_get(j_params, \"google-root-ca-r2-content\"), \"x509\"));\n    if (!gnutls_x509_crt_init(&cert_x509[json_array_size(j_header_x5c)]) && \n        !gnutls_x509_crt_import(cert_x509[json_array_size(j_header_x5c)], &cert_dat, GNUTLS_X509_FMT_PEM)) {\n      if (!gnutls_x509_crt_init(&root_x509) && \n          !gnutls_x509_crt_import(root_x509, &cert_dat, GNUTLS_X509_FMT_PEM)) {\n        if (!gnutls_x509_trust_list_init(&tlist, 0)) {\n          if (gnutls_x509_trust_list_add_cas(tlist, &root_x509, 1, 0) >= 0) {\n            if (gnutls_x509_trust_list_verify_crt(tlist, cert_x509, (json_array_size(j_header_x5c)+1), 0, &result, NULL) >= 0) {\n              if (!result) {\n                ret = G_OK;\n              } else {\n                y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_safetynet_ca_root - certificate chain invalid\");\n                ret = G_ERROR;\n              }\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error gnutls_x509_trust_list_verify_crt\");\n              ret = G_ERROR;\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error gnutls_x509_trust_list_add_cas\");\n            ret = G_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error gnutls_x509_trust_list_init\");\n          ret = G_ERROR;\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error import root cert\");\n        ret = G_ERROR;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"validate_safetynet_ca_root - Error import last cert\");\n      ret = G_ERROR;\n    }\n  }\n  // Clean after me\n  for (i=1; i<json_array_size(j_header_x5c); i++) {\n    gnutls_x509_crt_deinit(cert_x509[i]);\n  }\n  gnutls_x509_crt_deinit(cert_x509[json_array_size(j_header_x5c)]);\n  gnutls_x509_trust_list_deinit(tlist, 1);\n  return ret;\n}\n\nstatic int validate_packed_leaf_certificate(gnutls_x509_crt_t cert, unsigned char * aaguid) {\n  int ret = G_OK, i, c_valid = 0, o_valid = 0, ou_valid = 0, cn_valid = 0;\n  unsigned int critial = 1, ca = 1;\n  char cert_dn[128] = {0}, ** dn_exploded = NULL;\n  unsigned char aaguid_oid[32];\n  size_t cert_dn_len = 128, aaguid_oid_len = 32;\n  \n  do {\n    if (gnutls_x509_crt_get_version(cert) != 3) {\n      ret = G_ERROR_PARAM;\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Invalid certificate version\");\n      break;\n    }\n    \n    if ((ret = gnutls_x509_crt_get_dn(cert, cert_dn, &cert_dn_len)) < 0) {\n      ret = G_ERROR_PARAM;\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Error gnutls_x509_crt_get_dn\");\n      break;\n    }\n    \n    if ((dn_exploded = ldap_explode_dn(cert_dn, 0)) == NULL) {\n      ret = G_ERROR;\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Error ldap_explode_dn\");\n      break;\n    }\n    \n    for (i=0; dn_exploded[i] != NULL; i++) {\n      if (0 == o_strncasecmp(G_PACKED_CERT_C_KEY, dn_exploded[i], o_strlen(G_PACKED_CERT_C_KEY)) && string_array_has_value(iso_3166_list, dn_exploded[i]+o_strlen(G_PACKED_CERT_C_KEY))) {\n        c_valid = 1;\n      } else if (0 == o_strncasecmp(G_PACKED_CERT_O_KEY, dn_exploded[i], o_strlen(G_PACKED_CERT_O_KEY)) && o_strlen(dn_exploded[i]) > 2) {\n        o_valid = 1;\n      } else if (0 == o_strncasecmp(G_PACKED_CERT_CN_KEY, dn_exploded[i], o_strlen(G_PACKED_CERT_CN_KEY)) && o_strlen(dn_exploded[i]) > 3) {\n        cn_valid = 1;\n      } else if (0 == o_strncasecmp(G_PACKED_CERT_OU_KEY, dn_exploded[i], o_strlen(G_PACKED_CERT_OU_KEY)) && 0 == o_strcmp(G_PACKED_CERT_OU_VALUE, dn_exploded[i]+o_strlen(G_PACKED_CERT_OU_KEY))) {\n        ou_valid = 1;\n      }\n    }\n    ber_memvfree((void **)dn_exploded);\n    \n    if (!c_valid || !o_valid || !cn_valid || !ou_valid) {\n      ret = G_ERROR_PARAM;\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Invalid dn - C:%s - O:%s - OU:%s - CN:%s\", c_valid?\"valid\":\"invalid\", o_valid?\"valid\":\"invalid\", ou_valid?\"valid\":\"invalid\", cn_valid?\"valid\":\"invalid\");\n      break;\n    }\n    \n    if (gnutls_x509_crt_get_basic_constraints(cert, &critial, &ca, NULL) < 0) {\n      ret = G_ERROR;\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Error gnutls_x509_crt_get_basic_constraints\");\n      break;\n    }\n    \n    if (ca) {\n      ret = G_ERROR_PARAM;\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Error basic constraints for CA is set to true\");\n      break;\n    }\n    \n    if (gnutls_x509_crt_get_extension_by_oid(cert, G_PACKED_OID_AAGUID, 0, aaguid_oid, &aaguid_oid_len, NULL) >= 0) {\n      if (aaguid_oid_len != AAGUID_LEN+2) {\n        ret = G_ERROR_PARAM;\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Invalid aaguid_oid_len size %zu\", aaguid_oid_len);\n        break;\n      }\n      \n      if (memcmp(aaguid_oid+2, aaguid, AAGUID_LEN)) {\n        ret = G_ERROR_PARAM;\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"validate_packed_leaf_certificate - Invalid aaguid_oid match\");\n        break;\n      }\n    }\n    \n  } while (0);\n  \n  return ret;\n}\n\n/**\n * \n * Validate the attStmt object under the packed format\n * https://w3c.github.io/webauthn/#sctn-packed-attestation\n * (Step) Hey girl, when you smile\n * You got to know that you drive me wild\n * \n */\nstatic json_t * check_attestation_packed(json_t * j_params, cbor_item_t * auth_data, cbor_item_t * att_stmt, const unsigned char * client_data, gnutls_pubkey_t g_key) {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key, * alg = NULL, * sig = NULL, * x5c_array = NULL, * cert_leaf = NULL;\n  size_t i, client_data_hash_len = 32, cert_export_len = 128, cert_export_b64_len = 0;\n  char * message;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  int ret, sig_alg = GNUTLS_SIGN_UNKNOWN;\n  unsigned char client_data_hash[32], cert_export[128], cert_export_b64[256];\n\n  data.data = NULL;\n  UNUSED(j_params);\n  \n  if (j_error != NULL) {\n    do {\n      for (i=0; i<cbor_map_size(att_stmt); i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char *)cbor_string_handle(key), \"alg\", MIN(o_strlen(\"alg\"), cbor_string_length(key))) && cbor_isa_negint(cbor_map_handle(att_stmt)[i].value)) {\n            alg = cbor_map_handle(att_stmt)[i].value;\n            if (cbor_get_int(alg) == 6) {\n              sig_alg = GNUTLS_SIGN_ECDSA_SHA256;\n            } else if (cbor_get_int(alg) == 34) {\n              sig_alg = GNUTLS_SIGN_ECDSA_SHA384;\n            } else if (cbor_get_int(alg) == 35) {\n              sig_alg = GNUTLS_SIGN_ECDSA_SHA512;\n            }\n            if (sig_alg == GNUTLS_SIGN_UNKNOWN) {\n              json_array_append_new(j_error, json_string(\"Signature algorithm not supported\"));\n              break;\n            }\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"sig\", MIN(o_strlen(\"sig\"), cbor_string_length(key))) && cbor_isa_bytestring(cbor_map_handle(att_stmt)[i].value)) {\n            sig = cbor_map_handle(att_stmt)[i].value;\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"x5c\", MIN(o_strlen(\"x5c\"), cbor_string_length(key))) && cbor_isa_array(cbor_map_handle(att_stmt)[i].value) && cbor_array_size(cbor_map_handle(att_stmt)[i].value)) {\n            x5c_array = cbor_map_handle(att_stmt)[i].value;\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"ecdaaKeyId\", MIN(o_strlen(\"ecdaaKeyId\"), cbor_string_length(key)))) {\n            json_array_append_new(j_error, json_string(\"ecdaaKeyId not supported\"));\n            break;\n          }\n        } else {\n          message = msprintf(\"attStmt map element %zu key is not a string\", i);\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          break;\n        }\n      }\n      \n      if (json_array_size(j_error)) {\n        break;\n      }\n      \n      if (alg == NULL || sig == NULL) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_packed - Error alg or sig are not mapped in att_stmt\");\n        break;\n      }\n      \n      if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Error generate_digest_raw client_data\");\n        break;\n      }\n      \n      if ((data.data = o_malloc(cbor_bytestring_length(auth_data) + client_data_hash_len)) == NULL) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Error o_malloc data.data\");\n        break;\n      }\n      \n      signature.data = cbor_bytestring_handle(sig);\n      signature.size = cbor_bytestring_length(sig);\n      \n      memcpy(data.data, cbor_bytestring_handle(auth_data), cbor_bytestring_length(auth_data));\n      memcpy(data.data + cbor_bytestring_length(auth_data), client_data_hash, client_data_hash_len);\n      data.size = cbor_bytestring_length(auth_data) + client_data_hash_len;\n        \n      // packed disable SELF attestation for now\n      if (x5c_array == NULL) {\n        if (gnutls_pubkey_verify_data2(g_key, sig_alg, 0, &data, &signature)) {\n          json_array_append_new(j_error, json_string(\"Invalid signature\"));\n          break;\n        }\n        \n        cert_export_b64_len = 0;\n        cert_export_b64[0] = '\\0';\n      } else {\n        if (gnutls_x509_crt_init(&cert)) {\n          json_array_append_new(j_error, json_string(\"check_attestation_packed - Error gnutls_x509_crt_init\"));\n          break;\n        }\n        if (gnutls_pubkey_init(&pubkey)) {\n          json_array_append_new(j_error, json_string(\"check_attestation_packed - Error gnutls_pubkey_init\"));\n          break;\n        }\n\n        cert_leaf = cbor_array_get(x5c_array, 0);\n        cert_dat.data = cbor_bytestring_handle(cert_leaf);\n        cert_dat.size = cbor_bytestring_length(cert_leaf);\n        \n        if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n          json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Error gnutls_pcert_import_x509_raw: %d\", ret);\n          break;\n        }\n        \n        if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) {\n          json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Error gnutls_pubkey_import_x509: %d\", ret);\n          break;\n        }\n        \n        if (gnutls_pubkey_verify_data2(pubkey, sig_alg, 0, &data, &signature)) {\n          json_array_append_new(j_error, json_string(\"Invalid signature\"));\n          break;\n        }\n        \n        if (validate_packed_leaf_certificate(cert, (cbor_bytestring_handle(auth_data)+ATTESTED_CRED_DATA_OFFSET)) != G_OK) {\n          json_array_append_new(j_error, json_string(\"Invalid certificate\"));\n          break;\n        }\n        \n        if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) {\n          json_array_append_new(j_error, json_string(\"Error exporting x509 certificate\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Error gnutls_x509_crt_get_key_id: %d\", ret);\n          break;\n        }\n        \n        if (json_object_get(j_params, \"root-ca-list\") != json_null() && validate_certificate_from_root(j_params, cert, x5c_array) != G_OK) {\n          json_array_append_new(j_error, json_string(\"Unrecognized certificate authority\"));\n          if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) {\n            message = msprintf(\"Unrecognized certificate autohority: %.*s\", cert_issued_by.size, cert_issued_by.data);\n            y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - %s\", message);\n            o_free(message);\n            gnutls_free(cert_issued_by.data);\n          } else {\n            y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Unrecognized certificate autohority (unable to get issuer dn)\");\n          }\n          break;\n        }\n        \n        if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) {\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_packed - Error o_base64_encode cert_export\");\n          break;\n        }\n      }\n      \n    } while (0);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_x509_crt_deinit(cert);\n    gnutls_pubkey_deinit(pubkey);\n    o_free(data.data);\n    if (cert_leaf != NULL) {\n      cbor_decref(&cert_leaf);\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_packed - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\n/**\n * \n * Validate the attStmt object under the Android SafetyNet format\n * https://w3c.github.io/webauthn/#sctn-android-safetynet-attestation\n * (step) hey girl, in your eyes\n * I see a picture of me all the time\n * \n */\nstatic json_t * check_attestation_android_safetynet(json_t * j_params, cbor_item_t * auth_data, cbor_item_t * att_stmt, const unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n  unsigned char pubkey_export[1024] = {0}, cert_export[32] = {0}, cert_export_b64[64], client_data_hash[32], * nonce_base = NULL, nonce_base_hash[32], * nonce_base_hash_b64 = NULL, * header_cert_decoded = NULL;\n  char * message = NULL, * response_token = NULL, issued_to[128] = {0}, * jwt_header = NULL;\n  size_t pubkey_export_len = 1024, cert_export_len = 32, cert_export_b64_len, issued_to_len = 128, client_data_hash_len = 32, nonce_base_hash_len = 32, nonce_base_hash_b64_len = 0, header_cert_decoded_len = 0;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  cbor_item_t * key, * response = NULL;\n  int i, ret;\n  jwt_t * j_response = NULL;\n  json_t * j_header_x5c = NULL, * j_cert = NULL, * j_header = NULL, * j_value = NULL;\n  gnutls_datum_t cert_dat;\n  int has_ver = 0;\n  \n  if (j_error != NULL) {\n    do {\n      // Step 1\n      if (!cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'attStmt' invalid format\"));\n        break;\n      }\n      for (i=0; i<2; i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char *)cbor_string_handle(key), \"ver\", MIN(o_strlen(\"ver\"), cbor_string_length(key))) && cbor_isa_string(cbor_map_handle(att_stmt)[i].value)) {\n            has_ver = 1;\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"response\", MIN(o_strlen(\"response\"), cbor_string_length(key))) && cbor_isa_bytestring(cbor_map_handle(att_stmt)[i].value)) {\n            response = cbor_map_handle(att_stmt)[i].value;\n          } else {\n            message = msprintf(\"attStmt map element %d key is not valid: '%.*s'\", i, cbor_string_length(key), cbor_string_handle(key));\n            json_array_append_new(j_error, json_string(message));\n            o_free(message);\n            break;\n          }\n        } else {\n          message = msprintf(\"attStmt map element %d key is not a string\", i);\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          break;\n        }\n      }\n      \n      if (!has_ver) {\n        json_array_append_new(j_error, json_string(\"version invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error ver missing\");\n        break;\n      }\n\n      if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error generate_digest_raw client_data\");\n        break;\n      }\n      \n      if ((nonce_base = o_malloc(32 + cbor_bytestring_length(auth_data))) == NULL) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error allocating resources for nonce_base\");\n        break;\n      }\n      memcpy(nonce_base, cbor_bytestring_handle(auth_data), cbor_bytestring_length(auth_data));\n      memcpy(nonce_base+cbor_bytestring_length(auth_data), client_data_hash, client_data_hash_len);\n      \n      if (!generate_digest_raw(digest_SHA256, nonce_base, 32 + cbor_bytestring_length(auth_data), nonce_base_hash, &nonce_base_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error generate_digest_raw nonce_base\");\n        break;\n      }\n      \n      if ((nonce_base_hash_b64 = o_malloc(64)) == NULL) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error allocating resources for nonce_base_hash_b64\");\n        break;\n      }\n\n      if (!o_base64_encode(nonce_base_hash, 32, nonce_base_hash_b64, &nonce_base_hash_b64_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error o_base64_encode for nonce_base_hash_b64\");\n        break;\n      }\n      \n      if (response == NULL) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error response missing\");\n        break;\n      }\n      \n      if ((response_token = o_strndup((const char *)cbor_bytestring_handle(response), cbor_bytestring_length(response))) == NULL) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error o_strndup for response_token\");\n        break;\n      }\n      \n      if (r_jwt_init(&j_response) != RHN_OK) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error r_jwt_init\");\n        break;\n      }\n      \n      if (r_jwt_parse(j_response, response_token, 0) != RHN_OK) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error r_jwt_parse\");\n        break;\n      }\n      \n      if (o_strcmp(r_jwt_get_claim_str_value(j_response, \"nonce\"), (const char *)nonce_base_hash_b64)) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error nonce invalid\");\n        break;\n      }\n      \n      if (json_integer_value(json_object_get(j_params, \"ctsProfileMatch\")) != -1 && json_integer_value(json_object_get(j_params, \"ctsProfileMatch\")) != ((j_value = r_jwt_get_claim_json_t_value(j_response, \"ctsProfileMatch\"))==json_true()?1:0)) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error ctsProfileMatch invalid\");\n        json_decref(j_value);\n        j_value = NULL;\n        break;\n      }\n      json_decref(j_value);\n      j_value = NULL;\n      \n      if (json_integer_value(json_object_get(j_params, \"basicIntegrity\")) != -1 && json_integer_value(json_object_get(j_params, \"basicIntegrity\")) != ((j_value = r_jwt_get_claim_json_t_value(j_response, \"basicIntegrity\"))==json_true()?1:0)) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error basicIntegrity invalid\");\n        j_value = NULL;\n        break;\n      }\n      json_decref(j_value);\n      j_value = NULL;\n      \n      if (r_jwt_verify_signature(j_response, NULL, 0) != RHN_OK) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error r_jwt_verify_signature\");\n        break;\n      }\n      \n      if ((j_header_x5c = r_jwt_get_header_json_t_value(j_response, \"x5c\")) == NULL) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error parsing x5c JSON\");\n        break;\n      }\n      \n      if (!json_is_string((j_cert = json_array_get(j_header_x5c, 0)))) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error x5c leaf not a string\");\n        break;\n      }\n      \n      if ((header_cert_decoded = o_malloc(json_string_length(j_cert))) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error allocating resources for header_cert_decoded\");\n        break;\n      }\n      \n      if (!o_base64_decode((const unsigned char *)json_string_value(j_cert), json_string_length(j_cert), header_cert_decoded, &header_cert_decoded_len)) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error o_base64_decode x5c leaf\");\n        break;\n      }\n      \n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error, json_string(\"internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error gnutls_x509_crt_init\");\n        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error, json_string(\"internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error gnutls_pubkey_init\");\n        break;\n      }\n      cert_dat.data = header_cert_decoded;\n      cert_dat.size = header_cert_decoded_len;\n      if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error gnutls_pcert_import_x509_raw: %d\", ret);\n        break;\n      }\n      if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error gnutls_pubkey_import_x509: %d\", ret);\n        break;\n      }\n      if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error exporting x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error gnutls_x509_crt_get_key_id: %d\", ret);\n        break;\n      }\n      if ((ret = gnutls_x509_crt_get_dn(cert, issued_to, &issued_to_len)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error x509 dn\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error gnutls_x509_crt_get_dn: %d\", ret);\n        break;\n      }\n      if (o_strnstr(issued_to, SAFETYNET_ISSUED_TO, issued_to_len) == NULL) {\n        json_array_append_new(j_error, json_string(\"Error x509 dn\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - safetynet certificate issued for %.*s\", issued_to_len, issued_to);\n        break;\n      }\n      if (json_object_get(j_params, \"google-root-ca-r2\") != json_null()) {\n        if ((ret = validate_safetynet_ca_root(j_params, cert, j_header_x5c)) == G_ERROR_UNAUTHORIZED) {\n          json_array_append_new(j_error, json_string(\"Error x509 certificate chain validation\"));\n          break;\n        } else if (ret != G_OK) {\n          json_array_append_new(j_error, json_string(\"response invalid\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - safetynet certificate chain certificate validation error\");\n          break;\n        }\n      }\n      if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error o_base64_encode cert_export\");\n        break;\n      }\n      if ((ret = gnutls_pubkey_export(pubkey, GNUTLS_X509_FMT_PEM, pubkey_export, &pubkey_export_len)) < 0) {\n        json_array_append_new(j_error, json_string(\"response invalid\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_android_safetynet - Error gnutls_pubkey_export: %d\", ret);\n        break;\n      }\n      \n    } while (0);\n\n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    json_decref(j_header);\n    json_decref(j_header_x5c);\n    gnutls_pubkey_deinit(pubkey);\n    gnutls_x509_crt_deinit(cert);\n    r_jwt_free(j_response);\n    o_free(nonce_base);\n    o_free(nonce_base_hash_b64);\n    o_free(response_token);\n    o_free(header_cert_decoded);\n    o_free(jwt_header);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_android_safetynet - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\n/**\n * \n * Validate the attStmt object under the fido-u2f format\n * https://w3c.github.io/webauthn/#sctn-fido-u2f-attestation\n * Gonna get to you girl\n * Really want you in my world\n * \n */\nstatic json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char * data_signed = NULL, client_data_hash[32], cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL) {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n        break;\n      }\n      \n      // Step 1\n      if (att_stmt == NULL || !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'attStmt' invalid format\"));\n        break;\n      }\n      for (i=0; i<2; i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char *)cbor_string_handle(key), \"x5c\", MIN(o_strlen(\"x5c\"), cbor_string_length(key)))) {\n            x5c = cbor_map_handle(att_stmt)[i].value;\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"sig\", MIN(o_strlen(\"sig\"), cbor_string_length(key)))) {\n            sig = cbor_map_handle(att_stmt)[i].value;\n          } else {\n            message = msprintf(\"attStmt map element %d key is not valid: '%.*s'\", i, cbor_string_length(key), cbor_string_handle(key));\n            json_array_append_new(j_error, json_string(message));\n            o_free(message);\n            break;\n          }\n        } else {\n          message = msprintf(\"attStmt map element %d key is not a string\", i);\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          break;\n        }\n      }\n      if (x5c == NULL || !cbor_isa_array(x5c) || cbor_array_size(x5c) != 1) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'x5c' invalid format\"));\n        break;\n      }\n      att_cert = cbor_array_get(x5c, 0);\n      cert_dat.data = cbor_bytestring_handle(att_cert);\n      cert_dat.size = cbor_bytestring_length(att_cert);\n      if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d\", ret);\n        break;\n      }\n      if (json_object_get(j_params, \"root-ca-list\") != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK) {\n        json_array_append_new(j_error, json_string(\"Unrecognized certificate authority\"));\n        if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) {\n          message = msprintf(\"Unrecognized certificate autohority: %.*s\", cert_issued_by.size, cert_issued_by.data);\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - %s\", message);\n          o_free(message);\n          gnutls_free(cert_issued_by.data);\n        } else {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Unrecognized certificate autohority (unable to get issuer dn)\");\n        }\n        break;\n      }\n      if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d\", ret);\n        break;\n      }\n      if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error exporting x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d\", ret);\n        break;\n      }\n      if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error o_base64_encode cert_export\");\n        break;\n      }\n      if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig)) {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"));\n        break;\n      }\n      \n      if ((data_signed = o_malloc(rpid_hash_len+client_data_hash_len+credential_id_len+cert_x_len+cert_y_len+2)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error allocating data_signed\");\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n      data_signed_offset+=client_data_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, credential_id, credential_id_len);\n      data_signed_offset+=credential_id_len;\n      \n      data_signed[data_signed_offset] = 0x04;\n      data_signed_offset++;\n      \n      memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);\n      data_signed_offset+=cert_x_len;\n      \n      memcpy(data_signed+data_signed_offset, cert_y, cert_y_len);\n      data_signed_offset+=cert_y_len;\n        \n      // Let's verify sig over data_signed\n      data.data = data_signed;\n      data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n    o_free(data_signed);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {\n      cbor_decref(&att_cert);\n    }\n    \n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\n/**\n * \n * It's like the New Kids On The Block\n * \n * You have to validate the credential by following\n * the registration procedure step by step\n * Because the w3c said so\n * https://w3c.github.io/webauthn/#registering-a-new-credential\n * \n */\nstatic json_t * register_new_attestation(struct config_module * config, json_t * j_params, json_t * j_scheme_data, json_t * j_credential) {\n  json_t * j_return, * j_client_data = NULL, * j_error, * j_result, * j_pubkey = NULL, * j_cert = NULL, * j_query, * j_element = NULL;\n  unsigned char * client_data = NULL, * challenge_b64 = NULL, * att_obj = NULL, * cbor_bs_handle = NULL, rpid_hash[32], * fmt = NULL, * credential_id_b64 = NULL, * cbor_auth_data, * cred_pub_key, cert_x[256], cert_y[256], pubkey_export[1024];\n  char * challenge_hash = NULL, * message = NULL;\n  const char * rpid = NULL;\n  size_t client_data_len = 0, challenge_b64_len = 0, att_obj_len = 0, rpid_hash_len = 32, fmt_len = 0, credential_id_len = 0, credential_id_b64_len, cbor_auth_data_len, cred_pub_key_len, cert_x_len = 0, cert_y_len = 0, pubkey_export_len = 1024, index = 0, cbor_bs_handle_len, rpid_len;\n  uint32_t counter = 0;\n  int ret = G_OK, res, status, has_x = 0, has_y = 0, key_type_valid = 0, key_alg_valid = 0;\n  unsigned int i;\n  struct cbor_load_result cbor_result;\n  cbor_item_t * item = NULL, * key = NULL, * auth_data = NULL, * att_stmt = NULL, * cbor_cose = NULL, * cbor_key, * cbor_value;\n  gnutls_pubkey_t g_key = NULL;\n  gnutls_datum_t g_x, g_y;\n  gnutls_ecc_curve_t curve = GNUTLS_ECC_CURVE_INVALID;\n  \n  if (j_scheme_data != NULL) {\n    j_error = json_array();\n    if (j_error != NULL) {\n      do {\n        if (!json_string_length(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\"))) {\n          json_array_append_new(j_error, json_string(\"rawId mandatory\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if (!json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\"))) {\n          json_array_append_new(j_error, json_string(\"clientDataJSON mandatory\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if ((client_data = o_malloc(json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\"))+1)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error allocating resources for client_data\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_MEMORY;\n          break;\n        }\n        if (!o_base64_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\")), client_data, &client_data_len)) {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error o_base64_decode client_data\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        client_data[client_data_len] = '\\0';\n        j_client_data = json_loads((const char *)client_data, JSON_DECODE_ANY, NULL);\n        if (j_client_data == NULL) {\n          json_array_append_new(j_error, json_string(\"Error parsing JSON client data\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        // Step 3\n        if (0 != o_strcmp(json_string_value(json_object_get(j_client_data, \"type\")), \"webauthn.create\")) {\n          json_array_append_new(j_error, json_string(\"clientDataJSON.type invalid\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        // Step 4\n        if (!json_string_length(json_object_get(j_client_data, \"challenge\"))) {\n          json_array_append_new(j_error, json_string(\"clientDataJSON.challenge mandatory\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if ((challenge_b64 = o_malloc(json_string_length(json_object_get(j_client_data, \"challenge\"))+3)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error allocating resources for challenge_b64\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_MEMORY;\n          break;\n        }\n        if (!o_base64url_2_base64((unsigned char *)json_string_value(json_object_get(j_client_data, \"challenge\")), json_string_length(json_object_get(j_client_data, \"challenge\")), challenge_b64, &challenge_b64_len)) {\n          json_array_append_new(j_error, json_string(\"clientDataJSON.challenge invalid format\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        challenge_b64[challenge_b64_len] = '\\0';\n        if ((challenge_hash = generate_hash(config->hash_algorithm, (const char *)challenge_b64)) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error generate_hash for challenge_b64\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR;\n          break;\n        }\n        if (0 != o_strcmp(challenge_hash, json_string_value(json_object_get(j_credential, \"challenge_hash\")))) {\n          json_array_append_new(j_error, json_string(\"clientDataJSON.challenge invalid\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        // Step 5\n        if (!json_string_length(json_object_get(j_client_data, \"origin\"))) {\n          json_array_append_new(j_error, json_string(\"clientDataJSON.origin mandatory\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if (0 != o_strcmp(json_string_value(json_object_get(j_params, \"rp-origin\")), json_string_value(json_object_get(j_client_data, \"origin\")))) {\n          message = msprintf(\"clientDataJSON.origin invalid - Client send %s, required %s\", json_string_value(json_object_get(j_client_data, \"origin\")), json_string_value(json_object_get(j_params, \"rp-origin\")));\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        // Step 6 ??\n        \n        if (!json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"attestationObject\"))) {\n          json_array_append_new(j_error, json_string(\"attestationObject required\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        if ((att_obj = o_malloc(json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"attestationObject\")))) == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error allocating resources for o_malloc\");\n          ret = G_ERROR_MEMORY;\n          break;\n        }\n        if (!o_base64_decode((unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"attestationObject\")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"attestationObject\")), att_obj, &att_obj_len)) {\n          json_array_append_new(j_error, json_string(\"attestationObject invalid base64\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n\n        // Step 7\n        item = cbor_load(att_obj, att_obj_len, &cbor_result);\n        if (cbor_result.error.code != CBOR_ERR_NONE) {\n          json_array_append_new(j_error, json_string(\"attestationObject invalid cbor\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if (!cbor_isa_map(item)) {\n          json_array_append_new(j_error, json_string(\"attestationObject invalid cbor item\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        // Check attestation object\n        if (cbor_map_size(item) != 3) {\n          json_array_append_new(j_error, json_string(\"attestationObject invalid cbor item\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n\n        for (i=0; i<3; i++) {\n          key = cbor_map_handle(item)[i].key;\n          if (cbor_isa_string(key)) {\n            if (0 == o_strncmp((const char *)cbor_string_handle(key), \"fmt\", MIN(o_strlen(\"fmt\"), cbor_string_length(key)))) {\n              if (!cbor_isa_string(cbor_map_handle(item)[i].value)) {\n                json_array_append_new(j_error, json_string(\"CBOR map value 'fmt' isnt't a string\"));\n                ret = G_ERROR_PARAM;\n                break;\n              } else {\n                fmt_len = cbor_string_length(cbor_map_handle(item)[i].value);\n                fmt = cbor_string_handle(cbor_map_handle(item)[i].value);\n              }\n            } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"attStmt\", MIN(o_strlen(\"attStmt\"), cbor_string_length(key)))) {\n              att_stmt = cbor_map_handle(item)[i].value;\n            } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"authData\", MIN(o_strlen(\"authData\"), cbor_string_length(key)))) {\n              auth_data = cbor_map_handle(item)[i].value;\n              if (!cbor_isa_bytestring(auth_data) || cbor_bytestring_length(auth_data) < 56 || cbor_bytestring_is_indefinite(auth_data)) {\n                json_array_append_new(j_error, json_string(\"CBOR map value 'authData' is invalid\"));\n                ret = G_ERROR_PARAM;\n                break;\n              }\n            } else {\n              message = msprintf(\"CBOR map element %d is not an expected item\", i);\n              json_array_append_new(j_error, json_string(message));\n              o_free(message);\n              ret = G_ERROR_PARAM;\n              break;\n            }\n          }\n        }\n        \n        // Step 9\n        if (auth_data == NULL) {\n          json_array_append_new(j_error, json_string(\"authData invalid\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        cbor_bs_handle = cbor_bytestring_handle(auth_data);\n        cbor_bs_handle_len = cbor_bytestring_length(auth_data);\n        if (o_strstr(json_string_value(json_object_get(j_params, \"rp-origin\")), \"://\") == NULL) {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - rp-origin invalid\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        if (o_strstr(json_string_value(json_object_get(j_params, \"rp-origin\")), \"://\") != NULL) {\n          rpid = o_strstr(json_string_value(json_object_get(j_params, \"rp-origin\")), \"://\")+3;\n        } else {\n          rpid = json_string_value(json_object_get(j_params, \"rp-origin\"));\n        }\n        if (o_strchr(rpid, ':') != NULL) {\n          rpid_len = o_strchr(rpid, ':') - rpid;\n        } else {\n          rpid_len = o_strlen(rpid);\n        }\n        \n        if (!generate_digest_raw(digest_SHA256, (unsigned char *)rpid, rpid_len, rpid_hash, &rpid_hash_len)) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error generate_digest_raw\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        if (0 != memcmp(cbor_bs_handle, rpid_hash, rpid_hash_len)) {\n          json_array_append_new(j_error, json_string(\"authData.rpIdHash invalid\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        // Step 10\n        if (!(cbor_bs_handle[FLAGS_OFFSET] & FLAG_USER_PRESENT)) {\n          json_array_append_new(j_error, json_string(\"authData.userPresent not set\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if (!(cbor_bs_handle[FLAGS_OFFSET] & FLAG_AT)) {\n          json_array_append_new(j_error, json_string(\"authData.Attested credential data not set\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        // Step 11 ignored for now\n        //y_log_message(Y_LOG_LEVEL_DEBUG, \"authData.userVerified: %d\", !!(cbor_bs_handle[FLAGS_OFFSET] & FLAG_USER_VERIFY));\n        \n        // Step 12 ignored for now (no extension)\n        //y_log_message(Y_LOG_LEVEL_DEBUG, \"authData.Extension: %d\", !!(cbor_bs_handle[FLAGS_OFFSET] & FLAG_ED));\n        \n        credential_id_len = cbor_bs_handle[CRED_ID_L_OFFSET+1] | (cbor_bs_handle[CRED_ID_L_OFFSET] << 8);\n        if (cbor_bs_handle_len < CRED_ID_L_OFFSET+2+credential_id_len) {\n          json_array_append_new(j_error, json_string(\"auth_data invalid size\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        credential_id_b64 = o_malloc(credential_id_len*2);\n        if (credential_id_b64 == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error o_malloc for credential_id_b64\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        if (!o_base64_encode(cbor_bs_handle+CRED_ID_L_OFFSET+2, credential_id_len, credential_id_b64, &credential_id_b64_len)) {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error o_base64_encode for credential_id_b64\");\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        // Compare credential_id_b64 with rawId\n        if (memcmp(credential_id_b64, json_string_value(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\")), MIN(json_string_length(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\")), credential_id_b64_len))) {\n          json_array_append_new(j_error, json_string(\"Invalid rawId\"));\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        // Extract public key from auth_data COSE structure\n\n        // Extract credential ID\n        cbor_auth_data_len = cbor_bytestring_length(auth_data);\n        cbor_auth_data = cbor_bytestring_handle(auth_data);\n        \n        cred_pub_key = cbor_auth_data+CREDENTIAL_ID_OFFSET+credential_id_len;\n        cred_pub_key_len = cbor_auth_data_len-CREDENTIAL_ID_OFFSET-credential_id_len;\n        cbor_cose = cbor_load(cred_pub_key, cred_pub_key_len, &cbor_result);\n        if (cbor_result.error.code != CBOR_ERR_NONE) {\n          json_array_append_new(j_error, json_string(\"Invalid COSE key\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error cbor_load cbor_cose\");\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        if (!cbor_isa_map(cbor_cose)) {\n          json_array_append_new(j_error, json_string(\"Invalid COSE key\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error cbor_cose not a map\");\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        for (i=0; i<cbor_map_size(cbor_cose); i++) {\n          cbor_key = cbor_map_handle(cbor_cose)[i].key;\n          cbor_value = cbor_map_handle(cbor_cose)[i].value;\n          if (cbor_isa_negint(cbor_key) && cbor_get_int(cbor_key) == 1 && cbor_isa_bytestring(cbor_value)) {\n            has_x = 1;\n            memcpy(cert_x, cbor_bytestring_handle(cbor_value), cbor_bytestring_length(cbor_value));\n            cert_x_len = cbor_bytestring_length(cbor_value);\n            g_x.data = cert_x;\n            g_x.size = cbor_bytestring_length(cbor_value);\n          } else if (cbor_isa_negint(cbor_key) && cbor_get_int(cbor_key) == 2 && cbor_isa_bytestring(cbor_value)) {\n            has_y = 1;\n            memcpy(cert_y, cbor_bytestring_handle(cbor_value), cbor_bytestring_length(cbor_value));\n            cert_y_len = cbor_bytestring_length(cbor_value);\n            g_y.data = cert_y;\n            g_y.size = cbor_bytestring_length(cbor_value);\n          } else if (cbor_isa_uint(cbor_key) && cbor_get_int(cbor_key) == 1 && cbor_isa_uint(cbor_value) && cbor_get_int(cbor_value) == 2) {\n            key_type_valid = 1;\n          } else if (cbor_isa_uint(cbor_key) && cbor_get_int(cbor_key) == 3 && cbor_isa_negint(cbor_value)) {\n            if (cbor_get_int(cbor_value) == 6 || cbor_get_int(cbor_value) == 34 || cbor_get_int(cbor_value) == 35) {\n              json_array_foreach(json_object_get(j_params, \"pubKey-cred-params\"), index, j_element) {\n                if (cbor_get_int(cbor_value) == 6 && json_integer_value(json_object_get(j_element, \"alg\")) == ECDSA256) {\n                  key_alg_valid = 1;\n                  curve = GNUTLS_ECC_CURVE_SECP256R1;\n                } else if (cbor_get_int(cbor_value) == 34 && json_integer_value(json_object_get(j_element, \"alg\")) == ECDSA384) {\n                  key_alg_valid = 1;\n                  curve = GNUTLS_ECC_CURVE_SECP384R1;\n                } else if (cbor_get_int(cbor_value) == 35 && json_integer_value(json_object_get(j_element, \"alg\")) == ECDSA512) {\n                  key_alg_valid = 1;\n                  curve = GNUTLS_ECC_CURVE_SECP521R1;\n                }\n              }\n            }\n          }\n        }\n        \n        if (!has_x || !has_y || !key_type_valid || !key_alg_valid) {\n          json_array_append_new(j_error, json_string(\"Invalid COSE key\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error invalid COSE key has_x %d && has_y %d && key_type_valid %d && key_alg_valid %d\", has_x, has_y, key_type_valid, key_alg_valid);\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        if (gnutls_pubkey_init(&g_key)) {\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error gnutls_pubkey_init\");\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if (gnutls_pubkey_import_ecc_raw(g_key, curve, &g_x, &g_y) < 0) {\n          json_array_append_new(j_error, json_string(\"Internal error\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - error gnutls_pubkey_import_ecc_raw\");\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        if ((ret = gnutls_pubkey_export(g_key, GNUTLS_X509_FMT_PEM, pubkey_export, &pubkey_export_len)) < 0) {\n          json_array_append_new(j_error, json_string(\"Error exporting pubkey\"));\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - Error gnutls_pubkey_export: %d\", ret);\n          ret = G_ERROR_PARAM;\n          break;\n        }\n        \n        // Steps 13-14\n        if (0 == o_strncmp(\"packed\", (char *)fmt, MIN(fmt_len, o_strlen(\"packed\"))) && (json_object_get(json_object_get(j_params, \"fmt\"), \"packed\") == json_true())) {\n          j_result = check_attestation_packed(j_params, auth_data, att_stmt, client_data, g_key);\n          if (check_result_value(j_result, G_ERROR_PARAM)) {\n            json_array_extend(j_error, json_object_get(j_result, \"error\"));\n            ret = G_ERROR_PARAM;\n          } else if (!check_result_value(j_result, G_OK)) {\n            ret = G_ERROR_PARAM;\n            y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error check_attestation_packed\");\n            json_array_append_new(j_error, json_string(\"internal error\"));\n          } else {\n            j_cert = json_incref(json_object_get(json_object_get(j_result, \"data\"), \"certificate\"));\n          }\n          json_decref(j_result);\n        } else if (0 == o_strncmp(\"tpm\", (char *)fmt, MIN(fmt_len, o_strlen(\"tpm\"))) && (json_object_get(json_object_get(j_params, \"fmt\"), \"tpm\") == json_true())) {\n          json_array_append_new(j_error, json_string(\"Format 'tpm' not supported yet\"));\n          ret = G_ERROR_PARAM;\n        } else if (0 == o_strncmp(\"android-key\", (char *)fmt, MIN(fmt_len, o_strlen(\"android-key\"))) && (json_object_get(json_object_get(j_params, \"fmt\"), \"android-key\") == json_true())) {\n          json_array_append_new(j_error, json_string(\"Format 'android-key' not supported yet\"));\n          ret = G_ERROR_PARAM;\n        } else if (0 == o_strncmp(\"android-safetynet\", (char *)fmt, MIN(fmt_len, o_strlen(\"android-safetynet\"))) && (json_object_get(json_object_get(j_params, \"fmt\"), \"android-safetynet\") == json_true())) {\n          j_result = check_attestation_android_safetynet(j_params, auth_data, att_stmt, client_data);\n          if (check_result_value(j_result, G_ERROR_PARAM)) {\n            json_array_extend(j_error, json_object_get(j_result, \"error\"));\n            ret = G_ERROR_PARAM;\n          } else if (!check_result_value(j_result, G_OK)) {\n            ret = G_ERROR_PARAM;\n            y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error check_attestation_android_safetynet\");\n            json_array_append_new(j_error, json_string(\"internal error\"));\n          } else {\n            j_cert = json_incref(json_object_get(json_object_get(j_result, \"data\"), \"certificate\"));\n          }\n          json_decref(j_result);\n        } else if (0 == o_strncmp(\"fido-u2f\", (char *)fmt, MIN(fmt_len, o_strlen(\"fido-u2f\"))) && (json_object_get(json_object_get(j_params, \"fmt\"), \"fido-u2f\") == json_true())) {\n          j_result = check_attestation_fido_u2f(j_params, (cbor_auth_data+CREDENTIAL_ID_OFFSET), credential_id_len, cert_x, cert_x_len, cert_y, cert_y_len, att_stmt, rpid_hash, rpid_hash_len, client_data);\n          if (check_result_value(j_result, G_ERROR_PARAM)) {\n            json_array_extend(j_error, json_object_get(j_result, \"error\"));\n            ret = G_ERROR_PARAM;\n          } else if (!check_result_value(j_result, G_OK)) {\n            ret = G_ERROR_PARAM;\n            y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error check_attestation_fido_u2f\");\n            json_array_append_new(j_error, json_string(\"internal error\"));\n          } else {\n            j_cert = json_incref(json_object_get(json_object_get(j_result, \"data\"), \"certificate\"));\n          }\n          json_decref(j_result);\n        } else if (0 == o_strncmp(\"none\", (char *)fmt, MIN(fmt_len, o_strlen(\"none\"))) && (json_object_get(json_object_get(j_params, \"fmt\"), \"none\") == json_true() || json_object_get(j_params, \"force-fmt-none\") == json_true())) {\n          if (att_stmt != NULL && cbor_isa_map(att_stmt) && cbor_map_is_definite(att_stmt) && !cbor_map_size(att_stmt)) {\n            j_cert = json_string(\"\");\n          } else {\n            y_log_message(Y_LOG_LEVEL_DEBUG, \"register_new_attestation - response type 'none' has invalid format\");\n            json_array_append_new(j_error, json_string(\"response invalid\"));\n            ret = G_ERROR_PARAM;\n          }\n        } else {\n          message = msprintf(\"Format '%.*s' is not supported by Glewlwyd WebAuthn scheme\", fmt_len, fmt);\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          ret = G_ERROR_PARAM;\n        }\n      } while (0); // This is not a loop, but a structure where you can easily cancel the rest of the process with breaks\n      \n      if (ret != G_OK) {\n        if (json_array_size(j_error)) {\n          j_return = json_pack(\"{sisO}\", \"result\", ret, \"error\", j_error);\n        } else {\n          j_return = json_pack(\"{si}\", \"result\", ret);\n        }\n      } else {\n        if ((res = check_certificate(config, j_params, json_string_value(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\")), json_integer_value(json_object_get(j_credential, \"gswu_id\")))) == G_OK) {\n          j_return = json_pack(\"{sis[s]}\", \"result\", G_ERROR_PARAM, \"error\", \"Credential already registered\");\n          status = 2;\n        } else if (res == G_ERROR_UNAUTHORIZED) {\n          j_return = json_pack(\"{sis[s]}\", \"result\", G_ERROR_PARAM, \"error\", \"Credential unauthorized\");\n          status = 2;\n        } else if (res != G_ERROR_NOT_FOUND) {\n          j_return = json_pack(\"{sis[s]}\", \"result\", G_ERROR_PARAM, \"error\", \"Internal error\");\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error check_certificate\");\n          status = 2;\n        } else {\n          j_return = json_pack(\"{si}\", \"result\", G_OK);\n          status = 1;\n        }\n        counter = cbor_bs_handle[COUNTER_OFFSET+3] | (cbor_bs_handle[COUNTER_OFFSET+2] << 8) | (cbor_bs_handle[COUNTER_OFFSET+1] << 16) | (cbor_bs_handle[COUNTER_OFFSET] << 24);\n        // Store credential in the database\n        j_query = json_pack(\"{sss{siss%sOss%sOsi}s{sO}}\",\n                            \"table\", \n                            G_TABLE_WEBAUTHN_CREDENTIAL,\n                            \"set\",\n                              \"gswc_status\",\n                              status,\n                              \"gswc_name\",\n                              fmt,\n                              fmt_len,\n                              \"gswc_credential_id\",\n                              json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\"),\n                              \"gswc_public_key\",\n                              pubkey_export,\n                              pubkey_export_len,\n                              \"gswc_certificate\",\n                              j_cert,\n                              \"gswc_counter\",\n                              counter,\n                            \"where\",\n                              \"gswc_id\",\n                              json_object_get(j_credential, \"gswc_id\"));\n        res = h_update(config->conn, j_query, NULL);\n        json_decref(j_query);\n        if (res != H_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error h_update\");\n        }\n      }\n      json_decref(j_error);\n      json_decref(j_client_data);\n      json_decref(j_pubkey);\n      json_decref(j_cert);\n      o_free(client_data);\n      o_free(challenge_b64);\n      o_free(challenge_hash);\n      o_free(att_obj);\n      o_free(credential_id_b64);\n      gnutls_pubkey_deinit(g_key);\n      if (item != NULL) {\n        cbor_decref(&item);\n      }\n      if (cbor_cose != NULL) {\n        cbor_decref(&cbor_cose);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error allocating resources for j_error\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n  } else {\n    j_return = json_pack(\"{sis[s]}\", \"result\", G_ERROR_PARAM, \"error\", \"scheme_data mandatory\");\n  }\n  return j_return;\n}\n\n/**\n * \n */\nstatic int check_assertion(struct config_module * config, json_t * j_params, const char * username, json_t * j_scheme_data, json_t * j_assertion) {\n  int ret, res;\n  unsigned char * client_data = NULL, * challenge_b64 = NULL, * auth_data = NULL, rpid_hash[32] = {0}, * flags, cdata_hash[32] = {0}, \n                  data_signed[128] = {0}, sig[128] = {0}, * counter;\n  char * challenge_hash = NULL;\n  const char * rpid = NULL;\n  size_t client_data_len, challenge_b64_len, auth_data_len, rpid_hash_len = 32, cdata_hash_len = 32, sig_len = 128, counter_value = 0, rpid_len = 0;\n  json_t * j_client_data = NULL, * j_credential = NULL, * j_query;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_datum_t pubkey_dat, data, signature;\n  \n  if (j_scheme_data != NULL && j_assertion != NULL) {\n    do {\n      ret = G_OK;\n      \n      if (!json_is_string(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\")) || !json_string_length(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\"))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - rawId missing\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      j_credential = get_credential(config, j_params, username, json_string_value(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"rawId\")));\n      if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - credential ID not found\");\n        ret = G_ERROR_UNAUTHORIZED;\n        break;\n      }\n      if (!json_is_string(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\")) || !json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\"))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON mandatory\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      if ((client_data = o_malloc(json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\"))+1)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error allocating resources for client_data\");\n        ret = G_ERROR_MEMORY;\n        break;\n      }\n      if (!o_base64_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"clientDataJSON\")), client_data, &client_data_len)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error o_base64_decode client_data\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      client_data[client_data_len] = '\\0';\n      j_client_data = json_loads((const char *)client_data, JSON_DECODE_ANY, NULL);\n      if (j_client_data == NULL) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error parsing JSON client data %s\", client_data);\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      // Step 7\n      if (0 != o_strcmp(\"webauthn.get\", json_string_value(json_object_get(j_client_data, \"type\")))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON.type invalid\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      // Step 8\n      if (!json_string_length(json_object_get(j_client_data, \"challenge\"))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON.challenge mandatory\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      if ((challenge_b64 = o_malloc(json_string_length(json_object_get(j_client_data, \"challenge\"))+3)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error allocating resources for challenge_b64\");\n        ret = G_ERROR_MEMORY;\n        break;\n      }\n      if (!o_base64url_2_base64((unsigned char *)json_string_value(json_object_get(j_client_data, \"challenge\")), json_string_length(json_object_get(j_client_data, \"challenge\")), challenge_b64, &challenge_b64_len)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON.challenge invalid base64\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      challenge_b64[challenge_b64_len] = '\\0';\n      if ((challenge_hash = generate_hash(config->hash_algorithm, (const char *)challenge_b64)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"register_new_attestation - Error generate_hash for challenge_b64\");\n        ret = G_ERROR;\n        break;\n      }\n      if (0 != o_strcmp(challenge_hash, json_string_value(json_object_get(j_assertion, \"challenge_hash\")))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON.challenge invalid\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      // Step 9\n      if (!json_string_length(json_object_get(j_client_data, \"origin\"))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON.origin mandatory\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      if (0 != o_strcmp(json_string_value(json_object_get(j_params, \"rp-origin\")), json_string_value(json_object_get(j_client_data, \"origin\")))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - clientDataJSON.origin invalid - Client send %s, required %s\", json_string_value(json_object_get(j_client_data, \"origin\")), json_string_value(json_object_get(j_params, \"rp-origin\")));\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      // Step 10 ??\n      \n      // Step 11\n      if (!json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"authenticatorData\"))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - authenticatorData mandatory\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      if ((auth_data = o_malloc(json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"authenticatorData\"))+1)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error allocating resources for auth_data\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      if (!o_base64_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"authenticatorData\")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"authenticatorData\")), auth_data, &auth_data_len)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error o_base64_decode auth_data\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      if (auth_data_len < 37) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error authenticatorData invalid\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      \n      if (o_strstr(json_string_value(json_object_get(j_params, \"rp-origin\")), \"://\") != NULL) {\n        rpid = o_strstr(json_string_value(json_object_get(j_params, \"rp-origin\")), \"://\")+3;\n      } else {\n        rpid = json_string_value(json_object_get(j_params, \"rp-origin\"));\n      }\n      if (o_strchr(rpid, ':') != NULL) {\n        rpid_len = o_strchr(rpid, ':') - rpid;\n      } else {\n        rpid_len = o_strlen(rpid);\n      }\n        \n      if (!generate_digest_raw(digest_SHA256, (unsigned char *)rpid, rpid_len, rpid_hash, &rpid_hash_len)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error generate_digest_raw for rpid_hash\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      \n      if (0 != memcmp(auth_data, rpid_hash, rpid_hash_len)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - authData.rpIdHash invalid\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      flags = auth_data + FLAGS_OFFSET;\n      \n      // Step 12\n      if (!(*flags & FLAG_USER_PRESENT)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - authData.userPresent not set\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      \n      // Step 13 ignored for now\n      //y_log_message(Y_LOG_LEVEL_DEBUG, \"authData.userVerified: %d\", !!(*flags & FLAG_USER_VERIFY));\n      \n      // Step 14 ignored for now (no extension)\n      //y_log_message(Y_LOG_LEVEL_DEBUG, \"authData.Extension: %d\", !!(*flags & FLAG_ED));\n      \n      // Step 15\n      if (!generate_digest_raw(digest_SHA256, client_data, client_data_len, cdata_hash, &cdata_hash_len)) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error generate_digest_raw for cdata_hash\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      counter = auth_data + COUNTER_OFFSET;\n      counter_value = counter[3] | (counter[2] << 8) | (counter[1] << 16) | (counter[0] << 24);\n      \n      if (gnutls_pubkey_init(&pubkey) < 0) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error gnutls_pubkey_init\");\n        ret = G_ERROR;\n        break;\n      }\n      pubkey_dat.data = (unsigned char *)json_string_value(json_object_get(json_object_get(j_credential, \"credential\"), \"public_key\"));\n      pubkey_dat.size = json_string_length(json_object_get(json_object_get(j_credential, \"credential\"), \"public_key\"));\n      if ((ret = gnutls_pubkey_import(pubkey, &pubkey_dat, GNUTLS_X509_FMT_PEM)) < 0) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error gnutls_pubkey_import: %d\", ret);\n        ret = G_ERROR;\n        break;\n      }\n      \n      if (!o_base64url_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"signature\")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, \"credential\"), \"response\"), \"signature\")), sig, &sig_len)) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error o_base64url_decode signature\");\n        ret = G_ERROR_PARAM;\n        break;\n      }\n      \n      memcpy(data_signed, auth_data, auth_data_len);\n      memcpy(data_signed+auth_data_len, cdata_hash, cdata_hash_len);\n      \n      // Let's verify sig over data_signed\n      data.data = data_signed;\n      data.size = (auth_data_len+cdata_hash_len);\n      \n      signature.data = sig;\n      signature.size = sig_len;\n      \n      if ((res = gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) < 0) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Invalid signature: %d\", res);\n        ret = G_ERROR_UNAUTHORIZED;\n        break;\n      }\n      \n      if ((json_integer_value(json_object_get(json_object_get(j_credential, \"credential\"), \"counter\")) || counter_value) && counter_value <= (size_t)json_integer_value(json_object_get(json_object_get(j_credential, \"credential\"), \"counter\"))) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - counter invalid\");\n        ret = G_ERROR_UNAUTHORIZED;\n        break;\n      }\n    } while (0); // This is not a loop, but a structure where you can easily cancel the rest of the process with breaks\n    \n    if (ret == G_OK) {\n      // Update assertion\n      j_query = json_pack(\"{sss{sisi}s{sO}}\",\n                          \"table\",\n                          G_TABLE_WEBAUTHN_ASSERTION,\n                          \"set\",\n                            \"gswa_counter\",\n                            counter_value,\n                            \"gswa_status\",\n                            1,\n                          \"where\",\n                            \"gswa_id\",\n                            json_object_get(j_assertion, \"gswa_id\"));\n      res = h_update(config->conn, j_query, NULL);\n      json_decref(j_query);\n      if (res != H_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error executing j_query (1)\");\n        config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n        ret = G_ERROR_DB;\n      } else {\n        // Update counter in credential if necessary\n        if (counter) {\n          j_query = json_pack(\"{sss{si}s{sO}}\",\n                              \"table\",\n                              G_TABLE_WEBAUTHN_CREDENTIAL,\n                              \"set\",\n                                \"gswc_counter\",\n                                counter_value,\n                              \"where\",\n                                \"gswc_id\",\n                                json_object_get(json_object_get(j_credential, \"credential\"), \"gswc_id\"));\n          res = h_update(config->conn, j_query, NULL);\n          json_decref(j_query);\n          if (res != H_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error executing j_query (2)\");\n            config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n            ret = G_ERROR_DB;\n          }\n        }\n      }\n    } else if (ret == G_ERROR_PARAM) {\n      j_query = json_pack(\"{sss{sisi}s{sO}}\",\n                          \"table\",\n                          G_TABLE_WEBAUTHN_ASSERTION,\n                          \"set\",\n                            \"gswa_counter\",\n                            counter_value,\n                            \"gswa_status\",\n                            2,\n                          \"where\",\n                            \"gswa_id\",\n                            json_object_get(j_assertion, \"gswa_id\"));\n      res = h_update(config->conn, j_query, NULL);\n      json_decref(j_query);\n      if (res != H_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error executing j_query (3)\");\n        config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n        ret = G_ERROR_DB;\n      }\n    } else {\n      j_query = json_pack(\"{sss{sisi}s{sO}}\",\n                          \"table\",\n                          G_TABLE_WEBAUTHN_ASSERTION,\n                          \"set\",\n                            \"gswa_counter\",\n                            counter_value,\n                            \"gswa_status\",\n                            3,\n                          \"where\",\n                            \"gswa_id\",\n                            json_object_get(j_assertion, \"gswa_id\"));\n      res = h_update(config->conn, j_query, NULL);\n      json_decref(j_query);\n      if (res != H_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_assertion - Error executing j_query (4)\");\n        config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n        ret = G_ERROR_DB;\n      }\n    }\n    o_free(client_data);\n    o_free(challenge_b64);\n    o_free(challenge_hash);\n    o_free(auth_data);\n    json_decref(j_client_data);\n    json_decref(j_credential);\n    gnutls_pubkey_deinit(pubkey);\n  } else {\n    ret = G_ERROR_PARAM;\n  }\n  return ret;\n}\n\n/**\n * Generates a fake credential based on the seed\n * the fake credential has the following form:\n * {\n *   credential_id: string, base64 encoding of 64 a bytes string\n *   name: string\n *   created_at: number, epoch time\n *   status: string, always \"registered\"\n * }\n */\nstatic json_t * generate_credential_fake_from_seed(const char * seed) {\n  unsigned char credential_id[64] = {0}, credential_id_b64[129], created_at[32], name_hash[32];\n  char * seed_credential_id, * seed_name, * seed_created_at, name[32];\n  time_t created_at_t;\n  size_t credential_id_len = 64, credential_id_b64_len, name_hash_len = 32, created_at_len = 32;\n  json_t * j_return;\n  \n  if ((seed_credential_id = msprintf(\"%s-credential_id\", seed)) != NULL) {\n    if (generate_digest_raw(digest_SHA512, (unsigned char *)seed_credential_id, o_strlen(seed_credential_id), credential_id, &credential_id_len)) {\n      if (o_base64_encode(credential_id, credential_id_len, credential_id_b64, &credential_id_b64_len)) {\n        if ((seed_name = msprintf(\"%s-name\", seed)) != NULL) {\n          if (generate_digest_raw(digest_SHA256, (unsigned char *)seed_name, o_strlen(seed_name), name_hash, &name_hash_len)) {\n            if (name_hash[0]%2) {\n              o_strcpy(name, \"fido-u2f\");\n            } else {\n              o_strcpy(name, \"android-safetynet\");\n            }\n            if ((seed_created_at = msprintf(\"%s-created_at\", seed)) != NULL) {\n              if (generate_digest_raw(digest_SHA256, (unsigned char *)seed_created_at, o_strlen(seed_created_at), created_at, &created_at_len)) {\n                time(&created_at_t);\n                created_at_t -= created_at[0] - (created_at[1] << 8);\n                j_return = json_pack(\"{sis{sssssiss}}\", \n                                     \"result\", \n                                     G_OK, \n                                     \"credential\", \n                                      \"credential_id\", \n                                      credential_id_b64,\n                                      \"name\", \n                                      name,\n                                      \"created_at\",\n                                      created_at_t,\n                                      \"status\",\n                                      \"registered\");\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error generate_digest_raw for seed_created_at\");\n                j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n              }\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error allocating resources for seed_created_at\");\n              j_return = json_pack(\"{si}\", \"result\", G_ERROR_MEMORY);\n            }\n            o_free(seed_created_at);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error generate_digest_raw for seed_name\");\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error allocating resources for seed_name\");\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_MEMORY);\n        }\n        o_free(seed_name);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error o_base64_encode for seed_credential_id\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error generate_digest_raw for seed_credential_id\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error allocating resources for seed_credential_id\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_MEMORY);\n  }\n  o_free(seed_credential_id);\n  return j_return;\n}\n\n/**\n * Generates 1 to 3 random credentials using the seed and the username\n */\nstatic json_t * generate_credential_fake_list(json_t * j_params, const char * username) {\n  json_t * j_credential, * j_credential_sub, * j_return;\n  char * seed;\n  unsigned char seed_hash[32] = {0};\n  size_t seed_hash_len = 32;\n  unsigned int i;\n  \n  if ((seed = msprintf(\"%s%s0\", username, json_string_value(json_object_get(j_params, \"seed\")))) != NULL) {\n    j_credential = generate_credential_fake_from_seed(seed);\n    if (check_result_value(j_credential, G_OK)) {\n      j_return = json_pack(\"{sis[O]}\", \"result\", G_OK, \"credential\", json_object_get(j_credential, \"credential\"));\n      if (j_return != NULL) {\n        if (generate_digest_raw(digest_SHA256, (unsigned char *)seed, o_strlen(seed), seed_hash, &seed_hash_len)) {\n          for (i=0; i<seed_hash[0]%3; i++) {\n            seed[o_strlen(seed)-1]++;\n            j_credential_sub = generate_credential_fake_from_seed(seed);\n            if (check_result_value(j_credential, G_OK)) {\n              json_array_append(json_object_get(j_return, \"credential\"), json_object_get(j_credential_sub, \"credential\"));\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_list - Error generate_credential_fake_from_seed at index %u\", i);\n            }\n            json_decref(j_credential_sub);\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_list - Error generate_digest_raw\");\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_list - Error allocating resources for j_return\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_MEMORY);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_list - Error generate_credential_fake_from_seed\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_list - Error allocating resources for seed\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_MEMORY);\n  }\n  o_free(seed);\n  return j_return;\n}\n\n/**\n * Generates a fake user_id based on the username provided and the seed\n */\nstatic int generate_fake_user_id(json_t * j_params, const char * username, unsigned char * user_id) {\n  char * seed;\n  unsigned char seed_hash[32];\n  size_t seed_hash_len = 32, seed_hash_b64_len;\n  int ret;\n  \n  if ((seed = msprintf(\"%s%s-user_id\", username, json_string_value(json_object_get(j_params, \"seed\")))) != NULL) {\n    if (generate_digest_raw(digest_SHA256, (unsigned char *)seed, o_strlen(seed), seed_hash, &seed_hash_len)) {\n      if (o_base64_encode(seed_hash, seed_hash_len, user_id, &seed_hash_b64_len)) {\n        ret = G_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error o_base64_encode\");\n        ret = G_ERROR;\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error generate_digest_raw\");\n      ret = G_ERROR;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"generate_credential_fake_from_seed - Error allocating resources for seed\");\n    ret = G_ERROR_MEMORY;\n  }\n  o_free(seed);\n  return ret;\n}\n\n/**\n * \n * user_auth_scheme_module_load\n * \n * Executed once when Glewlwyd service is started\n * Used to identify the module and to show its parameters on init\n * You can also use it to load resources that are required once for all\n * instance modules for example\n * \n * @return value: a json_t * value with the following pattern:\n *                {\n *                  result: number (G_OK on success, another value on error)\n *                  name: string, mandatory, name of the module, must be unique among other scheme modules\n *                  display_name: string, optional, long name of the module\n *                  description: string, optional, description for the module\n *                  parameters: object, optional, parameters description for the module\n *                }\n * \n *                Example:\n *                {\n *                  result: G_OK,\n *                  name: \"mock\",\n *                  display_name: \"Mock scheme module\",\n *                  description: \"Mock scheme module for glewlwyd tests\",\n *                  parameters: {\n *                    mock-value: {\n *                      type: \"string\",\n *                      mandatory: true\n *                    }\n *                  }\n *                }\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * \n */\njson_t * user_auth_scheme_module_load(struct config_module * config) {\n  UNUSED(config);\n  return json_pack(\"{si ss ss ss }\",\n                   \"result\", G_OK,\n                   \"name\", \"webauthn\",\n                   \"display_name\", \"WebAuthn\",\n                   \"description\", \"WebAuthn scheme module\");\n}\n\n/**\n * \n * user_auth_scheme_module_unload\n * \n * Executed once when Glewlwyd service is stopped\n * You can also use it to release resources that are required once for all\n * instance modules for example\n * \n * @return value: G_OK on success, another value on error\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * \n */\nint user_auth_scheme_module_unload(struct config_module * config) {\n  UNUSED(config);\n  return G_OK;\n}\n\n/**\n * \n * user_auth_scheme_module_init\n * \n * Initialize an instance of this module declared in Glewlwyd service.\n * If required, you must dynamically allocate a pointer to the configuration\n * for this instance and pass it to *cls\n * \n * @return value: a json_t * value with the following pattern:\n *                {\n *                  result: number (G_OK on success, G_ERROR_PARAM on input parameters error, another value on error)\n *                  error: array of strings containg the list of input errors, mandatory on result G_ERROR_PARAM, ignored otherwise\n *                }\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter j_parameters: used to initialize an instance in JSON format\n *                          The module must validate itself its parameters\n * @parameter mod_name: module name in glewlwyd service\n * @parameter cls: will contain an allocated void * pointer that will be sent back\n *                 as void * in all module functions\n * \n */\njson_t * user_auth_scheme_module_init(struct config_module * config, json_t * j_parameters, const char * mod_name, void ** cls) {\n  UNUSED(config);\n  json_t * j_result = is_scheme_parameters_valid(j_parameters), * j_element = NULL, * j_return;\n  size_t index = 0;\n  char * message;\n  \n  if (check_result_value(j_result, G_OK)) {\n    *cls = json_pack(\"{sO sO sO sO sI sI sO ss so sO sO sO sO sO ss s[]}\",\n                     \"challenge-length\", json_object_get(j_parameters, \"challenge-length\"),\n                     \"rp-origin\", json_object_get(j_parameters, \"rp-origin\"),\n                     \"credential-expiration\", json_object_get(j_parameters, \"credential-expiration\"),\n                     \"credential-assertion\", json_object_get(j_parameters, \"credential-assertion\"),\n                     \"ctsProfileMatch\", json_object_get(j_parameters, \"ctsProfileMatch\")!=NULL?json_integer_value(json_object_get(j_parameters, \"ctsProfileMatch\")):-1,\n                     \"basicIntegrity\", json_object_get(j_parameters, \"basicIntegrity\")!=NULL?json_integer_value(json_object_get(j_parameters, \"basicIntegrity\")):-1,\n                     \"session-mandatory\", json_object_get(j_parameters, \"session-mandatory\")!=NULL?json_object_get(j_parameters, \"session-mandatory\"):json_true(),\n                     \"seed\", !json_string_length(json_object_get(j_parameters, \"seed\"))?\"\":json_string_value(json_object_get(j_parameters, \"seed\")),\n                     \"fmt\", json_object_get(j_parameters, \"fmt\")!=NULL?json_deep_copy(json_object_get(j_parameters, \"fmt\")):json_pack(\"{sosososososo}\", \"packed\", json_true(), \"tpm\", json_true(), \"android-key\", json_true(), \"android-safetynet\", json_true(), \"fido-u2f\", json_true(), \"none\", json_true()),\n                     \"force-fmt-none\", json_object_get(j_parameters, \"force-fmt-none\")!=NULL?json_object_get(j_parameters, \"force-fmt-none\"):json_false(),\n                     \"google-root-ca-r2\", json_string_length(json_object_get(j_parameters, \"google-root-ca-r2\"))?json_object_get(j_parameters, \"google-root-ca-r2\"):json_null(),\n                     \"google-root-ca-r2-content\", json_object_get(j_parameters, \"google-root-ca-r2-content\")!=NULL?json_object_get(j_parameters, \"google-root-ca-r2-content\"):json_null(),\n                     \"root-ca-list\", json_array_size(json_object_get(j_parameters, \"root-ca-list\"))?json_object_get(j_parameters, \"root-ca-list\"):json_null(),\n                     \"root-ca-array\", json_object_get(j_parameters, \"root-ca-array\")!=NULL?json_object_get(j_parameters, \"root-ca-array\"):json_null(),\n                     \"mod_name\", mod_name,\n                     \"pubKey-cred-params\");\n    json_array_foreach(json_object_get(j_parameters, \"pubKey-cred-params\"), index, j_element) {\n      json_array_append_new(json_object_get((json_t *)*cls, \"pubKey-cred-params\"), json_pack(\"{sssO}\", \"type\", \"public-key\", \"alg\", j_element));\n    }\n    j_return = json_pack(\"{si}\", \"result\", G_OK);\n  } else if (check_result_value(j_result, G_ERROR_PARAM)) {\n    message = json_dumps(json_object_get(j_result, \"error\"), JSON_COMPACT);\n    y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_init webauthn - Error input parameters: %s\", message);\n    o_free(message);\n    j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", json_object_get(j_result, \"error\"));\n  } else {\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  json_decref(j_result);\n  return j_return;\n}\n\n/**\n * \n * user_auth_scheme_module_close\n * \n * Close an instance of this module declared in Glewlwyd service.\n * You must free the memory previously allocated in\n * the user_auth_scheme_module_init function as void * cls\n * \n * @return value: G_OK on success, another value on error\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\nint user_auth_scheme_module_close(struct config_module * config, void * cls) {\n  UNUSED(config);\n  json_decref((json_t *)cls);\n  return G_OK;\n}\n\n/**\n * \n * user_auth_scheme_module_can_use\n * \n * Validate if the user is allowed to use this scheme prior to the\n * authentication or registration\n * \n * @return value: GLEWLWYD_IS_REGISTERED - User can use scheme and has registered\n *                GLEWLWYD_IS_AVAILABLE - User can use scheme but hasn't registered\n *                GLEWLWYD_IS_NOT_AVAILABLE - User can't use scheme\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter username: username to identify the user\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\nint user_auth_scheme_module_can_use(struct config_module * config, const char * username, void * cls) {\n  json_t * j_user_id, * j_credential;\n  int ret;\n  \n  j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 0);\n  if (check_result_value(j_user_id, G_OK)) {\n    j_credential = get_credential_list(config, (json_t *)cls, username, 1);\n    if (check_result_value(j_credential, G_OK)) {\n      ret = GLEWLWYD_IS_REGISTERED;\n    } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n      ret = GLEWLWYD_IS_AVAILABLE;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_can_use webauthn - Error get_credential_list\");\n      ret = GLEWLWYD_IS_NOT_AVAILABLE;\n    }\n    json_decref(j_credential);\n  } else if (check_result_value(j_user_id, G_ERROR_NOT_FOUND)) {\n    ret = GLEWLWYD_IS_AVAILABLE;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_can_use webauthn - Error get_user_id_from_username\");\n    ret = GLEWLWYD_IS_NOT_AVAILABLE;\n  }\n  json_decref(j_user_id);\n  return ret;\n}\n\n/**\n * \n * user_auth_scheme_module_register\n * \n * Register the scheme for a user\n * Ex: add a certificate, add new TOTP values, etc.\n * \n * @return value: a json_t * value with the following pattern:\n *                {\n *                  result: number (G_OK on success, another value on error)\n *                  response: JSON object, optional\n *                }\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter http_request: the original struct _u_request from the HTTP API\n * @parameter username: username to identify the user\n * @parameter j_scheme_data: additional data used to register the scheme for the user\n *                           in JSON format\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\njson_t * user_auth_scheme_module_register(struct config_module * config, const struct _u_request * http_request, const char * username, json_t * j_scheme_data, void * cls) {\n  UNUSED(config);\n  UNUSED(http_request);\n  json_t * j_return, * j_result, * j_credential, * j_user_id, * j_assertion;\n  int res;\n\n  if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"new-credential\")) {\n    j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 1);\n    if (check_result_value(j_user_id, G_OK)) {\n      j_credential = generate_new_credential(config, (json_t *)cls, username);\n      if (check_result_value(j_credential, G_OK)) {\n        j_return = json_pack(\"{sis{sOsOsOsss{sOss}sO}}\",\n                              \"result\", G_OK, \n                              \"response\", \n                                \"session\", json_object_get(json_object_get(j_credential, \"credential\"), \"session\"), \n                                \"challenge\", json_object_get(json_object_get(j_credential, \"credential\"), \"challenge\"), \n                                \"pubKey-cred-params\", json_object_get((json_t *)cls, \"pubKey-cred-params\"),\n                                \"attestation-required\", json_object_get((json_t *)cls, \"force-fmt-none\")==json_true()?\"none\":\"direct\",\n                                \"user\",\n                                  \"id\", json_object_get(j_user_id, \"user_id\"),\n                                  \"name\", username,\n                                \"rpId\", json_object_get((json_t *)cls, \"rp-origin\")\n                             );\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error generate_new_credential\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      json_decref(j_credential);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_user_id_from_username\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_user_id);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"register-credential\")) {\n    j_credential = get_credential_from_session(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"session\")));\n    if (check_result_value(j_credential, G_OK)) {\n      j_result = register_new_attestation(config, (json_t *)cls, j_scheme_data, json_object_get(j_credential, \"credential\"));\n      if (check_result_value(j_result, G_OK)) {\n        j_return = json_pack(\"{si}\", \"result\", G_OK);\n      } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n        j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_UNAUTHORIZED, \"response\", json_object_get(j_result, \"error\"));\n      } else if (check_result_value(j_result, G_ERROR_PARAM)) {\n        j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"response\", json_object_get(j_result, \"error\"));\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error register_new_attestation\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      json_decref(j_result);\n    } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    } else if (check_result_value(j_credential, G_ERROR_PARAM)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential_from_session\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"remove-credential\") && json_string_length(json_object_get(j_scheme_data, \"credential_id\"))) {\n    j_credential = get_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")));\n    if (check_result_value(j_credential, G_OK)) {\n      if ((res = update_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")), 4)) == G_OK) {\n        j_return = json_pack(\"{si}\", \"result\", G_OK);\n      } else if (res == G_ERROR_PARAM) {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error update_credential\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"disable-credential\") && json_string_length(json_object_get(j_scheme_data, \"credential_id\"))) {\n    j_credential = get_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")));\n    if (check_result_value(j_credential, G_OK)) {\n      if ((res = update_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")), 3)) == G_OK) {\n        j_return = json_pack(\"{si}\", \"result\", G_OK);\n      } else if (res == G_ERROR_PARAM) {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error update_credential\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"enable-credential\") && json_string_length(json_object_get(j_scheme_data, \"credential_id\"))) {\n    j_credential = get_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")));\n    if (check_result_value(j_credential, G_OK)) {\n      if ((res = update_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")), 1)) == G_OK) {\n        j_return = json_pack(\"{si}\", \"result\", G_OK);\n      } else if (res == G_ERROR_PARAM) {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error update_credential\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"edit-credential\") && json_string_length(json_object_get(j_scheme_data, \"credential_id\")) && json_string_length(json_object_get(j_scheme_data, \"name\"))) {\n    j_credential = get_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")));\n    if (check_result_value(j_credential, G_OK)) {\n      if ((res = update_credential_name(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"credential_id\")), json_string_value(json_object_get(j_scheme_data, \"name\")))) == G_OK) {\n        j_return = json_pack(\"{si}\", \"result\", G_OK);\n      } else if (res == G_ERROR_PARAM) {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error update_credential_name\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n    } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"trigger-assertion\")) {\n    j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 0);\n    if (check_result_value(j_user_id, G_OK)) {\n      j_credential = get_credential_list(config, (json_t *)cls, username, 1);\n      if (check_result_value(j_credential, G_OK)) {\n        j_assertion = generate_new_assertion(config, (json_t *)cls, username, 1);\n        if (check_result_value(j_assertion, G_OK)) {\n          j_return = json_pack(\"{sis{sOsOsOs{sOss}sO}}\", \n                              \"result\", G_OK, \n                              \"response\", \n                                \"allowCredentials\", json_object_get(j_credential, \"credential\"), \n                                \"session\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"session\"), \n                                \"challenge\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"challenge\"),\n                                \"user\",\n                                  \"id\", json_object_get(j_user_id, \"user_id\"),\n                                  \"name\", username,\n                                \"rpId\", json_object_get((json_t *)cls, \"rp-origin\")\n                              );\n        } else if (check_result_value(j_assertion, G_ERROR_UNAUTHORIZED)) {\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error register_new_assertion\");\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n        }\n        json_decref(j_assertion);\n      } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error get_credential_list\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      json_decref(j_credential);\n    } else if (check_result_value(j_user_id, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_user_id_from_username\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_user_id);\n  } else if (0 == o_strcmp(json_string_value(json_object_get(j_scheme_data, \"register\")), \"validate-assertion\")) {\n    j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 0);\n    if (check_result_value(j_user_id, G_OK)) {\n      j_assertion = get_assertion_from_session(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"session\")), 1);\n      if (check_result_value(j_assertion, G_OK)) {\n        if ((res = check_assertion(config, (json_t *)cls, username, j_scheme_data, json_object_get(j_assertion, \"assertion\"))) == G_OK) {\n          j_return = json_pack(\"{si}\", \"result\", G_OK);\n        } else if (res == G_ERROR_UNAUTHORIZED || res == G_ERROR_PARAM) {\n          j_return = json_pack(\"{si}\", \"result\", res);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error check_assertion\");\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n        }\n      } else if (check_result_value(j_assertion, G_ERROR_NOT_FOUND)) {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      json_decref(j_assertion);\n    } else if (check_result_value(j_user_id, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_validate webauthn - Error get_user_id_from_username\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_user_id);\n  } else {\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n  }\n  \n  return j_return;\n}\n\n/**\n * \n * user_auth_scheme_module_register_get\n * \n * Get the registration value(s) of the scheme for a user\n * \n * @return value: a json_t * value with the following pattern:\n *                {\n *                  result: number (G_OK on success, another value on error)\n *                  response: JSON object, optional\n *                }\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter http_request: the original struct _u_request from the API, must be casted to be available\n * @parameter username: username to identify the user\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\njson_t * user_auth_scheme_module_register_get(struct config_module * config, const struct _u_request * http_request, const char * username, void * cls) {\n  UNUSED(http_request);\n  json_t * j_return, * j_user_id, * j_credential_list;\n\n  j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 1);\n  if (check_result_value(j_user_id, G_OK)) {\n    j_credential_list = get_credential_list(config, (json_t *)cls, username, 0);\n    if (check_result_value(j_credential_list, G_OK)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_OK, \"response\", json_object_get(j_credential_list, \"credential\"));\n    } else if (check_result_value(j_credential_list, G_ERROR_NOT_FOUND)) {\n      j_return = json_pack(\"{sis[]}\", \"result\", G_OK, \"response\");\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register_get webauthn - Error get_credential_list\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential_list);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register_get webauthn - Error get_user_id_from_username\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  json_decref(j_user_id);\n  \n  return j_return;\n}\n\n/**\n * \n * user_auth_scheme_module_deregister\n * \n * Deregister the scheme for a user\n * Ex: remove certificates, TOTP values, etc.\n * \n * @return value: G_OK on success, even if no data has been removed\n *                G_ERROR on another error\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter username: username to identify the user\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\nint user_auth_scheme_module_deregister(struct config_module * config, const char * username, void * cls) {\n  json_t * j_user_id, * j_credential_list, * j_credential, * j_element = NULL;\n  size_t index = 0;\n  int ret;\n\n  j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 1);\n  if (check_result_value(j_user_id, G_OK)) {\n    j_credential_list = get_credential_list(config, (json_t *)cls, username, 0);\n    if (check_result_value(j_credential_list, G_OK)) {\n      json_array_foreach(json_object_get(j_credential_list, \"credential\"), index, j_element) {\n        j_credential = get_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_element, \"credential_id\")));\n        if (check_result_value(j_credential, G_OK)) {\n          if (update_credential(config, (json_t *)cls, username, json_string_value(json_object_get(j_element, \"credential_id\")), 4) != G_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_deregister webauthn - Error update_credential\");\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_deregister webauthn - Error get_credential\");\n        }\n        json_decref(j_credential);\n      }\n      ret = G_OK;\n    } else if (check_result_value(j_credential_list, G_ERROR_NOT_FOUND)) {\n      ret = G_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_deregister webauthn - Error get_credential_list\");\n      ret = G_ERROR;\n    }\n    json_decref(j_credential_list);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_deregister webauthn - Error get_user_id_from_username\");\n    ret = G_ERROR;\n  }\n  json_decref(j_user_id);\n  \n  return ret;\n}\n\n/**\n * \n * user_auth_scheme_module_trigger\n * \n * Trigger the scheme for a user\n * Ex: send the code to a device, generate a challenge, etc.\n * \n * @return value: a json_t * value with the following pattern:\n *                {\n *                  result: number (G_OK on success, another value on error)\n *                  response: JSON object, optional\n *                }\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter http_request: the original struct _u_request from the API, must be casted to be available\n * @parameter username: username to identify the user\n * @parameter scheme_trigger: data sent to trigger the scheme for the user\n *                           in JSON format\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\njson_t * user_auth_scheme_module_trigger(struct config_module * config, const struct _u_request * http_request, const char * username, json_t * j_scheme_trigger, void * cls) {\n  UNUSED(j_scheme_trigger);\n  json_t * j_return = NULL, * j_session = config->glewlwyd_module_callback_check_user_session(config, http_request, username), * j_credential, * j_assertion, * j_user_id, * j_credential_fake;\n  unsigned char user_id_fake[64];\n  \n  if (check_result_value(j_session, G_OK) || json_object_get((json_t *)cls, \"session-mandatory\") == json_false()) {\n    j_credential_fake = generate_credential_fake_list((json_t *)cls, username);\n    if (check_result_value(j_credential_fake, G_OK)) {\n      j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 0);\n      if (check_result_value(j_user_id, G_OK)) {\n        j_credential = get_credential_list(config, (json_t *)cls, username, 1);\n        if (check_result_value(j_credential, G_OK)) {\n          j_assertion = generate_new_assertion(config, (json_t *)cls, username, 0);\n          if (check_result_value(j_assertion, G_OK)) {\n            j_return = json_pack(\"{sis{sOsOsOs{sOss}sOsssi}}\", \n                                \"result\", G_OK, \n                                \"response\", \n                                  \"allowCredentials\", json_object_get(j_credential, \"credential\"), \n                                  \"session\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"session\"), \n                                  \"challenge\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"challenge\"),\n                                  \"user\",\n                                    \"id\", json_object_get(j_user_id, \"user_id\"),\n                                    \"name\", username,\n                                  \"rpId\", json_object_get((json_t *)cls, \"rp-origin\"),\n                                  \"attestation-required\", json_object_get((json_t *)cls, \"force-fmt-none\")==json_true()?\"none\":\"direct\",\n                                  \"timeout\", 60000\n                                );\n            if (json_object_get((json_t *)cls, \"session-mandatory\") == json_false()) {\n              json_array_extend(json_object_get(json_object_get(j_return, \"response\"), \"allowCredentials\"), json_object_get(j_credential_fake, \"credential\"));\n            }\n          } else if (check_result_value(j_assertion, G_ERROR_UNAUTHORIZED)) {\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error register_new_assertion\");\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n          }\n          json_decref(j_assertion);\n        } else if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) {\n          if (json_object_get((json_t *)cls, \"session-mandatory\") == json_false()) {\n            j_assertion = generate_new_assertion(config, (json_t *)cls, username, 2);\n            if (check_result_value(j_assertion, G_OK)) {\n              j_return = json_pack(\"{sis{sOsOsOs{sOss}sO}}\", \n                                  \"result\", G_OK, \n                                  \"response\", \n                                    \"allowCredentials\", json_object_get(j_credential_fake, \"credential\"), \n                                    \"session\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"session\"), \n                                    \"challenge\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"challenge\"),\n                                    \"user\",\n                                      \"id\", json_object_get(j_user_id, \"user_id\"),\n                                      \"name\", username,\n                                    \"rpId\", json_object_get((json_t *)cls, \"rp-origin\")\n                                  );\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error register_new_assertion\");\n              j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n            }\n            json_decref(j_assertion);\n          } else {\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error get_credential_list\");\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n        }\n        json_decref(j_credential);\n      } else if (check_result_value(j_user_id, G_ERROR_NOT_FOUND)) {\n        if (json_object_get((json_t *)cls, \"session-mandatory\") == json_false()) {\n          if (generate_fake_user_id((json_t *)cls, username, user_id_fake) == G_OK) {\n            j_assertion = generate_new_assertion(config, (json_t *)cls, username, 2);\n            if (check_result_value(j_assertion, G_OK)) {\n              j_return = json_pack(\"{sis{sOsOsOs{ssss}sO}}\", \n                                  \"result\", G_OK, \n                                  \"response\", \n                                    \"allowCredentials\", json_object_get(j_credential_fake, \"credential\"), \n                                    \"session\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"session\"), \n                                    \"challenge\", json_object_get(json_object_get(j_assertion, \"assertion\"), \"challenge\"),\n                                    \"user\",\n                                      \"id\", user_id_fake,\n                                      \"name\", username,\n                                    \"rpId\", json_object_get((json_t *)cls, \"rp-origin\")\n                                  );\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error register_new_assertion\");\n              j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n            }\n            json_decref(j_assertion);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error generate_fake_user_id\");\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n          }\n        } else {\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n        }\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_user_id_from_username\");\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n      }\n      json_decref(j_user_id);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error generate_credential_fake\");\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n    }\n    json_decref(j_credential_fake);\n  } else if (check_result_value(j_session, G_ERROR_UNAUTHORIZED)) {\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_trigger webauthn - Error glewlwyd_module_callback_check_user_session\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  json_decref(j_session);\n  return j_return;\n}\n\n/**\n * \n * user_auth_scheme_module_validate\n * \n * Validate the scheme for a user\n * Ex: check the code sent to a device, verify the challenge, etc.\n * \n * @return value: G_OK on success\n *                G_ERROR_UNAUTHORIZED if validation fails\n *                G_ERROR_PARAM if error in parameters\n *                G_ERROR on another error\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter http_request: the original struct _u_request from the API, must be casted to be available\n * @parameter username: username to identify the user\n * @parameter j_scheme_data: data sent to validate the scheme for the user\n *                           in JSON format\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\nint user_auth_scheme_module_validate(struct config_module * config, const struct _u_request * http_request, const char * username, json_t * j_scheme_data, void * cls) {\n  UNUSED(http_request);\n  int ret, res;\n  json_t * j_user_id, * j_assertion;\n\n  j_user_id = get_user_id_from_username(config, (json_t *)cls, username, 0);\n  if (check_result_value(j_user_id, G_OK)) {\n    j_assertion = get_assertion_from_session(config, (json_t *)cls, username, json_string_value(json_object_get(j_scheme_data, \"session\")), 0);\n    if (check_result_value(j_assertion, G_OK)) {\n      if ((res = check_assertion(config, (json_t *)cls, username, j_scheme_data, json_object_get(j_assertion, \"assertion\"))) == G_OK) {\n        ret = G_OK;\n      } else if (res == G_ERROR_UNAUTHORIZED) {\n        ret = G_ERROR_UNAUTHORIZED;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_validate webauthn - Error check_assertion\");\n        ret = G_ERROR;\n      }\n    } else if (check_result_value(j_assertion, G_ERROR_NOT_FOUND)) {\n      ret = G_ERROR_UNAUTHORIZED;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_register webauthn - Error get_credential\");\n      ret = G_ERROR;\n    }\n    json_decref(j_assertion);\n  } else if (check_result_value(j_user_id, G_ERROR_NOT_FOUND)) {\n    ret = G_ERROR_UNAUTHORIZED;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"user_auth_scheme_module_validate webauthn - Error get_user_id_from_username\");\n    ret = G_ERROR;\n  }\n  json_decref(j_user_id);\n  \n  return ret;\n}\n\n/**\n * \n * user_auth_scheme_module_identify\n * \n * Identify the user using the scheme without the username to be previously given\n * This functionality isn't available for all schemes, because the scheme authentification\n * must be triggered without username and the authentication result must contain the username\n * \n * @return value: a json_t * value with the following pattern:\n *                {\n *                  result: number (G_OK on success, another value on error)\n *                  username: string value of the user identified - if the function is called within /auth\n *                  response: JSON object, optional - if the function is called within /auth/scheme/trigger\n *                }\n * \n * @parameter config: a struct config_module with acess to some Glewlwyd\n *                    service and data\n * @parameter http_request: the original struct _u_request from the API, must be casted to be available\n * @parameter j_scheme_data: data sent to validate the scheme for the user\n *                           in JSON format\n * @parameter cls: pointer to the void * cls value allocated in user_auth_scheme_module_init\n * \n */\njson_t * user_auth_scheme_module_identify(struct config_module * config, const struct _u_request * http_request, json_t * j_scheme_data, void * cls) {\n  UNUSED(config);\n  UNUSED(http_request);\n  UNUSED(j_scheme_data);\n  UNUSED(cls);\n  return json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n}\n"], "filenames": ["src/scheme/webauthn.c"], "buggy_code_start_loc": [1546], "buggy_code_end_loc": [1668], "fixing_code_start_loc": [1546], "fixing_code_end_loc": [1676], "type": "CWE-120", "message": "scheme/webauthn.c in Glewlwyd SSO server through 2.5.3 has a buffer overflow during FIDO2 signature validation in webauthn registration.", "other": {"cve": {"id": "CVE-2021-40818", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-08T22:15:11.383", "lastModified": "2021-09-15T14:59:36.733", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "scheme/webauthn.c in Glewlwyd SSO server through 2.5.3 has a buffer overflow during FIDO2 signature validation in webauthn registration."}, {"lang": "es", "value": "El archivo scheme/webauthn.c en el servidor SSO de Glewlwyd versiones hasta 2.5.3, presenta un desbordamiento de b\u00fafer durante la comprobaci\u00f3n de la firma FIDO2 en el registro de webauthn"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:glewlwyd_sso_server_project:glewlwyd_sso_server:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.5.3", "matchCriteriaId": "CDD0EFAB-3548-4CC4-9D2E-DA747C67BB39"}]}]}], "references": [{"url": "https://bugs.debian.org/993867", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/babelouest/glewlwyd/commit/0efd112bb62f566877750ad62ee828bff579b4e2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/babelouest/glewlwyd/commit/0efd112bb62f566877750ad62ee828bff579b4e2"}}