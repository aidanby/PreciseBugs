{"buggy_code": ["/*\n * Client routines for the CUPS scheduler.\n *\n * Copyright 2007-2015 by Apple Inc.\n * Copyright 1997-2007 by Easy Software Products, all rights reserved.\n *\n * This file contains Kerberos support code, copyright 2006 by\n * Jelmer Vernooij.\n *\n * These coded instructions, statements, and computer programs are the\n * property of Apple Inc. and are protected by Federal copyright\n * law.  Distribution and use rights are outlined in the file \"LICENSE.txt\"\n * which should have been included with this file.  If this file is\n * file is missing or damaged, see the license at \"http://www.cups.org/\".\n */\n\n/*\n * Include necessary headers...\n */\n\n#define _CUPS_NO_DEPRECATED\n#define _HTTP_NO_PRIVATE\n#include \"cupsd.h\"\n\n#ifdef __APPLE__\n#  include <libproc.h>\n#endif /* __APPLE__ */\n#ifdef HAVE_TCPD_H\n#  include <tcpd.h>\n#endif /* HAVE_TCPD_H */\n\n\n/*\n * Local functions...\n */\n\nstatic int\t\tcheck_if_modified(cupsd_client_t *con,\n\t\t\t                  struct stat *filestats);\nstatic int\t\tcompare_clients(cupsd_client_t *a, cupsd_client_t *b,\n\t\t\t                void *data);\n#ifdef HAVE_SSL\nstatic int\t\tcupsd_start_tls(cupsd_client_t *con, http_encryption_t e);\n#endif /* HAVE_SSL */\nstatic char\t\t*get_file(cupsd_client_t *con, struct stat *filestats,\n\t\t\t          char *filename, size_t len);\nstatic http_status_t\tinstall_cupsd_conf(cupsd_client_t *con);\nstatic int\t\tis_cgi(cupsd_client_t *con, const char *filename,\n\t\t               struct stat *filestats, mime_type_t *type);\nstatic int\t\tis_path_absolute(const char *path);\nstatic int\t\tpipe_command(cupsd_client_t *con, int infile, int *outfile,\n\t\t\t             char *command, char *options, int root);\nstatic int\t\tvalid_host(cupsd_client_t *con);\nstatic int\t\twrite_file(cupsd_client_t *con, http_status_t code,\n\t\t        \t   char *filename, char *type,\n\t\t\t\t   struct stat *filestats);\nstatic void\t\twrite_pipe(cupsd_client_t *con);\n\n\n/*\n * 'cupsdAcceptClient()' - Accept a new client.\n */\n\nvoid\ncupsdAcceptClient(cupsd_listener_t *lis)/* I - Listener socket */\n{\n  const char\t\t*hostname;\t/* Hostname of client */\n  char\t\t\tname[256];\t/* Hostname of client */\n  int\t\t\tcount;\t\t/* Count of connections on a host */\n  cupsd_client_t\t*con,\t\t/* New client pointer */\n\t\t\t*tempcon;\t/* Temporary client pointer */\n  socklen_t\t\taddrlen;\t/* Length of address */\n  http_addr_t\t\ttemp;\t\t/* Temporary address variable */\n  static time_t\t\tlast_dos = 0;\t/* Time of last DoS attack */\n#ifdef HAVE_TCPD_H\n  struct request_info\twrap_req;\t/* TCP wrappers request information */\n#endif /* HAVE_TCPD_H */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cupsdAcceptClient(lis=%p(%d)) Clients=%d\", lis, lis->fd, cupsArrayCount(Clients));\n\n /*\n  * Make sure we don't have a full set of clients already...\n  */\n\n  if (cupsArrayCount(Clients) == MaxClients)\n    return;\n\n /*\n  * Get a pointer to the next available client...\n  */\n\n  if (!Clients)\n    Clients = cupsArrayNew(NULL, NULL);\n\n  if (!Clients)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to allocate memory for clients array!\");\n    cupsdPauseListening();\n    return;\n  }\n\n  if (!ActiveClients)\n    ActiveClients = cupsArrayNew((cups_array_func_t)compare_clients, NULL);\n\n  if (!ActiveClients)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to allocate memory for active clients array!\");\n    cupsdPauseListening();\n    return;\n  }\n\n  if ((con = calloc(1, sizeof(cupsd_client_t))) == NULL)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"Unable to allocate memory for client!\");\n    cupsdPauseListening();\n    return;\n  }\n\n /*\n  * Accept the client and get the remote address...\n  */\n\n  con->number = ++ LastClientNumber;\n  con->file   = -1;\n\n  if ((con->http = httpAcceptConnection(lis->fd, 0)) == NULL)\n  {\n    if (errno == ENFILE || errno == EMFILE)\n      cupsdPauseListening();\n\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"Unable to accept client connection - %s.\",\n                    strerror(errno));\n    free(con);\n\n    return;\n  }\n\n /*\n  * Save the connected address and port number...\n  */\n\n  addrlen = sizeof(con->clientaddr);\n\n  if (getsockname(httpGetFd(con->http), (struct sockaddr *)&con->clientaddr, &addrlen) || addrlen == 0)\n    con->clientaddr = lis->address;\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Server address is \\\"%s\\\".\", httpAddrString(&con->clientaddr, name, sizeof(name)));\n\n /*\n  * Check the number of clients on the same address...\n  */\n\n  for (count = 0, tempcon = (cupsd_client_t *)cupsArrayFirst(Clients);\n       tempcon;\n       tempcon = (cupsd_client_t *)cupsArrayNext(Clients))\n    if (httpAddrEqual(httpGetAddress(tempcon->http), httpGetAddress(con->http)))\n    {\n      count ++;\n      if (count >= MaxClientsPerHost)\n\tbreak;\n    }\n\n  if (count >= MaxClientsPerHost)\n  {\n    if ((time(NULL) - last_dos) >= 60)\n    {\n      last_dos = time(NULL);\n      cupsdLogMessage(CUPSD_LOG_WARN,\n                      \"Possible DoS attack - more than %d clients connecting \"\n\t\t      \"from %s.\",\n\t              MaxClientsPerHost,\n\t\t      httpGetHostname(con->http, name, sizeof(name)));\n    }\n\n    httpClose(con->http);\n    free(con);\n    return;\n  }\n\n /*\n  * Get the hostname or format the IP address as needed...\n  */\n\n  if (HostNameLookups)\n    hostname = httpResolveHostname(con->http, NULL, 0);\n  else\n    hostname = httpGetHostname(con->http, NULL, 0);\n\n  if (hostname == NULL && HostNameLookups == 2)\n  {\n   /*\n    * Can't have an unresolved IP address with double-lookups enabled...\n    */\n\n    httpClose(con->http);\n\n    cupsdLogClient(con, CUPSD_LOG_WARN,\n                    \"Name lookup failed - connection from %s closed!\",\n                    httpGetHostname(con->http, NULL, 0));\n\n    free(con);\n    return;\n  }\n\n  if (HostNameLookups == 2)\n  {\n   /*\n    * Do double lookups as needed...\n    */\n\n    http_addrlist_t\t*addrlist,\t/* List of addresses */\n\t\t\t*addr;\t\t/* Current address */\n\n    if ((addrlist = httpAddrGetList(hostname, AF_UNSPEC, NULL)) != NULL)\n    {\n     /*\n      * See if the hostname maps to the same IP address...\n      */\n\n      for (addr = addrlist; addr; addr = addr->next)\n        if (httpAddrEqual(httpGetAddress(con->http), &(addr->addr)))\n          break;\n    }\n    else\n      addr = NULL;\n\n    httpAddrFreeList(addrlist);\n\n    if (!addr)\n    {\n     /*\n      * Can't have a hostname that doesn't resolve to the same IP address\n      * with double-lookups enabled...\n      */\n\n      httpClose(con->http);\n\n      cupsdLogClient(con, CUPSD_LOG_WARN,\n                      \"IP lookup failed - connection from %s closed!\",\n                      httpGetHostname(con->http, NULL, 0));\n      free(con);\n      return;\n    }\n  }\n\n#ifdef HAVE_TCPD_H\n /*\n  * See if the connection is denied by TCP wrappers...\n  */\n\n  request_init(&wrap_req, RQ_DAEMON, \"cupsd\", RQ_FILE, httpGetFd(con->http),\n               NULL);\n  fromhost(&wrap_req);\n\n  if (!hosts_access(&wrap_req))\n  {\n    httpClose(con->http);\n\n    cupsdLogClient(con, CUPSD_LOG_WARN,\n                    \"Connection from %s refused by /etc/hosts.allow and \"\n\t\t    \"/etc/hosts.deny rules.\", httpGetHostname(con->http, NULL, 0));\n    free(con);\n    return;\n  }\n#endif /* HAVE_TCPD_H */\n\n#ifdef AF_LOCAL\n  if (httpAddrFamily(httpGetAddress(con->http)) == AF_LOCAL)\n  {\n#  ifdef __APPLE__\n    socklen_t\tpeersize;\t\t/* Size of peer credentials */\n    pid_t\tpeerpid;\t\t/* Peer process ID */\n    char\tpeername[256];\t\t/* Name of process */\n\n    peersize = sizeof(peerpid);\n    if (!getsockopt(httpGetFd(con->http), SOL_LOCAL, LOCAL_PEERPID, &peerpid,\n                    &peersize))\n    {\n      if (!proc_name((int)peerpid, peername, sizeof(peername)))\n\tcupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t               \"Accepted from %s (Domain ???[%d])\",\n                       httpGetHostname(con->http, NULL, 0), (int)peerpid);\n      else\n\tcupsdLogClient(con, CUPSD_LOG_DEBUG,\n                       \"Accepted from %s (Domain %s[%d])\",\n                       httpGetHostname(con->http, NULL, 0), peername, (int)peerpid);\n    }\n    else\n#  endif /* __APPLE__ */\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Accepted from %s (Domain)\",\n                   httpGetHostname(con->http, NULL, 0));\n  }\n  else\n#endif /* AF_LOCAL */\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Accepted from %s:%d (IPv%d)\",\n                 httpGetHostname(con->http, NULL, 0),\n\t\t httpAddrPort(httpGetAddress(con->http)),\n\t\t httpAddrFamily(httpGetAddress(con->http)) == AF_INET ? 4 : 6);\n\n /*\n  * Get the local address the client connected to...\n  */\n\n  addrlen = sizeof(temp);\n  if (getsockname(httpGetFd(con->http), (struct sockaddr *)&temp, &addrlen))\n  {\n    cupsdLogClient(con, CUPSD_LOG_ERROR, \"Unable to get local address - %s\",\n                   strerror(errno));\n\n    strlcpy(con->servername, \"localhost\", sizeof(con->servername));\n    con->serverport = LocalPort;\n  }\n#ifdef AF_LOCAL\n  else if (httpAddrFamily(&temp) == AF_LOCAL)\n  {\n    strlcpy(con->servername, \"localhost\", sizeof(con->servername));\n    con->serverport = LocalPort;\n  }\n#endif /* AF_LOCAL */\n  else\n  {\n    if (httpAddrLocalhost(&temp))\n      strlcpy(con->servername, \"localhost\", sizeof(con->servername));\n    else if (HostNameLookups)\n      httpAddrLookup(&temp, con->servername, sizeof(con->servername));\n    else\n      httpAddrString(&temp, con->servername, sizeof(con->servername));\n\n    con->serverport = httpAddrPort(&(lis->address));\n  }\n\n /*\n  * Add the connection to the array of active clients...\n  */\n\n  cupsArrayAdd(Clients, con);\n\n /*\n  * Add the socket to the server select.\n  */\n\n  cupsdAddSelect(httpGetFd(con->http), (cupsd_selfunc_t)cupsdReadClient, NULL,\n                 con);\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Waiting for request.\");\n\n /*\n  * Temporarily suspend accept()'s until we lose a client...\n  */\n\n  if (cupsArrayCount(Clients) == MaxClients)\n    cupsdPauseListening();\n\n#ifdef HAVE_SSL\n /*\n  * See if we are connecting on a secure port...\n  */\n\n  if (lis->encryption == HTTP_ENCRYPTION_ALWAYS)\n  {\n   /*\n    * https connection; go secure...\n    */\n\n    if (cupsd_start_tls(con, HTTP_ENCRYPTION_ALWAYS))\n      cupsdCloseClient(con);\n  }\n  else\n    con->auto_ssl = 1;\n#endif /* HAVE_SSL */\n}\n\n\n/*\n * 'cupsdCloseAllClients()' - Close all remote clients immediately.\n */\n\nvoid\ncupsdCloseAllClients(void)\n{\n  cupsd_client_t\t*con;\t\t/* Current client */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cupsdCloseAllClients() Clients=%d\", cupsArrayCount(Clients));\n\n  for (con = (cupsd_client_t *)cupsArrayFirst(Clients);\n       con;\n       con = (cupsd_client_t *)cupsArrayNext(Clients))\n    if (cupsdCloseClient(con))\n      cupsdCloseClient(con);\n}\n\n\n/*\n * 'cupsdCloseClient()' - Close a remote client.\n */\n\nint\t\t\t\t\t/* O - 1 if partial close, 0 if fully closed */\ncupsdCloseClient(cupsd_client_t *con)\t/* I - Client to close */\n{\n  int\t\tpartial;\t\t/* Do partial close for SSL? */\n\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing connection.\");\n\n /*\n  * Flush pending writes before closing...\n  */\n\n  httpFlushWrite(con->http);\n\n  partial = 0;\n\n  if (con->pipe_pid != 0)\n  {\n   /*\n    * Stop any CGI process...\n    */\n\n    cupsdEndProcess(con->pipe_pid, 1);\n    con->pipe_pid = 0;\n  }\n\n  if (con->file >= 0)\n  {\n    cupsdRemoveSelect(con->file);\n\n    close(con->file);\n    con->file = -1;\n  }\n\n /*\n  * Close the socket and clear the file from the input set for select()...\n  */\n\n  if (httpGetFd(con->http) >= 0)\n  {\n    cupsArrayRemove(ActiveClients, con);\n    cupsdSetBusyState();\n\n#ifdef HAVE_SSL\n   /*\n    * Shutdown encryption as needed...\n    */\n\n    if (httpIsEncrypted(con->http))\n      partial = 1;\n#endif /* HAVE_SSL */\n\n    if (partial)\n    {\n     /*\n      * Only do a partial close so that the encrypted client gets everything.\n      */\n\n      httpShutdown(con->http);\n      cupsdAddSelect(httpGetFd(con->http), (cupsd_selfunc_t)cupsdReadClient,\n                     NULL, con);\n\n      cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Waiting for socket close.\");\n    }\n    else\n    {\n     /*\n      * Shut the socket down fully...\n      */\n\n      cupsdRemoveSelect(httpGetFd(con->http));\n      httpClose(con->http);\n      con->http = NULL;\n    }\n  }\n\n  if (!partial)\n  {\n   /*\n    * Free memory...\n    */\n\n    cupsdRemoveSelect(httpGetFd(con->http));\n\n    httpClose(con->http);\n\n    if (con->filename)\n    {\n      unlink(con->filename);\n      cupsdClearString(&con->filename);\n    }\n\n    cupsdClearString(&con->command);\n    cupsdClearString(&con->options);\n    cupsdClearString(&con->query_string);\n\n    if (con->request)\n    {\n      ippDelete(con->request);\n      con->request = NULL;\n    }\n\n    if (con->response)\n    {\n      ippDelete(con->response);\n      con->response = NULL;\n    }\n\n    if (con->language)\n    {\n      cupsLangFree(con->language);\n      con->language = NULL;\n    }\n\n#ifdef HAVE_AUTHORIZATION_H\n    if (con->authref)\n    {\n      AuthorizationFree(con->authref, kAuthorizationFlagDefaults);\n      con->authref = NULL;\n    }\n#endif /* HAVE_AUTHORIZATION_H */\n\n   /*\n    * Re-enable new client connections if we are going back under the\n    * limit...\n    */\n\n    if (cupsArrayCount(Clients) == MaxClients)\n      cupsdResumeListening();\n\n   /*\n    * Compact the list of clients as necessary...\n    */\n\n    cupsArrayRemove(Clients, con);\n\n    free(con);\n  }\n\n  return (partial);\n}\n\n\n/*\n * 'cupsdReadClient()' - Read data from a client.\n */\n\nvoid\ncupsdReadClient(cupsd_client_t *con)\t/* I - Client to read from */\n{\n  char\t\t\tline[32768],\t/* Line from client... */\n\t\t\tlocale[64],\t/* Locale */\n\t\t\t*ptr;\t\t/* Pointer into strings */\n  http_status_t\t\tstatus;\t\t/* Transfer status */\n  ipp_state_t\t\tipp_state;\t/* State of IPP transfer */\n  int\t\t\tbytes;\t\t/* Number of bytes to POST */\n  char\t\t\t*filename;\t/* Name of file for GET/HEAD */\n  char\t\t\tbuf[1024];\t/* Buffer for real filename */\n  struct stat\t\tfilestats;\t/* File information */\n  mime_type_t\t\t*type;\t\t/* MIME type of file */\n  cupsd_printer_t\t*p;\t\t/* Printer */\n  static unsigned\trequest_id = 0;\t/* Request ID for temp files */\n\n\n  status = HTTP_STATUS_CONTINUE;\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"cupsdReadClient: error=%d, used=%d, state=%s, data_encoding=HTTP_ENCODING_%s, data_remaining=\" CUPS_LLFMT \", request=%p(%s), file=%d\", httpError(con->http), (int)httpGetReady(con->http), httpStateString(httpGetState(con->http)), httpIsChunked(con->http) ? \"CHUNKED\" : \"LENGTH\", CUPS_LLCAST httpGetRemaining(con->http), con->request, con->request ? ippStateString(ippGetState(con->request)) : \"\", con->file);\n\n  if (httpGetState(con->http) == HTTP_STATE_GET_SEND ||\n      httpGetState(con->http) == HTTP_STATE_POST_SEND ||\n      httpGetState(con->http) == HTTP_STATE_STATUS)\n  {\n   /*\n    * If we get called in the wrong state, then something went wrong with the\n    * connection and we need to shut it down...\n    */\n\n    if (!httpGetReady(con->http) && recv(httpGetFd(con->http), buf, 1, MSG_PEEK) < 1)\n    {\n     /*\n      * Connection closed...\n      */\n\n      cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing on EOF.\");\n      cupsdCloseClient(con);\n      return;\n    }\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing on unexpected HTTP read state %s.\", httpStateString(httpGetState(con->http)));\n    cupsdCloseClient(con);\n    return;\n  }\n\n#ifdef HAVE_SSL\n  if (con->auto_ssl)\n  {\n   /*\n    * Automatically check for a SSL/TLS handshake...\n    */\n\n    con->auto_ssl = 0;\n\n    if (recv(httpGetFd(con->http), buf, 1, MSG_PEEK) == 1 &&\n        (!buf[0] || !strchr(\"DGHOPT\", buf[0])))\n    {\n     /*\n      * Encrypt this connection...\n      */\n\n      cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"Saw first byte %02X, auto-negotiating SSL/TLS session.\", buf[0] & 255);\n\n      if (cupsd_start_tls(con, HTTP_ENCRYPTION_ALWAYS))\n        cupsdCloseClient(con);\n\n      return;\n    }\n  }\n#endif /* HAVE_SSL */\n\n  switch (httpGetState(con->http))\n  {\n    case HTTP_STATE_WAITING :\n       /*\n        * See if we've received a request line...\n\t*/\n\n        con->operation = httpReadRequest(con->http, con->uri, sizeof(con->uri));\n        if (con->operation == HTTP_STATE_ERROR ||\n\t    con->operation == HTTP_STATE_UNKNOWN_METHOD ||\n\t    con->operation == HTTP_STATE_UNKNOWN_VERSION)\n\t{\n\t  if (httpError(con->http))\n\t    cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t\t\t   \"HTTP_STATE_WAITING Closing for error %d (%s)\",\n\t\t\t   httpError(con->http), strerror(httpError(con->http)));\n\t  else\n\t    cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t                   \"HTTP_STATE_WAITING Closing on error: %s\",\n\t\t\t   cupsLastErrorString());\n\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n\n       /*\n        * Ignore blank request lines...\n\t*/\n\n        if (con->operation == HTTP_STATE_WAITING)\n\t  break;\n\n       /*\n        * Clear other state variables...\n\t*/\n\n\tcon->bytes       = 0;\n\tcon->file        = -1;\n\tcon->file_ready  = 0;\n\tcon->pipe_pid    = 0;\n\tcon->username[0] = '\\0';\n\tcon->password[0] = '\\0';\n\n\tcupsdClearString(&con->command);\n\tcupsdClearString(&con->options);\n\tcupsdClearString(&con->query_string);\n\n\tif (con->request)\n\t{\n\t  ippDelete(con->request);\n\t  con->request = NULL;\n\t}\n\n\tif (con->response)\n\t{\n\t  ippDelete(con->response);\n\t  con->response = NULL;\n\t}\n\n\tif (con->language)\n\t{\n\t  cupsLangFree(con->language);\n\t  con->language = NULL;\n\t}\n\n#ifdef HAVE_GSSAPI\n        con->have_gss = 0;\n\tcon->gss_uid  = 0;\n#endif /* HAVE_GSSAPI */\n\n       /*\n        * Handle full URLs in the request line...\n\t*/\n\n        if (strcmp(con->uri, \"*\"))\n\t{\n\t  char\tscheme[HTTP_MAX_URI],\t/* Method/scheme */\n\t\tuserpass[HTTP_MAX_URI],\t/* Username:password */\n\t\thostname[HTTP_MAX_URI],\t/* Hostname */\n\t\tresource[HTTP_MAX_URI];\t/* Resource path */\n          int\tport;\t\t\t/* Port number */\n\n         /*\n\t  * Separate the URI into its components...\n\t  */\n\n          if (httpSeparateURI(HTTP_URI_CODING_MOST, con->uri,\n\t                      scheme, sizeof(scheme),\n\t                      userpass, sizeof(userpass),\n\t\t\t      hostname, sizeof(hostname), &port,\n\t\t\t      resource, sizeof(resource)) < HTTP_URI_STATUS_OK)\n          {\n\t    cupsdLogClient(con, CUPSD_LOG_ERROR, \"Bad URI \\\"%s\\\" in request.\",\n                           con->uri);\n\t    cupsdSendError(con, HTTP_STATUS_METHOD_NOT_ALLOWED, CUPSD_AUTH_NONE);\n\t    cupsdCloseClient(con);\n\t    return;\n\t  }\n\n\t /*\n\t  * Only allow URIs with the servername, localhost, or an IP\n\t  * address...\n\t  */\n\n\t  if (strcmp(scheme, \"file\") &&\n\t      _cups_strcasecmp(hostname, ServerName) &&\n\t      _cups_strcasecmp(hostname, \"localhost\") &&\n\t      !cupsArrayFind(ServerAlias, hostname) &&\n\t      !isdigit(hostname[0]) && hostname[0] != '[')\n\t  {\n\t   /*\n\t    * Nope, we don't do proxies...\n\t    */\n\n\t    cupsdLogClient(con, CUPSD_LOG_ERROR, \"Bad URI \\\"%s\\\" in request.\",\n                           con->uri);\n\t    cupsdSendError(con, HTTP_STATUS_METHOD_NOT_ALLOWED, CUPSD_AUTH_NONE);\n\t    cupsdCloseClient(con);\n\t    return;\n\t  }\n\n         /*\n\t  * Copy the resource portion back into the URI; both resource and\n\t  * con->uri are HTTP_MAX_URI bytes in size...\n\t  */\n\n          strlcpy(con->uri, resource, sizeof(con->uri));\n\t}\n\n       /*\n        * Process the request...\n\t*/\n\n        gettimeofday(&(con->start), NULL);\n\n        cupsdLogClient(con, CUPSD_LOG_DEBUG, \"%s %s HTTP/%d.%d\",\n\t               httpStateString(con->operation) + 11, con->uri,\n\t\t       httpGetVersion(con->http) / 100,\n                       httpGetVersion(con->http) % 100);\n\n        if (!cupsArrayFind(ActiveClients, con))\n\t{\n\t  cupsArrayAdd(ActiveClients, con);\n          cupsdSetBusyState();\n        }\n\n    case HTTP_STATE_OPTIONS :\n    case HTTP_STATE_DELETE :\n    case HTTP_STATE_GET :\n    case HTTP_STATE_HEAD :\n    case HTTP_STATE_POST :\n    case HTTP_STATE_PUT :\n    case HTTP_STATE_TRACE :\n       /*\n        * Parse incoming parameters until the status changes...\n\t*/\n\n        while ((status = httpUpdate(con->http)) == HTTP_STATUS_CONTINUE)\n\t  if (!httpGetReady(con->http))\n\t    break;\n\n\tif (status != HTTP_STATUS_OK && status != HTTP_STATUS_CONTINUE)\n\t{\n\t  if (httpError(con->http) && httpError(con->http) != EPIPE)\n\t    cupsdLogClient(con, CUPSD_LOG_DEBUG,\n                           \"Closing for error %d (%s) while reading headers.\",\n                           httpError(con->http), strerror(httpError(con->http)));\n\t  else\n\t    cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t                   \"Closing on EOF while reading headers.\");\n\n\t  cupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE);\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n\tbreak;\n\n    default :\n        if (!httpGetReady(con->http) && recv(httpGetFd(con->http), buf, 1, MSG_PEEK) < 1)\n\t{\n\t /*\n\t  * Connection closed...\n\t  */\n\n\t  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing on EOF.\");\n          cupsdCloseClient(con);\n\t  return;\n\t}\n        break; /* Anti-compiler-warning-code */\n  }\n\n /*\n  * Handle new transfers...\n  */\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Read: status=%d\", status);\n\n  if (status == HTTP_STATUS_OK)\n  {\n    if (httpGetField(con->http, HTTP_FIELD_ACCEPT_LANGUAGE)[0])\n    {\n     /*\n      * Figure out the locale from the Accept-Language and Content-Type\n      * fields...\n      */\n\n      if ((ptr = strchr(httpGetField(con->http, HTTP_FIELD_ACCEPT_LANGUAGE),\n                        ',')) != NULL)\n        *ptr = '\\0';\n\n      if ((ptr = strchr(httpGetField(con->http, HTTP_FIELD_ACCEPT_LANGUAGE),\n                        ';')) != NULL)\n        *ptr = '\\0';\n\n      if ((ptr = strstr(httpGetField(con->http, HTTP_FIELD_CONTENT_TYPE),\n                        \"charset=\")) != NULL)\n      {\n       /*\n        * Combine language and charset, and trim any extra params in the\n\t* content-type.\n\t*/\n\n        snprintf(locale, sizeof(locale), \"%s.%s\",\n\t         httpGetField(con->http, HTTP_FIELD_ACCEPT_LANGUAGE), ptr + 8);\n\n\tif ((ptr = strchr(locale, ',')) != NULL)\n\t  *ptr = '\\0';\n      }\n      else\n        snprintf(locale, sizeof(locale), \"%s.UTF-8\",\n\t         httpGetField(con->http, HTTP_FIELD_ACCEPT_LANGUAGE));\n\n      con->language = cupsLangGet(locale);\n    }\n    else\n      con->language = cupsLangGet(DefaultLocale);\n\n    cupsdAuthorize(con);\n\n    if (!_cups_strncasecmp(httpGetField(con->http, HTTP_FIELD_CONNECTION),\n                           \"Keep-Alive\", 10) && KeepAlive)\n      httpSetKeepAlive(con->http, HTTP_KEEPALIVE_ON);\n    else if (!_cups_strncasecmp(httpGetField(con->http, HTTP_FIELD_CONNECTION),\n                                \"close\", 5))\n      httpSetKeepAlive(con->http, HTTP_KEEPALIVE_OFF);\n\n    if (!httpGetField(con->http, HTTP_FIELD_HOST)[0] &&\n        httpGetVersion(con->http) >= HTTP_VERSION_1_1)\n    {\n     /*\n      * HTTP/1.1 and higher require the \"Host:\" field...\n      */\n\n      if (!cupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE))\n      {\n        cupsdLogClient(con, CUPSD_LOG_ERROR, \"Missing Host: field in request.\");\n\tcupsdCloseClient(con);\n\treturn;\n      }\n    }\n    else if (!valid_host(con))\n    {\n     /*\n      * Access to localhost must use \"localhost\" or the corresponding IPv4\n      * or IPv6 values in the Host: field.\n      */\n\n      cupsdLogClient(con, CUPSD_LOG_ERROR,\n                     \"Request from \\\"%s\\\" using invalid Host: field \\\"%s\\\".\",\n                     httpGetHostname(con->http, NULL, 0), httpGetField(con->http, HTTP_FIELD_HOST));\n\n      if (!cupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE))\n      {\n\tcupsdCloseClient(con);\n\treturn;\n      }\n    }\n    else if (con->operation == HTTP_STATE_OPTIONS)\n    {\n     /*\n      * Do OPTIONS command...\n      */\n\n      if (con->best && con->best->type != CUPSD_AUTH_NONE)\n      {\n        httpClearFields(con->http);\n\n\tif (!cupsdSendHeader(con, HTTP_STATUS_UNAUTHORIZED, NULL, CUPSD_AUTH_NONE))\n\t{\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n      }\n\n      if (!_cups_strcasecmp(httpGetField(con->http, HTTP_FIELD_CONNECTION), \"Upgrade\") && strstr(httpGetField(con->http, HTTP_FIELD_UPGRADE), \"TLS/\") != NULL && !httpIsEncrypted(con->http))\n      {\n#ifdef HAVE_SSL\n       /*\n        * Do encryption stuff...\n\t*/\n\n        httpClearFields(con->http);\n\n\tif (!cupsdSendHeader(con, HTTP_STATUS_SWITCHING_PROTOCOLS, NULL, CUPSD_AUTH_NONE))\n\t{\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n\n        if (cupsd_start_tls(con, HTTP_ENCRYPTION_REQUIRED))\n        {\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n#else\n\tif (!cupsdSendError(con, HTTP_STATUS_NOT_IMPLEMENTED, CUPSD_AUTH_NONE))\n\t{\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n#endif /* HAVE_SSL */\n      }\n\n      httpClearFields(con->http);\n      httpSetField(con->http, HTTP_FIELD_ALLOW,\n\t\t   \"GET, HEAD, OPTIONS, POST, PUT\");\n      httpSetField(con->http, HTTP_FIELD_CONTENT_LENGTH, \"0\");\n\n      if (!cupsdSendHeader(con, HTTP_STATUS_OK, NULL, CUPSD_AUTH_NONE))\n      {\n\tcupsdCloseClient(con);\n\treturn;\n      }\n    }\n    else if (!is_path_absolute(con->uri))\n    {\n     /*\n      * Protect against malicious users!\n      */\n\n      cupsdLogClient(con, CUPSD_LOG_ERROR,\n                     \"Request for non-absolute resource \\\"%s\\\".\", con->uri);\n\n      if (!cupsdSendError(con, HTTP_STATUS_FORBIDDEN, CUPSD_AUTH_NONE))\n      {\n\tcupsdCloseClient(con);\n\treturn;\n      }\n    }\n    else\n    {\n      if (!_cups_strcasecmp(httpGetField(con->http, HTTP_FIELD_CONNECTION),\n                            \"Upgrade\") && !httpIsEncrypted(con->http))\n      {\n#ifdef HAVE_SSL\n       /*\n        * Do encryption stuff...\n\t*/\n\n        httpClearFields(con->http);\n\n\tif (!cupsdSendHeader(con, HTTP_STATUS_SWITCHING_PROTOCOLS, NULL,\n\t                     CUPSD_AUTH_NONE))\n\t{\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n\n        if (cupsd_start_tls(con, HTTP_ENCRYPTION_REQUIRED))\n        {\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n#else\n\tif (!cupsdSendError(con, HTTP_STATUS_NOT_IMPLEMENTED, CUPSD_AUTH_NONE))\n\t{\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n#endif /* HAVE_SSL */\n      }\n\n      if ((status = cupsdIsAuthorized(con, NULL)) != HTTP_STATUS_OK)\n      {\n\tcupsdSendError(con, status, CUPSD_AUTH_NONE);\n\tcupsdCloseClient(con);\n\treturn;\n      }\n\n      if (httpGetExpect(con->http) &&\n          (con->operation == HTTP_STATE_POST || con->operation == HTTP_STATE_PUT))\n      {\n        if (httpGetExpect(con->http) == HTTP_STATUS_CONTINUE)\n\t{\n\t /*\n\t  * Send 100-continue header...\n\t  */\n\n          if (httpWriteResponse(con->http, HTTP_STATUS_CONTINUE))\n\t  {\n\t    cupsdCloseClient(con);\n\t    return;\n\t  }\n\t}\n\telse\n\t{\n\t /*\n\t  * Send 417-expectation-failed header...\n\t  */\n\n          httpClearFields(con->http);\n\t  httpSetField(con->http, HTTP_FIELD_CONTENT_LENGTH, \"0\");\n\n\t  cupsdSendError(con, HTTP_STATUS_EXPECTATION_FAILED, CUPSD_AUTH_NONE);\n          cupsdCloseClient(con);\n          return;\n\t}\n      }\n\n      switch (httpGetState(con->http))\n      {\n\tcase HTTP_STATE_GET_SEND :\n            cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Processing GET %s\", con->uri);\n\n            if ((!strncmp(con->uri, \"/ppd/\", 5) ||\n\t\t !strncmp(con->uri, \"/printers/\", 10) ||\n\t\t !strncmp(con->uri, \"/classes/\", 9)) &&\n\t\t!strcmp(con->uri + strlen(con->uri) - 4, \".ppd\"))\n\t    {\n\t     /*\n\t      * Send PPD file - get the real printer name since printer\n\t      * names are not case sensitive but filenames can be...\n\t      */\n\n              con->uri[strlen(con->uri) - 4] = '\\0';\t/* Drop \".ppd\" */\n\n\t      if (!strncmp(con->uri, \"/ppd/\", 5))\n\t\tp = cupsdFindPrinter(con->uri + 5);\n\t      else if (!strncmp(con->uri, \"/printers/\", 10))\n\t\tp = cupsdFindPrinter(con->uri + 10);\n\t      else\n\t      {\n\t\tp = cupsdFindClass(con->uri + 9);\n\n\t\tif (p)\n\t\t{\n\t\t  int i;\t\t/* Looping var */\n\n\t\t  for (i = 0; i < p->num_printers; i ++)\n\t\t  {\n\t\t    if (!(p->printers[i]->type & CUPS_PRINTER_CLASS))\n\t\t    {\n\t\t      char ppdname[1024];/* PPD filename */\n\n\t\t      snprintf(ppdname, sizeof(ppdname), \"%s/ppd/%s.ppd\",\n\t\t               ServerRoot, p->printers[i]->name);\n\t\t      if (!access(ppdname, 0))\n\t\t      {\n\t\t        p = p->printers[i];\n\t\t        break;\n\t\t      }\n\t\t    }\n\t\t  }\n\n                  if (i >= p->num_printers)\n                    p = NULL;\n\t\t}\n\t      }\n\n\t      if (p)\n\t      {\n\t\tsnprintf(con->uri, sizeof(con->uri), \"/ppd/%s.ppd\", p->name);\n\t      }\n\t      else\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tbreak;\n\t      }\n\t    }\n            else if ((!strncmp(con->uri, \"/icons/\", 7) ||\n\t\t      !strncmp(con->uri, \"/printers/\", 10) ||\n\t\t      !strncmp(con->uri, \"/classes/\", 9)) &&\n\t\t     !strcmp(con->uri + strlen(con->uri) - 4, \".png\"))\n\t    {\n\t     /*\n\t      * Send icon file - get the real queue name since queue names are\n\t      * not case sensitive but filenames can be...\n\t      */\n\n\t      con->uri[strlen(con->uri) - 4] = '\\0';\t/* Drop \".png\" */\n\n              if (!strncmp(con->uri, \"/icons/\", 7))\n                p = cupsdFindPrinter(con->uri + 7);\n              else if (!strncmp(con->uri, \"/printers/\", 10))\n                p = cupsdFindPrinter(con->uri + 10);\n              else\n              {\n\t\tp = cupsdFindClass(con->uri + 9);\n\n\t\tif (p)\n\t\t{\n\t\t  int i;\t\t/* Looping var */\n\n\t\t  for (i = 0; i < p->num_printers; i ++)\n\t\t  {\n\t\t    if (!(p->printers[i]->type & CUPS_PRINTER_CLASS))\n\t\t    {\n\t\t      char ppdname[1024];/* PPD filename */\n\n\t\t      snprintf(ppdname, sizeof(ppdname), \"%s/ppd/%s.ppd\",\n\t\t               ServerRoot, p->printers[i]->name);\n\t\t      if (!access(ppdname, 0))\n\t\t      {\n\t\t        p = p->printers[i];\n\t\t        break;\n\t\t      }\n\t\t    }\n\t\t  }\n\n                  if (i >= p->num_printers)\n                    p = NULL;\n\t\t}\n\t      }\n\n              if (p)\n\t\tsnprintf(con->uri, sizeof(con->uri), \"/icons/%s.png\", p->name);\n\t      else\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tbreak;\n\t      }\n\t    }\n\n\t    if ((!strncmp(con->uri, \"/admin\", 6) && strcmp(con->uri, \"/admin/conf/cupsd.conf\") && strncmp(con->uri, \"/admin/log/\", 11)) ||\n\t\t !strncmp(con->uri, \"/printers\", 9) ||\n\t\t !strncmp(con->uri, \"/classes\", 8) ||\n\t\t !strncmp(con->uri, \"/help\", 5) ||\n\t\t !strncmp(con->uri, \"/jobs\", 5))\n\t    {\n\t      if (!WebInterface)\n\t      {\n\t       /*\n\t\t* Web interface is disabled. Show an appropriate message...\n\t\t*/\n\n\t\tif (!cupsdSendError(con, HTTP_STATUS_CUPS_WEBIF_DISABLED, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tbreak;\n\t      }\n\n\t     /*\n\t      * Send CGI output...\n\t      */\n\n              if (!strncmp(con->uri, \"/admin\", 6))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/admin.cgi\",\n\t\t                ServerBin);\n\n\t\tcupsdSetString(&con->options, strchr(con->uri + 6, '?'));\n\t      }\n              else if (!strncmp(con->uri, \"/printers\", 9))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/printers.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[9] && con->uri[10])\n\t\t  cupsdSetString(&con->options, con->uri + 9);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\t      else if (!strncmp(con->uri, \"/classes\", 8))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/classes.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[8] && con->uri[9])\n\t\t  cupsdSetString(&con->options, con->uri + 8);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\t      else if (!strncmp(con->uri, \"/jobs\", 5))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/jobs.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[5] && con->uri[6])\n\t\t  cupsdSetString(&con->options, con->uri + 5);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\t      else\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/help.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[5] && con->uri[6])\n\t\t  cupsdSetString(&con->options, con->uri + 5);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\n              if (!cupsdSendCommand(con, con->command, con->options, 0))\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n              }\n\t      else\n        \tcupsdLogRequest(con, HTTP_STATUS_OK);\n\n\t      if (httpGetVersion(con->http) <= HTTP_VERSION_1_0)\n\t\thttpSetKeepAlive(con->http, HTTP_KEEPALIVE_OFF);\n\t    }\n            else if (!strncmp(con->uri, \"/admin/log/\", 11) && (strchr(con->uri + 11, '/') || strlen(con->uri) == 11))\n\t    {\n\t     /*\n\t      * GET can only be done to configuration files directly under\n\t      * /admin/conf...\n\t      */\n\n\t      cupsdLogClient(con, CUPSD_LOG_ERROR, \"Request for subdirectory \\\"%s\\\".\", con->uri);\n\n\t      if (!cupsdSendError(con, HTTP_STATUS_FORBIDDEN, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n\t    }\n\t    else\n\t    {\n\t     /*\n\t      * Serve a file...\n\t      */\n\n              if ((filename = get_file(con, &filestats, buf,\n\t                               sizeof(buf))) == NULL)\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tbreak;\n\t      }\n\n\t      type = mimeFileType(MimeDatabase, filename, NULL, NULL);\n\n              cupsdLogClient(con, CUPSD_LOG_DEBUG, \"filename=\\\"%s\\\", type=%s/%s\", filename, type ? type->super : \"\", type ? type->type : \"\");\n\n              if (is_cgi(con, filename, &filestats, type))\n\t      {\n\t       /*\n\t        * Note: con->command and con->options were set by\n\t\t* is_cgi()...\n\t\t*/\n\n        \tif (!cupsdSendCommand(con, con->command, con->options, 0))\n\t\t{\n\t\t  if (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t  {\n\t\t    cupsdCloseClient(con);\n\t\t    return;\n\t\t  }\n        \t}\n\t\telse\n        \t  cupsdLogRequest(con, HTTP_STATUS_OK);\n\n\t\tif (httpGetVersion(con->http) <= HTTP_VERSION_1_0)\n\t\t  httpSetKeepAlive(con->http, HTTP_KEEPALIVE_OFF);\n\t        break;\n\t      }\n\n\t      if (!check_if_modified(con, &filestats))\n              {\n        \tif (!cupsdSendError(con, HTTP_STATUS_NOT_MODIFIED, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\t      }\n\t      else\n              {\n\t\tif (type == NULL)\n\t          strlcpy(line, \"text/plain\", sizeof(line));\n\t\telse\n\t          snprintf(line, sizeof(line), \"%s/%s\", type->super, type->type);\n\n        \tif (!write_file(con, HTTP_STATUS_OK, filename, line, &filestats))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\t      }\n\t    }\n            break;\n\n\tcase HTTP_STATE_POST_RECV :\n           /*\n\t    * See if the POST request includes a Content-Length field, and if\n\t    * so check the length against any limits that are set...\n\t    */\n\n            if (httpGetField(con->http, HTTP_FIELD_CONTENT_LENGTH)[0] &&\n\t\tMaxRequestSize > 0 &&\n\t\thttpGetLength2(con->http) > MaxRequestSize)\n\t    {\n\t     /*\n\t      * Request too large...\n\t      */\n\n              if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n            }\n\t    else if (httpGetLength2(con->http) < 0)\n\t    {\n\t     /*\n\t      * Negative content lengths are invalid!\n\t      */\n\n              if (!cupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n\t    }\n\n           /*\n\t    * See what kind of POST request this is; for IPP requests the\n\t    * content-type field will be \"application/ipp\"...\n\t    */\n\n\t    if (!strcmp(httpGetField(con->http, HTTP_FIELD_CONTENT_TYPE),\n\t                \"application/ipp\"))\n              con->request = ippNew();\n            else if (!WebInterface)\n\t    {\n\t     /*\n\t      * Web interface is disabled. Show an appropriate message...\n\t      */\n\n\t      if (!cupsdSendError(con, HTTP_STATUS_CUPS_WEBIF_DISABLED, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n\t    }\n\t    else if ((!strncmp(con->uri, \"/admin\", 6) && strncmp(con->uri, \"/admin/log/\", 11)) ||\n\t             !strncmp(con->uri, \"/printers\", 9) ||\n\t             !strncmp(con->uri, \"/classes\", 8) ||\n\t             !strncmp(con->uri, \"/help\", 5) ||\n\t             !strncmp(con->uri, \"/jobs\", 5))\n\t    {\n\t     /*\n\t      * CGI request...\n\t      */\n\n              if (!strncmp(con->uri, \"/admin\", 6))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/admin.cgi\",\n\t\t                ServerBin);\n\n\t\tcupsdSetString(&con->options, strchr(con->uri + 6, '?'));\n\t      }\n              else if (!strncmp(con->uri, \"/printers\", 9))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/printers.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[9] && con->uri[10])\n\t\t  cupsdSetString(&con->options, con->uri + 9);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\t      else if (!strncmp(con->uri, \"/classes\", 8))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/classes.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[8] && con->uri[9])\n\t\t  cupsdSetString(&con->options, con->uri + 8);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\t      else if (!strncmp(con->uri, \"/jobs\", 5))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/jobs.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[5] && con->uri[6])\n\t\t  cupsdSetString(&con->options, con->uri + 5);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\t      else\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/help.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[5] && con->uri[6])\n\t\t  cupsdSetString(&con->options, con->uri + 5);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\n\t      if (httpGetVersion(con->http) <= HTTP_VERSION_1_0)\n\t\thttpSetKeepAlive(con->http, HTTP_KEEPALIVE_OFF);\n\t    }\n\t    else\n\t    {\n\t     /*\n\t      * POST to a file...\n\t      */\n\n              if ((filename = get_file(con, &filestats, buf,\n\t                               sizeof(buf))) == NULL)\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tbreak;\n\t      }\n\n\t      type = mimeFileType(MimeDatabase, filename, NULL, NULL);\n\n              if (!is_cgi(con, filename, &filestats, type))\n\t      {\n\t       /*\n\t        * Only POST to CGI's...\n\t\t*/\n\n\t\tif (!cupsdSendError(con, HTTP_STATUS_UNAUTHORIZED, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\t      }\n\t    }\n\t    break;\n\n\tcase HTTP_STATE_PUT_RECV :\n\t   /*\n\t    * Validate the resource name...\n\t    */\n\n            if (strcmp(con->uri, \"/admin/conf/cupsd.conf\"))\n\t    {\n\t     /*\n\t      * PUT can only be done to the cupsd.conf file...\n\t      */\n\n\t      cupsdLogClient(con, CUPSD_LOG_ERROR,\n\t\t\t     \"Disallowed PUT request for \\\"%s\\\".\", con->uri);\n\n\t      if (!cupsdSendError(con, HTTP_STATUS_FORBIDDEN, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n\t    }\n\n           /*\n\t    * See if the PUT request includes a Content-Length field, and if\n\t    * so check the length against any limits that are set...\n\t    */\n\n            if (httpGetField(con->http, HTTP_FIELD_CONTENT_LENGTH)[0] &&\n\t\tMaxRequestSize > 0 &&\n\t\thttpGetLength2(con->http) > MaxRequestSize)\n\t    {\n\t     /*\n\t      * Request too large...\n\t      */\n\n              if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n            }\n\t    else if (httpGetLength2(con->http) < 0)\n\t    {\n\t     /*\n\t      * Negative content lengths are invalid!\n\t      */\n\n              if (!cupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n\t    }\n\n           /*\n\t    * Open a temporary file to hold the request...\n\t    */\n\n            cupsdSetStringf(&con->filename, \"%s/%08x\", RequestRoot,\n\t                    request_id ++);\n\t    con->file = open(con->filename, O_WRONLY | O_CREAT | O_TRUNC, 0640);\n\n\t    if (con->file < 0)\n\t    {\n\t      cupsdLogClient(con, CUPSD_LOG_ERROR,\n\t                     \"Unable to create request file \\\"%s\\\": %s\",\n                             con->filename, strerror(errno));\n\n\t      if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\t    }\n\n\t    fchmod(con->file, 0640);\n\t    fchown(con->file, RunUser, Group);\n\t    fcntl(con->file, F_SETFD, fcntl(con->file, F_GETFD) | FD_CLOEXEC);\n\t    break;\n\n\tcase HTTP_STATE_DELETE :\n\tcase HTTP_STATE_TRACE :\n            cupsdSendError(con, HTTP_STATUS_NOT_IMPLEMENTED, CUPSD_AUTH_NONE);\n\t    cupsdCloseClient(con);\n\t    return;\n\n\tcase HTTP_STATE_HEAD :\n            if (!strncmp(con->uri, \"/printers/\", 10) &&\n\t\t!strcmp(con->uri + strlen(con->uri) - 4, \".ppd\"))\n\t    {\n\t     /*\n\t      * Send PPD file - get the real printer name since printer\n\t      * names are not case sensitive but filenames can be...\n\t      */\n\n              con->uri[strlen(con->uri) - 4] = '\\0';\t/* Drop \".ppd\" */\n\n              if ((p = cupsdFindPrinter(con->uri + 10)) != NULL)\n\t\tsnprintf(con->uri, sizeof(con->uri), \"/ppd/%s.ppd\", p->name);\n\t      else\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tcupsdLogRequest(con, HTTP_STATUS_NOT_FOUND);\n\t\tbreak;\n\t      }\n\t    }\n            else if (!strncmp(con->uri, \"/printers/\", 10) &&\n\t\t     !strcmp(con->uri + strlen(con->uri) - 4, \".png\"))\n\t    {\n\t     /*\n\t      * Send PNG file - get the real printer name since printer\n\t      * names are not case sensitive but filenames can be...\n\t      */\n\n              con->uri[strlen(con->uri) - 4] = '\\0';\t/* Drop \".ppd\" */\n\n              if ((p = cupsdFindPrinter(con->uri + 10)) != NULL)\n\t\tsnprintf(con->uri, sizeof(con->uri), \"/icons/%s.png\", p->name);\n\t      else\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tcupsdLogRequest(con, HTTP_STATUS_NOT_FOUND);\n\t\tbreak;\n\t      }\n\t    }\n\t    else if (!WebInterface)\n\t    {\n              httpClearFields(con->http);\n\n              if (!cupsdSendHeader(con, HTTP_STATUS_OK, NULL, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n              cupsdLogRequest(con, HTTP_STATUS_OK);\n\t      break;\n\t    }\n\n\t    if ((!strncmp(con->uri, \"/admin\", 6) && strcmp(con->uri, \"/admin/conf/cupsd.conf\") && strncmp(con->uri, \"/admin/log/\", 11)) ||\n\t\t!strncmp(con->uri, \"/printers\", 9) ||\n\t\t!strncmp(con->uri, \"/classes\", 8) ||\n\t\t!strncmp(con->uri, \"/help\", 5) ||\n\t\t!strncmp(con->uri, \"/jobs\", 5))\n\t    {\n\t     /*\n\t      * CGI output...\n\t      */\n\n              httpClearFields(con->http);\n\n              if (!cupsdSendHeader(con, HTTP_STATUS_OK, \"text/html\", CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n              cupsdLogRequest(con, HTTP_STATUS_OK);\n\t    }\n            else if (!strncmp(con->uri, \"/admin/log/\", 11) && (strchr(con->uri + 11, '/') || strlen(con->uri) == 11))\n\t    {\n\t     /*\n\t      * HEAD can only be done to configuration files under\n\t      * /admin/conf...\n\t      */\n\n\t      cupsdLogClient(con, CUPSD_LOG_ERROR,\n\t\t\t     \"Request for subdirectory \\\"%s\\\".\", con->uri);\n\n\t      if (!cupsdSendError(con, HTTP_STATUS_FORBIDDEN, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n              cupsdLogRequest(con, HTTP_STATUS_FORBIDDEN);\n\t      break;\n\t    }\n\t    else if ((filename = get_file(con, &filestats, buf,\n\t                                  sizeof(buf))) == NULL)\n\t    {\n              httpClearFields(con->http);\n\n\t      if (!cupsdSendHeader(con, HTTP_STATUS_NOT_FOUND, \"text/html\",\n\t                           CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n              cupsdLogRequest(con, HTTP_STATUS_NOT_FOUND);\n\t    }\n\t    else if (!check_if_modified(con, &filestats))\n            {\n              if (!cupsdSendError(con, HTTP_STATUS_NOT_MODIFIED, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n              cupsdLogRequest(con, HTTP_STATUS_NOT_MODIFIED);\n\t    }\n\t    else\n\t    {\n\t     /*\n\t      * Serve a file...\n\t      */\n\n\t      type = mimeFileType(MimeDatabase, filename, NULL, NULL);\n\t      if (type == NULL)\n\t\tstrlcpy(line, \"text/plain\", sizeof(line));\n\t      else\n\t\tsnprintf(line, sizeof(line), \"%s/%s\", type->super, type->type);\n\n              httpClearFields(con->http);\n\n\t      httpSetField(con->http, HTTP_FIELD_LAST_MODIFIED,\n\t\t\t   httpGetDateString(filestats.st_mtime));\n\t      httpSetLength(con->http, (size_t)filestats.st_size);\n\n              if (!cupsdSendHeader(con, HTTP_STATUS_OK, line, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n              cupsdLogRequest(con, HTTP_STATUS_OK);\n\t    }\n            break;\n\n\tdefault :\n            break; /* Anti-compiler-warning-code */\n      }\n    }\n  }\n\n /*\n  * Handle any incoming data...\n  */\n\n  switch (httpGetState(con->http))\n  {\n    case HTTP_STATE_PUT_RECV :\n        do\n\t{\n          if ((bytes = httpRead2(con->http, line, sizeof(line))) < 0)\n\t  {\n\t    if (httpError(con->http) && httpError(con->http) != EPIPE)\n\t      cupsdLogClient(con, CUPSD_LOG_DEBUG,\n                             \"HTTP_STATE_PUT_RECV Closing for error %d (%s)\",\n                             httpError(con->http), strerror(httpError(con->http)));\n\t    else\n\t      cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t\t\t     \"HTTP_STATE_PUT_RECV Closing on EOF.\");\n\n\t    cupsdCloseClient(con);\n\t    return;\n\t  }\n\t  else if (bytes > 0)\n\t  {\n\t    con->bytes += bytes;\n\n            if (MaxRequestSize > 0 && con->bytes > MaxRequestSize)\n            {\n\t      close(con->file);\n\t      con->file = -1;\n\t      unlink(con->filename);\n\t      cupsdClearString(&con->filename);\n\n              if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n            }\n\n            if (write(con->file, line, (size_t)bytes) < bytes)\n\t    {\n              cupsdLogClient(con, CUPSD_LOG_ERROR,\n\t                     \"Unable to write %d bytes to \\\"%s\\\": %s\", bytes,\n                             con->filename, strerror(errno));\n\n\t      close(con->file);\n\t      con->file = -1;\n\t      unlink(con->filename);\n\t      cupsdClearString(&con->filename);\n\n              if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\t    }\n\t  }\n          else if (httpGetState(con->http) == HTTP_STATE_PUT_RECV)\n          {\n            cupsdCloseClient(con);\n            return;\n          }\n        }\n\twhile (httpGetState(con->http) == HTTP_STATE_PUT_RECV && httpGetReady(con->http));\n\n        if (httpGetState(con->http) == HTTP_STATE_STATUS)\n\t{\n\t /*\n\t  * End of file, see how big it is...\n\t  */\n\n\t  fstat(con->file, &filestats);\n\n\t  close(con->file);\n\t  con->file = -1;\n\n          if (filestats.st_size > MaxRequestSize &&\n\t      MaxRequestSize > 0)\n\t  {\n\t   /*\n\t    * Request is too big; remove it and send an error...\n\t    */\n\n\t    unlink(con->filename);\n\t    cupsdClearString(&con->filename);\n\n            if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t    {\n\t      cupsdCloseClient(con);\n\t      return;\n\t    }\n\t  }\n\n         /*\n\t  * Install the configuration file...\n\t  */\n\n          status = install_cupsd_conf(con);\n\n         /*\n\t  * Return the status to the client...\n\t  */\n\n          if (!cupsdSendError(con, status, CUPSD_AUTH_NONE))\n\t  {\n\t    cupsdCloseClient(con);\n\t    return;\n\t  }\n\t}\n        break;\n\n    case HTTP_STATE_POST_RECV :\n        do\n\t{\n          if (con->request && con->file < 0)\n\t  {\n\t   /*\n\t    * Grab any request data from the connection...\n\t    */\n\n\t    if (!httpWait(con->http, 0))\n\t      return;\n\n\t    if ((ipp_state = ippRead(con->http, con->request)) == IPP_STATE_ERROR)\n\t    {\n              cupsdLogClient(con, CUPSD_LOG_ERROR, \"IPP read error: %s\",\n                             cupsLastErrorString());\n\n\t      cupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE);\n\t      cupsdCloseClient(con);\n\t      return;\n\t    }\n\t    else if (ipp_state != IPP_STATE_DATA)\n\t    {\n              if (httpGetState(con->http) == HTTP_STATE_POST_SEND)\n\t      {\n\t\tcupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE);\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      if (httpGetReady(con->http))\n\t        continue;\n\t      break;\n            }\n\t    else\n\t    {\n\t      cupsdLogClient(con, CUPSD_LOG_DEBUG, \"%d.%d %s %d\",\n\t\t\t      con->request->request.op.version[0],\n\t\t\t      con->request->request.op.version[1],\n\t\t\t      ippOpString(con->request->request.op.operation_id),\n\t\t\t      con->request->request.op.request_id);\n\t      con->bytes += (off_t)ippLength(con->request);\n\t    }\n\t  }\n\n          if (con->file < 0 && httpGetState(con->http) != HTTP_STATE_POST_SEND)\n\t  {\n           /*\n\t    * Create a file as needed for the request data...\n\t    */\n\n            cupsdSetStringf(&con->filename, \"%s/%08x\", RequestRoot,\n\t                    request_id ++);\n\t    con->file = open(con->filename, O_WRONLY | O_CREAT | O_TRUNC, 0640);\n\n\t    if (con->file < 0)\n\t    {\n\t      cupsdLogClient(con, CUPSD_LOG_ERROR,\n\t                     \"Unable to create request file \\\"%s\\\": %s\",\n                             con->filename, strerror(errno));\n\n\t      if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\t    }\n\n\t    fchmod(con->file, 0640);\n\t    fchown(con->file, RunUser, Group);\n            fcntl(con->file, F_SETFD, fcntl(con->file, F_GETFD) | FD_CLOEXEC);\n\t  }\n\n\t  if (httpGetState(con->http) != HTTP_STATE_POST_SEND)\n\t  {\n\t    if (!httpWait(con->http, 0))\n\t      return;\n            else if ((bytes = httpRead2(con->http, line, sizeof(line))) < 0)\n\t    {\n\t      if (httpError(con->http) && httpError(con->http) != EPIPE)\n\t\tcupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t\t\t       \"HTTP_STATE_POST_SEND Closing for error %d (%s)\",\n                               httpError(con->http), strerror(httpError(con->http)));\n\t      else\n\t\tcupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t\t\t       \"HTTP_STATE_POST_SEND Closing on EOF.\");\n\n\t      cupsdCloseClient(con);\n\t      return;\n\t    }\n\t    else if (bytes > 0)\n\t    {\n\t      con->bytes += bytes;\n\n              if (MaxRequestSize > 0 && con->bytes > MaxRequestSize)\n              {\n                close(con->file);\n                con->file = -1;\n                unlink(con->filename);\n                cupsdClearString(&con->filename);\n\n                if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n                {\n                  cupsdCloseClient(con);\n                  return;\n                }\n              }\n\n              if (write(con->file, line, (size_t)bytes) < bytes)\n\t      {\n        \tcupsdLogClient(con, CUPSD_LOG_ERROR,\n\t                       \"Unable to write %d bytes to \\\"%s\\\": %s\",\n                               bytes, con->filename, strerror(errno));\n\n\t\tclose(con->file);\n\t\tcon->file = -1;\n\t\tunlink(con->filename);\n\t\tcupsdClearString(&con->filename);\n\n        \tif (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE,\n\t\t                    CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\t      }\n\t    }\n\t    else if (httpGetState(con->http) == HTTP_STATE_POST_RECV)\n              return;\n\t    else if (httpGetState(con->http) != HTTP_STATE_POST_SEND)\n\t    {\n\t      cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t                     \"Closing on unexpected state %s.\",\n\t\t\t     httpStateString(httpGetState(con->http)));\n\t      cupsdCloseClient(con);\n\t      return;\n\t    }\n\t  }\n        }\n\twhile (httpGetState(con->http) == HTTP_STATE_POST_RECV && httpGetReady(con->http));\n\n\tif (httpGetState(con->http) == HTTP_STATE_POST_SEND)\n\t{\n\t  if (con->file >= 0)\n\t  {\n\t    fstat(con->file, &filestats);\n\n\t    close(con->file);\n\t    con->file = -1;\n\n            if (filestats.st_size > MaxRequestSize &&\n\t        MaxRequestSize > 0)\n\t    {\n\t     /*\n\t      * Request is too big; remove it and send an error...\n\t      */\n\n\t      unlink(con->filename);\n\t      cupsdClearString(&con->filename);\n\n\t      if (con->request)\n\t      {\n\t       /*\n\t        * Delete any IPP request data...\n\t\t*/\n\n\t        ippDelete(con->request);\n\t\tcon->request = NULL;\n              }\n\n              if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\t    }\n\t    else if (filestats.st_size == 0)\n\t    {\n\t     /*\n\t      * Don't allow empty file...\n\t      */\n\n\t      unlink(con->filename);\n\t      cupsdClearString(&con->filename);\n\t    }\n\n\t    if (con->command)\n\t    {\n\t      if (!cupsdSendCommand(con, con->command, con->options, 0))\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n              }\n\t      else\n        \tcupsdLogRequest(con, HTTP_STATUS_OK);\n            }\n\t  }\n\n          if (con->request)\n\t  {\n\t    cupsdProcessIPPRequest(con);\n\n\t    if (con->filename)\n\t    {\n\t      unlink(con->filename);\n\t      cupsdClearString(&con->filename);\n\t    }\n\n\t    return;\n\t  }\n\t}\n        break;\n\n    default :\n        break; /* Anti-compiler-warning-code */\n  }\n\n  if (httpGetState(con->http) == HTTP_STATE_WAITING)\n  {\n    if (!httpGetKeepAlive(con->http))\n    {\n      cupsdLogClient(con, CUPSD_LOG_DEBUG,\n                     \"Closing because Keep-Alive is disabled.\");\n      cupsdCloseClient(con);\n    }\n    else\n    {\n      cupsArrayRemove(ActiveClients, con);\n      cupsdSetBusyState();\n    }\n  }\n}\n\n\n/*\n * 'cupsdSendCommand()' - Send output from a command via HTTP.\n */\n\nint\t\t\t\t\t/* O - 1 on success, 0 on failure */\ncupsdSendCommand(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    char           *command,\t\t/* I - Command to run */\n    char           *options,\t\t/* I - Command-line options */\n    int            root)\t\t/* I - Run as root? */\n{\n  int\tfd;\t\t\t\t/* Standard input file descriptor */\n\n\n  if (con->filename)\n  {\n    fd = open(con->filename, O_RDONLY);\n\n    if (fd < 0)\n    {\n      cupsdLogClient(con, CUPSD_LOG_ERROR,\n                     \"Unable to open \\\"%s\\\" for reading: %s\",\n                     con->filename ? con->filename : \"/dev/null\",\n\t             strerror(errno));\n      return (0);\n    }\n\n    fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n  }\n  else\n    fd = -1;\n\n  con->pipe_pid    = pipe_command(con, fd, &(con->file), command, options, root);\n  con->pipe_status = HTTP_STATUS_OK;\n\n  httpClearFields(con->http);\n\n  if (fd >= 0)\n    close(fd);\n\n  cupsdLogClient(con, CUPSD_LOG_INFO, \"Started \\\"%s\\\" (pid=%d, file=%d)\",\n                 command, con->pipe_pid, con->file);\n\n  if (con->pipe_pid == 0)\n    return (0);\n\n  fcntl(con->file, F_SETFD, fcntl(con->file, F_GETFD) | FD_CLOEXEC);\n\n  cupsdAddSelect(con->file, (cupsd_selfunc_t)write_pipe, NULL, con);\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Waiting for CGI data.\");\n\n  con->sent_header = 0;\n  con->file_ready  = 0;\n  con->got_fields  = 0;\n  con->header_used = 0;\n\n  return (1);\n}\n\n\n/*\n * 'cupsdSendError()' - Send an error message via HTTP.\n */\n\nint\t\t\t\t\t/* O - 1 if successful, 0 otherwise */\ncupsdSendError(cupsd_client_t *con,\t/* I - Connection */\n               http_status_t  code,\t/* I - Error code */\n\t       int            auth_type)/* I - Authentication type */\n{\n  char\tlocation[HTTP_MAX_VALUE];\t/* Location field */\n\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"cupsdSendError code=%d, auth_type=%d\", code, auth_type);\n\n#ifdef HAVE_SSL\n /*\n  * Force client to upgrade for authentication if that is how the\n  * server is configured...\n  */\n\n  if (code == HTTP_STATUS_UNAUTHORIZED &&\n      DefaultEncryption == HTTP_ENCRYPTION_REQUIRED &&\n      _cups_strcasecmp(httpGetHostname(con->http, NULL, 0), \"localhost\") &&\n      !httpIsEncrypted(con->http))\n  {\n    code = HTTP_STATUS_UPGRADE_REQUIRED;\n  }\n#endif /* HAVE_SSL */\n\n /*\n  * Put the request in the access_log file...\n  */\n\n  cupsdLogRequest(con, code);\n\n /*\n  * To work around bugs in some proxies, don't use Keep-Alive for some\n  * error messages...\n  *\n  * Kerberos authentication doesn't work without Keep-Alive, so\n  * never disable it in that case.\n  */\n\n  strlcpy(location, httpGetField(con->http, HTTP_FIELD_LOCATION), sizeof(location));\n\n  httpClearFields(con->http);\n\n  httpSetField(con->http, HTTP_FIELD_LOCATION, location);\n\n  if (code >= HTTP_STATUS_BAD_REQUEST && con->type != CUPSD_AUTH_NEGOTIATE)\n    httpSetKeepAlive(con->http, HTTP_KEEPALIVE_OFF);\n\n  if (httpGetVersion(con->http) >= HTTP_VERSION_1_1 &&\n      httpGetKeepAlive(con->http) == HTTP_KEEPALIVE_OFF)\n    httpSetField(con->http, HTTP_FIELD_CONNECTION, \"close\");\n\n  if (code >= HTTP_STATUS_BAD_REQUEST)\n  {\n   /*\n    * Send a human-readable error message.\n    */\n\n    char\tmessage[4096],\t\t/* Message for user */\n\t\turltext[1024],\t\t/* URL redirection text */\n\t\tredirect[1024];\t\t/* Redirection link */\n    const char\t*text;\t\t\t/* Status-specific text */\n\n\n    redirect[0] = '\\0';\n\n    if (code == HTTP_STATUS_UNAUTHORIZED)\n      text = _cupsLangString(con->language,\n                             _(\"Enter your username and password or the \"\n\t\t\t       \"root username and password to access this \"\n\t\t\t       \"page. If you are using Kerberos authentication, \"\n\t\t\t       \"make sure you have a valid Kerberos ticket.\"));\n    else if (code == HTTP_STATUS_UPGRADE_REQUIRED)\n    {\n      text = urltext;\n\n      snprintf(urltext, sizeof(urltext),\n               _cupsLangString(con->language,\n                               _(\"You must access this page using the URL \"\n\t\t\t         \"<A HREF=\\\"https://%s:%d%s\\\">\"\n\t\t\t\t \"https://%s:%d%s</A>.\")),\n               con->servername, con->serverport, con->uri,\n\t       con->servername, con->serverport, con->uri);\n\n      snprintf(redirect, sizeof(redirect),\n               \"<META HTTP-EQUIV=\\\"Refresh\\\" \"\n\t       \"CONTENT=\\\"3;URL=https://%s:%d%s\\\">\\n\",\n\t       con->servername, con->serverport, con->uri);\n    }\n    else if (code == HTTP_STATUS_CUPS_WEBIF_DISABLED)\n      text = _cupsLangString(con->language,\n                             _(\"The web interface is currently disabled. Run \"\n\t\t\t       \"\\\"cupsctl WebInterface=yes\\\" to enable it.\"));\n    else\n      text = \"\";\n\n    snprintf(message, sizeof(message),\n             \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \"\n\t     \"\\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\"\n\t     \"<HTML>\\n\"\n\t     \"<HEAD>\\n\"\n             \"\\t<META HTTP-EQUIV=\\\"Content-Type\\\" \"\n\t     \"CONTENT=\\\"text/html; charset=utf-8\\\">\\n\"\n\t     \"\\t<TITLE>%s - \" CUPS_SVERSION \"</TITLE>\\n\"\n\t     \"\\t<LINK REL=\\\"STYLESHEET\\\" TYPE=\\\"text/css\\\" \"\n\t     \"HREF=\\\"/cups.css\\\">\\n\"\n\t     \"%s\"\n\t     \"</HEAD>\\n\"\n             \"<BODY>\\n\"\n\t     \"<H1>%s</H1>\\n\"\n\t     \"<P>%s</P>\\n\"\n\t     \"</BODY>\\n\"\n\t     \"</HTML>\\n\",\n\t     _httpStatus(con->language, code), redirect,\n\t     _httpStatus(con->language, code), text);\n\n   /*\n    * Send an error message back to the client.  If the error code is a\n    * 400 or 500 series, make sure the message contains some text, too!\n    */\n\n    size_t length = strlen(message);\t/* Length of message */\n\n    httpSetLength(con->http, length);\n\n    if (!cupsdSendHeader(con, code, \"text/html\", auth_type))\n      return (0);\n\n    if (httpWrite2(con->http, message, length) < 0)\n      return (0);\n\n    if (httpFlushWrite(con->http) < 0)\n      return (0);\n  }\n  else\n  {\n    httpSetField(con->http, HTTP_FIELD_CONTENT_LENGTH, \"0\");\n\n    if (!cupsdSendHeader(con, code, NULL, auth_type))\n      return (0);\n  }\n\n  return (1);\n}\n\n\n/*\n * 'cupsdSendHeader()' - Send an HTTP request.\n */\n\nint\t\t\t\t\t/* O - 1 on success, 0 on failure */\ncupsdSendHeader(\n    cupsd_client_t *con,\t\t/* I - Client to send to */\n    http_status_t  code,\t\t/* I - HTTP status code */\n    char           *type,\t\t/* I - MIME type of document */\n    int            auth_type)\t\t/* I - Type of authentication */\n{\n  char\t\tauth_str[1024];\t\t/* Authorization string */\n\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"cupsdSendHeader: code=%d, type=\\\"%s\\\", auth_type=%d\", code, type, auth_type);\n\n /*\n  * Send the HTTP status header...\n  */\n\n  if (code == HTTP_STATUS_CUPS_WEBIF_DISABLED)\n  {\n   /*\n    * Treat our special \"web interface is disabled\" status as \"200 OK\" for web\n    * browsers.\n    */\n\n    code = HTTP_STATUS_OK;\n  }\n\n  if (ServerHeader)\n    httpSetField(con->http, HTTP_FIELD_SERVER, ServerHeader);\n\n  if (code == HTTP_STATUS_METHOD_NOT_ALLOWED)\n    httpSetField(con->http, HTTP_FIELD_ALLOW, \"GET, HEAD, OPTIONS, POST, PUT\");\n\n  if (code == HTTP_STATUS_UNAUTHORIZED)\n  {\n    if (auth_type == CUPSD_AUTH_NONE)\n    {\n      if (!con->best || con->best->type <= CUPSD_AUTH_NONE)\n\tauth_type = cupsdDefaultAuthType();\n      else\n\tauth_type = con->best->type;\n    }\n\n    auth_str[0] = '\\0';\n\n    if (auth_type == CUPSD_AUTH_BASIC)\n      strlcpy(auth_str, \"Basic realm=\\\"CUPS\\\"\", sizeof(auth_str));\n#ifdef HAVE_GSSAPI\n    else if (auth_type == CUPSD_AUTH_NEGOTIATE)\n    {\n#  ifdef AF_LOCAL\n      if (httpAddrFamily(httpGetAddress(con->http)) == AF_LOCAL)\n        strlcpy(auth_str, \"Basic realm=\\\"CUPS\\\"\", sizeof(auth_str));\n      else\n#  endif /* AF_LOCAL */\n      strlcpy(auth_str, \"Negotiate\", sizeof(auth_str));\n    }\n#endif /* HAVE_GSSAPI */\n\n    if (con->best && auth_type != CUPSD_AUTH_NEGOTIATE &&\n        !_cups_strcasecmp(httpGetHostname(con->http, NULL, 0), \"localhost\"))\n    {\n     /*\n      * Add a \"trc\" (try root certification) parameter for local non-Kerberos\n      * requests when the request requires system group membership - then the\n      * client knows the root certificate can/should be used.\n      *\n      * Also, for macOS we also look for @AUTHKEY and add an \"authkey\"\n      * parameter as needed...\n      */\n\n      char\t*name,\t\t\t/* Current user name */\n\t\t*auth_key;\t\t/* Auth key buffer */\n      size_t\tauth_size;\t\t/* Size of remaining buffer */\n\n      auth_key  = auth_str + strlen(auth_str);\n      auth_size = sizeof(auth_str) - (size_t)(auth_key - auth_str);\n\n      for (name = (char *)cupsArrayFirst(con->best->names);\n           name;\n\t   name = (char *)cupsArrayNext(con->best->names))\n      {\n#ifdef HAVE_AUTHORIZATION_H\n\tif (!_cups_strncasecmp(name, \"@AUTHKEY(\", 9))\n\t{\n\t  snprintf(auth_key, auth_size, \", authkey=\\\"%s\\\"\", name + 9);\n\t  /* end parenthesis is stripped in conf.c */\n\t  break;\n        }\n\telse\n#endif /* HAVE_AUTHORIZATION_H */\n\tif (!_cups_strcasecmp(name, \"@SYSTEM\"))\n\t{\n#ifdef HAVE_AUTHORIZATION_H\n\t  if (SystemGroupAuthKey)\n\t    snprintf(auth_key, auth_size,\n\t             \", authkey=\\\"%s\\\"\",\n\t\t     SystemGroupAuthKey);\n          else\n#else\n\t  strlcpy(auth_key, \", trc=\\\"y\\\"\", auth_size);\n#endif /* HAVE_AUTHORIZATION_H */\n\t  break;\n\t}\n      }\n    }\n\n    if (auth_str[0])\n    {\n      cupsdLogClient(con, CUPSD_LOG_DEBUG, \"WWW-Authenticate: %s\", auth_str);\n\n      httpSetField(con->http, HTTP_FIELD_WWW_AUTHENTICATE, auth_str);\n    }\n  }\n\n  if (con->language && strcmp(con->language->language, \"C\"))\n    httpSetField(con->http, HTTP_FIELD_CONTENT_LANGUAGE, con->language->language);\n\n  if (type)\n  {\n    if (!strcmp(type, \"text/html\"))\n      httpSetField(con->http, HTTP_FIELD_CONTENT_TYPE, \"text/html; charset=utf-8\");\n    else\n      httpSetField(con->http, HTTP_FIELD_CONTENT_TYPE, type);\n  }\n\n  return (!httpWriteResponse(con->http, code));\n}\n\n\n/*\n * 'cupsdUpdateCGI()' - Read status messages from CGI scripts and programs.\n */\n\nvoid\ncupsdUpdateCGI(void)\n{\n  char\t\t*ptr,\t\t\t/* Pointer to end of line in buffer */\n\t\tmessage[1024];\t\t/* Pointer to message text */\n  int\t\tloglevel;\t\t/* Log level for message */\n\n\n  while ((ptr = cupsdStatBufUpdate(CGIStatusBuffer, &loglevel,\n                                   message, sizeof(message))) != NULL)\n  {\n    if (loglevel == CUPSD_LOG_INFO)\n      cupsdLogMessage(CUPSD_LOG_INFO, \"%s\", message);\n\n    if (!strchr(CGIStatusBuffer->buffer, '\\n'))\n      break;\n  }\n\n  if (ptr == NULL && !CGIStatusBuffer->bufused)\n  {\n   /*\n    * Fatal error on pipe - should never happen!\n    */\n\n    cupsdLogMessage(CUPSD_LOG_CRIT,\n                    \"cupsdUpdateCGI: error reading from CGI error pipe - %s\",\n                    strerror(errno));\n  }\n}\n\n\n/*\n * 'cupsdWriteClient()' - Write data to a client as needed.\n */\n\nvoid\ncupsdWriteClient(cupsd_client_t *con)\t/* I - Client connection */\n{\n  int\t\tbytes,\t\t\t/* Number of bytes written */\n\t\tfield_col;\t\t/* Current column */\n  char\t\t*bufptr,\t\t/* Pointer into buffer */\n\t\t*bufend;\t\t/* Pointer to end of buffer */\n  ipp_state_t\tipp_state;\t\t/* IPP state value */\n\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"con->http=%p\", con->http);\n  cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t\t \"cupsdWriteClient \"\n\t\t \"error=%d, \"\n\t\t \"used=%d, \"\n\t\t \"state=%s, \"\n\t\t \"data_encoding=HTTP_ENCODING_%s, \"\n\t\t \"data_remaining=\" CUPS_LLFMT \", \"\n\t\t \"response=%p(%s), \"\n\t\t \"pipe_pid=%d, \"\n\t\t \"file=%d\",\n\t\t httpError(con->http), (int)httpGetReady(con->http),\n\t\t httpStateString(httpGetState(con->http)),\n\t\t httpIsChunked(con->http) ? \"CHUNKED\" : \"LENGTH\",\n\t\t CUPS_LLCAST httpGetLength2(con->http),\n\t\t con->response,\n\t\t con->response ? ippStateString(ippGetState(con->request)) : \"\",\n\t\t con->pipe_pid, con->file);\n\n  if (httpGetState(con->http) != HTTP_STATE_GET_SEND &&\n      httpGetState(con->http) != HTTP_STATE_POST_SEND)\n  {\n   /*\n    * If we get called in the wrong state, then something went wrong with the\n    * connection and we need to shut it down...\n    */\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing on unexpected HTTP write state %s.\",\n\t\t   httpStateString(httpGetState(con->http)));\n    cupsdCloseClient(con);\n    return;\n  }\n\n  if (con->pipe_pid)\n  {\n   /*\n    * Make sure we select on the CGI output...\n    */\n\n    cupsdAddSelect(con->file, (cupsd_selfunc_t)write_pipe, NULL, con);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Waiting for CGI data.\");\n\n    if (!con->file_ready)\n    {\n     /*\n      * Try again later when there is CGI output available...\n      */\n\n      cupsdRemoveSelect(httpGetFd(con->http));\n      return;\n    }\n\n    con->file_ready = 0;\n  }\n\n  bytes = (ssize_t)(sizeof(con->header) - (size_t)con->header_used);\n\n  if (!con->pipe_pid && bytes > (ssize_t)httpGetRemaining(con->http))\n  {\n   /*\n    * Limit GET bytes to original size of file (STR #3265)...\n    */\n\n    bytes = (ssize_t)httpGetRemaining(con->http);\n  }\n\n  if (con->response && con->response->state != IPP_STATE_DATA)\n  {\n    size_t wused = httpGetPending(con->http);\t/* Previous write buffer use */\n\n    do\n    {\n     /*\n      * Write a single attribute or the IPP message header...\n      */\n\n      ipp_state = ippWrite(con->http, con->response);\n\n     /*\n      * If the write buffer has been flushed, stop buffering up attributes...\n      */\n\n      if (httpGetPending(con->http) <= wused)\n        break;\n    }\n    while (ipp_state != IPP_STATE_DATA && ipp_state != IPP_STATE_ERROR);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG,\n                   \"Writing IPP response, ipp_state=%s, old \"\n                   \"wused=\" CUPS_LLFMT \", new wused=\" CUPS_LLFMT,\n                   ippStateString(ipp_state),\n\t\t   CUPS_LLCAST wused, CUPS_LLCAST httpGetPending(con->http));\n\n    if (httpGetPending(con->http) > 0)\n      httpFlushWrite(con->http);\n\n    bytes = ipp_state != IPP_STATE_ERROR &&\n\t    (con->file >= 0 || ipp_state != IPP_STATE_DATA);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG,\n                   \"bytes=%d, http_state=%d, data_remaining=\" CUPS_LLFMT,\n                   (int)bytes, httpGetState(con->http),\n                   CUPS_LLCAST httpGetLength2(con->http));\n  }\n  else if ((bytes = read(con->file, con->header + con->header_used, (size_t)bytes)) > 0)\n  {\n    con->header_used += bytes;\n\n    if (con->pipe_pid && !con->got_fields)\n    {\n     /*\n      * Inspect the data for Content-Type and other fields.\n      */\n\n      for (bufptr = con->header, bufend = con->header + con->header_used,\n               field_col = 0;\n           !con->got_fields && bufptr < bufend;\n\t   bufptr ++)\n      {\n        if (*bufptr == '\\n')\n\t{\n\t /*\n\t  * Send line to client...\n\t  */\n\n\t  if (bufptr > con->header && bufptr[-1] == '\\r')\n\t    bufptr[-1] = '\\0';\n\t  *bufptr++ = '\\0';\n\n          cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Script header: %s\", con->header);\n\n          if (!con->sent_header)\n\t  {\n\t   /*\n\t    * Handle redirection and CGI status codes...\n\t    */\n\n\t    http_field_t field;\t\t/* HTTP field */\n\t    char\t*value = strchr(con->header, ':');\n\t\t\t\t\t/* Value of field */\n\n\t    if (value)\n\t    {\n\t      *value++ = '\\0';\n\t      while (isspace(*value & 255))\n\t\tvalue ++;\n\t    }\n\n\t    field = httpFieldValue(con->header);\n\n\t    if (field != HTTP_FIELD_UNKNOWN && value)\n\t    {\n\t      httpSetField(con->http, field, value);\n\n\t      if (field == HTTP_FIELD_LOCATION)\n\t      {\n\t\tcon->pipe_status = HTTP_STATUS_SEE_OTHER;\n\t\tcon->sent_header = 2;\n\t      }\n\t      else\n\t        con->sent_header = 1;\n\t    }\n\t    else if (!_cups_strcasecmp(con->header, \"Status\") && value)\n\t    {\n  \t      con->pipe_status = (http_status_t)atoi(value);\n\t      con->sent_header = 2;\n\t    }\n\t    else if (!_cups_strcasecmp(con->header, \"Set-Cookie\") && value)\n\t    {\n\t      httpSetCookie(con->http, value);\n\t      con->sent_header = 1;\n\t    }\n\t  }\n\n         /*\n\t  * Update buffer...\n\t  */\n\n\t  con->header_used -= bufptr - con->header;\n\n\t  if (con->header_used > 0)\n\t    memmove(con->header, bufptr, (size_t)con->header_used);\n\n\t  bufptr = con->header - 1;\n\n         /*\n\t  * See if the line was empty...\n\t  */\n\n\t  if (field_col == 0)\n\t  {\n\t    con->got_fields = 1;\n\n\t    if (httpGetVersion(con->http) == HTTP_VERSION_1_1 &&\n\t\t!httpGetField(con->http, HTTP_FIELD_CONTENT_LENGTH)[0])\n\t      httpSetLength(con->http, 0);\n\n            cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Sending status %d for CGI.\", con->pipe_status);\n\n            if (con->pipe_status == HTTP_STATUS_OK)\n\t    {\n\t      if (!cupsdSendHeader(con, con->pipe_status, NULL, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (!cupsdSendError(con, con->pipe_status, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\t    }\n          }\n\t  else\n\t    field_col = 0;\n\t}\n\telse if (*bufptr != '\\r')\n\t  field_col ++;\n      }\n\n      if (!con->got_fields)\n        return;\n    }\n\n    if (con->header_used > 0)\n    {\n      if (httpWrite2(con->http, con->header, (size_t)con->header_used) < 0)\n      {\n\tcupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing for error %d (%s)\",\n\t\t       httpError(con->http), strerror(httpError(con->http)));\n\tcupsdCloseClient(con);\n\treturn;\n      }\n\n      if (httpIsChunked(con->http))\n        httpFlushWrite(con->http);\n\n      con->bytes += con->header_used;\n\n      if (httpGetState(con->http) == HTTP_STATE_WAITING)\n\tbytes = 0;\n      else\n        bytes = con->header_used;\n\n      con->header_used = 0;\n    }\n  }\n\n  if (bytes <= 0 ||\n      (httpGetState(con->http) != HTTP_STATE_GET_SEND &&\n       httpGetState(con->http) != HTTP_STATE_POST_SEND))\n  {\n    if (!con->sent_header && con->pipe_pid)\n      cupsdSendError(con, HTTP_STATUS_SERVER_ERROR, CUPSD_AUTH_NONE);\n    else\n    {\n      cupsdLogRequest(con, HTTP_STATUS_OK);\n\n      if (httpIsChunked(con->http) && (!con->pipe_pid || con->sent_header > 0))\n      {\n        cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Sending 0-length chunk.\");\n\n\tif (httpWrite2(con->http, \"\", 0) < 0)\n\t{\n\t  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing for error %d (%s)\",\n\t\t\t httpError(con->http), strerror(httpError(con->http)));\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n      }\n\n      cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Flushing write buffer.\");\n      httpFlushWrite(con->http);\n      cupsdLogClient(con, CUPSD_LOG_DEBUG, \"New state is %s\", httpStateString(httpGetState(con->http)));\n    }\n\n    cupsdAddSelect(httpGetFd(con->http), (cupsd_selfunc_t)cupsdReadClient, NULL, con);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Waiting for request.\");\n\n    if (con->file >= 0)\n    {\n      cupsdRemoveSelect(con->file);\n\n      if (con->pipe_pid)\n\tcupsdEndProcess(con->pipe_pid, 0);\n\n      close(con->file);\n      con->file     = -1;\n      con->pipe_pid = 0;\n    }\n\n    if (con->filename)\n    {\n      unlink(con->filename);\n      cupsdClearString(&con->filename);\n    }\n\n    if (con->request)\n    {\n      ippDelete(con->request);\n      con->request = NULL;\n    }\n\n    if (con->response)\n    {\n      ippDelete(con->response);\n      con->response = NULL;\n    }\n\n    cupsdClearString(&con->command);\n    cupsdClearString(&con->options);\n    cupsdClearString(&con->query_string);\n\n    if (!httpGetKeepAlive(con->http))\n    {\n      cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t\t     \"Closing because Keep-Alive is disabled.\");\n      cupsdCloseClient(con);\n      return;\n    }\n    else\n    {\n      cupsArrayRemove(ActiveClients, con);\n      cupsdSetBusyState();\n    }\n  }\n}\n\n\n/*\n * 'check_if_modified()' - Decode an \"If-Modified-Since\" line.\n */\n\nstatic int\t\t\t\t/* O - 1 if modified since */\ncheck_if_modified(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    struct stat    *filestats)\t\t/* I - File information */\n{\n  const char\t*ptr;\t\t\t/* Pointer into field */\n  time_t\tdate;\t\t\t/* Time/date value */\n  off_t\t\tsize;\t\t\t/* Size/length value */\n\n\n  size = 0;\n  date = 0;\n  ptr  = httpGetField(con->http, HTTP_FIELD_IF_MODIFIED_SINCE);\n\n  if (*ptr == '\\0')\n    return (1);\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"check_if_modified: filestats=%p(\" CUPS_LLFMT \", %d)) If-Modified-Since=\\\"%s\\\"\", filestats, CUPS_LLCAST filestats->st_size, (int)filestats->st_mtime, ptr);\n\n  while (*ptr != '\\0')\n  {\n    while (isspace(*ptr) || *ptr == ';')\n      ptr ++;\n\n    if (_cups_strncasecmp(ptr, \"length=\", 7) == 0)\n    {\n      ptr += 7;\n      size = strtoll(ptr, NULL, 10);\n\n      while (isdigit(*ptr))\n        ptr ++;\n    }\n    else if (isalpha(*ptr))\n    {\n      date = httpGetDateTime(ptr);\n      while (*ptr != '\\0' && *ptr != ';')\n        ptr ++;\n    }\n    else\n      ptr ++;\n  }\n\n  return ((size != filestats->st_size && size != 0) ||\n          (date < filestats->st_mtime && date != 0) ||\n\t  (size == 0 && date == 0));\n}\n\n\n/*\n * 'compare_clients()' - Compare two client connections.\n */\n\nstatic int\t\t\t\t/* O - Result of comparison */\ncompare_clients(cupsd_client_t *a,\t/* I - First client */\n                cupsd_client_t *b,\t/* I - Second client */\n                void           *data)\t/* I - User data (not used) */\n{\n  (void)data;\n\n  if (a == b)\n    return (0);\n  else if (a < b)\n    return (-1);\n  else\n    return (1);\n}\n\n\n#ifdef HAVE_SSL\n/*\n * 'cupsd_start_tls()' - Start encryption on a connection.\n */\n\nstatic int\t\t\t\t/* O - 0 on success, -1 on error */\ncupsd_start_tls(cupsd_client_t    *con,\t/* I - Client connection */\n                http_encryption_t e)\t/* I - Encryption mode */\n{\n  if (httpEncryption(con->http, e))\n  {\n    cupsdLogClient(con, CUPSD_LOG_ERROR, \"Unable to encrypt connection: %s\",\n                   cupsLastErrorString());\n    return (-1);\n  }\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Connection now encrypted.\");\n  return (0);\n}\n#endif /* HAVE_SSL */\n\n\n/*\n * 'get_file()' - Get a filename and state info.\n */\n\nstatic char *\t\t\t\t/* O  - Real filename */\nget_file(cupsd_client_t *con,\t\t/* I  - Client connection */\n         struct stat    *filestats,\t/* O  - File information */\n         char           *filename,\t/* IO - Filename buffer */\n         size_t         len)\t\t/* I  - Buffer length */\n{\n  int\t\tstatus;\t\t\t/* Status of filesystem calls */\n  char\t\t*ptr;\t\t\t/* Pointer info filename */\n  size_t\tplen;\t\t\t/* Remaining length after pointer */\n  char\t\tlanguage[7],\t\t/* Language subdirectory, if any */\n\t\tdest[1024];\t\t/* Destination name */\n  int\t\tperm_check = 1;\t\t/* Do permissions check? */\n\n\n /*\n  * Figure out the real filename...\n  */\n\n  language[0] = '\\0';\n\n  if (!strncmp(con->uri, \"/ppd/\", 5) && !strchr(con->uri + 5, '/'))\n  {\n    strlcpy(dest, con->uri + 5, sizeof(dest));\n    ptr = dest + strlen(dest) - 4;\n\n    if (ptr <= dest || strcmp(ptr, \".ppd\"))\n    {\n      cupsdLogClient(con, CUPSD_LOG_INFO, \"Disallowed path \\\"%s\\\".\", con->uri);\n      return (NULL);\n    }\n\n    *ptr = '\\0';\n    if (!cupsdFindPrinter(dest))\n    {\n      cupsdLogClient(con, CUPSD_LOG_INFO, \"No printer \\\"%s\\\" found.\", dest);\n      return (NULL);\n    }\n\n    snprintf(filename, len, \"%s%s\", ServerRoot, con->uri);\n\n    perm_check = 0;\n  }\n  else if (!strncmp(con->uri, \"/icons/\", 7) && !strchr(con->uri + 7, '/'))\n  {\n    strlcpy(dest, con->uri + 7, sizeof(dest));\n    ptr = dest + strlen(dest) - 4;\n\n    if (ptr <= dest || strcmp(ptr, \".png\"))\n    {\n      cupsdLogClient(con, CUPSD_LOG_INFO, \"Disallowed path \\\"%s\\\".\", con->uri);\n      return (NULL);\n    }\n\n    *ptr = '\\0';\n    if (!cupsdFindDest(dest))\n    {\n      cupsdLogClient(con, CUPSD_LOG_INFO, \"No printer \\\"%s\\\" found.\", dest);\n      return (NULL);\n    }\n\n    snprintf(filename, len, \"%s/%s.png\", CacheDir, dest);\n    if (access(filename, F_OK) < 0)\n      snprintf(filename, len, \"%s/images/generic.png\", DocumentRoot);\n\n    perm_check = 0;\n  }\n  else if (!strncmp(con->uri, \"/rss/\", 5) && !strchr(con->uri + 5, '/'))\n    snprintf(filename, len, \"%s/rss/%s\", CacheDir, con->uri + 5);\n  else if (!strcmp(con->uri, \"/admin/conf/cupsd.conf\"))\n  {\n    strlcpy(filename, ConfigurationFile, len);\n\n    perm_check = 0;\n  }\n  else if (!strncmp(con->uri, \"/admin/log/\", 11))\n  {\n    if (!strncmp(con->uri + 11, \"access_log\", 10) && AccessLog[0] == '/')\n      strlcpy(filename, AccessLog, len);\n    else if (!strncmp(con->uri + 11, \"error_log\", 9) && ErrorLog[0] == '/')\n      strlcpy(filename, ErrorLog, len);\n    else if (!strncmp(con->uri + 11, \"page_log\", 8) && PageLog[0] == '/')\n      strlcpy(filename, PageLog, len);\n    else\n      return (NULL);\n\n    perm_check = 0;\n  }\n  else if (con->language)\n  {\n    snprintf(language, sizeof(language), \"/%s\", con->language->language);\n    snprintf(filename, len, \"%s%s%s\", DocumentRoot, language, con->uri);\n  }\n  else\n    snprintf(filename, len, \"%s%s\", DocumentRoot, con->uri);\n\n  if ((ptr = strchr(filename, '?')) != NULL)\n    *ptr = '\\0';\n\n /*\n  * Grab the status for this language; if there isn't a language-specific file\n  * then fallback to the default one...\n  */\n\n  if ((status = lstat(filename, filestats)) != 0 && language[0] &&\n      strncmp(con->uri, \"/icons/\", 7) &&\n      strncmp(con->uri, \"/ppd/\", 5) &&\n      strncmp(con->uri, \"/rss/\", 5) &&\n      strncmp(con->uri, \"/admin/conf/\", 12) &&\n      strncmp(con->uri, \"/admin/log/\", 11))\n  {\n   /*\n    * Drop the country code...\n    */\n\n    language[3] = '\\0';\n    snprintf(filename, len, \"%s%s%s\", DocumentRoot, language, con->uri);\n\n    if ((ptr = strchr(filename, '?')) != NULL)\n      *ptr = '\\0';\n\n    if ((status = lstat(filename, filestats)) != 0)\n    {\n     /*\n      * Drop the language prefix and try the root directory...\n      */\n\n      language[0] = '\\0';\n      snprintf(filename, len, \"%s%s\", DocumentRoot, con->uri);\n\n      if ((ptr = strchr(filename, '?')) != NULL)\n\t*ptr = '\\0';\n\n      status = lstat(filename, filestats);\n    }\n  }\n\n /*\n  * If we've found a symlink, 404 the sucker to avoid disclosing information.\n  */\n\n  if (!status && S_ISLNK(filestats->st_mode))\n  {\n    cupsdLogClient(con, CUPSD_LOG_INFO, \"Symlinks such as \\\"%s\\\" are not allowed.\", filename);\n    return (NULL);\n  }\n\n /*\n  * Similarly, if the file/directory does not have world read permissions, do\n  * not allow access...\n  */\n\n  if (!status && perm_check && !(filestats->st_mode & S_IROTH))\n  {\n    cupsdLogClient(con, CUPSD_LOG_INFO, \"Files/directories such as \\\"%s\\\" must be world-readable.\", filename);\n    return (NULL);\n  }\n\n /*\n  * If we've found a directory, get the index.html file instead...\n  */\n\n  if (!status && S_ISDIR(filestats->st_mode))\n  {\n   /*\n    * Make sure the URI ends with a slash...\n    */\n\n    if (con->uri[strlen(con->uri) - 1] != '/')\n      strlcat(con->uri, \"/\", sizeof(con->uri));\n\n   /*\n    * Find the directory index file, trying every language...\n    */\n\n    do\n    {\n      if (status && language[0])\n      {\n       /*\n        * Try a different language subset...\n\t*/\n\n\tif (language[3])\n\t  language[0] = '\\0';\t\t/* Strip country code */\n\telse\n\t  language[0] = '\\0';\t\t/* Strip language */\n      }\n\n     /*\n      * Look for the index file...\n      */\n\n      snprintf(filename, len, \"%s%s%s\", DocumentRoot, language, con->uri);\n\n      if ((ptr = strchr(filename, '?')) != NULL)\n\t*ptr = '\\0';\n\n      ptr  = filename + strlen(filename);\n      plen = len - (size_t)(ptr - filename);\n\n      strlcpy(ptr, \"index.html\", plen);\n      status = lstat(filename, filestats);\n\n#ifdef HAVE_JAVA\n      if (status)\n      {\n\tstrlcpy(ptr, \"index.class\", plen);\n\tstatus = lstat(filename, filestats);\n      }\n#endif /* HAVE_JAVA */\n\n#ifdef HAVE_PERL\n      if (status)\n      {\n\tstrlcpy(ptr, \"index.pl\", plen);\n\tstatus = lstat(filename, filestats);\n      }\n#endif /* HAVE_PERL */\n\n#ifdef HAVE_PHP\n      if (status)\n      {\n\tstrlcpy(ptr, \"index.php\", plen);\n\tstatus = lstat(filename, filestats);\n      }\n#endif /* HAVE_PHP */\n\n#ifdef HAVE_PYTHON\n      if (status)\n      {\n\tstrlcpy(ptr, \"index.pyc\", plen);\n\tstatus = lstat(filename, filestats);\n      }\n\n      if (status)\n      {\n\tstrlcpy(ptr, \"index.py\", plen);\n\tstatus = lstat(filename, filestats);\n      }\n#endif /* HAVE_PYTHON */\n\n    }\n    while (status && language[0]);\n\n   /*\n    * If we've found a symlink, 404 the sucker to avoid disclosing information.\n    */\n\n    if (!status && S_ISLNK(filestats->st_mode))\n    {\n      cupsdLogClient(con, CUPSD_LOG_INFO, \"Symlinks such as \\\"%s\\\" are not allowed.\", filename);\n      return (NULL);\n    }\n\n   /*\n    * Similarly, if the file/directory does not have world read permissions, do\n    * not allow access...\n    */\n\n    if (!status && perm_check && !(filestats->st_mode & S_IROTH))\n    {\n      cupsdLogClient(con, CUPSD_LOG_INFO, \"Files/directories such as \\\"%s\\\" must be world-readable.\", filename);\n      return (NULL);\n    }\n  }\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"get_file: filestats=%p, filename=%p, len=\" CUPS_LLFMT \", returning \\\"%s\\\".\", filestats, filename, CUPS_LLCAST len, status ? \"(null)\" : filename);\n\n  if (status)\n    return (NULL);\n  else\n    return (filename);\n}\n\n\n/*\n * 'install_cupsd_conf()' - Install a configuration file.\n */\n\nstatic http_status_t\t\t\t/* O - Status */\ninstall_cupsd_conf(cupsd_client_t *con)\t/* I - Connection */\n{\n  char\t\tfilename[1024];\t\t/* Configuration filename */\n  cups_file_t\t*in,\t\t\t/* Input file */\n\t\t*out;\t\t\t/* Output file */\n  char\t\tbuffer[16384];\t\t/* Copy buffer */\n  ssize_t\tbytes;\t\t\t/* Number of bytes */\n\n\n /*\n  * Open the request file...\n  */\n\n  if ((in = cupsFileOpen(con->filename, \"rb\")) == NULL)\n  {\n    cupsdLogClient(con, CUPSD_LOG_ERROR, \"Unable to open request file \\\"%s\\\": %s\",\n                    con->filename, strerror(errno));\n    goto server_error;\n  }\n\n /*\n  * Open the new config file...\n  */\n\n  if ((out = cupsdCreateConfFile(ConfigurationFile, ConfigFilePerm)) == NULL)\n  {\n    cupsFileClose(in);\n    goto server_error;\n  }\n\n  cupsdLogClient(con, CUPSD_LOG_INFO, \"Installing config file \\\"%s\\\"...\",\n                  ConfigurationFile);\n\n /*\n  * Copy from the request to the new config file...\n  */\n\n  while ((bytes = cupsFileRead(in, buffer, sizeof(buffer))) > 0)\n    if (cupsFileWrite(out, buffer, (size_t)bytes) < bytes)\n    {\n      cupsdLogClient(con, CUPSD_LOG_ERROR,\n                      \"Unable to copy to config file \\\"%s\\\": %s\",\n        \t      ConfigurationFile, strerror(errno));\n\n      cupsFileClose(in);\n      cupsFileClose(out);\n\n      snprintf(filename, sizeof(filename), \"%s.N\", ConfigurationFile);\n      cupsdUnlinkOrRemoveFile(filename);\n\n      goto server_error;\n    }\n\n /*\n  * Close the files...\n  */\n\n  cupsFileClose(in);\n\n  if (cupsdCloseCreatedConfFile(out, ConfigurationFile))\n    goto server_error;\n\n /*\n  * Remove the request file...\n  */\n\n  cupsdUnlinkOrRemoveFile(con->filename);\n  cupsdClearString(&con->filename);\n\n /*\n  * Set the NeedReload flag...\n  */\n\n  NeedReload = RELOAD_CUPSD;\n  ReloadTime = time(NULL);\n\n /*\n  * Return that the file was created successfully...\n  */\n\n  return (HTTP_STATUS_CREATED);\n\n /*\n  * Common exit for errors...\n  */\n\n  server_error:\n\n  cupsdUnlinkOrRemoveFile(con->filename);\n  cupsdClearString(&con->filename);\n\n  return (HTTP_STATUS_SERVER_ERROR);\n}\n\n\n/*\n * 'is_cgi()' - Is the resource a CGI script/program?\n */\n\nstatic int\t\t\t\t/* O - 1 = CGI, 0 = file */\nis_cgi(cupsd_client_t *con,\t\t/* I - Client connection */\n       const char     *filename,\t/* I - Real filename */\n       struct stat    *filestats,\t/* I - File information */\n       mime_type_t    *type)\t\t/* I - MIME type */\n{\n  const char\t*options;\t\t/* Options on URL */\n\n\n /*\n  * Get the options, if any...\n  */\n\n  if ((options = strchr(con->uri, '?')) != NULL)\n  {\n    options ++;\n    cupsdSetStringf(&(con->query_string), \"QUERY_STRING=%s\", options);\n  }\n\n /*\n  * Check for known types...\n  */\n\n  if (!type || _cups_strcasecmp(type->super, \"application\"))\n  {\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 0.\", filename, filestats, type ? type->super : \"unknown\", type ? type->type : \"unknown\");\n    return (0);\n  }\n\n  if (!_cups_strcasecmp(type->type, \"x-httpd-cgi\") &&\n      (filestats->st_mode & 0111))\n  {\n   /*\n    * \"application/x-httpd-cgi\" is a CGI script.\n    */\n\n    cupsdSetString(&con->command, filename);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s\", options);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#ifdef HAVE_JAVA\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-java\"))\n  {\n   /*\n    * \"application/x-httpd-java\" is a Java servlet.\n    */\n\n    cupsdSetString(&con->command, CUPS_JAVA);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_JAVA */\n#ifdef HAVE_PERL\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-perl\"))\n  {\n   /*\n    * \"application/x-httpd-perl\" is a Perl page.\n    */\n\n    cupsdSetString(&con->command, CUPS_PERL);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_PERL */\n#ifdef HAVE_PHP\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-php\"))\n  {\n   /*\n    * \"application/x-httpd-php\" is a PHP page.\n    */\n\n    cupsdSetString(&con->command, CUPS_PHP);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_PHP */\n#ifdef HAVE_PYTHON\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-python\"))\n  {\n   /*\n    * \"application/x-httpd-python\" is a Python page.\n    */\n\n    cupsdSetString(&con->command, CUPS_PYTHON);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_PYTHON */\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 0.\", filename, filestats, type->super, type->type);\n  return (0);\n}\n\n\n/*\n * 'is_path_absolute()' - Is a path absolute and free of relative elements (i.e. \"..\").\n */\n\nstatic int\t\t\t\t/* O - 0 if relative, 1 if absolute */\nis_path_absolute(const char *path)\t/* I - Input path */\n{\n /*\n  * Check for a leading slash...\n  */\n\n  if (path[0] != '/')\n    return (0);\n\n /*\n  * Check for \"<\" or quotes in the path and reject since this is probably\n  * someone trying to inject HTML...\n  */\n\n  if (strchr(path, '<') != NULL || strchr(path, '\\\"') != NULL || strchr(path, '\\'') != NULL)\n    return (0);\n\n /*\n  * Check for \"/..\" in the path...\n  */\n\n  while ((path = strstr(path, \"/..\")) != NULL)\n  {\n    if (!path[3] || path[3] == '/')\n      return (0);\n\n    path ++;\n  }\n\n /*\n  * If we haven't found any relative paths, return 1 indicating an\n  * absolute path...\n  */\n\n  return (1);\n}\n\n\n/*\n * 'pipe_command()' - Pipe the output of a command to the remote client.\n */\n\nstatic int\t\t\t\t/* O - Process ID */\npipe_command(cupsd_client_t *con,\t/* I - Client connection */\n             int            infile,\t/* I - Standard input for command */\n             int            *outfile,\t/* O - Standard output for command */\n\t     char           *command,\t/* I - Command to run */\n\t     char           *options,\t/* I - Options for command */\n\t     int            root)\t/* I - Run as root? */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  int\t\tpid;\t\t\t/* Process ID */\n  char\t\t*commptr,\t\t/* Command string pointer */\n\t\tcommch;\t\t\t/* Command string character */\n  char\t\t*uriptr;\t\t/* URI string pointer */\n  int\t\tfds[2];\t\t\t/* Pipe FDs */\n  int\t\targc;\t\t\t/* Number of arguments */\n  int\t\tenvc;\t\t\t/* Number of environment variables */\n  char\t\targbuf[10240],\t\t/* Argument buffer */\n\t\t*argv[100],\t\t/* Argument strings */\n\t\t*envp[MAX_ENV + 20];\t/* Environment variables */\n  char\t\tauth_type[256],\t\t/* AUTH_TYPE environment variable */\n\t\tcontent_length[1024],\t/* CONTENT_LENGTH environment variable */\n\t\tcontent_type[1024],\t/* CONTENT_TYPE environment variable */\n\t\thttp_cookie[32768],\t/* HTTP_COOKIE environment variable */\n\t\thttp_referer[1024],\t/* HTTP_REFERER environment variable */\n\t\thttp_user_agent[1024],\t/* HTTP_USER_AGENT environment variable */\n\t\tlang[1024],\t\t/* LANG environment variable */\n\t\tpath_info[1024],\t/* PATH_INFO environment variable */\n\t\tremote_addr[1024],\t/* REMOTE_ADDR environment variable */\n\t\tremote_host[1024],\t/* REMOTE_HOST environment variable */\n\t\tremote_user[1024],\t/* REMOTE_USER environment variable */\n\t\tscript_filename[1024],\t/* SCRIPT_FILENAME environment variable */\n\t\tscript_name[1024],\t/* SCRIPT_NAME environment variable */\n\t\tserver_name[1024],\t/* SERVER_NAME environment variable */\n\t\tserver_port[1024];\t/* SERVER_PORT environment variable */\n  ipp_attribute_t *attr;\t\t/* attributes-natural-language attribute */\n\n\n /*\n  * Parse a copy of the options string, which is of the form:\n  *\n  *     argument+argument+argument\n  *     ?argument+argument+argument\n  *     param=value&param=value\n  *     ?param=value&param=value\n  *     /name?argument+argument+argument\n  *     /name?param=value&param=value\n  *\n  * If the string contains an \"=\" character after the initial name,\n  * then we treat it as a HTTP GET form request and make a copy of\n  * the remaining string for the environment variable.\n  *\n  * The string is always parsed out as command-line arguments, to\n  * be consistent with Apache...\n  */\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"pipe_command: infile=%d, outfile=%p, command=\\\"%s\\\", options=\\\"%s\\\", root=%d\", infile, outfile, command, options ? options : \"(null)\", root);\n\n  argv[0] = command;\n\n  if (options)\n    strlcpy(argbuf, options, sizeof(argbuf));\n  else\n    argbuf[0] = '\\0';\n\n  if (argbuf[0] == '/')\n  {\n   /*\n    * Found some trailing path information, set PATH_INFO...\n    */\n\n    if ((commptr = strchr(argbuf, '?')) == NULL)\n      commptr = argbuf + strlen(argbuf);\n\n    commch   = *commptr;\n    *commptr = '\\0';\n    snprintf(path_info, sizeof(path_info), \"PATH_INFO=%s\", argbuf);\n    *commptr = commch;\n  }\n  else\n  {\n    commptr      = argbuf;\n    path_info[0] = '\\0';\n\n    if (*commptr == ' ')\n      commptr ++;\n  }\n\n  if (*commptr == '?' && con->operation == HTTP_STATE_GET && !con->query_string)\n  {\n    commptr ++;\n    cupsdSetStringf(&(con->query_string), \"QUERY_STRING=%s\", commptr);\n  }\n\n  argc = 1;\n\n  if (*commptr)\n  {\n    argv[argc ++] = commptr;\n\n    for (; *commptr && argc < 99; commptr ++)\n    {\n     /*\n      * Break arguments whenever we see a + or space...\n      */\n\n      if (*commptr == ' ' || *commptr == '+')\n      {\n\twhile (*commptr == ' ' || *commptr == '+')\n\t  *commptr++ = '\\0';\n\n       /*\n\t* If we don't have a blank string, save it as another argument...\n\t*/\n\n\tif (*commptr)\n\t{\n\t  argv[argc] = commptr;\n\t  argc ++;\n\t}\n\telse\n\t  break;\n      }\n      else if (*commptr == '%' && isxdigit(commptr[1] & 255) &&\n               isxdigit(commptr[2] & 255))\n      {\n       /*\n\t* Convert the %xx notation to the individual character.\n\t*/\n\n\tif (commptr[1] >= '0' && commptr[1] <= '9')\n          *commptr = (char)((commptr[1] - '0') << 4);\n\telse\n          *commptr = (char)((tolower(commptr[1]) - 'a' + 10) << 4);\n\n\tif (commptr[2] >= '0' && commptr[2] <= '9')\n          *commptr |= commptr[2] - '0';\n\telse\n          *commptr |= tolower(commptr[2]) - 'a' + 10;\n\n\t_cups_strcpy(commptr + 1, commptr + 3);\n\n       /*\n\t* Check for a %00 and break if that is the case...\n\t*/\n\n\tif (!*commptr)\n          break;\n      }\n    }\n  }\n\n  argv[argc] = NULL;\n\n /*\n  * Setup the environment variables as needed...\n  */\n\n  if (con->username[0])\n  {\n    snprintf(auth_type, sizeof(auth_type), \"AUTH_TYPE=%s\",\n             httpGetField(con->http, HTTP_FIELD_AUTHORIZATION));\n\n    if ((uriptr = strchr(auth_type + 10, ' ')) != NULL)\n      *uriptr = '\\0';\n  }\n  else\n    auth_type[0] = '\\0';\n\n  if (con->request &&\n      (attr = ippFindAttribute(con->request, \"attributes-natural-language\",\n                               IPP_TAG_LANGUAGE)) != NULL)\n  {\n    switch (strlen(attr->values[0].string.text))\n    {\n      default :\n\t /*\n\t  * This is an unknown or badly formatted language code; use\n\t  * the POSIX locale...\n\t  */\n\n\t  strlcpy(lang, \"LANG=C\", sizeof(lang));\n\t  break;\n\n      case 2 :\n\t /*\n\t  * Just the language code (ll)...\n\t  */\n\n\t  snprintf(lang, sizeof(lang), \"LANG=%s.UTF8\",\n\t\t   attr->values[0].string.text);\n\t  break;\n\n      case 5 :\n\t /*\n\t  * Language and country code (ll-cc)...\n\t  */\n\n\t  snprintf(lang, sizeof(lang), \"LANG=%c%c_%c%c.UTF8\",\n\t\t   attr->values[0].string.text[0],\n\t\t   attr->values[0].string.text[1],\n\t\t   toupper(attr->values[0].string.text[3] & 255),\n\t\t   toupper(attr->values[0].string.text[4] & 255));\n\t  break;\n    }\n  }\n  else if (con->language)\n    snprintf(lang, sizeof(lang), \"LANG=%s.UTF8\", con->language->language);\n  else\n    strlcpy(lang, \"LANG=C\", sizeof(lang));\n\n  strlcpy(remote_addr, \"REMOTE_ADDR=\", sizeof(remote_addr));\n  httpAddrString(httpGetAddress(con->http), remote_addr + 12,\n                 sizeof(remote_addr) - 12);\n\n  snprintf(remote_host, sizeof(remote_host), \"REMOTE_HOST=%s\",\n           httpGetHostname(con->http, NULL, 0));\n\n  snprintf(script_name, sizeof(script_name), \"SCRIPT_NAME=%s\", con->uri);\n  if ((uriptr = strchr(script_name, '?')) != NULL)\n    *uriptr = '\\0';\n\n  snprintf(script_filename, sizeof(script_filename), \"SCRIPT_FILENAME=%s%s\",\n           DocumentRoot, script_name + 12);\n\n  snprintf(server_port, sizeof(server_port), \"SERVER_PORT=%d\", con->serverport);\n\n  if (httpGetField(con->http, HTTP_FIELD_HOST)[0])\n  {\n    char *nameptr;\t\t\t/* Pointer to \":port\" */\n\n    snprintf(server_name, sizeof(server_name), \"SERVER_NAME=%s\",\n\t     httpGetField(con->http, HTTP_FIELD_HOST));\n    if ((nameptr = strrchr(server_name, ':')) != NULL && !strchr(nameptr, ']'))\n      *nameptr = '\\0';\t\t\t/* Strip trailing \":port\" */\n  }\n  else\n    snprintf(server_name, sizeof(server_name), \"SERVER_NAME=%s\",\n\t     con->servername);\n\n  envc = cupsdLoadEnv(envp, (int)(sizeof(envp) / sizeof(envp[0])));\n\n  if (auth_type[0])\n    envp[envc ++] = auth_type;\n\n  envp[envc ++] = lang;\n  envp[envc ++] = \"REDIRECT_STATUS=1\";\n  envp[envc ++] = \"GATEWAY_INTERFACE=CGI/1.1\";\n  envp[envc ++] = server_name;\n  envp[envc ++] = server_port;\n  envp[envc ++] = remote_addr;\n  envp[envc ++] = remote_host;\n  envp[envc ++] = script_name;\n  envp[envc ++] = script_filename;\n\n  if (path_info[0])\n    envp[envc ++] = path_info;\n\n  if (con->username[0])\n  {\n    snprintf(remote_user, sizeof(remote_user), \"REMOTE_USER=%s\", con->username);\n\n    envp[envc ++] = remote_user;\n  }\n\n  if (httpGetVersion(con->http) == HTTP_VERSION_1_1)\n    envp[envc ++] = \"SERVER_PROTOCOL=HTTP/1.1\";\n  else if (httpGetVersion(con->http) == HTTP_VERSION_1_0)\n    envp[envc ++] = \"SERVER_PROTOCOL=HTTP/1.0\";\n  else\n    envp[envc ++] = \"SERVER_PROTOCOL=HTTP/0.9\";\n\n  if (httpGetCookie(con->http))\n  {\n    snprintf(http_cookie, sizeof(http_cookie), \"HTTP_COOKIE=%s\",\n             httpGetCookie(con->http));\n    envp[envc ++] = http_cookie;\n  }\n\n  if (httpGetField(con->http, HTTP_FIELD_USER_AGENT)[0])\n  {\n    snprintf(http_user_agent, sizeof(http_user_agent), \"HTTP_USER_AGENT=%s\",\n             httpGetField(con->http, HTTP_FIELD_USER_AGENT));\n    envp[envc ++] = http_user_agent;\n  }\n\n  if (httpGetField(con->http, HTTP_FIELD_REFERER)[0])\n  {\n    snprintf(http_referer, sizeof(http_referer), \"HTTP_REFERER=%s\",\n             httpGetField(con->http, HTTP_FIELD_REFERER));\n    envp[envc ++] = http_referer;\n  }\n\n  if (con->operation == HTTP_STATE_GET)\n  {\n    envp[envc ++] = \"REQUEST_METHOD=GET\";\n\n    if (con->query_string)\n    {\n     /*\n      * Add GET form variables after ?...\n      */\n\n      envp[envc ++] = con->query_string;\n    }\n    else\n      envp[envc ++] = \"QUERY_STRING=\";\n  }\n  else\n  {\n    sprintf(content_length, \"CONTENT_LENGTH=\" CUPS_LLFMT,\n            CUPS_LLCAST con->bytes);\n    snprintf(content_type, sizeof(content_type), \"CONTENT_TYPE=%s\",\n             httpGetField(con->http, HTTP_FIELD_CONTENT_TYPE));\n\n    envp[envc ++] = \"REQUEST_METHOD=POST\";\n    envp[envc ++] = content_length;\n    envp[envc ++] = content_type;\n  }\n\n /*\n  * Tell the CGI if we are using encryption...\n  */\n\n  if (httpIsEncrypted(con->http))\n    envp[envc ++] = \"HTTPS=ON\";\n\n /*\n  * Terminate the environment array...\n  */\n\n  envp[envc] = NULL;\n\n  if (LogLevel >= CUPSD_LOG_DEBUG)\n  {\n    for (i = 0; i < argc; i ++)\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n                      \"[CGI] argv[%d] = \\\"%s\\\"\", i, argv[i]);\n    for (i = 0; i < envc; i ++)\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n                      \"[CGI] envp[%d] = \\\"%s\\\"\", i, envp[i]);\n  }\n\n /*\n  * Create a pipe for the output...\n  */\n\n  if (cupsdOpenPipe(fds))\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"[CGI] Unable to create pipe for %s - %s\",\n                    argv[0], strerror(errno));\n    return (0);\n  }\n\n /*\n  * Then execute the command...\n  */\n\n  if (cupsdStartProcess(command, argv, envp, infile, fds[1], CGIPipes[1],\n\t\t\t-1, -1, root, DefaultProfile, NULL, &pid) < 0)\n  {\n   /*\n    * Error - can't fork!\n    */\n\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"[CGI] Unable to start %s - %s\", argv[0],\n                    strerror(errno));\n\n    cupsdClosePipe(fds);\n    pid = 0;\n  }\n  else\n  {\n   /*\n    * Fork successful - return the PID...\n    */\n\n    if (con->username[0])\n      cupsdAddCert(pid, con->username, con->type);\n\n    cupsdLogMessage(CUPSD_LOG_DEBUG, \"[CGI] Started %s (PID %d)\", command, pid);\n\n    *outfile = fds[0];\n    close(fds[1]);\n  }\n\n  return (pid);\n}\n\n\n/*\n * 'valid_host()' - Is the Host: field valid?\n */\n\nstatic int\t\t\t\t/* O - 1 if valid, 0 if not */\nvalid_host(cupsd_client_t *con)\t\t/* I - Client connection */\n{\n  cupsd_alias_t\t*a;\t\t\t/* Current alias */\n  cupsd_netif_t\t*netif;\t\t\t/* Current network interface */\n  const char\t*end;\t\t\t/* End character */\n  char\t\t*ptr;\t\t\t/* Pointer into host value */\n\n\n /*\n  * Copy the Host: header for later use...\n  */\n\n  strlcpy(con->clientname, httpGetField(con->http, HTTP_FIELD_HOST),\n          sizeof(con->clientname));\n  if ((ptr = strrchr(con->clientname, ':')) != NULL && !strchr(ptr, ']'))\n  {\n    *ptr++ = '\\0';\n    con->clientport = atoi(ptr);\n  }\n  else\n    con->clientport = con->serverport;\n\n /*\n  * Then validate...\n  */\n\n  if (httpAddrLocalhost(httpGetAddress(con->http)))\n  {\n   /*\n    * Only allow \"localhost\" or the equivalent IPv4 or IPv6 numerical\n    * addresses when accessing CUPS via the loopback interface...\n    */\n\n    return (!_cups_strcasecmp(con->clientname, \"localhost\") ||\n\t    !_cups_strcasecmp(con->clientname, \"localhost.\") ||\n#ifdef __linux\n\t    !_cups_strcasecmp(con->clientname, \"localhost.localdomain\") ||\n#endif /* __linux */\n            !strcmp(con->clientname, \"127.0.0.1\") ||\n\t    !strcmp(con->clientname, \"[::1]\"));\n  }\n\n#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)\n /*\n  * Check if the hostname is something.local (Bonjour); if so, allow it.\n  */\n\n  if ((end = strrchr(con->clientname, '.')) != NULL && end > con->clientname &&\n      !end[1])\n  {\n   /*\n    * \".\" on end, work back to second-to-last \".\"...\n    */\n\n    for (end --; end > con->clientname && *end != '.'; end --);\n  }\n\n  if (end && (!_cups_strcasecmp(end, \".local\") ||\n\t      !_cups_strcasecmp(end, \".local.\")))\n    return (1);\n#endif /* HAVE_DNSSD || HAVE_AVAHI */\n\n /*\n  * Check if the hostname is an IP address...\n  */\n\n  if (isdigit(con->clientname[0] & 255) || con->clientname[0] == '[')\n  {\n   /*\n    * Possible IPv4/IPv6 address...\n    */\n\n    http_addrlist_t *addrlist;\t\t/* List of addresses */\n\n\n    if ((addrlist = httpAddrGetList(con->clientname, AF_UNSPEC, NULL)) != NULL)\n    {\n     /*\n      * Good IPv4/IPv6 address...\n      */\n\n      httpAddrFreeList(addrlist);\n      return (1);\n    }\n  }\n\n /*\n  * Check for (alias) name matches...\n  */\n\n  for (a = (cupsd_alias_t *)cupsArrayFirst(ServerAlias);\n       a;\n       a = (cupsd_alias_t *)cupsArrayNext(ServerAlias))\n  {\n   /*\n    * \"ServerAlias *\" allows all host values through...\n    */\n\n    if (!strcmp(a->name, \"*\"))\n      return (1);\n\n    if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))\n    {\n     /*\n      * Prefix matches; check the character at the end - it must be \".\" or nul.\n      */\n\n      end = con->clientname + a->namelen;\n\n      if (!*end || (*end == '.' && !end[1]))\n        return (1);\n    }\n  }\n\n#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)\n  for (a = (cupsd_alias_t *)cupsArrayFirst(DNSSDAlias);\n       a;\n       a = (cupsd_alias_t *)cupsArrayNext(DNSSDAlias))\n  {\n   /*\n    * \"ServerAlias *\" allows all host values through...\n    */\n\n    if (!strcmp(a->name, \"*\"))\n      return (1);\n\n    if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))\n    {\n     /*\n      * Prefix matches; check the character at the end - it must be \".\" or nul.\n      */\n\n      end = con->clientname + a->namelen;\n\n      if (!*end || (*end == '.' && !end[1]))\n        return (1);\n    }\n  }\n#endif /* HAVE_DNSSD || HAVE_AVAHI */\n\n /*\n  * Check for interface hostname matches...\n  */\n\n  for (netif = (cupsd_netif_t *)cupsArrayFirst(NetIFList);\n       netif;\n       netif = (cupsd_netif_t *)cupsArrayNext(NetIFList))\n  {\n    if (!_cups_strncasecmp(con->clientname, netif->hostname, netif->hostlen))\n    {\n     /*\n      * Prefix matches; check the character at the end - it must be \".\" or nul.\n      */\n\n      end = con->clientname + netif->hostlen;\n\n      if (!*end || (*end == '.' && !end[1]))\n        return (1);\n    }\n  }\n\n  return (0);\n}\n\n\n/*\n * 'write_file()' - Send a file via HTTP.\n */\n\nstatic int\t\t\t\t/* O - 0 on failure, 1 on success */\nwrite_file(cupsd_client_t *con,\t\t/* I - Client connection */\n           http_status_t  code,\t\t/* I - HTTP status */\n\t   char           *filename,\t/* I - Filename */\n\t   char           *type,\t/* I - File type */\n\t   struct stat    *filestats)\t/* O - File information */\n{\n  con->file = open(filename, O_RDONLY);\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"write_file: code=%d, filename=\\\"%s\\\" (%d), type=\\\"%s\\\", filestats=%p.\", code, filename, con->file, type ? type : \"(null)\", filestats);\n\n  if (con->file < 0)\n    return (0);\n\n  fcntl(con->file, F_SETFD, fcntl(con->file, F_GETFD) | FD_CLOEXEC);\n\n  con->pipe_pid    = 0;\n  con->sent_header = 1;\n\n  httpClearFields(con->http);\n\n  httpSetLength(con->http, (size_t)filestats->st_size);\n\n  httpSetField(con->http, HTTP_FIELD_LAST_MODIFIED,\n\t       httpGetDateString(filestats->st_mtime));\n\n  if (!cupsdSendHeader(con, code, type, CUPSD_AUTH_NONE))\n    return (0);\n\n  cupsdAddSelect(httpGetFd(con->http), NULL, (cupsd_selfunc_t)cupsdWriteClient, con);\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Sending file.\");\n\n  return (1);\n}\n\n\n/*\n * 'write_pipe()' - Flag that data is available on the CGI pipe.\n */\n\nstatic void\nwrite_pipe(cupsd_client_t *con)\t\t/* I - Client connection */\n{\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"write_pipe: CGI output on fd %d.\", con->file);\n\n  con->file_ready = 1;\n\n  cupsdRemoveSelect(con->file);\n  cupsdAddSelect(httpGetFd(con->http), NULL, (cupsd_selfunc_t)cupsdWriteClient, con);\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"CGI data ready to be sent.\");\n}\n"], "fixing_code": ["/*\n * Client routines for the CUPS scheduler.\n *\n * Copyright 2007-2015 by Apple Inc.\n * Copyright 1997-2007 by Easy Software Products, all rights reserved.\n *\n * This file contains Kerberos support code, copyright 2006 by\n * Jelmer Vernooij.\n *\n * These coded instructions, statements, and computer programs are the\n * property of Apple Inc. and are protected by Federal copyright\n * law.  Distribution and use rights are outlined in the file \"LICENSE.txt\"\n * which should have been included with this file.  If this file is\n * file is missing or damaged, see the license at \"http://www.cups.org/\".\n */\n\n/*\n * Include necessary headers...\n */\n\n#define _CUPS_NO_DEPRECATED\n#define _HTTP_NO_PRIVATE\n#include \"cupsd.h\"\n\n#ifdef __APPLE__\n#  include <libproc.h>\n#endif /* __APPLE__ */\n#ifdef HAVE_TCPD_H\n#  include <tcpd.h>\n#endif /* HAVE_TCPD_H */\n\n\n/*\n * Local functions...\n */\n\nstatic int\t\tcheck_if_modified(cupsd_client_t *con,\n\t\t\t                  struct stat *filestats);\nstatic int\t\tcompare_clients(cupsd_client_t *a, cupsd_client_t *b,\n\t\t\t                void *data);\n#ifdef HAVE_SSL\nstatic int\t\tcupsd_start_tls(cupsd_client_t *con, http_encryption_t e);\n#endif /* HAVE_SSL */\nstatic char\t\t*get_file(cupsd_client_t *con, struct stat *filestats,\n\t\t\t          char *filename, size_t len);\nstatic http_status_t\tinstall_cupsd_conf(cupsd_client_t *con);\nstatic int\t\tis_cgi(cupsd_client_t *con, const char *filename,\n\t\t               struct stat *filestats, mime_type_t *type);\nstatic int\t\tis_path_absolute(const char *path);\nstatic int\t\tpipe_command(cupsd_client_t *con, int infile, int *outfile,\n\t\t\t             char *command, char *options, int root);\nstatic int\t\tvalid_host(cupsd_client_t *con);\nstatic int\t\twrite_file(cupsd_client_t *con, http_status_t code,\n\t\t        \t   char *filename, char *type,\n\t\t\t\t   struct stat *filestats);\nstatic void\t\twrite_pipe(cupsd_client_t *con);\n\n\n/*\n * 'cupsdAcceptClient()' - Accept a new client.\n */\n\nvoid\ncupsdAcceptClient(cupsd_listener_t *lis)/* I - Listener socket */\n{\n  const char\t\t*hostname;\t/* Hostname of client */\n  char\t\t\tname[256];\t/* Hostname of client */\n  int\t\t\tcount;\t\t/* Count of connections on a host */\n  cupsd_client_t\t*con,\t\t/* New client pointer */\n\t\t\t*tempcon;\t/* Temporary client pointer */\n  socklen_t\t\taddrlen;\t/* Length of address */\n  http_addr_t\t\ttemp;\t\t/* Temporary address variable */\n  static time_t\t\tlast_dos = 0;\t/* Time of last DoS attack */\n#ifdef HAVE_TCPD_H\n  struct request_info\twrap_req;\t/* TCP wrappers request information */\n#endif /* HAVE_TCPD_H */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cupsdAcceptClient(lis=%p(%d)) Clients=%d\", lis, lis->fd, cupsArrayCount(Clients));\n\n /*\n  * Make sure we don't have a full set of clients already...\n  */\n\n  if (cupsArrayCount(Clients) == MaxClients)\n    return;\n\n /*\n  * Get a pointer to the next available client...\n  */\n\n  if (!Clients)\n    Clients = cupsArrayNew(NULL, NULL);\n\n  if (!Clients)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to allocate memory for clients array!\");\n    cupsdPauseListening();\n    return;\n  }\n\n  if (!ActiveClients)\n    ActiveClients = cupsArrayNew((cups_array_func_t)compare_clients, NULL);\n\n  if (!ActiveClients)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to allocate memory for active clients array!\");\n    cupsdPauseListening();\n    return;\n  }\n\n  if ((con = calloc(1, sizeof(cupsd_client_t))) == NULL)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"Unable to allocate memory for client!\");\n    cupsdPauseListening();\n    return;\n  }\n\n /*\n  * Accept the client and get the remote address...\n  */\n\n  con->number = ++ LastClientNumber;\n  con->file   = -1;\n\n  if ((con->http = httpAcceptConnection(lis->fd, 0)) == NULL)\n  {\n    if (errno == ENFILE || errno == EMFILE)\n      cupsdPauseListening();\n\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"Unable to accept client connection - %s.\",\n                    strerror(errno));\n    free(con);\n\n    return;\n  }\n\n /*\n  * Save the connected address and port number...\n  */\n\n  addrlen = sizeof(con->clientaddr);\n\n  if (getsockname(httpGetFd(con->http), (struct sockaddr *)&con->clientaddr, &addrlen) || addrlen == 0)\n    con->clientaddr = lis->address;\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Server address is \\\"%s\\\".\", httpAddrString(&con->clientaddr, name, sizeof(name)));\n\n /*\n  * Check the number of clients on the same address...\n  */\n\n  for (count = 0, tempcon = (cupsd_client_t *)cupsArrayFirst(Clients);\n       tempcon;\n       tempcon = (cupsd_client_t *)cupsArrayNext(Clients))\n    if (httpAddrEqual(httpGetAddress(tempcon->http), httpGetAddress(con->http)))\n    {\n      count ++;\n      if (count >= MaxClientsPerHost)\n\tbreak;\n    }\n\n  if (count >= MaxClientsPerHost)\n  {\n    if ((time(NULL) - last_dos) >= 60)\n    {\n      last_dos = time(NULL);\n      cupsdLogMessage(CUPSD_LOG_WARN,\n                      \"Possible DoS attack - more than %d clients connecting \"\n\t\t      \"from %s.\",\n\t              MaxClientsPerHost,\n\t\t      httpGetHostname(con->http, name, sizeof(name)));\n    }\n\n    httpClose(con->http);\n    free(con);\n    return;\n  }\n\n /*\n  * Get the hostname or format the IP address as needed...\n  */\n\n  if (HostNameLookups)\n    hostname = httpResolveHostname(con->http, NULL, 0);\n  else\n    hostname = httpGetHostname(con->http, NULL, 0);\n\n  if (hostname == NULL && HostNameLookups == 2)\n  {\n   /*\n    * Can't have an unresolved IP address with double-lookups enabled...\n    */\n\n    httpClose(con->http);\n\n    cupsdLogClient(con, CUPSD_LOG_WARN,\n                    \"Name lookup failed - connection from %s closed!\",\n                    httpGetHostname(con->http, NULL, 0));\n\n    free(con);\n    return;\n  }\n\n  if (HostNameLookups == 2)\n  {\n   /*\n    * Do double lookups as needed...\n    */\n\n    http_addrlist_t\t*addrlist,\t/* List of addresses */\n\t\t\t*addr;\t\t/* Current address */\n\n    if ((addrlist = httpAddrGetList(hostname, AF_UNSPEC, NULL)) != NULL)\n    {\n     /*\n      * See if the hostname maps to the same IP address...\n      */\n\n      for (addr = addrlist; addr; addr = addr->next)\n        if (httpAddrEqual(httpGetAddress(con->http), &(addr->addr)))\n          break;\n    }\n    else\n      addr = NULL;\n\n    httpAddrFreeList(addrlist);\n\n    if (!addr)\n    {\n     /*\n      * Can't have a hostname that doesn't resolve to the same IP address\n      * with double-lookups enabled...\n      */\n\n      httpClose(con->http);\n\n      cupsdLogClient(con, CUPSD_LOG_WARN,\n                      \"IP lookup failed - connection from %s closed!\",\n                      httpGetHostname(con->http, NULL, 0));\n      free(con);\n      return;\n    }\n  }\n\n#ifdef HAVE_TCPD_H\n /*\n  * See if the connection is denied by TCP wrappers...\n  */\n\n  request_init(&wrap_req, RQ_DAEMON, \"cupsd\", RQ_FILE, httpGetFd(con->http),\n               NULL);\n  fromhost(&wrap_req);\n\n  if (!hosts_access(&wrap_req))\n  {\n    httpClose(con->http);\n\n    cupsdLogClient(con, CUPSD_LOG_WARN,\n                    \"Connection from %s refused by /etc/hosts.allow and \"\n\t\t    \"/etc/hosts.deny rules.\", httpGetHostname(con->http, NULL, 0));\n    free(con);\n    return;\n  }\n#endif /* HAVE_TCPD_H */\n\n#ifdef AF_LOCAL\n  if (httpAddrFamily(httpGetAddress(con->http)) == AF_LOCAL)\n  {\n#  ifdef __APPLE__\n    socklen_t\tpeersize;\t\t/* Size of peer credentials */\n    pid_t\tpeerpid;\t\t/* Peer process ID */\n    char\tpeername[256];\t\t/* Name of process */\n\n    peersize = sizeof(peerpid);\n    if (!getsockopt(httpGetFd(con->http), SOL_LOCAL, LOCAL_PEERPID, &peerpid,\n                    &peersize))\n    {\n      if (!proc_name((int)peerpid, peername, sizeof(peername)))\n\tcupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t               \"Accepted from %s (Domain ???[%d])\",\n                       httpGetHostname(con->http, NULL, 0), (int)peerpid);\n      else\n\tcupsdLogClient(con, CUPSD_LOG_DEBUG,\n                       \"Accepted from %s (Domain %s[%d])\",\n                       httpGetHostname(con->http, NULL, 0), peername, (int)peerpid);\n    }\n    else\n#  endif /* __APPLE__ */\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Accepted from %s (Domain)\",\n                   httpGetHostname(con->http, NULL, 0));\n  }\n  else\n#endif /* AF_LOCAL */\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Accepted from %s:%d (IPv%d)\",\n                 httpGetHostname(con->http, NULL, 0),\n\t\t httpAddrPort(httpGetAddress(con->http)),\n\t\t httpAddrFamily(httpGetAddress(con->http)) == AF_INET ? 4 : 6);\n\n /*\n  * Get the local address the client connected to...\n  */\n\n  addrlen = sizeof(temp);\n  if (getsockname(httpGetFd(con->http), (struct sockaddr *)&temp, &addrlen))\n  {\n    cupsdLogClient(con, CUPSD_LOG_ERROR, \"Unable to get local address - %s\",\n                   strerror(errno));\n\n    strlcpy(con->servername, \"localhost\", sizeof(con->servername));\n    con->serverport = LocalPort;\n  }\n#ifdef AF_LOCAL\n  else if (httpAddrFamily(&temp) == AF_LOCAL)\n  {\n    strlcpy(con->servername, \"localhost\", sizeof(con->servername));\n    con->serverport = LocalPort;\n  }\n#endif /* AF_LOCAL */\n  else\n  {\n    if (httpAddrLocalhost(&temp))\n      strlcpy(con->servername, \"localhost\", sizeof(con->servername));\n    else if (HostNameLookups)\n      httpAddrLookup(&temp, con->servername, sizeof(con->servername));\n    else\n      httpAddrString(&temp, con->servername, sizeof(con->servername));\n\n    con->serverport = httpAddrPort(&(lis->address));\n  }\n\n /*\n  * Add the connection to the array of active clients...\n  */\n\n  cupsArrayAdd(Clients, con);\n\n /*\n  * Add the socket to the server select.\n  */\n\n  cupsdAddSelect(httpGetFd(con->http), (cupsd_selfunc_t)cupsdReadClient, NULL,\n                 con);\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Waiting for request.\");\n\n /*\n  * Temporarily suspend accept()'s until we lose a client...\n  */\n\n  if (cupsArrayCount(Clients) == MaxClients)\n    cupsdPauseListening();\n\n#ifdef HAVE_SSL\n /*\n  * See if we are connecting on a secure port...\n  */\n\n  if (lis->encryption == HTTP_ENCRYPTION_ALWAYS)\n  {\n   /*\n    * https connection; go secure...\n    */\n\n    if (cupsd_start_tls(con, HTTP_ENCRYPTION_ALWAYS))\n      cupsdCloseClient(con);\n  }\n  else\n    con->auto_ssl = 1;\n#endif /* HAVE_SSL */\n}\n\n\n/*\n * 'cupsdCloseAllClients()' - Close all remote clients immediately.\n */\n\nvoid\ncupsdCloseAllClients(void)\n{\n  cupsd_client_t\t*con;\t\t/* Current client */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cupsdCloseAllClients() Clients=%d\", cupsArrayCount(Clients));\n\n  for (con = (cupsd_client_t *)cupsArrayFirst(Clients);\n       con;\n       con = (cupsd_client_t *)cupsArrayNext(Clients))\n    if (cupsdCloseClient(con))\n      cupsdCloseClient(con);\n}\n\n\n/*\n * 'cupsdCloseClient()' - Close a remote client.\n */\n\nint\t\t\t\t\t/* O - 1 if partial close, 0 if fully closed */\ncupsdCloseClient(cupsd_client_t *con)\t/* I - Client to close */\n{\n  int\t\tpartial;\t\t/* Do partial close for SSL? */\n\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing connection.\");\n\n /*\n  * Flush pending writes before closing...\n  */\n\n  httpFlushWrite(con->http);\n\n  partial = 0;\n\n  if (con->pipe_pid != 0)\n  {\n   /*\n    * Stop any CGI process...\n    */\n\n    cupsdEndProcess(con->pipe_pid, 1);\n    con->pipe_pid = 0;\n  }\n\n  if (con->file >= 0)\n  {\n    cupsdRemoveSelect(con->file);\n\n    close(con->file);\n    con->file = -1;\n  }\n\n /*\n  * Close the socket and clear the file from the input set for select()...\n  */\n\n  if (httpGetFd(con->http) >= 0)\n  {\n    cupsArrayRemove(ActiveClients, con);\n    cupsdSetBusyState();\n\n#ifdef HAVE_SSL\n   /*\n    * Shutdown encryption as needed...\n    */\n\n    if (httpIsEncrypted(con->http))\n      partial = 1;\n#endif /* HAVE_SSL */\n\n    if (partial)\n    {\n     /*\n      * Only do a partial close so that the encrypted client gets everything.\n      */\n\n      httpShutdown(con->http);\n      cupsdAddSelect(httpGetFd(con->http), (cupsd_selfunc_t)cupsdReadClient,\n                     NULL, con);\n\n      cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Waiting for socket close.\");\n    }\n    else\n    {\n     /*\n      * Shut the socket down fully...\n      */\n\n      cupsdRemoveSelect(httpGetFd(con->http));\n      httpClose(con->http);\n      con->http = NULL;\n    }\n  }\n\n  if (!partial)\n  {\n   /*\n    * Free memory...\n    */\n\n    cupsdRemoveSelect(httpGetFd(con->http));\n\n    httpClose(con->http);\n\n    if (con->filename)\n    {\n      unlink(con->filename);\n      cupsdClearString(&con->filename);\n    }\n\n    cupsdClearString(&con->command);\n    cupsdClearString(&con->options);\n    cupsdClearString(&con->query_string);\n\n    if (con->request)\n    {\n      ippDelete(con->request);\n      con->request = NULL;\n    }\n\n    if (con->response)\n    {\n      ippDelete(con->response);\n      con->response = NULL;\n    }\n\n    if (con->language)\n    {\n      cupsLangFree(con->language);\n      con->language = NULL;\n    }\n\n#ifdef HAVE_AUTHORIZATION_H\n    if (con->authref)\n    {\n      AuthorizationFree(con->authref, kAuthorizationFlagDefaults);\n      con->authref = NULL;\n    }\n#endif /* HAVE_AUTHORIZATION_H */\n\n   /*\n    * Re-enable new client connections if we are going back under the\n    * limit...\n    */\n\n    if (cupsArrayCount(Clients) == MaxClients)\n      cupsdResumeListening();\n\n   /*\n    * Compact the list of clients as necessary...\n    */\n\n    cupsArrayRemove(Clients, con);\n\n    free(con);\n  }\n\n  return (partial);\n}\n\n\n/*\n * 'cupsdReadClient()' - Read data from a client.\n */\n\nvoid\ncupsdReadClient(cupsd_client_t *con)\t/* I - Client to read from */\n{\n  char\t\t\tline[32768],\t/* Line from client... */\n\t\t\tlocale[64],\t/* Locale */\n\t\t\t*ptr;\t\t/* Pointer into strings */\n  http_status_t\t\tstatus;\t\t/* Transfer status */\n  ipp_state_t\t\tipp_state;\t/* State of IPP transfer */\n  int\t\t\tbytes;\t\t/* Number of bytes to POST */\n  char\t\t\t*filename;\t/* Name of file for GET/HEAD */\n  char\t\t\tbuf[1024];\t/* Buffer for real filename */\n  struct stat\t\tfilestats;\t/* File information */\n  mime_type_t\t\t*type;\t\t/* MIME type of file */\n  cupsd_printer_t\t*p;\t\t/* Printer */\n  static unsigned\trequest_id = 0;\t/* Request ID for temp files */\n\n\n  status = HTTP_STATUS_CONTINUE;\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"cupsdReadClient: error=%d, used=%d, state=%s, data_encoding=HTTP_ENCODING_%s, data_remaining=\" CUPS_LLFMT \", request=%p(%s), file=%d\", httpError(con->http), (int)httpGetReady(con->http), httpStateString(httpGetState(con->http)), httpIsChunked(con->http) ? \"CHUNKED\" : \"LENGTH\", CUPS_LLCAST httpGetRemaining(con->http), con->request, con->request ? ippStateString(ippGetState(con->request)) : \"\", con->file);\n\n  if (httpGetState(con->http) == HTTP_STATE_GET_SEND ||\n      httpGetState(con->http) == HTTP_STATE_POST_SEND ||\n      httpGetState(con->http) == HTTP_STATE_STATUS)\n  {\n   /*\n    * If we get called in the wrong state, then something went wrong with the\n    * connection and we need to shut it down...\n    */\n\n    if (!httpGetReady(con->http) && recv(httpGetFd(con->http), buf, 1, MSG_PEEK) < 1)\n    {\n     /*\n      * Connection closed...\n      */\n\n      cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing on EOF.\");\n      cupsdCloseClient(con);\n      return;\n    }\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing on unexpected HTTP read state %s.\", httpStateString(httpGetState(con->http)));\n    cupsdCloseClient(con);\n    return;\n  }\n\n#ifdef HAVE_SSL\n  if (con->auto_ssl)\n  {\n   /*\n    * Automatically check for a SSL/TLS handshake...\n    */\n\n    con->auto_ssl = 0;\n\n    if (recv(httpGetFd(con->http), buf, 1, MSG_PEEK) == 1 &&\n        (!buf[0] || !strchr(\"DGHOPT\", buf[0])))\n    {\n     /*\n      * Encrypt this connection...\n      */\n\n      cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"Saw first byte %02X, auto-negotiating SSL/TLS session.\", buf[0] & 255);\n\n      if (cupsd_start_tls(con, HTTP_ENCRYPTION_ALWAYS))\n        cupsdCloseClient(con);\n\n      return;\n    }\n  }\n#endif /* HAVE_SSL */\n\n  switch (httpGetState(con->http))\n  {\n    case HTTP_STATE_WAITING :\n       /*\n        * See if we've received a request line...\n\t*/\n\n        con->operation = httpReadRequest(con->http, con->uri, sizeof(con->uri));\n        if (con->operation == HTTP_STATE_ERROR ||\n\t    con->operation == HTTP_STATE_UNKNOWN_METHOD ||\n\t    con->operation == HTTP_STATE_UNKNOWN_VERSION)\n\t{\n\t  if (httpError(con->http))\n\t    cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t\t\t   \"HTTP_STATE_WAITING Closing for error %d (%s)\",\n\t\t\t   httpError(con->http), strerror(httpError(con->http)));\n\t  else\n\t    cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t                   \"HTTP_STATE_WAITING Closing on error: %s\",\n\t\t\t   cupsLastErrorString());\n\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n\n       /*\n        * Ignore blank request lines...\n\t*/\n\n        if (con->operation == HTTP_STATE_WAITING)\n\t  break;\n\n       /*\n        * Clear other state variables...\n\t*/\n\n\tcon->bytes       = 0;\n\tcon->file        = -1;\n\tcon->file_ready  = 0;\n\tcon->pipe_pid    = 0;\n\tcon->username[0] = '\\0';\n\tcon->password[0] = '\\0';\n\n\tcupsdClearString(&con->command);\n\tcupsdClearString(&con->options);\n\tcupsdClearString(&con->query_string);\n\n\tif (con->request)\n\t{\n\t  ippDelete(con->request);\n\t  con->request = NULL;\n\t}\n\n\tif (con->response)\n\t{\n\t  ippDelete(con->response);\n\t  con->response = NULL;\n\t}\n\n\tif (con->language)\n\t{\n\t  cupsLangFree(con->language);\n\t  con->language = NULL;\n\t}\n\n#ifdef HAVE_GSSAPI\n        con->have_gss = 0;\n\tcon->gss_uid  = 0;\n#endif /* HAVE_GSSAPI */\n\n       /*\n        * Handle full URLs in the request line...\n\t*/\n\n        if (strcmp(con->uri, \"*\"))\n\t{\n\t  char\tscheme[HTTP_MAX_URI],\t/* Method/scheme */\n\t\tuserpass[HTTP_MAX_URI],\t/* Username:password */\n\t\thostname[HTTP_MAX_URI],\t/* Hostname */\n\t\tresource[HTTP_MAX_URI];\t/* Resource path */\n          int\tport;\t\t\t/* Port number */\n\n         /*\n\t  * Separate the URI into its components...\n\t  */\n\n          if (httpSeparateURI(HTTP_URI_CODING_MOST, con->uri,\n\t                      scheme, sizeof(scheme),\n\t                      userpass, sizeof(userpass),\n\t\t\t      hostname, sizeof(hostname), &port,\n\t\t\t      resource, sizeof(resource)) < HTTP_URI_STATUS_OK)\n          {\n\t    cupsdLogClient(con, CUPSD_LOG_ERROR, \"Bad URI \\\"%s\\\" in request.\",\n                           con->uri);\n\t    cupsdSendError(con, HTTP_STATUS_METHOD_NOT_ALLOWED, CUPSD_AUTH_NONE);\n\t    cupsdCloseClient(con);\n\t    return;\n\t  }\n\n\t /*\n\t  * Only allow URIs with the servername, localhost, or an IP\n\t  * address...\n\t  */\n\n\t  if (strcmp(scheme, \"file\") &&\n\t      _cups_strcasecmp(hostname, ServerName) &&\n\t      _cups_strcasecmp(hostname, \"localhost\") &&\n\t      !cupsArrayFind(ServerAlias, hostname) &&\n\t      !isdigit(hostname[0]) && hostname[0] != '[')\n\t  {\n\t   /*\n\t    * Nope, we don't do proxies...\n\t    */\n\n\t    cupsdLogClient(con, CUPSD_LOG_ERROR, \"Bad URI \\\"%s\\\" in request.\",\n                           con->uri);\n\t    cupsdSendError(con, HTTP_STATUS_METHOD_NOT_ALLOWED, CUPSD_AUTH_NONE);\n\t    cupsdCloseClient(con);\n\t    return;\n\t  }\n\n         /*\n\t  * Copy the resource portion back into the URI; both resource and\n\t  * con->uri are HTTP_MAX_URI bytes in size...\n\t  */\n\n          strlcpy(con->uri, resource, sizeof(con->uri));\n\t}\n\n       /*\n        * Process the request...\n\t*/\n\n        gettimeofday(&(con->start), NULL);\n\n        cupsdLogClient(con, CUPSD_LOG_DEBUG, \"%s %s HTTP/%d.%d\",\n\t               httpStateString(con->operation) + 11, con->uri,\n\t\t       httpGetVersion(con->http) / 100,\n                       httpGetVersion(con->http) % 100);\n\n        if (!cupsArrayFind(ActiveClients, con))\n\t{\n\t  cupsArrayAdd(ActiveClients, con);\n          cupsdSetBusyState();\n        }\n\n    case HTTP_STATE_OPTIONS :\n    case HTTP_STATE_DELETE :\n    case HTTP_STATE_GET :\n    case HTTP_STATE_HEAD :\n    case HTTP_STATE_POST :\n    case HTTP_STATE_PUT :\n    case HTTP_STATE_TRACE :\n       /*\n        * Parse incoming parameters until the status changes...\n\t*/\n\n        while ((status = httpUpdate(con->http)) == HTTP_STATUS_CONTINUE)\n\t  if (!httpGetReady(con->http))\n\t    break;\n\n\tif (status != HTTP_STATUS_OK && status != HTTP_STATUS_CONTINUE)\n\t{\n\t  if (httpError(con->http) && httpError(con->http) != EPIPE)\n\t    cupsdLogClient(con, CUPSD_LOG_DEBUG,\n                           \"Closing for error %d (%s) while reading headers.\",\n                           httpError(con->http), strerror(httpError(con->http)));\n\t  else\n\t    cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t                   \"Closing on EOF while reading headers.\");\n\n\t  cupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE);\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n\tbreak;\n\n    default :\n        if (!httpGetReady(con->http) && recv(httpGetFd(con->http), buf, 1, MSG_PEEK) < 1)\n\t{\n\t /*\n\t  * Connection closed...\n\t  */\n\n\t  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing on EOF.\");\n          cupsdCloseClient(con);\n\t  return;\n\t}\n        break; /* Anti-compiler-warning-code */\n  }\n\n /*\n  * Handle new transfers...\n  */\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Read: status=%d\", status);\n\n  if (status == HTTP_STATUS_OK)\n  {\n    if (httpGetField(con->http, HTTP_FIELD_ACCEPT_LANGUAGE)[0])\n    {\n     /*\n      * Figure out the locale from the Accept-Language and Content-Type\n      * fields...\n      */\n\n      if ((ptr = strchr(httpGetField(con->http, HTTP_FIELD_ACCEPT_LANGUAGE),\n                        ',')) != NULL)\n        *ptr = '\\0';\n\n      if ((ptr = strchr(httpGetField(con->http, HTTP_FIELD_ACCEPT_LANGUAGE),\n                        ';')) != NULL)\n        *ptr = '\\0';\n\n      if ((ptr = strstr(httpGetField(con->http, HTTP_FIELD_CONTENT_TYPE),\n                        \"charset=\")) != NULL)\n      {\n       /*\n        * Combine language and charset, and trim any extra params in the\n\t* content-type.\n\t*/\n\n        snprintf(locale, sizeof(locale), \"%s.%s\",\n\t         httpGetField(con->http, HTTP_FIELD_ACCEPT_LANGUAGE), ptr + 8);\n\n\tif ((ptr = strchr(locale, ',')) != NULL)\n\t  *ptr = '\\0';\n      }\n      else\n        snprintf(locale, sizeof(locale), \"%s.UTF-8\",\n\t         httpGetField(con->http, HTTP_FIELD_ACCEPT_LANGUAGE));\n\n      con->language = cupsLangGet(locale);\n    }\n    else\n      con->language = cupsLangGet(DefaultLocale);\n\n    cupsdAuthorize(con);\n\n    if (!_cups_strncasecmp(httpGetField(con->http, HTTP_FIELD_CONNECTION),\n                           \"Keep-Alive\", 10) && KeepAlive)\n      httpSetKeepAlive(con->http, HTTP_KEEPALIVE_ON);\n    else if (!_cups_strncasecmp(httpGetField(con->http, HTTP_FIELD_CONNECTION),\n                                \"close\", 5))\n      httpSetKeepAlive(con->http, HTTP_KEEPALIVE_OFF);\n\n    if (!httpGetField(con->http, HTTP_FIELD_HOST)[0] &&\n        httpGetVersion(con->http) >= HTTP_VERSION_1_1)\n    {\n     /*\n      * HTTP/1.1 and higher require the \"Host:\" field...\n      */\n\n      if (!cupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE))\n      {\n        cupsdLogClient(con, CUPSD_LOG_ERROR, \"Missing Host: field in request.\");\n\tcupsdCloseClient(con);\n\treturn;\n      }\n    }\n    else if (!valid_host(con))\n    {\n     /*\n      * Access to localhost must use \"localhost\" or the corresponding IPv4\n      * or IPv6 values in the Host: field.\n      */\n\n      cupsdLogClient(con, CUPSD_LOG_ERROR,\n                     \"Request from \\\"%s\\\" using invalid Host: field \\\"%s\\\".\",\n                     httpGetHostname(con->http, NULL, 0), httpGetField(con->http, HTTP_FIELD_HOST));\n\n      if (!cupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE))\n      {\n\tcupsdCloseClient(con);\n\treturn;\n      }\n    }\n    else if (con->operation == HTTP_STATE_OPTIONS)\n    {\n     /*\n      * Do OPTIONS command...\n      */\n\n      if (con->best && con->best->type != CUPSD_AUTH_NONE)\n      {\n        httpClearFields(con->http);\n\n\tif (!cupsdSendHeader(con, HTTP_STATUS_UNAUTHORIZED, NULL, CUPSD_AUTH_NONE))\n\t{\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n      }\n\n      if (!_cups_strcasecmp(httpGetField(con->http, HTTP_FIELD_CONNECTION), \"Upgrade\") && strstr(httpGetField(con->http, HTTP_FIELD_UPGRADE), \"TLS/\") != NULL && !httpIsEncrypted(con->http))\n      {\n#ifdef HAVE_SSL\n       /*\n        * Do encryption stuff...\n\t*/\n\n        httpClearFields(con->http);\n\n\tif (!cupsdSendHeader(con, HTTP_STATUS_SWITCHING_PROTOCOLS, NULL, CUPSD_AUTH_NONE))\n\t{\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n\n        if (cupsd_start_tls(con, HTTP_ENCRYPTION_REQUIRED))\n        {\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n#else\n\tif (!cupsdSendError(con, HTTP_STATUS_NOT_IMPLEMENTED, CUPSD_AUTH_NONE))\n\t{\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n#endif /* HAVE_SSL */\n      }\n\n      httpClearFields(con->http);\n      httpSetField(con->http, HTTP_FIELD_ALLOW,\n\t\t   \"GET, HEAD, OPTIONS, POST, PUT\");\n      httpSetField(con->http, HTTP_FIELD_CONTENT_LENGTH, \"0\");\n\n      if (!cupsdSendHeader(con, HTTP_STATUS_OK, NULL, CUPSD_AUTH_NONE))\n      {\n\tcupsdCloseClient(con);\n\treturn;\n      }\n    }\n    else if (!is_path_absolute(con->uri))\n    {\n     /*\n      * Protect against malicious users!\n      */\n\n      cupsdLogClient(con, CUPSD_LOG_ERROR,\n                     \"Request for non-absolute resource \\\"%s\\\".\", con->uri);\n\n      if (!cupsdSendError(con, HTTP_STATUS_FORBIDDEN, CUPSD_AUTH_NONE))\n      {\n\tcupsdCloseClient(con);\n\treturn;\n      }\n    }\n    else\n    {\n      if (!_cups_strcasecmp(httpGetField(con->http, HTTP_FIELD_CONNECTION),\n                            \"Upgrade\") && !httpIsEncrypted(con->http))\n      {\n#ifdef HAVE_SSL\n       /*\n        * Do encryption stuff...\n\t*/\n\n        httpClearFields(con->http);\n\n\tif (!cupsdSendHeader(con, HTTP_STATUS_SWITCHING_PROTOCOLS, NULL,\n\t                     CUPSD_AUTH_NONE))\n\t{\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n\n        if (cupsd_start_tls(con, HTTP_ENCRYPTION_REQUIRED))\n        {\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n#else\n\tif (!cupsdSendError(con, HTTP_STATUS_NOT_IMPLEMENTED, CUPSD_AUTH_NONE))\n\t{\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n#endif /* HAVE_SSL */\n      }\n\n      if ((status = cupsdIsAuthorized(con, NULL)) != HTTP_STATUS_OK)\n      {\n\tcupsdSendError(con, status, CUPSD_AUTH_NONE);\n\tcupsdCloseClient(con);\n\treturn;\n      }\n\n      if (httpGetExpect(con->http) &&\n          (con->operation == HTTP_STATE_POST || con->operation == HTTP_STATE_PUT))\n      {\n        if (httpGetExpect(con->http) == HTTP_STATUS_CONTINUE)\n\t{\n\t /*\n\t  * Send 100-continue header...\n\t  */\n\n          if (httpWriteResponse(con->http, HTTP_STATUS_CONTINUE))\n\t  {\n\t    cupsdCloseClient(con);\n\t    return;\n\t  }\n\t}\n\telse\n\t{\n\t /*\n\t  * Send 417-expectation-failed header...\n\t  */\n\n          httpClearFields(con->http);\n\t  httpSetField(con->http, HTTP_FIELD_CONTENT_LENGTH, \"0\");\n\n\t  cupsdSendError(con, HTTP_STATUS_EXPECTATION_FAILED, CUPSD_AUTH_NONE);\n          cupsdCloseClient(con);\n          return;\n\t}\n      }\n\n      switch (httpGetState(con->http))\n      {\n\tcase HTTP_STATE_GET_SEND :\n            cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Processing GET %s\", con->uri);\n\n            if ((!strncmp(con->uri, \"/ppd/\", 5) ||\n\t\t !strncmp(con->uri, \"/printers/\", 10) ||\n\t\t !strncmp(con->uri, \"/classes/\", 9)) &&\n\t\t!strcmp(con->uri + strlen(con->uri) - 4, \".ppd\"))\n\t    {\n\t     /*\n\t      * Send PPD file - get the real printer name since printer\n\t      * names are not case sensitive but filenames can be...\n\t      */\n\n              con->uri[strlen(con->uri) - 4] = '\\0';\t/* Drop \".ppd\" */\n\n\t      if (!strncmp(con->uri, \"/ppd/\", 5))\n\t\tp = cupsdFindPrinter(con->uri + 5);\n\t      else if (!strncmp(con->uri, \"/printers/\", 10))\n\t\tp = cupsdFindPrinter(con->uri + 10);\n\t      else\n\t      {\n\t\tp = cupsdFindClass(con->uri + 9);\n\n\t\tif (p)\n\t\t{\n\t\t  int i;\t\t/* Looping var */\n\n\t\t  for (i = 0; i < p->num_printers; i ++)\n\t\t  {\n\t\t    if (!(p->printers[i]->type & CUPS_PRINTER_CLASS))\n\t\t    {\n\t\t      char ppdname[1024];/* PPD filename */\n\n\t\t      snprintf(ppdname, sizeof(ppdname), \"%s/ppd/%s.ppd\",\n\t\t               ServerRoot, p->printers[i]->name);\n\t\t      if (!access(ppdname, 0))\n\t\t      {\n\t\t        p = p->printers[i];\n\t\t        break;\n\t\t      }\n\t\t    }\n\t\t  }\n\n                  if (i >= p->num_printers)\n                    p = NULL;\n\t\t}\n\t      }\n\n\t      if (p)\n\t      {\n\t\tsnprintf(con->uri, sizeof(con->uri), \"/ppd/%s.ppd\", p->name);\n\t      }\n\t      else\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tbreak;\n\t      }\n\t    }\n            else if ((!strncmp(con->uri, \"/icons/\", 7) ||\n\t\t      !strncmp(con->uri, \"/printers/\", 10) ||\n\t\t      !strncmp(con->uri, \"/classes/\", 9)) &&\n\t\t     !strcmp(con->uri + strlen(con->uri) - 4, \".png\"))\n\t    {\n\t     /*\n\t      * Send icon file - get the real queue name since queue names are\n\t      * not case sensitive but filenames can be...\n\t      */\n\n\t      con->uri[strlen(con->uri) - 4] = '\\0';\t/* Drop \".png\" */\n\n              if (!strncmp(con->uri, \"/icons/\", 7))\n                p = cupsdFindPrinter(con->uri + 7);\n              else if (!strncmp(con->uri, \"/printers/\", 10))\n                p = cupsdFindPrinter(con->uri + 10);\n              else\n              {\n\t\tp = cupsdFindClass(con->uri + 9);\n\n\t\tif (p)\n\t\t{\n\t\t  int i;\t\t/* Looping var */\n\n\t\t  for (i = 0; i < p->num_printers; i ++)\n\t\t  {\n\t\t    if (!(p->printers[i]->type & CUPS_PRINTER_CLASS))\n\t\t    {\n\t\t      char ppdname[1024];/* PPD filename */\n\n\t\t      snprintf(ppdname, sizeof(ppdname), \"%s/ppd/%s.ppd\",\n\t\t               ServerRoot, p->printers[i]->name);\n\t\t      if (!access(ppdname, 0))\n\t\t      {\n\t\t        p = p->printers[i];\n\t\t        break;\n\t\t      }\n\t\t    }\n\t\t  }\n\n                  if (i >= p->num_printers)\n                    p = NULL;\n\t\t}\n\t      }\n\n              if (p)\n\t\tsnprintf(con->uri, sizeof(con->uri), \"/icons/%s.png\", p->name);\n\t      else\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tbreak;\n\t      }\n\t    }\n\n\t    if ((!strncmp(con->uri, \"/admin\", 6) && strcmp(con->uri, \"/admin/conf/cupsd.conf\") && strncmp(con->uri, \"/admin/log/\", 11)) ||\n\t\t !strncmp(con->uri, \"/printers\", 9) ||\n\t\t !strncmp(con->uri, \"/classes\", 8) ||\n\t\t !strncmp(con->uri, \"/help\", 5) ||\n\t\t !strncmp(con->uri, \"/jobs\", 5))\n\t    {\n\t      if (!WebInterface)\n\t      {\n\t       /*\n\t\t* Web interface is disabled. Show an appropriate message...\n\t\t*/\n\n\t\tif (!cupsdSendError(con, HTTP_STATUS_CUPS_WEBIF_DISABLED, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tbreak;\n\t      }\n\n\t     /*\n\t      * Send CGI output...\n\t      */\n\n              if (!strncmp(con->uri, \"/admin\", 6))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/admin.cgi\",\n\t\t                ServerBin);\n\n\t\tcupsdSetString(&con->options, strchr(con->uri + 6, '?'));\n\t      }\n              else if (!strncmp(con->uri, \"/printers\", 9))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/printers.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[9] && con->uri[10])\n\t\t  cupsdSetString(&con->options, con->uri + 9);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\t      else if (!strncmp(con->uri, \"/classes\", 8))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/classes.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[8] && con->uri[9])\n\t\t  cupsdSetString(&con->options, con->uri + 8);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\t      else if (!strncmp(con->uri, \"/jobs\", 5))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/jobs.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[5] && con->uri[6])\n\t\t  cupsdSetString(&con->options, con->uri + 5);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\t      else\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/help.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[5] && con->uri[6])\n\t\t  cupsdSetString(&con->options, con->uri + 5);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\n              if (!cupsdSendCommand(con, con->command, con->options, 0))\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n              }\n\t      else\n        \tcupsdLogRequest(con, HTTP_STATUS_OK);\n\n\t      if (httpGetVersion(con->http) <= HTTP_VERSION_1_0)\n\t\thttpSetKeepAlive(con->http, HTTP_KEEPALIVE_OFF);\n\t    }\n            else if (!strncmp(con->uri, \"/admin/log/\", 11) && (strchr(con->uri + 11, '/') || strlen(con->uri) == 11))\n\t    {\n\t     /*\n\t      * GET can only be done to configuration files directly under\n\t      * /admin/conf...\n\t      */\n\n\t      cupsdLogClient(con, CUPSD_LOG_ERROR, \"Request for subdirectory \\\"%s\\\".\", con->uri);\n\n\t      if (!cupsdSendError(con, HTTP_STATUS_FORBIDDEN, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n\t    }\n\t    else\n\t    {\n\t     /*\n\t      * Serve a file...\n\t      */\n\n              if ((filename = get_file(con, &filestats, buf,\n\t                               sizeof(buf))) == NULL)\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tbreak;\n\t      }\n\n\t      type = mimeFileType(MimeDatabase, filename, NULL, NULL);\n\n              cupsdLogClient(con, CUPSD_LOG_DEBUG, \"filename=\\\"%s\\\", type=%s/%s\", filename, type ? type->super : \"\", type ? type->type : \"\");\n\n              if (is_cgi(con, filename, &filestats, type))\n\t      {\n\t       /*\n\t        * Note: con->command and con->options were set by\n\t\t* is_cgi()...\n\t\t*/\n\n        \tif (!cupsdSendCommand(con, con->command, con->options, 0))\n\t\t{\n\t\t  if (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t  {\n\t\t    cupsdCloseClient(con);\n\t\t    return;\n\t\t  }\n        \t}\n\t\telse\n        \t  cupsdLogRequest(con, HTTP_STATUS_OK);\n\n\t\tif (httpGetVersion(con->http) <= HTTP_VERSION_1_0)\n\t\t  httpSetKeepAlive(con->http, HTTP_KEEPALIVE_OFF);\n\t        break;\n\t      }\n\n\t      if (!check_if_modified(con, &filestats))\n              {\n        \tif (!cupsdSendError(con, HTTP_STATUS_NOT_MODIFIED, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\t      }\n\t      else\n              {\n\t\tif (type == NULL)\n\t          strlcpy(line, \"text/plain\", sizeof(line));\n\t\telse\n\t          snprintf(line, sizeof(line), \"%s/%s\", type->super, type->type);\n\n        \tif (!write_file(con, HTTP_STATUS_OK, filename, line, &filestats))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\t      }\n\t    }\n            break;\n\n\tcase HTTP_STATE_POST_RECV :\n           /*\n\t    * See if the POST request includes a Content-Length field, and if\n\t    * so check the length against any limits that are set...\n\t    */\n\n            if (httpGetField(con->http, HTTP_FIELD_CONTENT_LENGTH)[0] &&\n\t\tMaxRequestSize > 0 &&\n\t\thttpGetLength2(con->http) > MaxRequestSize)\n\t    {\n\t     /*\n\t      * Request too large...\n\t      */\n\n              if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n            }\n\t    else if (httpGetLength2(con->http) < 0)\n\t    {\n\t     /*\n\t      * Negative content lengths are invalid!\n\t      */\n\n              if (!cupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n\t    }\n\n           /*\n\t    * See what kind of POST request this is; for IPP requests the\n\t    * content-type field will be \"application/ipp\"...\n\t    */\n\n\t    if (!strcmp(httpGetField(con->http, HTTP_FIELD_CONTENT_TYPE),\n\t                \"application/ipp\"))\n              con->request = ippNew();\n            else if (!WebInterface)\n\t    {\n\t     /*\n\t      * Web interface is disabled. Show an appropriate message...\n\t      */\n\n\t      if (!cupsdSendError(con, HTTP_STATUS_CUPS_WEBIF_DISABLED, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n\t    }\n\t    else if ((!strncmp(con->uri, \"/admin\", 6) && strncmp(con->uri, \"/admin/log/\", 11)) ||\n\t             !strncmp(con->uri, \"/printers\", 9) ||\n\t             !strncmp(con->uri, \"/classes\", 8) ||\n\t             !strncmp(con->uri, \"/help\", 5) ||\n\t             !strncmp(con->uri, \"/jobs\", 5))\n\t    {\n\t     /*\n\t      * CGI request...\n\t      */\n\n              if (!strncmp(con->uri, \"/admin\", 6))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/admin.cgi\",\n\t\t                ServerBin);\n\n\t\tcupsdSetString(&con->options, strchr(con->uri + 6, '?'));\n\t      }\n              else if (!strncmp(con->uri, \"/printers\", 9))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/printers.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[9] && con->uri[10])\n\t\t  cupsdSetString(&con->options, con->uri + 9);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\t      else if (!strncmp(con->uri, \"/classes\", 8))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/classes.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[8] && con->uri[9])\n\t\t  cupsdSetString(&con->options, con->uri + 8);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\t      else if (!strncmp(con->uri, \"/jobs\", 5))\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/jobs.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[5] && con->uri[6])\n\t\t  cupsdSetString(&con->options, con->uri + 5);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\t      else\n\t      {\n\t\tcupsdSetStringf(&con->command, \"%s/cgi-bin/help.cgi\",\n\t\t                ServerBin);\n\n                if (con->uri[5] && con->uri[6])\n\t\t  cupsdSetString(&con->options, con->uri + 5);\n\t\telse\n\t\t  cupsdSetString(&con->options, NULL);\n\t      }\n\n\t      if (httpGetVersion(con->http) <= HTTP_VERSION_1_0)\n\t\thttpSetKeepAlive(con->http, HTTP_KEEPALIVE_OFF);\n\t    }\n\t    else\n\t    {\n\t     /*\n\t      * POST to a file...\n\t      */\n\n              if ((filename = get_file(con, &filestats, buf,\n\t                               sizeof(buf))) == NULL)\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tbreak;\n\t      }\n\n\t      type = mimeFileType(MimeDatabase, filename, NULL, NULL);\n\n              if (!is_cgi(con, filename, &filestats, type))\n\t      {\n\t       /*\n\t        * Only POST to CGI's...\n\t\t*/\n\n\t\tif (!cupsdSendError(con, HTTP_STATUS_UNAUTHORIZED, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\t      }\n\t    }\n\t    break;\n\n\tcase HTTP_STATE_PUT_RECV :\n\t   /*\n\t    * Validate the resource name...\n\t    */\n\n            if (strcmp(con->uri, \"/admin/conf/cupsd.conf\"))\n\t    {\n\t     /*\n\t      * PUT can only be done to the cupsd.conf file...\n\t      */\n\n\t      cupsdLogClient(con, CUPSD_LOG_ERROR,\n\t\t\t     \"Disallowed PUT request for \\\"%s\\\".\", con->uri);\n\n\t      if (!cupsdSendError(con, HTTP_STATUS_FORBIDDEN, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n\t    }\n\n           /*\n\t    * See if the PUT request includes a Content-Length field, and if\n\t    * so check the length against any limits that are set...\n\t    */\n\n            if (httpGetField(con->http, HTTP_FIELD_CONTENT_LENGTH)[0] &&\n\t\tMaxRequestSize > 0 &&\n\t\thttpGetLength2(con->http) > MaxRequestSize)\n\t    {\n\t     /*\n\t      * Request too large...\n\t      */\n\n              if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n            }\n\t    else if (httpGetLength2(con->http) < 0)\n\t    {\n\t     /*\n\t      * Negative content lengths are invalid!\n\t      */\n\n              if (!cupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      break;\n\t    }\n\n           /*\n\t    * Open a temporary file to hold the request...\n\t    */\n\n            cupsdSetStringf(&con->filename, \"%s/%08x\", RequestRoot,\n\t                    request_id ++);\n\t    con->file = open(con->filename, O_WRONLY | O_CREAT | O_TRUNC, 0640);\n\n\t    if (con->file < 0)\n\t    {\n\t      cupsdLogClient(con, CUPSD_LOG_ERROR,\n\t                     \"Unable to create request file \\\"%s\\\": %s\",\n                             con->filename, strerror(errno));\n\n\t      if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\t    }\n\n\t    fchmod(con->file, 0640);\n\t    fchown(con->file, RunUser, Group);\n\t    fcntl(con->file, F_SETFD, fcntl(con->file, F_GETFD) | FD_CLOEXEC);\n\t    break;\n\n\tcase HTTP_STATE_DELETE :\n\tcase HTTP_STATE_TRACE :\n            cupsdSendError(con, HTTP_STATUS_NOT_IMPLEMENTED, CUPSD_AUTH_NONE);\n\t    cupsdCloseClient(con);\n\t    return;\n\n\tcase HTTP_STATE_HEAD :\n            if (!strncmp(con->uri, \"/printers/\", 10) &&\n\t\t!strcmp(con->uri + strlen(con->uri) - 4, \".ppd\"))\n\t    {\n\t     /*\n\t      * Send PPD file - get the real printer name since printer\n\t      * names are not case sensitive but filenames can be...\n\t      */\n\n              con->uri[strlen(con->uri) - 4] = '\\0';\t/* Drop \".ppd\" */\n\n              if ((p = cupsdFindPrinter(con->uri + 10)) != NULL)\n\t\tsnprintf(con->uri, sizeof(con->uri), \"/ppd/%s.ppd\", p->name);\n\t      else\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tcupsdLogRequest(con, HTTP_STATUS_NOT_FOUND);\n\t\tbreak;\n\t      }\n\t    }\n            else if (!strncmp(con->uri, \"/printers/\", 10) &&\n\t\t     !strcmp(con->uri + strlen(con->uri) - 4, \".png\"))\n\t    {\n\t     /*\n\t      * Send PNG file - get the real printer name since printer\n\t      * names are not case sensitive but filenames can be...\n\t      */\n\n              con->uri[strlen(con->uri) - 4] = '\\0';\t/* Drop \".ppd\" */\n\n              if ((p = cupsdFindPrinter(con->uri + 10)) != NULL)\n\t\tsnprintf(con->uri, sizeof(con->uri), \"/icons/%s.png\", p->name);\n\t      else\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\n\t\tcupsdLogRequest(con, HTTP_STATUS_NOT_FOUND);\n\t\tbreak;\n\t      }\n\t    }\n\t    else if (!WebInterface)\n\t    {\n              httpClearFields(con->http);\n\n              if (!cupsdSendHeader(con, HTTP_STATUS_OK, NULL, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n              cupsdLogRequest(con, HTTP_STATUS_OK);\n\t      break;\n\t    }\n\n\t    if ((!strncmp(con->uri, \"/admin\", 6) && strcmp(con->uri, \"/admin/conf/cupsd.conf\") && strncmp(con->uri, \"/admin/log/\", 11)) ||\n\t\t!strncmp(con->uri, \"/printers\", 9) ||\n\t\t!strncmp(con->uri, \"/classes\", 8) ||\n\t\t!strncmp(con->uri, \"/help\", 5) ||\n\t\t!strncmp(con->uri, \"/jobs\", 5))\n\t    {\n\t     /*\n\t      * CGI output...\n\t      */\n\n              httpClearFields(con->http);\n\n              if (!cupsdSendHeader(con, HTTP_STATUS_OK, \"text/html\", CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n              cupsdLogRequest(con, HTTP_STATUS_OK);\n\t    }\n            else if (!strncmp(con->uri, \"/admin/log/\", 11) && (strchr(con->uri + 11, '/') || strlen(con->uri) == 11))\n\t    {\n\t     /*\n\t      * HEAD can only be done to configuration files under\n\t      * /admin/conf...\n\t      */\n\n\t      cupsdLogClient(con, CUPSD_LOG_ERROR,\n\t\t\t     \"Request for subdirectory \\\"%s\\\".\", con->uri);\n\n\t      if (!cupsdSendError(con, HTTP_STATUS_FORBIDDEN, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n              cupsdLogRequest(con, HTTP_STATUS_FORBIDDEN);\n\t      break;\n\t    }\n\t    else if ((filename = get_file(con, &filestats, buf,\n\t                                  sizeof(buf))) == NULL)\n\t    {\n              httpClearFields(con->http);\n\n\t      if (!cupsdSendHeader(con, HTTP_STATUS_NOT_FOUND, \"text/html\",\n\t                           CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n              cupsdLogRequest(con, HTTP_STATUS_NOT_FOUND);\n\t    }\n\t    else if (!check_if_modified(con, &filestats))\n            {\n              if (!cupsdSendError(con, HTTP_STATUS_NOT_MODIFIED, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n              cupsdLogRequest(con, HTTP_STATUS_NOT_MODIFIED);\n\t    }\n\t    else\n\t    {\n\t     /*\n\t      * Serve a file...\n\t      */\n\n\t      type = mimeFileType(MimeDatabase, filename, NULL, NULL);\n\t      if (type == NULL)\n\t\tstrlcpy(line, \"text/plain\", sizeof(line));\n\t      else\n\t\tsnprintf(line, sizeof(line), \"%s/%s\", type->super, type->type);\n\n              httpClearFields(con->http);\n\n\t      httpSetField(con->http, HTTP_FIELD_LAST_MODIFIED,\n\t\t\t   httpGetDateString(filestats.st_mtime));\n\t      httpSetLength(con->http, (size_t)filestats.st_size);\n\n              if (!cupsdSendHeader(con, HTTP_STATUS_OK, line, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n              cupsdLogRequest(con, HTTP_STATUS_OK);\n\t    }\n            break;\n\n\tdefault :\n            break; /* Anti-compiler-warning-code */\n      }\n    }\n  }\n\n /*\n  * Handle any incoming data...\n  */\n\n  switch (httpGetState(con->http))\n  {\n    case HTTP_STATE_PUT_RECV :\n        do\n\t{\n          if ((bytes = httpRead2(con->http, line, sizeof(line))) < 0)\n\t  {\n\t    if (httpError(con->http) && httpError(con->http) != EPIPE)\n\t      cupsdLogClient(con, CUPSD_LOG_DEBUG,\n                             \"HTTP_STATE_PUT_RECV Closing for error %d (%s)\",\n                             httpError(con->http), strerror(httpError(con->http)));\n\t    else\n\t      cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t\t\t     \"HTTP_STATE_PUT_RECV Closing on EOF.\");\n\n\t    cupsdCloseClient(con);\n\t    return;\n\t  }\n\t  else if (bytes > 0)\n\t  {\n\t    con->bytes += bytes;\n\n            if (MaxRequestSize > 0 && con->bytes > MaxRequestSize)\n            {\n\t      close(con->file);\n\t      con->file = -1;\n\t      unlink(con->filename);\n\t      cupsdClearString(&con->filename);\n\n              if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n            }\n\n            if (write(con->file, line, (size_t)bytes) < bytes)\n\t    {\n              cupsdLogClient(con, CUPSD_LOG_ERROR,\n\t                     \"Unable to write %d bytes to \\\"%s\\\": %s\", bytes,\n                             con->filename, strerror(errno));\n\n\t      close(con->file);\n\t      con->file = -1;\n\t      unlink(con->filename);\n\t      cupsdClearString(&con->filename);\n\n              if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\t    }\n\t  }\n          else if (httpGetState(con->http) == HTTP_STATE_PUT_RECV)\n          {\n            cupsdCloseClient(con);\n            return;\n          }\n        }\n\twhile (httpGetState(con->http) == HTTP_STATE_PUT_RECV && httpGetReady(con->http));\n\n        if (httpGetState(con->http) == HTTP_STATE_STATUS)\n\t{\n\t /*\n\t  * End of file, see how big it is...\n\t  */\n\n\t  fstat(con->file, &filestats);\n\n\t  close(con->file);\n\t  con->file = -1;\n\n          if (filestats.st_size > MaxRequestSize &&\n\t      MaxRequestSize > 0)\n\t  {\n\t   /*\n\t    * Request is too big; remove it and send an error...\n\t    */\n\n\t    unlink(con->filename);\n\t    cupsdClearString(&con->filename);\n\n            if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t    {\n\t      cupsdCloseClient(con);\n\t      return;\n\t    }\n\t  }\n\n         /*\n\t  * Install the configuration file...\n\t  */\n\n          status = install_cupsd_conf(con);\n\n         /*\n\t  * Return the status to the client...\n\t  */\n\n          if (!cupsdSendError(con, status, CUPSD_AUTH_NONE))\n\t  {\n\t    cupsdCloseClient(con);\n\t    return;\n\t  }\n\t}\n        break;\n\n    case HTTP_STATE_POST_RECV :\n        do\n\t{\n          if (con->request && con->file < 0)\n\t  {\n\t   /*\n\t    * Grab any request data from the connection...\n\t    */\n\n\t    if (!httpWait(con->http, 0))\n\t      return;\n\n\t    if ((ipp_state = ippRead(con->http, con->request)) == IPP_STATE_ERROR)\n\t    {\n              cupsdLogClient(con, CUPSD_LOG_ERROR, \"IPP read error: %s\",\n                             cupsLastErrorString());\n\n\t      cupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE);\n\t      cupsdCloseClient(con);\n\t      return;\n\t    }\n\t    else if (ipp_state != IPP_STATE_DATA)\n\t    {\n              if (httpGetState(con->http) == HTTP_STATE_POST_SEND)\n\t      {\n\t\tcupsdSendError(con, HTTP_STATUS_BAD_REQUEST, CUPSD_AUTH_NONE);\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\n\t      if (httpGetReady(con->http))\n\t        continue;\n\t      break;\n            }\n\t    else\n\t    {\n\t      cupsdLogClient(con, CUPSD_LOG_DEBUG, \"%d.%d %s %d\",\n\t\t\t      con->request->request.op.version[0],\n\t\t\t      con->request->request.op.version[1],\n\t\t\t      ippOpString(con->request->request.op.operation_id),\n\t\t\t      con->request->request.op.request_id);\n\t      con->bytes += (off_t)ippLength(con->request);\n\t    }\n\t  }\n\n          if (con->file < 0 && httpGetState(con->http) != HTTP_STATE_POST_SEND)\n\t  {\n           /*\n\t    * Create a file as needed for the request data...\n\t    */\n\n            cupsdSetStringf(&con->filename, \"%s/%08x\", RequestRoot,\n\t                    request_id ++);\n\t    con->file = open(con->filename, O_WRONLY | O_CREAT | O_TRUNC, 0640);\n\n\t    if (con->file < 0)\n\t    {\n\t      cupsdLogClient(con, CUPSD_LOG_ERROR,\n\t                     \"Unable to create request file \\\"%s\\\": %s\",\n                             con->filename, strerror(errno));\n\n\t      if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\t    }\n\n\t    fchmod(con->file, 0640);\n\t    fchown(con->file, RunUser, Group);\n            fcntl(con->file, F_SETFD, fcntl(con->file, F_GETFD) | FD_CLOEXEC);\n\t  }\n\n\t  if (httpGetState(con->http) != HTTP_STATE_POST_SEND)\n\t  {\n\t    if (!httpWait(con->http, 0))\n\t      return;\n            else if ((bytes = httpRead2(con->http, line, sizeof(line))) < 0)\n\t    {\n\t      if (httpError(con->http) && httpError(con->http) != EPIPE)\n\t\tcupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t\t\t       \"HTTP_STATE_POST_SEND Closing for error %d (%s)\",\n                               httpError(con->http), strerror(httpError(con->http)));\n\t      else\n\t\tcupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t\t\t       \"HTTP_STATE_POST_SEND Closing on EOF.\");\n\n\t      cupsdCloseClient(con);\n\t      return;\n\t    }\n\t    else if (bytes > 0)\n\t    {\n\t      con->bytes += bytes;\n\n              if (MaxRequestSize > 0 && con->bytes > MaxRequestSize)\n              {\n                close(con->file);\n                con->file = -1;\n                unlink(con->filename);\n                cupsdClearString(&con->filename);\n\n                if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n                {\n                  cupsdCloseClient(con);\n                  return;\n                }\n              }\n\n              if (write(con->file, line, (size_t)bytes) < bytes)\n\t      {\n        \tcupsdLogClient(con, CUPSD_LOG_ERROR,\n\t                       \"Unable to write %d bytes to \\\"%s\\\": %s\",\n                               bytes, con->filename, strerror(errno));\n\n\t\tclose(con->file);\n\t\tcon->file = -1;\n\t\tunlink(con->filename);\n\t\tcupsdClearString(&con->filename);\n\n        \tif (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE,\n\t\t                    CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n\t      }\n\t    }\n\t    else if (httpGetState(con->http) == HTTP_STATE_POST_RECV)\n              return;\n\t    else if (httpGetState(con->http) != HTTP_STATE_POST_SEND)\n\t    {\n\t      cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t                     \"Closing on unexpected state %s.\",\n\t\t\t     httpStateString(httpGetState(con->http)));\n\t      cupsdCloseClient(con);\n\t      return;\n\t    }\n\t  }\n        }\n\twhile (httpGetState(con->http) == HTTP_STATE_POST_RECV && httpGetReady(con->http));\n\n\tif (httpGetState(con->http) == HTTP_STATE_POST_SEND)\n\t{\n\t  if (con->file >= 0)\n\t  {\n\t    fstat(con->file, &filestats);\n\n\t    close(con->file);\n\t    con->file = -1;\n\n            if (filestats.st_size > MaxRequestSize &&\n\t        MaxRequestSize > 0)\n\t    {\n\t     /*\n\t      * Request is too big; remove it and send an error...\n\t      */\n\n\t      unlink(con->filename);\n\t      cupsdClearString(&con->filename);\n\n\t      if (con->request)\n\t      {\n\t       /*\n\t        * Delete any IPP request data...\n\t\t*/\n\n\t        ippDelete(con->request);\n\t\tcon->request = NULL;\n              }\n\n              if (!cupsdSendError(con, HTTP_STATUS_REQUEST_TOO_LARGE, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\t    }\n\t    else if (filestats.st_size == 0)\n\t    {\n\t     /*\n\t      * Don't allow empty file...\n\t      */\n\n\t      unlink(con->filename);\n\t      cupsdClearString(&con->filename);\n\t    }\n\n\t    if (con->command)\n\t    {\n\t      if (!cupsdSendCommand(con, con->command, con->options, 0))\n\t      {\n\t\tif (!cupsdSendError(con, HTTP_STATUS_NOT_FOUND, CUPSD_AUTH_NONE))\n\t\t{\n\t\t  cupsdCloseClient(con);\n\t\t  return;\n\t\t}\n              }\n\t      else\n        \tcupsdLogRequest(con, HTTP_STATUS_OK);\n            }\n\t  }\n\n          if (con->request)\n\t  {\n\t    cupsdProcessIPPRequest(con);\n\n\t    if (con->filename)\n\t    {\n\t      unlink(con->filename);\n\t      cupsdClearString(&con->filename);\n\t    }\n\n\t    return;\n\t  }\n\t}\n        break;\n\n    default :\n        break; /* Anti-compiler-warning-code */\n  }\n\n  if (httpGetState(con->http) == HTTP_STATE_WAITING)\n  {\n    if (!httpGetKeepAlive(con->http))\n    {\n      cupsdLogClient(con, CUPSD_LOG_DEBUG,\n                     \"Closing because Keep-Alive is disabled.\");\n      cupsdCloseClient(con);\n    }\n    else\n    {\n      cupsArrayRemove(ActiveClients, con);\n      cupsdSetBusyState();\n    }\n  }\n}\n\n\n/*\n * 'cupsdSendCommand()' - Send output from a command via HTTP.\n */\n\nint\t\t\t\t\t/* O - 1 on success, 0 on failure */\ncupsdSendCommand(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    char           *command,\t\t/* I - Command to run */\n    char           *options,\t\t/* I - Command-line options */\n    int            root)\t\t/* I - Run as root? */\n{\n  int\tfd;\t\t\t\t/* Standard input file descriptor */\n\n\n  if (con->filename)\n  {\n    fd = open(con->filename, O_RDONLY);\n\n    if (fd < 0)\n    {\n      cupsdLogClient(con, CUPSD_LOG_ERROR,\n                     \"Unable to open \\\"%s\\\" for reading: %s\",\n                     con->filename ? con->filename : \"/dev/null\",\n\t             strerror(errno));\n      return (0);\n    }\n\n    fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n  }\n  else\n    fd = -1;\n\n  con->pipe_pid    = pipe_command(con, fd, &(con->file), command, options, root);\n  con->pipe_status = HTTP_STATUS_OK;\n\n  httpClearFields(con->http);\n\n  if (fd >= 0)\n    close(fd);\n\n  cupsdLogClient(con, CUPSD_LOG_INFO, \"Started \\\"%s\\\" (pid=%d, file=%d)\",\n                 command, con->pipe_pid, con->file);\n\n  if (con->pipe_pid == 0)\n    return (0);\n\n  fcntl(con->file, F_SETFD, fcntl(con->file, F_GETFD) | FD_CLOEXEC);\n\n  cupsdAddSelect(con->file, (cupsd_selfunc_t)write_pipe, NULL, con);\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Waiting for CGI data.\");\n\n  con->sent_header = 0;\n  con->file_ready  = 0;\n  con->got_fields  = 0;\n  con->header_used = 0;\n\n  return (1);\n}\n\n\n/*\n * 'cupsdSendError()' - Send an error message via HTTP.\n */\n\nint\t\t\t\t\t/* O - 1 if successful, 0 otherwise */\ncupsdSendError(cupsd_client_t *con,\t/* I - Connection */\n               http_status_t  code,\t/* I - Error code */\n\t       int            auth_type)/* I - Authentication type */\n{\n  char\tlocation[HTTP_MAX_VALUE];\t/* Location field */\n\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"cupsdSendError code=%d, auth_type=%d\", code, auth_type);\n\n#ifdef HAVE_SSL\n /*\n  * Force client to upgrade for authentication if that is how the\n  * server is configured...\n  */\n\n  if (code == HTTP_STATUS_UNAUTHORIZED &&\n      DefaultEncryption == HTTP_ENCRYPTION_REQUIRED &&\n      _cups_strcasecmp(httpGetHostname(con->http, NULL, 0), \"localhost\") &&\n      !httpIsEncrypted(con->http))\n  {\n    code = HTTP_STATUS_UPGRADE_REQUIRED;\n  }\n#endif /* HAVE_SSL */\n\n /*\n  * Put the request in the access_log file...\n  */\n\n  cupsdLogRequest(con, code);\n\n /*\n  * To work around bugs in some proxies, don't use Keep-Alive for some\n  * error messages...\n  *\n  * Kerberos authentication doesn't work without Keep-Alive, so\n  * never disable it in that case.\n  */\n\n  strlcpy(location, httpGetField(con->http, HTTP_FIELD_LOCATION), sizeof(location));\n\n  httpClearFields(con->http);\n\n  httpSetField(con->http, HTTP_FIELD_LOCATION, location);\n\n  if (code >= HTTP_STATUS_BAD_REQUEST && con->type != CUPSD_AUTH_NEGOTIATE)\n    httpSetKeepAlive(con->http, HTTP_KEEPALIVE_OFF);\n\n  if (httpGetVersion(con->http) >= HTTP_VERSION_1_1 &&\n      httpGetKeepAlive(con->http) == HTTP_KEEPALIVE_OFF)\n    httpSetField(con->http, HTTP_FIELD_CONNECTION, \"close\");\n\n  if (code >= HTTP_STATUS_BAD_REQUEST)\n  {\n   /*\n    * Send a human-readable error message.\n    */\n\n    char\tmessage[4096],\t\t/* Message for user */\n\t\turltext[1024],\t\t/* URL redirection text */\n\t\tredirect[1024];\t\t/* Redirection link */\n    const char\t*text;\t\t\t/* Status-specific text */\n\n\n    redirect[0] = '\\0';\n\n    if (code == HTTP_STATUS_UNAUTHORIZED)\n      text = _cupsLangString(con->language,\n                             _(\"Enter your username and password or the \"\n\t\t\t       \"root username and password to access this \"\n\t\t\t       \"page. If you are using Kerberos authentication, \"\n\t\t\t       \"make sure you have a valid Kerberos ticket.\"));\n    else if (code == HTTP_STATUS_UPGRADE_REQUIRED)\n    {\n      text = urltext;\n\n      snprintf(urltext, sizeof(urltext),\n               _cupsLangString(con->language,\n                               _(\"You must access this page using the URL \"\n\t\t\t         \"<A HREF=\\\"https://%s:%d%s\\\">\"\n\t\t\t\t \"https://%s:%d%s</A>.\")),\n               con->servername, con->serverport, con->uri,\n\t       con->servername, con->serverport, con->uri);\n\n      snprintf(redirect, sizeof(redirect),\n               \"<META HTTP-EQUIV=\\\"Refresh\\\" \"\n\t       \"CONTENT=\\\"3;URL=https://%s:%d%s\\\">\\n\",\n\t       con->servername, con->serverport, con->uri);\n    }\n    else if (code == HTTP_STATUS_CUPS_WEBIF_DISABLED)\n      text = _cupsLangString(con->language,\n                             _(\"The web interface is currently disabled. Run \"\n\t\t\t       \"\\\"cupsctl WebInterface=yes\\\" to enable it.\"));\n    else\n      text = \"\";\n\n    snprintf(message, sizeof(message),\n             \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \"\n\t     \"\\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\"\n\t     \"<HTML>\\n\"\n\t     \"<HEAD>\\n\"\n             \"\\t<META HTTP-EQUIV=\\\"Content-Type\\\" \"\n\t     \"CONTENT=\\\"text/html; charset=utf-8\\\">\\n\"\n\t     \"\\t<TITLE>%s - \" CUPS_SVERSION \"</TITLE>\\n\"\n\t     \"\\t<LINK REL=\\\"STYLESHEET\\\" TYPE=\\\"text/css\\\" \"\n\t     \"HREF=\\\"/cups.css\\\">\\n\"\n\t     \"%s\"\n\t     \"</HEAD>\\n\"\n             \"<BODY>\\n\"\n\t     \"<H1>%s</H1>\\n\"\n\t     \"<P>%s</P>\\n\"\n\t     \"</BODY>\\n\"\n\t     \"</HTML>\\n\",\n\t     _httpStatus(con->language, code), redirect,\n\t     _httpStatus(con->language, code), text);\n\n   /*\n    * Send an error message back to the client.  If the error code is a\n    * 400 or 500 series, make sure the message contains some text, too!\n    */\n\n    size_t length = strlen(message);\t/* Length of message */\n\n    httpSetLength(con->http, length);\n\n    if (!cupsdSendHeader(con, code, \"text/html\", auth_type))\n      return (0);\n\n    if (httpWrite2(con->http, message, length) < 0)\n      return (0);\n\n    if (httpFlushWrite(con->http) < 0)\n      return (0);\n  }\n  else\n  {\n    httpSetField(con->http, HTTP_FIELD_CONTENT_LENGTH, \"0\");\n\n    if (!cupsdSendHeader(con, code, NULL, auth_type))\n      return (0);\n  }\n\n  return (1);\n}\n\n\n/*\n * 'cupsdSendHeader()' - Send an HTTP request.\n */\n\nint\t\t\t\t\t/* O - 1 on success, 0 on failure */\ncupsdSendHeader(\n    cupsd_client_t *con,\t\t/* I - Client to send to */\n    http_status_t  code,\t\t/* I - HTTP status code */\n    char           *type,\t\t/* I - MIME type of document */\n    int            auth_type)\t\t/* I - Type of authentication */\n{\n  char\t\tauth_str[1024];\t\t/* Authorization string */\n\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"cupsdSendHeader: code=%d, type=\\\"%s\\\", auth_type=%d\", code, type, auth_type);\n\n /*\n  * Send the HTTP status header...\n  */\n\n  if (code == HTTP_STATUS_CUPS_WEBIF_DISABLED)\n  {\n   /*\n    * Treat our special \"web interface is disabled\" status as \"200 OK\" for web\n    * browsers.\n    */\n\n    code = HTTP_STATUS_OK;\n  }\n\n  if (ServerHeader)\n    httpSetField(con->http, HTTP_FIELD_SERVER, ServerHeader);\n\n  if (code == HTTP_STATUS_METHOD_NOT_ALLOWED)\n    httpSetField(con->http, HTTP_FIELD_ALLOW, \"GET, HEAD, OPTIONS, POST, PUT\");\n\n  if (code == HTTP_STATUS_UNAUTHORIZED)\n  {\n    if (auth_type == CUPSD_AUTH_NONE)\n    {\n      if (!con->best || con->best->type <= CUPSD_AUTH_NONE)\n\tauth_type = cupsdDefaultAuthType();\n      else\n\tauth_type = con->best->type;\n    }\n\n    auth_str[0] = '\\0';\n\n    if (auth_type == CUPSD_AUTH_BASIC)\n      strlcpy(auth_str, \"Basic realm=\\\"CUPS\\\"\", sizeof(auth_str));\n#ifdef HAVE_GSSAPI\n    else if (auth_type == CUPSD_AUTH_NEGOTIATE)\n    {\n#  ifdef AF_LOCAL\n      if (httpAddrFamily(httpGetAddress(con->http)) == AF_LOCAL)\n        strlcpy(auth_str, \"Basic realm=\\\"CUPS\\\"\", sizeof(auth_str));\n      else\n#  endif /* AF_LOCAL */\n      strlcpy(auth_str, \"Negotiate\", sizeof(auth_str));\n    }\n#endif /* HAVE_GSSAPI */\n\n    if (con->best && auth_type != CUPSD_AUTH_NEGOTIATE &&\n        !_cups_strcasecmp(httpGetHostname(con->http, NULL, 0), \"localhost\"))\n    {\n     /*\n      * Add a \"trc\" (try root certification) parameter for local non-Kerberos\n      * requests when the request requires system group membership - then the\n      * client knows the root certificate can/should be used.\n      *\n      * Also, for macOS we also look for @AUTHKEY and add an \"authkey\"\n      * parameter as needed...\n      */\n\n      char\t*name,\t\t\t/* Current user name */\n\t\t*auth_key;\t\t/* Auth key buffer */\n      size_t\tauth_size;\t\t/* Size of remaining buffer */\n\n      auth_key  = auth_str + strlen(auth_str);\n      auth_size = sizeof(auth_str) - (size_t)(auth_key - auth_str);\n\n      for (name = (char *)cupsArrayFirst(con->best->names);\n           name;\n\t   name = (char *)cupsArrayNext(con->best->names))\n      {\n#ifdef HAVE_AUTHORIZATION_H\n\tif (!_cups_strncasecmp(name, \"@AUTHKEY(\", 9))\n\t{\n\t  snprintf(auth_key, auth_size, \", authkey=\\\"%s\\\"\", name + 9);\n\t  /* end parenthesis is stripped in conf.c */\n\t  break;\n        }\n\telse\n#endif /* HAVE_AUTHORIZATION_H */\n\tif (!_cups_strcasecmp(name, \"@SYSTEM\"))\n\t{\n#ifdef HAVE_AUTHORIZATION_H\n\t  if (SystemGroupAuthKey)\n\t    snprintf(auth_key, auth_size,\n\t             \", authkey=\\\"%s\\\"\",\n\t\t     SystemGroupAuthKey);\n          else\n#else\n\t  strlcpy(auth_key, \", trc=\\\"y\\\"\", auth_size);\n#endif /* HAVE_AUTHORIZATION_H */\n\t  break;\n\t}\n      }\n    }\n\n    if (auth_str[0])\n    {\n      cupsdLogClient(con, CUPSD_LOG_DEBUG, \"WWW-Authenticate: %s\", auth_str);\n\n      httpSetField(con->http, HTTP_FIELD_WWW_AUTHENTICATE, auth_str);\n    }\n  }\n\n  if (con->language && strcmp(con->language->language, \"C\"))\n    httpSetField(con->http, HTTP_FIELD_CONTENT_LANGUAGE, con->language->language);\n\n  if (type)\n  {\n    if (!strcmp(type, \"text/html\"))\n      httpSetField(con->http, HTTP_FIELD_CONTENT_TYPE, \"text/html; charset=utf-8\");\n    else\n      httpSetField(con->http, HTTP_FIELD_CONTENT_TYPE, type);\n  }\n\n  return (!httpWriteResponse(con->http, code));\n}\n\n\n/*\n * 'cupsdUpdateCGI()' - Read status messages from CGI scripts and programs.\n */\n\nvoid\ncupsdUpdateCGI(void)\n{\n  char\t\t*ptr,\t\t\t/* Pointer to end of line in buffer */\n\t\tmessage[1024];\t\t/* Pointer to message text */\n  int\t\tloglevel;\t\t/* Log level for message */\n\n\n  while ((ptr = cupsdStatBufUpdate(CGIStatusBuffer, &loglevel,\n                                   message, sizeof(message))) != NULL)\n  {\n    if (loglevel == CUPSD_LOG_INFO)\n      cupsdLogMessage(CUPSD_LOG_INFO, \"%s\", message);\n\n    if (!strchr(CGIStatusBuffer->buffer, '\\n'))\n      break;\n  }\n\n  if (ptr == NULL && !CGIStatusBuffer->bufused)\n  {\n   /*\n    * Fatal error on pipe - should never happen!\n    */\n\n    cupsdLogMessage(CUPSD_LOG_CRIT,\n                    \"cupsdUpdateCGI: error reading from CGI error pipe - %s\",\n                    strerror(errno));\n  }\n}\n\n\n/*\n * 'cupsdWriteClient()' - Write data to a client as needed.\n */\n\nvoid\ncupsdWriteClient(cupsd_client_t *con)\t/* I - Client connection */\n{\n  int\t\tbytes,\t\t\t/* Number of bytes written */\n\t\tfield_col;\t\t/* Current column */\n  char\t\t*bufptr,\t\t/* Pointer into buffer */\n\t\t*bufend;\t\t/* Pointer to end of buffer */\n  ipp_state_t\tipp_state;\t\t/* IPP state value */\n\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"con->http=%p\", con->http);\n  cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t\t \"cupsdWriteClient \"\n\t\t \"error=%d, \"\n\t\t \"used=%d, \"\n\t\t \"state=%s, \"\n\t\t \"data_encoding=HTTP_ENCODING_%s, \"\n\t\t \"data_remaining=\" CUPS_LLFMT \", \"\n\t\t \"response=%p(%s), \"\n\t\t \"pipe_pid=%d, \"\n\t\t \"file=%d\",\n\t\t httpError(con->http), (int)httpGetReady(con->http),\n\t\t httpStateString(httpGetState(con->http)),\n\t\t httpIsChunked(con->http) ? \"CHUNKED\" : \"LENGTH\",\n\t\t CUPS_LLCAST httpGetLength2(con->http),\n\t\t con->response,\n\t\t con->response ? ippStateString(ippGetState(con->request)) : \"\",\n\t\t con->pipe_pid, con->file);\n\n  if (httpGetState(con->http) != HTTP_STATE_GET_SEND &&\n      httpGetState(con->http) != HTTP_STATE_POST_SEND)\n  {\n   /*\n    * If we get called in the wrong state, then something went wrong with the\n    * connection and we need to shut it down...\n    */\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing on unexpected HTTP write state %s.\",\n\t\t   httpStateString(httpGetState(con->http)));\n    cupsdCloseClient(con);\n    return;\n  }\n\n  if (con->pipe_pid)\n  {\n   /*\n    * Make sure we select on the CGI output...\n    */\n\n    cupsdAddSelect(con->file, (cupsd_selfunc_t)write_pipe, NULL, con);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Waiting for CGI data.\");\n\n    if (!con->file_ready)\n    {\n     /*\n      * Try again later when there is CGI output available...\n      */\n\n      cupsdRemoveSelect(httpGetFd(con->http));\n      return;\n    }\n\n    con->file_ready = 0;\n  }\n\n  bytes = (ssize_t)(sizeof(con->header) - (size_t)con->header_used);\n\n  if (!con->pipe_pid && bytes > (ssize_t)httpGetRemaining(con->http))\n  {\n   /*\n    * Limit GET bytes to original size of file (STR #3265)...\n    */\n\n    bytes = (ssize_t)httpGetRemaining(con->http);\n  }\n\n  if (con->response && con->response->state != IPP_STATE_DATA)\n  {\n    size_t wused = httpGetPending(con->http);\t/* Previous write buffer use */\n\n    do\n    {\n     /*\n      * Write a single attribute or the IPP message header...\n      */\n\n      ipp_state = ippWrite(con->http, con->response);\n\n     /*\n      * If the write buffer has been flushed, stop buffering up attributes...\n      */\n\n      if (httpGetPending(con->http) <= wused)\n        break;\n    }\n    while (ipp_state != IPP_STATE_DATA && ipp_state != IPP_STATE_ERROR);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG,\n                   \"Writing IPP response, ipp_state=%s, old \"\n                   \"wused=\" CUPS_LLFMT \", new wused=\" CUPS_LLFMT,\n                   ippStateString(ipp_state),\n\t\t   CUPS_LLCAST wused, CUPS_LLCAST httpGetPending(con->http));\n\n    if (httpGetPending(con->http) > 0)\n      httpFlushWrite(con->http);\n\n    bytes = ipp_state != IPP_STATE_ERROR &&\n\t    (con->file >= 0 || ipp_state != IPP_STATE_DATA);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG,\n                   \"bytes=%d, http_state=%d, data_remaining=\" CUPS_LLFMT,\n                   (int)bytes, httpGetState(con->http),\n                   CUPS_LLCAST httpGetLength2(con->http));\n  }\n  else if ((bytes = read(con->file, con->header + con->header_used, (size_t)bytes)) > 0)\n  {\n    con->header_used += bytes;\n\n    if (con->pipe_pid && !con->got_fields)\n    {\n     /*\n      * Inspect the data for Content-Type and other fields.\n      */\n\n      for (bufptr = con->header, bufend = con->header + con->header_used,\n               field_col = 0;\n           !con->got_fields && bufptr < bufend;\n\t   bufptr ++)\n      {\n        if (*bufptr == '\\n')\n\t{\n\t /*\n\t  * Send line to client...\n\t  */\n\n\t  if (bufptr > con->header && bufptr[-1] == '\\r')\n\t    bufptr[-1] = '\\0';\n\t  *bufptr++ = '\\0';\n\n          cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Script header: %s\", con->header);\n\n          if (!con->sent_header)\n\t  {\n\t   /*\n\t    * Handle redirection and CGI status codes...\n\t    */\n\n\t    http_field_t field;\t\t/* HTTP field */\n\t    char\t*value = strchr(con->header, ':');\n\t\t\t\t\t/* Value of field */\n\n\t    if (value)\n\t    {\n\t      *value++ = '\\0';\n\t      while (isspace(*value & 255))\n\t\tvalue ++;\n\t    }\n\n\t    field = httpFieldValue(con->header);\n\n\t    if (field != HTTP_FIELD_UNKNOWN && value)\n\t    {\n\t      httpSetField(con->http, field, value);\n\n\t      if (field == HTTP_FIELD_LOCATION)\n\t      {\n\t\tcon->pipe_status = HTTP_STATUS_SEE_OTHER;\n\t\tcon->sent_header = 2;\n\t      }\n\t      else\n\t        con->sent_header = 1;\n\t    }\n\t    else if (!_cups_strcasecmp(con->header, \"Status\") && value)\n\t    {\n  \t      con->pipe_status = (http_status_t)atoi(value);\n\t      con->sent_header = 2;\n\t    }\n\t    else if (!_cups_strcasecmp(con->header, \"Set-Cookie\") && value)\n\t    {\n\t      httpSetCookie(con->http, value);\n\t      con->sent_header = 1;\n\t    }\n\t  }\n\n         /*\n\t  * Update buffer...\n\t  */\n\n\t  con->header_used -= bufptr - con->header;\n\n\t  if (con->header_used > 0)\n\t    memmove(con->header, bufptr, (size_t)con->header_used);\n\n\t  bufptr = con->header - 1;\n\n         /*\n\t  * See if the line was empty...\n\t  */\n\n\t  if (field_col == 0)\n\t  {\n\t    con->got_fields = 1;\n\n\t    if (httpGetVersion(con->http) == HTTP_VERSION_1_1 &&\n\t\t!httpGetField(con->http, HTTP_FIELD_CONTENT_LENGTH)[0])\n\t      httpSetLength(con->http, 0);\n\n            cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Sending status %d for CGI.\", con->pipe_status);\n\n            if (con->pipe_status == HTTP_STATUS_OK)\n\t    {\n\t      if (!cupsdSendHeader(con, con->pipe_status, NULL, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (!cupsdSendError(con, con->pipe_status, CUPSD_AUTH_NONE))\n\t      {\n\t\tcupsdCloseClient(con);\n\t\treturn;\n\t      }\n\t    }\n          }\n\t  else\n\t    field_col = 0;\n\t}\n\telse if (*bufptr != '\\r')\n\t  field_col ++;\n      }\n\n      if (!con->got_fields)\n        return;\n    }\n\n    if (con->header_used > 0)\n    {\n      if (httpWrite2(con->http, con->header, (size_t)con->header_used) < 0)\n      {\n\tcupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing for error %d (%s)\",\n\t\t       httpError(con->http), strerror(httpError(con->http)));\n\tcupsdCloseClient(con);\n\treturn;\n      }\n\n      if (httpIsChunked(con->http))\n        httpFlushWrite(con->http);\n\n      con->bytes += con->header_used;\n\n      if (httpGetState(con->http) == HTTP_STATE_WAITING)\n\tbytes = 0;\n      else\n        bytes = con->header_used;\n\n      con->header_used = 0;\n    }\n  }\n\n  if (bytes <= 0 ||\n      (httpGetState(con->http) != HTTP_STATE_GET_SEND &&\n       httpGetState(con->http) != HTTP_STATE_POST_SEND))\n  {\n    if (!con->sent_header && con->pipe_pid)\n      cupsdSendError(con, HTTP_STATUS_SERVER_ERROR, CUPSD_AUTH_NONE);\n    else\n    {\n      cupsdLogRequest(con, HTTP_STATUS_OK);\n\n      if (httpIsChunked(con->http) && (!con->pipe_pid || con->sent_header > 0))\n      {\n        cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Sending 0-length chunk.\");\n\n\tif (httpWrite2(con->http, \"\", 0) < 0)\n\t{\n\t  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Closing for error %d (%s)\",\n\t\t\t httpError(con->http), strerror(httpError(con->http)));\n\t  cupsdCloseClient(con);\n\t  return;\n\t}\n      }\n\n      cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Flushing write buffer.\");\n      httpFlushWrite(con->http);\n      cupsdLogClient(con, CUPSD_LOG_DEBUG, \"New state is %s\", httpStateString(httpGetState(con->http)));\n    }\n\n    cupsdAddSelect(httpGetFd(con->http), (cupsd_selfunc_t)cupsdReadClient, NULL, con);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Waiting for request.\");\n\n    if (con->file >= 0)\n    {\n      cupsdRemoveSelect(con->file);\n\n      if (con->pipe_pid)\n\tcupsdEndProcess(con->pipe_pid, 0);\n\n      close(con->file);\n      con->file     = -1;\n      con->pipe_pid = 0;\n    }\n\n    if (con->filename)\n    {\n      unlink(con->filename);\n      cupsdClearString(&con->filename);\n    }\n\n    if (con->request)\n    {\n      ippDelete(con->request);\n      con->request = NULL;\n    }\n\n    if (con->response)\n    {\n      ippDelete(con->response);\n      con->response = NULL;\n    }\n\n    cupsdClearString(&con->command);\n    cupsdClearString(&con->options);\n    cupsdClearString(&con->query_string);\n\n    if (!httpGetKeepAlive(con->http))\n    {\n      cupsdLogClient(con, CUPSD_LOG_DEBUG,\n\t\t     \"Closing because Keep-Alive is disabled.\");\n      cupsdCloseClient(con);\n      return;\n    }\n    else\n    {\n      cupsArrayRemove(ActiveClients, con);\n      cupsdSetBusyState();\n    }\n  }\n}\n\n\n/*\n * 'check_if_modified()' - Decode an \"If-Modified-Since\" line.\n */\n\nstatic int\t\t\t\t/* O - 1 if modified since */\ncheck_if_modified(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    struct stat    *filestats)\t\t/* I - File information */\n{\n  const char\t*ptr;\t\t\t/* Pointer into field */\n  time_t\tdate;\t\t\t/* Time/date value */\n  off_t\t\tsize;\t\t\t/* Size/length value */\n\n\n  size = 0;\n  date = 0;\n  ptr  = httpGetField(con->http, HTTP_FIELD_IF_MODIFIED_SINCE);\n\n  if (*ptr == '\\0')\n    return (1);\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"check_if_modified: filestats=%p(\" CUPS_LLFMT \", %d)) If-Modified-Since=\\\"%s\\\"\", filestats, CUPS_LLCAST filestats->st_size, (int)filestats->st_mtime, ptr);\n\n  while (*ptr != '\\0')\n  {\n    while (isspace(*ptr) || *ptr == ';')\n      ptr ++;\n\n    if (_cups_strncasecmp(ptr, \"length=\", 7) == 0)\n    {\n      ptr += 7;\n      size = strtoll(ptr, NULL, 10);\n\n      while (isdigit(*ptr))\n        ptr ++;\n    }\n    else if (isalpha(*ptr))\n    {\n      date = httpGetDateTime(ptr);\n      while (*ptr != '\\0' && *ptr != ';')\n        ptr ++;\n    }\n    else\n      ptr ++;\n  }\n\n  return ((size != filestats->st_size && size != 0) ||\n          (date < filestats->st_mtime && date != 0) ||\n\t  (size == 0 && date == 0));\n}\n\n\n/*\n * 'compare_clients()' - Compare two client connections.\n */\n\nstatic int\t\t\t\t/* O - Result of comparison */\ncompare_clients(cupsd_client_t *a,\t/* I - First client */\n                cupsd_client_t *b,\t/* I - Second client */\n                void           *data)\t/* I - User data (not used) */\n{\n  (void)data;\n\n  if (a == b)\n    return (0);\n  else if (a < b)\n    return (-1);\n  else\n    return (1);\n}\n\n\n#ifdef HAVE_SSL\n/*\n * 'cupsd_start_tls()' - Start encryption on a connection.\n */\n\nstatic int\t\t\t\t/* O - 0 on success, -1 on error */\ncupsd_start_tls(cupsd_client_t    *con,\t/* I - Client connection */\n                http_encryption_t e)\t/* I - Encryption mode */\n{\n  if (httpEncryption(con->http, e))\n  {\n    cupsdLogClient(con, CUPSD_LOG_ERROR, \"Unable to encrypt connection: %s\",\n                   cupsLastErrorString());\n    return (-1);\n  }\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Connection now encrypted.\");\n  return (0);\n}\n#endif /* HAVE_SSL */\n\n\n/*\n * 'get_file()' - Get a filename and state info.\n */\n\nstatic char *\t\t\t\t/* O  - Real filename */\nget_file(cupsd_client_t *con,\t\t/* I  - Client connection */\n         struct stat    *filestats,\t/* O  - File information */\n         char           *filename,\t/* IO - Filename buffer */\n         size_t         len)\t\t/* I  - Buffer length */\n{\n  int\t\tstatus;\t\t\t/* Status of filesystem calls */\n  char\t\t*ptr;\t\t\t/* Pointer info filename */\n  size_t\tplen;\t\t\t/* Remaining length after pointer */\n  char\t\tlanguage[7],\t\t/* Language subdirectory, if any */\n\t\tdest[1024];\t\t/* Destination name */\n  int\t\tperm_check = 1;\t\t/* Do permissions check? */\n\n\n /*\n  * Figure out the real filename...\n  */\n\n  language[0] = '\\0';\n\n  if (!strncmp(con->uri, \"/ppd/\", 5) && !strchr(con->uri + 5, '/'))\n  {\n    strlcpy(dest, con->uri + 5, sizeof(dest));\n    ptr = dest + strlen(dest) - 4;\n\n    if (ptr <= dest || strcmp(ptr, \".ppd\"))\n    {\n      cupsdLogClient(con, CUPSD_LOG_INFO, \"Disallowed path \\\"%s\\\".\", con->uri);\n      return (NULL);\n    }\n\n    *ptr = '\\0';\n    if (!cupsdFindPrinter(dest))\n    {\n      cupsdLogClient(con, CUPSD_LOG_INFO, \"No printer \\\"%s\\\" found.\", dest);\n      return (NULL);\n    }\n\n    snprintf(filename, len, \"%s%s\", ServerRoot, con->uri);\n\n    perm_check = 0;\n  }\n  else if (!strncmp(con->uri, \"/icons/\", 7) && !strchr(con->uri + 7, '/'))\n  {\n    strlcpy(dest, con->uri + 7, sizeof(dest));\n    ptr = dest + strlen(dest) - 4;\n\n    if (ptr <= dest || strcmp(ptr, \".png\"))\n    {\n      cupsdLogClient(con, CUPSD_LOG_INFO, \"Disallowed path \\\"%s\\\".\", con->uri);\n      return (NULL);\n    }\n\n    *ptr = '\\0';\n    if (!cupsdFindDest(dest))\n    {\n      cupsdLogClient(con, CUPSD_LOG_INFO, \"No printer \\\"%s\\\" found.\", dest);\n      return (NULL);\n    }\n\n    snprintf(filename, len, \"%s/%s.png\", CacheDir, dest);\n    if (access(filename, F_OK) < 0)\n      snprintf(filename, len, \"%s/images/generic.png\", DocumentRoot);\n\n    perm_check = 0;\n  }\n  else if (!strncmp(con->uri, \"/rss/\", 5) && !strchr(con->uri + 5, '/'))\n    snprintf(filename, len, \"%s/rss/%s\", CacheDir, con->uri + 5);\n  else if (!strcmp(con->uri, \"/admin/conf/cupsd.conf\"))\n  {\n    strlcpy(filename, ConfigurationFile, len);\n\n    perm_check = 0;\n  }\n  else if (!strncmp(con->uri, \"/admin/log/\", 11))\n  {\n    if (!strncmp(con->uri + 11, \"access_log\", 10) && AccessLog[0] == '/')\n      strlcpy(filename, AccessLog, len);\n    else if (!strncmp(con->uri + 11, \"error_log\", 9) && ErrorLog[0] == '/')\n      strlcpy(filename, ErrorLog, len);\n    else if (!strncmp(con->uri + 11, \"page_log\", 8) && PageLog[0] == '/')\n      strlcpy(filename, PageLog, len);\n    else\n      return (NULL);\n\n    perm_check = 0;\n  }\n  else if (con->language)\n  {\n    snprintf(language, sizeof(language), \"/%s\", con->language->language);\n    snprintf(filename, len, \"%s%s%s\", DocumentRoot, language, con->uri);\n  }\n  else\n    snprintf(filename, len, \"%s%s\", DocumentRoot, con->uri);\n\n  if ((ptr = strchr(filename, '?')) != NULL)\n    *ptr = '\\0';\n\n /*\n  * Grab the status for this language; if there isn't a language-specific file\n  * then fallback to the default one...\n  */\n\n  if ((status = lstat(filename, filestats)) != 0 && language[0] &&\n      strncmp(con->uri, \"/icons/\", 7) &&\n      strncmp(con->uri, \"/ppd/\", 5) &&\n      strncmp(con->uri, \"/rss/\", 5) &&\n      strncmp(con->uri, \"/admin/conf/\", 12) &&\n      strncmp(con->uri, \"/admin/log/\", 11))\n  {\n   /*\n    * Drop the country code...\n    */\n\n    language[3] = '\\0';\n    snprintf(filename, len, \"%s%s%s\", DocumentRoot, language, con->uri);\n\n    if ((ptr = strchr(filename, '?')) != NULL)\n      *ptr = '\\0';\n\n    if ((status = lstat(filename, filestats)) != 0)\n    {\n     /*\n      * Drop the language prefix and try the root directory...\n      */\n\n      language[0] = '\\0';\n      snprintf(filename, len, \"%s%s\", DocumentRoot, con->uri);\n\n      if ((ptr = strchr(filename, '?')) != NULL)\n\t*ptr = '\\0';\n\n      status = lstat(filename, filestats);\n    }\n  }\n\n /*\n  * If we've found a symlink, 404 the sucker to avoid disclosing information.\n  */\n\n  if (!status && S_ISLNK(filestats->st_mode))\n  {\n    cupsdLogClient(con, CUPSD_LOG_INFO, \"Symlinks such as \\\"%s\\\" are not allowed.\", filename);\n    return (NULL);\n  }\n\n /*\n  * Similarly, if the file/directory does not have world read permissions, do\n  * not allow access...\n  */\n\n  if (!status && perm_check && !(filestats->st_mode & S_IROTH))\n  {\n    cupsdLogClient(con, CUPSD_LOG_INFO, \"Files/directories such as \\\"%s\\\" must be world-readable.\", filename);\n    return (NULL);\n  }\n\n /*\n  * If we've found a directory, get the index.html file instead...\n  */\n\n  if (!status && S_ISDIR(filestats->st_mode))\n  {\n   /*\n    * Make sure the URI ends with a slash...\n    */\n\n    if (con->uri[strlen(con->uri) - 1] != '/')\n      strlcat(con->uri, \"/\", sizeof(con->uri));\n\n   /*\n    * Find the directory index file, trying every language...\n    */\n\n    do\n    {\n      if (status && language[0])\n      {\n       /*\n        * Try a different language subset...\n\t*/\n\n\tif (language[3])\n\t  language[0] = '\\0';\t\t/* Strip country code */\n\telse\n\t  language[0] = '\\0';\t\t/* Strip language */\n      }\n\n     /*\n      * Look for the index file...\n      */\n\n      snprintf(filename, len, \"%s%s%s\", DocumentRoot, language, con->uri);\n\n      if ((ptr = strchr(filename, '?')) != NULL)\n\t*ptr = '\\0';\n\n      ptr  = filename + strlen(filename);\n      plen = len - (size_t)(ptr - filename);\n\n      strlcpy(ptr, \"index.html\", plen);\n      status = lstat(filename, filestats);\n\n#ifdef HAVE_JAVA\n      if (status)\n      {\n\tstrlcpy(ptr, \"index.class\", plen);\n\tstatus = lstat(filename, filestats);\n      }\n#endif /* HAVE_JAVA */\n\n#ifdef HAVE_PERL\n      if (status)\n      {\n\tstrlcpy(ptr, \"index.pl\", plen);\n\tstatus = lstat(filename, filestats);\n      }\n#endif /* HAVE_PERL */\n\n#ifdef HAVE_PHP\n      if (status)\n      {\n\tstrlcpy(ptr, \"index.php\", plen);\n\tstatus = lstat(filename, filestats);\n      }\n#endif /* HAVE_PHP */\n\n#ifdef HAVE_PYTHON\n      if (status)\n      {\n\tstrlcpy(ptr, \"index.pyc\", plen);\n\tstatus = lstat(filename, filestats);\n      }\n\n      if (status)\n      {\n\tstrlcpy(ptr, \"index.py\", plen);\n\tstatus = lstat(filename, filestats);\n      }\n#endif /* HAVE_PYTHON */\n\n    }\n    while (status && language[0]);\n\n   /*\n    * If we've found a symlink, 404 the sucker to avoid disclosing information.\n    */\n\n    if (!status && S_ISLNK(filestats->st_mode))\n    {\n      cupsdLogClient(con, CUPSD_LOG_INFO, \"Symlinks such as \\\"%s\\\" are not allowed.\", filename);\n      return (NULL);\n    }\n\n   /*\n    * Similarly, if the file/directory does not have world read permissions, do\n    * not allow access...\n    */\n\n    if (!status && perm_check && !(filestats->st_mode & S_IROTH))\n    {\n      cupsdLogClient(con, CUPSD_LOG_INFO, \"Files/directories such as \\\"%s\\\" must be world-readable.\", filename);\n      return (NULL);\n    }\n  }\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"get_file: filestats=%p, filename=%p, len=\" CUPS_LLFMT \", returning \\\"%s\\\".\", filestats, filename, CUPS_LLCAST len, status ? \"(null)\" : filename);\n\n  if (status)\n    return (NULL);\n  else\n    return (filename);\n}\n\n\n/*\n * 'install_cupsd_conf()' - Install a configuration file.\n */\n\nstatic http_status_t\t\t\t/* O - Status */\ninstall_cupsd_conf(cupsd_client_t *con)\t/* I - Connection */\n{\n  char\t\tfilename[1024];\t\t/* Configuration filename */\n  cups_file_t\t*in,\t\t\t/* Input file */\n\t\t*out;\t\t\t/* Output file */\n  char\t\tbuffer[16384];\t\t/* Copy buffer */\n  ssize_t\tbytes;\t\t\t/* Number of bytes */\n\n\n /*\n  * Open the request file...\n  */\n\n  if ((in = cupsFileOpen(con->filename, \"rb\")) == NULL)\n  {\n    cupsdLogClient(con, CUPSD_LOG_ERROR, \"Unable to open request file \\\"%s\\\": %s\",\n                    con->filename, strerror(errno));\n    goto server_error;\n  }\n\n /*\n  * Open the new config file...\n  */\n\n  if ((out = cupsdCreateConfFile(ConfigurationFile, ConfigFilePerm)) == NULL)\n  {\n    cupsFileClose(in);\n    goto server_error;\n  }\n\n  cupsdLogClient(con, CUPSD_LOG_INFO, \"Installing config file \\\"%s\\\"...\",\n                  ConfigurationFile);\n\n /*\n  * Copy from the request to the new config file...\n  */\n\n  while ((bytes = cupsFileRead(in, buffer, sizeof(buffer))) > 0)\n    if (cupsFileWrite(out, buffer, (size_t)bytes) < bytes)\n    {\n      cupsdLogClient(con, CUPSD_LOG_ERROR,\n                      \"Unable to copy to config file \\\"%s\\\": %s\",\n        \t      ConfigurationFile, strerror(errno));\n\n      cupsFileClose(in);\n      cupsFileClose(out);\n\n      snprintf(filename, sizeof(filename), \"%s.N\", ConfigurationFile);\n      cupsdUnlinkOrRemoveFile(filename);\n\n      goto server_error;\n    }\n\n /*\n  * Close the files...\n  */\n\n  cupsFileClose(in);\n\n  if (cupsdCloseCreatedConfFile(out, ConfigurationFile))\n    goto server_error;\n\n /*\n  * Remove the request file...\n  */\n\n  cupsdUnlinkOrRemoveFile(con->filename);\n  cupsdClearString(&con->filename);\n\n /*\n  * Set the NeedReload flag...\n  */\n\n  NeedReload = RELOAD_CUPSD;\n  ReloadTime = time(NULL);\n\n /*\n  * Return that the file was created successfully...\n  */\n\n  return (HTTP_STATUS_CREATED);\n\n /*\n  * Common exit for errors...\n  */\n\n  server_error:\n\n  cupsdUnlinkOrRemoveFile(con->filename);\n  cupsdClearString(&con->filename);\n\n  return (HTTP_STATUS_SERVER_ERROR);\n}\n\n\n/*\n * 'is_cgi()' - Is the resource a CGI script/program?\n */\n\nstatic int\t\t\t\t/* O - 1 = CGI, 0 = file */\nis_cgi(cupsd_client_t *con,\t\t/* I - Client connection */\n       const char     *filename,\t/* I - Real filename */\n       struct stat    *filestats,\t/* I - File information */\n       mime_type_t    *type)\t\t/* I - MIME type */\n{\n  const char\t*options;\t\t/* Options on URL */\n\n\n /*\n  * Get the options, if any...\n  */\n\n  if ((options = strchr(con->uri, '?')) != NULL)\n  {\n    options ++;\n    cupsdSetStringf(&(con->query_string), \"QUERY_STRING=%s\", options);\n  }\n\n /*\n  * Check for known types...\n  */\n\n  if (!type || _cups_strcasecmp(type->super, \"application\"))\n  {\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 0.\", filename, filestats, type ? type->super : \"unknown\", type ? type->type : \"unknown\");\n    return (0);\n  }\n\n  if (!_cups_strcasecmp(type->type, \"x-httpd-cgi\") &&\n      (filestats->st_mode & 0111))\n  {\n   /*\n    * \"application/x-httpd-cgi\" is a CGI script.\n    */\n\n    cupsdSetString(&con->command, filename);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s\", options);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#ifdef HAVE_JAVA\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-java\"))\n  {\n   /*\n    * \"application/x-httpd-java\" is a Java servlet.\n    */\n\n    cupsdSetString(&con->command, CUPS_JAVA);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_JAVA */\n#ifdef HAVE_PERL\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-perl\"))\n  {\n   /*\n    * \"application/x-httpd-perl\" is a Perl page.\n    */\n\n    cupsdSetString(&con->command, CUPS_PERL);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_PERL */\n#ifdef HAVE_PHP\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-php\"))\n  {\n   /*\n    * \"application/x-httpd-php\" is a PHP page.\n    */\n\n    cupsdSetString(&con->command, CUPS_PHP);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_PHP */\n#ifdef HAVE_PYTHON\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-python\"))\n  {\n   /*\n    * \"application/x-httpd-python\" is a Python page.\n    */\n\n    cupsdSetString(&con->command, CUPS_PYTHON);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_PYTHON */\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 0.\", filename, filestats, type->super, type->type);\n  return (0);\n}\n\n\n/*\n * 'is_path_absolute()' - Is a path absolute and free of relative elements (i.e. \"..\").\n */\n\nstatic int\t\t\t\t/* O - 0 if relative, 1 if absolute */\nis_path_absolute(const char *path)\t/* I - Input path */\n{\n /*\n  * Check for a leading slash...\n  */\n\n  if (path[0] != '/')\n    return (0);\n\n /*\n  * Check for \"<\" or quotes in the path and reject since this is probably\n  * someone trying to inject HTML...\n  */\n\n  if (strchr(path, '<') != NULL || strchr(path, '\\\"') != NULL || strchr(path, '\\'') != NULL)\n    return (0);\n\n /*\n  * Check for \"/..\" in the path...\n  */\n\n  while ((path = strstr(path, \"/..\")) != NULL)\n  {\n    if (!path[3] || path[3] == '/')\n      return (0);\n\n    path ++;\n  }\n\n /*\n  * If we haven't found any relative paths, return 1 indicating an\n  * absolute path...\n  */\n\n  return (1);\n}\n\n\n/*\n * 'pipe_command()' - Pipe the output of a command to the remote client.\n */\n\nstatic int\t\t\t\t/* O - Process ID */\npipe_command(cupsd_client_t *con,\t/* I - Client connection */\n             int            infile,\t/* I - Standard input for command */\n             int            *outfile,\t/* O - Standard output for command */\n\t     char           *command,\t/* I - Command to run */\n\t     char           *options,\t/* I - Options for command */\n\t     int            root)\t/* I - Run as root? */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  int\t\tpid;\t\t\t/* Process ID */\n  char\t\t*commptr,\t\t/* Command string pointer */\n\t\tcommch;\t\t\t/* Command string character */\n  char\t\t*uriptr;\t\t/* URI string pointer */\n  int\t\tfds[2];\t\t\t/* Pipe FDs */\n  int\t\targc;\t\t\t/* Number of arguments */\n  int\t\tenvc;\t\t\t/* Number of environment variables */\n  char\t\targbuf[10240],\t\t/* Argument buffer */\n\t\t*argv[100],\t\t/* Argument strings */\n\t\t*envp[MAX_ENV + 20];\t/* Environment variables */\n  char\t\tauth_type[256],\t\t/* AUTH_TYPE environment variable */\n\t\tcontent_length[1024],\t/* CONTENT_LENGTH environment variable */\n\t\tcontent_type[1024],\t/* CONTENT_TYPE environment variable */\n\t\thttp_cookie[32768],\t/* HTTP_COOKIE environment variable */\n\t\thttp_referer[1024],\t/* HTTP_REFERER environment variable */\n\t\thttp_user_agent[1024],\t/* HTTP_USER_AGENT environment variable */\n\t\tlang[1024],\t\t/* LANG environment variable */\n\t\tpath_info[1024],\t/* PATH_INFO environment variable */\n\t\tremote_addr[1024],\t/* REMOTE_ADDR environment variable */\n\t\tremote_host[1024],\t/* REMOTE_HOST environment variable */\n\t\tremote_user[1024],\t/* REMOTE_USER environment variable */\n\t\tscript_filename[1024],\t/* SCRIPT_FILENAME environment variable */\n\t\tscript_name[1024],\t/* SCRIPT_NAME environment variable */\n\t\tserver_name[1024],\t/* SERVER_NAME environment variable */\n\t\tserver_port[1024];\t/* SERVER_PORT environment variable */\n  ipp_attribute_t *attr;\t\t/* attributes-natural-language attribute */\n\n\n /*\n  * Parse a copy of the options string, which is of the form:\n  *\n  *     argument+argument+argument\n  *     ?argument+argument+argument\n  *     param=value&param=value\n  *     ?param=value&param=value\n  *     /name?argument+argument+argument\n  *     /name?param=value&param=value\n  *\n  * If the string contains an \"=\" character after the initial name,\n  * then we treat it as a HTTP GET form request and make a copy of\n  * the remaining string for the environment variable.\n  *\n  * The string is always parsed out as command-line arguments, to\n  * be consistent with Apache...\n  */\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"pipe_command: infile=%d, outfile=%p, command=\\\"%s\\\", options=\\\"%s\\\", root=%d\", infile, outfile, command, options ? options : \"(null)\", root);\n\n  argv[0] = command;\n\n  if (options)\n    strlcpy(argbuf, options, sizeof(argbuf));\n  else\n    argbuf[0] = '\\0';\n\n  if (argbuf[0] == '/')\n  {\n   /*\n    * Found some trailing path information, set PATH_INFO...\n    */\n\n    if ((commptr = strchr(argbuf, '?')) == NULL)\n      commptr = argbuf + strlen(argbuf);\n\n    commch   = *commptr;\n    *commptr = '\\0';\n    snprintf(path_info, sizeof(path_info), \"PATH_INFO=%s\", argbuf);\n    *commptr = commch;\n  }\n  else\n  {\n    commptr      = argbuf;\n    path_info[0] = '\\0';\n\n    if (*commptr == ' ')\n      commptr ++;\n  }\n\n  if (*commptr == '?' && con->operation == HTTP_STATE_GET && !con->query_string)\n  {\n    commptr ++;\n    cupsdSetStringf(&(con->query_string), \"QUERY_STRING=%s\", commptr);\n  }\n\n  argc = 1;\n\n  if (*commptr)\n  {\n    argv[argc ++] = commptr;\n\n    for (; *commptr && argc < 99; commptr ++)\n    {\n     /*\n      * Break arguments whenever we see a + or space...\n      */\n\n      if (*commptr == ' ' || *commptr == '+')\n      {\n\twhile (*commptr == ' ' || *commptr == '+')\n\t  *commptr++ = '\\0';\n\n       /*\n\t* If we don't have a blank string, save it as another argument...\n\t*/\n\n\tif (*commptr)\n\t{\n\t  argv[argc] = commptr;\n\t  argc ++;\n\t}\n\telse\n\t  break;\n      }\n      else if (*commptr == '%' && isxdigit(commptr[1] & 255) &&\n               isxdigit(commptr[2] & 255))\n      {\n       /*\n\t* Convert the %xx notation to the individual character.\n\t*/\n\n\tif (commptr[1] >= '0' && commptr[1] <= '9')\n          *commptr = (char)((commptr[1] - '0') << 4);\n\telse\n          *commptr = (char)((tolower(commptr[1]) - 'a' + 10) << 4);\n\n\tif (commptr[2] >= '0' && commptr[2] <= '9')\n          *commptr |= commptr[2] - '0';\n\telse\n          *commptr |= tolower(commptr[2]) - 'a' + 10;\n\n\t_cups_strcpy(commptr + 1, commptr + 3);\n\n       /*\n\t* Check for a %00 and break if that is the case...\n\t*/\n\n\tif (!*commptr)\n          break;\n      }\n    }\n  }\n\n  argv[argc] = NULL;\n\n /*\n  * Setup the environment variables as needed...\n  */\n\n  if (con->username[0])\n  {\n    snprintf(auth_type, sizeof(auth_type), \"AUTH_TYPE=%s\",\n             httpGetField(con->http, HTTP_FIELD_AUTHORIZATION));\n\n    if ((uriptr = strchr(auth_type + 10, ' ')) != NULL)\n      *uriptr = '\\0';\n  }\n  else\n    auth_type[0] = '\\0';\n\n  if (con->request &&\n      (attr = ippFindAttribute(con->request, \"attributes-natural-language\",\n                               IPP_TAG_LANGUAGE)) != NULL)\n  {\n    switch (strlen(attr->values[0].string.text))\n    {\n      default :\n\t /*\n\t  * This is an unknown or badly formatted language code; use\n\t  * the POSIX locale...\n\t  */\n\n\t  strlcpy(lang, \"LANG=C\", sizeof(lang));\n\t  break;\n\n      case 2 :\n\t /*\n\t  * Just the language code (ll)...\n\t  */\n\n\t  snprintf(lang, sizeof(lang), \"LANG=%s.UTF8\",\n\t\t   attr->values[0].string.text);\n\t  break;\n\n      case 5 :\n\t /*\n\t  * Language and country code (ll-cc)...\n\t  */\n\n\t  snprintf(lang, sizeof(lang), \"LANG=%c%c_%c%c.UTF8\",\n\t\t   attr->values[0].string.text[0],\n\t\t   attr->values[0].string.text[1],\n\t\t   toupper(attr->values[0].string.text[3] & 255),\n\t\t   toupper(attr->values[0].string.text[4] & 255));\n\t  break;\n    }\n  }\n  else if (con->language)\n    snprintf(lang, sizeof(lang), \"LANG=%s.UTF8\", con->language->language);\n  else\n    strlcpy(lang, \"LANG=C\", sizeof(lang));\n\n  strlcpy(remote_addr, \"REMOTE_ADDR=\", sizeof(remote_addr));\n  httpAddrString(httpGetAddress(con->http), remote_addr + 12,\n                 sizeof(remote_addr) - 12);\n\n  snprintf(remote_host, sizeof(remote_host), \"REMOTE_HOST=%s\",\n           httpGetHostname(con->http, NULL, 0));\n\n  snprintf(script_name, sizeof(script_name), \"SCRIPT_NAME=%s\", con->uri);\n  if ((uriptr = strchr(script_name, '?')) != NULL)\n    *uriptr = '\\0';\n\n  snprintf(script_filename, sizeof(script_filename), \"SCRIPT_FILENAME=%s%s\",\n           DocumentRoot, script_name + 12);\n\n  snprintf(server_port, sizeof(server_port), \"SERVER_PORT=%d\", con->serverport);\n\n  if (httpGetField(con->http, HTTP_FIELD_HOST)[0])\n  {\n    char *nameptr;\t\t\t/* Pointer to \":port\" */\n\n    snprintf(server_name, sizeof(server_name), \"SERVER_NAME=%s\",\n\t     httpGetField(con->http, HTTP_FIELD_HOST));\n    if ((nameptr = strrchr(server_name, ':')) != NULL && !strchr(nameptr, ']'))\n      *nameptr = '\\0';\t\t\t/* Strip trailing \":port\" */\n  }\n  else\n    snprintf(server_name, sizeof(server_name), \"SERVER_NAME=%s\",\n\t     con->servername);\n\n  envc = cupsdLoadEnv(envp, (int)(sizeof(envp) / sizeof(envp[0])));\n\n  if (auth_type[0])\n    envp[envc ++] = auth_type;\n\n  envp[envc ++] = lang;\n  envp[envc ++] = \"REDIRECT_STATUS=1\";\n  envp[envc ++] = \"GATEWAY_INTERFACE=CGI/1.1\";\n  envp[envc ++] = server_name;\n  envp[envc ++] = server_port;\n  envp[envc ++] = remote_addr;\n  envp[envc ++] = remote_host;\n  envp[envc ++] = script_name;\n  envp[envc ++] = script_filename;\n\n  if (path_info[0])\n    envp[envc ++] = path_info;\n\n  if (con->username[0])\n  {\n    snprintf(remote_user, sizeof(remote_user), \"REMOTE_USER=%s\", con->username);\n\n    envp[envc ++] = remote_user;\n  }\n\n  if (httpGetVersion(con->http) == HTTP_VERSION_1_1)\n    envp[envc ++] = \"SERVER_PROTOCOL=HTTP/1.1\";\n  else if (httpGetVersion(con->http) == HTTP_VERSION_1_0)\n    envp[envc ++] = \"SERVER_PROTOCOL=HTTP/1.0\";\n  else\n    envp[envc ++] = \"SERVER_PROTOCOL=HTTP/0.9\";\n\n  if (httpGetCookie(con->http))\n  {\n    snprintf(http_cookie, sizeof(http_cookie), \"HTTP_COOKIE=%s\",\n             httpGetCookie(con->http));\n    envp[envc ++] = http_cookie;\n  }\n\n  if (httpGetField(con->http, HTTP_FIELD_USER_AGENT)[0])\n  {\n    snprintf(http_user_agent, sizeof(http_user_agent), \"HTTP_USER_AGENT=%s\",\n             httpGetField(con->http, HTTP_FIELD_USER_AGENT));\n    envp[envc ++] = http_user_agent;\n  }\n\n  if (httpGetField(con->http, HTTP_FIELD_REFERER)[0])\n  {\n    snprintf(http_referer, sizeof(http_referer), \"HTTP_REFERER=%s\",\n             httpGetField(con->http, HTTP_FIELD_REFERER));\n    envp[envc ++] = http_referer;\n  }\n\n  if (con->operation == HTTP_STATE_GET)\n  {\n    envp[envc ++] = \"REQUEST_METHOD=GET\";\n\n    if (con->query_string)\n    {\n     /*\n      * Add GET form variables after ?...\n      */\n\n      envp[envc ++] = con->query_string;\n    }\n    else\n      envp[envc ++] = \"QUERY_STRING=\";\n  }\n  else\n  {\n    sprintf(content_length, \"CONTENT_LENGTH=\" CUPS_LLFMT,\n            CUPS_LLCAST con->bytes);\n    snprintf(content_type, sizeof(content_type), \"CONTENT_TYPE=%s\",\n             httpGetField(con->http, HTTP_FIELD_CONTENT_TYPE));\n\n    envp[envc ++] = \"REQUEST_METHOD=POST\";\n    envp[envc ++] = content_length;\n    envp[envc ++] = content_type;\n  }\n\n /*\n  * Tell the CGI if we are using encryption...\n  */\n\n  if (httpIsEncrypted(con->http))\n    envp[envc ++] = \"HTTPS=ON\";\n\n /*\n  * Terminate the environment array...\n  */\n\n  envp[envc] = NULL;\n\n  if (LogLevel >= CUPSD_LOG_DEBUG)\n  {\n    for (i = 0; i < argc; i ++)\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n                      \"[CGI] argv[%d] = \\\"%s\\\"\", i, argv[i]);\n    for (i = 0; i < envc; i ++)\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n                      \"[CGI] envp[%d] = \\\"%s\\\"\", i, envp[i]);\n  }\n\n /*\n  * Create a pipe for the output...\n  */\n\n  if (cupsdOpenPipe(fds))\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"[CGI] Unable to create pipe for %s - %s\",\n                    argv[0], strerror(errno));\n    return (0);\n  }\n\n /*\n  * Then execute the command...\n  */\n\n  if (cupsdStartProcess(command, argv, envp, infile, fds[1], CGIPipes[1],\n\t\t\t-1, -1, root, DefaultProfile, NULL, &pid) < 0)\n  {\n   /*\n    * Error - can't fork!\n    */\n\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"[CGI] Unable to start %s - %s\", argv[0],\n                    strerror(errno));\n\n    cupsdClosePipe(fds);\n    pid = 0;\n  }\n  else\n  {\n   /*\n    * Fork successful - return the PID...\n    */\n\n    if (con->username[0])\n      cupsdAddCert(pid, con->username, con->type);\n\n    cupsdLogMessage(CUPSD_LOG_DEBUG, \"[CGI] Started %s (PID %d)\", command, pid);\n\n    *outfile = fds[0];\n    close(fds[1]);\n  }\n\n  return (pid);\n}\n\n\n/*\n * 'valid_host()' - Is the Host: field valid?\n */\n\nstatic int\t\t\t\t/* O - 1 if valid, 0 if not */\nvalid_host(cupsd_client_t *con)\t\t/* I - Client connection */\n{\n  cupsd_alias_t\t*a;\t\t\t/* Current alias */\n  cupsd_netif_t\t*netif;\t\t\t/* Current network interface */\n  const char\t*end;\t\t\t/* End character */\n  char\t\t*ptr;\t\t\t/* Pointer into host value */\n\n\n /*\n  * Copy the Host: header for later use...\n  */\n\n  strlcpy(con->clientname, httpGetField(con->http, HTTP_FIELD_HOST),\n          sizeof(con->clientname));\n  if ((ptr = strrchr(con->clientname, ':')) != NULL && !strchr(ptr, ']'))\n  {\n    *ptr++ = '\\0';\n    con->clientport = atoi(ptr);\n  }\n  else\n    con->clientport = con->serverport;\n\n /*\n  * Then validate...\n  */\n\n  if (httpAddrLocalhost(httpGetAddress(con->http)))\n  {\n   /*\n    * Only allow \"localhost\" or the equivalent IPv4 or IPv6 numerical\n    * addresses when accessing CUPS via the loopback interface...\n    */\n\n    return (!_cups_strcasecmp(con->clientname, \"localhost\") ||\n\t    !_cups_strcasecmp(con->clientname, \"localhost.\") ||\n            !strcmp(con->clientname, \"127.0.0.1\") ||\n\t    !strcmp(con->clientname, \"[::1]\"));\n  }\n\n#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)\n /*\n  * Check if the hostname is something.local (Bonjour); if so, allow it.\n  */\n\n  if ((end = strrchr(con->clientname, '.')) != NULL && end > con->clientname &&\n      !end[1])\n  {\n   /*\n    * \".\" on end, work back to second-to-last \".\"...\n    */\n\n    for (end --; end > con->clientname && *end != '.'; end --);\n  }\n\n  if (end && (!_cups_strcasecmp(end, \".local\") ||\n\t      !_cups_strcasecmp(end, \".local.\")))\n    return (1);\n#endif /* HAVE_DNSSD || HAVE_AVAHI */\n\n /*\n  * Check if the hostname is an IP address...\n  */\n\n  if (isdigit(con->clientname[0] & 255) || con->clientname[0] == '[')\n  {\n   /*\n    * Possible IPv4/IPv6 address...\n    */\n\n    http_addrlist_t *addrlist;\t\t/* List of addresses */\n\n\n    if ((addrlist = httpAddrGetList(con->clientname, AF_UNSPEC, NULL)) != NULL)\n    {\n     /*\n      * Good IPv4/IPv6 address...\n      */\n\n      httpAddrFreeList(addrlist);\n      return (1);\n    }\n  }\n\n /*\n  * Check for (alias) name matches...\n  */\n\n  for (a = (cupsd_alias_t *)cupsArrayFirst(ServerAlias);\n       a;\n       a = (cupsd_alias_t *)cupsArrayNext(ServerAlias))\n  {\n   /*\n    * \"ServerAlias *\" allows all host values through...\n    */\n\n    if (!strcmp(a->name, \"*\"))\n      return (1);\n\n    if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))\n    {\n     /*\n      * Prefix matches; check the character at the end - it must be \".\" or nul.\n      */\n\n      end = con->clientname + a->namelen;\n\n      if (!*end || (*end == '.' && !end[1]))\n        return (1);\n    }\n  }\n\n#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)\n  for (a = (cupsd_alias_t *)cupsArrayFirst(DNSSDAlias);\n       a;\n       a = (cupsd_alias_t *)cupsArrayNext(DNSSDAlias))\n  {\n   /*\n    * \"ServerAlias *\" allows all host values through...\n    */\n\n    if (!strcmp(a->name, \"*\"))\n      return (1);\n\n    if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))\n    {\n     /*\n      * Prefix matches; check the character at the end - it must be \".\" or nul.\n      */\n\n      end = con->clientname + a->namelen;\n\n      if (!*end || (*end == '.' && !end[1]))\n        return (1);\n    }\n  }\n#endif /* HAVE_DNSSD || HAVE_AVAHI */\n\n /*\n  * Check for interface hostname matches...\n  */\n\n  for (netif = (cupsd_netif_t *)cupsArrayFirst(NetIFList);\n       netif;\n       netif = (cupsd_netif_t *)cupsArrayNext(NetIFList))\n  {\n    if (!_cups_strncasecmp(con->clientname, netif->hostname, netif->hostlen))\n    {\n     /*\n      * Prefix matches; check the character at the end - it must be \".\" or nul.\n      */\n\n      end = con->clientname + netif->hostlen;\n\n      if (!*end || (*end == '.' && !end[1]))\n        return (1);\n    }\n  }\n\n  return (0);\n}\n\n\n/*\n * 'write_file()' - Send a file via HTTP.\n */\n\nstatic int\t\t\t\t/* O - 0 on failure, 1 on success */\nwrite_file(cupsd_client_t *con,\t\t/* I - Client connection */\n           http_status_t  code,\t\t/* I - HTTP status */\n\t   char           *filename,\t/* I - Filename */\n\t   char           *type,\t/* I - File type */\n\t   struct stat    *filestats)\t/* O - File information */\n{\n  con->file = open(filename, O_RDONLY);\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"write_file: code=%d, filename=\\\"%s\\\" (%d), type=\\\"%s\\\", filestats=%p.\", code, filename, con->file, type ? type : \"(null)\", filestats);\n\n  if (con->file < 0)\n    return (0);\n\n  fcntl(con->file, F_SETFD, fcntl(con->file, F_GETFD) | FD_CLOEXEC);\n\n  con->pipe_pid    = 0;\n  con->sent_header = 1;\n\n  httpClearFields(con->http);\n\n  httpSetLength(con->http, (size_t)filestats->st_size);\n\n  httpSetField(con->http, HTTP_FIELD_LAST_MODIFIED,\n\t       httpGetDateString(filestats->st_mtime));\n\n  if (!cupsdSendHeader(con, code, type, CUPSD_AUTH_NONE))\n    return (0);\n\n  cupsdAddSelect(httpGetFd(con->http), NULL, (cupsd_selfunc_t)cupsdWriteClient, con);\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Sending file.\");\n\n  return (1);\n}\n\n\n/*\n * 'write_pipe()' - Flag that data is available on the CGI pipe.\n */\n\nstatic void\nwrite_pipe(cupsd_client_t *con)\t\t/* I - Client connection */\n{\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"write_pipe: CGI output on fd %d.\", con->file);\n\n  con->file_ready = 1;\n\n  cupsdRemoveSelect(con->file);\n  cupsdAddSelect(httpGetFd(con->http), NULL, (cupsd_selfunc_t)cupsdWriteClient, con);\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"CGI data ready to be sent.\");\n}\n"], "filenames": ["scheduler/client.c"], "buggy_code_start_loc": [3893], "buggy_code_end_loc": [3896], "fixing_code_start_loc": [3892], "fixing_code_end_loc": [3892], "type": "CWE-290", "message": "A localhost.localdomain whitelist entry in valid_host() in scheduler/client.c in CUPS before 2.2.2 allows remote attackers to execute arbitrary IPP commands by sending POST requests to the CUPS daemon in conjunction with DNS rebinding. The localhost.localdomain name is often resolved via a DNS server (neither the OS nor the web browser is responsible for ensuring that localhost.localdomain is 127.0.0.1).", "other": {"cve": {"id": "CVE-2017-18190", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-16T17:29:00.217", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A localhost.localdomain whitelist entry in valid_host() in scheduler/client.c in CUPS before 2.2.2 allows remote attackers to execute arbitrary IPP commands by sending POST requests to the CUPS daemon in conjunction with DNS rebinding. The localhost.localdomain name is often resolved via a DNS server (neither the OS nor the web browser is responsible for ensuring that localhost.localdomain is 127.0.0.1)."}, {"lang": "es", "value": "Una entrada en la lista blanca localhost.localdomain en valid_host() en scheduler/client.c en CUPS, en versiones anteriores a la 2.2.2, permite que atacantes remotos ejecuten comandos IPP arbitrarios mediante el env\u00edo de peticiones POST al demonio CUPS junto con reenlaces DNS. El nombre localhost.localdomain suele resolverse mediante un servidor DNS (ni el sistema operativo ni el navegador web son responsables de garantizar que localhost.localdomain sea 127.0.0.1)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-290"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apple:cups:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.2", "matchCriteriaId": "295435A4-C8D6-4FB5-9C28-D63A1B88DCFA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=1048", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/apple/cups/commit/afa80cb2b457bf8d64f775bed307588610476c41", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/02/msg00023.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00003.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3577-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/apple/cups/commit/afa80cb2b457bf8d64f775bed307588610476c41"}}