{"buggy_code": ["\"\"\"TokenManager service is a HTTPs-exposed service responsible for token management, namely storing, updating,\nrequesting new tokens for DIRAC components that have the appropriate permissions.\n\n.. note:: As a newly created service, it will not support the old DIPS protocol, which is living to its age.\n\n.. literalinclude:: ../ConfigTemplate.cfg\n    :start-after: ##BEGIN TokenManager:\n    :end-before: ##END\n    :dedent: 2\n    :caption: TokenManager options\n\nThe most common use of this service is to obtain tokens with certain scope to return to the user for its purposes,\nor to provide to the DIRAC service to perform asynchronous tasks on behalf of the user.\nThis is mainly about the :py:meth:`export_getToken` method.\n\n.. image:: /_static/Systems/FS/TokenManager_getToken.png\n    :alt: https://dirac.readthedocs.io/en/integration/_images/TokenManager_getToken.png (source https://github.com/TaykYoku/DIRACIMGS/raw/main/TokenManagerService_getToken.ai)\n\nThe service and its client have a mechanism for caching the received tokens.\nThis helps reduce the number of requests to both the service and the Identity Provider (IdP).\n\nIf the client has a valid **access token** in the cache, it is used until it expires.\nAfter that you need to update. The client can update it independently if on the server where it is in ``dirac.cfg``\n``client_id`` and ``client_secret`` of the Identity Provider client are registered.\n\nOtherwise, the client makes an RPC call to the **TornadoManager** service.\nIt in turn checks the cache and if the ``access token`` is already invalid tries to update it using a ``refresh token``.\nIf the required token is not in the cache, then the ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`\nis taken and the **exchange token** request to Identity Provider is made. The received tokens are cached.\n\"\"\"\n\nimport pprint\n\nfrom DIRAC import S_OK, S_ERROR\nfrom DIRAC.Core.Security import Properties\nfrom DIRAC.Core.Utilities import ThreadSafe\nfrom DIRAC.Core.Utilities.DictCache import DictCache\nfrom DIRAC.Core.Tornado.Server.TornadoService import TornadoService\nfrom DIRAC.FrameworkSystem.DB.TokenDB import TokenDB\nfrom DIRAC.ConfigurationSystem.Client.Helpers import Registry\nfrom DIRAC.Resources.IdProvider.IdProviderFactory import IdProviderFactory\nfrom DIRAC.FrameworkSystem.Utilities.TokenManagementUtilities import (\n    getIdProviderClient,\n    getCachedKey,\n    getCachedToken,\n    DEFAULT_RT_EXPIRATION_TIME,\n    DEFAULT_AT_EXPIRATION_TIME,\n)\n\n\n# Used to synchronize the cache with user tokens\ngTokensSync = ThreadSafe.Synchronizer()\n\n\nclass TokenManagerHandler(TornadoService):\n    DEFAULT_AUTHORIZATION = [\"authenticated\"]\n\n    @classmethod\n    def initializeHandler(cls, *args):\n        \"\"\"Initialization\n\n        :return: S_OK()/S_ERROR()\n        \"\"\"\n        # Cache containing tokens from scope requested by the client\n        cls.__tokensCache = DictCache()\n\n        # The service plays an important OAuth 2.0 role, namely it is an Identity Provider client.\n        # This allows you to manage tokens without the involvement of their owners.\n        cls.idps = IdProviderFactory()\n\n        # Let's try to connect to the database\n        try:\n            cls.__tokenDB = TokenDB(parentLogger=cls.log)\n        except Exception as e:\n            cls.log.exception(e)\n            return S_ERROR(f\"Could not connect to the database {repr(e)}\")\n\n        return S_OK()\n\n    def export_getUserTokensInfo(self):\n        \"\"\"Generate information dict about user tokens\n\n        :return: dict\n        \"\"\"\n        tokensInfo = []\n        credDict = self.getRemoteCredentials()\n        result = Registry.getDNForUsername(credDict[\"username\"])\n        if not result[\"OK\"]:\n            return result\n        for dn in result[\"Value\"]:\n            result = Registry.getIDFromDN(dn)\n            if result[\"OK\"]:\n                result = self.__tokenDB.getTokensByUserID(result[\"Value\"])\n                if not result[\"OK\"]:\n                    return result\n                tokensInfo += result[\"Value\"]\n        return S_OK(tokensInfo)\n\n    auth_getUsersTokensInfo = [Properties.PROXY_MANAGEMENT]\n\n    def export_getUsersTokensInfo(self, users: list):\n        \"\"\"Get the info about the user tokens in the database\n\n        :param users: user names\n\n        :return: S_OK(list) -- return list of tokens dictionaries\n        \"\"\"\n        tokensInfo = []\n        for user in users:\n            # Find the user ID among his DNs\n            result = Registry.getDNForUsername(user)\n            if not result[\"OK\"]:\n                return result\n            for dn in result[\"Value\"]:\n                uid = Registry.getIDFromDN(dn).get(\"Value\")\n                if uid:\n                    result = self.__tokenDB.getTokensByUserID(uid)\n                    if not result[\"OK\"]:\n                        self.log.error(result[\"Message\"])\n                    else:\n                        for tokenDict in result[\"Value\"]:\n                            if tokenDict not in tokensInfo:\n                                # The database does not contain a username,\n                                # as it is a unique user ID exclusively for DIRAC\n                                # and is not associated with a token.\n                                tokenDict[\"username\"] = user\n                                tokensInfo.append(tokenDict)\n        return S_OK(tokensInfo)\n\n    def export_updateToken(self, token: dict, userID: str, provider: str, rt_expired_in: int = 24 * 3600):\n        \"\"\"Using this method, you can transfer user tokens for storage in the TokenManager.\n\n        It is important to note that TokenManager saves only one token per user and, accordingly,\n        the Identity Provider from which it was issued. So when a new token is delegated,\n        keep in mind that the old token will be deleted.\n\n        :param token: token\n        :param userID: user ID\n        :param provider: provider name\n        :param rt_expired_in: refresh token expires time (in seconds)\n\n        :return: S_OK(list)/S_ERROR() -- list contain uploaded tokens info as dictionaries\n        \"\"\"\n        self.log.verbose(f\"Update {userID} user token issued by {provider}:\\n\", pprint.pformat(token))\n        # prepare the client instance of the appropriate IdP to revoke the old tokens\n        result = self.idps.getIdProvider(provider)\n        if not result[\"OK\"]:\n            return result\n        idPObj = result[\"Value\"]\n        # overwrite old tokens with new ones\n        result = self.__tokenDB.updateToken(token, userID, provider, rt_expired_in)\n        if not result[\"OK\"]:\n            return result\n        # revoke the old tokens\n        for oldToken in result[\"Value\"]:\n            if \"refresh_token\" in oldToken and oldToken[\"refresh_token\"] != token[\"refresh_token\"]:\n                self.log.verbose(\"Revoke old refresh token:\\n\", pprint.pformat(oldToken))\n                idPObj.revokeToken(oldToken[\"refresh_token\"])\n        # Let's return to the current situation with the storage of user tokens\n        return self.__tokenDB.getTokensByUserID(userID)\n\n    def __checkProperties(self, requestedUserDN: str, requestedUserGroup: str):\n        \"\"\"Check the properties and return if they can only download limited tokens if authorized\n\n        :param requestedUserDN: user DN\n        :param requestedUserGroup: DIRAC group\n\n        :return: S_OK(bool)/S_ERROR()\n        \"\"\"\n        credDict = self.getRemoteCredentials()\n        if Properties.FULL_DELEGATION in credDict[\"properties\"]:\n            return S_OK(False)\n        if Properties.LIMITED_DELEGATION in credDict[\"properties\"]:\n            return S_OK(True)\n        if Properties.PRIVATE_LIMITED_DELEGATION in credDict[\"properties\"]:\n            if credDict[\"DN\"] != requestedUserDN:\n                return S_ERROR(\"You are not allowed to download any token\")\n            if Properties.PRIVATE_LIMITED_DELEGATION not in Registry.getPropertiesForGroup(requestedUserGroup):\n                return S_ERROR(\"You can't download tokens for that group\")\n            return S_OK(True)\n        # Not authorized!\n        return S_ERROR(\"You can't get tokens!\")\n\n    @gTokensSync\n    def export_getToken(\n        self,\n        username: str = None,\n        userGroup: str = None,\n        scope: list[str] = None,\n        audience: str = None,\n        identityProvider: str = None,\n        requiredTimeLeft: int = 0,\n    ):\n        \"\"\"Get an access token for a user/group.\n\n        * Properties:\n            * FullDelegation <- permits full delegation of tokens\n            * LimitedDelegation <- permits downloading only limited tokens\n            * PrivateLimitedDelegation <- permits downloading only limited tokens for one self\n\n        :param username: user name\n        :param userGroup: user group\n        :param scope: requested scope\n        :param audience: requested audience\n        :param identityProvider: Identity Provider name\n        :param requiredTimeLeft: requested minimum life time\n\n        :return: S_OK(dict)/S_ERROR()\n        \"\"\"\n        # Get an IdProvider Client instance\n        result = getIdProviderClient(userGroup, identityProvider)\n        if not result[\"OK\"]:\n            return result\n        idpObj = result[\"Value\"]\n\n        # Search for an existing token in tokensCache\n        cachedKey = getCachedKey(idpObj, username, userGroup, scope, audience)\n        result = getCachedToken(self.__tokensCache, cachedKey, requiredTimeLeft)\n        if result[\"OK\"]:\n            # A valid token has been found and is returned\n            return result\n\n        # A client token is requested\n        if not username:\n            result = self.__checkProperties(\"\", \"\")\n            if not result[\"OK\"]:\n                return result\n\n            # Get the client token with requested scope and audience\n            scope = cachedKey[1]\n            audience = cachedKey[2]\n            result = idpObj.fetchToken(grant_type=\"client_credentials\", scope=scope, audience=audience)\n            if not result[\"OK\"]:\n                return result\n            token = result[\"Value\"]\n\n            # Caching new token: only get an access token (no refresh token in this context)\n            self.__tokensCache.add(\n                cachedKey,\n                result[\"Value\"].get_claim(\"exp\", \"access_token\") or DEFAULT_AT_EXPIRATION_TIME,\n                token,\n            )\n            return result\n\n        # A user token is requested\n        err = []\n        # No luck so far, let's refresh the token stored in the database\n        result = Registry.getDNForUsername(username)\n        if not result[\"OK\"]:\n            return result\n        for dn in result[\"Value\"]:\n            # For backward compatibility, the user ID is written as DN. So let's check if this DN contains a user ID\n            result = Registry.getIDFromDN(dn)\n            if result[\"OK\"]:\n                uid = result[\"Value\"]\n                # To do this, first find the refresh token stored in the database with the maximum scope\n                result = self.__tokenDB.getTokenForUserProvider(uid, idpObj.name)\n                if result[\"OK\"] and result[\"Value\"]:\n                    tokens = result[\"Value\"]\n                    result = self.__checkProperties(dn, userGroup)\n                    if result[\"OK\"]:\n                        # refresh token with requested scope\n                        result = idpObj.refreshToken(tokens.get(\"refresh_token\"), group=userGroup, scope=scope)\n                        if result[\"OK\"]:\n                            # caching new tokens\n                            self.__tokensCache.add(\n                                cachedKey,\n                                result[\"Value\"].get_claim(\"exp\", \"refresh_token\") or DEFAULT_RT_EXPIRATION_TIME,\n                                result[\"Value\"],\n                            )\n                            return result\n                # Did not find any token associated with the found user ID\n                err.append(result.get(\"Message\", f\"No token found for {uid}\"))\n        # Collect all errors when trying to get a token, or if no user ID is registered\n        return S_ERROR(\"; \".join(err or [f\"No user ID found for {username}\"]))\n\n    def export_deleteToken(self, userDN: str):\n        \"\"\"Delete a token from the DB\n\n        :param userDN: user DN\n\n        :return: S_OK()/S_ERROR()\n        \"\"\"\n\n        # temporary ugly stuff to make it compliant with proxy management\n        userDN = f\"/O=DIRAC/CN={userDN}\"\n\n        # Delete it from cache\n        credDict = self.getRemoteCredentials()\n        if Properties.PROXY_MANAGEMENT not in credDict[\"properties\"]:\n            if userDN != credDict[\"DN\"]:\n                return S_ERROR(\"You aren't allowed!\")\n        result = Registry.getIDFromDN(userDN)\n        return self.__tokenDB.removeToken(user_id=result[\"Value\"]) if result[\"OK\"] else result\n\n    def export_getTokensByUserID(self, userID: str):\n        \"\"\"Retrieve a token from the DB\n\n        :param userID: user's token id\n\n        :return: S_OK(list)/S_ERROR() token row in dict format\n        \"\"\"\n        return self.__tokenDB.getTokensByUserID(userID)\n"], "fixing_code": ["\"\"\"TokenManager service is a HTTPs-exposed service responsible for token management, namely storing, updating,\nrequesting new tokens for DIRAC components that have the appropriate permissions.\n\n.. note:: As a newly created service, it will not support the old DIPS protocol, which is living to its age.\n\n.. literalinclude:: ../ConfigTemplate.cfg\n    :start-after: ##BEGIN TokenManager:\n    :end-before: ##END\n    :dedent: 2\n    :caption: TokenManager options\n\nThe most common use of this service is to obtain tokens with certain scope to return to the user for its purposes,\nor to provide to the DIRAC service to perform asynchronous tasks on behalf of the user.\nThis is mainly about the :py:meth:`export_getToken` method.\n\n.. image:: /_static/Systems/FS/TokenManager_getToken.png\n    :alt: https://dirac.readthedocs.io/en/integration/_images/TokenManager_getToken.png (source https://github.com/TaykYoku/DIRACIMGS/raw/main/TokenManagerService_getToken.ai)\n\nThe client has a mechanism for caching the received tokens.\nThis helps reduce the number of requests to both the service and the Identity Provider (IdP).\n\nIf the client has a valid **access token** in the cache, it is used until it expires.\nAfter that you need to update. The client can update it independently if on the server where it is in ``dirac.cfg``\n``client_id`` and ``client_secret`` of the Identity Provider client are registered.\n\nOtherwise, the client makes an RPC call to the **TornadoManager** service.\nThe ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`\nis taken and the **exchange token** request to Identity Provider is made.\n\"\"\"\n\nimport pprint\n\nfrom DIRAC import S_OK, S_ERROR\nfrom DIRAC.Core.Security import Properties\nfrom DIRAC.Core.Utilities import ThreadSafe\nfrom DIRAC.Core.Utilities.DictCache import DictCache\nfrom DIRAC.Core.Tornado.Server.TornadoService import TornadoService\nfrom DIRAC.FrameworkSystem.DB.TokenDB import TokenDB\nfrom DIRAC.ConfigurationSystem.Client.Helpers import Registry\nfrom DIRAC.Resources.IdProvider.IdProviderFactory import IdProviderFactory\nfrom DIRAC.FrameworkSystem.Utilities.TokenManagementUtilities import (\n    getIdProviderClient,\n    getCachedKey,\n    DEFAULT_RT_EXPIRATION_TIME,\n    DEFAULT_AT_EXPIRATION_TIME,\n)\n\n\nclass TokenManagerHandler(TornadoService):\n    DEFAULT_AUTHORIZATION = [\"authenticated\"]\n\n    @classmethod\n    def initializeHandler(cls, *args):\n        \"\"\"Initialization\n\n        :return: S_OK()/S_ERROR()\n        \"\"\"\n\n        # The service plays an important OAuth 2.0 role, namely it is an Identity Provider client.\n        # This allows you to manage tokens without the involvement of their owners.\n        cls.idps = IdProviderFactory()\n\n        # Let's try to connect to the database\n        try:\n            cls.__tokenDB = TokenDB(parentLogger=cls.log)\n        except Exception as e:\n            cls.log.exception(e)\n            return S_ERROR(f\"Could not connect to the database {repr(e)}\")\n\n        return S_OK()\n\n    def export_getUserTokensInfo(self):\n        \"\"\"Generate information dict about user tokens\n\n        :return: dict\n        \"\"\"\n        tokensInfo = []\n        credDict = self.getRemoteCredentials()\n        result = Registry.getDNForUsername(credDict[\"username\"])\n        if not result[\"OK\"]:\n            return result\n        for dn in result[\"Value\"]:\n            result = Registry.getIDFromDN(dn)\n            if result[\"OK\"]:\n                result = self.__tokenDB.getTokensByUserID(result[\"Value\"])\n                if not result[\"OK\"]:\n                    return result\n                tokensInfo += result[\"Value\"]\n        return S_OK(tokensInfo)\n\n    auth_getUsersTokensInfo = [Properties.PROXY_MANAGEMENT]\n\n    def export_getUsersTokensInfo(self, users: list):\n        \"\"\"Get the info about the user tokens in the database\n\n        :param users: user names\n\n        :return: S_OK(list) -- return list of tokens dictionaries\n        \"\"\"\n        tokensInfo = []\n        for user in users:\n            # Find the user ID among his DNs\n            result = Registry.getDNForUsername(user)\n            if not result[\"OK\"]:\n                return result\n            for dn in result[\"Value\"]:\n                uid = Registry.getIDFromDN(dn).get(\"Value\")\n                if uid:\n                    result = self.__tokenDB.getTokensByUserID(uid)\n                    if not result[\"OK\"]:\n                        self.log.error(result[\"Message\"])\n                    else:\n                        for tokenDict in result[\"Value\"]:\n                            if tokenDict not in tokensInfo:\n                                # The database does not contain a username,\n                                # as it is a unique user ID exclusively for DIRAC\n                                # and is not associated with a token.\n                                tokenDict[\"username\"] = user\n                                tokensInfo.append(tokenDict)\n        return S_OK(tokensInfo)\n\n    def export_updateToken(self, token: dict, userID: str, provider: str, rt_expired_in: int = 24 * 3600):\n        \"\"\"Using this method, you can transfer user tokens for storage in the TokenManager.\n\n        It is important to note that TokenManager saves only one token per user and, accordingly,\n        the Identity Provider from which it was issued. So when a new token is delegated,\n        keep in mind that the old token will be deleted.\n\n        :param token: token\n        :param userID: user ID\n        :param provider: provider name\n        :param rt_expired_in: refresh token expires time (in seconds)\n\n        :return: S_OK(list)/S_ERROR() -- list contain uploaded tokens info as dictionaries\n        \"\"\"\n        self.log.verbose(f\"Update {userID} user token issued by {provider}:\\n\", pprint.pformat(token))\n        # prepare the client instance of the appropriate IdP to revoke the old tokens\n        result = self.idps.getIdProvider(provider)\n        if not result[\"OK\"]:\n            return result\n        idPObj = result[\"Value\"]\n        # overwrite old tokens with new ones\n        result = self.__tokenDB.updateToken(token, userID, provider, rt_expired_in)\n        if not result[\"OK\"]:\n            return result\n        # revoke the old tokens\n        for oldToken in result[\"Value\"]:\n            if \"refresh_token\" in oldToken and oldToken[\"refresh_token\"] != token[\"refresh_token\"]:\n                self.log.verbose(\"Revoke old refresh token:\\n\", pprint.pformat(oldToken))\n                idPObj.revokeToken(oldToken[\"refresh_token\"])\n        # Let's return to the current situation with the storage of user tokens\n        return self.__tokenDB.getTokensByUserID(userID)\n\n    def __checkProperties(self, requestedUserDN: str, requestedUserGroup: str):\n        \"\"\"Check the properties and return if they can only download limited tokens if authorized\n\n        :param requestedUserDN: user DN\n        :param requestedUserGroup: DIRAC group\n\n        :return: S_OK(bool)/S_ERROR()\n        \"\"\"\n        credDict = self.getRemoteCredentials()\n        if Properties.FULL_DELEGATION in credDict[\"properties\"]:\n            return S_OK(False)\n        if Properties.LIMITED_DELEGATION in credDict[\"properties\"]:\n            return S_OK(True)\n        if Properties.PRIVATE_LIMITED_DELEGATION in credDict[\"properties\"]:\n            if credDict[\"DN\"] != requestedUserDN:\n                return S_ERROR(\"You are not allowed to download any token\")\n            if Properties.PRIVATE_LIMITED_DELEGATION not in Registry.getPropertiesForGroup(requestedUserGroup):\n                return S_ERROR(\"You can't download tokens for that group\")\n            return S_OK(True)\n        # Not authorized!\n        return S_ERROR(\"You can't get tokens!\")\n\n    def export_getToken(\n        self,\n        username: str = None,\n        userGroup: str = None,\n        scope: list[str] = None,\n        audience: str = None,\n        identityProvider: str = None,\n        requiredTimeLeft: int = 0,\n    ):\n        \"\"\"Get an access token for a user/group.\n\n        * Properties:\n            * FullDelegation <- permits full delegation of tokens\n            * LimitedDelegation <- permits downloading only limited tokens\n            * PrivateLimitedDelegation <- permits downloading only limited tokens for one self\n\n        :param username: user name\n        :param userGroup: user group\n        :param scope: requested scope\n        :param audience: requested audience\n        :param identityProvider: Identity Provider name\n        :param requiredTimeLeft: requested minimum life time\n\n        :return: S_OK(dict)/S_ERROR()\n        \"\"\"\n        # Get an IdProvider Client instance\n        result = getIdProviderClient(userGroup, identityProvider)\n        if not result[\"OK\"]:\n            return result\n        idpObj = result[\"Value\"]\n\n        # getCachedKey is just used here to resolve the default scopes\n        _, scope, *_ = getCachedKey(idpObj, username, userGroup, scope, audience)\n\n        # A client token is requested\n        if not username:\n            result = self.__checkProperties(\"\", \"\")\n            if not result[\"OK\"]:\n                return result\n\n            # Get the client token with requested scope and audience\n            result = idpObj.fetchToken(grant_type=\"client_credentials\", scope=scope, audience=audience)\n\n            return result\n\n        # A user token is requested\n        err = []\n        # No luck so far, let's refresh the token stored in the database\n        result = Registry.getDNForUsername(username)\n        if not result[\"OK\"]:\n            return result\n        for dn in result[\"Value\"]:\n            # For backward compatibility, the user ID is written as DN. So let's check if this DN contains a user ID\n            result = Registry.getIDFromDN(dn)\n            if result[\"OK\"]:\n                uid = result[\"Value\"]\n                # To do this, first find the refresh token stored in the database with the maximum scope\n                result = self.__tokenDB.getTokenForUserProvider(uid, idpObj.name)\n                if result[\"OK\"] and result[\"Value\"]:\n                    tokens = result[\"Value\"]\n                    result = self.__checkProperties(dn, userGroup)\n                    if result[\"OK\"]:\n                        # refresh token with requested scope\n                        result = idpObj.refreshToken(tokens.get(\"refresh_token\"), group=userGroup, scope=scope)\n                        if result[\"OK\"]:\n                            return result\n                # Did not find any token associated with the found user ID\n                err.append(result.get(\"Message\", f\"No token found for {uid}\"))\n        # Collect all errors when trying to get a token, or if no user ID is registered\n        return S_ERROR(\"; \".join(err or [f\"No user ID found for {username}\"]))\n\n    def export_deleteToken(self, userDN: str):\n        \"\"\"Delete a token from the DB\n\n        :param userDN: user DN\n\n        :return: S_OK()/S_ERROR()\n        \"\"\"\n\n        # temporary ugly stuff to make it compliant with proxy management\n        userDN = f\"/O=DIRAC/CN={userDN}\"\n\n        # Delete it from cache\n        credDict = self.getRemoteCredentials()\n        if Properties.PROXY_MANAGEMENT not in credDict[\"properties\"]:\n            if userDN != credDict[\"DN\"]:\n                return S_ERROR(\"You aren't allowed!\")\n        result = Registry.getIDFromDN(userDN)\n        return self.__tokenDB.removeToken(user_id=result[\"Value\"]) if result[\"OK\"] else result\n\n    def export_getTokensByUserID(self, userID: str):\n        \"\"\"Retrieve a token from the DB\n\n        :param userID: user's token id\n\n        :return: S_OK(list)/S_ERROR() token row in dict format\n        \"\"\"\n        return self.__tokenDB.getTokensByUserID(userID)\n"], "filenames": ["src/DIRAC/FrameworkSystem/Service/TokenManagerHandler.py"], "buggy_code_start_loc": [19], "buggy_code_end_loc": [271], "fixing_code_start_loc": [19], "fixing_code_end_loc": [240], "type": "CWE-200", "message": "DIRAC is a distributed resource framework. In affected versions any user could get a token that has been requested by another user/agent. This may expose resources to unintended parties. This issue has been addressed in release version 8.0.37. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2024-24825", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-09T00:15:08.903", "lastModified": "2024-02-16T21:37:47.923", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "DIRAC is a distributed resource framework. In affected versions any user could get a token that has been requested by another user/agent. This may expose resources to unintended parties. This issue has been addressed in release version 8.0.37. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "DIRAC es un framework de recursos distribuidos. En las versiones afectadas, cualquier usuario podr\u00eda obtener un token solicitado por otro usuario/agente. Esto puede exponer los recursos a partes no deseadas. Este problema se solucion\u00f3 en la versi\u00f3n 8.0.37. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:diracgrid:dirac:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.0.37", "matchCriteriaId": "4DF1FFD5-3D44-4605-8B1F-6BB3188E923E"}]}]}], "references": [{"url": "https://github.com/DIRACGrid/DIRAC/commit/f9ddab755b9a69acb85e14d2db851d8ac0c9648c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/DIRACGrid/DIRAC/security/advisories/GHSA-59qj-jcjv-662j", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DIRACGrid/DIRAC/commit/f9ddab755b9a69acb85e14d2db851d8ac0c9648c"}}