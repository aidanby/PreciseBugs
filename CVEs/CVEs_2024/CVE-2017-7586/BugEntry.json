{"buggy_code": ["/*\n** Copyright (C) 1999-2016 Erik de Castro Lopo <erikd@mega-nerd.com>\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n#include <config.h>\n\n#include <stdarg.h>\n#include <string.h>\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <ctype.h>\n#include <math.h>\n#include <time.h>\n#if HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#include \"sndfile.h\"\n#include \"sfendian.h\"\n#include \"common.h\"\n\n/*-----------------------------------------------------------------------------------------------\n** psf_log_printf allows libsndfile internal functions to print to an internal parselog which\n** can later be displayed.\n** The format specifiers are as for printf but without the field width and other modifiers.\n** Printing is performed to the parselog char array of the SF_PRIVATE struct.\n** Printing is done in such a way as to guarantee that the log never overflows the end of the\n** parselog array.\n*/\n\nstatic inline void\nlog_putchar (SF_PRIVATE *psf, char ch)\n{\tif (psf->parselog.indx < SIGNED_SIZEOF (psf->parselog.buf) - 1)\n\t{\tpsf->parselog.buf [psf->parselog.indx++] = ch ;\n\t\tpsf->parselog.buf [psf->parselog.indx] = 0 ;\n\t\t} ;\n\treturn ;\n} /* log_putchar */\n\nvoid\npsf_log_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\t\tap ;\n\tuint32_t\tu ;\n\tint\t\t\td, tens, shift, width, width_specifier, left_align, slen ;\n\tchar\t\tc, *strptr, istr [5], lead_char, sign_char ;\n\n\tva_start (ap, format) ;\n\n\twhile ((c = *format++))\n\t{\tif (c != '%')\n\t\t{\tlog_putchar (psf, c) ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tif (format [0] == '%') /* Handle %% */\n\t\t{ \tlog_putchar (psf, '%') ;\n\t\t\tformat ++ ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tsign_char = 0 ;\n\t\tleft_align = SF_FALSE ;\n\t\twhile (1)\n\t\t{\tswitch (format [0])\n\t\t\t{\tcase ' ' :\n\t\t\t\tcase '+' :\n\t\t\t\t\tsign_char = format [0] ;\n\t\t\t\t\tformat ++ ;\n\t\t\t\t\tcontinue ;\n\n\t\t\t\tcase '-' :\n\t\t\t\t\tleft_align = SF_TRUE ;\n\t\t\t\t\tformat ++ ;\n\t\t\t\t\tcontinue ;\n\n\t\t\t\tdefault : break ;\n\t\t\t\t} ;\n\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (format [0] == 0)\n\t\t\tbreak ;\n\n\t\tlead_char = ' ' ;\n\t\tif (format [0] == '0')\n\t\t\tlead_char = '0' ;\n\n\t\twidth_specifier = 0 ;\n\t\twhile ((c = *format++) && isdigit (c))\n\t\t\twidth_specifier = width_specifier * 10 + (c - '0') ;\n\n\t\tswitch (c)\n\t\t{\tcase 0 : /* NULL character. */\n\t\t\t\t\tva_end (ap) ;\n\t\t\t\t\treturn ;\n\n\t\t\tcase 's': /* string */\n\t\t\t\t\tstrptr = va_arg (ap, char *) ;\n\t\t\t\t\tif (strptr == NULL)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tslen = strlen (strptr) ;\n\t\t\t\t\twidth_specifier = width_specifier >= slen ? width_specifier - slen : 0 ;\n\t\t\t\t\tif (left_align == SF_FALSE)\n\t\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\t\tlog_putchar (psf, ' ') ;\n\t\t\t\t\twhile (*strptr)\n\t\t\t\t\t\tlog_putchar (psf, *strptr++) ;\n\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\tlog_putchar (psf, ' ') ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'd': /* int */\n\t\t\t\t\td = va_arg (ap, int) ;\n\n\t\t\t\t\tif (d < 0)\n\t\t\t\t\t{\td = -d ;\n\t\t\t\t\t\tsign_char = '-' ;\n\t\t\t\t\t\tif (lead_char != '0' && left_align == SF_FALSE)\n\t\t\t\t\t\t\twidth_specifier -- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\ttens = 1 ;\n\t\t\t\t\twidth = 1 ;\n\t\t\t\t\twhile (d / tens >= 10)\n\t\t\t\t\t{\ttens *= 10 ;\n\t\t\t\t\t\twidth ++ ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\twidth_specifier -= width ;\n\n\t\t\t\t\tif (sign_char == ' ')\n\t\t\t\t\t{\tlog_putchar (psf, ' ') ;\n\t\t\t\t\t\twidth_specifier -- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (left_align == SF_FALSE && lead_char != '0')\n\t\t\t\t\t{\tif (sign_char == '+')\n\t\t\t\t\t\t\twidth_specifier -- ;\n\n\t\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (sign_char == '+' || sign_char == '-')\n\t\t\t\t\t{\tlog_putchar (psf, sign_char) ;\n\t\t\t\t\t\twidth_specifier -- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (left_align == SF_FALSE)\n\t\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\n\t\t\t\t\twhile (tens > 0)\n\t\t\t\t\t{\tlog_putchar (psf, '0' + d / tens) ;\n\t\t\t\t\t\td %= tens ;\n\t\t\t\t\t\ttens /= 10 ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'D': /* sf_count_t */\n\t\t\t\t\t{\tsf_count_t\t\tD, Tens ;\n\n\t\t\t\t\t\tD = va_arg (ap, sf_count_t) ;\n\n\t\t\t\t\t\tif (D == 0)\n\t\t\t\t\t\t{\twhile (-- width_specifier > 0)\n\t\t\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\t\t\tlog_putchar (psf, '0') ;\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif (D < 0)\n\t\t\t\t\t\t{\tlog_putchar (psf, '-') ;\n\t\t\t\t\t\t\tD = -D ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\tTens = 1 ;\n\t\t\t\t\t\twidth = 1 ;\n\t\t\t\t\t\twhile (D / Tens >= 10)\n\t\t\t\t\t\t{\tTens *= 10 ;\n\t\t\t\t\t\t\twidth ++ ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\twhile (width_specifier > width)\n\t\t\t\t\t\t{\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\t\t\twidth_specifier-- ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\twhile (Tens > 0)\n\t\t\t\t\t\t{\tlog_putchar (psf, '0' + D / Tens) ;\n\t\t\t\t\t\t\tD %= Tens ;\n\t\t\t\t\t\t\tTens /= 10 ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'u': /* unsigned int */\n\t\t\t\t\tu = va_arg (ap, unsigned int) ;\n\n\t\t\t\t\ttens = 1 ;\n\t\t\t\t\twidth = 1 ;\n\t\t\t\t\twhile (u / tens >= 10)\n\t\t\t\t\t{\ttens *= 10 ;\n\t\t\t\t\t\twidth ++ ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\twidth_specifier -= width ;\n\n\t\t\t\t\tif (sign_char == ' ')\n\t\t\t\t\t{\tlog_putchar (psf, ' ') ;\n\t\t\t\t\t\twidth_specifier -- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (left_align == SF_FALSE && lead_char != '0')\n\t\t\t\t\t{\tif (sign_char == '+')\n\t\t\t\t\t\t\twidth_specifier -- ;\n\n\t\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (sign_char == '+' || sign_char == '-')\n\t\t\t\t\t{\tlog_putchar (psf, sign_char) ;\n\t\t\t\t\t\twidth_specifier -- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (left_align == SF_FALSE)\n\t\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\n\t\t\t\t\twhile (tens > 0)\n\t\t\t\t\t{\tlog_putchar (psf, '0' + u / tens) ;\n\t\t\t\t\t\tu %= tens ;\n\t\t\t\t\t\ttens /= 10 ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'c': /* char */\n\t\t\t\t\tc = va_arg (ap, int) & 0xFF ;\n\t\t\t\t\tlog_putchar (psf, c) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'x': /* hex */\n\t\t\tcase 'X': /* hex */\n\t\t\t\t\td = va_arg (ap, int) ;\n\n\t\t\t\t\tif (d == 0)\n\t\t\t\t\t{\twhile (--width_specifier > 0)\n\t\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\t\tlog_putchar (psf, '0') ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tshift = 28 ;\n\t\t\t\t\twidth = (width_specifier < 8) ? 8 : width_specifier ;\n\t\t\t\t\twhile (! ((((uint32_t) 0xF) << shift) & d))\n\t\t\t\t\t{\tshift -= 4 ;\n\t\t\t\t\t\twidth -- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\twhile (width > 0 && width_specifier > width)\n\t\t\t\t\t{\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\t\twidth_specifier-- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\twhile (shift >= 0)\n\t\t\t\t\t{\tc = (d >> shift) & 0xF ;\n\t\t\t\t\t\tlog_putchar (psf, (c > 9) ? c + 'A' - 10 : c + '0') ;\n\t\t\t\t\t\tshift -= 4 ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'M': /* int2str */\n\t\t\t\t\td = va_arg (ap, int) ;\n\t\t\t\t\tif (CPU_IS_LITTLE_ENDIAN)\n\t\t\t\t\t{\tistr [0] = d & 0xFF ;\n\t\t\t\t\t\tistr [1] = (d >> 8) & 0xFF ;\n\t\t\t\t\t\tistr [2] = (d >> 16) & 0xFF ;\n\t\t\t\t\t\tistr [3] = (d >> 24) & 0xFF ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\tistr [3] = d & 0xFF ;\n\t\t\t\t\t\tistr [2] = (d >> 8) & 0xFF ;\n\t\t\t\t\t\tistr [1] = (d >> 16) & 0xFF ;\n\t\t\t\t\t\tistr [0] = (d >> 24) & 0xFF ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tistr [4] = 0 ;\n\t\t\t\t\tstrptr = istr ;\n\t\t\t\t\twhile (*strptr)\n\t\t\t\t\t{\tc = *strptr++ ;\n\t\t\t\t\t\tlog_putchar (psf, c) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\t\tlog_putchar (psf, '*') ;\n\t\t\t\t\tlog_putchar (psf, c) ;\n\t\t\t\t\tlog_putchar (psf, '*') ;\n\t\t\t\t\tbreak ;\n\t\t\t} /* switch */\n\t\t} /* while */\n\n\tva_end (ap) ;\n\treturn ;\n} /* psf_log_printf */\n\n/*-----------------------------------------------------------------------------------------------\n**  ASCII header printf functions.\n**  Some formats (ie NIST) use ascii text in their headers.\n**  Format specifiers are the same as the standard printf specifiers (uses vsnprintf).\n**  If this generates a compile error on any system, the author should be notified\n**  so an alternative vsnprintf can be provided.\n*/\n\nvoid\npsf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tint\t\tmaxlen ;\n\tchar\t*start ;\n\n\tmaxlen = strlen ((char*) psf->header) ;\n\tstart\t= ((char*) psf->header) + maxlen ;\n\tmaxlen\t= sizeof (psf->header) - maxlen ;\n\n\tva_start (argptr, format) ;\n\tvsnprintf (start, maxlen, format, argptr) ;\n\tva_end (argptr) ;\n\n\t/* Make sure the string is properly terminated. */\n\tstart [maxlen - 1] = 0 ;\n\n\tpsf->headindex = strlen ((char*) psf->header) ;\n\n\treturn ;\n} /* psf_asciiheader_printf */\n\n/*-----------------------------------------------------------------------------------------------\n**  Binary header writing functions. Returns number of bytes written.\n**\n**  Format specifiers for psf_binheader_writef are as follows\n**\t\tm\t- marker - four bytes - no endian manipulation\n**\n**\t\te   - all following numerical values will be little endian\n**\t\tE   - all following numerical values will be big endian\n**\n**\t\tt   - all following O types will be truncated to 4 bytes\n**\t\tT   - switch off truncation of all following O types\n**\n**\t\t1\t- single byte value\n**\t\t2\t- two byte value\n**\t\t3\t- three byte value\n**\t\t4\t- four byte value\n**\t\t8\t- eight byte value (sometimes written as 4 bytes)\n**\n**\t\ts   - string preceded by a four byte length\n**\t\tS   - string including null terminator\n**      p   - a Pascal string\n**\n**\t\tf\t- floating point data\n**\t\td\t- double precision floating point data\n**\t\th\t- 16 binary bytes value\n**\n**\t\tb\t- binary data (see below)\n**\t\tz   - zero bytes (ses below)\n**\t\tj\t- jump forwards or backwards\n**\n**\tTo write a word followed by an int (both little endian) use:\n**\t\tpsf_binheader_writef (\"e24\", wordval, longval) ;\n**\n**\tTo write binary data use:\n**\t\tpsf_binheader_writef (\"b\", &bindata, sizeof (bindata)) ;\n**\n**\tTo write N zero bytes use:\n**\t\t\tNOTE: due to platform issues (ie x86-64) you should cast the\n**\t\t\targument to size_t or ensure the variable type is size_t.\n**\t\tpsf_binheader_writef (\"z\", N) ;\n*/\n\n/* These macros may seem a bit messy but do prevent problems with processors which\n** seg. fault when asked to write an int or short to a non-int/short aligned address.\n*/\n\nstatic inline void\nheader_put_byte (SF_PRIVATE *psf, char x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 1)\n\t\tpsf->header [psf->headindex++] = x ;\n} /* header_put_byte */\n\n#if (CPU_IS_BIG_ENDIAN == 1)\nstatic inline void\nheader_put_marker (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_marker */\n\n#elif (CPU_IS_LITTLE_ENDIAN == 1)\nstatic inline void\nheader_put_marker (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\t} ;\n} /* header_put_marker */\n\n#else\n#\terror \"Cannot determine endian-ness of processor.\"\n#endif\n\n\nstatic inline void\nheader_put_be_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n\t{\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_be_short */\n\nstatic inline void\nheader_put_le_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\t} ;\n} /* header_put_le_short */\n\nstatic inline void\nheader_put_be_3byte (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n\t{\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_be_3byte */\n\nstatic inline void\nheader_put_le_3byte (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\t} ;\n} /* header_put_le_3byte */\n\nstatic inline void\nheader_put_be_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_be_int */\n\nstatic inline void\nheader_put_le_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\t} ;\n} /* header_put_le_int */\n\n#if (SIZEOF_SF_COUNT_T == 4)\n\nstatic inline void\nheader_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_be_8byte */\n\nstatic inline void\nheader_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\t} ;\n} /* header_put_le_8byte */\n\n#elif (SIZEOF_SF_COUNT_T == 8)\n\nstatic inline void\nheader_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = (x >> 56) ;\n\t\tpsf->header [psf->headindex++] = (x >> 48) ;\n\t\tpsf->header [psf->headindex++] = (x >> 40) ;\n\t\tpsf->header [psf->headindex++] = (x >> 32) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_be_8byte */\n\nstatic inline void\nheader_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 32) ;\n\t\tpsf->header [psf->headindex++] = (x >> 40) ;\n\t\tpsf->header [psf->headindex++] = (x >> 48) ;\n\t\tpsf->header [psf->headindex++] = (x >> 56) ;\n\t\t} ;\n} /* header_put_le_8byte */\n\n#else\n#error \"SIZEOF_SF_COUNT_T is not defined.\"\n#endif\n\nint\npsf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tsf_count_t \t\tcountdata ;\n\tunsigned long \tlongdata ;\n\tunsigned int \tdata ;\n\tfloat\t\t\tfloatdata ;\n\tdouble\t\t\tdoubledata ;\n\tvoid\t\t\t*bindata ;\n\tsize_t\t\t\tsize ;\n\tchar\t\t\tc, *strptr ;\n\tint\t\t\t\tcount = 0, trunc_8to4 ;\n\n\ttrunc_8to4 = SF_FALSE ;\n\n\tva_start (argptr, format) ;\n\n\twhile ((c = *format++))\n\t{\tswitch (c)\n\t\t{\tcase ' ' : /* Do nothing. Just used to space out format string. */\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'e' : /* All conversions are now from LE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_LITTLE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'E' : /* All conversions are now from BE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_BIG ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 't' : /* All 8 byte values now get written as 4 bytes. */\n\t\t\t\t\ttrunc_8to4 = SF_TRUE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'T' : /* All 8 byte values now get written as 8 bytes. */\n\t\t\t\t\ttrunc_8to4 = SF_FALSE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'm' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\theader_put_marker (psf, data) ;\n\t\t\t\t\tcount += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '1' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\theader_put_byte (psf, data) ;\n\t\t\t\t\tcount += 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '2' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t{\theader_put_be_short (psf, data) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_short (psf, data) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tcount += 2 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '3' : /* tribyte */\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t{\theader_put_be_3byte (psf, data) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_3byte (psf, data) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tcount += 3 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '4' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t{\theader_put_be_int (psf, data) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_int (psf, data) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tcount += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '8' :\n\t\t\t\t\tcountdata = va_arg (argptr, sf_count_t) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_FALSE)\n\t\t\t\t\t{\theader_put_be_8byte (psf, countdata) ;\n\t\t\t\t\t\tcount += 8 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE)\n\t\t\t\t\t{\theader_put_le_8byte (psf, countdata) ;\n\t\t\t\t\t\tcount += 8 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_TRUE)\n\t\t\t\t\t{\tlongdata = countdata & 0xFFFFFFFF ;\n\t\t\t\t\t\theader_put_be_int (psf, longdata) ;\n\t\t\t\t\t\tcount += 4 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_TRUE)\n\t\t\t\t\t{\tlongdata = countdata & 0xFFFFFFFF ;\n\t\t\t\t\t\theader_put_le_int (psf, longdata) ;\n\t\t\t\t\t\tcount += 4 ;\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'f' :\n\t\t\t\t\t/* Floats are passed as doubles. Is this always true? */\n\t\t\t\t\tfloatdata = (float) va_arg (argptr, double) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\tfloat32_be_write (floatdata, psf->header + psf->headindex) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tfloat32_le_write (floatdata, psf->header + psf->headindex) ;\n\t\t\t\t\tpsf->headindex += 4 ;\n\t\t\t\t\tcount += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'd' :\n\t\t\t\t\tdoubledata = va_arg (argptr, double) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\tdouble64_be_write (doubledata, psf->header + psf->headindex) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tdouble64_le_write (doubledata, psf->header + psf->headindex) ;\n\t\t\t\t\tpsf->headindex += 8 ;\n\t\t\t\t\tcount += 8 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 's' :\n\t\t\t\t\t/* Write a C string (guaranteed to have a zero terminator). */\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize = strlen (strptr) + 1 ;\n\t\t\t\t\tsize += (size & 1) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\theader_put_be_int (psf, size) ;\n\t\t\t\t\telse\n\t\t\t\t\t\theader_put_le_int (psf, size) ;\n\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), strptr, size) ;\n\t\t\t\t\tpsf->headindex += size ;\n\t\t\t\t\tpsf->header [psf->headindex - 1] = 0 ;\n\t\t\t\t\tcount += 4 + size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'S' :\n\t\t\t\t\t/*\n\t\t\t\t\t**\tWrite an AIFF style string (no zero terminator but possibly\n\t\t\t\t\t**\tan extra pad byte if the string length is odd).\n\t\t\t\t\t*/\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize = strlen (strptr) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\theader_put_be_int (psf, size) ;\n\t\t\t\t\telse\n\t\t\t\t\t\theader_put_le_int (psf, size) ;\n\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), strptr, size + 1) ;\n\t\t\t\t\tsize += (size & 1) ;\n\t\t\t\t\tpsf->headindex += size ;\n\t\t\t\t\tpsf->header [psf->headindex] = 0 ;\n\t\t\t\t\tcount += 4 + size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'p' :\n\t\t\t\t\t/* Write a PASCAL string (as used by AIFF files).\n\t\t\t\t\t*/\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize = strlen (strptr) ;\n\t\t\t\t\tsize = (size & 1) ? size : size + 1 ;\n\t\t\t\t\tsize = (size > 254) ? 254 : size ;\n\t\t\t\t\theader_put_byte (psf, size) ;\n\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), strptr, size) ;\n\t\t\t\t\tpsf->headindex += size ;\n\t\t\t\t\tcount += 1 + size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'b' :\n\t\t\t\t\tbindata\t= va_arg (argptr, void *) ;\n\t\t\t\t\tsize\t= va_arg (argptr, size_t) ;\n\t\t\t\t\tif (psf->headindex + size < sizeof (psf->header))\n\t\t\t\t\t{\tmemcpy (&(psf->header [psf->headindex]), bindata, size) ;\n\t\t\t\t\t\tpsf->headindex += size ;\n\t\t\t\t\t\tcount += size ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'z' :\n\t\t\t\t\tsize = va_arg (argptr, size_t) ;\n\t\t\t\t\tcount += size ;\n\t\t\t\t\twhile (size)\n\t\t\t\t\t{\tpsf->header [psf->headindex] = 0 ;\n\t\t\t\t\t\tpsf->headindex ++ ;\n\t\t\t\t\t\tsize -- ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'h' :\n\t\t\t\t\tbindata = va_arg (argptr, void *) ;\n\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), bindata, 16) ;\n\t\t\t\t\tpsf->headindex += 16 ;\n\t\t\t\t\tcount += 16 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'j' :\t/* Jump forwards/backwards by specified amount. */\n\t\t\t\t\tsize = va_arg (argptr, size_t) ;\n\t\t\t\t\tpsf->headindex += size ;\n\t\t\t\t\tcount += size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'o' :\t/* Jump to specified offset. */\n\t\t\t\t\tsize = va_arg (argptr, size_t) ;\n\t\t\t\t\tif (size < sizeof (psf->header))\n\t\t\t\t\t{\tpsf->headindex = size ;\n\t\t\t\t\t\tcount = 0 ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\tpsf_log_printf (psf, \"*** Invalid format specifier `%c'\\n\", c) ;\n\t\t\t\tpsf->error = SFE_INTERNAL ;\n\t\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ;\n\n\tva_end (argptr) ;\n\treturn count ;\n} /* psf_binheader_writef */\n\n/*-----------------------------------------------------------------------------------------------\n**  Binary header reading functions. Returns number of bytes read.\n**\n**\tFormat specifiers are the same as for header write function above with the following\n**\tadditions:\n**\n**\t\tp   - jump a given number of position from start of file.\n**\n**\tIf format is NULL, psf_binheader_readf returns the current offset.\n*/\n\n#if (CPU_IS_BIG_ENDIAN == 1)\n#define\tGET_MARKER(ptr)\t(\t(((uint32_t) (ptr) [0]) << 24)\t| ((ptr) [1] << 16) |\t\\\n\t\t\t\t\t\t\t((ptr) [2] << 8)\t| ((ptr) [3]))\n\n#elif (CPU_IS_LITTLE_ENDIAN == 1)\n#define\tGET_MARKER(ptr)\t(\t((ptr) [0])\t\t\t| ((ptr) [1] << 8) |\t\\\n\t\t\t\t\t\t\t((ptr) [2] << 16)\t| (((uint32_t) (ptr) [3]) << 24))\n\n#else\n#\terror \"Cannot determine endian-ness of processor.\"\n#endif\n\n#define\tGET_LE_SHORT(ptr)\t(((ptr) [1] << 8) | ((ptr) [0]))\n#define\tGET_BE_SHORT(ptr)\t(((ptr) [0] << 8) | ((ptr) [1]))\n\n#define\tGET_LE_3BYTE(ptr)\t(\t((ptr) [2] << 16) | ((ptr) [1] << 8) | ((ptr) [0]))\n#define\tGET_BE_3BYTE(ptr)\t(\t((ptr) [0] << 16) | ((ptr) [1] << 8) | ((ptr) [2]))\n\n#define\tGET_LE_INT(ptr)\t\t(\t((ptr) [3] << 24)\t| ((ptr) [2] << 16) |\t\\\n\t\t\t\t\t\t\t\t((ptr) [1] << 8)\t| ((ptr) [0]))\n\n#define\tGET_BE_INT(ptr)\t\t(\t((ptr) [0] << 24)\t| ((ptr) [1] << 16) |\t\\\n\t\t\t\t\t\t\t\t((ptr) [2] << 8)\t| ((ptr) [3]))\n\n#define\tGET_LE_8BYTE(ptr)\t(\t(((sf_count_t) (ptr) [7]) << 56)\t| (((sf_count_t) (ptr) [6]) << 48) |\t\\\n\t\t\t\t\t\t\t\t(((sf_count_t) (ptr) [5]) << 40)\t| (((sf_count_t) (ptr) [4]) << 32) |\t\\\n\t\t\t\t\t\t\t\t(((sf_count_t) (ptr) [3]) << 24)\t| (((sf_count_t) (ptr) [2]) << 16) |\t\\\n\t\t\t\t\t\t\t\t(((sf_count_t) (ptr) [1]) << 8)\t\t| ((ptr) [0]))\n\n#define\tGET_BE_8BYTE(ptr)\t(\t(((sf_count_t) (ptr) [0]) << 56)\t| (((sf_count_t) (ptr) [1]) << 48) |\t\\\n\t\t\t\t\t\t\t\t(((sf_count_t) (ptr) [2]) << 40)\t| (((sf_count_t) (ptr) [3]) << 32) |\t\\\n\t\t\t\t\t\t\t\t(((sf_count_t) (ptr) [4]) << 24)\t| (((sf_count_t) (ptr) [5]) << 16) |\t\\\n\t\t\t\t\t\t\t\t(((sf_count_t) (ptr) [6]) << 8)\t\t| ((ptr) [7]))\n\n\n\nstatic int\nheader_read (SF_PRIVATE *psf, void *ptr, int bytes)\n{\tint count = 0 ;\n\n\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\treturn psf_fread (ptr, 1, bytes, psf) ;\n\n\tif (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))\n\t{\tint most ;\n\n\t\tmost = SIGNED_SIZEOF (psf->header) - psf->headend ;\n\t\tpsf_fread (psf->header + psf->headend, 1, most, psf) ;\n\t\tmemcpy (ptr, psf->header + psf->headend, most) ;\n\t\tpsf->headend = psf->headindex += most ;\n\t\tpsf_fread ((char *) ptr + most, bytes - most, 1, psf) ;\n\t\treturn bytes ;\n\t\t} ;\n\n\tif (psf->headindex + bytes > psf->headend)\n\t{\tcount = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;\n\t\tif (count != bytes - (int) (psf->headend - psf->headindex))\n\t\t{\tpsf_log_printf (psf, \"Error : psf_fread returned short count.\\n\") ;\n\t\t\treturn count ;\n\t\t\t} ;\n\t\tpsf->headend += count ;\n\t\t} ;\n\n\tmemcpy (ptr, psf->header + psf->headindex, bytes) ;\n\tpsf->headindex += bytes ;\n\n\treturn bytes ;\n} /* header_read */\n\nstatic void\nheader_seek (SF_PRIVATE *psf, sf_count_t position, int whence)\n{\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\tif (position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t/* Too much header to cache so just seek instead. */\n\t\t\t\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (position > psf->headend)\n\t\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - psf->headend, psf) ;\n\t\t\tpsf->headindex = position ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_CUR :\n\t\t\tif (psf->headindex + position < 0)\n\t\t\t\tbreak ;\n\n\t\t\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\t\t{\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->headindex + position <= psf->headend)\n\t\t\t{\tpsf->headindex += position ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->headindex + position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t/* Need to jump this without caching it. */\n\t\t\t\tpsf->headindex = psf->headend ;\n\t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - (psf->headend - psf->headindex), psf) ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad whence param in header_seek().\\n\") ;\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn ;\n} /* header_seek */\n\nstatic int\nheader_gets (SF_PRIVATE *psf, char *ptr, int bufsize)\n{\tint\t\tk ;\n\n\tfor (k = 0 ; k < bufsize - 1 ; k++)\n\t{\tif (psf->headindex < psf->headend)\n\t\t{\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex ++ ;\n\t\t\t}\n\t\telse\n\t\t{\tpsf->headend += psf_fread (psf->header + psf->headend, 1, 1, psf) ;\n\t\t\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\t} ;\n\n\t\tif (ptr [k] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\n\tptr [k] = 0 ;\n\n\treturn k ;\n} /* header_gets */\n\nint\npsf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)\n{\tva_list\t\t\targptr ;\n\tsf_count_t\t\t*countptr, countdata ;\n\tunsigned char\t*ucptr, sixteen_bytes [16] ;\n\tunsigned int \t*intptr, intdata ;\n\tunsigned short\t*shortptr ;\n\tchar\t\t\t*charptr ;\n\tfloat\t\t\t*floatptr ;\n\tdouble\t\t\t*doubleptr ;\n\tchar\t\t\tc ;\n\tint\t\t\t\tbyte_count = 0, count ;\n\n\tif (! format)\n\t\treturn psf_ftell (psf) ;\n\n\tva_start (argptr, format) ;\n\n\twhile ((c = *format++))\n\t{\tswitch (c)\n\t\t{\tcase 'e' : /* All conversions are now from LE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_LITTLE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'E' : /* All conversions are now from BE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_BIG ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'm' : /* 4 byte marker value eg 'RIFF' */\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\tucptr = (unsigned char*) intptr ;\n\t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (int)) ;\n\t\t\t\t\t*intptr = GET_MARKER (ucptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'h' :\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\tucptr = (unsigned char*) intptr ;\n\t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, sizeof (sixteen_bytes)) ;\n\t\t\t\t\t{\tint k ;\n\t\t\t\t\t\tintdata = 0 ;\n\t\t\t\t\t\tfor (k = 0 ; k < 16 ; k++)\n\t\t\t\t\t\t\tintdata ^= sixteen_bytes [k] << k ;\n\t\t\t\t\t\t}\n\t\t\t\t\t*intptr = intdata ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '1' :\n\t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n\t\t\t\t\t*charptr = 0 ;\n\t\t\t\t\tbyte_count += header_read (psf, charptr, sizeof (char)) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '2' : /* 2 byte value with the current endian-ness */\n\t\t\t\t\tshortptr = va_arg (argptr, unsigned short*) ;\n\t\t\t\t\t*shortptr = 0 ;\n\t\t\t\t\tucptr = (unsigned char*) shortptr ;\n\t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (short)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*shortptr = GET_BE_SHORT (ucptr) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*shortptr = GET_LE_SHORT (ucptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '3' : /* 3 byte value with the current endian-ness */\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\t*intptr = 0 ;\n\t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, 3) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*intptr = GET_BE_3BYTE (sixteen_bytes) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*intptr = GET_LE_3BYTE (sixteen_bytes) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '4' : /* 4 byte value with the current endian-ness */\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\t*intptr = 0 ;\n\t\t\t\t\tucptr = (unsigned char*) intptr ;\n\t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (int)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*intptr = psf_get_be32 (ucptr, 0) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*intptr = psf_get_le32 (ucptr, 0) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '8' : /* 8 byte value with the current endian-ness */\n\t\t\t\t\tcountptr = va_arg (argptr, sf_count_t *) ;\n\t\t\t\t\t*countptr = 0 ;\n\t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, 8) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\tcountdata = psf_get_be64 (sixteen_bytes, 0) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tcountdata = psf_get_le64 (sixteen_bytes, 0) ;\n\t\t\t\t\t*countptr = countdata ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'f' : /* Float conversion */\n\t\t\t\t\tfloatptr = va_arg (argptr, float *) ;\n\t\t\t\t\t*floatptr = 0.0 ;\n\t\t\t\t\tbyte_count += header_read (psf, floatptr, sizeof (float)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*floatptr = float32_be_read ((unsigned char*) floatptr) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*floatptr = float32_le_read ((unsigned char*) floatptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'd' : /* double conversion */\n\t\t\t\t\tdoubleptr = va_arg (argptr, double *) ;\n\t\t\t\t\t*doubleptr = 0.0 ;\n\t\t\t\t\tbyte_count += header_read (psf, doubleptr, sizeof (double)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*doubleptr = double64_be_read ((unsigned char*) doubleptr) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*doubleptr = double64_le_read ((unsigned char*) doubleptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 's' :\n\t\t\t\t\tpsf_log_printf (psf, \"Format conversion 's' not implemented yet.\\n\") ;\n\t\t\t\t\t/*\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize   = strlen (strptr) + 1 ;\n\t\t\t\t\tsize  += (size & 1) ;\n\t\t\t\t\tlongdata = H2LE_32 (size) ;\n\t\t\t\t\tget_int (psf, longdata) ;\n\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), strptr, size) ;\n\t\t\t\t\tpsf->headindex += size ;\n\t\t\t\t\t*/\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'b' : /* Raw bytes */\n\t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n\t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\tif (count > 0)\n\t\t\t\t\t\tbyte_count += header_read (psf, charptr, count) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'G' :\n\t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n\t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\tif (count > 0)\n\t\t\t\t\t\tbyte_count += header_gets (psf, charptr, count) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'z' :\n\t\t\t\t\tpsf_log_printf (psf, \"Format conversion 'z' not implemented yet.\\n\") ;\n\t\t\t\t\t/*\n\t\t\t\t\tsize    = va_arg (argptr, size_t) ;\n\t\t\t\t\twhile (size)\n\t\t\t\t\t{\tpsf->header [psf->headindex] = 0 ;\n\t\t\t\t\t\tpsf->headindex ++ ;\n\t\t\t\t\t\tsize -- ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\t*/\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'p' :\n\t\t\t\t\t/* Get the seek position first. */\n\t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\theader_seek (psf, count, SEEK_SET) ;\n\t\t\t\t\tbyte_count = count ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'j' :\n\t\t\t\t\t/* Get the seek position first. */\n\t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\tif (count)\n\t\t\t\t\t{\theader_seek (psf, count, SEEK_CUR) ;\n\t\t\t\t\t\tbyte_count += count ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\tpsf_log_printf (psf, \"*** Invalid format specifier `%c'\\n\", c) ;\n\t\t\t\tpsf->error = SFE_INTERNAL ;\n\t\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ;\n\n\tva_end (argptr) ;\n\n\treturn byte_count ;\n} /* psf_binheader_readf */\n\n/*-----------------------------------------------------------------------------------------------\n*/\n\nsf_count_t\npsf_default_seek (SF_PRIVATE *psf, int UNUSED (mode), sf_count_t samples_from_start)\n{\tsf_count_t position, retval ;\n\n\tif (! (psf->blockwidth && psf->dataoffset >= 0))\n\t{\tpsf->error = SFE_BAD_SEEK ;\n\t\treturn\tPSF_SEEK_ERROR ;\n\t\t} ;\n\n\tif (! psf->sf.seekable)\n\t{\tpsf->error = SFE_NOT_SEEKABLE ;\n\t\treturn\tPSF_SEEK_ERROR ;\n\t\t} ;\n\n\tposition = psf->dataoffset + psf->blockwidth * samples_from_start ;\n\n\tif ((retval = psf_fseek (psf, position, SEEK_SET)) != position)\n\t{\tpsf->error = SFE_SEEK_FAILED ;\n\t\treturn PSF_SEEK_ERROR ;\n\t\t} ;\n\n\treturn samples_from_start ;\n} /* psf_default_seek */\n\n/*-----------------------------------------------------------------------------------------------\n*/\n\nvoid\npsf_hexdump (const void *ptr, int len)\n{\tconst char *data ;\n\tchar\tascii [17] ;\n\tint\t\tk, m ;\n\n\tif ((data = ptr) == NULL)\n\t\treturn ;\n\tif (len <= 0)\n\t\treturn ;\n\n\tputs (\"\") ;\n\tfor (k = 0 ; k < len ; k += 16)\n\t{\tmemset (ascii, ' ', sizeof (ascii)) ;\n\n\t\tprintf (\"%08X: \", k) ;\n\t\tfor (m = 0 ; m < 16 && k + m < len ; m++)\n\t\t{\tprintf (m == 8 ? \" %02X \" : \"%02X \", data [k + m] & 0xFF) ;\n\t\t\tascii [m] = psf_isprint (data [k + m]) ? data [k + m] : '.' ;\n\t\t\t} ;\n\n\t\tif (m <= 8) printf (\" \") ;\n\t\tfor ( ; m < 16 ; m++) printf (\"   \") ;\n\n\t\tascii [16] = 0 ;\n\t\tprintf (\" %s\\n\", ascii) ;\n\t\t} ;\n\n\tputs (\"\") ;\n} /* psf_hexdump */\n\nvoid\npsf_log_SF_INFO (SF_PRIVATE *psf)\n{\tpsf_log_printf (psf, \"---------------------------------\\n\") ;\n\n\tpsf_log_printf (psf, \" Sample rate :   %d\\n\", psf->sf.samplerate) ;\n\tif (psf->sf.frames == SF_COUNT_MAX)\n\t\tpsf_log_printf (psf, \" Frames      :   unknown\\n\") ;\n\telse\n\t\tpsf_log_printf (psf, \" Frames      :   %D\\n\", psf->sf.frames) ;\n\tpsf_log_printf (psf, \" Channels    :   %d\\n\", psf->sf.channels) ;\n\n\tpsf_log_printf (psf, \" Format      :   0x%X\\n\", psf->sf.format) ;\n\tpsf_log_printf (psf, \" Sections    :   %d\\n\", psf->sf.sections) ;\n\tpsf_log_printf (psf, \" Seekable    :   %s\\n\", psf->sf.seekable ? \"TRUE\" : \"FALSE\") ;\n\n\tpsf_log_printf (psf, \"---------------------------------\\n\") ;\n} /* psf_dump_SFINFO */\n\n/*========================================================================================\n*/\n\nvoid*\npsf_memset (void *s, int c, sf_count_t len)\n{\tchar\t*ptr ;\n\tint \tsetcount ;\n\n\tptr = (char *) s ;\n\n\twhile (len > 0)\n\t{\tsetcount = (len > 0x10000000) ? 0x10000000 : (int) len ;\n\n\t\tmemset (ptr, c, setcount) ;\n\n\t\tptr += setcount ;\n\t\tlen -= setcount ;\n\t\t} ;\n\n\treturn s ;\n} /* psf_memset */\n\n\n/*\n** Clang refuses to do sizeof (SF_CUES_VAR (cue_count)) so we have to manually\n** bodgy something up instead.\n*/\n\ntypedef SF_CUES_VAR (1) SF_CUES_1 ;\ntypedef SF_CUES_VAR (2) SF_CUES_2 ;\n\n#define SF_CUES_VAR_SIZE(count)\t(sizeof (SF_CUES_1) + count * (sizeof (SF_CUES_2) - sizeof (SF_CUES_1)))\n\nSF_CUES *\npsf_cues_alloc (uint32_t cue_count)\n{\tSF_CUES *pcues = calloc (1, SF_CUES_VAR_SIZE (cue_count)) ;\n\n\tpcues->cue_count = cue_count ;\n\treturn pcues ;\n} /* psf_cues_alloc */\n\nSF_CUES *\npsf_cues_dup (const void * ptr)\n{\tconst SF_CUES *pcues = ptr ;\n\tSF_CUES *pnew = psf_cues_alloc (pcues->cue_count) ;\n\n\tmemcpy (pnew, pcues, SF_CUES_VAR_SIZE (pcues->cue_count)) ;\n\treturn pnew ;\n} /* psf_cues_dup */\n\nvoid\npsf_get_cues (SF_PRIVATE * psf, void * data, size_t datasize)\n{\n\tif (psf->cues)\n\t{\tuint32_t cue_count = (datasize - sizeof (uint32_t)) / sizeof (SF_CUE_POINT) ;\n\n\t\tcue_count = SF_MIN (cue_count, psf->cues->cue_count) ;\n\t\tmemcpy (data, psf->cues, SF_CUES_VAR_SIZE (cue_count)) ;\n\t\t((SF_CUES*) data)->cue_count = cue_count ;\n\t\t} ;\n\n\treturn ;\n} /* psf_get_cues */\n\n\nSF_INSTRUMENT *\npsf_instrument_alloc (void)\n{\tSF_INSTRUMENT *instr ;\n\n\tinstr = calloc (1, sizeof (SF_INSTRUMENT)) ;\n\n\tif (instr == NULL)\n\t\treturn NULL ;\n\n\t/* Set non-zero default values. */\n\tinstr->basenote = -1 ;\n\tinstr->velocity_lo = -1 ;\n\tinstr->velocity_hi = -1 ;\n\tinstr->key_lo = -1 ;\n\tinstr->key_hi = -1 ;\n\n\treturn instr ;\n} /* psf_instrument_alloc */\n\nvoid\npsf_sanitize_string (char * cptr, int len)\n{\n\tdo\n\t{\n\t\tlen -- ;\n\t\tcptr [len] = psf_isprint (cptr [len]) ? cptr [len] : '.' ;\n\t}\n\twhile (len > 0) ;\n} /* psf_sanitize_string */\n\nvoid\npsf_get_date_str (char *str, int maxlen)\n{\ttime_t\t\tcurrent ;\n\tstruct tm\ttimedata, *tmptr ;\n\n\ttime (&current) ;\n\n#if defined (HAVE_GMTIME_R)\n\t/* If the re-entrant version is available, use it. */\n\ttmptr = gmtime_r (&current, &timedata) ;\n#elif defined (HAVE_GMTIME)\n\t/* Otherwise use the standard one and copy the data to local storage. */\n\ttmptr = gmtime (&current) ;\n\tmemcpy (&timedata, tmptr, sizeof (timedata)) ;\n#else\n\ttmptr = NULL ;\n#endif\n\n\tif (tmptr)\n\t\tsnprintf (str, maxlen, \"%4d-%02d-%02d %02d:%02d:%02d UTC\",\n\t\t\t1900 + timedata.tm_year, timedata.tm_mon, timedata.tm_mday,\n\t\t\ttimedata.tm_hour, timedata.tm_min, timedata.tm_sec) ;\n\telse\n\t\tsnprintf (str, maxlen, \"Unknown date\") ;\n\n\treturn ;\n} /* psf_get_date_str */\n\nint\nsubformat_to_bytewidth (int format)\n{\n\tswitch (format)\n\t{\tcase SF_FORMAT_PCM_U8 :\n\t\tcase SF_FORMAT_PCM_S8 :\n\t\t\t\treturn 1 ;\n\t\tcase SF_FORMAT_PCM_16 :\n\t\t\t\treturn 2 ;\n\t\tcase SF_FORMAT_PCM_24 :\n\t\t\t\treturn 3 ;\n\t\tcase SF_FORMAT_PCM_32 :\n\t\tcase SF_FORMAT_FLOAT :\n\t\t\t\treturn 4 ;\n\t\tcase SF_FORMAT_DOUBLE :\n\t\t\t\treturn 8 ;\n\t\t} ;\n\n\treturn 0 ;\n} /* subformat_to_bytewidth */\n\nint\ns_bitwidth_to_subformat (int bits)\n{\tstatic int array [] =\n\t{\tSF_FORMAT_PCM_S8, SF_FORMAT_PCM_16, SF_FORMAT_PCM_24, SF_FORMAT_PCM_32\n\t\t} ;\n\n\tif (bits < 8 || bits > 32)\n\t\treturn 0 ;\n\n\treturn array [((bits + 7) / 8) - 1] ;\n} /* bitwidth_to_subformat */\n\nint\nu_bitwidth_to_subformat (int bits)\n{\tstatic int array [] =\n\t{\tSF_FORMAT_PCM_U8, SF_FORMAT_PCM_16, SF_FORMAT_PCM_24, SF_FORMAT_PCM_32\n\t\t} ;\n\n\tif (bits < 8 || bits > 32)\n\t\treturn 0 ;\n\n\treturn array [((bits + 7) / 8) - 1] ;\n} /* bitwidth_to_subformat */\n\n/*\n**\tpsf_rand_int32 : Not crypto quality, but more than adequate for things\n**\tlike stream serial numbers in Ogg files or the unique_id field of the\n**\tSF_PRIVATE struct.\n*/\n\nint32_t\npsf_rand_int32 (void)\n{\tstatic uint64_t value = 0 ;\n\tint k, count ;\n\n\tif (value == 0)\n\t{\n#if HAVE_GETTIMEOFDAY\n\t\tstruct timeval tv ;\n\t\tgettimeofday (&tv, NULL) ;\n\t\tvalue = tv.tv_sec + tv.tv_usec ;\n#else\n\t\tvalue = time (NULL) ;\n#endif\n\t\t} ;\n\n\tcount = 4 + (value & 7) ;\n\tfor (k = 0 ; k < count ; k++)\n\t\tvalue = (11117 * value + 211231) & 0x7fffffff ;\n\n\treturn (int32_t) value ;\n} /* psf_rand_int32 */\n\nvoid\nappend_snprintf (char * dest, size_t maxlen, const char * fmt, ...)\n{\tsize_t len = strlen (dest) ;\n\n\tif (len < maxlen)\n\t{\tva_list ap ;\n\n\t\tva_start (ap, fmt) ;\n\t\tvsnprintf (dest + len, maxlen - len, fmt, ap) ;\n\t\tva_end (ap) ;\n\t\t} ;\n\n\treturn ;\n} /* append_snprintf */\n\n\nvoid\npsf_strlcpy_crlf (char *dest, const char *src, size_t destmax, size_t srcmax)\n{\t/* Must be minus 2 so it can still expand a single trailing '\\n' or '\\r'. */\n\tchar * destend = dest + destmax - 2 ;\n\tconst char * srcend = src + srcmax ;\n\n\twhile (dest < destend && src < srcend)\n\t{\tif ((src [0] == '\\r' && src [1] == '\\n') || (src [0] == '\\n' && src [1] == '\\r'))\n\t\t{\t*dest++ = '\\r' ;\n\t\t\t*dest++ = '\\n' ;\n\t\t\tsrc += 2 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tif (src [0] == '\\r')\n\t\t{\t*dest++ = '\\r' ;\n\t\t\t*dest++ = '\\n' ;\n\t\t\tsrc += 1 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tif (src [0] == '\\n')\n\t\t{\t*dest++ = '\\r' ;\n\t\t\t*dest++ = '\\n' ;\n\t\t\tsrc += 1 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\t*dest++ = *src++ ;\n\t\t} ;\n\n\t/* Make sure dest is terminated. */\n\t*dest = 0 ;\n} /* psf_strlcpy_crlf */\n\nsf_count_t\npsf_decode_frame_count (SF_PRIVATE *psf)\n{\tsf_count_t count, readlen, total = 0 ;\n\tBUF_UNION\tubuf ;\n\n\t/* If we're reading from a pipe or the file is too long, just return SF_COUNT_MAX. */\n\tif (psf_is_pipe (psf) || psf->datalength > 0x1000000)\n\t\treturn SF_COUNT_MAX ;\n\n\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\n\treadlen = ARRAY_LEN (ubuf.ibuf) / psf->sf.channels ;\n\treadlen *= psf->sf.channels ;\n\n\twhile ((count = psf->read_int (psf, ubuf.ibuf, readlen)) > 0)\n\t\ttotal += count ;\n\n\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\n\treturn total / psf->sf.channels ;\n} /* psf_decode_frame_count */\n\n/*==============================================================================\n*/\n\n#define CASE_NAME(x)\t\tcase x : return #x ; break ;\n\nconst char *\nstr_of_major_format (int format)\n{\tswitch (SF_CONTAINER (format))\n\t{\tCASE_NAME (SF_FORMAT_WAV) ;\n\t\tCASE_NAME (SF_FORMAT_AIFF) ;\n\t\tCASE_NAME (SF_FORMAT_AU) ;\n\t\tCASE_NAME (SF_FORMAT_RAW) ;\n\t\tCASE_NAME (SF_FORMAT_PAF) ;\n\t\tCASE_NAME (SF_FORMAT_SVX) ;\n\t\tCASE_NAME (SF_FORMAT_NIST) ;\n\t\tCASE_NAME (SF_FORMAT_VOC) ;\n\t\tCASE_NAME (SF_FORMAT_IRCAM) ;\n\t\tCASE_NAME (SF_FORMAT_W64) ;\n\t\tCASE_NAME (SF_FORMAT_MAT4) ;\n\t\tCASE_NAME (SF_FORMAT_MAT5) ;\n\t\tCASE_NAME (SF_FORMAT_PVF) ;\n\t\tCASE_NAME (SF_FORMAT_XI) ;\n\t\tCASE_NAME (SF_FORMAT_HTK) ;\n\t\tCASE_NAME (SF_FORMAT_SDS) ;\n\t\tCASE_NAME (SF_FORMAT_AVR) ;\n\t\tCASE_NAME (SF_FORMAT_WAVEX) ;\n\t\tCASE_NAME (SF_FORMAT_SD2) ;\n\t\tCASE_NAME (SF_FORMAT_FLAC) ;\n\t\tCASE_NAME (SF_FORMAT_CAF) ;\n\t\tCASE_NAME (SF_FORMAT_WVE) ;\n\t\tCASE_NAME (SF_FORMAT_OGG) ;\n\t\tdefault :\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn \"BAD_MAJOR_FORMAT\" ;\n} /* str_of_major_format */\n\nconst char *\nstr_of_minor_format (int format)\n{\tswitch (SF_CODEC (format))\n\t{\tCASE_NAME (SF_FORMAT_PCM_S8) ;\n\t\tCASE_NAME (SF_FORMAT_PCM_16) ;\n\t\tCASE_NAME (SF_FORMAT_PCM_24) ;\n\t\tCASE_NAME (SF_FORMAT_PCM_32) ;\n\t\tCASE_NAME (SF_FORMAT_PCM_U8) ;\n\t\tCASE_NAME (SF_FORMAT_FLOAT) ;\n\t\tCASE_NAME (SF_FORMAT_DOUBLE) ;\n\t\tCASE_NAME (SF_FORMAT_ULAW) ;\n\t\tCASE_NAME (SF_FORMAT_ALAW) ;\n\t\tCASE_NAME (SF_FORMAT_IMA_ADPCM) ;\n\t\tCASE_NAME (SF_FORMAT_MS_ADPCM) ;\n\t\tCASE_NAME (SF_FORMAT_GSM610) ;\n\t\tCASE_NAME (SF_FORMAT_VOX_ADPCM) ;\n\t\tCASE_NAME (SF_FORMAT_G721_32) ;\n\t\tCASE_NAME (SF_FORMAT_G723_24) ;\n\t\tCASE_NAME (SF_FORMAT_G723_40) ;\n\t\tCASE_NAME (SF_FORMAT_DWVW_12) ;\n\t\tCASE_NAME (SF_FORMAT_DWVW_16) ;\n\t\tCASE_NAME (SF_FORMAT_DWVW_24) ;\n\t\tCASE_NAME (SF_FORMAT_DWVW_N) ;\n\t\tCASE_NAME (SF_FORMAT_DPCM_8) ;\n\t\tCASE_NAME (SF_FORMAT_DPCM_16) ;\n\t\tCASE_NAME (SF_FORMAT_VORBIS) ;\n\t\tdefault :\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn \"BAD_MINOR_FORMAT\" ;\n} /* str_of_minor_format */\n\nconst char *\nstr_of_open_mode (int mode)\n{\tswitch (mode)\n\t{\tCASE_NAME (SFM_READ) ;\n\t\tCASE_NAME (SFM_WRITE) ;\n\t\tCASE_NAME (SFM_RDWR) ;\n\n\t\tdefault :\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn \"BAD_MODE\" ;\n} /* str_of_open_mode */\n\nconst char *\nstr_of_endianness (int end)\n{\tswitch (end)\n\t{\tCASE_NAME (SF_ENDIAN_BIG) ;\n\t\tCASE_NAME (SF_ENDIAN_LITTLE) ;\n\t\tCASE_NAME (SF_ENDIAN_CPU) ;\n\t\tdefault :\n\t\t\tbreak ;\n\t\t} ;\n\n\t/* Zero length string for SF_ENDIAN_FILE. */\n\treturn \"\" ;\n} /* str_of_endianness */\n\n/*==============================================================================\n*/\n\nvoid\npsf_f2s_array (const float *src, short *dest, int count, int normalize)\n{\tfloat \t\t\tnormfact ;\n\n\tnormfact = normalize ? (1.0 * 0x7FFF) : 1.0 ;\n\twhile (--count >= 0)\n\t\tdest [count] = lrintf (src [count] * normfact) ;\n\n\treturn ;\n} /* psf_f2s_array */\n\nvoid\npsf_f2s_clip_array (const float *src, short *dest, int count, int normalize)\n{\tfloat\t\t\tnormfact, scaled_value ;\n\n\tnormfact = normalize ? (1.0 * 0x8000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFF))\n\t\t{\tdest [count] = 0x7FFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x1000))\n\t\t{\tdest [count] = 0x8000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tdest [count] = lrintf (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_f2s_clip_array */\n\nvoid\npsf_d2s_array (const double *src, short *dest, int count, int normalize)\n{\tdouble \t\t\tnormfact ;\n\n\tnormfact = normalize ? (1.0 * 0x7FFF) : 1.0 ;\n\twhile (--count >= 0)\n\t\tdest [count] = lrint (src [count] * normfact) ;\n\n\treturn ;\n} /* psf_f2s_array */\n\nvoid\npsf_d2s_clip_array (const double *src, short *dest, int count, int normalize)\n{\tdouble\t\t\tnormfact, scaled_value ;\n\n\tnormfact = normalize ? (1.0 * 0x8000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFF))\n\t\t{\tdest [count] = 0x7FFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x1000))\n\t\t{\tdest [count] = 0x8000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_d2s_clip_array */\n\n\nvoid\npsf_f2i_array (const float *src, int *dest, int count, int normalize)\n{\tfloat \t\t\tnormfact ;\n\n\tnormfact = normalize ? (1.0 * 0x7FFFFFFF) : 1.0 ;\n\twhile (--count >= 0)\n\t\tdest [count] = lrintf (src [count] * normfact) ;\n\n\treturn ;\n} /* psf_f2i_array */\n\nvoid\npsf_f2i_clip_array (const float *src, int *dest, int count, int normalize)\n{\tfloat\t\t\tnormfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x10000000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFFFF))\n\t\t{\tdest [count] = 0x7FFFFFFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10000000))\n\t\t{\tdest [count] = 0x80000000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tdest [count] = lrintf (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_f2i_clip_array */\n\nvoid\npsf_d2i_array (const double *src, int *dest, int count, int normalize)\n{\tdouble \t\t\tnormfact ;\n\n\tnormfact = normalize ? (1.0 * 0x7FFFFFFF) : 1.0 ;\n\twhile (--count >= 0)\n\t\tdest [count] = lrint (src [count] * normfact) ;\n\n\treturn ;\n} /* psf_f2i_array */\n\nvoid\npsf_d2i_clip_array (const double *src, int *dest, int count, int normalize)\n{\tdouble\t\t\tnormfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x10000000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFFFF))\n\t\t{\tdest [count] = 0x7FFFFFFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10000000))\n\t\t{\tdest [count] = 0x80000000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_d2i_clip_array */\n\nFILE *\npsf_open_tmpfile (char * fname, size_t fnamelen)\n{\tconst char * tmpdir ;\n\tFILE * file ;\n\n\tif (OS_IS_WIN32)\n\t\ttmpdir = getenv (\"TEMP\") ;\n\telse\n\t{\ttmpdir = getenv (\"TMPDIR\") ;\n\t\ttmpdir = tmpdir == NULL ? \"/tmp\" : tmpdir ;\n\t\t} ;\n\n\tif (tmpdir && access (tmpdir, R_OK | W_OK | X_OK) == 0)\n\t{\tsnprintf (fname, fnamelen, \"%s/%x%x-alac.tmp\", tmpdir, psf_rand_int32 (), psf_rand_int32 ()) ;\n\t\tif ((file = fopen (fname, \"wb+\")) != NULL)\n\t\t\treturn file ;\n\t\t} ;\n\n\tsnprintf (fname, fnamelen, \"%x%x-alac.tmp\", psf_rand_int32 (), psf_rand_int32 ()) ;\n\tif ((file = fopen (fname, \"wb+\")) != NULL)\n\t\treturn file ;\n\n\tmemset (fname, 0, fnamelen) ;\n\treturn NULL ;\n} /* psf_open_tmpfile */\n", "/*\n** Copyright (C) 1999-2016 Erik de Castro Lopo <erikd@mega-nerd.com>\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n#ifndef SNDFILE_COMMON_H\n#define SNDFILE_COMMON_H\n\n#include \"sfconfig.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#if HAVE_STDINT_H\n#include <stdint.h>\n#elif HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n#if HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n#ifndef SNDFILE_H\n#include \"sndfile.h\"\n#endif\n\n#ifdef __cplusplus\n#error \"This code is not designed to be compiled with a C++ compiler.\"\n#endif\n\n#ifdef INT64_C\n#\tdefine\tSF_PLATFORM_S64(x)\t\tINT64_C(x)\n#elif (SIZEOF_LONG == 8)\n#\tdefine\tSF_PLATFORM_S64(x)\t\tx##l\n#elif (SIZEOF_LONG_LONG == 8)\n#\tdefine\tSF_PLATFORM_S64(x)\t\tx##ll\n#elif COMPILER_IS_GCC\n#\tdefine\tSF_PLATFORM_S64(x)\t\tx##ll\n#elif OS_IS_WIN32\n#\tdefine\tSF_PLATFORM_S64(x)\t\tx##I64\n#else\n#\terror \"Don't know how to define a 64 bit integer constant.\"\n#endif\n\n\n\n/*\n** Inspiration : http://sourcefrog.net/weblog/software/languages/C/unused.html\n*/\n#ifdef UNUSED\n#elif defined (__GNUC__)\n#\tdefine UNUSED(x) UNUSED_ ## x __attribute__ ((unused))\n#elif defined (__LCLINT__)\n#\tdefine UNUSED(x) /*@unused@*/ x\n#else\n#\tdefine UNUSED(x) x\n#endif\n\n#ifdef __GNUC__\n#\tdefine WARN_UNUSED\t__attribute__ ((warn_unused_result))\n#else\n#\tdefine WARN_UNUSED\n#endif\n\n#define\tSF_BUFFER_LEN\t\t\t(8192)\n#define\tSF_FILENAME_LEN\t\t\t(1024)\n#define SF_SYSERR_LEN\t\t\t(256)\n#define SF_MAX_STRINGS\t\t\t(32)\n#define\tSF_HEADER_LEN\t\t\t(12292)\n#define\tSF_PARSELOG_LEN\t\t\t(2048)\n\n#define\tPSF_SEEK_ERROR\t\t\t((sf_count_t) -1)\n\n#define\tBITWIDTH2BYTES(x)\t(((x) + 7) / 8)\n\n/*\tFor some reason sizeof returns an unsigned  value which causes\n**\ta warning when that value is added or subtracted from a signed\n**\tvalue. Use SIGNED_SIZEOF instead.\n*/\n#define\t\tSIGNED_SIZEOF(x)\t((int) sizeof (x))\n\n#define\t\tARRAY_LEN(x)\t((int) (sizeof (x) / sizeof ((x) [0])))\n\n#define\t\tNOT(x)\t\t\t(! (x))\n\n#if COMPILER_IS_GCC\n#define\t\tSF_MAX(x, y)\t({ \\\n\t\t\t\t\t\t\t\ttypeof (x) sf_max_x1 = (x) ; \\\n\t\t\t\t\t\t\t\ttypeof (y) sf_max_y1 = (y) ; \\\n\t\t\t\t\t\t\t\t(void) (&sf_max_x1 == &sf_max_y1) ; \\\n\t\t\t\t\t\t\t\tsf_max_x1 > sf_max_y1 ? sf_max_x1 : sf_max_y1 ; })\n\n#define\t\tSF_MIN(x, y)\t({ \\\n\t\t\t\t\t\t\t\ttypeof (x) sf_min_x2 = (x) ; \\\n\t\t\t\t\t\t\t\ttypeof (y) sf_min_y2 = (y) ; \\\n\t\t\t\t\t\t\t\t(void) (&sf_min_x2 == &sf_min_y2) ; \\\n\t\t\t\t\t\t\t\tsf_min_x2 < sf_min_y2 ? sf_min_x2 : sf_min_y2 ; })\n#else\n#define\t\tSF_MAX(a, b)\t((a) > (b) ? (a) : (b))\n#define\t\tSF_MIN(a, b)\t((a) < (b) ? (a) : (b))\n#endif\n\n\n#define\t\tCOMPILE_TIME_ASSERT(e)\t(sizeof (struct { int : - !! (e) ; }))\n\n\n#define\t\tSF_MAX_CHANNELS\t\t1024\n\n\n/*\n*\tMacros for spliting the format file of SF_INFO into container type,\n**\tcodec type and endian-ness.\n*/\n#define SF_CONTAINER(x)\t\t((x) & SF_FORMAT_TYPEMASK)\n#define SF_CODEC(x)\t\t\t((x) & SF_FORMAT_SUBMASK)\n#define SF_ENDIAN(x)\t\t((x) & SF_FORMAT_ENDMASK)\n\nenum\n{\t/* PEAK chunk location. */\n\tSF_PEAK_START\t\t= 42,\n\tSF_PEAK_END\t\t\t= 43,\n\n\t/* PEAK chunk location. */\n\tSF_SCALE_MAX\t\t= 52,\n\tSF_SCALE_MIN\t\t= 53,\n\n\t/* str_flags values. */\n\tSF_STR_ALLOW_START\t= 0x0100,\n\tSF_STR_ALLOW_END\t= 0x0200,\n\n\t/* Location of strings. */\n\tSF_STR_LOCATE_START\t= 0x0400,\n\tSF_STR_LOCATE_END\t= 0x0800,\n\n\tSFD_TYPEMASK\t\t= 0x0FFFFFFF\n} ;\n\n#define\t\tSFM_MASK \t(SFM_READ | SFM_WRITE | SFM_RDWR)\n#define\t\tSFM_UNMASK \t(~SFM_MASK)\n\n/*---------------------------------------------------------------------------------------\n** Formats that may be supported at some time in the future.\n** When support is finalised, these values move to src/sndfile.h.\n*/\n\nenum\n{\t/* Work in progress. */\n\tSF_FORMAT_SPEEX\t\t\t= 0x5000000,\n\tSF_FORMAT_OGGFLAC\t\t= 0x5000001,\n\n\t/* Formats supported read only. */\n\tSF_FORMAT_TXW\t\t\t= 0x4030000,\t\t/* Yamaha TX16 sampler file */\n\tSF_FORMAT_DWD\t\t\t= 0x4040000,\t\t/* DiamondWare Digirized */\n\n\t/* Following are detected but not supported. */\n\tSF_FORMAT_REX\t\t\t= 0x40A0000,\t\t/* Propellorheads Rex/Rcy */\n\tSF_FORMAT_REX2\t\t\t= 0x40D0000,\t\t/* Propellorheads Rex2 */\n\tSF_FORMAT_KRZ\t\t\t= 0x40E0000,\t\t/* Kurzweil sampler file */\n\tSF_FORMAT_WMA\t\t\t= 0x4100000,\t\t/* Windows Media Audio. */\n\tSF_FORMAT_SHN\t\t\t= 0x4110000,\t\t/* Shorten. */\n\n\t/* Unsupported encodings. */\n\tSF_FORMAT_SVX_FIB\t\t= 0x1020, \t\t/* SVX Fibonacci Delta encoding. */\n\tSF_FORMAT_SVX_EXP\t\t= 0x1021, \t\t/* SVX Exponential Delta encoding. */\n\n\tSF_FORMAT_PCM_N\t\t\t= 0x1030\n} ;\n\n/*---------------------------------------------------------------------------------------\n*/\n\ntypedef struct\n{\tunsigned\tkuki_offset ;\n\tunsigned\tpakt_offset ;\n\n\tunsigned\tbits_per_sample ;\n\tunsigned\tframes_per_packet ;\n\n\tint64_t \tpackets ;\n\tint64_t \tvalid_frames ;\n\tint32_t \tpriming_frames ;\n\tint32_t \tremainder_frames ;\n} ALAC_DECODER_INFO ;\n\n/*---------------------------------------------------------------------------------------\n**\tPEAK_CHUNK - This chunk type is common to both AIFF and WAVE files although their\n**\tendian encodings are different.\n*/\n\ntypedef struct\n{\tdouble\t\tvalue ;\t\t/* signed value of peak */\n\tsf_count_t\tposition ;\t/* the sample frame for the peak */\n} PEAK_POS ;\n\ntypedef struct\n{\t/* libsndfile internal : write a PEAK chunk at the start or end of the file? */\n\tint\t\t\t\tpeak_loc ;\n\n\t/* WAV/AIFF */\n\tunsigned int\tversion ;\t/* version of the PEAK chunk */\n\tunsigned int\ttimestamp ;\t/* secs since 1/1/1970  */\n\n\t/* CAF */\n\tunsigned int\tedit_number ;\n\n\t/* the per channel peak info */\n\tPEAK_POS\t\tpeaks [] ;\n} PEAK_INFO ;\n\nstatic inline PEAK_INFO *\npeak_info_calloc (int channels)\n{\treturn calloc (1, sizeof (PEAK_INFO) + channels * sizeof (PEAK_POS)) ;\n} /* peak_info_calloc */\n\ntypedef struct\n{\tint\t\ttype ;\n\tint\t\tflags ;\n\tsize_t \toffset ;\n} STR_DATA ;\n\ntypedef struct\n{\tuint64_t\thash ;\n\tchar\t\tid [64] ;\n\tunsigned\tid_size ;\n\tuint32_t\tmark32 ;\n\tsf_count_t\toffset ;\n\tuint32_t\tlen ;\n} READ_CHUNK ;\n\ntypedef struct\n{\tuint64_t\thash ;\n\tuint32_t\tmark32 ;\n\tuint32_t\tlen ;\n\tvoid\t\t*data ;\n} WRITE_CHUNK ;\n\ntypedef struct\n{\tuint32_t\tcount ;\n\tuint32_t\tused ;\n\tREAD_CHUNK\t*chunks ;\n} READ_CHUNKS ;\ntypedef struct\n{\tuint32_t\tcount ;\n\tuint32_t\tused ;\n\tWRITE_CHUNK\t*chunks ;\n} WRITE_CHUNKS ;\n\nstruct SF_CHUNK_ITERATOR\n{\tuint32_t\tcurrent ;\n\tint64_t\t\thash ;\n\tchar\t\tid [64] ;\n\tunsigned\tid_size ;\n\tSNDFILE\t\t*sndfile ;\n} ;\n\nstatic inline size_t\nmake_size_t (int x)\n{\treturn (size_t) x ;\n} /* make_size_t */\n\nstatic inline uint64_t\nmake_size_8 (int x)\n{\treturn (uint64_t) x ;\n} /* make_size_8 */\n\ntypedef SF_BROADCAST_INFO_VAR (16 * 1024) SF_BROADCAST_INFO_16K ;\n\ntypedef SF_CART_INFO_VAR (16 * 1024) SF_CART_INFO_16K ;\n\n#if SIZEOF_WCHAR_T == 2\ntypedef wchar_t\tsfwchar_t ;\n#else\ntypedef int16_t sfwchar_t ;\n#endif\n\n\nstatic inline void *\npsf_memdup (const void *src, size_t n)\n{\tvoid * mem = calloc (1, n & 3 ? n + 4 - (n & 3) : n) ;\n\treturn memcpy (mem, src, n) ;\n} /* psf_memdup */\n\n/*\n**\tThis version of isprint specifically ignores any locale info. Its used for\n**\tdetermining which characters can be printed in things like hexdumps.\n*/\nstatic inline int\npsf_isprint (int ch)\n{\treturn (ch >= ' ' && ch <= '~') ;\n} /* psf_isprint */\n\n/*=======================================================================================\n**\tSF_PRIVATE stuct - a pointer to this struct is passed back to the caller of the\n**\tsf_open_XXXX functions. The caller however has no knowledge of the struct's\n**\tcontents.\n*/\n\ntypedef struct\n{\n\tunion\n\t{\tchar\t\tc [SF_FILENAME_LEN] ;\n\t\tsfwchar_t\twc [SF_FILENAME_LEN] ;\n\t} path ;\n\n\tunion\n\t{\tchar\t\tc [SF_FILENAME_LEN] ;\n\t\tsfwchar_t\twc [SF_FILENAME_LEN] ;\n\t} dir ;\n\n\tunion\n\t{\tchar\t\tc [SF_FILENAME_LEN / 4] ;\n\t\tsfwchar_t\twc [SF_FILENAME_LEN / 4] ;\n\t} name ;\n\n#if USE_WINDOWS_API\n\t/*\n\t**\tThese fields can only be used in src/file_io.c.\n\t**\tThey are basically the same as a windows file HANDLE.\n\t*/\n\tvoid \t\t\t*handle, *hsaved ;\n\n\tint\t\t\t\tuse_wchar ;\n#else\n\t/* These fields can only be used in src/file_io.c. */\n\tint \t\t\tfiledes, savedes ;\n#endif\n\n\tint\t\t\t\tdo_not_close_descriptor ;\n\tint\t\t\t\tmode ;\t\t\t/* Open mode : SFM_READ, SFM_WRITE or SFM_RDWR. */\n} PSF_FILE ;\n\n\n\ntypedef union\n{\tdouble\t\t\tdbuf\t[SF_BUFFER_LEN / sizeof (double)] ;\n#if (defined (SIZEOF_INT64_T) && (SIZEOF_INT64_T == 8))\n\tint64_t\t\t\tlbuf\t[SF_BUFFER_LEN / sizeof (int64_t)] ;\n#else\n\tlong\t\t\tlbuf\t[SF_BUFFER_LEN / sizeof (double)] ;\n#endif\n\tfloat\t\t\tfbuf\t[SF_BUFFER_LEN / sizeof (float)] ;\n\tint\t\t\t\tibuf\t[SF_BUFFER_LEN / sizeof (int)] ;\n\tshort\t\t\tsbuf\t[SF_BUFFER_LEN / sizeof (short)] ;\n\tchar\t\t\tcbuf\t[SF_BUFFER_LEN / sizeof (char)] ;\n\tsigned char\t\tscbuf\t[SF_BUFFER_LEN / sizeof (signed char)] ;\n\tunsigned char\tucbuf\t[SF_BUFFER_LEN / sizeof (signed char)] ;\n} BUF_UNION ;\n\n\n\ntypedef struct sf_private_tag\n{\n\t/* Canary in a coal mine. */\n\tunion\n\t{\t/* Place a double here to encourage double alignment. */\n\t\tdouble d [2] ;\n\t\tchar c [16] ;\n\t\t} canary ;\n\n\tPSF_FILE\t\tfile, rsrc ;\n\n\tchar\t\t\tsyserr\t\t[SF_SYSERR_LEN] ;\n\n\t/* parselog and indx should only be changed within the logging functions\n\t** of common.c\n\t*/\n\tstruct\n\t{\tchar\t\t\tbuf\t[SF_PARSELOG_LEN] ;\n\t\tint\t\t\t\tindx ;\n\t} parselog ;\n\n\tunsigned char\theader\t\t[SF_HEADER_LEN] ; /* Must be unsigned */\n\tint\t\t\t\trwf_endian ;\t/* Header endian-ness flag. */\n\n\t/* Storage and housekeeping data for adding/reading strings from\n\t** sound files.\n\t*/\n\tstruct\n\t{\tSTR_DATA\tdata [SF_MAX_STRINGS] ;\n\t\tchar\t\t*storage ;\n\t\tsize_t\t\tstorage_len ;\n\t\tsize_t\t\tstorage_used ;\n\t\tuint32_t\tflags ;\n\t} strings ;\n\n\t/* Guard value. If this changes the buffers above have overflowed. */\n\tint\t\t\t\tMagick ;\n\n\tunsigned\t\tunique_id ;\n\n\t/* Index variables for maintaining parselog and header above. */\n\tint\t\t\t\theadindex, headend ;\n\tint\t\t\t\thas_text ;\n\n\tint\t\t\t\terror ;\n\n\tint\t\t\t\tendian ;\t\t/* File endianness : SF_ENDIAN_LITTLE or SF_ENDIAN_BIG. */\n\tint\t\t\t\tdata_endswap ;\t/* Need to endswap data? */\n\n\t/*\n\t** Maximum float value for calculating the multiplier for\n\t** float/double to short/int conversions.\n\t*/\n\tint\t\t\t\tfloat_int_mult ;\n\tfloat\t\t\tfloat_max ;\n\n\tint\t\t\t\tscale_int_float ;\n\n\t/* Vairables for handling pipes. */\n\tint\t\t\t\tis_pipe ;\t\t/* True if file is a pipe. */\n\tsf_count_t\t\tpipeoffset ;\t/* Number of bytes read from a pipe. */\n\n\t/* True if clipping must be performed on float->int conversions. */\n\tint\t\t\t\tadd_clipping ;\n\n\tSF_INFO\t\t\tsf ;\n\n\tint\t\t\t\thave_written ;\t/* Has a single write been done to the file? */\n\tPEAK_INFO\t\t*peak_info ;\n\n\t/* Cue Marker Info */\n\tSF_CUES\t\t*cues ;\n\n\t/* Loop Info */\n\tSF_LOOP_INFO\t*loop_info ;\n\tSF_INSTRUMENT\t*instrument ;\n\n\t/* Broadcast (EBU) Info */\n\tSF_BROADCAST_INFO_16K *broadcast_16k ;\n\n\t/* Cart (AES46) Info */\n\tSF_CART_INFO_16K *cart_16k ;\n\n\t/* Channel map data (if present) : an array of ints. */\n\tint\t\t\t\t*channel_map ;\n\n\tsf_count_t\t\tfilelength ;\t/* Overall length of (embedded) file. */\n\tsf_count_t\t\tfileoffset ;\t/* Offset in number of bytes from beginning of file. */\n\n\tsf_count_t\t\trsrclength ;\t/* Length of the resource fork (if it exists). */\n\n\tsf_count_t\t\tdataoffset ;\t/* Offset in number of bytes from beginning of file. */\n\tsf_count_t\t\tdatalength ;\t/* Length in bytes of the audio data. */\n\tsf_count_t\t\tdataend ;\t\t/* Offset to file tailer. */\n\n\tint\t\t\t\tblockwidth ;\t/* Size in bytes of one set of interleaved samples. */\n\tint\t\t\t\tbytewidth ;\t\t/* Size in bytes of one sample (one channel). */\n\n\tvoid\t\t\t*dither ;\n\tvoid\t\t\t*interleave ;\n\n\tint\t\t\t\tlast_op ;\t\t/* Last operation; either SFM_READ or SFM_WRITE */\n\tsf_count_t\t\tread_current ;\n\tsf_count_t\t\twrite_current ;\n\n\tvoid\t\t\t*container_data ;\t/*\tThis is a pointer to dynamically allocated file\n\t\t\t\t\t\t\t\t\t\t**\tcontainer format specific data.\n\t\t\t\t\t\t\t\t\t\t*/\n\n\tvoid\t\t\t*codec_data ;\t\t/*\tThis is a pointer to dynamically allocated file\n\t\t\t\t\t\t\t\t\t\t**\tcodec format specific data.\n\t\t\t\t\t\t\t\t\t\t*/\n\n\tSF_DITHER_INFO\twrite_dither ;\n\tSF_DITHER_INFO\tread_dither ;\n\n\tint\t\t\t\tnorm_double ;\n\tint\t\t\t\tnorm_float ;\n\n\tint\t\t\t\tauto_header ;\n\n\tint\t\t\t\tieee_replace ;\n\n\t/* A set of file specific function pointers */\n\tsf_count_t\t\t(*read_short)\t(struct sf_private_tag*, short *ptr, sf_count_t len) ;\n\tsf_count_t\t\t(*read_int)\t\t(struct sf_private_tag*, int *ptr, sf_count_t len) ;\n\tsf_count_t\t\t(*read_float)\t(struct sf_private_tag*, float *ptr, sf_count_t len) ;\n\tsf_count_t\t\t(*read_double)\t(struct sf_private_tag*, double *ptr, sf_count_t len) ;\n\n\tsf_count_t\t\t(*write_short)\t(struct sf_private_tag*, const short *ptr, sf_count_t len) ;\n\tsf_count_t\t\t(*write_int)\t(struct sf_private_tag*, const int *ptr, sf_count_t len) ;\n\tsf_count_t\t\t(*write_float)\t(struct sf_private_tag*, const float *ptr, sf_count_t len) ;\n\tsf_count_t\t\t(*write_double)\t(struct sf_private_tag*, const double *ptr, sf_count_t len) ;\n\n\tsf_count_t\t\t(*seek) \t\t(struct sf_private_tag*, int mode, sf_count_t samples_from_start) ;\n\tint\t\t\t\t(*write_header)\t(struct sf_private_tag*, int calc_length) ;\n\tint\t\t\t\t(*command)\t\t(struct sf_private_tag*, int command, void *data, int datasize) ;\n\tint\t\t\t\t(*byterate)\t\t(struct sf_private_tag*) ;\n\n\t/*\n\t**\tSeparate close functions for the codec and the container.\n\t**\tThe codec close function is always called first.\n\t*/\n\tint\t\t\t\t(*codec_close)\t\t(struct sf_private_tag*) ;\n\tint\t\t\t\t(*container_close)\t(struct sf_private_tag*) ;\n\n\tchar\t\t\t*format_desc ;\n\n\t/* Virtual I/O functions. */\n\tint\t\t\t\t\tvirtual_io ;\n\tSF_VIRTUAL_IO\t\tvio ;\n\tvoid\t\t\t\t*vio_user_data ;\n\n\t/* Chunk get/set. */\n\tSF_CHUNK_ITERATOR\t*iterator ;\n\n\tREAD_CHUNKS\t\t\trchunks ;\n\tWRITE_CHUNKS\t\twchunks ;\n\n\tint\t\t\t\t\t(*set_chunk)\t\t(struct sf_private_tag*, const SF_CHUNK_INFO * chunk_info) ;\n\tSF_CHUNK_ITERATOR *\t(*next_chunk_iterator)\t(struct sf_private_tag*, SF_CHUNK_ITERATOR * iterator) ;\n\tint\t\t\t\t\t(*get_chunk_size)\t(struct sf_private_tag*, const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info) ;\n\tint\t\t\t\t\t(*get_chunk_data)\t(struct sf_private_tag*, const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info) ;\n} SF_PRIVATE ;\n\n\n\nenum\n{\tSFE_NO_ERROR\t\t\t\t= SF_ERR_NO_ERROR,\n\tSFE_BAD_OPEN_FORMAT\t\t\t= SF_ERR_UNRECOGNISED_FORMAT,\n\tSFE_SYSTEM\t\t\t\t\t= SF_ERR_SYSTEM,\n\tSFE_MALFORMED_FILE\t\t\t= SF_ERR_MALFORMED_FILE,\n\tSFE_UNSUPPORTED_ENCODING\t= SF_ERR_UNSUPPORTED_ENCODING,\n\n\tSFE_ZERO_MAJOR_FORMAT,\n\tSFE_ZERO_MINOR_FORMAT,\n\tSFE_BAD_FILE,\n\tSFE_BAD_FILE_READ,\n\tSFE_OPEN_FAILED,\n\tSFE_BAD_SNDFILE_PTR,\n\tSFE_BAD_SF_INFO_PTR,\n\tSFE_BAD_SF_INCOMPLETE,\n\tSFE_BAD_FILE_PTR,\n\tSFE_BAD_INT_PTR,\n\tSFE_BAD_STAT_SIZE,\n\tSFE_NO_TEMP_DIR,\n\tSFE_MALLOC_FAILED,\n\tSFE_UNIMPLEMENTED,\n\tSFE_BAD_READ_ALIGN,\n\tSFE_BAD_WRITE_ALIGN,\n\tSFE_UNKNOWN_FORMAT,\n\tSFE_NOT_READMODE,\n\tSFE_NOT_WRITEMODE,\n\tSFE_BAD_MODE_RW,\n\tSFE_BAD_SF_INFO,\n\tSFE_BAD_OFFSET,\n\tSFE_NO_EMBED_SUPPORT,\n\tSFE_NO_EMBEDDED_RDWR,\n\tSFE_NO_PIPE_WRITE,\n\n\tSFE_INTERNAL,\n\tSFE_BAD_COMMAND_PARAM,\n\tSFE_BAD_ENDIAN,\n\tSFE_CHANNEL_COUNT_ZERO,\n\tSFE_CHANNEL_COUNT,\n\tSFE_CHANNEL_COUNT_BAD,\n\n\tSFE_BAD_VIRTUAL_IO,\n\n\tSFE_INTERLEAVE_MODE,\n\tSFE_INTERLEAVE_SEEK,\n\tSFE_INTERLEAVE_READ,\n\n\tSFE_BAD_SEEK,\n\tSFE_NOT_SEEKABLE,\n\tSFE_AMBIGUOUS_SEEK,\n\tSFE_WRONG_SEEK,\n\tSFE_SEEK_FAILED,\n\n\tSFE_BAD_OPEN_MODE,\n\tSFE_OPEN_PIPE_RDWR,\n\tSFE_RDWR_POSITION,\n\tSFE_RDWR_BAD_HEADER,\n\tSFE_CMD_HAS_DATA,\n\tSFE_BAD_BROADCAST_INFO_SIZE,\n\tSFE_BAD_BROADCAST_INFO_TOO_BIG,\n\tSFE_BAD_CART_INFO_SIZE,\n\tSFE_BAD_CART_INFO_TOO_BIG,\n\n\tSFE_STR_NO_SUPPORT,\n\tSFE_STR_NOT_WRITE,\n\tSFE_STR_MAX_DATA,\n\tSFE_STR_MAX_COUNT,\n\tSFE_STR_BAD_TYPE,\n\tSFE_STR_NO_ADD_END,\n\tSFE_STR_BAD_STRING,\n\tSFE_STR_WEIRD,\n\n\tSFE_WAV_NO_RIFF,\n\tSFE_WAV_NO_WAVE,\n\tSFE_WAV_NO_FMT,\n\tSFE_WAV_BAD_FMT,\n\tSFE_WAV_FMT_SHORT,\n\tSFE_WAV_BAD_FACT,\n\tSFE_WAV_BAD_PEAK,\n\tSFE_WAV_PEAK_B4_FMT,\n\tSFE_WAV_BAD_FORMAT,\n\tSFE_WAV_BAD_BLOCKALIGN,\n\tSFE_WAV_NO_DATA,\n\tSFE_WAV_BAD_LIST,\n\tSFE_WAV_ADPCM_NOT4BIT,\n\tSFE_WAV_ADPCM_CHANNELS,\n\tSFE_WAV_ADPCM_SAMPLES,\n\tSFE_WAV_GSM610_FORMAT,\n\tSFE_WAV_UNKNOWN_CHUNK,\n\tSFE_WAV_WVPK_DATA,\n\n\tSFE_AIFF_NO_FORM,\n\tSFE_AIFF_AIFF_NO_FORM,\n\tSFE_AIFF_COMM_NO_FORM,\n\tSFE_AIFF_SSND_NO_COMM,\n\tSFE_AIFF_UNKNOWN_CHUNK,\n\tSFE_AIFF_COMM_CHUNK_SIZE,\n\tSFE_AIFF_BAD_COMM_CHUNK,\n\tSFE_AIFF_PEAK_B4_COMM,\n\tSFE_AIFF_BAD_PEAK,\n\tSFE_AIFF_NO_SSND,\n\tSFE_AIFF_NO_DATA,\n\tSFE_AIFF_RW_SSND_NOT_LAST,\n\n\tSFE_AU_UNKNOWN_FORMAT,\n\tSFE_AU_NO_DOTSND,\n\tSFE_AU_EMBED_BAD_LEN,\n\n\tSFE_RAW_READ_BAD_SPEC,\n\tSFE_RAW_BAD_BITWIDTH,\n\tSFE_RAW_BAD_FORMAT,\n\n\tSFE_PAF_NO_MARKER,\n\tSFE_PAF_VERSION,\n\tSFE_PAF_UNKNOWN_FORMAT,\n\tSFE_PAF_SHORT_HEADER,\n\tSFE_PAF_BAD_CHANNELS,\n\n\tSFE_SVX_NO_FORM,\n\tSFE_SVX_NO_BODY,\n\tSFE_SVX_NO_DATA,\n\tSFE_SVX_BAD_COMP,\n\tSFE_SVX_BAD_NAME_LENGTH,\n\n\tSFE_NIST_BAD_HEADER,\n\tSFE_NIST_CRLF_CONVERISON,\n\tSFE_NIST_BAD_ENCODING,\n\n\tSFE_VOC_NO_CREATIVE,\n\tSFE_VOC_BAD_FORMAT,\n\tSFE_VOC_BAD_VERSION,\n\tSFE_VOC_BAD_MARKER,\n\tSFE_VOC_BAD_SECTIONS,\n\tSFE_VOC_MULTI_SAMPLERATE,\n\tSFE_VOC_MULTI_SECTION,\n\tSFE_VOC_MULTI_PARAM,\n\tSFE_VOC_SECTION_COUNT,\n\tSFE_VOC_NO_PIPE,\n\n\tSFE_IRCAM_NO_MARKER,\n\tSFE_IRCAM_BAD_CHANNELS,\n\tSFE_IRCAM_UNKNOWN_FORMAT,\n\n\tSFE_W64_64_BIT,\n\tSFE_W64_NO_RIFF,\n\tSFE_W64_NO_WAVE,\n\tSFE_W64_NO_DATA,\n\tSFE_W64_ADPCM_NOT4BIT,\n\tSFE_W64_ADPCM_CHANNELS,\n\tSFE_W64_GSM610_FORMAT,\n\n\tSFE_MAT4_BAD_NAME,\n\tSFE_MAT4_NO_SAMPLERATE,\n\n\tSFE_MAT5_BAD_ENDIAN,\n\tSFE_MAT5_NO_BLOCK,\n\tSFE_MAT5_SAMPLE_RATE,\n\n\tSFE_PVF_NO_PVF1,\n\tSFE_PVF_BAD_HEADER,\n\tSFE_PVF_BAD_BITWIDTH,\n\n\tSFE_DWVW_BAD_BITWIDTH,\n\tSFE_G72X_NOT_MONO,\n\n\tSFE_XI_BAD_HEADER,\n\tSFE_XI_EXCESS_SAMPLES,\n\tSFE_XI_NO_PIPE,\n\n\tSFE_HTK_NO_PIPE,\n\n\tSFE_SDS_NOT_SDS,\n\tSFE_SDS_BAD_BIT_WIDTH,\n\n\tSFE_SD2_FD_DISALLOWED,\n\tSFE_SD2_BAD_DATA_OFFSET,\n\tSFE_SD2_BAD_MAP_OFFSET,\n\tSFE_SD2_BAD_DATA_LENGTH,\n\tSFE_SD2_BAD_MAP_LENGTH,\n\tSFE_SD2_BAD_RSRC,\n\tSFE_SD2_BAD_SAMPLE_SIZE,\n\n\tSFE_FLAC_BAD_HEADER,\n\tSFE_FLAC_NEW_DECODER,\n\tSFE_FLAC_INIT_DECODER,\n\tSFE_FLAC_LOST_SYNC,\n\tSFE_FLAC_BAD_SAMPLE_RATE,\n\tSFE_FLAC_UNKOWN_ERROR,\n\n\tSFE_WVE_NOT_WVE,\n\tSFE_WVE_NO_PIPE,\n\n\tSFE_VORBIS_ENCODER_BUG,\n\n\tSFE_RF64_NOT_RF64,\n\tSFE_RF64_PEAK_B4_FMT,\n\tSFE_RF64_NO_DATA,\n\n\tSFE_BAD_CHUNK_PTR,\n\tSFE_UNKNOWN_CHUNK,\n\tSFE_BAD_CHUNK_FORMAT,\n\tSFE_BAD_CHUNK_MARKER,\n\tSFE_BAD_CHUNK_DATA_PTR,\n\tSFE_ALAC_FAIL_TMPFILE,\n\tSFE_FILENAME_TOO_LONG,\n\n\tSFE_MAX_ERROR\t\t\t/* This must be last in list. */\n} ;\n\nint subformat_to_bytewidth (int format) ;\nint s_bitwidth_to_subformat (int bits) ;\nint u_bitwidth_to_subformat (int bits) ;\n\n/*  Functions for reading and writing floats and doubles on processors\n**\twith non-IEEE floats/doubles.\n*/\nfloat\tfloat32_be_read\t\t(const unsigned char *cptr) ;\nfloat\tfloat32_le_read\t\t(const unsigned char *cptr) ;\nvoid\tfloat32_be_write\t(float in, unsigned char *out) ;\nvoid\tfloat32_le_write\t(float in, unsigned char *out) ;\n\ndouble\tdouble64_be_read\t(const unsigned char *cptr) ;\ndouble\tdouble64_le_read\t(const unsigned char *cptr) ;\nvoid\tdouble64_be_write\t(double in, unsigned char *out) ;\nvoid\tdouble64_le_write\t(double in, unsigned char *out) ;\n\n/* Functions for writing to the internal logging buffer. */\n\nvoid\tpsf_log_printf\t\t(SF_PRIVATE *psf, const char *format, ...) ;\nvoid\tpsf_log_SF_INFO \t(SF_PRIVATE *psf) ;\n\nint32_t\tpsf_rand_int32 (void) ;\n\nvoid append_snprintf (char * dest, size_t maxlen, const char * fmt, ...) ;\nvoid psf_strlcpy_crlf (char *dest, const char *src, size_t destmax, size_t srcmax) ;\n\nsf_count_t psf_decode_frame_count (SF_PRIVATE *psf) ;\n\n/* Functions used when writing file headers. */\n\nint\t\tpsf_binheader_writef\t(SF_PRIVATE *psf, const char *format, ...) ;\nvoid\tpsf_asciiheader_printf\t(SF_PRIVATE *psf, const char *format, ...) ;\n\n/* Functions used when reading file headers. */\n\nint\t\tpsf_binheader_readf\t(SF_PRIVATE *psf, char const *format, ...) ;\n\n/* Functions used in the write function for updating the peak chunk. */\n\nvoid\tpeak_update_short\t(SF_PRIVATE *psf, short *ptr, size_t items) ;\nvoid\tpeak_update_int\t\t(SF_PRIVATE *psf, int *ptr, size_t items) ;\nvoid\tpeak_update_double\t(SF_PRIVATE *psf, double *ptr, size_t items) ;\n\n/* Functions defined in command.c. */\n\nint\t\tpsf_get_format_simple_count\t(void) ;\nint\t\tpsf_get_format_simple\t\t(SF_FORMAT_INFO *data) ;\n\nint\t\tpsf_get_format_info\t\t\t(SF_FORMAT_INFO *data) ;\n\nint\t\tpsf_get_format_major_count\t(void) ;\nint\t\tpsf_get_format_major\t\t(SF_FORMAT_INFO *data) ;\n\nint\t\tpsf_get_format_subtype_count\t(void) ;\nint\t\tpsf_get_format_subtype\t\t(SF_FORMAT_INFO *data) ;\n\nvoid\tpsf_generate_format_desc (SF_PRIVATE *psf) ;\n\ndouble\tpsf_calc_signal_max\t\t\t(SF_PRIVATE *psf, int normalize) ;\nint\t\tpsf_calc_max_all_channels\t(SF_PRIVATE *psf, double *peaks, int normalize) ;\n\nint\t\tpsf_get_signal_max\t\t\t(SF_PRIVATE *psf, double *peak) ;\nint\t\tpsf_get_max_all_channels\t(SF_PRIVATE *psf, double *peaks) ;\n\n/* Functions in strings.c. */\n\nconst char* psf_get_string (SF_PRIVATE *psf, int str_type) ;\nint psf_set_string (SF_PRIVATE *psf, int str_type, const char *str) ;\nint psf_store_string (SF_PRIVATE *psf, int str_type, const char *str) ;\nint psf_location_string_count (const SF_PRIVATE * psf, int location) ;\n\n/* Default seek function. Use for PCM and float encoded data. */\nsf_count_t\tpsf_default_seek (SF_PRIVATE *psf, int mode, sf_count_t samples_from_start) ;\n\nint macos_guess_file_type (SF_PRIVATE *psf, const char *filename) ;\n\n/*------------------------------------------------------------------------------------\n**\tFile I/O functions which will allow access to large files (> 2 Gig) on\n**\tsome 32 bit OSes. Implementation in file_io.c.\n*/\n\nint psf_fopen (SF_PRIVATE *psf) ;\nint psf_set_stdio (SF_PRIVATE *psf) ;\nint psf_file_valid (SF_PRIVATE *psf) ;\nvoid psf_set_file (SF_PRIVATE *psf, int fd) ;\nvoid psf_init_files (SF_PRIVATE *psf) ;\nvoid psf_use_rsrc (SF_PRIVATE *psf, int on_off) ;\n\nSNDFILE * psf_open_file (SF_PRIVATE *psf, SF_INFO *sfinfo) ;\n\nsf_count_t psf_fseek (SF_PRIVATE *psf, sf_count_t offset, int whence) ;\nsf_count_t psf_fread (void *ptr, sf_count_t bytes, sf_count_t count, SF_PRIVATE *psf) ;\nsf_count_t psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t count, SF_PRIVATE *psf) ;\nsf_count_t psf_fgets (char *buffer, sf_count_t bufsize, SF_PRIVATE *psf) ;\nsf_count_t psf_ftell (SF_PRIVATE *psf) ;\nsf_count_t psf_get_filelen (SF_PRIVATE *psf) ;\n\nvoid psf_fsync (SF_PRIVATE *psf) ;\n\nint psf_is_pipe (SF_PRIVATE *psf) ;\n\nint psf_ftruncate (SF_PRIVATE *psf, sf_count_t len) ;\nint psf_fclose (SF_PRIVATE *psf) ;\n\n/* Open and close the resource fork of a file. */\nint psf_open_rsrc (SF_PRIVATE *psf) ;\nint psf_close_rsrc (SF_PRIVATE *psf) ;\n\n/*\nvoid psf_fclearerr (SF_PRIVATE *psf) ;\nint psf_ferror (SF_PRIVATE *psf) ;\n*/\n\n/*------------------------------------------------------------------------------------\n** Functions for reading and writing different file formats.\n*/\n\nint\t\taiff_open\t(SF_PRIVATE *psf) ;\nint\t\tau_open\t\t(SF_PRIVATE *psf) ;\nint\t\tavr_open\t(SF_PRIVATE *psf) ;\nint\t\thtk_open\t(SF_PRIVATE *psf) ;\nint\t\tircam_open\t(SF_PRIVATE *psf) ;\nint\t\tmat4_open\t(SF_PRIVATE *psf) ;\nint\t\tmat5_open\t(SF_PRIVATE *psf) ;\nint\t\tnist_open\t(SF_PRIVATE *psf) ;\nint\t\tpaf_open\t(SF_PRIVATE *psf) ;\nint\t\tpvf_open\t(SF_PRIVATE *psf) ;\nint\t\traw_open\t(SF_PRIVATE *psf) ;\nint\t\tsd2_open\t(SF_PRIVATE *psf) ;\nint\t\tsds_open\t(SF_PRIVATE *psf) ;\nint\t\tsvx_open\t(SF_PRIVATE *psf) ;\nint\t\tvoc_open\t(SF_PRIVATE *psf) ;\nint\t\tw64_open\t(SF_PRIVATE *psf) ;\nint\t\twav_open\t(SF_PRIVATE *psf) ;\nint\t\txi_open\t\t(SF_PRIVATE *psf) ;\nint\t\tflac_open\t(SF_PRIVATE *psf) ;\nint\t\tcaf_open\t(SF_PRIVATE *psf) ;\nint\t\tmpc2k_open\t(SF_PRIVATE *psf) ;\nint\t\trf64_open\t(SF_PRIVATE *psf) ;\n\nint\t\togg_vorbis_open\t(SF_PRIVATE *psf) ;\nint\t\togg_speex_open\t(SF_PRIVATE *psf) ;\nint\t\togg_pcm_open\t(SF_PRIVATE *psf) ;\nint\t\togg_opus_open\t(SF_PRIVATE *psf) ;\nint\t\togg_open\t(SF_PRIVATE *psf) ;\n\n\n/* In progress. Do not currently work. */\n\nint\t\tmpeg_open\t(SF_PRIVATE *psf) ;\nint\t\trx2_open\t(SF_PRIVATE *psf) ;\nint\t\ttxw_open\t(SF_PRIVATE *psf) ;\nint\t\twve_open\t(SF_PRIVATE *psf) ;\nint\t\tdwd_open\t(SF_PRIVATE *psf) ;\n\n/*------------------------------------------------------------------------------------\n**\tInit functions for a number of common data encodings.\n*/\n\nint\t\tpcm_init\t\t(SF_PRIVATE *psf) ;\nint\t\tulaw_init\t\t(SF_PRIVATE *psf) ;\nint\t\talaw_init\t\t(SF_PRIVATE *psf) ;\nint\t\tfloat32_init\t(SF_PRIVATE *psf) ;\nint\t\tdouble64_init\t(SF_PRIVATE *psf) ;\nint\t\tdwvw_init\t\t(SF_PRIVATE *psf, int bitwidth) ;\nint\t\tgsm610_init\t\t(SF_PRIVATE *psf) ;\nint\t\tvox_adpcm_init\t(SF_PRIVATE *psf) ;\nint\t\tflac_init\t\t(SF_PRIVATE *psf) ;\nint\t\tg72x_init \t\t(SF_PRIVATE * psf) ;\nint\t\talac_init\t\t(SF_PRIVATE *psf, const ALAC_DECODER_INFO * info) ;\n\nint \tdither_init\t\t(SF_PRIVATE *psf, int mode) ;\n\nint\t\twavlike_ima_init (SF_PRIVATE *psf, int blockalign, int samplesperblock) ;\nint\t\twavlike_msadpcm_init (SF_PRIVATE *psf, int blockalign, int samplesperblock) ;\n\nint\t\taiff_ima_init (SF_PRIVATE *psf, int blockalign, int samplesperblock) ;\n\nint\t\tinterleave_init (SF_PRIVATE *psf) ;\n\n/*------------------------------------------------------------------------------------\n** Chunk logging functions.\n*/\n\nSF_CHUNK_ITERATOR * psf_get_chunk_iterator (SF_PRIVATE * psf, const char * marker_str) ;\nSF_CHUNK_ITERATOR * psf_next_chunk_iterator (const READ_CHUNKS * pchk , SF_CHUNK_ITERATOR *iterator) ;\nint\t\tpsf_store_read_chunk_u32 (READ_CHUNKS * pchk, uint32_t marker, sf_count_t offset, uint32_t len) ;\nint\t\tpsf_store_read_chunk_str (READ_CHUNKS * pchk, const char * marker, sf_count_t offset, uint32_t len) ;\nint\t\tpsf_save_write_chunk (WRITE_CHUNKS * pchk, const SF_CHUNK_INFO * chunk_info) ;\nint\t\tpsf_find_read_chunk_str (const READ_CHUNKS * pchk, const char * marker) ;\nint\t\tpsf_find_read_chunk_m32 (const READ_CHUNKS * pchk, uint32_t marker) ;\nint\t\tpsf_find_read_chunk_iterator (const READ_CHUNKS * pchk, const SF_CHUNK_ITERATOR * marker) ;\n\nint\t\tpsf_find_write_chunk (WRITE_CHUNKS * pchk, const char * marker) ;\n\nstatic inline int\nfourcc_to_marker (const SF_CHUNK_INFO * chunk_info)\n{\tconst unsigned char * cptr ;\n\n\tif (chunk_info->id_size != 4)\n\t\treturn 0 ;\n\n\tcptr = (const unsigned char *) chunk_info->id ;\n\treturn (cptr [3] << 24) + (cptr [2] << 16) + (cptr [1] << 8) + cptr [0] ;\n} /* fourcc_to_marker */\n\n/*------------------------------------------------------------------------------------\n** Functions that work like OpenBSD's strlcpy/strlcat to replace strncpy/strncat.\n**\n** See : http://www.gratisoft.us/todd/papers/strlcpy.html\n**\n** These functions are available on *BSD, but are not avaialble everywhere so we\n** implement them here.\n**\n** The argument order has been changed to that of strncpy/strncat to cause\n** compiler errors if code is carelessly converted from one to the other.\n*/\n\nstatic inline void\npsf_strlcat (char *dest, size_t n, const char *src)\n{\tstrncat (dest, src, n - strlen (dest) - 1) ;\n\tdest [n - 1] = 0 ;\n} /* psf_strlcat */\n\nstatic inline void\npsf_strlcpy (char *dest, size_t n, const char *src)\n{\tstrncpy (dest, src, n - 1) ;\n\tdest [n - 1] = 0 ;\n} /* psf_strlcpy */\n\n/*------------------------------------------------------------------------------------\n** Other helper functions.\n*/\n\nvoid\t*psf_memset (void *s, int c, sf_count_t n) ;\n\nSF_CUES * psf_cues_dup (const void * ptr) ;\nSF_CUES * psf_cues_alloc (uint32_t cue_count) ;\nvoid psf_get_cues (SF_PRIVATE * psf, void * data, size_t datasize) ;\n\nSF_INSTRUMENT * psf_instrument_alloc (void) ;\n\nvoid\tpsf_sanitize_string (char * cptr, int len) ;\n\n/* Generate the current date as a string. */\nvoid\tpsf_get_date_str (char *str, int maxlen) ;\n\nSF_BROADCAST_INFO_16K * broadcast_var_alloc (void) ;\nint\t\tbroadcast_var_set (SF_PRIVATE *psf, const SF_BROADCAST_INFO * data, size_t datasize) ;\nint\t\tbroadcast_var_get (SF_PRIVATE *psf, SF_BROADCAST_INFO * data, size_t datasize) ;\n\n\nSF_CART_INFO_16K * cart_var_alloc (void) ;\nint \t\tcart_var_set (SF_PRIVATE *psf, const SF_CART_INFO * date, size_t datasize) ;\nint\t\tcart_var_get (SF_PRIVATE *psf, SF_CART_INFO * data, size_t datasize) ;\n\ntypedef struct\n{\tint channels ;\n\tint endianness ;\n} AUDIO_DETECT ;\n\nint audio_detect (SF_PRIVATE * psf, AUDIO_DETECT *ad, const unsigned char * data, int datalen) ;\nint id3_skip (SF_PRIVATE * psf) ;\n\nvoid\talac_get_desc_chunk_items (int subformat, uint32_t *fmt_flags, uint32_t *frames_per_packet) ;\n\nFILE *\tpsf_open_tmpfile (char * fname, size_t fnamelen) ;\n\n/*------------------------------------------------------------------------------------\n** Helper/debug functions.\n*/\n\nvoid\tpsf_hexdump (const void *ptr, int len) ;\n\nconst char * str_of_major_format (int format) ;\nconst char * str_of_minor_format (int format) ;\nconst char * str_of_open_mode (int mode) ;\nconst char * str_of_endianness (int end) ;\n\n/*------------------------------------------------------------------------------------\n** Extra commands for sf_command(). Not for public use yet.\n*/\n\nenum\n{\tSFC_TEST_AIFF_ADD_INST_CHUNK\t= 0x2000,\n\tSFC_TEST_WAV_ADD_INFO_CHUNK\t\t= 0x2010\n} ;\n\n/*\n** Maybe, one day, make these functions or something like them, public.\n**\n** Buffer to buffer dithering. Pointer in and out are allowed to point\n** to the same buffer for in-place dithering.\n*/\n\n#if 0\nint sf_dither_short\t\t(const SF_DITHER_INFO *dither, const short *in, short *out, int count) ;\nint sf_dither_int\t\t(const SF_DITHER_INFO *dither, const int *in, int *out, int count) ;\nint sf_dither_float\t\t(const SF_DITHER_INFO *dither, const float *in, float *out, int count) ;\nint sf_dither_double\t(const SF_DITHER_INFO *dither, const double *in, double *out, int count) ;\n#endif\n\n/*------------------------------------------------------------------------------------\n** Data conversion functions.\n*/\n\nvoid psf_f2s_array (const float *src, short *dest, int count, int normalize) ;\nvoid psf_f2s_clip_array (const float *src, short *dest, int count, int normalize) ;\n\nvoid psf_d2s_array (const double *src, short *dest, int count, int normalize) ;\nvoid psf_d2s_clip_array (const double *src, short *dest, int count, int normalize) ;\n\nvoid psf_f2i_array (const float *src, int *dest, int count, int normalize) ;\nvoid psf_f2i_clip_array (const float *src, int *dest, int count, int normalize) ;\n\nvoid psf_d2i_array (const double *src, int *dest, int count, int normalize) ;\nvoid psf_d2i_clip_array (const double *src, int *dest, int count, int normalize) ;\n\n\n/*------------------------------------------------------------------------------------\n** Left and right shift on int. According to the C standard, the left and right\n** shift operations applied to a negative integer results in undefined behavior.\n** These twp functions work around that.\n*/\n\n#if __GNUC__\n#define ALWAYS_INLINE\t\t__attribute__ ((always_inline))\n#else\n#define ALWAYS_INLINE\n#endif\n\nstatic inline int32_t ALWAYS_INLINE\narith_shift_left (int32_t x, int shift)\n{\treturn (int32_t) (((uint32_t) x) << shift) ;\n} /* arith_shift_left */\n\nstatic inline int32_t ALWAYS_INLINE\narith_shift_right (int32_t x, int shift)\n{\tif (x >= 0)\n\t\treturn x >> shift ;\n\treturn ~ ((~x) >> shift) ;\n} /* arith_shift_right */\n\n#endif /* SNDFILE_COMMON_H */\n", "/*\n** Copyright (C) 1999-2016 Erik de Castro Lopo <erikd@mega-nerd.com>\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n#include\t\"sfconfig.h\"\n\n#include\t<stdlib.h>\n#include\t<string.h>\n#include\t<ctype.h>\n#include\t<assert.h>\n\n#include\t\"sndfile.h\"\n#include\t\"sfendian.h\"\n#include\t\"common.h\"\n\n#define\t\tSNDFILE_MAGICK\t0x1234C0DE\n\n#ifdef __APPLE__\n\t/*\n\t**\tDetect if a compile for a universal binary is being attempted and barf if it is.\n\t**\tSee the URL below for the rationale.\n\t*/\n\t#ifdef __BIG_ENDIAN__\n\t\t#if (CPU_IS_LITTLE_ENDIAN == 1)\n\t\t\t#error \"Universal binary compile detected. See http://www.mega-nerd.com/libsndfile/FAQ.html#Q018\"\n\t\t#endif\n\t#endif\n\n\t#ifdef __LITTLE_ENDIAN__\n\t\t#if (CPU_IS_BIG_ENDIAN == 1)\n\t\t\t#error \"Universal binary compile detected. See http://www.mega-nerd.com/libsndfile/FAQ.html#Q018\"\n\t\t#endif\n\t#endif\n#endif\n\n\ntypedef struct\n{\tint \t\terror ;\n\tconst char\t*str ;\n} ErrorStruct ;\n\nstatic\nErrorStruct SndfileErrors [] =\n{\n\t/* Public error values and their associated strings. */\n\t{\tSF_ERR_NO_ERROR\t\t\t\t, \"No Error.\" },\n\t{\tSF_ERR_UNRECOGNISED_FORMAT\t, \"Format not recognised.\" },\n\t{\tSF_ERR_SYSTEM\t\t\t\t, \"System error.\" /* Often replaced. */ \t},\n\t{\tSF_ERR_MALFORMED_FILE\t\t, \"Supported file format but file is malformed.\" },\n\t{\tSF_ERR_UNSUPPORTED_ENCODING\t, \"Supported file format but unsupported encoding.\" },\n\n\t/* Private error values and their associated strings. */\n\t{\tSFE_ZERO_MAJOR_FORMAT\t, \"Error : major format is 0.\" },\n\t{\tSFE_ZERO_MINOR_FORMAT\t, \"Error : minor format is 0.\" },\n\t{\tSFE_BAD_FILE\t\t\t, \"File does not exist or is not a regular file (possibly a pipe?).\" },\n\t{\tSFE_BAD_FILE_READ\t\t, \"File exists but no data could be read.\" },\n\t{\tSFE_OPEN_FAILED\t\t\t, \"Could not open file.\" },\n\t{\tSFE_BAD_SNDFILE_PTR\t\t, \"Not a valid SNDFILE* pointer.\" },\n\t{\tSFE_BAD_SF_INFO_PTR\t\t, \"NULL SF_INFO pointer passed to libsndfile.\" },\n\t{\tSFE_BAD_SF_INCOMPLETE\t, \"SF_PRIVATE struct incomplete and end of header parsing.\" },\n\t{\tSFE_BAD_FILE_PTR\t\t, \"Bad FILE pointer.\" },\n\t{\tSFE_BAD_INT_PTR\t\t\t, \"Internal error, Bad pointer.\" },\n\t{\tSFE_BAD_STAT_SIZE\t\t, \"Error : software was misconfigured at compile time (sizeof statbuf.st_size).\" },\n\t{\tSFE_NO_TEMP_DIR\t\t\t, \"Error : Could not file temp dir.\" },\n\n\t{\tSFE_MALLOC_FAILED\t\t, \"Internal malloc () failed.\" },\n\t{\tSFE_UNIMPLEMENTED\t\t, \"File contains data in an unimplemented format.\" },\n\t{\tSFE_BAD_READ_ALIGN\t\t, \"Attempt to read a non-integer number of channels.\" },\n\t{\tSFE_BAD_WRITE_ALIGN \t, \"Attempt to write a non-integer number of channels.\" },\n\t{\tSFE_UNKNOWN_FORMAT\t\t, \"File contains data in an unknown format.\" },\n\t{\tSFE_NOT_READMODE\t\t, \"Read attempted on file currently open for write.\" },\n\t{\tSFE_NOT_WRITEMODE\t\t, \"Write attempted on file currently open for read.\" },\n\t{\tSFE_BAD_MODE_RW\t\t\t, \"Error : This file format does not support read/write mode.\" },\n\t{\tSFE_BAD_SF_INFO\t\t\t, \"Internal error : SF_INFO struct incomplete.\" },\n\t{\tSFE_BAD_OFFSET\t\t\t, \"Error : supplied offset beyond end of file.\" },\n\t{\tSFE_NO_EMBED_SUPPORT\t, \"Error : embedding not supported for this file format.\" },\n\t{\tSFE_NO_EMBEDDED_RDWR\t, \"Error : cannot open embedded file read/write.\" },\n\t{\tSFE_NO_PIPE_WRITE\t\t, \"Error : this file format does not support pipe write.\" },\n\t{\tSFE_BAD_VIRTUAL_IO\t\t, \"Error : bad pointer on SF_VIRTUAL_IO struct.\" },\n\t{\tSFE_BAD_BROADCAST_INFO_SIZE\n\t\t\t\t\t\t\t\t, \"Error : bad coding_history_size in SF_BROADCAST_INFO struct.\" },\n\t{\tSFE_BAD_BROADCAST_INFO_TOO_BIG\n\t\t\t\t\t\t\t\t, \"Error : SF_BROADCAST_INFO struct too large.\" },\n\t{\tSFE_BAD_CART_INFO_SIZE\t\t\t\t, \"Error: SF_CART_INFO struct too large.\" },\n\t{\tSFE_BAD_CART_INFO_TOO_BIG\t\t\t, \"Error: bag tag_text_size in SF_CART_INFO struct.\" },\n\t{\tSFE_INTERLEAVE_MODE\t\t, \"Attempt to write to file with non-interleaved data.\" },\n\t{\tSFE_INTERLEAVE_SEEK\t\t, \"Bad karma in seek during interleave read operation.\" },\n\t{\tSFE_INTERLEAVE_READ\t\t, \"Bad karma in read during interleave read operation.\" },\n\n\t{\tSFE_INTERNAL\t\t\t, \"Unspecified internal error.\" },\n\t{\tSFE_BAD_COMMAND_PARAM\t, \"Bad parameter passed to function sf_command.\" },\n\t{\tSFE_BAD_ENDIAN\t\t\t, \"Bad endian-ness. Try default endian-ness\" },\n\t{\tSFE_CHANNEL_COUNT_ZERO\t, \"Channel count is zero.\" },\n\t{\tSFE_CHANNEL_COUNT\t\t, \"Too many channels specified.\" },\n\t{\tSFE_CHANNEL_COUNT_BAD\t, \"Bad channel count.\" },\n\n\t{\tSFE_BAD_SEEK\t\t\t, \"Internal psf_fseek() failed.\" },\n\t{\tSFE_NOT_SEEKABLE\t\t, \"Seek attempted on unseekable file type.\" },\n\t{\tSFE_AMBIGUOUS_SEEK\t\t, \"Error : combination of file open mode and seek command is ambiguous.\" },\n\t{\tSFE_WRONG_SEEK\t\t\t, \"Error : invalid seek parameters.\" },\n\t{\tSFE_SEEK_FAILED\t\t\t, \"Error : parameters OK, but psf_seek() failed.\" },\n\n\t{\tSFE_BAD_OPEN_MODE\t\t, \"Error : bad mode parameter for file open.\" },\n\t{\tSFE_OPEN_PIPE_RDWR\t\t, \"Error : attempt to open a pipe in read/write mode.\" },\n\t{\tSFE_RDWR_POSITION\t\t, \"Error on RDWR position (cryptic).\" },\n\t{\tSFE_RDWR_BAD_HEADER\t\t, \"Error : Cannot open file in read/write mode due to string data in header.\" },\n\t{\tSFE_CMD_HAS_DATA\t\t, \"Error : Command fails because file already has audio data.\" },\n\n\t{\tSFE_STR_NO_SUPPORT\t\t, \"Error : File type does not support string data.\" },\n\t{\tSFE_STR_NOT_WRITE\t\t, \"Error : Trying to set a string when file is not in write mode.\" },\n\t{\tSFE_STR_MAX_DATA\t\t, \"Error : Maximum string data storage reached.\" },\n\t{\tSFE_STR_MAX_COUNT\t\t, \"Error : Maximum string data count reached.\" },\n\t{\tSFE_STR_BAD_TYPE\t\t, \"Error : Bad string data type.\" },\n\t{\tSFE_STR_NO_ADD_END\t\t, \"Error : file type does not support strings added at end of file.\" },\n\t{\tSFE_STR_BAD_STRING\t\t, \"Error : bad string.\" },\n\t{\tSFE_STR_WEIRD\t\t\t, \"Error : Weird string error.\" },\n\n\t{\tSFE_WAV_NO_RIFF\t\t\t, \"Error in WAV file. No 'RIFF' chunk marker.\" },\n\t{\tSFE_WAV_NO_WAVE\t\t\t, \"Error in WAV file. No 'WAVE' chunk marker.\" },\n\t{\tSFE_WAV_NO_FMT\t\t\t, \"Error in WAV/W64/RF64 file. No 'fmt ' chunk marker.\" },\n\t{\tSFE_WAV_BAD_FMT\t\t\t, \"Error in WAV/W64/RF64 file. Malformed 'fmt ' chunk.\" },\n\t{\tSFE_WAV_FMT_SHORT\t\t, \"Error in WAV/W64/RF64 file. Short 'fmt ' chunk.\" },\n\n\t{\tSFE_WAV_BAD_FACT\t\t, \"Error in WAV file. 'fact' chunk out of place.\" },\n\t{\tSFE_WAV_BAD_PEAK\t\t, \"Error in WAV file. Bad 'PEAK' chunk.\" },\n\t{\tSFE_WAV_PEAK_B4_FMT\t\t, \"Error in WAV file. 'PEAK' chunk found before 'fmt ' chunk.\" },\n\n\t{\tSFE_WAV_BAD_FORMAT\t\t, \"Error in WAV file. Errors in 'fmt ' chunk.\" },\n\t{\tSFE_WAV_BAD_BLOCKALIGN\t, \"Error in WAV file. Block alignment in 'fmt ' chunk is incorrect.\" },\n\t{\tSFE_WAV_NO_DATA\t\t\t, \"Error in WAV file. No 'data' chunk marker.\" },\n\t{\tSFE_WAV_BAD_LIST\t\t, \"Error in WAV file. Malformed LIST chunk.\" },\n\t{\tSFE_WAV_UNKNOWN_CHUNK\t, \"Error in WAV file. File contains an unknown chunk marker.\" },\n\t{\tSFE_WAV_WVPK_DATA\t\t, \"Error in WAV file. Data is in WAVPACK format.\" },\n\n\t{\tSFE_WAV_ADPCM_NOT4BIT\t, \"Error in ADPCM WAV file. Invalid bit width.\" },\n\t{\tSFE_WAV_ADPCM_CHANNELS\t, \"Error in ADPCM WAV file. Invalid number of channels.\" },\n\t{\tSFE_WAV_ADPCM_SAMPLES\t, \"Error in ADPCM WAV file. Invalid number of samples per block.\" },\n\t{\tSFE_WAV_GSM610_FORMAT\t, \"Error in GSM610 WAV file. Invalid format chunk.\" },\n\n\t{\tSFE_AIFF_NO_FORM\t\t, \"Error in AIFF file, bad 'FORM' marker.\" },\n\t{\tSFE_AIFF_AIFF_NO_FORM\t, \"Error in AIFF file, 'AIFF' marker without 'FORM'.\" },\n\t{\tSFE_AIFF_COMM_NO_FORM\t, \"Error in AIFF file, 'COMM' marker without 'FORM'.\" },\n\t{\tSFE_AIFF_SSND_NO_COMM\t, \"Error in AIFF file, 'SSND' marker without 'COMM'.\" },\n\t{\tSFE_AIFF_UNKNOWN_CHUNK\t, \"Error in AIFF file, unknown chunk.\" },\n\t{\tSFE_AIFF_COMM_CHUNK_SIZE, \"Error in AIFF file, bad 'COMM' chunk size.\" },\n\t{\tSFE_AIFF_BAD_COMM_CHUNK , \"Error in AIFF file, bad 'COMM' chunk.\" },\n\t{\tSFE_AIFF_PEAK_B4_COMM\t, \"Error in AIFF file. 'PEAK' chunk found before 'COMM' chunk.\" },\n\t{\tSFE_AIFF_BAD_PEAK\t\t, \"Error in AIFF file. Bad 'PEAK' chunk.\" },\n\t{\tSFE_AIFF_NO_SSND\t\t, \"Error in AIFF file, bad 'SSND' chunk.\" },\n\t{\tSFE_AIFF_NO_DATA\t\t, \"Error in AIFF file, no sound data.\" },\n\t{\tSFE_AIFF_RW_SSND_NOT_LAST, \"Error in AIFF file, RDWR only possible if SSND chunk at end of file.\" },\n\n\t{\tSFE_AU_UNKNOWN_FORMAT\t, \"Error in AU file, unknown format.\" },\n\t{\tSFE_AU_NO_DOTSND\t\t, \"Error in AU file, missing '.snd' or 'dns.' marker.\" },\n\t{\tSFE_AU_EMBED_BAD_LEN\t, \"Embedded AU file with unknown length.\" },\n\n\t{\tSFE_RAW_READ_BAD_SPEC\t, \"Error while opening RAW file for read. Must specify format and channels.\\n\"\n\t\t\t\t\t\t\t\t\t\"Possibly trying to open unsupported format.\" },\n\t{\tSFE_RAW_BAD_BITWIDTH\t, \"Error. RAW file bitwidth must be a multiple of 8.\" },\n\t{\tSFE_RAW_BAD_FORMAT\t\t, \"Error. Bad format field in SF_INFO struct when opening a RAW file for read.\" },\n\n\t{\tSFE_PAF_NO_MARKER\t\t, \"Error in PAF file, no marker.\" },\n\t{\tSFE_PAF_VERSION\t\t\t, \"Error in PAF file, bad version.\" },\n\t{\tSFE_PAF_UNKNOWN_FORMAT\t, \"Error in PAF file, unknown format.\" },\n\t{\tSFE_PAF_SHORT_HEADER\t, \"Error in PAF file. File shorter than minimal header.\" },\n\t{\tSFE_PAF_BAD_CHANNELS\t, \"Error in PAF file. Bad channel count.\" },\n\n\t{\tSFE_SVX_NO_FORM\t\t\t, \"Error in 8SVX / 16SV file, no 'FORM' marker.\" },\n\t{\tSFE_SVX_NO_BODY\t\t\t, \"Error in 8SVX / 16SV file, no 'BODY' marker.\" },\n\t{\tSFE_SVX_NO_DATA\t\t\t, \"Error in 8SVX / 16SV file, no sound data.\" },\n\t{\tSFE_SVX_BAD_COMP\t\t, \"Error in 8SVX / 16SV file, unsupported compression format.\" },\n\t{\tSFE_SVX_BAD_NAME_LENGTH\t, \"Error in 8SVX / 16SV file, NAME chunk too long.\" },\n\n\t{\tSFE_NIST_BAD_HEADER\t\t, \"Error in NIST file, bad header.\" },\n\t{\tSFE_NIST_CRLF_CONVERISON, \"Error : NIST file damaged by Windows CR -> CRLF conversion process.\"\t},\n\t{\tSFE_NIST_BAD_ENCODING\t, \"Error in NIST file, unsupported compression format.\" },\n\n\t{\tSFE_VOC_NO_CREATIVE\t\t, \"Error in VOC file, no 'Creative Voice File' marker.\" },\n\t{\tSFE_VOC_BAD_FORMAT\t\t, \"Error in VOC file, bad format.\" },\n\t{\tSFE_VOC_BAD_VERSION\t\t, \"Error in VOC file, bad version number.\" },\n\t{\tSFE_VOC_BAD_MARKER\t\t, \"Error in VOC file, bad marker in file.\" },\n\t{\tSFE_VOC_BAD_SECTIONS\t, \"Error in VOC file, incompatible VOC sections.\" },\n\t{\tSFE_VOC_MULTI_SAMPLERATE, \"Error in VOC file, more than one sample rate defined.\" },\n\t{\tSFE_VOC_MULTI_SECTION\t, \"Unimplemented VOC file feature, file contains multiple sound sections.\" },\n\t{\tSFE_VOC_MULTI_PARAM\t\t, \"Error in VOC file, file contains multiple bit or channel widths.\" },\n\t{\tSFE_VOC_SECTION_COUNT\t, \"Error in VOC file, too many sections.\" },\n\t{\tSFE_VOC_NO_PIPE\t\t\t, \"Error : not able to operate on VOC files over a pipe.\" },\n\n\t{\tSFE_IRCAM_NO_MARKER\t\t, \"Error in IRCAM file, bad IRCAM marker.\" },\n\t{\tSFE_IRCAM_BAD_CHANNELS\t, \"Error in IRCAM file, bad channel count.\" },\n\t{\tSFE_IRCAM_UNKNOWN_FORMAT, \"Error in IRCAM file, unknown encoding format.\" },\n\n\t{\tSFE_W64_64_BIT\t\t\t, \"Error in W64 file, file contains 64 bit offset.\" },\n\t{\tSFE_W64_NO_RIFF\t\t\t, \"Error in W64 file. No 'riff' chunk marker.\" },\n\t{\tSFE_W64_NO_WAVE\t\t\t, \"Error in W64 file. No 'wave' chunk marker.\" },\n\t{\tSFE_W64_NO_DATA\t\t\t, \"Error in W64 file. No 'data' chunk marker.\" },\n\t{\tSFE_W64_ADPCM_NOT4BIT\t, \"Error in ADPCM W64 file. Invalid bit width.\" },\n\t{\tSFE_W64_ADPCM_CHANNELS\t, \"Error in ADPCM W64 file. Invalid number of channels.\" },\n\t{\tSFE_W64_GSM610_FORMAT\t, \"Error in GSM610 W64 file. Invalid format chunk.\" },\n\n\t{\tSFE_MAT4_BAD_NAME\t\t, \"Error in MAT4 file. No variable name.\" },\n\t{\tSFE_MAT4_NO_SAMPLERATE\t, \"Error in MAT4 file. No sample rate.\" },\n\n\t{\tSFE_MAT5_BAD_ENDIAN\t\t, \"Error in MAT5 file. Not able to determine endian-ness.\" },\n\t{\tSFE_MAT5_NO_BLOCK\t\t, \"Error in MAT5 file. Bad block structure.\" },\n\t{\tSFE_MAT5_SAMPLE_RATE\t, \"Error in MAT5 file. Not able to determine sample rate.\" },\n\n\t{\tSFE_PVF_NO_PVF1\t\t\t, \"Error in PVF file. No PVF1 marker.\" },\n\t{\tSFE_PVF_BAD_HEADER\t\t, \"Error in PVF file. Bad header.\" },\n\t{\tSFE_PVF_BAD_BITWIDTH\t, \"Error in PVF file. Bad bit width.\" },\n\n\t{\tSFE_XI_BAD_HEADER\t\t, \"Error in XI file. Bad header.\" },\n\t{\tSFE_XI_EXCESS_SAMPLES\t, \"Error in XI file. Excess samples in file.\" },\n\t{\tSFE_XI_NO_PIPE\t\t\t, \"Error : not able to operate on XI files over a pipe.\" },\n\n\t{\tSFE_HTK_NO_PIPE\t\t\t, \"Error : not able to operate on HTK files over a pipe.\" },\n\n\t{\tSFE_SDS_NOT_SDS\t\t\t, \"Error : not an SDS file.\" },\n\t{\tSFE_SDS_BAD_BIT_WIDTH\t, \"Error : bad bit width for SDS file.\" },\n\n\t{\tSFE_SD2_FD_DISALLOWED\t, \"Error : cannot open SD2 file without a file name.\" },\n\t{\tSFE_SD2_BAD_DATA_OFFSET\t, \"Error : bad data offset.\" },\n\t{\tSFE_SD2_BAD_MAP_OFFSET\t, \"Error : bad map offset.\" },\n\t{\tSFE_SD2_BAD_DATA_LENGTH\t, \"Error : bad data length.\" },\n\t{\tSFE_SD2_BAD_MAP_LENGTH\t, \"Error : bad map length.\" },\n\t{\tSFE_SD2_BAD_RSRC\t\t, \"Error : bad resource fork.\" },\n\t{\tSFE_SD2_BAD_SAMPLE_SIZE\t, \"Error : bad sample size.\" },\n\n\t{\tSFE_FLAC_BAD_HEADER\t\t, \"Error : bad flac header.\" },\n\t{\tSFE_FLAC_NEW_DECODER\t, \"Error : problem while creating flac decoder.\" },\n\t{\tSFE_FLAC_INIT_DECODER\t, \"Error : problem while initialization of the flac decoder.\" },\n\t{\tSFE_FLAC_LOST_SYNC\t\t, \"Error : flac decoder lost sync.\" },\n\t{\tSFE_FLAC_BAD_SAMPLE_RATE, \"Error : flac does not support this sample rate.\" },\n\t{\tSFE_FLAC_UNKOWN_ERROR\t, \"Error : unknown error in flac decoder.\" },\n\n\t{\tSFE_WVE_NOT_WVE\t\t\t, \"Error : not a WVE file.\" },\n\t{\tSFE_WVE_NO_PIPE\t\t\t, \"Error : not able to operate on WVE files over a pipe.\" },\n\n\t{\tSFE_DWVW_BAD_BITWIDTH\t, \"Error : Bad bit width for DWVW encoding. Must be 12, 16 or 24.\" },\n\t{\tSFE_G72X_NOT_MONO\t\t, \"Error : G72x encoding does not support more than 1 channel.\" },\n\n\t{\tSFE_VORBIS_ENCODER_BUG\t, \"Error : Sample rate chosen is known to trigger a Vorbis encoder bug on this CPU.\" },\n\n\t{\tSFE_RF64_NOT_RF64\t\t, \"Error : Not an RF64 file.\" },\n\t{\tSFE_RF64_PEAK_B4_FMT\t, \"Error in RF64 file. 'PEAK' chunk found before 'fmt ' chunk.\" },\n\t{\tSFE_RF64_NO_DATA\t\t, \"Error in RF64 file. No 'data' chunk marker.\" },\n\n\t{\tSFE_ALAC_FAIL_TMPFILE\t, \"Error : Failed to open tmp file for ALAC encoding.\" },\n\n\t{\tSFE_BAD_CHUNK_PTR\t\t, \"Error : Bad SF_CHUNK_INFO pointer.\" },\n\t{\tSFE_UNKNOWN_CHUNK\t\t, \"Error : Unknown chunk marker.\" },\n\t{\tSFE_BAD_CHUNK_FORMAT\t, \"Error : Reading/writing chunks from this file format is not supported.\" },\n\t{\tSFE_BAD_CHUNK_MARKER\t, \"Error : Bad chunk marker.\" },\n\t{\tSFE_BAD_CHUNK_DATA_PTR\t, \"Error : Bad data pointer in SF_CHUNK_INFO struct.\" },\n\t{\tSFE_FILENAME_TOO_LONG\t, \"Error : Supplied filename too long.\" },\n\n\n\t{\tSFE_MAX_ERROR\t\t\t, \"Maximum error number.\" },\n\t{\tSFE_MAX_ERROR + 1\t\t, NULL }\n} ;\n\n/*------------------------------------------------------------------------------\n*/\n\nstatic int \tformat_from_extension (SF_PRIVATE *psf) ;\nstatic int\tguess_file_type (SF_PRIVATE *psf) ;\nstatic int\tvalidate_sfinfo (SF_INFO *sfinfo) ;\nstatic int\tvalidate_psf (SF_PRIVATE *psf) ;\nstatic void\tsave_header_info (SF_PRIVATE *psf) ;\nstatic int\tcopy_filename (SF_PRIVATE *psf, const char *path) ;\nstatic int\tpsf_close (SF_PRIVATE *psf) ;\n\nstatic int\ttry_resource_fork (SF_PRIVATE * psf) ;\n\n/*------------------------------------------------------------------------------\n** Private (static) variables.\n*/\n\nint\tsf_errno = 0 ;\nstatic char\tsf_parselog [SF_BUFFER_LEN] = { 0 } ;\nstatic char\tsf_syserr [SF_SYSERR_LEN] = { 0 } ;\n\n/*------------------------------------------------------------------------------\n*/\n\n#define\tVALIDATE_SNDFILE_AND_ASSIGN_PSF(a, b, c)\t\\\n\t\t{\tif ((a) == NULL)\t\t\t\t\t\t\\\n\t\t\t{\tsf_errno = SFE_BAD_SNDFILE_PTR ;\t\\\n\t\t\t\treturn 0 ;\t\t\t\t\t\t\t\\\n\t\t\t\t} ;\t\t\t\t\t\t\t\t\t\\\n\t\t\t(b) = (SF_PRIVATE*) (a) ;\t\t\t\t\\\n\t\t\tif ((b)->virtual_io == SF_FALSE &&\t\t\\\n\t\t\t\tpsf_file_valid (b) == 0)\t\t\t\\\n\t\t\t{\t(b)->error = SFE_BAD_FILE_PTR ;\t\t\\\n\t\t\t\treturn 0 ;\t\t\t\t\t\t\t\\\n\t\t\t\t} ;\t\t\t\t\t\t\t\t\t\\\n\t\t\tif ((b)->Magick != SNDFILE_MAGICK)\t\t\\\n\t\t\t{\t(b)->error = SFE_BAD_SNDFILE_PTR ;\t\\\n\t\t\t\treturn 0 ;\t\t\t\t\t\t\t\\\n\t\t\t\t} ;\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (c) (b)->error = 0 ;\t\t\t\t\t\\\n\t\t\t}\n\n/*------------------------------------------------------------------------------\n**\tPublic functions.\n*/\n\nSNDFILE*\nsf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\n\t/* Ultimate sanity check. */\n\tassert (sizeof (sf_count_t) == 8) ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf_log_printf (psf, \"File : %s\\n\", path) ;\n\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf->error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf->file.mode = mode ;\n\tif (strcmp (path, \"-\") == 0)\n\t\tpsf->error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf->error = psf_fopen (psf) ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open */\n\nSNDFILE*\nsf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\tpsf->fileoffset = psf_ftell (psf) ;\n\n\tif (! close_desc)\n\t\tpsf->file.do_not_close_descriptor = SF_TRUE ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open_fd */\n\nSNDFILE*\nsf_open_virtual\t(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)\n{\tSF_PRIVATE \t*psf ;\n\n\t/* Make sure we have a valid set ot virtual pointers. */\n\tif (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\n\tif ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_read in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\n\tif ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_write in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf->virtual_io = SF_TRUE ;\n\tpsf->vio = *sfvirtual ;\n\tpsf->vio_user_data = user_data ;\n\n\tpsf->file.mode = mode ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open_virtual */\n\nint\nsf_close\t(SNDFILE *sndfile)\n{\tSF_PRIVATE\t*psf ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\treturn psf_close (psf) ;\n} /* sf_close */\n\nvoid\nsf_write_sync\t(SNDFILE *sndfile)\n{\tSF_PRIVATE\t*psf ;\n\n\tif ((psf = (SF_PRIVATE *) sndfile) == NULL)\n\t\treturn ;\n\n\tpsf_fsync (psf) ;\n\n\treturn ;\n} /* sf_write_sync */\n\n/*==============================================================================\n*/\n\nconst char*\nsf_error_number\t(int errnum)\n{\tstatic const char *bad_errnum =\n\t\t\"No error defined for this error number. This is a bug in libsndfile.\" ;\n\tint\tk ;\n\n\tif (errnum == SFE_MAX_ERROR)\n\t\treturn SndfileErrors [0].str ;\n\n\tif (errnum < 0 || errnum > SFE_MAX_ERROR)\n\t{\t/* This really shouldn't happen in release versions. */\n\t\tprintf (\"Not a valid error number (%d).\\n\", errnum) ;\n\t\treturn bad_errnum ;\n\t\t} ;\n\n\tfor (k = 0 ; SndfileErrors [k].str ; k++)\n\t\tif (errnum == SndfileErrors [k].error)\n\t\t\treturn SndfileErrors [k].str ;\n\n\treturn bad_errnum ;\n} /* sf_error_number */\n\nconst char*\nsf_strerror (SNDFILE *sndfile)\n{\tSF_PRIVATE \t*psf = NULL ;\n\tint errnum ;\n\n\tif (sndfile == NULL)\n\t{\terrnum = sf_errno ;\n\t\tif (errnum == SFE_SYSTEM && sf_syserr [0])\n\t\t\treturn sf_syserr ;\n\t\t}\n\telse\n\t{\tpsf = (SF_PRIVATE *) sndfile ;\n\n\t\tif (psf->Magick != SNDFILE_MAGICK)\n\t\t\treturn\t\"sf_strerror : Bad magic number.\" ;\n\n\t\terrnum = psf->error ;\n\n\t\tif (errnum == SFE_SYSTEM && psf->syserr [0])\n\t\t\treturn psf->syserr ;\n\t\t} ;\n\n\treturn sf_error_number (errnum) ;\n} /* sf_strerror */\n\n/*------------------------------------------------------------------------------\n*/\n\nint\nsf_error (SNDFILE *sndfile)\n{\tSF_PRIVATE\t*psf ;\n\n\tif (sndfile == NULL)\n\t\treturn sf_errno ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 0) ;\n\n\tif (psf->error)\n\t\treturn psf->error ;\n\n\treturn 0 ;\n} /* sf_error */\n\n/*------------------------------------------------------------------------------\n*/\n\nint\nsf_perror (SNDFILE *sndfile)\n{\tSF_PRIVATE \t*psf ;\n\tint \t\terrnum ;\n\n\tif (sndfile == NULL)\n\t{\terrnum = sf_errno ;\n\t\t}\n\telse\n\t{\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 0) ;\n\t\terrnum = psf->error ;\n\t\t} ;\n\n\tfprintf (stderr, \"%s\\n\", sf_error_number (errnum)) ;\n\treturn SFE_NO_ERROR ;\n} /* sf_perror */\n\n\n/*------------------------------------------------------------------------------\n*/\n\nint\nsf_error_str (SNDFILE *sndfile, char *str, size_t maxlen)\n{\tSF_PRIVATE \t*psf ;\n\tint \t\terrnum ;\n\n\tif (str == NULL)\n\t\treturn SFE_INTERNAL ;\n\n\tif (sndfile == NULL)\n\t\terrnum = sf_errno ;\n\telse\n\t{\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 0) ;\n\t\terrnum = psf->error ;\n\t\t} ;\n\n\tsnprintf (str, maxlen, \"%s\", sf_error_number (errnum)) ;\n\n\treturn SFE_NO_ERROR ;\n} /* sf_error_str */\n\n/*==============================================================================\n*/\n\nint\nsf_format_check\t(const SF_INFO *info)\n{\tint\tsubformat, endian ;\n\n\tsubformat = SF_CODEC (info->format) ;\n\tendian = SF_ENDIAN (info->format) ;\n\n\t/* This is the place where each file format can check if the suppiled\n\t** SF_INFO struct is valid.\n\t** Return 0 on failure, 1 ons success.\n\t*/\n\n\tif (info->channels < 1 || info->channels > SF_MAX_CHANNELS)\n\t\treturn 0 ;\n\n\tif (info->samplerate < 0)\n\t\treturn 0 ;\n\n\tswitch (SF_CONTAINER (info->format))\n\t{\tcase SF_FORMAT_WAV :\n\t\t\t\t/* WAV now allows both endian, RIFF or RIFX (little or big respectively) */\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif ((subformat == SF_FORMAT_IMA_ADPCM || subformat == SF_FORMAT_MS_ADPCM) && info->channels <= 2)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_GSM610 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_G721_32 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_WAVEX :\n\t\t\t\tif (endian == SF_ENDIAN_BIG || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_AIFF :\n\t\t\t\t/* AIFF does allow both endian-nesses for PCM data.*/\n\t\t\t\tif (subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\t/* For other encodings reject any endian-ness setting. */\n\t\t\t\tif (endian != 0)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_S8)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif ((subformat == SF_FORMAT_DWVW_12 || subformat == SF_FORMAT_DWVW_16 ||\n\t\t\t\t\t\t\tsubformat == SF_FORMAT_DWVW_24) && info-> channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_GSM610 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_IMA_ADPCM && (info->channels == 1 || info->channels == 2))\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_AU :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_G721_32 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_G723_24 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_G723_40 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_CAF :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ALAC_16 || subformat == SF_FORMAT_ALAC_20)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ALAC_24 || subformat == SF_FORMAT_ALAC_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_RAW :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ALAW || subformat == SF_FORMAT_ULAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif ((subformat == SF_FORMAT_DWVW_12 || subformat == SF_FORMAT_DWVW_16 ||\n\t\t\t\t\t\t\tsubformat == SF_FORMAT_DWVW_24) && info-> channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_GSM610 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_VOX_ADPCM && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PAF :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_24)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_SVX :\n\t\t\t\t/* SVX only supports writing mono SVX files. */\n\t\t\t\tif (info->channels > 1)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* Always big endian. */\n\t\t\t\tif (endian == SF_ENDIAN_LITTLE || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_NIST :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_IRCAM :\n\t\t\t\tif (info->channels > 256)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW || subformat == SF_FORMAT_FLOAT)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_VOC :\n\t\t\t\tif (info->channels > 2)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* VOC is strictly little endian. */\n\t\t\t\tif (endian == SF_ENDIAN_BIG || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_W64 :\n\t\t\t\t/* W64 is strictly little endian. */\n\t\t\t\tif (endian == SF_ENDIAN_BIG || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif ((subformat == SF_FORMAT_IMA_ADPCM || subformat == SF_FORMAT_MS_ADPCM) && info->channels <= 2)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_GSM610 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_MAT4 :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_MAT5 :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PVF :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_XI :\n\t\t\t\tif (info->channels != 1)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_DPCM_8 || subformat == SF_FORMAT_DPCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_HTK :\n\t\t\t\tif (info->channels != 1)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* HTK is strictly big endian. */\n\t\t\t\tif (endian == SF_ENDIAN_LITTLE || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_SDS :\n\t\t\t\tif (info->channels != 1)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* SDS is strictly big endian. */\n\t\t\t\tif (endian == SF_ENDIAN_LITTLE || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_24)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_AVR :\n\t\t\t\tif (info->channels > 2)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* SDS is strictly big endian. */\n\t\t\t\tif (endian == SF_ENDIAN_LITTLE || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_FLAC :\n\t\t\t\t/* FLAC can't do more than 8 channels. */\n\t\t\t\tif (info->channels > 8)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (endian != SF_ENDIAN_FILE)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_24)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_SD2 :\n\t\t\t\t/* SD2 is strictly big endian. */\n\t\t\t\tif (endian == SF_ENDIAN_LITTLE || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_WVE :\n\t\t\t\tif (info->channels > 1)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* WVE is strictly big endian. */\n\t\t\t\tif (endian == SF_ENDIAN_BIG || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_OGG :\n\t\t\t\tif (endian != SF_ENDIAN_FILE)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_VORBIS)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_MPC2K :\n\t\t\t\tif (info->channels > 2)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* MPC2000 is strictly little endian. */\n\t\t\t\tif (endian == SF_ENDIAN_BIG || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_RF64 :\n\t\t\t\tif (endian == SF_ENDIAN_BIG || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\t\tdefault : break ;\n\t\t} ;\n\n\treturn 0 ;\n} /* sf_format_check */\n\n/*------------------------------------------------------------------------------\n*/\n\nconst char *\nsf_version_string (void)\n{\n#if\tENABLE_EXPERIMENTAL_CODE\n\treturn PACKAGE_NAME \"-\" PACKAGE_VERSION \"-exp\" ;\n#else\n\treturn PACKAGE_NAME \"-\" PACKAGE_VERSION ;\n#endif\n}\n\n\n/*------------------------------------------------------------------------------\n*/\n\nint\nsf_command\t(SNDFILE *sndfile, int command, void *data, int datasize)\n{\tSF_PRIVATE *psf = (SF_PRIVATE *) sndfile ;\n\tdouble quality ;\n\tint old_value ;\n\n\t/* This set of commands do not need the sndfile parameter. */\n\tswitch (command)\n\t{\tcase SFC_GET_LIB_VERSION :\n\t\t\tif (data == NULL)\n\t\t\t{\tif (psf)\n\t\t\t\t\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SFE_BAD_COMMAND_PARAM ;\n\t\t\t\t} ;\n\t\t\tsnprintf (data, datasize, \"%s\", sf_version_string ()) ;\n\t\t\treturn strlen (data) ;\n\n\t\tcase SFC_GET_SIMPLE_FORMAT_COUNT :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (int))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\t*((int*) data) = psf_get_format_simple_count () ;\n\t\t\treturn 0 ;\n\n\t\tcase SFC_GET_SIMPLE_FORMAT :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_FORMAT_INFO))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\treturn psf_get_format_simple (data) ;\n\n\t\tcase SFC_GET_FORMAT_MAJOR_COUNT :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (int))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\t*((int*) data) = psf_get_format_major_count () ;\n\t\t\treturn 0 ;\n\n\t\tcase SFC_GET_FORMAT_MAJOR :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_FORMAT_INFO))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\treturn psf_get_format_major (data) ;\n\n\t\tcase SFC_GET_FORMAT_SUBTYPE_COUNT :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (int))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\t*((int*) data) = psf_get_format_subtype_count () ;\n\t\t\treturn 0 ;\n\n\t\tcase SFC_GET_FORMAT_SUBTYPE :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_FORMAT_INFO))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\treturn psf_get_format_subtype (data) ;\n\n\t\tcase SFC_GET_FORMAT_INFO :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_FORMAT_INFO))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\treturn psf_get_format_info (data) ;\n\t\t} ;\n\n\tif (sndfile == NULL && command == SFC_GET_LOG_INFO)\n\t{\tif (data == NULL)\n\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\tsnprintf (data, datasize, \"%s\", sf_parselog) ;\n\t\treturn strlen (data) ;\n\t\t} ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tswitch (command)\n\t{\tcase SFC_SET_NORM_FLOAT :\n\t\t\told_value = psf->norm_float ;\n\t\t\tpsf->norm_float = (datasize) ? SF_TRUE : SF_FALSE ;\n\t\t\treturn old_value ;\n\n\t\tcase SFC_GET_CURRENT_SF_INFO :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_INFO))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\tmemcpy (data, &psf->sf, sizeof (SF_INFO)) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_SET_NORM_DOUBLE :\n\t\t\told_value = psf->norm_double ;\n\t\t\tpsf->norm_double = (datasize) ? SF_TRUE : SF_FALSE ;\n\t\t\treturn old_value ;\n\n\t\tcase SFC_GET_NORM_FLOAT :\n\t\t\treturn psf->norm_float ;\n\n\t\tcase SFC_GET_NORM_DOUBLE :\n\t\t\treturn psf->norm_double ;\n\n\t\tcase SFC_SET_SCALE_FLOAT_INT_READ :\n\t\t\told_value = psf->float_int_mult ;\n\n\t\t\tpsf->float_int_mult = (datasize != 0) ? SF_TRUE : SF_FALSE ;\n\t\t\tif (psf->float_int_mult && psf->float_max < 0.0)\n\t\t\t\t/* Scale to prevent wrap-around distortion. */\n\t\t\t\tpsf->float_max = (32768.0 / 32767.0) * psf_calc_signal_max (psf, SF_FALSE) ;\n\t\t\treturn old_value ;\n\n\t\tcase SFC_SET_SCALE_INT_FLOAT_WRITE :\n\t\t\told_value = psf->scale_int_float ;\n\t\t\tpsf->scale_int_float = (datasize != 0) ? SF_TRUE : SF_FALSE ;\n\t\t\treturn old_value ;\n\n\t\tcase SFC_SET_ADD_PEAK_CHUNK :\n\t\t\t{\tint format = SF_CONTAINER (psf->sf.format) ;\n\n\t\t\t\t/* Only WAV and AIFF support the PEAK chunk. */\n\t\t\t\tswitch (format)\n\t\t\t\t{\tcase SF_FORMAT_AIFF :\n\t\t\t\t\tcase SF_FORMAT_CAF :\n\t\t\t\t\tcase SF_FORMAT_WAV :\n\t\t\t\t\tcase SF_FORMAT_WAVEX :\n\t\t\t\t\tcase SF_FORMAT_RF64 :\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tdefault :\n\t\t\t\t\t\treturn SF_FALSE ;\n\t\t\t\t\t} ;\n\n\t\t\t\tformat = SF_CODEC (psf->sf.format) ;\n\n\t\t\t\t/* Only files containg the following data types support the PEAK chunk. */\n\t\t\t\tif (format != SF_FORMAT_FLOAT && format != SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn SF_FALSE ;\n\n\t\t\t\t} ;\n\t\t\t/* Can only do this is in SFM_WRITE mode. */\n\t\t\tif (psf->file.mode != SFM_WRITE && psf->file.mode != SFM_RDWR)\n\t\t\t\treturn SF_FALSE ;\n\t\t\t/* If data has already been written this must fail. */\n\t\t\tif (psf->have_written)\n\t\t\t{\tpsf->error = SFE_CMD_HAS_DATA ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\t/* Everything seems OK, so set psf->has_peak and re-write header. */\n\t\t\tif (datasize == SF_FALSE && psf->peak_info != NULL)\n\t\t\t{\tfree (psf->peak_info) ;\n\t\t\t\tpsf->peak_info = NULL ;\n\t\t\t\t}\n\t\t\telse if (psf->peak_info == NULL)\n\t\t\t{\tpsf->peak_info = peak_info_calloc (psf->sf.channels) ;\n\t\t\t\tif (psf->peak_info != NULL)\n\t\t\t\t\tpsf->peak_info->peak_loc = SF_PEAK_START ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->write_header)\n\t\t\t\tpsf->write_header (psf, SF_TRUE) ;\n\t\t\treturn datasize ;\n\n\t\tcase SFC_SET_ADD_HEADER_PAD_CHUNK :\n\t\t\treturn SF_FALSE ;\n\n\t\tcase SFC_GET_LOG_INFO :\n\t\t\tif (data == NULL)\n\t\t\t\treturn SFE_BAD_COMMAND_PARAM ;\n\t\t\tsnprintf (data, datasize, \"%s\", psf->parselog.buf) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_CALC_SIGNAL_MAX :\n\t\t\tif (data == NULL || datasize != sizeof (double))\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\t*((double*) data) = psf_calc_signal_max (psf, SF_FALSE) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_CALC_NORM_SIGNAL_MAX :\n\t\t\tif (data == NULL || datasize != sizeof (double))\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\t*((double*) data) = psf_calc_signal_max (psf, SF_TRUE) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_CALC_MAX_ALL_CHANNELS :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (double) * psf->sf.channels)\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\treturn psf_calc_max_all_channels (psf, (double*) data, SF_FALSE) ;\n\n\t\tcase SFC_CALC_NORM_MAX_ALL_CHANNELS :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (double) * psf->sf.channels)\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\treturn psf_calc_max_all_channels (psf, (double*) data, SF_TRUE) ;\n\n\t\tcase SFC_GET_SIGNAL_MAX :\n\t\t\tif (data == NULL || datasize != sizeof (double))\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\treturn psf_get_signal_max (psf, (double *) data) ;\n\n\t\tcase SFC_GET_MAX_ALL_CHANNELS :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (double) * psf->sf.channels)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\treturn psf_get_max_all_channels (psf, (double*) data) ;\n\n\t\tcase SFC_UPDATE_HEADER_NOW :\n\t\t\tif (psf->write_header)\n\t\t\t\tpsf->write_header (psf, SF_TRUE) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_SET_UPDATE_HEADER_AUTO :\n\t\t\tpsf->auto_header = datasize ? SF_TRUE : SF_FALSE ;\n\t\t\treturn psf->auto_header ;\n\t\t\tbreak ;\n\n\t\tcase SFC_SET_ADD_DITHER_ON_WRITE :\n\t\tcase SFC_SET_ADD_DITHER_ON_READ :\n\t\t\t/*\n\t\t\t** FIXME !\n\t\t\t** These are obsolete. Just return.\n\t\t\t** Remove some time after version 1.0.8.\n\t\t\t*/\n\t\t\tbreak ;\n\n\t\tcase SFC_SET_DITHER_ON_WRITE :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_DITHER_INFO))\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\tmemcpy (&psf->write_dither, data, sizeof (psf->write_dither)) ;\n\t\t\tif (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t\t\t\tdither_init (psf, SFM_WRITE) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_SET_DITHER_ON_READ :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_DITHER_INFO))\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\tmemcpy (&psf->read_dither, data, sizeof (psf->read_dither)) ;\n\t\t\tif (psf->file.mode == SFM_READ || psf->file.mode == SFM_RDWR)\n\t\t\t\tdither_init (psf, SFM_READ) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_FILE_TRUNCATE :\n\t\t\tif (psf->file.mode != SFM_WRITE && psf->file.mode != SFM_RDWR)\n\t\t\t\treturn SF_TRUE ;\n\t\t\tif (datasize != sizeof (sf_count_t))\n\t\t\t\treturn SF_TRUE ;\n\t\t\tif (data == NULL || datasize != sizeof (sf_count_t))\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t}\n\t\t\telse\n\t\t\t{\tsf_count_t position ;\n\n\t\t\t\tposition = *((sf_count_t*) data) ;\n\n\t\t\t\tif (sf_seek (sndfile, position, SEEK_SET) != position)\n\t\t\t\t\treturn SF_TRUE ;\n\n\t\t\t\tpsf->sf.frames = position ;\n\n\t\t\t\tposition = psf_fseek (psf, 0, SEEK_CUR) ;\n\n\t\t\t\treturn psf_ftruncate (psf, position) ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tcase SFC_SET_RAW_START_OFFSET :\n\t\t\tif (data == NULL || datasize != sizeof (sf_count_t))\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\n\t\t\tif ((SF_CONTAINER (psf->sf.format)) != SF_FORMAT_RAW)\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\n\t\t\tpsf->dataoffset = *((sf_count_t*) data) ;\n\t\t\tsf_seek (sndfile, 0, SEEK_CUR) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_GET_EMBED_FILE_INFO :\n\t\t\tif (data == NULL || datasize != sizeof (SF_EMBED_FILE_INFO))\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\n\t\t\t((SF_EMBED_FILE_INFO*) data)->offset = psf->fileoffset ;\n\t\t\t((SF_EMBED_FILE_INFO*) data)->length = psf->filelength ;\n\t\t\tbreak ;\n\n\t\t/* Lite remove start */\n\t\tcase SFC_TEST_IEEE_FLOAT_REPLACE :\n\t\t\tpsf->ieee_replace = (datasize) ? SF_TRUE : SF_FALSE ;\n\t\t\tif ((SF_CODEC (psf->sf.format)) == SF_FORMAT_FLOAT)\n\t\t\t\tfloat32_init (psf) ;\n\t\t\telse if ((SF_CODEC (psf->sf.format)) == SF_FORMAT_DOUBLE)\n\t\t\t\tdouble64_init (psf) ;\n\t\t\telse\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\tbreak ;\n\t\t/* Lite remove end */\n\n\t\tcase SFC_SET_CLIPPING :\n\t\t\tpsf->add_clipping = (datasize) ? SF_TRUE : SF_FALSE ;\n\t\t\treturn psf->add_clipping ;\n\n\t\tcase SFC_GET_CLIPPING :\n\t\t\treturn psf->add_clipping ;\n\n\t\tcase SFC_GET_LOOP_INFO :\n\t\t\tif (datasize != sizeof (SF_LOOP_INFO) || data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (psf->loop_info == NULL)\n\t\t\t\treturn SF_FALSE ;\n\t\t\tmemcpy (data, psf->loop_info, sizeof (SF_LOOP_INFO)) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_SET_BROADCAST_INFO :\n\t\t\t{\tint format = SF_CONTAINER (psf->sf.format) ;\n\n\t\t\t\t/* Only WAV and RF64 supports the BEXT (Broadcast) chunk. */\n\t\t\t\tif (format != SF_FORMAT_WAV && format != SF_FORMAT_WAVEX && format != SF_FORMAT_RF64)\n\t\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\t/* Only makes sense in SFM_WRITE or SFM_RDWR mode. */\n\t\t\tif ((psf->file.mode != SFM_WRITE) && (psf->file.mode != SFM_RDWR))\n\t\t\t\treturn SF_FALSE ;\n\t\t\t/* If data has already been written this must fail. */\n\t\t\tif (psf->broadcast_16k == NULL && psf->have_written)\n\t\t\t{\tpsf->error = SFE_CMD_HAS_DATA ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\tif (NOT (broadcast_var_set (psf, data, datasize)))\n\t\t\t\treturn SF_FALSE ;\n\n\t\t\tif (psf->write_header)\n\t\t\t\tpsf->write_header (psf, SF_TRUE) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_GET_BROADCAST_INFO :\n\t\t\tif (data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\treturn broadcast_var_get (psf, data, datasize) ;\n\n\t\tcase SFC_SET_CART_INFO :\n\t\t\t{\tint format = SF_CONTAINER (psf->sf.format) ;\n\t\t\t\t/* Only WAV and RF64 support cart chunk format */\n\t\t\t\tif (format != SF_FORMAT_WAV && format != SF_FORMAT_RF64)\n\t\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\t/* Only makes sense in SFM_WRITE or SFM_RDWR mode */\n\t\t\tif ((psf->file.mode != SFM_WRITE) && (psf->file.mode != SFM_RDWR))\n\t\t\t\treturn SF_FALSE ;\n\t\t\t/* If data has already been written this must fail. */\n\t\t\tif (psf->cart_16k == NULL && psf->have_written)\n\t\t\t{\tpsf->error = SFE_CMD_HAS_DATA ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (NOT (cart_var_set (psf, data, datasize)))\n\t\t\t\treturn SF_FALSE ;\n\t\t\tif (psf->write_header)\n\t\t\t\tpsf->write_header (psf, SF_TRUE) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_GET_CART_INFO :\n\t\t\tif (data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\treturn cart_var_get (psf, data, datasize) ;\n\n\t\tcase SFC_GET_CUE_COUNT :\n\t\t\tif (datasize != sizeof (uint32_t) || data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (psf->cues != NULL)\n\t\t\t{\t*((uint32_t *) data) = psf->cues->cue_count ;\n\t\t\t\treturn SF_TRUE ;\n\t\t\t\t} ;\n\t\t\treturn SF_FALSE ;\n\n\t\tcase SFC_GET_CUE :\n\t\t\tif (datasize != sizeof (SF_CUES) || data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (psf->cues == NULL)\n\t\t\t\treturn SF_FALSE ;\n\t\t\tpsf_get_cues (psf, data, datasize) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_SET_CUE :\n\t\t\tif (psf->have_written)\n\t\t\t{\tpsf->error = SFE_CMD_HAS_DATA ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (datasize != sizeof (SF_CUES) || data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->cues == NULL && (psf->cues = psf_cues_dup (data)) == NULL)\n\t\t\t{\tpsf->error = SFE_MALLOC_FAILED ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_GET_INSTRUMENT :\n\t\t\tif (datasize != sizeof (SF_INSTRUMENT) || data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (psf->instrument == NULL)\n\t\t\t\treturn SF_FALSE ;\n\t\t\tmemcpy (data, psf->instrument, sizeof (SF_INSTRUMENT)) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_SET_INSTRUMENT :\n\t\t\t/* If data has already been written this must fail. */\n\t\t\tif (psf->have_written)\n\t\t\t{\tpsf->error = SFE_CMD_HAS_DATA ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (datasize != sizeof (SF_INSTRUMENT) || data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->instrument == NULL && (psf->instrument = psf_instrument_alloc ()) == NULL)\n\t\t\t{\tpsf->error = SFE_MALLOC_FAILED ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tmemcpy (psf->instrument, data, sizeof (SF_INSTRUMENT)) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_RAW_DATA_NEEDS_ENDSWAP :\n\t\t\treturn psf->data_endswap ;\n\n\t\tcase SFC_GET_CHANNEL_MAP_INFO :\n\t\t\tif (psf->channel_map == NULL)\n\t\t\t\treturn SF_FALSE ;\n\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (psf->channel_map [0]) * psf->sf.channels)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\tmemcpy (data, psf->channel_map, datasize) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_SET_CHANNEL_MAP_INFO :\n\t\t\tif (psf->have_written)\n\t\t\t{\tpsf->error = SFE_CMD_HAS_DATA ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (psf->channel_map [0]) * psf->sf.channels)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\t{\tint *iptr ;\n\n\t\t\t\tfor (iptr = data ; iptr < (int*) data + psf->sf.channels ; iptr++)\n\t\t\t\t{\tif (*iptr <= SF_CHANNEL_MAP_INVALID || *iptr >= SF_CHANNEL_MAP_MAX)\n\t\t\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\t\t\treturn SF_FALSE ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\n\t\t\tfree (psf->channel_map) ;\n\t\t\tif ((psf->channel_map = malloc (datasize)) == NULL)\n\t\t\t{\tpsf->error = SFE_MALLOC_FAILED ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\tmemcpy (psf->channel_map, data, datasize) ;\n\n\t\t\t/*\n\t\t\t**\tPass the command down to the container's command handler.\n\t\t\t**\tDon't pass user data, use validated psf->channel_map data instead.\n\t\t\t*/\n\t\t\tif (psf->command)\n\t\t\t\treturn psf->command (psf, command, NULL, 0) ;\n\t\t\treturn SF_FALSE ;\n\n\t\tcase SFC_SET_VBR_ENCODING_QUALITY :\n\t\t\tif (data == NULL || datasize != sizeof (double))\n\t\t\t\treturn SF_FALSE ;\n\n\t\t\tquality = *((double *) data) ;\n\t\t\tquality = 1.0 - SF_MAX (0.0, SF_MIN (1.0, quality)) ;\n\t\t\treturn sf_command (sndfile, SFC_SET_COMPRESSION_LEVEL, &quality, sizeof (quality)) ;\n\n\n\t\tdefault :\n\t\t\t/* Must be a file specific command. Pass it on. */\n\t\t\tif (psf->command)\n\t\t\t\treturn psf->command (psf, command, data, datasize) ;\n\n\t\t\tpsf_log_printf (psf, \"*** sf_command : cmd = 0x%X\\n\", command) ;\n\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t} ;\n\n\treturn 0 ;\n} /* sf_command */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_seek\t(SNDFILE *sndfile, sf_count_t offset, int whence)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tseek_from_start = 0, retval ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (! psf->sf.seekable)\n\t{\tpsf->error = SFE_NOT_SEEKABLE ;\n\t\treturn\tPSF_SEEK_ERROR ;\n\t\t} ;\n\n\t/* If the whence parameter has a mode ORed in, check to see that\n\t** it makes sense.\n\t*/\n\tif (((whence & SFM_MASK) == SFM_WRITE && psf->file.mode == SFM_READ) ||\n\t\t\t((whence & SFM_MASK) == SFM_READ && psf->file.mode == SFM_WRITE))\n\t{\tpsf->error = SFE_WRONG_SEEK ;\n\t\treturn PSF_SEEK_ERROR ;\n\t\t} ;\n\n\t/* Convert all SEEK_CUR and SEEK_END into seek_from_start to be\n\t** used with SEEK_SET.\n\t*/\n\tswitch (whence)\n\t{\t/* The SEEK_SET behaviour is independant of mode. */\n\t\tcase SEEK_SET :\n\t\tcase SEEK_SET | SFM_READ :\n\t\tcase SEEK_SET | SFM_WRITE :\n\t\tcase SEEK_SET | SFM_RDWR :\n\t\t\t\tseek_from_start = offset ;\n\t\t\t\tbreak ;\n\n\t\t/* The SEEK_CUR is a little more tricky. */\n\t\tcase SEEK_CUR :\n\t\t\t\tif (offset == 0)\n\t\t\t\t{\tif (psf->file.mode == SFM_READ)\n\t\t\t\t\t\treturn psf->read_current ;\n\t\t\t\t\tif (psf->file.mode == SFM_WRITE)\n\t\t\t\t\t\treturn psf->write_current ;\n\t\t\t\t\t} ;\n\t\t\t\tif (psf->file.mode == SFM_READ)\n\t\t\t\t\tseek_from_start = psf->read_current + offset ;\n\t\t\t\telse if (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t\t\t\t\tseek_from_start = psf->write_current + offset ;\n\t\t\t\telse\n\t\t\t\t\tpsf->error = SFE_AMBIGUOUS_SEEK ;\n\t\t\t\tbreak ;\n\n\t\tcase SEEK_CUR | SFM_READ :\n\t\t\t\tif (offset == 0)\n\t\t\t\t\treturn psf->read_current ;\n\t\t\t\tseek_from_start = psf->read_current + offset ;\n\t\t\t\tbreak ;\n\n\t\tcase SEEK_CUR | SFM_WRITE :\n\t\t\t\tif (offset == 0)\n\t\t\t\t\treturn psf->write_current ;\n\t\t\t\tseek_from_start = psf->write_current + offset ;\n\t\t\t\tbreak ;\n\n\t\t/* The SEEK_END */\n\t\tcase SEEK_END :\n\t\tcase SEEK_END | SFM_READ :\n\t\tcase SEEK_END | SFM_WRITE :\n\t\t\t\tseek_from_start = psf->sf.frames + offset ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\tpsf->error = SFE_BAD_SEEK ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tif (psf->error)\n\t\treturn PSF_SEEK_ERROR ;\n\n\tif (psf->file.mode == SFM_RDWR || psf->file.mode == SFM_WRITE)\n\t{\tif (seek_from_start < 0)\n\t\t{\tpsf->error = SFE_BAD_SEEK ;\n\t\t\treturn PSF_SEEK_ERROR ;\n\t\t\t} ;\n\t\t}\n\telse if (seek_from_start < 0 || seek_from_start > psf->sf.frames)\n\t{\tpsf->error = SFE_BAD_SEEK ;\n\t\treturn PSF_SEEK_ERROR ;\n\t\t} ;\n\n\tif (psf->seek)\n\t{\tint new_mode = (whence & SFM_MASK) ? (whence & SFM_MASK) : psf->file.mode ;\n\n\t\tretval = psf->seek (psf, new_mode, seek_from_start) ;\n\n\t\tswitch (new_mode)\n\t\t{\tcase SFM_READ :\n\t\t\t\t\tpsf->read_current = retval ;\n\t\t\t\t\tbreak ;\n\t\t\tcase SFM_WRITE :\n\t\t\t\t\tpsf->write_current = retval ;\n\t\t\t\t\tbreak ;\n\t\t\tcase SFM_RDWR :\n\t\t\t\t\tpsf->read_current = retval ;\n\t\t\t\t\tpsf->write_current = retval ;\n\t\t\t\t\tnew_mode = SFM_READ ;\n\t\t\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tpsf->last_op = new_mode ;\n\n\t\treturn retval ;\n\t\t} ;\n\n\tpsf->error = SFE_AMBIGUOUS_SEEK ;\n\treturn PSF_SEEK_ERROR ;\n} /* sf_seek */\n\n/*------------------------------------------------------------------------------\n*/\n\nconst char*\nsf_get_string (SNDFILE *sndfile, int str_type)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((psf = (SF_PRIVATE*) sndfile) == NULL)\n\t\treturn NULL ;\n\tif (psf->Magick != SNDFILE_MAGICK)\n\t\treturn NULL ;\n\n\treturn psf_get_string (psf, str_type) ;\n} /* sf_get_string */\n\nint\nsf_set_string (SNDFILE *sndfile, int str_type, const char* str)\n{\tSF_PRIVATE \t*psf ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\treturn psf_set_string (psf, str_type, str) ;\n} /* sf_get_string */\n\n/*------------------------------------------------------------------------------\n*/\n\nint\nsf_current_byterate (SNDFILE *sndfile)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((psf = (SF_PRIVATE*) sndfile) == NULL)\n\t\treturn -1 ;\n\tif (psf->Magick != SNDFILE_MAGICK)\n\t\treturn -1 ;\n\n\t/* This should cover all PCM and floating point formats. */\n\tif (psf->bytewidth)\n\t\treturn psf->sf.samplerate * psf->sf.channels * psf->bytewidth ;\n\n\tif (psf->byterate)\n\t\treturn psf->byterate (psf) ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_IMA_ADPCM :\n\t\tcase SF_FORMAT_MS_ADPCM :\n\t\tcase SF_FORMAT_VOX_ADPCM :\n\t\t\treturn (psf->sf.samplerate * psf->sf.channels) / 2 ;\n\n\t\tcase SF_FORMAT_GSM610 :\n\t\t\treturn (psf->sf.samplerate * psf->sf.channels * 13000) / 8000 ;\n\n\t\tcase SF_FORMAT_G721_32 :\t/* 32kbs G721 ADPCM encoding. */\n\t\t\treturn (psf->sf.samplerate * psf->sf.channels) / 2 ;\n\n\t\tcase SF_FORMAT_G723_24 :\t/* 24kbs G723 ADPCM encoding. */\n\t\t\treturn (psf->sf.samplerate * psf->sf.channels * 3) / 8 ;\n\n\t\tcase SF_FORMAT_G723_40 :\t/* 40kbs G723 ADPCM encoding. */\n\t\t\treturn (psf->sf.samplerate * psf->sf.channels * 5) / 8 ;\n\n\t\tdefault :\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn -1 ;\n} /* sf_current_byterate */\n\n/*==============================================================================\n*/\n\nsf_count_t\nsf_read_raw\t\t(SNDFILE *sndfile, void *ptr, sf_count_t bytes)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\tint\t\t\tbytewidth, blockwidth ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tbytewidth = (psf->bytewidth > 0) ? psf->bytewidth : 1 ;\n\tblockwidth = (psf->blockwidth > 0) ? psf->blockwidth : 1 ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (bytes < 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, bytes) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (bytes % (psf->sf.channels * bytewidth))\n\t{\tpsf->error = SFE_BAD_READ_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf_fread (ptr, 1, bytes, psf) ;\n\n\tif (psf->read_current + count / blockwidth <= psf->sf.frames)\n\t\tpsf->read_current += count / blockwidth ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * blockwidth ;\n\t\textra = bytes - count ;\n\t\tpsf_memset (((char *) ptr) + count, 0, extra) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count ;\n} /* sf_read_raw */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_read_short\t(SNDFILE *sndfile, short *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_READ_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, len * sizeof (short)) ;\n\t\treturn 0 ; /* End of file. */\n\t\t} ;\n\n\tif (psf->read_short == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_short (psf, ptr, len) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = len - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (short)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count ;\n} /* sf_read_short */\n\nsf_count_t\nsf_readf_short\t\t(SNDFILE *sndfile, short *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (frames <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, frames * psf->sf.channels * sizeof (short)) ;\n\t\treturn 0 ; /* End of file. */\n\t\t} ;\n\n\tif (psf->read_short == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_short (psf, ptr, frames * psf->sf.channels) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = frames * psf->sf.channels - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (short)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_readf_short */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_read_int\t\t(SNDFILE *sndfile, int *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_READ_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, len * sizeof (int)) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->read_int == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_int (psf, ptr, len) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = len - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (int)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count ;\n} /* sf_read_int */\n\nsf_count_t\nsf_readf_int\t(SNDFILE *sndfile, int *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (frames <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, frames * psf->sf.channels * sizeof (int)) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->read_int == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_int (psf, ptr, frames * psf->sf.channels) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = frames * psf->sf.channels - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (int)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_readf_int */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_read_float\t(SNDFILE *sndfile, float *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_READ_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, len * sizeof (float)) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->read_float == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_float (psf, ptr, len) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = len - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (float)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count ;\n} /* sf_read_float */\n\nsf_count_t\nsf_readf_float\t(SNDFILE *sndfile, float *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (frames <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, frames * psf->sf.channels * sizeof (float)) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->read_float == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_float (psf, ptr, frames * psf->sf.channels) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = frames * psf->sf.channels - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (float)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_readf_float */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_read_double\t(SNDFILE *sndfile, double *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_READ_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, len * sizeof (double)) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->read_double == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_double (psf, ptr, len) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = len - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (double)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count ;\n} /* sf_read_double */\n\nsf_count_t\nsf_readf_double\t(SNDFILE *sndfile, double *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (frames <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, frames * psf->sf.channels * sizeof (double)) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->read_double == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_double (psf, ptr, frames * psf->sf.channels) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = frames * psf->sf.channels - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (double)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_readf_double */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_write_raw\t(SNDFILE *sndfile, const void *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\tint\t\t\tbytewidth, blockwidth ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tbytewidth = (psf->bytewidth > 0) ? psf->bytewidth : 1 ;\n\tblockwidth = (psf->blockwidth > 0) ? psf->blockwidth : 1 ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % (psf->sf.channels * bytewidth))\n\t{\tpsf->error = SFE_BAD_WRITE_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf_fwrite (ptr, 1, len, psf) ;\n\n\tpsf->write_current += count / blockwidth ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count ;\n} /* sf_write_raw */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_write_short\t(SNDFILE *sndfile, const short *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_WRITE_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_short == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_short (psf, ptr, len) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count ;\n} /* sf_write_short */\n\nsf_count_t\nsf_writef_short\t(SNDFILE *sndfile, const short *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_short == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_short (psf, ptr, frames * psf->sf.channels) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_writef_short */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_write_int\t(SNDFILE *sndfile, const int *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_WRITE_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_int == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_int (psf, ptr, len) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count ;\n} /* sf_write_int */\n\nsf_count_t\nsf_writef_int\t(SNDFILE *sndfile, const int *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_int == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_int (psf, ptr, frames * psf->sf.channels) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_writef_int */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_write_float\t(SNDFILE *sndfile, const float *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_WRITE_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_float == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_float (psf, ptr, len) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count ;\n} /* sf_write_float */\n\nsf_count_t\nsf_writef_float\t(SNDFILE *sndfile, const float *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_float == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_float (psf, ptr, frames * psf->sf.channels) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_writef_float */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_write_double\t(SNDFILE *sndfile, const double *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_WRITE_ALIGN ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->write_double == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_double (psf, ptr, len) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count ;\n} /* sf_write_double */\n\nsf_count_t\nsf_writef_double\t(SNDFILE *sndfile, const double *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_double == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_double (psf, ptr, frames * psf->sf.channels) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_writef_double */\n\n/*=========================================================================\n** Private functions.\n*/\n\nstatic int\ntry_resource_fork (SF_PRIVATE * psf)\n{\tint old_error = psf->error ;\n\n\t/* Set READ mode now, to see if resource fork exists. */\n\tpsf->rsrc.mode = SFM_READ ;\n\tif (psf_open_rsrc (psf) != 0)\n\t{\tpsf->error = old_error ;\n\t\treturn 0 ;\n\t\t} ;\n\n\t/* More checking here. */\n\tpsf_log_printf (psf, \"Resource fork : %s\\n\", psf->rsrc.path.c) ;\n\n\treturn SF_FORMAT_SD2 ;\n} /* try_resource_fork */\n\nstatic int\nformat_from_extension (SF_PRIVATE *psf)\n{\tchar *cptr ;\n\tchar buffer [16] ;\n\tint format = 0 ;\n\n\tif ((cptr = strrchr (psf->file.name.c, '.')) == NULL)\n\t\treturn 0 ;\n\n\tcptr ++ ;\n\tif (strlen (cptr) > sizeof (buffer) - 1)\n\t\treturn 0 ;\n\n\tpsf_strlcpy (buffer, sizeof (buffer), cptr) ;\n\tbuffer [sizeof (buffer) - 1] = 0 ;\n\n\t/* Convert everything in the buffer to lower case. */\n\tcptr = buffer ;\n\twhile (*cptr)\n\t{\t*cptr = tolower (*cptr) ;\n\t\tcptr ++ ;\n\t\t} ;\n\n\tcptr = buffer ;\n\n\tif (strcmp (cptr, \"au\") == 0)\n\t{\tpsf->sf.channels = 1 ;\n\t\tpsf->sf.samplerate = 8000 ;\n\t\tformat = SF_FORMAT_RAW | SF_FORMAT_ULAW ;\n\t\t}\n\telse if (strcmp (cptr, \"snd\") == 0)\n\t{\tpsf->sf.channels = 1 ;\n\t\tpsf->sf.samplerate = 8000 ;\n\t\tformat = SF_FORMAT_RAW | SF_FORMAT_ULAW ;\n\t\t}\n\n\telse if (strcmp (cptr, \"vox\") == 0 || strcmp (cptr, \"vox8\") == 0)\n\t{\tpsf->sf.channels = 1 ;\n\t\tpsf->sf.samplerate = 8000 ;\n\t\tformat = SF_FORMAT_RAW | SF_FORMAT_VOX_ADPCM ;\n\t\t}\n\telse if (strcmp (cptr, \"vox6\") == 0)\n\t{\tpsf->sf.channels = 1 ;\n\t\tpsf->sf.samplerate = 6000 ;\n\t\tformat = SF_FORMAT_RAW | SF_FORMAT_VOX_ADPCM ;\n\t\t}\n\telse if (strcmp (cptr, \"gsm\") == 0)\n\t{\tpsf->sf.channels = 1 ;\n\t\tpsf->sf.samplerate = 8000 ;\n\t\tformat = SF_FORMAT_RAW | SF_FORMAT_GSM610 ;\n\t\t}\n\n\t/* For RAW files, make sure the dataoffset if set correctly. */\n\tif ((SF_CONTAINER (format)) == SF_FORMAT_RAW)\n\t\tpsf->dataoffset = 0 ;\n\n\treturn format ;\n} /* format_from_extension */\n\nstatic int\nguess_file_type (SF_PRIVATE *psf)\n{\tuint32_t buffer [3], format ;\n\n\tif (psf_binheader_readf (psf, \"b\", &buffer, SIGNED_SIZEOF (buffer)) != SIGNED_SIZEOF (buffer))\n\t{\tpsf->error = SFE_BAD_FILE_READ ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif ((buffer [0] == MAKE_MARKER ('R', 'I', 'F', 'F') || buffer [0] == MAKE_MARKER ('R', 'I', 'F', 'X'))\n\t\t\t&& buffer [2] == MAKE_MARKER ('W', 'A', 'V', 'E'))\n\t\treturn SF_FORMAT_WAV ;\n\n\tif (buffer [0] == MAKE_MARKER ('F', 'O', 'R', 'M'))\n\t{\tif (buffer [2] == MAKE_MARKER ('A', 'I', 'F', 'F') || buffer [2] == MAKE_MARKER ('A', 'I', 'F', 'C'))\n\t\t\treturn SF_FORMAT_AIFF ;\n\t\tif (buffer [2] == MAKE_MARKER ('8', 'S', 'V', 'X') || buffer [2] == MAKE_MARKER ('1', '6', 'S', 'V'))\n\t\t\treturn SF_FORMAT_SVX ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (buffer [0] == MAKE_MARKER ('.', 's', 'n', 'd') || buffer [0] == MAKE_MARKER ('d', 'n', 's', '.'))\n\t\treturn SF_FORMAT_AU ;\n\n\tif ((buffer [0] == MAKE_MARKER ('f', 'a', 'p', ' ') || buffer [0] == MAKE_MARKER (' ', 'p', 'a', 'f')))\n\t\treturn SF_FORMAT_PAF ;\n\n\tif (buffer [0] == MAKE_MARKER ('N', 'I', 'S', 'T'))\n\t\treturn SF_FORMAT_NIST ;\n\n\tif (buffer [0] == MAKE_MARKER ('C', 'r', 'e', 'a') && buffer [1] == MAKE_MARKER ('t', 'i', 'v', 'e'))\n\t\treturn SF_FORMAT_VOC ;\n\n\tif ((buffer [0] & MAKE_MARKER (0xFF, 0xFF, 0xF8, 0xFF)) == MAKE_MARKER (0x64, 0xA3, 0x00, 0x00) ||\n\t\t(buffer [0] & MAKE_MARKER (0xFF, 0xF8, 0xFF, 0xFF)) == MAKE_MARKER (0x00, 0x00, 0xA3, 0x64))\n\t\treturn SF_FORMAT_IRCAM ;\n\n\tif (buffer [0] == MAKE_MARKER ('r', 'i', 'f', 'f'))\n\t\treturn SF_FORMAT_W64 ;\n\n\tif (buffer [0] == MAKE_MARKER (0, 0, 0x03, 0xE8) && buffer [1] == MAKE_MARKER (0, 0, 0, 1) &&\n\t\t\t\t\t\t\t\tbuffer [2] == MAKE_MARKER (0, 0, 0, 1))\n\t\treturn SF_FORMAT_MAT4 ;\n\n\tif (buffer [0] == MAKE_MARKER (0, 0, 0, 0) && buffer [1] == MAKE_MARKER (1, 0, 0, 0) &&\n\t\t\t\t\t\t\t\tbuffer [2] == MAKE_MARKER (1, 0, 0, 0))\n\t\treturn SF_FORMAT_MAT4 ;\n\n\tif (buffer [0] == MAKE_MARKER ('M', 'A', 'T', 'L') && buffer [1] == MAKE_MARKER ('A', 'B', ' ', '5'))\n\t\treturn SF_FORMAT_MAT5 ;\n\n\tif (buffer [0] == MAKE_MARKER ('P', 'V', 'F', '1'))\n\t\treturn SF_FORMAT_PVF ;\n\n\tif (buffer [0] == MAKE_MARKER ('E', 'x', 't', 'e') && buffer [1] == MAKE_MARKER ('n', 'd', 'e', 'd') &&\n\t\t\t\t\t\t\t\tbuffer [2] == MAKE_MARKER (' ', 'I', 'n', 's'))\n\t\treturn SF_FORMAT_XI ;\n\n\tif (buffer [0] == MAKE_MARKER ('c', 'a', 'f', 'f') && buffer [2] == MAKE_MARKER ('d', 'e', 's', 'c'))\n\t\treturn SF_FORMAT_CAF ;\n\n\tif (buffer [0] == MAKE_MARKER ('O', 'g', 'g', 'S'))\n\t\treturn SF_FORMAT_OGG ;\n\n\tif (buffer [0] == MAKE_MARKER ('A', 'L', 'a', 'w') && buffer [1] == MAKE_MARKER ('S', 'o', 'u', 'n')\n\t\t\t&& buffer [2] == MAKE_MARKER ('d', 'F', 'i', 'l'))\n\t\treturn SF_FORMAT_WVE ;\n\n\tif (buffer [0] == MAKE_MARKER ('D', 'i', 'a', 'm') && buffer [1] == MAKE_MARKER ('o', 'n', 'd', 'W')\n\t\t\t&& buffer [2] == MAKE_MARKER ('a', 'r', 'e', ' '))\n\t\treturn SF_FORMAT_DWD ;\n\n\tif (buffer [0] == MAKE_MARKER ('L', 'M', '8', '9') || buffer [0] == MAKE_MARKER ('5', '3', 0, 0))\n\t\treturn SF_FORMAT_TXW ;\n\n\tif ((buffer [0] & MAKE_MARKER (0xFF, 0xFF, 0x80, 0xFF)) == MAKE_MARKER (0xF0, 0x7E, 0, 0x01))\n\t\treturn SF_FORMAT_SDS ;\n\n\tif ((buffer [0] & MAKE_MARKER (0xFF, 0xFF, 0, 0)) == MAKE_MARKER (1, 4, 0, 0))\n\t\treturn SF_FORMAT_MPC2K ;\n\n\tif (buffer [0] == MAKE_MARKER ('C', 'A', 'T', ' ') && buffer [2] == MAKE_MARKER ('R', 'E', 'X', '2'))\n\t\treturn SF_FORMAT_REX2 ;\n\n\tif (buffer [0] == MAKE_MARKER (0x30, 0x26, 0xB2, 0x75) && buffer [1] == MAKE_MARKER (0x8E, 0x66, 0xCF, 0x11))\n\t\treturn 0 /*-SF_FORMAT_WMA-*/ ;\n\n\t/* HMM (Hidden Markov Model) Tool Kit. */\n\tif (buffer [2] == MAKE_MARKER (0, 2, 0, 0) && 2 * ((int64_t) BE2H_32 (buffer [0])) + 12 == psf->filelength)\n\t\treturn SF_FORMAT_HTK ;\n\n\tif (buffer [0] == MAKE_MARKER ('f', 'L', 'a', 'C'))\n\t\treturn SF_FORMAT_FLAC ;\n\n\tif (buffer [0] == MAKE_MARKER ('2', 'B', 'I', 'T'))\n\t\treturn SF_FORMAT_AVR ;\n\n\tif (buffer [0] == MAKE_MARKER ('R', 'F', '6', '4') && buffer [2] == MAKE_MARKER ('W', 'A', 'V', 'E'))\n\t\treturn SF_FORMAT_RF64 ;\n\n\tif (buffer [0] == MAKE_MARKER ('I', 'D', '3', 3))\n\t{\tpsf_log_printf (psf, \"Found 'ID3' marker.\\n\") ;\n\t\tif (id3_skip (psf))\n\t\t\treturn guess_file_type (psf) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\t/* Turtle Beach SMP 16-bit */\n\tif (buffer [0] == MAKE_MARKER ('S', 'O', 'U', 'N') && buffer [1] == MAKE_MARKER ('D', ' ', 'S', 'A'))\n\t\treturn 0 ;\n\n\t/* Yamaha sampler format. */\n\tif (buffer [0] == MAKE_MARKER ('S', 'Y', '8', '0') || buffer [0] == MAKE_MARKER ('S', 'Y', '8', '5'))\n\t\treturn 0 ;\n\n\tif (buffer [0] == MAKE_MARKER ('a', 'j', 'k', 'g'))\n\t\treturn 0 /*-SF_FORMAT_SHN-*/ ;\n\n\t/* This must be the last one. */\n\tif (psf->filelength > 0 && (format = try_resource_fork (psf)) != 0)\n\t\treturn format ;\n\n\treturn 0 ;\n} /* guess_file_type */\n\n\nstatic int\nvalidate_sfinfo (SF_INFO *sfinfo)\n{\tif (sfinfo->samplerate < 1)\n\t\treturn 0 ;\n\tif (sfinfo->frames < 0)\n\t\treturn 0 ;\n\tif (sfinfo->channels < 1)\n\t\treturn 0 ;\n\tif ((SF_CONTAINER (sfinfo->format)) == 0)\n\t\treturn 0 ;\n\tif ((SF_CODEC (sfinfo->format)) == 0)\n\t\treturn 0 ;\n\tif (sfinfo->sections < 1)\n\t\treturn 0 ;\n\treturn 1 ;\n} /* validate_sfinfo */\n\nstatic int\nvalidate_psf (SF_PRIVATE *psf)\n{\n\tif (psf->datalength < 0)\n\t{\tpsf_log_printf (psf, \"Invalid SF_PRIVATE field : datalength == %D.\\n\", psf->datalength) ;\n\t\treturn 0 ;\n\t\t} ;\n\tif (psf->dataoffset < 0)\n\t{\tpsf_log_printf (psf, \"Invalid SF_PRIVATE field : dataoffset == %D.\\n\", psf->dataoffset) ;\n\t\treturn 0 ;\n\t\t} ;\n\tif (psf->blockwidth && psf->blockwidth != psf->sf.channels * psf->bytewidth)\n\t{\tpsf_log_printf (psf, \"Invalid SF_PRIVATE field : channels * bytewidth == %d.\\n\",\n\t\t\t\t\t\t\t\tpsf->sf.channels * psf->bytewidth) ;\n\t\treturn 0 ;\n\t\t} ;\n\treturn 1 ;\n} /* validate_psf */\n\nstatic void\nsave_header_info (SF_PRIVATE *psf)\n{\tsnprintf (sf_parselog, sizeof (sf_parselog), \"%s\", psf->parselog.buf) ;\n} /* save_header_info */\n\nstatic int\ncopy_filename (SF_PRIVATE *psf, const char *path)\n{\tconst char *ccptr ;\n\tchar *cptr ;\n\n\tif (strlen (path) > 1 && strlen (path) - 1 >= sizeof (psf->file.path.c))\n\t{\tpsf->error = SFE_FILENAME_TOO_LONG ;\n\t\treturn psf->error ;\n\t\t} ;\n\n\tsnprintf (psf->file.path.c, sizeof (psf->file.path.c), \"%s\", path) ;\n\tif ((ccptr = strrchr (path, '/')) || (ccptr = strrchr (path, '\\\\')))\n\t\tccptr ++ ;\n\telse\n\t\tccptr = path ;\n\n\tsnprintf (psf->file.name.c, sizeof (psf->file.name.c), \"%s\", ccptr) ;\n\n\t/* Now grab the directory. */\n\tsnprintf (psf->file.dir.c, sizeof (psf->file.dir.c), \"%s\", path) ;\n\tif ((cptr = strrchr (psf->file.dir.c, '/')) || (cptr = strrchr (psf->file.dir.c, '\\\\')))\n\t\tcptr [1] = 0 ;\n\telse\n\t\tpsf->file.dir.c [0] = 0 ;\n\n\treturn 0 ;\n} /* copy_filename */\n\n/*==============================================================================\n*/\n\nstatic int\npsf_close (SF_PRIVATE *psf)\n{\tuint32_t k ;\n\tint\terror = 0 ;\n\n\tif (psf->codec_close)\n\t{\terror = psf->codec_close (psf) ;\n\t\t/* To prevent it being called in psf->container_close(). */\n\t\tpsf->codec_close = NULL ;\n\t\t} ;\n\n\tif (psf->container_close)\n\t\terror = psf->container_close (psf) ;\n\n\terror = psf_fclose (psf) ;\n\tpsf_close_rsrc (psf) ;\n\n\t/* For an ISO C compliant implementation it is ok to free a NULL pointer. */\n\tfree (psf->container_data) ;\n\tfree (psf->codec_data) ;\n\tfree (psf->interleave) ;\n\tfree (psf->dither) ;\n\tfree (psf->peak_info) ;\n\tfree (psf->broadcast_16k) ;\n\tfree (psf->loop_info) ;\n\tfree (psf->instrument) ;\n\tfree (psf->cues) ;\n\tfree (psf->channel_map) ;\n\tfree (psf->format_desc) ;\n\tfree (psf->strings.storage) ;\n\n\tif (psf->wchunks.chunks)\n\t\tfor (k = 0 ; k < psf->wchunks.used ; k++)\n\t\t\tfree (psf->wchunks.chunks [k].data) ;\n\tfree (psf->rchunks.chunks) ;\n\tfree (psf->wchunks.chunks) ;\n\tfree (psf->iterator) ;\n\tfree (psf->cart_16k) ;\n\n\tmemset (psf, 0, sizeof (SF_PRIVATE)) ;\n\tfree (psf) ;\n\n\treturn error ;\n} /* psf_close */\n\nSNDFILE *\npsf_open_file (SF_PRIVATE *psf, SF_INFO *sfinfo)\n{\tint\t\terror, format ;\n\n\tsf_errno = error = 0 ;\n\tsf_parselog [0] = 0 ;\n\n\tif (psf->error)\n\t{\terror = psf->error ;\n\t\tgoto error_exit ;\n\t\t} ;\n\n\tif (psf->file.mode != SFM_READ && psf->file.mode != SFM_WRITE && psf->file.mode != SFM_RDWR)\n\t{\terror = SFE_BAD_OPEN_MODE ;\n\t\tgoto error_exit ;\n\t\t} ;\n\n\tif (sfinfo == NULL)\n\t{\terror = SFE_BAD_SF_INFO_PTR ;\n\t\tgoto error_exit ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_RAW)\n\t\t{\tif (sf_format_check (sfinfo) == 0)\n\t\t\t{\terror = SFE_RAW_BAD_FORMAT ;\n\t\t\t\tgoto error_exit ;\n\t\t\t\t} ;\n\t\t\t}\n\t\telse\n\t\t\tmemset (sfinfo, 0, sizeof (SF_INFO)) ;\n\t\t} ;\n\n\tmemcpy (&psf->sf, sfinfo, sizeof (SF_INFO)) ;\n\n\tpsf->Magick \t\t= SNDFILE_MAGICK ;\n\tpsf->norm_float \t= SF_TRUE ;\n\tpsf->norm_double\t= SF_TRUE ;\n\tpsf->dataoffset\t\t= -1 ;\n\tpsf->datalength\t\t= -1 ;\n\tpsf->read_current\t= -1 ;\n\tpsf->write_current\t= -1 ;\n\tpsf->auto_header \t= SF_FALSE ;\n\tpsf->rwf_endian\t\t= SF_ENDIAN_LITTLE ;\n\tpsf->seek\t\t\t= psf_default_seek ;\n\tpsf->float_int_mult = 0 ;\n\tpsf->float_max\t\t= -1.0 ;\n\n\t/* An attempt at a per SF_PRIVATE unique id. */\n\tpsf->unique_id\t\t= psf_rand_int32 () ;\n\n\tpsf->sf.sections = 1 ;\n\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\n\tif (psf->is_pipe)\n\t{\tpsf->sf.seekable = SF_FALSE ;\n\t\tpsf->filelength = SF_COUNT_MAX ;\n\t\t}\n\telse\n\t{\tpsf->sf.seekable = SF_TRUE ;\n\n\t\t/* File is open, so get the length. */\n\t\tpsf->filelength = psf_get_filelen (psf) ;\n\t\t} ;\n\n\tif (psf->fileoffset > 0)\n\t{\tswitch (psf->file.mode)\n\t\t{\tcase SFM_READ :\n\t\t\t\tif (psf->filelength < 44)\n\t\t\t\t{\tpsf_log_printf (psf, \"Short filelength: %D (fileoffset: %D)\\n\", psf->filelength, psf->fileoffset) ;\n\t\t\t\t\terror = SFE_BAD_OFFSET ;\n\t\t\t\t\tgoto error_exit ;\n\t\t\t\t\t} ;\n\t\t\t\tbreak ;\n\n\t\t\tcase SFM_WRITE :\n\t\t\t\tpsf->fileoffset = 0 ;\n\t\t\t\tpsf_fseek (psf, 0, SEEK_END) ;\n\t\t\t\tpsf->fileoffset = psf_ftell (psf) ;\n\t\t\t\tbreak ;\n\n\t\t\tcase SFM_RDWR :\n\t\t\t\terror = SFE_NO_EMBEDDED_RDWR ;\n\t\t\t\tgoto error_exit ;\n\t\t\t} ;\n\n\t\tpsf_log_printf (psf, \"Embedded file offset : %D\\n\", psf->fileoffset) ;\n\t\t} ;\n\n\tif (psf->filelength == SF_COUNT_MAX)\n\t\tpsf_log_printf (psf, \"Length : unknown\\n\") ;\n\telse\n\t\tpsf_log_printf (psf, \"Length : %D\\n\", psf->filelength) ;\n\n\tif (psf->file.mode == SFM_WRITE || (psf->file.mode == SFM_RDWR && psf->filelength == 0))\n\t{\t/* If the file is being opened for write or RDWR and the file is currently\n\t\t** empty, then the SF_INFO struct must contain valid data.\n\t\t*/\n\t\tif ((SF_CONTAINER (psf->sf.format)) == 0)\n\t\t{\terror = SFE_ZERO_MAJOR_FORMAT ;\n\t\t\tgoto error_exit ;\n\t\t\t} ;\n\t\tif ((SF_CODEC (psf->sf.format)) == 0)\n\t\t{\terror = SFE_ZERO_MINOR_FORMAT ;\n\t\t\tgoto error_exit ;\n\t\t\t} ;\n\n\t\tif (sf_format_check (&psf->sf) == 0)\n\t\t{\terror = SFE_BAD_OPEN_FORMAT ;\n\t\t\tgoto error_exit ;\n\t\t\t} ;\n\t\t}\n\telse if ((SF_CONTAINER (psf->sf.format)) != SF_FORMAT_RAW)\n\t{\t/* If type RAW has not been specified then need to figure out file type. */\n\t\tpsf->sf.format = guess_file_type (psf) ;\n\n\t\tif (psf->sf.format == 0)\n\t\t\tpsf->sf.format = format_from_extension (psf) ;\n\t\t} ;\n\n\t/* Prevent unnecessary seeks */\n\tpsf->last_op = psf->file.mode ;\n\n\t/* Set bytewidth if known. */\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_S8 :\n\t\tcase SF_FORMAT_PCM_U8 :\n\t\tcase SF_FORMAT_ULAW :\n\t\tcase SF_FORMAT_ALAW :\n\t\tcase SF_FORMAT_DPCM_8 :\n\t\t\t\tpsf->bytewidth = 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_16 :\n\t\tcase SF_FORMAT_DPCM_16 :\n\t\t\t\tpsf->bytewidth = 2 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_24 :\n\t\t\t\tpsf->bytewidth = 3 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_32 :\n\t\tcase SF_FORMAT_FLOAT :\n\t\t\t\tpsf->bytewidth = 4 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DOUBLE :\n\t\t\t\tpsf->bytewidth = 8 ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\t/* Call the initialisation function for the relevant file type. */\n\tswitch (SF_CONTAINER (psf->sf.format))\n\t{\tcase\tSF_FORMAT_WAV :\n\t\tcase\tSF_FORMAT_WAVEX :\n\t\t\t\terror = wav_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_AIFF :\n\t\t\t\terror = aiff_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_AU :\n\t\t\t\terror = au_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_RAW :\n\t\t\t\terror = raw_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_W64 :\n\t\t\t\terror = w64_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_RF64 :\n\t\t\t\terror = rf64_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\t/* Lite remove start */\n\t\tcase\tSF_FORMAT_PAF :\n\t\t\t\terror = paf_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_SVX :\n\t\t\t\terror = svx_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_NIST :\n\t\t\t\terror = nist_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_IRCAM :\n\t\t\t\terror = ircam_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_VOC :\n\t\t\t\terror = voc_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_SDS :\n\t\t\t\terror = sds_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_OGG :\n\t\t\t\terror = ogg_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_TXW :\n\t\t\t\terror = txw_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_WVE :\n\t\t\t\terror = wve_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_DWD :\n\t\t\t\terror = dwd_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_MAT4 :\n\t\t\t\terror = mat4_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_MAT5 :\n\t\t\t\terror = mat5_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_PVF :\n\t\t\t\terror = pvf_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_XI :\n\t\t\t\terror = xi_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_HTK :\n\t\t\t\terror = htk_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_SD2 :\n\t\t\t\terror = sd2_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_REX2 :\n\t\t\t\terror = rx2_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_AVR :\n\t\t\t\terror = avr_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_FLAC :\n\t\t\t\terror = flac_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_CAF :\n\t\t\t\terror = caf_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_MPC2K :\n\t\t\t\terror = mpc2k_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\t/* Lite remove end */\n\n\t\tdefault :\n\t\t\t\terror = SFE_UNKNOWN_FORMAT ;\n\t\t} ;\n\n\tif (error)\n\t\tgoto error_exit ;\n\n\t/* For now, check whether embedding is supported. */\n\tformat = SF_CONTAINER (psf->sf.format) ;\n\tif (psf->fileoffset > 0)\n\t{\tswitch (format)\n\t\t{\tcase SF_FORMAT_WAV :\n\t\t\tcase SF_FORMAT_WAVEX :\n\t\t\tcase SF_FORMAT_AIFF :\n\t\t\tcase SF_FORMAT_AU :\n\t\t\t\t/* Actual embedded files. */\n\t\t\t\tbreak ;\n\n\t\t\tcase SF_FORMAT_FLAC :\n\t\t\t\t/* Flac with an ID3v2 header? */\n\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\terror = SFE_NO_EMBED_SUPPORT ;\n\t\t\t\tgoto error_exit ;\n\t\t\t} ;\n\t\t} ;\n\n\tif (psf->fileoffset > 0)\n\t\tpsf_log_printf (psf, \"Embedded file length : %D\\n\", psf->filelength) ;\n\n\tif (psf->file.mode == SFM_RDWR && sf_format_check (&psf->sf) == 0)\n\t{\terror = SFE_BAD_MODE_RW ;\n\t\tgoto error_exit ;\n\t\t} ;\n\n\tif (validate_sfinfo (&psf->sf) == 0)\n\t{\tpsf_log_SF_INFO (psf) ;\n\t\tsave_header_info (psf) ;\n\t\terror = SFE_BAD_SF_INFO ;\n\t\tgoto error_exit ;\n\t\t} ;\n\n\tif (validate_psf (psf) == 0)\n\t{\tsave_header_info (psf) ;\n\t\terror = SFE_INTERNAL ;\n\t\tgoto error_exit ;\n\t\t} ;\n\n\tpsf->read_current = 0 ;\n\tpsf->write_current = 0 ;\n\tif (psf->file.mode == SFM_RDWR)\n\t{\tpsf->write_current = psf->sf.frames ;\n\t\tpsf->have_written = psf->sf.frames > 0 ? SF_TRUE : SF_FALSE ;\n\t\t} ;\n\n\tmemcpy (sfinfo, &psf->sf, sizeof (SF_INFO)) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\t/* Zero out these fields. */\n\t\tsfinfo->frames = 0 ;\n\t\tsfinfo->sections = 0 ;\n\t\tsfinfo->seekable = 0 ;\n\t\t} ;\n\n\treturn (SNDFILE *) psf ;\n\nerror_exit :\n\tsf_errno = error ;\n\n\tif (error == SFE_SYSTEM)\n\t\tsnprintf (sf_syserr, sizeof (sf_syserr), \"%s\", psf->syserr) ;\n\tsnprintf (sf_parselog, sizeof (sf_parselog), \"%s\", psf->parselog.buf) ;\n\n\tswitch (error)\n\t{\tcase SF_ERR_SYSTEM :\n\t\tcase SF_ERR_UNSUPPORTED_ENCODING :\n\t\tcase SFE_UNIMPLEMENTED :\n\t\t\tbreak ;\n\n\t\tcase SFE_RAW_BAD_FORMAT :\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tif (psf->file.mode == SFM_READ)\n\t\t\t{\tpsf_log_printf (psf, \"Parse error : %s\\n\", sf_error_number (error)) ;\n\t\t\t\terror = SF_ERR_MALFORMED_FILE ;\n\t\t\t\t} ;\n\t\t} ;\n\n\tpsf_close (psf) ;\n\treturn NULL ;\n} /* psf_open_file */\n\n/*==============================================================================\n** Chunk getting and setting.\n** This works for AIFF, CAF, RF64 and WAV.\n** It doesn't work for W64 because W64 uses weird GUID style chunk markers.\n*/\n\nint\nsf_set_chunk (SNDFILE * sndfile, const SF_CHUNK_INFO * chunk_info)\n{\tSF_PRIVATE \t*psf ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (chunk_info == NULL || chunk_info->data == NULL)\n\t\treturn SFE_BAD_CHUNK_PTR ;\n\n\tif (psf->set_chunk)\n\t\treturn psf->set_chunk (psf, chunk_info) ;\n\n\treturn SFE_BAD_CHUNK_FORMAT ;\n} /* sf_set_chunk */\n\nSF_CHUNK_ITERATOR *\nsf_get_chunk_iterator (SNDFILE * sndfile, const SF_CHUNK_INFO * chunk_info)\n{\tSF_PRIVATE \t*psf ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (chunk_info)\n\t\treturn psf_get_chunk_iterator (psf, chunk_info->id) ;\n\n\treturn psf_get_chunk_iterator (psf, NULL) ;\n} /* sf_get_chunk_iterator */\n\nSF_CHUNK_ITERATOR *\nsf_next_chunk_iterator (SF_CHUNK_ITERATOR * iterator)\n{\tSF_PRIVATE \t*psf ;\n\tSNDFILE\t*sndfile = iterator ? iterator->sndfile : NULL ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->next_chunk_iterator)\n\t\treturn psf->next_chunk_iterator (psf, iterator) ;\n\n\treturn NULL ;\n} /* sf_get_chunk_iterator_next */\n\nint\nsf_get_chunk_size (const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info)\n{\tSF_PRIVATE \t*psf ;\n\tSNDFILE\t*sndfile = iterator ? iterator->sndfile : NULL ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (chunk_info == NULL)\n\t\treturn SFE_BAD_CHUNK_PTR ;\n\n\tif (psf->get_chunk_size)\n\t\treturn psf->get_chunk_size (psf, iterator, chunk_info) ;\n\n\treturn SFE_BAD_CHUNK_FORMAT ;\n\treturn 0 ;\n} /* sf_get_chunk_size */\n\nint\nsf_get_chunk_data (const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info)\n{\tSF_PRIVATE\t*psf ;\n\tSNDFILE\t*sndfile = iterator ? iterator->sndfile : NULL ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (chunk_info == NULL || chunk_info->data == NULL)\n\t\treturn SFE_BAD_CHUNK_PTR ;\n\n\tif (psf->get_chunk_data)\n\t\treturn psf->get_chunk_data (psf, iterator, chunk_info) ;\n\n\treturn SFE_BAD_CHUNK_FORMAT ;\n} /* sf_get_chunk_data */\n"], "fixing_code": ["/*\n** Copyright (C) 1999-2016 Erik de Castro Lopo <erikd@mega-nerd.com>\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n#include <config.h>\n\n#include <stdarg.h>\n#include <string.h>\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <ctype.h>\n#include <math.h>\n#include <time.h>\n#if HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#include \"sndfile.h\"\n#include \"sfendian.h\"\n#include \"common.h\"\n\n#define\tINITAL_HEADER_SIZE\t256\n\n/* Allocate and initialize the SF_PRIVATE struct. */\nSF_PRIVATE *\npsf_allocate (void)\n{\tSF_PRIVATE * psf ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t\treturn\tNULL ;\n\n\tif ((psf->header.ptr = calloc (1, INITAL_HEADER_SIZE)) == NULL)\n\t{\tfree (psf) ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf->header.len = INITAL_HEADER_SIZE ;\n\n\treturn psf ;\n} /* psf_allocate */\n\nstatic int\npsf_bump_header_allocation (SF_PRIVATE * psf, sf_count_t needed)\n{\n\tsf_count_t newlen, smallest = INITAL_HEADER_SIZE ;\n\tvoid * ptr ;\n\n\tnewlen = (needed > psf->header.len) ? 2 * SF_MAX (needed, smallest) : 2 * psf->header.len ;\n\n\tif (newlen > 100 * 1024)\n\t{\tpsf_log_printf (psf, \"Request for header allocation of %D denined.\\n\", newlen) ;\n\t\treturn 1 ;\n\t\t}\n\n\tif ((ptr = realloc (psf->header.ptr, newlen)) == NULL)\n\t{\tpsf_log_printf (psf, \"realloc (%p, %D) failed\\n\", psf->header.ptr, newlen) ;\n\t\tpsf->error = SFE_MALLOC_FAILED ;\n\t\treturn 1 ;\n\t\t} ;\n\n\tpsf->header.ptr = ptr ;\n\tpsf->header.len = newlen ;\n\treturn 0 ;\n} /* psf_bump_header_allocation */\n\n/*-----------------------------------------------------------------------------------------------\n** psf_log_printf allows libsndfile internal functions to print to an internal parselog which\n** can later be displayed.\n** The format specifiers are as for printf but without the field width and other modifiers.\n** Printing is performed to the parselog char array of the SF_PRIVATE struct.\n** Printing is done in such a way as to guarantee that the log never overflows the end of the\n** parselog array.\n*/\n\nstatic inline void\nlog_putchar (SF_PRIVATE *psf, char ch)\n{\tif (psf->parselog.indx < SIGNED_SIZEOF (psf->parselog.buf) - 1)\n\t{\tpsf->parselog.buf [psf->parselog.indx++] = ch ;\n\t\tpsf->parselog.buf [psf->parselog.indx] = 0 ;\n\t\t} ;\n\treturn ;\n} /* log_putchar */\n\nvoid\npsf_log_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\t\tap ;\n\tuint32_t\tu ;\n\tint\t\t\td, tens, shift, width, width_specifier, left_align, slen ;\n\tchar\t\tc, *strptr, istr [5], lead_char, sign_char ;\n\n\tva_start (ap, format) ;\n\n\twhile ((c = *format++))\n\t{\tif (c != '%')\n\t\t{\tlog_putchar (psf, c) ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tif (format [0] == '%') /* Handle %% */\n\t\t{ \tlog_putchar (psf, '%') ;\n\t\t\tformat ++ ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tsign_char = 0 ;\n\t\tleft_align = SF_FALSE ;\n\t\twhile (1)\n\t\t{\tswitch (format [0])\n\t\t\t{\tcase ' ' :\n\t\t\t\tcase '+' :\n\t\t\t\t\tsign_char = format [0] ;\n\t\t\t\t\tformat ++ ;\n\t\t\t\t\tcontinue ;\n\n\t\t\t\tcase '-' :\n\t\t\t\t\tleft_align = SF_TRUE ;\n\t\t\t\t\tformat ++ ;\n\t\t\t\t\tcontinue ;\n\n\t\t\t\tdefault : break ;\n\t\t\t\t} ;\n\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (format [0] == 0)\n\t\t\tbreak ;\n\n\t\tlead_char = ' ' ;\n\t\tif (format [0] == '0')\n\t\t\tlead_char = '0' ;\n\n\t\twidth_specifier = 0 ;\n\t\twhile ((c = *format++) && isdigit (c))\n\t\t\twidth_specifier = width_specifier * 10 + (c - '0') ;\n\n\t\tswitch (c)\n\t\t{\tcase 0 : /* NULL character. */\n\t\t\t\t\tva_end (ap) ;\n\t\t\t\t\treturn ;\n\n\t\t\tcase 's': /* string */\n\t\t\t\t\tstrptr = va_arg (ap, char *) ;\n\t\t\t\t\tif (strptr == NULL)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tslen = strlen (strptr) ;\n\t\t\t\t\twidth_specifier = width_specifier >= slen ? width_specifier - slen : 0 ;\n\t\t\t\t\tif (left_align == SF_FALSE)\n\t\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\t\tlog_putchar (psf, ' ') ;\n\t\t\t\t\twhile (*strptr)\n\t\t\t\t\t\tlog_putchar (psf, *strptr++) ;\n\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\tlog_putchar (psf, ' ') ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'd': /* int */\n\t\t\t\t\td = va_arg (ap, int) ;\n\n\t\t\t\t\tif (d < 0)\n\t\t\t\t\t{\td = -d ;\n\t\t\t\t\t\tsign_char = '-' ;\n\t\t\t\t\t\tif (lead_char != '0' && left_align == SF_FALSE)\n\t\t\t\t\t\t\twidth_specifier -- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\ttens = 1 ;\n\t\t\t\t\twidth = 1 ;\n\t\t\t\t\twhile (d / tens >= 10)\n\t\t\t\t\t{\ttens *= 10 ;\n\t\t\t\t\t\twidth ++ ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\twidth_specifier -= width ;\n\n\t\t\t\t\tif (sign_char == ' ')\n\t\t\t\t\t{\tlog_putchar (psf, ' ') ;\n\t\t\t\t\t\twidth_specifier -- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (left_align == SF_FALSE && lead_char != '0')\n\t\t\t\t\t{\tif (sign_char == '+')\n\t\t\t\t\t\t\twidth_specifier -- ;\n\n\t\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (sign_char == '+' || sign_char == '-')\n\t\t\t\t\t{\tlog_putchar (psf, sign_char) ;\n\t\t\t\t\t\twidth_specifier -- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (left_align == SF_FALSE)\n\t\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\n\t\t\t\t\twhile (tens > 0)\n\t\t\t\t\t{\tlog_putchar (psf, '0' + d / tens) ;\n\t\t\t\t\t\td %= tens ;\n\t\t\t\t\t\ttens /= 10 ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'D': /* sf_count_t */\n\t\t\t\t\t{\tsf_count_t\t\tD, Tens ;\n\n\t\t\t\t\t\tD = va_arg (ap, sf_count_t) ;\n\n\t\t\t\t\t\tif (D == 0)\n\t\t\t\t\t\t{\twhile (-- width_specifier > 0)\n\t\t\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\t\t\tlog_putchar (psf, '0') ;\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif (D < 0)\n\t\t\t\t\t\t{\tlog_putchar (psf, '-') ;\n\t\t\t\t\t\t\tD = -D ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\tTens = 1 ;\n\t\t\t\t\t\twidth = 1 ;\n\t\t\t\t\t\twhile (D / Tens >= 10)\n\t\t\t\t\t\t{\tTens *= 10 ;\n\t\t\t\t\t\t\twidth ++ ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\twhile (width_specifier > width)\n\t\t\t\t\t\t{\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\t\t\twidth_specifier-- ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\twhile (Tens > 0)\n\t\t\t\t\t\t{\tlog_putchar (psf, '0' + D / Tens) ;\n\t\t\t\t\t\t\tD %= Tens ;\n\t\t\t\t\t\t\tTens /= 10 ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'u': /* unsigned int */\n\t\t\t\t\tu = va_arg (ap, unsigned int) ;\n\n\t\t\t\t\ttens = 1 ;\n\t\t\t\t\twidth = 1 ;\n\t\t\t\t\twhile (u / tens >= 10)\n\t\t\t\t\t{\ttens *= 10 ;\n\t\t\t\t\t\twidth ++ ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\twidth_specifier -= width ;\n\n\t\t\t\t\tif (sign_char == ' ')\n\t\t\t\t\t{\tlog_putchar (psf, ' ') ;\n\t\t\t\t\t\twidth_specifier -- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (left_align == SF_FALSE && lead_char != '0')\n\t\t\t\t\t{\tif (sign_char == '+')\n\t\t\t\t\t\t\twidth_specifier -- ;\n\n\t\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (sign_char == '+' || sign_char == '-')\n\t\t\t\t\t{\tlog_putchar (psf, sign_char) ;\n\t\t\t\t\t\twidth_specifier -- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (left_align == SF_FALSE)\n\t\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\n\t\t\t\t\twhile (tens > 0)\n\t\t\t\t\t{\tlog_putchar (psf, '0' + u / tens) ;\n\t\t\t\t\t\tu %= tens ;\n\t\t\t\t\t\ttens /= 10 ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\twhile (width_specifier -- > 0)\n\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'c': /* char */\n\t\t\t\t\tc = va_arg (ap, int) & 0xFF ;\n\t\t\t\t\tlog_putchar (psf, c) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'x': /* hex */\n\t\t\tcase 'X': /* hex */\n\t\t\t\t\td = va_arg (ap, int) ;\n\n\t\t\t\t\tif (d == 0)\n\t\t\t\t\t{\twhile (--width_specifier > 0)\n\t\t\t\t\t\t\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\t\tlog_putchar (psf, '0') ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tshift = 28 ;\n\t\t\t\t\twidth = (width_specifier < 8) ? 8 : width_specifier ;\n\t\t\t\t\twhile (! ((((uint32_t) 0xF) << shift) & d))\n\t\t\t\t\t{\tshift -= 4 ;\n\t\t\t\t\t\twidth -- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\twhile (width > 0 && width_specifier > width)\n\t\t\t\t\t{\tlog_putchar (psf, lead_char) ;\n\t\t\t\t\t\twidth_specifier-- ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\twhile (shift >= 0)\n\t\t\t\t\t{\tc = (d >> shift) & 0xF ;\n\t\t\t\t\t\tlog_putchar (psf, (c > 9) ? c + 'A' - 10 : c + '0') ;\n\t\t\t\t\t\tshift -= 4 ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'M': /* int2str */\n\t\t\t\t\td = va_arg (ap, int) ;\n\t\t\t\t\tif (CPU_IS_LITTLE_ENDIAN)\n\t\t\t\t\t{\tistr [0] = d & 0xFF ;\n\t\t\t\t\t\tistr [1] = (d >> 8) & 0xFF ;\n\t\t\t\t\t\tistr [2] = (d >> 16) & 0xFF ;\n\t\t\t\t\t\tistr [3] = (d >> 24) & 0xFF ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\tistr [3] = d & 0xFF ;\n\t\t\t\t\t\tistr [2] = (d >> 8) & 0xFF ;\n\t\t\t\t\t\tistr [1] = (d >> 16) & 0xFF ;\n\t\t\t\t\t\tistr [0] = (d >> 24) & 0xFF ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tistr [4] = 0 ;\n\t\t\t\t\tstrptr = istr ;\n\t\t\t\t\twhile (*strptr)\n\t\t\t\t\t{\tc = *strptr++ ;\n\t\t\t\t\t\tlog_putchar (psf, c) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\t\tlog_putchar (psf, '*') ;\n\t\t\t\t\tlog_putchar (psf, c) ;\n\t\t\t\t\tlog_putchar (psf, '*') ;\n\t\t\t\t\tbreak ;\n\t\t\t} /* switch */\n\t\t} /* while */\n\n\tva_end (ap) ;\n\treturn ;\n} /* psf_log_printf */\n\n/*-----------------------------------------------------------------------------------------------\n**  ASCII header printf functions.\n**  Some formats (ie NIST) use ascii text in their headers.\n**  Format specifiers are the same as the standard printf specifiers (uses vsnprintf).\n**  If this generates a compile error on any system, the author should be notified\n**  so an alternative vsnprintf can be provided.\n*/\n\nvoid\npsf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tint\t\tmaxlen ;\n\tchar\t*start ;\n\n\tmaxlen = strlen ((char*) psf->header.ptr) ;\n\tstart\t= ((char*) psf->header.ptr) + maxlen ;\n\tmaxlen\t= psf->header.len - maxlen ;\n\n\tva_start (argptr, format) ;\n\tvsnprintf (start, maxlen, format, argptr) ;\n\tva_end (argptr) ;\n\n\t/* Make sure the string is properly terminated. */\n\tstart [maxlen - 1] = 0 ;\n\n\tpsf->header.indx = strlen ((char*) psf->header.ptr) ;\n\n\treturn ;\n} /* psf_asciiheader_printf */\n\n/*-----------------------------------------------------------------------------------------------\n**  Binary header writing functions. Returns number of bytes written.\n**\n**  Format specifiers for psf_binheader_writef are as follows\n**\t\tm\t- marker - four bytes - no endian manipulation\n**\n**\t\te   - all following numerical values will be little endian\n**\t\tE   - all following numerical values will be big endian\n**\n**\t\tt   - all following O types will be truncated to 4 bytes\n**\t\tT   - switch off truncation of all following O types\n**\n**\t\t1\t- single byte value\n**\t\t2\t- two byte value\n**\t\t3\t- three byte value\n**\t\t4\t- four byte value\n**\t\t8\t- eight byte value (sometimes written as 4 bytes)\n**\n**\t\ts   - string preceded by a four byte length\n**\t\tS   - string including null terminator\n**      p   - a Pascal string\n**\n**\t\tf\t- floating point data\n**\t\td\t- double precision floating point data\n**\t\th\t- 16 binary bytes value\n**\n**\t\tb\t- binary data (see below)\n**\t\tz   - zero bytes (ses below)\n**\t\tj\t- jump forwards or backwards\n**\n**\tTo write a word followed by an int (both little endian) use:\n**\t\tpsf_binheader_writef (\"e24\", wordval, longval) ;\n**\n**\tTo write binary data use:\n**\t\tpsf_binheader_writef (\"b\", &bindata, sizeof (bindata)) ;\n**\n**\tTo write N zero bytes use:\n**\t\t\tNOTE: due to platform issues (ie x86-64) you should cast the\n**\t\t\targument to size_t or ensure the variable type is size_t.\n**\t\tpsf_binheader_writef (\"z\", N) ;\n*/\n\n/* These macros may seem a bit messy but do prevent problems with processors which\n** seg. fault when asked to write an int or short to a non-int/short aligned address.\n*/\n\nstatic inline void\nheader_put_byte (SF_PRIVATE *psf, char x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\n} /* header_put_byte */\n\n#if (CPU_IS_BIG_ENDIAN == 1)\nstatic inline void\nheader_put_marker (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} /* header_put_marker */\n\n#elif (CPU_IS_LITTLE_ENDIAN == 1)\nstatic inline void\nheader_put_marker (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n} /* header_put_marker */\n\n#else\n#\terror \"Cannot determine endian-ness of processor.\"\n#endif\n\n\nstatic inline void\nheader_put_be_short (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} /* header_put_be_short */\n\nstatic inline void\nheader_put_le_short (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n} /* header_put_le_short */\n\nstatic inline void\nheader_put_be_3byte (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} /* header_put_be_3byte */\n\nstatic inline void\nheader_put_le_3byte (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n} /* header_put_le_3byte */\n\nstatic inline void\nheader_put_be_int (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} /* header_put_be_int */\n\nstatic inline void\nheader_put_le_int (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n} /* header_put_le_int */\n\n#if (SIZEOF_SF_COUNT_T == 8)\n\nstatic inline void\nheader_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 56) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 48) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 40) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 32) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} /* header_put_be_8byte */\n\nstatic inline void\nheader_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 32) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 40) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 48) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 56) ;\n} /* header_put_le_8byte */\n\n#else\n#error \"SIZEOF_SF_COUNT_T != 8\"\n#endif\n\nint\npsf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tsf_count_t \t\tcountdata ;\n\tunsigned long \tlongdata ;\n\tunsigned int \tdata ;\n\tfloat\t\t\tfloatdata ;\n\tdouble\t\t\tdoubledata ;\n\tvoid\t\t\t*bindata ;\n\tsize_t\t\t\tsize ;\n\tchar\t\t\tc, *strptr ;\n\tint\t\t\t\tcount = 0, trunc_8to4 ;\n\n\ttrunc_8to4 = SF_FALSE ;\n\n\tva_start (argptr, format) ;\n\n\twhile ((c = *format++))\n\t{\n\t\tif (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))\n\t\t\treturn count ;\n\n\t\tswitch (c)\n\t\t{\tcase ' ' : /* Do nothing. Just used to space out format string. */\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'e' : /* All conversions are now from LE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_LITTLE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'E' : /* All conversions are now from BE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_BIG ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 't' : /* All 8 byte values now get written as 4 bytes. */\n\t\t\t\t\ttrunc_8to4 = SF_TRUE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'T' : /* All 8 byte values now get written as 8 bytes. */\n\t\t\t\t\ttrunc_8to4 = SF_FALSE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'm' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\theader_put_marker (psf, data) ;\n\t\t\t\t\tcount += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '1' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\theader_put_byte (psf, data) ;\n\t\t\t\t\tcount += 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '2' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t{\theader_put_be_short (psf, data) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_short (psf, data) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tcount += 2 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '3' : /* tribyte */\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t{\theader_put_be_3byte (psf, data) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_3byte (psf, data) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tcount += 3 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '4' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t{\theader_put_be_int (psf, data) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_int (psf, data) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tcount += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '8' :\n\t\t\t\t\tcountdata = va_arg (argptr, sf_count_t) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_FALSE)\n\t\t\t\t\t{\theader_put_be_8byte (psf, countdata) ;\n\t\t\t\t\t\tcount += 8 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE)\n\t\t\t\t\t{\theader_put_le_8byte (psf, countdata) ;\n\t\t\t\t\t\tcount += 8 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_TRUE)\n\t\t\t\t\t{\tlongdata = countdata & 0xFFFFFFFF ;\n\t\t\t\t\t\theader_put_be_int (psf, longdata) ;\n\t\t\t\t\t\tcount += 4 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_TRUE)\n\t\t\t\t\t{\tlongdata = countdata & 0xFFFFFFFF ;\n\t\t\t\t\t\theader_put_le_int (psf, longdata) ;\n\t\t\t\t\t\tcount += 4 ;\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'f' :\n\t\t\t\t\t/* Floats are passed as doubles. Is this always true? */\n\t\t\t\t\tfloatdata = (float) va_arg (argptr, double) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\tfloat32_be_write (floatdata, psf->header.ptr + psf->header.indx) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tfloat32_le_write (floatdata, psf->header.ptr + psf->header.indx) ;\n\t\t\t\t\tpsf->header.indx += 4 ;\n\t\t\t\t\tcount += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'd' :\n\t\t\t\t\tdoubledata = va_arg (argptr, double) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\tdouble64_be_write (doubledata, psf->header.ptr + psf->header.indx) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tdouble64_le_write (doubledata, psf->header.ptr + psf->header.indx) ;\n\t\t\t\t\tpsf->header.indx += 8 ;\n\t\t\t\t\tcount += 8 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 's' :\n\t\t\t\t\t/* Write a C string (guaranteed to have a zero terminator). */\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize = strlen (strptr) + 1 ;\n\t\t\t\t\tsize += (size & 1) ;\n\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, 16))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\theader_put_be_int (psf, size) ;\n\t\t\t\t\telse\n\t\t\t\t\t\theader_put_le_int (psf, size) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tpsf->header.ptr [psf->header.indx - 1] = 0 ;\n\t\t\t\t\tcount += 4 + size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'S' :\n\t\t\t\t\t/*\n\t\t\t\t\t**\tWrite an AIFF style string (no zero terminator but possibly\n\t\t\t\t\t**\tan extra pad byte if the string length is odd).\n\t\t\t\t\t*/\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize = strlen (strptr) ;\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\theader_put_be_int (psf, size) ;\n\t\t\t\t\telse\n\t\t\t\t\t\theader_put_le_int (psf, size) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + 1) ;\n\t\t\t\t\tsize += (size & 1) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tpsf->header.ptr [psf->header.indx] = 0 ;\n\t\t\t\t\tcount += 4 + size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'p' :\n\t\t\t\t\t/* Write a PASCAL string (as used by AIFF files).\n\t\t\t\t\t*/\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize = strlen (strptr) ;\n\t\t\t\t\tsize = (size & 1) ? size : size + 1 ;\n\t\t\t\t\tsize = (size > 254) ? 254 : size ;\n\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\theader_put_byte (psf, size) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tcount += 1 + size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'b' :\n\t\t\t\t\tbindata\t= va_arg (argptr, void *) ;\n\t\t\t\t\tsize\t= va_arg (argptr, size_t) ;\n\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), bindata, size) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tcount += size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'z' :\n\t\t\t\t\tsize = va_arg (argptr, size_t) ;\n\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tcount += size ;\n\t\t\t\t\twhile (size)\n\t\t\t\t\t{\tpsf->header.ptr [psf->header.indx] = 0 ;\n\t\t\t\t\t\tpsf->header.indx ++ ;\n\t\t\t\t\t\tsize -- ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'h' :\n\t\t\t\t\tbindata = va_arg (argptr, void *) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), bindata, 16) ;\n\t\t\t\t\tpsf->header.indx += 16 ;\n\t\t\t\t\tcount += 16 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'j' :\t/* Jump forwards/backwards by specified amount. */\n\t\t\t\t\tsize = va_arg (argptr, size_t) ;\n\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tcount += size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'o' :\t/* Jump to specified offset. */\n\t\t\t\t\tsize = va_arg (argptr, size_t) ;\n\n\t\t\t\t\tif ((sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tpsf->header.indx = size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\tpsf_log_printf (psf, \"*** Invalid format specifier `%c'\\n\", c) ;\n\t\t\t\tpsf->error = SFE_INTERNAL ;\n\t\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ;\n\n\tva_end (argptr) ;\n\treturn count ;\n} /* psf_binheader_writef */\n\n/*-----------------------------------------------------------------------------------------------\n**  Binary header reading functions. Returns number of bytes read.\n**\n**\tFormat specifiers are the same as for header write function above with the following\n**\tadditions:\n**\n**\t\tp   - jump a given number of position from start of file.\n**\n**\tIf format is NULL, psf_binheader_readf returns the current offset.\n*/\n\n#if (CPU_IS_BIG_ENDIAN == 1)\n#define\tGET_MARKER(ptr)\t(\t(((uint32_t) (ptr) [0]) << 24)\t| ((ptr) [1] << 16) |\t\\\n\t\t\t\t\t\t\t((ptr) [2] << 8)\t| ((ptr) [3]))\n\n#elif (CPU_IS_LITTLE_ENDIAN == 1)\n#define\tGET_MARKER(ptr)\t(\t((ptr) [0])\t\t\t| ((ptr) [1] << 8) |\t\\\n\t\t\t\t\t\t\t((ptr) [2] << 16)\t| (((uint32_t) (ptr) [3]) << 24))\n\n#else\n#\terror \"Cannot determine endian-ness of processor.\"\n#endif\n\n#define\tGET_LE_SHORT(ptr)\t(((ptr) [1] << 8) | ((ptr) [0]))\n#define\tGET_BE_SHORT(ptr)\t(((ptr) [0] << 8) | ((ptr) [1]))\n\n#define\tGET_LE_3BYTE(ptr)\t(\t((ptr) [2] << 16) | ((ptr) [1] << 8) | ((ptr) [0]))\n#define\tGET_BE_3BYTE(ptr)\t(\t((ptr) [0] << 16) | ((ptr) [1] << 8) | ((ptr) [2]))\n\n#define\tGET_LE_INT(ptr)\t\t(\t((ptr) [3] << 24)\t| ((ptr) [2] << 16) |\t\\\n\t\t\t\t\t\t\t\t((ptr) [1] << 8)\t| ((ptr) [0]))\n\n#define\tGET_BE_INT(ptr)\t\t(\t((ptr) [0] << 24)\t| ((ptr) [1] << 16) |\t\\\n\t\t\t\t\t\t\t\t((ptr) [2] << 8)\t| ((ptr) [3]))\n\n#define\tGET_LE_8BYTE(ptr)\t(\t(((sf_count_t) (ptr) [7]) << 56)\t| (((sf_count_t) (ptr) [6]) << 48) |\t\\\n\t\t\t\t\t\t\t\t(((sf_count_t) (ptr) [5]) << 40)\t| (((sf_count_t) (ptr) [4]) << 32) |\t\\\n\t\t\t\t\t\t\t\t(((sf_count_t) (ptr) [3]) << 24)\t| (((sf_count_t) (ptr) [2]) << 16) |\t\\\n\t\t\t\t\t\t\t\t(((sf_count_t) (ptr) [1]) << 8)\t\t| ((ptr) [0]))\n\n#define\tGET_BE_8BYTE(ptr)\t(\t(((sf_count_t) (ptr) [0]) << 56)\t| (((sf_count_t) (ptr) [1]) << 48) |\t\\\n\t\t\t\t\t\t\t\t(((sf_count_t) (ptr) [2]) << 40)\t| (((sf_count_t) (ptr) [3]) << 32) |\t\\\n\t\t\t\t\t\t\t\t(((sf_count_t) (ptr) [4]) << 24)\t| (((sf_count_t) (ptr) [5]) << 16) |\t\\\n\t\t\t\t\t\t\t\t(((sf_count_t) (ptr) [6]) << 8)\t\t| ((ptr) [7]))\n\n\n\nstatic int\nheader_read (SF_PRIVATE *psf, void *ptr, int bytes)\n{\tint count = 0 ;\n\n\tif (psf->header.indx + bytes >= psf->header.len && psf_bump_header_allocation (psf, bytes))\n\t\treturn count ;\n\n\tif (psf->header.indx + bytes > psf->header.end)\n\t{\tcount = psf_fread (psf->header.ptr + psf->header.end, 1, bytes - (psf->header.end - psf->header.indx), psf) ;\n\t\tif (count != bytes - (int) (psf->header.end - psf->header.indx))\n\t\t{\tpsf_log_printf (psf, \"Error : psf_fread returned short count.\\n\") ;\n\t\t\treturn count ;\n\t\t\t} ;\n\t\tpsf->header.end += count ;\n\t\t} ;\n\n\tmemcpy (ptr, psf->header.ptr + psf->header.indx, bytes) ;\n\tpsf->header.indx += bytes ;\n\n\treturn bytes ;\n} /* header_read */\n\nstatic void\nheader_seek (SF_PRIVATE *psf, sf_count_t position, int whence)\n{\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\tif (psf->header.indx + position >= psf->header.len)\n\t\t\t\tpsf_bump_header_allocation (psf, position) ;\n\t\t\tif (position > psf->header.len)\n\t\t\t{\t/* Too much header to cache so just seek instead. */\n\t\t\t\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (position > psf->header.end)\n\t\t\t\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - psf->header.end, psf) ;\n\t\t\tpsf->header.indx = position ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_CUR :\n\t\t\tif (psf->header.indx + position >= psf->header.len)\n\t\t\t\tpsf_bump_header_allocation (psf, position) ;\n\n\t\t\tif (psf->header.indx + position < 0)\n\t\t\t\tbreak ;\n\n\t\t\tif (psf->header.indx >= psf->header.len)\n\t\t\t{\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->header.indx + position <= psf->header.end)\n\t\t\t{\tpsf->header.indx += position ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->header.indx + position > psf->header.len)\n\t\t\t{\t/* Need to jump this without caching it. */\n\t\t\t\tpsf->header.indx = psf->header.end ;\n\t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - (psf->header.end - psf->header.indx), psf) ;\n\t\t\tpsf->header.indx = psf->header.end ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad whence param in header_seek().\\n\") ;\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn ;\n} /* header_seek */\n\nstatic int\nheader_gets (SF_PRIVATE *psf, char *ptr, int bufsize)\n{\tint\t\tk ;\n\n\tif (psf->header.indx + bufsize >= psf->header.len && psf_bump_header_allocation (psf, bufsize))\n\t\treturn 0 ;\n\n\tfor (k = 0 ; k < bufsize - 1 ; k++)\n\t{\tif (psf->header.indx < psf->header.end)\n\t\t{\tptr [k] = psf->header.ptr [psf->header.indx] ;\n\t\t\tpsf->header.indx ++ ;\n\t\t\t}\n\t\telse\n\t\t{\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, 1, psf) ;\n\t\t\tptr [k] = psf->header.ptr [psf->header.indx] ;\n\t\t\tpsf->header.indx = psf->header.end ;\n\t\t\t} ;\n\n\t\tif (ptr [k] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\n\tptr [k] = 0 ;\n\n\treturn k ;\n} /* header_gets */\n\nint\npsf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)\n{\tva_list\t\t\targptr ;\n\tsf_count_t\t\t*countptr, countdata ;\n\tunsigned char\t*ucptr, sixteen_bytes [16] ;\n\tunsigned int \t*intptr, intdata ;\n\tunsigned short\t*shortptr ;\n\tchar\t\t\t*charptr ;\n\tfloat\t\t\t*floatptr ;\n\tdouble\t\t\t*doubleptr ;\n\tchar\t\t\tc ;\n\tint\t\t\t\tbyte_count = 0, count = 0 ;\n\n\tif (! format)\n\t\treturn psf_ftell (psf) ;\n\n\tva_start (argptr, format) ;\n\n\twhile ((c = *format++))\n\t{\n\t\tif (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))\n\t\t\treturn count ;\n\n\t\tswitch (c)\n\t\t{\tcase 'e' : /* All conversions are now from LE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_LITTLE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'E' : /* All conversions are now from BE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_BIG ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'm' : /* 4 byte marker value eg 'RIFF' */\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\t*intptr = 0 ;\n\t\t\t\t\tucptr = (unsigned char*) intptr ;\n\t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (int)) ;\n\t\t\t\t\t*intptr = GET_MARKER (ucptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'h' :\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\t*intptr = 0 ;\n\t\t\t\t\tucptr = (unsigned char*) intptr ;\n\t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, sizeof (sixteen_bytes)) ;\n\t\t\t\t\t{\tint k ;\n\t\t\t\t\t\tintdata = 0 ;\n\t\t\t\t\t\tfor (k = 0 ; k < 16 ; k++)\n\t\t\t\t\t\t\tintdata ^= sixteen_bytes [k] << k ;\n\t\t\t\t\t\t}\n\t\t\t\t\t*intptr = intdata ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '1' :\n\t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n\t\t\t\t\t*charptr = 0 ;\n\t\t\t\t\tbyte_count += header_read (psf, charptr, sizeof (char)) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '2' : /* 2 byte value with the current endian-ness */\n\t\t\t\t\tshortptr = va_arg (argptr, unsigned short*) ;\n\t\t\t\t\t*shortptr = 0 ;\n\t\t\t\t\tucptr = (unsigned char*) shortptr ;\n\t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (short)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*shortptr = GET_BE_SHORT (ucptr) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*shortptr = GET_LE_SHORT (ucptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '3' : /* 3 byte value with the current endian-ness */\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\t*intptr = 0 ;\n\t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, 3) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*intptr = GET_BE_3BYTE (sixteen_bytes) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*intptr = GET_LE_3BYTE (sixteen_bytes) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '4' : /* 4 byte value with the current endian-ness */\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\t*intptr = 0 ;\n\t\t\t\t\tucptr = (unsigned char*) intptr ;\n\t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (int)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*intptr = psf_get_be32 (ucptr, 0) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*intptr = psf_get_le32 (ucptr, 0) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '8' : /* 8 byte value with the current endian-ness */\n\t\t\t\t\tcountptr = va_arg (argptr, sf_count_t *) ;\n\t\t\t\t\t*countptr = 0 ;\n\t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, 8) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\tcountdata = psf_get_be64 (sixteen_bytes, 0) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tcountdata = psf_get_le64 (sixteen_bytes, 0) ;\n\t\t\t\t\t*countptr = countdata ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'f' : /* Float conversion */\n\t\t\t\t\tfloatptr = va_arg (argptr, float *) ;\n\t\t\t\t\t*floatptr = 0.0 ;\n\t\t\t\t\tbyte_count += header_read (psf, floatptr, sizeof (float)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*floatptr = float32_be_read ((unsigned char*) floatptr) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*floatptr = float32_le_read ((unsigned char*) floatptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'd' : /* double conversion */\n\t\t\t\t\tdoubleptr = va_arg (argptr, double *) ;\n\t\t\t\t\t*doubleptr = 0.0 ;\n\t\t\t\t\tbyte_count += header_read (psf, doubleptr, sizeof (double)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*doubleptr = double64_be_read ((unsigned char*) doubleptr) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*doubleptr = double64_le_read ((unsigned char*) doubleptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 's' :\n\t\t\t\t\tpsf_log_printf (psf, \"Format conversion 's' not implemented yet.\\n\") ;\n\t\t\t\t\t/*\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize   = strlen (strptr) + 1 ;\n\t\t\t\t\tsize  += (size & 1) ;\n\t\t\t\t\tlongdata = H2LE_32 (size) ;\n\t\t\t\t\tget_int (psf, longdata) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\t*/\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'b' : /* Raw bytes */\n\t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n\t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\tmemset (charptr, 0, count) ;\n\t\t\t\t\tbyte_count += header_read (psf, charptr, count) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'G' :\n\t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n\t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\tmemset (charptr, 0, count) ;\n\n\t\t\t\t\tif (psf->header.indx + count >= psf->header.len && psf_bump_header_allocation (psf, count))\n\t\t\t\t\t\treturn 0 ;\n\n\t\t\t\t\tbyte_count += header_gets (psf, charptr, count) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'z' :\n\t\t\t\t\tpsf_log_printf (psf, \"Format conversion 'z' not implemented yet.\\n\") ;\n\t\t\t\t\t/*\n\t\t\t\t\tsize    = va_arg (argptr, size_t) ;\n\t\t\t\t\twhile (size)\n\t\t\t\t\t{\tpsf->header.ptr [psf->header.indx] = 0 ;\n\t\t\t\t\t\tpsf->header.indx ++ ;\n\t\t\t\t\t\tsize -- ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\t*/\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'p' :\t/* Seek to position from start. */\n\t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\theader_seek (psf, count, SEEK_SET) ;\n\t\t\t\t\tbyte_count = count ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'j' :\t/* Seek to position from current position. */\n\t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\theader_seek (psf, count, SEEK_CUR) ;\n\t\t\t\t\tbyte_count += count ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\tpsf_log_printf (psf, \"*** Invalid format specifier `%c'\\n\", c) ;\n\t\t\t\tpsf->error = SFE_INTERNAL ;\n\t\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ;\n\n\tva_end (argptr) ;\n\n\treturn byte_count ;\n} /* psf_binheader_readf */\n\n/*-----------------------------------------------------------------------------------------------\n*/\n\nsf_count_t\npsf_default_seek (SF_PRIVATE *psf, int UNUSED (mode), sf_count_t samples_from_start)\n{\tsf_count_t position, retval ;\n\n\tif (! (psf->blockwidth && psf->dataoffset >= 0))\n\t{\tpsf->error = SFE_BAD_SEEK ;\n\t\treturn\tPSF_SEEK_ERROR ;\n\t\t} ;\n\n\tif (! psf->sf.seekable)\n\t{\tpsf->error = SFE_NOT_SEEKABLE ;\n\t\treturn\tPSF_SEEK_ERROR ;\n\t\t} ;\n\n\tposition = psf->dataoffset + psf->blockwidth * samples_from_start ;\n\n\tif ((retval = psf_fseek (psf, position, SEEK_SET)) != position)\n\t{\tpsf->error = SFE_SEEK_FAILED ;\n\t\treturn PSF_SEEK_ERROR ;\n\t\t} ;\n\n\treturn samples_from_start ;\n} /* psf_default_seek */\n\n/*-----------------------------------------------------------------------------------------------\n*/\n\nvoid\npsf_hexdump (const void *ptr, int len)\n{\tconst char *data ;\n\tchar\tascii [17] ;\n\tint\t\tk, m ;\n\n\tif ((data = ptr) == NULL)\n\t\treturn ;\n\tif (len <= 0)\n\t\treturn ;\n\n\tputs (\"\") ;\n\tfor (k = 0 ; k < len ; k += 16)\n\t{\tmemset (ascii, ' ', sizeof (ascii)) ;\n\n\t\tprintf (\"%08X: \", k) ;\n\t\tfor (m = 0 ; m < 16 && k + m < len ; m++)\n\t\t{\tprintf (m == 8 ? \" %02X \" : \"%02X \", data [k + m] & 0xFF) ;\n\t\t\tascii [m] = psf_isprint (data [k + m]) ? data [k + m] : '.' ;\n\t\t\t} ;\n\n\t\tif (m <= 8) printf (\" \") ;\n\t\tfor ( ; m < 16 ; m++) printf (\"   \") ;\n\n\t\tascii [16] = 0 ;\n\t\tprintf (\" %s\\n\", ascii) ;\n\t\t} ;\n\n\tputs (\"\") ;\n} /* psf_hexdump */\n\nvoid\npsf_log_SF_INFO (SF_PRIVATE *psf)\n{\tpsf_log_printf (psf, \"---------------------------------\\n\") ;\n\n\tpsf_log_printf (psf, \" Sample rate :   %d\\n\", psf->sf.samplerate) ;\n\tif (psf->sf.frames == SF_COUNT_MAX)\n\t\tpsf_log_printf (psf, \" Frames      :   unknown\\n\") ;\n\telse\n\t\tpsf_log_printf (psf, \" Frames      :   %D\\n\", psf->sf.frames) ;\n\tpsf_log_printf (psf, \" Channels    :   %d\\n\", psf->sf.channels) ;\n\n\tpsf_log_printf (psf, \" Format      :   0x%X\\n\", psf->sf.format) ;\n\tpsf_log_printf (psf, \" Sections    :   %d\\n\", psf->sf.sections) ;\n\tpsf_log_printf (psf, \" Seekable    :   %s\\n\", psf->sf.seekable ? \"TRUE\" : \"FALSE\") ;\n\n\tpsf_log_printf (psf, \"---------------------------------\\n\") ;\n} /* psf_dump_SFINFO */\n\n/*========================================================================================\n*/\n\nvoid*\npsf_memset (void *s, int c, sf_count_t len)\n{\tchar\t*ptr ;\n\tint \tsetcount ;\n\n\tptr = (char *) s ;\n\n\twhile (len > 0)\n\t{\tsetcount = (len > 0x10000000) ? 0x10000000 : (int) len ;\n\n\t\tmemset (ptr, c, setcount) ;\n\n\t\tptr += setcount ;\n\t\tlen -= setcount ;\n\t\t} ;\n\n\treturn s ;\n} /* psf_memset */\n\n\n/*\n** Clang refuses to do sizeof (SF_CUES_VAR (cue_count)) so we have to manually\n** bodgy something up instead.\n*/\n\ntypedef SF_CUES_VAR (1) SF_CUES_1 ;\ntypedef SF_CUES_VAR (2) SF_CUES_2 ;\n\n#define SF_CUES_VAR_SIZE(count)\t(sizeof (SF_CUES_1) + count * (sizeof (SF_CUES_2) - sizeof (SF_CUES_1)))\n\nSF_CUES *\npsf_cues_alloc (uint32_t cue_count)\n{\tSF_CUES *pcues = calloc (1, SF_CUES_VAR_SIZE (cue_count)) ;\n\n\tpcues->cue_count = cue_count ;\n\treturn pcues ;\n} /* psf_cues_alloc */\n\nSF_CUES *\npsf_cues_dup (const void * ptr)\n{\tconst SF_CUES *pcues = ptr ;\n\tSF_CUES *pnew = psf_cues_alloc (pcues->cue_count) ;\n\n\tmemcpy (pnew, pcues, SF_CUES_VAR_SIZE (pcues->cue_count)) ;\n\treturn pnew ;\n} /* psf_cues_dup */\n\nvoid\npsf_get_cues (SF_PRIVATE * psf, void * data, size_t datasize)\n{\n\tif (psf->cues)\n\t{\tuint32_t cue_count = (datasize - sizeof (uint32_t)) / sizeof (SF_CUE_POINT) ;\n\n\t\tcue_count = SF_MIN (cue_count, psf->cues->cue_count) ;\n\t\tmemcpy (data, psf->cues, SF_CUES_VAR_SIZE (cue_count)) ;\n\t\t((SF_CUES*) data)->cue_count = cue_count ;\n\t\t} ;\n\n\treturn ;\n} /* psf_get_cues */\n\n\nSF_INSTRUMENT *\npsf_instrument_alloc (void)\n{\tSF_INSTRUMENT *instr ;\n\n\tinstr = calloc (1, sizeof (SF_INSTRUMENT)) ;\n\n\tif (instr == NULL)\n\t\treturn NULL ;\n\n\t/* Set non-zero default values. */\n\tinstr->basenote = -1 ;\n\tinstr->velocity_lo = -1 ;\n\tinstr->velocity_hi = -1 ;\n\tinstr->key_lo = -1 ;\n\tinstr->key_hi = -1 ;\n\n\treturn instr ;\n} /* psf_instrument_alloc */\n\nvoid\npsf_sanitize_string (char * cptr, int len)\n{\n\tdo\n\t{\n\t\tlen -- ;\n\t\tcptr [len] = psf_isprint (cptr [len]) ? cptr [len] : '.' ;\n\t}\n\twhile (len > 0) ;\n} /* psf_sanitize_string */\n\nvoid\npsf_get_date_str (char *str, int maxlen)\n{\ttime_t\t\tcurrent ;\n\tstruct tm\ttimedata, *tmptr ;\n\n\ttime (&current) ;\n\n#if defined (HAVE_GMTIME_R)\n\t/* If the re-entrant version is available, use it. */\n\ttmptr = gmtime_r (&current, &timedata) ;\n#elif defined (HAVE_GMTIME)\n\t/* Otherwise use the standard one and copy the data to local storage. */\n\ttmptr = gmtime (&current) ;\n\tmemcpy (&timedata, tmptr, sizeof (timedata)) ;\n#else\n\ttmptr = NULL ;\n#endif\n\n\tif (tmptr)\n\t\tsnprintf (str, maxlen, \"%4d-%02d-%02d %02d:%02d:%02d UTC\",\n\t\t\t1900 + timedata.tm_year, timedata.tm_mon, timedata.tm_mday,\n\t\t\ttimedata.tm_hour, timedata.tm_min, timedata.tm_sec) ;\n\telse\n\t\tsnprintf (str, maxlen, \"Unknown date\") ;\n\n\treturn ;\n} /* psf_get_date_str */\n\nint\nsubformat_to_bytewidth (int format)\n{\n\tswitch (format)\n\t{\tcase SF_FORMAT_PCM_U8 :\n\t\tcase SF_FORMAT_PCM_S8 :\n\t\t\t\treturn 1 ;\n\t\tcase SF_FORMAT_PCM_16 :\n\t\t\t\treturn 2 ;\n\t\tcase SF_FORMAT_PCM_24 :\n\t\t\t\treturn 3 ;\n\t\tcase SF_FORMAT_PCM_32 :\n\t\tcase SF_FORMAT_FLOAT :\n\t\t\t\treturn 4 ;\n\t\tcase SF_FORMAT_DOUBLE :\n\t\t\t\treturn 8 ;\n\t\t} ;\n\n\treturn 0 ;\n} /* subformat_to_bytewidth */\n\nint\ns_bitwidth_to_subformat (int bits)\n{\tstatic int array [] =\n\t{\tSF_FORMAT_PCM_S8, SF_FORMAT_PCM_16, SF_FORMAT_PCM_24, SF_FORMAT_PCM_32\n\t\t} ;\n\n\tif (bits < 8 || bits > 32)\n\t\treturn 0 ;\n\n\treturn array [((bits + 7) / 8) - 1] ;\n} /* bitwidth_to_subformat */\n\nint\nu_bitwidth_to_subformat (int bits)\n{\tstatic int array [] =\n\t{\tSF_FORMAT_PCM_U8, SF_FORMAT_PCM_16, SF_FORMAT_PCM_24, SF_FORMAT_PCM_32\n\t\t} ;\n\n\tif (bits < 8 || bits > 32)\n\t\treturn 0 ;\n\n\treturn array [((bits + 7) / 8) - 1] ;\n} /* bitwidth_to_subformat */\n\n/*\n**\tpsf_rand_int32 : Not crypto quality, but more than adequate for things\n**\tlike stream serial numbers in Ogg files or the unique_id field of the\n**\tSF_PRIVATE struct.\n*/\n\nint32_t\npsf_rand_int32 (void)\n{\tstatic uint64_t value = 0 ;\n\tint k, count ;\n\n\tif (value == 0)\n\t{\n#if HAVE_GETTIMEOFDAY\n\t\tstruct timeval tv ;\n\t\tgettimeofday (&tv, NULL) ;\n\t\tvalue = tv.tv_sec + tv.tv_usec ;\n#else\n\t\tvalue = time (NULL) ;\n#endif\n\t\t} ;\n\n\tcount = 4 + (value & 7) ;\n\tfor (k = 0 ; k < count ; k++)\n\t\tvalue = (11117 * value + 211231) & 0x7fffffff ;\n\n\treturn (int32_t) value ;\n} /* psf_rand_int32 */\n\nvoid\nappend_snprintf (char * dest, size_t maxlen, const char * fmt, ...)\n{\tsize_t len = strlen (dest) ;\n\n\tif (len < maxlen)\n\t{\tva_list ap ;\n\n\t\tva_start (ap, fmt) ;\n\t\tvsnprintf (dest + len, maxlen - len, fmt, ap) ;\n\t\tva_end (ap) ;\n\t\t} ;\n\n\treturn ;\n} /* append_snprintf */\n\n\nvoid\npsf_strlcpy_crlf (char *dest, const char *src, size_t destmax, size_t srcmax)\n{\t/* Must be minus 2 so it can still expand a single trailing '\\n' or '\\r'. */\n\tchar * destend = dest + destmax - 2 ;\n\tconst char * srcend = src + srcmax ;\n\n\twhile (dest < destend && src < srcend)\n\t{\tif ((src [0] == '\\r' && src [1] == '\\n') || (src [0] == '\\n' && src [1] == '\\r'))\n\t\t{\t*dest++ = '\\r' ;\n\t\t\t*dest++ = '\\n' ;\n\t\t\tsrc += 2 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tif (src [0] == '\\r')\n\t\t{\t*dest++ = '\\r' ;\n\t\t\t*dest++ = '\\n' ;\n\t\t\tsrc += 1 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tif (src [0] == '\\n')\n\t\t{\t*dest++ = '\\r' ;\n\t\t\t*dest++ = '\\n' ;\n\t\t\tsrc += 1 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\t*dest++ = *src++ ;\n\t\t} ;\n\n\t/* Make sure dest is terminated. */\n\t*dest = 0 ;\n} /* psf_strlcpy_crlf */\n\nsf_count_t\npsf_decode_frame_count (SF_PRIVATE *psf)\n{\tsf_count_t count, readlen, total = 0 ;\n\tBUF_UNION\tubuf ;\n\n\t/* If we're reading from a pipe or the file is too long, just return SF_COUNT_MAX. */\n\tif (psf_is_pipe (psf) || psf->datalength > 0x1000000)\n\t\treturn SF_COUNT_MAX ;\n\n\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\n\treadlen = ARRAY_LEN (ubuf.ibuf) / psf->sf.channels ;\n\treadlen *= psf->sf.channels ;\n\n\twhile ((count = psf->read_int (psf, ubuf.ibuf, readlen)) > 0)\n\t\ttotal += count ;\n\n\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\n\treturn total / psf->sf.channels ;\n} /* psf_decode_frame_count */\n\n/*==============================================================================\n*/\n\n#define CASE_NAME(x)\t\tcase x : return #x ; break ;\n\nconst char *\nstr_of_major_format (int format)\n{\tswitch (SF_CONTAINER (format))\n\t{\tCASE_NAME (SF_FORMAT_WAV) ;\n\t\tCASE_NAME (SF_FORMAT_AIFF) ;\n\t\tCASE_NAME (SF_FORMAT_AU) ;\n\t\tCASE_NAME (SF_FORMAT_RAW) ;\n\t\tCASE_NAME (SF_FORMAT_PAF) ;\n\t\tCASE_NAME (SF_FORMAT_SVX) ;\n\t\tCASE_NAME (SF_FORMAT_NIST) ;\n\t\tCASE_NAME (SF_FORMAT_VOC) ;\n\t\tCASE_NAME (SF_FORMAT_IRCAM) ;\n\t\tCASE_NAME (SF_FORMAT_W64) ;\n\t\tCASE_NAME (SF_FORMAT_MAT4) ;\n\t\tCASE_NAME (SF_FORMAT_MAT5) ;\n\t\tCASE_NAME (SF_FORMAT_PVF) ;\n\t\tCASE_NAME (SF_FORMAT_XI) ;\n\t\tCASE_NAME (SF_FORMAT_HTK) ;\n\t\tCASE_NAME (SF_FORMAT_SDS) ;\n\t\tCASE_NAME (SF_FORMAT_AVR) ;\n\t\tCASE_NAME (SF_FORMAT_WAVEX) ;\n\t\tCASE_NAME (SF_FORMAT_SD2) ;\n\t\tCASE_NAME (SF_FORMAT_FLAC) ;\n\t\tCASE_NAME (SF_FORMAT_CAF) ;\n\t\tCASE_NAME (SF_FORMAT_WVE) ;\n\t\tCASE_NAME (SF_FORMAT_OGG) ;\n\t\tdefault :\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn \"BAD_MAJOR_FORMAT\" ;\n} /* str_of_major_format */\n\nconst char *\nstr_of_minor_format (int format)\n{\tswitch (SF_CODEC (format))\n\t{\tCASE_NAME (SF_FORMAT_PCM_S8) ;\n\t\tCASE_NAME (SF_FORMAT_PCM_16) ;\n\t\tCASE_NAME (SF_FORMAT_PCM_24) ;\n\t\tCASE_NAME (SF_FORMAT_PCM_32) ;\n\t\tCASE_NAME (SF_FORMAT_PCM_U8) ;\n\t\tCASE_NAME (SF_FORMAT_FLOAT) ;\n\t\tCASE_NAME (SF_FORMAT_DOUBLE) ;\n\t\tCASE_NAME (SF_FORMAT_ULAW) ;\n\t\tCASE_NAME (SF_FORMAT_ALAW) ;\n\t\tCASE_NAME (SF_FORMAT_IMA_ADPCM) ;\n\t\tCASE_NAME (SF_FORMAT_MS_ADPCM) ;\n\t\tCASE_NAME (SF_FORMAT_GSM610) ;\n\t\tCASE_NAME (SF_FORMAT_VOX_ADPCM) ;\n\t\tCASE_NAME (SF_FORMAT_G721_32) ;\n\t\tCASE_NAME (SF_FORMAT_G723_24) ;\n\t\tCASE_NAME (SF_FORMAT_G723_40) ;\n\t\tCASE_NAME (SF_FORMAT_DWVW_12) ;\n\t\tCASE_NAME (SF_FORMAT_DWVW_16) ;\n\t\tCASE_NAME (SF_FORMAT_DWVW_24) ;\n\t\tCASE_NAME (SF_FORMAT_DWVW_N) ;\n\t\tCASE_NAME (SF_FORMAT_DPCM_8) ;\n\t\tCASE_NAME (SF_FORMAT_DPCM_16) ;\n\t\tCASE_NAME (SF_FORMAT_VORBIS) ;\n\t\tdefault :\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn \"BAD_MINOR_FORMAT\" ;\n} /* str_of_minor_format */\n\nconst char *\nstr_of_open_mode (int mode)\n{\tswitch (mode)\n\t{\tCASE_NAME (SFM_READ) ;\n\t\tCASE_NAME (SFM_WRITE) ;\n\t\tCASE_NAME (SFM_RDWR) ;\n\n\t\tdefault :\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn \"BAD_MODE\" ;\n} /* str_of_open_mode */\n\nconst char *\nstr_of_endianness (int end)\n{\tswitch (end)\n\t{\tCASE_NAME (SF_ENDIAN_BIG) ;\n\t\tCASE_NAME (SF_ENDIAN_LITTLE) ;\n\t\tCASE_NAME (SF_ENDIAN_CPU) ;\n\t\tdefault :\n\t\t\tbreak ;\n\t\t} ;\n\n\t/* Zero length string for SF_ENDIAN_FILE. */\n\treturn \"\" ;\n} /* str_of_endianness */\n\n/*==============================================================================\n*/\n\nvoid\npsf_f2s_array (const float *src, short *dest, int count, int normalize)\n{\tfloat \t\t\tnormfact ;\n\n\tnormfact = normalize ? (1.0 * 0x7FFF) : 1.0 ;\n\twhile (--count >= 0)\n\t\tdest [count] = lrintf (src [count] * normfact) ;\n\n\treturn ;\n} /* psf_f2s_array */\n\nvoid\npsf_f2s_clip_array (const float *src, short *dest, int count, int normalize)\n{\tfloat\t\t\tnormfact, scaled_value ;\n\n\tnormfact = normalize ? (1.0 * 0x8000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFF))\n\t\t{\tdest [count] = 0x7FFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x1000))\n\t\t{\tdest [count] = 0x8000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tdest [count] = lrintf (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_f2s_clip_array */\n\nvoid\npsf_d2s_array (const double *src, short *dest, int count, int normalize)\n{\tdouble \t\t\tnormfact ;\n\n\tnormfact = normalize ? (1.0 * 0x7FFF) : 1.0 ;\n\twhile (--count >= 0)\n\t\tdest [count] = lrint (src [count] * normfact) ;\n\n\treturn ;\n} /* psf_f2s_array */\n\nvoid\npsf_d2s_clip_array (const double *src, short *dest, int count, int normalize)\n{\tdouble\t\t\tnormfact, scaled_value ;\n\n\tnormfact = normalize ? (1.0 * 0x8000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFF))\n\t\t{\tdest [count] = 0x7FFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x1000))\n\t\t{\tdest [count] = 0x8000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_d2s_clip_array */\n\n\nvoid\npsf_f2i_array (const float *src, int *dest, int count, int normalize)\n{\tfloat \t\t\tnormfact ;\n\n\tnormfact = normalize ? (1.0 * 0x7FFFFFFF) : 1.0 ;\n\twhile (--count >= 0)\n\t\tdest [count] = lrintf (src [count] * normfact) ;\n\n\treturn ;\n} /* psf_f2i_array */\n\nvoid\npsf_f2i_clip_array (const float *src, int *dest, int count, int normalize)\n{\tfloat\t\t\tnormfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x10000000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFFFF))\n\t\t{\tdest [count] = 0x7FFFFFFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10000000))\n\t\t{\tdest [count] = 0x80000000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tdest [count] = lrintf (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_f2i_clip_array */\n\nvoid\npsf_d2i_array (const double *src, int *dest, int count, int normalize)\n{\tdouble \t\t\tnormfact ;\n\n\tnormfact = normalize ? (1.0 * 0x7FFFFFFF) : 1.0 ;\n\twhile (--count >= 0)\n\t\tdest [count] = lrint (src [count] * normfact) ;\n\n\treturn ;\n} /* psf_f2i_array */\n\nvoid\npsf_d2i_clip_array (const double *src, int *dest, int count, int normalize)\n{\tdouble\t\t\tnormfact, scaled_value ;\n\n\tnormfact = normalize ? (8.0 * 0x10000000) : 1.0 ;\n\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFFFF))\n\t\t{\tdest [count] = 0x7FFFFFFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10000000))\n\t\t{\tdest [count] = 0x80000000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\n\treturn ;\n} /* psf_d2i_clip_array */\n\nFILE *\npsf_open_tmpfile (char * fname, size_t fnamelen)\n{\tconst char * tmpdir ;\n\tFILE * file ;\n\n\tif (OS_IS_WIN32)\n\t\ttmpdir = getenv (\"TEMP\") ;\n\telse\n\t{\ttmpdir = getenv (\"TMPDIR\") ;\n\t\ttmpdir = tmpdir == NULL ? \"/tmp\" : tmpdir ;\n\t\t} ;\n\n\tif (tmpdir && access (tmpdir, R_OK | W_OK | X_OK) == 0)\n\t{\tsnprintf (fname, fnamelen, \"%s/%x%x-alac.tmp\", tmpdir, psf_rand_int32 (), psf_rand_int32 ()) ;\n\t\tif ((file = fopen (fname, \"wb+\")) != NULL)\n\t\t\treturn file ;\n\t\t} ;\n\n\tsnprintf (fname, fnamelen, \"%x%x-alac.tmp\", psf_rand_int32 (), psf_rand_int32 ()) ;\n\tif ((file = fopen (fname, \"wb+\")) != NULL)\n\t\treturn file ;\n\n\tmemset (fname, 0, fnamelen) ;\n\treturn NULL ;\n} /* psf_open_tmpfile */\n", "/*\n** Copyright (C) 1999-2016 Erik de Castro Lopo <erikd@mega-nerd.com>\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n#ifndef SNDFILE_COMMON_H\n#define SNDFILE_COMMON_H\n\n#include \"sfconfig.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#if HAVE_STDINT_H\n#include <stdint.h>\n#elif HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n#if HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n#ifndef SNDFILE_H\n#include \"sndfile.h\"\n#endif\n\n#ifdef __cplusplus\n#error \"This code is not designed to be compiled with a C++ compiler.\"\n#endif\n\n#ifdef INT64_C\n#\tdefine\tSF_PLATFORM_S64(x)\t\tINT64_C(x)\n#elif (SIZEOF_LONG == 8)\n#\tdefine\tSF_PLATFORM_S64(x)\t\tx##l\n#elif (SIZEOF_LONG_LONG == 8)\n#\tdefine\tSF_PLATFORM_S64(x)\t\tx##ll\n#elif COMPILER_IS_GCC\n#\tdefine\tSF_PLATFORM_S64(x)\t\tx##ll\n#elif OS_IS_WIN32\n#\tdefine\tSF_PLATFORM_S64(x)\t\tx##I64\n#else\n#\terror \"Don't know how to define a 64 bit integer constant.\"\n#endif\n\n\n\n/*\n** Inspiration : http://sourcefrog.net/weblog/software/languages/C/unused.html\n*/\n#ifdef UNUSED\n#elif defined (__GNUC__)\n#\tdefine UNUSED(x) UNUSED_ ## x __attribute__ ((unused))\n#elif defined (__LCLINT__)\n#\tdefine UNUSED(x) /*@unused@*/ x\n#else\n#\tdefine UNUSED(x) x\n#endif\n\n#ifdef __GNUC__\n#\tdefine WARN_UNUSED\t__attribute__ ((warn_unused_result))\n#else\n#\tdefine WARN_UNUSED\n#endif\n\n#define\tSF_BUFFER_LEN\t\t\t(8192)\n#define\tSF_FILENAME_LEN\t\t\t(1024)\n#define SF_SYSERR_LEN\t\t\t(256)\n#define SF_MAX_STRINGS\t\t\t(32)\n#define\tSF_PARSELOG_LEN\t\t\t(2048)\n\n#define\tPSF_SEEK_ERROR\t\t\t((sf_count_t) -1)\n\n#define\tBITWIDTH2BYTES(x)\t(((x) + 7) / 8)\n\n/*\tFor some reason sizeof returns an unsigned  value which causes\n**\ta warning when that value is added or subtracted from a signed\n**\tvalue. Use SIGNED_SIZEOF instead.\n*/\n#define\t\tSIGNED_SIZEOF(x)\t((int) sizeof (x))\n\n#define\t\tARRAY_LEN(x)\t((int) (sizeof (x) / sizeof ((x) [0])))\n\n#define\t\tNOT(x)\t\t\t(! (x))\n\n#if COMPILER_IS_GCC\n#define\t\tSF_MAX(x, y)\t({ \\\n\t\t\t\t\t\t\t\ttypeof (x) sf_max_x1 = (x) ; \\\n\t\t\t\t\t\t\t\ttypeof (y) sf_max_y1 = (y) ; \\\n\t\t\t\t\t\t\t\t(void) (&sf_max_x1 == &sf_max_y1) ; \\\n\t\t\t\t\t\t\t\tsf_max_x1 > sf_max_y1 ? sf_max_x1 : sf_max_y1 ; })\n\n#define\t\tSF_MIN(x, y)\t({ \\\n\t\t\t\t\t\t\t\ttypeof (x) sf_min_x2 = (x) ; \\\n\t\t\t\t\t\t\t\ttypeof (y) sf_min_y2 = (y) ; \\\n\t\t\t\t\t\t\t\t(void) (&sf_min_x2 == &sf_min_y2) ; \\\n\t\t\t\t\t\t\t\tsf_min_x2 < sf_min_y2 ? sf_min_x2 : sf_min_y2 ; })\n#else\n#define\t\tSF_MAX(a, b)\t((a) > (b) ? (a) : (b))\n#define\t\tSF_MIN(a, b)\t((a) < (b) ? (a) : (b))\n#endif\n\n\n#define\t\tCOMPILE_TIME_ASSERT(e)\t(sizeof (struct { int : - !! (e) ; }))\n\n\n#define\t\tSF_MAX_CHANNELS\t\t1024\n\n\n/*\n*\tMacros for spliting the format file of SF_INFO into container type,\n**\tcodec type and endian-ness.\n*/\n#define SF_CONTAINER(x)\t\t((x) & SF_FORMAT_TYPEMASK)\n#define SF_CODEC(x)\t\t\t((x) & SF_FORMAT_SUBMASK)\n#define SF_ENDIAN(x)\t\t((x) & SF_FORMAT_ENDMASK)\n\nenum\n{\t/* PEAK chunk location. */\n\tSF_PEAK_START\t\t= 42,\n\tSF_PEAK_END\t\t\t= 43,\n\n\t/* PEAK chunk location. */\n\tSF_SCALE_MAX\t\t= 52,\n\tSF_SCALE_MIN\t\t= 53,\n\n\t/* str_flags values. */\n\tSF_STR_ALLOW_START\t= 0x0100,\n\tSF_STR_ALLOW_END\t= 0x0200,\n\n\t/* Location of strings. */\n\tSF_STR_LOCATE_START\t= 0x0400,\n\tSF_STR_LOCATE_END\t= 0x0800,\n\n\tSFD_TYPEMASK\t\t= 0x0FFFFFFF\n} ;\n\n#define\t\tSFM_MASK \t(SFM_READ | SFM_WRITE | SFM_RDWR)\n#define\t\tSFM_UNMASK \t(~SFM_MASK)\n\n/*---------------------------------------------------------------------------------------\n** Formats that may be supported at some time in the future.\n** When support is finalised, these values move to src/sndfile.h.\n*/\n\nenum\n{\t/* Work in progress. */\n\tSF_FORMAT_SPEEX\t\t\t= 0x5000000,\n\tSF_FORMAT_OGGFLAC\t\t= 0x5000001,\n\n\t/* Formats supported read only. */\n\tSF_FORMAT_TXW\t\t\t= 0x4030000,\t\t/* Yamaha TX16 sampler file */\n\tSF_FORMAT_DWD\t\t\t= 0x4040000,\t\t/* DiamondWare Digirized */\n\n\t/* Following are detected but not supported. */\n\tSF_FORMAT_REX\t\t\t= 0x40A0000,\t\t/* Propellorheads Rex/Rcy */\n\tSF_FORMAT_REX2\t\t\t= 0x40D0000,\t\t/* Propellorheads Rex2 */\n\tSF_FORMAT_KRZ\t\t\t= 0x40E0000,\t\t/* Kurzweil sampler file */\n\tSF_FORMAT_WMA\t\t\t= 0x4100000,\t\t/* Windows Media Audio. */\n\tSF_FORMAT_SHN\t\t\t= 0x4110000,\t\t/* Shorten. */\n\n\t/* Unsupported encodings. */\n\tSF_FORMAT_SVX_FIB\t\t= 0x1020, \t\t/* SVX Fibonacci Delta encoding. */\n\tSF_FORMAT_SVX_EXP\t\t= 0x1021, \t\t/* SVX Exponential Delta encoding. */\n\n\tSF_FORMAT_PCM_N\t\t\t= 0x1030\n} ;\n\n/*---------------------------------------------------------------------------------------\n*/\n\ntypedef struct\n{\tunsigned\tkuki_offset ;\n\tunsigned\tpakt_offset ;\n\n\tunsigned\tbits_per_sample ;\n\tunsigned\tframes_per_packet ;\n\n\tint64_t \tpackets ;\n\tint64_t \tvalid_frames ;\n\tint32_t \tpriming_frames ;\n\tint32_t \tremainder_frames ;\n} ALAC_DECODER_INFO ;\n\n/*---------------------------------------------------------------------------------------\n**\tPEAK_CHUNK - This chunk type is common to both AIFF and WAVE files although their\n**\tendian encodings are different.\n*/\n\ntypedef struct\n{\tdouble\t\tvalue ;\t\t/* signed value of peak */\n\tsf_count_t\tposition ;\t/* the sample frame for the peak */\n} PEAK_POS ;\n\ntypedef struct\n{\t/* libsndfile internal : write a PEAK chunk at the start or end of the file? */\n\tint\t\t\t\tpeak_loc ;\n\n\t/* WAV/AIFF */\n\tunsigned int\tversion ;\t/* version of the PEAK chunk */\n\tunsigned int\ttimestamp ;\t/* secs since 1/1/1970  */\n\n\t/* CAF */\n\tunsigned int\tedit_number ;\n\n\t/* the per channel peak info */\n\tPEAK_POS\t\tpeaks [] ;\n} PEAK_INFO ;\n\nstatic inline PEAK_INFO *\npeak_info_calloc (int channels)\n{\treturn calloc (1, sizeof (PEAK_INFO) + channels * sizeof (PEAK_POS)) ;\n} /* peak_info_calloc */\n\ntypedef struct\n{\tint\t\ttype ;\n\tint\t\tflags ;\n\tsize_t \toffset ;\n} STR_DATA ;\n\ntypedef struct\n{\tuint64_t\thash ;\n\tchar\t\tid [64] ;\n\tunsigned\tid_size ;\n\tuint32_t\tmark32 ;\n\tsf_count_t\toffset ;\n\tuint32_t\tlen ;\n} READ_CHUNK ;\n\ntypedef struct\n{\tuint64_t\thash ;\n\tuint32_t\tmark32 ;\n\tuint32_t\tlen ;\n\tvoid\t\t*data ;\n} WRITE_CHUNK ;\n\ntypedef struct\n{\tuint32_t\tcount ;\n\tuint32_t\tused ;\n\tREAD_CHUNK\t*chunks ;\n} READ_CHUNKS ;\ntypedef struct\n{\tuint32_t\tcount ;\n\tuint32_t\tused ;\n\tWRITE_CHUNK\t*chunks ;\n} WRITE_CHUNKS ;\n\nstruct SF_CHUNK_ITERATOR\n{\tuint32_t\tcurrent ;\n\tint64_t\t\thash ;\n\tchar\t\tid [64] ;\n\tunsigned\tid_size ;\n\tSNDFILE\t\t*sndfile ;\n} ;\n\nstatic inline size_t\nmake_size_t (int x)\n{\treturn (size_t) x ;\n} /* make_size_t */\n\nstatic inline uint64_t\nmake_size_8 (int x)\n{\treturn (uint64_t) x ;\n} /* make_size_8 */\n\ntypedef SF_BROADCAST_INFO_VAR (16 * 1024) SF_BROADCAST_INFO_16K ;\n\ntypedef SF_CART_INFO_VAR (16 * 1024) SF_CART_INFO_16K ;\n\n#if SIZEOF_WCHAR_T == 2\ntypedef wchar_t\tsfwchar_t ;\n#else\ntypedef int16_t sfwchar_t ;\n#endif\n\n\nstatic inline void *\npsf_memdup (const void *src, size_t n)\n{\tvoid * mem = calloc (1, n & 3 ? n + 4 - (n & 3) : n) ;\n\treturn memcpy (mem, src, n) ;\n} /* psf_memdup */\n\n/*\n**\tThis version of isprint specifically ignores any locale info. Its used for\n**\tdetermining which characters can be printed in things like hexdumps.\n*/\nstatic inline int\npsf_isprint (int ch)\n{\treturn (ch >= ' ' && ch <= '~') ;\n} /* psf_isprint */\n\n/*=======================================================================================\n**\tSF_PRIVATE stuct - a pointer to this struct is passed back to the caller of the\n**\tsf_open_XXXX functions. The caller however has no knowledge of the struct's\n**\tcontents.\n*/\n\ntypedef struct\n{\n\tunion\n\t{\tchar\t\tc [SF_FILENAME_LEN] ;\n\t\tsfwchar_t\twc [SF_FILENAME_LEN] ;\n\t} path ;\n\n\tunion\n\t{\tchar\t\tc [SF_FILENAME_LEN] ;\n\t\tsfwchar_t\twc [SF_FILENAME_LEN] ;\n\t} dir ;\n\n\tunion\n\t{\tchar\t\tc [SF_FILENAME_LEN / 4] ;\n\t\tsfwchar_t\twc [SF_FILENAME_LEN / 4] ;\n\t} name ;\n\n#if USE_WINDOWS_API\n\t/*\n\t**\tThese fields can only be used in src/file_io.c.\n\t**\tThey are basically the same as a windows file HANDLE.\n\t*/\n\tvoid \t\t\t*handle, *hsaved ;\n\n\tint\t\t\t\tuse_wchar ;\n#else\n\t/* These fields can only be used in src/file_io.c. */\n\tint \t\t\tfiledes, savedes ;\n#endif\n\n\tint\t\t\t\tdo_not_close_descriptor ;\n\tint\t\t\t\tmode ;\t\t\t/* Open mode : SFM_READ, SFM_WRITE or SFM_RDWR. */\n} PSF_FILE ;\n\n\n\ntypedef union\n{\tdouble\t\t\tdbuf\t[SF_BUFFER_LEN / sizeof (double)] ;\n#if (defined (SIZEOF_INT64_T) && (SIZEOF_INT64_T == 8))\n\tint64_t\t\t\tlbuf\t[SF_BUFFER_LEN / sizeof (int64_t)] ;\n#else\n\tlong\t\t\tlbuf\t[SF_BUFFER_LEN / sizeof (double)] ;\n#endif\n\tfloat\t\t\tfbuf\t[SF_BUFFER_LEN / sizeof (float)] ;\n\tint\t\t\t\tibuf\t[SF_BUFFER_LEN / sizeof (int)] ;\n\tshort\t\t\tsbuf\t[SF_BUFFER_LEN / sizeof (short)] ;\n\tchar\t\t\tcbuf\t[SF_BUFFER_LEN / sizeof (char)] ;\n\tsigned char\t\tscbuf\t[SF_BUFFER_LEN / sizeof (signed char)] ;\n\tunsigned char\tucbuf\t[SF_BUFFER_LEN / sizeof (signed char)] ;\n} BUF_UNION ;\n\n\n\ntypedef struct sf_private_tag\n{\n\t/* Canary in a coal mine. */\n\tunion\n\t{\t/* Place a double here to encourage double alignment. */\n\t\tdouble d [2] ;\n\t\tchar c [16] ;\n\t\t} canary ;\n\n\tPSF_FILE\t\tfile, rsrc ;\n\n\tchar\t\t\tsyserr\t\t[SF_SYSERR_LEN] ;\n\n\t/* parselog and indx should only be changed within the logging functions\n\t** of common.c\n\t*/\n\tstruct\n\t{\tchar\t\t\tbuf\t[SF_PARSELOG_LEN] ;\n\t\tint\t\t\t\tindx ;\n\t} parselog ;\n\n\n\tstruct\n\t{\tunsigned char\t* ptr ;\n\t\tsf_count_t\t\tindx, end, len ;\n\t} header ;\n\n\tint\t\t\t\trwf_endian ;\t/* Header endian-ness flag. */\n\n\t/* Storage and housekeeping data for adding/reading strings from\n\t** sound files.\n\t*/\n\tstruct\n\t{\tSTR_DATA\tdata [SF_MAX_STRINGS] ;\n\t\tchar\t\t*storage ;\n\t\tsize_t\t\tstorage_len ;\n\t\tsize_t\t\tstorage_used ;\n\t\tuint32_t\tflags ;\n\t} strings ;\n\n\t/* Guard value. If this changes the buffers above have overflowed. */\n\tint\t\t\t\tMagick ;\n\n\tunsigned\t\tunique_id ;\n\n\tint\t\t\t\terror ;\n\n\tint\t\t\t\tendian ;\t\t/* File endianness : SF_ENDIAN_LITTLE or SF_ENDIAN_BIG. */\n\tint\t\t\t\tdata_endswap ;\t/* Need to endswap data? */\n\n\t/*\n\t** Maximum float value for calculating the multiplier for\n\t** float/double to short/int conversions.\n\t*/\n\tint\t\t\t\tfloat_int_mult ;\n\tfloat\t\t\tfloat_max ;\n\n\tint\t\t\t\tscale_int_float ;\n\n\t/* Vairables for handling pipes. */\n\tint\t\t\t\tis_pipe ;\t\t/* True if file is a pipe. */\n\tsf_count_t\t\tpipeoffset ;\t/* Number of bytes read from a pipe. */\n\n\t/* True if clipping must be performed on float->int conversions. */\n\tint\t\t\t\tadd_clipping ;\n\n\tSF_INFO\t\t\tsf ;\n\n\tint\t\t\t\thave_written ;\t/* Has a single write been done to the file? */\n\tPEAK_INFO\t\t*peak_info ;\n\n\t/* Cue Marker Info */\n\tSF_CUES\t\t*cues ;\n\n\t/* Loop Info */\n\tSF_LOOP_INFO\t*loop_info ;\n\tSF_INSTRUMENT\t*instrument ;\n\n\t/* Broadcast (EBU) Info */\n\tSF_BROADCAST_INFO_16K *broadcast_16k ;\n\n\t/* Cart (AES46) Info */\n\tSF_CART_INFO_16K *cart_16k ;\n\n\t/* Channel map data (if present) : an array of ints. */\n\tint\t\t\t\t*channel_map ;\n\n\tsf_count_t\t\tfilelength ;\t/* Overall length of (embedded) file. */\n\tsf_count_t\t\tfileoffset ;\t/* Offset in number of bytes from beginning of file. */\n\n\tsf_count_t\t\trsrclength ;\t/* Length of the resource fork (if it exists). */\n\n\tsf_count_t\t\tdataoffset ;\t/* Offset in number of bytes from beginning of file. */\n\tsf_count_t\t\tdatalength ;\t/* Length in bytes of the audio data. */\n\tsf_count_t\t\tdataend ;\t\t/* Offset to file tailer. */\n\n\tint\t\t\t\tblockwidth ;\t/* Size in bytes of one set of interleaved samples. */\n\tint\t\t\t\tbytewidth ;\t\t/* Size in bytes of one sample (one channel). */\n\n\tvoid\t\t\t*dither ;\n\tvoid\t\t\t*interleave ;\n\n\tint\t\t\t\tlast_op ;\t\t/* Last operation; either SFM_READ or SFM_WRITE */\n\tsf_count_t\t\tread_current ;\n\tsf_count_t\t\twrite_current ;\n\n\tvoid\t\t\t*container_data ;\t/*\tThis is a pointer to dynamically allocated file\n\t\t\t\t\t\t\t\t\t\t**\tcontainer format specific data.\n\t\t\t\t\t\t\t\t\t\t*/\n\n\tvoid\t\t\t*codec_data ;\t\t/*\tThis is a pointer to dynamically allocated file\n\t\t\t\t\t\t\t\t\t\t**\tcodec format specific data.\n\t\t\t\t\t\t\t\t\t\t*/\n\n\tSF_DITHER_INFO\twrite_dither ;\n\tSF_DITHER_INFO\tread_dither ;\n\n\tint\t\t\t\tnorm_double ;\n\tint\t\t\t\tnorm_float ;\n\n\tint\t\t\t\tauto_header ;\n\n\tint\t\t\t\tieee_replace ;\n\n\t/* A set of file specific function pointers */\n\tsf_count_t\t\t(*read_short)\t(struct sf_private_tag*, short *ptr, sf_count_t len) ;\n\tsf_count_t\t\t(*read_int)\t\t(struct sf_private_tag*, int *ptr, sf_count_t len) ;\n\tsf_count_t\t\t(*read_float)\t(struct sf_private_tag*, float *ptr, sf_count_t len) ;\n\tsf_count_t\t\t(*read_double)\t(struct sf_private_tag*, double *ptr, sf_count_t len) ;\n\n\tsf_count_t\t\t(*write_short)\t(struct sf_private_tag*, const short *ptr, sf_count_t len) ;\n\tsf_count_t\t\t(*write_int)\t(struct sf_private_tag*, const int *ptr, sf_count_t len) ;\n\tsf_count_t\t\t(*write_float)\t(struct sf_private_tag*, const float *ptr, sf_count_t len) ;\n\tsf_count_t\t\t(*write_double)\t(struct sf_private_tag*, const double *ptr, sf_count_t len) ;\n\n\tsf_count_t\t\t(*seek) \t\t(struct sf_private_tag*, int mode, sf_count_t samples_from_start) ;\n\tint\t\t\t\t(*write_header)\t(struct sf_private_tag*, int calc_length) ;\n\tint\t\t\t\t(*command)\t\t(struct sf_private_tag*, int command, void *data, int datasize) ;\n\tint\t\t\t\t(*byterate)\t\t(struct sf_private_tag*) ;\n\n\t/*\n\t**\tSeparate close functions for the codec and the container.\n\t**\tThe codec close function is always called first.\n\t*/\n\tint\t\t\t\t(*codec_close)\t\t(struct sf_private_tag*) ;\n\tint\t\t\t\t(*container_close)\t(struct sf_private_tag*) ;\n\n\tchar\t\t\t*format_desc ;\n\n\t/* Virtual I/O functions. */\n\tint\t\t\t\t\tvirtual_io ;\n\tSF_VIRTUAL_IO\t\tvio ;\n\tvoid\t\t\t\t*vio_user_data ;\n\n\t/* Chunk get/set. */\n\tSF_CHUNK_ITERATOR\t*iterator ;\n\n\tREAD_CHUNKS\t\t\trchunks ;\n\tWRITE_CHUNKS\t\twchunks ;\n\n\tint\t\t\t\t\t(*set_chunk)\t\t(struct sf_private_tag*, const SF_CHUNK_INFO * chunk_info) ;\n\tSF_CHUNK_ITERATOR *\t(*next_chunk_iterator)\t(struct sf_private_tag*, SF_CHUNK_ITERATOR * iterator) ;\n\tint\t\t\t\t\t(*get_chunk_size)\t(struct sf_private_tag*, const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info) ;\n\tint\t\t\t\t\t(*get_chunk_data)\t(struct sf_private_tag*, const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info) ;\n} SF_PRIVATE ;\n\n\n\nenum\n{\tSFE_NO_ERROR\t\t\t\t= SF_ERR_NO_ERROR,\n\tSFE_BAD_OPEN_FORMAT\t\t\t= SF_ERR_UNRECOGNISED_FORMAT,\n\tSFE_SYSTEM\t\t\t\t\t= SF_ERR_SYSTEM,\n\tSFE_MALFORMED_FILE\t\t\t= SF_ERR_MALFORMED_FILE,\n\tSFE_UNSUPPORTED_ENCODING\t= SF_ERR_UNSUPPORTED_ENCODING,\n\n\tSFE_ZERO_MAJOR_FORMAT,\n\tSFE_ZERO_MINOR_FORMAT,\n\tSFE_BAD_FILE,\n\tSFE_BAD_FILE_READ,\n\tSFE_OPEN_FAILED,\n\tSFE_BAD_SNDFILE_PTR,\n\tSFE_BAD_SF_INFO_PTR,\n\tSFE_BAD_SF_INCOMPLETE,\n\tSFE_BAD_FILE_PTR,\n\tSFE_BAD_INT_PTR,\n\tSFE_BAD_STAT_SIZE,\n\tSFE_NO_TEMP_DIR,\n\tSFE_MALLOC_FAILED,\n\tSFE_UNIMPLEMENTED,\n\tSFE_BAD_READ_ALIGN,\n\tSFE_BAD_WRITE_ALIGN,\n\tSFE_UNKNOWN_FORMAT,\n\tSFE_NOT_READMODE,\n\tSFE_NOT_WRITEMODE,\n\tSFE_BAD_MODE_RW,\n\tSFE_BAD_SF_INFO,\n\tSFE_BAD_OFFSET,\n\tSFE_NO_EMBED_SUPPORT,\n\tSFE_NO_EMBEDDED_RDWR,\n\tSFE_NO_PIPE_WRITE,\n\n\tSFE_INTERNAL,\n\tSFE_BAD_COMMAND_PARAM,\n\tSFE_BAD_ENDIAN,\n\tSFE_CHANNEL_COUNT_ZERO,\n\tSFE_CHANNEL_COUNT,\n\tSFE_CHANNEL_COUNT_BAD,\n\n\tSFE_BAD_VIRTUAL_IO,\n\n\tSFE_INTERLEAVE_MODE,\n\tSFE_INTERLEAVE_SEEK,\n\tSFE_INTERLEAVE_READ,\n\n\tSFE_BAD_SEEK,\n\tSFE_NOT_SEEKABLE,\n\tSFE_AMBIGUOUS_SEEK,\n\tSFE_WRONG_SEEK,\n\tSFE_SEEK_FAILED,\n\n\tSFE_BAD_OPEN_MODE,\n\tSFE_OPEN_PIPE_RDWR,\n\tSFE_RDWR_POSITION,\n\tSFE_RDWR_BAD_HEADER,\n\tSFE_CMD_HAS_DATA,\n\tSFE_BAD_BROADCAST_INFO_SIZE,\n\tSFE_BAD_BROADCAST_INFO_TOO_BIG,\n\tSFE_BAD_CART_INFO_SIZE,\n\tSFE_BAD_CART_INFO_TOO_BIG,\n\n\tSFE_STR_NO_SUPPORT,\n\tSFE_STR_NOT_WRITE,\n\tSFE_STR_MAX_DATA,\n\tSFE_STR_MAX_COUNT,\n\tSFE_STR_BAD_TYPE,\n\tSFE_STR_NO_ADD_END,\n\tSFE_STR_BAD_STRING,\n\tSFE_STR_WEIRD,\n\n\tSFE_WAV_NO_RIFF,\n\tSFE_WAV_NO_WAVE,\n\tSFE_WAV_NO_FMT,\n\tSFE_WAV_BAD_FMT,\n\tSFE_WAV_FMT_SHORT,\n\tSFE_WAV_BAD_FACT,\n\tSFE_WAV_BAD_PEAK,\n\tSFE_WAV_PEAK_B4_FMT,\n\tSFE_WAV_BAD_FORMAT,\n\tSFE_WAV_BAD_BLOCKALIGN,\n\tSFE_WAV_NO_DATA,\n\tSFE_WAV_BAD_LIST,\n\tSFE_WAV_ADPCM_NOT4BIT,\n\tSFE_WAV_ADPCM_CHANNELS,\n\tSFE_WAV_ADPCM_SAMPLES,\n\tSFE_WAV_GSM610_FORMAT,\n\tSFE_WAV_UNKNOWN_CHUNK,\n\tSFE_WAV_WVPK_DATA,\n\n\tSFE_AIFF_NO_FORM,\n\tSFE_AIFF_AIFF_NO_FORM,\n\tSFE_AIFF_COMM_NO_FORM,\n\tSFE_AIFF_SSND_NO_COMM,\n\tSFE_AIFF_UNKNOWN_CHUNK,\n\tSFE_AIFF_COMM_CHUNK_SIZE,\n\tSFE_AIFF_BAD_COMM_CHUNK,\n\tSFE_AIFF_PEAK_B4_COMM,\n\tSFE_AIFF_BAD_PEAK,\n\tSFE_AIFF_NO_SSND,\n\tSFE_AIFF_NO_DATA,\n\tSFE_AIFF_RW_SSND_NOT_LAST,\n\n\tSFE_AU_UNKNOWN_FORMAT,\n\tSFE_AU_NO_DOTSND,\n\tSFE_AU_EMBED_BAD_LEN,\n\n\tSFE_RAW_READ_BAD_SPEC,\n\tSFE_RAW_BAD_BITWIDTH,\n\tSFE_RAW_BAD_FORMAT,\n\n\tSFE_PAF_NO_MARKER,\n\tSFE_PAF_VERSION,\n\tSFE_PAF_UNKNOWN_FORMAT,\n\tSFE_PAF_SHORT_HEADER,\n\tSFE_PAF_BAD_CHANNELS,\n\n\tSFE_SVX_NO_FORM,\n\tSFE_SVX_NO_BODY,\n\tSFE_SVX_NO_DATA,\n\tSFE_SVX_BAD_COMP,\n\tSFE_SVX_BAD_NAME_LENGTH,\n\n\tSFE_NIST_BAD_HEADER,\n\tSFE_NIST_CRLF_CONVERISON,\n\tSFE_NIST_BAD_ENCODING,\n\n\tSFE_VOC_NO_CREATIVE,\n\tSFE_VOC_BAD_FORMAT,\n\tSFE_VOC_BAD_VERSION,\n\tSFE_VOC_BAD_MARKER,\n\tSFE_VOC_BAD_SECTIONS,\n\tSFE_VOC_MULTI_SAMPLERATE,\n\tSFE_VOC_MULTI_SECTION,\n\tSFE_VOC_MULTI_PARAM,\n\tSFE_VOC_SECTION_COUNT,\n\tSFE_VOC_NO_PIPE,\n\n\tSFE_IRCAM_NO_MARKER,\n\tSFE_IRCAM_BAD_CHANNELS,\n\tSFE_IRCAM_UNKNOWN_FORMAT,\n\n\tSFE_W64_64_BIT,\n\tSFE_W64_NO_RIFF,\n\tSFE_W64_NO_WAVE,\n\tSFE_W64_NO_DATA,\n\tSFE_W64_ADPCM_NOT4BIT,\n\tSFE_W64_ADPCM_CHANNELS,\n\tSFE_W64_GSM610_FORMAT,\n\n\tSFE_MAT4_BAD_NAME,\n\tSFE_MAT4_NO_SAMPLERATE,\n\n\tSFE_MAT5_BAD_ENDIAN,\n\tSFE_MAT5_NO_BLOCK,\n\tSFE_MAT5_SAMPLE_RATE,\n\n\tSFE_PVF_NO_PVF1,\n\tSFE_PVF_BAD_HEADER,\n\tSFE_PVF_BAD_BITWIDTH,\n\n\tSFE_DWVW_BAD_BITWIDTH,\n\tSFE_G72X_NOT_MONO,\n\n\tSFE_XI_BAD_HEADER,\n\tSFE_XI_EXCESS_SAMPLES,\n\tSFE_XI_NO_PIPE,\n\n\tSFE_HTK_NO_PIPE,\n\n\tSFE_SDS_NOT_SDS,\n\tSFE_SDS_BAD_BIT_WIDTH,\n\n\tSFE_SD2_FD_DISALLOWED,\n\tSFE_SD2_BAD_DATA_OFFSET,\n\tSFE_SD2_BAD_MAP_OFFSET,\n\tSFE_SD2_BAD_DATA_LENGTH,\n\tSFE_SD2_BAD_MAP_LENGTH,\n\tSFE_SD2_BAD_RSRC,\n\tSFE_SD2_BAD_SAMPLE_SIZE,\n\n\tSFE_FLAC_BAD_HEADER,\n\tSFE_FLAC_NEW_DECODER,\n\tSFE_FLAC_INIT_DECODER,\n\tSFE_FLAC_LOST_SYNC,\n\tSFE_FLAC_BAD_SAMPLE_RATE,\n\tSFE_FLAC_UNKOWN_ERROR,\n\n\tSFE_WVE_NOT_WVE,\n\tSFE_WVE_NO_PIPE,\n\n\tSFE_VORBIS_ENCODER_BUG,\n\n\tSFE_RF64_NOT_RF64,\n\tSFE_RF64_PEAK_B4_FMT,\n\tSFE_RF64_NO_DATA,\n\n\tSFE_BAD_CHUNK_PTR,\n\tSFE_UNKNOWN_CHUNK,\n\tSFE_BAD_CHUNK_FORMAT,\n\tSFE_BAD_CHUNK_MARKER,\n\tSFE_BAD_CHUNK_DATA_PTR,\n\tSFE_ALAC_FAIL_TMPFILE,\n\tSFE_FILENAME_TOO_LONG,\n\n\tSFE_MAX_ERROR\t\t\t/* This must be last in list. */\n} ;\n\n/* Allocate and initialize the SF_PRIVATE struct. */\nSF_PRIVATE * psf_allocate (void) ;\n\nint subformat_to_bytewidth (int format) ;\nint s_bitwidth_to_subformat (int bits) ;\nint u_bitwidth_to_subformat (int bits) ;\n\n/*  Functions for reading and writing floats and doubles on processors\n**\twith non-IEEE floats/doubles.\n*/\nfloat\tfloat32_be_read\t\t(const unsigned char *cptr) ;\nfloat\tfloat32_le_read\t\t(const unsigned char *cptr) ;\nvoid\tfloat32_be_write\t(float in, unsigned char *out) ;\nvoid\tfloat32_le_write\t(float in, unsigned char *out) ;\n\ndouble\tdouble64_be_read\t(const unsigned char *cptr) ;\ndouble\tdouble64_le_read\t(const unsigned char *cptr) ;\nvoid\tdouble64_be_write\t(double in, unsigned char *out) ;\nvoid\tdouble64_le_write\t(double in, unsigned char *out) ;\n\n/* Functions for writing to the internal logging buffer. */\n\nvoid\tpsf_log_printf\t\t(SF_PRIVATE *psf, const char *format, ...) ;\nvoid\tpsf_log_SF_INFO \t(SF_PRIVATE *psf) ;\n\nint32_t\tpsf_rand_int32 (void) ;\n\nvoid append_snprintf (char * dest, size_t maxlen, const char * fmt, ...) ;\nvoid psf_strlcpy_crlf (char *dest, const char *src, size_t destmax, size_t srcmax) ;\n\nsf_count_t psf_decode_frame_count (SF_PRIVATE *psf) ;\n\n/* Functions used when writing file headers. */\n\nint\t\tpsf_binheader_writef\t(SF_PRIVATE *psf, const char *format, ...) ;\nvoid\tpsf_asciiheader_printf\t(SF_PRIVATE *psf, const char *format, ...) ;\n\n/* Functions used when reading file headers. */\n\nint\t\tpsf_binheader_readf\t(SF_PRIVATE *psf, char const *format, ...) ;\n\n/* Functions used in the write function for updating the peak chunk. */\n\nvoid\tpeak_update_short\t(SF_PRIVATE *psf, short *ptr, size_t items) ;\nvoid\tpeak_update_int\t\t(SF_PRIVATE *psf, int *ptr, size_t items) ;\nvoid\tpeak_update_double\t(SF_PRIVATE *psf, double *ptr, size_t items) ;\n\n/* Functions defined in command.c. */\n\nint\t\tpsf_get_format_simple_count\t(void) ;\nint\t\tpsf_get_format_simple\t\t(SF_FORMAT_INFO *data) ;\n\nint\t\tpsf_get_format_info\t\t\t(SF_FORMAT_INFO *data) ;\n\nint\t\tpsf_get_format_major_count\t(void) ;\nint\t\tpsf_get_format_major\t\t(SF_FORMAT_INFO *data) ;\n\nint\t\tpsf_get_format_subtype_count\t(void) ;\nint\t\tpsf_get_format_subtype\t\t(SF_FORMAT_INFO *data) ;\n\nvoid\tpsf_generate_format_desc (SF_PRIVATE *psf) ;\n\ndouble\tpsf_calc_signal_max\t\t\t(SF_PRIVATE *psf, int normalize) ;\nint\t\tpsf_calc_max_all_channels\t(SF_PRIVATE *psf, double *peaks, int normalize) ;\n\nint\t\tpsf_get_signal_max\t\t\t(SF_PRIVATE *psf, double *peak) ;\nint\t\tpsf_get_max_all_channels\t(SF_PRIVATE *psf, double *peaks) ;\n\n/* Functions in strings.c. */\n\nconst char* psf_get_string (SF_PRIVATE *psf, int str_type) ;\nint psf_set_string (SF_PRIVATE *psf, int str_type, const char *str) ;\nint psf_store_string (SF_PRIVATE *psf, int str_type, const char *str) ;\nint psf_location_string_count (const SF_PRIVATE * psf, int location) ;\n\n/* Default seek function. Use for PCM and float encoded data. */\nsf_count_t\tpsf_default_seek (SF_PRIVATE *psf, int mode, sf_count_t samples_from_start) ;\n\nint macos_guess_file_type (SF_PRIVATE *psf, const char *filename) ;\n\n/*------------------------------------------------------------------------------------\n**\tFile I/O functions which will allow access to large files (> 2 Gig) on\n**\tsome 32 bit OSes. Implementation in file_io.c.\n*/\n\nint psf_fopen (SF_PRIVATE *psf) ;\nint psf_set_stdio (SF_PRIVATE *psf) ;\nint psf_file_valid (SF_PRIVATE *psf) ;\nvoid psf_set_file (SF_PRIVATE *psf, int fd) ;\nvoid psf_init_files (SF_PRIVATE *psf) ;\nvoid psf_use_rsrc (SF_PRIVATE *psf, int on_off) ;\n\nSNDFILE * psf_open_file (SF_PRIVATE *psf, SF_INFO *sfinfo) ;\n\nsf_count_t psf_fseek (SF_PRIVATE *psf, sf_count_t offset, int whence) ;\nsf_count_t psf_fread (void *ptr, sf_count_t bytes, sf_count_t count, SF_PRIVATE *psf) ;\nsf_count_t psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t count, SF_PRIVATE *psf) ;\nsf_count_t psf_fgets (char *buffer, sf_count_t bufsize, SF_PRIVATE *psf) ;\nsf_count_t psf_ftell (SF_PRIVATE *psf) ;\nsf_count_t psf_get_filelen (SF_PRIVATE *psf) ;\n\nvoid psf_fsync (SF_PRIVATE *psf) ;\n\nint psf_is_pipe (SF_PRIVATE *psf) ;\n\nint psf_ftruncate (SF_PRIVATE *psf, sf_count_t len) ;\nint psf_fclose (SF_PRIVATE *psf) ;\n\n/* Open and close the resource fork of a file. */\nint psf_open_rsrc (SF_PRIVATE *psf) ;\nint psf_close_rsrc (SF_PRIVATE *psf) ;\n\n/*\nvoid psf_fclearerr (SF_PRIVATE *psf) ;\nint psf_ferror (SF_PRIVATE *psf) ;\n*/\n\n/*------------------------------------------------------------------------------------\n** Functions for reading and writing different file formats.\n*/\n\nint\t\taiff_open\t(SF_PRIVATE *psf) ;\nint\t\tau_open\t\t(SF_PRIVATE *psf) ;\nint\t\tavr_open\t(SF_PRIVATE *psf) ;\nint\t\thtk_open\t(SF_PRIVATE *psf) ;\nint\t\tircam_open\t(SF_PRIVATE *psf) ;\nint\t\tmat4_open\t(SF_PRIVATE *psf) ;\nint\t\tmat5_open\t(SF_PRIVATE *psf) ;\nint\t\tnist_open\t(SF_PRIVATE *psf) ;\nint\t\tpaf_open\t(SF_PRIVATE *psf) ;\nint\t\tpvf_open\t(SF_PRIVATE *psf) ;\nint\t\traw_open\t(SF_PRIVATE *psf) ;\nint\t\tsd2_open\t(SF_PRIVATE *psf) ;\nint\t\tsds_open\t(SF_PRIVATE *psf) ;\nint\t\tsvx_open\t(SF_PRIVATE *psf) ;\nint\t\tvoc_open\t(SF_PRIVATE *psf) ;\nint\t\tw64_open\t(SF_PRIVATE *psf) ;\nint\t\twav_open\t(SF_PRIVATE *psf) ;\nint\t\txi_open\t\t(SF_PRIVATE *psf) ;\nint\t\tflac_open\t(SF_PRIVATE *psf) ;\nint\t\tcaf_open\t(SF_PRIVATE *psf) ;\nint\t\tmpc2k_open\t(SF_PRIVATE *psf) ;\nint\t\trf64_open\t(SF_PRIVATE *psf) ;\n\nint\t\togg_vorbis_open\t(SF_PRIVATE *psf) ;\nint\t\togg_speex_open\t(SF_PRIVATE *psf) ;\nint\t\togg_pcm_open\t(SF_PRIVATE *psf) ;\nint\t\togg_opus_open\t(SF_PRIVATE *psf) ;\nint\t\togg_open\t(SF_PRIVATE *psf) ;\n\n\n/* In progress. Do not currently work. */\n\nint\t\tmpeg_open\t(SF_PRIVATE *psf) ;\nint\t\trx2_open\t(SF_PRIVATE *psf) ;\nint\t\ttxw_open\t(SF_PRIVATE *psf) ;\nint\t\twve_open\t(SF_PRIVATE *psf) ;\nint\t\tdwd_open\t(SF_PRIVATE *psf) ;\n\n/*------------------------------------------------------------------------------------\n**\tInit functions for a number of common data encodings.\n*/\n\nint\t\tpcm_init\t\t(SF_PRIVATE *psf) ;\nint\t\tulaw_init\t\t(SF_PRIVATE *psf) ;\nint\t\talaw_init\t\t(SF_PRIVATE *psf) ;\nint\t\tfloat32_init\t(SF_PRIVATE *psf) ;\nint\t\tdouble64_init\t(SF_PRIVATE *psf) ;\nint\t\tdwvw_init\t\t(SF_PRIVATE *psf, int bitwidth) ;\nint\t\tgsm610_init\t\t(SF_PRIVATE *psf) ;\nint\t\tvox_adpcm_init\t(SF_PRIVATE *psf) ;\nint\t\tflac_init\t\t(SF_PRIVATE *psf) ;\nint\t\tg72x_init \t\t(SF_PRIVATE * psf) ;\nint\t\talac_init\t\t(SF_PRIVATE *psf, const ALAC_DECODER_INFO * info) ;\n\nint \tdither_init\t\t(SF_PRIVATE *psf, int mode) ;\n\nint\t\twavlike_ima_init (SF_PRIVATE *psf, int blockalign, int samplesperblock) ;\nint\t\twavlike_msadpcm_init (SF_PRIVATE *psf, int blockalign, int samplesperblock) ;\n\nint\t\taiff_ima_init (SF_PRIVATE *psf, int blockalign, int samplesperblock) ;\n\nint\t\tinterleave_init (SF_PRIVATE *psf) ;\n\n/*------------------------------------------------------------------------------------\n** Chunk logging functions.\n*/\n\nSF_CHUNK_ITERATOR * psf_get_chunk_iterator (SF_PRIVATE * psf, const char * marker_str) ;\nSF_CHUNK_ITERATOR * psf_next_chunk_iterator (const READ_CHUNKS * pchk , SF_CHUNK_ITERATOR *iterator) ;\nint\t\tpsf_store_read_chunk_u32 (READ_CHUNKS * pchk, uint32_t marker, sf_count_t offset, uint32_t len) ;\nint\t\tpsf_store_read_chunk_str (READ_CHUNKS * pchk, const char * marker, sf_count_t offset, uint32_t len) ;\nint\t\tpsf_save_write_chunk (WRITE_CHUNKS * pchk, const SF_CHUNK_INFO * chunk_info) ;\nint\t\tpsf_find_read_chunk_str (const READ_CHUNKS * pchk, const char * marker) ;\nint\t\tpsf_find_read_chunk_m32 (const READ_CHUNKS * pchk, uint32_t marker) ;\nint\t\tpsf_find_read_chunk_iterator (const READ_CHUNKS * pchk, const SF_CHUNK_ITERATOR * marker) ;\n\nint\t\tpsf_find_write_chunk (WRITE_CHUNKS * pchk, const char * marker) ;\n\nstatic inline int\nfourcc_to_marker (const SF_CHUNK_INFO * chunk_info)\n{\tconst unsigned char * cptr ;\n\n\tif (chunk_info->id_size != 4)\n\t\treturn 0 ;\n\n\tcptr = (const unsigned char *) chunk_info->id ;\n\treturn (cptr [3] << 24) + (cptr [2] << 16) + (cptr [1] << 8) + cptr [0] ;\n} /* fourcc_to_marker */\n\n/*------------------------------------------------------------------------------------\n** Functions that work like OpenBSD's strlcpy/strlcat to replace strncpy/strncat.\n**\n** See : http://www.gratisoft.us/todd/papers/strlcpy.html\n**\n** These functions are available on *BSD, but are not avaialble everywhere so we\n** implement them here.\n**\n** The argument order has been changed to that of strncpy/strncat to cause\n** compiler errors if code is carelessly converted from one to the other.\n*/\n\nstatic inline void\npsf_strlcat (char *dest, size_t n, const char *src)\n{\tstrncat (dest, src, n - strlen (dest) - 1) ;\n\tdest [n - 1] = 0 ;\n} /* psf_strlcat */\n\nstatic inline void\npsf_strlcpy (char *dest, size_t n, const char *src)\n{\tstrncpy (dest, src, n - 1) ;\n\tdest [n - 1] = 0 ;\n} /* psf_strlcpy */\n\n/*------------------------------------------------------------------------------------\n** Other helper functions.\n*/\n\nvoid\t*psf_memset (void *s, int c, sf_count_t n) ;\n\nSF_CUES * psf_cues_dup (const void * ptr) ;\nSF_CUES * psf_cues_alloc (uint32_t cue_count) ;\nvoid psf_get_cues (SF_PRIVATE * psf, void * data, size_t datasize) ;\n\nSF_INSTRUMENT * psf_instrument_alloc (void) ;\n\nvoid\tpsf_sanitize_string (char * cptr, int len) ;\n\n/* Generate the current date as a string. */\nvoid\tpsf_get_date_str (char *str, int maxlen) ;\n\nSF_BROADCAST_INFO_16K * broadcast_var_alloc (void) ;\nint\t\tbroadcast_var_set (SF_PRIVATE *psf, const SF_BROADCAST_INFO * data, size_t datasize) ;\nint\t\tbroadcast_var_get (SF_PRIVATE *psf, SF_BROADCAST_INFO * data, size_t datasize) ;\n\n\nSF_CART_INFO_16K * cart_var_alloc (void) ;\nint \t\tcart_var_set (SF_PRIVATE *psf, const SF_CART_INFO * date, size_t datasize) ;\nint\t\tcart_var_get (SF_PRIVATE *psf, SF_CART_INFO * data, size_t datasize) ;\n\ntypedef struct\n{\tint channels ;\n\tint endianness ;\n} AUDIO_DETECT ;\n\nint audio_detect (SF_PRIVATE * psf, AUDIO_DETECT *ad, const unsigned char * data, int datalen) ;\nint id3_skip (SF_PRIVATE * psf) ;\n\nvoid\talac_get_desc_chunk_items (int subformat, uint32_t *fmt_flags, uint32_t *frames_per_packet) ;\n\nFILE *\tpsf_open_tmpfile (char * fname, size_t fnamelen) ;\n\n/*------------------------------------------------------------------------------------\n** Helper/debug functions.\n*/\n\nvoid\tpsf_hexdump (const void *ptr, int len) ;\n\nconst char * str_of_major_format (int format) ;\nconst char * str_of_minor_format (int format) ;\nconst char * str_of_open_mode (int mode) ;\nconst char * str_of_endianness (int end) ;\n\n/*------------------------------------------------------------------------------------\n** Extra commands for sf_command(). Not for public use yet.\n*/\n\nenum\n{\tSFC_TEST_AIFF_ADD_INST_CHUNK\t= 0x2000,\n\tSFC_TEST_WAV_ADD_INFO_CHUNK\t\t= 0x2010\n} ;\n\n/*\n** Maybe, one day, make these functions or something like them, public.\n**\n** Buffer to buffer dithering. Pointer in and out are allowed to point\n** to the same buffer for in-place dithering.\n*/\n\n#if 0\nint sf_dither_short\t\t(const SF_DITHER_INFO *dither, const short *in, short *out, int count) ;\nint sf_dither_int\t\t(const SF_DITHER_INFO *dither, const int *in, int *out, int count) ;\nint sf_dither_float\t\t(const SF_DITHER_INFO *dither, const float *in, float *out, int count) ;\nint sf_dither_double\t(const SF_DITHER_INFO *dither, const double *in, double *out, int count) ;\n#endif\n\n/*------------------------------------------------------------------------------------\n** Data conversion functions.\n*/\n\nvoid psf_f2s_array (const float *src, short *dest, int count, int normalize) ;\nvoid psf_f2s_clip_array (const float *src, short *dest, int count, int normalize) ;\n\nvoid psf_d2s_array (const double *src, short *dest, int count, int normalize) ;\nvoid psf_d2s_clip_array (const double *src, short *dest, int count, int normalize) ;\n\nvoid psf_f2i_array (const float *src, int *dest, int count, int normalize) ;\nvoid psf_f2i_clip_array (const float *src, int *dest, int count, int normalize) ;\n\nvoid psf_d2i_array (const double *src, int *dest, int count, int normalize) ;\nvoid psf_d2i_clip_array (const double *src, int *dest, int count, int normalize) ;\n\n\n/*------------------------------------------------------------------------------------\n** Left and right shift on int. According to the C standard, the left and right\n** shift operations applied to a negative integer results in undefined behavior.\n** These twp functions work around that.\n*/\n\n#if __GNUC__\n#define ALWAYS_INLINE\t\t__attribute__ ((always_inline))\n#else\n#define ALWAYS_INLINE\n#endif\n\nstatic inline int32_t ALWAYS_INLINE\narith_shift_left (int32_t x, int shift)\n{\treturn (int32_t) (((uint32_t) x) << shift) ;\n} /* arith_shift_left */\n\nstatic inline int32_t ALWAYS_INLINE\narith_shift_right (int32_t x, int shift)\n{\tif (x >= 0)\n\t\treturn x >> shift ;\n\treturn ~ ((~x) >> shift) ;\n} /* arith_shift_right */\n\n#endif /* SNDFILE_COMMON_H */\n", "/*\n** Copyright (C) 1999-2016 Erik de Castro Lopo <erikd@mega-nerd.com>\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n#include\t\"sfconfig.h\"\n\n#include\t<stdlib.h>\n#include\t<string.h>\n#include\t<ctype.h>\n#include\t<assert.h>\n\n#include\t\"sndfile.h\"\n#include\t\"sfendian.h\"\n#include\t\"common.h\"\n\n#define\t\tSNDFILE_MAGICK\t0x1234C0DE\n\n#ifdef __APPLE__\n\t/*\n\t**\tDetect if a compile for a universal binary is being attempted and barf if it is.\n\t**\tSee the URL below for the rationale.\n\t*/\n\t#ifdef __BIG_ENDIAN__\n\t\t#if (CPU_IS_LITTLE_ENDIAN == 1)\n\t\t\t#error \"Universal binary compile detected. See http://www.mega-nerd.com/libsndfile/FAQ.html#Q018\"\n\t\t#endif\n\t#endif\n\n\t#ifdef __LITTLE_ENDIAN__\n\t\t#if (CPU_IS_BIG_ENDIAN == 1)\n\t\t\t#error \"Universal binary compile detected. See http://www.mega-nerd.com/libsndfile/FAQ.html#Q018\"\n\t\t#endif\n\t#endif\n#endif\n\n\ntypedef struct\n{\tint \t\terror ;\n\tconst char\t*str ;\n} ErrorStruct ;\n\nstatic\nErrorStruct SndfileErrors [] =\n{\n\t/* Public error values and their associated strings. */\n\t{\tSF_ERR_NO_ERROR\t\t\t\t, \"No Error.\" },\n\t{\tSF_ERR_UNRECOGNISED_FORMAT\t, \"Format not recognised.\" },\n\t{\tSF_ERR_SYSTEM\t\t\t\t, \"System error.\" /* Often replaced. */ \t},\n\t{\tSF_ERR_MALFORMED_FILE\t\t, \"Supported file format but file is malformed.\" },\n\t{\tSF_ERR_UNSUPPORTED_ENCODING\t, \"Supported file format but unsupported encoding.\" },\n\n\t/* Private error values and their associated strings. */\n\t{\tSFE_ZERO_MAJOR_FORMAT\t, \"Error : major format is 0.\" },\n\t{\tSFE_ZERO_MINOR_FORMAT\t, \"Error : minor format is 0.\" },\n\t{\tSFE_BAD_FILE\t\t\t, \"File does not exist or is not a regular file (possibly a pipe?).\" },\n\t{\tSFE_BAD_FILE_READ\t\t, \"File exists but no data could be read.\" },\n\t{\tSFE_OPEN_FAILED\t\t\t, \"Could not open file.\" },\n\t{\tSFE_BAD_SNDFILE_PTR\t\t, \"Not a valid SNDFILE* pointer.\" },\n\t{\tSFE_BAD_SF_INFO_PTR\t\t, \"NULL SF_INFO pointer passed to libsndfile.\" },\n\t{\tSFE_BAD_SF_INCOMPLETE\t, \"SF_PRIVATE struct incomplete and end of header parsing.\" },\n\t{\tSFE_BAD_FILE_PTR\t\t, \"Bad FILE pointer.\" },\n\t{\tSFE_BAD_INT_PTR\t\t\t, \"Internal error, Bad pointer.\" },\n\t{\tSFE_BAD_STAT_SIZE\t\t, \"Error : software was misconfigured at compile time (sizeof statbuf.st_size).\" },\n\t{\tSFE_NO_TEMP_DIR\t\t\t, \"Error : Could not file temp dir.\" },\n\n\t{\tSFE_MALLOC_FAILED\t\t, \"Internal malloc () failed.\" },\n\t{\tSFE_UNIMPLEMENTED\t\t, \"File contains data in an unimplemented format.\" },\n\t{\tSFE_BAD_READ_ALIGN\t\t, \"Attempt to read a non-integer number of channels.\" },\n\t{\tSFE_BAD_WRITE_ALIGN \t, \"Attempt to write a non-integer number of channels.\" },\n\t{\tSFE_UNKNOWN_FORMAT\t\t, \"File contains data in an unknown format.\" },\n\t{\tSFE_NOT_READMODE\t\t, \"Read attempted on file currently open for write.\" },\n\t{\tSFE_NOT_WRITEMODE\t\t, \"Write attempted on file currently open for read.\" },\n\t{\tSFE_BAD_MODE_RW\t\t\t, \"Error : This file format does not support read/write mode.\" },\n\t{\tSFE_BAD_SF_INFO\t\t\t, \"Internal error : SF_INFO struct incomplete.\" },\n\t{\tSFE_BAD_OFFSET\t\t\t, \"Error : supplied offset beyond end of file.\" },\n\t{\tSFE_NO_EMBED_SUPPORT\t, \"Error : embedding not supported for this file format.\" },\n\t{\tSFE_NO_EMBEDDED_RDWR\t, \"Error : cannot open embedded file read/write.\" },\n\t{\tSFE_NO_PIPE_WRITE\t\t, \"Error : this file format does not support pipe write.\" },\n\t{\tSFE_BAD_VIRTUAL_IO\t\t, \"Error : bad pointer on SF_VIRTUAL_IO struct.\" },\n\t{\tSFE_BAD_BROADCAST_INFO_SIZE\n\t\t\t\t\t\t\t\t, \"Error : bad coding_history_size in SF_BROADCAST_INFO struct.\" },\n\t{\tSFE_BAD_BROADCAST_INFO_TOO_BIG\n\t\t\t\t\t\t\t\t, \"Error : SF_BROADCAST_INFO struct too large.\" },\n\t{\tSFE_BAD_CART_INFO_SIZE\t\t\t\t, \"Error: SF_CART_INFO struct too large.\" },\n\t{\tSFE_BAD_CART_INFO_TOO_BIG\t\t\t, \"Error: bag tag_text_size in SF_CART_INFO struct.\" },\n\t{\tSFE_INTERLEAVE_MODE\t\t, \"Attempt to write to file with non-interleaved data.\" },\n\t{\tSFE_INTERLEAVE_SEEK\t\t, \"Bad karma in seek during interleave read operation.\" },\n\t{\tSFE_INTERLEAVE_READ\t\t, \"Bad karma in read during interleave read operation.\" },\n\n\t{\tSFE_INTERNAL\t\t\t, \"Unspecified internal error.\" },\n\t{\tSFE_BAD_COMMAND_PARAM\t, \"Bad parameter passed to function sf_command.\" },\n\t{\tSFE_BAD_ENDIAN\t\t\t, \"Bad endian-ness. Try default endian-ness\" },\n\t{\tSFE_CHANNEL_COUNT_ZERO\t, \"Channel count is zero.\" },\n\t{\tSFE_CHANNEL_COUNT\t\t, \"Too many channels specified.\" },\n\t{\tSFE_CHANNEL_COUNT_BAD\t, \"Bad channel count.\" },\n\n\t{\tSFE_BAD_SEEK\t\t\t, \"Internal psf_fseek() failed.\" },\n\t{\tSFE_NOT_SEEKABLE\t\t, \"Seek attempted on unseekable file type.\" },\n\t{\tSFE_AMBIGUOUS_SEEK\t\t, \"Error : combination of file open mode and seek command is ambiguous.\" },\n\t{\tSFE_WRONG_SEEK\t\t\t, \"Error : invalid seek parameters.\" },\n\t{\tSFE_SEEK_FAILED\t\t\t, \"Error : parameters OK, but psf_seek() failed.\" },\n\n\t{\tSFE_BAD_OPEN_MODE\t\t, \"Error : bad mode parameter for file open.\" },\n\t{\tSFE_OPEN_PIPE_RDWR\t\t, \"Error : attempt to open a pipe in read/write mode.\" },\n\t{\tSFE_RDWR_POSITION\t\t, \"Error on RDWR position (cryptic).\" },\n\t{\tSFE_RDWR_BAD_HEADER\t\t, \"Error : Cannot open file in read/write mode due to string data in header.\" },\n\t{\tSFE_CMD_HAS_DATA\t\t, \"Error : Command fails because file already has audio data.\" },\n\n\t{\tSFE_STR_NO_SUPPORT\t\t, \"Error : File type does not support string data.\" },\n\t{\tSFE_STR_NOT_WRITE\t\t, \"Error : Trying to set a string when file is not in write mode.\" },\n\t{\tSFE_STR_MAX_DATA\t\t, \"Error : Maximum string data storage reached.\" },\n\t{\tSFE_STR_MAX_COUNT\t\t, \"Error : Maximum string data count reached.\" },\n\t{\tSFE_STR_BAD_TYPE\t\t, \"Error : Bad string data type.\" },\n\t{\tSFE_STR_NO_ADD_END\t\t, \"Error : file type does not support strings added at end of file.\" },\n\t{\tSFE_STR_BAD_STRING\t\t, \"Error : bad string.\" },\n\t{\tSFE_STR_WEIRD\t\t\t, \"Error : Weird string error.\" },\n\n\t{\tSFE_WAV_NO_RIFF\t\t\t, \"Error in WAV file. No 'RIFF' chunk marker.\" },\n\t{\tSFE_WAV_NO_WAVE\t\t\t, \"Error in WAV file. No 'WAVE' chunk marker.\" },\n\t{\tSFE_WAV_NO_FMT\t\t\t, \"Error in WAV/W64/RF64 file. No 'fmt ' chunk marker.\" },\n\t{\tSFE_WAV_BAD_FMT\t\t\t, \"Error in WAV/W64/RF64 file. Malformed 'fmt ' chunk.\" },\n\t{\tSFE_WAV_FMT_SHORT\t\t, \"Error in WAV/W64/RF64 file. Short 'fmt ' chunk.\" },\n\n\t{\tSFE_WAV_BAD_FACT\t\t, \"Error in WAV file. 'fact' chunk out of place.\" },\n\t{\tSFE_WAV_BAD_PEAK\t\t, \"Error in WAV file. Bad 'PEAK' chunk.\" },\n\t{\tSFE_WAV_PEAK_B4_FMT\t\t, \"Error in WAV file. 'PEAK' chunk found before 'fmt ' chunk.\" },\n\n\t{\tSFE_WAV_BAD_FORMAT\t\t, \"Error in WAV file. Errors in 'fmt ' chunk.\" },\n\t{\tSFE_WAV_BAD_BLOCKALIGN\t, \"Error in WAV file. Block alignment in 'fmt ' chunk is incorrect.\" },\n\t{\tSFE_WAV_NO_DATA\t\t\t, \"Error in WAV file. No 'data' chunk marker.\" },\n\t{\tSFE_WAV_BAD_LIST\t\t, \"Error in WAV file. Malformed LIST chunk.\" },\n\t{\tSFE_WAV_UNKNOWN_CHUNK\t, \"Error in WAV file. File contains an unknown chunk marker.\" },\n\t{\tSFE_WAV_WVPK_DATA\t\t, \"Error in WAV file. Data is in WAVPACK format.\" },\n\n\t{\tSFE_WAV_ADPCM_NOT4BIT\t, \"Error in ADPCM WAV file. Invalid bit width.\" },\n\t{\tSFE_WAV_ADPCM_CHANNELS\t, \"Error in ADPCM WAV file. Invalid number of channels.\" },\n\t{\tSFE_WAV_ADPCM_SAMPLES\t, \"Error in ADPCM WAV file. Invalid number of samples per block.\" },\n\t{\tSFE_WAV_GSM610_FORMAT\t, \"Error in GSM610 WAV file. Invalid format chunk.\" },\n\n\t{\tSFE_AIFF_NO_FORM\t\t, \"Error in AIFF file, bad 'FORM' marker.\" },\n\t{\tSFE_AIFF_AIFF_NO_FORM\t, \"Error in AIFF file, 'AIFF' marker without 'FORM'.\" },\n\t{\tSFE_AIFF_COMM_NO_FORM\t, \"Error in AIFF file, 'COMM' marker without 'FORM'.\" },\n\t{\tSFE_AIFF_SSND_NO_COMM\t, \"Error in AIFF file, 'SSND' marker without 'COMM'.\" },\n\t{\tSFE_AIFF_UNKNOWN_CHUNK\t, \"Error in AIFF file, unknown chunk.\" },\n\t{\tSFE_AIFF_COMM_CHUNK_SIZE, \"Error in AIFF file, bad 'COMM' chunk size.\" },\n\t{\tSFE_AIFF_BAD_COMM_CHUNK , \"Error in AIFF file, bad 'COMM' chunk.\" },\n\t{\tSFE_AIFF_PEAK_B4_COMM\t, \"Error in AIFF file. 'PEAK' chunk found before 'COMM' chunk.\" },\n\t{\tSFE_AIFF_BAD_PEAK\t\t, \"Error in AIFF file. Bad 'PEAK' chunk.\" },\n\t{\tSFE_AIFF_NO_SSND\t\t, \"Error in AIFF file, bad 'SSND' chunk.\" },\n\t{\tSFE_AIFF_NO_DATA\t\t, \"Error in AIFF file, no sound data.\" },\n\t{\tSFE_AIFF_RW_SSND_NOT_LAST, \"Error in AIFF file, RDWR only possible if SSND chunk at end of file.\" },\n\n\t{\tSFE_AU_UNKNOWN_FORMAT\t, \"Error in AU file, unknown format.\" },\n\t{\tSFE_AU_NO_DOTSND\t\t, \"Error in AU file, missing '.snd' or 'dns.' marker.\" },\n\t{\tSFE_AU_EMBED_BAD_LEN\t, \"Embedded AU file with unknown length.\" },\n\n\t{\tSFE_RAW_READ_BAD_SPEC\t, \"Error while opening RAW file for read. Must specify format and channels.\\n\"\n\t\t\t\t\t\t\t\t\t\"Possibly trying to open unsupported format.\" },\n\t{\tSFE_RAW_BAD_BITWIDTH\t, \"Error. RAW file bitwidth must be a multiple of 8.\" },\n\t{\tSFE_RAW_BAD_FORMAT\t\t, \"Error. Bad format field in SF_INFO struct when opening a RAW file for read.\" },\n\n\t{\tSFE_PAF_NO_MARKER\t\t, \"Error in PAF file, no marker.\" },\n\t{\tSFE_PAF_VERSION\t\t\t, \"Error in PAF file, bad version.\" },\n\t{\tSFE_PAF_UNKNOWN_FORMAT\t, \"Error in PAF file, unknown format.\" },\n\t{\tSFE_PAF_SHORT_HEADER\t, \"Error in PAF file. File shorter than minimal header.\" },\n\t{\tSFE_PAF_BAD_CHANNELS\t, \"Error in PAF file. Bad channel count.\" },\n\n\t{\tSFE_SVX_NO_FORM\t\t\t, \"Error in 8SVX / 16SV file, no 'FORM' marker.\" },\n\t{\tSFE_SVX_NO_BODY\t\t\t, \"Error in 8SVX / 16SV file, no 'BODY' marker.\" },\n\t{\tSFE_SVX_NO_DATA\t\t\t, \"Error in 8SVX / 16SV file, no sound data.\" },\n\t{\tSFE_SVX_BAD_COMP\t\t, \"Error in 8SVX / 16SV file, unsupported compression format.\" },\n\t{\tSFE_SVX_BAD_NAME_LENGTH\t, \"Error in 8SVX / 16SV file, NAME chunk too long.\" },\n\n\t{\tSFE_NIST_BAD_HEADER\t\t, \"Error in NIST file, bad header.\" },\n\t{\tSFE_NIST_CRLF_CONVERISON, \"Error : NIST file damaged by Windows CR -> CRLF conversion process.\"\t},\n\t{\tSFE_NIST_BAD_ENCODING\t, \"Error in NIST file, unsupported compression format.\" },\n\n\t{\tSFE_VOC_NO_CREATIVE\t\t, \"Error in VOC file, no 'Creative Voice File' marker.\" },\n\t{\tSFE_VOC_BAD_FORMAT\t\t, \"Error in VOC file, bad format.\" },\n\t{\tSFE_VOC_BAD_VERSION\t\t, \"Error in VOC file, bad version number.\" },\n\t{\tSFE_VOC_BAD_MARKER\t\t, \"Error in VOC file, bad marker in file.\" },\n\t{\tSFE_VOC_BAD_SECTIONS\t, \"Error in VOC file, incompatible VOC sections.\" },\n\t{\tSFE_VOC_MULTI_SAMPLERATE, \"Error in VOC file, more than one sample rate defined.\" },\n\t{\tSFE_VOC_MULTI_SECTION\t, \"Unimplemented VOC file feature, file contains multiple sound sections.\" },\n\t{\tSFE_VOC_MULTI_PARAM\t\t, \"Error in VOC file, file contains multiple bit or channel widths.\" },\n\t{\tSFE_VOC_SECTION_COUNT\t, \"Error in VOC file, too many sections.\" },\n\t{\tSFE_VOC_NO_PIPE\t\t\t, \"Error : not able to operate on VOC files over a pipe.\" },\n\n\t{\tSFE_IRCAM_NO_MARKER\t\t, \"Error in IRCAM file, bad IRCAM marker.\" },\n\t{\tSFE_IRCAM_BAD_CHANNELS\t, \"Error in IRCAM file, bad channel count.\" },\n\t{\tSFE_IRCAM_UNKNOWN_FORMAT, \"Error in IRCAM file, unknown encoding format.\" },\n\n\t{\tSFE_W64_64_BIT\t\t\t, \"Error in W64 file, file contains 64 bit offset.\" },\n\t{\tSFE_W64_NO_RIFF\t\t\t, \"Error in W64 file. No 'riff' chunk marker.\" },\n\t{\tSFE_W64_NO_WAVE\t\t\t, \"Error in W64 file. No 'wave' chunk marker.\" },\n\t{\tSFE_W64_NO_DATA\t\t\t, \"Error in W64 file. No 'data' chunk marker.\" },\n\t{\tSFE_W64_ADPCM_NOT4BIT\t, \"Error in ADPCM W64 file. Invalid bit width.\" },\n\t{\tSFE_W64_ADPCM_CHANNELS\t, \"Error in ADPCM W64 file. Invalid number of channels.\" },\n\t{\tSFE_W64_GSM610_FORMAT\t, \"Error in GSM610 W64 file. Invalid format chunk.\" },\n\n\t{\tSFE_MAT4_BAD_NAME\t\t, \"Error in MAT4 file. No variable name.\" },\n\t{\tSFE_MAT4_NO_SAMPLERATE\t, \"Error in MAT4 file. No sample rate.\" },\n\n\t{\tSFE_MAT5_BAD_ENDIAN\t\t, \"Error in MAT5 file. Not able to determine endian-ness.\" },\n\t{\tSFE_MAT5_NO_BLOCK\t\t, \"Error in MAT5 file. Bad block structure.\" },\n\t{\tSFE_MAT5_SAMPLE_RATE\t, \"Error in MAT5 file. Not able to determine sample rate.\" },\n\n\t{\tSFE_PVF_NO_PVF1\t\t\t, \"Error in PVF file. No PVF1 marker.\" },\n\t{\tSFE_PVF_BAD_HEADER\t\t, \"Error in PVF file. Bad header.\" },\n\t{\tSFE_PVF_BAD_BITWIDTH\t, \"Error in PVF file. Bad bit width.\" },\n\n\t{\tSFE_XI_BAD_HEADER\t\t, \"Error in XI file. Bad header.\" },\n\t{\tSFE_XI_EXCESS_SAMPLES\t, \"Error in XI file. Excess samples in file.\" },\n\t{\tSFE_XI_NO_PIPE\t\t\t, \"Error : not able to operate on XI files over a pipe.\" },\n\n\t{\tSFE_HTK_NO_PIPE\t\t\t, \"Error : not able to operate on HTK files over a pipe.\" },\n\n\t{\tSFE_SDS_NOT_SDS\t\t\t, \"Error : not an SDS file.\" },\n\t{\tSFE_SDS_BAD_BIT_WIDTH\t, \"Error : bad bit width for SDS file.\" },\n\n\t{\tSFE_SD2_FD_DISALLOWED\t, \"Error : cannot open SD2 file without a file name.\" },\n\t{\tSFE_SD2_BAD_DATA_OFFSET\t, \"Error : bad data offset.\" },\n\t{\tSFE_SD2_BAD_MAP_OFFSET\t, \"Error : bad map offset.\" },\n\t{\tSFE_SD2_BAD_DATA_LENGTH\t, \"Error : bad data length.\" },\n\t{\tSFE_SD2_BAD_MAP_LENGTH\t, \"Error : bad map length.\" },\n\t{\tSFE_SD2_BAD_RSRC\t\t, \"Error : bad resource fork.\" },\n\t{\tSFE_SD2_BAD_SAMPLE_SIZE\t, \"Error : bad sample size.\" },\n\n\t{\tSFE_FLAC_BAD_HEADER\t\t, \"Error : bad flac header.\" },\n\t{\tSFE_FLAC_NEW_DECODER\t, \"Error : problem while creating flac decoder.\" },\n\t{\tSFE_FLAC_INIT_DECODER\t, \"Error : problem while initialization of the flac decoder.\" },\n\t{\tSFE_FLAC_LOST_SYNC\t\t, \"Error : flac decoder lost sync.\" },\n\t{\tSFE_FLAC_BAD_SAMPLE_RATE, \"Error : flac does not support this sample rate.\" },\n\t{\tSFE_FLAC_UNKOWN_ERROR\t, \"Error : unknown error in flac decoder.\" },\n\n\t{\tSFE_WVE_NOT_WVE\t\t\t, \"Error : not a WVE file.\" },\n\t{\tSFE_WVE_NO_PIPE\t\t\t, \"Error : not able to operate on WVE files over a pipe.\" },\n\n\t{\tSFE_DWVW_BAD_BITWIDTH\t, \"Error : Bad bit width for DWVW encoding. Must be 12, 16 or 24.\" },\n\t{\tSFE_G72X_NOT_MONO\t\t, \"Error : G72x encoding does not support more than 1 channel.\" },\n\n\t{\tSFE_VORBIS_ENCODER_BUG\t, \"Error : Sample rate chosen is known to trigger a Vorbis encoder bug on this CPU.\" },\n\n\t{\tSFE_RF64_NOT_RF64\t\t, \"Error : Not an RF64 file.\" },\n\t{\tSFE_RF64_PEAK_B4_FMT\t, \"Error in RF64 file. 'PEAK' chunk found before 'fmt ' chunk.\" },\n\t{\tSFE_RF64_NO_DATA\t\t, \"Error in RF64 file. No 'data' chunk marker.\" },\n\n\t{\tSFE_ALAC_FAIL_TMPFILE\t, \"Error : Failed to open tmp file for ALAC encoding.\" },\n\n\t{\tSFE_BAD_CHUNK_PTR\t\t, \"Error : Bad SF_CHUNK_INFO pointer.\" },\n\t{\tSFE_UNKNOWN_CHUNK\t\t, \"Error : Unknown chunk marker.\" },\n\t{\tSFE_BAD_CHUNK_FORMAT\t, \"Error : Reading/writing chunks from this file format is not supported.\" },\n\t{\tSFE_BAD_CHUNK_MARKER\t, \"Error : Bad chunk marker.\" },\n\t{\tSFE_BAD_CHUNK_DATA_PTR\t, \"Error : Bad data pointer in SF_CHUNK_INFO struct.\" },\n\t{\tSFE_FILENAME_TOO_LONG\t, \"Error : Supplied filename too long.\" },\n\t{\tSFE_BAD_HEADER_ALLOC \t, \"Error : Required header allocation is too large.\" },\n\n\t{\tSFE_MAX_ERROR\t\t\t, \"Maximum error number.\" },\n\t{\tSFE_MAX_ERROR + 1\t\t, NULL }\n} ;\n\n/*------------------------------------------------------------------------------\n*/\n\nstatic int \tformat_from_extension (SF_PRIVATE *psf) ;\nstatic int\tguess_file_type (SF_PRIVATE *psf) ;\nstatic int\tvalidate_sfinfo (SF_INFO *sfinfo) ;\nstatic int\tvalidate_psf (SF_PRIVATE *psf) ;\nstatic void\tsave_header_info (SF_PRIVATE *psf) ;\nstatic int\tcopy_filename (SF_PRIVATE *psf, const char *path) ;\nstatic int\tpsf_close (SF_PRIVATE *psf) ;\n\nstatic int\ttry_resource_fork (SF_PRIVATE * psf) ;\n\n/*------------------------------------------------------------------------------\n** Private (static) variables.\n*/\n\nint\tsf_errno = 0 ;\nstatic char\tsf_parselog [SF_BUFFER_LEN] = { 0 } ;\nstatic char\tsf_syserr [SF_SYSERR_LEN] = { 0 } ;\n\n/*------------------------------------------------------------------------------\n*/\n\n#define\tVALIDATE_SNDFILE_AND_ASSIGN_PSF(a, b, c)\t\\\n\t\t{\tif ((a) == NULL)\t\t\t\t\t\t\\\n\t\t\t{\tsf_errno = SFE_BAD_SNDFILE_PTR ;\t\\\n\t\t\t\treturn 0 ;\t\t\t\t\t\t\t\\\n\t\t\t\t} ;\t\t\t\t\t\t\t\t\t\\\n\t\t\t(b) = (SF_PRIVATE*) (a) ;\t\t\t\t\\\n\t\t\tif ((b)->virtual_io == SF_FALSE &&\t\t\\\n\t\t\t\tpsf_file_valid (b) == 0)\t\t\t\\\n\t\t\t{\t(b)->error = SFE_BAD_FILE_PTR ;\t\t\\\n\t\t\t\treturn 0 ;\t\t\t\t\t\t\t\\\n\t\t\t\t} ;\t\t\t\t\t\t\t\t\t\\\n\t\t\tif ((b)->Magick != SNDFILE_MAGICK)\t\t\\\n\t\t\t{\t(b)->error = SFE_BAD_SNDFILE_PTR ;\t\\\n\t\t\t\treturn 0 ;\t\t\t\t\t\t\t\\\n\t\t\t\t} ;\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (c) (b)->error = 0 ;\t\t\t\t\t\\\n\t\t\t}\n\n/*------------------------------------------------------------------------------\n**\tPublic functions.\n*/\n\nSNDFILE*\nsf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\n\t/* Ultimate sanity check. */\n\tassert (sizeof (sf_count_t) == 8) ;\n\n\tif ((psf = psf_allocate ()) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf_log_printf (psf, \"File : %s\\n\", path) ;\n\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf->error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf->file.mode = mode ;\n\tif (strcmp (path, \"-\") == 0)\n\t\tpsf->error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf->error = psf_fopen (psf) ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open */\n\nSNDFILE*\nsf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tif ((psf = psf_allocate ()) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\tpsf->fileoffset = psf_ftell (psf) ;\n\n\tif (! close_desc)\n\t\tpsf->file.do_not_close_descriptor = SF_TRUE ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open_fd */\n\nSNDFILE*\nsf_open_virtual\t(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)\n{\tSF_PRIVATE \t*psf ;\n\n\t/* Make sure we have a valid set ot virtual pointers. */\n\tif (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\n\tif ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_read in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\n\tif ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_write in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\n\tif ((psf = psf_allocate ()) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf->virtual_io = SF_TRUE ;\n\tpsf->vio = *sfvirtual ;\n\tpsf->vio_user_data = user_data ;\n\n\tpsf->file.mode = mode ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open_virtual */\n\nint\nsf_close\t(SNDFILE *sndfile)\n{\tSF_PRIVATE\t*psf ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\treturn psf_close (psf) ;\n} /* sf_close */\n\nvoid\nsf_write_sync\t(SNDFILE *sndfile)\n{\tSF_PRIVATE\t*psf ;\n\n\tif ((psf = (SF_PRIVATE *) sndfile) == NULL)\n\t\treturn ;\n\n\tpsf_fsync (psf) ;\n\n\treturn ;\n} /* sf_write_sync */\n\n/*==============================================================================\n*/\n\nconst char*\nsf_error_number\t(int errnum)\n{\tstatic const char *bad_errnum =\n\t\t\"No error defined for this error number. This is a bug in libsndfile.\" ;\n\tint\tk ;\n\n\tif (errnum == SFE_MAX_ERROR)\n\t\treturn SndfileErrors [0].str ;\n\n\tif (errnum < 0 || errnum > SFE_MAX_ERROR)\n\t{\t/* This really shouldn't happen in release versions. */\n\t\tprintf (\"Not a valid error number (%d).\\n\", errnum) ;\n\t\treturn bad_errnum ;\n\t\t} ;\n\n\tfor (k = 0 ; SndfileErrors [k].str ; k++)\n\t\tif (errnum == SndfileErrors [k].error)\n\t\t\treturn SndfileErrors [k].str ;\n\n\treturn bad_errnum ;\n} /* sf_error_number */\n\nconst char*\nsf_strerror (SNDFILE *sndfile)\n{\tSF_PRIVATE \t*psf = NULL ;\n\tint errnum ;\n\n\tif (sndfile == NULL)\n\t{\terrnum = sf_errno ;\n\t\tif (errnum == SFE_SYSTEM && sf_syserr [0])\n\t\t\treturn sf_syserr ;\n\t\t}\n\telse\n\t{\tpsf = (SF_PRIVATE *) sndfile ;\n\n\t\tif (psf->Magick != SNDFILE_MAGICK)\n\t\t\treturn\t\"sf_strerror : Bad magic number.\" ;\n\n\t\terrnum = psf->error ;\n\n\t\tif (errnum == SFE_SYSTEM && psf->syserr [0])\n\t\t\treturn psf->syserr ;\n\t\t} ;\n\n\treturn sf_error_number (errnum) ;\n} /* sf_strerror */\n\n/*------------------------------------------------------------------------------\n*/\n\nint\nsf_error (SNDFILE *sndfile)\n{\tSF_PRIVATE\t*psf ;\n\n\tif (sndfile == NULL)\n\t\treturn sf_errno ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 0) ;\n\n\tif (psf->error)\n\t\treturn psf->error ;\n\n\treturn 0 ;\n} /* sf_error */\n\n/*------------------------------------------------------------------------------\n*/\n\nint\nsf_perror (SNDFILE *sndfile)\n{\tSF_PRIVATE \t*psf ;\n\tint \t\terrnum ;\n\n\tif (sndfile == NULL)\n\t{\terrnum = sf_errno ;\n\t\t}\n\telse\n\t{\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 0) ;\n\t\terrnum = psf->error ;\n\t\t} ;\n\n\tfprintf (stderr, \"%s\\n\", sf_error_number (errnum)) ;\n\treturn SFE_NO_ERROR ;\n} /* sf_perror */\n\n\n/*------------------------------------------------------------------------------\n*/\n\nint\nsf_error_str (SNDFILE *sndfile, char *str, size_t maxlen)\n{\tSF_PRIVATE \t*psf ;\n\tint \t\terrnum ;\n\n\tif (str == NULL)\n\t\treturn SFE_INTERNAL ;\n\n\tif (sndfile == NULL)\n\t\terrnum = sf_errno ;\n\telse\n\t{\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 0) ;\n\t\terrnum = psf->error ;\n\t\t} ;\n\n\tsnprintf (str, maxlen, \"%s\", sf_error_number (errnum)) ;\n\n\treturn SFE_NO_ERROR ;\n} /* sf_error_str */\n\n/*==============================================================================\n*/\n\nint\nsf_format_check\t(const SF_INFO *info)\n{\tint\tsubformat, endian ;\n\n\tsubformat = SF_CODEC (info->format) ;\n\tendian = SF_ENDIAN (info->format) ;\n\n\t/* This is the place where each file format can check if the suppiled\n\t** SF_INFO struct is valid.\n\t** Return 0 on failure, 1 ons success.\n\t*/\n\n\tif (info->channels < 1 || info->channels > SF_MAX_CHANNELS)\n\t\treturn 0 ;\n\n\tif (info->samplerate < 0)\n\t\treturn 0 ;\n\n\tswitch (SF_CONTAINER (info->format))\n\t{\tcase SF_FORMAT_WAV :\n\t\t\t\t/* WAV now allows both endian, RIFF or RIFX (little or big respectively) */\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif ((subformat == SF_FORMAT_IMA_ADPCM || subformat == SF_FORMAT_MS_ADPCM) && info->channels <= 2)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_GSM610 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_G721_32 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_WAVEX :\n\t\t\t\tif (endian == SF_ENDIAN_BIG || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_AIFF :\n\t\t\t\t/* AIFF does allow both endian-nesses for PCM data.*/\n\t\t\t\tif (subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\t/* For other encodings reject any endian-ness setting. */\n\t\t\t\tif (endian != 0)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_S8)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif ((subformat == SF_FORMAT_DWVW_12 || subformat == SF_FORMAT_DWVW_16 ||\n\t\t\t\t\t\t\tsubformat == SF_FORMAT_DWVW_24) && info-> channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_GSM610 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_IMA_ADPCM && (info->channels == 1 || info->channels == 2))\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_AU :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_G721_32 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_G723_24 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_G723_40 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_CAF :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ALAC_16 || subformat == SF_FORMAT_ALAC_20)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ALAC_24 || subformat == SF_FORMAT_ALAC_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_RAW :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ALAW || subformat == SF_FORMAT_ULAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif ((subformat == SF_FORMAT_DWVW_12 || subformat == SF_FORMAT_DWVW_16 ||\n\t\t\t\t\t\t\tsubformat == SF_FORMAT_DWVW_24) && info-> channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_GSM610 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_VOX_ADPCM && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PAF :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_24)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_SVX :\n\t\t\t\t/* SVX only supports writing mono SVX files. */\n\t\t\t\tif (info->channels > 1)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* Always big endian. */\n\t\t\t\tif (endian == SF_ENDIAN_LITTLE || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_NIST :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_IRCAM :\n\t\t\t\tif (info->channels > 256)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW || subformat == SF_FORMAT_FLOAT)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_VOC :\n\t\t\t\tif (info->channels > 2)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* VOC is strictly little endian. */\n\t\t\t\tif (endian == SF_ENDIAN_BIG || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_W64 :\n\t\t\t\t/* W64 is strictly little endian. */\n\t\t\t\tif (endian == SF_ENDIAN_BIG || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif ((subformat == SF_FORMAT_IMA_ADPCM || subformat == SF_FORMAT_MS_ADPCM) && info->channels <= 2)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_GSM610 && info->channels == 1)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_MAT4 :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_MAT5 :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PVF :\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_XI :\n\t\t\t\tif (info->channels != 1)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_DPCM_8 || subformat == SF_FORMAT_DPCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_HTK :\n\t\t\t\tif (info->channels != 1)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* HTK is strictly big endian. */\n\t\t\t\tif (endian == SF_ENDIAN_LITTLE || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_SDS :\n\t\t\t\tif (info->channels != 1)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* SDS is strictly big endian. */\n\t\t\t\tif (endian == SF_ENDIAN_LITTLE || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_24)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_AVR :\n\t\t\t\tif (info->channels > 2)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* SDS is strictly big endian. */\n\t\t\t\tif (endian == SF_ENDIAN_LITTLE || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_FLAC :\n\t\t\t\t/* FLAC can't do more than 8 channels. */\n\t\t\t\tif (info->channels > 8)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (endian != SF_ENDIAN_FILE)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_24)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_SD2 :\n\t\t\t\t/* SD2 is strictly big endian. */\n\t\t\t\tif (endian == SF_ENDIAN_LITTLE || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_S8 || subformat == SF_FORMAT_PCM_16 || subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_WVE :\n\t\t\t\tif (info->channels > 1)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* WVE is strictly big endian. */\n\t\t\t\tif (endian == SF_ENDIAN_BIG || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_OGG :\n\t\t\t\tif (endian != SF_ENDIAN_FILE)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_VORBIS)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_MPC2K :\n\t\t\t\tif (info->channels > 2)\n\t\t\t\t\treturn 0 ;\n\t\t\t\t/* MPC2000 is strictly little endian. */\n\t\t\t\tif (endian == SF_ENDIAN_BIG || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_RF64 :\n\t\t\t\tif (endian == SF_ENDIAN_BIG || endian == SF_ENDIAN_CPU)\n\t\t\t\t\treturn 0 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_U8 || subformat == SF_FORMAT_PCM_16)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_PCM_24 || subformat == SF_FORMAT_PCM_32)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_ULAW || subformat == SF_FORMAT_ALAW)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tif (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn 1 ;\n\t\t\t\tbreak ;\n\t\tdefault : break ;\n\t\t} ;\n\n\treturn 0 ;\n} /* sf_format_check */\n\n/*------------------------------------------------------------------------------\n*/\n\nconst char *\nsf_version_string (void)\n{\n#if\tENABLE_EXPERIMENTAL_CODE\n\treturn PACKAGE_NAME \"-\" PACKAGE_VERSION \"-exp\" ;\n#else\n\treturn PACKAGE_NAME \"-\" PACKAGE_VERSION ;\n#endif\n}\n\n\n/*------------------------------------------------------------------------------\n*/\n\nint\nsf_command\t(SNDFILE *sndfile, int command, void *data, int datasize)\n{\tSF_PRIVATE *psf = (SF_PRIVATE *) sndfile ;\n\tdouble quality ;\n\tint old_value ;\n\n\t/* This set of commands do not need the sndfile parameter. */\n\tswitch (command)\n\t{\tcase SFC_GET_LIB_VERSION :\n\t\t\tif (data == NULL)\n\t\t\t{\tif (psf)\n\t\t\t\t\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SFE_BAD_COMMAND_PARAM ;\n\t\t\t\t} ;\n\t\t\tsnprintf (data, datasize, \"%s\", sf_version_string ()) ;\n\t\t\treturn strlen (data) ;\n\n\t\tcase SFC_GET_SIMPLE_FORMAT_COUNT :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (int))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\t*((int*) data) = psf_get_format_simple_count () ;\n\t\t\treturn 0 ;\n\n\t\tcase SFC_GET_SIMPLE_FORMAT :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_FORMAT_INFO))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\treturn psf_get_format_simple (data) ;\n\n\t\tcase SFC_GET_FORMAT_MAJOR_COUNT :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (int))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\t*((int*) data) = psf_get_format_major_count () ;\n\t\t\treturn 0 ;\n\n\t\tcase SFC_GET_FORMAT_MAJOR :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_FORMAT_INFO))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\treturn psf_get_format_major (data) ;\n\n\t\tcase SFC_GET_FORMAT_SUBTYPE_COUNT :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (int))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\t*((int*) data) = psf_get_format_subtype_count () ;\n\t\t\treturn 0 ;\n\n\t\tcase SFC_GET_FORMAT_SUBTYPE :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_FORMAT_INFO))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\treturn psf_get_format_subtype (data) ;\n\n\t\tcase SFC_GET_FORMAT_INFO :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_FORMAT_INFO))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\treturn psf_get_format_info (data) ;\n\t\t} ;\n\n\tif (sndfile == NULL && command == SFC_GET_LOG_INFO)\n\t{\tif (data == NULL)\n\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\tsnprintf (data, datasize, \"%s\", sf_parselog) ;\n\t\treturn strlen (data) ;\n\t\t} ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tswitch (command)\n\t{\tcase SFC_SET_NORM_FLOAT :\n\t\t\told_value = psf->norm_float ;\n\t\t\tpsf->norm_float = (datasize) ? SF_TRUE : SF_FALSE ;\n\t\t\treturn old_value ;\n\n\t\tcase SFC_GET_CURRENT_SF_INFO :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_INFO))\n\t\t\t\treturn (sf_errno = SFE_BAD_COMMAND_PARAM) ;\n\t\t\tmemcpy (data, &psf->sf, sizeof (SF_INFO)) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_SET_NORM_DOUBLE :\n\t\t\told_value = psf->norm_double ;\n\t\t\tpsf->norm_double = (datasize) ? SF_TRUE : SF_FALSE ;\n\t\t\treturn old_value ;\n\n\t\tcase SFC_GET_NORM_FLOAT :\n\t\t\treturn psf->norm_float ;\n\n\t\tcase SFC_GET_NORM_DOUBLE :\n\t\t\treturn psf->norm_double ;\n\n\t\tcase SFC_SET_SCALE_FLOAT_INT_READ :\n\t\t\told_value = psf->float_int_mult ;\n\n\t\t\tpsf->float_int_mult = (datasize != 0) ? SF_TRUE : SF_FALSE ;\n\t\t\tif (psf->float_int_mult && psf->float_max < 0.0)\n\t\t\t\t/* Scale to prevent wrap-around distortion. */\n\t\t\t\tpsf->float_max = (32768.0 / 32767.0) * psf_calc_signal_max (psf, SF_FALSE) ;\n\t\t\treturn old_value ;\n\n\t\tcase SFC_SET_SCALE_INT_FLOAT_WRITE :\n\t\t\told_value = psf->scale_int_float ;\n\t\t\tpsf->scale_int_float = (datasize != 0) ? SF_TRUE : SF_FALSE ;\n\t\t\treturn old_value ;\n\n\t\tcase SFC_SET_ADD_PEAK_CHUNK :\n\t\t\t{\tint format = SF_CONTAINER (psf->sf.format) ;\n\n\t\t\t\t/* Only WAV and AIFF support the PEAK chunk. */\n\t\t\t\tswitch (format)\n\t\t\t\t{\tcase SF_FORMAT_AIFF :\n\t\t\t\t\tcase SF_FORMAT_CAF :\n\t\t\t\t\tcase SF_FORMAT_WAV :\n\t\t\t\t\tcase SF_FORMAT_WAVEX :\n\t\t\t\t\tcase SF_FORMAT_RF64 :\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tdefault :\n\t\t\t\t\t\treturn SF_FALSE ;\n\t\t\t\t\t} ;\n\n\t\t\t\tformat = SF_CODEC (psf->sf.format) ;\n\n\t\t\t\t/* Only files containg the following data types support the PEAK chunk. */\n\t\t\t\tif (format != SF_FORMAT_FLOAT && format != SF_FORMAT_DOUBLE)\n\t\t\t\t\treturn SF_FALSE ;\n\n\t\t\t\t} ;\n\t\t\t/* Can only do this is in SFM_WRITE mode. */\n\t\t\tif (psf->file.mode != SFM_WRITE && psf->file.mode != SFM_RDWR)\n\t\t\t\treturn SF_FALSE ;\n\t\t\t/* If data has already been written this must fail. */\n\t\t\tif (psf->have_written)\n\t\t\t{\tpsf->error = SFE_CMD_HAS_DATA ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\t/* Everything seems OK, so set psf->has_peak and re-write header. */\n\t\t\tif (datasize == SF_FALSE && psf->peak_info != NULL)\n\t\t\t{\tfree (psf->peak_info) ;\n\t\t\t\tpsf->peak_info = NULL ;\n\t\t\t\t}\n\t\t\telse if (psf->peak_info == NULL)\n\t\t\t{\tpsf->peak_info = peak_info_calloc (psf->sf.channels) ;\n\t\t\t\tif (psf->peak_info != NULL)\n\t\t\t\t\tpsf->peak_info->peak_loc = SF_PEAK_START ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->write_header)\n\t\t\t\tpsf->write_header (psf, SF_TRUE) ;\n\t\t\treturn datasize ;\n\n\t\tcase SFC_SET_ADD_HEADER_PAD_CHUNK :\n\t\t\treturn SF_FALSE ;\n\n\t\tcase SFC_GET_LOG_INFO :\n\t\t\tif (data == NULL)\n\t\t\t\treturn SFE_BAD_COMMAND_PARAM ;\n\t\t\tsnprintf (data, datasize, \"%s\", psf->parselog.buf) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_CALC_SIGNAL_MAX :\n\t\t\tif (data == NULL || datasize != sizeof (double))\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\t*((double*) data) = psf_calc_signal_max (psf, SF_FALSE) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_CALC_NORM_SIGNAL_MAX :\n\t\t\tif (data == NULL || datasize != sizeof (double))\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\t*((double*) data) = psf_calc_signal_max (psf, SF_TRUE) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_CALC_MAX_ALL_CHANNELS :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (double) * psf->sf.channels)\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\treturn psf_calc_max_all_channels (psf, (double*) data, SF_FALSE) ;\n\n\t\tcase SFC_CALC_NORM_MAX_ALL_CHANNELS :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (double) * psf->sf.channels)\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\treturn psf_calc_max_all_channels (psf, (double*) data, SF_TRUE) ;\n\n\t\tcase SFC_GET_SIGNAL_MAX :\n\t\t\tif (data == NULL || datasize != sizeof (double))\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\treturn psf_get_signal_max (psf, (double *) data) ;\n\n\t\tcase SFC_GET_MAX_ALL_CHANNELS :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (double) * psf->sf.channels)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\treturn psf_get_max_all_channels (psf, (double*) data) ;\n\n\t\tcase SFC_UPDATE_HEADER_NOW :\n\t\t\tif (psf->write_header)\n\t\t\t\tpsf->write_header (psf, SF_TRUE) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_SET_UPDATE_HEADER_AUTO :\n\t\t\tpsf->auto_header = datasize ? SF_TRUE : SF_FALSE ;\n\t\t\treturn psf->auto_header ;\n\t\t\tbreak ;\n\n\t\tcase SFC_SET_ADD_DITHER_ON_WRITE :\n\t\tcase SFC_SET_ADD_DITHER_ON_READ :\n\t\t\t/*\n\t\t\t** FIXME !\n\t\t\t** These are obsolete. Just return.\n\t\t\t** Remove some time after version 1.0.8.\n\t\t\t*/\n\t\t\tbreak ;\n\n\t\tcase SFC_SET_DITHER_ON_WRITE :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_DITHER_INFO))\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\tmemcpy (&psf->write_dither, data, sizeof (psf->write_dither)) ;\n\t\t\tif (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t\t\t\tdither_init (psf, SFM_WRITE) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_SET_DITHER_ON_READ :\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (SF_DITHER_INFO))\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\tmemcpy (&psf->read_dither, data, sizeof (psf->read_dither)) ;\n\t\t\tif (psf->file.mode == SFM_READ || psf->file.mode == SFM_RDWR)\n\t\t\t\tdither_init (psf, SFM_READ) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_FILE_TRUNCATE :\n\t\t\tif (psf->file.mode != SFM_WRITE && psf->file.mode != SFM_RDWR)\n\t\t\t\treturn SF_TRUE ;\n\t\t\tif (datasize != sizeof (sf_count_t))\n\t\t\t\treturn SF_TRUE ;\n\t\t\tif (data == NULL || datasize != sizeof (sf_count_t))\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t}\n\t\t\telse\n\t\t\t{\tsf_count_t position ;\n\n\t\t\t\tposition = *((sf_count_t*) data) ;\n\n\t\t\t\tif (sf_seek (sndfile, position, SEEK_SET) != position)\n\t\t\t\t\treturn SF_TRUE ;\n\n\t\t\t\tpsf->sf.frames = position ;\n\n\t\t\t\tposition = psf_fseek (psf, 0, SEEK_CUR) ;\n\n\t\t\t\treturn psf_ftruncate (psf, position) ;\n\t\t\t\t} ;\n\t\t\tbreak ;\n\n\t\tcase SFC_SET_RAW_START_OFFSET :\n\t\t\tif (data == NULL || datasize != sizeof (sf_count_t))\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\n\t\t\tif ((SF_CONTAINER (psf->sf.format)) != SF_FORMAT_RAW)\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\n\t\t\tpsf->dataoffset = *((sf_count_t*) data) ;\n\t\t\tsf_seek (sndfile, 0, SEEK_CUR) ;\n\t\t\tbreak ;\n\n\t\tcase SFC_GET_EMBED_FILE_INFO :\n\t\t\tif (data == NULL || datasize != sizeof (SF_EMBED_FILE_INFO))\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\n\t\t\t((SF_EMBED_FILE_INFO*) data)->offset = psf->fileoffset ;\n\t\t\t((SF_EMBED_FILE_INFO*) data)->length = psf->filelength ;\n\t\t\tbreak ;\n\n\t\t/* Lite remove start */\n\t\tcase SFC_TEST_IEEE_FLOAT_REPLACE :\n\t\t\tpsf->ieee_replace = (datasize) ? SF_TRUE : SF_FALSE ;\n\t\t\tif ((SF_CODEC (psf->sf.format)) == SF_FORMAT_FLOAT)\n\t\t\t\tfloat32_init (psf) ;\n\t\t\telse if ((SF_CODEC (psf->sf.format)) == SF_FORMAT_DOUBLE)\n\t\t\t\tdouble64_init (psf) ;\n\t\t\telse\n\t\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t\tbreak ;\n\t\t/* Lite remove end */\n\n\t\tcase SFC_SET_CLIPPING :\n\t\t\tpsf->add_clipping = (datasize) ? SF_TRUE : SF_FALSE ;\n\t\t\treturn psf->add_clipping ;\n\n\t\tcase SFC_GET_CLIPPING :\n\t\t\treturn psf->add_clipping ;\n\n\t\tcase SFC_GET_LOOP_INFO :\n\t\t\tif (datasize != sizeof (SF_LOOP_INFO) || data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (psf->loop_info == NULL)\n\t\t\t\treturn SF_FALSE ;\n\t\t\tmemcpy (data, psf->loop_info, sizeof (SF_LOOP_INFO)) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_SET_BROADCAST_INFO :\n\t\t\t{\tint format = SF_CONTAINER (psf->sf.format) ;\n\n\t\t\t\t/* Only WAV and RF64 supports the BEXT (Broadcast) chunk. */\n\t\t\t\tif (format != SF_FORMAT_WAV && format != SF_FORMAT_WAVEX && format != SF_FORMAT_RF64)\n\t\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\t/* Only makes sense in SFM_WRITE or SFM_RDWR mode. */\n\t\t\tif ((psf->file.mode != SFM_WRITE) && (psf->file.mode != SFM_RDWR))\n\t\t\t\treturn SF_FALSE ;\n\t\t\t/* If data has already been written this must fail. */\n\t\t\tif (psf->broadcast_16k == NULL && psf->have_written)\n\t\t\t{\tpsf->error = SFE_CMD_HAS_DATA ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\tif (NOT (broadcast_var_set (psf, data, datasize)))\n\t\t\t\treturn SF_FALSE ;\n\n\t\t\tif (psf->write_header)\n\t\t\t\tpsf->write_header (psf, SF_TRUE) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_GET_BROADCAST_INFO :\n\t\t\tif (data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\treturn broadcast_var_get (psf, data, datasize) ;\n\n\t\tcase SFC_SET_CART_INFO :\n\t\t\t{\tint format = SF_CONTAINER (psf->sf.format) ;\n\t\t\t\t/* Only WAV and RF64 support cart chunk format */\n\t\t\t\tif (format != SF_FORMAT_WAV && format != SF_FORMAT_RF64)\n\t\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\t/* Only makes sense in SFM_WRITE or SFM_RDWR mode */\n\t\t\tif ((psf->file.mode != SFM_WRITE) && (psf->file.mode != SFM_RDWR))\n\t\t\t\treturn SF_FALSE ;\n\t\t\t/* If data has already been written this must fail. */\n\t\t\tif (psf->cart_16k == NULL && psf->have_written)\n\t\t\t{\tpsf->error = SFE_CMD_HAS_DATA ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (NOT (cart_var_set (psf, data, datasize)))\n\t\t\t\treturn SF_FALSE ;\n\t\t\tif (psf->write_header)\n\t\t\t\tpsf->write_header (psf, SF_TRUE) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_GET_CART_INFO :\n\t\t\tif (data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\treturn cart_var_get (psf, data, datasize) ;\n\n\t\tcase SFC_GET_CUE_COUNT :\n\t\t\tif (datasize != sizeof (uint32_t) || data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (psf->cues != NULL)\n\t\t\t{\t*((uint32_t *) data) = psf->cues->cue_count ;\n\t\t\t\treturn SF_TRUE ;\n\t\t\t\t} ;\n\t\t\treturn SF_FALSE ;\n\n\t\tcase SFC_GET_CUE :\n\t\t\tif (datasize != sizeof (SF_CUES) || data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (psf->cues == NULL)\n\t\t\t\treturn SF_FALSE ;\n\t\t\tpsf_get_cues (psf, data, datasize) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_SET_CUE :\n\t\t\tif (psf->have_written)\n\t\t\t{\tpsf->error = SFE_CMD_HAS_DATA ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (datasize != sizeof (SF_CUES) || data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->cues == NULL && (psf->cues = psf_cues_dup (data)) == NULL)\n\t\t\t{\tpsf->error = SFE_MALLOC_FAILED ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_GET_INSTRUMENT :\n\t\t\tif (datasize != sizeof (SF_INSTRUMENT) || data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (psf->instrument == NULL)\n\t\t\t\treturn SF_FALSE ;\n\t\t\tmemcpy (data, psf->instrument, sizeof (SF_INSTRUMENT)) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_SET_INSTRUMENT :\n\t\t\t/* If data has already been written this must fail. */\n\t\t\tif (psf->have_written)\n\t\t\t{\tpsf->error = SFE_CMD_HAS_DATA ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (datasize != sizeof (SF_INSTRUMENT) || data == NULL)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->instrument == NULL && (psf->instrument = psf_instrument_alloc ()) == NULL)\n\t\t\t{\tpsf->error = SFE_MALLOC_FAILED ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tmemcpy (psf->instrument, data, sizeof (SF_INSTRUMENT)) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_RAW_DATA_NEEDS_ENDSWAP :\n\t\t\treturn psf->data_endswap ;\n\n\t\tcase SFC_GET_CHANNEL_MAP_INFO :\n\t\t\tif (psf->channel_map == NULL)\n\t\t\t\treturn SF_FALSE ;\n\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (psf->channel_map [0]) * psf->sf.channels)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\tmemcpy (data, psf->channel_map, datasize) ;\n\t\t\treturn SF_TRUE ;\n\n\t\tcase SFC_SET_CHANNEL_MAP_INFO :\n\t\t\tif (psf->have_written)\n\t\t\t{\tpsf->error = SFE_CMD_HAS_DATA ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\t\t\tif (data == NULL || datasize != SIGNED_SIZEOF (psf->channel_map [0]) * psf->sf.channels)\n\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\t{\tint *iptr ;\n\n\t\t\t\tfor (iptr = data ; iptr < (int*) data + psf->sf.channels ; iptr++)\n\t\t\t\t{\tif (*iptr <= SF_CHANNEL_MAP_INVALID || *iptr >= SF_CHANNEL_MAP_MAX)\n\t\t\t\t\t{\tpsf->error = SFE_BAD_COMMAND_PARAM ;\n\t\t\t\t\t\treturn SF_FALSE ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\t} ;\n\t\t\t\t} ;\n\n\t\t\tfree (psf->channel_map) ;\n\t\t\tif ((psf->channel_map = malloc (datasize)) == NULL)\n\t\t\t{\tpsf->error = SFE_MALLOC_FAILED ;\n\t\t\t\treturn SF_FALSE ;\n\t\t\t\t} ;\n\n\t\t\tmemcpy (psf->channel_map, data, datasize) ;\n\n\t\t\t/*\n\t\t\t**\tPass the command down to the container's command handler.\n\t\t\t**\tDon't pass user data, use validated psf->channel_map data instead.\n\t\t\t*/\n\t\t\tif (psf->command)\n\t\t\t\treturn psf->command (psf, command, NULL, 0) ;\n\t\t\treturn SF_FALSE ;\n\n\t\tcase SFC_SET_VBR_ENCODING_QUALITY :\n\t\t\tif (data == NULL || datasize != sizeof (double))\n\t\t\t\treturn SF_FALSE ;\n\n\t\t\tquality = *((double *) data) ;\n\t\t\tquality = 1.0 - SF_MAX (0.0, SF_MIN (1.0, quality)) ;\n\t\t\treturn sf_command (sndfile, SFC_SET_COMPRESSION_LEVEL, &quality, sizeof (quality)) ;\n\n\n\t\tdefault :\n\t\t\t/* Must be a file specific command. Pass it on. */\n\t\t\tif (psf->command)\n\t\t\t\treturn psf->command (psf, command, data, datasize) ;\n\n\t\t\tpsf_log_printf (psf, \"*** sf_command : cmd = 0x%X\\n\", command) ;\n\t\t\treturn (psf->error = SFE_BAD_COMMAND_PARAM) ;\n\t\t} ;\n\n\treturn 0 ;\n} /* sf_command */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_seek\t(SNDFILE *sndfile, sf_count_t offset, int whence)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tseek_from_start = 0, retval ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (! psf->sf.seekable)\n\t{\tpsf->error = SFE_NOT_SEEKABLE ;\n\t\treturn\tPSF_SEEK_ERROR ;\n\t\t} ;\n\n\t/* If the whence parameter has a mode ORed in, check to see that\n\t** it makes sense.\n\t*/\n\tif (((whence & SFM_MASK) == SFM_WRITE && psf->file.mode == SFM_READ) ||\n\t\t\t((whence & SFM_MASK) == SFM_READ && psf->file.mode == SFM_WRITE))\n\t{\tpsf->error = SFE_WRONG_SEEK ;\n\t\treturn PSF_SEEK_ERROR ;\n\t\t} ;\n\n\t/* Convert all SEEK_CUR and SEEK_END into seek_from_start to be\n\t** used with SEEK_SET.\n\t*/\n\tswitch (whence)\n\t{\t/* The SEEK_SET behaviour is independant of mode. */\n\t\tcase SEEK_SET :\n\t\tcase SEEK_SET | SFM_READ :\n\t\tcase SEEK_SET | SFM_WRITE :\n\t\tcase SEEK_SET | SFM_RDWR :\n\t\t\t\tseek_from_start = offset ;\n\t\t\t\tbreak ;\n\n\t\t/* The SEEK_CUR is a little more tricky. */\n\t\tcase SEEK_CUR :\n\t\t\t\tif (offset == 0)\n\t\t\t\t{\tif (psf->file.mode == SFM_READ)\n\t\t\t\t\t\treturn psf->read_current ;\n\t\t\t\t\tif (psf->file.mode == SFM_WRITE)\n\t\t\t\t\t\treturn psf->write_current ;\n\t\t\t\t\t} ;\n\t\t\t\tif (psf->file.mode == SFM_READ)\n\t\t\t\t\tseek_from_start = psf->read_current + offset ;\n\t\t\t\telse if (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t\t\t\t\tseek_from_start = psf->write_current + offset ;\n\t\t\t\telse\n\t\t\t\t\tpsf->error = SFE_AMBIGUOUS_SEEK ;\n\t\t\t\tbreak ;\n\n\t\tcase SEEK_CUR | SFM_READ :\n\t\t\t\tif (offset == 0)\n\t\t\t\t\treturn psf->read_current ;\n\t\t\t\tseek_from_start = psf->read_current + offset ;\n\t\t\t\tbreak ;\n\n\t\tcase SEEK_CUR | SFM_WRITE :\n\t\t\t\tif (offset == 0)\n\t\t\t\t\treturn psf->write_current ;\n\t\t\t\tseek_from_start = psf->write_current + offset ;\n\t\t\t\tbreak ;\n\n\t\t/* The SEEK_END */\n\t\tcase SEEK_END :\n\t\tcase SEEK_END | SFM_READ :\n\t\tcase SEEK_END | SFM_WRITE :\n\t\t\t\tseek_from_start = psf->sf.frames + offset ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\tpsf->error = SFE_BAD_SEEK ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tif (psf->error)\n\t\treturn PSF_SEEK_ERROR ;\n\n\tif (psf->file.mode == SFM_RDWR || psf->file.mode == SFM_WRITE)\n\t{\tif (seek_from_start < 0)\n\t\t{\tpsf->error = SFE_BAD_SEEK ;\n\t\t\treturn PSF_SEEK_ERROR ;\n\t\t\t} ;\n\t\t}\n\telse if (seek_from_start < 0 || seek_from_start > psf->sf.frames)\n\t{\tpsf->error = SFE_BAD_SEEK ;\n\t\treturn PSF_SEEK_ERROR ;\n\t\t} ;\n\n\tif (psf->seek)\n\t{\tint new_mode = (whence & SFM_MASK) ? (whence & SFM_MASK) : psf->file.mode ;\n\n\t\tretval = psf->seek (psf, new_mode, seek_from_start) ;\n\n\t\tswitch (new_mode)\n\t\t{\tcase SFM_READ :\n\t\t\t\t\tpsf->read_current = retval ;\n\t\t\t\t\tbreak ;\n\t\t\tcase SFM_WRITE :\n\t\t\t\t\tpsf->write_current = retval ;\n\t\t\t\t\tbreak ;\n\t\t\tcase SFM_RDWR :\n\t\t\t\t\tpsf->read_current = retval ;\n\t\t\t\t\tpsf->write_current = retval ;\n\t\t\t\t\tnew_mode = SFM_READ ;\n\t\t\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tpsf->last_op = new_mode ;\n\n\t\treturn retval ;\n\t\t} ;\n\n\tpsf->error = SFE_AMBIGUOUS_SEEK ;\n\treturn PSF_SEEK_ERROR ;\n} /* sf_seek */\n\n/*------------------------------------------------------------------------------\n*/\n\nconst char*\nsf_get_string (SNDFILE *sndfile, int str_type)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((psf = (SF_PRIVATE*) sndfile) == NULL)\n\t\treturn NULL ;\n\tif (psf->Magick != SNDFILE_MAGICK)\n\t\treturn NULL ;\n\n\treturn psf_get_string (psf, str_type) ;\n} /* sf_get_string */\n\nint\nsf_set_string (SNDFILE *sndfile, int str_type, const char* str)\n{\tSF_PRIVATE \t*psf ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\treturn psf_set_string (psf, str_type, str) ;\n} /* sf_get_string */\n\n/*------------------------------------------------------------------------------\n*/\n\nint\nsf_current_byterate (SNDFILE *sndfile)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((psf = (SF_PRIVATE*) sndfile) == NULL)\n\t\treturn -1 ;\n\tif (psf->Magick != SNDFILE_MAGICK)\n\t\treturn -1 ;\n\n\t/* This should cover all PCM and floating point formats. */\n\tif (psf->bytewidth)\n\t\treturn psf->sf.samplerate * psf->sf.channels * psf->bytewidth ;\n\n\tif (psf->byterate)\n\t\treturn psf->byterate (psf) ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_IMA_ADPCM :\n\t\tcase SF_FORMAT_MS_ADPCM :\n\t\tcase SF_FORMAT_VOX_ADPCM :\n\t\t\treturn (psf->sf.samplerate * psf->sf.channels) / 2 ;\n\n\t\tcase SF_FORMAT_GSM610 :\n\t\t\treturn (psf->sf.samplerate * psf->sf.channels * 13000) / 8000 ;\n\n\t\tcase SF_FORMAT_G721_32 :\t/* 32kbs G721 ADPCM encoding. */\n\t\t\treturn (psf->sf.samplerate * psf->sf.channels) / 2 ;\n\n\t\tcase SF_FORMAT_G723_24 :\t/* 24kbs G723 ADPCM encoding. */\n\t\t\treturn (psf->sf.samplerate * psf->sf.channels * 3) / 8 ;\n\n\t\tcase SF_FORMAT_G723_40 :\t/* 40kbs G723 ADPCM encoding. */\n\t\t\treturn (psf->sf.samplerate * psf->sf.channels * 5) / 8 ;\n\n\t\tdefault :\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn -1 ;\n} /* sf_current_byterate */\n\n/*==============================================================================\n*/\n\nsf_count_t\nsf_read_raw\t\t(SNDFILE *sndfile, void *ptr, sf_count_t bytes)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\tint\t\t\tbytewidth, blockwidth ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tbytewidth = (psf->bytewidth > 0) ? psf->bytewidth : 1 ;\n\tblockwidth = (psf->blockwidth > 0) ? psf->blockwidth : 1 ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (bytes < 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, bytes) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (bytes % (psf->sf.channels * bytewidth))\n\t{\tpsf->error = SFE_BAD_READ_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf_fread (ptr, 1, bytes, psf) ;\n\n\tif (psf->read_current + count / blockwidth <= psf->sf.frames)\n\t\tpsf->read_current += count / blockwidth ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * blockwidth ;\n\t\textra = bytes - count ;\n\t\tpsf_memset (((char *) ptr) + count, 0, extra) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count ;\n} /* sf_read_raw */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_read_short\t(SNDFILE *sndfile, short *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_READ_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, len * sizeof (short)) ;\n\t\treturn 0 ; /* End of file. */\n\t\t} ;\n\n\tif (psf->read_short == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_short (psf, ptr, len) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = len - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (short)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count ;\n} /* sf_read_short */\n\nsf_count_t\nsf_readf_short\t\t(SNDFILE *sndfile, short *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (frames <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, frames * psf->sf.channels * sizeof (short)) ;\n\t\treturn 0 ; /* End of file. */\n\t\t} ;\n\n\tif (psf->read_short == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_short (psf, ptr, frames * psf->sf.channels) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = frames * psf->sf.channels - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (short)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_readf_short */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_read_int\t\t(SNDFILE *sndfile, int *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_READ_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, len * sizeof (int)) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->read_int == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_int (psf, ptr, len) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = len - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (int)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count ;\n} /* sf_read_int */\n\nsf_count_t\nsf_readf_int\t(SNDFILE *sndfile, int *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (frames <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, frames * psf->sf.channels * sizeof (int)) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->read_int == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_int (psf, ptr, frames * psf->sf.channels) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = frames * psf->sf.channels - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (int)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_readf_int */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_read_float\t(SNDFILE *sndfile, float *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_READ_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, len * sizeof (float)) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->read_float == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_float (psf, ptr, len) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = len - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (float)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count ;\n} /* sf_read_float */\n\nsf_count_t\nsf_readf_float\t(SNDFILE *sndfile, float *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (frames <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, frames * psf->sf.channels * sizeof (float)) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->read_float == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_float (psf, ptr, frames * psf->sf.channels) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = frames * psf->sf.channels - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (float)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_readf_float */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_read_double\t(SNDFILE *sndfile, double *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_READ_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, len * sizeof (double)) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->read_double == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_double (psf, ptr, len) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = len - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (double)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count ;\n} /* sf_read_double */\n\nsf_count_t\nsf_readf_double\t(SNDFILE *sndfile, double *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (frames <= 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, frames * psf->sf.channels * sizeof (double)) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->read_double == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf->read_double (psf, ptr, frames * psf->sf.channels) ;\n\n\tif (psf->read_current + count / psf->sf.channels <= psf->sf.frames)\n\t\tpsf->read_current += count / psf->sf.channels ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * psf->sf.channels ;\n\t\textra = frames * psf->sf.channels - count ;\n\t\tpsf_memset (ptr + count, 0, extra * sizeof (double)) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_readf_double */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_write_raw\t(SNDFILE *sndfile, const void *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\tint\t\t\tbytewidth, blockwidth ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tbytewidth = (psf->bytewidth > 0) ? psf->bytewidth : 1 ;\n\tblockwidth = (psf->blockwidth > 0) ? psf->blockwidth : 1 ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % (psf->sf.channels * bytewidth))\n\t{\tpsf->error = SFE_BAD_WRITE_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf_fwrite (ptr, 1, len, psf) ;\n\n\tpsf->write_current += count / blockwidth ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count ;\n} /* sf_write_raw */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_write_short\t(SNDFILE *sndfile, const short *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_WRITE_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_short == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_short (psf, ptr, len) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count ;\n} /* sf_write_short */\n\nsf_count_t\nsf_writef_short\t(SNDFILE *sndfile, const short *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_short == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_short (psf, ptr, frames * psf->sf.channels) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_writef_short */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_write_int\t(SNDFILE *sndfile, const int *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_WRITE_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_int == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_int (psf, ptr, len) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count ;\n} /* sf_write_int */\n\nsf_count_t\nsf_writef_int\t(SNDFILE *sndfile, const int *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_int == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_int (psf, ptr, frames * psf->sf.channels) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_writef_int */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_write_float\t(SNDFILE *sndfile, const float *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_WRITE_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_float == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_float (psf, ptr, len) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count ;\n} /* sf_write_float */\n\nsf_count_t\nsf_writef_float\t(SNDFILE *sndfile, const float *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_float == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_float (psf, ptr, frames * psf->sf.channels) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_writef_float */\n\n/*------------------------------------------------------------------------------\n*/\n\nsf_count_t\nsf_write_double\t(SNDFILE *sndfile, const double *ptr, sf_count_t len)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (len % psf->sf.channels)\n\t{\tpsf->error = SFE_BAD_WRITE_ALIGN ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (psf->write_double == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_double (psf, ptr, len) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count ;\n} /* sf_write_double */\n\nsf_count_t\nsf_writef_double\t(SNDFILE *sndfile, const double *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_double == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_double (psf, ptr, frames * psf->sf.channels) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_writef_double */\n\n/*=========================================================================\n** Private functions.\n*/\n\nstatic int\ntry_resource_fork (SF_PRIVATE * psf)\n{\tint old_error = psf->error ;\n\n\t/* Set READ mode now, to see if resource fork exists. */\n\tpsf->rsrc.mode = SFM_READ ;\n\tif (psf_open_rsrc (psf) != 0)\n\t{\tpsf->error = old_error ;\n\t\treturn 0 ;\n\t\t} ;\n\n\t/* More checking here. */\n\tpsf_log_printf (psf, \"Resource fork : %s\\n\", psf->rsrc.path.c) ;\n\n\treturn SF_FORMAT_SD2 ;\n} /* try_resource_fork */\n\nstatic int\nformat_from_extension (SF_PRIVATE *psf)\n{\tchar *cptr ;\n\tchar buffer [16] ;\n\tint format = 0 ;\n\n\tif ((cptr = strrchr (psf->file.name.c, '.')) == NULL)\n\t\treturn 0 ;\n\n\tcptr ++ ;\n\tif (strlen (cptr) > sizeof (buffer) - 1)\n\t\treturn 0 ;\n\n\tpsf_strlcpy (buffer, sizeof (buffer), cptr) ;\n\tbuffer [sizeof (buffer) - 1] = 0 ;\n\n\t/* Convert everything in the buffer to lower case. */\n\tcptr = buffer ;\n\twhile (*cptr)\n\t{\t*cptr = tolower (*cptr) ;\n\t\tcptr ++ ;\n\t\t} ;\n\n\tcptr = buffer ;\n\n\tif (strcmp (cptr, \"au\") == 0)\n\t{\tpsf->sf.channels = 1 ;\n\t\tpsf->sf.samplerate = 8000 ;\n\t\tformat = SF_FORMAT_RAW | SF_FORMAT_ULAW ;\n\t\t}\n\telse if (strcmp (cptr, \"snd\") == 0)\n\t{\tpsf->sf.channels = 1 ;\n\t\tpsf->sf.samplerate = 8000 ;\n\t\tformat = SF_FORMAT_RAW | SF_FORMAT_ULAW ;\n\t\t}\n\n\telse if (strcmp (cptr, \"vox\") == 0 || strcmp (cptr, \"vox8\") == 0)\n\t{\tpsf->sf.channels = 1 ;\n\t\tpsf->sf.samplerate = 8000 ;\n\t\tformat = SF_FORMAT_RAW | SF_FORMAT_VOX_ADPCM ;\n\t\t}\n\telse if (strcmp (cptr, \"vox6\") == 0)\n\t{\tpsf->sf.channels = 1 ;\n\t\tpsf->sf.samplerate = 6000 ;\n\t\tformat = SF_FORMAT_RAW | SF_FORMAT_VOX_ADPCM ;\n\t\t}\n\telse if (strcmp (cptr, \"gsm\") == 0)\n\t{\tpsf->sf.channels = 1 ;\n\t\tpsf->sf.samplerate = 8000 ;\n\t\tformat = SF_FORMAT_RAW | SF_FORMAT_GSM610 ;\n\t\t}\n\n\t/* For RAW files, make sure the dataoffset if set correctly. */\n\tif ((SF_CONTAINER (format)) == SF_FORMAT_RAW)\n\t\tpsf->dataoffset = 0 ;\n\n\treturn format ;\n} /* format_from_extension */\n\nstatic int\nguess_file_type (SF_PRIVATE *psf)\n{\tuint32_t buffer [3], format ;\n\n\tif (psf_binheader_readf (psf, \"b\", &buffer, SIGNED_SIZEOF (buffer)) != SIGNED_SIZEOF (buffer))\n\t{\tpsf->error = SFE_BAD_FILE_READ ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif ((buffer [0] == MAKE_MARKER ('R', 'I', 'F', 'F') || buffer [0] == MAKE_MARKER ('R', 'I', 'F', 'X'))\n\t\t\t&& buffer [2] == MAKE_MARKER ('W', 'A', 'V', 'E'))\n\t\treturn SF_FORMAT_WAV ;\n\n\tif (buffer [0] == MAKE_MARKER ('F', 'O', 'R', 'M'))\n\t{\tif (buffer [2] == MAKE_MARKER ('A', 'I', 'F', 'F') || buffer [2] == MAKE_MARKER ('A', 'I', 'F', 'C'))\n\t\t\treturn SF_FORMAT_AIFF ;\n\t\tif (buffer [2] == MAKE_MARKER ('8', 'S', 'V', 'X') || buffer [2] == MAKE_MARKER ('1', '6', 'S', 'V'))\n\t\t\treturn SF_FORMAT_SVX ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (buffer [0] == MAKE_MARKER ('.', 's', 'n', 'd') || buffer [0] == MAKE_MARKER ('d', 'n', 's', '.'))\n\t\treturn SF_FORMAT_AU ;\n\n\tif ((buffer [0] == MAKE_MARKER ('f', 'a', 'p', ' ') || buffer [0] == MAKE_MARKER (' ', 'p', 'a', 'f')))\n\t\treturn SF_FORMAT_PAF ;\n\n\tif (buffer [0] == MAKE_MARKER ('N', 'I', 'S', 'T'))\n\t\treturn SF_FORMAT_NIST ;\n\n\tif (buffer [0] == MAKE_MARKER ('C', 'r', 'e', 'a') && buffer [1] == MAKE_MARKER ('t', 'i', 'v', 'e'))\n\t\treturn SF_FORMAT_VOC ;\n\n\tif ((buffer [0] & MAKE_MARKER (0xFF, 0xFF, 0xF8, 0xFF)) == MAKE_MARKER (0x64, 0xA3, 0x00, 0x00) ||\n\t\t(buffer [0] & MAKE_MARKER (0xFF, 0xF8, 0xFF, 0xFF)) == MAKE_MARKER (0x00, 0x00, 0xA3, 0x64))\n\t\treturn SF_FORMAT_IRCAM ;\n\n\tif (buffer [0] == MAKE_MARKER ('r', 'i', 'f', 'f'))\n\t\treturn SF_FORMAT_W64 ;\n\n\tif (buffer [0] == MAKE_MARKER (0, 0, 0x03, 0xE8) && buffer [1] == MAKE_MARKER (0, 0, 0, 1) &&\n\t\t\t\t\t\t\t\tbuffer [2] == MAKE_MARKER (0, 0, 0, 1))\n\t\treturn SF_FORMAT_MAT4 ;\n\n\tif (buffer [0] == MAKE_MARKER (0, 0, 0, 0) && buffer [1] == MAKE_MARKER (1, 0, 0, 0) &&\n\t\t\t\t\t\t\t\tbuffer [2] == MAKE_MARKER (1, 0, 0, 0))\n\t\treturn SF_FORMAT_MAT4 ;\n\n\tif (buffer [0] == MAKE_MARKER ('M', 'A', 'T', 'L') && buffer [1] == MAKE_MARKER ('A', 'B', ' ', '5'))\n\t\treturn SF_FORMAT_MAT5 ;\n\n\tif (buffer [0] == MAKE_MARKER ('P', 'V', 'F', '1'))\n\t\treturn SF_FORMAT_PVF ;\n\n\tif (buffer [0] == MAKE_MARKER ('E', 'x', 't', 'e') && buffer [1] == MAKE_MARKER ('n', 'd', 'e', 'd') &&\n\t\t\t\t\t\t\t\tbuffer [2] == MAKE_MARKER (' ', 'I', 'n', 's'))\n\t\treturn SF_FORMAT_XI ;\n\n\tif (buffer [0] == MAKE_MARKER ('c', 'a', 'f', 'f') && buffer [2] == MAKE_MARKER ('d', 'e', 's', 'c'))\n\t\treturn SF_FORMAT_CAF ;\n\n\tif (buffer [0] == MAKE_MARKER ('O', 'g', 'g', 'S'))\n\t\treturn SF_FORMAT_OGG ;\n\n\tif (buffer [0] == MAKE_MARKER ('A', 'L', 'a', 'w') && buffer [1] == MAKE_MARKER ('S', 'o', 'u', 'n')\n\t\t\t&& buffer [2] == MAKE_MARKER ('d', 'F', 'i', 'l'))\n\t\treturn SF_FORMAT_WVE ;\n\n\tif (buffer [0] == MAKE_MARKER ('D', 'i', 'a', 'm') && buffer [1] == MAKE_MARKER ('o', 'n', 'd', 'W')\n\t\t\t&& buffer [2] == MAKE_MARKER ('a', 'r', 'e', ' '))\n\t\treturn SF_FORMAT_DWD ;\n\n\tif (buffer [0] == MAKE_MARKER ('L', 'M', '8', '9') || buffer [0] == MAKE_MARKER ('5', '3', 0, 0))\n\t\treturn SF_FORMAT_TXW ;\n\n\tif ((buffer [0] & MAKE_MARKER (0xFF, 0xFF, 0x80, 0xFF)) == MAKE_MARKER (0xF0, 0x7E, 0, 0x01))\n\t\treturn SF_FORMAT_SDS ;\n\n\tif ((buffer [0] & MAKE_MARKER (0xFF, 0xFF, 0, 0)) == MAKE_MARKER (1, 4, 0, 0))\n\t\treturn SF_FORMAT_MPC2K ;\n\n\tif (buffer [0] == MAKE_MARKER ('C', 'A', 'T', ' ') && buffer [2] == MAKE_MARKER ('R', 'E', 'X', '2'))\n\t\treturn SF_FORMAT_REX2 ;\n\n\tif (buffer [0] == MAKE_MARKER (0x30, 0x26, 0xB2, 0x75) && buffer [1] == MAKE_MARKER (0x8E, 0x66, 0xCF, 0x11))\n\t\treturn 0 /*-SF_FORMAT_WMA-*/ ;\n\n\t/* HMM (Hidden Markov Model) Tool Kit. */\n\tif (buffer [2] == MAKE_MARKER (0, 2, 0, 0) && 2 * ((int64_t) BE2H_32 (buffer [0])) + 12 == psf->filelength)\n\t\treturn SF_FORMAT_HTK ;\n\n\tif (buffer [0] == MAKE_MARKER ('f', 'L', 'a', 'C'))\n\t\treturn SF_FORMAT_FLAC ;\n\n\tif (buffer [0] == MAKE_MARKER ('2', 'B', 'I', 'T'))\n\t\treturn SF_FORMAT_AVR ;\n\n\tif (buffer [0] == MAKE_MARKER ('R', 'F', '6', '4') && buffer [2] == MAKE_MARKER ('W', 'A', 'V', 'E'))\n\t\treturn SF_FORMAT_RF64 ;\n\n\tif (buffer [0] == MAKE_MARKER ('I', 'D', '3', 3))\n\t{\tpsf_log_printf (psf, \"Found 'ID3' marker.\\n\") ;\n\t\tif (id3_skip (psf))\n\t\t\treturn guess_file_type (psf) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\t/* Turtle Beach SMP 16-bit */\n\tif (buffer [0] == MAKE_MARKER ('S', 'O', 'U', 'N') && buffer [1] == MAKE_MARKER ('D', ' ', 'S', 'A'))\n\t\treturn 0 ;\n\n\t/* Yamaha sampler format. */\n\tif (buffer [0] == MAKE_MARKER ('S', 'Y', '8', '0') || buffer [0] == MAKE_MARKER ('S', 'Y', '8', '5'))\n\t\treturn 0 ;\n\n\tif (buffer [0] == MAKE_MARKER ('a', 'j', 'k', 'g'))\n\t\treturn 0 /*-SF_FORMAT_SHN-*/ ;\n\n\t/* This must be the last one. */\n\tif (psf->filelength > 0 && (format = try_resource_fork (psf)) != 0)\n\t\treturn format ;\n\n\treturn 0 ;\n} /* guess_file_type */\n\n\nstatic int\nvalidate_sfinfo (SF_INFO *sfinfo)\n{\tif (sfinfo->samplerate < 1)\n\t\treturn 0 ;\n\tif (sfinfo->frames < 0)\n\t\treturn 0 ;\n\tif (sfinfo->channels < 1)\n\t\treturn 0 ;\n\tif ((SF_CONTAINER (sfinfo->format)) == 0)\n\t\treturn 0 ;\n\tif ((SF_CODEC (sfinfo->format)) == 0)\n\t\treturn 0 ;\n\tif (sfinfo->sections < 1)\n\t\treturn 0 ;\n\treturn 1 ;\n} /* validate_sfinfo */\n\nstatic int\nvalidate_psf (SF_PRIVATE *psf)\n{\n\tif (psf->datalength < 0)\n\t{\tpsf_log_printf (psf, \"Invalid SF_PRIVATE field : datalength == %D.\\n\", psf->datalength) ;\n\t\treturn 0 ;\n\t\t} ;\n\tif (psf->dataoffset < 0)\n\t{\tpsf_log_printf (psf, \"Invalid SF_PRIVATE field : dataoffset == %D.\\n\", psf->dataoffset) ;\n\t\treturn 0 ;\n\t\t} ;\n\tif (psf->blockwidth && psf->blockwidth != psf->sf.channels * psf->bytewidth)\n\t{\tpsf_log_printf (psf, \"Invalid SF_PRIVATE field : channels * bytewidth == %d.\\n\",\n\t\t\t\t\t\t\t\tpsf->sf.channels * psf->bytewidth) ;\n\t\treturn 0 ;\n\t\t} ;\n\treturn 1 ;\n} /* validate_psf */\n\nstatic void\nsave_header_info (SF_PRIVATE *psf)\n{\tsnprintf (sf_parselog, sizeof (sf_parselog), \"%s\", psf->parselog.buf) ;\n} /* save_header_info */\n\nstatic int\ncopy_filename (SF_PRIVATE *psf, const char *path)\n{\tconst char *ccptr ;\n\tchar *cptr ;\n\n\tif (strlen (path) > 1 && strlen (path) - 1 >= sizeof (psf->file.path.c))\n\t{\tpsf->error = SFE_FILENAME_TOO_LONG ;\n\t\treturn psf->error ;\n\t\t} ;\n\n\tsnprintf (psf->file.path.c, sizeof (psf->file.path.c), \"%s\", path) ;\n\tif ((ccptr = strrchr (path, '/')) || (ccptr = strrchr (path, '\\\\')))\n\t\tccptr ++ ;\n\telse\n\t\tccptr = path ;\n\n\tsnprintf (psf->file.name.c, sizeof (psf->file.name.c), \"%s\", ccptr) ;\n\n\t/* Now grab the directory. */\n\tsnprintf (psf->file.dir.c, sizeof (psf->file.dir.c), \"%s\", path) ;\n\tif ((cptr = strrchr (psf->file.dir.c, '/')) || (cptr = strrchr (psf->file.dir.c, '\\\\')))\n\t\tcptr [1] = 0 ;\n\telse\n\t\tpsf->file.dir.c [0] = 0 ;\n\n\treturn 0 ;\n} /* copy_filename */\n\n/*==============================================================================\n*/\n\nstatic int\npsf_close (SF_PRIVATE *psf)\n{\tuint32_t k ;\n\tint\terror = 0 ;\n\n\tif (psf->codec_close)\n\t{\terror = psf->codec_close (psf) ;\n\t\t/* To prevent it being called in psf->container_close(). */\n\t\tpsf->codec_close = NULL ;\n\t\t} ;\n\n\tif (psf->container_close)\n\t\terror = psf->container_close (psf) ;\n\n\terror = psf_fclose (psf) ;\n\tpsf_close_rsrc (psf) ;\n\n\t/* For an ISO C compliant implementation it is ok to free a NULL pointer. */\n\tfree (psf->header.ptr) ;\n\tfree (psf->container_data) ;\n\tfree (psf->codec_data) ;\n\tfree (psf->interleave) ;\n\tfree (psf->dither) ;\n\tfree (psf->peak_info) ;\n\tfree (psf->broadcast_16k) ;\n\tfree (psf->loop_info) ;\n\tfree (psf->instrument) ;\n\tfree (psf->cues) ;\n\tfree (psf->channel_map) ;\n\tfree (psf->format_desc) ;\n\tfree (psf->strings.storage) ;\n\n\tif (psf->wchunks.chunks)\n\t\tfor (k = 0 ; k < psf->wchunks.used ; k++)\n\t\t\tfree (psf->wchunks.chunks [k].data) ;\n\tfree (psf->rchunks.chunks) ;\n\tfree (psf->wchunks.chunks) ;\n\tfree (psf->iterator) ;\n\tfree (psf->cart_16k) ;\n\n\tmemset (psf, 0, sizeof (SF_PRIVATE)) ;\n\tfree (psf) ;\n\n\treturn error ;\n} /* psf_close */\n\nSNDFILE *\npsf_open_file (SF_PRIVATE *psf, SF_INFO *sfinfo)\n{\tint\t\terror, format ;\n\n\tsf_errno = error = 0 ;\n\tsf_parselog [0] = 0 ;\n\n\tif (psf->error)\n\t{\terror = psf->error ;\n\t\tgoto error_exit ;\n\t\t} ;\n\n\tif (psf->file.mode != SFM_READ && psf->file.mode != SFM_WRITE && psf->file.mode != SFM_RDWR)\n\t{\terror = SFE_BAD_OPEN_MODE ;\n\t\tgoto error_exit ;\n\t\t} ;\n\n\tif (sfinfo == NULL)\n\t{\terror = SFE_BAD_SF_INFO_PTR ;\n\t\tgoto error_exit ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_RAW)\n\t\t{\tif (sf_format_check (sfinfo) == 0)\n\t\t\t{\terror = SFE_RAW_BAD_FORMAT ;\n\t\t\t\tgoto error_exit ;\n\t\t\t\t} ;\n\t\t\t}\n\t\telse\n\t\t\tmemset (sfinfo, 0, sizeof (SF_INFO)) ;\n\t\t} ;\n\n\tmemcpy (&psf->sf, sfinfo, sizeof (SF_INFO)) ;\n\n\tpsf->Magick \t\t= SNDFILE_MAGICK ;\n\tpsf->norm_float \t= SF_TRUE ;\n\tpsf->norm_double\t= SF_TRUE ;\n\tpsf->dataoffset\t\t= -1 ;\n\tpsf->datalength\t\t= -1 ;\n\tpsf->read_current\t= -1 ;\n\tpsf->write_current\t= -1 ;\n\tpsf->auto_header \t= SF_FALSE ;\n\tpsf->rwf_endian\t\t= SF_ENDIAN_LITTLE ;\n\tpsf->seek\t\t\t= psf_default_seek ;\n\tpsf->float_int_mult = 0 ;\n\tpsf->float_max\t\t= -1.0 ;\n\n\t/* An attempt at a per SF_PRIVATE unique id. */\n\tpsf->unique_id\t\t= psf_rand_int32 () ;\n\n\tpsf->sf.sections = 1 ;\n\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\n\tif (psf->is_pipe)\n\t{\tpsf->sf.seekable = SF_FALSE ;\n\t\tpsf->filelength = SF_COUNT_MAX ;\n\t\t}\n\telse\n\t{\tpsf->sf.seekable = SF_TRUE ;\n\n\t\t/* File is open, so get the length. */\n\t\tpsf->filelength = psf_get_filelen (psf) ;\n\t\t} ;\n\n\tif (psf->fileoffset > 0)\n\t{\tswitch (psf->file.mode)\n\t\t{\tcase SFM_READ :\n\t\t\t\tif (psf->filelength < 44)\n\t\t\t\t{\tpsf_log_printf (psf, \"Short filelength: %D (fileoffset: %D)\\n\", psf->filelength, psf->fileoffset) ;\n\t\t\t\t\terror = SFE_BAD_OFFSET ;\n\t\t\t\t\tgoto error_exit ;\n\t\t\t\t\t} ;\n\t\t\t\tbreak ;\n\n\t\t\tcase SFM_WRITE :\n\t\t\t\tpsf->fileoffset = 0 ;\n\t\t\t\tpsf_fseek (psf, 0, SEEK_END) ;\n\t\t\t\tpsf->fileoffset = psf_ftell (psf) ;\n\t\t\t\tbreak ;\n\n\t\t\tcase SFM_RDWR :\n\t\t\t\terror = SFE_NO_EMBEDDED_RDWR ;\n\t\t\t\tgoto error_exit ;\n\t\t\t} ;\n\n\t\tpsf_log_printf (psf, \"Embedded file offset : %D\\n\", psf->fileoffset) ;\n\t\t} ;\n\n\tif (psf->filelength == SF_COUNT_MAX)\n\t\tpsf_log_printf (psf, \"Length : unknown\\n\") ;\n\telse\n\t\tpsf_log_printf (psf, \"Length : %D\\n\", psf->filelength) ;\n\n\tif (psf->file.mode == SFM_WRITE || (psf->file.mode == SFM_RDWR && psf->filelength == 0))\n\t{\t/* If the file is being opened for write or RDWR and the file is currently\n\t\t** empty, then the SF_INFO struct must contain valid data.\n\t\t*/\n\t\tif ((SF_CONTAINER (psf->sf.format)) == 0)\n\t\t{\terror = SFE_ZERO_MAJOR_FORMAT ;\n\t\t\tgoto error_exit ;\n\t\t\t} ;\n\t\tif ((SF_CODEC (psf->sf.format)) == 0)\n\t\t{\terror = SFE_ZERO_MINOR_FORMAT ;\n\t\t\tgoto error_exit ;\n\t\t\t} ;\n\n\t\tif (sf_format_check (&psf->sf) == 0)\n\t\t{\terror = SFE_BAD_OPEN_FORMAT ;\n\t\t\tgoto error_exit ;\n\t\t\t} ;\n\t\t}\n\telse if ((SF_CONTAINER (psf->sf.format)) != SF_FORMAT_RAW)\n\t{\t/* If type RAW has not been specified then need to figure out file type. */\n\t\tpsf->sf.format = guess_file_type (psf) ;\n\n\t\tif (psf->sf.format == 0)\n\t\t\tpsf->sf.format = format_from_extension (psf) ;\n\t\t} ;\n\n\t/* Prevent unnecessary seeks */\n\tpsf->last_op = psf->file.mode ;\n\n\t/* Set bytewidth if known. */\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_S8 :\n\t\tcase SF_FORMAT_PCM_U8 :\n\t\tcase SF_FORMAT_ULAW :\n\t\tcase SF_FORMAT_ALAW :\n\t\tcase SF_FORMAT_DPCM_8 :\n\t\t\t\tpsf->bytewidth = 1 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_16 :\n\t\tcase SF_FORMAT_DPCM_16 :\n\t\t\t\tpsf->bytewidth = 2 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_24 :\n\t\t\t\tpsf->bytewidth = 3 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_32 :\n\t\tcase SF_FORMAT_FLOAT :\n\t\t\t\tpsf->bytewidth = 4 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DOUBLE :\n\t\t\t\tpsf->bytewidth = 8 ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\t/* Call the initialisation function for the relevant file type. */\n\tswitch (SF_CONTAINER (psf->sf.format))\n\t{\tcase\tSF_FORMAT_WAV :\n\t\tcase\tSF_FORMAT_WAVEX :\n\t\t\t\terror = wav_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_AIFF :\n\t\t\t\terror = aiff_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_AU :\n\t\t\t\terror = au_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_RAW :\n\t\t\t\terror = raw_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_W64 :\n\t\t\t\terror = w64_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_RF64 :\n\t\t\t\terror = rf64_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\t/* Lite remove start */\n\t\tcase\tSF_FORMAT_PAF :\n\t\t\t\terror = paf_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_SVX :\n\t\t\t\terror = svx_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_NIST :\n\t\t\t\terror = nist_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_IRCAM :\n\t\t\t\terror = ircam_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_VOC :\n\t\t\t\terror = voc_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_SDS :\n\t\t\t\terror = sds_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_OGG :\n\t\t\t\terror = ogg_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_TXW :\n\t\t\t\terror = txw_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_WVE :\n\t\t\t\terror = wve_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_DWD :\n\t\t\t\terror = dwd_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_MAT4 :\n\t\t\t\terror = mat4_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_MAT5 :\n\t\t\t\terror = mat5_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_PVF :\n\t\t\t\terror = pvf_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_XI :\n\t\t\t\terror = xi_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_HTK :\n\t\t\t\terror = htk_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_SD2 :\n\t\t\t\terror = sd2_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_REX2 :\n\t\t\t\terror = rx2_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_AVR :\n\t\t\t\terror = avr_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_FLAC :\n\t\t\t\terror = flac_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_CAF :\n\t\t\t\terror = caf_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase\tSF_FORMAT_MPC2K :\n\t\t\t\terror = mpc2k_open (psf) ;\n\t\t\t\tbreak ;\n\n\t\t/* Lite remove end */\n\n\t\tdefault :\n\t\t\t\terror = SFE_UNKNOWN_FORMAT ;\n\t\t} ;\n\n\tif (error)\n\t\tgoto error_exit ;\n\n\t/* For now, check whether embedding is supported. */\n\tformat = SF_CONTAINER (psf->sf.format) ;\n\tif (psf->fileoffset > 0)\n\t{\tswitch (format)\n\t\t{\tcase SF_FORMAT_WAV :\n\t\t\tcase SF_FORMAT_WAVEX :\n\t\t\tcase SF_FORMAT_AIFF :\n\t\t\tcase SF_FORMAT_AU :\n\t\t\t\t/* Actual embedded files. */\n\t\t\t\tbreak ;\n\n\t\t\tcase SF_FORMAT_FLAC :\n\t\t\t\t/* Flac with an ID3v2 header? */\n\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\terror = SFE_NO_EMBED_SUPPORT ;\n\t\t\t\tgoto error_exit ;\n\t\t\t} ;\n\t\t} ;\n\n\tif (psf->fileoffset > 0)\n\t\tpsf_log_printf (psf, \"Embedded file length : %D\\n\", psf->filelength) ;\n\n\tif (psf->file.mode == SFM_RDWR && sf_format_check (&psf->sf) == 0)\n\t{\terror = SFE_BAD_MODE_RW ;\n\t\tgoto error_exit ;\n\t\t} ;\n\n\tif (validate_sfinfo (&psf->sf) == 0)\n\t{\tpsf_log_SF_INFO (psf) ;\n\t\tsave_header_info (psf) ;\n\t\terror = SFE_BAD_SF_INFO ;\n\t\tgoto error_exit ;\n\t\t} ;\n\n\tif (validate_psf (psf) == 0)\n\t{\tsave_header_info (psf) ;\n\t\terror = SFE_INTERNAL ;\n\t\tgoto error_exit ;\n\t\t} ;\n\n\tpsf->read_current = 0 ;\n\tpsf->write_current = 0 ;\n\tif (psf->file.mode == SFM_RDWR)\n\t{\tpsf->write_current = psf->sf.frames ;\n\t\tpsf->have_written = psf->sf.frames > 0 ? SF_TRUE : SF_FALSE ;\n\t\t} ;\n\n\tmemcpy (sfinfo, &psf->sf, sizeof (SF_INFO)) ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\t/* Zero out these fields. */\n\t\tsfinfo->frames = 0 ;\n\t\tsfinfo->sections = 0 ;\n\t\tsfinfo->seekable = 0 ;\n\t\t} ;\n\n\treturn (SNDFILE *) psf ;\n\nerror_exit :\n\tsf_errno = error ;\n\n\tif (error == SFE_SYSTEM)\n\t\tsnprintf (sf_syserr, sizeof (sf_syserr), \"%s\", psf->syserr) ;\n\tsnprintf (sf_parselog, sizeof (sf_parselog), \"%s\", psf->parselog.buf) ;\n\n\tswitch (error)\n\t{\tcase SF_ERR_SYSTEM :\n\t\tcase SF_ERR_UNSUPPORTED_ENCODING :\n\t\tcase SFE_UNIMPLEMENTED :\n\t\t\tbreak ;\n\n\t\tcase SFE_RAW_BAD_FORMAT :\n\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tif (psf->file.mode == SFM_READ)\n\t\t\t{\tpsf_log_printf (psf, \"Parse error : %s\\n\", sf_error_number (error)) ;\n\t\t\t\terror = SF_ERR_MALFORMED_FILE ;\n\t\t\t\t} ;\n\t\t} ;\n\n\tpsf_close (psf) ;\n\treturn NULL ;\n} /* psf_open_file */\n\n/*==============================================================================\n** Chunk getting and setting.\n** This works for AIFF, CAF, RF64 and WAV.\n** It doesn't work for W64 because W64 uses weird GUID style chunk markers.\n*/\n\nint\nsf_set_chunk (SNDFILE * sndfile, const SF_CHUNK_INFO * chunk_info)\n{\tSF_PRIVATE \t*psf ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (chunk_info == NULL || chunk_info->data == NULL)\n\t\treturn SFE_BAD_CHUNK_PTR ;\n\n\tif (psf->set_chunk)\n\t\treturn psf->set_chunk (psf, chunk_info) ;\n\n\treturn SFE_BAD_CHUNK_FORMAT ;\n} /* sf_set_chunk */\n\nSF_CHUNK_ITERATOR *\nsf_get_chunk_iterator (SNDFILE * sndfile, const SF_CHUNK_INFO * chunk_info)\n{\tSF_PRIVATE \t*psf ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (chunk_info)\n\t\treturn psf_get_chunk_iterator (psf, chunk_info->id) ;\n\n\treturn psf_get_chunk_iterator (psf, NULL) ;\n} /* sf_get_chunk_iterator */\n\nSF_CHUNK_ITERATOR *\nsf_next_chunk_iterator (SF_CHUNK_ITERATOR * iterator)\n{\tSF_PRIVATE \t*psf ;\n\tSNDFILE\t*sndfile = iterator ? iterator->sndfile : NULL ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->next_chunk_iterator)\n\t\treturn psf->next_chunk_iterator (psf, iterator) ;\n\n\treturn NULL ;\n} /* sf_get_chunk_iterator_next */\n\nint\nsf_get_chunk_size (const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info)\n{\tSF_PRIVATE \t*psf ;\n\tSNDFILE\t*sndfile = iterator ? iterator->sndfile : NULL ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (chunk_info == NULL)\n\t\treturn SFE_BAD_CHUNK_PTR ;\n\n\tif (psf->get_chunk_size)\n\t\treturn psf->get_chunk_size (psf, iterator, chunk_info) ;\n\n\treturn SFE_BAD_CHUNK_FORMAT ;\n\treturn 0 ;\n} /* sf_get_chunk_size */\n\nint\nsf_get_chunk_data (const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info)\n{\tSF_PRIVATE\t*psf ;\n\tSNDFILE\t*sndfile = iterator ? iterator->sndfile : NULL ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (chunk_info == NULL || chunk_info->data == NULL)\n\t\treturn SFE_BAD_CHUNK_PTR ;\n\n\tif (psf->get_chunk_data)\n\t\treturn psf->get_chunk_data (psf, iterator, chunk_info) ;\n\n\treturn SFE_BAD_CHUNK_FORMAT ;\n} /* sf_get_chunk_data */\n"], "filenames": ["src/common.c", "src/common.h", "src/sndfile.c"], "buggy_code_start_loc": [35, 82, 270], "buggy_code_end_loc": [1098, 738, 2690], "fixing_code_start_loc": [36, 81, 270], "fixing_code_end_loc": [1118, 742, 2692], "type": "CWE-119", "message": "In libsndfile before 1.0.28, an error in the \"header_read()\" function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file.", "other": {"cve": {"id": "CVE-2017-7586", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-07T20:59:00.220", "lastModified": "2017-07-11T01:33:47.377", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In libsndfile before 1.0.28, an error in the \"header_read()\" function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file."}, {"lang": "es", "value": "En libsndfile en versiones anteriores a 1.0.28, un error en la funci\u00f3n \"header_read()\" (common.c) cuando se manejan etiquetas ID3 pueden ser explotados para provocar un desbordamiento de b\u00fafer basado en pila a trav\u00e9s de un archivo FLAC especialmente manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libsndfile_project:libsndfile:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.27", "matchCriteriaId": "59548F6B-A7DD-4844-8347-79E7FEBF8280"}]}]}], "references": [{"url": "http://www.mega-nerd.com/libsndfile/#History", "source": "cve@mitre.org", "tags": ["Product", "Release Notes"]}, {"url": "http://www.mega-nerd.com/libsndfile/NEWS", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.securityfocus.com/bid/97522", "source": "cve@mitre.org"}, {"url": "https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/erikd/libsndfile/commit/f457b7b5ecfe91697ed01cfc825772c4d8de1236", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security.gentoo.org/glsa/201707-04", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074"}}