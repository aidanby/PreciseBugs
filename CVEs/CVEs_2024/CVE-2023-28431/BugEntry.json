{"buggy_code": ["// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(clippy::comparison_chain)]\n\nextern crate alloc;\n\nuse alloc::{vec, vec::Vec};\nuse core::cmp::max;\n\nuse num::{BigUint, FromPrimitive, One, ToPrimitive, Zero};\n\nuse fp_evm::{\n\tExitError, ExitSucceed, Precompile, PrecompileFailure, PrecompileHandle, PrecompileOutput,\n\tPrecompileResult,\n};\n\npub struct Modexp;\n\nconst MIN_GAS_COST: u64 = 200;\n\n// Calculate gas cost according to EIP 2565:\n// https://eips.ethereum.org/EIPS/eip-2565\nfn calculate_gas_cost(\n\tbase_length: u64,\n\tmod_length: u64,\n\texponent: &BigUint,\n\texponent_bytes: &[u8],\n) -> u64 {\n\tfn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {\n\t\tlet max_length = max(base_length, mod_length);\n\t\tlet mut words = max_length / 8;\n\t\tif max_length % 8 > 0 {\n\t\t\twords += 1;\n\t\t}\n\n\t\t// Note: can't overflow because we take words to be some u64 value / 8, which is\n\t\t// necessarily less than sqrt(u64::MAX).\n\t\t// Additionally, both base_length and mod_length are bounded to 1024, so this has\n\t\t// an upper bound of roughly (1024 / 8) squared\n\t\twords * words\n\t}\n\n\tfn calculate_iteration_count(exponent: &BigUint, exponent_bytes: &[u8]) -> u64 {\n\t\tlet mut iteration_count: u64 = 0;\n\t\tlet exp_length = exponent_bytes.len() as u64;\n\n\t\tif exp_length <= 32 && exponent.is_zero() {\n\t\t\titeration_count = 0;\n\t\t} else if exp_length <= 32 {\n\t\t\titeration_count = exponent.bits() - 1;\n\t\t} else if exp_length > 32 {\n\t\t\t// from the EIP spec:\n\t\t\t// (8 * (exp_length - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1)\n\t\t\t//\n\t\t\t// Notes:\n\t\t\t// * exp_length is bounded to 1024 and is > 32\n\t\t\t// * exponent can be zero, so we subtract 1 after adding the other terms (whose sum\n\t\t\t//   must be > 0)\n\t\t\t// * the addition can't overflow because the terms are both capped at roughly\n\t\t\t//   8 * max size of exp_length (1024)\n\t\t\t// * the EIP spec is written in python, in which (exponent & (2**256 - 1)) takes the\n\t\t\t//   FIRST 32 bytes. However this `BigUint` `&` operator takes the LAST 32 bytes.\n\t\t\t//   We thus instead take the bytes manually.\n\t\t\tlet exponent_head = BigUint::from_bytes_be(&exponent_bytes[..32]);\n\n\t\t\titeration_count = (8 * (exp_length - 32)) + exponent_head.bits() - 1;\n\t\t}\n\n\t\tmax(iteration_count, 1)\n\t}\n\n\tlet multiplication_complexity = calculate_multiplication_complexity(base_length, mod_length);\n\tlet iteration_count = calculate_iteration_count(exponent, exponent_bytes);\n\tmax(\n\t\tMIN_GAS_COST,\n\t\tmultiplication_complexity * iteration_count / 3,\n\t)\n}\n\n/// Copy bytes from input to target.\nfn read_input(source: &[u8], target: &mut [u8], source_offset: &mut usize) {\n\t// We move the offset by the len of the target, regardless of what we\n\t// actually copy.\n\tlet offset = *source_offset;\n\t*source_offset += target.len();\n\n\t// Out of bounds, nothing to copy.\n\tif source.len() <= offset {\n\t\treturn;\n\t}\n\n\t// Find len to copy up to target len, but not out of bounds.\n\tlet len = core::cmp::min(target.len(), source.len() - offset);\n\ttarget[..len].copy_from_slice(&source[offset..][..len]);\n}\n\n// ModExp expects the following as inputs:\n// 1) 32 bytes expressing the length of base\n// 2) 32 bytes expressing the length of exponent\n// 3) 32 bytes expressing the length of modulus\n// 4) base, size as described above\n// 5) exponent, size as described above\n// 6) modulus, size as described above\n//\n//\n// NOTE: input sizes are bound to 1024 bytes, with the expectation\n//       that gas limits would be applied before actual computation.\n//\n//       maximum stack size will also prevent abuse.\n//\n//       see: https://eips.ethereum.org/EIPS/eip-198\n\nimpl Precompile for Modexp {\n\tfn execute(handle: &mut impl PrecompileHandle) -> PrecompileResult {\n\t\tlet input = handle.input();\n\t\tlet mut input_offset = 0;\n\n\t\t// Yellowpaper: whenever the input is too short, the missing bytes are\n\t\t// considered to be zero.\n\t\tlet mut base_len_buf = [0u8; 32];\n\t\tread_input(input, &mut base_len_buf, &mut input_offset);\n\t\tlet mut exp_len_buf = [0u8; 32];\n\t\tread_input(input, &mut exp_len_buf, &mut input_offset);\n\t\tlet mut mod_len_buf = [0u8; 32];\n\t\tread_input(input, &mut mod_len_buf, &mut input_offset);\n\n\t\t// reasonable assumption: this must fit within the Ethereum EVM's max stack size\n\t\tlet max_size_big = BigUint::from_u32(1024).expect(\"can't create BigUint\");\n\n\t\tlet base_len_big = BigUint::from_bytes_be(&base_len_buf);\n\t\tif base_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large base length\".into()),\n\t\t\t});\n\t\t}\n\n\t\tlet exp_len_big = BigUint::from_bytes_be(&exp_len_buf);\n\t\tif exp_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large exponent length\".into()),\n\t\t\t});\n\t\t}\n\n\t\tlet mod_len_big = BigUint::from_bytes_be(&mod_len_buf);\n\t\tif mod_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large modulus length\".into()),\n\t\t\t});\n\t\t}\n\n\t\t// bounds check handled above\n\t\tlet base_len = base_len_big.to_usize().expect(\"base_len out of bounds\");\n\t\tlet exp_len = exp_len_big.to_usize().expect(\"exp_len out of bounds\");\n\t\tlet mod_len = mod_len_big.to_usize().expect(\"mod_len out of bounds\");\n\n\t\t// if mod_len is 0 output must be empty\n\t\tif mod_len == 0 {\n\t\t\treturn Ok(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\toutput: vec![],\n\t\t\t});\n\t\t}\n\n\t\t// Gas formula allows arbitrary large exp_len when base and modulus are empty, so we need to handle empty base first.\n\t\tlet r = if base_len == 0 && mod_len == 0 {\n\t\t\thandle.record_cost(MIN_GAS_COST)?;\n\t\t\tBigUint::zero()\n\t\t} else {\n\t\t\t// read the numbers themselves.\n\t\t\tlet mut base_buf = vec![0u8; base_len];\n\t\t\tread_input(input, &mut base_buf, &mut input_offset);\n\t\t\tlet base = BigUint::from_bytes_be(&base_buf);\n\n\t\t\tlet mut exp_buf = vec![0u8; exp_len];\n\t\t\tread_input(input, &mut exp_buf, &mut input_offset);\n\t\t\tlet exponent = BigUint::from_bytes_be(&exp_buf);\n\n\t\t\tlet mut mod_buf = vec![0u8; mod_len];\n\t\t\tread_input(input, &mut mod_buf, &mut input_offset);\n\t\t\tlet modulus = BigUint::from_bytes_be(&mod_buf);\n\n\t\t\t// do our gas accounting\n\t\t\tlet gas_cost = calculate_gas_cost(base_len as u64, mod_len as u64, &exponent, &exp_buf);\n\n\t\t\thandle.record_cost(gas_cost)?;\n\n\t\t\tif modulus.is_zero() || modulus.is_one() {\n\t\t\t\tBigUint::zero()\n\t\t\t} else {\n\t\t\t\tbase.modpow(&exponent, &modulus)\n\t\t\t}\n\t\t};\n\n\t\t// write output to given memory, left padded and same length as the modulus.\n\t\tlet bytes = r.to_bytes_be();\n\n\t\t// always true except in the case of zero-length modulus, which leads to\n\t\t// output of length and value 1.\n\t\tif bytes.len() == mod_len {\n\t\t\tOk(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\toutput: bytes.to_vec(),\n\t\t\t})\n\t\t} else if bytes.len() < mod_len {\n\t\t\tlet mut ret = Vec::with_capacity(mod_len);\n\t\t\tret.extend(core::iter::repeat(0).take(mod_len - bytes.len()));\n\t\t\tret.extend_from_slice(&bytes[..]);\n\t\t\tOk(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\toutput: ret.to_vec(),\n\t\t\t})\n\t\t} else {\n\t\t\tErr(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"failed\".into()),\n\t\t\t})\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\tuse super::*;\n\textern crate hex;\n\tuse fp_evm::Context;\n\tuse pallet_evm_test_vector_support::{test_precompile_test_vectors, MockHandle};\n\n\t#[test]\n\tfn process_consensus_tests() -> Result<(), String> {\n\t\ttest_precompile_test_vectors::<Modexp>(\"../testdata/modexp_eip2565.json\")?;\n\t\tOk(())\n\t}\n\n\t#[test]\n\tfn test_empty_input() {\n\t\tlet input = Vec::new();\n\n\t\tlet cost: u64 = 1;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tmatch Modexp::execute(&mut handle) {\n\t\t\tOk(precompile_result) => {\n\t\t\t\tassert_eq!(precompile_result.output.len(), 0);\n\t\t\t}\n\t\t\tErr(_) => {\n\t\t\t\tpanic!(\"Modexp::execute() returned error\"); // TODO: how to pass error on?\n\t\t\t}\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_insufficient_input() {\n\t\tlet input = hex::decode(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000001\",\n\t\t)\n\t\t.expect(\"Decode failed\");\n\n\t\tlet cost: u64 = 1;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tmatch Modexp::execute(&mut handle) {\n\t\t\tOk(precompile_result) => {\n\t\t\t\tassert_eq!(precompile_result.output.len(), 1);\n\t\t\t\tassert_eq!(precompile_result.output, vec![0x00]);\n\t\t\t}\n\t\t\tErr(_) => {\n\t\t\t\tpanic!(\"Modexp::execute() returned error\"); // TODO: how to pass error on?\n\t\t\t}\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_excessive_input() -> Result<(), PrecompileFailure> {\n\t\tlet input = hex::decode(\n\t\t\t\"1000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000001\",\n\t\t)\n\t\t.expect(\"Decode failed\");\n\n\t\tlet cost: u64 = 1;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tmatch Modexp::execute(&mut handle) {\n\t\t\tOk(_) => {\n\t\t\t\tpanic!(\"Test not expected to pass\");\n\t\t\t}\n\t\t\tErr(e) => {\n\t\t\t\tassert_eq!(\n\t\t\t\t\te,\n\t\t\t\t\tPrecompileFailure::Error {\n\t\t\t\t\t\texit_status: ExitError::Other(\"unreasonably large base length\".into())\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tOk(())\n\t\t\t}\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_simple_inputs() {\n\t\tlet input = hex::decode(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t03\\\n\t\t\t05\\\n\t\t\t07\",\n\t\t)\n\t\t.expect(\"Decode failed\");\n\n\t\t// 3 ^ 5 % 7 == 5\n\n\t\tlet cost: u64 = 100000;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tmatch Modexp::execute(&mut handle) {\n\t\t\tOk(precompile_result) => {\n\t\t\t\tassert_eq!(precompile_result.output.len(), 1); // should be same length as mod\n\t\t\t\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);\n\t\t\t\tlet expected = BigUint::parse_bytes(b\"5\", 10).unwrap();\n\t\t\t\tassert_eq!(result, expected);\n\t\t\t}\n\t\t\tErr(_) => {\n\t\t\t\tpanic!(\"Modexp::execute() returned error\"); // TODO: how to pass error on?\n\t\t\t}\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_large_inputs() {\n\t\tlet input = hex::decode(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000020\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000020\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000020\\\n\t\t\t000000000000000000000000000000000000000000000000000000000000EA5F\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000015\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000003874\",\n\t\t)\n\t\t.expect(\"Decode failed\");\n\n\t\t// 59999 ^ 21 % 14452 = 10055\n\n\t\tlet cost: u64 = 100000;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tmatch Modexp::execute(&mut handle) {\n\t\t\tOk(precompile_result) => {\n\t\t\t\tassert_eq!(precompile_result.output.len(), 32); // should be same length as mod\n\t\t\t\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);\n\t\t\t\tlet expected = BigUint::parse_bytes(b\"10055\", 10).unwrap();\n\t\t\t\tassert_eq!(result, expected);\n\t\t\t}\n\t\t\tErr(_) => {\n\t\t\t\tpanic!(\"Modexp::execute() returned error\"); // TODO: how to pass error on?\n\t\t\t}\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_large_computation() {\n\t\tlet input = hex::decode(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000020\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000020\\\n\t\t\t03\\\n\t\t\tfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e\\\n\t\t\tfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\",\n\t\t)\n\t\t.expect(\"Decode failed\");\n\n\t\tlet cost: u64 = 100000;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tmatch Modexp::execute(&mut handle) {\n\t\t\tOk(precompile_result) => {\n\t\t\t\tassert_eq!(precompile_result.output.len(), 32); // should be same length as mod\n\t\t\t\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);\n\t\t\t\tlet expected = BigUint::parse_bytes(b\"1\", 10).unwrap();\n\t\t\t\tassert_eq!(result, expected);\n\t\t\t}\n\t\t\tErr(_) => {\n\t\t\t\tpanic!(\"Modexp::execute() returned error\"); // TODO: how to pass error on?\n\t\t\t}\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_zero_exp_with_33_length() {\n\t\t// This is a regression test which ensures that the 'iteration_count' calculation\n\t\t// in 'calculate_iteration_count' cannot underflow.\n\t\t//\n\t\t// In debug mode, this underflow could cause a panic. Otherwise, it causes N**0 to\n\t\t// be calculated at more-than-normal expense.\n\t\t//\n\t\t// TODO: cite security advisory\n\n\t\tlet input = vec![\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n\t\t];\n\n\t\tlet cost: u64 = 100000;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tlet precompile_result =\n\t\t\tModexp::execute(&mut handle).expect(\"Modexp::execute() returned error\");\n\n\t\tassert_eq!(precompile_result.output.len(), 1); // should be same length as mod\n\t\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);\n\t\tlet expected = BigUint::parse_bytes(b\"0\", 10).unwrap();\n\t\tassert_eq!(result, expected);\n\t}\n\n\t#[test]\n\tfn test_long_exp_gas_cost_matches_specs() {\n\t\tlet input = vec![\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t16, 0, 0, 0, 255, 255, 255, 2, 0, 0, 179, 0, 0, 2, 0, 0, 122, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 255, 251, 0, 0, 0, 0, 4, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 255, 255, 255, 2, 0, 0, 179, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255,\n\t\t\t255, 255, 255, 249,\n\t\t];\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(100_000), context);\n\n\t\tlet _ = Modexp::execute(&mut handle).expect(\"Modexp::execute() returned error\");\n\n\t\tassert_eq!(handle.gas_used, 7104); // gas used when ran in geth\n\t}\n}\n", "let\n  mozillaOverlay =\n    import (builtins.fetchGit {\n      url = \"https://github.com/mozilla/nixpkgs-mozilla.git\";\n      rev = \"4a07484cf0e49047f82d83fd119acffbad3b235f\";\n    });\n  nixpkgs = import <nixpkgs> { overlays = [ mozillaOverlay ]; };\n  rust-nightly = with nixpkgs; ((rustChannelOf { date = \"2022-11-16\"; channel = \"nightly\"; }).rust.override {\n    extensions = [ \"rust-src\" ];\n    targets = [ \"wasm32-unknown-unknown\" ];\n  });\nin\nwith nixpkgs; pkgs.mkShell {\n  buildInputs = [\n    clang\n    pkg-config\n    rust-nightly\n  ] ++ lib.optionals stdenv.isDarwin [\n    darwin.apple_sdk.frameworks.Security\n  ];\n\n  RUST_SRC_PATH = \"${rust-nightly}/lib/rustlib/src/rust/src\";\n  LIBCLANG_PATH = \"${llvmPackages.libclang.lib}/lib\";\n  PROTOC = \"${protobuf}/bin/protoc\";\n  ROCKSDB_LIB_DIR = \"${rocksdb}/lib\";\n}\n"], "fixing_code": ["// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(clippy::comparison_chain)]\n\nextern crate alloc;\n\nuse alloc::{vec, vec::Vec};\nuse core::cmp::max;\n\nuse num::{BigUint, FromPrimitive, Integer, One, ToPrimitive, Zero};\n\nuse fp_evm::{\n\tExitError, ExitSucceed, Precompile, PrecompileFailure, PrecompileHandle, PrecompileOutput,\n\tPrecompileResult,\n};\n\npub struct Modexp;\n\nconst MIN_GAS_COST: u64 = 200;\n\n// Calculate gas cost according to EIP 2565:\n// https://eips.ethereum.org/EIPS/eip-2565\nfn calculate_gas_cost(\n\tbase_length: u64,\n\tmod_length: u64,\n\texponent: &BigUint,\n\texponent_bytes: &[u8],\n\tmod_is_even: bool,\n) -> u64 {\n\tfn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {\n\t\tlet max_length = max(base_length, mod_length);\n\t\tlet mut words = max_length / 8;\n\t\tif max_length % 8 > 0 {\n\t\t\twords += 1;\n\t\t}\n\n\t\t// Note: can't overflow because we take words to be some u64 value / 8, which is\n\t\t// necessarily less than sqrt(u64::MAX).\n\t\t// Additionally, both base_length and mod_length are bounded to 1024, so this has\n\t\t// an upper bound of roughly (1024 / 8) squared\n\t\twords * words\n\t}\n\n\tfn calculate_iteration_count(exponent: &BigUint, exponent_bytes: &[u8]) -> u64 {\n\t\tlet mut iteration_count: u64 = 0;\n\t\tlet exp_length = exponent_bytes.len() as u64;\n\n\t\tif exp_length <= 32 && exponent.is_zero() {\n\t\t\titeration_count = 0;\n\t\t} else if exp_length <= 32 {\n\t\t\titeration_count = exponent.bits() - 1;\n\t\t} else if exp_length > 32 {\n\t\t\t// from the EIP spec:\n\t\t\t// (8 * (exp_length - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1)\n\t\t\t//\n\t\t\t// Notes:\n\t\t\t// * exp_length is bounded to 1024 and is > 32\n\t\t\t// * exponent can be zero, so we subtract 1 after adding the other terms (whose sum\n\t\t\t//   must be > 0)\n\t\t\t// * the addition can't overflow because the terms are both capped at roughly\n\t\t\t//   8 * max size of exp_length (1024)\n\t\t\t// * the EIP spec is written in python, in which (exponent & (2**256 - 1)) takes the\n\t\t\t//   FIRST 32 bytes. However this `BigUint` `&` operator takes the LAST 32 bytes.\n\t\t\t//   We thus instead take the bytes manually.\n\t\t\tlet exponent_head = BigUint::from_bytes_be(&exponent_bytes[..32]);\n\n\t\t\titeration_count = (8 * (exp_length - 32)) + exponent_head.bits() - 1;\n\t\t}\n\n\t\tmax(iteration_count, 1)\n\t}\n\n\tlet multiplication_complexity = calculate_multiplication_complexity(base_length, mod_length);\n\tlet iteration_count = calculate_iteration_count(exponent, exponent_bytes);\n\tmax(\n\t\tMIN_GAS_COST,\n\t\tmultiplication_complexity * iteration_count / 3,\n\t)\n\t.saturating_mul(if mod_is_even { 20 } else { 1 })\n}\n\n/// Copy bytes from input to target.\nfn read_input(source: &[u8], target: &mut [u8], source_offset: &mut usize) {\n\t// We move the offset by the len of the target, regardless of what we\n\t// actually copy.\n\tlet offset = *source_offset;\n\t*source_offset += target.len();\n\n\t// Out of bounds, nothing to copy.\n\tif source.len() <= offset {\n\t\treturn;\n\t}\n\n\t// Find len to copy up to target len, but not out of bounds.\n\tlet len = core::cmp::min(target.len(), source.len() - offset);\n\ttarget[..len].copy_from_slice(&source[offset..][..len]);\n}\n\n// ModExp expects the following as inputs:\n// 1) 32 bytes expressing the length of base\n// 2) 32 bytes expressing the length of exponent\n// 3) 32 bytes expressing the length of modulus\n// 4) base, size as described above\n// 5) exponent, size as described above\n// 6) modulus, size as described above\n//\n//\n// NOTE: input sizes are bound to 1024 bytes, with the expectation\n//       that gas limits would be applied before actual computation.\n//\n//       maximum stack size will also prevent abuse.\n//\n//       see: https://eips.ethereum.org/EIPS/eip-198\n\nimpl Precompile for Modexp {\n\tfn execute(handle: &mut impl PrecompileHandle) -> PrecompileResult {\n\t\tlet input = handle.input();\n\t\tlet mut input_offset = 0;\n\n\t\t// Yellowpaper: whenever the input is too short, the missing bytes are\n\t\t// considered to be zero.\n\t\tlet mut base_len_buf = [0u8; 32];\n\t\tread_input(input, &mut base_len_buf, &mut input_offset);\n\t\tlet mut exp_len_buf = [0u8; 32];\n\t\tread_input(input, &mut exp_len_buf, &mut input_offset);\n\t\tlet mut mod_len_buf = [0u8; 32];\n\t\tread_input(input, &mut mod_len_buf, &mut input_offset);\n\n\t\t// reasonable assumption: this must fit within the Ethereum EVM's max stack size\n\t\tlet max_size_big = BigUint::from_u32(1024).expect(\"can't create BigUint\");\n\n\t\tlet base_len_big = BigUint::from_bytes_be(&base_len_buf);\n\t\tif base_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large base length\".into()),\n\t\t\t});\n\t\t}\n\n\t\tlet exp_len_big = BigUint::from_bytes_be(&exp_len_buf);\n\t\tif exp_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large exponent length\".into()),\n\t\t\t});\n\t\t}\n\n\t\tlet mod_len_big = BigUint::from_bytes_be(&mod_len_buf);\n\t\tif mod_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large modulus length\".into()),\n\t\t\t});\n\t\t}\n\n\t\t// bounds check handled above\n\t\tlet base_len = base_len_big.to_usize().expect(\"base_len out of bounds\");\n\t\tlet exp_len = exp_len_big.to_usize().expect(\"exp_len out of bounds\");\n\t\tlet mod_len = mod_len_big.to_usize().expect(\"mod_len out of bounds\");\n\n\t\t// if mod_len is 0 output must be empty\n\t\tif mod_len == 0 {\n\t\t\treturn Ok(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\toutput: vec![],\n\t\t\t});\n\t\t}\n\n\t\t// Gas formula allows arbitrary large exp_len when base and modulus are empty, so we need to handle empty base first.\n\t\tlet r = if base_len == 0 && mod_len == 0 {\n\t\t\thandle.record_cost(MIN_GAS_COST)?;\n\t\t\tBigUint::zero()\n\t\t} else {\n\t\t\t// read the numbers themselves.\n\t\t\tlet mut base_buf = vec![0u8; base_len];\n\t\t\tread_input(input, &mut base_buf, &mut input_offset);\n\t\t\tlet base = BigUint::from_bytes_be(&base_buf);\n\n\t\t\tlet mut exp_buf = vec![0u8; exp_len];\n\t\t\tread_input(input, &mut exp_buf, &mut input_offset);\n\t\t\tlet exponent = BigUint::from_bytes_be(&exp_buf);\n\n\t\t\tlet mut mod_buf = vec![0u8; mod_len];\n\t\t\tread_input(input, &mut mod_buf, &mut input_offset);\n\t\t\tlet modulus = BigUint::from_bytes_be(&mod_buf);\n\n\t\t\t// do our gas accounting\n\t\t\tlet gas_cost = calculate_gas_cost(\n\t\t\t\tbase_len as u64,\n\t\t\t\tmod_len as u64,\n\t\t\t\t&exponent,\n\t\t\t\t&exp_buf,\n\t\t\t\tmodulus.is_even(),\n\t\t\t);\n\n\t\t\thandle.record_cost(gas_cost)?;\n\n\t\t\tif modulus.is_zero() || modulus.is_one() {\n\t\t\t\tBigUint::zero()\n\t\t\t} else {\n\t\t\t\tbase.modpow(&exponent, &modulus)\n\t\t\t}\n\t\t};\n\n\t\t// write output to given memory, left padded and same length as the modulus.\n\t\tlet bytes = r.to_bytes_be();\n\n\t\t// always true except in the case of zero-length modulus, which leads to\n\t\t// output of length and value 1.\n\t\tif bytes.len() == mod_len {\n\t\t\tOk(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\toutput: bytes.to_vec(),\n\t\t\t})\n\t\t} else if bytes.len() < mod_len {\n\t\t\tlet mut ret = Vec::with_capacity(mod_len);\n\t\t\tret.extend(core::iter::repeat(0).take(mod_len - bytes.len()));\n\t\t\tret.extend_from_slice(&bytes[..]);\n\t\t\tOk(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\toutput: ret.to_vec(),\n\t\t\t})\n\t\t} else {\n\t\t\tErr(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"failed\".into()),\n\t\t\t})\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\tuse super::*;\n\textern crate hex;\n\tuse fp_evm::Context;\n\tuse pallet_evm_test_vector_support::{test_precompile_test_vectors, MockHandle};\n\n\t#[test]\n\tfn process_consensus_tests() -> Result<(), String> {\n\t\ttest_precompile_test_vectors::<Modexp>(\"../testdata/modexp_eip2565.json\")?;\n\t\tOk(())\n\t}\n\n\t#[test]\n\tfn test_empty_input() {\n\t\tlet input = Vec::new();\n\n\t\tlet cost: u64 = 1;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tmatch Modexp::execute(&mut handle) {\n\t\t\tOk(precompile_result) => {\n\t\t\t\tassert_eq!(precompile_result.output.len(), 0);\n\t\t\t}\n\t\t\tErr(_) => {\n\t\t\t\tpanic!(\"Modexp::execute() returned error\"); // TODO: how to pass error on?\n\t\t\t}\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_insufficient_input() {\n\t\tlet input = hex::decode(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000001\",\n\t\t)\n\t\t.expect(\"Decode failed\");\n\n\t\tlet cost: u64 = 1;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tmatch Modexp::execute(&mut handle) {\n\t\t\tOk(precompile_result) => {\n\t\t\t\tassert_eq!(precompile_result.output.len(), 1);\n\t\t\t\tassert_eq!(precompile_result.output, vec![0x00]);\n\t\t\t}\n\t\t\tErr(_) => {\n\t\t\t\tpanic!(\"Modexp::execute() returned error\"); // TODO: how to pass error on?\n\t\t\t}\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_excessive_input() -> Result<(), PrecompileFailure> {\n\t\tlet input = hex::decode(\n\t\t\t\"1000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000001\",\n\t\t)\n\t\t.expect(\"Decode failed\");\n\n\t\tlet cost: u64 = 1;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tmatch Modexp::execute(&mut handle) {\n\t\t\tOk(_) => {\n\t\t\t\tpanic!(\"Test not expected to pass\");\n\t\t\t}\n\t\t\tErr(e) => {\n\t\t\t\tassert_eq!(\n\t\t\t\t\te,\n\t\t\t\t\tPrecompileFailure::Error {\n\t\t\t\t\t\texit_status: ExitError::Other(\"unreasonably large base length\".into())\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tOk(())\n\t\t\t}\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_simple_inputs() {\n\t\tlet input = hex::decode(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t03\\\n\t\t\t05\\\n\t\t\t07\",\n\t\t)\n\t\t.expect(\"Decode failed\");\n\n\t\t// 3 ^ 5 % 7 == 5\n\n\t\tlet cost: u64 = 100000;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tmatch Modexp::execute(&mut handle) {\n\t\t\tOk(precompile_result) => {\n\t\t\t\tassert_eq!(precompile_result.output.len(), 1); // should be same length as mod\n\t\t\t\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);\n\t\t\t\tlet expected = BigUint::parse_bytes(b\"5\", 10).unwrap();\n\t\t\t\tassert_eq!(result, expected);\n\t\t\t}\n\t\t\tErr(_) => {\n\t\t\t\tpanic!(\"Modexp::execute() returned error\"); // TODO: how to pass error on?\n\t\t\t}\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_large_inputs() {\n\t\tlet input = hex::decode(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000020\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000020\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000020\\\n\t\t\t000000000000000000000000000000000000000000000000000000000000EA5F\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000015\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000003874\",\n\t\t)\n\t\t.expect(\"Decode failed\");\n\n\t\t// 59999 ^ 21 % 14452 = 10055\n\n\t\tlet cost: u64 = 100000;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tmatch Modexp::execute(&mut handle) {\n\t\t\tOk(precompile_result) => {\n\t\t\t\tassert_eq!(precompile_result.output.len(), 32); // should be same length as mod\n\t\t\t\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);\n\t\t\t\tlet expected = BigUint::parse_bytes(b\"10055\", 10).unwrap();\n\t\t\t\tassert_eq!(result, expected);\n\t\t\t}\n\t\t\tErr(_) => {\n\t\t\t\tpanic!(\"Modexp::execute() returned error\"); // TODO: how to pass error on?\n\t\t\t}\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_large_computation() {\n\t\tlet input = hex::decode(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000001\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000020\\\n\t\t\t0000000000000000000000000000000000000000000000000000000000000020\\\n\t\t\t03\\\n\t\t\tfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e\\\n\t\t\tfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\",\n\t\t)\n\t\t.expect(\"Decode failed\");\n\n\t\tlet cost: u64 = 100000;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tmatch Modexp::execute(&mut handle) {\n\t\t\tOk(precompile_result) => {\n\t\t\t\tassert_eq!(precompile_result.output.len(), 32); // should be same length as mod\n\t\t\t\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);\n\t\t\t\tlet expected = BigUint::parse_bytes(b\"1\", 10).unwrap();\n\t\t\t\tassert_eq!(result, expected);\n\t\t\t}\n\t\t\tErr(_) => {\n\t\t\t\tpanic!(\"Modexp::execute() returned error\"); // TODO: how to pass error on?\n\t\t\t}\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_zero_exp_with_33_length() {\n\t\t// This is a regression test which ensures that the 'iteration_count' calculation\n\t\t// in 'calculate_iteration_count' cannot underflow.\n\t\t//\n\t\t// In debug mode, this underflow could cause a panic. Otherwise, it causes N**0 to\n\t\t// be calculated at more-than-normal expense.\n\t\t//\n\t\t// TODO: cite security advisory\n\n\t\tlet input = vec![\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n\t\t];\n\n\t\tlet cost: u64 = 100000;\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(cost), context);\n\n\t\tlet precompile_result =\n\t\t\tModexp::execute(&mut handle).expect(\"Modexp::execute() returned error\");\n\n\t\tassert_eq!(precompile_result.output.len(), 1); // should be same length as mod\n\t\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);\n\t\tlet expected = BigUint::parse_bytes(b\"0\", 10).unwrap();\n\t\tassert_eq!(result, expected);\n\t}\n\n\t#[test]\n\tfn test_long_exp_gas_cost_matches_specs() {\n\t\tlet input = vec![\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t16, 0, 0, 0, 255, 255, 255, 2, 0, 0, 179, 0, 0, 2, 0, 0, 122, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 255, 251, 0, 0, 0, 0, 4, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 255, 255, 255, 2, 0, 0, 179, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255,\n\t\t\t255, 255, 255, 249,\n\t\t];\n\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\n\t\tlet mut handle = MockHandle::new(input, Some(100_000), context);\n\n\t\tlet _ = Modexp::execute(&mut handle).expect(\"Modexp::execute() returned error\");\n\n\t\tassert_eq!(handle.gas_used, 7104 * 20); // gas used when ran in geth (x20)\n\t}\n}\n", "let\n  mozillaOverlay =\n    import (builtins.fetchGit {\n      url = \"https://github.com/mozilla/nixpkgs-mozilla.git\";\n      rev = \"78e723925daf5c9e8d0a1837ec27059e61649cb6\";\n    });\n  nixpkgs = import <nixpkgs> { overlays = [ mozillaOverlay ]; };\n  rust-nightly = with nixpkgs; ((rustChannelOf { date = \"2022-11-16\"; channel = \"nightly\"; }).rust.override {\n    extensions = [ \"rust-src\" ];\n    targets = [ \"wasm32-unknown-unknown\" ];\n  });\nin\nwith nixpkgs; pkgs.mkShell {\n  buildInputs = [\n    clang\n    pkg-config\n    rust-nightly\n  ] ++ lib.optionals stdenv.isDarwin [\n    darwin.apple_sdk.frameworks.Security\n  ];\n\n  RUST_SRC_PATH = \"${rust-nightly}/lib/rustlib/src/rust/src\";\n  LIBCLANG_PATH = \"${llvmPackages.libclang.lib}/lib\";\n  PROTOC = \"${protobuf}/bin/protoc\";\n  ROCKSDB_LIB_DIR = \"${rocksdb}/lib\";\n}\n"], "filenames": ["frame/evm/precompile/modexp/src/lib.rs", "shell.nix"], "buggy_code_start_loc": [26, 5], "buggy_code_end_loc": [514, 6], "fixing_code_start_loc": [26, 5], "fixing_code_end_loc": [522, 6], "type": "CWE-682", "message": "Frontier is an Ethereum compatibility layer for Substrate. Frontier's `modexp` precompile uses `num-bigint` crate under the hood. In the implementation prior to pull request 1017, the cases for modulus being even and modulus being odd are treated separately. Odd modulus uses the fast Montgomery multiplication, and even modulus uses the slow plain power algorithm. This gas cost discrepancy was not accounted for in the `modexp` precompile, leading to possible denial of service attacks. No fixes for `num-bigint` are currently available, and thus this issue is fixed in the short term by raising the gas costs for even modulus, and in the long term fixing it in `num-bigint` or switching to another modexp implementation. The short-term fix for Frontier is deployed at pull request 1017. There are no known workarounds aside from applying the fix.", "other": {"cve": {"id": "CVE-2023-28431", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-22T21:15:18.170", "lastModified": "2023-03-28T16:27:42.310", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Frontier is an Ethereum compatibility layer for Substrate. Frontier's `modexp` precompile uses `num-bigint` crate under the hood. In the implementation prior to pull request 1017, the cases for modulus being even and modulus being odd are treated separately. Odd modulus uses the fast Montgomery multiplication, and even modulus uses the slow plain power algorithm. This gas cost discrepancy was not accounted for in the `modexp` precompile, leading to possible denial of service attacks. No fixes for `num-bigint` are currently available, and thus this issue is fixed in the short term by raising the gas costs for even modulus, and in the long term fixing it in `num-bigint` or switching to another modexp implementation. The short-term fix for Frontier is deployed at pull request 1017. There are no known workarounds aside from applying the fix."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-682"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parity:frontier:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-03-15", "matchCriteriaId": "D94BBB99-5FB0-4821-903E-58E016A7407F"}]}]}], "references": [{"url": "https://github.com/paritytech/frontier/commit/5af12e94d7dfc8a0208a290643a800f55de7b219", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/paritytech/frontier/pull/1017", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/paritytech/frontier/security/advisories/GHSA-fcmm-54jp-7vf6", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/rust-num/num-bigint/blob/6f2b8e0fc218dbd0f49bebb8db2d1a771fe6bafa/src/biguint/power.rs#L134", "source": "security-advisories@github.com", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/paritytech/frontier/commit/5af12e94d7dfc8a0208a290643a800f55de7b219"}}