{"buggy_code": ["/* DVB USB framework compliant Linux driver for the\n *\tDVBWorld DVB-S 2101, 2102, DVB-S2 2104, DVB-C 3101,\n *\tTeVii S421, S480, S482, S600, S630, S632, S650, S660, S662,\n *\tProf 1100, 7500,\n *\tGeniatech SU3000, T220,\n *\tTechnoTrend S2-4600,\n *\tTerratec Cinergy S2 cards\n * Copyright (C) 2008-2012 Igor M. Liplianin (liplianin@me.by)\n *\n *\tThis program is free software; you can redistribute it and/or modify it\n *\tunder the terms of the GNU General Public License as published by the\n *\tFree Software Foundation, version 2.\n *\n * see Documentation/dvb/README.dvb-usb for more information\n */\n#include \"dvb-usb-ids.h\"\n#include \"dw2102.h\"\n#include \"si21xx.h\"\n#include \"stv0299.h\"\n#include \"z0194a.h\"\n#include \"stv0288.h\"\n#include \"stb6000.h\"\n#include \"eds1547.h\"\n#include \"cx24116.h\"\n#include \"tda1002x.h\"\n#include \"mt312.h\"\n#include \"zl10039.h\"\n#include \"ts2020.h\"\n#include \"ds3000.h\"\n#include \"stv0900.h\"\n#include \"stv6110.h\"\n#include \"stb6100.h\"\n#include \"stb6100_proc.h\"\n#include \"m88rs2000.h\"\n#include \"tda18271.h\"\n#include \"cxd2820r.h\"\n#include \"m88ds3103.h\"\n\n/* Max transfer size done by I2C transfer functions */\n#define MAX_XFER_SIZE  64\n\n\n#define DW210X_READ_MSG 0\n#define DW210X_WRITE_MSG 1\n\n#define REG_1F_SYMBOLRATE_BYTE0 0x1f\n#define REG_20_SYMBOLRATE_BYTE1 0x20\n#define REG_21_SYMBOLRATE_BYTE2 0x21\n/* on my own*/\n#define DW2102_VOLTAGE_CTRL (0x1800)\n#define SU3000_STREAM_CTRL (0x1900)\n#define DW2102_RC_QUERY (0x1a00)\n#define DW2102_LED_CTRL (0x1b00)\n\n#define DW2101_FIRMWARE \"dvb-usb-dw2101.fw\"\n#define DW2102_FIRMWARE \"dvb-usb-dw2102.fw\"\n#define DW2104_FIRMWARE \"dvb-usb-dw2104.fw\"\n#define DW3101_FIRMWARE \"dvb-usb-dw3101.fw\"\n#define S630_FIRMWARE   \"dvb-usb-s630.fw\"\n#define S660_FIRMWARE   \"dvb-usb-s660.fw\"\n#define P1100_FIRMWARE  \"dvb-usb-p1100.fw\"\n#define P7500_FIRMWARE  \"dvb-usb-p7500.fw\"\n\n#define\terr_str \"did not find the firmware file. (%s) \" \\\n\t\t\"Please see linux/Documentation/dvb/ for more details \" \\\n\t\t\"on firmware-problems.\"\n\nstruct dw2102_state {\n\tu8 initialized;\n\tu8 last_lock;\n\tstruct i2c_client *i2c_client_demod;\n\tstruct i2c_client *i2c_client_tuner;\n\n\t/* fe hook functions*/\n\tint (*old_set_voltage)(struct dvb_frontend *f, enum fe_sec_voltage v);\n\tint (*fe_read_status)(struct dvb_frontend *fe,\n\t\t\t      enum fe_status *status);\n};\n\n/* debug */\nstatic int dvb_usb_dw2102_debug;\nmodule_param_named(debug, dvb_usb_dw2102_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info 2=xfer 4=rc(or-able)).\"\n\t\t\t\t\t\tDVB_USB_DEBUG_STATUS);\n\n/* demod probe */\nstatic int demod_probe = 1;\nmodule_param_named(demod, demod_probe, int, 0644);\nMODULE_PARM_DESC(demod, \"demod to probe (1=cx24116 2=stv0903+stv6110 4=stv0903+stb6100(or-able)).\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int dw210x_op_rw(struct usb_device *dev, u8 request, u16 value,\n\t\t\tu16 index, u8 * data, u16 len, int flags)\n{\n\tint ret;\n\tu8 *u8buf;\n\tunsigned int pipe = (flags == DW210X_READ_MSG) ?\n\t\t\t\tusb_rcvctrlpipe(dev, 0) : usb_sndctrlpipe(dev, 0);\n\tu8 request_type = (flags == DW210X_READ_MSG) ? USB_DIR_IN : USB_DIR_OUT;\n\n\tu8buf = kmalloc(len, GFP_KERNEL);\n\tif (!u8buf)\n\t\treturn -ENOMEM;\n\n\n\tif (flags == DW210X_WRITE_MSG)\n\t\tmemcpy(u8buf, data, len);\n\tret = usb_control_msg(dev, pipe, request, request_type | USB_TYPE_VENDOR,\n\t\t\t\tvalue, index , u8buf, len, 2000);\n\n\tif (flags == DW210X_READ_MSG)\n\t\tmemcpy(data, u8buf, len);\n\n\tkfree(u8buf);\n\treturn ret;\n}\n\n/* I2C */\nstatic int dw2102_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint i = 0;\n\tu8 buf6[] = {0x2c, 0x05, 0xc0, 0, 0, 0, 0};\n\tu16 value;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (num) {\n\tcase 2:\n\t\t/* read stv0299 register */\n\t\tvalue = msg[0].buf[0];/* register */\n\t\tfor (i = 0; i < msg[1].len; i++) {\n\t\t\tdw210x_op_rw(d->udev, 0xb5, value + i, 0,\n\t\t\t\t\tbuf6, 2, DW210X_READ_MSG);\n\t\t\tmsg[1].buf[i] = buf6[0];\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase 0x68:\n\t\t\t/* write to stv0299 register */\n\t\t\tbuf6[0] = 0x2a;\n\t\t\tbuf6[1] = msg[0].buf[0];\n\t\t\tbuf6[2] = msg[0].buf[1];\n\t\t\tdw210x_op_rw(d->udev, 0xb2, 0, 0,\n\t\t\t\t\tbuf6, 3, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\tcase 0x60:\n\t\t\tif (msg[0].flags == 0) {\n\t\t\t/* write to tuner pll */\n\t\t\t\tbuf6[0] = 0x2c;\n\t\t\t\tbuf6[1] = 5;\n\t\t\t\tbuf6[2] = 0xc0;\n\t\t\t\tbuf6[3] = msg[0].buf[0];\n\t\t\t\tbuf6[4] = msg[0].buf[1];\n\t\t\t\tbuf6[5] = msg[0].buf[2];\n\t\t\t\tbuf6[6] = msg[0].buf[3];\n\t\t\t\tdw210x_op_rw(d->udev, 0xb2, 0, 0,\n\t\t\t\t\t\tbuf6, 7, DW210X_WRITE_MSG);\n\t\t\t} else {\n\t\t\t/* read from tuner */\n\t\t\t\tdw210x_op_rw(d->udev, 0xb5, 0, 0,\n\t\t\t\t\t\tbuf6, 1, DW210X_READ_MSG);\n\t\t\t\tmsg[0].buf[0] = buf6[0];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase (DW2102_RC_QUERY):\n\t\t\tdw210x_op_rw(d->udev, 0xb8, 0, 0,\n\t\t\t\t\tbuf6, 2, DW210X_READ_MSG);\n\t\t\tmsg[0].buf[0] = buf6[0];\n\t\t\tmsg[0].buf[1] = buf6[1];\n\t\t\tbreak;\n\t\tcase (DW2102_VOLTAGE_CTRL):\n\t\t\tbuf6[0] = 0x30;\n\t\t\tbuf6[1] = msg[0].buf[0];\n\t\t\tdw210x_op_rw(d->udev, 0xb2, 0, 0,\n\t\t\t\t\tbuf6, 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn num;\n}\n\nstatic int dw2102_serit_i2c_transfer(struct i2c_adapter *adap,\n\t\t\t\t\t\tstruct i2c_msg msg[], int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tu8 buf6[] = {0, 0, 0, 0, 0, 0, 0};\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (num) {\n\tcase 2:\n\t\t/* read si2109 register by number */\n\t\tbuf6[0] = msg[0].addr << 1;\n\t\tbuf6[1] = msg[0].len;\n\t\tbuf6[2] = msg[0].buf[0];\n\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\tbuf6, msg[0].len + 2, DW210X_WRITE_MSG);\n\t\t/* read si2109 register */\n\t\tdw210x_op_rw(d->udev, 0xc3, 0xd0, 0,\n\t\t\t\tbuf6, msg[1].len + 2, DW210X_READ_MSG);\n\t\tmemcpy(msg[1].buf, buf6 + 2, msg[1].len);\n\n\t\tbreak;\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase 0x68:\n\t\t\t/* write to si2109 register */\n\t\t\tbuf6[0] = msg[0].addr << 1;\n\t\t\tbuf6[1] = msg[0].len;\n\t\t\tmemcpy(buf6 + 2, msg[0].buf, msg[0].len);\n\t\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0, buf6,\n\t\t\t\t\tmsg[0].len + 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\tcase(DW2102_RC_QUERY):\n\t\t\tdw210x_op_rw(d->udev, 0xb8, 0, 0,\n\t\t\t\t\tbuf6, 2, DW210X_READ_MSG);\n\t\t\tmsg[0].buf[0] = buf6[0];\n\t\t\tmsg[0].buf[1] = buf6[1];\n\t\t\tbreak;\n\t\tcase(DW2102_VOLTAGE_CTRL):\n\t\t\tbuf6[0] = 0x30;\n\t\t\tbuf6[1] = msg[0].buf[0];\n\t\t\tdw210x_op_rw(d->udev, 0xb2, 0, 0,\n\t\t\t\t\tbuf6, 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn num;\n}\n\nstatic int dw2102_earda_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[], int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint ret;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (num) {\n\tcase 2: {\n\t\t/* read */\n\t\t/* first write first register number */\n\t\tu8 ibuf[MAX_XFER_SIZE], obuf[3];\n\n\t\tif (2 + msg[1].len > sizeof(ibuf)) {\n\t\t\twarn(\"i2c rd: len=%d is too big!\\n\",\n\t\t\t     msg[1].len);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tobuf[0] = msg[0].addr << 1;\n\t\tobuf[1] = msg[0].len;\n\t\tobuf[2] = msg[0].buf[0];\n\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\tobuf, msg[0].len + 2, DW210X_WRITE_MSG);\n\t\t/* second read registers */\n\t\tdw210x_op_rw(d->udev, 0xc3, 0xd1 , 0,\n\t\t\t\tibuf, msg[1].len + 2, DW210X_READ_MSG);\n\t\tmemcpy(msg[1].buf, ibuf + 2, msg[1].len);\n\n\t\tbreak;\n\t}\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase 0x68: {\n\t\t\t/* write to register */\n\t\t\tu8 obuf[MAX_XFER_SIZE];\n\n\t\t\tif (2 + msg[0].len > sizeof(obuf)) {\n\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t     msg[1].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tobuf[0] = msg[0].addr << 1;\n\t\t\tobuf[1] = msg[0].len;\n\t\t\tmemcpy(obuf + 2, msg[0].buf, msg[0].len);\n\t\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\t\tobuf, msg[0].len + 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x61: {\n\t\t\t/* write to tuner */\n\t\t\tu8 obuf[MAX_XFER_SIZE];\n\n\t\t\tif (2 + msg[0].len > sizeof(obuf)) {\n\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t     msg[1].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tobuf[0] = msg[0].addr << 1;\n\t\t\tobuf[1] = msg[0].len;\n\t\t\tmemcpy(obuf + 2, msg[0].buf, msg[0].len);\n\t\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\t\tobuf, msg[0].len + 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\tcase(DW2102_RC_QUERY): {\n\t\t\tu8 ibuf[2];\n\t\t\tdw210x_op_rw(d->udev, 0xb8, 0, 0,\n\t\t\t\t\tibuf, 2, DW210X_READ_MSG);\n\t\t\tmemcpy(msg[0].buf, ibuf , 2);\n\t\t\tbreak;\n\t\t}\n\t\tcase(DW2102_VOLTAGE_CTRL): {\n\t\t\tu8 obuf[2];\n\t\t\tobuf[0] = 0x30;\n\t\t\tobuf[1] = msg[0].buf[0];\n\t\t\tdw210x_op_rw(d->udev, 0xb2, 0, 0,\n\t\t\t\t\tobuf, 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tret = num;\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic int dw2104_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[], int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint len, i, j, ret;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (j = 0; j < num; j++) {\n\t\tswitch (msg[j].addr) {\n\t\tcase(DW2102_RC_QUERY): {\n\t\t\tu8 ibuf[2];\n\t\t\tdw210x_op_rw(d->udev, 0xb8, 0, 0,\n\t\t\t\t\tibuf, 2, DW210X_READ_MSG);\n\t\t\tmemcpy(msg[j].buf, ibuf , 2);\n\t\t\tbreak;\n\t\t}\n\t\tcase(DW2102_VOLTAGE_CTRL): {\n\t\t\tu8 obuf[2];\n\t\t\tobuf[0] = 0x30;\n\t\t\tobuf[1] = msg[j].buf[0];\n\t\t\tdw210x_op_rw(d->udev, 0xb2, 0, 0,\n\t\t\t\t\tobuf, 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\t/*case 0x55: cx24116\n\t\tcase 0x6a: stv0903\n\t\tcase 0x68: ds3000, stv0903\n\t\tcase 0x60: ts2020, stv6110, stb6100 */\n\t\tdefault: {\n\t\t\tif (msg[j].flags == I2C_M_RD) {\n\t\t\t\t/* read registers */\n\t\t\t\tu8  ibuf[MAX_XFER_SIZE];\n\n\t\t\t\tif (2 + msg[j].len > sizeof(ibuf)) {\n\t\t\t\t\twarn(\"i2c rd: len=%d is too big!\\n\",\n\t\t\t\t\t     msg[j].len);\n\t\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\n\t\t\t\tdw210x_op_rw(d->udev, 0xc3,\n\t\t\t\t\t\t(msg[j].addr << 1) + 1, 0,\n\t\t\t\t\t\tibuf, msg[j].len + 2,\n\t\t\t\t\t\tDW210X_READ_MSG);\n\t\t\t\tmemcpy(msg[j].buf, ibuf + 2, msg[j].len);\n\t\t\t\tmdelay(10);\n\t\t\t} else if (((msg[j].buf[0] == 0xb0) &&\n\t\t\t\t\t\t(msg[j].addr == 0x68)) ||\n\t\t\t\t\t\t((msg[j].buf[0] == 0xf7) &&\n\t\t\t\t\t\t(msg[j].addr == 0x55))) {\n\t\t\t\t/* write firmware */\n\t\t\t\tu8 obuf[19];\n\t\t\t\tobuf[0] = msg[j].addr << 1;\n\t\t\t\tobuf[1] = (msg[j].len > 15 ? 17 : msg[j].len);\n\t\t\t\tobuf[2] = msg[j].buf[0];\n\t\t\t\tlen = msg[j].len - 1;\n\t\t\t\ti = 1;\n\t\t\t\tdo {\n\t\t\t\t\tmemcpy(obuf + 3, msg[j].buf + i,\n\t\t\t\t\t\t\t(len > 16 ? 16 : len));\n\t\t\t\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\t\t\tobuf, (len > 16 ? 16 : len) + 3,\n\t\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t\t\ti += 16;\n\t\t\t\t\tlen -= 16;\n\t\t\t\t} while (len > 0);\n\t\t\t} else {\n\t\t\t\t/* write registers */\n\t\t\t\tu8 obuf[MAX_XFER_SIZE];\n\n\t\t\t\tif (2 + msg[j].len > sizeof(obuf)) {\n\t\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t\t     msg[j].len);\n\t\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\n\t\t\t\tobuf[0] = msg[j].addr << 1;\n\t\t\t\tobuf[1] = msg[j].len;\n\t\t\t\tmemcpy(obuf + 2, msg[j].buf, msg[j].len);\n\t\t\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\t\t\tobuf, msg[j].len + 2,\n\t\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\n\t}\n\tret = num;\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic int dw3101_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t\t\t\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint ret;\n\tint i;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (num) {\n\tcase 2: {\n\t\t/* read */\n\t\t/* first write first register number */\n\t\tu8 ibuf[MAX_XFER_SIZE], obuf[3];\n\n\t\tif (2 + msg[1].len > sizeof(ibuf)) {\n\t\t\twarn(\"i2c rd: len=%d is too big!\\n\",\n\t\t\t     msg[1].len);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto unlock;\n\t\t}\n\t\tobuf[0] = msg[0].addr << 1;\n\t\tobuf[1] = msg[0].len;\n\t\tobuf[2] = msg[0].buf[0];\n\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\tobuf, msg[0].len + 2, DW210X_WRITE_MSG);\n\t\t/* second read registers */\n\t\tdw210x_op_rw(d->udev, 0xc3, 0x19 , 0,\n\t\t\t\tibuf, msg[1].len + 2, DW210X_READ_MSG);\n\t\tmemcpy(msg[1].buf, ibuf + 2, msg[1].len);\n\n\t\tbreak;\n\t}\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase 0x60:\n\t\tcase 0x0c: {\n\t\t\t/* write to register */\n\t\t\tu8 obuf[MAX_XFER_SIZE];\n\n\t\t\tif (2 + msg[0].len > sizeof(obuf)) {\n\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t     msg[0].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tobuf[0] = msg[0].addr << 1;\n\t\t\tobuf[1] = msg[0].len;\n\t\t\tmemcpy(obuf + 2, msg[0].buf, msg[0].len);\n\t\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\t\tobuf, msg[0].len + 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\tcase(DW2102_RC_QUERY): {\n\t\t\tu8 ibuf[2];\n\t\t\tdw210x_op_rw(d->udev, 0xb8, 0, 0,\n\t\t\t\t\tibuf, 2, DW210X_READ_MSG);\n\t\t\tmemcpy(msg[0].buf, ibuf , 2);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tdeb_xfer(\"%02x:%02x: %s \", i, msg[i].addr,\n\t\t\t\tmsg[i].flags == 0 ? \">>>\" : \"<<<\");\n\t\tdebug_dump(msg[i].buf, msg[i].len, deb_xfer);\n\t}\n\tret = num;\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic int s6x0_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t\t\t\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct usb_device *udev;\n\tint len, i, j, ret;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tudev = d->udev;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (j = 0; j < num; j++) {\n\t\tswitch (msg[j].addr) {\n\t\tcase (DW2102_RC_QUERY): {\n\t\t\tu8 ibuf[5];\n\t\t\tdw210x_op_rw(d->udev, 0xb8, 0, 0,\n\t\t\t\t\tibuf, 5, DW210X_READ_MSG);\n\t\t\tmemcpy(msg[j].buf, ibuf + 3, 2);\n\t\t\tbreak;\n\t\t}\n\t\tcase (DW2102_VOLTAGE_CTRL): {\n\t\t\tu8 obuf[2];\n\n\t\t\tobuf[0] = 1;\n\t\t\tobuf[1] = msg[j].buf[1];/* off-on */\n\t\t\tdw210x_op_rw(d->udev, 0x8a, 0, 0,\n\t\t\t\t\tobuf, 2, DW210X_WRITE_MSG);\n\t\t\tobuf[0] = 3;\n\t\t\tobuf[1] = msg[j].buf[0];/* 13v-18v */\n\t\t\tdw210x_op_rw(d->udev, 0x8a, 0, 0,\n\t\t\t\t\tobuf, 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\tcase (DW2102_LED_CTRL): {\n\t\t\tu8 obuf[2];\n\n\t\t\tobuf[0] = 5;\n\t\t\tobuf[1] = msg[j].buf[0];\n\t\t\tdw210x_op_rw(d->udev, 0x8a, 0, 0,\n\t\t\t\t\tobuf, 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\t/*case 0x55: cx24116\n\t\tcase 0x6a: stv0903\n\t\tcase 0x68: ds3000, stv0903, rs2000\n\t\tcase 0x60: ts2020, stv6110, stb6100\n\t\tcase 0xa0: eeprom */\n\t\tdefault: {\n\t\t\tif (msg[j].flags == I2C_M_RD) {\n\t\t\t\t/* read registers */\n\t\t\t\tu8 ibuf[MAX_XFER_SIZE];\n\n\t\t\t\tif (msg[j].len > sizeof(ibuf)) {\n\t\t\t\t\twarn(\"i2c rd: len=%d is too big!\\n\",\n\t\t\t\t\t     msg[j].len);\n\t\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\n\t\t\t\tdw210x_op_rw(d->udev, 0x91, 0, 0,\n\t\t\t\t\t\tibuf, msg[j].len,\n\t\t\t\t\t\tDW210X_READ_MSG);\n\t\t\t\tmemcpy(msg[j].buf, ibuf, msg[j].len);\n\t\t\t\tbreak;\n\t\t\t} else if ((msg[j].buf[0] == 0xb0) &&\n\t\t\t\t\t\t(msg[j].addr == 0x68)) {\n\t\t\t\t/* write firmware */\n\t\t\t\tu8 obuf[19];\n\t\t\t\tobuf[0] = (msg[j].len > 16 ?\n\t\t\t\t\t\t18 : msg[j].len + 1);\n\t\t\t\tobuf[1] = msg[j].addr << 1;\n\t\t\t\tobuf[2] = msg[j].buf[0];\n\t\t\t\tlen = msg[j].len - 1;\n\t\t\t\ti = 1;\n\t\t\t\tdo {\n\t\t\t\t\tmemcpy(obuf + 3, msg[j].buf + i,\n\t\t\t\t\t\t\t(len > 16 ? 16 : len));\n\t\t\t\t\tdw210x_op_rw(d->udev, 0x80, 0, 0,\n\t\t\t\t\t\tobuf, (len > 16 ? 16 : len) + 3,\n\t\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t\t\ti += 16;\n\t\t\t\t\tlen -= 16;\n\t\t\t\t} while (len > 0);\n\t\t\t} else if (j < (num - 1)) {\n\t\t\t\t/* write register addr before read */\n\t\t\t\tu8 obuf[MAX_XFER_SIZE];\n\n\t\t\t\tif (2 + msg[j].len > sizeof(obuf)) {\n\t\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t\t     msg[j].len);\n\t\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\n\t\t\t\tobuf[0] = msg[j + 1].len;\n\t\t\t\tobuf[1] = (msg[j].addr << 1);\n\t\t\t\tmemcpy(obuf + 2, msg[j].buf, msg[j].len);\n\t\t\t\tdw210x_op_rw(d->udev,\n\t\t\t\t\t\tle16_to_cpu(udev->descriptor.idProduct) ==\n\t\t\t\t\t\t0x7500 ? 0x92 : 0x90, 0, 0,\n\t\t\t\t\t\tobuf, msg[j].len + 2,\n\t\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* write registers */\n\t\t\t\tu8 obuf[MAX_XFER_SIZE];\n\n\t\t\t\tif (2 + msg[j].len > sizeof(obuf)) {\n\t\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t\t     msg[j].len);\n\t\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\t\t\t\tobuf[0] = msg[j].len + 1;\n\t\t\t\tobuf[1] = (msg[j].addr << 1);\n\t\t\t\tmemcpy(obuf + 2, msg[j].buf, msg[j].len);\n\t\t\t\tdw210x_op_rw(d->udev, 0x80, 0, 0,\n\t\t\t\t\t\tobuf, msg[j].len + 2,\n\t\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\tret = num;\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t\t\t\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tu8 obuf[0x40], ibuf[0x40];\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (num) {\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase SU3000_STREAM_CTRL:\n\t\t\tobuf[0] = msg[0].buf[0] + 0x36;\n\t\t\tobuf[1] = 3;\n\t\t\tobuf[2] = 0;\n\t\t\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 0, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tbreak;\n\t\tcase DW2102_RC_QUERY:\n\t\t\tobuf[0] = 0x10;\n\t\t\tif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 2, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tmsg[0].buf[1] = ibuf[0];\n\t\t\tmsg[0].buf[0] = ibuf[1];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* always i2c write*/\n\t\t\tobuf[0] = 0x08;\n\t\t\tobuf[1] = msg[0].addr;\n\t\t\tobuf[2] = msg[0].len;\n\n\t\t\tmemcpy(&obuf[3], msg[0].buf, msg[0].len);\n\n\t\t\tif (dvb_usb_generic_rw(d, obuf, msg[0].len + 3,\n\t\t\t\t\t\tibuf, 1, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t/* always i2c read */\n\t\tobuf[0] = 0x09;\n\t\tobuf[1] = msg[0].len;\n\t\tobuf[2] = msg[1].len;\n\t\tobuf[3] = msg[0].addr;\n\t\tmemcpy(&obuf[4], msg[0].buf, msg[0].len);\n\n\t\tif (dvb_usb_generic_rw(d, obuf, msg[0].len + 4,\n\t\t\t\t\tibuf, msg[1].len + 1, 0) < 0)\n\t\t\terr(\"i2c transfer failed.\");\n\n\t\tmemcpy(msg[1].buf, &ibuf[1], msg[1].len);\n\t\tbreak;\n\tdefault:\n\t\twarn(\"more than 2 i2c messages at a time is not handled yet.\");\n\t\tbreak;\n\t}\n\tmutex_unlock(&d->i2c_mutex);\n\treturn num;\n}\n\nstatic u32 dw210x_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm dw2102_i2c_algo = {\n\t.master_xfer = dw2102_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic struct i2c_algorithm dw2102_serit_i2c_algo = {\n\t.master_xfer = dw2102_serit_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic struct i2c_algorithm dw2102_earda_i2c_algo = {\n\t.master_xfer = dw2102_earda_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic struct i2c_algorithm dw2104_i2c_algo = {\n\t.master_xfer = dw2104_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic struct i2c_algorithm dw3101_i2c_algo = {\n\t.master_xfer = dw3101_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic struct i2c_algorithm s6x0_i2c_algo = {\n\t.master_xfer = s6x0_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic struct i2c_algorithm su3000_i2c_algo = {\n\t.master_xfer = su3000_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic int dw210x_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\n{\n\tint i;\n\tu8 ibuf[] = {0, 0};\n\tu8 eeprom[256], eepromline[16];\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (dw210x_op_rw(d->udev, 0xb6, 0xa0 , i, ibuf, 2, DW210X_READ_MSG) < 0) {\n\t\t\terr(\"read eeprom failed.\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\teepromline[i%16] = ibuf[0];\n\t\t\teeprom[i] = ibuf[0];\n\t\t}\n\t\tif ((i % 16) == 15) {\n\t\t\tdeb_xfer(\"%02x: \", i - 15);\n\t\t\tdebug_dump(eepromline, 16, deb_xfer);\n\t\t}\n\t}\n\n\tmemcpy(mac, eeprom + 8, 6);\n\treturn 0;\n};\n\nstatic int s6x0_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\n{\n\tint i, ret;\n\tu8 ibuf[] = { 0 }, obuf[] = { 0 };\n\tu8 eeprom[256], eepromline[16];\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = 0xa0 >> 1,\n\t\t\t.flags = 0,\n\t\t\t.buf = obuf,\n\t\t\t.len = 1,\n\t\t}, {\n\t\t\t.addr = 0xa0 >> 1,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = ibuf,\n\t\t\t.len = 1,\n\t\t}\n\t};\n\n\tfor (i = 0; i < 256; i++) {\n\t\tobuf[0] = i;\n\t\tret = s6x0_i2c_transfer(&d->i2c_adap, msg, 2);\n\t\tif (ret != 2) {\n\t\t\terr(\"read eeprom failed.\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\teepromline[i % 16] = ibuf[0];\n\t\t\teeprom[i] = ibuf[0];\n\t\t}\n\n\t\tif ((i % 16) == 15) {\n\t\t\tdeb_xfer(\"%02x: \", i - 15);\n\t\t\tdebug_dump(eepromline, 16, deb_xfer);\n\t\t}\n\t}\n\n\tmemcpy(mac, eeprom + 16, 6);\n\treturn 0;\n};\n\nstatic int su3000_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tstatic u8 command_start[] = {0x00};\n\tstatic u8 command_stop[] = {0x01};\n\tstruct i2c_msg msg = {\n\t\t.addr = SU3000_STREAM_CTRL,\n\t\t.flags = 0,\n\t\t.buf = onoff ? command_start : command_stop,\n\t\t.len = 1\n\t};\n\n\ti2c_transfer(&adap->dev->i2c_adap, &msg, 1);\n\n\treturn 0;\n}\n\nstatic int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tu8 obuf[] = {0xde, 0};\n\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\n\tif (i && !state->initialized) {\n\t\tstate->initialized = 1;\n\t\t/* reset board */\n\t\treturn dvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int su3000_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\n{\n\tint i;\n\tu8 obuf[] = { 0x1f, 0xf0 };\n\tu8 ibuf[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = 0x51,\n\t\t\t.flags = 0,\n\t\t\t.buf = obuf,\n\t\t\t.len = 2,\n\t\t}, {\n\t\t\t.addr = 0x51,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = ibuf,\n\t\t\t.len = 1,\n\n\t\t}\n\t};\n\n\tfor (i = 0; i < 6; i++) {\n\t\tobuf[1] = 0xf0 + i;\n\t\tif (i2c_transfer(&d->i2c_adap, msg, 2) != 2)\n\t\t\tbreak;\n\t\telse\n\t\t\tmac[i] = ibuf[0];\n\t}\n\n\treturn 0;\n}\n\nstatic int su3000_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tinfo(\"%s\", __func__);\n\n\t*cold = 0;\n\treturn 0;\n}\n\nstatic int dw210x_set_voltage(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_voltage voltage)\n{\n\tstatic u8 command_13v[] = {0x00, 0x01};\n\tstatic u8 command_18v[] = {0x01, 0x01};\n\tstatic u8 command_off[] = {0x00, 0x00};\n\tstruct i2c_msg msg = {\n\t\t.addr = DW2102_VOLTAGE_CTRL,\n\t\t.flags = 0,\n\t\t.buf = command_off,\n\t\t.len = 2,\n\t};\n\n\tstruct dvb_usb_adapter *udev_adap =\n\t\t(struct dvb_usb_adapter *)(fe->dvb->priv);\n\tif (voltage == SEC_VOLTAGE_18)\n\t\tmsg.buf = command_18v;\n\telse if (voltage == SEC_VOLTAGE_13)\n\t\tmsg.buf = command_13v;\n\n\ti2c_transfer(&udev_adap->dev->i2c_adap, &msg, 1);\n\n\treturn 0;\n}\n\nstatic int s660_set_voltage(struct dvb_frontend *fe,\n\t\t\t    enum fe_sec_voltage voltage)\n{\n\tstruct dvb_usb_adapter *d =\n\t\t(struct dvb_usb_adapter *)(fe->dvb->priv);\n\tstruct dw2102_state *st = (struct dw2102_state *)d->dev->priv;\n\n\tdw210x_set_voltage(fe, voltage);\n\tif (st->old_set_voltage)\n\t\tst->old_set_voltage(fe, voltage);\n\n\treturn 0;\n}\n\nstatic void dw210x_led_ctrl(struct dvb_frontend *fe, int offon)\n{\n\tstatic u8 led_off[] = { 0 };\n\tstatic u8 led_on[] = { 1 };\n\tstruct i2c_msg msg = {\n\t\t.addr = DW2102_LED_CTRL,\n\t\t.flags = 0,\n\t\t.buf = led_off,\n\t\t.len = 1\n\t};\n\tstruct dvb_usb_adapter *udev_adap =\n\t\t(struct dvb_usb_adapter *)(fe->dvb->priv);\n\n\tif (offon)\n\t\tmsg.buf = led_on;\n\ti2c_transfer(&udev_adap->dev->i2c_adap, &msg, 1);\n}\n\nstatic int tt_s2_4600_read_status(struct dvb_frontend *fe,\n\t\t\t\t  enum fe_status *status)\n{\n\tstruct dvb_usb_adapter *d =\n\t\t(struct dvb_usb_adapter *)(fe->dvb->priv);\n\tstruct dw2102_state *st = (struct dw2102_state *)d->dev->priv;\n\tint ret;\n\n\tret = st->fe_read_status(fe, status);\n\n\t/* resync slave fifo when signal change from unlock to lock */\n\tif ((*status & FE_HAS_LOCK) && (!st->last_lock))\n\t\tsu3000_streaming_ctrl(d, 1);\n\n\tst->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;\n\treturn ret;\n}\n\nstatic struct stv0299_config sharp_z0194a_config = {\n\t.demod_address = 0x68,\n\t.inittab = sharp_z0194a_inittab,\n\t.mclk = 88000000UL,\n\t.invert = 1,\n\t.skip_reinit = 0,\n\t.lock_output = STV0299_LOCKOUTPUT_1,\n\t.volt13_op0_op1 = STV0299_VOLT13_OP1,\n\t.min_delay_ms = 100,\n\t.set_symbol_rate = sharp_z0194a_set_symbol_rate,\n};\n\nstatic struct cx24116_config dw2104_config = {\n\t.demod_address = 0x55,\n\t.mpg_clk_pos_pol = 0x01,\n};\n\nstatic struct si21xx_config serit_sp1511lhb_config = {\n\t.demod_address = 0x68,\n\t.min_delay_ms = 100,\n\n};\n\nstatic struct tda10023_config dw3101_tda10023_config = {\n\t.demod_address = 0x0c,\n\t.invert = 1,\n};\n\nstatic struct mt312_config zl313_config = {\n\t.demod_address = 0x0e,\n};\n\nstatic struct ds3000_config dw2104_ds3000_config = {\n\t.demod_address = 0x68,\n};\n\nstatic struct ts2020_config dw2104_ts2020_config = {\n\t.tuner_address = 0x60,\n\t.clk_out_div = 1,\n\t.frequency_div = 1060000,\n};\n\nstatic struct ds3000_config s660_ds3000_config = {\n\t.demod_address = 0x68,\n\t.ci_mode = 1,\n\t.set_lock_led = dw210x_led_ctrl,\n};\n\nstatic struct ts2020_config s660_ts2020_config = {\n\t.tuner_address = 0x60,\n\t.clk_out_div = 1,\n\t.frequency_div = 1146000,\n};\n\nstatic struct stv0900_config dw2104a_stv0900_config = {\n\t.demod_address = 0x6a,\n\t.demod_mode = 0,\n\t.xtal = 27000000,\n\t.clkmode = 3,/* 0-CLKI, 2-XTALI, else AUTO */\n\t.diseqc_mode = 2,/* 2/3 PWM */\n\t.tun1_maddress = 0,/* 0x60 */\n\t.tun1_adc = 0,/* 2 Vpp */\n\t.path1_mode = 3,\n};\n\nstatic struct stb6100_config dw2104a_stb6100_config = {\n\t.tuner_address = 0x60,\n\t.refclock = 27000000,\n};\n\nstatic struct stv0900_config dw2104_stv0900_config = {\n\t.demod_address = 0x68,\n\t.demod_mode = 0,\n\t.xtal = 8000000,\n\t.clkmode = 3,\n\t.diseqc_mode = 2,\n\t.tun1_maddress = 0,\n\t.tun1_adc = 1,/* 1 Vpp */\n\t.path1_mode = 3,\n};\n\nstatic struct stv6110_config dw2104_stv6110_config = {\n\t.i2c_address = 0x60,\n\t.mclk = 16000000,\n\t.clk_div = 1,\n};\n\nstatic struct stv0900_config prof_7500_stv0900_config = {\n\t.demod_address = 0x6a,\n\t.demod_mode = 0,\n\t.xtal = 27000000,\n\t.clkmode = 3,/* 0-CLKI, 2-XTALI, else AUTO */\n\t.diseqc_mode = 2,/* 2/3 PWM */\n\t.tun1_maddress = 0,/* 0x60 */\n\t.tun1_adc = 0,/* 2 Vpp */\n\t.path1_mode = 3,\n\t.tun1_type = 3,\n\t.set_lock_led = dw210x_led_ctrl,\n};\n\nstatic struct ds3000_config su3000_ds3000_config = {\n\t.demod_address = 0x68,\n\t.ci_mode = 1,\n\t.set_lock_led = dw210x_led_ctrl,\n};\n\nstatic struct cxd2820r_config cxd2820r_config = {\n\t.i2c_address = 0x6c, /* (0xd8 >> 1) */\n\t.ts_mode = 0x38,\n\t.ts_clock_inv = 1,\n};\n\nstatic struct tda18271_config tda18271_config = {\n\t.output_opt = TDA18271_OUTPUT_LT_OFF,\n\t.gate = TDA18271_GATE_DIGITAL,\n};\n\nstatic u8 m88rs2000_inittab[] = {\n\tDEMOD_WRITE, 0x9a, 0x30,\n\tDEMOD_WRITE, 0x00, 0x01,\n\tWRITE_DELAY, 0x19, 0x00,\n\tDEMOD_WRITE, 0x00, 0x00,\n\tDEMOD_WRITE, 0x9a, 0xb0,\n\tDEMOD_WRITE, 0x81, 0xc1,\n\tDEMOD_WRITE, 0x81, 0x81,\n\tDEMOD_WRITE, 0x86, 0xc6,\n\tDEMOD_WRITE, 0x9a, 0x30,\n\tDEMOD_WRITE, 0xf0, 0x80,\n\tDEMOD_WRITE, 0xf1, 0xbf,\n\tDEMOD_WRITE, 0xb0, 0x45,\n\tDEMOD_WRITE, 0xb2, 0x01,\n\tDEMOD_WRITE, 0x9a, 0xb0,\n\t0xff, 0xaa, 0xff\n};\n\nstatic struct m88rs2000_config s421_m88rs2000_config = {\n\t.demod_addr = 0x68,\n\t.inittab = m88rs2000_inittab,\n};\n\nstatic int dw2104_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tstruct dvb_tuner_ops *tuner_ops = NULL;\n\n\tif (demod_probe & 4) {\n\t\td->fe_adap[0].fe = dvb_attach(stv0900_attach, &dw2104a_stv0900_config,\n\t\t\t\t&d->dev->i2c_adap, 0);\n\t\tif (d->fe_adap[0].fe != NULL) {\n\t\t\tif (dvb_attach(stb6100_attach, d->fe_adap[0].fe,\n\t\t\t\t\t&dw2104a_stb6100_config,\n\t\t\t\t\t&d->dev->i2c_adap)) {\n\t\t\t\ttuner_ops = &d->fe_adap[0].fe->ops.tuner_ops;\n\t\t\t\ttuner_ops->set_frequency = stb6100_set_freq;\n\t\t\t\ttuner_ops->get_frequency = stb6100_get_freq;\n\t\t\t\ttuner_ops->set_bandwidth = stb6100_set_bandw;\n\t\t\t\ttuner_ops->get_bandwidth = stb6100_get_bandw;\n\t\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\t\tinfo(\"Attached STV0900+STB6100!\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (demod_probe & 2) {\n\t\td->fe_adap[0].fe = dvb_attach(stv0900_attach, &dw2104_stv0900_config,\n\t\t\t\t&d->dev->i2c_adap, 0);\n\t\tif (d->fe_adap[0].fe != NULL) {\n\t\t\tif (dvb_attach(stv6110_attach, d->fe_adap[0].fe,\n\t\t\t\t\t&dw2104_stv6110_config,\n\t\t\t\t\t&d->dev->i2c_adap)) {\n\t\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\t\tinfo(\"Attached STV0900+STV6110A!\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (demod_probe & 1) {\n\t\td->fe_adap[0].fe = dvb_attach(cx24116_attach, &dw2104_config,\n\t\t\t\t&d->dev->i2c_adap);\n\t\tif (d->fe_adap[0].fe != NULL) {\n\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\tinfo(\"Attached cx24116!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &dw2104_ds3000_config,\n\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe != NULL) {\n\t\tdvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t&dw2104_ts2020_config, &d->dev->i2c_adap);\n\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\tinfo(\"Attached DS3000!\");\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\nstatic struct dvb_usb_device_properties dw2102_properties;\nstatic struct dvb_usb_device_properties dw2104_properties;\nstatic struct dvb_usb_device_properties s6x0_properties;\n\nstatic int dw2102_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tif (dw2102_properties.i2c_algo == &dw2102_serit_i2c_algo) {\n\t\t/*dw2102_properties.adapter->tuner_attach = NULL;*/\n\t\td->fe_adap[0].fe = dvb_attach(si21xx_attach, &serit_sp1511lhb_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\t\tif (d->fe_adap[0].fe != NULL) {\n\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\tinfo(\"Attached si21xx!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (dw2102_properties.i2c_algo == &dw2102_earda_i2c_algo) {\n\t\td->fe_adap[0].fe = dvb_attach(stv0288_attach, &earda_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\t\tif (d->fe_adap[0].fe != NULL) {\n\t\t\tif (dvb_attach(stb6000_attach, d->fe_adap[0].fe, 0x61,\n\t\t\t\t\t&d->dev->i2c_adap)) {\n\t\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\t\tinfo(\"Attached stv0288!\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dw2102_properties.i2c_algo == &dw2102_i2c_algo) {\n\t\t/*dw2102_properties.adapter->tuner_attach = dw2102_tuner_attach;*/\n\t\td->fe_adap[0].fe = dvb_attach(stv0299_attach, &sharp_z0194a_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\t\tif (d->fe_adap[0].fe != NULL) {\n\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\tinfo(\"Attached stv0299!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EIO;\n}\n\nstatic int dw3101_frontend_attach(struct dvb_usb_adapter *d)\n{\n\td->fe_adap[0].fe = dvb_attach(tda10023_attach, &dw3101_tda10023_config,\n\t\t\t\t&d->dev->i2c_adap, 0x48);\n\tif (d->fe_adap[0].fe != NULL) {\n\t\tinfo(\"Attached tda10023!\");\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}\n\nstatic int zl100313_frontend_attach(struct dvb_usb_adapter *d)\n{\n\td->fe_adap[0].fe = dvb_attach(mt312_attach, &zl313_config,\n\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe != NULL) {\n\t\tif (dvb_attach(zl10039_attach, d->fe_adap[0].fe, 0x60,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\tinfo(\"Attached zl100313+zl10039!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EIO;\n}\n\nstatic int stv0288_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[] = {7, 1};\n\n\td->fe_adap[0].fe = dvb_attach(stv0288_attach, &earda_config,\n\t\t\t&d->dev->i2c_adap);\n\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\tif (NULL == dvb_attach(stb6000_attach, d->fe_adap[0].fe, 0x61, &d->dev->i2c_adap))\n\t\treturn -EIO;\n\n\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\n\tdw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);\n\n\tinfo(\"Attached stv0288+stb6000!\");\n\n\treturn 0;\n\n}\n\nstatic int ds3000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tstruct dw2102_state *st = d->dev->priv;\n\tu8 obuf[] = {7, 1};\n\n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &s660_ds3000_config,\n\t\t\t&d->dev->i2c_adap);\n\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\tdvb_attach(ts2020_attach, d->fe_adap[0].fe, &s660_ts2020_config,\n\t\t&d->dev->i2c_adap);\n\n\tst->old_set_voltage = d->fe_adap[0].fe->ops.set_voltage;\n\td->fe_adap[0].fe->ops.set_voltage = s660_set_voltage;\n\n\tdw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);\n\n\tinfo(\"Attached ds3000+ts2020!\");\n\n\treturn 0;\n}\n\nstatic int prof_7500_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[] = {7, 1};\n\n\td->fe_adap[0].fe = dvb_attach(stv0900_attach, &prof_7500_stv0900_config,\n\t\t\t\t\t&d->dev->i2c_adap, 0);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\n\tdw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);\n\n\tinfo(\"Attached STV0900+STB6100A!\");\n\n\treturn 0;\n}\n\nstatic int su3000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached DS3000/TS2020!\");\n\t\treturn 0;\n\t}\n\n\tinfo(\"Failed to attach DS3000/TS2020!\");\n\treturn -EIO;\n}\n\nstatic int t220_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x87, 0 };\n\tu8 ibuf[] = { 0 };\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x86;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 0;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tmsleep(50);\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\td->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,\n\t\t\t\t\t&d->dev->i2c_adap, NULL);\n\tif (d->fe_adap[0].fe != NULL) {\n\t\tif (dvb_attach(tda18271_attach, d->fe_adap[0].fe, 0x60,\n\t\t\t\t\t&d->dev->i2c_adap, &tda18271_config)) {\n\t\t\tinfo(\"Attached TDA18271HD/CXD2820R!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tinfo(\"Failed to attach TDA18271HD/CXD2820R!\");\n\treturn -EIO;\n}\n\nstatic int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[] = { 0x51 };\n\tu8 ibuf[] = { 0 };\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\td->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached RS2000/TS2020!\");\n\t\treturn 0;\n\t}\n\n\tinfo(\"Failed to attach RS2000/TS2020!\");\n\treturn -EIO;\n}\n\nstatic int tt_s2_4600_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info;\n\tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n\tstruct ts2020_config ts2020_config = {};\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\t/* attach demod */\n\tm88ds3103_pdata.clk = 27000000;\n\tm88ds3103_pdata.i2c_wr_max = 33;\n\tm88ds3103_pdata.ts_mode = M88DS3103_TS_CI;\n\tm88ds3103_pdata.ts_clk = 16000;\n\tm88ds3103_pdata.ts_clk_pol = 0;\n\tm88ds3103_pdata.spec_inv = 0;\n\tm88ds3103_pdata.agc = 0x99;\n\tm88ds3103_pdata.agc_inv = 0;\n\tm88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_ENABLED;\n\tm88ds3103_pdata.envelope_mode = 0;\n\tm88ds3103_pdata.lnb_hv_pol = 1;\n\tm88ds3103_pdata.lnb_en_pol = 0;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"m88ds3103\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x68;\n\tboard_info.platform_data = &m88ds3103_pdata;\n\trequest_module(\"m88ds3103\");\n\tclient = i2c_new_device(&d->i2c_adap, &board_info);\n\tif (client == NULL || client->dev.driver == NULL)\n\t\treturn -ENODEV;\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\treturn -ENODEV;\n\t}\n\tadap->fe_adap[0].fe = m88ds3103_pdata.get_dvb_frontend(client);\n\ti2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);\n\n\tstate->i2c_client_demod = client;\n\n\t/* attach tuner */\n\tts2020_config.fe = adap->fe_adap[0].fe;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"ts2022\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x60;\n\tboard_info.platform_data = &ts2020_config;\n\trequest_module(\"ts2020\");\n\tclient = i2c_new_device(i2c_adapter, &board_info);\n\n\tif (client == NULL || client->dev.driver == NULL) {\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\t/* delegate signal strength measurement to tuner */\n\tadap->fe_adap[0].fe->ops.read_signal_strength =\n\t\t\tadap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;\n\n\tstate->i2c_client_tuner = client;\n\n\t/* hook fe: need to resync the slave fifo when signal locks */\n\tstate->fe_read_status = adap->fe_adap[0].fe->ops.read_status;\n\tadap->fe_adap[0].fe->ops.read_status = tt_s2_4600_read_status;\n\n\tstate->last_lock = 0;\n\n\treturn 0;\n}\n\nstatic int dw2102_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x60,\n\t\t&adap->dev->i2c_adap, DVB_PLL_OPERA1);\n\treturn 0;\n}\n\nstatic int dw3101_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x60,\n\t\t&adap->dev->i2c_adap, DVB_PLL_TUA6034);\n\n\treturn 0;\n}\n\nstatic int dw2102_rc_query(struct dvb_usb_device *d)\n{\n\tu8 key[2];\n\tstruct i2c_msg msg = {\n\t\t.addr = DW2102_RC_QUERY,\n\t\t.flags = I2C_M_RD,\n\t\t.buf = key,\n\t\t.len = 2\n\t};\n\n\tif (d->props.i2c_algo->master_xfer(&d->i2c_adap, &msg, 1) == 1) {\n\t\tif (msg.buf[0] != 0xff) {\n\t\t\tdeb_rc(\"%s: rc code: %x, %x\\n\",\n\t\t\t\t\t__func__, key[0], key[1]);\n\t\t\trc_keydown(d->rc_dev, RC_TYPE_UNKNOWN, key[0], 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int prof_rc_query(struct dvb_usb_device *d)\n{\n\tu8 key[2];\n\tstruct i2c_msg msg = {\n\t\t.addr = DW2102_RC_QUERY,\n\t\t.flags = I2C_M_RD,\n\t\t.buf = key,\n\t\t.len = 2\n\t};\n\n\tif (d->props.i2c_algo->master_xfer(&d->i2c_adap, &msg, 1) == 1) {\n\t\tif (msg.buf[0] != 0xff) {\n\t\t\tdeb_rc(\"%s: rc code: %x, %x\\n\",\n\t\t\t\t\t__func__, key[0], key[1]);\n\t\t\trc_keydown(d->rc_dev, RC_TYPE_UNKNOWN, key[0]^0xff, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int su3000_rc_query(struct dvb_usb_device *d)\n{\n\tu8 key[2];\n\tstruct i2c_msg msg = {\n\t\t.addr = DW2102_RC_QUERY,\n\t\t.flags = I2C_M_RD,\n\t\t.buf = key,\n\t\t.len = 2\n\t};\n\n\tif (d->props.i2c_algo->master_xfer(&d->i2c_adap, &msg, 1) == 1) {\n\t\tif (msg.buf[0] != 0xff) {\n\t\t\tdeb_rc(\"%s: rc code: %x, %x\\n\",\n\t\t\t\t\t__func__, key[0], key[1]);\n\t\t\trc_keydown(d->rc_dev, RC_TYPE_RC5,\n\t\t\t\t   RC_SCANCODE_RC5(key[1], key[0]), 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nenum dw2102_table_entry {\n\tCYPRESS_DW2102,\n\tCYPRESS_DW2101,\n\tCYPRESS_DW2104,\n\tTEVII_S650,\n\tTERRATEC_CINERGY_S,\n\tCYPRESS_DW3101,\n\tTEVII_S630,\n\tPROF_1100,\n\tTEVII_S660,\n\tPROF_7500,\n\tGENIATECH_SU3000,\n\tTERRATEC_CINERGY_S2,\n\tTEVII_S480_1,\n\tTEVII_S480_2,\n\tX3M_SPC1400HD,\n\tTEVII_S421,\n\tTEVII_S632,\n\tTERRATEC_CINERGY_S2_R2,\n\tTERRATEC_CINERGY_S2_R3,\n\tTERRATEC_CINERGY_S2_R4,\n\tGOTVIEW_SAT_HD,\n\tGENIATECH_T220,\n\tTECHNOTREND_S2_4600,\n\tTEVII_S482_1,\n\tTEVII_S482_2,\n\tTERRATEC_CINERGY_S2_BOX,\n\tTEVII_S662\n};\n\nstatic struct usb_device_id dw2102_table[] = {\n\t[CYPRESS_DW2102] = {USB_DEVICE(USB_VID_CYPRESS, USB_PID_DW2102)},\n\t[CYPRESS_DW2101] = {USB_DEVICE(USB_VID_CYPRESS, 0x2101)},\n\t[CYPRESS_DW2104] = {USB_DEVICE(USB_VID_CYPRESS, USB_PID_DW2104)},\n\t[TEVII_S650] = {USB_DEVICE(0x9022, USB_PID_TEVII_S650)},\n\t[TERRATEC_CINERGY_S] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S)},\n\t[CYPRESS_DW3101] = {USB_DEVICE(USB_VID_CYPRESS, USB_PID_DW3101)},\n\t[TEVII_S630] = {USB_DEVICE(0x9022, USB_PID_TEVII_S630)},\n\t[PROF_1100] = {USB_DEVICE(0x3011, USB_PID_PROF_1100)},\n\t[TEVII_S660] = {USB_DEVICE(0x9022, USB_PID_TEVII_S660)},\n\t[PROF_7500] = {USB_DEVICE(0x3034, 0x7500)},\n\t[GENIATECH_SU3000] = {USB_DEVICE(0x1f4d, 0x3000)},\n\t[TERRATEC_CINERGY_S2] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R1)},\n\t[TEVII_S480_1] = {USB_DEVICE(0x9022, USB_PID_TEVII_S480_1)},\n\t[TEVII_S480_2] = {USB_DEVICE(0x9022, USB_PID_TEVII_S480_2)},\n\t[X3M_SPC1400HD] = {USB_DEVICE(0x1f4d, 0x3100)},\n\t[TEVII_S421] = {USB_DEVICE(0x9022, USB_PID_TEVII_S421)},\n\t[TEVII_S632] = {USB_DEVICE(0x9022, USB_PID_TEVII_S632)},\n\t[TERRATEC_CINERGY_S2_R2] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R2)},\n\t[TERRATEC_CINERGY_S2_R3] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R3)},\n\t[TERRATEC_CINERGY_S2_R4] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R4)},\n\t[GOTVIEW_SAT_HD] = {USB_DEVICE(0x1FE1, USB_PID_GOTVIEW_SAT_HD)},\n\t[GENIATECH_T220] = {USB_DEVICE(0x1f4d, 0xD220)},\n\t[TECHNOTREND_S2_4600] = {USB_DEVICE(USB_VID_TECHNOTREND,\n\t\tUSB_PID_TECHNOTREND_CONNECT_S2_4600)},\n\t[TEVII_S482_1] = {USB_DEVICE(0x9022, 0xd483)},\n\t[TEVII_S482_2] = {USB_DEVICE(0x9022, 0xd484)},\n\t[TERRATEC_CINERGY_S2_BOX] = {USB_DEVICE(USB_VID_TERRATEC, 0x0105)},\n\t[TEVII_S662] = {USB_DEVICE(0x9022, USB_PID_TEVII_S662)},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, dw2102_table);\n\nstatic int dw2102_load_firmware(struct usb_device *dev,\n\t\t\tconst struct firmware *frmwr)\n{\n\tu8 *b, *p;\n\tint ret = 0, i;\n\tu8 reset;\n\tu8 reset16[] = {0, 0, 0, 0, 0, 0, 0};\n\tconst struct firmware *fw;\n\n\tswitch (le16_to_cpu(dev->descriptor.idProduct)) {\n\tcase 0x2101:\n\t\tret = request_firmware(&fw, DW2101_FIRMWARE, &dev->dev);\n\t\tif (ret != 0) {\n\t\t\terr(err_str, DW2101_FIRMWARE);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfw = frmwr;\n\t\tbreak;\n\t}\n\tinfo(\"start downloading DW210X firmware\");\n\tp = kmalloc(fw->size, GFP_KERNEL);\n\treset = 1;\n\t/*stop the CPU*/\n\tdw210x_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, DW210X_WRITE_MSG);\n\tdw210x_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, DW210X_WRITE_MSG);\n\n\tif (p != NULL) {\n\t\tmemcpy(p, fw->data, fw->size);\n\t\tfor (i = 0; i < fw->size; i += 0x40) {\n\t\t\tb = (u8 *) p + i;\n\t\t\tif (dw210x_op_rw(dev, 0xa0, i, 0, b , 0x40,\n\t\t\t\t\tDW210X_WRITE_MSG) != 0x40) {\n\t\t\t\terr(\"error while transferring firmware\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* restart the CPU */\n\t\treset = 0;\n\t\tif (ret || dw210x_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,\n\t\t\t\t\tDW210X_WRITE_MSG) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tif (ret || dw210x_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,\n\t\t\t\t\tDW210X_WRITE_MSG) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t/* init registers */\n\t\tswitch (le16_to_cpu(dev->descriptor.idProduct)) {\n\t\tcase USB_PID_TEVII_S650:\n\t\t\tdw2104_properties.rc.core.rc_codes = RC_MAP_TEVII_NEC;\n\t\tcase USB_PID_DW2104:\n\t\t\treset = 1;\n\t\t\tdw210x_op_rw(dev, 0xc4, 0x0000, 0, &reset, 1,\n\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t/* break omitted intentionally */\n\t\tcase USB_PID_DW3101:\n\t\t\treset = 0;\n\t\t\tdw210x_op_rw(dev, 0xbf, 0x0040, 0, &reset, 0,\n\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\tcase USB_PID_TERRATEC_CINERGY_S:\n\t\tcase USB_PID_DW2102:\n\t\t\tdw210x_op_rw(dev, 0xbf, 0x0040, 0, &reset, 0,\n\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\tdw210x_op_rw(dev, 0xb9, 0x0000, 0, &reset16[0], 2,\n\t\t\t\t\tDW210X_READ_MSG);\n\t\t\t/* check STV0299 frontend  */\n\t\t\tdw210x_op_rw(dev, 0xb5, 0, 0, &reset16[0], 2,\n\t\t\t\t\tDW210X_READ_MSG);\n\t\t\tif ((reset16[0] == 0xa1) || (reset16[0] == 0x80)) {\n\t\t\t\tdw2102_properties.i2c_algo = &dw2102_i2c_algo;\n\t\t\t\tdw2102_properties.adapter->fe[0].tuner_attach = &dw2102_tuner_attach;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* check STV0288 frontend  */\n\t\t\t\treset16[0] = 0xd0;\n\t\t\t\treset16[1] = 1;\n\t\t\t\treset16[2] = 0;\n\t\t\t\tdw210x_op_rw(dev, 0xc2, 0, 0, &reset16[0], 3,\n\t\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t\tdw210x_op_rw(dev, 0xc3, 0xd1, 0, &reset16[0], 3,\n\t\t\t\t\t\tDW210X_READ_MSG);\n\t\t\t\tif (reset16[2] == 0x11) {\n\t\t\t\t\tdw2102_properties.i2c_algo = &dw2102_earda_i2c_algo;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tcase 0x2101:\n\t\t\tdw210x_op_rw(dev, 0xbc, 0x0030, 0, &reset16[0], 2,\n\t\t\t\t\tDW210X_READ_MSG);\n\t\t\tdw210x_op_rw(dev, 0xba, 0x0000, 0, &reset16[0], 7,\n\t\t\t\t\tDW210X_READ_MSG);\n\t\t\tdw210x_op_rw(dev, 0xba, 0x0000, 0, &reset16[0], 7,\n\t\t\t\t\tDW210X_READ_MSG);\n\t\t\tdw210x_op_rw(dev, 0xb9, 0x0000, 0, &reset16[0], 2,\n\t\t\t\t\tDW210X_READ_MSG);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(100);\n\t\tkfree(p);\n\t}\n\n\tif (le16_to_cpu(dev->descriptor.idProduct) == 0x2101)\n\t\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic struct dvb_usb_device_properties dw2102_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.firmware = DW2102_FIRMWARE,\n\t.no_reconnect = 1,\n\n\t.i2c_algo = &dw2102_serit_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval = 150,\n\t\t.rc_codes = RC_MAP_DM1105_NEC,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_NEC,\n\t\t.rc_query = dw2102_rc_query,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x81,\n\t/* parameter for the MPEG2-data transfer */\n\t.num_adapters = 1,\n\t.download_firmware = dw2102_load_firmware,\n\t.read_mac_address = dw210x_read_mac_address,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach = dw2102_frontend_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n\t.num_device_descs = 3,\n\t.devices = {\n\t\t{\"DVBWorld DVB-S 2102 USB2.0\",\n\t\t\t{&dw2102_table[CYPRESS_DW2102], NULL},\n\t\t\t{NULL},\n\t\t},\n\t\t{\"DVBWorld DVB-S 2101 USB2.0\",\n\t\t\t{&dw2102_table[CYPRESS_DW2101], NULL},\n\t\t\t{NULL},\n\t\t},\n\t\t{\"TerraTec Cinergy S USB\",\n\t\t\t{&dw2102_table[TERRATEC_CINERGY_S], NULL},\n\t\t\t{NULL},\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties dw2104_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.firmware = DW2104_FIRMWARE,\n\t.no_reconnect = 1,\n\n\t.i2c_algo = &dw2104_i2c_algo,\n\t.rc.core = {\n\t\t.rc_interval = 150,\n\t\t.rc_codes = RC_MAP_DM1105_NEC,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_NEC,\n\t\t.rc_query = dw2102_rc_query,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x81,\n\t/* parameter for the MPEG2-data transfer */\n\t.num_adapters = 1,\n\t.download_firmware = dw2102_load_firmware,\n\t.read_mac_address = dw210x_read_mac_address,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach = dw2104_frontend_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n\t.num_device_descs = 2,\n\t.devices = {\n\t\t{ \"DVBWorld DW2104 USB2.0\",\n\t\t\t{&dw2102_table[CYPRESS_DW2104], NULL},\n\t\t\t{NULL},\n\t\t},\n\t\t{ \"TeVii S650 USB2.0\",\n\t\t\t{&dw2102_table[TEVII_S650], NULL},\n\t\t\t{NULL},\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties dw3101_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.firmware = DW3101_FIRMWARE,\n\t.no_reconnect = 1,\n\n\t.i2c_algo = &dw3101_i2c_algo,\n\t.rc.core = {\n\t\t.rc_interval = 150,\n\t\t.rc_codes = RC_MAP_DM1105_NEC,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_NEC,\n\t\t.rc_query = dw2102_rc_query,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x81,\n\t/* parameter for the MPEG2-data transfer */\n\t.num_adapters = 1,\n\t.download_firmware = dw2102_load_firmware,\n\t.read_mac_address = dw210x_read_mac_address,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach = dw3101_frontend_attach,\n\t\t\t.tuner_attach = dw3101_tuner_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{ \"DVBWorld DVB-C 3101 USB2.0\",\n\t\t\t{&dw2102_table[CYPRESS_DW3101], NULL},\n\t\t\t{NULL},\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties s6x0_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.size_of_priv = sizeof(struct dw2102_state),\n\t.firmware = S630_FIRMWARE,\n\t.no_reconnect = 1,\n\n\t.i2c_algo = &s6x0_i2c_algo,\n\t.rc.core = {\n\t\t.rc_interval = 150,\n\t\t.rc_codes = RC_MAP_TEVII_NEC,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_NEC,\n\t\t.rc_query = dw2102_rc_query,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x81,\n\t.num_adapters = 1,\n\t.download_firmware = dw2102_load_firmware,\n\t.read_mac_address = s6x0_read_mac_address,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach = zl100313_frontend_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{\"TeVii S630 USB\",\n\t\t\t{&dw2102_table[TEVII_S630], NULL},\n\t\t\t{NULL},\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties *p1100;\nstatic struct dvb_usb_device_description d1100 = {\n\t\"Prof 1100 USB \",\n\t{&dw2102_table[PROF_1100], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_properties *s660;\nstatic struct dvb_usb_device_description d660 = {\n\t\"TeVii S660 USB\",\n\t{&dw2102_table[TEVII_S660], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_description d480_1 = {\n\t\"TeVii S480.1 USB\",\n\t{&dw2102_table[TEVII_S480_1], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_description d480_2 = {\n\t\"TeVii S480.2 USB\",\n\t{&dw2102_table[TEVII_S480_2], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_properties *p7500;\nstatic struct dvb_usb_device_description d7500 = {\n\t\"Prof 7500 USB DVB-S2\",\n\t{&dw2102_table[PROF_7500], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_properties *s421;\nstatic struct dvb_usb_device_description d421 = {\n\t\"TeVii S421 PCI\",\n\t{&dw2102_table[TEVII_S421], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_description d632 = {\n\t\"TeVii S632 USB\",\n\t{&dw2102_table[TEVII_S632], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_properties su3000_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.size_of_priv = sizeof(struct dw2102_state),\n\t.power_ctrl = su3000_power_ctrl,\n\t.num_adapters = 1,\n\t.identify_state\t= su3000_identify_state,\n\t.i2c_algo = &su3000_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval = 150,\n\t\t.rc_codes = RC_MAP_SU3000,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_RC5,\n\t\t.rc_query = su3000_rc_query,\n\t},\n\n\t.read_mac_address = su3000_read_mac_address,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = su3000_streaming_ctrl,\n\t\t\t.frontend_attach  = su3000_frontend_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}},\n\t\t}\n\t},\n\t.num_device_descs = 6,\n\t.devices = {\n\t\t{ \"SU3000HD DVB-S USB2.0\",\n\t\t\t{ &dw2102_table[GENIATECH_SU3000], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"Terratec Cinergy S2 USB HD\",\n\t\t\t{ &dw2102_table[TERRATEC_CINERGY_S2], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"X3M TV SPC1400HD PCI\",\n\t\t\t{ &dw2102_table[X3M_SPC1400HD], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"Terratec Cinergy S2 USB HD Rev.2\",\n\t\t\t{ &dw2102_table[TERRATEC_CINERGY_S2_R2], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"Terratec Cinergy S2 USB HD Rev.3\",\n\t\t\t{ &dw2102_table[TERRATEC_CINERGY_S2_R3], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"GOTVIEW Satellite HD\",\n\t\t\t{ &dw2102_table[GOTVIEW_SAT_HD], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties t220_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.size_of_priv = sizeof(struct dw2102_state),\n\t.power_ctrl = su3000_power_ctrl,\n\t.num_adapters = 1,\n\t.identify_state\t= su3000_identify_state,\n\t.i2c_algo = &su3000_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval = 150,\n\t\t.rc_codes = RC_MAP_SU3000,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_RC5,\n\t\t.rc_query = su3000_rc_query,\n\t},\n\n\t.read_mac_address = su3000_read_mac_address,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = { {\n\t\t\t.streaming_ctrl   = su3000_streaming_ctrl,\n\t\t\t.frontend_attach  = t220_frontend_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} },\n\t\t}\n\t},\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{ \"Geniatech T220 DVB-T/T2 USB2.0\",\n\t\t\t{ &dw2102_table[GENIATECH_T220], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties tt_s2_4600_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.size_of_priv = sizeof(struct dw2102_state),\n\t.power_ctrl = su3000_power_ctrl,\n\t.num_adapters = 1,\n\t.identify_state\t= su3000_identify_state,\n\t.i2c_algo = &su3000_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval = 250,\n\t\t.rc_codes = RC_MAP_TT_1500,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_RC5,\n\t\t.rc_query = su3000_rc_query,\n\t},\n\n\t.read_mac_address = su3000_read_mac_address,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = su3000_streaming_ctrl,\n\t\t\t.frontend_attach  = tt_s2_4600_frontend_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} },\n\t\t}\n\t},\n\t.num_device_descs = 5,\n\t.devices = {\n\t\t{ \"TechnoTrend TT-connect S2-4600\",\n\t\t\t{ &dw2102_table[TECHNOTREND_S2_4600], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"TeVii S482 (tuner 1)\",\n\t\t\t{ &dw2102_table[TEVII_S482_1], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"TeVii S482 (tuner 2)\",\n\t\t\t{ &dw2102_table[TEVII_S482_2], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"Terratec Cinergy S2 USB BOX\",\n\t\t\t{ &dw2102_table[TERRATEC_CINERGY_S2_BOX], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"TeVii S662\",\n\t\t\t{ &dw2102_table[TEVII_S662], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t}\n};\n\nstatic int dw2102_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tp1100 = kmemdup(&s6x0_properties,\n\t\t\tsizeof(struct dvb_usb_device_properties), GFP_KERNEL);\n\tif (!p1100)\n\t\treturn -ENOMEM;\n\t/* copy default structure */\n\t/* fill only different fields */\n\tp1100->firmware = P1100_FIRMWARE;\n\tp1100->devices[0] = d1100;\n\tp1100->rc.core.rc_query = prof_rc_query;\n\tp1100->rc.core.rc_codes = RC_MAP_TBS_NEC;\n\tp1100->adapter->fe[0].frontend_attach = stv0288_frontend_attach;\n\n\ts660 = kmemdup(&s6x0_properties,\n\t\t       sizeof(struct dvb_usb_device_properties), GFP_KERNEL);\n\tif (!s660) {\n\t\tkfree(p1100);\n\t\treturn -ENOMEM;\n\t}\n\ts660->firmware = S660_FIRMWARE;\n\ts660->num_device_descs = 3;\n\ts660->devices[0] = d660;\n\ts660->devices[1] = d480_1;\n\ts660->devices[2] = d480_2;\n\ts660->adapter->fe[0].frontend_attach = ds3000_frontend_attach;\n\n\tp7500 = kmemdup(&s6x0_properties,\n\t\t\tsizeof(struct dvb_usb_device_properties), GFP_KERNEL);\n\tif (!p7500) {\n\t\tkfree(p1100);\n\t\tkfree(s660);\n\t\treturn -ENOMEM;\n\t}\n\tp7500->firmware = P7500_FIRMWARE;\n\tp7500->devices[0] = d7500;\n\tp7500->rc.core.rc_query = prof_rc_query;\n\tp7500->rc.core.rc_codes = RC_MAP_TBS_NEC;\n\tp7500->adapter->fe[0].frontend_attach = prof_7500_frontend_attach;\n\n\n\ts421 = kmemdup(&su3000_properties,\n\t\t       sizeof(struct dvb_usb_device_properties), GFP_KERNEL);\n\tif (!s421) {\n\t\tkfree(p1100);\n\t\tkfree(s660);\n\t\tkfree(p7500);\n\t\treturn -ENOMEM;\n\t}\n\ts421->num_device_descs = 2;\n\ts421->devices[0] = d421;\n\ts421->devices[1] = d632;\n\ts421->adapter->fe[0].frontend_attach = m88rs2000_frontend_attach;\n\n\tif (0 == dvb_usb_device_init(intf, &dw2102_properties,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &dw2104_properties,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &dw3101_properties,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &s6x0_properties,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, p1100,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, s660,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, p7500,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, s421,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &su3000_properties,\n\t\t\t THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &t220_properties,\n\t\t\t THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &tt_s2_4600_properties,\n\t\t\t THIS_MODULE, NULL, adapter_nr))\n\t\treturn 0;\n\n\treturn -ENODEV;\n}\n\nstatic void dw2102_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tstruct dw2102_state *st = (struct dw2102_state *)d->priv;\n\tstruct i2c_client *client;\n\n\t/* remove I2C client for tuner */\n\tclient = st->i2c_client_tuner;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\t/* remove I2C client for demodulator */\n\tclient = st->i2c_client_demod;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\tdvb_usb_device_exit(intf);\n}\n\nstatic struct usb_driver dw2102_driver = {\n\t.name = \"dw2102\",\n\t.probe = dw2102_probe,\n\t.disconnect = dw2102_disconnect,\n\t.id_table = dw2102_table,\n};\n\nmodule_usb_driver(dw2102_driver);\n\nMODULE_AUTHOR(\"Igor M. Liplianin (c) liplianin@me.by\");\nMODULE_DESCRIPTION(\"Driver for DVBWorld DVB-S 2101, 2102, DVB-S2 2104, DVB-C 3101 USB2.0, TeVii S421, S480, S482, S600, S630, S632, S650, TeVii S660, S662, Prof 1100, 7500 USB2.0, Geniatech SU3000, T220, TechnoTrend S2-4600, Terratec Cinergy S2 devices\");\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(DW2101_FIRMWARE);\nMODULE_FIRMWARE(DW2102_FIRMWARE);\nMODULE_FIRMWARE(DW2104_FIRMWARE);\nMODULE_FIRMWARE(DW3101_FIRMWARE);\nMODULE_FIRMWARE(S630_FIRMWARE);\nMODULE_FIRMWARE(S660_FIRMWARE);\nMODULE_FIRMWARE(P1100_FIRMWARE);\nMODULE_FIRMWARE(P7500_FIRMWARE);\n"], "fixing_code": ["/* DVB USB framework compliant Linux driver for the\n *\tDVBWorld DVB-S 2101, 2102, DVB-S2 2104, DVB-C 3101,\n *\tTeVii S421, S480, S482, S600, S630, S632, S650, S660, S662,\n *\tProf 1100, 7500,\n *\tGeniatech SU3000, T220,\n *\tTechnoTrend S2-4600,\n *\tTerratec Cinergy S2 cards\n * Copyright (C) 2008-2012 Igor M. Liplianin (liplianin@me.by)\n *\n *\tThis program is free software; you can redistribute it and/or modify it\n *\tunder the terms of the GNU General Public License as published by the\n *\tFree Software Foundation, version 2.\n *\n * see Documentation/dvb/README.dvb-usb for more information\n */\n#include \"dvb-usb-ids.h\"\n#include \"dw2102.h\"\n#include \"si21xx.h\"\n#include \"stv0299.h\"\n#include \"z0194a.h\"\n#include \"stv0288.h\"\n#include \"stb6000.h\"\n#include \"eds1547.h\"\n#include \"cx24116.h\"\n#include \"tda1002x.h\"\n#include \"mt312.h\"\n#include \"zl10039.h\"\n#include \"ts2020.h\"\n#include \"ds3000.h\"\n#include \"stv0900.h\"\n#include \"stv6110.h\"\n#include \"stb6100.h\"\n#include \"stb6100_proc.h\"\n#include \"m88rs2000.h\"\n#include \"tda18271.h\"\n#include \"cxd2820r.h\"\n#include \"m88ds3103.h\"\n\n/* Max transfer size done by I2C transfer functions */\n#define MAX_XFER_SIZE  64\n\n\n#define DW210X_READ_MSG 0\n#define DW210X_WRITE_MSG 1\n\n#define REG_1F_SYMBOLRATE_BYTE0 0x1f\n#define REG_20_SYMBOLRATE_BYTE1 0x20\n#define REG_21_SYMBOLRATE_BYTE2 0x21\n/* on my own*/\n#define DW2102_VOLTAGE_CTRL (0x1800)\n#define SU3000_STREAM_CTRL (0x1900)\n#define DW2102_RC_QUERY (0x1a00)\n#define DW2102_LED_CTRL (0x1b00)\n\n#define DW2101_FIRMWARE \"dvb-usb-dw2101.fw\"\n#define DW2102_FIRMWARE \"dvb-usb-dw2102.fw\"\n#define DW2104_FIRMWARE \"dvb-usb-dw2104.fw\"\n#define DW3101_FIRMWARE \"dvb-usb-dw3101.fw\"\n#define S630_FIRMWARE   \"dvb-usb-s630.fw\"\n#define S660_FIRMWARE   \"dvb-usb-s660.fw\"\n#define P1100_FIRMWARE  \"dvb-usb-p1100.fw\"\n#define P7500_FIRMWARE  \"dvb-usb-p7500.fw\"\n\n#define\terr_str \"did not find the firmware file. (%s) \" \\\n\t\t\"Please see linux/Documentation/dvb/ for more details \" \\\n\t\t\"on firmware-problems.\"\n\nstruct dw2102_state {\n\tu8 initialized;\n\tu8 last_lock;\n\tu8 data[MAX_XFER_SIZE + 4];\n\tstruct i2c_client *i2c_client_demod;\n\tstruct i2c_client *i2c_client_tuner;\n\n\t/* fe hook functions*/\n\tint (*old_set_voltage)(struct dvb_frontend *f, enum fe_sec_voltage v);\n\tint (*fe_read_status)(struct dvb_frontend *fe,\n\t\t\t      enum fe_status *status);\n};\n\n/* debug */\nstatic int dvb_usb_dw2102_debug;\nmodule_param_named(debug, dvb_usb_dw2102_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info 2=xfer 4=rc(or-able)).\"\n\t\t\t\t\t\tDVB_USB_DEBUG_STATUS);\n\n/* demod probe */\nstatic int demod_probe = 1;\nmodule_param_named(demod, demod_probe, int, 0644);\nMODULE_PARM_DESC(demod, \"demod to probe (1=cx24116 2=stv0903+stv6110 4=stv0903+stb6100(or-able)).\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int dw210x_op_rw(struct usb_device *dev, u8 request, u16 value,\n\t\t\tu16 index, u8 * data, u16 len, int flags)\n{\n\tint ret;\n\tu8 *u8buf;\n\tunsigned int pipe = (flags == DW210X_READ_MSG) ?\n\t\t\t\tusb_rcvctrlpipe(dev, 0) : usb_sndctrlpipe(dev, 0);\n\tu8 request_type = (flags == DW210X_READ_MSG) ? USB_DIR_IN : USB_DIR_OUT;\n\n\tu8buf = kmalloc(len, GFP_KERNEL);\n\tif (!u8buf)\n\t\treturn -ENOMEM;\n\n\n\tif (flags == DW210X_WRITE_MSG)\n\t\tmemcpy(u8buf, data, len);\n\tret = usb_control_msg(dev, pipe, request, request_type | USB_TYPE_VENDOR,\n\t\t\t\tvalue, index , u8buf, len, 2000);\n\n\tif (flags == DW210X_READ_MSG)\n\t\tmemcpy(data, u8buf, len);\n\n\tkfree(u8buf);\n\treturn ret;\n}\n\n/* I2C */\nstatic int dw2102_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint i = 0;\n\tu8 buf6[] = {0x2c, 0x05, 0xc0, 0, 0, 0, 0};\n\tu16 value;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (num) {\n\tcase 2:\n\t\t/* read stv0299 register */\n\t\tvalue = msg[0].buf[0];/* register */\n\t\tfor (i = 0; i < msg[1].len; i++) {\n\t\t\tdw210x_op_rw(d->udev, 0xb5, value + i, 0,\n\t\t\t\t\tbuf6, 2, DW210X_READ_MSG);\n\t\t\tmsg[1].buf[i] = buf6[0];\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase 0x68:\n\t\t\t/* write to stv0299 register */\n\t\t\tbuf6[0] = 0x2a;\n\t\t\tbuf6[1] = msg[0].buf[0];\n\t\t\tbuf6[2] = msg[0].buf[1];\n\t\t\tdw210x_op_rw(d->udev, 0xb2, 0, 0,\n\t\t\t\t\tbuf6, 3, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\tcase 0x60:\n\t\t\tif (msg[0].flags == 0) {\n\t\t\t/* write to tuner pll */\n\t\t\t\tbuf6[0] = 0x2c;\n\t\t\t\tbuf6[1] = 5;\n\t\t\t\tbuf6[2] = 0xc0;\n\t\t\t\tbuf6[3] = msg[0].buf[0];\n\t\t\t\tbuf6[4] = msg[0].buf[1];\n\t\t\t\tbuf6[5] = msg[0].buf[2];\n\t\t\t\tbuf6[6] = msg[0].buf[3];\n\t\t\t\tdw210x_op_rw(d->udev, 0xb2, 0, 0,\n\t\t\t\t\t\tbuf6, 7, DW210X_WRITE_MSG);\n\t\t\t} else {\n\t\t\t/* read from tuner */\n\t\t\t\tdw210x_op_rw(d->udev, 0xb5, 0, 0,\n\t\t\t\t\t\tbuf6, 1, DW210X_READ_MSG);\n\t\t\t\tmsg[0].buf[0] = buf6[0];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase (DW2102_RC_QUERY):\n\t\t\tdw210x_op_rw(d->udev, 0xb8, 0, 0,\n\t\t\t\t\tbuf6, 2, DW210X_READ_MSG);\n\t\t\tmsg[0].buf[0] = buf6[0];\n\t\t\tmsg[0].buf[1] = buf6[1];\n\t\t\tbreak;\n\t\tcase (DW2102_VOLTAGE_CTRL):\n\t\t\tbuf6[0] = 0x30;\n\t\t\tbuf6[1] = msg[0].buf[0];\n\t\t\tdw210x_op_rw(d->udev, 0xb2, 0, 0,\n\t\t\t\t\tbuf6, 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn num;\n}\n\nstatic int dw2102_serit_i2c_transfer(struct i2c_adapter *adap,\n\t\t\t\t\t\tstruct i2c_msg msg[], int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tu8 buf6[] = {0, 0, 0, 0, 0, 0, 0};\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (num) {\n\tcase 2:\n\t\t/* read si2109 register by number */\n\t\tbuf6[0] = msg[0].addr << 1;\n\t\tbuf6[1] = msg[0].len;\n\t\tbuf6[2] = msg[0].buf[0];\n\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\tbuf6, msg[0].len + 2, DW210X_WRITE_MSG);\n\t\t/* read si2109 register */\n\t\tdw210x_op_rw(d->udev, 0xc3, 0xd0, 0,\n\t\t\t\tbuf6, msg[1].len + 2, DW210X_READ_MSG);\n\t\tmemcpy(msg[1].buf, buf6 + 2, msg[1].len);\n\n\t\tbreak;\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase 0x68:\n\t\t\t/* write to si2109 register */\n\t\t\tbuf6[0] = msg[0].addr << 1;\n\t\t\tbuf6[1] = msg[0].len;\n\t\t\tmemcpy(buf6 + 2, msg[0].buf, msg[0].len);\n\t\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0, buf6,\n\t\t\t\t\tmsg[0].len + 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\tcase(DW2102_RC_QUERY):\n\t\t\tdw210x_op_rw(d->udev, 0xb8, 0, 0,\n\t\t\t\t\tbuf6, 2, DW210X_READ_MSG);\n\t\t\tmsg[0].buf[0] = buf6[0];\n\t\t\tmsg[0].buf[1] = buf6[1];\n\t\t\tbreak;\n\t\tcase(DW2102_VOLTAGE_CTRL):\n\t\t\tbuf6[0] = 0x30;\n\t\t\tbuf6[1] = msg[0].buf[0];\n\t\t\tdw210x_op_rw(d->udev, 0xb2, 0, 0,\n\t\t\t\t\tbuf6, 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn num;\n}\n\nstatic int dw2102_earda_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[], int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint ret;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (num) {\n\tcase 2: {\n\t\t/* read */\n\t\t/* first write first register number */\n\t\tu8 ibuf[MAX_XFER_SIZE], obuf[3];\n\n\t\tif (2 + msg[1].len > sizeof(ibuf)) {\n\t\t\twarn(\"i2c rd: len=%d is too big!\\n\",\n\t\t\t     msg[1].len);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tobuf[0] = msg[0].addr << 1;\n\t\tobuf[1] = msg[0].len;\n\t\tobuf[2] = msg[0].buf[0];\n\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\tobuf, msg[0].len + 2, DW210X_WRITE_MSG);\n\t\t/* second read registers */\n\t\tdw210x_op_rw(d->udev, 0xc3, 0xd1 , 0,\n\t\t\t\tibuf, msg[1].len + 2, DW210X_READ_MSG);\n\t\tmemcpy(msg[1].buf, ibuf + 2, msg[1].len);\n\n\t\tbreak;\n\t}\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase 0x68: {\n\t\t\t/* write to register */\n\t\t\tu8 obuf[MAX_XFER_SIZE];\n\n\t\t\tif (2 + msg[0].len > sizeof(obuf)) {\n\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t     msg[1].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tobuf[0] = msg[0].addr << 1;\n\t\t\tobuf[1] = msg[0].len;\n\t\t\tmemcpy(obuf + 2, msg[0].buf, msg[0].len);\n\t\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\t\tobuf, msg[0].len + 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x61: {\n\t\t\t/* write to tuner */\n\t\t\tu8 obuf[MAX_XFER_SIZE];\n\n\t\t\tif (2 + msg[0].len > sizeof(obuf)) {\n\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t     msg[1].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tobuf[0] = msg[0].addr << 1;\n\t\t\tobuf[1] = msg[0].len;\n\t\t\tmemcpy(obuf + 2, msg[0].buf, msg[0].len);\n\t\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\t\tobuf, msg[0].len + 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\tcase(DW2102_RC_QUERY): {\n\t\t\tu8 ibuf[2];\n\t\t\tdw210x_op_rw(d->udev, 0xb8, 0, 0,\n\t\t\t\t\tibuf, 2, DW210X_READ_MSG);\n\t\t\tmemcpy(msg[0].buf, ibuf , 2);\n\t\t\tbreak;\n\t\t}\n\t\tcase(DW2102_VOLTAGE_CTRL): {\n\t\t\tu8 obuf[2];\n\t\t\tobuf[0] = 0x30;\n\t\t\tobuf[1] = msg[0].buf[0];\n\t\t\tdw210x_op_rw(d->udev, 0xb2, 0, 0,\n\t\t\t\t\tobuf, 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tret = num;\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic int dw2104_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[], int num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint len, i, j, ret;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (j = 0; j < num; j++) {\n\t\tswitch (msg[j].addr) {\n\t\tcase(DW2102_RC_QUERY): {\n\t\t\tu8 ibuf[2];\n\t\t\tdw210x_op_rw(d->udev, 0xb8, 0, 0,\n\t\t\t\t\tibuf, 2, DW210X_READ_MSG);\n\t\t\tmemcpy(msg[j].buf, ibuf , 2);\n\t\t\tbreak;\n\t\t}\n\t\tcase(DW2102_VOLTAGE_CTRL): {\n\t\t\tu8 obuf[2];\n\t\t\tobuf[0] = 0x30;\n\t\t\tobuf[1] = msg[j].buf[0];\n\t\t\tdw210x_op_rw(d->udev, 0xb2, 0, 0,\n\t\t\t\t\tobuf, 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\t/*case 0x55: cx24116\n\t\tcase 0x6a: stv0903\n\t\tcase 0x68: ds3000, stv0903\n\t\tcase 0x60: ts2020, stv6110, stb6100 */\n\t\tdefault: {\n\t\t\tif (msg[j].flags == I2C_M_RD) {\n\t\t\t\t/* read registers */\n\t\t\t\tu8  ibuf[MAX_XFER_SIZE];\n\n\t\t\t\tif (2 + msg[j].len > sizeof(ibuf)) {\n\t\t\t\t\twarn(\"i2c rd: len=%d is too big!\\n\",\n\t\t\t\t\t     msg[j].len);\n\t\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\n\t\t\t\tdw210x_op_rw(d->udev, 0xc3,\n\t\t\t\t\t\t(msg[j].addr << 1) + 1, 0,\n\t\t\t\t\t\tibuf, msg[j].len + 2,\n\t\t\t\t\t\tDW210X_READ_MSG);\n\t\t\t\tmemcpy(msg[j].buf, ibuf + 2, msg[j].len);\n\t\t\t\tmdelay(10);\n\t\t\t} else if (((msg[j].buf[0] == 0xb0) &&\n\t\t\t\t\t\t(msg[j].addr == 0x68)) ||\n\t\t\t\t\t\t((msg[j].buf[0] == 0xf7) &&\n\t\t\t\t\t\t(msg[j].addr == 0x55))) {\n\t\t\t\t/* write firmware */\n\t\t\t\tu8 obuf[19];\n\t\t\t\tobuf[0] = msg[j].addr << 1;\n\t\t\t\tobuf[1] = (msg[j].len > 15 ? 17 : msg[j].len);\n\t\t\t\tobuf[2] = msg[j].buf[0];\n\t\t\t\tlen = msg[j].len - 1;\n\t\t\t\ti = 1;\n\t\t\t\tdo {\n\t\t\t\t\tmemcpy(obuf + 3, msg[j].buf + i,\n\t\t\t\t\t\t\t(len > 16 ? 16 : len));\n\t\t\t\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\t\t\tobuf, (len > 16 ? 16 : len) + 3,\n\t\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t\t\ti += 16;\n\t\t\t\t\tlen -= 16;\n\t\t\t\t} while (len > 0);\n\t\t\t} else {\n\t\t\t\t/* write registers */\n\t\t\t\tu8 obuf[MAX_XFER_SIZE];\n\n\t\t\t\tif (2 + msg[j].len > sizeof(obuf)) {\n\t\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t\t     msg[j].len);\n\t\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\n\t\t\t\tobuf[0] = msg[j].addr << 1;\n\t\t\t\tobuf[1] = msg[j].len;\n\t\t\t\tmemcpy(obuf + 2, msg[j].buf, msg[j].len);\n\t\t\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\t\t\tobuf, msg[j].len + 2,\n\t\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\n\t}\n\tret = num;\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic int dw3101_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t\t\t\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint ret;\n\tint i;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (num) {\n\tcase 2: {\n\t\t/* read */\n\t\t/* first write first register number */\n\t\tu8 ibuf[MAX_XFER_SIZE], obuf[3];\n\n\t\tif (2 + msg[1].len > sizeof(ibuf)) {\n\t\t\twarn(\"i2c rd: len=%d is too big!\\n\",\n\t\t\t     msg[1].len);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto unlock;\n\t\t}\n\t\tobuf[0] = msg[0].addr << 1;\n\t\tobuf[1] = msg[0].len;\n\t\tobuf[2] = msg[0].buf[0];\n\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\tobuf, msg[0].len + 2, DW210X_WRITE_MSG);\n\t\t/* second read registers */\n\t\tdw210x_op_rw(d->udev, 0xc3, 0x19 , 0,\n\t\t\t\tibuf, msg[1].len + 2, DW210X_READ_MSG);\n\t\tmemcpy(msg[1].buf, ibuf + 2, msg[1].len);\n\n\t\tbreak;\n\t}\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase 0x60:\n\t\tcase 0x0c: {\n\t\t\t/* write to register */\n\t\t\tu8 obuf[MAX_XFER_SIZE];\n\n\t\t\tif (2 + msg[0].len > sizeof(obuf)) {\n\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t     msg[0].len);\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tobuf[0] = msg[0].addr << 1;\n\t\t\tobuf[1] = msg[0].len;\n\t\t\tmemcpy(obuf + 2, msg[0].buf, msg[0].len);\n\t\t\tdw210x_op_rw(d->udev, 0xc2, 0, 0,\n\t\t\t\t\tobuf, msg[0].len + 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\tcase(DW2102_RC_QUERY): {\n\t\t\tu8 ibuf[2];\n\t\t\tdw210x_op_rw(d->udev, 0xb8, 0, 0,\n\t\t\t\t\tibuf, 2, DW210X_READ_MSG);\n\t\t\tmemcpy(msg[0].buf, ibuf , 2);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tdeb_xfer(\"%02x:%02x: %s \", i, msg[i].addr,\n\t\t\t\tmsg[i].flags == 0 ? \">>>\" : \"<<<\");\n\t\tdebug_dump(msg[i].buf, msg[i].len, deb_xfer);\n\t}\n\tret = num;\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic int s6x0_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t\t\t\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct usb_device *udev;\n\tint len, i, j, ret;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tudev = d->udev;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tfor (j = 0; j < num; j++) {\n\t\tswitch (msg[j].addr) {\n\t\tcase (DW2102_RC_QUERY): {\n\t\t\tu8 ibuf[5];\n\t\t\tdw210x_op_rw(d->udev, 0xb8, 0, 0,\n\t\t\t\t\tibuf, 5, DW210X_READ_MSG);\n\t\t\tmemcpy(msg[j].buf, ibuf + 3, 2);\n\t\t\tbreak;\n\t\t}\n\t\tcase (DW2102_VOLTAGE_CTRL): {\n\t\t\tu8 obuf[2];\n\n\t\t\tobuf[0] = 1;\n\t\t\tobuf[1] = msg[j].buf[1];/* off-on */\n\t\t\tdw210x_op_rw(d->udev, 0x8a, 0, 0,\n\t\t\t\t\tobuf, 2, DW210X_WRITE_MSG);\n\t\t\tobuf[0] = 3;\n\t\t\tobuf[1] = msg[j].buf[0];/* 13v-18v */\n\t\t\tdw210x_op_rw(d->udev, 0x8a, 0, 0,\n\t\t\t\t\tobuf, 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\tcase (DW2102_LED_CTRL): {\n\t\t\tu8 obuf[2];\n\n\t\t\tobuf[0] = 5;\n\t\t\tobuf[1] = msg[j].buf[0];\n\t\t\tdw210x_op_rw(d->udev, 0x8a, 0, 0,\n\t\t\t\t\tobuf, 2, DW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\t}\n\t\t/*case 0x55: cx24116\n\t\tcase 0x6a: stv0903\n\t\tcase 0x68: ds3000, stv0903, rs2000\n\t\tcase 0x60: ts2020, stv6110, stb6100\n\t\tcase 0xa0: eeprom */\n\t\tdefault: {\n\t\t\tif (msg[j].flags == I2C_M_RD) {\n\t\t\t\t/* read registers */\n\t\t\t\tu8 ibuf[MAX_XFER_SIZE];\n\n\t\t\t\tif (msg[j].len > sizeof(ibuf)) {\n\t\t\t\t\twarn(\"i2c rd: len=%d is too big!\\n\",\n\t\t\t\t\t     msg[j].len);\n\t\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\n\t\t\t\tdw210x_op_rw(d->udev, 0x91, 0, 0,\n\t\t\t\t\t\tibuf, msg[j].len,\n\t\t\t\t\t\tDW210X_READ_MSG);\n\t\t\t\tmemcpy(msg[j].buf, ibuf, msg[j].len);\n\t\t\t\tbreak;\n\t\t\t} else if ((msg[j].buf[0] == 0xb0) &&\n\t\t\t\t\t\t(msg[j].addr == 0x68)) {\n\t\t\t\t/* write firmware */\n\t\t\t\tu8 obuf[19];\n\t\t\t\tobuf[0] = (msg[j].len > 16 ?\n\t\t\t\t\t\t18 : msg[j].len + 1);\n\t\t\t\tobuf[1] = msg[j].addr << 1;\n\t\t\t\tobuf[2] = msg[j].buf[0];\n\t\t\t\tlen = msg[j].len - 1;\n\t\t\t\ti = 1;\n\t\t\t\tdo {\n\t\t\t\t\tmemcpy(obuf + 3, msg[j].buf + i,\n\t\t\t\t\t\t\t(len > 16 ? 16 : len));\n\t\t\t\t\tdw210x_op_rw(d->udev, 0x80, 0, 0,\n\t\t\t\t\t\tobuf, (len > 16 ? 16 : len) + 3,\n\t\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t\t\ti += 16;\n\t\t\t\t\tlen -= 16;\n\t\t\t\t} while (len > 0);\n\t\t\t} else if (j < (num - 1)) {\n\t\t\t\t/* write register addr before read */\n\t\t\t\tu8 obuf[MAX_XFER_SIZE];\n\n\t\t\t\tif (2 + msg[j].len > sizeof(obuf)) {\n\t\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t\t     msg[j].len);\n\t\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\n\t\t\t\tobuf[0] = msg[j + 1].len;\n\t\t\t\tobuf[1] = (msg[j].addr << 1);\n\t\t\t\tmemcpy(obuf + 2, msg[j].buf, msg[j].len);\n\t\t\t\tdw210x_op_rw(d->udev,\n\t\t\t\t\t\tle16_to_cpu(udev->descriptor.idProduct) ==\n\t\t\t\t\t\t0x7500 ? 0x92 : 0x90, 0, 0,\n\t\t\t\t\t\tobuf, msg[j].len + 2,\n\t\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* write registers */\n\t\t\t\tu8 obuf[MAX_XFER_SIZE];\n\n\t\t\t\tif (2 + msg[j].len > sizeof(obuf)) {\n\t\t\t\t\twarn(\"i2c wr: len=%d is too big!\\n\",\n\t\t\t\t\t     msg[j].len);\n\t\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\t\t\t\tobuf[0] = msg[j].len + 1;\n\t\t\t\tobuf[1] = (msg[j].addr << 1);\n\t\t\t\tmemcpy(obuf + 2, msg[j].buf, msg[j].len);\n\t\t\t\tdw210x_op_rw(d->udev, 0x80, 0, 0,\n\t\t\t\t\t\tobuf, msg[j].len + 2,\n\t\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\tret = num;\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t\t\t\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct dw2102_state *state;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\n\tstate = d->priv;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\tif (mutex_lock_interruptible(&d->data_mutex) < 0) {\n\t\tmutex_unlock(&d->i2c_mutex);\n\t\treturn -EAGAIN;\n\t}\n\n\tswitch (num) {\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase SU3000_STREAM_CTRL:\n\t\t\tstate->data[0] = msg[0].buf[0] + 0x36;\n\t\t\tstate->data[1] = 3;\n\t\t\tstate->data[2] = 0;\n\t\t\tif (dvb_usb_generic_rw(d, state->data, 3,\n\t\t\t\t\tstate->data, 0, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tbreak;\n\t\tcase DW2102_RC_QUERY:\n\t\t\tstate->data[0] = 0x10;\n\t\t\tif (dvb_usb_generic_rw(d, state->data, 1,\n\t\t\t\t\tstate->data, 2, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tmsg[0].buf[1] = state->data[0];\n\t\t\tmsg[0].buf[0] = state->data[1];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* always i2c write*/\n\t\t\tstate->data[0] = 0x08;\n\t\t\tstate->data[1] = msg[0].addr;\n\t\t\tstate->data[2] = msg[0].len;\n\n\t\t\tmemcpy(&state->data[3], msg[0].buf, msg[0].len);\n\n\t\t\tif (dvb_usb_generic_rw(d, state->data, msg[0].len + 3,\n\t\t\t\t\t\tstate->data, 1, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t/* always i2c read */\n\t\tstate->data[0] = 0x09;\n\t\tstate->data[1] = msg[0].len;\n\t\tstate->data[2] = msg[1].len;\n\t\tstate->data[3] = msg[0].addr;\n\t\tmemcpy(&state->data[4], msg[0].buf, msg[0].len);\n\n\t\tif (dvb_usb_generic_rw(d, state->data, msg[0].len + 4,\n\t\t\t\t\tstate->data, msg[1].len + 1, 0) < 0)\n\t\t\terr(\"i2c transfer failed.\");\n\n\t\tmemcpy(msg[1].buf, &state->data[1], msg[1].len);\n\t\tbreak;\n\tdefault:\n\t\twarn(\"more than 2 i2c messages at a time is not handled yet.\");\n\t\tbreak;\n\t}\n\tmutex_unlock(&d->data_mutex);\n\tmutex_unlock(&d->i2c_mutex);\n\treturn num;\n}\n\nstatic u32 dw210x_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm dw2102_i2c_algo = {\n\t.master_xfer = dw2102_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic struct i2c_algorithm dw2102_serit_i2c_algo = {\n\t.master_xfer = dw2102_serit_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic struct i2c_algorithm dw2102_earda_i2c_algo = {\n\t.master_xfer = dw2102_earda_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic struct i2c_algorithm dw2104_i2c_algo = {\n\t.master_xfer = dw2104_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic struct i2c_algorithm dw3101_i2c_algo = {\n\t.master_xfer = dw3101_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic struct i2c_algorithm s6x0_i2c_algo = {\n\t.master_xfer = s6x0_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic struct i2c_algorithm su3000_i2c_algo = {\n\t.master_xfer = su3000_i2c_transfer,\n\t.functionality = dw210x_i2c_func,\n};\n\nstatic int dw210x_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\n{\n\tint i;\n\tu8 ibuf[] = {0, 0};\n\tu8 eeprom[256], eepromline[16];\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (dw210x_op_rw(d->udev, 0xb6, 0xa0 , i, ibuf, 2, DW210X_READ_MSG) < 0) {\n\t\t\terr(\"read eeprom failed.\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\teepromline[i%16] = ibuf[0];\n\t\t\teeprom[i] = ibuf[0];\n\t\t}\n\t\tif ((i % 16) == 15) {\n\t\t\tdeb_xfer(\"%02x: \", i - 15);\n\t\t\tdebug_dump(eepromline, 16, deb_xfer);\n\t\t}\n\t}\n\n\tmemcpy(mac, eeprom + 8, 6);\n\treturn 0;\n};\n\nstatic int s6x0_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\n{\n\tint i, ret;\n\tu8 ibuf[] = { 0 }, obuf[] = { 0 };\n\tu8 eeprom[256], eepromline[16];\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = 0xa0 >> 1,\n\t\t\t.flags = 0,\n\t\t\t.buf = obuf,\n\t\t\t.len = 1,\n\t\t}, {\n\t\t\t.addr = 0xa0 >> 1,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = ibuf,\n\t\t\t.len = 1,\n\t\t}\n\t};\n\n\tfor (i = 0; i < 256; i++) {\n\t\tobuf[0] = i;\n\t\tret = s6x0_i2c_transfer(&d->i2c_adap, msg, 2);\n\t\tif (ret != 2) {\n\t\t\terr(\"read eeprom failed.\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\teepromline[i % 16] = ibuf[0];\n\t\t\teeprom[i] = ibuf[0];\n\t\t}\n\n\t\tif ((i % 16) == 15) {\n\t\t\tdeb_xfer(\"%02x: \", i - 15);\n\t\t\tdebug_dump(eepromline, 16, deb_xfer);\n\t\t}\n\t}\n\n\tmemcpy(mac, eeprom + 16, 6);\n\treturn 0;\n};\n\nstatic int su3000_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\n{\n\tstatic u8 command_start[] = {0x00};\n\tstatic u8 command_stop[] = {0x01};\n\tstruct i2c_msg msg = {\n\t\t.addr = SU3000_STREAM_CTRL,\n\t\t.flags = 0,\n\t\t.buf = onoff ? command_start : command_stop,\n\t\t.len = 1\n\t};\n\n\ti2c_transfer(&adap->dev->i2c_adap, &msg, 1);\n\n\treturn 0;\n}\n\nstatic int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tint ret = 0;\n\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\n\tif (i && !state->initialized) {\n\t\tmutex_lock(&d->data_mutex);\n\n\t\tstate->data[0] = 0xde;\n\t\tstate->data[1] = 0;\n\n\t\tstate->initialized = 1;\n\t\t/* reset board */\n\t\tret = dvb_usb_generic_rw(d, state->data, 2, NULL, 0, 0);\n\t\tmutex_unlock(&d->data_mutex);\n\t}\n\n\treturn ret;\n}\n\nstatic int su3000_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\n{\n\tint i;\n\tu8 obuf[] = { 0x1f, 0xf0 };\n\tu8 ibuf[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = 0x51,\n\t\t\t.flags = 0,\n\t\t\t.buf = obuf,\n\t\t\t.len = 2,\n\t\t}, {\n\t\t\t.addr = 0x51,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = ibuf,\n\t\t\t.len = 1,\n\n\t\t}\n\t};\n\n\tfor (i = 0; i < 6; i++) {\n\t\tobuf[1] = 0xf0 + i;\n\t\tif (i2c_transfer(&d->i2c_adap, msg, 2) != 2)\n\t\t\tbreak;\n\t\telse\n\t\t\tmac[i] = ibuf[0];\n\t}\n\n\treturn 0;\n}\n\nstatic int su3000_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tinfo(\"%s\", __func__);\n\n\t*cold = 0;\n\treturn 0;\n}\n\nstatic int dw210x_set_voltage(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_voltage voltage)\n{\n\tstatic u8 command_13v[] = {0x00, 0x01};\n\tstatic u8 command_18v[] = {0x01, 0x01};\n\tstatic u8 command_off[] = {0x00, 0x00};\n\tstruct i2c_msg msg = {\n\t\t.addr = DW2102_VOLTAGE_CTRL,\n\t\t.flags = 0,\n\t\t.buf = command_off,\n\t\t.len = 2,\n\t};\n\n\tstruct dvb_usb_adapter *udev_adap =\n\t\t(struct dvb_usb_adapter *)(fe->dvb->priv);\n\tif (voltage == SEC_VOLTAGE_18)\n\t\tmsg.buf = command_18v;\n\telse if (voltage == SEC_VOLTAGE_13)\n\t\tmsg.buf = command_13v;\n\n\ti2c_transfer(&udev_adap->dev->i2c_adap, &msg, 1);\n\n\treturn 0;\n}\n\nstatic int s660_set_voltage(struct dvb_frontend *fe,\n\t\t\t    enum fe_sec_voltage voltage)\n{\n\tstruct dvb_usb_adapter *d =\n\t\t(struct dvb_usb_adapter *)(fe->dvb->priv);\n\tstruct dw2102_state *st = (struct dw2102_state *)d->dev->priv;\n\n\tdw210x_set_voltage(fe, voltage);\n\tif (st->old_set_voltage)\n\t\tst->old_set_voltage(fe, voltage);\n\n\treturn 0;\n}\n\nstatic void dw210x_led_ctrl(struct dvb_frontend *fe, int offon)\n{\n\tstatic u8 led_off[] = { 0 };\n\tstatic u8 led_on[] = { 1 };\n\tstruct i2c_msg msg = {\n\t\t.addr = DW2102_LED_CTRL,\n\t\t.flags = 0,\n\t\t.buf = led_off,\n\t\t.len = 1\n\t};\n\tstruct dvb_usb_adapter *udev_adap =\n\t\t(struct dvb_usb_adapter *)(fe->dvb->priv);\n\n\tif (offon)\n\t\tmsg.buf = led_on;\n\ti2c_transfer(&udev_adap->dev->i2c_adap, &msg, 1);\n}\n\nstatic int tt_s2_4600_read_status(struct dvb_frontend *fe,\n\t\t\t\t  enum fe_status *status)\n{\n\tstruct dvb_usb_adapter *d =\n\t\t(struct dvb_usb_adapter *)(fe->dvb->priv);\n\tstruct dw2102_state *st = (struct dw2102_state *)d->dev->priv;\n\tint ret;\n\n\tret = st->fe_read_status(fe, status);\n\n\t/* resync slave fifo when signal change from unlock to lock */\n\tif ((*status & FE_HAS_LOCK) && (!st->last_lock))\n\t\tsu3000_streaming_ctrl(d, 1);\n\n\tst->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;\n\treturn ret;\n}\n\nstatic struct stv0299_config sharp_z0194a_config = {\n\t.demod_address = 0x68,\n\t.inittab = sharp_z0194a_inittab,\n\t.mclk = 88000000UL,\n\t.invert = 1,\n\t.skip_reinit = 0,\n\t.lock_output = STV0299_LOCKOUTPUT_1,\n\t.volt13_op0_op1 = STV0299_VOLT13_OP1,\n\t.min_delay_ms = 100,\n\t.set_symbol_rate = sharp_z0194a_set_symbol_rate,\n};\n\nstatic struct cx24116_config dw2104_config = {\n\t.demod_address = 0x55,\n\t.mpg_clk_pos_pol = 0x01,\n};\n\nstatic struct si21xx_config serit_sp1511lhb_config = {\n\t.demod_address = 0x68,\n\t.min_delay_ms = 100,\n\n};\n\nstatic struct tda10023_config dw3101_tda10023_config = {\n\t.demod_address = 0x0c,\n\t.invert = 1,\n};\n\nstatic struct mt312_config zl313_config = {\n\t.demod_address = 0x0e,\n};\n\nstatic struct ds3000_config dw2104_ds3000_config = {\n\t.demod_address = 0x68,\n};\n\nstatic struct ts2020_config dw2104_ts2020_config = {\n\t.tuner_address = 0x60,\n\t.clk_out_div = 1,\n\t.frequency_div = 1060000,\n};\n\nstatic struct ds3000_config s660_ds3000_config = {\n\t.demod_address = 0x68,\n\t.ci_mode = 1,\n\t.set_lock_led = dw210x_led_ctrl,\n};\n\nstatic struct ts2020_config s660_ts2020_config = {\n\t.tuner_address = 0x60,\n\t.clk_out_div = 1,\n\t.frequency_div = 1146000,\n};\n\nstatic struct stv0900_config dw2104a_stv0900_config = {\n\t.demod_address = 0x6a,\n\t.demod_mode = 0,\n\t.xtal = 27000000,\n\t.clkmode = 3,/* 0-CLKI, 2-XTALI, else AUTO */\n\t.diseqc_mode = 2,/* 2/3 PWM */\n\t.tun1_maddress = 0,/* 0x60 */\n\t.tun1_adc = 0,/* 2 Vpp */\n\t.path1_mode = 3,\n};\n\nstatic struct stb6100_config dw2104a_stb6100_config = {\n\t.tuner_address = 0x60,\n\t.refclock = 27000000,\n};\n\nstatic struct stv0900_config dw2104_stv0900_config = {\n\t.demod_address = 0x68,\n\t.demod_mode = 0,\n\t.xtal = 8000000,\n\t.clkmode = 3,\n\t.diseqc_mode = 2,\n\t.tun1_maddress = 0,\n\t.tun1_adc = 1,/* 1 Vpp */\n\t.path1_mode = 3,\n};\n\nstatic struct stv6110_config dw2104_stv6110_config = {\n\t.i2c_address = 0x60,\n\t.mclk = 16000000,\n\t.clk_div = 1,\n};\n\nstatic struct stv0900_config prof_7500_stv0900_config = {\n\t.demod_address = 0x6a,\n\t.demod_mode = 0,\n\t.xtal = 27000000,\n\t.clkmode = 3,/* 0-CLKI, 2-XTALI, else AUTO */\n\t.diseqc_mode = 2,/* 2/3 PWM */\n\t.tun1_maddress = 0,/* 0x60 */\n\t.tun1_adc = 0,/* 2 Vpp */\n\t.path1_mode = 3,\n\t.tun1_type = 3,\n\t.set_lock_led = dw210x_led_ctrl,\n};\n\nstatic struct ds3000_config su3000_ds3000_config = {\n\t.demod_address = 0x68,\n\t.ci_mode = 1,\n\t.set_lock_led = dw210x_led_ctrl,\n};\n\nstatic struct cxd2820r_config cxd2820r_config = {\n\t.i2c_address = 0x6c, /* (0xd8 >> 1) */\n\t.ts_mode = 0x38,\n\t.ts_clock_inv = 1,\n};\n\nstatic struct tda18271_config tda18271_config = {\n\t.output_opt = TDA18271_OUTPUT_LT_OFF,\n\t.gate = TDA18271_GATE_DIGITAL,\n};\n\nstatic u8 m88rs2000_inittab[] = {\n\tDEMOD_WRITE, 0x9a, 0x30,\n\tDEMOD_WRITE, 0x00, 0x01,\n\tWRITE_DELAY, 0x19, 0x00,\n\tDEMOD_WRITE, 0x00, 0x00,\n\tDEMOD_WRITE, 0x9a, 0xb0,\n\tDEMOD_WRITE, 0x81, 0xc1,\n\tDEMOD_WRITE, 0x81, 0x81,\n\tDEMOD_WRITE, 0x86, 0xc6,\n\tDEMOD_WRITE, 0x9a, 0x30,\n\tDEMOD_WRITE, 0xf0, 0x80,\n\tDEMOD_WRITE, 0xf1, 0xbf,\n\tDEMOD_WRITE, 0xb0, 0x45,\n\tDEMOD_WRITE, 0xb2, 0x01,\n\tDEMOD_WRITE, 0x9a, 0xb0,\n\t0xff, 0xaa, 0xff\n};\n\nstatic struct m88rs2000_config s421_m88rs2000_config = {\n\t.demod_addr = 0x68,\n\t.inittab = m88rs2000_inittab,\n};\n\nstatic int dw2104_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tstruct dvb_tuner_ops *tuner_ops = NULL;\n\n\tif (demod_probe & 4) {\n\t\td->fe_adap[0].fe = dvb_attach(stv0900_attach, &dw2104a_stv0900_config,\n\t\t\t\t&d->dev->i2c_adap, 0);\n\t\tif (d->fe_adap[0].fe != NULL) {\n\t\t\tif (dvb_attach(stb6100_attach, d->fe_adap[0].fe,\n\t\t\t\t\t&dw2104a_stb6100_config,\n\t\t\t\t\t&d->dev->i2c_adap)) {\n\t\t\t\ttuner_ops = &d->fe_adap[0].fe->ops.tuner_ops;\n\t\t\t\ttuner_ops->set_frequency = stb6100_set_freq;\n\t\t\t\ttuner_ops->get_frequency = stb6100_get_freq;\n\t\t\t\ttuner_ops->set_bandwidth = stb6100_set_bandw;\n\t\t\t\ttuner_ops->get_bandwidth = stb6100_get_bandw;\n\t\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\t\tinfo(\"Attached STV0900+STB6100!\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (demod_probe & 2) {\n\t\td->fe_adap[0].fe = dvb_attach(stv0900_attach, &dw2104_stv0900_config,\n\t\t\t\t&d->dev->i2c_adap, 0);\n\t\tif (d->fe_adap[0].fe != NULL) {\n\t\t\tif (dvb_attach(stv6110_attach, d->fe_adap[0].fe,\n\t\t\t\t\t&dw2104_stv6110_config,\n\t\t\t\t\t&d->dev->i2c_adap)) {\n\t\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\t\tinfo(\"Attached STV0900+STV6110A!\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (demod_probe & 1) {\n\t\td->fe_adap[0].fe = dvb_attach(cx24116_attach, &dw2104_config,\n\t\t\t\t&d->dev->i2c_adap);\n\t\tif (d->fe_adap[0].fe != NULL) {\n\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\tinfo(\"Attached cx24116!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &dw2104_ds3000_config,\n\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe != NULL) {\n\t\tdvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t&dw2104_ts2020_config, &d->dev->i2c_adap);\n\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\tinfo(\"Attached DS3000!\");\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\nstatic struct dvb_usb_device_properties dw2102_properties;\nstatic struct dvb_usb_device_properties dw2104_properties;\nstatic struct dvb_usb_device_properties s6x0_properties;\n\nstatic int dw2102_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tif (dw2102_properties.i2c_algo == &dw2102_serit_i2c_algo) {\n\t\t/*dw2102_properties.adapter->tuner_attach = NULL;*/\n\t\td->fe_adap[0].fe = dvb_attach(si21xx_attach, &serit_sp1511lhb_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\t\tif (d->fe_adap[0].fe != NULL) {\n\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\tinfo(\"Attached si21xx!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (dw2102_properties.i2c_algo == &dw2102_earda_i2c_algo) {\n\t\td->fe_adap[0].fe = dvb_attach(stv0288_attach, &earda_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\t\tif (d->fe_adap[0].fe != NULL) {\n\t\t\tif (dvb_attach(stb6000_attach, d->fe_adap[0].fe, 0x61,\n\t\t\t\t\t&d->dev->i2c_adap)) {\n\t\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\t\tinfo(\"Attached stv0288!\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dw2102_properties.i2c_algo == &dw2102_i2c_algo) {\n\t\t/*dw2102_properties.adapter->tuner_attach = dw2102_tuner_attach;*/\n\t\td->fe_adap[0].fe = dvb_attach(stv0299_attach, &sharp_z0194a_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\t\tif (d->fe_adap[0].fe != NULL) {\n\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\tinfo(\"Attached stv0299!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EIO;\n}\n\nstatic int dw3101_frontend_attach(struct dvb_usb_adapter *d)\n{\n\td->fe_adap[0].fe = dvb_attach(tda10023_attach, &dw3101_tda10023_config,\n\t\t\t\t&d->dev->i2c_adap, 0x48);\n\tif (d->fe_adap[0].fe != NULL) {\n\t\tinfo(\"Attached tda10023!\");\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}\n\nstatic int zl100313_frontend_attach(struct dvb_usb_adapter *d)\n{\n\td->fe_adap[0].fe = dvb_attach(mt312_attach, &zl313_config,\n\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe != NULL) {\n\t\tif (dvb_attach(zl10039_attach, d->fe_adap[0].fe, 0x60,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\t\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\t\t\tinfo(\"Attached zl100313+zl10039!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EIO;\n}\n\nstatic int stv0288_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[] = {7, 1};\n\n\td->fe_adap[0].fe = dvb_attach(stv0288_attach, &earda_config,\n\t\t\t&d->dev->i2c_adap);\n\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\tif (NULL == dvb_attach(stb6000_attach, d->fe_adap[0].fe, 0x61, &d->dev->i2c_adap))\n\t\treturn -EIO;\n\n\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\n\tdw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);\n\n\tinfo(\"Attached stv0288+stb6000!\");\n\n\treturn 0;\n\n}\n\nstatic int ds3000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tstruct dw2102_state *st = d->dev->priv;\n\tu8 obuf[] = {7, 1};\n\n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &s660_ds3000_config,\n\t\t\t&d->dev->i2c_adap);\n\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\tdvb_attach(ts2020_attach, d->fe_adap[0].fe, &s660_ts2020_config,\n\t\t&d->dev->i2c_adap);\n\n\tst->old_set_voltage = d->fe_adap[0].fe->ops.set_voltage;\n\td->fe_adap[0].fe->ops.set_voltage = s660_set_voltage;\n\n\tdw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);\n\n\tinfo(\"Attached ds3000+ts2020!\");\n\n\treturn 0;\n}\n\nstatic int prof_7500_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[] = {7, 1};\n\n\td->fe_adap[0].fe = dvb_attach(stv0900_attach, &prof_7500_stv0900_config,\n\t\t\t\t\t&d->dev->i2c_adap, 0);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\td->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\n\n\tdw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);\n\n\tinfo(\"Attached STV0900+STB6100A!\");\n\n\treturn 0;\n}\n\nstatic int su3000_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\n\tmutex_lock(&d->data_mutex);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x80;\n\tstate->data[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x02;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x83;\n\tstate->data[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x83;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\tmutex_unlock(&d->data_mutex);\n\n\tadap->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\n\t\t\t\t\t&d->i2c_adap);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\tif (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->i2c_adap)) {\n\t\tinfo(\"Attached DS3000/TS2020!\");\n\t\treturn 0;\n\t}\n\n\tinfo(\"Failed to attach DS3000/TS2020!\");\n\treturn -EIO;\n}\n\nstatic int t220_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\n\tmutex_lock(&d->data_mutex);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x87;\n\tstate->data[2] = 0x0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x86;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x80;\n\tstate->data[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tmsleep(50);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x80;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\tmutex_unlock(&d->data_mutex);\n\n\tadap->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,\n\t\t\t\t\t&d->i2c_adap, NULL);\n\tif (adap->fe_adap[0].fe != NULL) {\n\t\tif (dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0x60,\n\t\t\t\t\t&d->i2c_adap, &tda18271_config)) {\n\t\t\tinfo(\"Attached TDA18271HD/CXD2820R!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tinfo(\"Failed to attach TDA18271HD/CXD2820R!\");\n\treturn -EIO;\n}\n\nstatic int m88rs2000_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\n\tmutex_lock(&d->data_mutex);\n\n\tstate->data[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\tmutex_unlock(&d->data_mutex);\n\n\tadap->fe_adap[0].fe = dvb_attach(m88rs2000_attach,\n\t\t\t\t\t&s421_m88rs2000_config,\n\t\t\t\t\t&d->i2c_adap);\n\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\tif (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->i2c_adap)) {\n\t\tinfo(\"Attached RS2000/TS2020!\");\n\t\treturn 0;\n\t}\n\n\tinfo(\"Failed to attach RS2000/TS2020!\");\n\treturn -EIO;\n}\n\nstatic int tt_s2_4600_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info;\n\tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n\tstruct ts2020_config ts2020_config = {};\n\n\tmutex_lock(&d->data_mutex);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x80;\n\tstate->data[2] = 0x0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x02;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x83;\n\tstate->data[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x83;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\tmutex_unlock(&d->data_mutex);\n\n\t/* attach demod */\n\tm88ds3103_pdata.clk = 27000000;\n\tm88ds3103_pdata.i2c_wr_max = 33;\n\tm88ds3103_pdata.ts_mode = M88DS3103_TS_CI;\n\tm88ds3103_pdata.ts_clk = 16000;\n\tm88ds3103_pdata.ts_clk_pol = 0;\n\tm88ds3103_pdata.spec_inv = 0;\n\tm88ds3103_pdata.agc = 0x99;\n\tm88ds3103_pdata.agc_inv = 0;\n\tm88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_ENABLED;\n\tm88ds3103_pdata.envelope_mode = 0;\n\tm88ds3103_pdata.lnb_hv_pol = 1;\n\tm88ds3103_pdata.lnb_en_pol = 0;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"m88ds3103\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x68;\n\tboard_info.platform_data = &m88ds3103_pdata;\n\trequest_module(\"m88ds3103\");\n\tclient = i2c_new_device(&d->i2c_adap, &board_info);\n\tif (client == NULL || client->dev.driver == NULL)\n\t\treturn -ENODEV;\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\treturn -ENODEV;\n\t}\n\tadap->fe_adap[0].fe = m88ds3103_pdata.get_dvb_frontend(client);\n\ti2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);\n\n\tstate->i2c_client_demod = client;\n\n\t/* attach tuner */\n\tts2020_config.fe = adap->fe_adap[0].fe;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"ts2022\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x60;\n\tboard_info.platform_data = &ts2020_config;\n\trequest_module(\"ts2020\");\n\tclient = i2c_new_device(i2c_adapter, &board_info);\n\n\tif (client == NULL || client->dev.driver == NULL) {\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\t/* delegate signal strength measurement to tuner */\n\tadap->fe_adap[0].fe->ops.read_signal_strength =\n\t\t\tadap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;\n\n\tstate->i2c_client_tuner = client;\n\n\t/* hook fe: need to resync the slave fifo when signal locks */\n\tstate->fe_read_status = adap->fe_adap[0].fe->ops.read_status;\n\tadap->fe_adap[0].fe->ops.read_status = tt_s2_4600_read_status;\n\n\tstate->last_lock = 0;\n\n\treturn 0;\n}\n\nstatic int dw2102_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x60,\n\t\t&adap->dev->i2c_adap, DVB_PLL_OPERA1);\n\treturn 0;\n}\n\nstatic int dw3101_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tdvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x60,\n\t\t&adap->dev->i2c_adap, DVB_PLL_TUA6034);\n\n\treturn 0;\n}\n\nstatic int dw2102_rc_query(struct dvb_usb_device *d)\n{\n\tu8 key[2];\n\tstruct i2c_msg msg = {\n\t\t.addr = DW2102_RC_QUERY,\n\t\t.flags = I2C_M_RD,\n\t\t.buf = key,\n\t\t.len = 2\n\t};\n\n\tif (d->props.i2c_algo->master_xfer(&d->i2c_adap, &msg, 1) == 1) {\n\t\tif (msg.buf[0] != 0xff) {\n\t\t\tdeb_rc(\"%s: rc code: %x, %x\\n\",\n\t\t\t\t\t__func__, key[0], key[1]);\n\t\t\trc_keydown(d->rc_dev, RC_TYPE_UNKNOWN, key[0], 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int prof_rc_query(struct dvb_usb_device *d)\n{\n\tu8 key[2];\n\tstruct i2c_msg msg = {\n\t\t.addr = DW2102_RC_QUERY,\n\t\t.flags = I2C_M_RD,\n\t\t.buf = key,\n\t\t.len = 2\n\t};\n\n\tif (d->props.i2c_algo->master_xfer(&d->i2c_adap, &msg, 1) == 1) {\n\t\tif (msg.buf[0] != 0xff) {\n\t\t\tdeb_rc(\"%s: rc code: %x, %x\\n\",\n\t\t\t\t\t__func__, key[0], key[1]);\n\t\t\trc_keydown(d->rc_dev, RC_TYPE_UNKNOWN, key[0]^0xff, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int su3000_rc_query(struct dvb_usb_device *d)\n{\n\tu8 key[2];\n\tstruct i2c_msg msg = {\n\t\t.addr = DW2102_RC_QUERY,\n\t\t.flags = I2C_M_RD,\n\t\t.buf = key,\n\t\t.len = 2\n\t};\n\n\tif (d->props.i2c_algo->master_xfer(&d->i2c_adap, &msg, 1) == 1) {\n\t\tif (msg.buf[0] != 0xff) {\n\t\t\tdeb_rc(\"%s: rc code: %x, %x\\n\",\n\t\t\t\t\t__func__, key[0], key[1]);\n\t\t\trc_keydown(d->rc_dev, RC_TYPE_RC5,\n\t\t\t\t   RC_SCANCODE_RC5(key[1], key[0]), 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nenum dw2102_table_entry {\n\tCYPRESS_DW2102,\n\tCYPRESS_DW2101,\n\tCYPRESS_DW2104,\n\tTEVII_S650,\n\tTERRATEC_CINERGY_S,\n\tCYPRESS_DW3101,\n\tTEVII_S630,\n\tPROF_1100,\n\tTEVII_S660,\n\tPROF_7500,\n\tGENIATECH_SU3000,\n\tTERRATEC_CINERGY_S2,\n\tTEVII_S480_1,\n\tTEVII_S480_2,\n\tX3M_SPC1400HD,\n\tTEVII_S421,\n\tTEVII_S632,\n\tTERRATEC_CINERGY_S2_R2,\n\tTERRATEC_CINERGY_S2_R3,\n\tTERRATEC_CINERGY_S2_R4,\n\tGOTVIEW_SAT_HD,\n\tGENIATECH_T220,\n\tTECHNOTREND_S2_4600,\n\tTEVII_S482_1,\n\tTEVII_S482_2,\n\tTERRATEC_CINERGY_S2_BOX,\n\tTEVII_S662\n};\n\nstatic struct usb_device_id dw2102_table[] = {\n\t[CYPRESS_DW2102] = {USB_DEVICE(USB_VID_CYPRESS, USB_PID_DW2102)},\n\t[CYPRESS_DW2101] = {USB_DEVICE(USB_VID_CYPRESS, 0x2101)},\n\t[CYPRESS_DW2104] = {USB_DEVICE(USB_VID_CYPRESS, USB_PID_DW2104)},\n\t[TEVII_S650] = {USB_DEVICE(0x9022, USB_PID_TEVII_S650)},\n\t[TERRATEC_CINERGY_S] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S)},\n\t[CYPRESS_DW3101] = {USB_DEVICE(USB_VID_CYPRESS, USB_PID_DW3101)},\n\t[TEVII_S630] = {USB_DEVICE(0x9022, USB_PID_TEVII_S630)},\n\t[PROF_1100] = {USB_DEVICE(0x3011, USB_PID_PROF_1100)},\n\t[TEVII_S660] = {USB_DEVICE(0x9022, USB_PID_TEVII_S660)},\n\t[PROF_7500] = {USB_DEVICE(0x3034, 0x7500)},\n\t[GENIATECH_SU3000] = {USB_DEVICE(0x1f4d, 0x3000)},\n\t[TERRATEC_CINERGY_S2] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R1)},\n\t[TEVII_S480_1] = {USB_DEVICE(0x9022, USB_PID_TEVII_S480_1)},\n\t[TEVII_S480_2] = {USB_DEVICE(0x9022, USB_PID_TEVII_S480_2)},\n\t[X3M_SPC1400HD] = {USB_DEVICE(0x1f4d, 0x3100)},\n\t[TEVII_S421] = {USB_DEVICE(0x9022, USB_PID_TEVII_S421)},\n\t[TEVII_S632] = {USB_DEVICE(0x9022, USB_PID_TEVII_S632)},\n\t[TERRATEC_CINERGY_S2_R2] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R2)},\n\t[TERRATEC_CINERGY_S2_R3] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R3)},\n\t[TERRATEC_CINERGY_S2_R4] = {USB_DEVICE(USB_VID_TERRATEC, USB_PID_TERRATEC_CINERGY_S2_R4)},\n\t[GOTVIEW_SAT_HD] = {USB_DEVICE(0x1FE1, USB_PID_GOTVIEW_SAT_HD)},\n\t[GENIATECH_T220] = {USB_DEVICE(0x1f4d, 0xD220)},\n\t[TECHNOTREND_S2_4600] = {USB_DEVICE(USB_VID_TECHNOTREND,\n\t\tUSB_PID_TECHNOTREND_CONNECT_S2_4600)},\n\t[TEVII_S482_1] = {USB_DEVICE(0x9022, 0xd483)},\n\t[TEVII_S482_2] = {USB_DEVICE(0x9022, 0xd484)},\n\t[TERRATEC_CINERGY_S2_BOX] = {USB_DEVICE(USB_VID_TERRATEC, 0x0105)},\n\t[TEVII_S662] = {USB_DEVICE(0x9022, USB_PID_TEVII_S662)},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, dw2102_table);\n\nstatic int dw2102_load_firmware(struct usb_device *dev,\n\t\t\tconst struct firmware *frmwr)\n{\n\tu8 *b, *p;\n\tint ret = 0, i;\n\tu8 reset;\n\tu8 reset16[] = {0, 0, 0, 0, 0, 0, 0};\n\tconst struct firmware *fw;\n\n\tswitch (le16_to_cpu(dev->descriptor.idProduct)) {\n\tcase 0x2101:\n\t\tret = request_firmware(&fw, DW2101_FIRMWARE, &dev->dev);\n\t\tif (ret != 0) {\n\t\t\terr(err_str, DW2101_FIRMWARE);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfw = frmwr;\n\t\tbreak;\n\t}\n\tinfo(\"start downloading DW210X firmware\");\n\tp = kmalloc(fw->size, GFP_KERNEL);\n\treset = 1;\n\t/*stop the CPU*/\n\tdw210x_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, DW210X_WRITE_MSG);\n\tdw210x_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, DW210X_WRITE_MSG);\n\n\tif (p != NULL) {\n\t\tmemcpy(p, fw->data, fw->size);\n\t\tfor (i = 0; i < fw->size; i += 0x40) {\n\t\t\tb = (u8 *) p + i;\n\t\t\tif (dw210x_op_rw(dev, 0xa0, i, 0, b , 0x40,\n\t\t\t\t\tDW210X_WRITE_MSG) != 0x40) {\n\t\t\t\terr(\"error while transferring firmware\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* restart the CPU */\n\t\treset = 0;\n\t\tif (ret || dw210x_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,\n\t\t\t\t\tDW210X_WRITE_MSG) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tif (ret || dw210x_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,\n\t\t\t\t\tDW210X_WRITE_MSG) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t/* init registers */\n\t\tswitch (le16_to_cpu(dev->descriptor.idProduct)) {\n\t\tcase USB_PID_TEVII_S650:\n\t\t\tdw2104_properties.rc.core.rc_codes = RC_MAP_TEVII_NEC;\n\t\tcase USB_PID_DW2104:\n\t\t\treset = 1;\n\t\t\tdw210x_op_rw(dev, 0xc4, 0x0000, 0, &reset, 1,\n\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t/* break omitted intentionally */\n\t\tcase USB_PID_DW3101:\n\t\t\treset = 0;\n\t\t\tdw210x_op_rw(dev, 0xbf, 0x0040, 0, &reset, 0,\n\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\tbreak;\n\t\tcase USB_PID_TERRATEC_CINERGY_S:\n\t\tcase USB_PID_DW2102:\n\t\t\tdw210x_op_rw(dev, 0xbf, 0x0040, 0, &reset, 0,\n\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\tdw210x_op_rw(dev, 0xb9, 0x0000, 0, &reset16[0], 2,\n\t\t\t\t\tDW210X_READ_MSG);\n\t\t\t/* check STV0299 frontend  */\n\t\t\tdw210x_op_rw(dev, 0xb5, 0, 0, &reset16[0], 2,\n\t\t\t\t\tDW210X_READ_MSG);\n\t\t\tif ((reset16[0] == 0xa1) || (reset16[0] == 0x80)) {\n\t\t\t\tdw2102_properties.i2c_algo = &dw2102_i2c_algo;\n\t\t\t\tdw2102_properties.adapter->fe[0].tuner_attach = &dw2102_tuner_attach;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* check STV0288 frontend  */\n\t\t\t\treset16[0] = 0xd0;\n\t\t\t\treset16[1] = 1;\n\t\t\t\treset16[2] = 0;\n\t\t\t\tdw210x_op_rw(dev, 0xc2, 0, 0, &reset16[0], 3,\n\t\t\t\t\t\tDW210X_WRITE_MSG);\n\t\t\t\tdw210x_op_rw(dev, 0xc3, 0xd1, 0, &reset16[0], 3,\n\t\t\t\t\t\tDW210X_READ_MSG);\n\t\t\t\tif (reset16[2] == 0x11) {\n\t\t\t\t\tdw2102_properties.i2c_algo = &dw2102_earda_i2c_algo;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tcase 0x2101:\n\t\t\tdw210x_op_rw(dev, 0xbc, 0x0030, 0, &reset16[0], 2,\n\t\t\t\t\tDW210X_READ_MSG);\n\t\t\tdw210x_op_rw(dev, 0xba, 0x0000, 0, &reset16[0], 7,\n\t\t\t\t\tDW210X_READ_MSG);\n\t\t\tdw210x_op_rw(dev, 0xba, 0x0000, 0, &reset16[0], 7,\n\t\t\t\t\tDW210X_READ_MSG);\n\t\t\tdw210x_op_rw(dev, 0xb9, 0x0000, 0, &reset16[0], 2,\n\t\t\t\t\tDW210X_READ_MSG);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(100);\n\t\tkfree(p);\n\t}\n\n\tif (le16_to_cpu(dev->descriptor.idProduct) == 0x2101)\n\t\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic struct dvb_usb_device_properties dw2102_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.firmware = DW2102_FIRMWARE,\n\t.no_reconnect = 1,\n\n\t.i2c_algo = &dw2102_serit_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval = 150,\n\t\t.rc_codes = RC_MAP_DM1105_NEC,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_NEC,\n\t\t.rc_query = dw2102_rc_query,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x81,\n\t/* parameter for the MPEG2-data transfer */\n\t.num_adapters = 1,\n\t.download_firmware = dw2102_load_firmware,\n\t.read_mac_address = dw210x_read_mac_address,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach = dw2102_frontend_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n\t.num_device_descs = 3,\n\t.devices = {\n\t\t{\"DVBWorld DVB-S 2102 USB2.0\",\n\t\t\t{&dw2102_table[CYPRESS_DW2102], NULL},\n\t\t\t{NULL},\n\t\t},\n\t\t{\"DVBWorld DVB-S 2101 USB2.0\",\n\t\t\t{&dw2102_table[CYPRESS_DW2101], NULL},\n\t\t\t{NULL},\n\t\t},\n\t\t{\"TerraTec Cinergy S USB\",\n\t\t\t{&dw2102_table[TERRATEC_CINERGY_S], NULL},\n\t\t\t{NULL},\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties dw2104_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.firmware = DW2104_FIRMWARE,\n\t.no_reconnect = 1,\n\n\t.i2c_algo = &dw2104_i2c_algo,\n\t.rc.core = {\n\t\t.rc_interval = 150,\n\t\t.rc_codes = RC_MAP_DM1105_NEC,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_NEC,\n\t\t.rc_query = dw2102_rc_query,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x81,\n\t/* parameter for the MPEG2-data transfer */\n\t.num_adapters = 1,\n\t.download_firmware = dw2102_load_firmware,\n\t.read_mac_address = dw210x_read_mac_address,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach = dw2104_frontend_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n\t.num_device_descs = 2,\n\t.devices = {\n\t\t{ \"DVBWorld DW2104 USB2.0\",\n\t\t\t{&dw2102_table[CYPRESS_DW2104], NULL},\n\t\t\t{NULL},\n\t\t},\n\t\t{ \"TeVii S650 USB2.0\",\n\t\t\t{&dw2102_table[TEVII_S650], NULL},\n\t\t\t{NULL},\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties dw3101_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.firmware = DW3101_FIRMWARE,\n\t.no_reconnect = 1,\n\n\t.i2c_algo = &dw3101_i2c_algo,\n\t.rc.core = {\n\t\t.rc_interval = 150,\n\t\t.rc_codes = RC_MAP_DM1105_NEC,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_NEC,\n\t\t.rc_query = dw2102_rc_query,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x81,\n\t/* parameter for the MPEG2-data transfer */\n\t.num_adapters = 1,\n\t.download_firmware = dw2102_load_firmware,\n\t.read_mac_address = dw210x_read_mac_address,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach = dw3101_frontend_attach,\n\t\t\t.tuner_attach = dw3101_tuner_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{ \"DVBWorld DVB-C 3101 USB2.0\",\n\t\t\t{&dw2102_table[CYPRESS_DW3101], NULL},\n\t\t\t{NULL},\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties s6x0_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.size_of_priv = sizeof(struct dw2102_state),\n\t.firmware = S630_FIRMWARE,\n\t.no_reconnect = 1,\n\n\t.i2c_algo = &s6x0_i2c_algo,\n\t.rc.core = {\n\t\t.rc_interval = 150,\n\t\t.rc_codes = RC_MAP_TEVII_NEC,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_NEC,\n\t\t.rc_query = dw2102_rc_query,\n\t},\n\n\t.generic_bulk_ctrl_endpoint = 0x81,\n\t.num_adapters = 1,\n\t.download_firmware = dw2102_load_firmware,\n\t.read_mac_address = s6x0_read_mac_address,\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.frontend_attach = zl100313_frontend_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t}},\n\t\t}\n\t},\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{\"TeVii S630 USB\",\n\t\t\t{&dw2102_table[TEVII_S630], NULL},\n\t\t\t{NULL},\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties *p1100;\nstatic struct dvb_usb_device_description d1100 = {\n\t\"Prof 1100 USB \",\n\t{&dw2102_table[PROF_1100], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_properties *s660;\nstatic struct dvb_usb_device_description d660 = {\n\t\"TeVii S660 USB\",\n\t{&dw2102_table[TEVII_S660], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_description d480_1 = {\n\t\"TeVii S480.1 USB\",\n\t{&dw2102_table[TEVII_S480_1], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_description d480_2 = {\n\t\"TeVii S480.2 USB\",\n\t{&dw2102_table[TEVII_S480_2], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_properties *p7500;\nstatic struct dvb_usb_device_description d7500 = {\n\t\"Prof 7500 USB DVB-S2\",\n\t{&dw2102_table[PROF_7500], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_properties *s421;\nstatic struct dvb_usb_device_description d421 = {\n\t\"TeVii S421 PCI\",\n\t{&dw2102_table[TEVII_S421], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_description d632 = {\n\t\"TeVii S632 USB\",\n\t{&dw2102_table[TEVII_S632], NULL},\n\t{NULL},\n};\n\nstatic struct dvb_usb_device_properties su3000_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.size_of_priv = sizeof(struct dw2102_state),\n\t.power_ctrl = su3000_power_ctrl,\n\t.num_adapters = 1,\n\t.identify_state\t= su3000_identify_state,\n\t.i2c_algo = &su3000_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval = 150,\n\t\t.rc_codes = RC_MAP_SU3000,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_RC5,\n\t\t.rc_query = su3000_rc_query,\n\t},\n\n\t.read_mac_address = su3000_read_mac_address,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = su3000_streaming_ctrl,\n\t\t\t.frontend_attach  = su3000_frontend_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}},\n\t\t}\n\t},\n\t.num_device_descs = 6,\n\t.devices = {\n\t\t{ \"SU3000HD DVB-S USB2.0\",\n\t\t\t{ &dw2102_table[GENIATECH_SU3000], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"Terratec Cinergy S2 USB HD\",\n\t\t\t{ &dw2102_table[TERRATEC_CINERGY_S2], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"X3M TV SPC1400HD PCI\",\n\t\t\t{ &dw2102_table[X3M_SPC1400HD], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"Terratec Cinergy S2 USB HD Rev.2\",\n\t\t\t{ &dw2102_table[TERRATEC_CINERGY_S2_R2], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"Terratec Cinergy S2 USB HD Rev.3\",\n\t\t\t{ &dw2102_table[TERRATEC_CINERGY_S2_R3], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"GOTVIEW Satellite HD\",\n\t\t\t{ &dw2102_table[GOTVIEW_SAT_HD], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties t220_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.size_of_priv = sizeof(struct dw2102_state),\n\t.power_ctrl = su3000_power_ctrl,\n\t.num_adapters = 1,\n\t.identify_state\t= su3000_identify_state,\n\t.i2c_algo = &su3000_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval = 150,\n\t\t.rc_codes = RC_MAP_SU3000,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_RC5,\n\t\t.rc_query = su3000_rc_query,\n\t},\n\n\t.read_mac_address = su3000_read_mac_address,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = { {\n\t\t\t.streaming_ctrl   = su3000_streaming_ctrl,\n\t\t\t.frontend_attach  = t220_frontend_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} },\n\t\t}\n\t},\n\t.num_device_descs = 1,\n\t.devices = {\n\t\t{ \"Geniatech T220 DVB-T/T2 USB2.0\",\n\t\t\t{ &dw2102_table[GENIATECH_T220], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t}\n};\n\nstatic struct dvb_usb_device_properties tt_s2_4600_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.size_of_priv = sizeof(struct dw2102_state),\n\t.power_ctrl = su3000_power_ctrl,\n\t.num_adapters = 1,\n\t.identify_state\t= su3000_identify_state,\n\t.i2c_algo = &su3000_i2c_algo,\n\n\t.rc.core = {\n\t\t.rc_interval = 250,\n\t\t.rc_codes = RC_MAP_TT_1500,\n\t\t.module_name = \"dw2102\",\n\t\t.allowed_protos   = RC_BIT_RC5,\n\t\t.rc_query = su3000_rc_query,\n\t},\n\n\t.read_mac_address = su3000_read_mac_address,\n\n\t.generic_bulk_ctrl_endpoint = 0x01,\n\n\t.adapter = {\n\t\t{\n\t\t.num_frontends = 1,\n\t\t.fe = {{\n\t\t\t.streaming_ctrl   = su3000_streaming_ctrl,\n\t\t\t.frontend_attach  = tt_s2_4600_frontend_attach,\n\t\t\t.stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 8,\n\t\t\t\t.endpoint = 0x82,\n\t\t\t\t.u = {\n\t\t\t\t\t.bulk = {\n\t\t\t\t\t\t.buffersize = 4096,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} },\n\t\t}\n\t},\n\t.num_device_descs = 5,\n\t.devices = {\n\t\t{ \"TechnoTrend TT-connect S2-4600\",\n\t\t\t{ &dw2102_table[TECHNOTREND_S2_4600], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"TeVii S482 (tuner 1)\",\n\t\t\t{ &dw2102_table[TEVII_S482_1], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"TeVii S482 (tuner 2)\",\n\t\t\t{ &dw2102_table[TEVII_S482_2], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"Terratec Cinergy S2 USB BOX\",\n\t\t\t{ &dw2102_table[TERRATEC_CINERGY_S2_BOX], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t\t{ \"TeVii S662\",\n\t\t\t{ &dw2102_table[TEVII_S662], NULL },\n\t\t\t{ NULL },\n\t\t},\n\t}\n};\n\nstatic int dw2102_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tp1100 = kmemdup(&s6x0_properties,\n\t\t\tsizeof(struct dvb_usb_device_properties), GFP_KERNEL);\n\tif (!p1100)\n\t\treturn -ENOMEM;\n\t/* copy default structure */\n\t/* fill only different fields */\n\tp1100->firmware = P1100_FIRMWARE;\n\tp1100->devices[0] = d1100;\n\tp1100->rc.core.rc_query = prof_rc_query;\n\tp1100->rc.core.rc_codes = RC_MAP_TBS_NEC;\n\tp1100->adapter->fe[0].frontend_attach = stv0288_frontend_attach;\n\n\ts660 = kmemdup(&s6x0_properties,\n\t\t       sizeof(struct dvb_usb_device_properties), GFP_KERNEL);\n\tif (!s660) {\n\t\tkfree(p1100);\n\t\treturn -ENOMEM;\n\t}\n\ts660->firmware = S660_FIRMWARE;\n\ts660->num_device_descs = 3;\n\ts660->devices[0] = d660;\n\ts660->devices[1] = d480_1;\n\ts660->devices[2] = d480_2;\n\ts660->adapter->fe[0].frontend_attach = ds3000_frontend_attach;\n\n\tp7500 = kmemdup(&s6x0_properties,\n\t\t\tsizeof(struct dvb_usb_device_properties), GFP_KERNEL);\n\tif (!p7500) {\n\t\tkfree(p1100);\n\t\tkfree(s660);\n\t\treturn -ENOMEM;\n\t}\n\tp7500->firmware = P7500_FIRMWARE;\n\tp7500->devices[0] = d7500;\n\tp7500->rc.core.rc_query = prof_rc_query;\n\tp7500->rc.core.rc_codes = RC_MAP_TBS_NEC;\n\tp7500->adapter->fe[0].frontend_attach = prof_7500_frontend_attach;\n\n\n\ts421 = kmemdup(&su3000_properties,\n\t\t       sizeof(struct dvb_usb_device_properties), GFP_KERNEL);\n\tif (!s421) {\n\t\tkfree(p1100);\n\t\tkfree(s660);\n\t\tkfree(p7500);\n\t\treturn -ENOMEM;\n\t}\n\ts421->num_device_descs = 2;\n\ts421->devices[0] = d421;\n\ts421->devices[1] = d632;\n\ts421->adapter->fe[0].frontend_attach = m88rs2000_frontend_attach;\n\n\tif (0 == dvb_usb_device_init(intf, &dw2102_properties,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &dw2104_properties,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &dw3101_properties,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &s6x0_properties,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, p1100,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, s660,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, p7500,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, s421,\n\t\t\tTHIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &su3000_properties,\n\t\t\t THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &t220_properties,\n\t\t\t THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &tt_s2_4600_properties,\n\t\t\t THIS_MODULE, NULL, adapter_nr))\n\t\treturn 0;\n\n\treturn -ENODEV;\n}\n\nstatic void dw2102_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tstruct dw2102_state *st = (struct dw2102_state *)d->priv;\n\tstruct i2c_client *client;\n\n\t/* remove I2C client for tuner */\n\tclient = st->i2c_client_tuner;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\t/* remove I2C client for demodulator */\n\tclient = st->i2c_client_demod;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\tdvb_usb_device_exit(intf);\n}\n\nstatic struct usb_driver dw2102_driver = {\n\t.name = \"dw2102\",\n\t.probe = dw2102_probe,\n\t.disconnect = dw2102_disconnect,\n\t.id_table = dw2102_table,\n};\n\nmodule_usb_driver(dw2102_driver);\n\nMODULE_AUTHOR(\"Igor M. Liplianin (c) liplianin@me.by\");\nMODULE_DESCRIPTION(\"Driver for DVBWorld DVB-S 2101, 2102, DVB-S2 2104, DVB-C 3101 USB2.0, TeVii S421, S480, S482, S600, S630, S632, S650, TeVii S660, S662, Prof 1100, 7500 USB2.0, Geniatech SU3000, T220, TechnoTrend S2-4600, Terratec Cinergy S2 devices\");\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(DW2101_FIRMWARE);\nMODULE_FIRMWARE(DW2102_FIRMWARE);\nMODULE_FIRMWARE(DW2104_FIRMWARE);\nMODULE_FIRMWARE(DW3101_FIRMWARE);\nMODULE_FIRMWARE(S630_FIRMWARE);\nMODULE_FIRMWARE(S660_FIRMWARE);\nMODULE_FIRMWARE(P1100_FIRMWARE);\nMODULE_FIRMWARE(P7500_FIRMWARE);\n"], "filenames": ["drivers/media/usb/dvb-usb/dw2102.c"], "buggy_code_start_loc": [70], "buggy_code_end_loc": [1478], "fixing_code_start_loc": [71], "fixing_code_end_loc": [1525], "type": "CWE-119", "message": "drivers/media/usb/dvb-usb/dw2102.c in the Linux kernel 4.9.x and 4.10.x before 4.10.4 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.", "other": {"cve": {"id": "CVE-2017-8062", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-23T05:59:00.223", "lastModified": "2023-02-14T19:27:57.083", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/media/usb/dvb-usb/dw2102.c in the Linux kernel 4.9.x and 4.10.x before 4.10.4 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."}, {"lang": "es", "value": "drivers/media/usb/dvb-usb/dw2102.c en el kernel de Linux 4.9.x y 4.10.x en versiones anteriores a 4.10.4 interact\u00faa incorrectamente con la opci\u00f3n CONFIG_VMAP_STACK, que permite a usuarios locales provocar una denegaci\u00f3n de servicio (bloqueo del sistema o corrupci\u00f3n de memoria) o posiblemente tiene otro impacto no especificado aprovechando el uso de m\u00e1s de una p\u00e1gina virtual para la lista de dispersi\u00f3n DMA."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.9", "versionEndExcluding": "4.9.16", "matchCriteriaId": "C850AA48-53FC-4E7B-99E3-1059FFBF846B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.10.4", "matchCriteriaId": "06EFB965-C649-4542-8209-E54DD89FFA1A"}]}]}], "references": [{"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.10.4", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/04/16/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}, {"url": "http://www.securityfocus.com/bid/97973", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=606142af57dad981b78707234cfbd15f9f7b7125", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125"}}